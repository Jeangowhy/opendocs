
\part{ðŸ“œ 0: Contents of TeX files}

R6RS è§„èŒƒæŠ¥å‘Šæ–‡æ¡£å…±äº«åœ¨ \url{https://www.r6rs.org/} ç½‘ç«™ä¸Šï¼Œæ–‡æ¡£åˆ†ä¸ºå››ä¸ªéƒ¨åˆ†ï¼š

1. Revised6 Report on the Algorithmic Language Scheme
2. Revised6 Report on the Algorithmic Language Scheme â€” Standard Libraries
3. Revised6 Report on the Algorithmic Language Scheme â€” Non-Normative Appendices
4. Revised6 Report on the Algorithmic Language Scheme â€” Rationale

TeX æ–‡ä»¶ä¸ä»…åŒ…å«ä»¥ä¸Šå››éƒ¨åˆ†å†…å®¹ï¼Œè¿˜åŒ…å«ä¸€ç³»åˆ— TeX å®ç¬¦å·å®šä¹‰æ–‡ä»¶ã€‚

ðŸ“œ File   1: commands.tex}
ðŸ“œ File   2: revision.tex}
ðŸ“œ File   3: status.tex}
ðŸ“œ File   4: semantics-commands.tex}

ðŸ“œ File   5: r6rs.tex}
  ðŸ“œ File   6: intro.tex}
  ðŸ“œ File   7: struct.tex}
  ðŸ“œ File   8: mustard.tex}
  ðŸ“œ File   9: numbers.tex}
  ðŸ“œ File   10: lex.tex}
  ðŸ“œ File   11: basic.tex}
  ðŸ“œ File   12: entry.tex}
  ðŸ“œ File   13: library.tex}
  ðŸ“œ File   14: programs.tex}
  ðŸ“œ File   15: syntax.tex}
  ðŸ“œ File   16: expansion.tex}
  ðŸ“œ File   17: base.tex}
  ðŸ“œ File   18: semantics.tex}
  ðŸ“œ File   19: derived.tex}
  ðŸ“œ File   20: repository.tex}
  ðŸ“œ File   21: example.tex}
  ðŸ“œ File   22: changes}
  ðŸ“œ File   24: rrs.bib}
  ðŸ“œ File   25: abbrevs.bib}
ðŸ“œ File   26: r6rs-lib.tex}
  ðŸ“œ File   27: unicode.tex}
  ðŸ“œ File   28: bytevector.tex}
  ðŸ“œ File   29: list.tex}
  ðŸ“œ File   30: sort.tex}
  ðŸ“œ File   31: control.tex}
  ðŸ“œ File   32: records.tex}
  ðŸ“œ File   33: exc.tex}
  ðŸ“œ File   34: io.tex}
  ðŸ“œ File   35: iocond.tex}
  ðŸ“œ File   36: portio.tex}
  ðŸ“œ File   37: convio.tex}
  ðŸ“œ File   38: programlib.tex}
  ðŸ“œ File   39: arith.tex}
  ðŸ“œ File   40: syntax-case.tex}
  ðŸ“œ File   41: hashtable.tex}
  ðŸ“œ File   42: enum.tex}
  ðŸ“œ File   43: complib.tex}
  ðŸ“œ File   44: eval.tex}
  ðŸ“œ File   45: setcar.tex}
  ðŸ“œ File   46: stringset.tex}
  ðŸ“œ File   47: r5rscompat.tex}
ðŸ“œ File   23: r6rs-app.tex}
ðŸ“œ File   48: r6rs-rationale.tex}


\part{ðŸ“œ File   1: commands.tex}
% % Macros for R^nRS.

% % tex2page.sty mucks with in some manner
% \let\centerlinesaved=\centerline
% \usepackage{tex2page}
% \let\centerline=\centerlinesaved

% \usepackage{xr-hyper}

% \usepackage{makeidx}
% \usepackage{hyperref}

% % \let\htmlonly=\iffalse
% % \let\endhtmlonly=\fi
% % \let\texonly=\iftrue
% % \let\endtexonly=\fi

% \makeatletter

% \texonly
% \newcommand{\topnewpage}{\@topnewpage}
% \endtexonly

% \htmlonly
% \newcommand{\topnewpage}[0][]{#1}
% \endhtmlonly

% \newcommand{\authorsc}[1]{{\scriptsize\scshape #1}}

% % Chapters, sections, etc.

% \newcommand{\extrapart}[1]{
%  % \chapter{#1}
%   \chapter*{#1}
%   \markboth{#1}{#1}
%   \vskip 1ex
%   \addcontentsline{toc}{chapter}{#1}}

% \newcommand{\clearchaptergroupstar}[1]{
%   \texonly
%   \clearpage
%   \addcontentsline{toc}{chaptergroup}{#1}
%   \topnewpage[
%     \centerline{\large\bf\uppercase{#1}}
%     \bigskip]
%     \endtexonly
%   }

% \newcommand{\clearchapterstar}[1]{
%   \clearpage
%   \topnewpage[
%     \centerline{\large\bf\uppercase{#1}}
%     \bigskip]}

% \newcommand{\clearextrapart}[1]{
%   \clearchapterstar{#1}
%   \markboth{#1}{#1}
%   \addcontentsline{toc}{chapter}{#1}}

% \newcommand{\vest}{}
% \newcommand{\dotsfoo}{$\ldots\,$}

% \newcommand{\sharpfoo}[1]{{\tt\##1}}
% \newcommand{\schfalse}{\sharpfoo{f}}
% \newcommand{\schtrue}{\sharpfoo{t}}

% \newcommand{\ampfoo}[1]{{\tt\&#1}}

% \newcommand{\libfoo}[1]{{\tt(#1)}}

% \newcommand{\singlequote}{{\tt'}}  %\char19
% \newcommand{\doublequote}{{\tt"}}
% \newcommand{\backquote}{{\tt\char18}}
% \newcommand{\backwhack}{{\tt\char`\\}}
% \newcommand{\comma}{{\tt\char`\@}}
% \newcommand{\atsign}{{\tt\char`\@}}
% \newcommand{\bang}{{\tt\char`\!}}
% \newcommand{\sharpsign}{{\tt\#}}
% \newcommand{\verticalbar}{{\tt|}}
% \newcommand{\openbracket}{{\tt\char`\[}}
% \newcommand{\closedbracket}{{\tt\char`\]}}
% \newcommand{\ampersand}{{\tt\char`\&}}

% \newcommand{\coerce}{\discretionary{->}{}{->}}

% % Knuth's \in sucks big boulders
% \def\elem{\hbox{\raise.13ex\hbox{$\scriptstyle\in$}}}

% \newcommand{\meta}[1]{{\noindent\hbox{\rm$\langle$#1$\rangle$}}}
% \let\hyper=\meta
% \newcommand{\hyperi}[1]{\hyper{#1$_1$}}
% \newcommand{\hyperii}[1]{\hyper{#1$_2$}}
% \newcommand{\hyperiii}[1]{\hyper{#1$_3$}}
% \newcommand{\hyperiv}[1]{\hyper{#1$_4$}}
% \newcommand{\hyperj}[1]{\hyper{#1$_i$}}
% \newcommand{\hypern}[1]{\hyper{#1$_n$}}
% \texonly
% \newcommand{\var}[1]{\noindent\hbox{\textnormal{\textit{#1}}}}
% \endtexonly
% \htmlonly
% \newcommand{\var}[1]{\textnormal{\textit{#1}}}
% \endhtmlonly
% \newcommand{\vari}[1]{\var{#1$_1$}}
% \newcommand{\varii}[1]{\var{#1$_2$}}
% \newcommand{\variii}[1]{\var{#1$_3$}}
% \newcommand{\variv}[1]{\var{#1$_4$}}
% \newcommand{\varj}[1]{\var{#1$_j$}}
% \newcommand{\vark}[1]{\var{#1$_k$}}
% \newcommand{\varn}[1]{\var{#1$_n$}}

% \newcommand{\vr}[1]{{\noindent\hbox{$#1$\/}}}  % Careful, is \/ always the right thing?
% \newcommand{\vri}[1]{\vr{#1_1}}
% \newcommand{\vrii}[1]{\vr{#1_2}}
% \newcommand{\vriii}[1]{\vr{#1_3}}
% \newcommand{\vriv}[1]{\vr{#1_4}}
% \newcommand{\vrv}[1]{\vr{#1_5}}
% \newcommand{\vrj}[1]{\vr{#1_j}}
% \newcommand{\vrn}[1]{\vr{#1_n}}

% %%R4%% The excessive use of the code font in the numbers section was
% % confusing, somewhat obnoxious, and inconsistent with the rest
% % of the report and with parts of the section itself.  I added
% % a \tupe no-op, and changed most old uses of \type to \tupe,
% % to make it easier to change the fonts back if people object
% % to the change.

% \newcommand{\type}[1]{{\it#1}}
% \newcommand{\tupe}[1]{{#1}}

% \newcommand{\defining}[1]{\mainindex{#1}{\em #1}}
% \newcommand{\ide}[1]{{\schindex{#1}\frenchspacing\tt{#1}}}

% \newcommand{\lambdaexp}{{\cf lambda} expression}

% \newcommand{\callcc}{{\tt call-with-current-continuation}}

% \newcommand{\mainschindex}[1]{\label{#1}\index{#1@\texttt{#1}}}
% \newcommand{\mainindex}[1]{\index{#1}}
% \newcommand{\schindex}[1]{\index{#1@\texttt{#1}}}
% \newcommand{\sharpindex}[1]{\index{#1@\texttt{\#{}#1}}}
% \newcommand{\sharpbangindex}[1]{\index{#1@\texttt{\#!#1}}}
% \newcommand{\ampindex}[1]{\index{#1@\texttt{\&{}#1}}}
% \newcommand{\libindex}[1]{\index{#1@\texttt{(#1)}}}

% \texonly
% \newcommand{\extref}[2]{\ref{#1}}
% \endtexonly
% \htmlonly
% \newcommand{\extref}[2]{on ``#2''}
% \endhtmlonly

% \renewenvironment{theindex}
% {\texonly\clearpage\endtexonly
% \topnewpage[
%     \begin{center}
%       \large\bf\MakeUppercase{\indexheading}
%     \end{center}
%     \vskip 1ex \bigskip]
%     \markboth{Index}{Index}
%     \addcontentsline{toc}{chapter}{\indexheading}
%     \parindent\z@
%     \texonly\parskip\z@ plus .1pt\endtexonly\relax\let\item\@idxitem
%     \indexintro\par\bigskip}
%                {\texonly\clearpage\endtexonly}


% \newcommand{\domain}[1]{#1}
% \newcommand{\nodomain}[1]{}
% %\newcommand{\todo}[1]{{\rm$[\![$!!~#1$]\!]$}}
% \newcommand{\todo}[1]{}

% % \frobq will make quote and backquote look nicer.
% \def\frobqcats{%\catcode`\'=13
% \catcode`\`=13{}}
% {\frobqcats
% \gdef\frobqdefs{%\def'{\singlequote}
% \def`{\backquote}}}
% \def\frobq{\frobqcats\frobqdefs}

% % \cf = code font
% % Unfortunately, \cf \cf won't work at all, so don't even attempt to
% % next constructions which use them...
% \newcommand{\cf}{\frenchspacing\frobq\tt}

% \texonly
% % Same as \obeycr, but doesn't do a \@gobblecr.
% {\catcode`\^^M=13 \gdef\myobeycr{\catcode`\^^M=13 \def^^M{\\}}%
% \gdef\restorecr{\catcode`\^^M=5 }}
% \endtexonly

% {\obeyspaces\gdef {\hbox{\hskip0.5em}}}

% \gdef\gobblecr{\@gobblecr}

% \def\setupcode{\@makeother\^}

% % Scheme example environment
% % At 11 points, one column, these are about 56 characters wide.
% % That's 32 characters to the left of the => and about 20 to the right.

% \newcommand{\exception}[1]{{\cf#1} \textnormal{\textit{exception}}}
% \newenvironment{schemenoindent}{
%   % Commands for scheme examples
%   \newcommand{\ev}{\>\>\evalsto}
%   \newcommand{\xev}{\>\>\hspace*{-1em}\evalsto}
%   \newcommand{\lev}{\\\>\evalsto}
%   \newcommand{\unspecified}{{\em{}unspecified}}
%   \newcommand{\theunspecified}{{\em{}unspecified}}
%   \setupcode
%   \small \cf \obeyspaces \myobeycr
%   \begin{tabbing}%
% \qquad\=\hspace*{5em}\=\hspace*{9em}\=\evalsto~\=\kill%   was 16em
% \gobblecr}{\unskip\end{tabbing}}

% %\newenvironment{scheme}{\begin{schemenoindent}\+\kill}{\end{schemenoindent}}
% \newenvironment{scheme}{
%   % Commands for scheme examples
%   \newcommand{\ev}{\>\>\evalsto}
%   \newcommand{\xev}{\>\>\hspace*{-1em}\evalsto}
%   \newcommand{\lev}{\\\>\evalsto}
%   \renewcommand{\em}{\rmfamily\itshape}
%   \newcommand{\unspecified}{{\em{}unspecified}}
%   \newcommand{\theunspecified}{{\em{}unspecified}}
%   \setupcode
%   \small \cf \obeyspaces \myobeycr
%   \begin{tabbing}%
% \qquad\=\hspace*{5em}\=\hspace*{9em}\=\evalsto~\=\+\kill%   was 16em
% \gobblecr}{\unskip\end{tabbing}}

% \texonly
% \newcommand{\evalsto}{$\Longrightarrow$}
% \endtexonly
%  \htmlonly
% \newcommand{\evalsto}{$\Rightarrow$}
% \endhtmlonly

% % Rationale

% \newenvironment{rationale}{%
% \bgroup\small\noindent{\em Rationale:}\space}{%
% \egroup}

% % Notes

% \newenvironment{note}{%
% \bgroup\small\noindent{\em Note:}\space}{%
% \egroup}

% % Names of library modules

% \newcommand{\library}[1]{{\tt (#1)}}
% \newcommand{\deflibrary}[1]{\library{#1}\libindex{#1}}

% \newcommand{\rsixlibrary}[1]{\library{rnrs #1 (6)}}
% \newcommand{\defrsixlibrary}[1]{\deflibrary{rnrs #1 (6)}}

% \newcommand{\thersixlibrary}{\library{rnrs (6)}}
% \newcommand{\defthersixlibrary}{\deflibrary{rnrs (6)}}

% % Manual entries

% \newenvironment{entry}[1]{
%   \vspace{3.1ex plus .5ex minus .3ex}\noindent#1%
% \unpenalty\nopagebreak}{\vspace{0ex plus 1ex minus 1ex}}

% \newcommand{\exprtype}{syntax}

% \newcommand{\unspecifiedreturn}{unspecified values}
% \newcommand{\isunspecified}{is unspecified}
% \newcommand{\areunspecified}{are unspecified}

% % Primitive prototype
% \newcommand{\pproto}[2]{\unskip%
% \hbox{\cf\spaceskip=0.5em#1}\hfill\penalty 0%
% \hbox{ }\nobreak\hfill\hbox{\rm #2}\break}

% % Parenthesized prototype
% \newcommand{\proto}[3]{\pproto{(\mainschindex{#1}\hbox{#1}{\it#2\/})}{#3}}

% % Variable prototype
% \newcommand{\vproto}[2]{\mainschindex{#1}\pproto{#1}{#2}}

% % Condition-type prototype
%  \newcommand{\ctproto}[1]{\ampindex{#1}\pproto{\ampfoo{#1}}{condition type}}

% % Prototype for literal syntax, no index
% \newcommand{\litprotonoindex}[1]{\pproto{#1}{auxiliary syntax}}

% % Prototype for literal syntax
% \newcommand{\litproto}[1]{\mainschindex{#1}\litprotonoindex{#1}}

% % Prototype for literal syntax at level 1, no index
% \newcommand{\litprotoexpandnoindex}[1]{\pproto{#1}{auxiliary syntax ({\tt expand)}}}

% % Prototype for literal syntax at level 1
% \newcommand{\litprotoexpand}[1]{\mainschindex{#1}\litprotoexpandnoindex{#1}}

% % Extending an existing definition (\proto without the index entry)
% \newcommand{\rproto}[3]{\pproto{(\hbox{#1}{\it#2\/})}{#3}}

% % Extending an existing definition, with index entry
% \newcommand{\irproto}[3]{\schindex{#1}\rproto{#1}{#2}{#3}}

% % Variable prototype
% \newcommand{\rvproto}[2]{\pproto{#1}{#2}}

% % Grammar environment

% \newenvironment{grammar}{
%   \def\:{\goesto{}}
%   \def\|{$\vert$}
%   \cf \myobeycr
%   \begin{tabbing}
%     %\qquad\quad \= 
%     \qquad \= $\vert$ \= \kill
%   }{\unskip\end{tabbing}}

% %\newcommand{\unsection}{\unskip}
% \newcommand{\unsection}{{\vskip -2ex}}

% % Allow line break after hyphen
% \newcommand{\hp}{\linebreak[0]}

% \texonly
% \newcommand{\itspace}{\hspace{1pt}}
% \endtexonly
% \htmlonly
% \newcommand{\itspace}{}
% \endhtmlonly

% % Commands for grammars
% \newcommand{\arbno}[1]{#1\hbox{\rm*}}  
% \newcommand{\atleastone}[1]{#1\hbox{$^+$}}

% \texonly
% \newcommand{\goesto}{$\longrightarrow$}
% \endtexonly
%  \htmlonly
% \newcommand{\goesto}{$\rightarrow$}
% \endhtmlonly

% \newcommand{\syntax}{{\em Syntax: }}
% \newcommand{\semantics}{{\em Semantics: }}
% \newcommand{\implresp}{{\em Implementation responsibilities: }}

% \newcommand{\rrs}[1]{\textit{Revised$^#1$ Report on the Algorithmic Language Scheme}}

% \newcommand{\libindexentry}[1]{#1 (library)}

% \makeatother

% \input{revision}


\part{ðŸ“œ File   2: revision.tex}
% \def\rnrsrevision{6}
% \def\rnrsrevisiondate{26 September 2007}


\part{ðŸ“œ File   3: status.tex}
% We're done.


\part{ðŸ“œ File   4: semantics-commands.tex}
%!TEX root = r6rs.tex

% \usepackage{latexsym}
% \usepackage{mathrsfs}
% \usepackage{stmaryrd}

% \newcounter{subfig}
% \newcommand{\subfigurestart}{\renewcommand{\thefigure}{A.\arabic{figure}\alph{subfig}}\setcounter{subfig}{1}}


% % needed for the second thru the nth figure
% \newcommand{\subfigureadjust}{\addtocounter{figure}{-1}\addtocounter{subfig}{1}}

% \newcommand{\subfigurestop}{\renewcommand{\thefigure}{A.\arabic{figure}}}


% \newcommand{\semanticsindex}[2]{\index{#1@{\texttt{#1} (formal semantics)}}}

% \newcommand{\pltreducks}{PLT Redex}
% \newcommand{\rnrs}{Report}
% \newcommand{\rnrslongspace}{\mbox{Revised\ensuremath{\,^{\mbox{\textrm{\scriptsize 5}}}} Report on Scheme}}
% \newcommand{\rnrslong}{\mbox{Revised\ensuremath{^{\mbox{\textrm{\scriptsize 5}}}} Report on Scheme}}
% \newcommand{\largernrslong}{\mbox{Revised\ensuremath{\,^{\mbox{\textrm{\large 5}}}} Report on Scheme}}

% %\newenvironment*{proof}
% %{\noindent\textbf{Proof} }
% %{$\Box$ \\}

% %\newcommand{\either}{*\!{}\!{}\!\!\circ}
% \newcommand{\either}{*\!\circ}

% \newcommand{\hole}{[~]}
% \newcommand{\holes}{\ensuremath{\hole_{\star}}}
% \newcommand{\holeone}{\ensuremath{\hole_\circ}}
% \newcommand{\holeany}{\ensuremath{\hole_{\either}}}

% %% multi-letter nonterminals (one-letter can be done with $_$)
% \newcommand{\nt}[1]{\textnormal{\textit{#1}}}

% %\newcommand{\sy}[1]{\textnormal{\textbf{#1}}}
% %\newcommand{\va}[1]{\textnormal{\textsf{#1}}}

% \newcommand{\sy}[1]{{\cf #1}}
% \newcommand{\va}[1]{{\cf #1}}


% \newcommand{\beginF}{\ensuremath{\textbf{begin}^{\mbox{\textrm{\textbf{\scriptsize F}}}}}}
% \newcommand{\Eo}{\ensuremath{E^{\circ}}}
% \newcommand{\Estar}{\ensuremath{E^{\star}}}
% \newcommand{\Fo}{\ensuremath{F^{\circ}}}
% \newcommand{\Fstar}{\ensuremath{F^{\star}}}
% \newcommand{\Io}{\ensuremath{I^{\circ}}}
% \newcommand{\Istar}{\ensuremath{I^{\star}}}

% \imgdef\calP{\ensuremath{\mathcal{P}}}
% \imgdef\calS{\ensuremath{\mathcal{S}}}
% \imgdef\calR{\ensuremath{\mathcal{R}}}
% \imgdef\calRv{\ensuremath{\mathcal{R}_v}}
% \imgdef\calA{\ensuremath{\mathcal{A}}}
% \imgdef\scrO{\ensuremath{\mathscr{O}}}

% \newcommand{\semfalse}{\texttt{\#f}}
% \newcommand{\semtrue}{\texttt{\#t}}

% \newcommand{\aline}{\noindent\hrulefill\par}

% %\def\beginfig{\begin{figure*}[t]{\noindent\hrulefill\par}\small}
% %\def\endfig{{\noindent\hrulefill\par}\end{figure*}}

% \def\beginfig{\begin{figure*}[tb!]{\noindent\par}\small}
% \def\endfig{{\noindent\hrulefill\par}\end{figure*}}

% \newcommand{\dom}{\textit{dom}}

% \newcommand{\gopen}{{^{\scriptscriptstyle\lceil}\!\!}}
% \newcommand{\gclose}{\!\!{}^{\scriptscriptstyle\rceil}}

% \newcommand{\mrk}{\diamond}
% \newcommand{\umrk}{^\mrk}

% \newcommand{\rulename}[1]{\textsf{[#1]}}

% \newcommand{\extraspterm}{\\[6pt]}

% \newcommand{\twolinerule}[3]{\twolineruleA{#1}{#2}{\rulename{#3}}{\rightarrow}}
% \newcommand{\twolinescrule}[4]{\twolinescruleA{#1}{#2}{\rulename{#3}}{#4}{\rightarrow}}
% \newcommand{\onelinerule}[3]{\onelineruleA{#1}{#2}{\rulename{#3}}{\rightarrow}}
% \newcommand{\onelinescrule}[4]{\onelinescruleA{#1}{#2}{\rulename{#3}}{#4}{\rightarrow}}

% \newcommand{\twolineruleA}[4]{
% \multicolumn{3}{l}{{#1} {#4}} & {#3}\\ 
% \multicolumn{3}{l}{{#2}} & \extraspterm}

% \newcommand{\twolinescruleA}[5]{
% \multicolumn{3}{l}{{#1} {#5}} & {#3}\\ 
% \multicolumn{4}{l}{{#2 ~ ~ ~ {#4}}} \extraspterm}

% \newcommand{\twolinescruleB}[5]{
% \multicolumn{3}{l}{{#1} {#5}} & {#3}\\ 
% \multicolumn{4}{l}{#2} \\
% \multicolumn{4}{l}{~ ~ ~ #4} \extraspterm}

% \newcommand{\threelinescruleA}[5]{
% \multicolumn{3}{l}{{#1} {#5}} & {#4}\\ 
% \multicolumn{4}{l}{#2} \\
% \multicolumn{4}{l}{#3} \extraspterm}

% \newcommand{\threelinescruleB}[6]{
% \multicolumn{3}{l}{{#1} {#6}} & {#4}\\ 
% \multicolumn{4}{l}{#2} \\
% \multicolumn{4}{l}{#3} \\
% \multicolumn{4}{l}{~ ~ ~ #5} \extraspterm}


% \newcommand{\fourlinescruleB}[7]{
% \multicolumn{3}{l}{{#1} {#7}} & {#5}\\ 
% \multicolumn{4}{l}{#2} \\
% \multicolumn{4}{l}{#3} \\
% \multicolumn{4}{l}{#4} \\
% \multicolumn{4}{l}{~ ~ ~ #6} \extraspterm}


% \newcommand{\onelineruleA}[4]{
% \multicolumn{1}{l}{#1} & {#4} ~ & {#2} & {#3} \extraspterm}

% \newcommand{\onelinescruleA}[5]{
% \multicolumn{1}{l}{#1} & {#5} ~ & {#2} & {#3} \\
% & & {#4} \extraspterm}


\part{ðŸ“œ File   5: r6rs.tex}
\documentclass[twoside,twocolumn]{algol60}
%\documentclass[twoside]{algol60}


\pagestyle{headings}
\showboxdepth=0
\makeindex
\input{commands}
\input{semantics-commands}

\texonly
\externaldocument[lib:]{r6rs-lib}
\endtexonly

\def\headertitle{Revised$^{\rnrsrevision}$ Scheme}
\def\TZPtitle{Revised^\rnrsrevision{} Report on the Algorithmic Language Scheme}

\begin{document}

\thispagestyle{empty}

\topnewpage[{
\begin{center}   {\huge\bf
        Revised{\Huge$^{\mathbf{\htmlonly\tiny\endhtmlonly{}\rnrsrevision}}$} Report on the Algorithmic Language \\
                              \vskip 3pt
                                Scheme}

\vskip 1ex
$$
\begin{tabular}{l@{\extracolsep{.5in}}lll}
\multicolumn{4}{c}{M\authorsc{ICHAEL} S\authorsc{PERBER}}
\\
\multicolumn{4}{c}{R.\ K\authorsc{ENT} D\authorsc{YBVIG},
  M\authorsc{ATTHEW} F\authorsc{LATT},
  A\authorsc{NTON} \authorsc{VAN} S\authorsc{TRAATEN}}
\\
\multicolumn{4}{c}{(\textit{Editors})} \\
\multicolumn{4}{c}{
  R\authorsc{ICHARD} K\authorsc{ELSEY}, W\authorsc{ILLIAM} C\authorsc{LINGER},
  J\authorsc{ONATHAN} R\authorsc{EES}} \\
\multicolumn{4}{c}{(\textit{Editors, Revised\itspace{}$^5$ Report on the
    Algorithmic Language Scheme})} \\
\multicolumn{4}{c}{
  R\authorsc{OBERT} B\authorsc{RUCE} F\authorsc{INDLER}, J\authorsc{ACOB} M\authorsc{ATTHEWS}} \\
\multicolumn{4}{c}{(\textit{Authors, formal semantics})} \\[1ex]
\multicolumn{4}{c}{\bf \rnrsrevisiondate}
\end{tabular}
$$



\end{center}

\chapter*{Summary}
\medskip

{\parskip 1ex
The report gives a defining description of the programming language
Scheme.  Scheme is a statically scoped and properly tail-recursive
dialect of the Lisp programming language invented by Guy Lewis
Steele~Jr.\ and Gerald Jay~Sussman.  It was designed to have an
exceptionally clear and simple semantics and few different ways to
form expressions.  A wide variety of programming paradigms, including
functional, imperative, and message passing styles, find convenient
expression in Scheme.

This report is accompanied by a report describing standard
libraries~\cite{R6RS-libraries}; references to this document are
identified by designations such as ``library section'' or ``library
chapter''.  It is also accompanied by a report containing
non-normative appendices~\cite{R6RS-appendices}.  A fourth report gives
some historical background and rationales for many aspects of the
language and its libraries~\cite{R6RS-rationale}.

\medskip

The individuals listed above are not the sole authors of the text of
the report.  Over the years, the following individuals were involved
in discussions contributing to the design of the Scheme language, and
were listed as authors of prior reports:

Hal Abelson, Norman Adams, David Bartley, Gary Brooks, William
Clinger, R.\ Kent Dybvig, Daniel Friedman, Robert Halstead, Chris
Hanson, Christopher Haynes, Eugene Kohlbecker, Don Oxley, Kent Pitman,
Jonathan Rees, Guillermo Rozas, Guy L.\ Steele Jr., Gerald Jay Sussman, and
Mitchell Wand.

In order to highlight recent contributions, they are not listed as
authors of this version of the report.  However, their contribution
and service is gratefully acknowledged.

\medskip

We intend this report to belong to the entire Scheme community, and so
we grant permission to copy it in whole or in part without fee.  In
particular, we encourage implementors of Scheme to use this report as
a starting point for manuals and other documentation, modifying it as
necessary.
}

\bigskip

\input{status}
}]

\texonly\clearpage\endtexonly

\chapter*{Contents}
\addvspace{3.5pt}                  % don't shrink this gap
\renewcommand{\tocshrink}{-4.0pt}  % value determined experimentally
{
\tableofcontents
}

\vfill
\eject


\input{intro}   \par
\vskip 2ex
\clearchaptergroupstar{Description of the language} %\unskip\vskip -2ex
\input{struct}  \par
\input{mustard} \par
\input{numbers} \par
\input{lex}     \par
\input{basic}   \par
\input{entry} \par
\input{library} \par
\input{programs} \par
\input{syntax} \par
\input{expansion} \par
\input{base}    \par
\clearchaptergroupstar{Appendices}
\appendix
\chapter{Formal semantics}
% \label{formalsemanticschapter}
\input{semantics} \par
\input{derived} \par
\input{repository} \par
\input{example} \par
\input{changes} \par
\newpage
\renewcommand{\bibname}{References}

\bibliographystyle{plain}
\bibliography{abbrevs,rrs}

\vfill\eject


\newcommand{\indexheading}{Alphabetic index of definitions of
  concepts, keywords, and procedures}
\texonly
\newcommand{\indexintro}{The index includes entries from the library
  document; the entries are marked with ``(library)''.}
\endtexonly

\printindex

\end{document}


\part{ðŸ“œ File   6: intro.tex}
\clearextrapart{Introduction}

% \label{historysection}

Programming languages should be designed not by piling feature on top of
feature, but by removing the weaknesses and restrictions that make additional
features appear necessary.  Scheme demonstrates that a very small number
of rules for forming expressions, with no restrictions on how they are
composed, suffice to form a practical and efficient programming language
that is flexible enough to support most of the major programming
paradigms in use today.

Scheme
was one of the first programming languages to incorporate first-class
procedures as in the lambda calculus, thereby proving the usefulness of
static scope rules and block structure in a dynamically typed language.
Scheme was the first major dialect of Lisp to distinguish procedures
from lambda expressions and symbols, to use a single lexical
environment for all variables, and to evaluate the operator position
of a procedure call in the same way as an operand position.  By relying
entirely on procedure calls to express iteration, Scheme emphasized the
fact that tail-recursive procedure calls are essentially gotos that
pass arguments.  Scheme was the first widely used programming language to
embrace first-class escape procedures, from which all previously known
sequential control structures can be synthesized.  A subsequent
version of Scheme introduced the concept of exact and inexact number objects,
an extension of Common Lisp's generic arithmetic.
More recently, Scheme became the first programming language to support
hygienic macros, which permit the syntax of a block-structured language
to be extended in a consistent and reliable manner.

\subsection*{Guiding principles}

To help guide the standardization effort, the editors have adopted a
set of principles, presented below.
Like the Scheme language defined in \rrs{5}~\cite{R5RS}, the language described
in this report is intended to:

\begin{itemize}
\item allow programmers to read each other's code, and allow
  development of portable programs that can be executed in any
  conforming implementation of Scheme;

\item derive its power from simplicity, a small number of generally
  useful core syntactic forms and procedures, and no unnecessary
  restrictions on how they are composed;
  
\item allow programs to define new procedures and new hygienic
  syntactic forms;
  
\item support the representation of program source code as data;
  
\item make procedure calls powerful enough to express any form of
  sequential control, and allow programs to perform non-local control
  operations without the use of global program transformations;
  
\item allow interesting, purely functional programs to run indefinitely
  without terminating or running out of memory on finite-memory
  machines;
  
\item allow educators to use the language to teach programming
  effectively, at various levels and with a variety of pedagogical
  approaches; and

\item allow researchers to use the language to explore the design,
  implementation, and semantics of programming languages.
\end{itemize}

In addition, this report is intended to:

\begin{itemize}
\item allow programmers to create and distribute substantial programs
  and libraries, e.g., implementations of Scheme Requests for
  Implementation, that run without
  modification in a variety of Scheme implementations;
  
\item support procedural, syntactic, and data abstraction more fully
  by allowing programs to define hygiene-bending and hygiene-breaking
  syntactic abstractions and new unique datatypes along with
  procedures and hygienic macros in any scope;
  
\item allow programmers to rely on a level of automatic run-time type
  and bounds checking sufficient to ensure type safety; and

\item allow implementations to generate efficient code, without
  requiring programmers to use implementation-specific operators or
  declarations.
\end{itemize}

While it was possible to write portable programs in Scheme as
described in \rrs{5}, and indeed portable Scheme programs were written
prior to this report, many Scheme programs were not, primarily because
of the lack of substantial standardized libraries and the
proliferation of implementation-specific language additions.

In general, Scheme should include building blocks that allow a wide
variety of libraries to be written, include commonly used user-level
features to enhance portability and readability of library and
application code, and exclude features that are less commonly used and
easily implemented in separate libraries.

The language described in this report is intended to also be backward
compatible with programs written in Scheme as described in \rrs{5} to
the extent possible without compromising the above principles and
future viability of the language.  With respect to future viability,
the editors have operated under the assumption that many more Scheme
programs will be written in the future than exist in the present, so
the future programs are those with which we should be most concerned.

\subsection*{Acknowledgements}

Many people contributed significant help to this revision of the
report.  Specifically, we thank Aziz Ghuloum and Andr\'e van Tonder for
contributing reference implementations of the library system.  We
thank Alan Bawden, John Cowan, Sebastian Egner, Aubrey Jaffer, Shiro
Kawai, Bradley Lucier, and Andr\'e van Tonder for contributing insights on
language design.  Marc Feeley, Martin Gasbichler, Aubrey Jaffer, Lars T Hansen,
Richard Kelsey, Olin Shivers, and Andr\'e van Tonder wrote SRFIs that
served as direct input to the report.  Marcus Crestani, David Frese, 
Aziz Ghuloum, Arthur A.\ Gleckler, Eric Knauel, Jonathan Rees, and Andr\'e
van Tonder thoroughly proofread early versions of the report.

We would also like to thank the following people for their
help in creating this report: Lauri Alanko,
Eli Barzilay, Alan Bawden, Brian C.\ Barnes, Per Bothner, Trent Buck,
Thomas Bushnell, Taylor Campbell, Ludovic Court\`es, Pascal Costanza,
John Cowan, Ray Dillinger, Jed Davis, J.A.\ ``Biep'' Durieux, Carl Eastlund,
Sebastian Egner, Tom Emerson, Marc Feeley, Matthias Felleisen, Andy
Freeman, Ken Friedenbach, Martin Gasbichler, Arthur A.\ Gleckler, Aziz
Ghuloum, Dave Gurnell, Lars T Hansen, Ben Harris, Sven Hartrumpf, Dave
Herman, Nils M.\ Holm, Stanislav Ievlev, James Jackson, Aubrey Jaffer,
Shiro Kawai, Alexander Kjeldaas, Eric Knauel, Michael Lenaghan, Felix Klock,
Donovan Kolbly, Marcin Kowalczyk, Thomas Lord, Bradley Lucier, Paulo
J.\ Matos, Dan Muresan, Ryan Newton, Jason Orendorff, Erich Rast, Jeff
Read, Jonathan Rees, Jorgen Sch\"afer, Paul Schlie, Manuel Serrano,
Olin Shivers, Jonathan Shapiro, Jens Axel S\o{}gaard, Jay Sulzberger,
Pinku Surana, Mikael Tillenius, Sam Tobin-Hochstadt, David Van Horn,
Andr\'e van Tonder, Reinder Verlinde, Alan Watson, Andrew Wilcox, Jon
Wilson, Lynn Winebarger, Keith Wright, and Chongkai Zhu.

We would like to thank the following people for their help in creating
the previous revisions of this report: Alan Bawden, Michael
Blair, George Carrette, Andy Cromarty, Pavel Curtis, Jeff Dalton, Olivier Danvy,
Ken Dickey, Bruce Duba, Marc Feeley,
Andy Freeman, Richard Gabriel, Yekta G\"ursel, Ken Haase, Robert
Hieb, Paul Hudak, Morry Katz, Chris Lindblad, Mark Meyer, Jim Miller, Jim Philbin,
John Ramsdell, Mike Shaff, Jonathan Shapiro, Julie Sussman,
Perry Wagle, Daniel Weise, Henry Wu, and Ozan Yigit.

We thank Carol Fessenden, Daniel
Friedman, and Christopher Haynes for permission to use text from the Scheme 311
version 4 reference manual.  We thank Texas Instruments, Inc.~for permission to
use text from the {\em TI Scheme Language Reference Manual}~\cite{TImanual85}.
We gladly acknowledge the influence of manuals for MIT Scheme~\cite{MITScheme},
T~\cite{Rees84}, Scheme 84~\cite{Scheme84}, Common Lisp~\cite{CLtL},
Chez Scheme~\cite{csug7}, PLT~Scheme~\cite{mzscheme352},
and Algol 60~\cite{Naur63}.

\vest We also thank Betty Dexter for the extreme effort she put into
setting this report in \TeX, and Donald Knuth for designing the program
that caused her troubles.

\vest The Artificial Intelligence Laboratory of the
Massachusetts Institute of Technology, the Computer Science
Department of Indiana University, the Computer and Information
Sciences Department of the University of Oregon, and the NEC Research
Institute supported the preparation of this report.  Support for the MIT
work was provided in part by
the Advanced Research Projects Agency of the Department of Defense under Office
of Naval Research contract N00014-80-C-0505.  Support for the Indiana
University work was provided by NSF grants NCS 83-04567 and NCS
83-03325.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 


\part{ðŸ“œ File   7: struct.tex}
\chapter{Overview of Scheme}
% \label{semanticchapter}

This chapter gives an overview of Scheme's semantics.
The purpose of this overview is to explain
enough about the basic concepts of the language to facilitate
understanding of the subsequent chapters of the report, which are
organized as a reference manual.  Consequently, this overview is
not a complete introduction to the language, nor is it precise
in all respects or normative in any way.

\vest Following Algol, Scheme is a statically scoped programming
language.  Each use of a variable is associated with a lexically
apparent binding of that variable.

\vest Scheme has latent as opposed to manifest types
\cite{WaiteGoos}.  Types
are associated with objects\mainindex{object} (also called values) rather than
with variables.  (Some authors refer to languages with latent types as
untyped, weakly typed or dynamically typed languages.)  Other languages with
latent types are Python, Ruby, Smalltalk, and other dialects of Lisp.  Languages
with manifest types (sometimes referred to as strongly typed or
statically typed languages) include Algol 60, C, C\#, Java, Haskell, and ML.

\vest All objects created in the course of a Scheme computation, including
procedures and continuations, have unlimited extent.
No Scheme object is ever destroyed.  The reason that
implementations of Scheme do not (usually!)\ run out of storage is that
they are permitted to reclaim the storage occupied by an object if
they can prove that the object cannot possibly matter to any future
computation.  Other languages in which most objects have unlimited
extent include C\#, Java, Haskell, most Lisp dialects, ML, Python,
Ruby, and Smalltalk.

Implementations of Scheme must be properly tail-recursive.
This allows the execution of an iterative computation in constant space,
even if the iterative computation is described by a syntactically
recursive procedure.  Thus with a properly tail-recursive implementation,
iteration can be expressed using the ordinary procedure-call
mechanics, so that special iteration constructs are useful only as
syntactic sugar.

\vest Scheme was one of the first languages to support procedures as
objects in their own right.  Procedures can be created dynamically,
stored in data structures, returned as results of procedures, and so
on.  Other languages with these properties include Common Lisp,
Haskell, ML, Ruby, and Smalltalk.

\vest One distinguishing feature of Scheme is that continuations, which
in most other languages only operate behind the scenes, also have
``first-class'' status.  First-class continuations are useful for implementing a
wide variety of advanced control constructs, including non-local exits,
backtracking, and coroutines.

In Scheme, the argument expressions of a procedure call are evaluated
before the procedure gains control, whether the procedure needs the
result of the evaluation or not.  C, C\#, Common Lisp, Python,
Ruby, and Smalltalk are other languages that always evaluate argument
expressions before invoking a procedure.  This is distinct from the
lazy-evaluation semantics of Haskell, or the call-by-name semantics of
Algol 60, where an argument expression is not evaluated unless its
value is needed by the procedure.

Scheme's model of arithmetic provides a rich set of numerical types
and operations on them.  Furthermore, it distinguishes \textit{exact}
and \textit{inexact} number objects: Essentially, an exact number
object corresponds to a number exactly, and an inexact number object
is the result of a computation that involved rounding or other errors.

\section{Basic types}

Scheme programs manipulate \textit{objects}, which are also referred
to as \textit{values}.
Scheme objects are organized into sets of values called \textit{types}.
This section gives an overview of the fundamentally important types of the
Scheme language.  More types are described in later chapters.

\begin{note}
  As Scheme is latently typed, the use of the term \textit{type} in
  this report differs from the use of the term in the context of other
  languages, particularly those with manifest typing.
\end{note}

\paragraph{Booleans}

\mainindex{boolean}A boolean is a truth value, and can be either
true or false.  In Scheme, the object for ``false'' is written
\schfalse{}.  The object for ``true'' is written \schtrue{}.  In
most places where a truth value is expected, however, any object different from
\schfalse{} counts as true.

\paragraph{Numbers}

\mainindex{number}Scheme supports a rich variety of numerical data types, including
objects representing integers of arbitrary precision, rational numbers, complex numbers, and
inexact numbers of various kinds.  Chapter~\ref{numbertypeschapter} gives an
overview of the structure of Scheme's numerical tower.

\paragraph{Characters}

\mainindex{character}Scheme characters mostly correspond to textual characters.
More precisely, they are isomorphic to the \textit{scalar values} of
the Unicode standard.

\paragraph{Strings}

\mainindex{string}Strings are finite sequences of characters with fixed length and thus
represent arbitrary Unicode texts.

\paragraph{Symbols}

\mainindex{symbol}A symbol is an object representing a string,
the symbol's \textit{name}.
Unlike strings, two symbols whose names are spelled the same
way are never distinguishable.  Symbols are useful for many applications;
for instance, they may be used the way enumerated values are used in
other languages.

\paragraph{Pairs and lists}

\mainindex{pair}\mainindex{list}
A pair is a data structure with two components.  The most common use
of pairs is to represent (singly linked) lists, where the first
component (the ``car'') represents the first element of the list, and
the second component (the ``cdr'') the rest of the list.  Scheme also
has a distinguished empty list, which is the last cdr in a chain of
pairs that form a list.

\paragraph{Vectors}

\mainindex{vector}Vectors, like lists, are linear data structures
representing finite sequences of arbitrary objects.
Whereas the elements of a list are accessed
sequentially through the chain of pairs representing it,
the elements of a vector are addressed by integer indices.
Thus, vectors are more appropriate than
lists for random access to elements.

\paragraph{Procedures}

\mainindex{procedure}Procedures are values in Scheme.

\section{Expressions}

The most important elements of Scheme code are
\mainindex{expression}\textit{expressions}.  Expressions can be
\textit{evaluated}, producing a \textit{value}.  (Actually, any number
of values---see section~\ref{multiplereturnvaluessection}.)  The most
fundamental expressions are literal expressions:

\begin{scheme}
\schtrue{} \ev \schtrue
23 \ev 23%
\end{scheme}

This notation means that the expression \schtrue{} evaluates to
\schtrue{}, that is, the value for ``true'',  and that the expression
{\cf 23} evaluates to a number object representing the number 23.

Compound expressions are formed by placing parentheses around their
subexpressions.  The first subexpression identifies an operation; the
remaining subexpressions are operands to the operation:
%
\begin{scheme}
(+ 23 42) \ev 65
(+ 14 (* 23 42)) \ev 980%
\end{scheme}
%
In the first of these examples, {\cf +} is the name of
the built-in operation for addition, and {\cf 23} and {\cf 42} are the
operands.  The expression {\cf (+ 23 42)} reads as ``the sum of 23 and
42''.  Compound expressions can be nested---the second example reads
as ``the sum of 14 and the product of 23 and 42''.

As these examples indicate, compound expressions in Scheme are always
written using the same prefix notation\mainindex{prefix notation}.  As
a consequence, the parentheses are needed to indicate structure.
Consequently, ``superfluous'' parentheses, which are often permissible in
mathematical notation and also in many programming languages, are not
allowed in Scheme.

As in many other languages, whitespace (including line endings) is not
significant when it separates subexpressions of an expression, and
can be used to indicate structure.

\section{Variables and binding}

\mainindex{variable}\mainindex{binding}\mainindex{identifier}Scheme
allows identifiers to stand for locations containing values.
These identifiers are called variables.  In many cases, specifically
when the location's value is never modified after its creation, it is
useful to think of the variable as standing for the value directly.

\begin{scheme}
(let ((x 23)
      (y 42))
  (+ x y)) \ev 65%
\end{scheme}

In this case, the expression starting with {\cf let} is a binding
construct.  The parenthesized structure following the {\cf let} lists
variables alongside expressions: the variable {\cf x} alongside {\cf
  23}, and the variable {\cf y} alongside {\cf 42}.  The {\cf let}
expression binds {\cf x} to 23, and {\cf y} to 42.  These bindings are
available in the \textit{body} of the {\cf let} expression, {\cf (+ x
  y)}, and only there.

\section{Definitions}

\index{definition}The variables bound by a {\cf let} expression
are \textit{local}, because their bindings are visible only in the
{\cf let}'s body.  Scheme also allows creating top-level bindings for
identifiers as follows:

\begin{scheme}
(define x 23)
(define y 42)
(+ x y) \ev 65%
\end{scheme}

(These are actually ``top-level'' in the body of a top-level program or library;
see section~\ref{librariesintrosection} below.)

The first two parenthesized structures are \textit{definitions}; they
create top-level bindings, binding {\cf x} to 23 and {\cf y} to 42.
Definitions are not expressions, and cannot appear in all places
where an expression can occur.  Moreover, a definition has no value.

Bindings follow the lexical structure of the program:  When several
bindings with the same name exist, a variable refers to the binding
that is closest to it, starting with its occurrence in the program
and going from inside to outside, and referring to a top-level
binding if no
local binding can be found along the way:

\begin{scheme}
(define x 23)
(define y 42)
(let ((y 43))
  (+ x y)) \ev 66

(let ((y 43))
  (let ((y 44))
    (+ x y))) \ev 67%
\end{scheme}

\section{Forms}

While definitions are not expressions, compound expressions and
definitions exhibit similar syntactic structure:
%
\begin{scheme}
(define x 23)
(* x 2)%
\end{scheme}
%
While the first line contains a definition, and the second an
expression, this distinction depends on the bindings for {\cf define}
and {\cf *}.  At the purely syntactical level, both are
\textit{forms}\index{form}, and \textit{form} is the general name for
a syntactic part of a Scheme program.  In particular, {\cf 23} is a
\textit{subform}\index{subform} of the form {\cf (define x 23)}.

\section{Procedures}
% \label{proceduressection}

\index{procedure}Definitions can also be used to define
procedures:

\begin{scheme}
(define (f x)
  (+ x 42))

(f 23) \ev 65%
\end{scheme}

A procedure is, slightly simplified, an abstraction of an
expression over objects.  In the example, the first definition defines a procedure
called {\cf f}.  (Note the parentheses around {\cf f x}, which
indicate that this is a procedure definition.)  The expression {\cf (f
  23)} is a \index{procedure call}procedure call, meaning,
roughly, ``evaluate {\cf (+ x 42)} (the body of the procedure) with
{\cf x} bound to 23''.

As procedures are objects, they can be passed to other
procedures:
%
\begin{scheme}
(define (f x)
  (+ x 42))

(define (g p x)
  (p x))

(g f 23) \ev 65%
\end{scheme}

In this example, the body of {\cf g} is evaluated with {\cf p}
bound to {\cf f} and {\cf x} bound to 23, which is equivalent
to {\cf (f 23)}, which evaluates to 65.

In fact, many predefined operations of Scheme are provided not by
syntax, but by variables whose values are procedures.
The {\cf +} operation, for example, which receives
special syntactic treatment in many other languages, is just a regular
identifier in Scheme, bound to a procedure that adds number objects.  The
same holds for {\cf *} and many others:

\begin{scheme}
(define (h op x y)
  (op x y))

(h + 23 42) \ev 65
(h * 23 42) \ev 966%
\end{scheme}

Procedure definitions are not the only way to create procedures.  A
{\cf lambda} expression creates a new procedure as an object, with no
need to specify a name:

\begin{scheme}
((lambda (x) (+ x 42)) 23) \ev 65%
\end{scheme}

The entire expression in this example is a procedure call; {\cf
  (lambda (x) (+ x 42))}, evaluates to a procedure that takes a single
number object and adds 42 to it.

\section{Procedure calls and syntactic keywords}

Whereas {\cf (+ 23 42)}, {\cf (f 23)}, and {\cf ((lambda (x) (+ x 42))
  23)} are all examples of procedure calls, {\cf lambda} and {\cf
  let} expressions are not.  This is because {\cf let}, even though
it is an identifier, is not a variable, but is instead a \textit{syntactic
  keyword}\index{syntactic keyword}.  A form that has a
syntactic keyword as its first subexpression obeys special rules determined by
the keyword.  The {\cf define} identifier in a definition is also a
syntactic keyword.  Hence, definitions are also not procedure calls.

The rules for the {\cf lambda} keyword specify that the first
subform is a list of parameters, and the remaining subforms are the body of
the procedure.  In {\cf let} expressions, the first subform is a list
of binding specifications, and the remaining subforms constitute a body of
expressions.

Procedure calls can generally be distinguished from these
\textit{special forms}\mainindex{special form} by
looking for a syntactic keyword in the first position of an
form: if the first position does not contain a syntactic keyword, the expression
is a procedure call.  
(So-called \textit{identifier macros} allow creating other kinds of
special forms, but are comparatively rare.)
The set of syntactic keywords of Scheme is
fairly small, which usually makes this task fairly simple.
It is possible, however, to create new bindings for syntactic keywords; see
section~\ref{macrosintrosection} below.

\section{Assignment}

Scheme variables bound by definitions or {\cf let} or {\cf lambda}
expressions are not actually bound directly to the objects specified in the
respective bindings, but to locations containing these objects.  The
contents of these locations can subsequently be modified destructively
via \textit{assignment}\index{assignment}:
%
\begin{scheme}
(let ((x 23))
  (set! x 42)
  x) \ev 42%
\end{scheme}

In this case, the body of the {\cf let} expression consists of two
expressions which are evaluated sequentially, with the value of the
final expression becoming the value of the entire {\cf let}
expression.  The expression {\cf (set! x 42)} is an assignment, saying
``replace the object in the location referenced by {\cf x} with 42''.
Thus, the previous value of {\cf x}, 23, is replaced by 42.

\section{Derived forms and macros}
% \label{macrosintrosection}

Many of the special forms specified in this report
can be translated into more basic special forms.
For example, a {\cf let} expression can be translated
into a procedure call and a {\cf lambda} expression.  The following two
expressions are equivalent:
%
\begin{scheme}
(let ((x 23)
      (y 42))
  (+ x y)) \ev 65

((lambda (x y) (+ x y)) 23 42) \lev 65%
\end{scheme}

Special forms like {\cf let} expressions are called \textit{derived
  forms}\index{derived form} because their semantics can be
derived from that of other kinds of forms by a syntactic
transformation.  Some procedure definitions are also derived forms.  The
following two definitions are equivalent:

\begin{scheme}
(define (f x)
  (+ x 42))

(define f
  (lambda (x)
    (+ x 42)))%
\end{scheme}

In Scheme, it is possible for a program to create its own derived
forms by binding syntactic keywords to macros\index{macro}:

\begin{scheme}
(define-syntax def
  (syntax-rules ()
    ((def f (p ...) body)
     (define (f p ...)
       body))))

(def f (x)
  (+ x 42))%
\end{scheme}

The {\cf define-syntax} construct specifies that a parenthesized
structure matching the pattern {\cf (def f (p ...) body)}, where {\cf
  f}, {\cf p}, and {\cf body} are pattern variables, is translated to
{\cf (define (f p ...) body)}.  Thus, the {\cf def} form appearing in
the example gets translated to:

\begin{scheme}
(define (f x)
  (+ x 42))%
\end{scheme}

The ability to create new syntactic keywords makes Scheme extremely
flexible and expressive, allowing many of the features
built into other languages to be derived forms in Scheme.

\section{Syntactic data and datum values}

A subset of the Scheme objects is called \textit{datum
  values}\index{datum value}. 
These include booleans, number objects, characters, symbols,
and strings as well as lists and vectors whose elements are data.  Each
datum value may be represented in textual form as a
\textit{syntactic datum}\index{syntactic datum}, which can be written out
and read back in without loss of information.
A datum value may be represented by several different syntactic data.
Moreover, each datum value
can be trivially translated to a literal expression in a program by
prepending a {\cf\singlequote} to a corresponding syntactic datum:

\begin{scheme}
'23 \ev 23
'\schtrue{} \ev \schtrue{}
'foo \ev foo
'(1 2 3) \ev (1 2 3)
'\#(1 2 3) \ev \#(1 2 3)%
\end{scheme}

The {\cf\singlequote} shown in the previous examples
is not needed for representations of number objects or booleans.
The syntactic datum {\cf foo} represents a
symbol with name ``foo'', and {\cf 'foo} is a literal expression with
that symbol as its value.  {\cf (1 2 3)} is a syntactic datum that 
represents a list with elements 1, 2, and 3, and {\cf '(1 2 3)} is a literal
expression with this list as its value.  Likewise, {\cf \#(1 2 3)}
is a syntactic datum that represents a vector with elements 1, 2 and 3, and
{\cf '\#(1 2 3)} is the corresponding literal.

The syntactic data are a superset of the Scheme forms.  Thus, data
can be used to represent Scheme forms as data objects.  In
particular, symbols can be used to represent identifiers.

\begin{scheme}
'(+ 23 42) \ev (+ 23 42)
'(define (f x) (+ x 42)) \lev (define (f x) (+ x 42))%
\end{scheme}

This facilitates writing programs that operate on Scheme source code,
in particular interpreters and program transformers.

\section{Continuations}

Whenever a Scheme expression is evaluated there is a
\textit{continuation}\index{continuation} wanting the result of the
expression.  The continuation represents an entire (default) future
for the computation.  For example, informally the continuation of {\cf 3}
in the expression
%
\begin{scheme}
(+ 1 3)%
\end{scheme}
%
adds 1 to it.  Normally these ubiquitous continuations are hidden
behind the scenes and programmers do not think much about them.  On
rare occasions, however, a programmer may need to deal with
continuations explicitly.  The {\cf call-with-current-continuation}
procedure (see section~\ref{call-with-current-continuation}) allows
Scheme programmers to do that by creating a procedure that reinstates
the current continuation.  The {\cf call-with-current-continuation}
procedure accepts a procedure, calls it immediately with an argument
that is an \textit{escape procedure}\index{escape procedure}.  This
escape procedure can then be called with an argument that becomes the
result of the call to {\cf call-with-current-continuation}.  That is,
the escape procedure abandons its own continuation, and reinstates the
continuation of the call to {\cf call-with-current-continuation}.

In the following example, an escape procedure representing the
continuation that adds 1 to its argument is bound to {\cf escape}, and
then called with 3 as an argument.  The continuation of the call to
{\cf escape} is abandoned, and instead the 3 is passed to the
continuation that adds 1:
%
\begin{scheme}
(+ 1 (call-with-current-continuation
       (lambda (escape)
         (+ 2 (escape 3))))) \lev 4%
\end{scheme}
%
An escape procedure has unlimited extent: It can be called after the
continuation it captured has been invoked, and it can be called
multiple times.  This makes {\cf call-with-current-continuation}
significantly more powerful than typical non-local control constructs
such as exceptions in other languages.

\section{Libraries}
% \label{librariesintrosection}

Scheme code can be organized in components called
\textit{libraries}\index{library}.  Each library contains 
definitions and expressions.  It can import definitions
from other libraries and export definitions to other libraries.

The following library called {\cf (hello)} exports a definition called
{\cf hello-world},  and imports the base library (see
chapter~\ref{baselibrarychapter}) and the simple I/O library (see
library section~\extref{lib:simpleiosection}{Simple I/O}).  The {\cf
  hello-world} export is a procedure that displays {\cf Hello World}
on a separate line:
%
\begin{scheme}
(library (hello)
  (export hello-world)
  (import (rnrs base)
          (rnrs io simple))
  (define (hello-world)
    (display "Hello World")
    (newline)))%
\end{scheme}

\section{Top-level programs}

A Scheme program is invoked via a \textit{top-level
  program}\index{top-level program}.  Like a library, a top-level
program contains imports, definitions and expressions, and specifies
an entry point for execution.  Thus a top-level program defines, via
the transitive closure of the libraries it imports, a Scheme program.

The following top-level program obtains the first argument from the command line
via the {\cf command-line} procedure from the \rsixlibrary{programs}
library (see library chapter~\extref{lib:programlibchapter}{Command-line
  access and exit values}).  It then opens the file using {\cf
  open-file-input-port} (see library section~\extref{lib:portsiosection}),
yielding a \textit{port}, i.e.\ a connection to the file as a data
source, and calls the {\cf get-bytes-all} procedure to obtain the
contents of the file as binary data.  It then uses {\cf put-bytes} to
output the contents of the file to standard output:
%
\begin{scheme}
\#!r6rs
(import (rnrs base)
        (rnrs io ports)
        (rnrs programs))
(put-bytes (standard-output-port)
           (call-with-port
               (open-file-input-port
                 (cadr (command-line)))
             get-bytes-all))%
\end{scheme}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 


\part{ðŸ“œ File   8: mustard.tex}
\chapter{Requirement levels} 
% \label{requirementchapter}

The key words ``must'', ``must not'', ``should'',
``should not'', ``recommended'', ``may'', and ``optional'' in this
report are to be interpreted as described in RFC~2119~\cite{mustard}.
Specifically:

\begin{description}
\item[must]\mainindex{must} This word means that a statement is an absolute
  requirement of the specification.
\item[must not]\mainindex{must not} This phrase means that a statement is an absolute
  prohibition of the specification.
\item[should]\mainindex{should} This word, or the adjective ``recommended'', means that
  valid reasons may exist in particular circumstances to ignore a
  statement, but that the implications must be understood and weighed
  before choosing a different course.
\item[should not]\mainindex{should not} This phrase, or the phrase ``not recommended'', means
  that valid reasons may exist in particular circumstances when the
  behavior of a statement is acceptable, but that the implications
  should be understood and weighed before choosing the course described
  by the statement.
\item[may]\mainindex{may} This word, or the adjective ``optional'', means that an item
  is truly optional.
\end{description}

In particular, this report occasionally uses ``should'' to designate
circumstances that are outside the specification of this report, but
cannot be practically detected by an implementation; see
section~\ref{argumentcheckingsection}.  In such circumstances, a
particular implementation may allow the programmer to ignore the
recommendation of the report and even exhibit reasonable behavior.
However, as the report does not specify the behavior,
these programs may be unportable, that is, their execution might
produce different results on different implementations.

Moreover, this report occasionally uses the phrase ``not required'' to note the
absence of an absolute requirement.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 


\part{ðŸ“œ File   9: numbers.tex}
\chapter{Numbers}
% \label{numbertypeschapter}
\mainindex{number}

This chapter describes Scheme's model for numbers.  It is important to
distinguish between the mathematical numbers, the Scheme objects that
attempt to model them, the machine representations used to implement
the numbers, and notations used to write numbers.  In this report, the
term \textit{number} refers to a mathematical number, and the term
\textit{number object} refers to a Scheme object representing a
number.  This report uses the types \type{complex}, \type{real},
\type{rational}, and \type{integer} to refer to both mathematical
numbers and number objects.  The \type{fixnum} and \type{flonum} types
refer to special subsets of the number objects, as determined by
common machine representations, as explained below.

\section{Numerical tower}
% \label{numericaltypes}
\index{numerical types}

Numbers may be arranged into a tower of subsets in which each level
is a subset of the level above it:
\begin{tabbing}
\ \ \ \ \ \ \ \ \ \=\tupe{number} \\
\> \tupe{complex} \\
\> \tupe{real} \\
\> \tupe{rational} \\
\> \tupe{integer} 
\end{tabbing}

For example, 5 is an integer.  Therefore 5 is also a rational,
a real, and a complex.  The same is true of the number objects
that model 5.  

Number objects are organized as a corresponding tower of subtypes
defined by the predicates {\cf number?}, {\cf complex?}, {\cf real?},
{\cf rational?}, and {\cf integer?}; see section~\ref{number?}.
Integer number objects are also called \textit{integer
  objects}\mainindex{integer object}.

There is no simple relationship between the subset that contains a
number and its representation inside a computer.  For example, the
integer 5 may have several representations.  Scheme's numerical
operations treat number objects as abstract data, as independent of
their representation as possible.  Although an implementation of
Scheme may use many different representations for numbers, this should
not be apparent to a casual programmer writing simple programs.

\section{Exactness}
% \label{exactly}

\mainindex{exactness}It is useful to distinguish between number objects
that are known to correspond to a number exactly, and those number
objects whose computation involved rounding or other errors.  For
example, index operations into data structures may need to know the index
exactly, as may some operations on polynomial coefficients in a symbolic algebra
system.  On the other hand, the results of measurements are inherently
inexact, and irrational numbers may be approximated by rational and
therefore inexact approximations.  In order to catch uses of numbers
known only inexactly where exact numbers are required, Scheme
explicitly distinguishes \defining{exact} from \defining{inexact} number objects.  This
distinction is orthogonal to the dimension of type.

A
number object is exact if it is the value of an exact numerical
literal or was derived from exact number objects using only exact
operations.  Exact number objects correspond to mathematical numbers
in the obvious way.

Conversely, a number object is inexact if it is the value of an
inexact numerical literal, or was derived from inexact number objects,
or was derived using inexact operations.  Thus inexactness is
contagious.

Exact arithmetic is reliable in the following sense: If exact number
objects are passed to any of the arithmetic procedures described in
section~\ref{propagationsection}, and an exact number object is
returned, then the result is mathematically correct.  This is
generally not true of computations involving inexact number objects
because approximate methods such as floating-point arithmetic may be
used, but it is the duty of each implementation to make the result as
close as practical to the mathematically ideal result.

\section{Fixnums and flonums}

A \defining{fixnum} is an exact integer object that lies
within a certain implementation-dependent subrange of the
exact integer objects. (Library section \extref{lib:fixnumssection}{Fixnums} describes a
library for computing with fixnums.)
Likewise, every implementation must
designate a subset of its inexact real number objects as \defining{flonum}s, and
to convert certain external representations into flonums.  
(Library section \extref{lib:flonumssection}{Flonums} describes a library for
computing with flonums.)  Note that
this does not imply that an implementation must use
floating-point representations.

\section{Implementation requirements}

\index{implementation restriction}\label{restrictions}

Implementations of Scheme must support number objects for
the entire tower of subtypes given in section~\ref{numericaltypes}.
Moreover, implementations must support exact integer 
objects and exact rational number objects of practically unlimited
size and precision, and to implement certain procedures (listed in
\ref{propagationsection}) so they always return exact results when
given exact arguments.  (``Practically unlimited'' means that the size
and precision of these numbers should only be limited by the size of
the available memory.)

Implementations may support only a limited range of inexact number
objects of any type, subject to the requirements of this section.  For
example, an implementation may limit the range of the inexact real
number objects (and therefore the range of inexact integer and
rational number objects) to the dynamic range of the flonum format.
Furthermore the gaps between the inexact integer objects and
rationals are likely to be very large in such an implementation as the
limits of this range are approached.

An implementation may use floating point and other approximate 
representation strategies for \tupe{inexact} numbers.
This report recommends, but does not require, that the IEEE 
floating-point standards be followed by implementations that use
floating-point representations, and that implementations using
other representations should match or exceed the precision achievable
using these floating-point standards~\cite{IEEE}.

In particular, implementations that use floating-point representations
must follow these rules: A floating-point result must be represented
with at least as much precision as is used to express any of the
inexact arguments to that operation.
Potentially inexact operations such as {\cf sqrt}, when
applied to exact arguments, should produce exact answers whenever possible
(for example the square root of an exact 4 ought to be an exact 2).
However, this is not required.
If, on the other hand, an exact number object is operated upon so as to produce an
inexact result (as by {\cf sqrt}), and if the result is represented in
floating point, then the most precise floating-point format available
must be used; but if the result is represented in some other way then
the representation must have at least as much precision as the most
precise floating-point format available.

It is the programmer's responsibility to avoid using inexact number
objects with magnitude or significand too large to be represented in
the implementation.

\section{Infinities and NaNs}

Some Scheme implementations, specifically those that follow the IEEE
floating-point standards, distinguish special number objects called
\mainindex{infinity}\defining{positive infinity}, \defining{negative
  infinity}, and \defining{NaN}.

Positive infinity is regarded as an inexact real (but not rational) number
object that represents an indeterminate number greater than the
numbers represented by all rational number objects.  Negative infinity
is regarded as an inexact real (but not rational) number object that represents
an indeterminate number less than the numbers represented by all
rational numbers.

A NaN is regarded as an inexact real (but not rational) number object so
indeterminate that it might represent any real number, including
positive or negative infinity, and might even be greater than positive
infinity or less than negative infinity.

\section{Distinguished -0.0}

\index{-0.0}
Some Scheme implementations, specifically those that follow the IEEE
floating-point standards, distinguish between number objects for $0.0$
and $-0.0$, i.e., positive and negative inexact zero.  This report
will sometimes specify the behavior of certain arithmetic operations
on these number objects.  These specifications are marked with ``if
$-0.0$ is distinguished'' or ``implementations that distinguish
$-0.0$''.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 


\part{ðŸ“œ File   10: lex.tex}
% Lexical structure
\hyphenation{white-space}
%%\vfill\eject
\chapter{Lexical syntax and datum syntax}
% \label{readsyntaxchapter}

The syntax of Scheme code is organized in three levels:
%
\begin{enumerate}
\item the \textit{lexical syntax} that describes how a program text is split
  into a sequence of lexemes,
\item the \textit{datum syntax}, formulated in terms of the lexical
  syntax, that structures the lexeme sequence as a sequence of
  \textit{syntactic data\mainindex{datum}\mainindex{syntactic
      datum}}, where a syntactic datum is
    a recursively structured entity,
\item the \textit{program syntax} formulated in terms of the read
  syntax, imposing further structure and assigning meaning to
  syntactic data.
\end{enumerate}
%
Syntactic data (also called \textit{external
  representations\index{external representation}}) double
as a notation for objects, and Scheme's \rsixlibrary{io ports} library
(library section~\extref{lib:portsiosection}{Port I/O})
provides the {\cf get-datum} and {\cf put-datum} procedures
for reading and writing syntactic data, converting between their
textual representation and the corresponding objects. 
Each syntactic datum represents a corresponding \defining{datum value}.
A syntactic datum can be used in a program to obtain the corresponding
datum value using {\cf quote} (see section~\ref{quote}).

Scheme source code consists of syntactic data and (non-significant) comments.
Syntactic data in Scheme source code are called
\textit{forms}\mainindex{form}.
(A form nested inside another form is
called a \defining{subform}.)
Consequently, Scheme's syntax has the property that any sequence of
characters that is a form is also a syntactic datum representing
some object.  This can lead to confusion, since it may not be obvious
out of context whether a given sequence of characters is intended to
be a representation of objects or the text of a program.
It is also a source of power, since it
facilitates writing programs such as interpreters or compilers that
treat programs as objects (or vice versa).

A datum value may have several different external representations.
For example, both ``{\tt \#e28.000}'' and
``{\tt\#x1c}'' are syntactic data representing the exact integer
object 28, and the syntactic data ``{\tt(8 13)}'', ``{\tt( 08 13 )}'', ``{\tt(8 .\
  (13 .\ ()))}''
all represent a list containing the exact integer objects 8 and 13. 
Syntactic data that represent equal objects (in the sense of {\cf
  equal?}; see section~\ref{equal?}) are always equivalent 
as forms of a program.

Because of the close correspondence between syntactic data and datum
values, this report sometimes uses the term \defining{datum} for
either a syntactic datum or a datum value when the exact meaning
is apparent from the context.

An implementation must not extend the lexical or datum syntax in
any way, with one exception: it need not treat the syntax
{\cf \sharpsign{}!\meta{identifier}}, for any \meta{identifier} (see
section~\ref{identifiersection}) that is not {\cf r6rs}, as a syntax
violation, and it may use specific {\cf \sharpsign{}!}-prefixed
identifiers as flags indicating that subsequent input contains extensions
to the standard lexical or datum syntax. 
The syntax {\cf \sharpsign{}!r6rs} may be used to signify that
the input afterward is written with the lexical syntax and
datum syntax described by
this report.
{\cf \sharpsign{}!r6rs} is otherwise treated as a comment; see section~\ref{whitespaceandcomments}.

\section{Notation}
% \label{BNF}

The formal syntax for Scheme is written in an extended BNF.
Non-terminals are written using angle brackets.  Case is insignificant
for non-terminal names.

All spaces in the grammar are for legibility.
\meta{Empty} stands for the empty string.

The following extensions to BNF are used to make the description more
concise:  \arbno{\meta{thing}} means zero or more occurrences of
\meta{thing}, and \atleastone{\meta{thing}} means at least one
\meta{thing}.

Some non-terminal names refer to the Unicode scalar values of the same
name: \meta{character tabulation} (U+0009), \meta{linefeed} (U+000A),
\meta{carriage return} (U+000D), \meta{line tabulation} (U+000B),
\meta{form feed} (U+000C), \meta{carriage return} (U+000D),
\meta{space} (U+0020), \meta{next line} (U+0085), \meta{line
  separator} (U+2028), and \meta{paragraph separator} (U+2029).

\section{Lexical syntax}
% \label{lexicalsyntaxsection}

The lexical syntax determines how a character sequence is split into a
sequence of lexemes\index{lexeme}, omitting non-significant portions
such as comments and whitespace.  The character sequence is assumed to
be text according to the Unicode standard~\cite{Unicode}.  Some of
the lexemes, such as identifiers, representations of number objects, strings etc., of the lexical
syntax are syntactic data in the datum syntax, and thus represent objects.
Besides the formal account of the syntax, this section also describes
what datum values are represented by these syntactic data.

The lexical syntax, in the description of comments, contains
a forward reference to \meta{datum}, which is described as part of the
datum syntax.  Being comments, however, these \meta{datum}s do not play
a significant role in the syntax.

Case is significant except in representations of booleans, number objects, and
in hexadecimal numbers specifying Unicode scalar values.  For example, {\cf \#x1A}
and {\cf \#X1a} are equivalent.  The identifier {\cf Foo} is, however,
distinct from the identifier {\cf FOO}.

\subsection{Formal account}
% \label{lexicalgrammarsection}

\meta{Interlexeme space} may occur on either side of any lexeme, but not
within a lexeme.

\hyper{Identifier}s, {\cf .}, \hyper{number}s, \hyper{character}s, and
\hyper{boolean}s, must be terminated by a \meta{delimiter} or by the
end of the input.

The following two characters are reserved for future extensions to the
language: {\tt \verb"{" \verb"}"}

\begin{grammar}%
\meta{lexeme} \: \meta{identifier} \| \meta{boolean} \| \meta{number}\index{identifier}
\>  \| \meta{character} \| \meta{string}
\>  \| ( \| ) \| \openbracket{} \| \closedbracket{} \| \sharpsign( \| \sharpsign{}vu8( | \singlequote{} \| \backquote{} \| , \| ,@ \| {\bf.}
\>  \| \sharpsign\singlequote{} \| \sharpsign\backquote{} \| \sharpsign, \| \sharpsign,@
\meta{delimiter} \: ( \| ) \| \openbracket{} \| \closedbracket{} \| " \| ; \| \sharpsign{}
\>  \| \meta{whitespace}
\meta{whitespace} \: \meta{character tabulation}
\> \| \meta{linefeed} \| \meta{line tabulation} \| \meta{form feed}
\> \| \meta{carriage return} \| \meta{next line}
\> \| \meta{any character whose category is Zs, Zl, or Zp}
\meta{line ending} \: \meta{linefeed} \| \meta{carriage return}
\> \| \meta{carriage return} \meta{linefeed} \| \meta{next line}
\> \| \meta{carriage return} \meta{next line} \| \meta{line separator}
\meta{comment} \: ; \= $\langle$\rm all subsequent characters up to a
                    \>\ \rm \meta{line ending} or \meta{paragraph separator}$\rangle$\index{comment}
\qquad \= \| \meta{nested comment}
\> \| \#; \meta{interlexeme space} \meta{datum}
\> \| \#!r6rs
\meta{nested comment} \: \#| \= \meta{comment text}
\> \arbno{\meta{comment cont}} |\#
\meta{comment text} \: \= $\langle$\rm character sequence not containing
\>\ \rm {\tt \#|} or {\tt |\#}$\rangle$
\meta{comment cont} \: \meta{nested comment} \meta{comment text}
\meta{atmosphere} \: \meta{whitespace} \| \meta{comment}
\meta{interlexeme space} \: \arbno{\meta{atmosphere}}%
\end{grammar}

% \label{extendedalphas}
% \label{identifiersyntax}

% This is a kludge, but \multicolumn doesn't work in tabbing environments.
\setbox0\hbox{\cf\meta{variable} \goesto{} $\langle$}

\begin{grammar}%
\meta{identifier} \: \meta{initial} \arbno{\meta{subsequent}}
 \>  \| \meta{peculiar identifier}
\meta{initial} \: \meta{constituent} \| \meta{special initial}
 \> \| \meta{inline hex escape}
\meta{letter} \:  a \| b \| c \| ... \| z
\> \| A \| B \| C \| ... \| Z
\meta{constituent} \: \meta{letter}
 \> \| $\langle${\rm any character whose Unicode scalar value is greater than}
 \> \quad {\rm 127, and whose category is Lu, Ll, Lt, Lm, Lo, Mn,}
 \> \quad {\rm Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co}$\rangle$
\meta{special initial} \: ! \| \$ \| \% \| \verb"&" \| * \| / \| : \| < \| =
 \>  \| > \| ? \| \verb"^" \| \verb"_" \| \verb"~"
\meta{subsequent} \: \meta{initial} \| \meta{digit}
 \>  \| \meta{any character whose category is Nd, Mc, or Me}
 \>  \| \meta{special subsequent}
\meta{digit} \: 0 \| 1 \| 2 \| 3 \| 4 \| 5 \| 6 \| 7 \| 8 \| 9
\meta{hex digit} \: \meta{digit}
 \> \| a \| A \| b \| B \| c \| C \| d \| D \| e \| E \| f \| F
\meta{special subsequent} \: + \| - \| .\ \| @
\meta{inline hex escape} \: \backwhack{}x\meta{hex scalar value};
\meta{hex scalar value} \: \atleastone{\meta{hex digit}}
\meta{peculiar identifier} \: + \| - \| ... \| -> \arbno{\meta{subsequent}}
\meta{boolean} \: \schtrue{} \| \#T \| \schfalse{} \| \#F
\meta{character} \: \#\backwhack{}\meta{any character}
 \>  \| \#\backwhack{}\meta{character name}
 \>  \| \#\backwhack{}x\meta{hex scalar value}
\meta{character name} \: nul \| alarm \| backspace \| tab
\> \| linefeed \| newline \| vtab \| page \| return
\> \| esc \| space \| delete
\meta{string} \: " \arbno{\meta{string element}} "
\meta{string element} \: \meta{any character other than \doublequote{} or \backwhack}
 \> \| \backwhack{}a \| \backwhack{}b \| \backwhack{}t \| \backwhack{}n \| \backwhack{}v \| \backwhack{}f \| \backwhack{}r
 \>  \| \backwhack\doublequote{} \| \backwhack\backwhack 
 \>  \| \backwhack\meta{intraline whitespace}\meta{line ending}
 \>  \hspace*{4em}\meta{intraline whitespace}
 \>  \| \meta{inline hex escape}
\meta{intraline whitespace} \: \meta{character tabulation}
\> \| \meta{any character whose category is Zs}%
\end{grammar}

A \meta{hex scalar value} represents a Unicode scalar value
between 0 and \sharpsign{}x10FFFF, excluding the range
$\left[\sharpsign{}x\textrm{D800}, \sharpsign{}x\textrm{DFFF}\right]$.

% \label{numbersyntax}%
The rules for \meta{num $R$}, \meta{complex $R$}, \meta{real
$R$}, \meta{ureal $R$}, \meta{uinteger $R$}, and \meta{prefix $R$} below
should be replicated for \hbox{$R = 2, 8, 10,$}
and $16$.  There are no rules for \meta{decimal $2$}, \meta{decimal
$8$}, and \meta{decimal $16$}, which means that number representations containing
decimal points or exponents must be in decimal radix.

\begin{grammar}%
\meta{number} \: \meta{num $2$} \| \meta{num $8$}
   \>  \| \meta{num $10$} \| \meta{num $16$}
\meta{num $R$} \: \meta{prefix $R$} \meta{complex $R$}
\meta{complex $R$} \: %
         \meta{real $R$} %
      \| \meta{real $R$} @ \meta{real $R$}
   \> \| \meta{real $R$} + \meta{ureal $R$} i %
      \| \meta{real $R$} - \meta{ureal $R$} i
   \> \| \meta{real $R$} + \meta{naninf} i %
      \| \meta{real $R$} - \meta{naninf} i
   \> \| \meta{real $R$} + i %
      \| \meta{real $R$} - i
   \> \| + \meta{ureal $R$} i %
      \| - \meta{ureal $R$} i 
   \> \| + \meta{naninf} i %
      \| - \meta{naninf} i
   \> \| + i %
      \| - i
\meta{real $R$} \: \meta{sign} \meta{ureal $R$}
  \> \| + \meta{naninf} \| - \meta{naninf}
\meta{naninf} \: nan.0 \| inf.0
\meta{ureal $R$} \: %
         \meta{uinteger $R$}
   \> \| \meta{uinteger $R$} / \meta{uinteger $R$}
   \> \| \meta{decimal $R$} \meta{mantissa width}
\meta{decimal $10$} \: %
         \meta{uinteger $10$} \meta{suffix}
   \> \| . \atleastone{\meta{digit $10$}} \meta{suffix}
   \> \| \atleastone{\meta{digit $10$}} . \arbno{\meta{digit $10$}} \meta{suffix}
   \> \| \atleastone{\meta{digit $10$}} . \meta{suffix}
\meta{uinteger $R$} \: \atleastone{\meta{digit $R$}}
\meta{prefix $R$} \: %
         \meta{radix $R$} \meta{exactness}
   \> \| \meta{exactness} \meta{radix $R$}
\end{grammar}

\begin{grammar}%
\meta{suffix} \: \meta{empty} 
   \> \| \meta{exponent marker} \meta{sign} \atleastone{\meta{digit $10$}}
\meta{exponent marker} \: e \| E \| s \| S \| f \| F
   \> \| d \| D \| l \| L
\meta{mantissa width} \: \meta{empty}
   \> \| | \atleastone{\meta{digit 10}}
\meta{sign} \: \meta{empty}  \| + \|  -
\meta{exactness} \: \meta{empty}
   \> \| \#i\sharpindex{i} \| \#I \| \#e\sharpindex{e} \| \#E
\meta{radix 2} \: \#b\sharpindex{b} \| \#B
\meta{radix 8} \: \#o\sharpindex{o} \| \#O
\meta{radix 10} \: \meta{empty} \| \#d \| \#D
\meta{radix 16} \: \#x\sharpindex{x} \| \#X
\meta{digit 2} \: 0 \| 1
\meta{digit 8} \: 0 \| 1 \| 2 \| 3 \| 4 \| 5 \| 6 \| 7
\meta{digit 10} \: \meta{digit}
\meta{digit 16} \: \meta{hex digit}
\end{grammar}

\subsection{Line endings}
% \label{lineendings}

Line endings are significant in Scheme in single-line comments (see
section~\ref{whitespaceandcomments}) and within string literals.  In
Scheme source code, any of the line endings in \meta{line ending}
marks the end of a line.  Moreover, the two-character line endings
\meta{carriage return} \meta{linefeed} and \meta{carriage return}
\meta{next line} each count as a single line ending.

In a string literal, a \hyper{line ending} not preceded by a {\cf\backwhack}
stands for a linefeed character, which is the standard line-ending
character of Scheme.

\subsection{Whitespace and comments}
% \label{whitespaceandcomments}

\defining{Whitespace} characters are spaces, linefeeds,
carriage returns, character tabulations, form feeds, line tabulations,
and any other character whose category is Zs, Zl, or Zp.
Whitespace is used for improved readability and
as necessary to separate lexemes from each other.  Whitespace may
occur between any two lexemes,
but not within a lexeme.  Whitespace may also occur inside a string,
where it is significant.

The lexical syntax includes several comment forms. In all cases,
comments are invisible to Scheme, except that they act as delimiters,
so, for example, a comment cannot appear in the middle of an
identifier or representation of a number object.

A semicolon ({\tt;}) indicates the start of a line
comment.\mainindex{comment}\mainschindex{;} The comment continues to
the end of the line on which the semicolon appears.

Another way to indicate a comment is to prefix a \hyper{datum}
(cf.\ section~\ref{datumsyntax}) with {\tt \#;}\sharpindex{;}, possibly with
\meta{interlexeme space} before the \hyper{datum}.  The comment consists of
the comment prefix {\tt \#;} and the \hyper{datum} together.  This
notation is useful for ``commenting out'' sections of code.

Block comments may be indicated with properly nested {\tt
  \#|}\index{#"|@\texttt{\sharpsign\verticalbar}}\index{"|#@\texttt{\verticalbar\sharpsign}}
and {\tt |\#} pairs.

\begin{scheme}
\#|
   The FACT procedure computes the factorial
   of a non-negative integer.
|\#
(define fact
  (lambda (n)
    ;; base case
    (if (= n 0)
        \#;(= n 1)
        1       ; identity of *
        (* n (fact (- n 1))))))%
\end{scheme}

The lexeme {\cf \sharpsign{}!r6rs}, which signifies that the program text
that follows is written with the lexical and datum syntax described in this
report, is also otherwise treated as a comment.

\subsection{Identifiers}
% \label{identifiersection}

Most identifiers\mainindex{identifier} allowed by other programming
languages are also acceptable to Scheme.  In general,
a sequence of letters, digits, and ``extended alphabetic
characters'' is
an identifier when it begins with a character that cannot begin a
representation of a number object.
In addition, \ide{+}, \ide{-}, and \ide{...} are identifiers, as is
a sequence of letters, digits, and extended alphabetic
characters that begins with the two-character sequence \ide{->}.
Here are some examples of identifiers:

\begin{scheme}
lambda         q                soup
list->vector   {+}                V17a
<=             a34kTMNs         ->-
the-word-recursion-has-many-meanings%
\end{scheme}

Extended alphabetic characters may be used within identifiers as if
they were letters.  The following are extended alphabetic characters:

\begin{scheme}
!\ \$ \% \verb"&" * + - . / :\ < = > ? @ \verb"^" \verb"_" \verb"~" %
\end{scheme}

Moreover, all characters whose Unicode scalar values are greater than 127 and
whose Unicode category is Lu, Ll, Lt, Lm, Lo, Mn, Mc, Me, Nd, Nl, No, Pd,
Pc, Po, Sc, Sm, Sk, So, or Co can be used within identifiers.
In addition, any character can be used within an identifier
when specified via an \meta{inline hex escape}.  For example, the
identifier \verb|H\x65;llo| is the same as the identifier
\verb|Hello|, and the identifier \verb|\x3BB;| is the same as the
identifier $\lambda$.

Any identifier may be used as a variable\index{variable} or as a
syntactic keyword\index{syntactic keyword} (see
sections~\ref{variablesection} and~\ref{macrosection}) in a Scheme
program.
Any identifier may also be used as a syntactic datum, in which case it
represents a \textit{symbol}\index{symbol} (see section~\ref{symbolsection}).

\subsection{Booleans}

The standard boolean objects for true and false have external representations
\schtrue{} and \schfalse.\sharpindex{t}\sharpindex{f}

\subsection{Characters}

Characters are represented using the notation
\sharpsign\backwhack\hyper{character}\index{#\@\texttt{\sharpsign\backwhack}} or
\sharpsign\backwhack\hyper{character name} or
\sharpsign\backwhack{}x\meta{hex scalar value}.

For example:

\texonly
\newcommand{\extab}{\>}
\begin{tabbing}
{\cf\#\backwhack{}x0000000000}\=\kill
\endtexonly
\htmlonly
\newcommand{\extab}{&}
\begin{tabular}{ll}
\endhtmlonly
{\cf\#\backwhack{}a}          \extab \textrm{lower case letter a}\\
{\cf\#\backwhack{}A}          \extab \textrm{upper case letter A}\\
{\cf\#\backwhack{}(}          \extab \textrm{left parenthesis}\\
{\cf\#\backwhack{}}           \extab \textrm{space character}\\
{\cf\#\backwhack{}nul}        \extab \textrm{U+0000}\\
{\cf\#\backwhack{}alarm}      \extab \textrm{U+0007}\\
{\cf\#\backwhack{}backspace}  \extab \textrm{U+0008}\\
{\cf\#\backwhack{}tab}        \extab \textrm{U+0009}\\
{\cf\#\backwhack{}linefeed}   \extab \textrm{U+000A}\\
{\cf\#\backwhack{}newline}   \extab \textrm{U+000A}\\
{\cf\#\backwhack{}vtab}       \extab \textrm{U+000B}\\
{\cf\#\backwhack{}page}       \extab \textrm{U+000C}\\
{\cf\#\backwhack{}return}     \extab \textrm{U+000D}\\
{\cf\#\backwhack{}esc}        \extab \textrm{U+001B}\\
{\cf\#\backwhack{}space}      \extab \textrm{U+0020}\\
 \extab preferred way to write a space\\
{\cf\#\backwhack{}delete}     \extab \textrm{U+007F}\\[1ex]
{\cf\#\backwhack{}xFF}        \extab \textrm{U+00FF}\\
{\cf\#\backwhack{}x03BB}      \extab \textrm{U+03BB}\\
{\cf\#\backwhack{}x00006587}  \extab \textrm{U+6587}\\
{\cf\#\backwhack{}\(\lambda\)} \extab \textrm{U+03BB}\\[1ex]
{\cf\#\backwhack{}x0001z}     \extab \exception{\&lexical}\\
{\cf\#\backwhack{}\(\lambda\)x}         \extab \exception{\&lexical}\\
{\cf\#\backwhack{}alarmx}     \extab \exception{\&lexical}\\
{\cf\#\backwhack{}alarm x}    \extab \textrm{U+0007}\\
 \extab followed by {\cf{}x}\\
{\cf\#\backwhack{}Alarm}      \extab \exception{\&lexical}\\
{\cf\#\backwhack{}alert}      \extab \exception{\&lexical}\\
{\cf\#\backwhack{}xA}         \extab \textrm{U+000A}\\
{\cf\#\backwhack{}xFF}        \extab \textrm{U+00FF}\\
{\cf\#\backwhack{}xff}        \extab \textrm{U+00FF}\\
{\cf\#\backwhack{}x ff}       \extab \textrm{U+0078}\\
 \extab followed by another datum, {\cf{}ff}\\
{\cf\#\backwhack{}x(ff)}      \extab \textrm{U+0078}\\
 \extab followed by another datum,\\
 \extab a parenthesized {\cf{}ff}\\
{\cf\#\backwhack{}(x)}        \extab \exception{\&lexical}\\
{\cf\#\backwhack{}(x}         \extab \exception{\&lexical}\\
{\cf\#\backwhack{}((x)}       \extab \textrm{U+0028}\\
 \extab followed by another datum,\\
 \extab parenthesized {\cf{}x}\\
{\cf\#\backwhack{}x00110000}  \extab \exception{\&lexical}\\
 \extab out of range\\
{\cf\#\backwhack{}x000000001} \extab \textrm{U+0001}  \\
{\cf\#\backwhack{}xD800}      \extab \exception{\&lexical}\\
 \extab in excluded range
\htmlonly
\end{tabular}
\endhtmlonly
\texonly
\end{tabbing}
\endtexonly

(The notation \exception{\&lexical} means that the line in question is
a lexical syntax violation.)

Case is significant in \sharpsign\backwhack\hyper{character}, and in
\sharpsign\backwhack{\rm$\langle$character name$\rangle$}, % \hyper doesn't allow a linebreak
but not in {\cf\sharpsign\backwhack{}x}\meta{hex scalar value}.  
A \meta{character} must be followed by a \meta{delimiter} or by the end of the input.
This rule resolves various ambiguous cases involving named characters,
requiring, for
example, the sequence of characters ``{\tt\sharpsign\backwhack space}''
to be interpreted as the space character rather than as
the character ``{\tt\sharpsign\backwhack s}'' followed
by the identifier ``{\tt pace}''.

\begin{note}
  The {\cf\sharpsign\backwhack{}newline} notation is retained for
  backward compatibility.  Its use is deprecated;
  {\cf\sharpsign\backwhack{}linefeed} should be used instead.
\end{note}

\subsection{Strings}

\vest String are represented by sequences of characters enclosed within doublequotes
({\cf "}).  Within a string literal, various escape
sequences\mainindex{escape sequence} represent characters other than
themselves.  Escape sequences always start with a backslash (\backwhack{}):

\begin{itemize}
\item{\cf\backwhack{}a} : alarm, U+0007
\item{\cf\backwhack{}b} : backspace, U+0008 
\item{\cf\backwhack{}t} : character tabulation, U+0009 
\item{\cf\backwhack{}n} : linefeed, U+000A 
\item{\cf\backwhack{}v} : line tabulation, U+000B 
\item{\cf\backwhack{}f} : formfeed, U+000C 
\item{\cf\backwhack{}r} : return, U+000D 
\item{\cf\backwhack{}}\verb|"| : doublequote, U+0022 
\item{\cf\backwhack{}\backwhack{}} : backslash, U+005C 
\item{\cf\backwhack{}}\hyper{intraline whitespace}\hyper{line ending}\\\hspace*{2em}\hyper{intraline whitespace} : nothing
\item{\cf\backwhack{}x\meta{hex scalar value};} : specified character (note the
  terminating semi-colon).
\end{itemize}

These escape sequences are case-sensitive, except that the alphabetic
digits of a \meta{hex scalar value} can be uppercase or lowercase.

Any other character in a string after a backslash is a syntax violation. Except
for a line ending, any
character outside of an escape sequence and not a doublequote stands
for itself in the string literal. For example the single-character
string literal {\tt "$\lambda$"} (doublequote, a lower case lambda, doublequote)
represents the same string as {\tt "\backwhack{}x03bb;"}.
A line ending that does not follow a backslash stands for a linefeed character.

Examples:

\texonly
\begin{tabbing}
{\cf "\backwhack{}x0000000000;"} \=\kill
\endtexonly
\htmlonly
\begin{tabular}{ll}
\endhtmlonly
{\cf "abc"} \extab  \textrm{U+0061, U+0062, U+0063}\\
{\cf "\backwhack{}x41;bc"} \extab  {\cf "Abc"} ; \textrm{U+0041, U+0062, U+0063}\\
{\cf "\backwhack{}x41; bc"} \extab {\cf "A bc"}\\
 \extab U+0041, U+0020, U+0062, U+0063\\
{\cf "\backwhack{}x41bc;"} \extab  \textrm{U+41BC}\\
{\cf "\backwhack{}x41"} \extab \exception{\&lexical}\\
{\cf "\backwhack{}x;"} \extab \exception{\&lexical}\\
{\cf "\backwhack{}x41bx;"} \extab \exception{\&lexical}\\
{\cf "\backwhack{}x00000041;"} \extab  {\cf "A"} ; \textrm{U+0041}\\
{\cf "\backwhack{}x0010FFFF;"} \extab \textrm{U+10FFFF}\\
{\cf "\backwhack{}x00110000;"} \extab  \exception{\&lexical}\\
 \extab out of range\\
{\cf "\backwhack{}x000000001;"} \extab \textrm{U+0001}\\
{\cf "\backwhack{}xD800;"} \extab \exception{\&lexical}\\
 \extab in excluded range\\
{\cf "A}\\
{\cf bc"} \extab \textrm{U+0041, U+000A, U+0062, U+0063}\\
 \extab if no space occurs after the {\cf{}A}
\htmlonly
\end{tabular}
\endhtmlonly
\texonly
\end{tabbing}
\endtexonly
  
\subsection{Numbers}
% \label{numbernotations}

The syntax of external representations for number objects is described
formally by the \meta{number} rule in the formal grammar.
Case is not significant in external representations of number objects.

A representation of a number object may be written in binary, octal, decimal, or
hexadecimal by the use of a radix prefix.  The radix prefixes are {\cf
\#b}\sharpindex{b} (binary), {\cf \#o}\sharpindex{o} (octal), {\cf
\#d}\sharpindex{d} (decimal), and {\cf \#x}\sharpindex{x} (hexadecimal).  With
no radix prefix, a representation of a number object is assumed to be expressed in decimal.

A representation of a number object may be specified to be either exact or
inexact by a prefix.  The prefixes are {\cf \#e}\sharpindex{e}
for exact, and {\cf \#i}\sharpindex{i} for inexact.  An exactness
prefix may appear before or after any radix prefix that is used.  If
the representation of a number object has no exactness prefix, the
constant is
inexact if it contains a decimal point, an
exponent, or
a nonempty mantissa width;
otherwise it is exact.

In systems with inexact number objects
of varying precisions, it may be useful to specify
the precision of a constant.  For this purpose, representations of
number objects
may be written with an exponent marker that indicates the
desired precision of the inexact
representation.  The letters {\cf s}, {\cf f},
{\cf d}, and {\cf l} specify the use of \var{short}, \var{single},
\var{double}, and \var{long} precision, respectively.  (When fewer
than four internal
inexact
representations exist, the four size
specifications are mapped onto those available.  For example, an
implementation with two internal representations may map short and
single together and long and double together.)  In addition, the
exponent marker {\cf e} specifies the default precision for the
implementation.  The default precision has at least as much precision
as \var{double}, but
implementations may wish to allow this default to be set by the user.

\begin{scheme}
3.1415926535898F0 
       {\rm{}Round to single, perhaps} 3.141593
0.6L0
       {\rm{}Extend to long, perhaps} .600000000000000%
\end{scheme}

A representation of a number object with nonempty mantissa width,
{\cf \var{x}|\var{p}}, represents the best binary
floating-point approximation of \var{x} using a \var{p}-bit significand. 
For example, {\cf 1.1|53} is a
representation of the best approximation of 1.1 in IEEE double
precision.
If \var{x} is an external representation of an inexact real number object
that contains no vertical bar, then its numerical value should be computed
as though it had a mantissa width of 53 or more.

Implementations that use binary floating-point representations
of real number objects should represent {\cf \var{x}|\var{p}}
using a \var{p}-bit significand if practical, or by a greater
precision if a \var{p}-bit significand is not practical, or
by the largest available precision if \var{p} or more bits
of significand are not practical within the implementation.

\begin{note}
The precision of a significand should not be confused with the
number of bits used to represent the significand.  In the IEEE
floating-point standards, for example, the significand's most
significant bit is implicit in single and double precision but
is explicit in extended precision.  Whether that bit is implicit
or explicit does not affect the mathematical precision.
In implementations that use binary floating point, the default
precision can be calculated by calling the following procedure:

\begin{scheme}
(define (precision)
  (do ((n 0 (+ n 1))
       (x 1.0 (/ x 2.0)))
    ((= 1.0 (+ 1.0 x)) n)))
\end{scheme}
\end{note}      

\begin{note}
When the underlying floating-point representation is IEEE double
precision, the {\cf |\var{p}} suffix should not always be omitted:
Denormalized floating-point numbers have diminished precision,
and therefore their external representations should
carry a {\cf |\var{p}} suffix with the actual width of the
significand.
\end{note}

The literals {\cf +inf.0} and {\cf -inf.0} represent positive and
negative infinity, respectively.  The {\cf +nan.0}
literal represents the NaN that is the result of {\cf (/ 0.0 0.0)},
and may represent other NaNs as well.

If \var{x} is an external representation of an inexact real number
object and
contains no vertical bar and no exponent marker
other than {\cf e}, the inexact real number object it represents is a flonum
(see library section~\extref{lib:flonumssection}{Flonums}).
Some or all of the other external representations of
inexact real number objects may also represent flonums, but that is not required by
this report.

\section{Datum syntax}
% \label{datumsyntaxsection}

The datum syntax describes the syntax of
syntactic data\mainindex{syntactic datum} in terms of a sequence of
\meta{lexeme}s, as defined in the lexical syntax.

Syntactic data include the lexeme data described in the
previous section as well as the following constructs for forming
compound data:
%
\begin{itemize}
\item pairs and lists, enclosed by \verb|( )| or \verb|[ ]| (see
  section~\ref{pairlistsyntax})
\item vectors (see section~\ref{vectorsyntax})
\item bytevectors (see section~\ref{bytevectorsyntax})
\end{itemize}

\subsection{Formal account}
% \label{datumsyntax}

The following grammar describes the syntax of syntactic data in terms
of various kinds of lexemes defined in the grammar in
section~\ref{lexicalsyntaxsection}:

\begin{grammar}%
\meta{datum} \: \meta{lexeme datum}
\>  \| \meta{compound datum}
\meta{lexeme datum} \: \meta{boolean} \| \meta{number}
\>  \| \meta{character} \| \meta{string} \|  \meta{symbol}
\meta{symbol} \: \meta{identifier}
\meta{compound datum} \: \meta{list} \| \meta{vector} \| \meta{bytevector}
\meta{list} \: (\arbno{\meta{datum}}) \| [\arbno{\meta{datum}}]
\>    \| (\atleastone{\meta{datum}} .\ \meta{datum}) \| [\atleastone{\meta{datum}} .\ \meta{datum}]
\>    \| \meta{abbreviation}
\meta{abbreviation} \: \meta{abbrev prefix} \meta{datum}
\meta{abbrev prefix} \: ' \| ` \| , \| ,@
\>    \| \#' | \#` | \#, | \#,@
\meta{vector} \: \#(\arbno{\meta{datum}})
\meta{bytevector} \: \#vu8(\arbno{\meta{u8}})
\meta{u8} \: $\langle${\rm any \meta{number} representing an exact}
 \>\>\quad\quad {\rm integer in $\{0, \ldots, 255\}$}$\rangle$%
\end{grammar}

\subsection{Pairs and lists}
% \label{pairlistsyntax}

List and pair data, representing pairs and lists of values
(see section~\ref{listsection}) are represented using parentheses or brackets.
Matching pairs of brackets that occur in the rules of \meta{list} are
equivalent to matching pairs of parentheses.

The most general notation for Scheme pairs as syntactic data is
the ``dotted'' notation \hbox{\cf (\hyperi{datum} .\ \hyperii{datum})} where
\hyperi{datum} is the representation of the value of the car field and
\hyperii{datum} is the representation of the value of the
cdr field.  For example {\cf (4 .\ 5)} is a pair whose car is 4 and whose
cdr is 5.

A more streamlined notation can be used for lists: the elements of the
list are simply enclosed in parentheses and separated by spaces.  The
empty list\index{empty list} is represented by {\tt()} .  For example,

\begin{scheme}
(a b c d e)%
\end{scheme}

and

\begin{scheme}
(a . (b . (c . (d . (e . ())))))%
\end{scheme}

are equivalent notations for a list of symbols.

The general rule is that, if a dot is followed by an open parenthesis,
the dot, open parenthesis, and matching closing parenthesis
can be omitted in the external representation.

The sequence of characters ``{\cf (4 .\ 5)}'' is the external representation of a
pair, not an expression that evaluates to a pair.
Similarly, the sequence of characters ``{\tt(+ 2 6)}'' is {\em not} an
external representation of the integer 8, even though it {\em is} an
expression (in the language of the \rsixlibrary{base} library)
evaluating to the integer 8; rather, it is a
syntactic datum representing a three-element list, the elements of which
are the symbol {\tt +} and the integers 2 and 6.

\subsection{Vectors}
% \label{vectorsyntax}

Vector data, representing vectors of objects (see
section~\ref{vectorsection}), are represented using the notation
{\tt\#(\hyper{datum} \dotsfoo)}.  For example, a vector of length 3
containing the number object for zero in element 0, the list {\cf(2 2 2 2)} in
element 1, and the string {\cf "Anna"} in element 2 can be represented as
follows:

\begin{scheme}
\#(0 (2 2 2 2) "Anna")%
\end{scheme}

This is the external representation of a vector, not an
expression that evaluates to a vector.

\subsection{Bytevectors}
% \label{bytevectorsyntax}

Bytevector data, representing bytevectors (see
library chapter~\extref{lib:bytevectorschapter}{Bytevectors}), are represented using the notation
{\tt\#vu8(\hyper{u8} \dotsfoo)}, where the \hyper{u8}s represent the octets of
the bytevector.  For example, a bytevector of length 3 containing the
octets 2, 24, and 123 can be represented as follows:

\begin{scheme}
\#vu8(2 24 123)%
\end{scheme}

This is the external representation of a bytevector, and also an
expression that evaluates to a bytevector.

\subsection{Abbreviations}\unsection
% \label{abbreviationsection}

\begin{entry}{%
\pproto{\singlequote\hyper{datum}}{}
\pproto{\backquote\hyper{datum}}{}
\pproto{,\hyper{datum}}{}
\pproto{,\atsign\hyper{datum}}{}
\pproto{\#'\hyper{datum}}{}
\pproto{\#\backquote\hyper{datum}}{}
\pproto{\#,\hyper{datum}}{}
\pproto{\#,@\hyper{datum}}{}
}

Each of these is an abbreviation:
\\\quad\schindex{'}\singlequote\hyper{datum}
for {\cf (quote \hyper{datum})},
\\\quad\schindex{`}\backquote\hyper{datum}
for {\cf (quasiquote \hyper{datum})},
\\\quad\schindex{,}{\cf,}\hyper{datum}
for {\cf (unquote \hyper{datum})},
\\\quad\index{,@\texttt{,\atsign}}{\cf,}\atsign\hyper{datum}
for {\cf (unquote-splicing \hyper{datum})},
\\\quad\sharpindex{'}{\cf\#'}\hyper{datum}
for {\cf (syntax \hyper{datum})},
\\\quad\sharpindex{`}{\cf\#`}\hyper{datum}
for {\cf (quasisyntax \hyper{datum})},
\\\quad\sharpindex{,}{\cf\#,}\hyper{datum}
for {\cf (unsyntax \hyper{datum})}, and
\\\quad\index{#,@\texttt{\#,\atsign}}{\cf\#,@}\hyper{datum}
for {\cf (unsyntax-splicing \hyper{datum})}.
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 


\part{ðŸ“œ File   11: basic.tex}
%\vfill\eject
\chapter{Semantic concepts}
% \label{basicchapter}

\section{Programs and libraries}

A Scheme program consists of a \textit{top-level program\index{top-level program}}
together with a set of \textit{libraries\index{library}}, each
of which defines a part of the program connected to the others through
explicitly specified exports and imports.  A library consists of a set
of export and import specifications and a body, which consists of
definitions, and expressions.
A top-level program is similar to a library, but
has no export specifications.
Chapters~\ref{librarychapter} and \ref{programchapter}
describe the syntax and semantics of libraries and top-level programs,
respectively. 
Chapter~\ref{baselibrarychapter} describes a base
library that defines many of the constructs traditionally associated with
Scheme.
A separate report~\cite{R6RS-libraries}
describes the various \textit{standard libraries}\index{standard
  library} provided by a Scheme system.

The division between the base library and the other standard libraries is
based on use, not on construction.  In particular, some facilities
that are typically implemented as ``primitives'' by a compiler or the
run-time system rather than in terms of other standard procedures
 or syntactic forms are not part of the base library, but are defined in
separate libraries.  Examples include the fixnums and flonums libraries,
the exceptions and conditions libraries, and the libraries for
records.

\section{Variables, keywords, and regions}
% \label{specialformsection}
% \label{variablesection}

Within the body of a library or top-level program,
an identifier\index{identifier} may name a kind of syntax, or it may name
a location where a value can be stored.  An identifier that names a kind
of syntax is called a {\em keyword}\mainindex{keyword}, or {\em syntactic keyword}\mainindex{syntactic keyword},
and is said to be {\em bound} to that kind of syntax (or, in the case of a
syntactic abstraction, a {\em transformer} that translates the syntax into more
primitive forms; see section~\ref{macrosection}).  An identifier that names a
location is called a {\em variable}\mainindex{variable} and is said to be
{\em bound} to that location.  
At each point within a top-level program or a library, a specific, fixed set
of identifiers is bound.  The set of these identifiers, the set of \textit{visible
bindings}\mainindex{binding}, is
known as the {\em environment} in effect at that point.

Certain forms are used to create syntactic abstractions
and to bind keywords to transformers for those new syntactic abstractions, while other
forms create new locations and bind variables to those
locations.  Collectively, these forms are called {\em binding
  constructs}.\mainindex{binding construct}
Some binding constructs take the form of
\textit{definitions}\index{definition}, while others are
expressions.
With the exception of exported library bindings, a binding created
by a definition is visible only within the body in which the
definition appears, e.g., the body of a library, top-level program,
or {\cf lambda} expression.
Exported library bindings are also visible within the bodies of
the libraries and top-level programs that import them (see
chapter~\ref{librarychapter}).

Expressions that bind variables include the {\cf lambda},
{\cf let}, {\cf let*}, {\cf letrec}, {\cf letrec*}, {\cf let-values},
and {\cf let*-values} forms from the base library (see
sections~\ref{lambda}, \ref{letrec}).
Of these, {\cf lambda} is the most fundamental.
Variable definitions appearing within the body of 
such an expression, or within the bodies of a library or top-level
program, are treated as a set of
{\cf letrec*} bindings.
In addition, for library bodies, 
the variables exported from the library can be referenced by
importing libraries and top-level programs.

Expressions that bind keywords include the {\cf
  let-syntax} and {\cf letrec-syntax} forms (see
section~\ref{bindsyntax}).  A {\cf define} form (see section~\ref{define}) is a
definition that creates a variable binding (see 
section~\ref{defines}), and a {\cf define-syntax} form is
a definition that creates a keyword binding (see
section~\ref{syntaxdefinitionsection}).

\vest Scheme is a statically scoped language with
block structure.  To each place in a top-level program or library body where an identifier is bound 
there corresponds a \defining{region} of code within which
the binding is visible.  The region is determined by the particular
binding construct that establishes the binding; if the binding is
established by a {\cf lambda} expression, for example, then its region
is the entire {\cf lambda} expression.  Every mention of an identifier
refers to the binding of the identifier that establishes the
innermost of the regions containing the use.  If a use of an
identifier appears in a place where none of the surrounding expressions
contains a binding for the identifier, the use may refer to a
binding established by a definition or import at the top of the
enclosing library or top-level program
(see chapter~\ref{librarychapter}).
If there is no binding for the identifier,
it is said to be \defining{unbound}.\mainindex{bound}

\section{Exceptional situations}
% \label{exceptionalsituationsection}

\mainindex{exceptional situation}A variety of exceptional situations
are distinguished in this report, among them violations of syntax,
violations of a procedure's specification, violations of
implementation restrictions, and exceptional situations in the
environment.  When an exceptional situation is detected by the
implementation, an \textit{exception is raised}\mainindex{raise},
which means that a special procedure called the \textit{current
  exception handler} is called.  A program can also raise an
exception, and override the current exception handler; see
library section~\extref{lib:exceptionssection}{Exceptions}.

When an exception is raised, an object is provided that
describes the nature of the exceptional situation.  The report uses
the condition system described in library section~\extref{lib:conditionssection}{Conditions} to
describe exceptional situations, classifying them by condition types.

Some exceptional situations allow continuing the program if the
exception handler takes appropriate action.  The corresponding
exceptions are called \textit{continuable}\index{continuable exception}.
For most of the exceptional situations described in this report,
portable programs cannot rely upon the exception being continuable
at the place where the situation was detected.
For those exceptions, the exception handler that is invoked by the
exception should not return.
In some cases, however, continuing is permissible, and the
handler may return.  See library section~\extref{lib:exceptionssection}{Exceptions}.

Implementations must raise an exception
when they are unable to continue correct execution
of a correct program due to some \defining{implementation restriction}.  For
example, an implementation that does not support infinities
must raise an exception with condition type
{\cf\&implementation-restriction} when it evaluates an expression
whose result would be an infinity.

Some possible implementation restrictions such as the lack of
representations for NaNs and infinities (see
section~\ref{infinitiesnanssection}) are anticipated by this report,
and implementations typically must raise an exception of the
appropriate condition type if they encounter such a situation.

This report uses the phrase ``an exception is raised'' synonymously
with ``an exception must be raised''.
This report uses the phrase ``an exception with condition type \var{t}''
to indicate that the object provided with the
exception is a condition object of the specified type.
The phrase ``a continuable exception is raised'' indicates an
exceptional situation that permits the exception handler to return.

\section{Argument checking}
% \label{argumentcheckingsection}

\mainindex{argument checking}
Many procedures specified in this report or as part of a
standard library restrict the arguments they accept.
Typically, a procedure accepts only specific numbers and types of arguments.
Many syntactic forms similarly restrict the values to which one or
more of their subforms can evaluate.
These restrictions imply responsibilities\mainindex{responsibility} for
both the programmer and the implementation.
Specifically, the programmer is responsible for ensuring
that the values indeed adhere to the restrictions described
in the specification.  The implementation must check
that the restrictions in the specification are indeed met, to the
extent that it is reasonable, possible, and necessary to allow the
specified operation to complete successfully.  The implementation's
responsibilities are specified in more detail in
chapter~\ref{entryformatchapter} and throughout the report.

Note that it is not always possible for an implementation to completely check
the restrictions set forth in a specification.  For example, if an
operation is specified to accept a procedure with specific properties,
checking of these properties is undecidable in general.  Similarly,
some operations accept both lists and procedures that are
called by these operations.  Since lists can be mutated by the procedures
through the \rsixlibrary{mutable-pairs} library (see library
chapter~\extref{lib:pairmutationchapter}{Mutable pairs}), an argument that is a list
when the operation starts may become a non-list during the execution of the operation.
Also, the procedure might escape to a different continuation,
preventing the operation from performing more checks.
Requiring the operation to check that the argument is a list after
each call to such a procedure would be impractical.  Furthermore, some
operations that accept lists only need to traverse these lists
partially to perform their function; requiring the implementation to
traverse the remainder of the list to verify that all specified
restrictions have been met might
violate reasonable performance assumptions.  For these reasons, the
programmer's obligations may exceed the checking obligations of the
implementation.

When an implementation detects a violation of a restriction for an
argument, it must raise an exception with condition type
{\cf\&assertion} in a way consistent with the safety of execution as
described in section~\ref{safetysection}.

\section{Syntax violations}

The subforms of a special form usually need to obey certain syntactic
restrictions.  As forms may be subject to macro expansion, which may
not terminate, the question of whether they obey the specified
restrictions is undecidable in general.

When macro expansion terminates, however, implementations must detect
violations of the syntax.  A \defining{syntax violation} is an error
with respect to the syntax of library bodies, top-level bodies,
or the ``\exprtype'' entries in the
specification of the base library or the standard libraries.
Moreover, attempting to assign to an immutable variable (i.e., the
variables exported by a library; see
section~\ref{importsareimmutablesection}) is also
considered a syntax violation.

If a top-level or library form in a program is not syntactically
correct, then the implementation must raise an exception with
condition type {\cf\&syntax}, and execution of that top-level program
or library must not be allowed to begin.

\section{Safety}
% \label{safetysection}

The standard libraries whose exports are described by this document
are said to be \defining{safe libraries}.  Libraries and top-level
programs that import only from safe libraries are also said to be safe.

As defined by this document, the Scheme programming language
is safe in the following sense:
The execution of a safe top-level program
cannot go so badly wrong as to crash or to continue to
execute while behaving in ways that are
inconsistent with the semantics described in this document,
unless an exception is raised.

Violations of an implementation restriction must raise an
exception with condition type {\cf\&implementation-\hp{}restriction},
as must all
violations and errors that would otherwise threaten system
integrity in ways that might result in execution that is
inconsistent with the semantics described in this document.

The above safety properties are guaranteed only for top-level programs
and libraries that are said to be safe.  In particular,
implementations may provide access to unsafe libraries in ways that
cannot guarantee safety.

\section{Boolean values}
% \label{booleanvaluessection}

Although there is a separate boolean type, any Scheme value can be
used as a boolean value for the purpose of a conditional test.  In a
conditional test, all values count as true in such a test except for
\schfalse{}.  This report uses the word ``true'' to refer to any
Scheme value except \schfalse{}, and the word ``false'' to refer to
\schfalse{}. \mainindex{true} \mainindex{false}

\section{Multiple return values}
% \label{multiplereturnvaluessection}

A Scheme expression can evaluate to an arbitrary finite number of
values.  These values are passed to the expression's continuation.

Not all continuations accept any number of values. For example, a continuation that
accepts the argument to a procedure call is guaranteed to accept
exactly one value.  The effect of passing some other number of values
to such a continuation is unspecified.  The {\cf call-with-values}
procedure
described in section~\ref{controlsection} makes it possible to create
continuations that accept specified numbers of return values.
If the number of
return values passed to a continuation created by a call to
{\cf call-with-values} is not accepted by its consumer
that was passed in that call, then an exception is raised.
A more complete description of the number of values accepted by
different continuations and the consequences of passing an unexpected
number of values is given in the description of the {\cf values}
procedure in section~\ref{values}.

A number of forms in the base library have sequences of expressions
as subforms that are evaluated sequentially, with the return values of
all but the last expression being discarded.  The continuations
discarding these values accept any number of values.

\section{Unspecified behavior}

\vest If an expression is said to ``return unspecified values'',
then the expression must evaluate without raising an exception, but
the values returned depend on the implementation; this report
explicitly does not say how many or what values should be returned.
Programmers should not rely on a specific number of return values or
the specific values themselves.
\mainindex{unspecified behavior}\mainindex{unspecified values}


\section{Storage model}
% \label{storagemodel}

Variables and objects such as pairs, vectors, bytevectors, strings,
hashtables, and records implicitly
refer to locations\mainindex{location} or sequences of locations.  A string, for
example, contains as many locations as there are characters in the string. 
(These locations need not correspond to a full machine word.) A new value may be
stored into one of these locations using the {\tt string-set!} procedure, but
the string contains the same locations as before.

An object fetched from a location, by a variable reference or by
a procedure such as {\cf car}, {\cf vector-ref}, or {\cf string-ref}, is
equivalent in the sense of \ide{eqv?} % and \ide{eq?} ??
(section~\ref{equivalencesection})
to the object last stored in the location before the fetch.

Every location is marked to show whether it is in use.
No variable or object ever refers to a location that is not in use.
Whenever this report speaks of storage being allocated for a variable
or object, what is meant is that an appropriate number of locations are
chosen from the set of locations that are not in use, and the chosen
locations are marked to indicate that they are now in use before the variable
or object is made to refer to them.

It is desirable for constants\index{constant} (i.e. the values of
literal expressions) to reside in read-only memory.  To express this,
it is convenient to imagine that every object that refers to locations
is associated with a flag telling whether that object is
mutable\index{mutable} or immutable\index{immutable}.  Literal
constants, the strings returned by \ide{symbol->string}, records with
no mutable fields, and other values explicitly designated as immutable
are immutable objects, while all objects created by the other
procedures listed in this report are mutable.  An attempt to store a
new value into a location referred to by an immutable object
should raise an exception with condition type {\cf\&assertion}.


\section{Proper tail recursion}
% \label{proper tail recursion}

Implementations of Scheme must be
{\em properly tail-recursive}\mainindex{proper tail recursion}.
Procedure calls that occur in certain syntactic
contexts called \textit{tail contexts}\index{tail context} 
are \textit{tail calls}\mainindex{tail call}.  A Scheme implementation is
properly tail-recursive if it supports an unbounded number of active
tail calls.  A call is {\em active} if the called procedure may still
return.  Note that this includes regular returns as well as returns
through continuations captured earlier by
{\cf call-with-current-continuation} that are later invoked.
In the absence of captured continuations, calls could
return at most once and the active calls would be those that had not
yet returned.
A formal definition of proper tail recursion can be found
in Clinger's paper~\cite{propertailrecursion}.  The rules for identifying tail calls
in constructs from the \rsixlibrary{base} library are described in
section~\ref{basetailcontextsection}.

\section{Dynamic extent and the dynamic environment}
% \label{dynamicenvironmentsection}

For a procedure call, the time between when it is initiated and when
it returns is called its \defining{dynamic extent}.  In Scheme, {\cf
  call-with-current-continuation}
(section~\ref{call-with-current-continuation}) allows reentering a
dynamic extent after its procedure call has returned.  Thus, the
dynamic extent of a call may not be a single, connected time period.

Some operations described in the report acquire information in
addition to their explicit arguments from the \defining{dynamic
  environment}.  For example, {\cf call-\hp{}with-\hp{}current-\hp{}continuation}
accesses an implicit context established
by {\cf dynamic-wind} (section~\ref{dynamic-wind}), and the {\cf
  raise} procedure (library
section~\extref{lib:exceptionssection}{Exceptions}) accesses the
current exception handler.  The operations that modify the dynamic
environment do so dynamically, for the dynamic extent of a call to a
procedure like {\cf dynamic-wind} or {\cf with-exception-handler}.
When such a call returns, the previous dynamic environment is
restored.  The dynamic environment can be thought of as part of the
dynamic extent of a call.  Consequently, it is captured by {\cf
  call-with-current-continuation}, and restored by invoking the escape
procedure it creates.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 


\part{ðŸ“œ File   12: entry.tex}
%\vfill\eject
\chapter{Entry format}
% \label{entryformatchapter}

The chapters that describe bindings in the base library and the standard
libraries are organized
into entries.  Each entry describes one language feature or a group of
related features, where a feature is either a syntactic construct or a
built-in procedure.  An entry begins with one or more header lines of the form

\noindent\pproto{\var{template}}{\var{category}}\unpenalty

The \var{category} defines the kind of binding described by the entry,
typically either ``\exprtype'' or ``procedure''.
An entry may specify various restrictions on subforms or arguments.
For background on this, see section~\ref{argumentcheckingsection}.

\section{Syntax entries}

If \var{category} is ``\exprtype'', the entry describes a 
special syntactic construct, and the template gives the syntax of the
forms of the construct.  
The template is written in a notation similar to a right-hand
side of the BNF rules in chapter~\ref{readsyntaxchapter}, and describes
the set of forms equivalent to the forms matching the
template as syntactic data.  Some ``\exprtype'' entries carry a
suffix ({\cf expand}), specifying that the syntactic keyword of the
construct is exported with level
$1$.  Otherwise, the syntactic keyword is exported with level $0$; see
section~\ref{phasessection}.

Components of the form described by a template are designated
by syntactic variables, which are written using angle brackets, for
example, \hyper{expression}, \hyper{variable}.  Case is insignificant
in syntactic variables.  Syntactic variables
stand for other forms, or
sequences of them.  A syntactic variable may refer to a non-terminal
in the grammar for syntactic data (see section~\ref{datumsyntax}),
in which case only forms matching
that non-terminal are permissible in that position.
For example, \hyper{identifier} stands for a form which must be an
identifier.
Also,
\hyper{expression} stands for any form which is a
syntactically valid expression.  Other non-terminals that are used in
templates are defined as part of the specification.

The notation
\begin{tabbing}
\qquad \hyperi{thing} $\ldots$
\end{tabbing}
indicates zero or more occurrences of a \hyper{thing}, and
\begin{tabbing}
\qquad \hyperi{thing} \hyperii{thing} $\ldots$
\end{tabbing}
indicates one or more occurrences of a \hyper{thing}.

It is the programmer's responsibility to ensure that each component of
a form has the shape specified by a template.  Descriptions of syntax
may express other restrictions on the components of a form.
Typically, such a restriction is formulated as a phrase of the form
``\hyper{x} must be\mainindex{must be} a \ldots''.  Again, these
specify the programmer's responsibility.  It is the implementation's
responsibility to check that these restrictions are satisfied, as long
as the macro transformers involved in expanding the form terminate.
If the implementation detects that a component does not meet the
restriction, an exception with condition type {\cf\&syntax} is raised.

\section{Procedure entries}

If \var{category} is ``procedure'', then the entry describes a procedure, and
the header line gives a template for a call to the procedure.  Parameter
names in the template are \var{italicized}.  Thus the header line

\noindent\pproto{(vector-ref \var{vector} \var{k})}{procedure}\unpenalty

indicates that the built-in procedure {\tt vector-ref} takes
two arguments, a vector \var{vector} and an exact non-negative integer
object \var{k} (see below).  The header lines

\noindent%
\pproto{(make-vector \var{k})}{procedure}
\pproto{(make-vector \var{k} \var{fill})}{procedure}\unpenalty

indicate that the {\tt make-vector} procedure takes
either one or two arguments.  The parameter names are
case-insensitive: \var{Vector} is the same as \var{vector}.

As with syntax templates, an ellipsis \dotsfoo{} at the end of a header
line, as in

\noindent\pproto{(= \vari{z} \varii{z} \variii{z} \dotsfoo)}{procedure}\unpenalty

indicates that the procedure takes arbitrarily many arguments of the
same type as specified for the last parameter name.  In this case,
{\cf =} accepts two or more arguments that must all be complex
number objects.

% \label{typeconventions}
A procedure that detects an argument that it is not specified to
handle must raise an exception with condition type
{\cf\&assertion}.  Also, the argument specifications are exhaustive: if the
number of arguments provided in a procedure call does not match 
any number of arguments accepted by the procedure, an exception with
condition type {\cf\&assertion} must be raised.

For succinctness, the report follows the convention
that if a parameter name is also the name of a type, then the corresponding argument must be of the named type.
For example, the header line for {\tt vector-ref} given above dictates that the
first argument to {\tt vector-ref} must be a vector.  The following naming
conventions imply type restrictions:

\texonly\begin{center}\endtexonly
  \begin{tabular}{ll}
    \var{obj}&any object\\
    \var{z}&complex number object\\
    \var{x}&real number object\\
    \var{y}&real number object\\
    \var{q}&rational number object\\
    \var{n}&integer object\\
    \var{k}&exact non-negative integer object\\
    \var{bool}&boolean (\schfalse{} or \schtrue{})\\
    \var{octet}&exact integer object in $\{0, \ldots, 255\}$\\
    \var{byte}&exact integer object in $\{-128, \ldots, 127\}$\\
    \var{char}&character (see section~\ref{charactersection})\\
    \var{pair}&pair (see section~\ref{listsection})\\
    \var{vector}&vector (see section~\ref{vectorsection})\\
    \var{string}&string (see section~\ref{stringsection})\\
    \var{condition}&condition (see library section~\extref{lib:conditionssection}{Conditions})\\
    \var{bytevector}&bytevector (see library chapter~\extref{lib:bytevectorschapter}{Bytevectors})\\
    \var{proc}&procedure (see section~\ref{proceduressection})
  \end{tabular}
\texonly\end{center}\endtexonly

Other type restrictions are expressed through parameter-naming
conventions that are described in specific chapters.  For example,
library chapter~\extref{lib:numberchapter}{Arithmetic} uses a number of special
parameter variables for the various subsets of the numbers.

With the listed type restrictions, it is the programmer's responsibility to
ensure that the corresponding argument is of the specified type.
It is the implementation's responsibility to check for
that type.

A parameter called \var{list} means that it is the
programmer's responsibility to pass an argument that is a list (see
section~\ref{listsection}).  It is the implementation's responsibility
to check that the argument is appropriately structured for the
operation to perform its function, to the extent that this is possible
and reasonable.  The implementation must at least check that the
argument is either an empty list or a pair.

Descriptions of procedures may express other restrictions on the
arguments of a procedure.  Typically, such a restriction is formulated
as a phrase of the form ``\var{x} must be a \ldots'' (or otherwise
using the word ``must'').

\section{Implementation responsibilities}

In addition to the restrictions implied by naming conventions, an
entry may list additional explicit restrictions.
These explicit restrictions usually describe both the
programmer's responsibilities, who must ensure that the subforms of a
form are appropriate, or that an appropriate
argument is passed, and the implementation's responsibilities, which
must check that subform adheres to the specified restrictions (if
macro expansion terminates), or if the argument is appropriate.  A description
may explicitly list the implementation's responsibilities for some
arguments or subforms in a paragraph labeled ``\textit{Implementation
  responsibilities}''.  In this case, the responsibilities specified
for these subforms or arguments in the rest of the description are only for the
programmer.  A paragraph describing implementation responsibility does not
affect the implementation's responsibilities for checking subforms or arguments not
mentioned in the paragraph.

\section{Other kinds of entries}

If \var{category} is something other than ``syntax'' and
``procedure'', then the entry describes a non-procedural value, and
the \var{category} describes the type of that value.  The header line

\noindent\rvproto{\&who}{condition type}\\
indicates that {\cf\&who} is a condition type.  The header line

\noindent\rvproto{unquote}{auxiliary syntax}\\
indicates that {\cf unquote} is a syntax binding that may occur
only as part of specific surrounding expressions.  Any use as an
independent syntactic construct or identifier is a syntax violation.
As with ``\exprtype'' entries, some ``auxiliary syntax'' entries  carry a
suffix ({\cf expand}), specifying that the syntactic keyword of the
construct is exported with level $1$.
\section{Equivalent entries}

The description of an entry occasionally states that it is \textit{the
  same} as another entry.  This means that both entries are
equivalent.  Specifically, it means that if both entries have the same
name and are thus exported from different libraries, the entries from
both libraries can be imported under the same name without conflict.

\section{Evaluation examples}

The symbol ``\evalsto'' used in program examples can be read
``evaluates to''.  For example,

\begin{scheme}
(* 5 8)      \ev  40%
\end{scheme}

means that the expression {\tt(* 5 8)} evaluates to the object {\tt 40}.
Or, more precisely:  the expression given by the sequence of characters
``{\tt(* 5 8)}'' evaluates, in an environment that imports the relevant library, to an object
that may be represented externally by the sequence of characters ``{\tt
40}''.  See section~\ref{datumsyntaxsection} for a discussion of external
representations of objects.

The ``\evalsto'' symbol is also used when the evaluation of an
expression causes a violation.  For example,

\begin{scheme}
(integer->char \sharpsign{}xD800) \xev \exception{\&assertion}%
\end{scheme}
%
means that the evaluation of the expression {\cf (integer->char
  \sharpsign{}xD800)} must raise an exception with condition type
{\cf\&assertion}.

Moreover, the ``\evalsto'' symbol is also used to explicitly say that
the value of an expression in unspecified.  For example:
%
\begin{scheme}
(eqv? "" "")             \ev  \unspecified%
\end{scheme}

Mostly, examples merely illustrate the behavior specified in the
entry.  In some cases, however, they disambiguate otherwise ambiguous
specifications and are thus normative.  Note that, in some cases,
specifically in the case of inexact number objects, the return value is only
specified conditionally or approximately.  For example:
%
\begin{scheme}
(atan -inf.0)                  \lev -1.5707963267948965 ; \textrm{approximately}%
\end{scheme}

\section{Naming conventions}

By convention, the names of procedures that store values into previously
allocated locations (see section~\ref{storagemodel}) usually end in
``\ide{!}''.

By convention, ``\ide{->}'' appears within the names of procedures that
take an object of one type and return an analogous object of another type.
For example, {\cf list->vector} takes a list and returns a vector whose
elements are the same as those of the list.

By convention, the names of predicates---procedures that always return
a boolean value---end in ``\ide{?}'' when the name contains any
letters; otherwise, the predicate's name does not end with a question
mark.

By convention, the components of compound names are separated by ``\ide{-}''
In particular, prefixes that are actual words or can be pronounced as
though they were actual words are followed by a hyphen, except when
the first character following the hyphen would be something other than
a letter, in which case the hyphen is omitted.  Short,
unpronounceable prefixes (``\ide{fx}'' and ``\ide{fl}'') are not
followed by a hyphen.

By convention, the names of condition types start with
``{\cf\&}''\index{&@\texttt{\&}}.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 


\part{ðŸ“œ File   13: library.tex}
\chapter{Libraries}
% \label{librarychapter}
\mainindex{library}
Libraries are parts of a program that can be distributed
independently.
The library system supports macro definitions within libraries,
macro exports, and distinguishes the phases in which definitions
and imports are needed.  This chapter defines the notation for
libraries and a semantics for library expansion and execution.

\section{Library form}
% \label{librarysyntaxsection}

A library definition must have the following form:\mainschindex{library}\mainschindex{import}\mainschindex{export}

\begin{scheme}
(library \hyper{library~name}
  (export \hyper{export~spec} \ldots)
  (import \hyper{import~spec} \ldots)
  \hyper{library~body})%
\end{scheme}

A library declaration contains the following elements:

\begin{itemize}
\item The \hyper{library~name} specifies the name of the library
  (possibly with version).
\item The {\cf export} subform specifies a list of exports, which name
  a subset of the bindings defined within or imported into the
  library.
\item The {\cf import} subform specifies the imported bindings as a
  list of import dependencies, where each dependency specifies:
\begin{itemize}
\item the imported library's name, and, optionally, constraints on its
  version,
\item the relevant levels, e.g., expand or run time (see
  section~\ref{phasessection}, and
\item the subset of the library's exports to make available within the
      importing library, and the local names to use within the importing
      library for each of the library's exports.
\end{itemize}
\item The \hyper{library body} is the library body, consisting of a
  sequence of definitions followed by a sequence of expressions.  The
  definitions may be both for local (unexported) and exported
  bindings, and the expressions are initialization expressions to be evaluated
  for their effects.
\end{itemize}

An identifier can be imported with the same local name from two or
more libraries or for two levels from the same library only if the
binding exported by each library is the same (i.e., the binding is
defined in one library, and it arrives through the imports only by
exporting and re-exporting).  Otherwise, no identifier can be imported
multiple times, defined multiple times, or both defined and imported.
No identifiers are visible within a library except for those
explicitly imported into the library or defined within the library.

A \hyper{library name} uniquely identifies a library within an
implementation, and is globally visible in the {\cf import} clauses
(see below) of all other libraries within an implementation.
A \hyper{library name} has the following form:

\begin{scheme}
(\hyperi{identifier} \hyperii{identifier} \ldots \hyper{version})%
\end{scheme}

where \hyper{version} is empty or has the following form:
%
\begin{scheme}
(\hyper{sub-version} \ldots)%
\end{scheme}

Each \hyper{sub-version} must represent an exact nonnegative integer object.
An empty \hyper{version} is equivalent to {\cf ()}.

An \hyper{export~spec} names a set of imported and locally defined bindings to
be exported, possibly with different
external names.  An \hyper{export~spec} must have one of the
following forms:

\begin{scheme}
\hyper{identifier}
(rename (\hyperi{identifier} \hyperii{identifier}) \ldots)%
\end{scheme}

In an \hyper{export~spec}, an \hyper{identifier} names a single binding defined
within or imported into the library, where the external name for the export is
the same as the name of the binding within the library. 
A {\cf rename} spec exports the binding named by 
\hyperi{identifier} in each {\cf (\hyperi{identifier}
  \hyperii{identifier})} pairing, using \hyperii{identifier} as the
external name.

Each \hyper{import~spec} specifies a set of bindings to be imported into
the library, the levels at which they are to be available, and the local
names by which they are to be known.  An \hyper{import spec} must
be one of the following:
%
\begin{scheme}
\hyper{import set}
(for \hyper{import~set} \hyper{import~level} \ldots)%
\end{scheme}

An \hyper{import level}  is one of the following:
\begin{scheme}
run
expand
(meta \hyper{level})%
\end{scheme}

where \hyper{level} represents an exact integer object.

As an \hyper{import level}, {\cf run} is an abbreviation for {\cf
  (meta 0)}, and {\cf expand} is an abbreviation for {\cf (meta 1)}.
Levels and phases are discussed in section~\ref{phasessection}.

An \hyper{import~set} names a set of bindings from another library and
possibly specifies local names for the imported bindings.  It must be
one of the following:

\begin{scheme}
\hyper{library~reference}
(library \hyper{library~reference})
(only \hyper{import~set} \hyper{identifier} \ldots)
(except \hyper{import~set} \hyper{identifier} \ldots)
(prefix \hyper{import~set} \hyper{identifier})
(rename \hyper{import~set} (\hyperi{identifier} \hyperii{identifier}) \ldots)%
\end{scheme}

A \hyper{library~reference} identifies a library by its 
name and optionally by its version.  It has one of the following forms:

\begin{scheme}
(\hyperi{identifier} \hyperii{identifier} \ldots)
(\hyperi{identifier} \hyperii{identifier} \ldots \hyper{version~reference})%
\end{scheme}

A \hyper{library~reference} whose first \hyper{identifier} is
{\cf for}, {\cf library}, {\cf only}, {\cf except}, {\cf prefix}, or {\cf rename} is
permitted only within a {\cf library} \hyper{import~set}.
The \hyper{import~set} {\cf (library \hyper{library~reference})} is
otherwise equivalent to \hyper{library~reference}.

A \hyper{library~reference} with no \hyper{version~reference}
(first form above) is equivalent to a \hyper{library~reference} with a
\hyper{version~reference} of {\cf ()}.

A \hyper{version~reference} specifies a set of \hyper{version}s that
it matches.  The \hyper{library~reference} identifies all libraries of
the same name and whose version is matched by the
\hyper{version~reference}.  A \hyper{version~reference} has
the following form:
%
\begin{scheme}
(\hyperi{sub-version reference} \ldots \hypern{sub-version reference})
(and \hyper{version reference} \ldots)
(or \hyper{version reference} \ldots)
(not \hyper{version reference})%
\end{scheme}
%
A \hyper{version reference} of the first form matches a \hyper{version}
with at least $n$ elements, whose \hyper{sub-version reference}s match
the corresponding \hyper{sub-version}s.  An {\cf and} \hyper{version
  reference} matches a version if all \hyper{version references}
following the {\cf and} match it.  Correspondingly, an {\cf
  or} \hyper{version reference} matches a version if one of
\hyper{version references} following the {\cf or} matches it,
and a {\cf not} \hyper{version reference} matches a version if the
\hyper{version reference} following it does not match it.

A \hyper{sub-version reference} has one of the following forms:

\begin{scheme}
\hyper{sub-version}
(>= \hyper{sub-version})
(<= \hyper{sub-version})
(and \hyper{sub-version~reference} \ldots)
(or \hyper{sub-version~reference} \ldots)
(not \hyper{sub-version~reference})%
\end{scheme}

A \hyper{sub-version reference} of the first form matches a
\hyper{sub-version} if it is equal to it.  A {\cf >=}
\hyper{sub-version reference} of the first form matches a sub-version
if it is greater or equal to the \hyper{sub-version} following it;
analogously for {\cf <=}.  An {\cf and} \hyper{sub-version reference}
matches a sub-version if all of the subsequent \hyper{sub-version
  reference}s match it.  Correspondingly, an {\cf or}
\hyper{sub-version reference} matches a sub-version if one of the
subsequent \hyper{sub-version reference}s matches it, and a {\cf not}
\hyper{sub-version reference} matches a sub-version if the subsequent
\hyper{sub-version reference} does not match it.

Examples:

\texonly\begin{center}\endtexonly
  \begin{tabular}{lll}
    version reference & version & match?
    \\
    {\cf ()} & {\cf (1)} & yes\\
    {\cf (1)} & {\cf (1)} & yes\\
    {\cf (1)} & {\cf (2)} & no\\
    {\cf (2 3)} & {\cf (2)} & no\\
    {\cf (2 3)} & {\cf (2 3)} & yes\\
    {\cf (2 3)} & {\cf (2 3 5)} & yes\\
    {\cf (or (1 (>= 1)) (2))} & {\cf (2)} & yes\\
    {\cf (or (1 (>= 1)) (2))} & {\cf (1 1)} & yes\\
    {\cf (or (1 (>= 1)) (2))} & {\cf (1 0)} & no\\
    {\cf ((or 1 2 3))} & {\cf (1)} & yes\\
    {\cf ((or 1 2 3))} & {\cf (2)} & yes\\
    {\cf ((or 1 2 3))} & {\cf (3)} & yes\\
    {\cf ((or 1 2 3))} & {\cf (4)} & no
  \end{tabular}
\texonly\end{center}\endtexonly

When more than one library is identified by a library reference, the
choice of libraries is determined in some implementation-dependent manner.

To avoid problems such as incompatible types and replicated state,
implementations should prohibit the two libraries whose library names
consist of the same sequence of identifiers but whose versions do not
match to co-exist in the same program.

By default, all of an imported library's exported bindings are made
visible within an importing library using the names given to the bindings
by the imported library.
The precise set of bindings to be imported and the names of those
bindings can be adjusted with the {\cf only}, {\cf except},
{\cf prefix}, and {\cf rename} forms as described below.

\begin{itemize}
\item An {\cf only} form produces a subset of the bindings from another
\hyper{import~set}, including only the listed
\hyper{identifier}s.
The included \hyper{identifier}s must be in
the original \hyper{import~set}.
\item An {\cf except} form produces a subset of the bindings from another
\hyper{import~set}, including all but the listed
\hyper{identifier}s.
All of the excluded \hyper{identifier}s must be in
the original \hyper{import~set}.
\item A {\cf prefix} form adds the \hyper{identifier} prefix to each
name from another \hyper{import~set}.
\item A {\cf rename} form, {\cf (rename (\hyperi{identifier} \hyperii{identifier}) \ldots)},
removes the bindings for {\cf \hyperi{identifier} \ldots} to form an
intermediate \hyper{import~set}, then adds the bindings back for the
corresponding {\cf \hyperii{identifier} \ldots} to form the final
\hyper{import~set}.
Each \hyperi{identifier} must be in the original \hyper{import~set},
each \hyperii{identifier} must not be in the intermediate \hyper{import~set},
and the \hyperii{identifier}s must be distinct.
\end{itemize}
It is a syntax violation if a constraint given above is not met.

% \label{librarybodysection}
The \hyper{library~body} of a {\cf library} form consists of forms
that are classified as 
\textit{definitions}\mainindex{definition} or
\textit{expressions}\mainindex{expression}.  Which forms belong to
which class depends on the imported libraries and the result of
expansion---see chapter~\ref{expansionchapter}.  Generally, forms that
are not 
definitions (see section~\ref{defines} for definitions available
through the base library) are expressions.

A \hyper{library~body} is like a \hyper{body} (see section~\ref{bodiessection}) except that
a \hyper{library~body}s need not include any expressions.  It must
have the following form:

\begin{scheme}
\hyper{definition} \ldots \hyper{expression} \ldots%
\end{scheme}

When {\cf begin}, {\cf let-syntax}, or {\cf letrec-syntax} forms
occur in a top-level body prior to the first
expression, they are spliced into the body; see section~\ref{begin}.
Some or all of the body, including portions wrapped in {\cf begin},
{\cf let-syntax}, or {\cf letrec-syntax}
forms, may be specified by a syntactic abstraction
(see section~\ref{macrosection}).

The transformer expressions and bindings are evaluated and created
from left to right, as described in chapter~\ref{expansionchapter}.
The expressions of variable definitions are evaluated
from left to right, as if in an implicit {\cf letrec*},
and the body expressions are also evaluated from left to right
after the expressions of the variable definitions.
A fresh location is created for each exported variable and initialized
to the value of its local counterpart.
The effect of returning twice to the continuation of the last body
expression is unspecified.

\begin{note}
The names {\cf library}, {\cf export}, {\cf import},
{\cf for}, {\cf run}, {\cf expand}, {\cf meta},
{\cf import}, {\cf export}, {\cf only}, {\cf except}, {\cf
  prefix}, {\cf rename}, {\cf and}, {\cf or}, {\cf not}, {\cf >=}, and {\cf <=}
appearing in the library syntax are part of the
syntax and are not reserved, i.e., the same names can be used for other
purposes within the library or even exported from or imported 
into a library with different meanings, without affecting their
use in the {\cf library} form.
\end{note}

Bindings defined with a library are not visible in code
outside of the library, unless the bindings are explicitly exported from the
library. 
An exported macro may, however, \emph{implicitly export} an otherwise
unexported identifier defined within or imported into the library.
That is, it may insert a reference to that identifier into the output code
it produces.

% \label{importsareimmutablesection} 
All explicitly exported variables are immutable in both the
exporting and importing libraries. 
It is thus a syntax violation if an
explicitly exported variable appears on the left-hand side of a {\cf set!}
expression, either in the exporting or importing libraries.

All implicitly exported variables are also immutable in both the
exporting and importing libraries.
It is thus a syntax violation if a
variable appears on the left-hand side of a {\cf set!}
expression in any code produced by an exported macro outside of the
library in which the variable is defined.
It is also a syntax violation if a
reference to an assigned variable appears in any code produced by
an exported macro outside of the library in which the variable is defined,
where an assigned variable is one that appears on the left-hand
side of a {\cf set!} expression in the exporting library.

All other variables defined within a library are mutable.

\section{Import and export levels}
% \label{phasessection}

Expanding a library may require run-time information from another
library.  For example, if a macro transformer calls a
procedure from library $A$, then the library $A$ must be
instantiated before expanding any use of the macro in library $B$.  Library $A$ may
not be
needed when library $B$ is eventually run as part of a program, or it
may be needed for run time of library $B$, too.  The library
mechanism distinguishes these times by phases, which are explained in
this section.

Every library can be characterized by expand-time information (minimally,
its imported libraries, a list of the exported keywords, a list of the
exported variables, and code to evaluate the transformer expressions) and
run-time information (minimally, code to evaluate the variable definition
right-hand-side expressions, and code to evaluate the body expressions).
The expand-time information must be available to expand references to
any exported binding, and the run-time information must be available to
evaluate references to any exported variable binding.

\mainindex{phase}
%
A \emph{phase} is a time at which the expressions within a library are
evaluated.
Within a library body, top-level expressions and
the right-hand sides of {\cf define} forms are evaluated at run time,
i.e., phase $0$, and the right-hand
sides of {\cf define-syntax} forms are evaluated at expand time, i.e.,
phase $1$.
When {\cf define-syntax},
{\cf let-syntax}, or {\cf letrec-syntax}
forms appear within code evaluated at phase $n$, the right-hand sides
are evaluated at phase $n+1$.

These phases are relative to the phase in which the library itself is
used.
An \defining{instance} of a library corresponds to an evaluation of its
variable definitions and expressions in a particular phase relative to another
library---a process called \defining{instantiation}.
For example, if a top-level expression in a library $B$ refers to
a variable export from another library $A$, then it refers to the export from an
instance of $A$ at phase $0$ (relative to the phase of $B$).
But if a phase $1$ expression within $B$ refers to the same binding from
$A$, then it refers to the export from an instance of $A$ at phase $1$
(relative to the phase of $B$).

A \defining{visit} of a library corresponds to the evaluation of its syntax
definitions in a particular phase relative to another
library---a process called \defining{visiting}. 
For example, if a top-level expression in a library $B$ refers to
a macro export from another library $A$, then it refers to the export from a
visit of $A$ at phase $0$ (relative to the phase of $B$), which corresponds
to the evaluation of the macro's transformer expression at phase $1$.


\mainindex{level}\mainindex{import level} 
%
A \emph{level} is a lexical property of an identifier that determines
in which phases it can be referenced. The level for each identifier
bound by a definition within a library is $0$; that is, the identifier
can be referenced only at phase $0$ within the library.
The level for each imported binding is determined by the enclosing {\cf
  for} form of the {\cf import} in the importing library, in
addition to the levels of the identifier in the exporting
library. Import and export levels are combined by pairwise addition of
all level combinations.  For example, references to an imported
identifier exported for levels $p_a$ and $p_b$ and imported for levels
$q_a$, $q_b$, and $q_c$ are valid at levels $p_a+q_a$, $p_a+q_b$,
$p_a+q_c$, $p_b+q_a$, $p_b+q_b$, and $p_b+q_c$. An \hyper{import~set}
without an enclosing {\cf for} is equivalent to {\cf (for
  \hyper{import~set} run)}, which is the same as {\cf (for
  \hyper{import~set} (meta 0))}.

The export level of an exported binding is $0$ for all bindings
that are defined within the exporting library. The export levels of a
reexported binding, i.e., an export imported from another library, are the
same as the effective import levels of that binding within the reexporting
library.

For the libraries defined in the library report, the export level is
$0$ for nearly all bindings. The exceptions are {\cf syntax-rules},
{\cf identifier-syntax}, {\cf ...}, and {\cf \_} from the
\rsixlibrary{base} library, which are exported with level $1$, {\cf
  set!} from the \rsixlibrary{base} library, which is exported with
levels $0$ and $1$, and all bindings from the composite
\thersixlibrary{} library (see library
chapter~\extref{lib:complibchapter}{Composite library}), which are
exported with levels $0$ and $1$.

Macro expansion within a library can introduce a reference to an
identifier that is not explicitly imported into the library. In that
case, the phase of the reference must match the identifier's level as
shifted by the difference between the phase of the source library
(i.e., the library that supplied the identifier's lexical context) and
the library that encloses the reference. For example, suppose that
expanding a library invokes a macro transformer, and the evaluation of
the macro transformer refers to an identifier that is exported from
another library (so the phase-$1$ instance of the library is used);
suppose further that the value of the binding is a syntax object
representing an identifier with only a level-$n$ binding; then, the
identifier must be used only at phase $n+1$ in the
library being expanded. This combination of levels and phases is why
negative levels on identifiers can be useful, even though libraries
exist only at non-negative phases.

If any of a library's definitions are referenced at phase $0$ in the
expanded form of a program, then an instance of the referenced library
is created for phase $0$ before the program's definitions and
expressions are evaluated. This rule applies transitively: if the
expanded form of one library references at phase $0$ an identifier
from another library, then before the referencing library is
instantiated at phase $n$, the referenced library must be instantiated
at phase $n$. When an identifier is referenced at any phase $n$
greater than $0$, in contrast, then the defining library is
instantiated at phase $n$ at some unspecified time before the
reference is evaluated. Similarly, when a macro keyword is referenced at
phase $n$ during the expansion of a library, then the
defining library is visited at phase $n$ at some unspecified time
before the reference is evaluated.

An implementation may distinguish instances/visits of a library for
different phases or to use an instance/visit at any phase as an instance/visit at
any other phase. An implementation may further
expand each {\cf library} form with distinct
visits of libraries in any phase and/or instances of
libraries in phases above $0$. An implementation may
create instances/visits of more libraries at more phases than required to
satisfy references. When an identifier appears as an expression in a
phase that is inconsistent with the identifier's level, then an
implementation may raise an exception either at expand time or run
time, or it may allow the reference. Thus, a library whose meaning depends on whether the
instances of a library are distinguished or shared across phases or
{\cf library} expansions may be unportable.

\section{Examples}

Examples for various \hyper{import~spec}s and \hyper{export~spec}s:

\begin{scheme}
(library (stack)
  (export make push! pop! empty!)
  (import (rnrs))

  (define (make) (list '()))
  (define (push! s v) (set-car! s (cons v (car s))))
  (define (pop! s) (let ([v (caar s)])
                     (set-car! s (cdar s))
                     v))
  (define (empty! s) (set-car! s '())))

(library (balloons)
  (export make push pop)
  (import (rnrs))

  (define (make w h) (cons w h))
  (define (push b amt)
    (cons (- (car b) amt) (+ (cdr b) amt)))
  (define (pop b) (display "Boom! ") 
                  (display (* (car b) (cdr b))) 
                  (newline)))

(library (party)
  ;; Total exports:
  ;; make, push, push!, make-party, pop!
  (export (rename (balloon:make make)
                  (balloon:push push))
          push!
          make-party
          (rename (party-pop! pop!)))
  (import (rnrs)
          (only (stack) make push! pop!) ; not empty!
          (prefix (balloons) balloon:))

  ;; Creates a party as a stack of balloons,
  ;; starting with two balloons
  (define (make-party)
    (let ([s (make)]) ; from stack
      (push! s (balloon:make 10 10))
      (push! s (balloon:make 12 9))
      s))
  (define (party-pop! p)
    (balloon:pop (pop! p))))


(library (main)
  (export)
  (import (rnrs) (party))

  (define p (make-party))
  (pop! p)        ; displays "Boom! 108"
  (push! p (push (make 5 5) 1))
  (pop! p))       ; displays "Boom! 24"%
\end{scheme}

Examples for macros and phases:

\begin{schemenoindent}
(library (my-helpers id-stuff)
  (export find-dup)
  (import (rnrs))

  (define (find-dup l)
    (and (pair? l)
         (let loop ((rest (cdr l)))
           (cond
            [(null? rest) (find-dup (cdr l))]
            [(bound-identifier=? (car l) (car rest)) 
             (car rest)]
            [else (loop (cdr rest))])))))

(library (my-helpers values-stuff)
  (export mvlet)
  (import (rnrs) (for (my-helpers id-stuff) expand))

  (define-syntax mvlet
    (lambda (stx)
      (syntax-case stx ()
        [(\_ [(id ...) expr] body0 body ...)
         (not (find-dup (syntax (id ...))))
         (syntax
           (call-with-values
               (lambda () expr) 
             (lambda (id ...) body0 body ...)))]))))

(library (let-div)
  (export let-div)
  (import (rnrs)
          (my-helpers values-stuff)
          (rnrs r5rs))

  (define (quotient+remainder n d)
    (let ([q (quotient n d)])
      (values q (- n (* q d)))))
  (define-syntax let-div
    (syntax-rules ()
     [(\_ n d (q r) body0 body ...)
      (mvlet [(q r) (quotient+remainder n d)]
        body0 body ...)])))%
\end{schemenoindent}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 


\part{ðŸ“œ File   14: programs.tex}
\chapter{Top-level programs}
% \label{programchapter}

A \defining{top-level program} specifies an entry point for defining and running
a Scheme program.  A top-level program specifies a set of libraries to import and
code to run.  Through the imported libraries, whether directly or through the
transitive closure of importing, a top-level program defines a complete Scheme
program.

\section{Top-level program syntax}
% \label{programsyntaxsection}

A top-level program is a delimited piece of text, typically a file, that 
has the following form:
%
\begin{scheme}
\hyper{import form} \hyper{top-level body}%
\end{scheme}
%
An \hyper{import form} has the following form:
%
\begin{scheme}
(import \hyper{import spec} \dotsfoo)%
\end{scheme}
%
A \hyper{top-level body} has the following form:
\begin{scheme}
\hyper{top-level body form} \dotsfoo%
\end{scheme}
%
A \hyper{top-level body form} is either a \hyper{definition} or an
\hyper{expression}.

The \hyper{import form} is identical to the import clause in
libraries (see section~\ref{librarysyntaxsection}), 
and specifies a set of libraries to import.  A \hyper{top-level 
 body} is like a \hyper{library body} (see
section~\ref{librarybodysection}), except that 
definitions and expressions may occur in any order.  Thus, the syntax
specified by \hyper{top-level body form} refers to the result of macro
expansion.

When uses of {\cf begin}, {\cf let-syntax}, or {\cf letrec-syntax}
from the \rsixlibrary{base} library
occur in a top-level body prior to the first
expression, they are spliced into the body; see section~\ref{begin}.
Some or all of the body, including portions wrapped in {\cf begin},
{\cf let-syntax}, or {\cf letrec-syntax}
forms, may be specified by a syntactic abstraction
(see section~\ref{macrosection}).

\section{Top-level program semantics}

A top-level program is executed by treating the program similarly to a library, and
evaluating its definitions and expressions.
The semantics of a top-level body may be roughly explained by
a simple translation into a library body: 
Each \hyper{expression} that appears before a
definition in
the top-level body is converted into a dummy definition 
%
\begin{scheme}
(define \hyper{variable} (begin \hyper{expression} \hyper{unspecified}))%
\end{scheme}
%
where \hyper{variable} is a fresh identifier and \hyper{unspecified}
is a side-effect-free expression returning an unspecified value.
(It is generally impossible to determine which forms are 
definitions and expressions without concurrently expanding the body, so
the actual translation is somewhat more complicated; see
chapter~\ref{expansionchapter}.)

On platforms that support it, a top-level program may access its command line 
by calling the {\cf command-line} procedure (see library 
section~\extref{lib:command-line}{Command-line access and exit values}).

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 


\part{ðŸ“œ File   15: syntax.tex}
\chapter{Primitive syntax}

After the {\cf import} form within a {\cf library} form or a top-level
program, the forms
that constitute the body of the library or the top-level program
depend on the libraries that are
imported. In particular, imported syntactic keywords determine 
the available syntactic abstractions and whether each form is a 
definition or expression. A few form types are
always available independent of imported libraries, however,
including constant literals, variable references, procedure calls,
 and macro uses.

\section{Primitive expression types}
% \label{primitiveexpressionsection}

The entries in this section all describe expressions, which may occur
in the place of \hyper{expression} syntactic variables.  See
also section~\ref{expressionsection}.

\subsection*{Constant literals}\unsection

\begin{entry}{%
\pproto{\hyper{number}}{\exprtype}
\pproto{\hyper{boolean}}{\exprtype}
\pproto{\hyper{character}}{\exprtype}
\pproto{\hyper{string}}{\exprtype}
\pproto{\hyper{bytevector}}{\exprtype}}\mainindex{literal}

An expression consisting of a representation of a number object, a
boolean, a character, a string, or a bytevector, evaluates ``to
itself''.

\begin{scheme}
145932     \ev  145932
\schtrue   \ev  \schtrue
"abc"      \ev  "abc"
\#vu8(2 24 123) \ev \#vu8(2 24 123)%
\end{scheme}

As noted in section~\ref{storagemodel}, the value of a literal
expression is immutable.
\end{entry}

\subsection*{Variable references}\unsection
\begin{entry}{%
\pproto{\hyper{variable}}{\exprtype}}

An expression consisting of a variable\index{variable}
(section~\ref{variablesection}) is a variable reference if it is not a
macro use (see below).  The value of
the variable reference is the value stored in the location to which the
variable is bound.  It is a syntax violation to reference
an unbound\index{unbound} variable.

The following example examples assumes the base library
has been imported:
%
\begin{scheme}
(define x 28)
x   \ev  28%
\end{scheme}
\end{entry}

\subsection*{Procedure calls}\unsection

\begin{entry}{%
\pproto{(\hyper{operator} \hyperi{operand} \dotsfoo)}{\exprtype}}

A procedure call consists of expressions for the procedure to be
called and the arguments to be passed to it, with enclosing
parentheses.  A form in an expression context is a procedure call if
\hyper{operator} is not an identifier bound as a syntactic keyword
(see section~\ref{macrosection} below).

When a procedure call is evaluated, the operator and operand
expressions are evaluated (in an unspecified order) and the resulting
procedure is passed the resulting
arguments.\mainindex{call}\mainindex{procedure call}

The following examples assume the \rsixlibrary{base} library
has been imported:
%
\begin{scheme}%
(+ 3 4)                          \ev  7
((if \schfalse + *) 3 4)         \ev  12%
\end{scheme}
%
If the value of \hyper{operator} is not a procedure, an exception with
condition type {\cf\&assertion} is raised.  Also, if \hyper{operator}
does not accept as many arguments as there are \hyper{operand}s, an
exception with condition type {\cf\&assertion} is raised.

\begin{note} In contrast to other dialects of Lisp, the order of
evaluation is unspecified, and the operator expression and the operand
expressions are always evaluated with the same evaluation rules.

Although the order of evaluation is otherwise unspecified, the effect of
any concurrent evaluation of the operator and operand expressions is
constrained to be consistent with some sequential order of evaluation.
The order of evaluation may be chosen differently for each procedure call.
\end{note}

\begin{note} In many dialects of Lisp, the form {\tt
()} is a legitimate expression.  In Scheme, expressions written as
list/pair forms must have at
least one subexpression, so {\tt ()} is not a syntactically valid
expression.
\end{note}

\end{entry}

\section{Macros}
% \label{macrosection}

Libraries and top-level programs can define and use new kinds of derived expressions and
definitions called {\em syntactic abstractions} or
{\em macros}.\mainindex{syntactic abstraction}\mainindex{macro}
A syntactic abstraction is created by binding a keyword to a
{\em macro transformer} or, simply, {\em transformer}.
\index{macro transformer}\index{transformer}
The transformer determines
how a use of the macro (called a \defining{macro use})
is transcribed into a more primitive form.

Most macro uses have the form:
\begin{scheme}
(\hyper{keyword} \hyper{datum} \dotsfoo)%
\end{scheme}%
where \hyper{keyword} is an identifier that uniquely determines the
kind of form.  This identifier is called the {\em syntactic
keyword}\index{syntactic keyword}, or simply {\em
keyword}\index{keyword}, of the macro\index{macro keyword}.
The number of \hyper{datum}s and the syntax
of each depends on the syntactic abstraction.

Macro uses can also take the form of improper lists, singleton
identifiers, or {\cf set!} forms, where the second subform of the
{\cf set!} is the keyword (see section~\ref{identifier-syntax})
library section~\extref{lib:make-variable-transformer}{{\cf make-variable-transformer}}):
\begin{scheme}
(\hyper{keyword} \hyper{datum} \dotsfoo . \hyper{datum})
\hyper{keyword}
(set! \hyper{keyword} \hyper{datum})%
\end{scheme}

The {\cf define-syntax}, {\cf let-syntax} and {\cf letrec-syntax}
forms, described in sections~\ref{define-syntax} and \ref{let-syntax},
create bindings for keywords, associate them with macro transformers,
and control the scope within which they are visible.

The {\cf syntax-rules} and {\cf identifier-syntax} forms, described in
section~\ref{syntaxrulessection}, create transformers via a pattern
language.  Moreover, the {\cf syntax-case} form, described in library
chapter~\extref{lib:syntaxcasechapter}{{\cf syntax-case}}, 
allows creating transformers via arbitrary Scheme code.

Keywords occupy the same name space as variables.
That is, within the same
scope, an identifier can be bound as a variable or keyword, or neither, but
not both, and local bindings of either kind may shadow other bindings of
either kind.

Macros defined using {\cf syntax-rules} and {\cf identifier-\hp{}syntax}
are ``hygienic'' and ``referentially transparent'' and thus preserve
Scheme's lexical scoping~\cite{Kohlbecker86,
  hygienic,Bawden88,macrosthatwork,syntacticabstraction}:
\mainindex{hygienic} \mainindex{referentially transparent}

\begin{itemize}
\item If a macro transformer inserts a binding for an identifier
(variable or keyword) not appearing in the macro use, the identifier is in effect renamed
throughout its scope to avoid conflicts with other identifiers.

\item If a macro transformer inserts a free reference to an
identifier, the reference refers to the binding that was visible
where the transformer was specified, regardless of any local
bindings that may surround the use of the macro.
\end{itemize}

Macros defined using the {\cf syntax-case} facility are also
hygienic unless {\cf datum\coerce{}syntax}
(see library section~\extref{lib:conversionssection}{Syntax-object and datum conversions}) is used.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 


\part{ðŸ“œ File   16: expansion.tex}
\chapter{Expansion process}
% \label{expansionchapter}

Macro uses (see section~\ref{macrosection}) are expanded into \textit{core
forms}\mainindex{core form} at the start of evaluation (before compilation or interpretation)
by a syntax \emph{expander}.
The set of core forms is implementation-dependent, as is the
representation of these forms in the expander's output.
If the expander encounters a syntactic abstraction, it invokes
the associated transformer to expand the syntactic abstraction, then
repeats the expansion process for the form returned by the transformer.
If the expander encounters a core form, it recursively
processes its subforms that are in expression or definition context,
if any, and reconstructs the form from the
expanded subforms.
Information about identifier bindings is maintained during expansion
to enforce lexical scoping for variables and keywords.

To handle definitions, the expander processes the initial
forms in a \hyper{body} (see section~\ref{bodiessection}) or
\hyper{library body} (see section~\ref{librarybodysection})
from left to
right.  How the expander processes each form encountered 
depends upon the kind of form.

\begin{description}
\item[macro use]
The expander invokes the associated transformer to transform the macro
use, then recursively performs whichever of these actions are appropriate
for the resulting form.

\item[{\cf define-syntax} form]
The expander expands and evaluates the right-hand-side expression and binds the
keyword to the resulting transformer.

\item[{\cf define} form]
The expander records the fact that the defined identifier is a variable but defers
expansion of the right-hand-side expression until after all of the
definitions have been processed.

\item[{\cf begin} form]
The expander splices the subforms into the list of body forms it is
processing.  (See section~\ref{begin}.)

\item[{\cf let-syntax} or {\cf letrec-syntax} form]
The expander splic\-es the inner body forms into the list of (outer) body forms it is
processing, arranging for the keywords bound by the {\cf let-syntax}
and {\cf letrec-syntax} to be visible only in the inner body forms.

\item[expression, i.e., nondefinition]
The expander completes the expansion of the deferred right-hand-side expressions
and the current and remaining expressions in the body, and then
creates the equivalent of a {\cf letrec*} form from the defined variables,
expanded right-hand-side expressions, and expanded body expressions.
\end{description}

For the right-hand side of the definition of a variable, expansion is
deferred until after all of the definitions have been seen.  Consequently,
each keyword and variable reference within the right-hand side
resolves to the local binding, if any.

A definition in the sequence of forms must not define any identifier whose
binding is used to determine the meaning of the undeferred portions of the
definition or any definition that precedes it in the sequence of forms.
For example, the bodies of the following expressions violate this
restriction.

\begin{scheme}
(let ()
  (define define 17)
  (list define))

(let-syntax ([def0 (syntax-rules ()
                     [(\_ x) (define x 0)])])
  (let ([z 3])
    (def0 z)
    (define def0 list)
    (list z)))

(let ()
  (define-syntax foo
    (lambda (e)
      (+ 1 2)))
  (define + 2)
  (foo))%
\end{scheme}

The following do not violate the restriction.

\begin{scheme}
(let ([x 5])
  (define lambda list)
  (lambda x x))         \ev  (5 5)

(let-syntax ([def0 (syntax-rules ()
                     [(\_ x) (define x 0)])])
  (let ([z 3])
    (define def0 list)
    (def0 z)
    (list z)))          \ev  (3)

(let ()
  (define-syntax foo
    (lambda (e)
      (let ([+ -]) (+ 1 2))))
  (define + 2)
  (foo))                \ev  -1%
\end{scheme}

The implementation should treat a violation of the restriction as a
syntax violation.

% Andre's proposed implementation:
% To detect this violation, the expander can record each
% identifier whose denotation is determined during expansion
% of the body, together with the denotation.
% Before an identifier is bound, its current denotation is compared
% against denotations already used for the same (in the sense of
% bound-identifier=?) identifier in the scope of the intended binding,
% to determine if its current denotation has already been used
% during the expansion of the body.

Note that this algorithm does not directly reprocess any form.
It requires a single left-to-right pass over the definitions followed by a
single pass (in any order) over the body expressions and deferred
right-hand sides.

Example:

\begin{scheme}
(lambda (x)
  (define-syntax defun
    (syntax-rules ()
      [(\_ x a e) (define x (lambda a e))]))
  (defun even? (n) (or (= n 0) (odd? (- n 1))))
  (define-syntax odd?
    (syntax-rules () [(\_ n) (not (even? n))]))
  (odd? (if (odd? x) (* x x) x)))%
\end{scheme}

In the example, the definition of {\cf defun} is encountered first, and the keyword
{\cf defun} is associated with the transformer resulting from
the expansion and evaluation of the corresponding right-hand side.
A use of {\cf defun} is encountered next and expands into a
{\cf define} form.
Expansion of the right-hand side of this define form is deferred.
The definition of {\cf odd?} is next and results in the association
of the keyword {\cf odd?} with the transformer resulting from
expanding and evaluating the corresponding right-hand side.
A use of {\cf odd?} appears next and is expanded; the resulting
call to {\cf not} is recognized as an expression
because {\cf not} is bound as a variable.
At this point, the expander completes the expansion of the current
expression (the call to {\cf not}) and the deferred right-hand side of the
{\cf even?} definition;
the uses of {\cf odd?} appearing in these expressions are expanded
using the transformer associated with the keyword {\cf odd?}.
The final output is the equivalent of

\begin{scheme}
(lambda (x)
  (letrec* ([even?
              (lambda (n)
                (or (= n 0)
                    (not (even? (- n 1)))))])
    (not (even? (if (not (even? x)) (* x x) x)))))%
\end{scheme}

although the structure of the output is implementation-dependent.

Because definitions and expressions can be interleaved in a
\hyper{top-level body} (see chapter~\ref{programchapter}),
the expander's processing of a \hyper{top-level body} is somewhat
more complicated.
It behaves as described above for a \hyper{body} or
\hyper{library body} with the following exceptions:
When the expander finds a nondefinition,
it defers its expansion and continues scanning for definitions.
Once it reaches the end of the set of forms, it processes the
deferred right-hand-side and body expressions, then
generates the equivalent of a {\cf letrec*} form from the defined variables,
expanded right-hand-side expressions, and expanded body expressions.
For each body expression \hyper{expression} that appears before a variable definition
in the body, a dummy binding is created at the corresponding place within
the set of {\cf letrec*} bindings, with a fresh temporary variable on the
left-hand side and the equivalent of {\cf (begin \hyper{expression}
  \hyper{unspecified})},
where \hyper{unspecified} is a side-effect-free expression returning
an unspecified value,
on the right-hand side, so that
left-to-right evaluation order is preserved.
The {\cf begin} wrapper allows \hyper{expression} to evaluate to an
arbitrary number of values.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 


\part{ðŸ“œ File   17: base.tex}
%\vfill\eject
\chapter{Base library}
% \label{baselibrarychapter}

This chapter describes Scheme's \defrsixlibrary{base} library, which exports many of
the procedure and syntax bindings that are traditionally associated
with Scheme.

Section~\ref{basetailcontextsection} defines the rules that identify
tail calls and tail contexts in constructs from the \rsixlibrary{base}
library.

\section{Base types}
% \label{disjointness}

No object satisfies more than one of the following predicates:

\begin{scheme}
boolean?          pair?
symbol?           number?
char?             string?
vector?           procedure?
null?%
\end{scheme}

These predicates define the base types {\em boolean}, {\em pair}, {\em
symbol}, {\em number}, {\em char} (or {\em character}), {\em string}, {\em
vector}, and {\em procedure}.  Moreover, the empty list is a special
object of its own type.
\mainindex{type}\schindex{boolean?}\schindex{pair?}\schindex{symbol?}
\schindex{number?}\schindex{char?}\schindex{string?}\schindex{vector?}
\schindex{procedure?}\index{empty list}\schindex{null?}

Note that, although there is a separate boolean type, any Scheme value
can be used as a boolean value for the purpose of a conditional test;
see section~\ref{booleanvaluessection}.

\section{Definitions}
% \label{defines}

Definitions\mainindex{definition} may appear within a
\meta{top-level body} (section~\ref{programsyntaxsection}),
at the top of a \meta{library body} (section~\ref{librarysyntaxsection}),
or at the top of a \meta{body} (section~\ref{bodiessection}).

A \hyper{definition} may be a variable definition
(section~\ref{variabledefinitionsection}) or
keyword definition
(section~\ref{variabledefinitionsection}).
Macro uses that expand into definitions or groups of
definitions (packaged in a {\cf begin}, {\cf let-syntax}, or
{\cf letrec-syntax} form; see section~\ref{begin}) may also appear
wherever other definitions may appear.

\subsection{Variable definitions}
% \label{variabledefinitionsection}

The {\cf define} form described in this section is a
\hyper{definition}\mainindex{definition} used to create variable bindings
and may appear anywhere other definitions may appear.

\begin{entry}{%
\proto{define}{ \hyper{variable} \hyper{expression}}{\exprtype}
\rproto{define}{ \hyper{variable}}{\exprtype}
\pproto{(define (\hyper{variable} \hyper{formals}) \hyper{body})}{\exprtype}
\pproto{(define (\hyper{variable} .\ \hyper{formal}) \hyper{body})}{\exprtype}}


The first from of {\cf define} binds \hyper{variable} to a new
location before assigning the value of \hyper{expression} to it.
\begin{scheme}
(define add3
  (lambda (x) (+ x 3)))
(add3 3)                            \ev  6
(define first car)
(first '(1 2))                      \ev  1%
\end{scheme}
%
The continuation of \hyper{expression} should not be invoked more than
once.

\implresp Implementations should detect that the
continuation of \hyper{expression} is invoked more than once.
If the implementation detects this, it must raise an
exception with condition type {\cf\&assertion}.

The second form of {\cf define} is equivalent to
\begin{scheme}
(define \hyper{variable} \hyper{unspecified})%
\end{scheme}
where \hyper{unspecified} is a side-effect-free expression returning
an unspecified value.

In the third form of {\cf define}, \hyper{formals} must be either a
sequence of zero or more variables, or a sequence of one or more
variables followed by a dot {\cf .} and another variable (as
in a lambda expression, see section~\ref{lambda}).  This form is equivalent to
\begin{scheme}
(define \hyper{variable}
  (lambda (\hyper{formals}) \hyper{body}))\rm.%
\end{scheme}

In the fourth form of {\cf define}, 
\hyper{formal} must be a single
variable.  This form is equivalent to
\begin{scheme}
(define \hyper{variable}
  (lambda \hyper{formal} \hyper{body}))\rm.%
\end{scheme}
\end{entry}

\subsection{Syntax definitions}
% \label{syntaxdefinitionsection}

The {\cf define-syntax} form described in this section is a
\hyper{definition}\mainindex{definition} used to create keyword bindings
and may appear anywhere other definitions may appear.

\begin{entry}{%
\proto{define-syntax}{ \hyper{keyword} \hyper{expression}}{\exprtype}}

Binds \hyper{keyword} to the value of
\hyper{expression}, which must evaluate, at macro-expansion
time, to a transformer.  Macro transformers can be created using the
{\cf syntax-rules} and {\cf identifier-syntax} forms described in
section~\ref{syntaxrulessection}.  See library
section~\extref{lib:transformerssection}{Transformers} for a more
complete description of transformers.

Keyword bindings established by {\cf define-syntax} are visible
throughout the body in which they appear, except where shadowed by
other bindings, and nowhere else, just like variable bindings established
by {\cf define}.
All bindings established by a set of definitions, whether
keyword or variable definitions, are visible within the definitions
themselves.

\implresp The implementation should detect if the value of
\hyper{expression} cannot possibly be a transformer.

Example:

\begin{scheme}
(let ()
  (define even?
    (lambda (x)
      (or (= x 0) (odd? (- x 1)))))
  (define-syntax odd?
    (syntax-rules ()
      ((odd?  x) (not (even? x)))))
  (even? 10))                       \ev \schtrue{}%
\end{scheme}

An implication of the left-to-right processing order
(section~\ref{expansionchapter}) is that one definition can
affect whether a subsequent form is also a definition.  

Example:

\begin{scheme}
(let ()
  (define-syntax bind-to-zero
    (syntax-rules ()
      ((bind-to-zero id) (define id 0))))
  (bind-to-zero x)
  x) \ev 0%
\end{scheme}

The behavior is unaffected by any binding for
{\cf bind-to-zero} that might appear outside of the {\cf let}
expression.
\end{entry}

\section{Bodies}
% \label{bodiessection}

\index{body}The \hyper{body} of a \ide{lambda}, \ide{let}, \ide{let*},
\ide{let-values}, \ide{let*-values}, \ide{letrec}, or \ide{letrec*}
expression, or that of a definition with a body
consists of zero or more definitions followed by one or more
expressions.

{\cf \hyper{definition} \ldots{} \hyperi{expression} \hyperii{expression} \ldots}

Each identifier defined by a
definition is local to the \hyper{body}.  That is, the identifier is
bound, and the region of the binding is the
entire \hyper{body} (see section~\ref{variablesection}).

Example:
%
\begin{scheme}
(let ((x 5))
  (define foo (lambda (y) (bar x y)))
  (define bar (lambda (a b) (+ (* a b) a)))
  (foo (+ x 3)))                \ev  45%
\end{scheme}
%
When {\cf begin}, {\cf let-syntax}, or {\cf letrec-syntax} forms
occur in a body prior to the first
expression, they are spliced into the body; see section~\ref{begin}.
Some or all of the body, including portions wrapped in {\cf begin},
{\cf let-syntax}, or {\cf letrec-syntax}
forms, may be specified by a macro use
(see section~\ref{macrosection}).

An expanded \hyper{body} (see chapter~\ref{expansionchapter})
containing variable definitions can
always be converted into an equivalent {\cf letrec*}
expression.  For example, the {\cf let} expression in the above
example is equivalent to

\begin{scheme}
(let ((x 5))
  (letrec* ((foo (lambda (y) (bar x y)))
            (bar (lambda (a b) (+ (* a b) a))))
    (foo (+ x 3))))%
\end{scheme}

\section{Expressions}
% \label{expressionsection}

The entries in this section describe the expressions of the \rsixlibrary{base}
library, which may occur in the position of the \hyper{expression}
syntactic variable in addition to the primitive
expression types as described in
section~\ref{primitiveexpressionsection}.

\subsection{Quotation}\unsection
% \label{quotesection}

\begin{entry}{%
\proto{quote}{ \hyper{datum}}{\exprtype}}

\syntax \hyper{Datum} should be a syntactic datum.

\semantics
{\cf (quote \hyper{datum})} evaluates to the datum value
represented by \hyper{datum}
(see
section~\ref{datumsyntaxsection}).  This notation is used to include
constants.

\begin{scheme}%
(quote a)                     \ev  a
(quote \sharpsign(a b c))     \ev  \#(a b c)
(quote (+ 1 2))               \ev  (+ 1 2)%
\end{scheme}

As noted in section~\ref{abbreviationsection}, {\cf (quote \hyper{datum})}
may be abbreviated as \singlequote\hyper{datum}:

\begin{scheme}
'"abc"               \ev  "abc"
'145932              \ev  145932
'a                   \ev  a
'\#(a b c)           \ev  \#(a b c)
'()                  \ev  ()
'(+ 1 2)             \ev  (+ 1 2)
'(quote a)           \ev  (quote a)
''a                  \ev  (quote a)%
\end{scheme}

As noted in section~\ref{storagemodel}, constants are immutable.

\begin{note}
  Different constants that are the value of a {\cf quote} expression may
  share the same locations.
\end{note}
\end{entry}

\subsection{Procedures}\unsection
% \label{lamba}

\begin{entry}{%
\proto{lambda}{ \hyper{formals} \hyper{body}}{\exprtype}}

\syntax
\hyper{Formals} must be a formal parameter list as described below,
and \hyper{body} must be as described in section~\ref{bodiessection}.

\semantics
\vest A \lambdaexp{} evaluates to a procedure.  The environment in
effect when the \lambdaexp{} is evaluated is remembered as part of the
procedure.  When the procedure is later called with some 
arguments, the environment in which the \lambdaexp{} was evaluated is
extended by binding the variables in the parameter list to
fresh locations, and the resulting argument values are stored
in those locations.  Then, the expressions in the body of the \lambdaexp{}
(which may contain definitions and thus represent a {\cf
  letrec*} form, see section~\ref{bodiessection}) are evaluated
sequentially in the extended environment.
The results of the last expression in the body are returned as
the results of the procedure call.

\begin{scheme}
(lambda (x) (+ x x))      \ev  {\em{}a procedure}
((lambda (x) (+ x x)) 4)  \ev  8

((lambda (x)
   (define (p y)
     (+ y 1))
   (+ (p x) x))
 5) \ev 11

(define reverse-subtract
  (lambda (x y) (- y x)))
(reverse-subtract 7 10)         \ev  3

(define add4
  (let ((x 4))
    (lambda (y) (+ x y))))
(add4 6)                        \ev  10%
\end{scheme}

\hyper{Formals} must have one of the following forms:

\begin{itemize}
\item {\tt(\hyperi{variable} \dotsfoo)}:
The procedure takes a fixed number of arguments; when the procedure is
called, the arguments are stored in the bindings of the
corresponding variables.

\item \hyper{variable}:
The procedure takes any number of arguments; when the procedure is
called, the sequence of arguments is converted into a newly
allocated list, and the list is stored in the binding of the
\hyper{variable}.

\item {\tt(\hyperi{variable} \dotsfoo{} \hyper{variable$_{n}$}\ {\bf.}\
\hyper{variable$_{n+1}$})}:
If a period {\cf .} precedes the last variable, then
the procedure takes $n$ or more arguments, where $n$ is the
number of parameters before the period (there must
be at least one).
The value stored in the binding of the last variable is a
newly allocated
list of the arguments left over after all the other 
arguments have been matched up against the other parameters.
\end{itemize}

\begin{scheme}
((lambda x x) 3 4 5 6)          \ev  (3 4 5 6)
((lambda (x y . z) z)
 3 4 5 6)                       \ev  (5 6)%
\end{scheme}

Any \hyper{variable} must not appear more than once in
\hyper{formals}.
\end{entry}


\subsection{Conditionals}\unsection

\begin{entry}{%
\proto{if}{ \hyper{test} \hyper{consequent} \hyper{alternate}}{\exprtype}
\rproto{if}{ \hyper{test} \hyper{consequent}}{\exprtype}}  %\/ if hyper = italic

\syntax
\hyper{Test}, \hyper{consequent}, and \hyper{alternate} must be 
expressions.

\semantics
An {\cf if} expression is evaluated as follows: first,
\hyper{test} is evaluated.  If it yields a true value\index{true} (see
section~\ref{booleanvaluessection}), then \hyper{consequent} is evaluated and
its values are returned.  Otherwise \hyper{alternate} is evaluated and its
values are returned.  If \hyper{test} yields \schfalse{} and no
\hyper{alternate} is specified, then the result of the expression \isunspecified.

\begin{scheme}
(if (> 3 2) 'yes 'no)           \ev  yes
(if (> 2 3) 'yes 'no)           \ev  no
(if (> 3 2)
    (- 3 2)
    (+ 3 2))                    \ev  1
(if \#f \#f)                    \ev \theunspecified%
\end{scheme}

The \hyper{consequent} and \hyper{alternate} expressions are in
tail context if the {\cf if} expression itself is; see
section~\ref{basetailcontextsection}.
\end{entry}


\subsection{Assignments}\unsection
% \label{assignment}

\begin{entry}{%
\proto{set!}{ \hyper{variable} \hyper{expression}}{\exprtype}}

\hyper{Expression} is evaluated, and the resulting value is stored in
the location to which \hyper{variable} is bound.  \hyper{Variable} must
be bound either in some region\index{region} enclosing the {\cf set!}\ expression
or at the top level.  The result of the {\cf set!}
expression \isunspecified.

\begin{scheme}
(let ((x 2))
  (+ x 1)
  (set! x 4)
  (+ x 1)) \ev  5%
\end{scheme}

It is a syntax violation if \hyper{variable} refers to an
immutable binding.

\begin{note}
  The identifier {\cf set!} is exported with level $1$ as well.  See
  section~\ref{identifier-syntax}.
\end{note}
\end{entry}

\subsection{Derived conditionals}\unsection

\begin{entry}{%
\proto{cond}{ \hyperi{cond clause} \hyperii{cond clause} \dotsfoo}{\exprtype}
\litproto{=>}
\litproto{else}}

\syntax
Each \hyper{cond clause} must be of the form
\begin{scheme}
(\hyper{test} \hyperi{expression} \dotsfoo)%
\end{scheme}
where \hyper{test} is an expression.  Alternatively, a \hyper{cond clause} may be
of the form
\begin{scheme}
(\hyper{test} => \hyper{expression})%
\end{scheme}
The last \hyper{cond clause} may be
an ``{\cf else} clause'', which has the form
\begin{scheme}
(else \hyperi{expression} \hyperii{expression} \dotsfoo)\rm.%
\end{scheme}

\semantics
A {\cf cond} expression is evaluated by evaluating the \hyper{test}
expressions of successive \hyper{cond clause}s in order until one of them
evaluates to a true value\index{true} (see
section~\ref{booleanvaluessection}).  When a \hyper{test} evaluates to a true
value, then the remaining \hyper{expression}s in its \hyper{cond clause} are
evaluated in order, and the results of the last \hyper{expression} in the
\hyper{cond clause} are returned as the results of the entire {\cf cond}
expression.  If the selected \hyper{cond clause} contains only the
\hyper{test} and no \hyper{expression}s, then the value of the
\hyper{test} is returned as the result.  If the selected \hyper{cond clause} uses the
\ide{=>} alternate form, then the \hyper{expression} is evaluated.
Its value must be a procedure.  This procedure should accept one argument; it is
called on the value of the \hyper{test} and the values returned by this
procedure are returned by the {\cf cond} expression.
If all \hyper{test}s evaluate
to \schfalse, and there is no {\cf else} clause, then 
the conditional expression returns \unspecifiedreturn; if there is an {\cf else}
clause, then its \hyper{expression}s are evaluated, and the values of
the last one are returned.

\begin{scheme}
(cond ((> 3 2) 'greater)
      ((< 3 2) 'less))         \ev  greater%

(cond ((> 3 3) 'greater)
      ((< 3 3) 'less)
      (else 'equal))            \ev  equal%

(cond ('(1 2 3) => cadr)
      (else \schfalse{}))         \ev  2%
\end{scheme}

For a \hyper{cond clause} of one of the following forms
%
\begin{scheme}
(\hyper{test} \hyperi{expression} \dotsfoo)
(else \hyperi{expression} \hyperii{expression} \dotsfoo)%
\end{scheme}
%
the last \hyper{expression} is in tail context if the {\cf cond} form
itself is.  For a \hyper{cond clause} of the form
\begin{scheme}
(\hyper{test} => \hyper{expression})%
\end{scheme}
the (implied) call to the procedure that results from the evaluation
of \hyper{expression} is in a tail context if the {\cf cond} form
itself is. See section~\ref{basetailcontextsection}.

A sample definition of {\cf cond} in terms of simpler forms is in
appendix~\ref{derivedformsappendix}.
\end{entry}


\begin{entry}{%
\proto{case}{ \hyper{key} \hyperi{case clause} \hyperii{case clause} \dotsfoo}{\exprtype}}

\syntax
\hyper{Key} must be an expression.  Each \hyper{case clause} must have one of
the following forms:
\begin{scheme}
((\hyperi{datum} \dotsfoo) \hyperi{expression} \hyperii{expression} \dotsfoo)
(else \hyperi{expression} \hyperii{expression} \dotsfoo)%
\end{scheme}
\schindex{else}
The second form, which specifies an ``{\cf else} clause'',
may only appear as the last \hyper{case clause}.
Each \hyper{datum} is an external representation of some object.
The data represented by the \hyper{datum}s need not be distinct.

\semantics
A {\cf case} expression is evaluated as follows.  \hyper{Key} is
evaluated and its result is compared using {\cf eqv?} (see
section~\ref{eqv?}) against the data
represented by the \hyper{datum}s of each \hyper{case clause} in turn, proceeding
in order from left to right through the set of clauses.  If the
result of evaluating \hyper{key} is equivalent to a datum of a \hyper{case clause}, the
corresponding \hyper{expression}s are evaluated from left
to right and the results of the last expression in the \hyper{case clause} are
returned as the results of the {\cf case} expression.  Otherwise, the
comparison process continues.  If the result of
evaluating \hyper{key} is different from every datum in each set, then if
there is an {\cf else} clause its expressions are evaluated and the
results of the last are the results of the {\cf case} expression;
otherwise the {\cf case} expression returns \unspecifiedreturn.

\begin{scheme}
(case (* 2 3)
  ((2 3 5 7) 'prime)
  ((1 4 6 8 9) 'composite))     \ev  composite
(case (car '(c d))
  ((a) 'a)
  ((b) 'b))                     \ev  \theunspecified
(case (car '(c d))
  ((a e i o u) 'vowel)
  ((w y) 'semivowel)
  (else 'consonant))            \ev  consonant%
\end{scheme}

The last \hyper{expression} of a \hyper{case clause} is in tail
context if the {\cf case} expression itself is; see
section~\ref{basetailcontextsection}.

% A sample definition of {\cf case} in terms of simpler forms is in
% appendix~\ref{derivedformsappendix}.
\end{entry}


\begin{entry}{%
\proto{and}{ \hyperi{test} \dotsfoo}{\exprtype}}

\syntax The \hyper{test}s must be expressions.

\semantics If there are no \hyper{test}s, \schtrue{} is returned.
Otherwise, the \hyper{test} expressions are evaluated from left to
right until a \hyper{test} returns \schfalse{} or the last
\hyper{test} is reached.  In the former case, the {\cf and} expression
returns \schfalse{} without evaluating the remaining expressions.
In the latter case, the last expression is evaluated and its values
are returned.

\begin{scheme}
(and (= 2 2) (> 2 1))           \ev  \schtrue
(and (= 2 2) (< 2 1))           \ev  \schfalse
(and 1 2 'c '(f g))             \ev  (f g)
(and)                           \ev  \schtrue%
\end{scheme}

The {\cf and} keyword could be defined in terms of {\cf if} using {\cf
  syntax-rules} (see section~\ref{syntaxrulessection}) as follows:

\begin{scheme}
(define-syntax \ide{and}
  (syntax-rules ()
    ((and) \sharpfoo{t})
    ((and test) test)
    ((and test1 test2 ...)
     (if test1 (and test2 ...) \sharpfoo{f}))))%
\end{scheme}

The last \hyper{test} expression is in tail context if the {\cf and}
expression itself is; see section~\ref{basetailcontextsection}.
\end{entry}


\begin{entry}{%
\proto{or}{ \hyperi{test} \dotsfoo}{\exprtype}}

\syntax The \hyper{test}s must be expressions.

\semantics If there are no \hyper{test}s, \schfalse{} is returned.
Otherwise, the \hyper{test} expressions are evaluated from left to
right until a \hyper{test} returns a true value \var{val}
(see section~\ref{booleanvaluessection}) or the last
\hyper{test} is reached.  In the former case, the {\cf or} expression
returns \var{val} without evaluating the remaining expressions.
In the latter case, the last expression is evaluated and its values
are returned.

\begin{scheme}
(or (= 2 2) (> 2 1))            \ev  \schtrue
(or (= 2 2) (< 2 1))            \ev  \schtrue
(or \schfalse \schfalse \schfalse) \ev  \schfalse
(or '(b c) (/ 3 0))             \ev  (b c)%
\end{scheme}

The {\cf or} keyword could be defined in terms of {\cf if} using {\cf
  syntax-rules} (see section~\ref{syntaxrulessection}) as follows:

\begin{scheme}
(define-syntax \ide{or}
  (syntax-rules ()
    ((or) \sharpfoo{f})
    ((or test) test)
    ((or test1 test2 ...)
     (let ((x test1))
       (if x x (or test2 ...))))))%
\end{scheme}

The last \hyper{test} expression is in tail context if the {\cf or}
expression itself is; see section~\ref{basetailcontextsection}.
\end{entry}


\subsection{Binding constructs}

The binding constructs described in this section
create local bindings for variables that are visible only in a
delimited region.  The syntax of the 
constructs
{\cf let}, {\cf let*}, {\cf letrec}, and {\cf letrec*}
 is identical, but they differ in the regions\index{region}
(see section~\ref{variablesection}) they establish
for their variable bindings and in the order in which the values for
the bindings are computed.  In a {\cf let} expression, the initial
values are computed before any of the variables become bound; in a
{\cf let*} expression, the bindings and evaluations are performed
sequentially.  In a {\cf letrec} or {\cf letrec*}
expression, all the bindings are in
effect while their initial values are being computed, thus allowing
mutually recursive definitions.  In a {\cf letrec} expression, the
initial values are computed before being assigned to the variables;
in a {\cf letrec*}, the evaluations and assignments are performed
sequentially.

In addition, the binding constructs {\cf let-values} and {\cf
  let*-values} generalize {\cf let} and {\cf let*} to allow multiple
variables to be bound to the results of expressions that evaluate to
multiple values.
They are analogous to {\cf let} and {\cf let*} in the
way they establish regions: in a {\cf let-values} expression, the
initial values are computed before any of the variables become bound;
in a {\cf let*-values} expression, the bindings are performed
sequentially. 

Sample definitions of all the binding forms of this section in terms
of simpler forms are in appendix~\ref{derivedformsappendix}.

\begin{entry}{%
\proto{let}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{Bindings} must have the form
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
where each \hyper{init} is an expression, and \hyper{body} 
is as described in section~\ref{bodiessection}.  
Any variable must not appear more than once in the \hyper{variable}s.

\semantics
The \hyper{init}s are evaluated in the current environment (in some
unspecified order), the \hyper{variable}s are bound to fresh locations
holding the results, the \hyper{body} is evaluated in the extended
environment, and the values of the last expression of \hyper{body}
are returned.  Each binding of a \hyper{variable} has \hyper{body} as its
region.\index{region}

\begin{scheme}
(let ((x 2) (y 3))
  (* x y))                      \ev  6

(let ((x 2) (y 3))
  (let ((x 7)
        (z (+ x y)))
    (* z x)))                   \ev  35%
\end{scheme}

See also named {\cf let}, section \ref{namedlet}.

\end{entry}


\begin{entry}{%
\proto{let*}{ \hyper{bindings} \hyper{body}}{\exprtype}}\nobreak

\nobreak
\syntax
\hyper{Bindings} must have the form
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
where each \hyper{init} is an expression, and \hyper{body} 
is as described in section~\ref{bodiessection}.

\semantics
The {\cf let*} form is similar to {\cf let}, but the \hyper{init}s are
evaluated and bindings created sequentially from left to right, with
the region\index{region} of each binding including the bindings to
its right as well as \hyper{body}.  Thus the second \hyper{init} is evaluated
in an environment in which the first binding is visible and initialized,
and so on.

\begin{scheme}
(let ((x 2) (y 3))
  (let* ((x 7)
         (z (+ x y)))
    (* z x)))             \ev  70%
\end{scheme}

\begin{note}
  While the variables bound by a {\cf let} expression must be distinct,
  the variables bound by a {\cf let*} expression need not be distinct.
\end{note}
\end{entry}

\begin{entry}{%
\proto{letrec}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{Bindings} must have the form
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
where each \hyper{init} is an expression, and \hyper{body} 
is as described in section~\ref{bodiessection}.  Any
variable must not appear more than once in the
\hyper{variable}s.

\semantics
The \hyper{variable}s are bound to fresh locations, the \hyper{init}s
are evaluated in the resulting environment (in
some unspecified order), each \hyper{variable} is assigned to the result
of the corresponding \hyper{init}, the \hyper{body} is evaluated in the
resulting environment, and the values of the last expression in
\hyper{body} are returned.  Each binding of a \hyper{variable} has the
entire {\cf letrec} expression as its region\index{region}, making it possible to
define mutually recursive procedures.

\begin{scheme}
%(letrec ((x 2) (y 3))
%  (letrec ((foo (lambda (z) (+ x y z))) (x 7))
%    (foo 4)))                   \ev  14
%
(letrec ((even?
          (lambda (n)
            (if (zero? n)
                \schtrue
                (odd? (- n 1)))))
         (odd?
          (lambda (n)
            (if (zero? n)
                \schfalse
                (even? (- n 1))))))
  (even? 88))   
                \ev  \schtrue%
\end{scheme}

It should be possible
to evaluate each \hyper{init} without assigning or referring to the
value of any \hyper{variable}.  In the most
common uses of {\cf letrec}, all the \hyper{init}s are \lambdaexp{}s
and the restriction is satisfied automatically.
Another restriction is that the continuation of each \hyper{init} should not be invoked
more than once.

\implresp Implementations must detect references to a \hyper{variable} during the
evaluation of the \hyper{init} expressions (using one particular
evaluation order and order of evaluating the \hyper{init} expressions).
If an implementation detects such a violation of the
restriction, it must raise an exception with condition type
{\cf\&assertion}.
Implementations may or may not detect that the continuation of each
\hyper{init} is invoked more than once.  However, if the
implementation detects this, it must raise an exception with condition
type {\cf\&assertion}.
\end{entry}

\begin{entry}{%
\proto{letrec*}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{Bindings} must have the form
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
where each \hyper{init} is an expression, and \hyper{body} 
is as described in section~\ref{bodiessection}. 
Any variable must not appear more than once in the
\hyper{variable}s.

\semantics
The \hyper{variable}s are bound to fresh locations,
each \hyper{variable} is assigned in left-to-right order to the
result of evaluating the corresponding \hyper{init}, the \hyper{body} is
evaluated in the resulting environment, and the values of the last
expression in \hyper{body} are returned. 
Despite the left-to-right evaluation and assignment order, each binding of
a \hyper{variable} has the entire {\cf letrec*} expression as its
region\index{region}, making it possible to define mutually recursive
procedures.

\begin{scheme}
(letrec* ((p
           (lambda (x)
             (+ 1 (q (- x 1)))))
          (q
           (lambda (y)
             (if (zero? y)
                 0
                 (+ 1 (p (- y 1))))))
          (x (p 5))
          (y x))
  y)
                \ev  5%
\end{scheme}

It must be possible
to evaluate each \hyper{init} without assigning or referring to the value
of the corresponding \hyper{variable} or the \hyper{variable} of any of
the bindings that follow it in \hyper{bindings}.
Another restriction is that the continuation of each \hyper{init} should not be invoked
more than once.

\implresp Implementations must, during the evaluation of an
\hyper{init} expression, detect references to the
value of the corresponding \hyper{variable} or the \hyper{variable} of
any of the bindings that follow it in \hyper{bindings}.
If an implementation detects such a
violation of the restriction, it must raise an exception with
condition type {\cf\&assertion}.  Implementations may or may not
detect that the continuation of each \hyper{init} is invoked more than
once.  However, if the implementation detects this, it must raise an
exception with condition type {\cf\&assertion}.
\end{entry}

\begin{entry}{%
\proto{let-values}{ \hyper{mv-bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{Mv-bindings} must have the form
\begin{scheme}
((\hyperi{formals} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
where each \hyper{init} is an expression, and \hyper{body} 
is as described in section~\ref{bodiessection}.  
Any variable must not appear more
than once in the set of \hyper{formals}.

\semantics The \hyper{init}s are evaluated in the current environment
(in some unspecified order), and the variables occurring in the
\hyper{formals} are bound to fresh locations containing the values
returned by the \hyper{init}s, where the \hyper{formals} are matched
to the return values in the same way that the \hyper{formals} in a
\lambdaexp{} are matched to the arguments in a procedure call.
Then, the \hyper{body} is evaluated in the extended environment, and the
values of the last expression of \hyper{body} are returned.
Each binding of a variable has \hyper{body} as its
region.\index{region}
If the \hyper{formals} do not match, an exception with condition type
{\cf\&assertion} is raised.

\begin{scheme}
(let-values (((a b) (values 1 2))
             ((c d) (values 3 4)))
  (list a b c d)) \ev (1 2 3 4)

(let-values (((a b . c) (values 1 2 3 4)))
  (list a b c))            \ev (1 2 (3 4))

(let ((a 'a) (b 'b) (x 'x) (y 'y))
  (let-values (((a b) (values x y))
               ((x y) (values a b)))
    (list a b x y)))       \ev (x y a b)%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{let*-values}{ \hyper{mv-bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{Mv-bindings} must have the form
\begin{scheme}
((\hyperi{formals} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
where each \hyper{init} is an expression, and \hyper{body} 
is as described in section~\ref{bodiessection}.
In each \hyper{formals}, any variable must not appear more than once.

\semantics
The {\cf let*-values} form is similar to {\cf let-values}, but the \hyper{init}s are
evaluated and bindings created sequentially from left to right, with
the region\index{region} of the bindings of each \hyper{formals} including
the bindings to its right as well as \hyper{body}. 
Thus the second \hyper{init} is evaluated in an environment in which the
bindings of the first \hyper{formals} is visible and initialized, and so
on.

\begin{scheme}
(let ((a 'a) (b 'b) (x 'x) (y 'y))
  (let*-values (((a b) (values x y))
                ((x y) (values a b)))
    (list a b x y)))  \ev (x y x y)%
\end{scheme}

\begin{note}
  While all of the variables bound by a {\cf let-values} expression
  must be distinct, the variables bound by different \hyper{formals} of a
  {\cf let*-values} expression need not be distinct.
\end{note}

\end{entry}

\subsection{Sequencing}\unsection

\begin{entry}{%
\proto{begin}{ \hyper{form} \dotsfoo}{\exprtype}
\rproto{begin}{ \hyper{expression} \hyper{expression} \dotsfoo}{\exprtype}}

The \hyper{begin} keyword has two different roles, depending on its
context:
\begin{itemize}
\item It may appear as a form in a \hyper{body} (see
  section~\ref{bodiessection}), \hyper{library body} (see
  section~\ref{librarybodysection}), or \hyper{top-level body} (see
  chapter~\ref{programchapter}), or directly nested in a {\cf begin}
  form that appears in a body.  In this case, the {\cf begin} form
  must have the shape specified in the first header line.  This use of
  {\cf begin} acts as a \defining{splicing} form---the forms inside
  the \hyper{body} are spliced into the surrounding body, as if the
  {\cf begin} wrapper were not actually present.
  
  A {\cf begin} form in a \hyper{body} or \hyper{library body} must
  be non-empty if it appears after the first \hyper{expression}
  within the body.
\item It may appear as an ordinary expression and must have the shape
  specified in the second header line.  In this case, the
  \hyper{expression}s are evaluated sequentially from left to right,
  and the values of the last \hyper{expression} are returned.
  This expression type is used to sequence side effects such as
  assignments or input
  and output.
\end{itemize}

\begin{scheme}
(define x 0)

(begin (set! x 5)
       (+ x 1))                  \ev  6

(begin (display "4 plus 1 equals ")
       (display (+ 4 1)))      \ev  \unspecified
 \>{\em and prints}  4 plus 1 equals 5%
\end{scheme}
\end{entry}

\section{Equivalence predicates}
% \label{equivalencesection}

A \defining{predicate} is a procedure that always returns a boolean
value (\schtrue{} or \schfalse).  An \defining{equivalence predicate} is
the computational analogue of a mathematical equivalence relation (it is
symmetric, reflexive, and transitive).  Of the equivalence predicates
described in this section, {\cf eq?}\ is the finest or most
discriminating, and {\cf equal?}\ is the coarsest.  The {\cf eqv?} predicate is
slightly less discriminating than {\cf eq?}.  \todo{Pitman doesn't like
this paragraph.  Lift the discussion from the Maclisp manual.  Explain
why there's more than one predicate.}


\begin{entry}{%
\proto{eqv?}{ \vari{obj} \varii{obj}}{procedure}}

The {\cf eqv?} procedure defines a useful equivalence relation on objects.
Briefly, it returns \schtrue{} if \vari{obj} and \varii{obj} should
normally be regarded as the same object and \schfalse{} otherwise.  This relation is left slightly
open to interpretation, but the following partial specification of
{\cf eqv?} must hold for all implementations.

The {\cf eqv?} procedure returns \schtrue{} if one of the following holds:

\begin{itemize}
\item \vari{Obj} and \varii{obj} are both booleans and are the same
  according to the {\cf boolean=?} procedure (section~\ref{boolean=?}).

\item \vari{Obj} and \varii{obj} are both symbols and are the same
  according to the {\cf symbol=?} procedure (section~\ref{symbol=?}).

\item \vari{Obj} and \varii{obj} are both exact\index{exact} number objects
  and are numerically equal (see {\cf =}, 
  section~\ref{genericarithmeticsection}).

\item \vari{Obj} and \varii{obj} are both inexact\index{inexact}
  number objects, are numerically
  equal (see {\cf =}, section~\ref{genericarithmeticsection}), and
  yield the same results (in the sense of {\cf eqv?}) when passed
  as arguments to any other procedure that can be defined
  as a finite composition of Scheme's standard arithmetic
  procedures.

\item \vari{Obj} and \varii{obj} are both characters and are the same
character according to the {\cf char=?} procedure
(section~\ref{charactersection}).

\item Both \vari{obj} and \varii{obj} are the empty list.

\item \vari{Obj} and \varii{obj} are objects such as pairs, vectors, bytevectors
  (library chapter~\extref{lib:bytevectorschapter}{Bytevectors}),
  strings, hashtables, records (library
  chapter~\extref{lib:recordschapter}{Records}), ports (library
  section~\extref{lib:portsiosection}{Port I/O}), or hashtables
  (library chapter~\extref{lib:hashtablechapter}{Hash tables}) that
  refer to the same locations in the store (section~\ref{storagemodel}).

\item \vari{Obj} and \varii{obj} are record-type descriptors that are
  specified to be {\cf eqv?} in library
  section~\extref{lib:recordsproceduralsection}{Procedural layer}.
\end{itemize}

The {\cf eqv?} procedure returns \schfalse{} if one of the following holds:

\begin{itemize}
\item \vari{Obj} and \varii{obj} are of different types
(section~\ref{disjointness}).

\item \vari{Obj} and \varii{obj} are booleans for which the {\cf
    boolean=?} procedure returns \schfalse.

\item \vari{Obj} and \varii{obj} are symbols for which the {\cf
    symbol=?} procedure returns \schfalse.

\item One of \vari{obj} and \varii{obj} is an exact number object but the other is
        an inexact number object.

\item \vari{Obj} and \varii{obj} are rational number objects for which the {\cf =} procedure
  returns \schfalse{}.

\item \vari{Obj} and \varii{obj} yield different results (in the sense of
  {\cf eqv?}) when passed as arguments to any other procedure
  that can be defined as a finite composition of Scheme's
  standard arithmetic procedures.

\item \vari{Obj} and \varii{obj} are characters for which the {\cf char=?}
  procedure returns \schfalse{}.

\item One of \vari{obj} and \varii{obj} is the empty list, but the other is not.

\item \vari{Obj} and \varii{obj} are objects such as pairs, vectors,
  bytevectors (library
  chapter~\extref{lib:bytevectorschapter}{Bytevectors}), strings,
  records (library
  chapter~\extref{lib:recordschapter}{Records}), ports (library
  section~\extref{lib:portsiosection}{Port I/O}), or hashtables
  (library chapter~\extref{lib:hashtablechapter}{Hashtables}) that
  refer to distinct locations.

\item \vari{Obj} and \varii{obj} are pairs, vectors, strings, or
  records, or hashtables, where the applying the same accessor (i.e.\
  {\cf car}, {\cf cdr}, {\cf vector-ref}, {\cf string-ref}, or record
  accessors) to both yields results for which {\cf eqv?} returns
  \schfalse.

\item \vari{Obj} and \varii{obj} are procedures that would behave differently
(return different values or have different side effects) for some arguments.

\end{itemize}

\begin{note}
  The {\cf eqv?} procedure returning \schtrue{} when \vari{obj} and
  \varii{obj} are number objects does not imply that {\cf =} would also
  return \schtrue{} when called with \vari{obj} and \varii{obj} as
  arguments.
\end{note}


\begin{scheme}
(eqv? 'a 'a)                     \ev  \schtrue
(eqv? 'a 'b)                     \ev  \schfalse
(eqv? 2 2)                       \ev  \schtrue
(eqv? '() '())                   \ev  \schtrue
(eqv? 100000000 100000000)       \ev  \schtrue
(eqv? (cons 1 2) (cons 1 2))     \ev  \schfalse
(eqv? (lambda () 1)
      (lambda () 2))             \ev  \schfalse
(eqv? \#f 'nil)                  \ev  \schfalse%
\end{scheme}

The following examples illustrate cases in which the above rules do
not fully specify the behavior of {\cf eqv?}.  All that can be said
about such cases is that the value returned by {\cf eqv?} must be a
boolean.

\begin{scheme}
(let ((p (lambda (x) x)))
  (eqv? p p))                    \ev  \unspecified
(eqv? "" "")             \ev  \unspecified
(eqv? '\#() '\#())         \ev  \unspecified
(eqv? (lambda (x) x)
      (lambda (x) x))    \ev  \unspecified
(eqv? (lambda (x) x)
      (lambda (y) y))    \ev  \unspecified
(eqv? +nan.0 +nan.0)             \ev \unspecified%
\end{scheme}

The next set of examples shows the use of {\cf eqv?}\ with procedures
that have local state.  Calls to {\cf gen-counter} must return a
distinct procedure every time, since each procedure has its own
internal counter.  Calls to {\cf gen-loser} return procedures that
behave equivalently when called.  However, {\cf eqv?} may
not detect this equivalence.

\begin{scheme}
(define gen-counter
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) n))))
(let ((g (gen-counter)))
  (eqv? g g))           \ev  \unspecified
(eqv? (gen-counter) (gen-counter))
                        \ev  \schfalse
(define gen-loser
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) 27))))
(let ((g (gen-loser)))
  (eqv? g g))           \ev  \unspecified
(eqv? (gen-loser) (gen-loser))
                        \ev  \unspecified

(letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
         (g (lambda () (if (eqv? f g) 'both 'g))))
  (eqv? f g)) \ev  \unspecified

(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
         (g (lambda () (if (eqv? f g) 'g 'both))))
  (eqv? f g)) \ev  \schfalse%
\end{scheme}

Implementations may
share structure between constants where appropriate.
Furthermore, a constant may be copied at any time by the implementation so
as to exist simultaneously in different sets of locations, as noted in
section~\ref{quote}.
Thus the value of {\cf eqv?} on constants is sometimes
implementation-dependent.

\begin{scheme}
(eqv? '(a) '(a))                 \ev  \unspecified
(eqv? "a" "a")                   \ev  \unspecified
(eqv? '(b) (cdr '(a b)))         \ev  \unspecified
(let ((x '(a)))
  (eqv? x x))                    \ev  \schtrue%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{eq?}{ \vari{obj} \varii{obj}}{procedure}}

The {\cf eq?} predicate is similar to {\cf eqv?}\ except that in some cases it is
capable of discerning distinctions finer than those detectable by
{\cf eqv?}.

The {\cf eq?}\ and {\cf eqv?} predicates are guaranteed to have the
same behavior on symbols, booleans, the empty list, pairs, procedures,
non-empty strings, bytevectors, and vectors, and records.  The
behavior of {\cf eq?} on number objects and characters is
implementation-dependent, but it always returns either \schtrue{} or
\schfalse{}, and returns \schtrue{} only when {\cf eqv?}\ would also
return \schtrue.  The {\cf eq?} predicate may also behave differently
from {\cf eqv?} on empty vectors, empty bytevectors, and empty strings.

\begin{scheme}
(eq? 'a 'a)                     \ev  \schtrue
(eq? '(a) '(a))                 \ev  \unspecified
(eq? (list 'a) (list 'a))       \ev  \schfalse
(eq? "a" "a")                   \ev  \unspecified
(eq? "" "")                     \ev  \unspecified
(eq? '() '())                   \ev  \schtrue
(eq? 2 2)                       \ev  \unspecified
(eq? \#\backwhack{}A \#\backwhack{}A) \ev  \unspecified
(eq? car car)                   \ev  \schtrue
(let ((n (+ 2 3)))
  (eq? n n))      \ev  \unspecified
(let ((x '(a)))
  (eq? x x))      \ev  \schtrue
(let ((x '\#()))
  (eq? x x))      \ev  \unspecified
(let ((p (lambda (x) x)))
  (eq? p p))      \ev  \unspecified%
\end{scheme}

\todo{Needs to be explained better above.  How can this be made to be
not confusing?  A table maybe?}

\end{entry}

\begin{entry}{%
\proto{equal?}{ \vari{obj} \varii{obj}}{procedure}}

The {\cf equal?}  predicate returns \schtrue{} if and only if the
(possibly infinite) unfoldings of its arguments into regular trees are
equal as ordered trees.

The {\cf equal?} predicate treats pairs and vectors
as nodes with outgoing edges, uses {\cf
  string=?} to compare strings, uses {\cf
  bytevector=?} to compare bytevectors (see library chapter~\extref{lib:bytevectorschapter}{Bytevectors}),
  and uses {\cf eqv?} to compare other nodes.

\begin{scheme}
(equal? 'a 'a)                  \ev  \schtrue
(equal? '(a) '(a))              \ev  \schtrue
(equal? '(a (b) c)
        '(a (b) c))             \ev  \schtrue
(equal? "abc" "abc")            \ev  \schtrue
(equal? 2 2)                    \ev  \schtrue
(equal? (make-vector 5 'a)
        (make-vector 5 'a))     \ev  \schtrue
(equal? '\#vu8(1 2 3 4 5)
        (u8-list->bytevector
         '(1 2 3 4 5))          \ev  \schtrue
(equal? (lambda (x) x)
        (lambda (y) y))  \ev  \unspecified

(let* ((x (list 'a))
       (y (list 'a))
       (z (list x y)))
  (list (equal? z (list y x))
        (equal? z (list x x))))             \lev  (\schtrue{} \schtrue{})%
\end{scheme}

\begin{note}
  The {\cf equal?} procedure must always terminate, even if its
  arguments contain cycles.
\end{note}

\end{entry}

\section{Procedure predicate}

\begin{entry}{%
\proto{procedure?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a procedure, otherwise returns \schfalse.

\begin{scheme}
(procedure? car)            \ev  \schtrue
(procedure? 'car)           \ev  \schfalse
(procedure? (lambda (x) (* x x)))   
                            \ev  \schtrue
(procedure? '(lambda (x) (* x x)))  
                            \ev  \schfalse%
\end{scheme}

\end{entry}

\section{Arithmetic}
% \label{genericarithmeticsection}

The procedures described here implement arithmetic that is
generic over
the numerical tower described in chapter~\ref{numbertypeschapter}.
The generic procedures described in this section
accept both exact and inexact number objects as arguments,
performing coercions and selecting the appropriate operations
as determined by the numeric subtypes of their arguments.

Library chapter~\extref{lib:numberchapter}{Arithmetic} describes
libraries that define other numerical procedures.

\subsection{Propagation of exactness and inexactness}
% \label{propagationsection}

The procedures listed below must return the mathematically correct exact result
provided all their arguments are exact:

\begin{scheme}
+            -            *
max          min          abs
numerator    denominator  gcd
lcm          floor        ceiling
truncate     round        rationalize
real-part    imag-part    make-rectangular%
\end{scheme}

The procedures listed below must return the correct exact result
provided all their arguments are exact, and no divisors are zero:

\begin{scheme}
/
div          mod           div-and-mod
div0         mod0          div0-and-mod0%
\end{scheme}

Moreover, the procedure {\cf expt} must return the correct exact
result provided its first argument is an exact real number object and
its second argument is an exact integer object.

The general rule is that the generic operations return the correct
exact result when all of their arguments are exact and the result is
mathematically well-defined, but return an inexact result when any
argument is inexact.  Exceptions to this rule include
{\cf sqrt}, {\cf exp}, {\cf log},
{\cf sin}, {\cf cos}, {\cf tan},
{\cf asin}, {\cf acos}, {\cf atan},
{\cf expt}, {\cf make-polar}, {\cf magnitude}, and {\cf angle}, which
may (but are not required to) return inexact results even when
given exact arguments, as indicated in the specification of these
procedures.

One general exception to the rule above is that an implementation may
return an exact result despite inexact arguments if that exact result
would be the correct result for all possible substitutions of exact
arguments for the inexact ones.  An example is {\cf (* 1.0 0)} which
may return either {\cf 0} (exact) or {\cf 0.0} (inexact).

\subsection{Representability of infinities and NaNs}
% \label{infinitiesnanssection}

The specification of the numerical operations is written as though
infinities and NaNs are representable, and specifies many operations
with respect to these number objects in ways that are consistent with the
IEEE-754 standard for binary floating-point arithmetic.  
An implementation of Scheme may or may not represent infinities and
NaNs; however,
an implementation must raise a continuable exception with
condition type {\cf\&no-infinities} or {\cf\&no-nans} (respectively;
see library section~\extref{lib:flonumssection}{Flonums})
whenever it is unable to represent an infinity or NaN as specified. 
In this case, the continuation of the exception
handler is the continuation that otherwise would have received
the infinity or NaN value.  This requirement also applies to
conversions between number objects and external representations, including
the reading of program source code.

\subsection{Semantics of common operations}

Some operations are the semantic basis for several arithmetic
procedures.  The behavior of these operations is described in this
section for later reference.

\subsubsection{Integer division}
% \label{integerdivision}

Scheme's operations for performing integer
division rely on mathematical operations $\mathrm{div}$,
$\mathrm{mod}$, $\mathrm{div}_0$, and
$\mathrm{mod}_0$, that are defined as follows:

$\mathrm{div}$, $\mathrm{mod}$, $\mathrm{div}_0$, and $\mathrm{mod}_0$
each accept two real numbers $x_1$ and $x_2$ as operands, where
$x_2$ must be nonzero.

$\mathrm{div}$ returns an integer, and $\mathrm{mod}$ returns a real.
Their results are specified by
%
\begin{eqnarray*}
x_1~\mathrm{div}~x_2 &=& n_d\\
x_1~\mathrm{mod}~x_2 &=& x_m
\end{eqnarray*}
%
where
%
\begin{displaymath}
\begin{array}{c}
x_1 = n_d \cdot x_2 + x_m\\
0 \leq x_m < |x_2|
\end{array}
\end{displaymath}
%
Examples:
\begin{eqnarray*}
123~\mathrm{div}~10    &=&  12\\
123~\mathrm{mod}~10    &=&  3\\
123~\mathrm{div}~\textrm{$-10$}   &=&  -12\\
123~\mathrm{mod}~\textrm{$-10$}   &=&  3\\
-123~\mathrm{div}~10    &=&  -13\\
-123~\mathrm{mod}~10    &=&  7\\
-123~\mathrm{div}~\textrm{$-10$}   &=&  13\\
-123~\mathrm{mod}~\textrm{$-10$}   &=&  7
\end{eqnarray*}
%
$\mathrm{div}_0$ and $\mathrm{mod}_0$ are like $\mathrm{div}$ and
$\mathrm{mod}$, except the result of $\mathrm{mod}_0$ lies within a
half-open interval centered on zero.  The results are specified by
%
\begin{eqnarray*}
x_1~\mathrm{div}_0~x_2 &=& n_d\\
x_1~\mathrm{mod}_0~x_2 &=& x_m
\end{eqnarray*}
%
where:
%
\begin{displaymath}
\begin{array}{c}
x_1 = n_d \cdot x_2 + x_m\\
-|\frac{x_2}{2}| \leq x_m < |\frac{x_2}{2}|
\end{array}
\end{displaymath}
%
Examples:
%
\begin{eqnarray*}
123~\mathrm{div}_0~10    &=&  12\\
123~\mathrm{mod}_0~10    &=&  3\\
123~\mathrm{div}_0~\textrm{$-10$}   &=&  -12\\
123~\mathrm{mod}_0~\textrm{$-10$}   &=&  3\\
-123~\mathrm{div}_0~10    &=&  -12\\
-123~\mathrm{mod}_0~10    &=&  -3\\
-123~\mathrm{div}_0~\textrm{$-10$}   &=&  12\\
-123~\mathrm{mod}_0~\textrm{$-10$}   &=&  -3
\end{eqnarray*}

\subsubsection{Transcendental functions}
% \label{transcendentalfunctions}

In general, the transcendental functions $\log$, $\sin^{-1}$
(arcsine), $\cos^{-1}$ (arccosine), and $\tan^{-1}$ are multiply
defined.  The value of $\log z$ is defined to be the one whose
imaginary part lies in the range from $-\pi$ (inclusive if $-0.0$ is
distinguished, exclusive otherwise) to $\pi$ (inclusive).  $\log 0$ is
undefined.

The value of $\log z$ for non-real $z$ is defined in terms of log on real numbers as 

\begin{displaymath}
\log z = \log |z| + (\mathrm{angle}~z)i
\end{displaymath}
%
where $\mathrm{angle}~z$ is the angle of $z = a\cdot e^{ib}$ specified
as:
$$\mathrm{angle}~z = b+2\pi n$$
with $-\pi \leq \mathrm{angle}~z\leq \pi$ and $\mathrm{angle}~z =
b+2\pi n$ for some integer $n$.

With the one-argument version of $\log$ defined this way, the values
of the two-argument-version of $\log$, $\sin^{-1} z$, $\cos^{-1} z$,
$\tan^{-1} z$, and the two-argument version of $\tan^{-1}$ are
according to the following formul\ae:
\begin{eqnarray*}
\log z~b &=& \frac{\log z}{\log b}\\
\sin^{-1} z &=& -i \log (i z + \sqrt{1 - z^2})\\
\cos^{-1} z &=& \pi / 2 - \sin^{-1} z\\
\tan^{-1} z &=& (\log (1 + i z) - \log (1 - i z)) / (2 i)\\
\tan^{-1} x~y &=& \mathrm{angle}(x+ yi)
\end{eqnarray*}

The range of $\tan^{-1} x~y$ is as in the following table. The
asterisk (*) indicates that the entry applies to implementations that
distinguish minus zero.

\begin{center}
\begin{tabular}{clll}
& $y$ condition & $x$ condition & range of result $r$\\\hline
& $y = 0.0$ & $x > 0.0$ & $0.0$\\
$\ast$ & $y = +0.0$  & $x > 0.0$ & $+0.0$\\     
$\ast$ & $y = -0.0$ & $x > 0.0$ & $-0.0$\\
& $y > 0.0$ & $x > 0.0$ & $0.0 < r < \frac{\pi}{2}$\\
& $y > 0.0$ & $x = 0.0$ & $\frac{\pi}{2}$\\
& $y > 0.0$ & $x < 0.0$ & $\frac{\pi}{2} < r < \pi$\\
& $y = 0.0$ & $x < 0$ & $\pi$\\
$\ast$ & $y = +0.0$ & $x < 0.0$ & $\pi$\\
$\ast$ & $y = -0.0$ & $x < 0.0$ & $-\pi$\\      
&$y < 0.0$ & $x < 0.0$ & $-\pi< r< -\frac{\pi}{2}$\\
&$y < 0.0$ & $x = 0.0$ & $-\frac{\pi}{2}$\\
&$y < 0.0$ & $x > 0.0$ & $-\frac{\pi}{2} < r< 0.0$\\    
&$y = 0.0$ & $x = 0.0$ & undefined\\
$\ast$& $y = +0.0$ & $x = +0.0$ & $+0.0$\\
$\ast$& $y = -0.0$ & $x = +0.0$& $-0.0$\\
$\ast$& $y = +0.0$ & $x = -0.0$ & $\pi$\\
$\ast$& $y = -0.0$ & $x = -0.0$ & $-\pi$\\
$\ast$& $y = +0.0$ & $x = 0$ & $\frac{\pi}{2}$\\
$\ast$& $y = -0.0$ & $x = 0$    & $-\frac{\pi}{2}$
\end{tabular}
\end{center}

\subsection{Numerical operations}

\subsubsection{Numerical type predicates}

\begin{entry}{%
\proto{number?}{ obj}{procedure}
\proto{complex?}{ obj}{procedure}
\proto{real?}{ obj}{procedure}
\proto{rational?}{ obj}{procedure}
\proto{integer?}{ obj}{procedure}}

These numerical type predicates can be applied to any kind of
argument.  They return \schtrue{} if the object is a number object
of the named type, and \schfalse{} otherwise.
In general, if a type predicate is true of a number object then all higher
type predicates are also true of that number object.  Consequently, if a type
predicate is false of a number object, then all lower type predicates are
also false of that number object.

If \var{z} is a complex number object, then {\cf (real? \var{z})} is true if
and only if {\cf (zero? (imag-part \var{z}))} and {\cf (exact?
  (imag-part \var{z}))} are both true.

If \var{x} is a real number object, then {\cf (rational? \var{x})} is true if
and only if there exist exact integer objects \vari{k} and \varii{k} such that
{\cf (= \var{x} (/ \vari{k} \varii{k}))} and {\cf (= (numerator
  \var{x}) \vari{k})} and {\cf (= (denominator \var{x}) \varii{k})} are
all true.  Thus infinities and NaNs are not rational number objects.

If \var{q} is a rational number objects, then {\cf (integer?
\var{q})} is true if and only if {\cf (= (denominator
\var{q}) 1)} is true.  If \var{q} is not a rational number object,
then {\cf (integer? \var{q})} is \schfalse.

\begin{scheme}
(complex? 3+4i)                        \ev  \schtrue{}
(complex? 3)                           \ev  \schtrue{}
(real? 3)                              \ev  \schtrue{}
(real? -2.5+0.0i)                      \ev  \schfalse{}
(real? -2.5+0i)                        \ev  \schtrue{}
(real? -2.5)                           \ev  \schtrue{}
(real? \sharpsign{}e1e10)                         \ev  \schtrue{}
(rational? 6/10)                       \ev  \schtrue{}
(rational? 6/3)                        \ev  \schtrue{}
(rational? 2)                          \ev  \schtrue{}
(integer? 3+0i)                        \ev  \schtrue{}
(integer? 3.0)                         \ev  \schtrue{}
(integer? 8/4)                         \ev  \schtrue{}

(number? +nan.0)                       \ev  \schtrue{}
(complex? +nan.0)                      \ev  \schtrue{}
(real? +nan.0)                         \ev  \schtrue{}
(rational? +nan.0)                     \ev  \schfalse{}
(complex? +inf.0)                      \ev  \schtrue{}
(real? -inf.0)                         \ev  \schtrue{}
(rational? -inf.0)                     \ev  \schfalse{}
(integer? -inf.0)                      \ev  \schfalse{}%
\end{scheme}

\begin{note}
Except for {\cf number?}, the behavior of these type predicates
on inexact number objects is
unreliable, because any inaccuracy may
affect the result.
\end{note}
\end{entry}

\begin{entry}{%
\proto{real-valued?}{ obj}{procedure}
\proto{rational-valued?}{ obj}{procedure}
\proto{integer-valued?}{ obj}{procedure}}

These numerical type predicates can be applied to any kind of
argument.  The {\cf real-valued?} procedure
returns \schtrue{} if the object is a number object and is equal in the
sense of {\cf =} to some real number object, or if the object is a NaN, or a
complex number object whose real part is a NaN and whose imaginary
part is zero
in the sense of {\cf zero?}.  The {\cf rational-valued?} and {\cf
  integer-valued?} procedures return \schtrue{} if the object is a
number object and is equal in the sense of {\cf =} to some object of the
named type, and otherwise they return \schfalse{}.

\begin{scheme}
(real-valued? +nan.0)                  \ev  \schtrue{}
(real-valued? +nan.0+0i)                  \ev  \schtrue{}
(real-valued? -inf.0)                  \ev  \schtrue{}
(real-valued? 3)                       \ev  \schtrue{}
(real-valued? -2.5+0.0i)               \ev  \schtrue{}
(real-valued? -2.5+0i)                 \ev  \schtrue{}
(real-valued? -2.5)                    \ev  \schtrue{}
(real-valued? \sharpsign{}e1e10)                  \ev  \schtrue{}

(rational-valued? +nan.0)              \ev  \schfalse{}
(rational-valued? -inf.0)              \ev  \schfalse{}
(rational-valued? 6/10)                \ev  \schtrue{}
(rational-valued? 6/10+0.0i)           \ev  \schtrue{}
(rational-valued? 6/10+0i)             \ev  \schtrue{}
(rational-valued? 6/3)                 \ev  \schtrue{}

(integer-valued? 3+0i)                 \ev  \schtrue{}
(integer-valued? 3+0.0i)               \ev  \schtrue{}
(integer-valued? 3.0)                  \ev  \schtrue{}
(integer-valued? 3.0+0.0i)             \ev  \schtrue{}
(integer-valued? 8/4)                  \ev  \schtrue{}%
\end{scheme}

\begin{note}
  These procedures test whether a given number object can be coerced
  to the specified type without loss of numerical accuracy.
  Specifically, the behavior of these predicates differs from the
  behavior of {\cf real?}, {\cf rational?}, and {\cf integer?} on
  complex number objects whose imaginary part is inexact zero.
\end{note}

\begin{note}
The behavior of these type predicates on inexact number objects is
unreliable, because any inaccuracy may
affect the result.
\end{note}
\end{entry}

\begin{entry}{%
\proto{exact?}{ z}{procedure}
\proto{inexact?}{ z}{procedure}}

These numerical predicates provide tests for the exactness of a
quantity.  For any number object, precisely one of these predicates is
true.

\begin{scheme}
(exact? 5)                   \ev  \schtrue{}
(inexact? +inf.0)            \ev  \schtrue{}%
\end{scheme}
\end{entry}

\subsubsection{Generic conversions}

\begin{entry}{%
\proto{inexact}{ z}{procedure}
\proto{exact}{ z}{procedure}}

The {\cf inexact} procedure returns an inexact representation of \var{z}.  If
inexact number objects of the appropriate type have bounded precision, then
the value returned is an inexact number object that is nearest to the
argument.  If an exact argument has no reasonably close inexact
equivalent, an exception with condition type
{\cf\&implementation-violation} may be
raised.

\begin{note}
  For a real number object whose magnitude is finite but so large that it has
  no reasonable finite approximation as an inexact number, a
  reasonably close inexact equivalent may be {\cf +inf.0} or {\cf
    -inf.0}.  Similarly, the inexact representation of a complex
  number object whose components are finite may have infinite components.
\end{note}

The {\cf exact} procedure returns an exact representation of \var{z}.  The value
returned is the exact number object that is numerically closest to the
argument; in most cases, the result of this procedure should be
numerically equal to its argument.  If an inexact argument has no
reasonably close exact equivalent, an exception with condition type
{\cf\&implementation-violation} may be
raised.

These procedures implement the natural one-to-one correspondence
between exact and inexact integer objects throughout an
implementation-dependent range.

The {\cf inexact} and {\cf exact} procedures are idempotent.
\end{entry}

\subsubsection{Arithmetic operations}

\begin{entry}{%
\proto{=}{ \vari{z} \varii{z} \variii{z} \dotsfoo}{procedure}
\proto{<}{ \vari{x} \varii{x} \variii{x} \dotsfoo}{procedure}
\proto{>}{ \vari{x} \varii{x} \variii{x} \dotsfoo}{procedure}
\proto{<=}{ \vari{x} \varii{x} \variii{x} \dotsfoo}{procedure}
\proto{>=}{ \vari{x} \varii{x} \variii{x} \dotsfoo}{procedure}}

These procedures return \schtrue{} if their arguments are
(respectively): equal, monotonically increasing, monotonically
decreasing, monotonically nondecreasing, or monotonically
nonincreasing, and \schfalse{} otherwise.

\begin{scheme}
(= +inf.0 +inf.0)           \ev  \schtrue{}
(= -inf.0 +inf.0)           \ev  \schfalse{}
(= -inf.0 -inf.0)           \ev  \schtrue{}%
\end{scheme}

For any real number object \var{x} that is neither infinite nor NaN:

\begin{scheme}
(< -inf.0 \var{x} +inf.0))        \ev  \schtrue{}
(> +inf.0 \var{x} -inf.0))        \ev  \schtrue{}%
\end{scheme}

For any number object \var{z}:
%
\begin{scheme}
(= +nan.0 \var{z})               \ev  \schfalse{}%
\end{scheme}
%
For any real number object \var{x}:
%
\begin{scheme}
(< +nan.0 \var{x})               \ev  \schfalse{}
(> +nan.0 \var{x})               \ev  \schfalse{}%
\end{scheme}

These predicates must be transitive.

\begin{note}
The traditional implementations of these predicates in Lisp-like
languages are not transitive.
\end{note}

\begin{note}
While it is possible to compare inexact number objects using these
predicates, the results may be unreliable because a small inaccuracy
may affect the result; this is especially true of {\cf =} and {\cf zero?} (below).

When in doubt, consult a numerical analyst.
\end{note}
\end{entry}

\begin{entry}{%
\proto{zero?}{ z}{procedure}
\proto{positive?}{ x}{procedure}
\proto{negative?}{ x}{procedure}
\proto{odd?}{ n}{procedure}
\proto{even?}{ n}{procedure}
\proto{finite?}{ x}{procedure}
\proto{infinite?}{ x}{procedure}
\proto{nan?}{ x}{procedure}}

These numerical predicates test a number object for a particular property,
returning \schtrue{} or \schfalse{}.  The {\cf zero?}
procedure
tests if the number object is {\cf =} to zero, {\cf positive?} tests whether it is
greater than zero, {\cf negative?} tests whether it is less than zero, {\cf
  odd?} tests whether it is odd, {\cf even?} tests whether it is even, {\cf
  finite?} tests whether it is not an infinity and not a NaN, {\cf
  infinite?} tests whether it is an infinity, {\cf nan?} tests whether it is a
NaN.

\begin{scheme}
(zero? +0.0)                  \ev  \schtrue{}
(zero? -0.0)                  \ev  \schtrue{}
(zero? +nan.0)                \ev  \schfalse{}
(positive? +inf.0)            \ev  \schtrue{}
(negative? -inf.0)            \ev  \schtrue{}
(positive? +nan.0)            \ev  \schfalse{}
(negative? +nan.0)            \ev  \schfalse{}
(finite? +inf.0)              \ev  \schfalse{}
(finite? 5)                   \ev  \schtrue{}
(finite? 5.0)                 \ev  \schtrue{}
(infinite? 5.0)               \ev  \schfalse{}
(infinite? +inf.0)            \ev  \schtrue{}%
\end{scheme}

\begin{note}
  As with the predicates above, the results may be unreliable because
  a small inaccuracy may affect the result.
\end{note}
\end{entry}

\begin{entry}{%
\proto{max}{ \vari{x} \varii{x} \dotsfoo}{procedure}
\proto{min}{ \vari{x} \varii{x} \dotsfoo}{procedure}}

These procedures return the maximum or minimum of their arguments.

\begin{scheme}
(max 3 4)                              \ev  4
(max 3.9 4)                            \ev  4.0%
\end{scheme}

For any real number object \var{x}:

\begin{scheme}
(max +inf.0 \var{x})                         \ev  +inf.0
(min -inf.0 \var{x})                         \ev  -inf.0%
\end{scheme}

\begin{note}
If any argument is inexact, then the result is also inexact (unless
the procedure can prove that the inaccuracy is not large enough to affect the
result, which is possible only in unusual implementations).  If {\cf min} or
{\cf max} is used to compare number objects of mixed exactness, and the numerical
value of the result cannot be represented as an inexact number object without loss of
accuracy, then the procedure may raise an exception with condition
type {\cf\&implementation-restriction}.
\end{note}

\end{entry}

\begin{entry}{%
\proto{+}{ \vari{z} \dotsfoo}{procedure}
\proto{*}{ \vari{z} \dotsfoo}{procedure}}

These procedures return the sum or product of their arguments.

\begin{scheme}
(+ 3 4)                                \ev  7
(+ 3)                                  \ev  3
(+)                                    \ev  0
(+ +inf.0 +inf.0)                      \ev  +inf.0
(+ +inf.0 -inf.0)                      \ev  +nan.0

(* 4)                                  \ev  4
(*)                                    \ev  1
(* 5 +inf.0)                           \ev  +inf.0
(* -5 +inf.0)                          \ev  -inf.0
(* +inf.0 +inf.0)                      \ev  +inf.0
(* +inf.0 -inf.0)                      \ev  -inf.0
(* 0 +inf.0)                           \ev  0 \textnormal{\textit{or}} +nan.0
(* 0 +nan.0)                           \ev  0 \textnormal{\textit{or}} +nan.0
(* 1.0 0)                              \ev  0 \textnormal{\textit{or}} 0.0%
\end{scheme}

For any real number object \var{x} that is neither infinite nor NaN:

\begin{scheme}
(+ +inf.0 \var{x})                           \ev  +inf.0
(+ -inf.0 \var{x})                           \ev  -inf.0%
\end{scheme}

For any real number object \var{x}:

\begin{scheme}
(+ +nan.0 \var{x})                           \ev  +nan.0%
\end{scheme}

For any real number object \var{x} that is not an exact 0:

\begin{scheme}
(* +nan.0 \var{x})                           \ev  +nan.0%
\end{scheme}

If any of these procedures are applied to mixed non-rational real and
non-real complex arguments, they either raise an exception with
condition type {\cf\&implementation-restriction} or return an
unspecified number object.

Implementations that distinguish $-0.0$ should adopt behavior
consistent with the following examples:

\begin{scheme}
(+ 0.0 -0.0)  \ev 0.0
(+ -0.0 0.0)  \ev 0.0
(+ 0.0 0.0)   \ev 0.0
(+ -0.0 -0.0) \ev -0.0%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{-}{ z}{procedure}
\rproto{-}{ \vari{z} \varii{z} \dotsfoo}{procedure}}

With two or more arguments, this procedures returns the difference of
its arguments, associating to the left.  With one argument, however,
it returns the additive inverse of its argument.

\begin{scheme}
(- 3 4)                                \ev  -1
(- 3 4 5)                              \ev  -6
(- 3)                                  \ev  -3
(- +inf.0 +inf.0)                      \ev  +nan.0%
\end{scheme}

If this procedure is applied to mixed non-rational real and
non-real complex arguments, it either raises an exception with
condition type {\cf\&implementation-restriction} or returns an
unspecified number object.

Implementations that distinguish $-0.0$ should adopt behavior
consistent with the following examples:

\begin{scheme}
(- 0.0)       \ev -0.0
(- -0.0)      \ev 0.0
(- 0.0 -0.0)  \ev 0.0
(- -0.0 0.0)  \ev -0.0
(- 0.0 0.0)   \ev 0.0
(- -0.0 -0.0) \ev 0.0%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{/}{ z}{procedure}
\rproto{/}{ \vari{z} \varii{z} \dotsfoo}{procedure}}

\domain{If all of the arguments are exact, then the divisors must all
  be nonzero.}
With two or more arguments, this procedure returns the 
quotient of its arguments, associating to the left.  With one
argument, however, it returns the multiplicative inverse
of its argument.

\begin{scheme}
(/ 3 4 5)                              \ev  3/20
(/ 3)                                  \ev  1/3
(/ 0.0)                                \ev  +inf.0
(/ 1.0 0)                              \ev  +inf.0
(/ -1 0.0)                             \ev  -inf.0
(/ +inf.0)                             \ev  0.0
(/ 0 0)                                \xev \exception{\&assertion}
(/ 3 0)                                \xev \exception{\&assertion}
(/ 0 3.5)                              \ev  0.0
(/ 0 0.0)                              \ev  +nan.0
(/ 0.0 0)                              \ev  +nan.0
(/ 0.0 0.0)                            \ev  +nan.0%
\end{scheme}

If this procedure is applied to mixed non-rational real and
non-real complex arguments, it either raises an exception with
condition type {\cf\&implementation-restriction} or returns an
unspecified number object.
\end{entry}

\begin{entry}{%
\proto{abs}{ x}{procedure}}

Returns the absolute value of its argument.

\begin{scheme}
(abs -7)                               \ev  7
(abs -inf.0)                           \ev  +inf.0%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{div-and-mod}{ \vari{x} \varii{x}}{procedure}
\proto{div}{ \vari{x} \varii{x}}{procedure}
\proto{mod}{ \vari{x} \varii{x}}{procedure}
\proto{div0-and-mod0}{ \vari{x} \varii{x}}{procedure}
\proto{div0}{ \vari{x} \varii{x}}{procedure}
\proto{mod0}{ \vari{x} \varii{x}}{procedure}}

These procedures implement number-theoretic integer division and
return the results of the corresponding mathematical operations
specified in section~\ref{integerdivision}.  In each case, \vari{x}
must be neither infinite nor a NaN, and \varii{x} must be nonzero;
otherwise, an exception with condition type {\cf\&assertion} is raised.

\begin{scheme}
(div \vari{x} \varii{x})         \ev \(\vari{x}~\mathrm{div}~\varii{x}\)
(mod \vari{x} \varii{x})         \ev \(\vari{x}~\mathrm{mod}~\varii{x}\)
(div-and-mod \vari{x} \varii{x})     \ev \(\vari{x}~\mathrm{div}~\varii{x}, \vari{x}~\mathrm{mod}~\varii{x}\)\\\>\>\>; \textrm{two return values}
(div0 \vari{x} \varii{x})        \ev \(\vari{x}~\mathrm{div}_0~\varii{x}\)
(mod0 \vari{x} \varii{x})        \ev \(\vari{x}~\mathrm{mod}_0~\varii{x}\)
(div0-and-mod0 \vari{x} \varii{x})   \lev \(\vari{x}~\mathrm{div}_0~\varii{x}, \vari{x}~\mathrm{mod}_0~\varii{x}\)\\\>\>; \textrm{two return values}%
\end{scheme}

\begin{entry}{%
\proto{gcd}{ \vari{n} \dotsfoo}{procedure}
\proto{lcm}{ \vari{n} \dotsfoo}{procedure}}

These procedures return the greatest common divisor or least common
multiple of their arguments.  The result is always non-negative.

\begin{scheme}
(gcd 32 -36)                           \ev  4
(gcd)                                  \ev  0
(lcm 32 -36)                           \ev  288
(lcm 32.0 -36)                         \ev  288.0
(lcm)                                  \ev  1%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{numerator}{ q}{procedure}
\proto{denominator}{ q}{procedure}}

These procedures return the numerator or denominator of their
argument; the result is computed as if the argument was represented as
a fraction in lowest terms.  The denominator is always positive.  The
denominator of $0$ is defined to be $1$.

\begin{scheme}
(numerator (/ 6 4))                    \ev  3
(denominator (/ 6 4))                  \ev  2
(denominator
  (inexact (/ 6 4)))                   \ev  2.0%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{floor}{ x}{procedure}
\proto{ceiling}{ x}{procedure}
\proto{truncate}{ x}{procedure}
\proto{round}{ x}{procedure}}

These procedures return inexact integer objects for inexact arguments that are
not infinities or NaNs, and exact integer objects for exact rational
arguments.  For such arguments, {\cf floor} returns the largest
integer object not larger than \var{x}.  The {\cf ceiling} procedure returns the smallest
integer object not smaller than \var{x}.  The {\cf truncate} procedure returns the integer
object closest to \var{x} whose absolute value is not larger than the
absolute value of \var{x}.  The {\cf round} procedure returns the
closest integer object to
\var{x}, rounding to even when \var{x} represents a number halfway between two
integers.

\begin{note}
If the argument to one of these procedures is inexact, then the result
is also inexact.  If an exact value is needed, the
result should be passed to the {\cf exact} procedure.
\end{note}

Although infinities and NaNs are not integer objects, these procedures return
an infinity when given an infinity as an argument, and a NaN when
given a NaN.

\begin{scheme}
(floor -4.3)                           \ev  -5.0
(ceiling -4.3)                         \ev  -4.0
(truncate -4.3)                        \ev  -4.0
(round -4.3)                           \ev  -4.0

(floor 3.5)                            \ev  3.0
(ceiling 3.5)                          \ev  4.0
(truncate 3.5)                         \ev  3.0
(round 3.5)                            \ev  4.0

(round 7/2)                            \ev  4
(round 7)                              \ev  7

(floor +inf.0)                         \ev  +inf.0
(ceiling -inf.0)                       \ev  -inf.0
(round +nan.0)                         \ev  +nan.0%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{rationalize}{ \vari{x} \varii{x}}{procedure}}

The {\cf rationalize} procedure returns the a number object
representing the {\em simplest} rational
number differing from \vari{x} by no more than \varii{x}.    A rational number $r_1$ is
{\em simpler} \mainindex{simplest rational} than another rational number
$r_2$ if $r_1 = p_1/q_1$ and $r_2 = p_2/q_2$ (in lowest terms) and $|p_1|
\leq |p_2|$ and $|q_1| \leq |q_2|$.  Thus $3/5$ is simpler than $4/7$.
Although not all rationals are comparable in this ordering (consider $2/7$
and $3/5$) any interval contains a rational number that is simpler than
every other rational number in that interval (the simpler $2/5$ lies
between $2/7$ and $3/5$).  Note that $0 = 0/1$ is the simplest rational of
all.
%
\begin{scheme}
(rationalize (exact .3) 1/10)          \lev 1/3
(rationalize .3 1/10)                  \lev \sharpsign{}i1/3  ; \textrm{approximately}

(rationalize +inf.0 3)                 \ev  +inf.0
(rationalize +inf.0 +inf.0)            \ev  +nan.0
(rationalize 3 +inf.0)                 \ev  0.0%
\end{scheme}
%
The first two examples hold only in implementations whose inexact real
number objects have sufficient precision.

\end{entry}

\begin{entry}{%
\proto{exp}{ z}{procedure}
\proto{log}{ z}{procedure}
\rproto{log}{ \vari{z} \varii{z}}{procedure}
\proto{sin}{ z}{procedure}
\proto{cos}{ z}{procedure}
\proto{tan}{ z}{procedure}
\proto{asin}{ z}{procedure}
\proto{acos}{ z}{procedure}
\proto{atan}{ z}{procedure}
\rproto{atan}{ \vari{x} \varii{x}}{procedure}}

These procedures compute the usual transcendental functions.  The {\cf
  exp} procedure computes the base-$e$ exponential of \var{z}. 
The {\cf log} procedure with a single argument computes the natural logarithm of
\var{z} (not the base-ten logarithm); {\cf (log \vari{z}
  \varii{z})} computes the base-\varii{z} logarithm of \vari{z}.
The {\cf asin}, {\cf acos}, and {\cf atan} procedures compute arcsine,
arccosine, and arctangent, respectively.  The two-argument variant of
{\cf atan} computes {\cf (angle (make-rectangular \varii{x}
\vari{x}))}.

See section~\ref{transcendentalfunctions} for the underlying
mathematical operations. These procedures may return inexact results
even when given exact arguments.

\begin{scheme}
(exp +inf.0)                   \ev +inf.0
(exp -inf.0)                   \ev 0.0
(log +inf.0)                   \ev +inf.0
(log 0.0)                      \ev -inf.0
(log 0)                        \xev \exception{\&assertion}
(log -inf.0)                   \lev +inf.0+3.141592653589793i\\\> ; \textrm{approximately}
(atan -inf.0)                  \lev -1.5707963267948965 ; \textrm{approximately}
(atan +inf.0)                  \lev 1.5707963267948965 ; \textrm{approximately}
(log -1.0+0.0i)                \lev 0.0+3.141592653589793i ; \textrm{approximately}
(log -1.0-0.0i)                \lev 0.0-3.141592653589793i ; \textrm{approximately}\\\>; \textrm{if -0.0 is distinguished}%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{sqrt}{ z}{procedure}}

Returns the principal square root of \var{z}.  For rational \var{z},
the result has either positive real part, or zero real part and
non-negative imaginary part.  With $\log$ defined as in
section~\ref{transcendentalfunctions}, the value of {\cf (sqrt
  \var{z})} could be expressed as $e^{\frac{\log z}{2}}$.

The {\cf sqrt} procedure may return an inexact result even when given an exact
argument.

\begin{scheme}
(sqrt -5)                   \lev  0.0+2.23606797749979i ; \textrm{approximately}
(sqrt +inf.0)               \ev  +inf.0
(sqrt -inf.0)               \ev  +inf.0i%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{exact-integer-sqrt}{ k}{procedure}}

The {\cf exact-integer-sqrt} procedure returns two non-negative exact
integer objects $s$ and $r$ where $\var{k} = s^2 +
r$ and $\var{k} < (s+1)^2$.

\begin{scheme}
(exact-integer-sqrt 4) \ev 2 0\\\>\>\>; \textrm{two return values}
(exact-integer-sqrt 5) \ev 2 1\\\>\>\>; \textrm{two return values}
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{expt}{ \vari{z} \varii{z}}{procedure}}

Returns \vari{z} raised to the power \varii{z}.  For nonzero \vari{z},
this is $e^{z_2 \log z_1}$.
$0.0^{z}$ is $1.0$ if $\var{z} = 0.0$, and $0.0$ if {\cf
  (real-part \var{z})} is positive.  For other cases in which
the first argument is zero, either an exception is raised with
condition type {\cf\&implementation-restriction}, or an unspecified
number object is returned.

For an exact real number object \vari{z} and an exact
integer object \varii{z}, {\cf (expt \vari{z}
\varii{z})} must return an exact result.  For all other
values of \vari{z} and \varii{z}, {\cf (expt \vari{z}
\varii{z})} may return an inexact result, even when both
\vari{z} and \varii{z} are exact.

\begin{scheme}
(expt 5 3)                  \ev  125
(expt 5 -3)                 \ev  1/125
(expt 5 0)                  \ev  1
(expt 0 5)                  \ev  0
(expt 0 5+.0000312i)        \ev  0
(expt 0 -5)                 \ev  \unspecified
(expt 0 -5+.0000312i)       \ev  \unspecified
(expt 0 0)                  \ev  1
(expt 0.0 0.0)              \ev  1.0%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{make-rectangular}{ \vari{x} \varii{x}}{procedure}
\proto{make-polar}{ \variii{x} \variv{x}}{procedure}
\proto{real-part}{ z}{procedure}
\proto{imag-part}{ z}{procedure}
\proto{magnitude}{ z}{procedure}
\proto{angle}{ z}{procedure}}

Suppose $a_1$, $a_2$, $a_3$, and $a_4$ are real
numbers, and $c$ is a complex number such that the
following holds:
%
\begin{displaymath}
c = a_1 + a_2 i = a_3 e^{i a_4}
\end{displaymath}

Then, if \vari{x}, \varii{x}, \variii{x}, and \variv{x} are number
objects representing $a_1$, $a_2$, $a_3$, and $a_4$, respectively,
{\cf (make-rectangular \vari{x} \varii{x})} returns $c$, and {\cf
  (make-polar \variii{x} \variv{x})} returns $c$.
%
\begin{scheme}
(make-rectangular 1.1 2.2) \lev 1.1+2.2i ; \textrm{approximately}
(make-polar 1.1 2.2) \lev 1.1@2.2 ; \textrm{approximately}
\end{scheme}
%
Conversely, if $-\pi \leq a_4 \leq \pi$, and if $z$ is a number object
representing $c$, then {\cf (real-part \var{z})} returns $a_1$ {\cf
  (imag-part \var{z})} returns $a_2$, {\cf (magnitude \var{z})}
returns $a_3$, and {\cf (angle \var{z})} returns $a_4$.

\begin{scheme}
(real-part 1.1+2.2i)              \ev 1.1 ; \textrm{approximately}
(imag-part 1.1+2.2i)              \ev 2.2i ; \textrm{approximately}
(magnitude 1.1@2.2)              \ev 1.1 ; \textrm{approximately}
(angle 1.1@2.2)                  \ev 2.2 ; \textrm{approximately}

(angle -1.0)         \lev 3.141592653589793 ; \textrm{approximately}
(angle -1.0+0.0i)    \lev 3.141592653589793 ; \textrm{approximately}
(angle -1.0-0.0i)    \lev -3.141592653589793 ; \textrm{approximately}\\\>; \textrm{if -0.0 is distinguished}
(angle +inf.0)       \ev 0.0
(angle -inf.0)       \lev 3.141592653589793 ; \textrm{approximately}%
\end{scheme}

Moreover, suppose \vari{x}, \varii{x} are such that either \vari{x}
or \varii{x} is an infinity, then
%
\begin{scheme}
(make-rectangular \vari{x} \varii{x}) \ev \var{z}
(magnitude \var{z})              \ev +inf.0%
\end{scheme}
\end{entry}

The {\cf make-polar}, {\cf magnitude}, and
{\cf angle} procedures may return inexact results even when given exact
arguments.

\begin{scheme}
(angle -1)                    \lev 3.141592653589793 ; \textrm{approximately}
\end{scheme}
\end{entry}

\subsubsection{Numerical Input and Output}

\begin{entry}{%
\proto{number->string}{ z}{procedure}
\rproto{number->string}{ z radix}{procedure}
\rproto{number->string}{ z radix precision}{procedure}}

\var{Radix} must be an exact integer object, either 2, 8, 10, or 16.  If
omitted, \var{radix} defaults to 10.  If a \var{precision} is
specified, then \var{z} must be an inexact complex number object,
\var{precision} must be an exact positive integer object, and \var{radix}
must be 10.  The {\cf number->string} procedure takes a number object and a
radix and returns as a string an external representation of the given
number object in the given radix such that
%
\begin{scheme}
(let ((number \var{z}) (radix \var{radix}))
  (eqv? (string->number
          (number->string number radix)
          radix)
        number))%
\end{scheme}
%
is true.  If no possible result makes this expression
true, an exception with condition type
{\cf\&implementation-\hp{}restriction} is raised.

\begin{note}
The error case can occur only when \var{z} is not a complex number object
or is a complex number object with a non-rational real or imaginary part.
\end{note}

If a \var{precision} is specified, then the representations of the
inexact real components of the result, unless they are infinite or
NaN, specify an explicit \meta{mantissa width} \var{p}, and \var{p} is the
least $\var{p} \geq \var{precision}$ for which the above expression is
true.

If \var{z} is inexact, the radix is 10, and the above expression and
condition can be satisfied by a result that contains a decimal point,
then the result contains a decimal point and is expressed using the
minimum number of digits (exclusive of exponent, trailing zeroes, and
mantissa width) needed to make the above expression and condition
true~\cite{howtoprint,howtoread}; otherwise the format of the result
is unspecified.

The result returned by {\cf number->string} never contains an explicit
radix prefix.
\end{entry}

\begin{entry}{%
\proto{string->number}{ string}{procedure}
\rproto{string->number}{ string radix}{procedure}}

Returns a number object with maximally precise representation expressed by the
given \var{string}.  \var{Radix} must be an exact integer object, either 2, 8, 10,
or 16.  If supplied, \var{radix} is a default radix that may be overridden
by an explicit radix prefix in \var{string} (e.g., {\tt "\#o177"}).  If \var{radix}
is not supplied, then the default radix is 10.  If \var{string} is not
a syntactically valid notation for a number object or a notation for a
rational number object with a zero denominator, then {\cf string->number}
returns \schfalse{}.
%
\begin{scheme}
(string->number "100")                 \ev  100
(string->number "100" 16)              \ev  256
(string->number "1e2")                 \ev  100.0
(string->number "0/0")                 \ev  \schfalse
(string->number "+inf.0")              \ev  +inf.0
(string->number "-inf.0")              \ev  -inf.0
(string->number "+nan.0")              \ev  +nan.0%
\end{scheme}

\begin{note}
  The {\cf string->number} procedure always returns a number object or
  \schfalse{}; it never raises an exception.
\end{note}
\end{entry}


\section{Booleans}
% \label{booleansection}

The standard boolean objects for true and false have external representations
\schtrue{} and \schfalse.\sharpindex{t}\sharpindex{f} However, of all
objects, only \schfalse{} counts as false in
conditional expressions.  See section~\ref{booleanvaluessection}.

\begin{note}
Programmers accustomed to other dialects of Lisp should be aware that
Scheme distinguishes both \schfalse{} and the empty list \index{empty list}
from each other and from the symbol \ide{nil}.
\end{note}

\begin{entry}{%
\proto{not}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is \schfalse, and returns
\schfalse{} otherwise.

\begin{scheme}
(not \schtrue)   \ev  \schfalse
(not 3)          \ev  \schfalse
(not (list 3))   \ev  \schfalse
(not \schfalse)  \ev  \schtrue
(not '())        \ev  \schfalse
(not (list))     \ev  \schfalse
(not 'nil)       \ev  \schfalse%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{boolean?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is either \schtrue{} or
\schfalse{} and returns \schfalse{} otherwise.

\begin{scheme}
(boolean? \schfalse)  \ev  \schtrue
(boolean? 0)          \ev  \schfalse
(boolean? '())        \ev  \schfalse%
\end{scheme}

\begin{entry}{%
\proto{boolean=?}{ \vari{bool} \varii{bool} \variii{bool}
  \dotsfoo}{procedure}}

Returns \schtrue{} if the booleans are the same.
\end{entry}

\end{entry}

 
\section{Pairs and lists}
% \label{listsection}

A \defining{pair} is a
compound structure with two fields called the car and cdr fields (for
historical reasons).  Pairs are created by the procedure {\cf cons}.
The car and cdr fields are accessed by the procedures {\cf car} and
{\cf cdr}.

Pairs are used primarily to represent lists.  A list can
be defined recursively as either the empty list\index{empty list} or a pair whose
cdr is a list.  More precisely, the set of lists is defined as the smallest
set \var{X} such that

\begin{itemize}
\item The empty list is in \var{X}.
\item If \var{list} is in \var{X}, then any pair whose cdr field contains
      \var{list} is also in \var{X}.
\end{itemize}

The objects in the car fields of successive pairs of a list are the
elements of the list.  For example, a two-element list is a pair whose car
is the first element and whose cdr is a pair whose car is the second element
and whose cdr is the empty list.  The length of a list is the number of
elements, which is the same as the number of pairs.

The empty list\mainindex{empty list} is a special object of its own type.
It is not a pair.  It has no elements and its length is zero.

\begin{note}
The above definitions imply that all lists have finite length and are
terminated by the empty list.
\end{note}

A chain of pairs not ending in the empty list is called an
\defining{improper list}.  Note that an improper list is not a list.
The list and dotted notations can be combined to represent
improper lists:

\begin{scheme}
(a b c . d)%
\end{scheme}

is equivalent to

\begin{scheme}
(a . (b . (c . d)))%
\end{scheme}

Whether a given pair is a list depends upon what is stored in the cdr
field.

\begin{entry}{%
\proto{pair?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a pair, and otherwise
returns \schfalse.

\begin{scheme}
(pair? '(a . b))        \ev  \schtrue
(pair? '(a b c))        \ev  \schtrue
(pair? '())             \ev  \schfalse
(pair? '\#(a b))         \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{cons}{ \vari{obj} \varii{obj}}{procedure}}

Returns a newly allocated pair whose car is \vari{obj} and whose cdr is
\varii{obj}.  The pair is guaranteed to be different (in the sense of
{\cf eqv?}) from every existing object.

\begin{scheme}
(cons 'a '())           \ev  (a)
(cons '(a) '(b c d))    \ev  ((a) b c d)
(cons "a" '(b c))       \ev  ("a" b c)
(cons 'a 3)             \ev  (a . 3)
(cons '(a b) 'c)        \ev  ((a b) . c)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{car}{ pair}{procedure}}

Returns the contents of the car field of \var{pair}.

\begin{scheme}
(car '(a b c))          \ev  a
(car '((a) b c d))      \ev  (a)
(car '(1 . 2))          \ev  1
(car '())               \xev \exception{\&assertion}%
\end{scheme}
 
\end{entry}


\begin{entry}{%
\proto{cdr}{ pair}{procedure}}

Returns the contents of the cdr field of \var{pair}.

\begin{scheme}
(cdr '((a) b c d))      \ev  (b c d)
(cdr '(1 . 2))          \ev  2
(cdr '())               \xev \exception{\&assertion}%
\end{scheme}
 
\end{entry}



\setbox0\hbox{\tt(cadr \var{pair})}
\setbox1\hbox{procedure}


\begin{entry}{%
\proto{caar}{ pair}{procedure}
\proto{cadr}{ pair}{procedure}
\texonly
\pproto{\hbox to 1\wd0 {\hfil$\vdots$\hfil}}{\hbox to 1\wd1 {\hfil$\vdots$\hfil}}
\endtexonly
\htmlonly $\vdots$ \endhtmlonly
\proto{cdddar}{ pair}{procedure}
\proto{cddddr}{ pair}{procedure}}

These procedures are compositions of {\cf car} and {\cf cdr}, where
for example {\cf caddr} could be defined by

\begin{scheme}
(define caddr (lambda (x) (car (cdr (cdr x))))){\rm.}%
\end{scheme}

Arbitrary compositions, up to four deep, are provided.  There are
twenty-eight of these procedures in all.

\end{entry}


\begin{entry}{%
\proto{null?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is the empty list\index{empty list},
\schfalse otherwise.

\end{entry}

\begin{entry}{%
\proto{list?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a list, \schfalse{} otherwise.
By definition, all lists are chains of pairs that have finite length and are terminated by
the empty list.

\begin{scheme}
(list? '(a b c))     \ev  \schtrue
(list? '())          \ev  \schtrue
(list? '(a . b))     \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{list}{ \var{obj} \dotsfoo}{procedure}}

Returns a newly allocated list of its arguments.

\begin{scheme}
(list 'a (+ 3 4) 'c)            \ev  (a 7 c)
(list)                          \ev  ()%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{length}{ list}{procedure}}

Returns the length of \var{list}.

\begin{scheme}
(length '(a b c))               \ev  3
(length '(a (b) (c d e)))       \ev  3
(length '())                    \ev  0%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{append}{ list \dotsfoo{} obj}{procedure}}

Returns a possibly improper list consisting of the elements of the first \var{list}
followed by the elements of the other \var{list}s, with \var{obj} as
the cdr of the final pair.
An improper list results if \var{obj} is not a
list.

\begin{scheme}
(append '(x) '(y))              \ev  (x y)
(append '(a) '(b c d))          \ev  (a b c d)
(append '(a (b)) '((c)))        \ev  (a (b) (c))
(append '(a b) '(c . d))        \ev  (a b c . d)
(append '() 'a)                 \ev  a%
\end{scheme}

If {\cf append} constructs a nonempty chain of pairs, it is always
newly allocated.  If no pairs are allocated, \var{obj} is returned.
\end{entry}


\begin{entry}{%
\proto{reverse}{ list}{procedure}}

Returns a newly allocated list consisting of the elements of \var{list}
in reverse order.

\begin{scheme}
(reverse '(a b c))              \ev  (c b a)
(reverse '(a (b c) d (e (f))))  \lev  ((e (f)) d (b c) a)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{list-tail}{ list k}{procedure}}

\domain{\var{List} should be a list of size at least \var{k}.}
The {\cf list-tail} procedure returns the subchain of pairs of \var{list}
obtained by omitting the first \var{k} elements.

\begin{scheme}
(list-tail '(a b c d) 2)                 \ev  (c d)%
\end{scheme}

\implresp The implementation must check that \var{list} is a chain of
pairs whose length is at least \var{k}.  It should not check that it is a chain
of pairs beyond this length.
\end{entry}


\begin{entry}{%
\proto{list-ref}{ list k}{procedure}}

\domain{\var{List} must be a list whose length is at least $\var{k}+1$.}
The {\cf list-tail} procedure returns the \var{k}th element of \var{list}.

\begin{scheme}
(list-ref '(a b c d) 2)                 \ev c%
\end{scheme}

\implresp The implementation must check that \var{list} is a chain of
pairs whose length is at least $\var{k}+1$.  It should not check that it is a list
of pairs beyond this length.
\end{entry}


\begin{entry}{%
\proto{map}{ proc \vari{list} \varii{list} \dotsfoo}{procedure}}

\domain{The \var{list}s should all have the same length.  \var{Proc}
  should accept as many arguments as there are
  \var{list}s and return a single value.  \var{Proc} should not mutate
  any of the \var{list}s.}

The {\cf map} procedure applies \var{proc} element-wise to the elements of the
\var{list}s and returns a list of the results, in order.
\var{Proc} is always called in the same dynamic environment 
as {\cf map} itself.
The order in which \var{proc} is applied to the elements of the
\var{list}s is unspecified.
If multiple returns occur from {\cf map}, the 
values returned by earlier returns are not mutated.

\begin{scheme}
(map cadr '((a b) (d e) (g h)))   \lev  (b e h)

(map (lambda (n) (expt n n))
     '(1 2 3 4 5))                \lev  (1 4 27 256 3125)

(map + '(1 2 3) '(4 5 6))         \ev  (5 7 9)

(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b)))                 \ev  (1 2) \var{or} (2 1)%
\end{scheme}

\implresp The implementation should check that the \var{list}s all
have the same length.  The implementation must check the restrictions
on \var{proc} to the extent performed by applying it as described.  An
implementation may check whether \var{proc} is an appropriate argument
before applying it.
\end{entry}


\begin{entry}{%
\proto{for-each}{ proc \vari{list} \varii{list} \dotsfoo}{procedure}}

\domain{The \var{list}s should all have the same length.  \var{Proc}
  should accept as many arguments as there are
  \var{list}s.  \var{Proc} should not mutate
  any of the \var{list}s.}

The {\cf for-each} procedure applies \var{proc}
element-wise to the elements of the
\var{list}s for its side effects,  in order from the first elements to the
last.
\var{Proc} is always called in the same dynamic environment 
as {\cf for-each} itself.
The return values of {\cf for-each} \areunspecified.

\begin{scheme}
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)                                \ev  \#(0 1 4 9 16)

(for-each (lambda (x) x) '(1 2 3 4)) \lev \theunspecified

(for-each even? '()) \ev \theunspecified%
\end{scheme}

\implresp The implementation should check that the \var{list}s all
have the same length.  The implementation must check the restrictions
on \var{proc} to the extent performed by applying it as described.
An implementation may check whether \var{proc} is an appropriate argument
before applying it.

\begin{note}
Implementations of {\cf for-each} may or may not tail-call
\var{proc} on the last elements.
\end{note}

\end{entry}


\section{Symbols}
% \label{symbolsection}

Symbols are objects whose usefulness rests on the fact that two
symbols are identical (in the sense of {\cf eq?}, {\cf eqv?} and {\cf equal?}) if and only if their
names are spelled the same way. 
A symbol literal is formed using {\cf quote}.

\begin{entry}{%
\proto{symbol?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a symbol, otherwise returns \schfalse.

\begin{scheme}
(symbol? 'foo)          \ev  \schtrue
(symbol? (car '(a b)))  \ev  \schtrue
(symbol? "bar")         \ev  \schfalse
(symbol? 'nil)          \ev  \schtrue
(symbol? '())           \ev  \schfalse
(symbol? \schfalse)     \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{symbol->string}{ symbol}{procedure}}

Returns the name of \var{symbol} as an immutable string.  

\begin{scheme}
(symbol->string 'flying-fish)     
                                  \ev  "flying-fish"
(symbol->string 'Martin)          \ev  "Martin"
(symbol->string
   (string->symbol "Malvina"))     
                                  \ev  "Malvina"%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{symbol=?}{ \vari{symbol} \varii{symbol} \variii{symbol}
  \dotsfoo}{procedure}}

Returns \schtrue{} if the symbols are the same, i.e., if their names
are spelled the same.
\end{entry}

\begin{entry}{%
\proto{string->symbol}{ string}{procedure}}

Returns the symbol whose name is \var{string}. 

\begin{scheme}
(eq? 'mISSISSIppi 'mississippi)  \lev  \schfalse
(string->symbol "mISSISSIppi")  \lev%
  {\rm{}the symbol with name} "mISSISSIppi"
(eq? 'bitBlt (string->symbol "bitBlt"))     \lev  \schtrue
(eq? 'JollyWog
     (string->symbol
       (symbol->string 'JollyWog)))  \lev  \schtrue
(string=? "K. Harper, M.D."
          (symbol->string
            (string->symbol "K. Harper, M.D.")))  \lev  \schtrue%
\end{scheme}

\end{entry}


\section{Characters}
% \label{charactersection}

\mainindex{Unicode}
\mainindex{scalar value}

\defining{Characters} are objects that represent Unicode scalar
values~\cite{Unicode}.

\begin{note}
  Unicode defines a standard mapping between sequences of
  \textit{Unicode scalar values}\mainindex{Unicode scalar
    value}\mainindex{scalar value} (integers in the range 0 to
  \#x10FFFF, excluding the range \#xD800 to \#xDFFF) in the latest
  version of the standard and human-readable ``characters''. More
  precisely, Unicode distinguishes between glyphs, which are printed
  for humans to read, and characters, which are abstract entities that
  map to glyphs (sometimes in a way that's sensitive to surrounding
  characters).  Furthermore, different sequences of scalar values
  sometimes correspond to the same character.  The relationships among
  scalar, characters, and glyphs are subtle and complex.

  Despite this complexity, most things that a literate human would
  call a ``character'' can be represented by a single Unicode scalar
  value (although several sequences of Unicode scalar values may
  represent that same character). For example, Roman letters, Cyrillic
  letters, Hebrew consonants, and most Chinese characters fall into
  this category.
  
  Unicode scalar values exclude the range \#xD800 to \#xDFFF, which
  are part of the range of Unicode \textit{code points}\mainindex{code
    point}.  However, the Unicode code points in this range,
  the so-called \textit{surrogates}\mainindex{surrogate}, are an
  artifact of the UTF-16 encoding, and can only appear in specific
  Unicode encodings, and even then only in pairs that encode scalar
  values.  Consequently, all characters represent code points, but the
  surrogate code points do not have representations as characters.
\end{note}

\begin{entry}{%
\proto{char?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a character, otherwise returns \schfalse.

\end{entry}

\begin{entry}{%
\proto{char->integer}{ char}{procedure}
\proto{integer->char}{ \vr{sv}}{procedure}}

\domain{\var{Sv} must be a Unicode scalar value, i.e., a non-negative exact
  integer object in $\left[0, \#x\textrm{D7FF}\right] \cup
  \left[\#x\textrm{E000}, \#x\textrm{10FFFF}\right]$.}

Given a character, {\cf char\coerce{}integer} returns its Unicode scalar value
as an exact integer object.  
For a Unicode scalar value \var{sv}, {\cf integer\coerce{}char}
returns its associated character.

\begin{scheme}
(integer->char 32) \ev \sharpsign\backwhack{}space
(char->integer (integer->char 5000))
\ev 5000
(integer->char \sharpsign{}\backwhack{}xD800) \xev \exception{\&assertion}%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{char=?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}
\proto{char<?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}
\proto{char>?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}
\proto{char<=?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}
\proto{char>=?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}}

% \label{characterequality}
These procedures impose a total ordering on the set of characters
according to their Unicode scalar values.

\begin{scheme}
(char<? \sharpsign\backwhack{}z \sharpsign\backwhack{}\ss) \ev \schtrue
(char<? \sharpsign\backwhack{}z \sharpsign\backwhack{}Z) \ev \schfalse%
\end{scheme}

\end{entry}

\section{Strings}
% \label{stringsection}

Strings are sequences of characters.  

\vest The {\em length} of a string is the number of characters that it
contains.  This number is fixed when the
string is created.  The \defining{valid indices} of a string are the
integers less than the length of the string.  The first
character of a string has index 0, the second has index 1, and so on.

\begin{entry}{%
\proto{string?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a string, otherwise returns \schfalse.
\end{entry}


\begin{entry}{%
\proto{make-string}{ k}{procedure}
\rproto{make-string}{ k char}{procedure}}

Returns a newly allocated string of
length \var{k}.  If \var{char} is given, then all elements of the string
are initialized to \var{char}, otherwise the contents of the
\var{string} are unspecified.

\end{entry}

\begin{entry}{%
\proto{string}{ char \dotsfoo}{procedure}}

Returns a newly allocated string composed of the arguments.

\end{entry}

\begin{entry}{%
\proto{string-length}{ string}{procedure}}

Returns the number of characters in the given \var{string} as an exact
integer object.
\end{entry}


\begin{entry}{%
\proto{string-ref}{ string k}{procedure}}

\domain{\var{K} must be a valid index of \var{string}.}
The {\cf string-ref} procedure returns character \vr{k} of \var{string} using zero-origin indexing.

\begin{note}
  Implementors should make {\cf string-ref} run in constant
  time.
\end{note}
\end{entry}

\begin{entry}{%
\proto{string=?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{procedure}}

Returns \schtrue{} if the strings are the same length and contain the same
characters in the same positions.  Otherwise, the {\cf string=?}
procedure returns \schfalse.

\begin{scheme}
(string=? "Stra\ss{}e" "Strasse") \lev \schfalse%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{string<?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{procedure}
\proto{string>?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{procedure}
\proto{string<=?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{procedure}
\proto{string>=?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{procedure}}

These procedures are the lexicographic extensions to strings of the
corresponding orderings on characters.  For example, {\cf string<?}\ is
the lexicographic ordering on strings induced by the ordering
{\cf char<?}\ on characters.  If two strings differ in length but
are the same up to the length of the shorter string, the shorter string
is considered to be lexicographically less than the longer string.

\begin{scheme}
(string<? "z" "\ss") \ev \schtrue
(string<? "z" "zz") \ev \schtrue
(string<? "z" "Z") \ev \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{substring}{ string start end}{procedure}}

\domain{\var{String} must be a string, and \var{start} and \var{end}
must be exact integer objects satisfying
$$0 \leq \var{start} \leq \var{end} \leq \hbox{\tt(string-length \var{string})\rm.}$$}
The {\cf substring} procedure returns a newly allocated string formed from the characters of
\var{string} beginning with index \var{start} (inclusive) and ending with index
\var{end} (exclusive).
\end{entry}


\begin{entry}{%
\proto{string-append}{ \var{string} \dotsfoo}{procedure}}

Returns a newly allocated string whose characters form the concatenation of the
given strings.
\end{entry}


\begin{entry}{%
\proto{string->list}{ string}{procedure}
\proto{list->string}{ list}{procedure}}

\domain{\var{List} must be a list of characters.}
The {\cf string\coerce{}list} procedure returns a newly allocated list of the
characters that make up the given string.  The {\cf
  list\coerce{}string} procedure
returns a newly allocated string formed from the characters in 
\var{list}. The {\cf string\coerce{}list}
and {\cf list\coerce{}string} procedures are
inverses so far as {\cf equal?}\ is concerned.  
\end{entry}

\begin{entry}{%
\proto{string-for-each}{ proc \vari{string} \varii{string} \dotsfoo}{procedure}}

\domain{The \var{string}s must all have the same length.  \var{Proc}
  should accept as many arguments as there are {\it string}s.}
The {\cf string-for-each} procedure applies \var{proc}
element-wise to the characters of the
\var{string}s for its side effects,  in order from the first characters to the
last.
\var{Proc} is always called in the same dynamic environment 
as {\cf string-for-each} itself.
The return values of {\cf string-for-each} \areunspecified.

Analogous to {\cf for-each}.

\implresp The implementation must check the restrictions
on \var{proc} to the extent performed by applying it as described.
An
implementation may check whether \var{proc} is an appropriate argument
before applying it.
\end{entry}

\begin{entry}{%
\proto{string-copy}{ string}{procedure}}

Returns a newly allocated copy of the given \var{string}.

\end{entry}

\section{Vectors}
% \label{vectorsection}

Vectors are heterogeneous structures whose elements are indexed
by integers.  A vector typically occupies less space than a list
of the same length, and the average time needed to access a randomly
chosen element is typically less for the vector than for the list.

\vest The {\em length} of a vector is the number of elements that it
contains.  This number is a non-negative integer that is fixed when the
vector is created.
The {\em valid indices}\index{valid indices} of a
vector are the exact non-negative integer objects less than the length of the
vector.  The first element in a vector is indexed by zero, and the last
element is indexed by one less than the length of the vector.

Like list constants, vector constants must be quoted:

\begin{scheme}
'\#(0 (2 2 2 2) "Anna")  \lev  \#(0 (2 2 2 2) "Anna")%
\end{scheme}

\begin{entry}{%
\proto{vector?}{ obj}{procedure}}
 
Returns \schtrue{} if \var{obj} is a vector.  Otherwise the procedure
returns \schfalse.
\end{entry}


\begin{entry}{%
\proto{make-vector}{ k}{procedure}
\rproto{make-vector}{ k fill}{procedure}}

Returns a newly allocated vector of \var{k} elements.  If a second
argument is given, then each element is initialized to \var{fill}.
Otherwise the initial contents of each element is unspecified.

\end{entry}


\begin{entry}{%
\proto{vector}{ obj \dotsfoo}{procedure}}

Returns a newly allocated vector whose elements contain the given
arguments.  Analogous to {\cf list}.

\begin{scheme}
(vector 'a 'b 'c)               \ev  \#(a b c)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-length}{ vector}{procedure}}

Returns the number of elements in \var{vector} as an exact integer object.
\end{entry}


\begin{entry}{%
\proto{vector-ref}{ vector k}{procedure}}

\domain{\var{K} must be a valid index of \var{vector}.}
The {\cf vector-ref} procedure returns the contents of element \vr{k} of
\var{vector}.

\begin{scheme}
(vector-ref '\#(1 1 2 3 5 8 13 21) 5)  \lev  8%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-set!}{ vector k obj}{procedure}}

\domain{\var{K} must be a valid index of \var{vector}.}
The {\cf vector-set!} procedure stores \var{obj} in element \vr{k} of
\var{vector}, and returns \unspecifiedreturn.

Passing an immutable vector to {\cf vector-set!} should cause an exception
with condition type {\cf\&assertion} to be raised.

\begin{scheme}
(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec)      \lev  \#(0 ("Sue" "Sue") "Anna")

(vector-set! '\#(0 1 2) 1 "doe")  \lev  \unspecified
             ; \textrm{constant vector}
             ; \textrm{should raise} \exception{\&assertion}%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{vector->list}{ vector}{procedure}
\proto{list->vector}{ list}{procedure}}

The {\cf vector->list} procedure returns a newly allocated list of the objects contained
in the elements of \var{vector}.  The {\cf list->vector} procedure returns a newly
created vector initialized to the elements of the list \var{list}.

\begin{scheme}
(vector->list '\#(dah dah didah))  \lev  (dah dah didah)
(list->vector '(dididit dah))   \lev  \#(dididit dah)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-fill!}{ vector fill}{procedure}}

Stores \var{fill} in every element of \var{vector}
and returns \unspecifiedreturn.
\end{entry}

\begin{entry}{%
\proto{vector-map}{ proc \vari{vector} \varii{vector} \dotsfoo}{procedure}}

\domain{The \var{vector}s must all have the same length.  \var{Proc}
  should accept as many arguments as there are {\it vector}s and return a
  single value.}

The {\cf vector-map} procedure applies \var{proc} element-wise to the elements of the
\var{vector}s and returns a vector of the results, in order.
\var{Proc} is always called in the same dynamic environment 
as {\cf vector-map} itself.
The order in which \var{proc} is applied to the elements of the
\var{vector}s is unspecified.
If multiple returns occur from {\cf vector-map}, the return
values returned by earlier returns are not mutated.


Analogous to {\cf map}.

\implresp The implementation must check the restrictions
on \var{proc} to the extent performed by applying it as described.
An
implementation may check whether \var{proc} is an appropriate argument
before applying it.
\end{entry}


\begin{entry}{%
\proto{vector-for-each}{ proc \vari{vector} \varii{vector} \dotsfoo}{procedure}}

\domain{The \var{vector}s must all have the same length.  \var{Proc}
  should accept as many arguments as there are {\it vector}s.}
The {\cf vector-for-each} procedure applies \var{proc}
element-wise to the elements of the
\var{vector}s for its side effects,  in order from the first elements to the
last.
\var{Proc} is always called in the same dynamic environment 
as {\cf vector-for-each} itself.
The return values of {\cf vector-for-each} \areunspecified.

Analogous to {\cf for-each}.

\implresp The implementation must check the restrictions
on \var{proc} to the extent performed by applying it as described.
An
implementation may check whether \var{proc} is an appropriate argument
before applying it.
\end{entry}

\section{Errors and violations}
% \label{errorviolation}

\begin{entry}{%
\proto{error}{ who message \vari{irritant} \dotsfoo}{procedure}
\proto{assertion-violation}{ who message \vari{irritant} \dotsfoo}{procedure}}

\domain{\var{Who} must be a string or a symbol or \schfalse{}.
  \var{Message} must be a string.
  The \var{irritant}s are arbitrary objects.}

These procedures raise an exception.  The {\cf error}
procedure should be called when an error has occurred, typically caused by
something that has gone wrong in the interaction of the program with the
external world or the user.  The {\cf assertion-violation} procedure
should be called when an invalid call to a procedure was made, either passing an
invalid number of arguments, or passing an argument that it is not
specified to handle.

The \var{who} argument should describe the procedure or operation that
detected the exception.  The \var{message} argument should describe
the exceptional situation.  The \var{irritant}s should be the arguments
to the operation that detected the operation.

The condition object provided with the exception (see
library chapter~\extref{lib:exceptionsconditionschapter}{Exceptions
  and conditions}) has the following condition types:
%
\begin{itemize}
\item If \var{who} is not \schfalse, the condition has condition type
  {\cf \&who}, with \var{who} as the value of its field.  In
  that case, \var{who} should be the name of the procedure or entity that
  detected the exception.  If it is \schfalse, the condition does not
  have condition type {\cf \&who}.
\item The condition has condition type {\cf \&message}, with
  \var{message} as the value of its field.
\item The condition has condition type {\cf \&irritants}, and its
  field has as its value a list of the \var{irritant}s.
\end{itemize}
%
Moreover, the condition created by {\cf error} has condition type 
{\cf \&error}, and the condition created by {\cf assertion-\hp{}violation} has
condition type {\cf \&assertion}.

\begin{scheme}
(define (fac n)
  (if (not (integer-valued? n))
      (assertion-violation
       'fac "non-integral argument" n))
  (if (negative? n)
      (assertion-violation
       'fac "negative argument" n))
  (letrec
    ((loop (lambda (n r)
             (if (zero? n)
                 r
                 (loop (- n 1) (* r n))))))
      (loop n 1)))

(fac 5) \ev 120
(fac 4.5) \xev \exception{\&assertion}
(fac -3) \xev \exception{\&assertion}%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{assert}{ \hyper{expression}}{\exprtype}}

An {\cf assert} form is evaluated by evaluating \hyper{expression}.
If \hyper{expression} returns a true value, that value is returned
from the {\cf assert} expression.  If \hyper{expression} returns
\schfalse, an exception with condition types {\cf \&assertion} and
{\cf \&message} is raised.  The message provided in the condition
object is implementation-dependent.

\begin{note}
  Implementations should exploit the fact that
  {\cf assert} is syntax to provide as much information as possible
  about the location of the assertion failure.
\end{note}
\end{entry}

\section{Control features}
% \label{controlsection}
% \label{valuessection}
 
This chapter describes various primitive procedures which control the
flow of program execution in special ways.

\begin{entry}{%
\proto{apply}{ proc \vari{arg} $\ldots$ rest-args}{procedure}}

\domain{\var{Rest-args} must be a list.
 \var{Proc} should accept $n$ arguments, where $n$ is
  number of \var{arg}s plus the length of \var{rest-args}.}
The {\cf apply} procedure calls \var{proc} with the elements of the list
{\cf(append (list \vari{arg} \dotsfoo) \var{rest-args})} as the actual
arguments.

If a call to {\cf apply} occurs in a tail context, the call
to \var{proc} is also in a tail context.

\begin{scheme}
(apply + (list 3 4))              \ev  7

(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))

((compose sqrt *) 12 75)              \ev  30%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{call-with-current-continuation}{ proc}{procedure}
\proto{call/cc}{ proc}{procedure}}

% \label{continuations} \domain{\var{Proc} should accept one
argument.} The procedure {\cf call-with-current-continuation} 
(which is the same as the procedure {\cf call/cc}) packages
the current continuation as an ``escape
procedure''\mainindex{escape procedure} and passes it as an argument to
\var{proc}.  The escape procedure is a Scheme procedure that, if it is
later called, will abandon whatever continuation is in effect at that later
time and will instead reinstate the continuation that was in effect
when the escape procedure was created.  Calling the escape procedure
may cause the invocation of \var{before} and \var{after} procedures installed using
\ide{dynamic-wind}.

The escape procedure accepts the same number of arguments as the
continuation of the original call to {\cf call-\hp{}with-\hp{}current-\hp{}continuation}.

The escape procedure that is passed to \var{proc} has
unlimited extent just like any other procedure in Scheme.  It may be stored
in variables or data structures and may be called as many times as desired.

If a call to {\cf call-with-current-continuation} occurs in a tail
context, the call to \var{proc} is also in a tail context.

The following examples show only some ways in which
{\cf call-with-current-continuation} is used.  If all real uses were as
simple as these examples, there would be no need for a procedure with
the power of {\cf call-\hp{}with-\hp{}current-\hp{}continuation}.

\begin{scheme}
(call-with-current-continuation
  (lambda (exit)
    (for-each (lambda (x)
                (if (negative? x)
                    (exit x)))
              '(54 0 37 -3 245 19))
    \schtrue))                        \ev  -3

(define list-length
  (lambda (obj)
    (call-with-current-continuation
      (lambda (return)
        (letrec ((r
                  (lambda (obj)
                    (cond ((null? obj) 0)
                          ((pair? obj)
                           (+ (r (cdr obj)) 1))
                          (else (return \schfalse))))))
          (r obj))))))

(list-length '(1 2 3 4))            \ev  4

(list-length '(a b . c))            \ev  \schfalse%

(call-with-current-continuation procedure?)
                            \ev  \schtrue%
\end{scheme}

\begin{note}
  Calling an escape procedure reenters the dynamic extent of the call
  to {\cf call-with-current-continuation}, and thus restores its
  dynamic environment; see section~\ref{dynamicenvironmentsection}.
\end{note}

\end{entry}

\begin{entry}{%
\proto{values}{ obj $\ldots$}{procedure}}

Delivers all of its arguments to its continuation.
The {\cf values} procedure might be defined as follows:
\begin{scheme}
(define (values . things)
  (call-with-current-continuation 
    (lambda (cont) (apply cont things))))%
\end{scheme}

The continuations of all non-final expressions within a sequence of
expressions, such as in {\cf lambda}, {\cf begin}, {\cf let}, {\cf
  let*}, {\cf letrec}, {\cf letrec*}, {\cf let-values}, {\cf
  let*-values}, {\cf case}, and {\cf cond} forms, usually take an
arbitrary number of values.

Except for these and the continuations created by {\cf
  call-\hp{}with-\hp{}values}, {\cf let-values}, and {\cf let*-values},
continuations implicitly accepting a single value, such as the
continuations of \hyper{operator} and \hyper{operand}s of procedure
calls or the \hyper{test} expressions in conditionals, take exactly
one value.  The effect of passing an inappropriate number of values to
such a continuation is undefined.
\end{entry}

\begin{entry}{%
\proto{call-with-values}{ producer consumer}{procedure}}

\domain{\var{Producer} must be a procedure and should accept zero
  arguments.  \var{Consumer} must be a procedure and should accept as many
  values as \var{producer} returns.}
The {\cf call-\hp{}with-\hp{}values} procedure calls \var{producer} with no arguments and
a continuation that, when passed some values, calls the
\var{consumer} procedure with those values as arguments.
The continuation for the call to \var{consumer} is the
continuation of the call to {\tt call-with-values}.

\begin{scheme}
(call-with-values (lambda () (values 4 5))
                  (lambda (a b) b))
                                                   \ev  5

(call-with-values * -)                             \ev  -1%
\end{scheme}

If a call to {\cf call-with-values} occurs in a tail context, the call
to \var{consumer} is also in a tail context.

\implresp After \var{producer} returns, the implementation must check
that \var{consumer} accepts as many values as \var{consumer} has
returned.
\end{entry}

\begin{entry}{%
\proto{dynamic-wind}{ before thunk after}{procedure}}

\domain{\var{Before}, \var{thunk}, and \var{after} must be procedures,
  and each should accept zero arguments.  These procedures may return
  any number of values.}  The {\cf dynamic-wind} procedure calls
\var{thunk} without arguments, returning the results of this call.
Moreover, {\cf dynamic-wind} calls \var{before} without arguments
whenever the dynamic extent of the call to \var{thunk} is entered, and
\var{after} without arguments whenever the dynamic extent of the call
to \var{thunk} is exited.  Thus, in the absence of calls to escape
procedures created by {\cf call-with-current-continuation}, {\cf
  dynamic-wind} calls \var{before}, \var{thunk}, and \var{after}, in
that order.

While the calls to \var{before} and \var{after} are not considered to be
within the dynamic extent of the call to \var{thunk}, calls to the \var{before}
and \var{after} procedures of any other calls to {\cf dynamic-wind} that occur
within the dynamic extent of the call to \var{thunk} are considered to be
within the dynamic extent of the call to \var{thunk}.

More precisely, an escape procedure transfers control out of the
dynamic extent of a set of zero or more active {\cf dynamic-wind}
calls $x\ \dots$ and transfer control into the dynamic extent
of a set of zero or more active {\cf dynamic-wind} calls
$y\ \dots$.  
It leaves the dynamic extent of the most recent $x$ and calls without
arguments the corresponding \var{after} procedure.
If the \var{after} procedure returns, the escape procedure proceeds to
the next most recent $x$, and so on.
Once each $x$ has been handled in this manner,
the escape procedure calls without arguments the \var{before} procedure
corresponding to the least recent $y$.
If the \var{before} procedure returns, the escape procedure reenters the
dynamic extent of the least recent $y$ and proceeds with the next least
recent $y$, and so on.
Once each $y$ has been handled in this manner, control is transferred to
the continuation packaged in the escape procedure.

\implresp The implementation must check the restrictions on
\var{thunk} and \var{after} only if they are actually called.

\begin{scheme}
(let ((path '())
      (c \#f))
  (let ((add (lambda (s)
               (set! path (cons s path)))))
    (dynamic-wind
      (lambda () (add 'connect))
      (lambda ()
        (add (call-with-current-continuation
               (lambda (c0)
                 (set! c c0)
                 'talk1))))
      (lambda () (add 'disconnect)))
    (if (< (length path) 4)
        (c 'talk2)
        (reverse path))))
    \lev (connect talk1 disconnect
               connect talk2 disconnect)

(let ((n 0))
  (call-with-current-continuation
    (lambda (k)
      (dynamic-wind
        (lambda ()
          (set! n (+ n 1))
          (k))
        (lambda ()
          (set! n (+ n 2)))
        (lambda ()
          (set! n (+ n 4))))))
  n) \ev 1

(let ((n 0))
  (call-with-current-continuation
    (lambda (k)
      (dynamic-wind
        values
        (lambda ()
          (dynamic-wind
            values
            (lambda ()
              (set! n (+ n 1))
              (k))
            (lambda ()
              (set! n (+ n 2))
              (k))))
        (lambda ()
          (set! n (+ n 4))))))
  n) \ev 7%
\end{scheme}

\begin{note}
  Entering a dynamic extent restores its dynamic environment; see
  section~\ref{dynamicenvironmentsection}.
\end{note}
\end{entry}

\section{Iteration}\unsection

\begin{entry}{%
\rproto{let}{ \hyper{variable} \hyper{bindings} \hyper{body}}{\exprtype}}

% \label{namedlet}
``Named {\cf let}'' is a variant on the syntax of \ide{let} that provides
a general looping construct and may also be used to express
recursion.
It has the same syntax and semantics as ordinary {\cf let}
except that \hyper{variable} is bound within \hyper{body} to a procedure
whose parameters are the bound variables and whose body is
\hyper{body}.  Thus the execution of \hyper{body} may be repeated by
invoking the procedure named by \hyper{variable}.

%                                              |  <-- right margin
\begin{scheme}
(let loop ((numbers '(3 -2 1 6 -5))
           (nonneg '())
           (neg '()))
  (cond ((null? numbers) (list nonneg neg))
        ((>= (car numbers) 0)
         (loop (cdr numbers)
               (cons (car numbers) nonneg)
               neg))
        ((< (car numbers) 0)
         (loop (cdr numbers)
               nonneg
               (cons (car numbers) neg))))) %
  \lev  ((6 1 3) (-5 -2))%
\end{scheme}

\end{entry}

\section{Quasiquotation}\unsection
% \label{quasiquotesection}

\begin{entry}{%
\proto{quasiquote}{ \hyper{qq template}}{\exprtype}
\litproto{unquote}
\litproto{unquote-splicing}}

``Backquote'' or ``quasiquote''\index{backquote} expressions are useful
for constructing a list or vector structure when some but not all of the
desired structure is known in advance.  

\syntax \hyper{Qq template} should be as specified by the grammar at
the end of this entry.

\semantics If no
{\cf unquote} or {\cf unquote-splicing} forms
appear within the \hyper{qq template}, the result of
evaluating
{\cf (quasiquote \hyper{qq template})} is equivalent to the result of evaluating
{\cf (quote \hyper{qq template})}.

If an {\cf (unquote \hyper{expression} \dotsfoo)} form appears inside a
\hyper{qq template}, however, the \hyper{expression}s are evaluated
(``unquoted'') and their results are inserted into the structure instead
of the {\cf unquote} form.

If an {\cf (unquote-splicing \hyper{expression} \dotsfoo)} form
appears inside a \hyper{qq template}, then the \hyper{expression}s must
evaluate to lists; the opening and closing parentheses of the lists are
then ``stripped away'' and the elements of the lists are inserted in
place of the {\cf unquote-splicing} form.

Any {\cf unquote-splicing} or multi-operand {\cf unquote} form must
appear only within a list or vector \hyper{qq template}.

As noted in section~\ref{abbreviationsection},
{\cf (quasiquote \hyper{qq template})} may be abbreviated
\backquote\hyper{qq template},
{\cf (unquote \hyper{expression})} may be abbreviated
{\cf,}\hyper{expression}, and
{\cf (unquote-splicing \hyper{expression})} may be abbreviated
{\cf,}\atsign\hyper{expression}.

\begin{scheme}
`(list ,(+ 1 2) 4)  \ev  (list 3 4)
(let ((name 'a)) `(list ,name ',name)) %
          \lev  (list a (quote a))
`(a ,(+ 1 2) ,@(map abs '(4 -5 6)) b) %
          \lev  (a 3 4 5 6 b)
`(({\cf foo} ,(- 10 3)) ,@(cdr '(c)) . ,(car '(cons))) %
          \lev  ((foo 7) . cons)
`\#(10 5 ,(sqrt 4) ,@(map sqrt '(16 9)) 8) %
          \lev  \#(10 5 2 4 3 8)
(let ((name 'foo))
  `((unquote name name name)))%
          \lev (foo foo foo)
(let ((name '(foo)))
  `((unquote-splicing name name name)))%
          \lev (foo foo foo)
(let ((q '((append x y) (sqrt 9))))
  ``(foo ,,@q)) \lev `(foo
                 (unquote (append x y) (sqrt 9)))
(let ((x '(2 3))
      (y '(4 5)))
  `(foo (unquote (append x y) (sqrt 9)))) \lev (foo (2 3 4 5) 3)%
\end{scheme}

Quasiquote forms may be nested.  Substitutions are made only for
unquoted components appearing at the same nesting level
as the outermost {\cf quasiquote}.  The nesting level increases by one inside
each successive quasiquotation, and decreases by one inside each
unquotation.

\begin{scheme}
`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f) %
          \lev  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)
(let ((name1 'x)
      (name2 'y))
  `(a `(b ,,name1 ,',name2 d) e)) %
          \lev  (a `(b ,x ,'y d) e)%
\end{scheme}

A {\cf quasiquote} expression may return either fresh, mutable objects
or literal structure for any structure that is constructed at run time
during the evaluation of the expression.  Portions that do not need to
be rebuilt are always literal.  Thus,
%
\begin{scheme}
(let ((a 3)) `((1 2) ,a ,4 ,'five 6))%
\end{scheme}
%
may be equivalent to either of the following expressions:
%
\begin{scheme}
'((1 2) 3 4 five 6)
(let ((a 3)) 
  (cons '(1 2)
        (cons a (cons 4 (cons 'five '(6))))))%
\end{scheme}
%
However, it is not equivalent to this expression:
%
\begin{scheme}
(let ((a 3)) (list (list 1 2) a 4 'five 6))
\end{scheme}
%
It is a syntax violation if any of the identifiers
\ide{quasiquote}, \ide{unquote}, or \ide{unquote-splicing} appear in
positions within a \hyper{qq template} otherwise than as described above.

The following grammar for quasiquote expressions is not context-free.
It is presented as a recipe for generating an infinite number of
production rules.  Imagine a copy of the following rules for $D = 1, 2,
3, \ldots$.  $D$ keeps track of the nesting depth.

\begin{grammar}%
\meta{qq template} \: \meta{qq template 1}
\meta{qq template 0} \: \meta{expression}
\meta{quasiquotation $D$} \: (quasiquote \meta{qq template $D$})
\meta{qq template $D$} \: \meta{lexeme datum}
\>    \| \meta{list qq template $D$}
\>    \| \meta{vector qq template $D$}
\>    \| \meta{unquotation $D$}
\meta{list qq template $D$} \: (\arbno{\meta{qq template or splice $D$}})
\>    \| (\atleastone{\meta{qq template or splice $D$}} .\ \meta{qq template $D$})
\>    \| \meta{quasiquotation $D+1$}
\meta{vector qq template $D$} \: \#(\arbno{\meta{qq template or splice $D$}})
\meta{unquotation $D$} \: (unquote \meta{qq template $D-1$})
\meta{qq template or splice $D$} \: \meta{qq template $D$}
\>    \| \meta{splicing unquotation $D$}
\meta{splicing unquotation $D$} \:
\>\> (unquote-splicing \arbno{\meta{qq template $D-1$}})
\>    \| (unquote \arbno{\meta{qq template $D-1$}}) %
\end{grammar}

In \meta{quasiquotation}s, a \meta{list qq template $D$} can sometimes
be confused with either an \meta{un\-quota\-tion $D$} or a \meta{splicing
un\-quo\-ta\-tion $D$}.  The interpretation as an
\meta{un\-quo\-ta\-tion} or \meta{splicing
un\-quo\-ta\-tion $D$} takes precedence.

\end{entry}

\section{Binding constructs for syntactic keywords}
% \label{bindsyntax}

The {\cf let-syntax} and {\cf letrec-syntax} forms 
bind keywords.
Like a {\cf begin} form, a {\cf let-syntax} or {\cf letrec-syntax} form
may appear in a definition context, in which case it is treated as a
definition, and the forms in the body must also be
definitions.
A {\cf let-syntax} or {\cf letrec-syntax} form may also appear in an
expression context, in which case the forms within their bodies must be
expressions.

\begin{entry}{%
\proto{let-syntax}{ \hyper{bindings} \hyper{form} \dotsfoo}{\exprtype}}

\syntax
\hyper{Bindings} must have the form
\begin{scheme}
((\hyper{keyword} \hyper{expression}) \dotsfoo)%
\end{scheme}
Each \hyper{keyword} is an identifier,
and each \hyper{expression} is 
an expression that evaluates, at macro-expansion
time, to a \textit{transformer}\index{transformer}\index{macro transformer}.
Transformers may be created by {\cf syntax-rules} or {\cf identifier-syntax}
(see section~\ref{syntaxrulessection}) or by one of the other mechanisms
described in library chapter~\extref{lib:syntaxcasechapter}{{\cf syntax-case}}.  It is a
syntax violation for \hyper{keyword} to appear more than once in the list of keywords
being bound.

\semantics
The \hyper{form}s are expanded in the syntactic environment
obtained by extending the syntactic environment of the
{\cf let-syntax} form with macros whose keywords are
the \hyper{keyword}s, bound to the specified transformers.
Each binding of a \hyper{keyword} has the \hyper{form}s as its region.

The \hyper{form}s of a {\cf let-syntax}
form are treated, whether in definition or expression context, as if
wrapped in an implicit {\cf begin}; see section~\ref{begin}.
Thus definitions in the result of expanding the \hyper{form}s have
the same region as any definition appearing in place of the {\cf
  let-syntax} form would have.

\implresp The implementation should detect if the value of
\hyper{expression} cannot possibly be a transformer.

\begin{scheme}
(let-syntax ((when (syntax-rules ()
                     ((when test stmt1 stmt2 ...)
                      (if test
                          (begin stmt1
                                 stmt2 ...))))))
  (let ((if \schtrue))
    (when if (set! if 'now))
    if))                           \ev  now

(let ((x 'outer))
  (let-syntax ((m (syntax-rules () ((m) x))))
    (let ((x 'inner))
      (m))))                       \ev  outer%

(let ()
  (let-syntax
    ((def (syntax-rules ()
            ((def stuff ...) (define stuff ...)))))
    (def foo 42))
  foo) \ev 42

(let ()
  (let-syntax ())
  5) \ev 5%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{letrec-syntax}{ \hyper{bindings} \hyper{form} \dotsfoo}{\exprtype}}

\syntax
Same as for {\cf let-syntax}.

\semantics
The \hyper{form}s are
expanded in the syntactic environment obtained by
extending the syntactic environment of the {\cf letrec-syntax}
form with macros whose keywords are the
\hyper{keyword}s, bound to the specified transformers.
Each binding of a \hyper{keyword} has the \hyper{bindings}
as well as the \hyper{form}s within its region,
so the transformers can
transcribe forms into uses of the macros
introduced by the {\cf letrec-syntax} form.

The \hyper{form}s of a {\cf letrec-syntax}
form are treated, whether in definition or expression context, as if
wrapped in an implicit {\cf begin}; see section~\ref{begin}.
Thus definitions in the result of expanding the \hyper{form}s have
the same region as any definition appearing in place of the {\cf
  letrec-syntax} form would have.

\implresp The implementation should detect if the value of
\hyper{expression} cannot possibly be a transformer.

\begin{scheme}
(letrec-syntax
  ((my-or (syntax-rules ()
            ((my-or) \schfalse)
            ((my-or e) e)
            ((my-or e1 e2 ...)
             (let ((temp e1))
               (if temp
                   temp
                   (my-or e2 ...)))))))
  (let ((x \schfalse)
        (y 7)
        (temp 8)
        (let odd?)
        (if even?))
    (my-or x
           (let temp)
           (if y)
           y)))        \ev  7%
\end{scheme}

The following example highlights how {\cf let-syntax}
and {\cf letrec-syntax} differ.

\begin{scheme}
(let ((f (lambda (x) (+ x 1))))
  (let-syntax ((f (syntax-rules ()
                    ((f x) x)))
               (g (syntax-rules ()
                    ((g x) (f x)))))
    (list (f 1) (g 1)))) \lev (1 2)

(let ((f (lambda (x) (+ x 1))))
  (letrec-syntax ((f (syntax-rules ()
                       ((f x) x)))
                  (g (syntax-rules ()
                       ((g x) (f x)))))
    (list (f 1) (g 1)))) \lev (1 1)%
\end{scheme}

The two expressions are identical except that the {\cf let-syntax} form
in the first expression is a {\cf letrec-syntax} form in the second.
In the first expression, the {\cf f} occurring in {\cf g} refers to
the {\cf let}-bound variable {\cf f}, whereas in the second it refers
to the keyword {\cf f} whose binding is established by the
{\cf letrec-syntax} form.
\end{entry}

\section{Macro transformers}
% \label{syntaxrulessection}

\begin{entry}{%
\pproto{(syntax-rules (\hyper{literal} \dotsfoo) \hyper{syntax rule} \dotsfoo)}{\exprtype~({\cf expand})}
\litprotoexpandnoindex{\_}
\litprotoexpand{...}}
\mainschindex{syntax-rules}\schindex{\_}

\syntax Each \hyper{literal} must be an identifier.
Each \hyper{syntax rule} must have the following form:

\begin{scheme}
(\hyper{srpattern} \hyper{template})%
\end{scheme}

An \hyper{srpattern} is a restricted form of \hyper{pattern},
namely, a nonempty \hyper{pattern} in one of four parenthesized forms below
whose first subform is an identifier or an underscore {\cf \_}\schindex{\_}.
A \hyper{pattern} is an identifier, constant, or one of the following.

\begin{schemenoindent}
(\hyper{pattern} \ldots)
(\hyper{pattern} \hyper{pattern} \ldots . \hyper{pattern})
(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots)
(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots . \hyper{pattern})
\#(\hyper{pattern} \ldots)
\#(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots)%
\end{schemenoindent}

An \hyper{ellipsis} is the identifier ``{\cf ...}'' (three periods).\schindex{...}

A \hyper{template} is a pattern variable, an identifier that
is not a pattern
variable, a pattern datum, or one of the following.

\begin{scheme}
(\hyper{subtemplate} \ldots)
(\hyper{subtemplate} \ldots . \hyper{template})
\#(\hyper{subtemplate} \ldots)%
\end{scheme}

A \hyper{subtemplate} is a \hyper{template} followed by zero or more ellipses.

\semantics An instance of {\cf syntax-rules} evaluates, at
macro-expansion time, to a new macro
transformer by specifying a sequence of hygienic rewrite rules.  A use
of a macro whose keyword is associated with a transformer specified by
{\cf syntax-rules} is matched against the patterns contained in the
\hyper{syntax rule}s, beginning with the leftmost \hyper{syntax rule}.
When a match is found, the macro use is transcribed hygienically
according to the template.  It is a syntax violation when no match is found.

An identifier appearing within a \hyper{pattern} may be an underscore
(~{\cf \_}~), a literal identifier listed in the list of literals
{\cf (\hyper{literal} \dotsfoo)}, or an ellipsis (~{\cf ...}~).
All other identifiers appearing within a \hyper{pattern} are
\textit{pattern variables\mainindex{pattern variable}}.
It is a syntax violation if an ellipsis or underscore appears in {\cf (\hyper{literal} \dotsfoo)}.

While the first subform of \hyper{srpattern} may be an identifier, the
identifier is not involved in the matching and
is not considered a pattern variable or literal identifier.

Pattern variables match arbitrary input subforms and
are used to refer to elements of the input.
It is a syntax violation if the same pattern variable appears more than once in a
\hyper{pattern}.

Underscores also match arbitrary input subforms but are not pattern variables
and so cannot be used to refer to those elements.
Multiple underscores may appear in a \hyper{pattern}.

A literal identifier matches an input subform if and only if the input
subform is an identifier and either both its occurrence in the input
expression and its occurrence in the list of literals have the same
lexical binding, or the two identifiers have the same name and both have
no lexical binding.

A subpattern followed by an ellipsis can match zero or more elements of
the input.

More formally, an input form $F$ matches a pattern $P$ if and only if
one of the following holds:

\begin{itemize}
\item $P$ is an underscore (~{\cf \_}~).

\item $P$ is a pattern variable.

\item $P$ is a literal identifier
and $F$ is an identifier such that both $P$ and $F$ would refer to the
same binding if both were to appear in the output of the macro outside
of any bindings inserted into the output of the macro.
(If neither of two like-named identifiers refers to any binding, i.e., both
are undefined, they are considered to refer to the same binding.)

\item $P$ is of the form
{\cf ($P_1$ \dotsfoo{} $P_n$)}
and $F$ is a list of $n$ elements that match $P_1$ through
$P_n$.

\item $P$ is of the form
{\cf ($P_1$ \dotsfoo{} $P_n$ . $P_x$)}
and $F$ is a list or improper list of $n$ or more elements
whose first $n$ elements match $P_1$ through $P_n$
and
whose $n$th cdr matches $P_x$.

\item $P$ is of the form
{\cf ($P_1$ \dotsfoo{} $P_k$ $P_e$ \hyper{ellipsis} $P_{m+1}$ \dotsfoo{} $P_n$)},
where \hyper{ellipsis} is the identifier {\cf ...}
and $F$ is a list of $n$
elements whose first $k$ elements match $P_1$ through $P_k$,
whose next $m-k$ elements each match $P_e$,
and
whose remaining $n-m$ elements match $P_{m+1}$ through $P_n$.

\item $P$ is of the form
{\cf ($P_1$ \dotsfoo{} $P_k$ $P_e$ \hyper{ellipsis} $P_{m+1}$ \dotsfoo{} $P_n$ . $P_x$)},
where \hyper{ellipsis} is the identifier {\cf ...}
and $F$ is a list or improper list of $n$
elements whose first $k$ elements match $P_1$ through $P_k$,
whose next $m-k$ elements each match $P_e$,
whose next $n-m$ elements match $P_{m+1}$ through $P_n$,
and 
whose $n$th and final cdr matches $P_x$.

\item $P$ is of the form
{\cf \#($P_1$ \dotsfoo{} $P_n$)}
and $F$ is a vector of $n$ elements that match $P_1$ through
$P_n$.

\item $P$ is of the form
{\cf \#($P_1$ \dotsfoo{} $P_k$ $P_e$ \hyper{ellipsis} $P_{m+1}$ \dotsfoo{} $P_n$)},
where \hyper{ellipsis} is the identifier {\cf ...}
and $F$ is a vector of $n$ or more elements
whose first $k$ elements match $P_1$ through $P_k$,
whose next $m-k$ elements each match $P_e$,
and
whose remaining $n-m$ elements match $P_{m+1}$ through $P_n$.

\item $P$ is a pattern datum (any nonlist, nonvector, nonsymbol
datum) and $F$ is equal to $P$ in the sense of the
{\cf equal?} procedure.
\end{itemize}

When a macro use is transcribed according to the template of the
matching \hyper{syntax rule}, pattern variables that occur in the
template are replaced by the subforms they match in the input.

Pattern data and identifiers that are not pattern variables
or ellipses are copied into the output.
A subtemplate followed by an ellipsis expands
into zero or more occurrences of the subtemplate.
Pattern variables that occur in subpatterns followed by one or more
ellipses may occur only in subtemplates that are
followed by (at least) as many ellipses.
These pattern variables are replaced in the output by the input
subforms to which they are bound, distributed as specified.
If a pattern variable is followed by more ellipses in the subtemplate
than in the associated subpattern, the input form is replicated as
necessary.
The subtemplate must contain at least one pattern variable from a
subpattern followed by an ellipsis, and for at least one such pattern
variable, the subtemplate must be followed by exactly as many ellipses as
the subpattern in which the pattern variable appears.
(Otherwise, the expander would not be able to determine how many times the
subform should be repeated in the output.)
It is a syntax violation if the constraints of this paragraph are not met.

A template of the form
{\cf (\hyper{ellipsis} \hyper{template})} is identical to \hyper{template}, except that
ellipses within the template have no special meaning.
That is, any ellipses contained within \hyper{template} are
treated as ordinary identifiers.
In particular, the template {\cf (... ...)} produces a single
ellipsis, {\cf ...}.
This allows syntactic abstractions to expand into forms containing
ellipses.

\begin{scheme}
(define-syntax be-like-begin
  (syntax-rules ()
    ((be-like-begin name)
     (define-syntax name
       (syntax-rules ()
         ((name expr (... ...))
          (begin expr (... ...))))))))

(be-like-begin sequence)
(sequence 1 2 3 4) \ev 4%
\end{scheme}

As an example for hygienic use of auxiliary identifier,
if \ide{let} and \ide{cond} are defined as in
section~\ref{let} and appendix~\ref{derivedformsappendix} then they
are hygienic (as required) and the following is not an error.

\begin{scheme}
(let ((=> \schfalse))
  (cond (\schtrue => 'ok)))           \ev ok%
\end{scheme}

The macro transformer for {\cf cond} recognizes {\cf =>}
as a local variable, and hence an expression, and not as the
identifier {\cf =>}, which the macro transformer treats
as a syntactic keyword.  Thus the example expands into

\begin{scheme}
(let ((=> \schfalse))
  (if \schtrue (begin => 'ok)))%
\end{scheme}

instead of

\begin{scheme}
(let ((=> \schfalse))
  (let ((temp \schtrue))
    (if temp ('ok temp))))%
\end{scheme}

which would result in an assertion violation.
\end{entry}

\begin{entry}{%
\proto{identifier-syntax}{ \hyper{template}}{\exprtype~({\cf expand})}
\pproto{(identifier-syntax}{\exprtype~({\cf expand})}}\\
{\tt\obeyspaces
  (\hyperi{id} \hyperi{template})\\
  ((set! \hyperii{id} \hyper{pattern})\\
   \hyperii{template}))\\
\litprotoexpandnoindex{set!}}

\syntax The \hyper{id}s must be identifiers.  The \hyper{template}s
must be as for {\cf syntax-rules}.

\semantics
When a keyword is bound to a transformer produced by the first form of
{\cf identifier-syntax}, references to the keyword within the scope
of the binding are replaced by \hyper{template}.

\begin{scheme}
(define p (cons 4 5))
(define-syntax p.car (identifier-syntax (car p)))
p.car \ev 4
(set! p.car 15) \ev \exception{\&syntax}%
\end{scheme}

The second, more general, form of {\cf identifier-syntax} permits
the transformer to determine what happens when {\cf set!} is used.
In this case, uses of the identifier by itself are replaced by
\hyperi{template}, and uses of {\cf set!} with the identifier are
replaced by \hyperii{template}.

\begin{scheme}
(define p (cons 4 5))
(define-syntax p.car
  (identifier-syntax
    (\_ (car p))
    ((set! \_ e) (set-car! p e))))
(set! p.car 15)
p.car           \ev 15
p               \ev (15 5)%
\end{scheme}

\end{entry}

\section{Tail calls and tail contexts}
% \label{basetailcontextsection}

A {\em tail call}\mainindex{tail call} is a procedure call that occurs
in a {\em tail context}.  Tail contexts are defined inductively.  Note
that a tail context is always determined with respect to a particular lambda
expression.

\begin{itemize}
\item The last expression within the body of a lambda expression,
  shown as \hyper{tail expression} below, occurs in a tail context.
%
\begin{scheme}
(l\=ambda \hyper{formals}
  \>\arbno{\hyper{definition}} 
  \>\arbno{\hyper{expression}} \hyper{tail expression})%
\end{scheme}
%
\item If one of the following expressions is in a tail context,
then the subexpressions shown as \hyper{tail expression} are in a tail context.
These were derived from specifications of the syntax of the forms described in
this chapter by replacing some occurrences of \hyper{expression}
with \hyper{tail expression}.  Only those rules that contain tail contexts
are shown here.
%
\begin{scheme}
(if \hyper{expression} \hyper{tail expression} \hyper{tail expression})
(if \hyper{expression} \hyper{tail expression})

(cond \atleastone{\hyper{cond clause}})
(cond \arbno{\hyper{cond clause}} (else \hyper{tail sequence}))

(c\=ase \hyper{expression}
  \>\atleastone{\hyper{case clause}})
(c\=ase \hyper{expression}
  \>\arbno{\hyper{case clause}}
  \>(else \hyper{tail sequence}))

(and \arbno{\hyper{expression}} \hyper{tail expression})
(or \arbno{\hyper{expression}} \hyper{tail expression})

(let \hyper{bindings} \hyper{tail body})
(let \hyper{variable} \hyper{bindings} \hyper{tail body})
(let* \hyper{bindings} \hyper{tail body})
(letrec* \hyper{bindings} \hyper{tail body})
(letrec \hyper{bindings} \hyper{tail body})
(let-values \hyper{mv-bindings} \hyper{tail body})
(let*-values \hyper{mv-bindings} \hyper{tail body})

(let-syntax \hyper{bindings} \hyper{tail body})
(letrec-syntax \hyper{bindings} \hyper{tail body})

(begin \hyper{tail sequence})%
\end{scheme}
%
A \hyper{cond clause} is 
%
\begin{scheme}
(\hyper{test} \hyper{tail sequence})\textrm{,}%
\end{scheme}
a \hyper{case clause} is
%
\begin{scheme}
((\arbno{\hyper{datum}}) \hyper{tail sequence})\textrm{,}%
\end{scheme}
%
a \hyper{tail body} is
\begin{scheme}
\arbno{\hyper{definition}} \hyper{tail sequence}\textrm{,}%
\end{scheme}
%
and a \hyper{tail sequence} is
%
\begin{scheme}
\arbno{\hyper{expression}} \hyper{tail expression}\textrm{.}%
\end{scheme}%

\item
If a {\cf cond} expression is in a tail context, and has a clause of
the form {\cf (\hyperi{expression} => \hyperii{expression})}
then the (implied) call to
the procedure that results from the evaluation of \hyperii{expression} is in a
tail context.  \hyperii{Expression} itself is not in a tail context.

\end{itemize}

Certain built-in procedures must also perform tail calls.
The first argument passed to {\cf apply} and to
{\cf call-\hp{}with-\hp{}current-continuation}, and the second argument passed to
{\cf call-with-values}, must be called via a tail call.

In the following example the only tail call is the call to {\cf f}.
None of the calls to {\cf g} or {\cf h} are tail calls.  The reference to
{\cf x} is in a tail context, but it is not a call and thus is not a
tail call.
\begin{scheme}%
(lambda ()
  (if (g)
      (let ((x (h)))
        x)
      (and (g) (f))))%
\end{scheme}%

\begin{note}
Implementations may
recognize that some non-tail calls, such as the call to {\cf h}
above, can be evaluated as though they were tail calls.
In the example above, the {\cf let} expression could be compiled
as a tail call to {\cf h}. (The possibility of {\cf h} returning
an unexpected number of values can be ignored, because in that
case the effect of the {\cf let} is explicitly unspecified and
implementation-dependent.)
\end{note}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 


\part{ðŸ“œ File   18: semantics.tex}
%!TEX root = r6rs.tex

This appendix presents a non-normative, formal, operational semantics for Scheme, that is based on an earlier semantics~\cite{mf:scheme-op-sem}. It does not cover the entire language. The notable missing features are the macro system, I/O, and the numerical tower. The precise list of features included is given in section~\ref{sec:semantics:grammar}.

The core of the specification is a single-step term rewriting relation that indicates how an (abstract) machine behaves. In general, the report is not a complete specification, giving implementations freedom to behave differently, typically to allow optimizations. This underspecification shows up in two ways in the semantics. 

The first is reduction rules that reduce to special ``\textbf{unknown:} \textit{string}'' states (where the string provides a description of the unknown state). The intention is that rules that reduce to such states can be replaced with arbitrary reduction rules. The precise specification of how to replace those rules is given in section~\ref{sec:semantics:underspecification}.

The other is that the single-step relation relates one program to
multiple different programs, each corresponding to a legal transition
that an abstract machine might take. Accordingly we use the transitive
closure of the single step relation $\rightarrow^*$ to define the
semantics, \calS, as a function from programs (\calP)
to sets of observable results (\calR):
\begin{center}
\begin{tabular}{l}
$\calS : \calP \longrightarrow 2^{\calR}$ \\
$\calS(\calP) = \{ \scrO(\calA) \mid \calP \rightarrow^* \calA \}$
\end{tabular}
\end{center}
where the function $\scrO$ turns an answer ($\calA$) from the semantics into an observable result. Roughly, $\scrO$ is the identity function on simple base values, and returns a special tag for more complex values, like procedure and pairs.

So, an implementation conforms to the semantics if, for every program $\calP$, the implementation produces one of the results in $\calS(\calP)$ or, if the implementation loops forever, then there is an infinite reduction sequence starting at $\calP$, assuming that the reduction relation $\rightarrow$ has been adjusted to replace the \textbf{unknown:} states.

The precise definitions of $\calP$, $\calA$, $\calR$, and $\scrO$ are also given in section~\ref{sec:semantics:grammar}.

To help understand the semantics and how it behaves, we have
implemented it in PLT Redex. The implementation is available at the
report's website: \url{http://www.r6rs.org/}. All of the reduction
rules and the metafunctions shown in the figures in this semantics
were generated automatically from the source code.

\section{Background}

We assume the reader has a basic familiarity with context-sensitive
reduction semantics. Readers unfamiliar with this system may wish to
consult Felleisen and Flatt's monograph~\cite{ff:monograph} or Wright
and Felleisen~\cite{wf:type-soundness} for a thorough introduction,
including the relevant technical background, or an introduction to PLT
Redex~\cite{mfff:plt-redex} for a somewhat lighter one.

As a rough guide, we define the operational semantics of a language
via a relation on program terms, where the relation corresponds to a
single step of an abstract machine. The relation is defined using
evaluation contexts, namely terms with a distinguished place in them,
called \emph{holes}\index{hole}, where the next step of evaluation
occurs. We say that a term $e$ decomposes into an evaluation
context $E$ and another term $e'$ if $e$ is the
same as $E$ but with the hole replaced by $e'$. We write
$E[e']$ to indicate the term obtained by replacing the hole in
$E$ with $e'$.

For example, assuming that we have defined a grammar containing
non-terminals for evaluation contexts ($E$), expressions
($e$), variables ($x$), and values ($v$), we
would write:
%
\begin{displaymath}
  \begin{array}{l}
    E_1[\texttt{((}\sy{lambda}~\texttt{(}x_1 \cdots{}\texttt{)}~e_1\texttt{)}~v_1~\cdots\texttt{)}] \rightarrow
    \\
    E_1[\{ x_1 \cdots \mapsto v_1 \cdots \} e_1] ~~~~~ (\#x_1 = \#v_1)
  \end{array}
\end{displaymath}
%
to define the $\beta_v$ rewriting rule (as a part of the $\rightarrow$
single step relation). We use the names of the non-terminals (possibly
with subscripts) in a rewriting rule to restrict the application of
the rule, so it applies only when some term produced by that grammar
appears in the corresponding position in the term. If the same
non-terminal with an identical subscript appears multiple times, the
rule only applies when the corresponding terms are structurally
identical (nonterminals without subscripts are not constrained to
match each other). Thus, the occurrence of $E_1$ on both the
left-hand and right-hand side of the rule above means that the context
of the application expression does not change when using this rule.
The ellipses are a form of Kleene star, meaning that zero or more
occurrences of terms matching the pattern proceeding the ellipsis may
appear in place of the the ellipsis and the pattern preceding it. We
use the notation $\{ x_1 \cdots \mapsto v_1 \cdots \} e_1$ for
capture-avoiding substitution; in this case it means that each
$x_1$ is replaced with the corresponding $v_1$ in
$e_1$. Finally, we write side-conditions in parentheses beside
a rule; the side-condition in the above rule indicates that the number
of $x_1$s must be the same as the number of $v_1$s.
Sometimes we use equality in the side-conditions; when we do it merely
means simple term equality, i.e., the two terms must have the
same syntactic shape.


\addtocounter{figure}{1} % get the figure counter in sync with the section counter
\subfigurestart{}
\beginfig
\input{r6-fig-grammar-parti.tex}
\caption{Grammar for programs and observables}\label{fig:grammar}
\endfig

Making the evaluation context $E$ explicit in the rule allows
us to define relations that manipulate their context. As a simple
example, we can add another rule that signals a violation when a
procedure is applied to the wrong number of arguments by discarding
the evaluation context on the right-hand side of a rule:
%
\begin{displaymath}
  \begin{array}{l}
    E[\texttt{((}\sy{lambda}~\texttt{(}x_1 \cdots\texttt{)}~e\texttt{)}~v_1~\cdots\texttt{)}] \rightarrow
    \\
    \textrm{\textbf{violation:} wrong argument count} ~~~~~ (\#x_1 \neq \#v_1)
  \end{array}
\end{displaymath}
%
Later we take advantage of the explicit evaluation context in more
sophisticated ways.



\section{Grammar}\label{sec:semantics:grammar}

\beginfig
\subfigureadjust{}
\input{r6-fig-grammar-partii.tex}
\caption{Grammar for evaluation contexts}\label{fig:ec-grammar}
\endfig
\subfigurestop{}

Figure~\ref{fig:grammar} shows the grammar for the subset of the
report this semantics models. Non-terminals are written in
\textit{italics} or in a calligraphic font ($\calP$
$\calA$, $\calR$, and $\calRv$) and literals are 
written in a \texttt{monospaced} font.

The $\calP$ non-terminal represents possible program states. The
first alternative is a program with a store and an expression. 
The second alternative is an uncaught exception, and the third is
used to indicate a place where the model does not completely specify
the behavior of the primitives it models (see section~\ref{sec:semantics:underspecification} for details of those situations). 
The $\calA$ non-terminal
represents a final result of a program. It is just like $\calP$
except that expression has been reduced to some sequence of values.

The $\calR$ and $\calRv$ non-terminals specify the observable results of a program. Each $\calR$ is either a sequence of values that correspond to the values produced by the program that terminates normally, or a tag indicating an uncaught exception was raised, or \sy{unknown} if the program encounters a situation the semantics does not cover. The $\calRv$ non-terminal specifies what the observable results are for a particular value: a pair, the empty list, a symbol, a self-quoting value (\schtrue, \schfalse, and numbers), a condition, or a procedure.

The \nt{sf} non-terminal generates individual elements of the
store. The store holds all of the mutable state of a program. It is
explained in more detail along with the rules that manipulate it.

Expressions ($\mathit{es}$) include quoted data, \sy{begin} expressions, \sy{begin0} expressions%
\footnote{ \sy{begin0} is not part of the standard, but we include it
  to make the rules for \va{dynamic-wind} and \va{letrec} easier to read. Although
  we model it directly, it can be defined in terms of other forms we
  model here that do come from the standard:
\begin{displaymath}
  \begin{array}{rcl}\tt
    \texttt{(}\sy{begin0}~e_1~e_2~\cdots\texttt{)} &=&
    \begin{array}{l}
      \texttt{(}\va{call\mbox{-}with\mbox{-}values}\\
      ~\texttt{(}\sy{lambda}~\texttt{()}~e_1\texttt{)}\\
      ~\texttt{(}\sy{lambda}~x\\
      ~~~e_2~\cdots\\
      ~~~\texttt{(}\va{apply}~\va{values}~x\texttt{)))}
    \end{array}
  \end{array}
\end{displaymath}
}, application expressions, \sy{if} expressions, \sy{set!}
expressions, variables, non-procedure values (\nt{nonproc}), primitive
procedures (\nt{pproc}), lambda expressions, \sy{letrec} and \sy{letrec*} expressions. 

The last few expression forms are only generated for intermediate states (\sy{dw} for \sy{dynamic-wind}, \sy{throw} for continuations, \sy{unspecified} for the result of the assignment operators, \sy{handlers} for exception handlers, and \sy{l!} and \sy{reinit} for \sy{letrec}), and should not appear in an initial program. Their use is described in the relevant sections of this appendix.

The \nt{f} non-terminal describes the formals for \sy{lambda} expressions. (The \sy{dot} is used instead of a period for procedures that accept an arbitrary number of arguments, in order to avoid meta-circular confusion in our PLT Redex model.) 

The \nt{s} non-terminal covers all datums, which can be either non-empty sequences (\nt{seq}), the empty sequence, self-quoting values (\nt{sqv}), or symbols. Non-empty sequences are either just a sequence of datums, or they are terminated with a dot followed by either a symbol or a self-quoting value. Finally the self-quoting values are numbers and the booleans \semtrue{} and \semfalse{}.

The \nt{p} non-terminal represents programs that have no quoted
data. Most of the reduction rules rewrite \nt{p} to \nt{p},
rather than $\calP$ to $\calP$, since quoted data is first
rewritten into calls to the list construction functions before
ordinary evaluation proceeds. In parallel to \nt{es}, \nt{e} represents
expressions that have no quoted expressions.

\beginfig
\begin{center}
\input{r6-fig-Quote.tex}

\input{r6-fig-QtocQtoic.tex}
\end{center}
\caption{Quote}\label{fig:quote}
\endfig

The values ($v$) are divided into four categories:
%
\begin{itemize}
\item Non-procedures (\nt{nonproc}) include pair pointers
  (\va{pp}), the empty list (\va{null}), symbols, self-quoting values
  (\nt{sqv}), and conditions. Conditions represent
  the report's condition values, but here just contain a message and
  are otherwise inert.
\item User procedures (\texttt{(}\sy{lambda} \nt{f} \nt{e} \nt{e} $\cdots$\texttt{)}) include multi-arity lambda expressions and lambda expressions with dotted parameter lists,
\item Primitive procedures (\nt{pproc}) include

\begin{itemize}
\item
 arithmetic procedures
  (\nt{aproc}): \va{+}, \va{-}, \va{/}, and \va{*}, 
\item 
  procedures of one
  argument (\nt{proc1}): \va{null?}, \va{pair?}, \va{car}, \va{cdr},
  \va{call/cc}, \va{procedure?}, \va{condition?}, \va{unspecified?}, \va{raise}, and \va{raise-continuable}, 
  \item
  procedures of
  two arguments (\nt{proc2}): \va{cons}, \va{set-car!}, \va{set-cdr!}, \va{eqv?},
  and \va{call-with-values}, 
  \item as well as \va{list}, \va{dynamic-wind},
  \va{apply}, \va{values}, and \va{with-exception-handler}.
\end{itemize}
\item Finally, continuations are represented as \sy{throw} expressions
  whose body consists of the context where the continuation was
  grabbed.
\end{itemize}
%
The next three set of non-terminals in figure~\ref{fig:grammar} represent pairs (\nt{pp}), which are divided into immutable pairs (\nt{ip}) and mutable pairs (\nt{mp}). The final set of non-terminals in figure~\ref{fig:grammar}, \nt{sym},
\nt{x}, and $n$ represent symbols, variables, and
numbers respectively. The non-terminals \nt{ip}, \nt{mp}, and \nt{sym} are all assumed to all be disjoint. Additionally, the variables $x$ are assumed not to include any keywords or primitive operations, so any program variables whose names coincide with them must be renamed before the semantics can give the meaning of that program.

\beginfig
\begin{center}
\input{r6-fig-Multiple--values--and--call-with-values.tex}
\end{center}
\caption{Multiple values and call-with-values}\label{fig:Multiple--values--and--call-with-values}
\endfig

The set of non-terminals for evaluation contexts is shown in
figure~\ref{fig:ec-grammar}. The \nt{P} non-terminal controls where
evaluation happens in a program that does not contain any quoted data.
The $E$ and $F$ evaluation contexts are for expressions.  They are factored in
that manner so that the \nt{PG}, \nt{G}, and \nt{H} evaluation contexts can
re-use \nt{F} and have fine-grained control over the context to support
exceptions and \va{dynamic-wind}. The starred and circled variants,
\Estar{}, \Eo{}, \Fstar{}, and \Fo{} dictate where a single value is
promoted to multiple values and where multiple values are demoted to a
single value. The \nt{U} context is used to manage the report's underspecification of the results of \sy{set!}, \va{set-car!}, and \va{set-cdr!} (see section~\ref{sec:semantics:underspecification} for details). Finally, the \nt{S} context is where quoted expressions can be simplified. The precise use of the evaluation contexts is explained along with the relevant rules.

To convert the answers ($\calA$)  of the semantics into observable results, we use these two functions:
\input{r6-fig-observable}
\input{r6-fig-observable-value}
They eliminate the store, and replace complex values with simple tags that indicate only the kind of value that was produced or, if no values were produced, indicates that either an uncaught exception was raised, or that the program reached a state that is not specified by the semantics.

\section{Quote}\label{sec:semantics:quote}

The first reduction rules that apply to any program is the 
rules in figure~\ref{fig:quote} that eliminate quoted expressions. 
The first two rules erase the quote for quoted expressions that do not introduce any pairs.
The last two rules lift quoted datums to the top of the expression so
they are evaluated only once, and turn the datums into calls to either \va{cons} or \va{consi}, via the metafunctions $\mathscr{Q}_i$ and $\mathscr{Q}_m$.

Note that the left-hand side of the \rulename{6qcons} and \rulename{6qconsi} rules are identical, meaning that if one rule applies to a term, so does the other rule. 
Accordingly, a quoted expression may be lifted out into a sequence of \va{cons} expressions, which create mutable pairs, or into a sequence of \va{consi} expressions, which create immutable pairs (see section~\ref{sec:semantics:lists} for the rules on how that happens).

These rules apply before any other because of the contexts in which they, and all of the other rules, apply. In particular, these rule applies in the
\nt{S} context. Figure~\ref{fig:ec-grammar} shows that the
\nt{S} context allows this reduction to apply in
any subexpression of an \nt{e}, as long as all of the
subexpressions to the left have no quoted expressions in them,
although expressions to the right may have quoted expressions.
Accordingly, this rule applies once for each quoted expression in the
program, moving out to the beginning of the program.
The rest of the rules apply in contexts that do not contain any quoted
expressions, ensuring that these rules convert all quoted data
into lists before those rules apply.

Although the identifier \nt{qp} does not have a subscript, the semantics of PLT Redex's ``fresh'' declaration takes special care to ensures that the \nt{qp} on the right-hand side of the rule is indeed the same as the one in the side-condition.

\beginfig
\begin{center}
\input{r6-fig-Exceptions}
\end{center}
\caption{Exceptions}\label{fig:Exceptions}
\endfig

\section{Multiple values}

The basic strategy for multiple values is to add a rule that demotes
$(\va{values}~v)$ to $v$ and another rule that promotes
$v$ to $(\va{values}~v)$. If we allowed these rules to apply
in an arbitrary evaluation context, however, we would get infinite
reduction sequences of endless alternation between promotion and
demotion. So, the semantics allows demotion only in a context
expecting a single value and allows promotion only in a context
expecting multiple values. We obtain this behavior with a small
extension to the Felleisen-Hieb framework (also present in the
operational model for R$^5$RS~\cite{mf:op-r5rs}).
We extend the notation so that
holes have names (written with a subscript), and the context-matching
syntax may also demand a hole of a particular name (also written with
a subscript, for instance $E[e]_{\star}$).  The extension
allows us to give different names to the holes in which multiple
values are expected and those in which single values are expected, and
structure the grammar of contexts accordingly.

To exploit this extension, we use three kinds of holes in the
evaluation context grammar in figure~\ref{fig:ec-grammar}. The
ordinary hole \hole{} appears where the usual kinds of
evaluation can occur. The hole \holes{} appears in contexts that
allow multiple values and \holeone{} appears in
contexts that expect a single value. Accordingly, the rule
\rulename{6promote} only applies in \holes{} contexts, and 
\rulename{6demote} only applies in \holeone{} contexts.

To see how the evaluation contexts are organized to ensure that
promotion and demotion occur in the right places, consider the \nt{F},
\Fstar{} and \Fo{} evaluation contexts. The \Fstar{} and \Fo{}
evaluation contexts are just the same as \nt{F}, except that they allow
promotion to multiple values and demotion to a single value,
respectively. So, the \nt{F} evaluation context, rather than being
defined in terms of itself, exploits \Fstar{} and \Fo{} to dictate
where promotion and demotion can occur. For example, \nt{F} can be
$\texttt{(}\sy{if}~\Fo{}~e~e\texttt{)}$ meaning that demotion from
$\texttt{(}\va{values}~v\texttt{)}$ to
$v$ can occur in the test of an \sy{if} expression.
Similarly, $F$ can be $\texttt{(}\sy{begin}~\Fstar{}~e~e~\cdots\texttt{)}$ meaning that
$v$ can be promoted to $\texttt{(}\va{values}~v\texttt{)}$ in the first subexpression of a \sy{begin}.

In general, the promotion and demotion rules simplify the definitions
of the other rules. For instance, the rule for \sy{if} does not
need to consider multiple values in its first subexpression.
Similarly, the rule for \sy{begin} does not need to consider the
case of a single value as its first subexpression.

\beginfig
\begin{center}
\input{r6-fig-Arithmetic.tex}
\input{r6-fig-Basic--syntactic--forms.tex}
\end{center}
\caption{Arithmetic and basic forms}\label{fig:Arithmetic}
\endfig

The other two rules in
figure~\ref{fig:Multiple--values--and--call-with-values} handle
\va{call-\hp{}with-\hp{}values}. The evaluation contexts for
\va{call-with-values} (in the $F$ non-terminal) allow
evaluation in the body of a procedure that has been passed as the first
argument to \va{call-with-values}, as long as the second argument
has been reduced to a value. Once evaluation inside that procedure
completes, it will produce multiple values (since it is an \Fstar{}
position), and the entire \va{call-with-values} expression reduces
to an application of its second argument to those values, via the rule
\rulename{6cwvd}. Finally, in the
case that the first argument to \va{call-with-values} is a value,
but is not of the form $\texttt{(}\sy{lambda}~\texttt{()}~e\texttt{)}$, the rule
\rulename{6cwvw} wraps it in a thunk to trigger evaluation.

\beginfig
\begin{center}
\input{r6-fig-Cons.tex}
\end{center}
\caption{Lists}\label{fig:Cons}
\endfig

\section{Exceptions}

The workhorses for the exception system are $$\texttt{(}\sy{handlers}~\nt{proc}~\cdots{}~\nt{e}\texttt{)}$$ expressions and the \nt{G} and \nt{PG} evaluation contexts (shown in figure~\ref{fig:ec-grammar}). 
The \sy{handlers} expression records the
active exception handlers (\nt{proc} $\cdots$) in some expression (\nt{e}). The
intention is that only the nearest enclosing \sy{handlers} expression
is relevant to raised exceptions, and the $G$ and \nt{PG} evaluation
contexts help achieve that goal. They are just like their counterparts
\nt{E} and \nt{P}, except that \sy{handlers} expressions cannot occur on the
path to the hole, and the exception system rules take advantage of
that context to find the closest enclosing handler.

To see how the contexts work together with \sy{handler}
expressions, consider the left-hand side of the \rulename{6xunee}
rule in figure~\ref{fig:Exceptions}.
It matches expressions that have a call to \va{raise} or
\va{raise-continuable} (the non-terminal \nt{raise*} matches
both exception-raising procedures) in a \nt{PG}
evaluation context. Since the \nt{PG} context does not contain any
\sy{handlers} expressions, this exception cannot be caught, so
this expression reduces to a final state indicating the uncaught
exception. The rule \rulename{6xuneh} also signals an uncaught
exception, but it covers the case where a \sy{handlers} expression
has exhausted all of the handlers available to it. The rule applies to
expressions that have a \sy{handlers} expression (with no
exception handlers) in an arbitrary evaluation context where a call to
one of the exception-raising functions is nested in the
\sy{handlers} expression. The use of the \nt{G} evaluation
context ensures that there are no other \sy{handler} expressions
between this one and the raise.

The next two rules cover call to the procedure \va{with-exception-handler}.
The \rulename{6xwh1} rule applies when there are no \sy{handler}
expressions. It constructs a new one and applies $\nt{v}_2$ as a
thunk in the \sy{handler} body. If there already is a handler
expression, the \rulename{6xwhn} applies. It collects the current
handlers and adds the new one into a new \sy{handlers} expression
and, as with the previous rule, invokes the second argument to
\va{with-exception-handlers}.

The next two rules cover exceptions that are raised in the context of
a \sy{handlers} expression. If a continuable exception is raised,
\rulename{6xrc} applies. It takes the most recently installed
handler from the nearest enclosing \sy{handlers} expression and
applies it to the argument to \va{raise-continuable}, but in a
context where the exception handlers do not include that latest
handler. The \rulename{6xr} rule behaves similarly, except it
raises a new exception if the handler returns. The new exception is
created with the \sy{make-cond} special form.

\beginfig
\begin{center}
\input{r6-fig-Eqv.tex}
\end{center}
\caption{Eqv}\label{fig:Eqv}
\endfig

The \sy{make-cond} special form is a stand-in for the report's
conditions. It does not evaluate its argument (note its absence from
the $E$ grammar in figure~\ref{fig:ec-grammar}). That argument
is just a literal string describing the context in which the exception
was raised. The only operation on conditions is \va{condition?},
whose semantics are given by the two rules \rulename{6ct} and
\rulename{6cf}.

Finally, the rule \rulename{6xdone} drops a \sy{handlers} expression
when its body is fully evaluated, and the rule \rulename{6weherr}
raises an exception when \va{with-exception-handler} is supplied with
incorrect arguments.

\section{Arithmetic and basic forms}

This model does not include the report's arithmetic, but does include
an idealized form in order to make experimentation with other features
and writing test suites for the model simpler.
Figure~\ref{fig:Arithmetic} shows the reduction rules for the
primitive procedures that implement addition, subtraction,
multiplication, and division. They defer to their mathematical
analogues. In addition, when the subtraction or divison operator are
applied to no arguments, or when division receives a zero as a
divisor, or when any of the arithmetic operations receive a
non-number, an exception is raised.

The bottom half of figure~\ref{fig:Arithmetic} shows the rules for
\sy{if}, \sy{begin}, and \sy{begin0}. The relevant
evaluation contexts are given by the $F$ non-terminal.

The evaluation contexts for \sy{if} only allow evaluation in its
test expression. Once that is a value, the rules reduce
an \sy{if} expression to its consequent if the test is not
\semfalse{}, and to its alternative if it is \semfalse{}.

The \sy{begin} evaluation contexts allow evaluation in the first
subexpression of a begin, but only if there are two or more
subexpressions. In that case, once the first expression has been fully
simplified, the reduction rules drop its value. If there is only a
single subexpression, the \sy{begin} itself is dropped.

\subfigurestart{}
\beginfig
\begin{center}
\input{r6-fig-Procedure--application.tex}
\end{center}
\caption{Procedures \& application}\label{fig:Procedure--application}
\endfig

Like the \sy{begin} evaluation contexts, the \sy{begin0}
evaluation contexts allow evaluation of the first subexpression of a
\sy{begin0} expression when there are two or more subexpressions.
The \sy{begin0} evaluation contexts also allow evaluation in the
second subexpression of a \sy{begin0} expression, as long as the first
subexpression has been fully simplified. The \rulename{6begin0n} rule for
\sy{begin0} then drops a fully simplified second subexpression.
Eventually, there is only a single expression in the \sy{begin0},
at which point the \rulename{begin01} rule fires, and removes the
\sy{begin0} expression.

\section{Lists}\label{sec:semantics:lists}

The rules in figure~\ref{fig:Cons} handle lists. The first two rules handle \va{list} by reducing it to a succession of calls to \va{cons}, followed by \va{null}.

The next two rules, \rulename{6cons} and \rulename{6consi}, allocate new \va{cons} cells.
They both move $\texttt{(}\va{cons}~v_1~v_2\texttt{)}$ into the store, bound to a fresh
pair pointer (see also section~\ref{sec:semantics:quote} for a description of ``fresh''). 
The \rulename{6cons} uses a \nt{mp} variable, to indicate the pair is mutable, and the \rulename{6consi} uses a \nt{ip} variable to indicate the pair is immutable.

The rules \rulename{6car} and \rulename{6cdr} extract the components of a pair from the store when presented with a pair pointer (the \nt{pp} can be either \nt{mp} or \nt{ip}, as shown in figure~\ref{fig:grammar}).

The rules \rulename{6setcar} and \rulename{6setcdr} handle assignment of mutable pairs. 
They replace the contents of the appropriate location in the store with the new value, and reduce to \va{unspecified}. See section~\ref{sec:semantics:underspecification} for an explanation of how \va{unspecified} reduces.

\beginfig
\subfigureadjust{}
\begin{center}
\input{r6-fig-Var-set!d_.tex}
\end{center}
\caption{Variable-assignment relation}\label{fig:varsetd}
\endfig

The next four rules handle the \va{null?} predicate and the \va{pair?} predicate, and the final four rules raise exceptions when \va{car}, \va{cdr}, \va{set-car!} or \va{set-cdr!} receive non pairs.

\section{Eqv}

The rules for \va{eqv?} are shown in figure~\ref{fig:Eqv}. The first two rules cover most of the behavior of \va{eqv?}. 
The first says that when the two arguments to \va{eqv?} are syntactically identical, then \va{eqv?} produces \semtrue{} and the second says that when the arguments are not syntactically identical, then \va{eqv?} produces \semfalse{}. 
The structure of \nt{v} has been carefully designed so that simple term equality corresponds closely to \va{eqv?}'s behavior. 
For example, pairs are represented as pointers into the store and \va{eqv?} only compares those pointers.

The side-conditions on those first two rules ensure that they do not apply when simple term equality does not match the behavior of \va{eqv?}. There are two situations where it does not match: comparing two conditions and comparing two procedures. For the first, the report does not specify \va{eqv?}'s behavior, except to say that it must return a boolean, so the remaining two rules (\rulename{6eqct}, and \rulename{6eqcf}) allow such comparisons to return \semtrue{} or \semfalse{}. Comparing two procedures is covered in section~\ref{sec:semantics:underspecification}. 

\section{Procedures and application}

In evaluating a procedure call, the report leaves
unspecified the order in which arguments are evaluated. So, our reduction system allows multiple, different reductions to occur, one for each possible order of evaluation.

To capture unspecified evaluation order but allow only evaluation that
is consistent with some sequential ordering of the evaluation of an
application's subexpressions, we use non-deterministic choice to first pick
a subexpression to reduce only when we have not already committed to
reducing some other subexpression. To achieve that effect, we limit
the evaluation of application expressions to only those that have a
single expression that is not fully reduced, as shown in the
non-terminal $F$, in figure~\ref{fig:ec-grammar}. To evaluate
application expressions that have more than two arguments to evaluate,
the rule \rulename{6mark} picks one of the subexpressions of an
application that is not fully simplified and lifts it out in its own
application, allowing it to be evaluated. Once one of the lifted
expressions is evaluated, the \rulename{6appN} substitutes its value
back into the original application.

The \rulename{6appN} rule also handles other applications whose
arguments are finished by substituting the first argument for
the first formal parameter in the expression. Its side-condition uses
the relation in figure~\ref{fig:varsetd} to ensure that there are no
\sy{set!} expressions with the parameter $x_1$ as a target.
If there is such an assignment, the \rulename{6appN!} rule applies (see also section~\ref{sec:semantics:quote} for a description of ``fresh'').
Instead of directly substituting the actual parameter for the formal
parameter, it creates a new location in the store, initially bound the
actual parameter, and substitutes a variable standing for that
location in place of the formal parameter. The store, then, handles
any eventual assignment to the parameter. Once all of the parameters
have been substituted away, the rule \rulename{6app0} applies and
evaluation of the body of the procedure begins.

At first glance, the rule \rulename{6appN} appears superfluous, since it seems like the rules could just reduce first by \rulename{6appN!} and then look up the variable when it is evaluated. 
There are two reasons why we keep the \rulename{6appN}, however. 
The first is purely conventional: reducing applications via substitution is taught to us at an early age and is commonly used in rewriting systems in the literature.
The second reason is more technical:  the
\rulename{6mark} rule requires that \rulename{6appN} be applied once $\nt{e}_i$ has been reduced to a value. \rulename{6appN!} would
lift the value into the store and put a variable reference into the application, leading to another use of \rulename{6mark}, and another use of \rulename{6appN!}, which continues forever.

The rule \rulename{6$\mu$app} handles a well-formed application of a function with a dotted parameter lists. 
It such an application into an application of an
ordinary procedure by constructing a list of the extra arguments. Similarly, the rule \rulename{6$\mu$app1} handles an application of a procedure that has a single variable as its parameter list.

The rule \rulename{6var} handles variable lookup in the store and \rulename{6set} handles variable assignment.

The next two rules \rulename{6proct} and \rulename{6procf} handle applications of \va{procedure?}, and the remaining rules cover applications of non-procedures and arity violations.

\beginfig
\subfigureadjust{}
\begin{center}
\input{r6-fig-Apply.tex}
\input{r6-fig-circular_.tex}
\end{center}
\caption{Apply}\label{fig:Apply}
\endfig
\subfigurestop{}

The rules in figure~\ref{fig:Apply} 
cover \va{apply}. 
The first rule, \rulename{6applyf}, covers the case where the last argument to
\va{apply} is the empty list, and simply reduces by erasing the
empty list and the \va{apply}. The second rule, \rulename{6applyc}
covers a well-formed application of \va{apply} where \va{apply}'s final argument is a pair. It
reduces by extracting the components of the pair from the store and
putting them into the application of \va{apply}. Repeated
application of this rule thus extracts all of the list elements passed
to \va{apply} out of the store. 

The remaining five rules cover the
various violations that can occur when using \va{apply}. The first one covers the case where \va{apply} is supplied with a cyclic list. The next four cover applying a
non-procedure, passing a non-list as the last argument, and supplying
too few arguments to \va{apply}.

\section{Call/cc and dynamic wind}

\beginfig
\begin{center}
\input{r6-fig-Call-cc--and--dynamic-wind.tex} \\
\input{r6-fig-TrimpRepoSt.tex}
\end{center}
\caption{Call/cc and dynamic wind}\label{fig:Call-cc--and--dynamic-wind}
\endfig

The specification of \va{dynamic-wind} uses 
$\texttt{(}\sy{dw}~x~e~e~e\texttt{)}$
expressions to record which dynamic-wind \var{thunk}s are active at
each point in the computation. Its first argument is an identifier
that is globally unique and serves to identify invocations of
\va{dynamic-wind}, in order to avoid exiting and re-entering the
same dynamic context during a continuation switch. The second, third,
and fourth arguments are calls to some \var{before}, \var{thunk}, and
\var{after} procedures from a call to \va{dynamic-wind}. Evaluation only
occurs in the middle expression; the \sy{dw} expression only
serves to record which \var{before} and \var{after} procedures need to be run during a
continuation switch. Accordingly, the reduction rule for an
application of \va{dynamic-wind} reduces to a call to the
\var{before} procedure, a \sy{dw} expression and a call to the
\var{after} procedure, as
shown in rule \rulename{6wind} in
figure~\ref{fig:Call-cc--and--dynamic-wind}. The next two rules cover
abuses of the \va{dynamic-wind} procedure: calling it with
non-procedures, and calling it with the wrong number of arguments. The
\rulename{6dwdone} rule erases a \sy{dw} expression when its second
argument has finished evaluating.

The next two rules cover \va{call/cc}. The rule
\rulename{6call/cc} creates a new continuation. It takes the context
of the \va{call/cc} expression and packages it up into a
\sy{throw} expression that represents the continuation. The
\sy{throw} expression uses the fresh variable $x$ to record
where the application of \va{call/cc} occurred in the context for
use in the \rulename{6throw} rule when the continuation is applied.
That rule takes the arguments of the continuation, wraps them with a
call to \va{values}, and puts them back into the place where the
original call to \va{call/cc} occurred, replacing the current
context with the context returned by the $\mathscr{T}$ metafunction.

The $\mathscr{T}$ (for ``trim'') metafunction accepts two $D$ contexts and
builds a context that matches its second argument, the destination
context, except that additional calls to the \var{before} and
\var{after} procedures
from \sy{dw} expressions in the context have been added.

The first clause of the $\mathscr{T}$ metafunction exploits the
$H$ context, a context that contains everything except
\sy{dw} expressions. It ensures that shared parts of the
\va{dynamic-wind} context are ignored, recurring deeper into the
two expression contexts as long as the first \sy{dw} expression in
each have matching identifiers ($x_1$). The final rule is a
catchall; it only applies when all the others fail and thus applies
either when there are no \sy{dw}s in the context, or when the
\sy{dw} expressions do not match. It calls the two other
metafunctions defined in figure~\ref{fig:Call-cc--and--dynamic-wind} and
puts their results together into a \sy{begin} expression.

The $\mathscr{R}$ metafunction extracts all of the \var{before}
procedures from its argument and the $\mathscr{S}$ metafunction extracts all of the \var{after} procedures from its argument. They each construct new contexts and exploit
$H$ to work through their arguments, one \sy{dw} at a time.
In each case, the metafunctions are careful to keep the right
\sy{dw} context around each of the procedures in case a continuation
jump occurs during one of their evaluations. 
Since $\mathscr{R}$,
receives the destination context, it keeps the intermediate
parts of the context in its result.
In contrast
$\mathscr{S}$ discards all of the context except the \sy{dw}s,
since that was the context where the call to the
continuation occurred.

\section{Letrec}

\beginfig
\begin{center}
\input{r6-fig-Letrec.tex}
\end{center}
\caption{Letrec and letrec*}
% \label{fig:Letrec}
\endfig

Figre~\ref{fig:Letrec} shows the rules that handle \sy{letrec} and \sy{letrec*} and the supplementary expressions that they produce, \sy{l!} and \sy{reinit}. As a first approximation, both \va{letrec} and \va{letrec*} reduce by allocating locations in the store to hold the values of the init expressions, initializing those locations to \sy{bh} (for ``black hole''), evaluating the init expressions, and then using \va{l!} to update the locations in the store with the value of the init expressions. They also use \va{reinit} to detect when an init expression in a letrec is reentered via a continuation.

Before considering how \sy{letrec} and \sy{letrec*} use \sy{l!} and \sy{reinit}, first consider how \sy{l!} and \sy{reinit} behave. The first two rules in figure~\ref{fig:Letrec} cover \sy{l!}. It behaves very much like \sy{set!}, but it initializes both ordinary variables, and variables that are current bound to the black hole (\sy{bh}).

The next two rules cover ordinary \sy{set!} when applied to a variable
that is currently bound to a black hole. This situation can arise when
the program assigns to a variable before letrec initializes it, eg
\verb|(letrec ((x (set! x 5))) x)|. The report specifies that either
an implementation should perform the assignment, as reflected in the
\rulename{6setdt} rule or it raise an exception, as reflected in the \rulename{6setdte} rule.

The \rulename{6dt} rule covers the case where a variable is referred
to before the value of a init expression is filled in, which must
always raise an exception.

A \va{reinit} expression is used to detect a program that captures a continuation in an initialization expression and returns to it, as shown in the three rules \rulename{6init}, \rulename{6reinit}, and \rulename{6reinite}. The \va{reinit} form accepts an identifier that is bound in the store to a boolean as its argument. Those are identifiers are initially \semfalse{}. When \va{reinit} is evaluated, it checks the value of the variable and, if it is still \semfalse{}, it changes it to \semtrue{}. If it is already \semtrue{}, then \va{reinit} either just does nothing, or it raises an exception, in keeping with the two legal behaviors of \va{letrec} and \va{letrec*}. 

The last two rules in figure~\ref{fig:Letrec} put together \sy{l!} and \sy{reinit}. The \rulename{6letrec} rule reduces a \sy{letrec} expression to an application expression, in order to capture the unspecified order of evaluation of the init expressions. Each init expression is wrapped in a \sy{begin0} that records the value of the init and then uses \sy{reinit} to detect continuations that return to the init expression. Once all of the init expressions have been evaluated, the procedure on the right-hand side of the rule is invoked, causing the value of the init expression to be filled in the store, and evaluation continues with the body of the original \sy{letrec} expression.

The \rulename{6letrec*} rule behaves similarly, but uses a \sy{begin} expression rather than an application, since the init expressions are evaluated from left to right. Moreover, each init expression is filled into the store as it is evaluated, so that subsequent init expressions can refer to its value.

\section{Underspecification}\label{sec:semantics:underspecification}

\beginfig
\begin{center}
\input{r6-fig-Underspecification.tex}
\end{center}
\caption{Explicitly unspecified behavior}\label{fig:Underspecification}
\endfig

The rules in figure~\ref{fig:Underspecification} cover aspects of the
semantics that are explicitly unspecified. Implementations can replace
the rules \rulename{6ueqv}, \rulename{6uval} and with different rules that cover the left-hand sides and, as long as they follow the informal specification, any replacement is valid. Those three situations correspond to the case when \va{eqv?} applied to two procedures and when multiple values are used in a single-value context.

The remaining rules in figure~\ref{fig:Underspecification} cover the results from the assignment operations, \sy{set!}, \va{set-car!}, and \va{set-cdr!}. An implementation does not adjust those rules, but instead renders them useless by adjusting the rules that insert \va{unspecified}: \rulename{6setcar}, \rulename{6setcdr}, \rulename{6set}, and \rulename{6setd}. Those rules can be adjusted by replacing \va{unspecified} with any number of values in those rules.

So, the remaining rules just specify the minimal behavior that we know that a value or values must have and otherwise reduce to an \textbf{unknown:} state. The rule \rulename{6udemand} drops \va{unspecified} in the \sy{U} context. See figure~\ref{fig:ec-grammar} for the precise definition of \sy{U}, but intuitively it is a context that is only a single expression layer deep that contains expressions whose value depends on the value of their subexpressions, like the first subexpression of a \sy{if}. Following that are rules that discard \va{unspecified} in expressions that discard the results of some of their subexpressions. The \rulename{6ubegin} shows how \sy{begin} discards its first expression when there are more expressions to evaluate. The next two rules, \rulename{6uhandlers} and \rulename{6udw} propagate \va{unspecified} to their context, since they also return any number of values to their context. Finally, the two \va{begin0} rules preserve \va{unspecified} until the rule \rulename{6begin01} can return it to its context.

%\section*{Acknowledgments}
%Thanks to Michael Sperber for many helpful discussions of specific points in the semantics, for spotting many mistakes and places where the formal semantics diverged from the informal semantics, and for generally making it possible for us to keep up with changes to the informal semantics as it developed. Thanks also to Will Clinger for a careful reading of the semantics and its explanation.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 


\part{ðŸ“œ File   19: derived.tex}
\chapter{Sample definitions for derived forms}
% \label{derivedformsappendix}

This appendix contains sample definitions for some of the keywords
described in this report in terms of simpler forms:

\subsubsection*{{\tt cond}}
The {\cf cond} keyword (section~\ref{cond}) 
could be defined in terms of {\cf if}, {\cf let} and {\cf
  begin} using {\cf syntax-rules} as follows:

\begin{scheme}
(define-syntax \ide{cond}
  (syntax-rules (else =>)
    ((cond (else result1 result2 ...))
     (begin result1 result2 ...))
    ((cond (test => result))
     (let ((temp test))
       (if temp (result temp))))
    ((cond (test => result) clause1 clause2 ...)
     (let ((temp test))
       (if temp
           (result temp)
           (cond clause1 clause2 ...))))
    ((cond (test)) test)
    ((cond (test) clause1 clause2 ...)
     (let ((temp test))
       (if temp
           temp
           (cond clause1 clause2 ...))))
    ((cond (test result1 result2 ...))
     (if test (begin result1 result2 ...)))
    ((cond (test result1 result2 ...)
           clause1 clause2 ...)
     (if test
         (begin result1 result2 ...)
         (cond clause1 clause2 ...)))))%
\end{scheme}
\subsubsection*{{\tt case}}
The {\cf case} keyword (section~\ref{case}) could be defined in terms of {\cf let}, {\cf cond}, and
{\cf memv} (see library chapter~\extref{lib:listutilities}{List utilities}) using {\cf syntax-rules} as follows:

\begin{scheme}
(define-syntax \ide{case}
  (syntax-rules (else)
    ((case expr0
       ((key ...) res1 res2 ...)
       ...
       (else else-res1 else-res2 ...))
     (let ((tmp expr0))
       (cond
         ((memv tmp '(key ...)) res1 res2 ...)
         ...
         (else else-res1 else-res2 ...))))
    ((case expr0
       ((keya ...) res1a res2a ...)
       ((keyb ...) res1b res2b ...)
       ...)
     (let ((tmp expr0))
       (cond
         ((memv tmp '(keya ...)) res1a res2a ...)
         ((memv tmp '(keyb ...)) res1b res2b ...)
         ...)))))%
\end{scheme}

\subsubsection*{{\tt let*}}

The {\cf let*} keyword (section~\ref{let*})
could be defined in terms of {\cf let}
using {\cf syntax-rules} as follows:

\begin{scheme}
(define-syntax \ide{let*}
  (syntax-rules ()
    ((let* () body1 body2 ...)
     (let () body1 body2 ...))
    ((let* ((name1 expr1) (name2 expr2) ...)
       body1 body2 ...)
     (let ((name1 expr1))
       (let* ((name2 expr2) ...)
         body1 body2 ...)))))%
\end{scheme}

\subsubsection*{{\tt letrec}}
The {\cf letrec} keyword (section~\ref{letrec})
could be defined approximately in terms of {\cf let}
and {\cf set!} using {\cf syntax-rules}, using a helper
to generate the temporary variables
needed to hold the values before the assignments are made,
as follows:

\begin{scheme}
(define-syntax \ide{letrec}
  (syntax-rules ()
    ((letrec () body1 body2 ...)
     (let () body1 body2 ...))
    ((letrec ((var init) ...) body1 body2 ...)
     (letrec-helper
       (var ...)
       ()
       ((var init) ...)
       body1 body2 ...))))

(define-syntax letrec-helper
  (syntax-rules ()
    ((letrec-helper
       ()
       (temp ...)
       ((var init) ...)
       body1 body2 ...)
     (let ((var <undefined>) ...)
       (let ((temp init) ...)
         (set! var temp)
         ...)
       (let () body1 body2 ...)))
    ((letrec-helper
       (x y ...)
       (temp ...)
       ((var init) ...)
       body1 body2 ...)
     (letrec-helper
       (y ...)
       (newtemp temp ...)
       ((var init) ...)
       body1 body2 ...))))%
\end{scheme}

The syntax {\cf <undefined>} represents an expression that
returns something that, when stored in a location, causes an exception
with condition type {\cf\&assertion} to
be raised if an attempt to read from or write to the location occurs before the
assignments generated by the {\cf letrec} transformation take place.
(No such expression is defined in Scheme.)

A simpler definition using {\cf syntax-case} and {\cf
generate-\hp{}temporaries} is given in library
chapter~\extref{lib:syntaxcasechapter}{{\cf syntax-case}}.

\subsubsection*{{\tt letrec*}}

The {\cf letrec*} keyword could be defined approximately in terms of
{\cf let} and {\cf set!}  using {\cf syntax-rules} as follows:

\begin{scheme}
(define-syntax \ide{letrec*}
  (syntax-rules ()
    ((letrec* ((var1 init1) ...) body1 body2 ...)
     (let ((var1 <undefined>) ...)
       (set! var1 init1)
       ...
       (let () body1 body2 ...)))))%
\end{scheme}

The syntax {\cf <undefined>} is as in the definition of {\cf letrec} above.

\subsubsection*{{\tt let-values}}
The following definition of {\cf let-values} (section~\ref{let-values})
using {\cf syntax-rules}
employs a pair of helpers to
create temporary names for the formals.

\begin{scheme}
(define-syntax let-values
  (syntax-rules ()
    ((let-values (binding ...) body1 body2 ...)
     (let-values-helper1
       ()
       (binding ...)
       body1 body2 ...))))

(define-syntax let-values-helper1
  ;; map over the bindings
  (syntax-rules ()
    ((let-values
       ((id temp) ...)
       ()
       body1 body2 ...)
     (let ((id temp) ...) body1 body2 ...))
    ((let-values
       assocs
       ((formals1 expr1) (formals2 expr2) ...)
       body1 body2 ...)
     (let-values-helper2
       formals1
       ()
       expr1
       assocs
       ((formals2 expr2) ...)
       body1 body2 ...))))

(define-syntax let-values-helper2
  ;; create temporaries for the formals
  (syntax-rules ()
    ((let-values-helper2
       ()
       temp-formals
       expr1
       assocs
       bindings
       body1 body2 ...)
     (call-with-values
       (lambda () expr1)
       (lambda temp-formals
         (let-values-helper1
           assocs
           bindings
           body1 body2 ...))))
    ((let-values-helper2
       (first . rest)
       (temp ...)
       expr1
       (assoc ...)
       bindings
       body1 body2 ...)
     (let-values-helper2
       rest
       (temp ... newtemp)
       expr1
       (assoc ... (first newtemp))
       bindings
       body1 body2 ...))
    ((let-values-helper2
       rest-formal
       (temp ...)
       expr1
       (assoc ...)
       bindings
       body1 body2 ...)
     (call-with-values
       (lambda () expr1)
       (lambda (temp ... . newtemp)
         (let-values-helper1
           (assoc ... (rest-formal newtemp))
           bindings
           body1 body2 ...))))))%
\end{scheme}

\subsubsection*{{\tt let*-values}}

The following macro defines {\cf let*-values} in terms of {\cf let}
and {\cf let-values} using {\cf syntax-rules}:

\begin{scheme}
(define-syntax let*-values
  (syntax-rules ()
    ((let*-values () body1 body2 ...)
     (let () body1 body2 ...))
    ((let*-values (binding1 binding2 ...)
       body1 body2 ...)
     (let-values (binding1)
       (let*-values (binding2 ...)
         body1 body2 ...)))))%
\end{scheme}


\subsubsection*{{\tt let}}

The {\cf let} keyword could be defined in terms of {\cf lambda} and {\cf letrec}
using {\cf syntax-rules} as
follows:

\begin{scheme}
(define-syntax \ide{let}
  (syntax-rules ()
    ((let ((name val) ...) body1 body2 ...)
     ((lambda (name ...) body1 body2 ...)
      val ...))
    ((let tag ((name val) ...) body1 body2 ...)
     ((letrec ((tag (lambda (name ...)
                      body1 body2 ...)))
        tag)
      val ...))))%
\end{scheme}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 


\part{ðŸ“œ File   20: repository.tex}
\chapter{Additional material}
% \label{additionalmaterialappendix}

This report itself, as well as more material related to this report
such as reference implementations of some parts of Scheme and archives of
mailing lists discussing this report is at
\begin{center}
\url{http://www.r6rs.org/}
\end{center}

The Schemers web site at
\begin{center}
\url{http://www.schemers.org/}
\end{center}
as well as the Readscheme site at
\begin{center}
\url{http://library.readscheme.org/}
\end{center}
contain extensive Scheme bibliographies, as well as papers,
programs, implementations, and other material related to Scheme.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 


\part{ðŸ“œ File   21: example.tex}
\chapter{Example }
% \label{exampleappendix}

\nobreak
This section describes an example consisting of the
\library{runge-kutta} library, which provides an {\cf integrate-system}
procedure that integrates the system 
$$y_k^\prime = f_k(y_1, y_2, \ldots, y_n), \; k = 1, \ldots, n$$
of differential equations with the method of Runge-Kutta.

As the \library{runge-kutta} library makes use of the \rsixlibrary{base}
library, its skeleton is as follows:

\begin{scheme}
\#!r6rs
(library (runge-kutta)
  (export integrate-system
          head tail)
  (import (rnrs base))
  \hyper{library body})
\end{scheme}

The procedure definitions described below go in the place of \hyper{library body}.

The parameter {\tt system-derivative} is a function that takes a system
state (a vector of values for the state variables $y_1, \ldots, y_n$)
and produces a system derivative (the values $y_1^\prime, \ldots,
y_n^\prime$).  The parameter {\tt initial-state} provides an initial
system state, and {\tt h} is an initial guess for the length of the
integration step.

The value returned by {\cf integrate-system} is an infinite stream of
system states.

\begin{schemenoindent}
(define integrate-system
  (lambda (system-derivative initial-state h)
    (let ((next (runge-kutta-4 system-derivative h)))
      (letrec ((states
                (cons initial-state
                      (lambda ()
                        (map-streams next states)))))
        states))))%
\end{schemenoindent}

The {\cf runge-kutta-4} procedure takes a function, {\tt f}, that produces a
system derivative from a system state.  The {\cf runge-kutta-4} procedure
produces a function that takes a system state and
produces a new system state.

\begin{schemenoindent}
(define runge-kutta-4
  (lambda (f h)
    (let ((*h (scale-vector h))
          (*2 (scale-vector 2))
          (*1/2 (scale-vector (/ 1 2)))
          (*1/6 (scale-vector (/ 1 6))))
      (lambda (y)
        ;; y {\rm{}is a system state}
        (let* ((k0 (*h (f y)))
               (k1 (*h (f (add-vectors y (*1/2 k0)))))
               (k2 (*h (f (add-vectors y (*1/2 k1)))))
               (k3 (*h (f (add-vectors y k2)))))
          (add-vectors y
            (*1/6 (add-vectors k0
                               (*2 k1)
                               (*2 k2)
                               k3))))))))
%|--------------------------------------------------|

(define elementwise
  (lambda (f)
    (lambda vectors
      (generate-vector
        (vector-length (car vectors))
        (lambda (i)
          (apply f
                 (map (lambda (v) (vector-ref  v i))
                      vectors)))))))

%|--------------------------------------------------|
(define generate-vector
  (lambda (size proc)
    (let ((ans (make-vector size)))
      (letrec ((loop
                (lambda (i)
                  (cond ((= i size) ans)
                        (else
                         (vector-set! ans i (proc i))
                         (loop (+ i 1)))))))
        (loop 0)))))

(define add-vectors (elementwise +))

(define scale-vector
  (lambda (s)
    (elementwise (lambda (x) (* x s)))))%
\end{schemenoindent}

The {\cf map-streams} procedure is analogous to {\cf map}: it applies its first
argument (a procedure) to all the elements of its second argument (a
stream).

\begin{schemenoindent}
(define map-streams
  (lambda (f s)
    (cons (f (head s))
          (lambda () (map-streams f (tail s))))))%
\end{schemenoindent}

Infinite streams are implemented as pairs whose car holds the first
element of the stream and whose cdr holds a procedure that delivers the rest
of the stream.

\begin{schemenoindent}
(define head car)
(define tail
  (lambda (stream) ((cdr stream))))%
\end{schemenoindent}

\bigskip
The following program illustrates the use of {\cf integrate-\hp{}system} in
integrating the system
$$ C {dv_C \over dt} = -i_L - {v_C \over R}$$\nobreak
$$ L {di_L \over dt} = v_C$$
which models a damped oscillator.

\begin{schemenoindent}
\#!r6rs
(import (rnrs base)
        (rnrs io simple)
        (runge-kutta))

(define damped-oscillator
  (lambda (R L C)
    (lambda (state)
      (let ((Vc (vector-ref state 0))
            (Il (vector-ref state 1)))
        (vector (- 0 (+ (/ Vc (* R C)) (/ Il C)))
                (/ Vc L))))))

(define the-states
  (integrate-system
     (damped-oscillator 10000 1000 .001)
     '\#(1 0)
     .01))

(letrec ((loop (lambda (s)
                 (newline)
                 (write (head s))
                 (loop (tail s)))))
  (loop the-states))%
\end{schemenoindent}

This prints output like the following:

\begin{scheme}
\#(1 0)
\#(0.99895054 9.994835e-6)
\#(0.99780226 1.9978681e-5)
\#(0.9965554 2.9950552e-5)
\#(0.9952102 3.990946e-5)
\#(0.99376684 4.985443e-5)
\#(0.99222565 5.9784474e-5)
\#(0.9905868 6.969862e-5)
\#(0.9888506 7.9595884e-5)
\#(0.9870173 8.94753e-5)
\end{scheme}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End: 


\part{ðŸ“œ File   22: changes}
changes between R5.96RS and R5.97RS:

Editorial changes:

- significantly revised the description of the syntactic record layer
- revised the description of constructor descriptors in the procedural record layer
- clarified description of the respective roles of the syntactic record layer
- provided human-language descriptions of many bitwise procedures
- an introductory section on `call-with-current-continuation' was
  added to the overview chapter
- a diagram showing the standard condition hierarchy was added
- reworded port-position to avoid implication that textual port that
  supports port-position must also support set-port-position!
- ports created by open-string-input-port now "should" support
  port-position and set-port-position! (was "implementation dependent")
- the non-normative appendix on file-system mapping was alided

Substantive changes:

- specified tail contexts for ` guard', `when', `unless', 
  `case-lambda', and `syntax-case'
- added `parent-rtd' clause to `define-record-type-descriptor' form
- changed implementation responsibilities for transformer expressions
  so that they should only be checked for non-transformer-ness
- weakened the equivalence for `put-datum' / `get-datum'
- the response to Formal comment #9
  (concerning \<line ending><intraline whitespace>) was properly
  implemented
- the specification of representations of inexact real number objects that
  contain no vertical bar was adjusted

changes between R5.95RS and R5.96RS:

Substantive changes:

- made encoding and decoding exceptions non-continuable, and removed
  the protocol exception handlers could use to address the
  decoding/encoding error
- made `replace' the default error-handling mode of transcoders
- included # in the set of delimiters
- removed empty delimiter
- removed # in place of digits from number representations
- changed "must" on prohibiting multiple versions of the same library
  to "should"
- added (library <library reference>) to <import spec> to resolve
  ambiguity
- made #!fold-case and #!no-fold-case operate at the lexeme level
  rather than the level of syntactic datums
- pluralized library names where applicable
- specified enumeration syntax to only look at the name of the
  argument, not its binding

Editorial changes:

- revised the specification of `dynamic-wind'; added definition of
  "dynamic extent"
- revised the specification of generic arithmetic
- reorganized chapter on "Semantic concepts" and "Notation and
  terminology" into a separate chapter "Requirement levels", an expanded
  chapter "Semantic concepts" and a new chapter "Entry format"
- removed uses of "denote"
- moved "primitive syntax" into its own chapter
- added non-normative appendix non suggested use of square brackets
- added note in non-normative appendix on implementations that allow
  multiple versions of the same library to coexist
- removed (6) from (rnrs ...) library imports in the examples
- added non-normative appendix on use of library versions
- renamed "meaningless flonum" to "unspecified flonum"
- auxiliary identifiers such as ... and _ now have their own entries
- clarify `put-datum / get-datum' invariance

changes between R5.94RS and R5.95RS:

Editorial changes:

- added a separate rationale document
- moved background section and rationale paragraphs to rationale document
- removed a superfluous production <string element> -> <newline>
- clarified that `inexact' may return infinite number for finite argument
- clarified that `string->number' can't raise an exception
- clarified that `set-port-position!', for textual ports, is only
  guaranteed to work on positions *from the same port*
- noted that `equal?' and `equal-hash' must always terminate
- revised the terminology describing numbers

Substantive changes:

- textual ports must no longer have an associated transcoder
- reverted the semantics of `eqv?' to the state of R5.92RS, except
  for procedures, which continue to carry *no* location tag
- extended `flexpt' for negative fl1 if fl2 is an integer
- (exit #f) now means an abnormal exit
- renamed (rnrs i/o ...) libraries to (rnrs io ...)
- renamed `&i/o-file-exists-not' to `&i/o-does-not-exist'
- reinstated #\newline
- `utf16->string' and `utf32->string' were extended according to
  http://lists.r6rs.org/pipermail/r6rs-discuss/2007-May/002399.html
- a bogus `obj' argument from `make-assertion-violation' was removed

changes between R5.93RS and R5.94RS:

- added report with non-normative appendices

Editorial changes:

- added reference for "endianness"
- fixed ordering issue with `letrec' and `letrec*' specifications
- synchronized descriptions of levels of exported identifiers
- replaced "datums" by "data"
- miscellaneous changes and typo fixes
- revised description on "entry format" and "argument and subform checking"
- clarified description of `eq?' and `eqv?'
- deleted mention of "implementation-specific declarations"
- improved description of `apply'
- made the example `defun' macro actually look like `defun'
- added more complete acknowledgements to the front page of the report
- properly referenced `identifier-syntax' in section on macro uses
- noted that #\newline has been removed
- various miscellaneous changes and corrections

Substantive changes:

- (belatedly) deleted `real->single' and `real->double' (Formal comment #122)
- (belatedly) change `flmin' and `flmax' to always return an inexact
  NaN when one or more of the arguments is a NaN (Formal comment #230)
- (belatedly) make bytevectors self-evaluating (Formal comment #154)
- (belatedly) add `make-custom-textual-input/output-port' (Formal comment #225)


\part{ðŸ“œ File   23: r6rs-app.tex}
 \documentclass[twoside,twocolumn]{algol60}
%\documentclass[twoside]{algol60}

\pagestyle{headings} 
\showboxdepth=0
%\makeindex
\input{commands}

\texonly
\externaldocument[report:]{r6rs}
\externaldocument[lib:]{r6rs-lib}
\endtexonly

\def\headertitle{Revised$^{\rnrsrevision}$ Scheme Non-Normative Appendices}
\def\TZPtitle{Revised^\rnrsrevision{} Report on the Algorithmic Language Scheme - Rationale -}

\begin{document}

\thispagestyle{empty}

\topnewpage[{
\begin{center}   {\huge\bf
        Revised{\Huge$^{\mathbf{\htmlonly\tiny\endhtmlonly{}\rnrsrevision}}$} Report on the Algorithmic Language \\
                              \vskip 3pt
                              Scheme\\
                                \vskip 1.5ex
                              --- Non-Normative Appendices ---}

\vskip 1ex
$$
\begin{tabular}{l@{\extracolsep{.5in}}lll}
\multicolumn{4}{c}{M\authorsc{ICHAEL} S\authorsc{PERBER}}
\\
\multicolumn{4}{c}{R.\ K\authorsc{ENT} D\authorsc{YBVIG},
  M\authorsc{ATTHEW} F\authorsc{LATT},
  A\authorsc{NTON} \authorsc{VAN} S\authorsc{TRAATEN}}
\\
\multicolumn{4}{c}{(\textit{Editors})} \\[1ex]
\multicolumn{4}{c}{\bf \rnrsrevisiondate}
\end{tabular}
$$



\end{center}

\chapter*{Summary}
\medskip

{\parskip 1ex
This document contains non-normative appendices to the
\textit{Revised\itspace{}$^6$ Report on the Algorithmic Language Scheme}.  These
appendices contain advice for users and suggestions for implementors
on issues not fit for standardization, in particular on platform-specific
issues.

This document frequently refers back to the \textit{Revised\itspace{}$^6$ Report
  on the Algorithmic Language Scheme}~\cite{R6RS} and the
\textit{Revised\itspace{}$^6$ Report on the Algorithmic Language Scheme ---
  Libraries ---}~\cite{R6RS-libraries}; references to the report are
identified by designations such as ``report section'' or ``report
chapter'', and references to the library report are identified by
designations such as ``library section'' or ``library chapter''.
}

\medskip

We intend this report to belong to the entire Scheme community, and so
we grant permission to copy it in whole or in part without fee.  In
particular, we encourage implementors of Scheme to use this report as
a starting point for manuals and other documentation, modifying it as
necessary.
\input{status}
}]

\texonly\clearpage\endtexonly

\chapter*{Contents}
\addvspace{3.5pt}                  % don't shrink this gap
\renewcommand{\tocshrink}{-4.0pt}  % value determined experimentally
{%\footnotesize
\tableofcontents
}

\vfill

\texonly\clearpage\endtexonly

\appendix

\chapter{Standard-conformant mode}
% \label{standardconformantmode}

Scheme implementations compliant with the report may operate in a
variety of modes.  In particular, in addition to one or more modes
conformant with the requirements of the report, an implementation
may offer non-conformant modes.  These modes are by nature
implementation-specific, and may differ in the language and available
libraries.  In particular, non-conformant language extensions may be
available, including unsafe libraries or otherwise unsafe features,
and the semantics of the language may differ from the semantics
described in the report.  Moreover, the default mode offered by a
Scheme implementation may be non-conformant, and such a Scheme
implementation may require special settings or declarations to enter
the report-conformant mode.  Implementors should clearly
document the nature of the default mode and how to enter a
report-conformant mode.

\chapter{Optional case insensitivity}
% \label{caseinsensitivityappendix}

In contrast with earlier revisions of the report~\cite{R5RS}, the
syntax of data distinguishes upper and lower case in identifiers and in
characters specified via their names.  For example, the identifiers
{\cf X} and {\cf x} are different, and the character
{\cf\sharpsign\backwhack{}space} cannot be written
{\cf\sharpsign\backwhack{}SPACE}.

Implementors may wish to support case-insensitive syntax for backward
compatibility or other reasons.
If they do so, they should adopt the following directives
to control case folding.

\begin{entry}{%
{\cf{}\#!fold-case}\sharpbangindex{fold-case}\\
{\cf{}\#!no-fold-case}\sharpbangindex{no-fold-case}}

These directives may appear anywhere comments may appear and are
treated as comments, except that they affect the reading of subsequent
lexemes.
The {\cf{}\#!fold-case} causes the reader to case-fold
(see library section~\extref{lib:string-foldcase}{``Unicode''})
each \meta{identifier} and \meta{character name}.
The {\cf{}\#!no-fold-case} directive causes the reader to return
to the default, non-folding behavior.
\end{entry}

\chapter{Use of square brackets}

Even though matched square brackets are synonymous with parentheses in
the syntax, many programmers use square brackets only in a few select
places.  In particular, programmers should restrict use of
square brackets to places in syntactic forms where two consecutive
open parentheses would otherwise be common.  These are the applicable
forms specified in the report and the library report:
%
\begin{itemize}
\item For {\cf cond} forms (see report section~\extref{report:cond}{Derived
    conditionals}), a \hyper{cond clause} may take one of the follow
  forms:
\begin{scheme}
[\hyper{test} \hyperi{expression} \dotsfoo]
{}[\hyper{test} => \hyper{expression}]
{}[else \hyperi{expression} \hyperii{expression} \dotsfoo]%
\end{scheme}
\item For {\cf case} forms (see report section~\extref{report:case}{Derived
    conditionals}), a \hyper{case clause} may take one of the follow
  forms:
\begin{scheme}
[(\hyperi{datum} \dotsfoo) \hyperi{expression} \hyperii{expression} \dotsfoo]
{}[else \hyperi{expression} \hyperii{expression} \dotsfoo]%
\end{scheme}
\item For {\cf let}, {\cf let*}, {\cf letrec}, {\cf letrec*} forms
  (see report section~\extref{report:let}{Binding constructs}), 
  \hyper{bindings} may take the following form:
\begin{scheme}
([\hyperi{variable} \hyperi{init}] \dotsfoo)%
\end{scheme}
\item For {\cf let-values} and {\cf let-values*} forms 
  (see report section~\extref{report:let}{Binding constructs}),
  \hyper{mv-bindings} may take the following form:
\begin{scheme}
([\hyperi{formals} \hyperi{init}] \dotsfoo)%
\end{scheme}
\item For {\cf syntax-rules} forms (see report
  section~\extref{report:syntax-rules}{Macro transformers}), a
  \hyper{syntax rule} may take the following form:
\begin{scheme}
[\hyper{srpattern} \hyper{template}]%
\end{scheme}
\item For {\cf identifier-syntax} forms (see report
  section~\extref{report:identifier-syntax}{Macro transformers}), the two
  clauses may take the following form:
\begin{scheme}
[\hyperi{id} \hyperi{template}]
{}[(set! \hyperii{id} \hyper{pattern}) \hyperii{template}]%
\end{scheme}
\item For {\cf do} forms (see library
  section~\extref{lib:do}{Control structures}), the variable bindings
  may take the following form:
\begin{scheme}
([\hyperi{variable} \hyperi{init} \hyperi{step}] \dotsfoo)%
\end{scheme}
\item For {\cf case-lambda} forms (see library
  section~\extref{lib:case-lambda}{Control structures}), a
  \hyper{case-lambda clause} may take the following form:
%
\begin{scheme}
[\hyper{formals} \hyper{body}]%
\end{scheme}
\item For {\cf guard} forms (see library section~\extref{lib:guard}{Exceptions}),
a \hyper{cond clause} may take one of the follow forms:
\begin{scheme}
[\hyper{test} \hyperi{expression} \dotsfoo]
{}[\hyper{test} => \hyper{expression}] 
{}[else \hyperi{expression} \hyperii{expression} \dotsfoo]%
\end{scheme}
\item For {\cf syntax-case} forms (see library
  chapter~\extref{lib:syntax-case}{{\tt syntax-case}}), a
  \hyper{syntax-case rule} may take one of the following forms:
\begin{scheme}
[\hyper{pattern} \hyper{output expression}]
{}[\hyper{pattern} \hyper{fender} \hyper{output expression}]%
\end{scheme}
\end{itemize}

\chapter{Scripts}
% \label{scriptappendix}

A \defining{Scheme script\mainindex{script}} is a top-level program 
(see report chapter~\extref{report:programchapter}{Top-level
  programs}) which is packaged such that 
it is directly executable by conforming implementations of Scheme, on 
one or more plaforms.

\section{Script interpreter}

Where applicable, implementations should provide a \defining{script interpreter} in 
the form of an executable program named {\cf scheme-script} that is 
capable of initiating the execution of Scheme scripts, as described 
below.

\begin{rationale}
Distributing a Scheme program that is portable with respect to both 
Scheme implementations and operating systems is challenging, even 
if that program has been written in standard Scheme.  Languages with 
a single or primary implementation can at least rely on a standard 
name for their script interpreters.  Standardizing the name of the 
executable used to start a Scheme script removes one barrier to the 
distribution of Scheme scripts.
\end{rationale}

\section{Syntax}
% \label{scriptsyntaxsection}

A Scheme \defining{script} is a delimited piece of text, typically a
file, which consists of an optional script header, followed by a
top-level program.  A script header has the following syntax:
%
\begin{grammar}
\meta{script header} \: \meta{shebang} /usr/bin/env \meta{space} 
  \> scheme-script \meta{linefeed}
\meta{shebang} \: \#! \| \#! \meta{space}
\end{grammar}

\subsection{Script header}

The \defining{script header}, if present on the first line of a script,
is used by Unix-like operating systems to identify the interpreter to 
execute that script.

The script header syntax given above is the recommended portable 
form that programmers should use.  However, if the first line 
of a script begins with {\cf \#!/} or {\cf \#!\meta{space}}, 
implementations should ignore it on all platforms, even if it does not conform to 
the recommended syntax.  

\begin{rationale}
Requiring script interpreters to recognize and ignore the script 
header helps ensure that Scheme scripts written for Unix-like systems 
can also run on other kinds of systems. Furthermore, recognizing
all {\cf \#!/} or {\cf \#!\meta{space}} combinations 
allows local customizations to be 
performed by altering a script header from its default form.
\end{rationale}

\subsection{Example}
\begin{scheme}
\#!/usr/bin/env scheme-script
\#!r6rs
(import (rnrs base)
        (rnrs io ports)
        (rnrs programs))
(put-bytes (standard-output-port)
           (call-with-port
               (open-file-input-port
                 (cadr (command-line)))
             get-bytes-all))%
\end{scheme}

\section{Platform considerations}
Many platforms require that scripts be marked as executable in some way. 
The platform-specific details of this are beyond the scope of this 
report.  Scripts that are not suitably marked as executable will fail 
to execute on many platforms.
Other platform-specific notes for some popular operating systems follow.

\subsection{Apple Mac OS X}
The Mac OS X operating system supports the Unix-like script header for
shell scripts that run in the Terminal.  Depending on the intended
usage, it may be advisable to choose a file name ending in {\cf
  .command} for a script, as this makes the script double-clickable.
 %TODO: other kind of Mac script?

\subsection{Unix}
Scheme scripts on Unix-like operating systems are supported by the 
presence of the script header.  Scripts that omit the script header 
are unlikely to be directly executable on Unix-like systems.

To support installation of the Scheme script interpreter in 
non-standard paths, scripts should use the {\cf /usr/bin/env} 
program as specified in the recommended script header syntax.  
(Note that on many Unix-like systems, this also allows the 
script interpreter itself to be implemented as a shell script.)

\subsection{Microsoft Windows}
The Windows operating system allows a file extension to be associated 
with a script interpreter such as {\cf scheme-script}.  This 
association may be configured appropriately by Scheme implementations, 
installation programs, or by the user.

\subsection{Selecting an implementation}
If multiple implementations of Scheme are installed on a machine, the
user may wish to specify which implementation should be used to 
execute Scheme scripts by default.  Most platforms support some 
mechanism for choosing between alternative implementations of a 
program.  For example, Debian GNU/Linux uses the {\cf /etc/alternatives} 
mechanism to do this; Microsoft Windows uses file extension 
associations.  Implementations are expected to configure this 
appropriately, e.g., as part of their installation procedure.
Failing that, users must perform any necessary configuration to 
choose their preferred Scheme script interpreter.

\chapter{Source code representation}
% \label{sourcecoderepappendix}

The report does not specify how source code is represented and stored.
The only requirement the report imposes is that the source code of a
top-level program (see report
section~\extref{report:programsyntaxsection}{Top-level program
  syntax}) or a script (see section~\ref{scriptsyntaxsection}) be
delimited.  The source code of a library is self-delimiting in the
sense that, if the beginning of a library form can be identified, so
can the end.

Implementations may take radically different approaches to storing
source code for libraries, among them: files in the file system where
each file contains an arbitrary number of library forms, files in the
file system where each file contains exactly one library form, records
in a database, and data structures in memory.

Similarly, programs and scripts may be stored in a variety of
formats.  Platform constraints may restrict the choices available to
an implementation, which is why the report neither mandates nor
recommends a specific method for storage.

Implementations may provide a means for importing libraries coming
from the outside via an interface that accepts a UTF-8 text file in
Unicode Normalization Form C where line endings are encoded as linefeed
characters.  Such text files may contain an arbitrary number of
library forms.  (Authors of such files should include an
{\cf\#!r6rs} comment if the file is written purely with the lexical
and datum syntax described in the report.  See report
section~\extref{report:whitespaceandcomments}{Whitespace and
  comments}.)  After importing such a file, the libraries defined in
it should be available to other libraries and files.  An
implementation may store the file as is, or convert it to some storage
format to achieve this.

Similarly, implementations may provide a means for executing a program
represented as a UTF-8 text file containing its source code.  Again,
authors of such files should include an {\cf\#!r6rs}
comment if the file is written purely with the lexical and datum syntax
described in the report.  This report does not describe a file format
that allows both libraries and programs to appear in the same file.

\chapter{Use of library versions}

Names for libraries may include a version.  An \hyper{import spec} may
designate a set of acceptable versions that may be imported.
Conversely, only one version of each library should be part of a
program.  This allows using the ``name part'' of a \hyper{library
  name} for different purposes than the \hyper{version}. 

In particular, if several different variants of a library exists where
it is feasible that they coexist in the same program, it is
recommended that different names be used for the variants.  In
contrast, for compatible versions of a library where coexistence of
several versions is unnecessary and undesirable, it is recommended
that the same name and different versions be used.  In particular, it
is recommended that new versions of libraries that are conservative
extensions of old ones differ only in the version, not in the name.

Correspondingly, it is recommended that \hyper{import spec}s do not
constrain an import to a single version, but instead specify a wide
range of acceptable versions of a library.

Implementations that allow two libraries of the same name with
different versions to coexist in the same program should
report when processing a program that actually makes use of this
extension.

\chapter{Unique library names}
% \label{librarynamesappendix}

Programmers should choose names for distributed libraries
that do not collide with other libraries' names.
This appendix suggests a convention for generating unique library
names, similar to the convention for Java~\cite{JLS3}.

A unique library name can be formed by associating the library with an
Internet domain name, such as {\cf mit.edu}.  The lower-case
components of the domain are reversed to form a prefix for the library
name.  Adding further name components to establish a hierarchy may be
advisable, depending on the size of the organization associated with
the domain name, the number of libraries to be distributed from it,
and other organizational properties or conventions associated with the
library.

Programmers should use library names that are suitable for
use as part of file names.  Special characters in
domain names that do not fit conventions of commonly used file systems should be replaced by
hyphens or suitable ``escape sequences'' that, as much as possible,
are suitable for avoiding collisions.  Here are some examples for
possible library names according to this convention:
%
\begin{scheme}
(edu mit swiss cheese)
(de deinprogramm educational graphics turtle)
(com pan-am booking passenger)%
\end{scheme}
%
The name of a library does not necessarily indicate an Internet
address where the package is distributed.

\renewcommand{\bibname}{References}

\bibliographystyle{plain}
\bibliography{abbrevs,rrs}

% \newcommand{\indexheading}{Alphabetic index of definitions of
%   concepts, keywords, and procedures}
% \newcommand{\indexintro}{}
%
% \printindex

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-app"
%%% End: 


\part{ðŸ“œ File   24: rrs.bib}
@Book{SICP,
  author =   {Harold Abelson
                and Gerald Jay Sussman
                and Julie Sussman},
  title =    {Structure and Interpretation of Computer Programs},
  publisher =    {MIT Press},
  year =   1996,
  address =  {Cambridge, Mass.},
  edition =  "second",
  language =     "USenglish"
}


@Article{barendregt,
  author =   {Henk P. Barendregt},
  title =    {Introduction to the Lambda Calculus},
  journal =    {Nieuw Archief voor Wisenkunde},
  year =   1984,
  volume =   4,
  number =   2,
  pages =  {337--372}
}

@InProceedings{Bawden88,
  author =       {Alan Bawden and Jonathan Rees},
  title =        {Syntactic Closures},
  crossref = {LFP1988},
  pages = {86--95},
  year = 1988
}

@InProceedings{bawdenquasiquote,
  author =   {Alan Bawden},
  title =    {Quasiquotation in {Lisp}},
  crossref =   {PEPM1999},
  pages =  {4--12}
}


@Misc{mustard,
  author =   {Scott Bradner},
  title =  {Key words for use in {RFC}s to Indicate Requirement Levels.},
  howpublished = {\url{http://www.ietf.org/rfc/rfc2119.txt}},
  month =  mar,
  year =   1997,
  note =   {RFC 2119}
}

@InProceedings{howtoprint,
  author =   {Robert G. Burger and R. Kent Dybvig},
  title =    {Printing floating-point numbers quickly and accurately},
  crossref =   {PLDI1996},
  pages =  {108--116}
}


@PhdThesis{AITR633,
  author =   {William Clinger},
  title =    {Foundations of Actor Semantics},
  school =   {MIT},
  year =   1981,
  month =  may,
  note =   {MIT Artificial Intelligence Laboratory Technical Report 633}
}

@TechReport{RRRS,
  author =       {William Clinger},
  title =    {The revised revised report on {Scheme}, or an uncommon {Lisp}},
  institution =  {MIT},
  year =   1985,
  number =   {MIT Artificial Intelligence Memo 848},
  month =  1985,
  note =   {Also published as Computer Science Department Technical Report 174,
  Indiana University, June 1985.}
}

@InProceedings{howtoread,
  author =   {William D. Clinger},
  title =    {How to Read Floating Point Numbers Accurately},
  crossref =   {PLDI1990},
  pages =  {92--101}
}

@Article{R4RS,
  author =       "William Clinger and Jonathan Rees",
  title =        "Revised{$^4$} Report on the Algorithmic Language {Scheme}",
  key =          "Revised{$^4$} Report on the Algorithmic Language {Scheme}",
  journal =      "Lisp Pointers",
  year =         1991,
  volume =       "IV",
  number =       3,
  pages =        "1--55",
  month =        "July--September"
}

@InProceedings{macrosthatwork,
  author =   "William Clinger and Jonathan Rees",
  title =    "Macros That Work",
  crossref =   "POPL1991",
  pages =  "155-162"
}

 
@InProceedings{propertailrecursion,
  author =   {William Clinger},
  title =    {Proper Tail Recursion and Space Efficiency},
  crossref =   {PLDI1998},
  pages =  {174--185}
}

@Misc{IEN137,
  author =   {Danny Cohen},
  title =  {On Holy Wars and a Plea for Peace},
  howpublished = {\url{http://www.ietf.org/rfc/ien/ien137.txt}},
  month =  apr,
  year =   1980,
  note =   {Internet Engineering Note 137}
}


@Misc{RFC4122,
  author =   {P. Leach and M. Mealling and R. Salz},
  title =  {A {Universally} {Unique} {IDentifier} ({UUID}) {URN} Namespace},
  howpublished = {\url{http://www.ietf.org/rfc/rfc4122.txt}},
  month =  jul,
  year =   2005,
  note =   {RFC 4122}
}

@Misc{srfi1,
  author =   {Olin Shivers},
  title =  {{SRFI~1}: List Library},
  howpublished = {\url{http://srfi.schemers.org/srfi-1/}},
  year =   1999
}

@Misc{srfi33,
  author =   {Olin Shivers},
  title =  {{SRFI~33}: Integer Bitwise-operation Library},
  howpublished = {\url{http://srfi.schemers.org/srfi-33/}},
  year =   2002
}

@Misc{srfi60,
  author =   {Aubrey Jaffer},
  title =  {{SRFI~60}: Integers as Bits},
  howpublished = {\url{http://srfi.schemers.org/srfi-60/}},
  year =   2005
}

@Misc{srfi9,
  author =   {Richard Kelsey},
  title =  {{SRFI~9}: Defining Record Types},
  howpublished = {\ur l{http://srfi.schemers.org/srfi-9/}},
  year =   1999
}

@Misc{srfi74,
  author =   {Michael Sperber},
  title =  {{SRFI~74}: Octet-Addressed Binary Blocks},
  howpublished = {\url{http://srfi.schemers.org/srfi-74/}},
  year =   2005
}

@Misc{srfi76,
  author =   {Will Clinger and R. Kent Dybvig and Michael Sperber and Anton van Straaten},
  title =  {{SRFI~76}: {R6RS} Records},
  howpublished = {\url{http://srfi.schemers.org/srfi-76/}},
  year =   2005
}

@Misc{srfi77,
  author =   {William D Clinger and Michael Sperber},
  title =  {{SRFI~77}: Preliminary Proposal for {R6RS} Arithmetic},
  howpublished = {\url{http://srfi.schemers.org/srfi-77/}},
  year =   2005
}

@Article{syntacticabstraction,
  author =   {R. Kent Dybvig and Robert Hieb and Carl Bruggeman},
  title =    {Syntactic Abstraction in {Scheme}},
  journal =    lasc,
  year =   1988,
  volume =   1,
  number =   1,
  pages =  {53-75}
}

@Book{tspl3,
  author =   {R.~Kent Dybvig},
  title =    {The {Scheme} Programming Language},
  publisher =    {MIT Press},
  year =   2003,
  address =  {Cambridge},
  edition =  {third},
  note =   {\url{http://www.scheme.com/tspl3/}}
}

@Manual{csug7,
  title =    {{Chez Scheme} Version 7 User's Guide},
  author =   {R.~Kent Dybvig},
  organization = {Cadence Research Systems},
  year =   2005,
  note =   {\url{http://www.scheme.com/csug7/}}
}

@Misc{srfi93,
  author =   {R. Kent Dybvig},
  title =  {{SRFI~93}: {R6RS} {\url{syntax-case}} macros},
  howpublished = {\url{http://srfi.schemers.org/srfi-93/}},
  year =   2006
}

@InProceedings{cleaninguptower,
  author =   {Sebastian Egner and Richard Kelsey and Michael Sperber},
  title =    {Cleaning up the tower: Numbers in {Scheme}},
  crossref =   {Scheme2004},
  pages =  {109--120}
}

@Manual{Scheme311,
  title =    {{Scheme} 311 version 4 reference manual},
  author =   {Carol Fessenden and William Clinger and Daniel P. Friedman and Christopher Haynes},
  organization = {Indiana University},
  year =   1983,
  note =   {Indiana University Computer Science Technical Report 137, Superseded by~\cite{Scheme84}}
}

@Manual{mzscheme352,
  title =    {{PLT MzScheme}: Language Manual},
  author =   {Matthew Flatt},
  organization = {Rice University, University of Utah},
  month =  jul,
  year =   2006,
  note =   {\url{http://download.plt-scheme.org/doc/352/html/mzscheme/}}
}

@Misc{srfi83,
  author =   {Matthew Flatt and Kent Dybvig},
  title =  {{SRFI~83}: {R6RS} Library Syntax},
  howpublished = {\url{http://srfi.schemers.org/srfi-83/}},
  year =   2005
}

@Misc{srfi75,
  author =   {Matthew Flatt and Marc Feeley},
  title =  {{SRFI~75}: {R6RS} Unicode Data},
  howpublished = {\url{http://srfi.schemers.org/srfi-75/}},
  year =   2005
}

@Manual{Scheme84,
  title =    {{Scheme} 84 interim reference manual},
  author =   {Daniel P. Friedman and Christopher Haynes and Eugene Kohlbecker and Mitchell Wand},
  organization = {Indiana University},
  month =  jan,
  year =   1985,
  note =   {Indiana University Computer Science Technical Report 153}
}

@Misc{srfi22,
  author =   {Martin Gasbichler and Michael Sperber},
  title =  {{SRFI~22}: Running {Scheme} Scripts on {Unix}},
  howpublished = {\url{http://srfi.schemers.org/srfi-22/}},
  year =   2002
}

@Book{JLS3,
  author =   {James Gosling and Bill Joy and Guy Steele and Gilad Bracha},
  title =    {The {Java$^{\textrm{TM}}$} Language Specification},
  publisher =    {Addison-Wesley},
  year =   2005,
  edition =    {Third}
}

@Misc{srfi11,
  author =   {Lars T Hansen},
  title =  {{SRFI~11}: Syntax for receiving multiple values},
  howpublished = {\url{http://srfi.schemers.org/srfi-11/}},
  year =   2000
}

@Misc{IEEE,
  title =    {{IEEE} Standard 754-1985.  {IEEE} Standard for Binary Floating-Point
Arithmetic},
  institution =  {IEEE},
  year =   1985,
  key =    {IEEE754},
  address =  {New York},
  note = {Reprinted in SIGPLAN Notices, 22(2):9-25, 1987.}
}

@Misc{IEEE754R,
  title =    {{IEEE} 754 Revision Work},
  institution =  {IEEE},
  year =   2006,
  key =    {IEEE754R},
  address =  {New York},
  howpublished = {\url{http://grouper.ieee.org/groups/754/revision.html}}
}

@Misc{IEEEScheme,
  title =    {{IEEE} Standard 1178-1990.  {IEEE} Standard for the {Scheme} Programming Language},
  institution =  {IEEE},
  year =   1991,
  key =    {IEEE1178},
  address =  {New York},
}

@Article{R5RS,
  author =   {Richard Kelsey and William Clinger and Jonathan Rees},
  title =    {Revised$^5$ Report on the Algorithmic Language {Scheme}},
  journal =    {Higher-Order and Symbolic Computation},
  year =   1998,
  volume =   11,
  number =   1,
  pages =  {7-105}
}

@Misc{R6RS,
  author =   {Michael Sperber and R. Kent Dybvig and Matthew Flatt and Anton van Straaten and Richard Kelsey and William Clinger and Jonathan Rees},
  title =  {Revised$^6$ Report on the Algorithmic Language {Scheme}},
  howpublished = {\url{http://www.r6rs.org/}},
  year =   2007
}

@Misc{R6RS-libraries,
  author =   {Michael Sperber and R. Kent Dybvig and Matthew Flatt and Anton van Straaten and Richard Kelsey and William Clinger and Jonathan Rees},
  title =  {Revised$^6$ Report on the Algorithmic Language {Scheme} ({Libraries})},
  howpublished = {\url{http://www.r6rs.org/}},
  year =   2007
}

@Misc{R6RS-appendices,
  author =   {Michael Sperber and R. Kent Dybvig and Matthew Flatt and Anton van Straaten},
  title =  {Revised$^6$ Report on the Algorithmic Language {Scheme} ({Non-Normative} Appendices)},
  howpublished = {\url{http://www.r6rs.org/}},
  year =   2007
}

@Misc{R6RS-rationale,
  author =   {Michael Sperber and R. Kent Dybvig and Matthew Flatt and Anton van Straaten},
  title =  {Revised$^6$ Report on the Algorithmic Language {Scheme} ({Rationale})},
  howpublished = {\url{http://www.r6rs.org/}},
  year =   2007
}

@Misc{srfi34,
  author =   {Richard Kelsey and Michael Sperber},
  title =  {{SRFI~34}: Exception Handling for Programs},
  howpublished = {\url{http://srfi.schemers.org/srfi-34/}},
  year =   2002
}

@Misc{srfi35,
  author =   {Richard Kelsey and Michael Sperber},
  title =  {{SRFI~35}: Conditions},
  howpublished = {\url{http://srfi.schemers.org/srfi-35/}},
  year =   2002
}

@PhdThesis{Kohlbecker86,
  author =   {Eugene E. {Kohlbecker Jr.}},
  key = {Kohlbecker},
  title =    {Syntactic Extensions in the Programming Language Lisp},
  school =   {Indiana University},
  year =   1986,
  month =  aug
}

@InProceedings{hygienic,
  author =   {Eugene E. Kohlbecker and Daniel P. Friedman and Matthias Felleisen and Bruce Duba},
  title =    {Hygienic Macro Expansion},
  crossref =   {LFP1986},
  pages =  {151-161}
}

@Article{Landin65,
  author =   {Peter Landin},
  title =    {A correspondence between {Algol 60} and {Church}'s lambda notation: Part {I}},
  journal =    cacm,
  year =   1965,
  volume =   8,
  number =   2,
  pages =  {89--101},
  month =  feb
}

@Manual{MITScheme,
  title =    {{Scheme} manual, seventh edition},
  organization = {MIT Department of Electrical Engineering and Computer Science},
  month =  sep,
  year =   1984
}

@Article{Naur63,
  author = {J. W. Backus and F.L. Bauer and J.Green and C. Katz and J. McCarthy
P. Naur and A. J. Perlis and H. Rutishauser and K. Samuelson and B. Vauquois
J. H. Wegstein and A. van Wijngaarden and M. Woodger},
  editor = {Peter Naur},  
  title =    {Revised report on the algorithmic language {Algol 60}},
  journal =    cacm,
  year =   1963,
  volume =   6,
  number =   1,
  pages =  {1--17}
}

@InProceedings{Penfield81,
  author =   {Paul {Penfield Jr.}},
  title =    {Principal values and branch cuts in complex {APL}},
  crossref =   {APL1981},
  pages =  {248--256}
}

@Manual{Pitman83,
  title =    {The revised {MacLisp} manual (Saturday evening edition)},
  author =   {Kent M. Pitman},
  organization = {MIT},
  month =  may,
  year =   1983,
  note =   {MIT Laboratory for Computer Science Technical Report 295}
}

@inproceedings{Rees82,
 author = {Jonathan A. Rees and Norman I. Adams IV},
 title = {T: a dialect of Lisp or LAMBDA: The ultimate software tool},
 crossref = {LFP1982},
 pages = {114--122}
 }

@Manual{Rees84,
  title =    {The {T} manual},
  author =   {Jonathan A. Rees and Norman I.~Adams IV and James R.~Meehan},
  organization = {Yale University Computer Science Department},
  edition =  {fourth},
  month =  jan,
  year =   1984
}

@Article{R3RS,
  author =       {William Clinger and Jonathan Rees},
  title =        {Revised{$^3$} Report on the Algorithmic Language {Scheme}},
  journal =      notices,
  year =         1986,
  volume =       21,
  number =       12,
  pages =        {37--79},
  month =        dec
}

@INPROCEEDINGS{Reynolds72,
        BOOKTITLE = {ACM Annual Conference},
        AUTHOR = {John C. Reynolds},
        TITLE = {Definitional Interpreters for Higher-Order Programming Languages},
        YEAR = 1972,
        PAGES = {717-740},
        MONTH = jul
}

@Book{algorithms,
  author =   {Thomas H. Cormen and Charles E. Leiserson and Ronald L. Rivest and Clifford Stein},
  title =    {Introduction to Algorithms},
  publisher =    {MIT Press and McGraw-Hill},
  year =   2001,
  edition =  {second}
}


@Article{quicksort,
  author =   {C. A. R. Hoare},
  title =    {Algorithm 63 (Partition); 64 (Quicksort); 65 (Find)},
  journal =    {Communications of the {ACM}},
  year =   1961,
  volume =   4,
  number =   7,
  pages =  {321--322}
}

@TechReport{Scheme78,
  author =   {Guy Lewis {Steele Jr.} and Gerald Jay Sussman},
  title =    {The revised report on {Scheme}, a dialect of {Lisp}},
  institution =  {MIT},
  year =   1978,
  number =   {MIT Artificial Intelligence Memo 452},
  month =  jan
}

@TechReport{Rabbit,
  author =   {Guy Lewis {Steele Jr.}},
  title =    {{Rabbit}: a compiler for {Scheme}},
  institution =  {MIT},
  year =   1978,
  number =   {MIT Artificial Intelligence Laboratory Technical Report 474},
  month =  may
}

@Book{CltL,
  author =   {Guy Lewis {Steele Jr.}},
  title =    {{Common Lisp}: The Language},
  publisher =    {Digital Press},
  year =   1990,
  address =  {Burlington, MA},
  edition =  {second}
}

@TechReport{Scheme75,
  author =   {Gerald Jay Sussman and Guy Lewis Steele Jr.},
  title =    {{Scheme}: an interpreter for extended lambda calculus},
  institution =  {MIT},
  year =   1975,
  number =   {MIT Artificial Intelligence Memo 349},
  month =  dec
}

@Misc{SchemeCharter2006,
  key =    {Scheme Charter},
  title =  {{Scheme} Standardization charter},
  howpublished = {\url{http://www.schemers.org/Documents/Standards/Charter/mar-2006.txt}},
  month =  mar,
  year =   2006
}

@Book{Stoy77,
    author = {Joseph Stoy},
    title = {Denotational Semantics: The {Scott-Strachey} Approach to Programming Language Theory},
    publisher = {MIT Press},
    year = 1977
}

@Manual{TImanual85,
  title =    {{TI Scheme} Language Reference Manual},
  key =    {Texas Instruments},
  organization = {Texas Instruments, Inc.},
  month =  nov,
  year =   1985,
  note =   {Preliminary version 1.0}
}

@Misc{Unicode,
  key =    {Unicode},
  author =   {The {Unicode Consortium}},
  title =  {The {Unicode} Standard, Version 5.0.0},
  howpublished = {defined by: {\em The Unicode Standard, Version 5.0} (Boston, MA,
 Addison-Wesley, 2007. ISBN 0-321-48091-0)},
  year =   2007
}

@Misc{UnicodeUAX29,
  author =   {Mark Davis},
  title =  {{Unicode} {Standard} {Annex} \#29: Text Boundaries},
  howpublished = {\url{http://www.unicode.org/reports/tr29/}},
  year =   2006
}

@PhdThesis{Waddellphd,
  author =   {Oscar Waddell},
  title =    {Extending the Scope of Syntactic Abstraction},
  school =   {Indiana University},
  year =   1999,
  month =  aug,
  note =   {\url{http://www.cs.indiana.edu/~owaddell/papers/thesis.ps.gz}}
}

@Book{WaiteGoos,
        author = {William M. Waite and Gerhard Goos},
        title = {Compiler Construction},
        publisher = SP,
        year = 1984
}



@Unpublished{ff:monograph,
  author =   {Matthias Felleisen and Matthew Flatt},
  title =    {Programming Languages and Lambda Calculi},
  note =   {{\url{http://www.cs.utah.edu/plt/publications/pllc.pdf}}},
  year =   2003
}

@InProceedings{mf:op-r5rs,
  author =   {Jacob Matthews and Robert Bruce Findler},
  title =    {An Operational Semantics for {R5RS Scheme}},
  crossref =   {Scheme2005},
  pages =  {41--54}
}

@InProceedings{mf:interop,
  author =   {Jacob Matthews and Robert Bruce Findler},
  title =    {Operational semantics for multi-language programs},
  crossref =   {POPL2007}
}

@InProceedings{mfff:plt-redex,
  author =   {Jacob Matthews and Robert Bruce Findler and Matthew Flatt and Matthias Felleisen},
  title =    {A Visual Environment for Developing Context-Sensitive Term Rewriting Systems},
  crossref =   {RTA2004}
}

@Article{wf:type-soundness,
title={A Syntactic Approach to Type Soundness},
author={Andrew Wright and Matthias Felleisen},
pages={38--94},
journal={Information and Computation},
year=1994,
volume=115,
number=1,
note={{F}irst appeared as Technical Report TR160, Rice University, 1991}
}


@Article{Curtis1991,
  author =   {Pavel Curtis},
  title =    {The {Scheme} of {Things}},
  journal =    {Lisp Pointers},
  year =   1991,
  volume =   {IV},
  number =   1,
  month =  mar
}

@Incollection{SteeleGabriel1993,
        AUTHOR = {Guy L. {Steele Jr.} and Richard P. Gabriel},
        PAGES = {231--270},
        TITLE = {The Evolution of {Lisp}},
        CROSSREF = {HOPL1993}
}

@PROCEEDINGS{HOPL1993,
        TITLE = {History of Programming Languages~II},
        YEAR = 1993,
        BOOKTITLE = {History of Programming Languages~II},
        EDITOR = {Jean E. Sammet},
        PUBLISHER = {{ACM}},
        ADDRESS = {New York},
        MONTH = apr,
        NOTE = {SIGPLAN Notices 3(28)}
}

@Proceedings{LFP1988,
        key={LFP 1988},
        title = {{ACM} Conference on {Lisp} and Functional Programming},
        year = 1988,
        booktitle = {{ACM} Conference on {Lisp} and Functional Programming},
  address = {Snowbird, Utah},
        publisher = {{ACM} Press}
}


@PROCEEDINGS{PLDI1996,
        KEY = {PLDI~1996},
        TITLE = proc#{of the {ACM SIGPLAN} '96 Conference on Programming Language Design and Implementation},
        YEAR = 1996,
        BOOKTITLE = proc#{of the {ACM SIGPLAN} '96 Conference on Programming Language Design and Implementation},
        PUBLISHER = {{ACM} Press},
        ADDRESS = {Philadelphia, PA, USA},
 isbn = {0-89791-795-2},
        MONTH = may
}


@Proceedings{PEPM1999,
        title = proclong#acmsigwork#PEPM#{ PEPM '99},
        year = 1999,
        booktitle = proc#acmsigwork#PEPM#{ PEPM '99},
        editor = {Olivier Danvy},
        address = {San Antonio, Texas, USA},
        month = jan,
        note = {BRICS Notes Series NS-99-1}
}

@Proceedings{PLDI1990,
        KEY = {PLDI~1990},
        title = proc#PLDI#{ '90},
        BOOKTITLE = proc#PLDI#{ '90},
        year =   1990,
        publisher =      "{ACM}",
        month =  jun,
        address = {White Plains, New York, USA},
        mynote = "SIGPLAN Notices 25(6)"
}


@PROCEEDINGS{POPL1991,
        KEY = {POPL~1991},
        TITLE = proc#" 1991 "#acmpopl,
        YEAR = 1991,
        BOOKTITLE = proc#" 1991 "#acmpopl,
        PUBLISHER = {{ACM} Press},
        ADDRESS = {Orlando, Florida},
        MONTH = jan
}

@Proceedings{PLDI1998,
  title =    proclong#" 1998 "#PLDI,
  booktitle =    proclong#" 1998 "#PLDI,
  year =   1998,
  key =    "PLDI~1998",
  editor =   "Keith Cooper",
 publisher = {ACM Press},
  address =  "Montreal, Canada",
  month =  jun,
 isbn = {0-89791-987-4},
  note =  {Volume 33(5) of }#notices
}

@Proceedings{Scheme2004,
  title =    {Proceedings of the Fifth Workshop on Scheme and Functional Programming},
  booktitle =    {Proceedings of the Fifth Workshop on Scheme and Functional Programming},
  year =   2004,
  editor =   {Olin Shivers and Oscar Waddell},
  address =  {Snowbird},
  month =  oct,
  note = {Indiana University Technical Report TR600}
}

@PROCEEDINGS{LFP1986,
        KEY={LFP 1986},
        TITLE = proclong#{ 1986 {ACM} Conference on {Lisp} and Functional Programming},
        YEAR = 1986,
        BOOKTITLE = proclong#{ 1986 {ACM} Conference on {Lisp} and Functional Programming}
}

@PROCEEDINGS{RTA2004,
        TITLE = Proc#{15th Conference on Rewriting Techniques and Applications},
        BOOKTITLE = Proc#{15th Conference on Rewriting Techniques and Applications},
        YEAR = 2004,
        PUBLISHER = SP,
        ADDRESS = {Aachen},
        MONTH = jun
}

@Proceedings{Scheme2005,
  title =    {Proceedings of the Sixth Workshop on Scheme and Functional Programming},
  booktitle =    {Proceedings of the Sixth Workshop on Scheme and Functional Programming},
  year =   2005,
  editor =   {J. Michael Ashley and Michael Sperber},
  address =  {Tallin, Estonia},
  month =  sep,
  note = {Indiana University Technical Report TR619}
}

@Proceedings{APL1981,
  title =    {APL '81 Conference Proceedings},
  booktitle =    {APL '81 Conference Proceedings},
  year =   1981,
  address =  {San Francisco},
  month =  sep,
  organization = {ACM SIGAPL},
  note =   {Proceedings published as {\textit{APL Quote Quad}} 12(1)}
}

@PROCEEDINGS{LFP1982,
        KEY={LFP 1982},
        TITLE = {{ACM} Conference on {Lisp} and Functional Programming},
        BOOKTITLE = {{ACM} Conference on {Lisp} and Functional Programming},
        YEAR = 1982,
        ADDRESS = {Pittsburgh, Pennsylvania},
        PUBLISHER = {{ACM} Press}
}

@Proceedings{POPL2007,
  title =        proc#"34rd "#popl,
  booktitle =    proc#"34rd "#popl,
  year =         2007,
  key =          "POPL~2007",
  editor =       "Matthias Felleisen",
  publisher =    "{ACM} Press",
  address =      "Nice, France",
  month =        jan
}      

@article{mf:scheme-op-sem,
  title="An Operational Semantics for {S}cheme",
  author="Jacob Matthews and Robert Bruce Findler",
  year=2007,
  journal="Journal of Functional Programming",
  note="{\href{http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=1268564&fulltextType=RA&fileId=S0956796807006478}{From \url{http://www.cambridge.org/journals/JFP/}}}"
}


\part{ðŸ“œ File   25: abbrevs.bib}
@STRING{CAAP = "Trees in Algebra and Programming"}
@STRING{CC = "International Conference on Compiler Construction"}
@STRING{ESOP = "European Symposium on Programming"}
@STRING{FPCA = "Functional Programming Languages and Computer Architecture"}
@string{ICFP = "International Conference on Functional Programming"}
@STRING{IJCAI = "International Joint Conference on Artificial Intelligence"}
@string{IWMM = "International Workshop on Memory Management, {IWMM}"}
@STRING{LFP = "Lisp and Functional Programming"}
@string{LOPSTR = "Logic Program Synthesis and Transformation"}
@string{MFPS = "Mathematical Foundations of Programming Semantics"}
@STRING{PEPM = {Partial Evaluation and Semantics-Based Program Manipulation}}
@STRING{PLDI = "Conference on Programming Language Design and Implementation"}
@STRING{PLILP = "International Symposium on Programming Languages, Implementations, Logics and Programs"}
@STRING{oldPLILP = "Programming Language Implementation and Logic Programming"}
@STRING{POPL = "Annual {ACM} Symposium on Principles of Programming Languages"}
@STRING{acmpopl = "{ACM} SIGPLAN Symposium on Principles of Programming Languages"}
@STRING{RTA = "Rewriting Techniques and Applications"}
@STRING{SAC = "Annual Symposium on Applied Computing, {SAC}"}
@STRING{SAS = "International Static Analysis Symposium, {SAS}"}
@STRING{SASShort = "International Static Analysis Symposium"}
@STRING{STACS = "Symposium on Theoretical Aspects of Computer Science"}
@STRING{TACS = "Theoretical Aspects of Computer Software"}
@STRING{WIFPL = "Workshop on the Implementation of Functional Programming Languages"}
@STRING{LICS = "IEEE Symposium on Logic in Computer Science"}

@string{icsi = "The International Computer Science Institute"}

@string{CMU = "Carnegie Mellon University"}
@string{BROWN = "Brown University"}
@string{CORNELL = "Cornell University"}
@string{DECSRC = "Digital Equipment Corporation Systems Research Center"}
@string{DECWRL = "Digital Equipment Corporation Western Research Laboratory"}
@string{MIT = "Massachusetts Institute of Technology"}
@string{NYUCOUR = "Courant Institute of Mathematical Sciences, New York University"}
@string{OGC = "Oregon Graduate Center"}
@string{PARC = "Xerox Palo Alto Research Center"}
@string{PRINCETON = "Princeton University"}
@string{RICE = "Rice University"}
@string{SIAM = "Society for Industrial and Applied Mathematics"}
@string{UCB = "University of California, Berkeley"}
@string{UCSC = "University of California at Santa Cruz"}
@string{BRICS = "Basic Research in Computer Science"}

@string{AW = "Addison-Wesley"}
@string{ACM = "{ACM} Press"}
@STRING{EH = "Ellis Horwood"}
@string{ENH = "Elsevier North-Holland"}
@STRING{ESP = "Elsevier Science Publishers"}
@string{HR = "Harper and Row"}
@string{HRW = "Holt, Reinhart and Winston"}
@STRING{JW = "John Wiley \& Sons"}
@string{LNCS = "Lecture Notes in Computer Science"}
@STRING{MIT = "{MIT} Press"}
@string{MK = "Morgan-Kaufman"}
@string{NH = "North-Holland"}

@String{OUP = {Oxford University Press}}
@string{PH = "Prentice-Hall"}
@string{PP = "Pergamon Press"}
@STRING{SP = "Springer-Verlag"}
@string{SV = "Springer-Verlag"}
                
                
@string{ai = "Artificial Intelligence"}
@string{ainf = "Acta Informatica"}
@string{bstj = "Bell System Technical Journal"}
@string{cacm = "Communications of the {ACM}"}
@string{compj = "Computer Journal"}
@string{clang = "Computer Languages"}
@string{csurv = "Computing Surveys"}
@string{eatcs = "Bulletin of the European Association for Theoretical Computer Science"}
@string{ENTCS = "Electronic Notes in Theoretical Computer Science"}
@string{hosc = "Higher-Order and Symbolic Computation"}
@STRING{iandc = "Information and Computation"}
@STRING{ieeec = "{IEEE} Computer"}
@STRING{ieees = "{IEEE} Software"}
@string{ieeese = "{IEEE} Transactions on Software Engineering"}
@STRING{ieeesoft = "{IEEE} Software"}
@STRING{ieeetit = "{IEEE} Transactions on Information Theory"}
@STRING{ieeetc = "{IEEE} Transactions on Computers"}
@string{ijcm  = "International Journal of Computer Mathematics"}
@STRING{infco = "Information and Control"}
@string{IPL = "Information Processing Letters"}
@string{jacm = "Journal of the {ACM}"}
@string{jase = "Journal of Automated Software Engineering"}
@string{jfp = "Journal of Functional Programming"}
@string{jflp = "Journal of Functional and Logic Programming"}
@STRING{jlc = "Journal of Logic and Computation"}
@STRING{jlp = "Journal of Logic Programming"}
@String{jodl = {Journal of Digital Libraries}}
@STRING{jpldi = "Journal of Programming Languages"}
@STRING{jsc = "Journal of Symbolic Computation"}
@String{jucs = "Journal of Universal Computer Science"}
@string{lsc = "Lisp and Symbolic Computation"}
@string{lasc = "Lisp and Symbolic Computation"}
@string{loplas = "Letters on Programming Languages and Systems"}
@string{mscs = {Mathematical Structures in Computer Science}}
@string{mst ={Mathematical Systems Theory}}
@string{ngc = "New Generation Computing"}
@STRING{notices = "{SIGPLAN} Notices"}
@string{sigarch = "{SIGARCH} Newsletter"}
@string{sigplan = "{SIGPLAN} Notices"}
@string{scp = "Science of Computer Programming"}
@string{spe = "Software---Practice {\&} Experience"}
@string{tapos = "Theory and Practice of Object Systems"}
@STRING{tcj = "The Computer Journal"}
@string{tcs = "Theoretical Computer Science"}
@String{tissec = {{ACM} Transactions on Information and Systems Security}}
@string{tocs = "{ACM} Transactions on Computer Systems"}
@string{tocl = {{ACM} Transactions on Computational Logic}}
@string{todas = {{ACM} Transactions on Database Systems}}
@string{tois = {{ACM} Transactions on Information Systems}}
@string{toit = {{ACM} Transactions on Internet Technology}}
@string{tochi = {{ACM} Transactions on Computer-Human Interaction}}
@string{toplas = "{ACM} Transactions on Programming Languages and Systems"}
@String{tosem = "{ACM} Transactions of Software Engineering and Methodology"}
@STRING{WSI = "Berichte des Wilhelm-Schickard-Instituts"}

@string{oopsla-full-title = "Object Oriented Programming, Systems, Languages, and Applications"}

@string{acmsigconf = " ACM SIGPLAN Conference on "}
@string{acmsigsymp = " ACM SIGPLAN Symposium on "}
@string{acmsigwork = " ACM SIGPLAN Workshop on "}
@STRING{ieee = "{IEEE} Computer Society Press"}
@STRING{ig = "(in german)"}
@string{proclong = "Proceedings of the "}
@STRING{proc = "Proc.~"}
@STRING{conf = "Conf.~"}
@STRING{symp = "Symp.~"}
@STRING{work = "Workshop "}


\part{ðŸ“œ File   26: r6rs-lib.tex}
\documentclass[twoside,twocolumn]{algol60}
%\documentclass[twoside]{algol60}

\pagestyle{headings} 
\showboxdepth=0
\makeindex
\input{commands}

\texonly\externaldocument[report:]{r6rs}\endtexonly

\def\headertitle{Revised$^{\rnrsrevision}$ Scheme Libraries}
\def\integerversion{6}

\begin{document}

\thispagestyle{empty}

\topnewpage[{
\begin{center}   {\huge\bf
        Revised{\Huge$^{\mathbf{\htmlonly\tiny\endhtmlonly{}\rnrsrevision}}$} Report on the Algorithmic Language \\
                              \vskip 3pt
                              Scheme\\
                                \vskip 1.5ex
                              --- Standard Libraries ---}

\vskip 1ex
$$
\begin{tabular}{l@{\extracolsep{.5in}}lll}
\multicolumn{4}{c}{M\authorsc{ICHAEL} S\authorsc{PERBER}}
\\
\multicolumn{4}{c}{R.\ K\authorsc{ENT} D\authorsc{YBVIG},
  M\authorsc{ATTHEW} F\authorsc{LATT},
  A\authorsc{NTON} \authorsc{VAN} S\authorsc{TRAATEN}}
\\
\multicolumn{4}{c}{(\textit{Editors})} \\
\multicolumn{4}{c}{
  R\authorsc{ICHARD} K\authorsc{ELSEY}, W\authorsc{ILLIAM} C\authorsc{LINGER},
  J\authorsc{ONATHAN} R\authorsc{EES}} \\
\multicolumn{4}{c}{(\textit{Editors, Revised\itspace{}$^5$ Report on the
    Algorithmic Language Scheme})} \\
\multicolumn{4}{c}{\bf \rnrsrevisiondate}
\end{tabular}
$$



\end{center}

{\parskip 1ex
The report gives a defining description of the standard libraries of
the programming language Scheme.

This report frequently refers back to the \textit{Revised\itspace{}$^6$ Report
  on the Algorithmic Language Scheme}~\cite{R6RS}; references to the
report are identified by designations such as ``report section'' or
``report chapter''.
}

\medskip

Parts of the library report are derived from earlier revisions of the
report~\cite{R5RS}.  We gratefully acknowledge their authors for their
contributions.  More detailed information on authorship can be found
at the beginning of the \textit{Revised\itspace{}$^6$ Report on the Algorithmic
  Language Scheme}.

\medskip

We intend this report to belong to the entire Scheme community, and so
we grant permission to copy it in whole or in part without fee.  In
particular, we encourage implementors of Scheme to use this report as
a starting point for manuals and other documentation, modifying it as
necessary.

\bigskip

\input{status}
}]

\texonly\clearpage\endtexonly

\chapter*{Contents}
\addvspace{3.5pt}                  % don't shrink this gap
\renewcommand{\tocshrink}{-4.0pt}  % value determined experimentally
{%\footnotesize
\tableofcontents
}

\vfill

\texonly\clearpage\endtexonly

\input{unicode} \par
\input{bytevector} \par
\input{list}    \par
\input{sort}    \par
\input{control} \par
\input{records} \par
\input{exc}     \par
\input{io}      \par
\input{files}   \par
\input{programlib} \par
\input{arith}   \par
\input{syntax-case} \par
\input{hashtable} \par
\input{enum}    \par
\input{complib} \par
\input{eval}    \par
\input{setcar}  \par
\input{stringset} \par
\input{r5rscompat} \par
%\newpage                   %  Put bib on it's own page (it's just one)
%\twocolumn[\vspace{-.18in}]%  Last bib item was on a page by itself.
\renewcommand{\bibname}{References}

\bibliographystyle{plain}
\bibliography{abbrevs,rrs}

\vfill\eject


\newcommand{\indexheading}{Alphabetic index of definitions of
  concepts, keywords, and procedures}
\newcommand{\indexintro}{}

\printindex

\end{document}


\part{ðŸ“œ File   27: unicode.tex}
\chapter{Unicode}
% \label{unicodechapter}

\newcommand{\latingreek}[1]{\texonly\mathit{#1}\endtexonly\htmlonly\textit{#1}\endhtmlonly}

The procedures exported by the \defrsixlibrary{unicode}
library provide access to some aspects
of the Unicode semantics for characters and strings:
category information, case-independent comparisons,
case mappings, and normalization~\cite{Unicode}.

Some of the procedures that operate on characters or strings ignore the
difference between upper case and lower case.  These procedures
have \hbox{``{\tt -ci}''} (for ``case
insensitive'') embedded in their names.

\section{Characters}

\begin{entry}{%
\proto{char-upcase}{ char}{procedure}
\proto{char-downcase}{ char}{procedure}
\proto{char-titlecase}{ char}{procedure}
\proto{char-foldcase}{ char}{procedure}}

These procedures take a character argument and return a character
result. If the argument is an upper-case or title-case character, and if
there is a single character that is its lower-case form, then
{\cf char-downcase} returns that character. If the argument is a lower-case
or title-case character, and there is a single character that is
its upper-case form, then {\cf char-upcase} returns that character.
If the argument is a lower-case
or upper-case character, and there is a single character that is
its title-case form, then {\cf char-titlecase} returns that character.
If the argument is not a title-case character and there is no single
character that is its title-case form, then {\cf char-titlecase}
returns the upper-case form of the argument.
Finally, if the character has a case-folded character,
then {\cf char-foldcase} returns that character.
Otherwise the character returned is the same
as the argument.
For Turkic characters \.I ({\tt \#\backwhack{}x130})
and \i{} ({\tt \#\backwhack{}x131}),
{\cf char-foldcase} behaves as the identity function; otherwise 
{\cf char-foldcase} is the
same as {\cf char-downcase} composed with {\cf char-upcase}.

\begin{scheme}
(char-upcase \sharpsign\backwhack{}i) \ev \sharpsign\backwhack{}I
(char-downcase \sharpsign\backwhack{}i) \ev \sharpsign\backwhack{}i
(char-titlecase \sharpsign\backwhack{}i) \ev \sharpsign\backwhack{}I
(char-foldcase \sharpsign\backwhack{}i) \ev \sharpsign\backwhack{}i

(char-upcase \sharpsign\backwhack{}\ss) \ev \sharpsign\backwhack{}\ss
(char-downcase \sharpsign\backwhack{}\ss) \ev \sharpsign\backwhack{}\ss
(char-titlecase \sharpsign\backwhack{}\ss) \ev \sharpsign\backwhack{}\ss
(char-foldcase \sharpsign\backwhack{}\ss) \ev \sharpsign\backwhack{}\ss

(char-upcase \sharpsign\backwhack{}$\Sigma$) \ev \sharpsign\backwhack{}$\Sigma$
(char-downcase \sharpsign\backwhack{}$\Sigma$) \ev \sharpsign\backwhack{}$\sigma$
(char-titlecase \sharpsign\backwhack{}$\Sigma$) \ev \sharpsign\backwhack{}$\Sigma$
(char-foldcase \sharpsign\backwhack{}$\Sigma$) \ev \sharpsign\backwhack{}$\sigma$

(char-upcase \sharpsign\backwhack{}$\varsigma$) \ev \sharpsign\backwhack{}$\Sigma$
(char-downcase \sharpsign\backwhack{}$\varsigma$) \ev \sharpsign\backwhack{}$\varsigma$
(char-titlecase \sharpsign\backwhack{}$\varsigma$) \ev \sharpsign\backwhack{}$\Sigma$
(char-foldcase \sharpsign\backwhack{}$\varsigma$) \ev \sharpsign\backwhack{}$\sigma$
\end{scheme}

\begin{note}
  Note that {\cf char-titlecase} does not always return a title-case
  character.
\end{note}

\begin{note}
  These procedures are consistent with
  Unicode's locale-independent mappings from scalar values to
  scalar values for upcase, downcase, titlecase, and case-folding
  operations.  These mappings can be extracted from {\cf
    UnicodeData.txt} and {\cf CaseFolding.txt} from the Unicode
  Consortium, ignoring Turkic mappings in the latter.

  Note that these character-based procedures are an incomplete
  approximation to case conversion, even ignoring the user's locale.
  In general, case mappings require the context of a string, both in
  arguments and in result. The {\cf string-upcase}, {\cf
    string-downcase}, {\cf string-titlecase}, and {\cf
    string-foldcase} procedures (section~\ref{string-upcase})
  perform more general case conversion.
\end{note}
\end{entry}


\begin{entry}{%
\proto{char-ci=?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}
\proto{char-ci<?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}
\proto{char-ci>?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}
\proto{char-ci<=?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}
\proto{char-ci>=?}{ \vari{char} \varii{char} \variii{char} \dotsfoo}{procedure}}

These procedures are similar to {\cf char=?}, etc., but operate
on the case-folded versions of the characters.

\begin{scheme}
(char-ci<? \sharpsign\backwhack{}z \sharpsign\backwhack{}Z) \ev \schfalse
(char-ci=? \sharpsign\backwhack{}z \sharpsign\backwhack{}Z) \ev \schtrue
(char-ci=? \sharpsign\backwhack{}$\varsigma$ \sharpsign\backwhack{}$\sigma$) \ev \schtrue%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{char-alphabetic?}{ char}{procedure}
\proto{char-numeric?}{ char}{procedure}
\proto{char-whitespace?}{ char}{procedure}
\proto{char-upper-case?}{ char}{procedure}
\proto{char-lower-case?}{ char}{procedure}
\proto{char-title-case?}{ char}{procedure}}

These procedures return \schtrue{} if their arguments are alphabetic,
numeric, whitespace, upper-case, lower-case, or title-case characters,
respectively; otherwise they return \schfalse.

A character is alphabetic if it has the Unicode ``Alphabetic''
property.  A character is numeric if it has the Unicode ``Numeric''
property.  A character is whitespace if has the Unicode
``White\_Space'' property.
A character is upper case if it has the Unicode
``Uppercase'' property, lower case if it has the ``Lowercase''
property, and title case if it is in the Lt general category.

\begin{scheme}
(char-alphabetic? \sharpsign\backwhack{}a) \ev \schtrue{}
(char-numeric? \sharpsign\backwhack{}1) \ev \schtrue{}
(char-whitespace? \sharpsign\backwhack{}space) \ev \schtrue{}
(char-whitespace? \sharpsign\backwhack{}x00A0) \ev \schtrue{}
(char-upper-case? \sharpsign\backwhack{}$\Sigma$) \ev \schtrue{}
(char-lower-case? \sharpsign\backwhack{}$\sigma$) \ev \schtrue{}
(char-lower-case? \sharpsign\backwhack{}x00AA) \ev \schtrue{}
(char-title-case? \sharpsign\backwhack{}I) \ev \schfalse{}
(char-title-case? \sharpsign\backwhack{}x01C5) \ev \schtrue{}%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{char-general-category}{ char}{procedure}}

Returns a symbol representing the
Unicode general category of \var{char}, one of {\cf Lu}, {\cf Ll}, {\cf Lt},
{\cf Lm}, {\cf Lo}, {\cf Mn}, {\cf Mc}, {\cf Me}, {\cf Nd}, {\cf Nl},
{\cf No}, {\cf Ps}, {\cf Pe}, {\cf Pi}, {\cf Pf}, {\cf Pd}, {\cf Pc},
{\cf Po}, {\cf Sc}, {\cf Sm}, {\cf Sk}, {\cf So}, {\cf Zs}, {\cf Zp},
{\cf Zl}, {\cf Cc}, {\cf Cf}, {\cf Cs}, {\cf Co}, or {\cf Cn}.

\begin{scheme}
(char-general-category \#\backwhack{}a) \ev Ll
(char-general-category \#\backwhack{}space) \lev Zs
(char-general-category \#\backwhack{}x10FFFF) \lev Cn  
\end{scheme}
\end{entry}

\section{Strings}

\begin{entry}{%
\proto{string-upcase}{ \var{string}}{procedure}
\proto{string-downcase}{ \var{string}}{procedure}
\proto{string-titlecase}{ \var{string}}{procedure}
\proto{string-foldcase}{ \var{string}}{procedure}}

These procedures take a string argument and return a string
result.  They are defined in terms of Unicode's locale-independent
case mappings from Unicode scalar-value sequences to scalar-value sequences.
In particular, the length of the result string can be different from
the length of the input string.
When the specified result is equal in the sense of {\cf string=?} to the
argument, these procedures may return the argument instead of a newly
allocated string.

The {\cf string-upcase} procedure converts a string to upper case;
{\cf string-downcase} converts a string to lower case. The {\cf
  string-foldcase} procedure converts the string to its case-folded
counterpart, using the full case-folding mapping, but without the
special mappings for Turkic languages.  The {\cf string-titlecase}
procedure converts the first cased character of each word via {\cf
  char-titlecase}, and downcases all other cased characters.

\begin{scheme}
(string-upcase "Hi") \ev "HI"
(string-downcase "Hi") \ev "hi"
(string-foldcase "Hi") \ev "hi"

(string-upcase "Stra\ss{}e") \ev "STRASSE"
(string-downcase "Stra\ss{}e") \ev "stra\ss{}e"
(string-foldcase "Stra\ss{}e") \ev "strasse"
(string-downcase "STRASSE")  \ev "strasse"

(string-downcase "$\Sigma$") \ev "$\sigma$"

; \textrm{Chi Alpha Omicron Sigma}:
(string-upcase "$\latingreek{XAO}\Sigma$") \ev "$\latingreek{XAO}\Sigma$" 
(string-downcase "$\latingreek{XAO}\Sigma$") \ev "$\chi\alpha{}o\varsigma$"
(string-downcase "$\latingreek{XAO}\Sigma\Sigma$") \ev "$\chi\alpha{}o\sigma\varsigma$"
(string-downcase "$\latingreek{XAO}\Sigma~\Sigma$") \ev "$\chi\alpha{}o\varsigma~\sigma$"
(string-foldcase "$\latingreek{XAO}\Sigma\Sigma$") \ev "$\chi\alpha{}o\sigma\sigma$"
(string-upcase "$\chi\alpha{}o\varsigma$") \ev "$\latingreek{XAO}\Sigma$"
(string-upcase "$\chi\alpha{}o\sigma$") \ev "$\latingreek{XAO}\Sigma$"

(string-titlecase "kNock KNoCK")
\ev "Knock Knock"
(string-titlecase "who's there?")
\ev "Who's There?"
(string-titlecase "r6rs") \ev "R6Rs"
(string-titlecase "R6RS") \ev "R6Rs"%
\end{scheme}

\begin{note}
  The case mappings needed for implementing these procedures
  can be extracted from {\cf UnicodeData.txt}, {\cf
    SpecialCasing.txt}, {\cf WordBreakProperty.txt} 
  (the ``MidLetter'' property partly defines case-ignorable characters), 
  and {\cf CaseFolding.txt} from the Unicode Consortium.

  Since these procedures are locale-independent, they may not
  be appropriate for some locales.
\end{note}

\begin{note}
  Word breaking, as needed for the correct casing of $\Sigma$ and for
  {\cf string-titlecase}, is specified in Unicode Standard Annex
  \#29~\cite{UnicodeUAX29}.
\end{note}

\end{entry}

\begin{entry}{%
\proto{string-ci=?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{procedure}
\proto{string-ci<?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{procedure}
\proto{string-ci>?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{procedure}
\proto{string-ci<=?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{procedure}
\proto{string-ci>=?}{ \vari{string} \varii{string} \variii{string} \dotsfoo}{procedure}}

These procedures are similar to {\cf string=?}, etc., but 
operate on the case-folded versions of the strings.

\begin{scheme}
(string-ci<? "z" "Z") \ev \schfalse
(string-ci=? "z" "Z") \ev \schtrue
(string-ci=? "Stra\ss{}e" "Strasse") 
\ev \schtrue
(string-ci=? "Stra\ss{}e" "STRASSE")
\ev \schtrue
(string-ci=? "$\latingreek{XAO}\Sigma$" "$\chi\alpha{}o\sigma$")
\ev \schtrue%
\end{scheme}

\end{entry}

\begin{entry}{
\proto{string-normalize-nfd}{ \var{string}}{procedure}
\proto{string-normalize-nfkd}{ \var{string}}{procedure}
\proto{string-normalize-nfc}{ \var{string}}{procedure}
\proto{string-normalize-nfkc}{ \var{string}}{procedure}}
  
These procedures take a string argument and return a string
result, which is the input string normalized
to Unicode normalization form D, KD, C, or KC, respectively.
When the specified result is equal in the sense of {\cf string=?} to the
argument, these procedures may return the argument instead of a newly
allocated string.

\begin{scheme}
(string-normalize-nfd "\backwhack{}xE9;")
\ev "\backwhack{}x65;\backwhack{}x301;"
(string-normalize-nfc "\backwhack{}xE9;")
\ev "\backwhack{}xE9;"
(string-normalize-nfd "\backwhack{}x65;\backwhack{}x301;")
\ev "\backwhack{}x65;\backwhack{}x301;"
(string-normalize-nfc "\backwhack{}x65;\backwhack{}x301;")
\ev "\backwhack{}xE9;"%
\end{scheme}
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   28: bytevector.tex}
\chapter{Bytevectors}
% \label{bytevectorschapter}

Many applications deal with blocks of binary data by accessing
them in various ways---extracting signed or unsigned numbers of
various sizes.  Therefore, the \defrsixlibrary{bytevectors} library
provides a single type for
blocks of binary data with multiple ways to access that data. It deals
with integers and floating-point representations 
in various sizes with specified endianness.

Bytevectors\mainindex{bytevector} are objects of a disjoint
type. Conceptually, a bytevector represents a sequence of 8-bit
bytes.  The description of bytevectors uses the term \defining{byte}
for an exact integer object in the interval $\{-128, \ldots, 127\}$ and the
term \defining{octet} for an exact integer object in the interval $\{0,
\ldots, 255\}$.  A byte corresponds to its two's complement
representation as an octet.

The length of a bytevector is the number of bytes it contains. This
number is fixed. A valid index into a bytevector is an exact,
non-negative integer object less than the length of the bytevector.
The first byte of a bytevector has index 0;
the last byte has an index one less than the length of the bytevector.

Generally, the access procedures come in different flavors according
to the size of the represented integer and the endianness of the
representation.  The procedures also distinguish signed and unsigned
representations.
The signed representations all use two's complement.

Like string literals, literals representing bytevectors do not need to
be quoted:
%
\begin{scheme}
\#vu8(12 23 123) \ev \#vu8(12 23 123)%
\end{scheme}

\section{Endianness}

Many operations described in this chapter accept an
\defining{endianness} argument.  Endianness describes the encoding of
exact integer objects as several contiguous bytes in a bytevector~\cite{IEN137}. 
For this purpose, the binary representation of the integer object is split into
consecutive bytes.  \mainindex{little-endian}The little-endian
encoding places the least significant byte of an integer first, with
the other bytes following in increasing order of significance.
\mainindex{big-endian}The big-endian encoding places the most
significant byte of an integer first, with the other bytes following
in decreasing order of significance. 

This terminology also applies to IEEE-754 numbers: IEEE~754 describes
how to represent a floating-point number as an exact integer object, and
endianness describes how the bytes of such an integer are laid out in
a bytevector.

\begin{note}
  Little- and big-endianness are only the most common kinds of
  endianness.  Some architectures distinguish between the endianness
  at different levels of a binary representation.
\end{note}

\section{General operations}

\begin{entry}{%
\proto{endianness}{ \hyper{endianness symbol}}{\exprtype}}

\domain{The name of \hyper{endianness symbol} must be a symbol describing an
  endianness.  An implementation must support at least the symbols
  {\cf big} and {\cf little}, but may support other endianness
  symbols.}  {\cf (endianness \hyper{endianness symbol})} evaluates to
the symbol named \hyper{endianness symbol}.  Whenever one of the
procedures operating on bytevectors accepts an endianness as an
argument, that argument must be one of these symbols.  It is a syntax
violation for \hyper{endianness symbol} to be anything other than an
endianness symbol supported by the implementation.

\begin{note}
  Implementors should use widely accepted designations
  for endianness symbols other than {\cf big} and {\cf little}.
\end{note}

\begin{note}
  Only the name of \hyper{endianness symbol} is significant.
\end{note}
\end{entry}

\begin{entry}{%
\proto{native-endianness}{}{procedure}}

Returns the endianness symbol associated implementation's preferred
endianness (usually that of the underlying machine architecture).
This may be any \hyper{endianness symbol}, including a symbol other
than {\cf big} and {\cf little}.
\end{entry}   

\begin{entry}{%
\proto{bytevector?}{ obj}{procedure}}
   
Returns \schtrue{} if \var{obj} is a bytevector,
otherwise returns \schfalse{}.
\end{entry}

\begin{entry}{%
\proto{make-bytevector}{ k}{procedure}
\rproto{make-bytevector}{ k fill}{procedure}}
   
Returns a newly allocated bytevector of \var{k} bytes.
   
If the \var{fill} argument is missing, the initial contents of the
returned bytevector are unspecified.
   
If the \var{fill} argument is present, it must be an exact integer
object in
the interval $\{-128, \ldots 255\}$ that specifies the initial value
for the bytes of the bytevector: If \var{fill} is positive, it is
interpreted as an octet; if it is negative, it is interpreted as a byte.
\end{entry}   

\begin{entry}{%
\proto{bytevector-length}{ bytevector}{procedure}}
   
Returns, as an exact integer object, the number of bytes in \var{bytevector}.
\end{entry}

\begin{entry}{%
\proto{bytevector=?}{ \vari{bytevector} \varii{bytevector}}{procedure}}
   
Returns \schtrue{} if \vari{bytevector} and \varii{bytevector} are equal---that
is, if they have the same length and equal bytes at all valid indices.
It returns \schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{bytevector-fill!}{ bytevector fill}}

\domain{The \var{fill} argument is as in the description of the {\cf
    make-bytevector} procedure.}
The {\cf bytevector-fill!} procedure stores \var{fill} in every element of \var{bytevector}
and returns \unspecifiedreturn.  Analogous to {\cf vector-fill!}.
\end{entry}

\begin{entry}{%
\pproto{(bytevector-copy! \var{source} \var{source-start}}{procedure}}
\mainschindex{bytevector-copy!}{\tt\obeyspaces\\
     \var{target} \var{target-start} \var{k})}

\domain{\var{Source} and \var{target} must be bytevectors.
  \var{Source-start}, \var{target-start},
  and \var{k} must be non-negative exact integer objects that satisfy
  
  \begin{displaymath}
    \begin{array}{rcccccl}
      0 & \leq & \var{source-start} & \leq & \var{source-start} + \var{k} & \leq & l_{\var{source}}
      \\
      0 & \leq & \var{target-start} & \leq & \var{target-start} + \var{k} & \leq & l_{\var{target}}
    \end{array}
  \end{displaymath}
  %
  where $l_{\var{source}}$ is the length of \var{source} and
  $l_{\var{target}}$ is the length of \var{target}.}
   
   
  The {\cf bytevector-copy!} procedure copies the bytes from \var{source} at indices 
  \begin{displaymath}
     \var{source-start}, \ldots \var{source-start} + \var{k} - 1
  \end{displaymath}
  to consecutive indices in \var{target} starting at \var{target-index}.
   
  This must work even if the memory regions for the source and the target
  overlap, i.e., the bytes at the target location after the copy must be
  equal to the bytes at the source location before the copy.
   
  This returns \unspecifiedreturn.
\begin{scheme}
(let ((b (u8-list->bytevector '(1 2 3 4 5 6 7 8))))
  (bytevector-copy! b 0 b 3 4)
  (bytevector->u8-list b)) \ev (1 2 3 1 2 3 4 8)%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bytevector-copy}{ bytevector}{procedure}}
   
Returns a newly allocated copy of \var{bytevector}.
\end{entry}

\section{Operations on bytes and octets}

\begin{entry}{%
\proto{bytevector-u8-ref}{ bytevector k}{procedure}
\proto{bytevector-s8-ref}{ bytevector k}{procedure}}
   
\domain{\var{K} must be a valid index of \var{bytevector}.}
   
The {\cf bytevector-u8-ref} procedure returns the byte at index \var{k} of \var{bytevector},
as an octet.
   
The {\cf bytevector-s8-ref} procedure returns the byte at index \var{k} of \var{bytevector},
as a (signed) byte.

\begin{scheme}
(let ((b1 (make-bytevector 16 -127))
      (b2 (make-bytevector 16 255)))
  (list
    (bytevector-s8-ref b1 0)
    (bytevector-u8-ref b1 0)
    (bytevector-s8-ref b2 0)
    (bytevector-u8-ref b2 0))) \lev (-127 129 -1 255)%
\end{scheme}
\end{entry}   

\begin{entry}{%
\proto{bytevector-u8-set!}{ bytevector k octet}{procedure}
\proto{bytevector-s8-set!}{ bytevector k byte}{procedure}}
   
\domain{\var{K} must be a valid index of \var{bytevector}.}
   
The {\cf bytevector-u8-set!} procedure stores \var{octet} in element \var{k} of
\var{bytevector}.
   
The {\cf bytevector-s8-set!} procedure stores the two's-complement representation of
\var{byte} in element \var{k} of \var{bytevector}.
   
Both procedures return \unspecifiedreturn.

\begin{scheme}
(let ((b (make-bytevector 16 -127)))

  (bytevector-s8-set! b 0 -126)
  (bytevector-u8-set! b 1 246)

  (list
    (bytevector-s8-ref b 0)
    (bytevector-u8-ref b 0)
    (bytevector-s8-ref b 1)
    (bytevector-u8-ref b 1))) \lev (-126 130 -10 246)%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bytevector->u8-list}{ bytevector}{procedure}
\proto{u8-list->bytevector}{ list}{procedure}}
   
\domain{\var{List} must be a list of octets.}

The {\cf bytevector->u8-list} procedure returns a newly allocated list of the octets of
\var{bytevector} in the same order.

The {\cf u8-list->bytevector} procedure returns a newly allocated bytevector whose
elements are the elements of list \var{list}, in
the same order.  It is analogous to {\cf list->vector}.
\end{entry}

\section{Operations on integers of arbitrary size}

\begin{entry}{%
\proto{bytevector-uint-ref}{ bytevector k endianness size}{procedure}
\proto{bytevector-sint-ref}{ bytevector k endianness size}{procedure}
\proto{bytevector-uint-set!}{ bytevector k n endianness size}{procedure}
\proto{bytevector-sint-set!}{ bytevector k n endianness size}{procedure}}
   
\domain{\var{Size} must be a positive exact integer object. $\var{K}, \ldots,
  \var{k} + \var{size} - 1$ must be valid indices of \var{bytevector}.}
   
The {\cf bytevector-uint-ref} procedure retrieves the exact integer object corresponding to the
unsigned representation of size \var{size} and specified by \var{endianness}
at indices $\var{k}, \ldots, \var{k} + \var{size} - 1$.
   
The {\cf bytevector-sint-ref} procedure retrieves the exact integer object corresponding to the two's-complement representation of size \var{size} and specified by \var{endianness} at
indices $\var{k}, \ldots, \var{k} + \var{size} - 1$.
   
\domain{For {\cf bytevector-uint-set!}, \var{n} must be an exact
  integer object in the interval $\{0, \ldots, 256^{\mathit{size}}-1\}$.}

The {\cf bytevector-uint-set!} procedure stores the unsigned representation of size \var{size}
and specified by \var{endianness} into \var{bytevector} at indices
$\var{k}, \ldots, \var{k} + \var{size} - 1$.
   
\domain{For {\cf bytevector-sint-set!}, \var{n} must be an exact
  integer object in
  the interval $\{-256^{\mathit{size}}/2, \ldots,
  256^{\mathit{size}}/2-1\}$.}
{\cf bytevector-sint-set!} stores the two's-complement
representation of size \var{size} and specified by \var{endianness}
into \var{bytevector} at indices $\var{k}, \ldots, \var{k} + \var{size} - 1$.
   
The \ldots{\cf -set!} procedures return \unspecifiedreturn.

\begin{scheme}
(define b (make-bytevector 16 -127))

(bytevector-uint-set! b 0 (- (expt 2 128) 3)
                     (endianness little) 16)

(bytevector-uint-ref b 0 (endianness little) 16)\lev
    \#xfffffffffffffffffffffffffffffffd

(bytevector-sint-ref b 0 (endianness little) 16)\lev -3

(bytevector->u8-list b)\lev (253 255 255 255 255 255 255 255
               255 255 255 255 255 255 255 255)

(bytevector-uint-set! b 0 (- (expt 2 128) 3)
                 (endianness big) 16)
(bytevector-uint-ref b 0 (endianness big) 16) \lev
    \#xfffffffffffffffffffffffffffffffd

(bytevector-sint-ref b 0 (endianness big) 16) \lev -3

(bytevector->u8-list b) \lev (255 255 255 255 255 255 255 255
               255 255 255 255 255 255 255 253))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bytevector->uint-list}{ bytevector endianness size}{procedure}
\proto{bytevector->sint-list}{ bytevector endianness size}{procedure}
\proto{uint-list->bytevector}{ list endianness size}{procedure}
\proto{sint-list->bytevector}{ list endianness size}{procedure}}
   
\domain{\var{Size} must be a positive exact integer object.  For {\cf
    uint-list->bytevector}, \var{list} must be a list of exact
  integer objects in the interval $\{0, \ldots, 256^{\mathit{size}}-1\}$.  For
  {\cf sint-list->bytevector}, \var{list} must be a list of exact
  integer objects in the interval $\{-256^{\mathit{size}}/2, \ldots,
  256^{\mathit{size}}/2-1\}$.  The length of \var{bytevector} or,
  respectively, of \var{list} must be divisible by \var{size}.}
   
These procedures convert between lists of integer objects and their consecutive
representations according to \var{size} and \var{endianness} in the
\var{bytevector} objects in the same way as {\cf bytevector->u8-list} and {\cf
  u8-list->bytevector} do for one-byte representations.

\begin{scheme}
(let ((b (u8-list->bytevector '(1 2 3 255 1 2 1 2))))
  (bytevector->sint-list b (endianness little) 2)) \lev (513 -253 513 513)

(let ((b (u8-list->bytevector '(1 2 3 255 1 2 1 2))))
  (bytevector->uint-list b (endianness little) 2)) \lev (513 65283 513 513)%
\end{scheme}
\end{entry}

\section{Operations on 16-bit integers}

\begin{entry}{%
\proto{bytevector-u16-ref}{ bytevector k endianness}{procedure}
\proto{bytevector-s16-ref}{ bytevector k endianness}{procedure}
\proto{bytevector-u16-native-ref}{ bytevector k}{procedure}
\proto{bytevector-s16-native-ref}{ bytevector k}{procedure}
\proto{bytevector-u16-set!}{ bytevector k n endianness}{procedure}
\proto{bytevector-s16-set!}{ bytevector k n endianness}{procedure}
\proto{bytevector-u16-native-set!}{ bytevector k n}{procedure}
\proto{bytevector-s16-native-set!}{ bytevector k n}{procedure}}
   
\domain{\var{K} must be a valid index of \var{bytevector}; so must
  $\var{k} + 1$. For {\cf bytevector-u16-set!} and {\cf
    bytevector-\hp{}u16-native-\hp{}set!}, \var{n} must be an exact integer object in
  the interval $\{0, \ldots, 2^{16}-1\}$.  For {\cf bytevector-s16-set!}
  and {\cf bytevector-s16-native-set!}, \var{n} must be an exact
  integer object in the interval $\{-2^{15}, \ldots, 2^{15}-1\}$.}
   
These retrieve and set two-byte representations of numbers at indices
\var{k} and $\var{k}+1$, according to the endianness specified by
\var{endianness}. The procedures with {\cf u16} in their names deal with the
unsigned representation; those with {\cf s16} in their names deal
with the two's-complement representation.

The procedures with {\cf native} in their names employ the native
endianness, and work only at aligned indices:
\var{k} must be a multiple of 2.
   
The \ldots{\cf -set!} procedures return \unspecifiedreturn.

\begin{scheme}
(define b
  (u8-list->bytevector
    '(255 255 255 255 255 255 255 255
      255 255 255 255 255 255 255 253)))

(bytevector-u16-ref b 14 (endianness little)) \lev 65023
(bytevector-s16-ref b 14 (endianness little)) \lev -513
(bytevector-u16-ref b 14 (endianness big)) \lev 65533
(bytevector-s16-ref b 14 (endianness big)) \lev -3

(bytevector-u16-set! b 0 12345 (endianness little))
(bytevector-u16-ref b 0 (endianness little)) \lev 12345

(bytevector-u16-native-set! b 0 12345)
(bytevector-u16-native-ref b 0) \ev 12345

(bytevector-u16-ref b 0 (endianness little)) \lev \unspecified%
\end{scheme}
\end{entry}

\section{Operations on 32-bit integers}

\begin{entry}{%
\proto{bytevector-u32-ref}{ bytevector k endianness}{procedure}
\proto{bytevector-s32-ref}{ bytevector k endianness}{procedure}
\proto{bytevector-u32-native-ref}{ bytevector k}{procedure}
\proto{bytevector-s32-native-ref}{ bytevector k}{procedure}
\proto{bytevector-u32-set!}{ bytevector k n endianness}{procedure}
\proto{bytevector-s32-set!}{ bytevector k n endianness}{procedure}
\proto{bytevector-u32-native-set!}{ bytevector k n}{procedure}
\proto{bytevector-s32-native-set!}{ bytevector k n}{procedure}}
   
\domain{$\var{K}, \ldots, \var{k}+ 3$ must be valid indices of
  \var{bytevector}.
  For {\cf bytevector-u32-set!} and {\cf
    bytevector-\hp{}u32-\hp{}native-\hp{}set!}, \var{n} must be an exact integer
  object in
  the interval $\{0, \ldots, 2^{32}-1\}$.  For {\cf bytevector-s32-set!}
  and {\cf bytevector-s32-native-set!}, \var{n} must be an exact
  integer object in the interval $\{-2^{31}, \ldots, 2^{32}-1\}$.}
   
These retrieve and set four-byte representations of numbers at indices $\var{k},
\ldots, \var{k}+ 3$, according to the endianness specified by \var{endianness}. The
procedures with {\cf u32} in their names deal with the unsigned representation;
those with {\cf s32} with the two's-complement representation.
   
The procedures with {\cf native} in their names employ the native endianness, and
work only at aligned indices: \var{k} must be a multiple of 4.
   
The \ldots{\cf{}-set!} procedures return \unspecifiedreturn.

\begin{scheme}
(define b
  (u8-list->bytevector
    '(255 255 255 255 255 255 255 255
      255 255 255 255 255 255 255 253)))

(bytevector-u32-ref b 12 (endianness little)) \lev 4261412863
(bytevector-s32-ref b 12 (endianness little)) \lev -33554433
(bytevector-u32-ref b 12 (endianness big)) \lev 4294967293
(bytevector-s32-ref b 12 (endianness big)) \lev -3%
\end{scheme}
\end{entry}

\section{Operations on 64-bit integers}

\begin{entry}{%
\proto{bytevector-u64-ref}{ bytevector k endianness}{procedure}
\proto{bytevector-s64-ref}{ bytevector k endianness}{procedure}
\proto{bytevector-u64-native-ref}{ bytevector k}{procedure}
\proto{bytevector-s64-native-ref}{ bytevector k}{procedure}
\proto{bytevector-u64-set!}{ bytevector k n endianness}{procedure}
\proto{bytevector-s64-set!}{ bytevector k n endianness}{procedure}
\proto{bytevector-u64-native-set!}{ bytevector k n}{procedure}
\proto{bytevector-s64-native-set!}{ bytevector k n}{procedure}}
 
\domain{$\var{K}, \ldots, \var{k}+ 7$ must be valid indices of
  \var{bytevector}.
  For {\cf bytevector-u64-set!} and {\cf
    bytevector-\hp{}u64-\hp{}native-\hp{}set!}, \var{n} must be an exact integer
  object in
  the interval $\{0, \ldots, 2^{64}-1\}$.  For {\cf bytevector-s64-set!}
  and {\cf bytevector-s64-native-set!}, \var{n} must be an exact
  integer object in the interval $\{-2^{63}, \ldots, 2^{64}-1\}$.}
   
These retrieve and set eight-byte representations of numbers at
indices $\var{k}, \ldots, \var{k}+ 7$, according to the endianness
specified by \var{endianness}. The procedures with {\cf u64} in their names deal
with the unsigned representation; those with {\cf s64} with the
two's-complement representation.
   
The procedures with {\cf native} in their names employ the native endianness, and
work only at aligned indices: \var{k} must be a multiple of 8.
   
The \ldots{\cf{}-set!} procedures return \unspecifiedreturn.

\begin{scheme}
(define b
  (u8-list->bytevector
    '(255 255 255 255 255 255 255 255
      255 255 255 255 255 255 255 253)))

(bytevector-u64-ref b 8 (endianness little)) \lev 18302628885633695743
(bytevector-s64-ref b 8 (endianness little)) \lev -144115188075855873
(bytevector-u64-ref b 8 (endianness big)) \lev 18446744073709551613
(bytevector-s64-ref b 8 (endianness big)) \lev -3%
\end{scheme}
\end{entry}

\section{Operations on IEEE-754 representations}

\begin{entry}{%
\proto{bytevector-ieee-single-native-ref}{ bytevector k}{procedure}
\proto{bytevector-ieee-single-ref}{ bytevector k endianness}{procedure}}

\domain{$\var{K}, \ldots, \var{k}+3$ must be valid indices of
  \var{bytevector}.  For {\cf bytevector-ieee-single-native-ref}, \var{k} must
  be a multiple of $4$.}

These procedures return the inexact real number object that best
represents the IEEE-754 single-precision number represented by the
four bytes beginning at index
\var{k}.
\end{entry}

\begin{entry}{%
\proto{bytevector-ieee-double-native-ref}{ bytevector k}{procedure}
\proto{bytevector-ieee-double-ref}{ bytevector k endianness}{procedure}}

\domain{$\var{K}, \ldots, \var{k}+7$ must be valid indices of
  \var{bytevector}.  For {\cf bytevector-ieee-double-native-ref}, \var{k} must
  be a multiple of $8$.}

These procedures return the inexact real number object that best
represents the IEEE-754 double-precision number represented by the
eight bytes beginning at index \var{k}.
\end{entry}

\begin{entry}{%
\proto{bytevector-ieee-single-native-set!}{ bytevector k x}{procedure}
\pproto{(bytevector-ieee-single-set! \var{bytevector}}{procedure}}
{\tt\obeyspaces\\
     \var{k} \var{x} \var{endianness})}

\domain{$\var{K}, \ldots, \var{k}+3$ must be valid indices of
  \var{bytevector}.  For {\cf bytevector-ieee-single-native-set!}, \var{k} must
  be a multiple of $4$.}

These procedures store an IEEE-754 single-precision representation of \var{x} into
elements \var{k} through $\var{k}+3$ of \var{bytevector}, and return
\unspecifiedreturn.
\end{entry}

\begin{entry}{%
\proto{bytevector-ieee-double-native-set!}{ bytevector k x}{procedure}
\pproto{(bytevector-ieee-double-set! \var{bytevector}}{procedure}}
{\tt\obeyspaces\\
     \var{k} \var{x} \var{endianness})}

\domain{$\var{K}, \ldots, \var{k}+7$ must be valid indices of
  \var{bytevector}.  For {\cf bytevector-ieee-double-native-set!}, \var{k} must
  be a multiple of $8$.}

These procedures store an IEEE-754 double-precision representation of \var{x} into
elements \var{k} through $\var{k}+7$ of \var{bytevector}, and return
\unspecifiedreturn.
\end{entry}

\section{Operations on strings}

This section describes procedures that convert between strings and
bytevectors containing Unicode encodings of those strings.  When
decoding bytevectors, encoding errors are handled as with the {\cf
  replace} semantics of textual I/O (see
section~\ref{transcoderssection}): If an invalid or incomplete
character encoding is encountered, then the replacement character
U+FFFD is appended to the string being generated, an appropriate
number of bytes are ignored, and decoding continues with the following
bytes.

\begin{entry}{%
\proto{string->utf8}{ string}{procedure}}

Returns a newly allocated (unless empty) bytevector that
contains the UTF-8 encoding of the given string.
\end{entry}

\begin{entry}{%
\proto{string->utf16}{ string}{procedure}
\rproto{string->utf16}{ string endianness}{procedure}}

\domain{If \var{endianness} is specified, it must be the symbol {\cf
    big} or the symbol {\cf little}.}  The {\cf string->utf16}
  procedure returns a newly allocated (unless empty) bytevector that
contains the UTF-16BE or UTF-16LE encoding of the given string (with
no byte-order mark).  If endianness is not specified or is {\cf big},
then UTF-16BE is used.  If endianness is {\cf little}, then UTF-16LE
is used.
\end{entry}

\begin{entry}{%
\proto{string->utf32}{ string}{procedure}
\rproto{string->utf32}{ string endianness}{procedure}}

\domain{If \var{endianness} is specified, it must be the symbol {\cf
    big} or the symbol {\cf little}.}  The {\cf string->utf32}
procedure returns
a newly allocated (unless empty) bytevector that contains the UTF-32BE
or UTF-32LE encoding of the given string (with no byte mark).  If
endianness is not specified or is {\cf big}, then UTF-32BE is used.
If endianness is {\cf little}, then UTF-32LE is used.
\end{entry}

\begin{entry}{%
\proto{utf8->string}{ bytevector}{procedure}}

Returns a newly allocated (unless empty) string whose character
sequence is encoded by the given bytevector.
\end{entry}

\begin{entry}{%
\proto{utf16->string}{ bytevector endianness}{procedure}
\pproto{(utf16->string \var{bytevector}}{procedure}}
{\tt\obeyspaces\\
    \var{endianness} \var{endianness-mandatory})}

\domain{\var{Endianness} must be the symbol {\cf big} or
  the symbol {\cf little}.} The {\cf utf16->string} procedure returns
a newly allocated (unless empty) string whose character sequence is
encoded by the given bytevector.  \var{Bytevector} is decoded
according to UTF-16BE or UTF-16LE: If \var{endianness-mandatory?} is
absent or \schfalse, {\cf utf16->string} determines the endianness
according to a UTF-16 BOM at the beginning of \var{bytevector} if a
BOM is present; in this case, the BOM is not decoded as a character.
Also in this case, if no UTF-16 BOM is present, \var{endianness}
specifies the endianness of the encoding.  If
\var{endianness-mandatory?} is a true value, \var{endianness}
specifies the endianness of the encoding, and any UTF-16 BOM in the
encoding is decoded as a regular character.

\begin{note}
  A UTF-16 BOM is either a sequence of bytes \sharpsign{}xFE,
  \sharpsign{}xFF specifying {\cf big} and UTF-16BE, or \sharpsign{}xFF,
  \sharpsign{}xFE specifying {\cf little} and UTF-16LE.
\end{note}
\end{entry}

\begin{entry}{%
\proto{utf32->string}{ bytevector endianness}{procedure}
\pproto{(utf32->string \var{bytevector}}{procedure}}
{\tt\obeyspaces\\
    \var{endianness} \var{endianness-mandatory})}

\domain{\var{Endianness} must be the symbol {\cf big} or
  the symbol {\cf little}.} The {\cf utf32->string} procedure returns
a newly allocated (unless empty) string whose character sequence is
encoded by the given bytevector.  \var{Bytevector} is decoded
according to UTF-32BE or UTF-32LE: If \var{endianness-mandatory?} is
absent or \schfalse, {\cf utf32->string} determines the endianness
according to a UTF-32 BOM at the beginning of \var{bytevector} if a
BOM is present; in this case, the BOM is not decoded as a character.
Also in this case, if no UTF-32 BOM is present, \var{endianness}
specifies the endianness of the encoding.  If
\var{endianness-mandatory?} is a true value, \var{endianness}
specifies the endianness of the encoding, and any UTF-32 BOM in the
encoding is decoded as a regular character.

\begin{note}
  A UTF-32 BOM is either a sequence of bytes \sharpsign{}x00,
  \sharpsign{}x00, \sharpsign{}xFE, \sharpsign{}xFF specifying {\cf
    big} and UTF-32BE, or \sharpsign{}xFF, \sharpsign{}xFE,
  \sharpsign{}x00, \sharpsign{}x00, specifying {\cf little} and
  UTF-32LE.
\end{note}
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   29: list.tex}
\chapter{List utilities}
% \label{listutilities}

This chapter describes the \defrsixlibrary{lists} library, which
contains various useful procedures that operate on lists.

\begin{entry}{%
\proto{find}{ proc list}{procedure}}

\domain{\var{Proc} should accept one argument
  and return a single value.  \var{Proc} should not mutate \var{list}.}
The {\cf find} procedure applies \var{proc} to the elements of
\var{list} in order.  If \var{proc} returns a true value for an
element, {\cf find} immediately returns that element.  If \var{proc}
returns \schfalse{} for all elements of the list, {\cf find} returns
\schfalse{}.  \var{Proc} is always called in the same dynamic environment
as {\cf find} itself.

\begin{scheme}
(find even? '(3 1 4 1 5 9)) \ev 4
(find even? '(3 1 5 1 5 9)) \ev \schfalse{}
\end{scheme}

\implresp The implementation must check that \var{list} is a chain of
pairs up to the found element, or that it is indeed a list if no
element is found.  It should not check that it is a chain of pairs
beyond the found element.  The implementation must check the restrictions on
\var{proc} to the extent performed by applying it as described.
An
implementation may check whether \var{proc} is an appropriate argument
before applying it.
\end{entry}

\begin{entry}{%
\proto{for-all}{ proc \vari{list} \varii{list} \dotsfoo{} \varn{list}}{procedure}
\proto{exists}{ proc \vari{list} \varii{list} \dotsfoo{} \varn{list}}{procedure}}

\domain{The \var{list}s should all have the same length, and
  \var{proc} should accept $n$ arguments and
  return a single value.
  \var{Proc} should not mutate the \var{list} arguments.}

For natural numbers $i = 0, 1, \ldots$, the {\cf for-all} procedure
successively applies \var{proc} to arguments $x_i^1 \ldots x_i^n$,
where $x_i^j$ is the $i$th element of \varj{list}, until \schfalse{} is
returned.  If \var{proc} returns true values for all but the last
element of \vari{list}, {\cf for-all} performs a tail call of \var{proc}
on the $k$th elements, where $k$ is the length of \vari{list}.  If \var{proc}
returns \schfalse{} on any set of elements, {\cf for-all} returns
\schfalse{} after the first such application of \var{proc}.
If the \var{list}s are all empty, {\cf
  for-all} returns \schtrue.

For natural numbers $i = 0, 1, \ldots$, the {\cf exists} procedure
applies \var{proc} successively to arguments $x_i^1 \ldots x_i^n$,
where $x_i^j$ is the $i$th element of \varj{list}, until a true value is
returned.  If \var{proc} returns \schfalse{} for all but the last
elements of the \var{list}s, {\cf exists} performs a tail call of
\var{proc} on the $k$th elements, where $k$ is the length of
\vari{list}.
If \var{proc} returns a true value on any set of elements, {\cf
  exists} returns that value after the first such application of
\var{proc}.  If the \var{list}s
are all empty, {\cf exists} returns \schfalse.

\var{Proc} is always called in the same dynamic environment 
as {\cf for-all} or, respectively, {\cf exists} itself.

\begin{scheme}
(for-all even? '(3 1 4 1 5 9)) \lev \schfalse{}
(for-all even? '(3 1 4 1 5 9 . 2)) \lev \schfalse{}
(for-all even? '(2 4 14)) \ev \schtrue{}
(for-all even? '(2 4 14 . 9)) \lev \exception{\cf\&assertion}
(for-all (lambda (n) (and (even? n) n))
         '(2 4 14)) \lev 14
(for-all < '(1 2 3) '(2 3 4)) \lev \schtrue{}
(for-all < '(1 2 4) '(2 3 4)) \lev \schfalse{}

(exists even? '(3 1 4 1 5 9)) \lev \schtrue{}
(exists even? '(3 1 1 5 9)) \ev \schfalse{}
(exists even? '(3 1 1 5 9 . 2)) \lev \exception{\cf\&assertion}
(exists (lambda (n) (and (even? n) n)) '(2 1 4 14)) \lev 2
(exists < '(1 2 4) '(2 3 4)) \ev \schtrue{}
(exists > '(1 2 3) '(2 3 4)) \ev \schfalse{}
\end{scheme}

\implresp The implementation must check that the \var{list}s are
chains of pairs to the extent necessary to determine the return value.
If this requires traversing the lists entirely, the implementation
should check that the \var{list}s all have the same length.  If not,
it should not check that the \var{list}s are chains of pairs beyond
the traversal.  The implementation must check the restrictions on
\var{proc} to the extent performed by applying it as described.
An
implementation may check whether \var{proc} is an appropriate argument
before applying it.
\end{entry}

\begin{entry}{%
\proto{filter}{ proc list}{procedure}
\proto{partition}{ proc list}{procedure}
}

\domain{\var{Proc} should accept one argument
  and return a single value. \var{Proc} should not mutate \var{list}.}

The {\cf filter} procedure applies
\var{proc} to each element of \var{list} and returns a list of
the elements of \var{list} for which \var{proc} returned a true
value.  The {\cf partition} procedure also applies \var{proc} to
each element of \var{list}, but returns two values, the first one a
list of the elements of \var{list} for which \var{proc} returned a
true value, and the second a list of the elements of \var{list} for
which \var{proc} returned \schfalse.
In both cases, the elements of the result list(s) are in the same
order as they appear in the input list.
\var{Proc} is always called in the same dynamic environment 
as {\cf filter} or, respectively, {\cf partition} itself.
If multiple returns occur from {\cf filter} or {\cf partitions}, the return
values returned by earlier returns are not mutated.

\begin{scheme}
(filter even? '(3 1 4 1 5 9 2 6)) \lev (4 2 6)

(partition even? '(3 1 4 1 5 9 2 6)) \lev (4 2 6) (3 1 1 5 9) ; two values
\end{scheme}

\implresp The implementation must check the restrictions on \var{proc}
to the extent performed by applying it as described.
An
implementation may check whether \var{proc} is an appropriate argument
before applying it.
\end{entry}

\begin{entry}{%
\proto{fold-left}{ combine nil \vari{list} \varii{list} \dotsfoo \varn{list}}{procedure}}

\domain{The \var{list}s should all have the same
  length.  \var{Combine} must be a procedure.  It should accept one more
  argument than there are \var{list}s and return a single value.
  It should not mutate the \var{list} arguments.}
The {\cf fold-left} procedure iterates the \var{combine} procedure over an
accumulator value and the elements of the \var{list}s from left to
right, starting with an accumulator value of \var{nil}.  More
specifically, {\cf fold-left} returns \var{nil} if the \var{list}s are
empty.  If they are not empty, \var{combine} is first applied to
\var{nil} and the respective first elements of the \var{list}s in
order.  The result becomes the new accumulator value, and \var{combine}
is applied to the new accumulator value and the respective next elements
of the \var{list}.  This step is repeated until the end of the list is
reached; then the accumulator value is returned.
\var{Combine} is always called in the same dynamic environment 
as {\cf fold-left} itself.

\begin{scheme}
(fold-left + 0 '(1 2 3 4 5)) \ev 15

(fold-left (lambda (a e) (cons e a)) '()
           '(1 2 3 4 5)) \lev (5 4 3 2 1)

(fold-left (lambda (count x)
             (if (odd? x) (+ count 1) count))
           0
           '(3 1 4 1 5 9 2 6 5 3)) \lev 7

(fold-left (lambda (max-len s)
             (max max-len (string-length s)))
           0
           '("longest" "long" "longer")) \lev 7

(fold-left cons '(q) '(a b c)) \lev ((((q) . a) . b) . c)

(fold-left + 0 '(1 2 3) '(4 5 6)) \lev 21
\end{scheme}

\implresp The implementation should check that the \var{list}s all
have the same length.  The implementation must check the restrictions
on \var{combine} to the extent performed by applying it as described.
An
implementation may check whether \var{combine} is an appropriate argument
before applying it.
\end{entry}


\begin{entry}{%
\proto{fold-right}{ combine nil \vari{list} \varii{list} \dotsfoo \varn{list}}{procedure}}

\domain{The \var{list}s should all have the same
  length.  \var{Combine} must be a procedure.  It should accept one more
  argument than there are \var{list}s and return a single value.
  \var{Combine} should not mutate the \var{list} arguments.}
The {\cf fold-right} procedure iterates the \var{combine} procedure over
the elements of the \var{list}s from right to left and an accumulator
value, starting with an accumulator value of \var{nil}.  More
specifically, {\cf fold-right} returns \var{nil} if the \var{list}s
are empty.  If they are not empty, \var{combine} is first applied to the
respective last elements of the \var{list}s in order and \var{nil}.
The result becomes the new accumulator value, and \var{combine} is
applied to the respective previous elements of the \var{list}s and the
new accumulator value.  This step is repeated until the beginning of the
list is reached; then the accumulator value is returned.
\var{Proc} is always called in the same dynamic environment 
as {\cf fold-right} itself.

\begin{scheme}
(fold-right + 0 '(1 2 3 4 5)) \lev 15

(fold-right cons '() '(1 2 3 4 5)) \lev (1 2 3 4 5)

(fold-right (lambda (x l)
              (if (odd? x) (cons x l) l))
            '()
            '(3 1 4 1 5 9 2 6 5))
\ev (3 1 1 5 9 5)

(fold-right cons '(q) '(a b c)) \lev (a b c q)

(fold-right + 0 '(1 2 3) '(4 5 6)) \lev 21
\end{scheme}

\implresp The implementation should check that the \var{list}s all
have the same length.  The implementation must check the restrictions
on \var{combine} to the extent performed by applying it as described.
An
implementation may check whether \var{combine} is an appropriate argument
before applying it.
\end{entry}

\begin{entry}{%
\proto{remp}{ proc list}{procedure}
\proto{remove}{ obj list}{procedure}
\proto{remv}{ obj list}{procedure}
\proto{remq}{ obj list}{procedure}}

\domain{\var{Proc} should accept one argument
   and return a single value.
   \var{Proc} should not mutate \var{list}.}

Each of these procedures returns a list of the elements of \var{list}
that do not satisfy a given condition.  The {\cf remp} procedure
applies \var{proc} to each element of \var{list} and returns a
list of the elements of \var{list} for which \var{proc} returned
\schfalse.  \var{Proc} is always called in the same dynamic environment 
as {\cf remp} itself.
The {\cf remove}, {\cf remv}, and {\cf remq} procedures return a list of
the elements that are not \var{obj}.  The {\cf remq} procedure uses {\cf eq?}\ to
compare \var{obj} with the elements of \var{list}, while {\cf remv}
uses {\cf eqv?}\ and {\cf remove} uses {\cf equal?}.
The elements of the result list are in the same
order as they appear in the input list.
If multiple returns occur from {\cf remp}, the return
values returned by earlier returns are not mutated.

\begin{scheme}
(remp even? '(3 1 4 1 5 9 2 6 5)) \lev (3 1 1 5 9 5)

(remove 1 '(3 1 4 1 5 9 2 6 5)) \lev (3 4 5 9 2 6 5)

(remv 1 '(3 1 4 1 5 9 2 6 5)) \lev (3 4 5 9 2 6 5)

(remq 'foo '(bar foo baz)) \ev (bar baz)
\end{scheme}

\implresp The implementation must check the restrictions on \var{proc}
to the extent performed by applying it as described.
An
implementation may check whether \var{proc} is an appropriate argument
before applying it.
\end{entry}

\begin{entry}{%
\proto{memp}{ proc list}{procedure}
\proto{member}{ obj list}{procedure}
\proto{memv}{ obj list}{procedure}
\proto{memq}{ obj list}{procedure}
}

\domain{\var{Proc} should accept one argument
  and return a single value.  \var{Proc} should not mutate \var{list}.}

These procedures return the first sublist of \var{list} whose car
satisfies a given condition, where the sublists of \var{lists} are the
lists returned by {\tt (list-tail \var{list} \var{k})} for
\var{k} less than the length of \var{list}.  The {\cf memp} procedure applies
\var{proc} to the cars of the sublists of \var{list} until it
finds one for which \var{proc} returns a true value.
\var{Proc} is always called in the same dynamic environment 
as {\cf memp} itself.  The {\cf
  member}, {\cf memv}, and {\cf memq} procedures look for the first occurrence of
\var{obj}.  If \var{list} does not contain an element satisfying the
condition, then \schfalse{} (not the empty list) is returned.  The {\cf
  member} procedure uses {\cf equal?}\ to compare \var{obj} with the elements of
\var{list}, while {\cf memv} uses {\cf eqv?}\ and {\cf memq} uses
{\cf eq?}.

\begin{scheme}
(memp even? '(3 1 4 1 5 9 2 6 5)) \lev (4 1 5 9 2 6 5)

(memq 'a '(a b c))              \ev  (a b c)
(memq 'b '(a b c))              \ev  (b c)
(memq 'a '(b c d))              \ev  \schfalse
(memq (list 'a) '(b (a) c))     \ev  \schfalse
(member (list 'a)
        '(b (a) c))             \ev  ((a) c)
(memq 101 '(100 101 102))       \ev  \unspecified
(memv 101 '(100 101 102))       \ev  (101 102)%
\end{scheme} 

\implresp The implementation must check that \var{list} is a chain of
pairs up to the found element, or that it is indeed a list if no
element is found.  It should not check that it is a chain of pairs
beyond the found element.  The implementation must check the restrictions on
\var{proc} to the extent performed by applying it as described.
An
implementation may check whether \var{proc} is an appropriate argument
before applying it.
\end{entry}

\begin{entry}{%
\proto{assp}{ proc alist}{procedure}
\proto{assoc}{ obj alist}{procedure}
\proto{assv}{ obj alist}{procedure}
\proto{assq}{ obj alist}{procedure}}

\domain{\var{Alist} (for ``association list'') should be a list of pairs.
  \var{Proc} should accept one argument
  and return a single value.  \var{Proc} should not mutate \var{alist}.}

These procedures find the first pair in \var{alist}
whose car field satisfies a given condition, and returns that pair
without traversing \var{alist} further.
If no pair in \var{alist} satisfies the condition, then \schfalse{}
is returned.  The {\cf assp} procedure successively applies
\var{proc} to the car fields of \var{alist} and looks for a pair
for which it returns a true value.
\var{Proc} is always called in the same dynamic environment 
as {\cf assp} itself.  The {\cf assoc}, {\cf assv}, and {\cf
  assq} procedures look for a pair that has \var{obj} as its car.  The
{\cf assoc} procedure uses 
{\cf equal?}\ to compare \var{obj} with the car fields of the pairs in
\var{alist}, while {\cf assv} uses {\cf eqv?}\ and {\cf assq} uses
{\cf eq?}.

\implresp The implementation must check that \var{alist} is a chain of
pairs containing pairs up to the found pair, or that it is indeed a
list of pairs if no element is found.  It should not check that it is
a chain of pairs beyond the found element.  The implementation must
check the restrictions on \var{proc} to the extent performed by
applying it as described.
An
implementation may check whether \var{proc} is an appropriate argument
before applying it.

\begin{scheme}
(define d '((3 a) (1 b) (4 c)))

(assp even? d) \ev (4 c)
(assp odd? d) \ev (3 a)

(define e '((a 1) (b 2) (c 3)))
(assq 'a e)     \ev  (a 1)
(assq 'b e)     \ev  (b 2)
(assq 'd e)     \ev  \schfalse
(assq (list 'a) '(((a)) ((b)) ((c))))
                \ev  \schfalse
(assoc (list 'a) '(((a)) ((b)) ((c))))   
                           \ev  ((a))
(assq 5 '((2 3) (5 7) (11 13)))    
                           \ev  \unspecified
(assv 5 '((2 3) (5 7) (11 13)))    
                           \ev  (5 7)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{cons*}{ \vari{obj} \dotsfoo{} \varn{obj} \var{obj}}{procedure}
\rproto{cons*}{ \var{obj}}{procedure}}

If called with at least two arguments, {\cf cons*} returns a freshly
allocated chain of pairs whose cars are \vari{obj}, \dotsfoo,
\varn{obj}, and whose last cdr is \var{obj}.  If called with only one
argument, {\cf cons*} returns that argument.

\begin{scheme}
(cons* 1 2 '(3 4 5)) \ev (1 2 3 4 5)
(cons* 1 2 3) \ev (1 2 . 3)
(cons* 1) \ev 1%
\end{scheme}
  
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   30: sort.tex}
\chapter{Sorting}
% \label{sortingchapter}

This chapter describes the \defrsixlibrary{sorting} library for
sorting lists and vectors.

\begin{entry}{%
\proto{list-sort}{ proc list}{procedure}
\proto{vector-sort}{ proc vector}{procedure}}

\domain{\var{Proc} should accept any two elements
  of \var{list} or \var{vector}, and should not have any side
  effects.}  \var{Proc} should return a true value when its first argument
is strictly less than its second, and \schfalse{} otherwise.

The {\cf list-sort} and {\cf vector-sort} procedures perform a stable
sort of \var{list} or \var{vector} in ascending order according to
\var{proc}, without changing \var{list} or
\var{vector} in any way.  The {\cf list-sort} procedure returns a
list, and {\cf vector-sort} returns a vector.  The results may be {\cf
  eq?} to the argument when the argument is already sorted, and the
result of {\cf list-sort} may share structure with a tail of the
original list.  The sorting algorithm performs $O(n \lg n)$ calls to
\var{proc} where $n$ is the length of \var{list} or \var{vector},
and all arguments passed to \var{proc} are elements of the list or
vector being sorted, but the pairing of arguments and the sequencing
of calls to \var{proc} are not specified.
If multiple returns occur from {\cf list-sort} or {\cf vector-sort}, the return
values returned by earlier returns are not mutated.

\begin{scheme}
(list-sort < '(3 5 2 1)) \ev (1 2 3 5)
(vector-sort < '\sharpsign(3 5 2 1)) \ev \sharpsign(1 2 3 5)%
\end{scheme}

\implresp The implementation must check the restrictions
on \var{proc} to the extent performed by applying it as described.
An
implementation may check whether \var{proc} is an appropriate argument
before applying it.
\end{entry}

\begin{entry}{%
\proto{vector-sort!}{ proc vector}{procedure}}

\domain{\var{Proc} should accept any two elements
  of the vector, and should not have any side
  effects.  \var{Proc} should return a true value when its first
argument is strictly less than its second, and \schfalse{} otherwise.}
The {\cf vector-sort!} procedure destructively sorts \var{vector} in
ascending order according to \var{proc}.  The sorting algorithm
performs $O(n^2)$ calls to \var{proc} where $n$ is the length of
\var{vector}, and all arguments passed to \var{proc} are elements
of the vector being sorted, but the pairing of arguments and the
sequencing of calls to \var{proc} are not specified.  The sorting
algorithm may be unstable.  The procedure returns \unspecifiedreturn.

\begin{scheme}
(define v (vector 3 5 2 1))
(vector-sort! v) \ev \theunspecified
v \ev \sharpsign(1 2 3 5)
\end{scheme}
\implresp The implementation must check the restrictions
on \var{proc} to the extent performed by applying it as described.
An
implementation may check whether \var{proc} is an appropriate argument
before applying it.
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   31: control.tex}
\chapter{Control structures}
% \label{controllib}

This chapter describes the \defrsixlibrary{control} library, which
provides useful control structures.

\begin{entry}{%
\proto{when}{ \hyper{test} \hyperi{expression} \hyperii{expression} \dotsfoo}{\exprtype}
\proto{unless}{ \hyper{test} \hyperi{expression} \hyperii{expression} \dotsfoo}{\exprtype}}

\syntax \hyper{Test} must be an expression.

\semantics A {\cf when} expression is evaluated by evaluating the
\hyper{test} expression.  If \hyper{test} evaluates to a true value,
the remaining \hyper{expression}s are evaluated in order, and the
results of the last \hyper{expression} are returned as the
results of the entire {\cf when} expression.  Otherwise, the {\cf
    when} expression returns \unspecifiedreturn.  An {\cf unless}
expression is evaluated by evaluating the \hyper{test} expression.
If \hyper{test} evaluates to \schfalse, the remaining
\hyper{expression}s are evaluated in order, and the results of the
last \hyper{expression} are returned as the results of the
entire {\cf unless} expression.  Otherwise, the {\cf unless} expression
returns \unspecifiedreturn.

The final \hyper{expression} is in tail context if the {\cf when} or
{\cf unless} form is itself in tail context.

\begin{scheme}
(when (> 3 2) 'greater) \ev greater
(when (< 3 2) 'greater) \ev \theunspecified
(unless (> 3 2) 'less) \ev \theunspecified
(unless (< 3 2) 'less) \ev less
\end{scheme}

The {\cf when} and {\cf unless} expressions are derived forms.  They
could be defined by the following macros:

\begin{scheme}
(define-syntax \ide{when}
  (syntax-rules ()
    ((when test result1 result2 ...)
     (if test
         (begin result1 result2 ...)))))

(define-syntax \ide{unless}
  (syntax-rules ()
    ((unless test result1 result2 ...)
     (if (not test)
         (begin result1 result2 ...)))))
\end{scheme}

\end{entry}

\noindent%
\pproto{(do ((\hyperi{variable} \hyperi{init} \hyperi{step})}{\exprtype}
\mainschindex{do}{\tt\obeyspaces%
     \dotsfoo)\\
    (\hyper{test} \hyper{expression} \dotsfoo)\\
  \hyper{command} \dotsfoo)}

\syntax
The \hyper{init}s, \hyper{step}s, \hyper{test}s, and \hyper{command}s must be
expressions.  The \hyper{variable}s must be pairwise distinct variables.

\semantics
The {\cf do} expression is an iteration construct.  It specifies a set of variables to
be bound, how they are to be initialized at the start, and how they are
to be updated on each iteration.

A {\cf do} expression is evaluated as follows:
The \hyper{init} expressions are evaluated (in some unspecified order),
the \hyper{variable}s are bound to fresh locations, the results of the
\hyper{init} expressions are stored in the bindings of the
\hyper{variable}s, and then the iteration phase begins.

\vest Each iteration begins by evaluating \hyper{test}; if the result is
\schfalse, then the \hyper{command}s
are evaluated in order for effect, the \hyper{step}
expressions are evaluated in some unspecified order, the
\hyper{variable}s are bound to fresh locations holding the results,
and the next iteration begins.

\vest If \hyper{test} evaluates to a true value, the
\hyper{expression}s are evaluated from left to right and the values of
the last \hyper{expression} are returned.  If no \hyper{expression}s
are present, then the {\cf do} expression returns \unspecifiedreturn.

\vest The region\index{region} of the binding of a \hyper{variable}
consists of the entire {\cf do} expression except for the \hyper{init}s.

\vest A \hyper{step} may be omitted, in which case the effect is the
same as if {\cf(\hyper{variable} \hyper{init} \hyper{variable})} had
been written instead of {\cf(\hyper{variable} \hyper{init})}.

If a {\cf do} expression appears in a tail context, the
\hyper{expression}s are a \hyper{tail sequence} in the sense of report
section~\extref{report:basetailcontextsection}{Tail calls and tail contexts},
i.e., the last \hyper{expression} is also in a tail context.

\begin{scheme}
(do ((vec (make-vector 5))
     (i 0 (+ i 1)))
    ((= i 5) vec)
  (vector-set! vec i i))          \ev  \#(0 1 2 3 4)

(let ((x '(1 3 5 7 9)))
  (do ((x x (cdr x))
       (sum 0 (+ sum (car x))))
      ((null? x) sum)))             \ev  25%
\end{scheme}

The following definition
of {\cf do} uses a trick to expand the variable clauses.

\begin{scheme}
(define-syntax \ide{do}
  (syntax-rules ()
    ((do ((var init step ...) ...)
         (test expr ...)
         command ...)
     (letrec
       ((loop
         (lambda (var ...)
           (if test
               (begin
                 \schfalse ; avoid empty begin
                 expr ...)
               (begin
                 command
                 ...
                 (loop (do "step" var step ...)
                       ...))))))
       (loop init ...)))
    ((do "step" x)
     x)
    ((do "step" x y)
     y)))%
\end{scheme}

%\end{entry}

\begin{entry}{%
\proto{case-lambda}{ \hyper{case-lambda clause} \dotsfoo}{\exprtype}}
    
\syntax
Each \hyper{case-lambda clause} must be of the form
%
\begin{scheme}
(\hyper{formals} \hyper{body})%
\end{scheme}

\hyper{Formals} must be as in a {\cf lambda} form
(report section~\extref{report:lambda}{Procedures}), and \hyper{body} is as described in
report section~\extref{report:bodiessection}{Bodies and sequences}.

\semantics A {\cf case-lambda} expression evaluates to a procedure.
This procedure, when applied, tries to match its arguments to the
\hyper{case-lambda clause}s in order.  The arguments match a clause if one of the
following conditions is fulfilled:
%
\begin{itemize}
\item \hyper{Formals} has the form {\tt (\hyper{variable} \dotsfoo)}
and the number of arguments is the same as the number of formal
parameters in \hyper{formals}.
\item \hyper{Formals} has the form\\ {\tt
(\hyperi{variable} \dotsfoo \hypern{variable} . \hyper{variable$_{n+1}$)}
}\\
and the number of arguments is at least $n$.
\item \hyper{Formals} has the form {\tt \hyper{variable}}.
\end{itemize}
%
For the first clause matched by the arguments, the variables of the
\hyper{formals} are bound to fresh locations containing the
argument values in the same arrangement as with {\cf lambda}.

The last expression of a \hyper{body} in a {\cf case-lambda
  expression} is in tail context.

If the arguments match none of the clauses, an exception with condition 
type {\cf\&assertion} is raised.

\begin{scheme}
(define foo
  (case-lambda 
   (() 'zero)
   ((x) (list 'one x))
   ((x y) (list 'two x y))
   ((a b c d . e) (list 'four a b c d e))
   (rest (list 'rest rest))))

(foo) \ev zero
(foo 1) \ev (one 1)
(foo 1 2) \ev (two 1 2)
(foo 1 2 3) \ev (rest (1 2 3))
(foo 1 2 3 4) \ev (four 1 2 3 4 ())
\end{scheme}

The {\cf case-lambda} keyword
can be defined in terms of {\cf lambda} by the following macros:
%
\begin{scheme}
(define-syntax \ide{case-lambda}
  (syntax-rules ()
    ((\_ (fmls b1 b2 ...))
     (lambda fmls b1 b2 ...))
    ((\_ (fmls b1 b2 ...) ...)
     (lambda args
       (let ((n (length args)))
         (case-lambda-help args n
           (fmls b1 b2 ...) ...))))))

(define-syntax case-lambda-help
  (syntax-rules ()
    ((\_ args n)
     (assertion-violation \schfalse{}
       "unexpected number of arguments"))
    ((\_ args n ((x ...) b1 b2 ...) more ...)
     (if (= n (length '(x ...)))
         (apply (lambda (x ...) b1 b2 ...) args)
         (case-lambda-help args n more ...)))
    ((\_ args n ((x1 x2 ... . r) b1 b2 ...) more ...)
     (if (>= n (length '(x1 x2 ...)))
         (apply (lambda (x1 x2 ... . r) b1 b2 ...)
                   args)
         (case-lambda-help args n more ...)))
    ((\_ args n (r b1 b2 ...) more ...)
     (apply (lambda r b1 b2 ...) args))))
\end{scheme}
\end{entry}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   32: records.tex}
\chapter{Records}
% \label{recordschapter}
\mainindex{record}
This section describes abstractions for creating new data types
representing records.

A record is a compound data structure with a fixed number of
components, called \textit{fields}\mainindex{field}.  Each record has
an associated type specified by a \defining{record-type descriptor},
which is an object that specifies the fields of the record and various
other properties that all records of that type share.  Record objects
are created by a \defining{record constructor}, a procedure that
creates a fresh record object and initializes its fields to values.
Records of different types can be distinguished from each other and
from other types of objects by \textit{record predicates}. A record predicate
returns \schtrue{} when passed a record of the type specified by the
record-type descriptor and \schfalse{} otherwise.
An \defining{accessor} extracts from a record
the component associated with a field, and a \defining{mutator}
changes the component to a different value.

Record types can be extended via single inheritance, allowing record
types to model hierarchies that occur in applications like algebraic
data types as well as single-inheritance class systems.  If a record
type \var{t} extends another record type \var{p}, each record of type
\var{t} is also a record of type \var{p}, and the predicate,
accessors, and mutators applicable to a record of type \var{p} are
also applicable to a record of type \var{t}.  The extension
relationship is transitive in the sense that a type extends its
parent's parent, if any, and so on.  A record type that does not
extend another record type is called a \defining{base record type}.

A
record type can be \defining{sealed} to prevent it from being
extended.  Moreover, a record type can be \defining{nongenerative},
i.e., it is globally identified by a ``uid'', and new, compatible
definitions of a nongenerative record type with the same uid as a
previous always yield the same record type.

The record mechanism spans three libraries:

\begin{itemize}
\item the \rsixlibrary{records syntactic} library,
  a syntactic layer for defining a record type and
  associated constructor, predicate, accessor, and mutators,
\item the \rsixlibrary{records procedural} library,
  a procedural layer for creating and manipulating record types and creating
  constructors, predicates, accessors, and mutators;
\item the \rsixlibrary{records inspection} library,
  a set of inspection procedures.
\end{itemize}
% 
The inspection procedures allow programs to obtain from a record
instance a descriptor for the type and from there obtain access to the
fields of the record instance. This facility allows the creation of
portable printers and inspectors.  A program may prevent access to a
record's type---and thereby protect the information stored in the
record from the inspection mechanism---by declaring the type opaque.
Thus, opacity as presented here can be used to enforce abstraction
barriers.

Any of the standard types mentioned in this report may or may not be
implemented as an opaque record type.  Thus, it may be possible to use
inspection on objects of the standard types.

The procedural layer is particularly useful for writing interpreters
that construct host-compatible record types.  It may also serve as a
target for expansion of the syntactic layers.  The
record operations provided through the procedural layer may, however, be
less efficient than the operations provided through the
syntactic layer, which is designed to allow expand-time determination
of record-instance sizes and field offsets.  Therefore, alternative implementations
of syntactic record-type definition should, when possible, expand into
the syntactic layer rather than the procedural layer.

The syntactic layer is used more commonly and therefore described
first.  This chapter uses the \var{rtd} and
\var{constructor-descriptor} parameter names for arguments that must
be record-type descriptors and constructor descriptors, respectively
(see section~\ref{recordsproceduralsection}).


\section{Mutability and equivalence of records}
% \label{recordsequivalencesection}

The fields of a record type are designated \textit{mutable} or
\textit{immutable}.  Correspondingly, a record type with no mutable
field is called \textit{immutable}\mainindex{immutable record
  type}\mainindex{mutable record type}, and all records of that type
are immutable objects.  All other record types are \textit{mutable},
and so are their records.

Each call to a record constructor returns a new record with a fresh
location (see report section~\extref{report:storagemodel}{Storage
  model}).  Consequently, for two records \vari{obj} and \varii{obj},
the return value of {\cf (eqv? \vari{obj} \varii{obj})}, as well as the
return value of {\cf (eq? \vari{obj} \varii{obj})}, adheres to
the following criteria (see report
section~\extref{report:eqv?}{Equivalence predicates}):

\begin{itemize}
\item If \vari{obj} and \varii{obj} have different record types (i.e.,
  their record-type descriptors are not {\cf eqv?}), {\cf eqv?}
  returns \schfalse.
\item If \vari{obj} and \varii{obj} are both records of the
  same record type, and are the results of two separate calls to
  record constructors, then {\cf eqv?} returns \schfalse.
\item If \vari{obj} and \varii{obj} are both the result of a single call to a
  record constructor, then {\cf eqv?} returns \schtrue.
\item If \vari{obj} and \varii{obj} are both records of the same
  record type, where applying an accessor to both yields results
  for which {\cf eqv?} returns \schfalse, then {\cf eqv?} returns \schfalse.
\end{itemize}


\section{Syntactic layer}
% \label{recordssyntacticsection}

The syntactic layer is provided by the \defrsixlibrary{records
  syntactic} library.  Some details of the specification are
explained in terms of the specification of the procedural layer below.

The record-type-defining form {\cf define-record-type} is a definition and
can appear anywhere any other \hyper{definition} can appear.

\begin{entry}{%
\proto{define-record-type}{ \hyper{name spec} \arbno{\hyper{record clause}}}{\exprtype}
\litproto{fields}
\litproto{mutable}
\litproto{immutable}
\litproto{parent}
\litproto{protocol}
\litproto{sealed}
\litproto{opaque}
\litproto{nongenerative}
\litproto{parent-rtd}}

A {\cf define-record-type} form defines a record type along with
associated constructor descriptor and constructor, predicate, field
accessors, and field mutators. The {\cf define-record-type} form expands into
a set of definitions in the environment where {\cf define-record-type}
appears; hence, it is possible to refer to the bindings (except for
that of the record type itself) recursively.

The \hyper{name spec} specifies the names of the record type,
constructor, and predicate. It must take one of the following
forms:

\begin{scheme}
(\hyper{record name} \hyper{constructor name} \hyper{predicate name})
\hyper{record name}%
\end{scheme}

\hyper{Record name}, \hyper{constructor name}, and \hyper{predicate
  name} must all be identifiers.

\hyper{Record name}, taken as a symbol, becomes the name of the record
type. (See the description of {\cf make-record-type-descriptor}
below.)
Additionally, it is bound by this definition to an expand-time or run-time
representation of the record type and can be used as parent name in
syntactic record-type definitions that extend this definition. It can
also be used as a handle to gain access to the underlying record-type
descriptor and constructor descriptor (see {\cf
  record-type-descriptor} and {\cf record-constructor-descriptor}
below).

\hyper{Constructor name} is defined by this definition to be a
constructor for the defined record type, with a protocol specified by
the {\cf protocol} clause, or, in its absence, using a default protocol. For
details, see the description of the {\cf protocol} clause below.

\hyper{Predicate name} is defined by this definition to a predicate
for the defined record type.

The second form of \hyper{name spec} is an abbreviation for the first
form, where the name of the constructor is generated by prefixing the
record name with {\tt make-}, and the predicate name is generated by
adding a question mark ({\tt ?}) to the end of the record name. For
example, if the record name is {\tt frob}, the name of the
constructor is {\tt make-frob}, and the predicate name is
{\tt frob?}.

Each \hyper{record clause} must take one of the following forms; it is
a syntax violation if multiple \hyper{record clause}s of the same kind appear in a
{\cf define-record-type} form.

{\cf (fields \arbno{\hyper{field spec}})}

Each \hyper{field spec} has one of the following forms
  
\begin{scheme}
(immutable \hyper{field name} \hyper{accessor name})
(mutable \hyper{field name}
         \hyper{accessor name} \hyper{mutator name})
(immutable \hyper{field name})
(mutable \hyper{field name})
\hyper{field name}%
\end{scheme}

\hyper{Field name}, \hyper{accessor name}, and \hyper{mutator name}
must all be identifiers. The first form declares an immutable field
called \hyper{field name}, with the corresponding accessor named
\hyper{accessor name}. The second form declares a mutable field called
\hyper{field name}, with the corresponding accessor named
\hyper{accessor name}, and with the corresponding mutator named
\hyper{mutator name}.

If \hyper{field spec} takes the third or fourth form, the accessor
name is generated by appending the record name and field name with a
hyphen separator, and the mutator name (for a mutable field) is
generated by adding a {\tt -set!} suffix to the accessor name. For
example, if the record name is {\tt frob} and the field name is {\tt
  widget}, the accessor name is {\tt frob-widget} and the mutator name
is {\tt frob-widget-set!}.

If \hyper{field spec} is just a \hyper{field name} form, it is an
abbreviation for {\cf (immutable \hyper{field name})}.

The \hyper{field name}s become, as symbols, the names of the fields in
the record-type descriptor being created, in the same order.

The {\cf fields} clause may be absent; this is equivalent to an empty
{\cf fields} clause.

{\cf (parent \hyper{parent name})}
   
Specifies that the record type is to have parent type \hyper{parent
  name}, where \hyper{parent name} is the \hyper{record name} of a
record type previously defined using {\cf define-record-type}. 
The record-type definition
associated with \hyper{parent name} must not be sealed.
If
no {\cf parent} clause and no {\cf parent-rtd} (see below) clause
is present, the record type is a base type.  

{\cf (protocol \hyper{expression})}
   
\hyper{Expression} is evaluated in the same environment as the
{\cf define-record-type} form, and must evaluate to a protocol appropriate
for the record type being defined.

The protocol is used to create a record-constructor descriptor as
described below.  If no {\cf protocol} clause is specified, a
constructor descriptor is still created using a default protocol.  The
clause can be absent only if the record type being defined has no parent
type, or if the parent definition does not specify a protocol.

{\cf (sealed \schtrue)}\\
{\cf (sealed \schfalse)}
   
If this option is specified with operand \schtrue, the defined record
type is sealed, i.e., no extensions of the record type can be created.
If this option is specified with operand \schfalse, or is absent, the
defined record type is not sealed.

{\cf (opaque \schtrue)}\\
{\cf (opaque \schfalse)}
   
If this option is specified with operand \schtrue, or if an opaque
parent record type is specified, the defined record type is opaque.
Otherwise, the defined record type is not opaque.  See the
specification of {\cf record-rtd} below for details.
   
{\cf (nongenerative \hyper{uid})}\\
{\cf (nongenerative)}
   
This specifies that the record type is nongenerative with uid
\hyper{uid}, which must be an \hyper{identifier}.
If \hyper{uid} is absent, a unique uid is generated at macro-expansion time.
If two record-type definitions specify the same \var{uid}, then
the record-type definitions should be equivalent, i.e.,
the implied arguments to {\cf make-record-type-descriptor}
must be equivalent as described under {\cf
  make-record-type-descriptor}.  See section~\ref{make-record-type-descriptor}.
If this condition is not met, it is either considered a syntax violation or
an exception with condition type {\cf\&assertion} is raised.
If the condition is met, a single record type is generated for both
definitions.

In the absence of a {\cf nongenerative} clause, a new record type is
generated every time a {\cf define-record-type} form is evaluated:

\begin{scheme}
(let ((f (lambda (x)
           (define-record-type r \ldots)
           (if x r? (make-r \ldots)))))
  ((f \schtrue) (f \schfalse))) \ev \schfalse{}
\end{scheme}

{\cf (parent-rtd \hyper{parent rtd} \hyper{parent cd})}

Specifies that the record type is to have its parent type specified by
\hyper{parent rtd}, which should be an expression evaluating to a
record-type descriptor, and \hyper{parent cd}, which should be an
expression evaluating to a constructor descriptor (see below).  The
record-type definition associated with the value of \hyper{parent rtd}
must not be sealed.  Moreover, a record-type definition must not have
both a {\cf parent} and a {\cf parent-rtd} clause.

\begin{note}
  The syntactic layer is designed to allow record-instance sizes and field
  offsets to be determined at expand time, i.e., by a macro definition of
  {\cf define-record-type}, as long as the parent (if any) is known.
  Implementations that take advantage of this may generate less
  efficient constructor, accessor, and mutator code when the
  {\cf parent-rtd} clause is used, since the type of the parent is
  generally not known until run time.
  The {\cf parent} clause should therefore be used instead when possible.
\end{note}

All bindings created by {\cf define-record-type} (for the record type,
the constructor, the predicate, the accessors, and the
mutators) must have names that are pairwise distinct.

The constructor created by a {\cf define-record-type} form is a
procedure as follows:
%
\begin{itemize}
\item If there is no {\cf parent} clause and no {\cf protocol} clause,
  the constructor accepts as many arguments as there are fields, in
  the same order as they appear in the {\cf fields} clause, and
  returns a record object with the fields initialized to the
  corresponding arguments.
\item If there is no {\cf parent} or {\cf parent-rtd} clause and a
  {\cf protocol} clause,
  the protocol expression must evaluate to a procedure that accepts a
  single argument.  The protocol procedure is called once during the
  evaluation of the {\cf define-record-type} form with a
  procedure \var{p} as its argument.  It should return a procedure,
  which will become the constructor bound to \hyper{constructor name}.
  The procedure \var{p} accepts as many arguments as there are fields,
  in the same order as they appear in the {\cf fields} clause, and
  returns a record object with the fields initialized to the
  corresponding arguments.

  The constructor returned by the protocol procedure can accept an
  arbitrary number of arguments, and should call \var{p} once to
  construct a record object, and return that record object.

  For example, the following protocol expression for a record-type
  definition with three fields creates a constructor that accepts 
  values for all fields, and initialized them in the reverse order of
  the arguments:
%
\begin{scheme} 
(lambda (p)
  (lambda (v1 v2 v3)
    (p v3 v2 v1)))%
 \end{scheme}

\item If there is both a {\cf parent} clause and a {\cf protocol}
  clause, then the protocol procedure is called once with a procedure
  \var{n} as its argument.  As in the previous case, the protocol
  procedure should return a procedure, which will become the
  constructor bound to \hyper{constructor name}.  However, \var{n} is
  different from \var{p} in the previous case: It accepts arguments
  corresponding to the arguments of the constructor of the parent
  type.  It then returns a procedure \var{p} that accepts as many
  arguments as there are (additional) fields in this type, in the same order as in
  the {\cf fields} clause, and returns a record object with the fields
  of the parent record types initialized according to their
  constructors and the arguments to \var{n}, and the fields of
  this record type initialized to its arguments of \var{p}.

  The constructor returned by the protocol procedure can accept an
  arbitrary number of arguments, and should call \var{n} once to
  construct the procedure \var{p}, and call \var{p} once to create the
  record object, and finally return that record object.

  For example, the following protocol expression assumes that the
  constructor of the parent type takes three arguments:
\begin{scheme}
(lambda (n)
  (lambda (v1 v2 v3 x1 x2 x3 x4)
    (let ((p (n v1 v2 v3)))
      (p x1 x2 x3 x4))))%
\end{scheme}
The resulting constructor accepts seven arguments, and initializes
the fields of the parent types according to the constructor of the
parent type, with {\cf v1}, {\cf v2}, and {\cf v3} as arguments.  It
also initializes the fields of this record type to the values of {\cf
  x1}, \ldots, {\cf x4}.

\item If there is a {\cf parent} clause, but no {\cf protocol} clause,
  then the parent type must not have a
  {\cf protocol} clause itself.  The constructor bound to
  \hyper{constructor name} is a procedure that accepts arguments corresponding to the 
  parent types' constructor first, and then one argument for each field in the same
  order as in the {\cf fields} clause. The constructor
  returns a record object with the fields initialized to the corresponding
  arguments.
\item If there is a {\cf parent-rtd} clause, then the constructor is
  as with a {\cf parent} clause, except that the constructor of the
  parent type is determined by the constructor descriptor of the {\cf
    parent-rtd} clause.
\end{itemize}

A protocol may perform other actions consistent with the requirements
described above, including mutation of the new record or other side
effects, before returning the record.
\end{entry}

Any definition that takes advantage of implicit naming for the
constructor, predicate, accessor, and mutator names can be rewritten
trivially to a definition that specifies all names explicitly. For
example, the implicit-naming record definition:

\begin{scheme}
(define-record-type frob
  (fields (mutable widget))
  (protocol
    (lambda (p)
      (lambda (n) (p (make-widget n))))))%
\end{scheme}

is equivalent to the following explicit-naming record definition.

\begin{scheme}
(define-record-type (frob make-frob frob?)
  (fields (mutable widget
                   frob-widget
                   frob-widget-set!))
  (protocol
    (lambda (p)
      (lambda (n) (p (make-widget n))))))%
\end{scheme}

Also, the implicit-naming record definition:
 
\begin{scheme}
(define-record-type point (fields x y))%
\end{scheme}

is equivalent to the following explicit-naming record
definition:

\begin{scheme}
(define-record-type (point make-point point?)
  (fields 
    (immutable x point-x)
    (immutable y point-y)))%
\end{scheme}

With implicit naming, it is still possible to specify some of
the names explicitly; for example, the following overrides the choice
of accessor and mutator names for the widget field.

\begin{scheme}
(define-record-type frob
  (fields (mutable widget getwid setwid!))
  (protocol
    (lambda (p)
      (lambda (n) (p (make-widget n))))))%
\end{scheme}

\begin{entry}{%
\proto{record-type-descriptor}{ \hyper{record name}}{\exprtype}}
   
Evaluates to the record-type descriptor (see below) associated with the type
specified by \hyper{record name}.

\begin{note}   
The {\cf record-type-descriptor} procedure works on both opaque and non-opaque record
types.
\end{note}
\end{entry}

\begin{entry}{%
\proto{record-constructor-descriptor}{ \hyper{record name}}{\exprtype}}
   
Evaluates to the record-constructor descriptor (see below) associated with
\hyper{record name}.
\end{entry}

The following example uses the {\cf record?} procedure from the 
\rsixlibrary{records inspection} library (section
\ref{recordinspectionsection}):

\begin{scheme}
(define-record-type (point make-point point?)
  (fields (immutable x point-x)
          (mutable y point-y set-point-y!))
  (nongenerative
    point-4893d957-e00b-11d9-817f-00111175eb9e))

(define-record-type (cpoint make-cpoint cpoint?)
  (parent point)
  (protocol
   (lambda (n)
     (lambda (x y c) 
       ((n x y) (color->rgb c)))))
  (fields
    (mutable rgb cpoint-rgb cpoint-rgb-set!)))

(define (color->rgb c)
  (cons 'rgb c))

(define p1 (make-point 1 2))
(define p2 (make-cpoint 3 4 'red))

(point? p1) \ev \schtrue{}
(point? p2) \ev \schtrue{}
(point? (vector)) \ev \schfalse{}
(point? (cons 'a 'b)) \ev \schfalse{}
(cpoint? p1) \ev \schfalse{}
(cpoint? p2) \ev \schtrue{}
(point-x p1) \ev 1
(point-y p1) \ev 2
(point-x p2) \ev 3
(point-y p2) \ev 4
(cpoint-rgb p2) \ev (rgb . red)

(set-point-y! p1 17) \ev \unspecified
(point-y p1) \ev 17)

(record-rtd p1) \lev (record-type-descriptor point)

(define-record-type (ex1 make-ex1 ex1?)
  (protocol (lambda (p) (lambda a (p a))))
  (fields (immutable f ex1-f)))

(define ex1-i1 (make-ex1 1 2 3))
(ex1-f ex1-i1) \ev (1 2 3)

(define-record-type (ex2 make-ex2 ex2?)
  (protocol
    (lambda (p) (lambda (a . b) (p a b))))
  (fields (immutable a ex2-a)
          (immutable b ex2-b)))

(define ex2-i1 (make-ex2 1 2 3))
(ex2-a ex2-i1) \ev 1
(ex2-b ex2-i1) \ev (2 3)

(define-record-type (unit-vector
                     make-unit-vector
                     unit-vector?)
  (protocol
   (lambda (p)
     (lambda (x y z)
       (let ((length 
               (sqrt (+ (* x x)
                        (* y y)
                        (* z z)))))
         (p (/ x length)
            (/ y length)
            (/ z length))))))
  (fields (immutable x unit-vector-x)
          (immutable y unit-vector-y)
          (immutable z unit-vector-z)))

(define *ex3-instance* \schfalse{})

(define-record-type ex3
  (parent cpoint)
  (protocol
   (lambda (n)
     (lambda (x y t)
       (let ((r ((n x y 'red) t)))
         (set! *ex3-instance* r)
         r))))
  (fields 
   (mutable thickness))
  (sealed \schtrue{}) (opaque \schtrue{}))

(define ex3-i1 (make-ex3 1 2 17))
(ex3? ex3-i1) \ev \schtrue{}
(cpoint-rgb ex3-i1) \ev (rgb . red)
(ex3-thickness ex3-i1) \ev 17
(ex3-thickness-set! ex3-i1 18) \lev \unspecified
(ex3-thickness ex3-i1) \ev 18
{}*ex3-instance* \ev ex3-i1

(record? ex3-i1) \ev \schfalse{}%
\end{scheme}


\section{Procedural layer}
% \label{recordsproceduralsection}

The procedural layer is provided by the \defrsixlibrary{records
  procedural} library.

\begin{entry}{%
\pproto{(make-record-type-descriptor \var{name}}{procedure}}
\mainschindex{make-record-type-descriptor}{\tt\obeyspaces\\
        \var{parent} \var{uid} \var{sealed?} \var{opaque?} \var{fields})}
   
Returns a \defining{record-type descriptor}, or \defining{rtd},
representing a record type distinct from all built-in types and
other record types.

The \var{name} argument must be a symbol. It names the record type,
and is intended purely for informational purposes and may be used for printing by
the underlying Scheme system.

The \var{parent} argument must be either \schfalse{} or an rtd. If it is an
rtd, the returned record type, \var{t}, extends the record type
\var{p} represented by \var{parent}.  An exception with
condition type {\cf\&assertion} is raised if \var{parent} is sealed (see below).
   
The \var{uid} argument must be either \schfalse{} or a symbol.
If \var{uid} is a symbol, the record-creation operation is
\emph{nongenerative} i.e., a new record type is created only
if no previous call to {\cf make-record-type-descriptor}
was made with the \var{uid}.
If \var{uid} is \schfalse{}, the record-creation operation is
\emph{generative}, i.e., a new record type is created even if
a previous call to {\cf make-record-type-descriptor} was
made with the same arguments.

If {\cf make-record-type-descriptor} is
called twice with the same \var{uid} symbol, the parent
arguments in the two calls must be {\cf eqv?}, the \var{fields}
arguments {\cf equal?}, the \var{sealed?} arguments boolean-equivalent
(both \schfalse{} or both true), and the \var{opaque?} arguments
boolean-equivalent.
If these conditions are not met, an exception with condition type
{\cf\&assertion} is raised when the second call occurs.
If they are met, the second call returns, without creating a new
record type, the same record-type descriptor
(in the sense of {\cf eqv?}) as the first call.

\begin{note}   
  Users are encouraged to use symbol names
  constructed using the UUID namespace~\cite{RFC4122} (for example, using the
  record-type name as a prefix) for the uid argument.
\end{note}

The \var{sealed?} flag must be a boolean. If true, the returned record type
is sealed, i.e., it cannot be extended.

The \var{opaque?} flag must be a boolean. If true, the record type
is opaque.
If passed an instance of the record type,
{\cf record?} returns
\schfalse{}.  Moreover, if {\cf record-rtd} (see ``Inspection'' below)
is called with an instance of the record type, 
an exception with condition type {\cf\&assertion} is raised.
The record type is also opaque if an opaque parent is
supplied.  If \var{opaque?} is \schfalse{} and an opaque parent is not
supplied, the record is not opaque.

The \var{fields} argument must be a vector of field specifiers. Each
field specifier must be a list of the form {\cf (mutable \var{name})}
or a list of the form {\cf (immutable \var{name})}.
Each name must be a symbol and names the corresponding field of the record
type; the names need not be distinct.  A field identified as mutable may
be modified, whereas, when a program attempts to obtain a mutator for a field identified
as immutable, an exception with condition type {\cf\&assertion} is raised.
Where field order is relevant, e.g., for record construction and field
access, the fields are considered to be ordered as specified, although
no particular order is required for the actual representation of a
record instance.

The specified fields are added to the parent fields, if any, to determine
the complete set of fields of the returned record type.
If \var{fields} is modified after {\cf make-record-type-descriptor}
has been called, the effect on the returned
rtd is unspecified.

A generative record-type descriptor created by a call to {\cf
  make-record-type-descriptor} is not {\cf eqv?} to any record-type
descriptor (generative or nongenerative) created by another call to
{\cf make-record-type-descriptor}. A generative record-type descriptor
is {\cf eqv?}  only to itself, i.e., {\cf (eqv? \vari{rtd} \varii{rtd})} iff
{\cf (eq? \vari{rtd} \varii{rtd})}.
Also, two nongenerative record-type descriptors are {\cf eqv?} iff they were
created by calls to {\cf make-record-type-descriptor} with the same
uid arguments.
\end{entry}

\begin{entry}{%
\proto{record-type-descriptor?}{ obj}{procedure}}
   
Returns \schtrue{} if the argument is a record-type descriptor,
\schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\pproto{(make-record-constructor-descriptor \var{rtd}}{procedure}}
\mainschindex{make-record-constructor-descriptor}{\tt\obeyspaces\\
        \var{parent-constructor-descriptor} \var{protocol})}

Returns a \defining{record-constructor descriptor} (or
\defining{constructor descriptor} for short) that specifies a \defining{record
constructor} (or \textit{constructor} for short),
that can be used to construct record values of the type
specified by \var{rtd}, and which can be obtained
via {\cf record-constructor}.   A constructor descriptor can
also be used to create other constructor descriptors for subtypes of
its own record type.  \var{Rtd} must be a record-type
descriptor.  \var{Protocol}\mainindex{protocol} must be a procedure or \schfalse.
If it is \schfalse, a default \var{protocol} procedure is supplied.

If \var{protocol} is a procedure, it is handled analogously to the
protocol expression in a {\cf define-record-type} form.

If \var{rtd} is a base record type and \var{protocol} is a procedure,
\var{parent-constructor-descriptor} must be \schfalse.  In this case,
\var{protocol} is called by {\cf record-constructor} with a single
argument \var{p}.  \var{P} is a procedure that expects one argument
for every field of \var{rtd} and returns a record with the fields of
\var{rtd} initialized to these arguments.  The procedure returned by
\var{protocol} should call \var{p} once with the number of arguments
\var{p} expects and return the resulting record as shown in the simple
example below:
%
\begin{scheme}
(lambda (p)
  (lambda (v1 v2 v3)
    (p v1 v2 v3)))%
\end{scheme}
%
Here, the call to {\cf p} returns a record whose fields are
initialized with the values of {\cf v1}, {\cf v2}, and {\cf v3}.  The
expression above is equivalent to {\cf (lambda (p) p)}.  Note that the
procedure returned by \var{protocol} is otherwise unconstrained;
specifically, it can take any number of arguments.

\medskip

If \var{rtd} is an extension of another record type \var{parent-rtd}
and \var{protocol} is a procedure, \var{parent-constructor-descriptor}
must be a constructor descriptor of \var{parent-rtd} or \schfalse.  If
\var{parent-constructor-descriptor} is a constructor descriptor,
\var{protocol} it is called by {\cf record-constructor} with a single
argument \var{n}, which is a procedure that accepts the same number of
arguments as the constructor of \var{parent-constructor-descriptor}
and returns a procedure \var{p} that, when called, constructs the
record itself. The \var{p} procedure expects one argument for every
field of \var{rtd} (not including parent fields) and returns a record
with the fields of \var{rtd} initialized to these arguments, and the
fields of \var{parent-rtd} and its parents initialized as specified by
\var{parent-constructor-descriptor}.

The procedure returned by \var{protocol} should call \var{n} once with
the number of arguments \var{n} expects, call the procedure \var{p} it
returns once with the number of arguments \var{p} expects and return the
resulting record.  A simple \var{protocol} in this case might be
written as follows:
%
\begin{scheme}
(lambda (n)
  (lambda (v1 v2 v3 x1 x2 x3 x4)
    (let ((p (n v1 v2 v3)))
      (p x1 x2 x3 x4))))%
\end{scheme}
%
This passes arguments {\cf v1}, {\cf v2}, {\cf v3} to \var{n} for 
\var{parent-constructor-descriptor} and calls {\cf p}
with {\cf x1}, \ldots, {\cf x4} to initialize the fields of \var{rtd} itself.

Thus, the constructor descriptors for a record type form a sequence of
protocols parallel to the sequence of record-type parents. Each
constructor descriptor in the chain determines the field values for the
associated record type.
Child record constructors need not know the number or contents of parent
fields, only the number of arguments accepted by the parent constructor.

\var{Protocol} may be \schfalse, specifying a default constructor that
accepts one argument for each field of \var{rtd} (including the
fields of its parent type, if any).  Specifically, if \var{rtd} is a
base type, the default \var{protocol} procedure behaves as if it were
{\cf (lambda (p) p)}.  If \var{rtd} is an extension of another type,
then \var{parent-constructor-descriptor} must be either \schfalse{} or
itself specify a default constructor, and the default
\var{protocol} procedure behaves as if it were:
%
\begin{scheme}
(lambda (n)
  (lambda (\vari{v} \ldots \varj{v} \vari{x} \ldots \vark{x})
    (let ((p (n \vari{v} \ldots \varj{v})))
      (p \vari{x} \ldots \vark{x}))))%
\end{scheme}
%
The resulting constructor accepts one argument for each of the record
type's complete set of fields (including those of the parent record
type, the parent's parent record type, etc.) and returns a record with
the fields initialized to those arguments, with the field values for
the parent coming before those of the extension in the argument list.
(In the example, $j$ is the complete number of fields of the parent
type, and $k$ is the number of fields of \var{rtd} itself.)

If \var{rtd} is an extension of another record type, and
\var{parent-constructor-descriptor} or the \var{protocol} of
\var{parent-constructor-descriptor} is \schfalse, \var{protocol} must
also be \schfalse, and a default constructor descriptor as
described above is also assumed.

\implresp If \var{protocol} is a procedure, the implementation must
check the restrictions on it to the extent performed by applying it as
described when the constructor is called.
An
implementation may check whether \var{protocol} is an appropriate argument
before applying it.

\begin{scheme}
(define rtd1
  (make-record-type-descriptor
   'rtd1 \schfalse{} \schfalse{} \schfalse{} \schfalse{}
   '\sharpsign((immutable x1) (immutable x2))))

(define rtd2
  (make-record-type-descriptor
   'rtd2 rtd1 \schfalse{} \schfalse{} \schfalse{}
   '\sharpsign((immutable x3) (immutable x4))))

(define rtd3
  (make-record-type-descriptor
   'rtd3 rtd2 \schfalse{} \schfalse{} \schfalse{}
   '\sharpsign((immutable x5) (immutable x6))))

(define protocol1
  (lambda (p)
    (lambda (a b c)
      (p (+ a b) (+ b c)))))

(define protocol2
  (lambda (n)
    (lambda (a b c d e f)
      (let ((p (n a b c)))
        (p (+ d e) (+ e f))))))

(define protocol3
  (lambda (n)
    (lambda (a b c d e f g h i)
      (let ((p (n a b c d e f)))
        (p (+ g h) (+ h i))))))

(define cd1
  (make-record-constructor-descriptor
    rtd1 \schfalse{} protocol1))

(define cd2
  (make-record-constructor-descriptor
    rtd2 cd1 protocol2))

(define cd3
  (make-record-constructor-descriptor
    rtd3 cd2 protocol3))

(define make-rtd1 (record-constructor cd1))

(define make-rtd2 (record-constructor cd2))

(define make-rtd3 (record-constructor cd3))

(make-rtd3 1 2 3 4 5 6 7 8 9)\lev
  \(\langle\)\textrm{record with fields initialized to 3, 5, 9, 11, 15, 17}\(\rangle\)
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{record-constructor}{ constructor-descriptor}{procedure}}
   
Calls the \var{protocol} of \var{constructor-descriptor} (as described for
{\cf make-record-constructor-descriptor}) and returns the resulting
constructor \var{constructor} for records of the record type
associated with \var{constructor-descriptor}.
\end{entry}

\begin{entry}{%
\proto{record-predicate}{ rtd}{procedure}}
   
Returns a procedure that, given an object \var{obj}, returns
\schtrue{}
if \var{obj} is a record of the type represented by
\var{rtd}, and \schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{record-accessor}{ rtd k}{procedure}}

\domain{\var{K} must be a valid field index of \var{rtd}.}  The {\cf
  record-accessor} procedure returns a one-argument procedure whose
argument must be a record of the type represented by \var{rtd}.  This
procedure returns the value of the selected field of that record.

The field selected corresponds to the \var{k}th element
(0-based) of the \var{fields} argument to the invocation of {\cf
  make-record-type-descriptor} that created \var{rtd}. Note that
\var{k} cannot be used to specify a field of any type \var{rtd} extends.
\end{entry}

\begin{entry}{%
\proto{record-mutator}{ rtd k}{procedure}}
   
\domain{\var{K} must be a valid field index of \var{rtd}.}  The {\cf
  record-mutator} procedure returns a two-argument procedure whose
arguments must be a record record \var{r} of the type represented by
\var{rtd} and an object \var{obj}.  This procedure stores \var{obj}
within the field of \var{r} specified by \var{k}. The \var{k} argument
is as in {\cf record-accessor}. If \var{k} specifies an immutable
field, an exception with condition type {\cf\&assertion} is raised.
The mutator returns \unspecifiedreturn.
\end{entry}

\begin{scheme}
(define :point
  (make-record-type-descriptor
    'point \schfalse{}
    \schfalse{} \schfalse{} \schfalse{} 
    '\sharpsign((mutable x) (mutable y))))

(define :point-cd
  (make-record-constructor-descriptor :point \schfalse{} \schfalse{}))

(define make-point (record-constructor :point-cd))

(define point? (record-predicate :point))
(define point-x (record-accessor :point 0))
(define point-y (record-accessor :point 1))
(define point-x-set! (record-mutator :point 0))
(define point-y-set! (record-mutator :point 1))

(define p1 (make-point 1 2))
(point? p1) \ev \schtrue{}
(point-x p1) \ev 1
(point-y p1) \ev 2
(point-x-set! p1 5) \ev \theunspecified
(point-x p1) \ev 5

(define :point2
  (make-record-type-descriptor
    'point2 :point 
    \schfalse{} \schfalse{} \schfalse{} '\sharpsign((mutable x) (mutable y))))

(define make-point2
  (record-constructor
    (make-record-constructor-descriptor :point2
      \schfalse{} \schfalse{})))
(define point2? (record-predicate :point2))
(define point2-xx (record-accessor :point2 0))
(define point2-yy (record-accessor :point2 1))

(define p2 (make-point2 1 2 3 4))
(point? p2) \ev \schtrue{}
(point-x p2) \ev 1
(point-y p2) \ev 2
(point2-xx p2) \ev 3
(point2-yy p2) \ev 4

(define :point-cd/abs
  (make-record-constructor-descriptor
   :point \schfalse{}
   (lambda (new)
     (lambda (x y)
       (new (abs x) (abs y))))))

(define make-point/abs
  (record-constructor :point-cd/abs))

(point-x (make-point/abs -1 -2) \lev 1
(point-y (make-point/abs -1 -2) \lev 2

(define :cpoint
  (make-record-type-descriptor
   'cpoint :point
   \schfalse{} \schfalse{} \schfalse{}
   '\sharpsign((mutable rgb))))

(define make-cpoint
  (record-constructor
   (make-record-constructor-descriptor
    :cpoint :point-cd
    (lambda (p)
      (lambda (x y c)
  ((p x y) (color->rgb c)))))))

(define make-cpoint/abs
  (record-constructor
   (make-record-constructor-descriptor
    :cpoint :point-cd/abs
    (lambda (p)
      (lambda (x y c)
  ((p x y) (color->rgb c)))))))

(define cpoint-rgb
  (record-accessor :cpoint 0))

(define (color->rgb c)
  (cons 'rgb c))

(cpoint-rgb (make-cpoint -1 -3 'red) \lev (rgb . red)
(point-x (make-cpoint -1 -3 'red)) \lev -1
(point-x (make-cpoint/abs -1 -3 'red)) \lev 1%
\end{scheme}

\section{Inspection}
% \label{recordinspectionsection}

The \defrsixlibrary{records inspection} library
provides procedures for inspecting records and their
record-type descriptors. These procedures are designed to allow the
writing of portable printers and inspectors.

On the one hand, {\cf record?} and {\cf record-rtd} treat records of opaque
record types as if they were not records. On the other hand, the
inspection procedures that operate on record-type descriptors
themselves are not affected by opacity. In other words, opacity
controls whether a program can obtain an rtd from a record. If the
program has access to the original rtd via {\cf
  make-record-type-descriptor} or {\cf record-type-descriptor}, it can
still make use of the inspection procedures.

\begin{entry}{%
\proto{record?}{ obj}{procedure}}
   
Returns \schtrue{} if \var{obj} is a record, and its record type is
not opaque, and returns \schfalse{} otherwise.  
\end{entry}

\begin{entry}{%
\proto{record-rtd}{ record}{procedure}}
   
Returns the rtd representing the type of \var{record} if the type is not
opaque. The rtd of the most precise type is returned; that is, the
type \var{t} such that \var{record} is of type \var{t} but not of any
type that extends \var{t}.  If the type is opaque, an exception is
raised with condition type {\cf\&assertion}.
\end{entry}

\begin{entry}{%
\proto{record-type-name}{ rtd}{procedure}}
   
Returns the name of the record-type descriptor \var{rtd}.
\end{entry}   

\begin{entry}{%
\proto{record-type-parent}{ rtd}{procedure}}
   
Returns the parent of the record-type descriptor \var{rtd}, or
\schfalse{} if it has none.
\end{entry}

\begin{entry}{%
\proto{record-type-uid}{ rtd}{procedure}}
   
Returns the uid of the record-type descriptor rtd, or \schfalse{} if it has none.
(An implementation may assign a generated uid to a record type even if the
type is generative, so the return of a uid does not necessarily imply that
the type is nongenerative.)
\end{entry}

\begin{entry}{%
\proto{record-type-generative?}{ rtd}{procedure}}
   
Returns \schtrue{} if \var{rtd} is generative, and \schfalse{} if not.
\end{entry}

\begin{entry}{%
\proto{record-type-sealed?}{ rtd}{procedure}}

Returns \schtrue{} if the record-type descriptor is
sealed, and \schfalse{} if not.
\end{entry}

\begin{entry}{%
\proto{record-type-opaque?}{ rtd}{procedure}}
   
Returns \schtrue{} if the the record-type descriptor is
opaque, and \schfalse{} if not.
\end{entry}

\begin{entry}{%
\proto{record-type-field-names}{ rtd}{procedure}}
   
Returns a vector of symbols naming the fields of the type represented by \var{rtd}
(not including the fields of parent types) where the fields are ordered as
described under {\cf make-record-type-descriptor}.  The returned
vector may be immutable.
If the returned vector is modified, the effect on 
\var{rtd} is unspecified.
\end{entry}

\begin{entry}{%
\proto{record-field-mutable?}{ rtd k}{procedure}}
   
Returns \schtrue{} if the field specified by
\var{k} of the type represented by \var{rtd} is mutable, and
\schfalse{} if not.  \var{K} is as in {\cf record-accessor}.
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   33: exc.tex}
\chapter{Exceptions and conditions}
% \label{exceptionsconditionschapter}

Scheme allows programs to deal with exceptional situations using two
cooperating facilities: The exception system for raising and handling
exceptional situations, and the condition system for describing these
situations.

The exception system allows the program, when it detects an
exceptional situation, to pass control to an exception handler, and
to dynamically establish such exception handlers.  Exception
handlers are always invoked with an object describing the exceptional
situation.  Scheme's condition system provides a standardized taxonomy
of such descriptive objects, as well as a facility for extending the
taxonomy.

\section{Exceptions}
% \label{exceptionssection}
\mainindex{exceptions}

This section describes Scheme's exception-handling and
exception-raising constructs provided by the \defrsixlibrary{exceptions} library.

Exception handlers are one-argument procedures that determine the
action the program takes when an exceptional situation is signalled.
The system implicitly maintains a current exception handler.

\mainindex{current exception handler}The program raises an exception
by invoking the current exception handler, passing it an object
encapsulating information about the exception. Any procedure accepting
one argument may serve as an exception handler and any object may be
used to represent an exception.

The system maintains the current exception handler as part of the
dynamic environment of the program; see report
section~\extref{report:dynamicenvironmentsection}{Dynamic extent and
  dynamic environment}.

When a program begins its execution, the current
exception handler is expected to handle all {\cf\&serious}
conditions by interrupting execution, reporting that an
exception has been raised, and displaying information
about the condition object that was provided.  The handler
may then exit, or may provide a choice of other options.
Moreover, the exception handler is expected to return when
passed any other non-{\cf\&serious} condition.
Interpretation of these expectations necessarily depends
upon the nature of the system in which programs are executed,
but the intent is that users perceive the raising of an
exception as a controlled escape from the situation that
raised the exception, not as a crash.

\begin{entry}{%
\proto{with-exception-handler}{ \var{handler} \var{thunk}}{procedure}}

\domain{\var{Handler} must be a procedure and should accept one argument.
\var{Thunk} must be a procedure that accepts zero arguments.}  The {\cf
with-exception-handler} procedure returns the results of invoking
\var{thunk}.  \var{Handler} is installed as the current
exception handler for the dynamic extent (as determined by {\cf
  dynamic-wind}) of the invocation of \var{thunk}.

\implresp The implementation must check the restrictions on
\var{handler} to the extent performed by applying it as described
when it is called as a result of a call to {\cf raise} or {\cf
  raise-continuable}.
An
implementation may check whether \var{handler} is an appropriate argument
before applying it.
\end{entry}

\begin{entry}{%
\pproto{(guard (\hyper{variable}}{\exprtype}
{\tt\obeyspaces%
\hspace*{3em}\hyperi{cond clause} \hyperii{cond clause} \dotsfoo)\\
\hspace*{2em}\hyper{body})}\\
\litprotonoindex{=>}
\litprotonoindex{else}}
\mainschindex{guard}\schindex{=>}\schindex{else}

\syntax
Each \hyper{cond clause} is as in the specification of {\cf cond}.
(See report section~\extref{report:cond}{Derived conditionals}.)
{\cf \=>} and {\cf else} are the same as in the \rsixlibrary{base} library.

\semantics 
Evaluating a {\cf guard} form evaluates \hyper{body} with an exception
handler that binds the raised object to \hyper{variable} and within the scope of
that binding evaluates the clauses as if they were the clauses of a
{\cf cond} expression. That implicit {\cf cond} expression is evaluated with the
continuation and dynamic environment of the {\cf guard} expression. If every
\hyper{cond clause}'s \hyper{test} evaluates to \schfalse{} and there
is no {\cf else} clause, then
{\cf raise} is re-invoked on the raised object within the dynamic
environment of the original call to {\cf raise} except that the current
exception handler is that of the {\cf guard} expression.  

The final expression in a \hyper{cond} clause is in a tail context if
the {\cf guard} expression itself is.
\end{entry}

\begin{entry}{%
\proto{raise}{ \var{obj}}{procedure}}

Raises a non-continuable exception by invoking the current exception
handler on \var{obj}. The handler is called with a continuation whose
dynamic environment is that of the call to {\cf raise}, except that
the current exception handler is the one that was in place when the handler being
called was installed.  When the handler returns, a non-continuable
exception with condition type {\cf \&non-continuable} is raised in the
same dynamic environment as the handler.
\end{entry}

\begin{entry}{%
\proto{raise-continuable}{ \var{obj}}{procedure}}

Raises a \defining{continuable exception} by invoking the current exception
handler on \var{obj}. The handler is called with a continuation that
is equivalent to the continuation of the call to {\cf
  raise-continuable}, with these two exceptions: (1) the current
exception handler is the one that was in place 
when the handler being called was installed, and
(2) if the handler being called returns, then it will again become the
current exception handler.  If the handler returns, the values it
returns become the values returned by the call to
{\cf raise-continuable}.
\end{entry}

\begin{scheme}
(guard (con
         ((error? con)
          (if (message-condition? con)
              (display (condition-message con))
              (display "an error has occurred"))
          'error)
         ((violation? con)
          (if (message-condition? con)
              (display (condition-message con))
              (display "the program has a bug"))
          'violation))
  (raise
    (condition
      (make-error)
      (make-message-condition "I am an error"))))
   {\it prints:} I am an error
   \ev error%

(guard (con
         ((error? con)
          (if (message-condition? con)
              (display (condition-message con))
              (display "an error has occurred"))
          'error))
  (raise
    (condition
      (make-violation
      (make-message-condition "I am an error"))))
  \ev \exception{\&violation}

(guard (con
         ((error? con)
          (display "error opening file")
          \schfalse))
  (call-with-input-file "foo.scm" read))
   {\it prints:} error opening file
   \ev \schfalse{}

(with-exception-handler
  (lambda (con)
    (cond
      ((not (warning? con))
       (raise con))
      ((message-condition? con)
       (display (condition-message con)))
      (else
       (display "a warning has been issued")))
    42)
  (lambda ()
    (+ (raise-continuable
         (condition
           (make-warning)
           (make-message-condition
             "should be a number")))
       23)))
   {\it prints:} should be a number
   \ev 65
\end{scheme}

\section{Conditions}
% \label{conditionssection}

The section describes Scheme's \defrsixlibrary{conditions} library 
for creating and inspecting
condition types and values. A condition value encapsulates information
about an exceptional situation\mainindex{exceptional situation}.
Scheme also defines a
number of basic condition types.

Scheme conditions provides two mechanisms to enable communication
about an exceptional situation: subtyping among condition types allows
handling code to determine the general nature of an exception even
though it does not anticipate its exact nature, and compound
conditions allow an exceptional situation to be described in multiple
ways.

\subsection{Condition objects}

Conceptually, there are two different kinds of condition objects:
\textit{simple conditions}\mainindex{simple condition} and
\textit{compound conditions}\mainindex{compound condition}.  An object
that is either a simple condition or a compound condition is 
simply a \defining{condition}.  Compound conditions form a type disjoint
from the base types described in report
section~\extref{report:disjointness}{Base types}.  A simple condition
describes a single aspect of an exceptional situation.  A compound
condition represents multiple aspects of an exceptional situation as a
list of simple conditions, its \textit{components}.  Most of the
operations described in this section treat a simple condition
identically to a compound condition with itself as its own sole component.  For a
subtype \var{t} of {\cf\&condition}, a \textit{condition of type
  \var{t}} is either a record of type \var{t} or a compound condition
containing a component of type \var{t}.

\begin{entry}{%
\ctproto{condition}}

Simple conditions are records of subtypes of the {\cf\&condition}
record type.  The {\cf\&condition} type has no fields and is neither sealed nor opaque.
\end{entry}

\begin{entry}{%
\proto{condition}{ \vari{condition} \dotsfoo}{procedure}}

The {\cf condition}
procedure returns a condition object with the components of the
\var{condition}s as its components, in the same order, i.e., with the
components of \vari{condition} appearing first in the same order as in
\vari{condition}, then with the components of \varii{condition}, and so on.  The
returned condition is compound if the total number of components is
zero or greater than one.  Otherwise, it may be compound or simple.
\end{entry}

\begin{entry}{%
\proto{simple-conditions}{ condition}{procedure}}

The {\cf simple-conditions}
procedure returns a list of the components of \var{condition}, in the same
order as they appeared in the construction of \var{condition}.  The
returned list is immutable.  If the returned list is modified, the
effect on \var{condition} is unspecified.

\begin{note}
  Because {\cf condition} decomposes its arguments into simple
  conditions, {\cf simple-conditions} always returns a ``flattened''
  list of simple conditions.
\end{note}
\end{entry}


\begin{entry}{%
\proto{condition?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a (simple or compound) condition,
otherwise returns \schfalse.
\end{entry}

\begin{entry}{%
\proto{condition-predicate}{ rtd}{procedure}}

\domain{\var{Rtd} must be a record-type descriptor of a subtype of
  {\cf\&condition}.}  The {\cf condition-predicate} procedure returns
a procedure that takes one argument.  This procedure returns
\schtrue{} if its argument is a condition of the condition type
represented by \var{rtd}, i.e., if it is either a simple condition of
that record type (or one of its subtypes) or a compound conditition
with such a simple condition as one of its components, and \schfalse{}
otherwise.
\end{entry}

\begin{entry}{%
\proto{condition-accessor}{ rtd proc}{procedure}}

\domain{\var{Rtd} must be a record-type descriptor of a subtype of
  {\cf\&condition}.  \var{Proc} should accept
  one argument, a record of the record type of \var{rtd}.}  The {\cf
  condition-accessor} procedure returns a procedure that accepts a
single argument, which must be a condition of the type represented by
\var{rtd}.  This procedure extracts the first component of the
condition of the type represented by \var{rtd}, and returns the result
of applying \var{proc} to that component.
\end{entry}

\begin{scheme}
(define-record-type (\&cond1 make-cond1 real-cond1?)
  (parent \&condition)
  (fields
   (immutable x real-cond1-x)))

(define cond1?
  (condition-predicate
    (record-type-descriptor \&cond1)))
(define cond1-x
  (condition-accessor
    (record-type-descriptor \&cond1)
    real-cond1-x))

(define foo (make-cond1 'foo))

(condition? foo) \ev \schtrue
(cond1? foo) \ev \schtrue
(cond1-x foo) \ev foo

(define-record-type (\&cond2 make-cond2 real-cond2?)
  (parent \&condition)
  (fields
   (immutable y real-cond2-y)))

(define cond2?
  (condition-predicate
    (record-type-descriptor \&cond2)))
(define cond2-y
  (condition-accessor
     (record-type-descriptor \&cond2)
     real-cond2-y))

(define bar (make-cond2 'bar))

(condition? (condition foo bar)) \lev \schtrue
(cond1? (condition foo bar)) \lev \schtrue
(cond2? (condition foo bar)) \lev \schtrue
(cond1? (condition foo)) \ev \schtrue
(real-cond1? (condition foo)) \lev \unspecified
(real-cond1? (condition foo bar)) \lev \schfalse
(cond1-x (condition foo bar) \lev foo
(cond2-y (condition foo bar) \lev bar
 
(equal? (simple-conditions (condition foo bar))
        (list foo bar)) \ev \schtrue

(equal? (simple-conditions
          (condition foo (condition bar)))
        (list foo bar)) \ev \schtrue%
\end{scheme}

\begin{entry}{%
\pproto{(define-condition-type \hyper{condition-type}}{\exprtype}}
{\tt\obeyspaces\\
    \hyper{supertype}\\
  \hyper{constructor} \hyper{predicate}\\
  \hyperi{field-spec} \dotsfoo)}
\mainschindex{define-condition-type}

\syntax \hyper{Condition-type}, \hyper{supertypes},
\hyper{constructor}, and \hyper{predicate} must all be identifiers.
Each \hyper{field-spec} must be of the form
%
\begin{scheme}
(\hyper{field} \hyper{accessor})%
\end{scheme}
%
where both \hyper{field} and \hyper{accessor} must be identifiers.

\semantics
The {\cf define-condition-type} form expands into a record-type
definition for a record type \hyper{condition-type} (see
section~\ref{recordssyntacticsection}).  The record type will be
non-opaque, non-sealed, and its fields will be immutable.
It will have \hyper{supertype} has its parent type.  The remaining
identifiers will be bound as follows:
% 

\begin{itemize}

\item \hyper{Constructor} is bound to a default constructor for the
  type (see section~\ref{recordsproceduralsection}): It accepts one
  argument for each of the record type's complete set of fields
  (including parent types, with the fields of the parent coming before
  those of the extension in the arguments) and returns a condition
  object initialized to those arguments.

\item \hyper{Predicate} is bound to a predicate that identifies
  conditions of type \hyper{condition-type} or any of its
  subtypes.

\item Each \hyper{accessor} is bound to a procedure that extracts the
  corresponding field from a condition of type \hyper{condition-type}.
\end{itemize}
\end{entry}

\begin{scheme}
(define-condition-type \&c \&condition
  make-c c?
  (x c-x))

(define-condition-type \&c1 \&c
  make-c1 c1?
  (a c1-a))

(define-condition-type \&c2 \&c
  make-c2 c2?
  (b c2-b))%
\end{scheme}

\begin{scheme}
(define v1 (make-c1 "V1" "a1"))

(c? v1)        \ev \schtrue
(c1? v1)       \ev \schtrue
(c2? v1)       \ev \schfalse
(c-x v1)       \ev "V1"
(c1-a v1)      \ev "a1"%
\end{scheme}

\begin{scheme}
(define v2 (make-c2 "V2" "b2"))

(c? v2)        \ev \schtrue
(c1? v2)       \ev \schfalse
(c2? v2)       \ev \schtrue
(c-x v2)       \ev "V2"
(c2-b v2)      \ev "b2"%
\end{scheme}

\begin{scheme}
(define v3 (condition
             (make-c1 "V3/1" "a3")
             (make-c2 "V3/2" "b3")))

(c? v3)        \ev \schtrue
(c1? v3)       \ev \schtrue
(c2? v3)       \ev \schtrue
(c-x v3)       \ev "V3/1"
(c1-a v3)      \ev "a3"
(c2-b v3)      \ev "b3"%
\end{scheme}

\begin{scheme}
(define v4 (condition v1 v2))

(c? v4)        \ev \schtrue
(c1? v4)       \ev \schtrue
(c2? v4)       \ev \schtrue
(c-x v4)       \ev "V1"
(c1-a v4)      \ev "a1"
(c2-b v4)      \ev "b2"%
\end{scheme}

\begin{scheme}
(define v5 (condition v2 v3))

(c? v5)        \ev \schtrue
(c1? v5)       \ev \schtrue
(c2? v5)       \ev \schtrue
(c-x v5)       \ev "V2"
(c1-a v5)      \ev "a3"
(c2-b v5)      \ev "b2"%
\end{scheme}

\section{Standard condition types}

\begin{figure*}[t]
  \centering
  {
\setlength{\unitlength}{1mm}
\begin{picture}(156,44)
    \put(47,42){\tt\&condition}
    \put(53,36){\line(0,1){5}}

    \put(6,36){\line(0,-1){5}}
    \put(6,36){\line(1,0){39}}
    \put(0,28){\tt\&warning}

    \put(115,31){\line(0,1){5}}
    \put(110,24){\parbox{2cm}{
        {\tt\&message}\\
        {\tt\&irritants}\\
        {\tt\&who}
      }}

    \put(45,36){\line(1,0){70}}
    \put(45,31){\line(0,1){5}}
    \put(40,28){\tt\&serious}
    \put(45,21){\line(0,1){5}}

    \put(5,21){\line(1,0){84}}

    \put(5,16){\line(0,1){5}}
    \put(0,13){\tt\&error}

    \put(89,16){\line(0,1){5}}
    \put(80,13){\tt\&violation}
    \put(89,7){\line(0,1){5}}

    \put(13,7){\line(1,0){133}}
    \put(13,3){\line(0,1){4}}
    \put(3,0){{\tt\&assertion}}
    \put(36,3){\line(0,1){4}}
    \put(23,0){{\tt\&non-continuable}}
    \put(77,3){\line(0,1){4}}
    \put(55,0){{\tt\&implementation-restriction}}
    \put(114,3){\line(0,1){4}}
    \put(107,0){{\tt\&lexical}}
    \put(130,3){\line(0,1){4}}
    \put(123,0){{\tt\&syntax}}
    \put(146,3){\line(0,1){4}}
    \put(138,0){{\tt\&undefined}}
\end{picture}
}
  \caption{Hierarchy of standard condition types}
  \label{fig:standard-condition-hierarchy}
\end{figure*}

\begin{entry}{%
\ctproto{message}
\proto{make-message-condition}{ message}{procedure}
\proto{message-condition?}{ obj}{procedure}
\proto{condition-message}{ condition}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&message \&condition
  make-message-condition message-condition?
  (message condition-message))%
\end{scheme}
%
It carries a message further describing the nature of the condition to
humans.  
\end{entry}

\begin{entry}{%
\ctproto{warning}
\proto{make-warning}{}{procedure}
\proto{warning?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&warning \&condition
  make-warning warning?)%
\end{scheme}
%
This type describes conditions that do not, in
principle, prohibit immediate continued execution of the program, but
may interfere with the program's execution later.
\end{entry}

\begin{entry}{%
\ctproto{serious}
\proto{make-serious-condition}{}{procedure}
\proto{serious-condition?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&serious \&condition
  make-serious-condition serious-condition?)%
\end{scheme}

This type describes conditions serious enough that they cannot safely
be ignored. This condition type is primarily intended as a supertype
of other condition types. 
\end{entry}

\begin{entry}{%
\ctproto{error}
\proto{make-error}{}{procedure}
\proto{error?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&error \&serious
  make-error error?)%
\end{scheme}
%
This type describes errors, typically caused by something that
has gone wrong in the interaction of the program with the external
world or the user.
\end{entry}

\begin{entry}{%
\ctproto{violation}
\proto{make-violation}{}{procedure}
\proto{violation?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&violation \&serious
  make-violation violation?)%
\end{scheme}
%
This type describes violations of the language standard or a
library standard, typically caused by a programming error.
\end{entry}  

\begin{entry}{%
\ctproto{assertion}
\proto{make-assertion-violation}{}{procedure}
\proto{assertion-violation?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&assertion \&violation
  make-assertion-violation assertion-violation?)%
\end{scheme}
% 
This type describes an invalid call to a procedure, either passing an
invalid number of arguments, or passing an argument of the wrong type.
\end{entry}

\begin{entry}{%
\ctproto{irritants}
\proto{make-irritants-condition}{ irritants}{procedure}
\proto{irritants-condition?}{ obj}{procedure}
\proto{condition-irritants}{ condition}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&irritants \&condition
  make-irritants-condition irritants-condition?
  (irritants condition-irritants))%
\end{scheme}
%
\domain{\var{Irritants} should be a list of objects.}  This
condition provides additional information about a condition, typically
the argument list of a procedure that detected an exception.
Conditions of this type are created by the {\cf error} and {\cf
  assertion-violation} procedures of report
section~\extref{report:errorviolation}{Errors and violations}.
\end{entry}
 
\begin{entry}{%
\ctproto{who}
\proto{make-who-condition}{ who}{procedure}
\proto{who-condition?}{ obj}{procedure}
\proto{condition-who}{ condition}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&who \&condition
  make-who-condition who-condition?
  (who condition-who))%
\end{scheme}
%
\var{Who} should be a symbol or string identifying the
entity reporting the exception.
Conditions of this type are created by the {\cf error} and {\cf
  assertion-violation} procedures (report
section~\extref{report:errorviolation}{Errors and violations}), and
the {\cf syntax-violation} procedure
(section~\extref{syntax-violation}{Syntax violations}).
\end{entry}

\begin{entry}{%
\ctproto{non-continuable}
\proto{make-non-continuable-violation}{}{procedure}
\proto{non-continuable-violation?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&non-continuable \&violation
  make-non-continuable-violation
  non-continuable-violation?)%
\end{scheme}
%
This type indicates that an exception handler invoked via
\texttt{raise} has returned.
\end{entry}

\begin{entry}{%
\ctproto{implementation-restriction}
\proto{make-implementation-restriction-violation}{}{procedure}
\proto{implementation-restriction-violation?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&implementation-restriction
    \&violation
  make-implementation-restriction-violation
  implementation-restriction-violation?)%
\end{scheme}
%
This type describes a violation of an implementation restriction
allowed by the specification, such as the absence of representations
for NaNs and infinities.  (See section~\ref{flonumssection}.)
\end{entry}

\begin{entry}{%
\ctproto{lexical}
\proto{make-lexical-violation}{}{procedure}
\proto{lexical-violation?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&lexical \&violation
  make-lexical-violation lexical-violation?)%
\end{scheme}
%
This type describes syntax violations at the level of the datum syntax.
\end{entry}

\begin{entry}{%
\ctproto{syntax}
\proto{make-syntax-violation}{ form subform}{procedure}
\proto{syntax-violation?}{ obj}{procedure}
\proto{syntax-violation-form}{ condition}{procedure}
\proto{syntax-violation-subform}{ condition}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&syntax \&violation
  make-syntax-violation syntax-violation?
  (form syntax-violation-form)
  (subform syntax-violation-subform))%
\end{scheme}

This type describes syntax violations.
\var{Form} should be the erroneous syntax object or a
datum representing the code of the erroneous form.  \var{Subform}
should be an optional syntax object or
datum within the erroneous form that more precisely locates the
violation.  It can be \schfalse{} to indicate the absence of more precise
information.
\end{entry}

\begin{entry}{%
\ctproto{undefined}
\proto{make-undefined-violation}{}{procedure}
\proto{undefined-violation?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&undefined \&violation
  make-undefined-violation undefined-violation?)%
\end{scheme}
% x
This type describes unbound identifiers in the program.
\end{entry}




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   34: io.tex}
\chapter{I/O}
% \label{iochapter}

This chapter describes Scheme's libraries for performing input and output:

\begin{itemize}
\item The \rsixlibrary{io ports} library
  (section~\ref{portsiosection}) is an I/O layer for conventional,
  imperative buffered input and output with text and binary
  data.
\item The \rsixlibrary{io simple} library
  (section~\ref{simpleiosection}) is a convenience library atop the
  \rsixlibrary{io ports} library for textual I/O, compatible with 
  the traditional Scheme I/O procedures~\cite{R5RS}.
\end{itemize}

Section~\ref{iocondsection} defines a condition-type hierarchy that
is exported by both the \rsixlibrary{io ports} and
\rsixlibrary{io simple} libraries.

\input{iocond}
\input{portio}
\input{convio}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   35: iocond.tex}
\section{Condition types}
% \label{iocondsection}

The procedures described in this chapter, when they detect an
exceptional situation that arises from an ``I/O errors'', raise an
exception with condition type {\cf\&i/o}.

The condition types and corresponding predicates and accessors are
exported by both the \rsixlibrary{io ports} and \rsixlibrary{io
  simple} libraries.  They are also exported by the \rsixlibrary{files}
library described in chapter~\ref{filesystemchapter}.

\begin{entry}{%
\ctproto{i/o}
\proto{make-i/o-error}{}{procedure}
\proto{i/o-error?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&i/o \&error
  make-i/o-error i/o-error?)%
\end{scheme}        

This is a supertype for a set of more specific I/O errors.
\end{entry}   

\begin{entry}{%
\ctproto{i/o-read}
\proto{make-i/o-read-error}{}{procedure}
\proto{i/o-read-error?}{ obj}{procedure}}

This condition type could be defined by
\begin{scheme}
(define-condition-type \&i/o-read \&i/o
  make-i/o-read-error i/o-read-error?)%
\end{scheme}

This condition type describes read errors that occurred during an I/O
operation.
\end{entry}   

\begin{entry}{%
\ctproto{i/o-write}
\proto{make-i/o-write-error}{}{procedure}
\proto{i/o-write-error?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&i/o-write \&i/o
  make-i/o-write-error i/o-write-error?)%
\end{scheme}
This condition type describes write errors that occurred during an I/O
    operation.
  \end{entry}   
  
\begin{entry}{%
\ctproto{i/o-invalid-position}
\proto{make-i/o-invalid-position-error}{ position}{procedure}
\proto{i/o-invalid-position-error?}{ obj}{procedure}
\proto{i/o-error-position}{ condition}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&i/o-invalid-position \&i/o
  make-i/o-invalid-position-error
  i/o-invalid-position-error?
  (position i/o-error-position))%
\end{scheme}

This condition type describes attempts to set the file position to an
invalid position. \var{Position} should be the file position that
the program intended to set. This condition describes a range error, but
not an assertion violation.
\end{entry}   

\begin{entry}{%
\ctproto{i/o-filename}
\proto{make-i/o-filename-error}{ filename}{procedure}
\proto{i/o-filename-error?}{ obj}{procedure}
\proto{i/o-error-filename}{ condition}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&i/o-filename \&i/o
  make-i/o-filename-error i/o-filename-error?
  (filename i/o-error-filename))%
\end{scheme}

This condition type describes an I/O error that occurred during an
operation on a named file.  \var{Filename} should be the name of the file.
\end{entry}

\begin{entry}{%
\ctproto{i/o-file-protection}
\proto{make-i/o-file-protection-error}{ filename}{procedure}
\proto{i/o-file-protection-error?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&i/o-file-protection
    \&i/o-filename
  make-i/o-file-protection-error
  i/o-file-protection-error?)%
\end{scheme}

A condition of this type specifies that an operation tried to operate on a
named file with insufficient access rights.
\end{entry}   

\begin{entry}{%
\ctproto{i/o-file-is-read-only}
\proto{make-i/o-file-is-read-only-error}{ filename}{procedure}
\proto{i/o-file-is-read-only-error?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&i/o-file-is-read-only
    \&i/o-file-protection
  make-i/o-file-is-read-only-error
  i/o-file-is-read-only-error?)%
\end{scheme}

A condition of this type specifies that an operation tried to operate on a
named read-only file under the assumption that it is writeable.
\end{entry}   

\begin{entry}{%
\ctproto{i/o-file-already-exists}
\proto{make-i/o-file-already-exists-error}{ filename}{procedure}
\proto{i/o-file-already-exists-error?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&i/o-file-already-exists
    \&i/o-filename
  make-i/o-file-already-exists-error
  i/o-file-already-exists-error?)%
\end{scheme}
A condition of this type specifies that an operation tried to operate on an
existing named file under the assumption that it did not exist.
\end{entry}   

\begin{entry}{%
\ctproto{i/o-file-does-not-exist}
\proto{make-i/o-file-does-not-exist-error}{ filename}{procedure}
\proto{i/o-file-does-not-exist-error?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&i/o-file-does-not-exist
    \&i/o-filename
  make-i/o-file-does-not-exist-error
  i/o-file-does-not-exist-error?)%
\end{scheme}

A condition of this type specifies that an operation tried to operate on an
non-existent named file under the assumption that it existed.
\end{entry}   

\begin{entry}{%
\ctproto{i/o-port}
\proto{make-i/o-port-error}{ port}{procedure}
\proto{i/o-port-error?}{ obj}{procedure}
\proto{i/o-error-port}{ condition}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&i/o-port \&i/o
  make-i/o-port-error i/o-port-error?
  (port i/o-error-port))%
\end{scheme}

This condition type specifies the port with which an I/O
error is associated. 
\var{Port} should be the port.
Conditions raised by procedures accepting a port as an argument should
include an {\cf\&i/o-port-error} condition.
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   36: portio.tex}
\section{Port I/O}
% \label{portsiosection}

The \defrsixlibrary{io ports} library defines an I/O layer for
conventional, imperative buffered input and output.
A \defining{port} represents a buffered access object
for a data sink or source or both simultaneously.
The library allows ports to be created from arbitrary data sources
and sinks.

The \rsixlibrary{io ports} library distinguishes between \textit{input
  ports\mainindex{input port}} and \textit{output
  ports\mainindex{output ports}}.  An input port is a source for data,
whereas an output port is a sink for data.  A port may be both an
input port and an output port; such a port typically provides
simultaneous read and write access to a file or other data.

The \rsixlibrary{io ports} library also distinguishes between
\textit{binary ports\mainindex{binary port}}, which are sources
or sinks for uninterpreted bytes, and
\textit{textual ports\mainindex{textual ports}}, which are sources
or sinks for characters and strings.

This section uses \var{input-port}, \var{output-port},
\var{binary-port}, \var{textual-port},
\var{binary-input-port}, \var{textual-input-port},
\var{binary-output-port}, \var{textual-output-port},
and \var{port} as
parameter names for arguments that must be input ports (or combined
input/output ports), output ports (or combined input/output ports),
binary ports, textual ports, binary input ports, textual input ports,
binary output ports, textual output ports, or any kind of port,
respectively.

\subsection{File names}
% \label{filenamesection}

Some of the procedures described in this chapter accept a file name as an
argument. Valid values for such a file name include strings that name a file
using the native notation of filesystem paths on an implementation's
underlying operating system, and may include implementation-dependent
values as well.

A \var{filename} parameter name means that the
corresponding argument must be a file name.

\subsection{File options}
% \label{fileoptionssection}

\mainindex{file options}
When opening a file, the various procedures in this library accept a
{\cf file-options} object that encapsulates flags to specify how
the file is to be opened. A {\cf file-options} object is an enum-set
(see chapter~\ref{enumerationschapter}) over the symbols constituting
valid file options.
A \var{file-options} parameter name means that the
corresponding argument must be a file-options object.

\begin{entry}{%
\proto{file-options}{ \hyper{file-options symbol} \dotsfoo}{\exprtype}}

\domain{Each \hyper{file-options symbol} must be a symbol.}
The {\cf file-options} syntax returns a file-options object that 
encapsulates the
specified options.

When supplied to an operation that opens a file for output, the
file-options object returned by {\cf (file-options)} specifies that the
file is created if it does not exist and an exception with condition type
{\cf\&i/o-file-already-exists} is raised if it does exist.
The following standard options can be included to modify the default behavior.

\begin{itemize}   
\item {\cf no-create}
      If the file does not already exist, it is not created;
      instead, an exception with condition type {\cf\&i/o-file-does-not-exist}
      is raised.
      If the file already exists, the exception with condition type
      {\cf\&i/o-file-already-exists} is not raised
      and the file is truncated to zero length.
\item {\cf no-fail}
      If the file already exists, the exception with condition type
      {\cf\&i/o-file-already-exists} is not raised,
      even if {\cf no-create} is not included,
      and the file is truncated to zero length.
\item {\cf no-truncate}
      If the file already exists and the exception with condition type
      {\cf\&i/o-file-already-exists} has been inhibited by inclusion of
      {\cf no-create} or {\cf no-fail}, the file is not truncated, but
      the port's current position is still set to the beginning of the
      file.
\end{itemize}

These options have no effect when a file is opened only for input.
Symbols
other than those listed above may be used as \hyper{file-options symbol}s;
they have implementation-specific meaning, if any.

\begin{note}
  Only the name of \hyper{file-options symbol} is significant.
\end{note}
\end{entry}   

\subsection{Buffer modes}

Each port has an associated buffer mode.  For an output port, the
buffer mode defines when an output operation flushes the buffer
associated with the output port.  For an input port, the buffer mode
defines how much data will be read to satisfy read operations.  The
possible buffer modes are the symbols {\cf none} for no buffering,
{\cf line} for flushing upon line endings and reading up to line
endings, or other implementation-dependent behavior,
and {\cf block} for arbitrary buffering.  This section uses
the parameter name \var{buffer-mode} for arguments that must be
buffer-mode symbols.

If two ports are connected to the same mutable source, both ports
are unbuffered, and reading a byte or character from that shared
source via one of the two ports would change the bytes or characters
seen via the other port, a lookahead operation on one port will
render the peeked byte or character inaccessible via the other port,
while a subsequent read operation on the peeked port will see the
peeked byte or character even though the port is otherwise unbuffered.

In other words, the semantics of buffering is defined in terms of side
effects on shared mutable sources, and a lookahead operation has the
same side effect on the shared source as a read operation.

\begin{entry}{%
\proto{buffer-mode}{ \hyper{buffer-mode symbol}}{\exprtype}}
   
\domain{\hyper{Buffer-mode symbol} must be a symbol whose name is one
  of {\cf none}, {\cf line}, and {\cf block}.} The result is the
corresponding symbol, and specifies the associated buffer mode.

\begin{note}
  Only the name of \hyper{buffer-mode symbol} is significant.
\end{note}
\end{entry}

\begin{entry}{%
\proto{buffer-mode?}{ obj}{procedure}}
   
Returns \schtrue{} if the argument is a valid buffer-mode symbol,
and returns \schfalse{} otherwise.
\end{entry}

\subsection{Transcoders}
% \label{transcoderssection}

Several different Unicode encoding schemes describe standard ways to
encode characters and strings as byte sequences and to decode those
sequences~\cite{Unicode}.
Within this document, a \defining{codec} is an immutable Scheme
object that represents a Unicode or similar encoding scheme.

An \defining{end-of-line style} is a symbol that, if it is not {\cf
  none}, describes how a textual port transcodes representations of
line endings.

A \defining{transcoder} is an immutable Scheme object that combines
a codec with an end-of-line style and a method for handling
decoding errors.
Each transcoder represents some specific bidirectional (but not
necessarily lossless), possibly stateful translation between byte
sequences and Unicode characters and strings.
Every transcoder can operate in the input direction (bytes to characters)
or in the output direction (characters to bytes). 
A \var{transcoder} parameter name means that the corresponding
argument must be a transcoder.

A \defining{binary port} is a port that supports binary I/O, does not
have an associated transcoder and does not support textual I/O.  A
\defining{textual port} is a port that supports textual I/O, and does
not support binary I/O.  A textual port may or may not have an
associated transcoder.

\begin{entry}{%
\proto{latin-1-codec}{}{procedure}
\proto{utf-8-codec}{}{procedure}
\proto{utf-16-codec}{}{procedure}}

These are predefined codecs for the ISO 8859-1, UTF-8,
and UTF-16 encoding schemes \cite{Unicode}.

A call to any of these procedures returns a value that is equal in the
sense of {\cf eqv?} to the result of any other call to the same
procedure.
\end{entry}

\begin{entry}{%
\proto{eol-style}{ \hyper{eol-style symbol}}{\exprtype}}

\domain{\hyper{Eol-style symbol} should be a symbol whose name is one
  of {\cf lf}, {\cf cr}, {\cf crlf}, {\cf nel},
  {\cf crnel}, {\cf ls}, and {\cf none}.}  The form evaluates to the
corresponding symbol.  If the name of \var{eol-style symbol} is not
one of these symbols, the effect and result are
implementation-dependent; in particular, the result may be an
eol-style symbol acceptable as an \var{eol-style} argument to {\cf
  make-transcoder}.  Otherwise, an exception is raised.

All eol-style symbols except {\cf none} describe a specific
line-ending encoding:

\noindent\begin{tabular}{ll}
{\cf lf} & \meta{linefeed}\\
{\cf cr} & \meta{carriage return}\\
{\cf crlf} & \meta{carriage return} \meta{linefeed}\\
{\cf nel} & \meta{next line}\\
{\cf crnel} & \meta{carriage return} \meta{next line}\\
{\cf ls} & \meta{line separator}
\end{tabular}

For a textual port with a transcoder, and whose transcoder has an eol-style symbol {\cf
  none}, no conversion occurs.  For a textual input port, any
eol-style symbol other than {\cf none} means that all of the above
line-ending encodings are recognized and are translated into a single
linefeed.  For a textual output port, {\cf none} and {\cf lf} are
equivalent.  Linefeed characters are encoded according to the
specified eol-style symbol, and all other characters that participate
in possible line endings are encoded as is.

\begin{note}
  Only the name of \hyper{eol-style symbol} is significant.
\end{note}
\end{entry}

\begin{entry}{%
\proto{native-eol-style}{}{procedure}}

Returns the default end-of-line style of the underlying platform, e.g.,
{\cf lf} on Unix and {\cf crlf} on Windows.
\end{entry}

\begin{entry}{%
\ctproto{i/o-decoding}
\proto{make-i/o-decoding-error}{ port}{procedure}
\proto{i/o-decoding-error?}{ obj}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&i/o-decoding \&i/o-port
  make-i/o-decoding-error i/o-decoding-error?)%
\end{scheme}

An exception with this type is raised when one of the operations for
textual input from a port encounters a sequence of bytes that cannot
be translated into a character or string by the input direction of the
port's transcoder.

When such an exception is raised, the port's position is past
the invalid encoding.
\end{entry}

\begin{entry}{% 
\ctproto{i/o-encoding}
\proto{make-i/o-encoding-error}{ port char}{procedure}
\proto{i/o-encoding-error?}{ obj}{procedure}
\proto{i/o-encoding-error-char}{ condition}{procedure}}

This condition type could be defined by
%
\begin{scheme}
(define-condition-type \&i/o-encoding \&i/o-port
  make-i/o-encoding-error i/o-encoding-error?
  (char i/o-encoding-error-char))%
\end{scheme}

An exception with this type is raised when one of the operations for
textual output to a port encounters a character that cannot be
translated into bytes by the output direction of the port's transcoder.
\var{Char} is the character that could not be encoded.
\end{entry}

\begin{entry}{%
\proto{error-handling-mode}{ \hyper{error-handling-mode symbol}}{\exprtype}}

\domain{\hyper{Error-handling-mode symbol} should be a symbol whose
  name is one of {\cf ignore}, {\cf raise}, and {\cf replace}.} The
form evaluates to the corresponding symbol.  If
\var{error-handling-mode symbol} is not one of these identifiers,
effect and result are implementation-dependent: The result may be an
error-handling-mode symbol acceptable as a \var{handling-mode}
argument to {\cf make-transcoder}.  If it is not acceptable as a
\var{handling-mode} argument to {\cf make-transcoder}, an exception is
raised.

\begin{note}
  Only the name of \hyper{error-handling-style symbol} is significant.
\end{note}

The error-handling mode of a transcoder specifies the behavior
of textual I/O operations in the presence of encoding or decoding
errors.

If a textual input operation encounters an invalid or incomplete
character encoding, and the error-handling mode is {\cf ignore},
an appropriate number of bytes of the
invalid encoding are ignored and decoding continues with the
following bytes.
If the error-handling mode is {\cf replace}, the replacement
character U+FFFD is injected into the data stream, an appropriate
number of bytes are ignored, and decoding
continues with the following bytes.
If the error-handling mode is {\cf raise}, an 
exception with condition type {\cf\&i/o-decoding} is raised.

If a textual output operation encounters a character it cannot encode,
and the error-handling mode is {\cf ignore}, the character is
ignored and encoding continues with the next character.
If the error-handling mode is {\cf replace}, a codec-specific
replacement character is emitted by the transcoder, and encoding
continues with the next character.
The replacement character is U+FFFD for transcoders whose codec
is one of the Unicode encodings, but is the {\cf ?}
character for the Latin-1 encoding.
If the error-handling mode is {\cf raise}, an
exception with condition type {\cf\&i/o-encoding} is raised.
\end{entry}

\begin{entry}{%
\proto{make-transcoder}{ codec}{procedure}
\rproto{make-transcoder}{ codec eol-style}{procedure}
\rproto{make-transcoder}{ codec eol-style handling-mode}{procedure}}

\domain{\var{Codec} must be a codec; \var{eol-style}, if present, an
  eol-style symbol; and \var{handling-mode}, if present, an
  error-handling-mode symbol.}  \var{Eol-style} may be omitted, in
which case it defaults to the native end-of-line style of the
underlying platform.  \var{Handling-mode} may be omitted, in which
case it defaults to {\cf replace}.  The result is a transcoder with the
behavior specified by its arguments.
\end{entry}

\begin{entry}{
\proto{native-transcoder}{}{procedure}}

Returns an implementation-dependent transcoder that represents a
possibly locale-dependent ``native'' transcoding.
\end{entry}

\begin{entry}{%
\proto{transcoder-codec}{ transcoder}{procedure}
\proto{transcoder-eol-style}{ transcoder}{procedure}
\proto{transcoder-error-handling-mode}{ transcoder}{procedure}}

These are accessors for transcoder objects; when applied to a
transcoder returned by {\cf make-transcoder}, they return the
\var{codec}, \var{eol-style}, and \var{handling-mode} arguments,
respectively.
\end{entry}

\begin{entry}{%
\proto{bytevector->string}{ bytevector transcoder}{procedure}}

Returns the string that results from transcoding the
\var{bytevector} according to the input direction of the transcoder.
\end{entry}

\begin{entry}{%
\proto{string->bytevector}{ string transcoder}{procedure}}

Returns the bytevector that results from transcoding the
\var{string} according to the output direction of the transcoder.
\end{entry}

\subsection{End-of-file object}
% \label{eofsection}

The end-of-file object is returned by various I/O procedures when they
reach end of file.\index{end-of-file object}

\begin{entry}{%
\proto{eof-object}{}{procedure}}

Returns the end-of-file object.
\begin{scheme}
(eqv? (eof-object) (eof-object)) \lev  \schtrue
(eq? (eof-object) (eof-object)) \lev  \schtrue%
\end{scheme}
\end{entry}

\begin{note}
  The end-of-file object  is not a datum value, and thus has no external
  representation.
\end{note}

\begin{entry}{%
\proto{eof-object?}{ obj}{procedure}}
  
Returns \schtrue{} if \var{obj} is the end-of-file object, \schfalse{} otherwise.
\end{entry}

\subsection{Input and output ports}

The operations described in this section are common to input and
output ports, both binary and textual.  A port may also have an
associated \defining{position} that specifies a particular place
within its data sink or source, and may also provide operations for
inspecting and setting that place.

\begin{entry}{%
\proto{port?}{ obj}{procedure}}
   
Returns \schtrue{} if the argument is a port, and returns \schfalse{}
otherwise.
\end{entry}

\begin{entry}{%
\proto{port-transcoder}{ port}{procedure}}

Returns the transcoder associated with \var{port} if \var{port} is
textual and has an associated transcoder, and returns \schfalse{} if
\var{port} is binary or does not have an associated transcoder.
\end{entry}

\begin{entry}{%
\proto{textual-port?}{ port}{procedure}
\proto{binary-port?}{ port}{procedure}}

The {\cf textual-port?} procedure returns \schtrue{} if \var{port} is
textual, and returns \schfalse{} otherwise.
The {\cf binary-port?} procedure returns \schtrue{} if \var{port} is
binary, and returns \schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{transcoded-port}{ binary-port transcoder}{procedure}}

The {\cf transcoded-port} procedure
returns a new textual port with the specified \var{transcoder}.
Otherwise the new textual port's state is largely the same as
that of \var{binary-port}.
If \var{binary-port} is an input port, the new textual
port will be an input port and
will transcode the bytes that have not yet been read from
\var{binary-port}.
If \var{binary-port} is an output port, the new textual
port will be an output port and
will transcode output characters into bytes that are
written to the byte sink represented by \var{binary-port}.

As a side effect, however, {\cf transcoded-port}
closes \var{binary-port} in
a special way that allows the new textual port to continue to
use the byte source or sink represented by \var{binary-port},
even though \var{binary-port} itself is closed and cannot
be used by the input and output operations described in this
chapter.
\end{entry}

\begin{entry}{%
\proto{port-has-port-position?}{ port}{procedure}
\proto{port-position}{ port}{procedure}}

The {\cf port-has-port-position?} procedure returns \schtrue{} if the
port supports the {\cf port-position} operation, and \schfalse{}
otherwise.

For a binary port, the {\cf port-position} procedure returns the index
of the position at which the next byte would be read from or written
to the port as an exact non-negative integer object.  For a textual
port, {\cf port-position} returns a value of some implementation-dependent
type representing the port's position; this value may be useful only as
the \var{pos} argument to {\cf set-port-position!}, if the latter is
supported on the port (see below).

If the port does not support the operation, {\cf port-position} raises
an exception with condition type {\cf\&assertion}.

\begin{note}
  For a textual port, the port position may or may not be an integer
  object.  If it is an integer object, the integer object does not
  necessarily correspond to a byte or character position.
\end{note}
\end{entry}   

\begin{entry}{%
\proto{port-has-set-port-position!?}{ port}{procedure}
\proto{set-port-position!}{ port pos}{procedure}}

\domain{If \var{port} is a binary port, \var{pos} should be a
  non-negative exact integer object.  If \var{port} is a textual port,
  \var{pos} should be the return value of a call to {\cf
    port-position} on \var{port}.}
   
The {\cf port-has-set-port-position!?} procedure returns \schtrue{} if the port
supports the {\cf set-port-position!} operation, and \schfalse{}
otherwise.
   
The {\cf set-port-position!} procedure raises an
exception with condition type {\cf\&assertion}
if the port does not support the operation, 
and an exception with condition type {\cf\&i/o-invalid-position} if
\var{pos} is not in the range of valid positions of \var{port}.
Otherwise, it sets the current position
of the port to \var{pos}.  If \var{port} is an output
port, {\cf set-port-position!} first flushes \var{port}.  (See {\cf
  flush-output-port}, section~\ref{flush-output-port}.)

If \var{port} is a binary output port and the current position is set
beyond the current end of the data in the underlying data sink, the object is
not extended until new data is written at that position.
The contents of any intervening positions are unspecified.
Binary ports created by {\cf open-file-output-port} and
{\cf open-file-input/output-port} can always be extended in this manner
within the limits of the underlying operating system.
In other cases, attempts to set the port beyond the current end of data
in the underlying object may result in an exception with condition
type {\cf\&i/o-invalid-position}.
\end{entry}

\begin{entry}{%
\proto{close-port}{ port}{procedure}}
   
Closes the port, rendering the port incapable of delivering or
accepting data. If \var{port} is an output port, it is flushed before
being closed.  This has no effect if the port has already been closed.
A closed port is still a port.  The {\cf close-port} procedure returns
\unspecifiedreturn.
\end{entry}

\begin{entry}{%
\proto{call-with-port}{ port proc}{procedure}}
   
\domain{\var{Proc} must accept one argument.}
The {\cf call-with-port} procedure
calls \var{proc} with \var{port} as an argument. If
\var{proc} returns, \var{port} is closed automatically and
the values returned by \var{proc} are returned. If \var{proc} does not
return, \var{port} is not closed automatically, except perhaps when it is
possible to prove that \var{port} will never again be used for an
input or output operation.
\end{entry}

\subsection{Input ports}

An input port allows the reading of an infinite sequence of bytes
or characters punctuated
by end-of-file objects. An input port connected to a finite data
source ends in an infinite sequence of end-of-file objects.

It is unspecified whether a character encoding consisting of several
bytes may have an end of file between the bytes.  If, for example,
{\cf get-char} raises an {\cf\&i/o-decoding} exception because the
character encoding at the port's position is incomplete up to the next
end of file, a subsequent call to {\cf get-char} may successfully
decode a character if bytes completing the encoding are available
after the end of file.

\begin{entry}{%
\proto{input-port?}{ obj}{procedure}}

Returns \schtrue{} if the argument is an input port (or a combined input
and output port), and returns \schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{port-eof?}{ input-port}{procedure}}
   
Returns \schtrue{}
if the {\cf lookahead-u8} procedure (if \var{input-port} is a binary port)
or the {\cf lookahead-char} procedure (if \var{input-port} is a textual port)
would return
the end-of-file object, and \schfalse{} otherwise.
The operation may block indefinitely if no data is available
but the port cannot be determined to be at end of file.
\end{entry}

\begin{entry}{%
\proto{open-file-input-port}{ filename}{procedure}
\rproto{open-file-input-port}{ filename file-options}{procedure}
\pproto{(open-file-input-port \var{filename}}{procedure}{\tt\obeyspaces%
\hspace*{2em}\var{file-options} \var{buffer-mode})}\\
\pproto{(open-file-input-port \var{filename}}{procedure}{\tt\obeyspaces%
\hspace*{2em}\var{file-options} \var{buffer-mode} \var{maybe-transcoder})}}
   
\domain{\var{Maybe-transcoder} must be either a transcoder or \schfalse.}

The {\cf open-file-input-port} procedure returns an
input port for the named file. The \var{file-options} and
\var{maybe-transcoder} arguments are optional.

The \var{file-options} argument, which may determine
various aspects of the returned port (see section~\ref{fileoptionssection}),
defaults to the value of {\cf (file-options)}.

The \var{buffer-mode} argument, if supplied,
must be one of the symbols that name a buffer mode.
The \var{buffer-mode} argument defaults to {\cf block}.

If \var{maybe-transcoder} is a transcoder, it becomes the transcoder associated
with the returned port.

If \var{maybe-transcoder} is \schfalse{} or absent,
the port will be a binary port and will support the
{\cf port-position} and {\cf set-port-position!}  operations.
Otherwise the port will be a textual port, and whether it supports
the {\cf port-position} and {\cf set-port-position!} operations
is implementation-dependent (and possibly transcoder-dependent).
\end{entry}

\begin{entry}{%
\proto{open-bytevector-input-port}{ bytevector}{procedure}
\pproto{(open-bytevector-input-port \var{bytevector}}{procedure}{\tt\obeyspaces%
\hspace*{2em}\var{maybe-transcoder})}}

\domain{\var{Maybe-transcoder} must be either a transcoder or \schfalse.}
   
The {\cf open-bytevector-input-port} procedure returns an input port whose bytes are drawn from 
\var{bytevector}.
If \var{transcoder} is specified, it becomes the transcoder associated
with the returned port.

If \var{maybe-transcoder} is \schfalse{} or absent,
the port will be a binary port and will support the
{\cf port-position} and {\cf set-port-position!}  operations.
Otherwise the port will be a textual port, and whether it supports
the {\cf port-position} and {\cf set-port-position!} operations
will be implementation-dependent (and possibly transcoder-dependent).

If \var{bytevector} is modified after {\cf open-\hp{}bytevector-\hp{}input-\hp{}port}
has been called, the effect on the returned
port is unspecified.
\end{entry}

\begin{entry}{%
\proto{open-string-input-port}{ string}{procedure}}

Returns a textual input port whose characters are drawn from
\var{string}.  The port may or may not have an associated transcoder;
if it does, the transcoder is implementation-dependent.
The port should support the
{\cf port-position} and {\cf set-port-position!} operations.

If \var{string} is modified after {\cf open-string-input-port}
has been called, the effect on the returned port is unspecified.
\end{entry}

\begin{entry}{%
\proto{standard-input-port}{}{procedure}}
   
Returns a fresh binary input port connected to standard input.
Whether the port supports the {\cf port-position} and {\cf
  set-port-position!} operations is implementation-dependent.
\end{entry}

\begin{entry}{%
\proto{current-input-port}{}{procedure}}
 
This returns a default textual port for input.  Normally, this default port
is associated with standard input, but can be dynamically re-assigned
using the {\cf with-input-from-file} procedure from the
\rsixlibrary{io simple} library (see section~\ref{with-input-from-file}).
The port may or may not have an associated transcoder; if it does, the
transcoder is implementation-dependent.
\end{entry}

\begin{entry}{%
\pproto{(make-custom-binary-input-port \var{id} \var{read!}}{procedure}}
\mainschindex{make-custom-binary-input-port}{\tt\obeyspaces\\
  \var{get-position} \var{set-position!} \var{close})}

Returns a newly created binary input port whose byte source is
an arbitrary algorithm represented by the \var{read!} procedure.
\var{Id} must be a string naming the new port,
provided for informational purposes only.
\var{Read!} must be a procedure and should behave as specified
below; it will be called by operations that perform binary input.

Each of the remaining arguments may be \schfalse{}; if any of
those arguments is not \schfalse{}, it must be a procedure and
should behave as specified below.
   
\begin{itemize}
\item {\cf (\var{read!} \var{bytevector} \var{start} \var{count})}
       
  \domain{\var{Start} will be a non-negative exact integer object,
  \var{count} will be a positive exact integer object,}
  and \var{bytevector} will be a bytevector whose length is at least
  $\var{start} + \var{count}$.
  The \var{read!} procedure should obtain up to \var{count} bytes
  from the byte source, and should write those bytes
  into \var{bytevector} starting at index \var{start}.
  The \var{read!} procedure should return an exact integer object.  This
  integer object should represent the number of bytes that it has read.
  To indicate an end of file, the \var{read!}
  procedure should write no bytes and return 0.

\item {\cf (\var{get-position})}
       
  The \var{get-position} procedure (if supplied) should return an exact
  integer object representing the current position of
  the input port.  If not supplied, the custom port will not support
  the {\cf port-position} operation.
  
\item {\cf (\var{set-position!} \var{pos})}
       
  \domain{\var{Pos} will be a non-negative exact integer object.}
  The \var{set-position!} procedure (if supplied) should set the
  position of the input port to \var{pos}.  If not supplied, the custom
  port will not support the {\cf set-port-position!} operation.
       
\item {\cf (\var{close})}
       
  The \var{close} procedure (if supplied) should perform any actions
  that are necessary when the input port is closed.
\end{itemize}

\implresp The implementation must check the return
values of \var{read!} and \var{get-position} only when it actually calls
them as part of an I/O operation requested by the program.  The
implementation is not required to check that these procedures
otherwise behave as described.  If they do not, however, the behavior
of the resulting port is unspecified.
\end{entry}

\begin{entry}{%
\pproto{(make-custom-textual-input-port \var{id} \var{read!}}{procedure}}
\mainschindex{make-custom-textual-input-port}{\tt\obeyspaces\\
  \var{get-position} \var{set-position!} \var{close})}

Returns a newly created textual input port whose character source is
an arbitrary algorithm represented by the \var{read!} procedure.
\var{Id} must be a string naming the new port,
provided for informational purposes only.
\var{Read!} must be a procedure and should behave as specified
below; it will be called by operations that perform textual input.

Each of the remaining arguments may be \schfalse{}; if any of
those arguments is not \schfalse{}, it must be a procedure and
should behave as specified below.
   
\begin{itemize}
\item {\cf (\var{read!} \var{string} \var{start} \var{count})}
       
  \domain{\var{Start} will be a non-negative exact integer object,
  \var{count} will be a positive exact integer object,}
  and \var{string} will be a string whose length is at least
  $\var{start} + \var{count}$.
  The \var{read!} procedure should obtain up to \var{count} characters
  from the character source, and should write those characters
  into \var{string} starting at index \var{start}.
  The \var{read!} procedure should return an exact integer object
  representing the number of characters that it has written.
  To indicate an end of file, the \var{read!}
  procedure should write no bytes and return 0.

\item {\cf (\var{get-position})}
       
  The \var{get-position} procedure (if supplied) should return a single
  value.  The return value should represent the current position of
  the input port.  If not supplied, the custom port will not support
  the {\cf port-position} operation.
  
\item {\cf (\var{set-position!} \var{pos})}
       
  The \var{set-position!} procedure (if supplied) should set the
  position of the input port to \var{pos} if \var{pos} is the return
  value of a call to \var{get-position}.  If not supplied, the custom
  port will not support the {\cf set-port-position!} operation.
       
\item {\cf (\var{close})}
       
  The \var{close} procedure (if supplied) should perform any actions
  that are necessary when the input port is closed.
\end{itemize}

The port may or may not have an an associated transcoder; if it does,
the transcoder is implementation-dependent.

\implresp The implementation must check the return
values of \var{read!} and \var{get-position} only when it actually calls
them as part of an I/O operation requested by the program.  The
implementation is not required to check that these procedures
otherwise behave as described.  If they do not, however, the behavior
of the resulting port is unspecified.
\end{entry}

\subsection{Binary input}\unsection

\begin{entry}{%
\proto{get-u8}{ binary-input-port}{procedure}}
   
Reads from \var{binary-input-port}, blocking as necessary, until a
byte is available from \var{binary-input-port} or until an end of file is reached.
If a byte becomes available, {\cf get-u8} returns the byte as an octet and
updates \var{binary-input-port} to point just past that byte. If no input
byte is seen before an end of file is reached, the end-of-file
object is returned.
\end{entry}

\begin{entry}{%
\proto{lookahead-u8}{ binary-input-port}{procedure}}
   
The {\cf lookahead-u8} procedure is like {\cf get-u8}, but it does not 
update \var{binary-input-port} to point past the byte.
\end{entry}

\begin{entry}{%
\proto{get-bytevector-n}{ binary-input-port count}{procedure}}
   
\domain{\var{Count} must be an exact, non-negative integer object representing
  the number of bytes to be read.}
The {\cf get-bytevector-n} procedure reads
from \var{binary-input-port}, blocking as necessary, until \var{count}
bytes are available from \var{binary-input-port} or until an end of file is
reached. If \var{count} bytes are available before an end
of file, {\cf get-bytevector-n} returns a bytevector of size \var{count}.
If fewer bytes are available before an end of file, {\cf get-bytevector-n}
returns a bytevector
containing those bytes. In either case, the input port is updated to
point just past the bytes read.  If an end of file is reached before
any bytes are available, {\cf get-bytevector-n} returns the end-of-file object.
\end{entry}

\begin{entry}{%
\pproto{(get-bytevector-n! \var{binary-input-port}}{procedure}}
\mainschindex{get-bytevector-n!}{\tt\obeyspaces\\
    \var{bytevector} \var{start} \var{count})}

\domain{\var{Count} must be an exact, non-negative integer object, representing
  the number of bytes to be read. \var{bytevector} must be a bytevector
  with at
  least $\var{start} + \var{count}$ elements.}
   
The {\cf get-bytevector-n!} procedure reads from \var{binary-input-port},
blocking as necessary, until
\var{count} bytes are available from \var{binary-input-port} or until
an end of file is
reached. If \var{count} bytes are available before an end of file,
they are written into \var{bytevector} starting at index \var{start}, and
the result is \var{count}. If fewer bytes are available before
the next end of file, the available bytes are written into \var{bytevector}
starting at index \var{start}, and the result is a number object
representing the number of bytes actually
read. In either case, the input port is updated to point just past the
bytes read. If an end of file is reached before any bytes
are available, {\cf get-bytevector-n!} returns the end-of-file object.
\end{entry}

\begin{entry}{%
\proto{get-bytevector-some}{ binary-input-port}{procedure}}
   
Reads from \var{binary-input-port}, blocking as necessary, until bytes are
available from \var{binary-input-port} or until an end of file is reached.
If bytes become available,
{\cf get-bytevector-some} returns a freshly allocated
bytevector containing the initial available bytes (at least one),
and it updates \var{binary-input-port} to point just past these bytes.
If no input bytes are seen before an end
of file is reached, the end-of-file object is returned.
\end{entry}

\begin{entry}{%
\proto{get-bytevector-all}{ binary-input-port}{procedure}}
   
Attempts to read all bytes until the next end of file, blocking as
necessary. If one or more bytes are read, {\cf get-bytevector-all} returns
a bytevector
containing all bytes up to the next end of file.  Otherwise, {\cf
  get-bytevector-all} returns the end-of-file object.
The operation may block indefinitely waiting to see if more bytes
will become available, even if some bytes are already available.
\end{entry}

\subsection{Textual input}\unsection

\begin{entry}{%
\proto{get-char}{ textual-input-port}{procedure}}
   
Reads from \var{textual-input-port}, blocking as necessary, until a
complete character is available from \var{textual-input-port},
or until an end of file is reached.

If a complete character is available before the next end of file, {\cf
  get-char} returns that character and updates the input port to
point past the character. If an end of file is
reached before any character is read, {\cf get-char} returns the
end-of-file object.
\end{entry}

\begin{entry}{%
\proto{lookahead-char}{ textual-input-port}{procedure}}
  
The {\cf lookahead-char} procedure is like {\cf get-char}, but it does not 
update \var{textual-input-port} to point past the 
character.

\begin{note}
  With some of the standard transcoders
  described in this document, up to four bytes of lookahead are
  needed. Nonstandard transcoders may need even more lookahead.
\end{note}
\end{entry}

\begin{entry}{%
\proto{get-string-n}{ textual-input-port count}{procedure}}
   
\domain{\var{Count} must be an exact, non-negative integer object, representing
  the number of characters to be read.}

The {\cf get-string-n} procedure reads
from \var{textual-input-port}, blocking as necessary, until 
\var{count} characters are available, or until an end of
file is reached.
   
If \var{count} characters are available before end of file, {\cf
  get-string-n} returns a string consisting of those \var{count}
characters. If fewer characters are available before an end of file,
but one or more characters can be read,
{\cf get-string-n} returns a string containing
those characters. In either case, the input port is updated to point
just past the characters read. If no characters can be read before an 
end of file, the end-of-file object is returned.
\end{entry}

\begin{entry}{%
\proto{get-string-n!}{ textual-input-port string start count}{procedure}}

\domain{\var{Start} and \var{count} must be exact, non-negative
  integer objects, with \var{count} representing the number of characters to be read.
  \var{String} must be a string with at least $\var{start} +
  \var{count}$ characters.}

The {\cf get-string-n!} procedure reads from \var{textual-input-port} in the same manner as {\cf
  get-string-n}.  If \var{count} characters are available
before an end of file, they are written into \var{string}
starting at index \var{start}, and \var{count} is returned. If fewer
characters are available before an end of file, but one
or more can be read, those characters are written into \var{string}
starting at index \var{start} and the number of characters actually read is
returned as an exact integer object. If no characters can be read before an end of file,
the end-of-file object is returned.
\end{entry}   

\begin{entry}{%
\proto{get-string-all}{ textual-input-port}{procedure}}
   
Reads from \var{textual-input-port} until an end of file, decoding
characters in the same manner as {\cf get-string-n} and {\cf get-string-n!}.
   
If characters are available before the end of file, a string
containing all the characters decoded from that data are returned. If no character
precedes the end of file, the end-of-file object is
returned.
\end{entry}

\begin{entry}{%
\proto{get-line}{ textual-input-port}{procedure}}
   
Reads from \var{textual-input-port} up to and including the linefeed
character or end of file, decoding characters in the same manner as
{\cf get-string-n} and {\cf get-string-n!}.
   
If a linefeed character is read, a string
containing all of the text up to (but not including) the linefeed
character is returned, and the port is updated to point just past the
linefeed character. If an end of file is
encountered before any linefeed character is read, but some characters
have been read and decoded as characters, a string containing
those characters is returned. If an end of file is encountered before
any characters are read, the end-of-file object is
returned.

\begin{note}
  The end-of-line style, if not {\cf none}, will cause all line
  endings to be read as linefeed characters.  See
  section~\ref{transcoderssection}.
\end{note}
\end{entry}

\begin{entry}{%
\proto{get-datum}{ textual-input-port}{procedure}}
 
Reads an external representation from \var{textual-input-port} and returns the
datum it represents.  The {\cf get-datum} procedure returns the next
datum that can be parsed from the given \var{textual-input-port}, updating
\var{textual-input-port} to point exactly past the end of the external
representation of the object.

Any \meta{interlexeme space}
(see report section~\extref{report:lexicalsyntaxsection}{Lexical syntax}) in
the input is first skipped.  If an end of file occurs after the
\meta{interlexeme space}, the end-of-file object (see
section~\ref{eofsection}) is returned.

If a character inconsistent with an external representation is
encountered in the input, an exception with condition types
{\cf\&lexical} and {\cf\&i/o-read} is raised.
Also, if the end of file is encountered
after the beginning of an external representation, but the external
representation is incomplete and therefore cannot be parsed, an exception
with condition types {\cf\&lexical} and {\cf\&i/o-read} is raised.
\end{entry}

\subsection{Output ports}

An output port is a sink to which bytes or characters are written.
The written data may control
external devices or may produce files and other objects that may
subsequently be opened for input.

\begin{entry}{%
\proto{output-port?}{ obj}{procedure}}
   
Returns \schtrue{} if the argument is an output port (or a
combined input and output port), \schfalse{} otherwise.
\end{entry}   

\begin{entry}{%
\proto{flush-output-port}{ output-port}{procedure}}
   
Flushes any buffered output from the buffer of \var{output-port} to the
underlying file, device, or object. The {\cf flush-output-port}
procedure returns \unspecifiedreturn.
\end{entry}

\begin{entry}{%
\proto{output-port-buffer-mode}{ output-port}{procedure}}
   
Returns the symbol that represents the buffer mode of
\var{output-port}.
\end{entry}

\begin{entry}{%
\proto{open-file-output-port}{ filename}{procedure}
\rproto{open-file-output-port}{ filename file-options}{procedure}
\pproto{(open-file-output-port \var{filename}}{procedure}{\tt\obeyspaces%
\hspace*{2em}\var{file-options} \var{buffer-mode})}\\
\pproto{(open-file-output-port \var{filename}}{procedure}{\tt\obeyspaces%
\hspace*{2em}\var{file-options} \var{buffer-mode} \var{maybe-transcoder})}}

\domain{\var{Maybe-transcoder} must be either a transcoder or \schfalse.}

The {\cf open-file-output-port} procedure returns an output port for the named file.

The \var{file-options} argument, which may determine
various aspects of the returned port (see section~\ref{fileoptionssection}),
defaults to the value of {\cf (file-options)}.

The \var{buffer-mode} argument, if supplied,
must be one of the symbols that name a buffer mode.
The \var{buffer-mode} argument defaults to {\cf block}.

If \var{maybe-transcoder} is a transcoder, it becomes the transcoder
associated with the port.

If \var{maybe-transcoder} is \schfalse{} or absent,
the port will be a binary port and will support the
{\cf port-position} and {\cf set-port-position!}  operations.
Otherwise the port will be a textual port, and whether it supports
the {\cf port-position} and {\cf set-port-position!} operations
is implementation-dependent (and possibly transcoder-dependent).
\end{entry}   

\begin{entry}{%
\proto{open-bytevector-output-port}{}{procedure}
\rproto{open-bytevector-output-port}{ maybe-transcoder}{procedure}}

\domain{\var{Maybe-transcoder} must be either a transcoder or \schfalse.}

The {\cf open-bytevector-output-port} procedure returns 
two values: an output port and an extraction procedure.
The output port accumulates the bytes written to it for
later extraction by the procedure.

If \var{maybe-transcoder} is a transcoder, it becomes
the transcoder associated with the port.
If \var{maybe-transcoder} is \schfalse{} or absent,
the port will be a binary port and will support the
{\cf port-position} and {\cf set-port-position!}  operations.
Otherwise the port will be a textual port, and whether it supports
the {\cf port-position} and {\cf set-port-position!} operations
is implementation-dependent (and possibly transcoder-dependent).

The extraction procedure takes no arguments.
When called, it returns a
bytevector consisting of all the port's accumulated bytes (regardless
of the port's current position), removes
the accumulated bytes from the port, and resets the port's position.
\end{entry}

\begin{entry}{%
\proto{call-with-bytevector-output-port}{ proc}{procedure}
\pproto{(call-with-bytevector-output-port \var{proc}}{procedure}{\tt\obeyspaces%
\hspace*{2em}\var{maybe-transcoder})}}

\domain{\var{Proc} must accept one argument.
  \var{Maybe-transcoder} must be either a transcoder or \schfalse.}

The {\cf call-with-bytevector-output-port} procedure creates an output
port that accumulates the bytes written to it and calls \var{proc} with
that output port as an argument. Whenever \var{proc} returns, a
bytevector consisting of all of the port's accumulated bytes (regardless
of the port's current position) is returned and
the port is closed.

The transcoder associated with the output port is determined
as for a call to {\cf open-bytevector-output-port}.
\end{entry}

\begin{entry}{%
\proto{open-string-output-port}{}{procedure}}

Returns two values: a textual output port and an extraction procedure.
The output port accumulates the characters written to it for
later extraction by the procedure.

The port may or may not have an associated transcoder; if it does, the
transcoder is implementation-dependent.  The port should support the {\cf
  port-position} and {\cf set-port-position!} operations.

The extraction procedure takes no arguments.
When called, it returns a string consisting of all of the port's
accumulated characters (regardless of the current position),
removes the accumulated characters from the port, and resets
the port's position.
\end{entry}

\begin{entry}{%
\proto{call-with-string-output-port}{ proc}{procedure}}

\domain{\var{Proc} must accept one argument.}
The {\cf call-\hp{}with-\hp{}string-\hp{}output-\hp{}port} procedure creates a textual output port that accumulates the
characters written to it and calls \var{proc} with that output port
as an argument.  Whenever \var{proc} returns, a string consisting of all
of the port's accumulated characters (regardless of the port's current
position) is returned and the port is closed.

The port may or may not have an associated transcoder; if it does, the
transcoder is implementation-dependent.  The port should support the
{\cf port-position} and {\cf set-port-position!} operations.
\end{entry}

\begin{entry}{%
\proto{standard-output-port}{}{procedure}
\proto{standard-error-port}{}{procedure}}
   
Returns a fresh binary output port connected to the standard output or
standard error respectively.  Whether the port supports the {\cf
  port-position} and {\cf set-port-position!} operations is
implementation-dependent.
\end{entry}

\begin{entry}{%
\proto{current-output-port}{}{procedure}
\proto{current-error-port}{}{procedure}}
 
These return default textual ports for regular output and error
output.  Normally, these default ports are associated with standard
output, and standard error, respectively.  The return value of {\cf
  current-output-port} can be dynamically re-assigned using the {\cf
  with-output-to-file} procedure from the \rsixlibrary{io simple}
library (see section~\ref{with-output-to-file}).  A port returned by
one of these procedures may or may not have an associated transcoder;
if it does, the transcoder is implementation-dependent.
\end{entry}


\begin{entry}{%
\pproto{(make-custom-binary-output-port \var{id}}{procedure}}
\mainschindex{make-custom-binary-output-port}{\tt\obeyspaces\\
  \var{write!} \var{get-position} \var{set-position!} \var{close})}

Returns a newly created binary output port whose byte sink is
an arbitrary algorithm represented by the \var{write!} procedure.
\var{Id} must be a string naming the new port,
provided for informational purposes only.
\var{Write!} must be a procedure and should behave as specified
below; it will be called by operations that perform binary output.

Each of the remaining arguments may be \schfalse{}; if any of
those arguments is not \schfalse{}, it must be a procedure and
should behave as specified in the description of
{\cf make-custom-binary-input-port}.
   
\begin{itemize}
\item {\cf (\var{write!} \var{bytevector} \var{start} \var{count})}
       
  \domain{\var{Start} and \var{count} will be non-negative exact
    integer objects,
  and \var{bytevector} will be a bytevector whose length is at least
  $\var{start} + \var{count}$.}
  The \var{write!} procedure should write up to \var{count} bytes
  from \var{bytevector} starting at index \var{start} 
  to the byte sink.
  If \var{count} is 0, the \var{write!} procedure should
  have the effect of passing an end-of-file object to the byte sink.
  In any case, the \var{write!} procedure should return the number of
  bytes that it wrote, as an exact integer object.
\end{itemize}

\implresp The implementation must check the return
values of \var{write!} only when it actually calls \var{write!} as part of
an I/O operation requested by the program.  The implementation is not
required to check that \var{write!} otherwise behaves as described.
If it does not, however, the behavior of the resulting port is
unspecified.
\end{entry}

\begin{entry}{%
\pproto{(make-custom-textual-output-port \var{id}}{procedure}}
\mainschindex{make-custom-textual-output-port}{\tt\obeyspaces\\
  \var{write!} \var{get-position} \var{set-position!} \var{close})}

Returns a newly created textual output port whose byte sink is
an arbitrary algorithm represented by the \var{write!} procedure.
\var{Id} must be a string naming the new port,
provided for informational purposes only.
\var{Write!} must be a procedure and should behave as specified
below; it will be called by operations that perform textual output.

Each of the remaining arguments may be \schfalse{}; if any of
those arguments is not \schfalse{}, it must be a procedure and
should behave as specified in the description of
{\cf make-custom-textual-input-port}.
   
\begin{itemize}
\item {\cf (\var{write!} \var{string} \var{start} \var{count})}
       
  \domain{\var{Start} and \var{count} will be non-negative exact
    integer objects,
  and \var{string} will be a string whose length is at least
  $\var{start} + \var{count}$.}
  The \var{write!} procedure should write up to \var{count} characters
  from \var{string} starting at index \var{start} 
  to the character sink.
  If \var{count} is 0, the \var{write!} procedure should
  have the effect of passing an end-of-file object to the character sink.
  In any case, the \var{write!} procedure should return the number of
  characters that it wrote, as an exact integer object.
\end{itemize}

The port may or may not have an associated transcoder; if it does, the
transcoder is implementation-dependent.

\implresp The implementation must check the return
values of \var{write!} only when it actually calls \var{write!} as part of
an I/O operation requested by the program.  The implementation is not
required to check that \var{write!} otherwise behaves as described.
If it does not, however, the behavior of the resulting port is
unspecified.
\end{entry}

\subsection{Binary output}\unsection

\begin{entry}{%
\proto{put-u8}{ binary-output-port octet}{procedure}}

Writes \var{octet} to the output port and returns \unspecifiedreturn.
\end{entry}

\begin{entry}{%
\proto{put-bytevector}{ binary-output-port bytevector}{procedure}
\rproto{put-bytevector}{ binary-output-port bytevector start}{procedure}
\pproto{(put-bytevector \var{binary-output-port}}{procedure}}
{\tt\obeyspaces\\
     \var{bytevector} \var{start} \var{count})}
   
\domain{\var{Start} and \var{count} must be non-negative exact
  integer objects that default to 0 and $\texttt{(bytevector-length \var{bytevector})}
  - \var{start}$, respectively. \var{Bytevector} must have a length of at
  least $\var{start} + \var{count}$.}  The {\cf put-bytevector} procedure writes
the \var{count} bytes of the bytevector \var{bytevector} starting at index
\var{start} to the output port.  The {\cf put-bytevector} procedure
returns \unspecifiedreturn.
\end{entry}

\subsection{Textual output}\unsection

\begin{entry}{%
\proto{put-char}{ textual-output-port char}{procedure}}
   
Writes \var{char} to the port. The {\cf put-char} procedure returns
\unspecifiedreturn.
\end{entry}

\begin{entry}{%
\proto{put-string}{ textual-output-port string}{procedure}
\rproto{put-string}{ textual-output-port string start}{procedure}
\rproto{put-string}{ textual-output-port string start count}{procedure}}
   
\domain{\var{Start} and \var{count} must be non-negative exact
  integer objects.  \var{String} must have a length of at least $\var{start} +
  \var{count}$.}  \var{Start} defaults to 0.  \var{Count} defaults to
$\texttt{(string-length \var{string})} - \var{start}$.  The {\cf
  put-string} procedure writes the
\var{count} characters of \var{string} starting at
index \var{start} to the port.  The {\cf put-string} procedure
returns \unspecifiedreturn.
\end{entry}


\begin{entry}{%
\proto{put-datum}{ textual-output-port datum}{procedure}}

\domain{\var{Datum} should be a datum value.}  The {\cf put-datum}
procedure writes an external representation of \var{datum} to
\var{textual-output-port}.  The specific external representation is
implementation-dependent.  However, whenever possible, an
implementation should produce a representation for which {\cf
  get-datum}, when reading the representation, will return an object
equal (in the sense of {\cf equal?}) to \var{datum}.

\begin{note}
  Not all datums may allow producing an external representation for which
  {\cf get-datum} will produce an object that is equal to the
  original.  Specifically, NaNs contained in \var{datum} may make
  this impossible.
\end{note}

\begin{note}
  The {\cf put-datum} procedure merely writes the external
  representation, but no trailing delimiter.  If {\cf put-datum} is
  used to write several subsequent external representations to an
  output port, care should be taken to delimit them properly so they can
  be read back in by subsequent calls to {\cf get-datum}.
\end{note}
\end{entry}


\subsection{Input/output ports}\unsection

\begin{entry}{%
\proto{open-file-input/output-port}{ filename}{procedure}
\rproto{open-file-input/output-port}{ filename file-options}{procedure}
\pproto{(open-file-input/output-port \var{filename}}{procedure}{\tt\obeyspaces%
\hspace*{2em}\var{file-options} \var{buffer-mode})}\\
\pproto{(open-file-input/output-port \var{filename}}{procedure}{\tt\obeyspaces%
\hspace*{2em}\var{file-options} \var{buffer-mode} \var{transcoder})}}
   
Returns a single port that is both an input port and an
output port for the named file.
The optional arguments default as described in the specification
of {\cf open-file-output-port}.
If the input/output port supports {\cf port-position} and/or
{\cf set-port-position!}, the same port position is used
for both input and output.
\end{entry}

\begin{entry}{%
\pproto{(make-custom-binary-input/output-port}{procedure}}
\mainschindex{make-custom-binary-input/output-port}{\tt\obeyspaces\\
  \var{id} \var{read!} \var{write!} \var{get-position} \var{set-position!} \var{close})}

Returns a newly created binary input/output port whose
byte source and sink are
arbitrary algorithms represented by the \var{read!} and \var{write!}
procedures.
\var{Id} must be a string naming the new port,
provided for informational purposes only.
\var{Read!} and \var{write!} must be procedures,
and should behave as specified for the
{\cf make-custom-binary-input-port} and
{\cf make-custom-binary-output-port} procedures.

Each of the remaining arguments may be \schfalse{}; if any of
those arguments is not \schfalse{}, it must be a procedure and
should behave as specified in the description of
{\cf make-custom-binary-input-port}.
\end{entry}

\begin{entry}{%
\pproto{(make-custom-textual-input/output-port}{procedure}}
\mainschindex{make-custom-textual-input/output-port}{\tt\obeyspaces\\
  \var{id} \var{read!} \var{write!} \var{get-position} \var{set-position!} \var{close})}

Returns a newly created textual input/output port whose
textual source and sink are
arbitrary algorithms represented by the \var{read!} and \var{write!}
procedures.
\var{Id} must be a string naming the new port,
provided for informational purposes only.
\var{Read!} and \var{write!} must be procedures,
and should behave as specified for the
{\cf make-custom-textual-input-port} and
{\cf make-custom-textual-output-port} procedures.

Each of the remaining arguments may be \schfalse{}; if any of
those arguments is not \schfalse{}, it must be a procedure and
should behave as specified in the description of
{\cf make-custom-textual-input-port}.
\end{entry}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   37: convio.tex}
\section{Simple I/O}
% \label{simpleiosection}

This section describes the \defrsixlibrary{io simple} library, which
provides a somewhat more convenient interface for performing textual
I/O on ports.  This library implements most of the 
I/O procedures of the previous revision of this report~\cite{R5RS}.

The ports created by the procedures of this library are textual ports
associated implementation-dependent transcoders.

\begin{entry}{%
\rproto{eof-object}{}{procedure}
\rproto{eof-object?}{ obj}{procedure}}

These are the same as {\cf eof-object} and {\cf eof-object?} from the
\rsixlibrary{ports} library.\schindex{eof-object}\schindex{eof-object?}
\end{entry}

\begin{entry}{%
\proto{call-with-input-file}{ filename proc}{procedure}
\proto{call-with-output-file}{ filename proc}{procedure}}

\domain{\var{Proc} should accept one argument.}
These procedures open the file named by \var{filename} for input or
for output, with no specified file options, and call \var{proc} with
the obtained port as an argument.  If \var{proc} returns, the
port is closed automatically and the values returned by \var{proc} are
returned. If \var{proc} does not return, the port is not
closed automatically, unless it is possible to prove that the port
will never again be used for an I/O operation.
\end{entry}

\begin{entry}{%
\rproto{input-port?}{ obj}{procedure}
\rproto{output-port?}{ obj}{procedure}}

These are the same as the {\cf input-port?} and {\cf output-port?}
procedures in the \rsixlibrary{io ports} library.
\end{entry}

\begin{entry}{%
\rproto{current-input-port}{}{procedure}
\rproto{current-output-port}{}{procedure}
\rproto{current-error-port}{}{procedure}}
 
These are the same as the {\cf current-input-port}\schindex{current-input-port}, {\cf
  current-output-port}\schindex{current-output-port}, and {\cf current-error-port}\schindex{current-error-port} procedures from
the \rsixlibrary{io ports} library.
\end{entry}

\begin{entry}{%
\proto{with-input-from-file}{ filename thunk}{procedure}
\proto{with-output-to-file}{ filename thunk}{procedure}}

\domain{\var{Thunk} must be a procedure and must accept zero arguments.}  The
file is opened for input or output using empty file options, and
\var{thunk} is called with no arguments.  During the dynamic extent of
the call to \var{thunk}, the obtained port is made the value returned
by {\cf current-input-port} or {\cf current-output-port} procedures;
the previous default values are reinstated when the dynamic extent is
exited.  When \var{thunk} returns, the port is closed automatically.
The values
returned by \var{thunk} are returned.  If an escape procedure is used
to escape back into the call to \var{thunk} after \var{thunk} is
returned, the behavior is unspecified.
\end{entry}

\begin{entry}{%
\proto{open-input-file}{ filename}{procedure}}

Opens \var{filename} for input, with empty file options, and returns
the obtained port.
\end{entry}

\begin{entry}{%
\proto{open-output-file}{ filename}{procedure}}

Opens \var{filename} for output, with empty file options, and
returns the obtained port.
\end{entry}

\begin{entry}{%
\proto{close-input-port}{ input-port}{procedure}
\proto{close-output-port}{ output-port}{procedure}}

Closes \var{input-port} or \var{output-port}, respectively.
\end{entry}

\begin{entry}{%
\proto{read-char}{}{procedure}
\rproto{read-char}{ textual-input-port}{procedure}}

Reads from \var{textual-input-port},
blocking as necessary until a character
is available from \var{textual-input-port},
or the data that are available cannot
be the prefix of any valid encoding, or an end of file is reached.

If a complete character is available before the next end of file, {\cf
  read-char} returns that character, and updates the input port to
point past that character. If an end of file is
reached before any data are read, {\cf read-char} returns the
end-of-file object.

If \var{textual-input-port} is omitted, it defaults to the value returned by
{\cf current-input-port}.
\end{entry}

\begin{entry}{%
\rproto{peek-char}{}{procedure}
\proto{peek-char}{ textual-input-port}{procedure}}
   
This is the same as {\cf read-char}, but does not consume any data
from the port.
\end{entry}

\begin{entry}{%
\rproto{read}{}{procedure}
\proto{read}{ textual-input-port}{procedure}}

Reads an external representation from \var{textual-input-port}
and returns the datum it
represents.  The {\cf read} procedure operates in the same way as 
{\cf get-datum}, see section~\ref{get-datum}.

If \var{textual-input-port} is omitted, it defaults to the value returned by
{\cf current-input-port}.
\end{entry}

\begin{entry}{%
\proto{write-char}{ char}{procedure}
\rproto{write-char}{ char textual-output-port}{procedure}}

Writes an encoding of the character \var{char} to the
\var{textual-output-port}, and returns \unspecifiedreturn.

If \var{textual-output-port} is omitted, it defaults to the value returned by
{\cf current-output-port}.
\end{entry}

\begin{entry}{%
\proto{newline}{}{procedure}
\rproto{newline}{ textual-output-port}{procedure}}

This is equivalent to using {\cf write-char} to write
{\cf \#\backwhack{}linefeed}
to \var{textual-output-port}.

If \var{textual-output-port} is omitted, it defaults to the value returned by
{\cf current-output-port}.
\end{entry}

\begin{entry}{%
\proto{display}{ obj}{procedure}
\rproto{display}{ obj textual-output-port}{procedure}}

Writes a representation of \var{obj} to the given \var{textual-output-port}.
Strings that appear in
the written representation are not enclosed in doublequotes, and no
characters are escaped within those strings.  Character objects appear
in the representation as if written by {\cf write-char} instead of by
{\cf write}.  The {\cf display} procedure returns \unspecifiedreturn.  The
\var{textual-output-port} argument may be omitted, in which case it defaults
to the value returned by {\cf current-output-port}.
\end{entry}

\begin{entry}{%
\proto{write}{ obj}{procedure}
\rproto{write}{ obj textual-output-port}{procedure}}

Writes the external representation of \var{obj} to \var{textual-output-port}.
The {\cf write}
procedure operates in the same way as {\cf put-datum}; see
section~\ref{put-datum}.

If \var{textual-output-port} is omitted, it defaults to the value returned by
{\cf current-output-port}.
\end{entry}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   38: programlib.tex}
\chapter{Command-line access and exit values}
% \label{programlibchapter}

The procedures described in this section are exported by the
\defrsixlibrary{programs} library.

\begin{entry}{%
\proto{command-line}{}{procedure}}

Returns a nonempty list of strings.
The first element is an implementation-specific
name for the running top-level program.  The remaining elements are command-line
arguments according to the operating system's conventions.
\end{entry}

\begin{entry}{%
\proto{exit}{}{procedure}
\rproto{exit}{ obj}{procedure}}

Exits the running program and communicates an exit value to the 
operating system.  If no argument is supplied, the {\cf exit}
procedure should communicate to the operating system that the program 
exited normally.  If an argument is supplied, the {\cf exit} procedure 
should translate the argument into an appropriate exit value for the 
operating system.  If \var{obj} is \schfalse{}, the exit is assumed to
be abnormal.
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   39: arith.tex}
\chapter{Arithmetic}
% \label{numberchapter}
\index{number}

This chapter describes Scheme's libraries for more specialized
numerical operations: fixnum and flonum arithmetic, as well as bitwise
operations on exact integer objects.  

\section{Bitwise operations}

A number of procedures operate on the binary two's-complement
representations of exact integer objects: Bit positions within an
exact integer object are counted from the right, i.e.\ bit 0 is the
least significant bit.  Some procedures allow extracting \defining{bit
  fields}, i.e., number objects representing subsequences of the
binary representation of an exact integer object.  Bit fields are
always positive, and always defined using a finite number of bits.

\section{Fixnums}
% \label{fixnumssection}

Every implementation must define its fixnum range as a closed
interval
%
\begin{displaymath}
[-2^{w-1}, 2^{w-1} - 1]
\end{displaymath}
%
such that $w$ is a (mathematical) integer $w \geq 24$.  Every
mathematical integer within an implementation's fixnum range must
correspond to an exact integer object that is representable within the
implementation.
A fixnum is an exact integer object whose value lies within this
fixnum range.

This section describes the \defrsixlibrary{arithmetic fixnums} library,
which defines various operations on fixnums.
Fixnum operations perform integer arithmetic on their fixnum
arguments, but raise an exception with condition type
{\cf\&implementation-restriction} if the result is not a fixnum.

This section uses \var{fx}, \vari{fx}, \varii{fx}, etc., as parameter
names for arguments that must be fixnums.

\begin{entry}{%
\rproto{fixnum?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is an exact
integer object within the fixnum range, \schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\rproto{fixnum-width}{}{procedure}
\rproto{least-fixnum}{}{procedure}
\rproto{greatest-fixnum}{}{procedure}}

These procedures return $w$,
$-2^{w-1}$ and $2^{w-1} - 1$: the
width, minimum and the maximum value of the fixnum range, respectively.
\end{entry}

\begin{entry}{%
\proto{fx=?}{ \vari{fx} \varii{fx} \variii{fx} \dotsfoo}{procedure}
\proto{fx>?}{ \vari{fx} \varii{fx} \variii{fx} \dotsfoo}{procedure}
\proto{fx<?}{ \vari{fx} \varii{fx} \variii{fx} \dotsfoo}{procedure}
\proto{fx>=?}{ \vari{fx} \varii{fx} \variii{fx} \dotsfoo}{procedure}
\proto{fx<=?}{ \vari{fx} \varii{fx} \variii{fx} \dotsfoo}{procedure}}

These procedures return \schtrue{} if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing,
\schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{fxzero?}{ fx}{procedure}
\proto{fxpositive?}{ fx}{procedure}
\proto{fxnegative?}{ fx}{procedure}
\proto{fxodd?}{ fx}{procedure}
\proto{fxeven?}{ fx}{procedure}}

These numerical predicates test a fixnum for a particular property,
returning \schtrue{} or \schfalse{}.  The five properties tested by
these procedures are: whether the number object is zero, greater than zero,
less than zero, odd, or even.
\end{entry}

\begin{entry}{%
\proto{fxmax}{ \vari{fx} \varii{fx} \dotsfoo}{procedure}
\proto{fxmin}{ \vari{fx} \varii{fx} \dotsfoo}{procedure}}

These procedures return the maximum or minimum of their arguments.
\end{entry}

\begin{entry}{%
\proto{fx+}{ \vari{fx} \varii{fx}}{procedure}
\proto{fx*}{ \vari{fx} \varii{fx}}{procedure}}

These procedures return the sum or product of their arguments,
provided that sum or product is a fixnum.  An exception with condition
type {\cf\&implementation-restriction} is raised if
that sum or product is not a fixnum.
\end{entry}

\begin{entry}{%
\proto{fx-}{ \vari{fx} \varii{fx}}{procedure}
\rproto{fx-}{ fx}{procedure}}

With two arguments, this procedure returns the difference
$\vari{fx}-\varii{fx}$, provided that difference is a fixnum.

With one argument, this procedure returns the additive
inverse of its argument, provided that integer object is a
fixnum.

An exception with condition type {\cf\&assertion} is raised if the
mathematically correct result of this procedure is not a fixnum.

\begin{scheme}
(fx- (least-fixnum))  \xev  \exception{\&assertion}%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fxdiv-and-mod}{ \vari{fx} \varii{fx}}{procedure}
\proto{fxdiv}{ \vari{fx} \varii{fx}}{procedure}
\proto{fxmod}{ \vari{fx} \varii{fx}}{procedure}
\proto{fxdiv0-and-mod0}{ \vari{fx} \varii{fx}}{procedure}
\proto{fxdiv0}{ \vari{fx} \varii{fx}}{procedure}
\proto{fxmod0}{ \vari{fx} \varii{fx}}{procedure}}

\domain{\varii{Fx} must be nonzero.}
These procedures implement number-theoretic integer division and
return the results of the corresponding mathematical operations
specified in report section~\extref{report:integerdivision}{Integer division}.

\begin{scheme}
(fxdiv \vari{fx} \varii{fx})         \ev \(\vari{fx}~\mathrm{div}~\varii{fx}\)
(fxmod \vari{fx} \varii{fx})         \ev \(\vari{fx}~\mathrm{mod}~\varii{fx}\)
(fxdiv-and-mod \vari{fx} \varii{fx})     \lev \(\vari{fx}~\mathrm{div}~\varii{fx}, \vari{fx}~\mathrm{mod}~\varii{fx}\)\\\>\>; \textrm{two return values}
(fxdiv0 \vari{fx} \varii{fx})        \ev \(\vari{fx}~\mathrm{div}\sb{0}~\varii{fx}\)
(fxmod0 \vari{fx} \varii{fx})        \ev \(\vari{fx}~\mathrm{mod}\sb{0}~\varii{fx}\)
(fxdiv0-and-mod0 \vari{fx} \varii{fx})   \lev \(\vari{fx} \vari{fx}~\mathrm{div}\sb{0}~\varii{fx}, \vari{fx}~\mathrm{mod}\sb{0}~\varii{fx}\)\\\>\>; \textrm{two return values}%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fx+/carry}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

Returns the two fixnum results of the following computation:
%
\begin{scheme}
(let* ((s (+ \vari{fx} \varii{fx} \variii{fx}))
       (s0 (mod0 s (expt 2 (fixnum-width))))
       (s1 (div0 s (expt 2 (fixnum-width)))))
  (values s0 s1))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fx-/carry}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

Returns the two fixnum results of the following computation:
%
\begin{scheme}
(let* ((d (- \vari{fx} \varii{fx} \variii{fx}))
       (d0 (mod0 d (expt 2 (fixnum-width))))
       (d1 (div0 d (expt 2 (fixnum-width)))))
  (values d0 d1))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fx*/carry}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

Returns the two fixnum results of the following computation:
\begin{scheme}
(let* ((s (+ (* \vari{fx} \varii{fx}) \variii{fx}))
       (s0 (mod0 s (expt 2 (fixnum-width))))
       (s1 (div0 s (expt 2 (fixnum-width)))))
  (values s0 s1))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fxnot}{ \var{fx}}{procedure}}

Returns the unique fixnum that is congruent
mod $2^w$ to the one's-complement of \var{fx}.
\end{entry}

\begin{entry}{%
\proto{fxand}{ \vari{fx} \dotsfoo}{procedure}
\proto{fxior}{ \vari{fx} \dotsfoo}{procedure}
\proto{fxxor}{ \vari{fx} \dotsfoo}{procedure}}

These procedures return the fixnum that is the bit-wise ``and'',
``inclusive or'', or ``exclusive or'' of the two's complement
representations of their arguments.  If they are passed only one
argument, they return that argument.  If they are passed no arguments,
they return the fixnum (either $-1$ or $0$) that acts as identity for the
operation.
\end{entry}

\begin{entry}{%
\proto{fxif}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

Returns the fixnum that is the bit-wise ``if'' of the two's complement
representations of its arguments, i.e.\ for each bit, if it is 1 in
\vari{fx}, the corresponding bit in \varii{fx} becomes the value of
the corresponding bit in the result, and if it is 0, the corresponding
bit in \variii{fx} becomes the corresponding bit in the value of the
result.  This is the fixnum result of the following computation:
\begin{scheme}
(fxior (fxand \vari{fx} \varii{fx})
       (fxand (fxnot \vari{fx}) \variii{fx}))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fxbit-count}{ \var{fx}}{procedure}}

If \var{fx} is non-negative, this procedure returns the
number of 1 bits in the two's complement representation of \var{fx}.
Otherwise it returns the result of the following computation:
%
\begin{scheme}
(fxnot (fxbit-count (fxnot \var{ei})))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fxlength}{ \var{fx}}{procedure}}

Returns the number of bits needed to represent \var{fx} if it is
positive, and the number of bits needed to represent {\cf (fxnot
  \var{fx})} if it is negative, which is the fixnum result of the
following computation:
\begin{scheme}
(do ((result 0 (+ result 1))
     (bits (if (fxnegative? \var{fx})
               (fxnot \var{fx})
               \var{fx})
           (fxarithmetic-shift-right bits 1)))
    ((fxzero? bits)
     result))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fxfirst-bit-set}{ \var{fx}}{procedure}}

Returns the index of the least significant $1$ bit in
the two's complement representation of \var{fx}.  If 
\var{fx} is $0$, then $-1$ is returned.
%
\begin{scheme}
(fxfirst-bit-set 0)        \ev  -1
(fxfirst-bit-set 1)        \ev  0
(fxfirst-bit-set -4)       \ev  2%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fxbit-set?}{ \vari{fx} \varii{fx}}{procedure}}

\domain{\varii{Fx} must be non-negative and less than {\cf
    (fixnum-width)}.}  The {\cf fxbit-set?} procedure returns
\schtrue{} if the \varii{fx}th bit is 1 in the two's complement
representation of \vari{fx}, and \schfalse{} otherwise.  This is the
fixnum result of the following computation:
%
\begin{scheme}
(not
  (fxzero?
    (fxand \vari{fx}
           (fxarithmetic-shift-left 1 \varii{fx}))))%
\end{scheme}
%
\end{entry}

\begin{entry}{%
\proto{fxcopy-bit}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

\domain{\varii{Fx} must be non-negative and less than {\cf
  (fixnum-width)}. \variii{Fx} must be 0 or
1.}  The {\cf fxcopy-bit} procedure returns the result of replacing
the \varii{fx}th bit of \vari{fx} by \variii{fx}, which is
the result of the following computation:
\begin{scheme}
(let* ((mask (fxarithmetic-shift-left 1 \varii{fx})))
  (fxif mask
        (fxarithmetic-shift-left \variii{fx} \varii{fx})
        \vari{fx}))%
\end{scheme}
%
\end{entry}

\begin{entry}{%
\proto{fxbit-field}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

\domain{\varii{Fx} and \variii{fx} must be non-negative and less than
  {\cf (fixnum-width)}.  Moreover, \varii{fx} must be less than or
  equal to \variii{fx}.}  The {\cf fxbit-field} procedure returns the
number represented by the bits at the positions from \varii{fx} (inclusive) to
$\variii{fx}$ (exclusive), which is
the fixnum result of the following computation:
%
\begin{scheme}
(let* ((mask (fxnot
              (fxarithmetic-shift-left -1 \variii{fx}))))
  (fxarithmetic-shift-right (fxand \vari{fx} mask)
                            \varii{fx}))%
\end{scheme}
%
\end{entry}

\begin{entry}{%
\proto{fxcopy-bit-field}{ \vari{fx} \varii{fx} \variii{fx} \variv{fx}}{procedure}}

\domain{\varii{Fx} and \variii{fx} must be non-negative and less than
  {\cf (fixnum-width)}.  Moreover, \varii{fx} must be less than or
  equal to \variii{fx}.}  The {\cf fxcopy-bit-field} procedure returns
the result of replacing in \vari{fx} the bits at positions from
\varii{fx} (inclusive) to $\variii{fx}$ (exclusive) by the corresponding bits in \variv{fx}, which
is the fixnum result of the following computation:
\begin{scheme}
(let* ((to    \vari{fx})
       (start \varii{fx})
       (end   \variii{fx})
       (from  \variv{fx})
       (mask1 (fxarithmetic-shift-left -1 start))
       (mask2 (fxnot
               (fxarithmetic-shift-left -1 end)))
       (mask (fxand mask1 mask2)))
  (fxif mask
        (fxarithmetic-shift-left from start)
        to))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fxarithmetic-shift}{ \vari{fx} \varii{fx}}{procedure}}

\domain{The absolute value of \varii{fx} must be less than 
{\cf (fixnum-width)}.}  If
%
\begin{scheme}
(floor (* \vari{fx} (expt 2 \varii{fx})))%
\end{scheme}
%
is a fixnum, then that fixnum is returned.  Otherwise an exception
with condition type {\cf\&implementation-\hp{}restriction} is
raised.
\end{entry}

\begin{entry}{%
\proto{fxarithmetic-shift-left}{ \vari{fx} \varii{fx}}{procedure}
\proto{fxarithmetic-shift-right}{ \vari{fx} \varii{fx}}{procedure}}

\domain{\varii{Fx} must be non-negative, and less than {\cf
    (fixnum-width)}.}
  The {\cf fxarithmetic-shift-left} procedure behaves the same as {\cf
  fxarithmetic-shift}, and {\cf (fxarithmetic-shift-right \vari{fx}
  \varii{fx})} behaves the same as {\cf (fxarithmetic-shift \vari{fx}
  (fx- \varii{fx}))}.
\end{entry}

\begin{entry}{%
\proto{fxrotate-bit-field}{ \vari{fx} \varii{fx} \variii{fx} \variv{fx}}{procedure}}

\domain{\varii{Fx}, \variii{fx}, and \variv{fx} must be non-negative
  and less than {\cf (fixnum-width)}.  \varii{Fx} must be less than or
  equal to \variii{fx}. \variv{Fx} must be less than the difference
between \variii{fx} and \varii{fx}.}  The {\cf fxrotate-bit-field}
procedure returns the result of cyclically permuting in \vari{fx} the
bits at positions from \varii{fx} (inclusive) to \variii{fx}
(exclusive) by \variv{fx} bits
towards the more significant bits, which is the result of the
following computation:
\begin{scheme}
(let* ((n     \vari{fx})
       (start \varii{fx})
       (end   \variii{fx})
       (count \variv{fx})
       (width (fx- end start)))
  (if (fxpositive? width)
      (let* ((count (fxmod count width))
             (field0
               (fxbit-field n start end))
             (field1
               (fxarithmetic-shift-left
                 field0 count))
             (field2
               (fxarithmetic-shift-right
                 field0 (fx- width count)))
             (field (fxior field1 field2)))
        (fxcopy-bit-field n start end field))
      n))%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{fxreverse-bit-field}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}

\domain{\varii{Fx} and \variii{fx} must be non-negative and less than
  {\cf (fixnum-width)}.  Moreover, \varii{fx} must be less than or
  equal to \variii{fx}.}  The {\cf fxreverse-bit-field} procedure
returns
the fixnum obtained from \vari{fx} by reversing the
order of the bits at positions from \varii{fx} (inclusive) to
\variii{fx} (exclusive).
\begin{scheme}
(fxreverse-bit-field \sharpsign{}b1010010 1 4)    \lev  88 ; \sharpsign{}b1011000%
\end{scheme}

\end{entry}

\section{Flonums}
% \label{flonumssection}

This section describes the \defrsixlibrary{arithmetic flonums} library.

This section uses \var{fl}, \vari{fl}, \varii{fl}, etc., as
parameter names for arguments that must be flonums, and \var{ifl}
as a name for arguments that 
must be integer-valued flonums, i.e., flonums for which the
{\cf integer-valued?} predicate returns true.

\begin{entry}{%
\proto{flonum?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a flonum, \schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{real->flonum}{ x}{procedure}}

Returns the best flonum representation of
\var{x}.

The value returned is a flonum that is numerically closest to the
argument.

\begin{note}
  If flonums are represented in binary floating point, then
  implementations should break ties by preferring
  the floating-point representation whose least significant bit is
  zero.
\end{note}
\end{entry}

\begin{entry}{%
\proto{fl=?}{ \vari{fl} \varii{fl} \variii{fl} \dotsfoo}{procedure}
\proto{fl<?}{ \vari{fl} \varii{fl} \variii{fl} \dotsfoo}{procedure}
\proto{fl<=?}{ \vari{fl} \varii{fl} \variii{fl} \dotsfoo}{procedure}
\proto{fl>?}{ \vari{fl} \varii{fl} \variii{fl} \dotsfoo}{procedure}
\proto{fl>=?}{ \vari{fl} \varii{fl} \variii{fl} \dotsfoo}{procedure}}

These procedures return \schtrue{} if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing,
\schfalse{} otherwise.  These
predicates must be transitive.

\begin{scheme}
(fl= +inf.0 +inf.0)           \ev  \schtrue{}
(fl= -inf.0 +inf.0)           \ev  \schfalse{}
(fl= -inf.0 -inf.0)           \ev  \schtrue{}
(fl= 0.0 -0.0)                \ev  \schtrue{}
(fl< 0.0 -0.0)                \ev  \schfalse{}
(fl= +nan.0 \var{fl})               \ev  \schfalse{}
(fl< +nan.0 \var{fl})               \ev  \schfalse{}%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{flinteger?}{ fl}{procedure}
\proto{flzero?}{ fl}{procedure}
\proto{flpositive?}{ fl}{procedure}
\proto{flnegative?}{ fl}{procedure}
\proto{flodd?}{ ifl}{procedure}
\proto{fleven?}{ ifl}{procedure}
\proto{flfinite?}{ fl}{procedure}
\proto{flinfinite?}{ fl}{procedure}
\proto{flnan?}{ fl}{procedure}}

These numerical predicates test a flonum for a particular property,
returning \schtrue{} or \schfalse{}.
The {\cf flinteger?} procedure tests whether the number object is an integer,
{\cf flzero?} tests whether
it is {\cf fl=?} to zero, {\cf flpositive?} tests whether it is greater
than zero, {\cf flnegative?} tests whether it is less
than zero, {\cf flodd?} tests whether it is odd, 
{\cf fleven?} tests whether it is even,
{\cf flfinite?} tests whether it is not an infinity and not a NaN,
{\cf flinfinite?} tests whether it is an infinity, and
{\cf flnan?} tests whether it is a NaN.

\begin{scheme}
(flnegative? -0.0)   \ev \schfalse{}
(flfinite? +inf.0)   \ev \schfalse{}
(flfinite? 5.0)      \ev \schtrue{}
(flinfinite? 5.0)    \ev \schfalse{}
(flinfinite? +inf.0) \ev \schtrue{}%
\end{scheme}

\begin{note}
{\cf (flnegative? -0.0)} must return \schfalse{},
else it would lose the correspondence with
{\cf (fl< -0.0 0.0)}, which is \schfalse{}
according to IEEE 754~\cite{IEEE}.
\end{note}
\end{entry}

\begin{entry}{%
\proto{flmax}{ \vari{fl} \varii{fl} \dotsfoo}{procedure}
\proto{flmin}{ \vari{fl} \varii{fl} \dotsfoo}{procedure}}

These procedures return the maximum or minimum of their arguments.
They always return a NaN when one or more of the arguments is a NaN.
\end{entry}

\begin{entry}{%
\proto{fl+}{ \vari{fl} \dotsfoo}{procedure}
\proto{fl*}{ \vari{fl} \dotsfoo}{procedure}}

These procedures return the flonum sum or product of their flonum
arguments.  In general, they should return the flonum that best
approximates the mathematical sum or product.  (For implementations
that represent flonums using IEEE binary floating point, the
meaning of ``best'' is defined by the IEEE standards.)

\begin{scheme}
(fl+ +inf.0 -inf.0)      \ev  +nan.0
(fl+ +nan.0 \var{fl})          \ev  +nan.0
(fl* +nan.0 \var{fl})          \ev  +nan.0%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{fl-}{ \vari{fl} \varii{fl} \dotsfoo}{procedure}
\rproto{fl-}{ fl}{procedure}
\proto{fl/}{ \vari{fl} \varii{fl} \dotsfoo}{procedure}
\rproto{fl/}{ fl}{procedure}}

With two or more arguments, these procedures return the flonum
difference or quotient of their flonum arguments, associating to the
left.  With one argument, however, they return the additive or
multiplicative flonum inverse of their argument.  In general, they
should return the flonum that best approximates the mathematical
difference or quotient.  (For implementations that represent flonums
using IEEE binary floating point, the meaning of ``best'' is
reasonably well-defined by the IEEE standards.)

\begin{scheme}
(fl- +inf.0 +inf.0)      \ev  +nan.0%
\end{scheme}

For undefined quotients, {\cf fl/} behaves as specified by the
IEEE standards:

\begin{scheme}
(fl/ 1.0 0.0)  \ev +inf.0
(fl/ -1.0 0.0) \ev -inf.0
(fl/ 0.0 0.0)  \ev +nan.0%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{flabs}{ fl}{procedure}}

Returns the absolute value of \var{fl}.
\end{entry}

\begin{entry}{%
\proto{fldiv-and-mod}{ \vari{fl} \varii{fl}}{procedure}
\proto{fldiv}{ \vari{fl} \varii{fl}}{procedure}
\proto{flmod}{ \vari{fl} \varii{fl}}{procedure}
\proto{fldiv0-and-mod0}{ \vari{fl} \varii{fl}}{procedure}
\proto{fldiv0}{ \vari{fl} \varii{fl}}{procedure}
\proto{flmod0}{ \vari{fl} \varii{fl}}{procedure}}

These procedures implement number-theoretic integer division and
return the results of the corresponding mathematical operations
specified in report section~\extref{report:integerdivision}{Integer division}.  For zero divisors, these
procedures may return a NaN or some unspecified flonum.

\begin{scheme}
(fldiv \vari{fl} \varii{fl})         \ev \(\vari{fl}~\mathrm{div}~\varii{fl}\)
(flmod \vari{fl} \varii{fl})         \ev \(\vari{fl}~\mathrm{mod}~\varii{fl}\)
(fldiv-and-mod \vari{fl} \varii{fl})     \lev \(\vari{fl}~\mathrm{div}~\varii{fl}, \vari{fl}~\mathrm{mod}~\varii{fl}\)\\\>\>; \textrm{two return values}
(fldiv0 \vari{fl} \varii{fl})        \ev \(\vari{fl}~\mathrm{div}_0~\varii{fl}\)
(flmod0 \vari{fl} \varii{fl})        \ev \(\vari{fl}~\mathrm{mod}_0~\varii{fl}\)
(fldiv0-and-mod0 \vari{fl} \varii{fl})   \lev \(\vari{fl}~\mathrm{div}_0~\varii{fl}, \vari{fl}~\mathrm{mod}_0~\varii{fl}\)\\\>\>; \textrm{two return values}%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{flnumerator}{ fl}{procedure}
\proto{fldenominator}{ fl}{procedure}}

These procedures return the numerator or denominator of \var{fl}
as a flonum; the result is computed as if \var{fl} was represented as
a fraction in lowest terms.  The denominator is always positive.  The
denominator of 0.0 is defined to be 1.0.
%
\begin{scheme}
(flnumerator +inf.0)           \ev  +inf.0
(flnumerator -inf.0)           \ev  -inf.0
(fldenominator +inf.0)         \ev  1.0
(fldenominator -inf.0)         \ev  1.0
(flnumerator 0.75)             \ev  3.0 ; \textrm{probably}
(fldenominator 0.75)           \ev  4.0 ; \textrm{probably}%
\end{scheme}

Implementations should implement following behavior:

\begin{scheme}
(flnumerator -0.0)             \ev -0.0%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{flfloor}{ fl}{procedure}
\proto{flceiling}{ fl}{procedure}
\proto{fltruncate}{ fl}{procedure}
\proto{flround}{ fl}{procedure}}

These procedures return integral flonums for flonum arguments that are
not infinities or NaNs.  For such arguments, {\cf flfloor} returns the
largest integral flonum not larger than \var{fl}.  The {\cf flceiling}
procedure
returns the smallest integral flonum not smaller than \var{fl}.
The {\cf fltruncate} procedure returns the integral flonum closest to \var{fl} whose
absolute value is not larger than the absolute value of \var{fl}.
The {\cf flround} procedure returns the closest integral flonum to \var{fl},
rounding to even when \var{fl} represents a number halfway between two integers.

Although infinities and NaNs are not integer objects, these procedures return
an infinity when given an infinity as an argument, and a NaN when
given a NaN:

\begin{scheme}
(flfloor +inf.0)                       \ev  +inf.0
(flceiling -inf.0)                     \ev  -inf.0
(fltruncate +nan.0)                    \ev  +nan.0%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{flexp}{ fl}{procedure}
\proto{fllog}{ fl}{procedure}
\rproto{fllog}{ \vari{fl} \varii{fl}}{procedure}
\proto{flsin}{ fl}{procedure}
\proto{flcos}{ fl}{procedure}
\proto{fltan}{ fl}{procedure}
\proto{flasin}{ fl}{procedure}
\proto{flacos}{ fl}{procedure}
\proto{flatan}{ fl}{procedure}
\rproto{flatan}{ \vari{fl} \varii{fl}}{procedure}}

These procedures compute the usual transcendental functions.  
The {\cf flexp} procedure computes the base-$e$ exponential of \var{fl}.
The {\cf fllog} procedure with a single argument computes the natural logarithm of
\var{fl} (not the base ten logarithm); {\cf (fllog \vari{fl}
  \varii{fl})} computes the base-\varii{fl} logarithm of \vari{fl}.
The {\cf flasin}, {\cf flacos}, and {\cf flatan} procedures compute arcsine,
arccosine, and arctangent, respectively.  {\cf (flatan \vari{fl}
  \varii{fl})} computes the arc tangent of \vari{fl}/\varii{fl}.

See report
section~\extref{report:transcendentalfunctions}{Transcendental functions} for the underlying
mathematical operations.  In the event that these operations do not
yield a real result for the given arguments, the result may be a NaN,
or may be some unspecified flonum.

Implementations that use IEEE binary floating-point arithmetic 
should follow the relevant standards for these procedures.

\begin{scheme}
(flexp +inf.0)                \ev +inf.0
(flexp -inf.0)                \ev 0.0
(fllog +inf.0)                \ev +inf.0
(fllog 0.0)                   \ev -inf.0
(fllog -0.0)                  \ev \unspecified\\\>; \textrm{if -0.0 is distinguished}
(fllog -inf.0)                \ev +nan.0
(flatan -inf.0)               \lev -1.5707963267948965\\\>; \textrm{approximately}
(flatan +inf.0)               \lev 1.5707963267948965\\\>; \textrm{approximately}%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{flsqrt}{ fl}{procedure}}

Returns the principal square root of \var{fl}. For $-0.0$,
{\cf flsqrt} should return $-0.0$; for other negative arguments,
the result may be a NaN or some unspecified flonum.

\begin{scheme}
(flsqrt +inf.0)               \ev  +inf.0
(flsqrt -0.0)                 \ev  -0.0%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{flexpt}{ \vari{fl} \varii{fl}}{procedure}}

\domain{Either \vari{fl} should be non-negative, or, if \vari{fl} is
  negative, \varii{fl} should be an integer object.}
The {\cf flexpt} procedure returns \vari{fl} raised to the power \varii{fl}.  If \vari{fl} is
negative and \varii{fl} is not an integer object, the result may be a
NaN, or may be some unspecified flonum.  If \vari{fl} is zero, then
the result is zero.
\end{entry}

\begin{entry}{%
\ctproto{no-infinities}
\proto{make-no-infinities-violation}{ obj}{procedure}
\proto{no-infinities-violation?}{ obj}{procedure}
\ctproto{no-nans}
\proto{make-no-nans-violation}{ obj}{procedure}
\proto{no-nans-violation?}{ obj}{procedure}}

These condition types could be defined by the following code:

\begin{scheme}
(define-condition-type \&no-infinities
    \&implementation-restriction
  make-no-infinities-violation
  no-infinities-violation?)

(define-condition-type \&no-nans
    \&implementation-restriction
  make-no-nans-violation no-nans-violation?)%
\end{scheme}

These types describe that a program has executed an arithmetic
operations that is specified to return an infinity or a NaN,
respectively, on a Scheme implementation that is not able to represent
the infinity or NaN.  (See report section~\extref{report:infinitiesnanssection}{Representability of infinities and NaNs}.)
\end{entry}

\begin{entry}{%
\proto{fixnum->flonum}{ fx}{procedure}}

Returns a flonum that is numerically closest to \var{fx}.

\begin{note}
The result of this procedure may not be
numerically equal to \var{fx}, because the fixnum precision
may be greater than the flonum precision.
\end{note}
\end{entry}

\section{Exact bitwise arithmetic}
% \label{exactsection}

This section describes the \defrsixlibrary{arithmetic bitwise}
library.  The exact bitwise arithmetic provides generic operations on
exact integer objects.  This section uses \var{ei}, \vari{ei}, \varii{ei}, etc.,
as parameter names that must be exact integer objects.


\begin{entry}{%
\proto{bitwise-not}{ ei}{procedure}}

Returns the exact integer object whose two's complement representation is the
one's complement of the two's complement representation of \var{ei}.
\end{entry}

\begin{entry}{%
\proto{bitwise-and}{ \vari{ei} \dotsfoo}{procedure}
\proto{bitwise-ior}{ \vari{ei} \dotsfoo}{procedure}
\proto{bitwise-xor}{ \vari{ei} \dotsfoo}{procedure}}

These procedures return the exact integer object that is the bit-wise
``and'', ``inclusive or'', or ``exclusive or'' of the two's complement
representations of their arguments.  If they are passed only one
argument, they return that argument.  If they are passed no arguments,
they return the integer object (either $-1$ or $0$) that acts as identity for
the operation.
\end{entry}

\begin{entry}{%
\proto{bitwise-if}{ \vari{ei} \varii{ei} \variii{ei}}{procedure}}

Returns the exact integer object that is the bit-wise ``if'' of the two's complement
representations of its arguments, i.e.\ for each bit, if it is 1 in
\vari{ei}, the corresponding bit in \varii{ei} becomes the value of
the corresponding bit in the result, and if it is 0, the corresponding
bit in \variii{ei} becomes the corresponding bit in the value of the
result.
This is the result of the following computation:
\begin{scheme}
(bitwise-ior (bitwise-and \vari{ei} \varii{ei})
             (bitwise-and (bitwise-not \vari{ei}) \variii{ei}))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bitwise-bit-count}{ ei}{procedure}}
 
If \var{ei} is non-negative, this procedure returns the number of
1 bits in the two's complement representation of \var{ei}.
Otherwise it returns the result of the following computation:
%
\begin{scheme}
(bitwise-not (bitwise-bit-count (bitwise-not \var{ei})))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bitwise-length}{ ei}{procedure}}

Returns the number of bits needed to represent \var{ei} if it is
positive, and the number of bits needed to represent {\cf (bitwise-not
  \var{ei})} if it is negative, which is the exact integer object that
is the result of the following computation:
\begin{scheme}
(do ((result 0 (+ result 1))
     (bits (if (negative? \var{ei})
               (bitwise-not \var{ei})
               \var{ei})
           (bitwise-arithmetic-shift bits -1)))
    ((zero? bits)
     result))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bitwise-first-bit-set}{ ei}{procedure}}

Returns the index of the least significant $1$
bit in the two's complement representation of \var{ei}.
If \var{ei} is $0$, then $-1$ is returned.
\begin{scheme}
(bitwise-first-bit-set 0)        \ev  -1
(bitwise-first-bit-set 1)        \ev  0
(bitwise-first-bit-set -4)       \ev  2%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bitwise-bit-set?}{ \vari{ei} \varii{ei}}{procedure}}

\domain{\varii{Ei} must be non-negative.}
The {\cf bitwise-bit-set?} procedure returns
\schtrue{} if the \varii{ei}th bit is 1 in the two's complement
representation of \vari{ei}, and \schfalse{}
otherwise.  This is the result of the following computation:
\begin{scheme}
(not (zero?
       (bitwise-and
         (bitwise-arithmetic-shift-left 1 \varii{ei})
         \vari{ei})))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bitwise-copy-bit}{ \vari{ei} \varii{ei} \variii{ei}}{procedure}}

\domain{\varii{Ei} must be non-negative, and \variii{ei}
must be either $0$ or $1$.}
The {\cf bitwise-copy-bit} procedure returns the result of replacing
the \varii{ei}th bit of \vari{ei} by the \varii{ei}th bit of \variii{ei}, which is
the result of the following computation:
\begin{scheme}
(let* ((mask (bitwise-arithmetic-shift-left 1 \varii{ei})))
  (bitwise-if mask
            (bitwise-arithmetic-shift-left \variii{ei} \varii{ei})
            \vari{ei}))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bitwise-bit-field}{ \vari{ei} \varii{ei} \variii{ei}}{procedure}}

\domain{\varii{Ei} and \variii{ei} must be non-negative, and
  \varii{ei} must be less than or equal to \variii{ei}.}
The {\cf bitwise-bit-field} procedure returns the
number represented by the bits at the positions from \varii{ei}
(inclusive) to $\variii{ei}$ (exclusive), which is
the result of the following computation:
%
\begin{scheme}
(let ((mask
       (bitwise-not
        (bitwise-arithmetic-shift-left -1 \variii{ei}))))
  (bitwise-arithmetic-shift-right
    (bitwise-and \vari{ei} mask)
    \varii{ei}))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bitwise-copy-bit-field}{ \vari{ei} \varii{ei} \variii{ei} \variv{ei}}{procedure}}

\domain{\varii{Ei} and \variii{ei} must be non-negative,
and \varii{ei} must be less than or equal to \variii{ei}.}
The {\cf bitwise-copy-bit-field} procedure returns
the result of replacing in \vari{ei} the bits at positions from
\varii{ei} (inclusive) to $\variii{ei}$ (exclusive) by the corresponding bits in \variv{ei}, which
is the fixnum result of the following computation:
%
\begin{scheme}
(let* ((to    \vari{ei})
       (start \varii{ei})
       (end   \variii{ei})
       (from  \variv{ei})
       (mask1
         (bitwise-arithmetic-shift-left -1 start))
       (mask2
         (bitwise-not
           (bitwise-arithmetic-shift-left -1 end)))
       (mask (bitwise-and mask1 mask2)))
  (bitwise-if mask
              (bitwise-arithmetic-shift-left from
                                             start)
              to))%
\end{scheme}
\end{entry}

\begin{entry} {%
\proto{bitwise-arithmetic-shift}{ \vari{ei} \varii{ei}}{procedure}}

Returns the result of the following computation:
%
\begin{scheme}
(floor (* \vari{ei} (expt 2 \varii{ei})))%
\end{scheme}

Examples:
%
\begin{scheme}
(bitwise-arithmetic-shift -6 -1) \lev -3
(bitwise-arithmetic-shift -5 -1) \lev -3
(bitwise-arithmetic-shift -4 -1) \lev -2
(bitwise-arithmetic-shift -3 -1) \lev -2
(bitwise-arithmetic-shift -2 -1) \lev -1
(bitwise-arithmetic-shift -1 -1) \lev -1%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bitwise-arithmetic-shift-left}{ \vari{ei} \varii{ei}}{procedure}
\proto{bitwise-arithmetic-shift-right}{ \vari{ei} \varii{ei}}{procedure}}

\domain{\varii{Ei} must be non-negative.}  The {\cf
  bitwise-\hp{}arithmetic-\hp{}shift-\hp{}left} procedure returns the same result as {\cf
  bitwise-arithmetic-shift}, and
\begin{scheme}
(bitwise-arithmetic-shift-right \vari{ei} \varii{ei})%
\end{scheme}
returns the same result as 
\begin{scheme}
(bitwise-arithmetic-shift \vari{ei} (- \varii{ei}))\textrm{.}%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bitwise-rotate-bit-field}{ \vari{ei} \varii{ei} \variii{ei} \variv{ei}}{procedure}}

\domain{\varii{Ei}, \variii{ei}, \variv{ei} must be non-negative, 
\varii{ei} must be less than or equal to \variii{ei}, and
\variv{ei} must be non-negative.}
procedure returns the result of cyclically permuting in \vari{ei} the
bits at positions from \varii{ei} (inclusive) to \variii{ei} (exclusive) by \variv{ei} bits
towards the more significant bits, which is the result of the
following computation:
%
\begin{scheme}
(let* ((n     \vari{ei})
       (start \varii{ei})
       (end   \variii{ei})
       (count \variv{ei})
       (width (- end start)))
  (if (positive? width)
      (let* ((count (mod count width))
             (field0
               (bitwise-bit-field n start end))
             (field1 (bitwise-arithmetic-shift-left
                       field0 count))
             (field2 (bitwise-arithmetic-shift-right
                       field0
                       (- width count)))
             (field (bitwise-ior field1 field2)))
        (bitwise-copy-bit-field n start end field))
      n))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bitwise-reverse-bit-field}{ \vari{ei} \varii{ei} \variii{ei}}{procedure}}

\domain{\varii{Ei} and \variii{ei} must be non-negative, and
  \varii{ei} must be less than or equal to \variii{ei}.}  The {\cf bitwise-reverse-bit-field} procedure returns
the result obtained from \vari{ei} by reversing the
order of the bits at positions from \varii{ei} (inclusive) to
\variii{ei} (exclusive).
\begin{scheme}
(bitwise-reverse-bit-field \sharpsign{}b1010010 1 4)   \lev  88 ; \sharpsign{}b1011000%
\end{scheme}
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   40: syntax-case.tex}
\chapter{{\tt syntax-case}}
% \label{syntaxcasechapter}

% should include algebra for marks and substitutions
% ---see Waddell's dissertation or POPL '99 module paper
% but don't want to rule out van Tonder's shallow-binding approach

The \defrsixlibrary{syntax-case} library
provides
support for writing low-level macros
in a high-level style, with automatic syntax checking, input
destructuring, output restructuring, maintenance of lexical scoping
and referential transparency (hygiene), and support for controlled
identifier capture.

\section{Hygiene}
% \label{hygienesection}

% hygiene condition for macro expansion
% (Kohlbecker, E.E., Friedman, D.P., Felleisen, M., Duba, B. 'Hygienic macro expansion' (1986))
% "Generated identifiers that become binding instances in the completely
% expanded program must only bind variables that are generated at the same
% transcription step."

Barendregt's \emph{hygiene condition}~\cite{barendregt} for the
lambda calculus is an informal notion that requires the free variables of
an expression $N$ that is to be substituted into another expression $M$ not to
be captured by bindings in $M$ when such capture is not intended.
Kohlbecker, et al~\cite{hygienic} propose a corresponding
\emph{hygiene condition for macro expansion} that applies in all situations
where capturing is not explicit:
``Generated identifiers that become binding instances in
the completely expanded program must only bind variables that
are generated at the same transcription step''.
In the terminology of this document, the ``generated identifiers'' are
those introduced by a transformer rather than those present in the form
passed to the transformer, and a ``macro transcription step'' corresponds
to a single call by the expander to a transformer.
Also, the hygiene condition applies to all introduced bindings rather than
to introduced variable bindings alone.

This leaves open what happens to an introduced identifier that appears
outside the scope of a binding introduced by the same call.
Such an identifier refers to the lexical binding in effect where it
appears (within a {\cf syntax} \hyper{template};
see section~\ref{syntaxcasesection}) inside the transformer body or one of
the helpers it calls.
This is essentially the referential transparency property described
by Clinger and Rees~\cite{macrosthatwork}.
Thus, the hygiene condition can be restated as follows:

\begin{quotation}
\noindent
A binding for an identifier introduced into the output of a transformer
call from the expander must capture only references to the identifier
introduced into the output of the same transformer call.
A reference to an identifier introduced into the output of a transformer
refers to the closest enclosing binding for the introduced identifier or,
if it appears outside of any enclosing binding for the introduced
identifier, the closest enclosing lexical binding where the identifier
appears (within a {\cf syntax} \hyper{template})
inside the transformer body or one of the helpers it calls.
\end{quotation}

Explicit captures are handled via {\cf datum\coerce{}syntax}; see
section~\ref{conversionssection}.

Operationally, the expander can maintain hygiene with the help of
\emph{marks\mainindex{mark}} and \emph{substitutions\mainindex{substitution}}.
Marks are applied selectively by the expander to the output of each
transformer it invokes, and substitutions are applied to the portions
of each binding form that are supposed to be within the scope of the bound
identifiers.
Marks are used to distinguish like-named identifiers that are
introduced at different times (either present in the source or introduced
into the output of a particular transformer call), and substitutions are
used to map identifiers to their expand-time values.

Each time the expander encounters a macro use, it applies an
\defining{antimark} to the input form, invokes the associated transformer,
then applies a fresh mark to the output.
Marks and antimarks cancel, so the portions of the input that appear in
the output are effectively left unmarked, while the portions of the output
that are introduced are marked with the fresh mark.

Each time the expander encounters a binding form it creates a set of
substitutions, each mapping one of the (possibly marked) bound identifiers
to information about the binding.
(For a {\cf lambda} expression, the expander might map each bound
identifier to a representation of the formal parameter in the output of
the expander.
For a {\cf let-syntax} form, the expander might map each bound
identifier to the associated transformer.)
These substitutions are applied to the portions of the input form in
which the binding is supposed to be visible.

Marks and substitutions together form a \defining{wrap} that is layered on the
form being processed by the expander and pushed down toward the leaves as
necessary.
A wrapped form is referred to as a \defining{wrapped syntax object}.
Ultimately, the wrap may rest on a leaf that represents an identifier, in
which case the wrapped syntax object is also referred to
as an \emph{identifier}.
An identifier contains a name along with the wrap.
(Names are typically represented by symbols.)

When a substitution is created to map an identifier to an expand-time
value, the substitution records the name of the identifier and
the set of marks that have been applied to that identifier, along
with the associated expand-time value.
The expander resolves identifier references by looking for the latest
matching substitution to be applied to the identifier, i.e., the outermost
substitution in the wrap whose name and marks match the name and
marks recorded in the substitution.
The name matches if it is the same name (if using symbols, then by
{\cf eq?}), and the marks match if the marks recorded with the
substitution are the same as those that appear \emph{below} the
substitution in the wrap, i.e., those that were applied \emph{before} the
substitution.
Marks applied after a substitution, i.e., appear over the substitution in
the wrap, are not relevant and are ignored.

An algebra that defines how marks and substitutions work more precisely is
given in section~2.4 of Oscar Waddell's PhD thesis~\cite{Waddellphd}.

\section{Syntax objects}
% \label{syntaxobjectssection}

A \defining{syntax object} is a representation of a Scheme form that contains
contextual information about the form in addition to its structure.
This contextual information is used by the expander to maintain
lexical scoping and may also be used by an implementation to maintain
source-object correlation~\cite{syntacticabstraction}.

A syntax object may be wrapped, as described in section~\ref{hygienesection}.
It may also be unwrapped, fully or partially, i.e., consist of list and
vector structure with wrapped syntax objects or nonsymbol values at the
leaves.
More formally, a syntax object is:

\begin{itemize}
\item a pair of syntax objects,
\item a vector of syntax objects,
\item a nonpair, nonvector, nonsymbol value, or
\item a wrapped syntax object.
\end{itemize}

The distinction between the terms ``syntax object'' and ``wrapped syntax
object'' is important.
For example, when invoked by the expander, a transformer
(section~\ref{transformerssection}) must accept a wrapped syntax object but
may return any syntax object, including an unwrapped syntax object.

Syntax objects representing identifiers are always wrapped and are distinct
from other types of values.
Wrapped syntax objects that are not identifiers may or may not be distinct
from other types of values.

\section{Transformers}
% \label{transformerssection}

In {\cf define-syntax} (report
section~\extref{report:define-syntax}{Syntax definitions}), {\cf
  let-syntax}, and {\cf letrec-syntax} forms (report
section~\extref{report:let-syntax}{Binding constructs for syntactic
  keywords}), a binding for a syntactic keyword is an expression
that evaluates to a \defining{transformer}\index{macro transformer}.

A transformer is a \defining{transformation procedure} or a
\defining{variable transformer}.
A transformation procedure is a procedure that must accept one
argument, a wrapped syntax object (section~\ref{syntaxobjectssection})
representing the input, and return a syntax object
(section~\ref{syntaxobjectssection}) representing the output.
The transformer is called by the expander whenever a reference to
a keyword with which it has been associated is found.
If the keyword appears in the car of a list-structured
input form, the transformer receives the entire list-structured
form, and its output replaces the entire form.
Except with variable transformers (see below),
if the keyword is found in any other definition or expression
context, the transformer receives a wrapped syntax object representing
just the keyword reference, and its output replaces just the reference.
Except with variable transformers, an exception with condition
type {\cf\&syntax} is raised if the keyword appears on the left-hand side
of a {\cf set!} expression.

\begin{entry}{%
\proto{make-variable-transformer}{ proc}{procedure}}

\domain{\var{Proc} should accept one argument,
a wrapped syntax object, and return a syntax object.}

The {\cf make-variable-transformer} procedure creates a
\defining{variable transformer}.
A variable transformer is like an ordinary transformer except
that, if a keyword associated with a variable transformer appears on
the left-hand side of a {\cf set!} expression, an exception is
not raised.
Instead, \var{proc} is called with a
wrapped syntax object representing the entire {\cf set!} expression as
its argument, and its return value replaces the entire {\cf set!}
expression.

\implresp The implementation must check the restrictions on \var{proc}
only to the extent performed by applying it as described.
An
implementation may check whether \var{proc} is an appropriate argument
before applying it.
\end{entry}

\section{Parsing input and producing output}
% \label{syntaxcasesection}

Transformers can destructure their input with {\cf syntax-case} and rebuild
their output with {\cf syntax}.

\begin{entry}{%
\pproto{(syntax-case \hyper{expression} (\hyper{literal} \dotsfoo)}{\exprtype}
\mainschindex{syntax-case}{\tt\obeyspaces%
\hspace{2em}\hyper{syntax-case clause} \dotsfoo)}\\
\litprotonoindex{\_}
\litprotonoindex{...}}\schindex{\_}\schindex{...}

\syntax Each \hyper{literal} must be an identifier.
Each \hyper{syntax-case clause} must take one of the following two forms.

\begin{scheme}
(\hyper{pattern} \hyper{output expression})
(\hyper{pattern} \hyper{fender} \hyper{output expression})%
\end{scheme}

\hyper{Fender} and \hyper{output expression} must be
\hyper{expression}s.

A \hyper{pattern} is an identifier, constant, or one of the following.

\begin{schemenoindent}
(\hyper{pattern} \ldots)
(\hyper{pattern} \hyper{pattern} \ldots . \hyper{pattern})
(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots)
(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots . \hyper{pattern})
\#(\hyper{pattern} \ldots)
\#(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots)%
\end{schemenoindent}

An \hyper{ellipsis} is the identifier ``{\cf ...}'' (three periods).\schindex{...}

An identifier appearing within a \hyper{pattern} may be an underscore
(~{\cf \_}~), a literal identifier listed in the list of literals
{\cf (\hyper{literal} \dotsfoo)}, or an ellipsis (~{\cf ...}~).
All other identifiers appearing within a \hyper{pattern} are
\textit{pattern variables\mainindex{pattern variable}}.
It is a syntax violation if an ellipsis or underscore appears in {\cf (\hyper{literal} \dotsfoo)}.

{\cf \_} and {\cf ...} are the same as in the \rsixlibrary{base} library.

Pattern variables match arbitrary input subforms and
are used to refer to elements of the input.
It is a syntax violation if the same pattern variable appears more than once in a
\hyper{pattern}.

Underscores also match arbitrary input subforms but are not pattern variables
and so cannot be used to refer to those elements.
Multiple underscores may appear in a \hyper{pattern}.

A literal identifier matches an input subform if and only if the input
subform is an identifier and either both its occurrence in the input
expression and its occurrence in the list of literals have the same
lexical binding, or the two identifiers have the same name and both have
no lexical binding.

A subpattern followed by an ellipsis can match zero or more elements of
the input.

More formally, an input form $F$ matches a pattern $P$ if and only if
one of the following holds:

\begin{itemize}
\item $P$ is an underscore (~{\cf \_}~).

\item $P$ is a pattern variable.

\item $P$ is a literal identifier
and $F$ is an equivalent identifier in the
sense of {\cf free-identifier=?}
(section~\ref{identifierpredicatessection}).

\item $P$ is of the form
{\cf ($P_1$ \dotsfoo{} $P_n$)}
and $F$ is a list of $n$ elements that match $P_1$ through
$P_n$.

\item $P$ is of the form
{\cf ($P_1$ \dotsfoo{} $P_n$ . $P_x$)}
and $F$ is a list or improper list of $n$ or more elements
whose first $n$ elements match $P_1$ through $P_n$
and
whose $n$th cdr matches $P_x$.

\item $P$ is of the form
{\cf ($P_1$ \dotsfoo{} $P_k$ $P_e$ \hyper{ellipsis} $P_{m+1}$ \dotsfoo{} $P_n$)},
where \hyper{ellipsis} is the identifier {\cf ...}
and $F$ is a proper list of $n$
elements whose first $k$ elements match $P_1$ through $P_k$,
whose next $m-k$ elements each match $P_e$,
and
whose remaining $n-m$ elements match $P_{m+1}$ through $P_n$.

\item $P$ is of the form
{\cf ($P_1$ \dotsfoo{} $P_k$ $P_e$ \hyper{ellipsis} $P_{m+1}$ \dotsfoo{} $P_n$ . $P_x$)},
where \hyper{ellipsis} is the identifier {\cf ...}
and $F$ is a list or improper list of $n$
elements whose first $k$ elements match $P_1$ through $P_k$,
whose next $m-k$ elements each match $P_e$,
whose next $n-m$ elements match $P_{m+1}$ through $P_n$,
and 
whose $n$th and final cdr matches $P_x$.

\item $P$ is of the form
{\cf \#($P_1$ \dotsfoo{} $P_n$)}
and $F$ is a vector of $n$ elements that match $P_1$ through
$P_n$.

\item $P$ is of the form
{\cf \#($P_1$ \dotsfoo{} $P_k$ $P_e$ \hyper{ellipsis} $P_{m+1}$ \dotsfoo{} $P_n$)},
where \hyper{ellipsis} is the identifier {\cf ...}
and $F$ is a vector of $n$ or more elements
whose first $k$ elements match $P_1$ through $P_k$,
whose next $m-k$ elements each match $P_e$,
and
whose remaining $n-m$ elements match $P_{m+1}$ through $P_n$.

\item $P$ is a pattern datum (any nonlist, nonvector, nonsymbol
datum) and $F$ is equal to $P$ in the sense of the
{\cf equal?} procedure.
\end{itemize}

\semantics
A {\cf syntax-case} expression first evaluates \hyper{expression}.
It then attempts to match
the \hyper{pattern} from the first \hyper{syntax-case clause} against the resulting value,
which is unwrapped as necessary to perform the match.
If the pattern matches the value and no
\hyper{fender} is present,
\hyper{output expression} is evaluated and its value returned as the
value of the {\cf syntax-case} expression.
If the pattern does not match the value, {\cf syntax-case} tries
the second \hyper{syntax-case clause}, then the third, and so on.
It is a syntax violation if the value does not match any of the patterns.

If the optional \hyper{fender} is present, it serves as an additional
constraint on acceptance of a clause.
If the \hyper{pattern} of a given \hyper{syntax-case clause} matches the input value,
the corresponding \hyper{fender} is evaluated.
If \hyper{fender} evaluates to a true value, the clause is accepted;
otherwise, the clause is rejected as if the pattern had failed to match
the value.
Fenders are logically a part of the matching process, i.e., they
specify additional matching constraints beyond the basic structure of
the input.

Pattern variables contained within a clause's
\hyper{pattern} are bound to the corresponding pieces of the input
value within the clause's \hyper{fender} (if present) and
\hyper{output expression}.
Pattern variables can be referenced only within {\cf syntax}
expressions (see below).
Pattern variables occupy the same name space as program variables and
keywords.

If the {\cf syntax-case} form is in tail context, the \hyper{output
  expression}s are also in tail position.
\end{entry}

\begin{entry}{%
\proto{syntax}{ \hyper{template}}{\exprtype}}

\begin{note}
{\cf \#'\hyper{template}} is equivalent to {\cf (syntax
  \hyper{template})}.
\end{note}

A {\cf syntax} expression is similar to a {\cf quote} expression
except that (1) the values of pattern variables appearing within
\hyper{template} are inserted into \hyper{template}, (2) contextual
information associated both with the input and with the template is
retained in the output to support lexical scoping, and (3) the value
of a {\cf syntax} expression is a syntax object.

A \hyper{template} is a pattern variable, an identifier that
is not a pattern
variable, a pattern datum, or one of the following.

\begin{scheme}
(\hyper{subtemplate} \ldots)
(\hyper{subtemplate} \ldots . \hyper{template})
\#(\hyper{subtemplate} \ldots)%
\end{scheme}

A \hyper{subtemplate} is a \hyper{template} followed by zero or more ellipses.

The value of a {\cf syntax} form is a copy of \hyper{template} in which
the pattern variables appearing within the template are replaced with
the input subforms to which they are bound.
Pattern data and identifiers that are not pattern variables
or ellipses are copied directly into the output.
A subtemplate followed by an ellipsis expands
into zero or more occurrences of the subtemplate.
Pattern variables that occur in subpatterns followed by one or more
ellipses may occur only in subtemplates that are
followed by (at least) as many ellipses.
These pattern variables are replaced in the output by the input
subforms to which they are bound, distributed as specified.
If a pattern variable is followed by more ellipses in the subtemplate
than in the associated subpattern, the input form is replicated as
necessary.
The subtemplate must contain at least one pattern variable from a
subpattern followed by an ellipsis, and for at least one such pattern
variable, the subtemplate must be followed by exactly as many ellipses as
the subpattern in which the pattern variable appears.
(Otherwise, the expander would not be able to determine how many times the
subform should be repeated in the output.)
It is a syntax violation if the constraints of this paragraph are not met.

A template of the form
{\cf (\hyper{ellipsis} \hyper{template})} is identical to \hyper{template}, except that
ellipses within the template have no special meaning.
That is, any ellipses contained within \hyper{template} are
treated as ordinary identifiers.
In particular, the template {\cf (... ...)} produces a single
ellipsis.
This allows macro uses to expand into forms containing
ellipses.

% \label{wrappingrules}
The output produced by {\cf syntax} is wrapped or unwrapped according to
the following rules.

\begin{itemize}
\item the copy of {\cf (\hyperi{t} .  \hyperii{t})} is a pair if \hyperi{t}
      or \hyperii{t} contain any pattern variables,
\item the copy of {\cf (\hyper{t} \hyper{ellipsis})} is a list if \hyper{t}
      contains any pattern variables,
\item the copy of {\cf \#(\hyperi{t} ... \hypern{t})} is a vector if any of
      \hyperi{t},~\dots,~\hypern{t} contain any pattern variables, and
\item the copy of any portion of \hyper{t} not containing any pattern variables
      is a wrapped syntax object.
\end{itemize}

The input subforms inserted in place of the pattern variables are wrapped
if and only if the corresponding input subforms are wrapped.
\end{entry}

The following definitions of {\cf or} illustrate {\cf syntax-case}
and {\cf syntax}.
The second is equivalent to the first but uses the {\cf \#'}
prefix instead of the full {\cf syntax} form.

\begin{schemenoindent}
(define-syntax or
  (lambda (x)
    (syntax-case x ()
      [(\_) (syntax \schfalse{})]
      [(\_ e) (syntax e)]
      [(\_ e1 e2 e3 ...)
       (syntax (let ([t e1])
                 (if t t (or e2 e3 ...))))])))

(define-syntax or
  (lambda (x)
    (syntax-case x ()
      [(\_) \#'\schfalse{}]
      [(\_ e) \#'e]
      [(\_ e1 e2 e3 ...)
       \#'(let ([t e1])
           (if t t (or e2 e3 ...)))])))%
\end{schemenoindent}

The examples below define \emph{identifier macros\mainindex{identifier
  macro}}, macro uses
supporting keyword references that do not necessarily appear in the first
position of a list-structured form.
The second example uses {\cf make-variable-transformer} to handle the case
where the keyword appears on the left-hand side of a
{\cf set!} expression.

\begin{scheme}
(define p (cons 4 5))
(define-syntax p.car
  (lambda (x)
    (syntax-case x ()
      [(\_ . rest) \#'((car p) . rest)]
      [\_  \#'(car p)])))
p.car \ev 4
(set! p.car 15) \ev \exception{\&syntax}

(define p (cons 4 5))
(define-syntax p.car
  (make-variable-transformer
    (lambda (x)
      (syntax-case x (set!)
        [(set! \_ e) \#'(set-car! p e)]
        [(\_ . rest) \#'((car p) . rest)]
        [\_  \#'(car p)]))))
(set! p.car 15)
p.car           \ev 15
p               \ev (15 5)%
\end{scheme}

\section{Identifier predicates}
% \label{identifierpredicatessection}

\begin{entry}{%
\proto{identifier?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is an identifier, i.e., a
syntax object representing an identifier, and \schfalse{} otherwise.

The {\cf identifier?} procedure is often used within a fender to verify
that certain subforms of an input form are identifiers, as in the
definition of {\cf rec}, which creates self-contained
recursive objects, below.

\begin{scheme}
(define-syntax rec
  (lambda (x)
    (syntax-case x ()
      [(\_ x e)
       (identifier? \#'x)
       \#'(letrec ([x e]) x)])))

(map (rec fact
       (lambda (n)
         (if (= n 0)                 
             1
             (* n (fact (- n 1))))))
     '(1 2 3 4 5)) \lev (1 2 6 24 120)
 
(rec 5 (lambda (x) x)) \ev \exception{\&syntax}%
\end{scheme}
\end{entry}

The procedures {\cf bound-identifier=?} and {\cf free-\hp{}identifier=?}
each take two identifier arguments and return \schtrue{} if their
arguments are equivalent and \schfalse{} otherwise.
These predicates are used to compare identifiers according to their
\emph{intended use} as free references or bound identifiers in a given
context.

\begin{entry}{%
\proto{bound-identifier=?}{ \vari{id} \varii{id}}{procedure}}

\domain{\vari{Id} and \varii{id} must be identifiers.}
The procedure {\cf bound-\hp{}identifier=?} returns \schtrue{} if a
binding for one would capture a reference to the other in the output of
the transformer, assuming that the reference appears within the scope of
the binding, and \schfalse{} otherwise.
In general, two identifiers are {\cf bound-identifier=?} only if
both are present in the original program or both are introduced by the
same transformer application
(perhaps implicitly---see {\cf datum\coerce{}syntax}).
Operationally, two identifiers are
considered equivalent by {\cf bound-identifier=?} if and only if they
have the same name and same marks (section~\ref{hygienesection}).

The {\cf bound-identifier=?} procedure can be used for detecting
duplicate identifiers in a binding construct or for other
preprocessing of a binding construct that requires detecting instances
of the bound identifiers.
\end{entry}

\begin{entry}{%
\proto{free-identifier=?}{ \vari{id} \varii{id}}{procedure}}

\domain{\vari{Id} and \varii{id} must be identifiers.}
The {\cf free-identifier=?} procedure returns \schtrue{} if and
only if the two identifiers would resolve to the same binding if both were
to appear in the output of a transformer outside of any bindings inserted
by the transformer.
(If neither of two like-named identifiers resolves to a binding, i.e., both
are unbound, they are considered to resolve to the same binding.)
Operationally, two identifiers are considered equivalent by
{\cf free-identifier=?} if and only the topmost matching
substitution for each maps to the same binding (section~\ref{hygienesection})
or the identifiers have the same name and no matching substitution.

The {\cf syntax-case} and {\cf syntax-rules} forms internally use
{\cf free-identifier=?} to compare identifiers listed in the literals
list against input identifiers.

\begin{scheme}
(let ([fred 17])
  (define-syntax a
    (lambda (x)
      (syntax-case x ()
        [(\_ id) \sharpsign{}'(b id fred)])))
  (define-syntax b
    (lambda (x)
      (syntax-case x ()
        [(\_ id1 id2)
         \sharpsign{}`(list
             \sharpsign{},(free-identifier=? \sharpsign{}'id1 \sharpsign{}'id2)
             \sharpsign{},(bound-identifier=? \sharpsign{}'id1 \sharpsign{}'id2))])))
  (a fred)) \ev (\schtrue{} \schfalse{})%
\end{scheme}

The following definition of unnamed {\cf let}
uses {\cf bound-identifier=?} to detect duplicate identifiers.

\begin{schemenoindent}
(define-syntax let
  (lambda (x)
    (define unique-ids?
      (lambda (ls)
        (or (null? ls)
            (and (let notmem?
                        ([x (car ls)] [ls (cdr ls)])
                   (or (null? ls)
                       (and (not (bound-identifier=?
                                   x (car ls)))
                            (notmem? x (cdr ls)))))
                 (unique-ids? (cdr ls))))))
    (syntax-case x ()
      [(\_ ((i v) ...) e1 e2 ...)
       (unique-ids? \#'(i ...))
       \#'((lambda (i ...) e1 e2 ...) v ...)])))%
\end{schemenoindent}

The argument {\cf \#'(i ...)} to {\cf unique-ids?} is guaranteed
to be a list by the rules given in the description of {\cf syntax}
above.

With this definition of {\cf let}:

\begin{scheme}
(let ([a 3] [a 4]) (+ a a)) \lev \exception{\&syntax}%
\end{scheme}

However,

\begin{scheme}
(let-syntax
  ([dolet (lambda (x)
            (syntax-case x ()
              [(\_ b)
               \#'(let ([a 3] [b 4]) (+ a b))]))])
  (dolet a)) \lev 7%
\end{scheme}

since the identifier {\cf a} introduced by {\cf dolet}
and the identifier {\cf a} extracted from the input form are not
{\cf bound-identifier=?}.

The following definition of {\cf case} is equivalent to the one in
section~\ref{syntaxcasesection}.
Rather than including {\cf else} in the literals list as before,
this version explicitly tests for {\cf else} using
{\cf free-identifier=?}.

\begin{schemenoindent}
(define-syntax case
  (lambda (x)
    (syntax-case x ()
      [(\_ e0 [(k ...) e1 e2 ...] ...
              [else-key else-e1 else-e2 ...])
       (and (identifier? \#'else-key)
            (free-identifier=? \#'else-key \#'else))
       \#'(let ([t e0])
           (cond
             [(memv t '(k ...)) e1 e2 ...]
             ...
             [else else-e1 else-e2 ...]))]
      [(\_ e0 [(ka ...) e1a e2a ...]
              [(kb ...) e1b e2b ...] ...)
       \#'(let ([t e0])
           (cond
             [(memv t '(ka ...)) e1a e2a ...]
             [(memv t '(kb ...)) e1b e2b ...]
             ...))])))%
\end{schemenoindent}

With either definition of {\cf case}, {\cf else} is not
recognized as an auxiliary
keyword if an enclosing lexical binding for {\cf else} exists.
For example,

\begin{scheme}
(let ([else \schfalse{}])
  (case 0 [else (write "oops")])) \lev \exception{\&syntax}%
\end{scheme}

since {\cf else} is bound
lexically and is
therefore not the same {\cf else} that appears in the definition of
{\cf case}.
\end{entry}

\section{Syntax-object and datum conversions}
% \label{conversionssection}

\begin{entry}{%
\proto{syntax->datum}{ syntax-object}{procedure}}

Strips all syntactic information from a syntax
object and returns the corresponding Scheme datum.
\end{entry}

Identifiers stripped in this manner are converted to their symbolic
names, which can then be compared with {\cf eq?}.
Thus, a predicate {\cf symbolic-identifier=?} might be defined as follows.

\begin{scheme}
(define symbolic-identifier=?
  (lambda (x y)
    (eq? (syntax->datum x)
         (syntax->datum y))))%
\end{scheme}

% not be true with import alias and rename
%Two identifiers that are {\cf bound-identifier=?} or
%{\cf free-identifier=?} are {\cf symbolic-identifier=?}; in order to
%refer to the same binding, two identifiers must have the same name.
%The converse is not always true, since two identifiers may have
%the same name but different bindings.

\begin{entry}{%
\proto{datum->syntax}{ template-id datum}{procedure}}
\end{entry}

\domain{\var{Template-id} must be a
template identifier and \var{datum} should be a datum value.}
The {\cf datum->syntax} procedure returns a syntax-object representation of \var{datum} that
contains the same contextual information as
\var{template-id}, with the effect that the
syntax object behaves
as if it were introduced into the code when
\var{template-id} was introduced.

The {\cf datum\coerce{}syntax} procedure allows a transformer to ``bend'' lexical
scoping rules by creating \textit{implicit
  identifiers\mainindex{implicit identifier}}
that behave as if they were present in the input form,
thus permitting the definition of macros
that introduce visible bindings for or references to
identifiers that do not appear explicitly in the input form.
For example, the following defines a {\cf loop} expression that
uses this controlled form of identifier capture to
bind the variable {\cf break} to an escape procedure
within the loop body.
(The derived {\cf with-syntax} form is like {\cf let} but binds
pattern variables---see section~\ref{derivedsection}.)

\begin{scheme}
(define-syntax loop
  (lambda (x)
    (syntax-case x ()
      [(k e ...)
       (with-syntax
           ([break (datum->syntax \#'k 'break)])
         \#'(call-with-current-continuation
             (lambda (break)
               (let f () e ... (f)))))])))

(let ((n 3) (ls '()))
  (loop
    (if (= n 0) (break ls))
    (set! ls (cons 'a ls))
    (set! n (- n 1)))) \lev (a a a)%
\end{scheme}

Were {\cf loop} to be defined as

\begin{scheme}
(define-syntax loop
  (lambda (x)
    (syntax-case x ()
      [(\_ e ...)
       \#'(call-with-current-continuation
           (lambda (break)
             (let f () e ... (f))))])))%
\end{scheme}

the variable {\cf break} would not be visible in {\cf e \dots}.

The datum argument \var{datum} may also represent an arbitrary
Scheme form, as demonstrated by the following definition of
{\cf include}.

\begin{scheme}
(define-syntax include
  (lambda (x)
    (define read-file
      (lambda (fn k)
        (let ([p (open-file-input-port fn)])
          (let f ([x (get-datum p)])
            (if (eof-object? x)
                (begin (close-port p) '())
                (cons (datum->syntax k x)
                      (f (get-datum p))))))))
    (syntax-case x ()
      [(k filename)
       (let ([fn (syntax->datum \#'filename)])
         (with-syntax ([(exp ...)
                        (read-file fn \#'k)])
           \#'(begin exp ...)))])))%
\end{scheme}

{\cf (include "filename")} expands into a {\cf begin} expression
containing the forms found in the file named by
{\cf "filename"}.
For example, if the file {\cf flib.ss} contains
{\cf (define f (lambda (x) (g (* x x))))}, and the file
{\cf glib.ss} contains
{\cf (define g (lambda (x) (+ x x)))},
the expression

\begin{scheme}
(let ()
  (include "flib.ss")
  (include "glib.ss")
  (f 5))%
\end{scheme}

evaluates to {\cf 50}.

The definition of {\cf include} uses {\cf datum\coerce{}syntax} to convert
the objects read from the file into syntax objects in the proper
lexical context, so that identifier references and definitions within
those expressions are scoped where the {\cf include} form appears.

Using {\cf datum\coerce{}syntax}, it is even possible to break hygiene
entirely and write macros in the style of old Lisp macros.
The {\cf lisp-transformer} procedure defined below creates a transformer
that converts its input into a datum, calls the programmer's procedure on
this datum, and converts the result back into a syntax object scoped
where the original macro use appeared.

\begin{scheme}
(define lisp-transformer
  (lambda (p)
    (lambda (x)
      (syntax-case x ()
        [(kwd . rest)
         (datum\coerce{}syntax \#'kwd
           (p (syntax\coerce{}datum x)))]))))%
\end{scheme}

\section{Generating lists of temporaries}
% \label{generatingtemporariessection}

Transformers can introduce a fixed number of identifiers into their
output simply by naming each identifier.
In some cases, however, the number of identifiers to be introduced depends
upon some characteristic of the input expression.
A straightforward definition of {\cf letrec}, for example,
requires as many
temporary identifiers as there are binding pairs in the
input expression.
The procedure {\cf generate-temporaries} is used to construct
lists of temporary identifiers.

\begin{entry}{%
\proto{generate-temporaries}{ l}{procedure}}

\domain{\var{L} must be be a list or syntax object representing a list-structured
form; its contents are not important.}
The number of temporaries generated is the number of elements in \var{l}.
Each temporary is guaranteed to be unique, i.e., different from all other
identifiers.

A definition of {\cf letrec} equivalent to the one using
{\cf syntax-rules} given in report
appendix~\extref{report:derivedformsappendix}{Sample definitions for
derived forms} is shown below.

\begin{schemenoindent}
(define-syntax letrec
  (lambda (x)
    (syntax-case x ()
      ((\_ ((i e) ...) b1 b2 ...)
       (with-syntax
           (((t ...) (generate-temporaries \#'(i ...))))
         \#'(let ((i <undefined>) ...)
             (let ((t e) ...)
               (set! i t) ...
               (let () b1 b2 ...))))))))%
\end{schemenoindent}

This version uses {\cf generate-temporaries} instead of recursively defined
helper to generate the necessary temporaries.
\end{entry}

\section{Derived forms and procedures}
% \label{derivedsection}

The forms and procedures described in this section can be defined in
terms of the forms and procedures described in earlier sections of
this chapter.

\begin{entry}{%
\pproto{(with-syntax ((\hyper{pattern} \hyper{expression}) \dotsfoo) \hyper{body})}{\exprtype}}
\mainschindex{with-syntax}

The {\cf with-syntax} form is used to bind pattern variables,
just as {\cf let} is used to bind variables.
This allows a transformer to construct its output in separate
pieces, then put the pieces together.

Each \hyper{pattern} is identical in form to a {\cf syntax-case} pattern.
The value of each \hyper{expression} is computed and destructured according
to the corresponding \hyper{pattern}, and pattern variables within
the \hyper{pattern} are bound as with {\cf syntax-case} to the
corresponding portions of the value within \hyper{body}.

The {\cf with-syntax} form may be defined in terms of {\cf syntax-case} as
follows.

\begin{scheme}
(define-syntax with-syntax
  (lambda (x)
    (syntax-case x ()
      ((\_ ((p e0) ...) e1 e2 ...)
       (syntax (syntax-case (list e0 ...) ()
                 ((p ...) (let () e1 e2 ...))))))))%
\end{scheme}

The following definition of {\cf cond} demonstrates the use of
{\cf with-syntax} to support transformers that employ recursion
internally to construct their output.
It handles all {\cf cond} clause variations and takes care to produce
one-armed {\cf if} expressions where appropriate.

\begin{schemenoindent}
(define-syntax cond
  (lambda (x)
    (syntax-case x ()
      [(\_ c1 c2 ...)
       (let f ([c1 \#'c1] [c2* \#'(c2 ...)])
         (syntax-case c2* ()
           [()
            (syntax-case c1 (else =>)
              [(else e1 e2 ...) \#'(begin e1 e2 ...)]
              [(e0) \#'e0]
              [(e0 => e1)
               \#'(let ([t e0]) (if t (e1 t)))]
              [(e0 e1 e2 ...)
               \#'(if e0 (begin e1 e2 ...))])]
           [(c2 c3 ...)
            (with-syntax ([rest (f \#'c2 \#'(c3 ...))])
              (syntax-case c1 (=>)
                [(e0) \#'(let ([t e0]) (if t t rest))]
                [(e0 => e1)
                 \#'(let ([t e0]) (if t (e1 t) rest))]
                [(e0 e1 e2 ...)
                 \#'(if e0 
                        (begin e1 e2 ...)
                        rest)]))]))])))%
\end{schemenoindent}
\end{entry}

\begin{entry}{%
\proto{quasisyntax}{ \hyper{template}}{\exprtype}
\litproto{unsyntax}
\litproto{unsyntax-splicing}}

The {\cf quasisyntax} form is similar to {\cf syntax}, but it allows parts
of the quoted text to be evaluated, in a manner similar to the operation
of {\cf quasiquote} (report section~\extref{report:quasiquotesection}{Quasiquotation}).

Within a {\cf quasisyntax} \var{template}, subforms of
{\cf unsyntax} and {\cf unsyntax-splicing} forms are evaluated,
and everything else is treated as ordinary template material, as
with {\cf syntax}.
The value of each {\cf unsyntax} subform is inserted into the output
in place of the {\cf unsyntax} form, while the value of each
{\cf unsyntax-splicing} subform is spliced into the surrounding list
or vector structure.
Uses of {\cf unsyntax} and {\cf unsyntax-splicing} are valid only within
{\cf quasisyntax} expressions.

A {\cf quasisyntax} expression may be nested, with each {\cf quasisyntax}
introducing a new level of syntax quotation and each {\cf unsyntax} or
{\cf unsyntax-splicing} taking away a level of quotation.
An expression nested within $n$ {\cf quasisyntax} expressions must
be within $n$ {\cf unsyntax} or {\cf unsyntax-splicing} expressions to
be evaluated.

As noted in report section~\extref{report:abbreviationsection}{Abbreviations},
{\cf \#`\hyper{template}} is equivalent to {\cf (quasisyntax
  \hyper{template})}, {\cf \#,\hyper{template}} is equivalent to {\cf (unsyntax
  \hyper{template})}, and {\cf \#,@\hyper{template}} is equivalent to {\cf (unsyntax-splicing
  \hyper{template})}.

The {\cf quasisyntax} keyword can be used in place of {\cf with-syntax} in many
cases.
For example, the definition of {\cf case} shown under the description
of {\cf with-syntax} above can be rewritten using {\cf quasisyntax}
as follows.

\begin{schemenoindent}
(define-syntax case
  (lambda (x)
    (syntax-case x ()
      [(\_ e c1 c2 ...)
       \#`(let ([t e])
           \#,(let f ([c1 \#'c1] [cmore \#'(c2 ...)])
               (if (null? cmore)
                   (syntax-case c1 (else)
                     [(else e1 e2 ...)
                      \#'(begin e1 e2 ...)]
                     [((k ...) e1 e2 ...)
                      \#'(if (memv t '(k ...))
                            (begin e1 e2 ...))])
                   (syntax-case c1 ()
                     [((k ...) e1 e2 ...)
                      \#`(if (memv t '(k ...))
                            (begin e1 e2 ...)
                            \#,(f (car cmore)
                                  (cdr cmore)))]))))])))%
\end{schemenoindent}
                          
Uses of {\cf unsyntax} and {\cf unsyntax-splicing} with zero or more than
one subform are valid only in splicing (list or vector) contexts.
{\cf (unsyntax \var{template} \dotsfoo)} is equivalent to
{\cf (unsyntax \var{template}) \dots}, and
{\cf (unsyntax-splicing \var{template} \dotsfoo)} is equivalent to
{\cf (unsyntax-splicing \var{template}) \dots}.
These forms are primarily useful as intermediate forms in the output
of the {\cf quasisyntax} expander.

\begin{note}
Uses of {\cf unsyntax} and {\cf unsyntax-splicing} with 
zero or more than one subform enable certain 
idioms~\cite{bawdenquasiquote}, such as {\cf \#,@\#,@}, which has the
effect of a doubly indirect splicing when used within a doubly nested
and doubly evaluated {\cf quasisyntax} expression, as with the
nested {\cf quasiquote} examples shown in
section~\extref{report:quasiquotesection}{Quasiquotation}.
\end{note}
\end{entry}

\begin{note}
Any {\cf syntax-rules} form can be expressed with
{\cf syntax-case} by making the {\cf lambda} expression and
{\cf syntax} expressions explicit, and
{\cf syntax-rules} may be defined in terms of {\cf syntax-case}
as follows.

\begin{scheme}
(define-syntax syntax-rules
  (lambda (x)
    (syntax-case x ()
      [(\_ (lit ...) [(k . p) t] ...)
       (for-all identifier? \sharpsign{}'(lit ... k ...))
       \sharpsign{}'(lambda (x)
           (syntax-case x (lit ...)
             [(\_ . p) \sharpsign{}'t] ...))])))%
\end{scheme}
\end{note}

\begin{note}
The {\cf identifier-syntax} form of the base library (see
report section~\extref{report:identifier-syntax}{Macro transformers}) may be defined in terms of {\cf
  syntax-case}, {\cf syntax}, and {\cf make-variable-transformer} as
follows.

\begin{schemenoindent}
(define-syntax identifier-syntax
  (syntax-rules (set!)
    [(\_ e)
     (lambda (x)
       (syntax-case x ()
         [id (identifier? \#'id) \#'e]
         [(\_ x (... ...)) \#'(e x (... ...))]))]
    [(\_ (id exp1) ((set! var val) exp2))
     (and (identifier? \#'id) (identifier? \#'var))
     (make-variable-transformer
       (lambda (x)
         (syntax-case x (set!)
           [(set! var val) \#'exp2]
           [(id x (... ...)) \#'(exp1 x (... ...))]
           [id (identifier? \#'id) \#'exp1])))]))%
\end{schemenoindent}
\end{note}

\section{Syntax violations}

\begin{entry}{%
\proto{syntax-violation}{ who message form}{procedure}
\rproto{syntax-violation}{ who message form subform}{procedure}}

\domain{\var{Who} must be \schfalse{} or a string or a symbol.
  \var{Message} must be a string.
  \var{Form} must be a syntax object or a datum value.
  \var{Subform} must be a syntax object or a datum value.}
The {\cf syntax-violation} procedure raises an exception, reporting 
a syntax violation.  
\var{Who} should describe the macro transformer that
detected the exception.  The \var{message} argument should describe
the violation.
\var{Form} should be the erroneous source syntax
object or a datum value representing a form. The optional
\var{subform} argument should be a syntax
object or datum value representing a form that more precisely locates the
violation.

If \var{who} is \schfalse{}, {\cf syntax-violation} attempts to
infer an appropriate value for the condition object (see below) as
follows:  When \var{form} is either an identifier or a
list-structured syntax object containing an identifier as its first element, then
the inferred value is the identifier's symbol.
Otherwise, no value for \var{who} is provided as part of the
condition object.

The condition object provided with the exception (see
chapter~\ref{exceptionsconditionschapter}) has the following condition types:
%
\begin{itemize}
\item If \var{who} is not \schfalse{} or can be inferred, the condition has condition type
  {\cf \&who}, with \var{who} as the value of its field.  In
  that case, \var{who} should identify the procedure or entity that
  detected the exception.  If it is \schfalse, the condition does not
  have condition type {\cf \&who}.
\item The condition has condition type {\cf \&message}, with
  \var{message} as the value of its field.
\item The condition has condition type {\cf \&syntax} 
  with \var{form} and \var{subform} as the value of its fields.
  If \var{subform} is not provided, the value of the subform
  field is \schfalse.
\end{itemize}
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   41: hashtable.tex}
\chapter{Hashtables}
% \label{hashtablechapter}

The \defrsixlibrary{hashtables} library provides a set of operations on
hashtables.
A \defining{hashtable} is a data structure that associates keys with values.
Any object can be used as a key, provided a \defining{hash function}
and a suitable \defining{equivalence function} is available.  A hash function is a
procedure that maps
keys to exact integer objects.
It is the programmer's responsibility to ensure that the hash function
is compatible with the equivalence function,
which is a procedure that accepts two keys and returns true if they
are equivalent and \schfalse{} otherwise.
Standard hashtables for arbitrary objects based on the {\cf eq?} and 
{\cf eqv?} predicates (see report section~\extref{report:equivalencesection}{Equivalence predicates}) are provided.  
Also, hash functions for arbitrary objects, strings, and symbols are provided.

This section uses the \var{hashtable} parameter name for arguments
that must be hashtables, and the \var{key} parameter name for
arguments that must be hashtable keys.

\section{Constructors}

\mainindex{hashtable}

\begin{entry}{%
\proto{make-eq-hashtable}{}{procedure}
\rproto{make-eq-hashtable}{ \var{k}}{procedure}}

Returns a newly allocated mutable hashtable that accepts
arbitrary objects as keys,
and compares those keys with {\cf eq?}. If an argument is given, the initial 
capacity of the hashtable is set to approximately \var{k} elements.

\end{entry}

\begin{entry}{%
\proto{make-eqv-hashtable}{}{procedure}
\rproto{make-eqv-hashtable}{ \var{k}}{procedure}}

Returns a newly allocated mutable hashtable that accepts
arbitrary objects as keys,
and compares those keys with {\cf eqv?}.
If an argument is given, the initial 
capacity of the hashtable is set to approximately \var{k} elements.

\end{entry}

\begin{entry}{%
\proto{make-hashtable}{ \var{hash-function} \var{equiv}}{procedure}
\rproto{make-hashtable}{ \var{hash-function} \var{equiv} \var{k}}{procedure}}

\domain{\var{Hash-function} and \var{equiv} must be procedures.
\var{Hash-function} should accept a key as an argument and should return a 
non-negative exact integer object.
\var{Equiv} should accept two keys as arguments and return a single
value.
Neither procedure should mutate the hashtable returned by {\cf make-hashtable}.}
The {\cf make-hashtable} procedure returns a newly allocated mutable
hashtable using \var{hash-function} 
as the hash function and \var{equiv} as the equivalence function used to 
compare keys.
If a third argument is given, the 
initial capacity of the hashtable is set to approximately \var{k} elements.

Both \var{hash-function} and \var{equiv} should behave like pure functions
on the domain of keys.  For example, the {\cf string-hash}
and {\cf string=?} procedures are permissible only if all
keys are strings and the contents of those strings are never
changed so long as any of them continues to serve as a key in
the hashtable.  Furthermore, any pair of keys for which
\var{equiv} returns true should
be hashed to the same exact integer objects by 
\var{hash-function}.

\implresp The implementation must check the restrictions on
\var{hash-function} and \var{equiv} to the extent performed by
applying them as described.

\begin{note}
Hashtables are allowed to cache the results of calling the
hash function and equivalence function, so programs cannot
rely on the hash function being called for every lookup or
update.  Furthermore any hashtable operation may call the
hash function more than once.
\end{note}

\end{entry}

\section{Procedures}

\begin{entry}{%
\proto{hashtable?}{ \var{hashtable}}{procedure}}

Returns \schtrue{} if \var{hashtable} is a hashtable,
\schfalse{} otherwise.
\end{entry}

\begin{entry}{\proto{hashtable-size}{ \var{hashtable}}{procedure}}

Returns the number of keys contained in \var{hashtable} as an exact
integer object.
\end{entry}

\begin{entry}{%
\proto{hashtable-ref}{ \var{hashtable} \var{key} \var{default}}{procedure}}

Returns the value in \var{hashtable} associated with \var{key}.
If \var{hashtable} does not contain an association for \var{key},
\var{default} is returned.
\end{entry}

\begin{entry}{\proto{hashtable-set!}{ \var{hashtable} \var{key} \var{obj}}{procedure}}

Changes \var{hashtable} to associate \var{key} with \var{obj},
adding a new association or replacing any existing association for \var{key},
and returns \unspecifiedreturn.
\end{entry}

\begin{entry}{\proto{hashtable-delete!}{ \var{hashtable} \var{key}}{procedure}}

Removes any association for \var{key} within \var{hashtable} and
returns \unspecifiedreturn.
\end{entry}

\begin{entry}{\proto{hashtable-contains?}{ \var{hashtable} \var{key}}{procedure}}

Returns \schtrue{} if \var{hashtable} contains an association
for \var{key}, \schfalse{} otherwise.
\end{entry}

\begin{entry}{%
\proto{hashtable-update!}{ \var{hashtable} \var{key} \var{proc} \var{default}}{procedure}}

\domain{\var{Proc} should accept one argument,
should return a single value, and should not mutate \var{hashtable}.}
The {\cf hashtable-update!} procedure applies \var{proc} to the value in \var{hashtable}
associated with \var{key}, 
or to \var{default} if \var{hashtable} does not contain an
association for \var{key}.
The \var{hashtable} is then changed to associate \var{key}
with the value returned by \var{proc}.

The behavior of {\cf hashtable-update!} is equivalent to the
following code, but may be implemented 
more efficiently in cases where the implementation can
avoid multiple lookups of the same key:
\begin{scheme}
(hashtable-set!
  hashtable key
  (proc (hashtable-ref
         hashtable key default)))
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{hashtable-copy}{ \var{hashtable}}{procedure}
\rproto{hashtable-copy}{ \var{hashtable} \var{mutable}}{procedure}}

Returns a copy of \var{hashtable}.  If the
\var{mutable} argument is provided and is true, the returned hashtable is mutable;
otherwise it is immutable.

\end{entry}
\begin{entry}{%
\proto{hashtable-clear!}{ \var{hashtable}}{procedure}
\rproto{hashtable-clear!}{ \var{hashtable} \var{k}}{procedure}}

Removes all associations from \var{hashtable} and returns \unspecifiedreturn.

If a second argument is given, the current
capacity of the hashtable is reset to approximately \var{k} elements.
\end{entry}

\begin{entry}{\proto{hashtable-keys}{ \var{hashtable}}{procedure}}

Returns a vector of all keys in \var{hashtable}.
The order of the vector is unspecified.
\end{entry}

\begin{entry}{%
\proto{hashtable-entries}{ \var{hashtable}}{procedure}}

Returns two values, a vector of the keys in \var{hashtable}, and a
vector of the corresponding values.

\begin{scheme}
(let ((h (make-eqv-hashtable)))
  (hashtable-set! h 1 'one)
  (hashtable-set! h 2 'two)
  (hashtable-set! h 3 'three)
  (hashtable-entries h)) \lev \sharpsign(1 2 3) \sharpsign(one two three)\\\>; \textrm{two return values}%
\end{scheme}
\end{entry}

\section{Inspection}

\begin{entry}{\proto{hashtable-equivalence-function}{ \var{hashtable}}{procedure}}

Returns the equivalence function used by
\var{hashtable} to compare keys.  For hashtables
created with {\cf make-eq-hashtable} and {\cf make-eqv-hashtable},
returns {\cf eq?} and {\cf eqv?} respectively.
\end{entry}

\begin{entry}{\proto{hashtable-hash-function}{ \var{hashtable}}{procedure}}

Returns the hash function used by \var{hashtable}.
For hashtables created by {\cf make-eq-hashtable} 
or {\cf make-\hp{}eqv-\hp{}hashtable}, \schfalse{} is returned.
\end{entry}

\begin{entry}{\proto{hashtable-mutable?}{ \var{hashtable}}{procedure}}

Returns \schtrue{} if \var{hashtable} is mutable, otherwise \schfalse{}.
\end{entry}

\section{Hash functions}

The {\cf equal-hash}, {\cf string-hash}, and {\cf string-ci-hash}
procedures of this section are acceptable as the hash functions of
a hashtable only if the keys on which they are called are not mutated
while they remain in use as keys in the hashtable.

\begin{entry}{\proto{equal-hash}{ \var{obj}}{procedure}}

Returns an integer hash value for \var{obj}, based on
its structure and current contents.  This hash function is suitable
for use with {\cf equal?} as an equivalence function.

\begin{note}
  Like {\cf equal?}, the {\cf equal-hash} procedure must always
  terminate, even if its arguments contain cycles.
\end{note}
\end{entry}

\begin{entry}{\proto{string-hash}{ \var{string}}{procedure}}

Returns an integer hash value for \var{string}, based on
its current contents.
This hash function is suitable
for use with {\cf string=?} as an equivalence function.
\end{entry}

\begin{entry}{\proto{string-ci-hash}{ \var{string}}{procedure}}

Returns an integer hash value for \var{string} based on
its current contents, ignoring case.
This hash function is suitable
for use with {\cf string-ci=?} as an equivalence function.
\end{entry}

\begin{entry}{\proto{symbol-hash}{ \var{symbol}}{procedure}}

Returns an integer hash value for \var{symbol}.
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   42: enum.tex}
\chapter{Enumerations}
% \label{enumerationschapter}

This chapter describes the \defrsixlibrary{enums} library for dealing with enumerated values
\mainindex{enumeration}and sets of enumerated values.  Enumerated
values are represented by ordinary symbols, while finite sets of
enumerated values form a separate type, known as the
\defining{enumeration sets}.
The enumeration sets are further partitioned into sets that
share the same \defining{universe} and \defining{enumeration type}.
These universes and enumeration types are created by the
{\cf make-enumeration} procedure.  Each call to that procedure
creates a new enumeration type.

This library interprets each enumeration set with respect to
its specific universe of symbols and enumeration type.
This facilitates efficient implementation of enumeration sets
and enables the complement operation.

In the descriptions of the following procedures, \var{enum-set}
ranges over the enumeration sets, which are defined as the subsets
of the universes that can be defined using {\cf make-enumeration}.

\begin{entry}{%
\proto{make-enumeration}{ symbol-list}{procedure}}

\domain{\var{Symbol-list} must be a list of symbols.}
The {\cf make-\hp{}enumeration} procedure
creates a new enumeration type whose universe consists of
those symbols (in canonical order of their first appearance
in the list) and returns that universe as an enumeration
set whose universe is itself and whose enumeration type is
the newly created enumeration type.
\end{entry}

\begin{entry}{%
\proto{enum-set-universe}{ enum-set}{procedure}}

Returns the set of all symbols that comprise
the universe of its argument, as an enumeration set.
\end{entry}

\begin{entry}{%
\proto{enum-set-indexer}{ enum-set}{procedure}}

Returns a unary procedure that, given a symbol
that is in the universe of \var{enum-set}, returns its 0-origin index
within the canonical ordering of the symbols in the universe; given a
value not in the universe, the unary procedure returns \schfalse.

\begin{scheme}
(let* ((e (make-enumeration '(red green blue)))
       (i (enum-set-indexer e)))
  (list (i 'red) (i 'green) (i 'blue) (i 'yellow))) \lev (0 1 2 \schfalse)%
\end{scheme}

The {\cf enum-set-indexer} procedure could be defined as follows using the
{\cf memq} procedure from the \rsixlibrary{lists} library:

\begin{scheme}
(define (enum-set-indexer set)
  (let* ((symbols (enum-set->list
                    (enum-set-universe set)))
         (cardinality (length symbols)))
    (lambda (x)
      (cond
       ((memq x symbols)
        => (lambda (probe)
             (- cardinality (length probe))))
       (else \schfalse)))))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{enum-set-constructor}{ enum-set}{procedure}}

Returns a unary procedure that, given a
list of symbols that belong to the universe of \var{enum-set}, returns
a subset of that universe that contains exactly the symbols in the
list.  The values in the list must all belong to the universe.
\end{entry}

\begin{entry}{%
\proto{enum-set->list}{ enum-set}{procedure}}

Returns a list of the symbols that belong to its
argument, in the canonical order of the universe of \var{enum-set}.

\begin{scheme}
(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (enum-set->list (c '(blue red)))) \lev (red blue)
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{enum-set-member?}{ symbol enum-set}{procedure}
\proto{enum-set-subset?}{ \vari{enum-set} \varii{enum-set}}{procedure}
\proto{enum-set=?}{ \vari{enum-set} \varii{enum-set}}{procedure}}

The {\cf enum-set-member?} procedure returns \schtrue{} if its first argument is an
element of its second argument, \schfalse{} otherwise.

The {\cf enum-set-subset?} procedure returns \schtrue{} if the universe of
\vari{enum-set} is a subset of the universe of \varii{enum-set}
(considered as sets of symbols) and every element of \vari{enum-set}
is a member of \varii{enum-set}.  It returns \schfalse{} otherwise.

The {\cf enum-set=?} procedure returns \schtrue{} if \vari{enum-set}  is a
subset of \varii{enum-set} and vice versa, as determined by the
{\cf enum-set-subset?} procedure.  This implies that the universes of
the two sets are equal as sets of symbols, but does not imply
that they are equal as enumeration types.  Otherwise, \schfalse{} is
returned.

\begin{schemenoindent}
(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (list
   (enum-set-member? 'blue (c '(red blue)))
   (enum-set-member? 'green (c '(red blue)))
   (enum-set-subset? (c '(red blue)) e)
   (enum-set-subset? (c '(red blue)) (c '(blue red)))
   (enum-set-subset? (c '(red blue)) (c '(red)))
   (enum-set=? (c '(red blue)) (c '(blue red)))))
\ev (\schtrue{} \schfalse{} \schtrue{} \schtrue{} \schfalse{} \schtrue{})%
\end{schemenoindent}
\end{entry}

\begin{entry}{%
\proto{enum-set-union}{ \vari{enum-set} \varii{enum-set}}{procedure}
\proto{enum-set-intersection}{ \vari{enum-set} \varii{enum-set}}{procedure}
\proto{enum-set-difference}{ \vari{enum-set} \varii{enum-set}}{procedure}}


\domain{\vari{Enum-set} and \varii{enum-set} must be enumeration sets 
  that have the same enumeration type.}

The {\cf enum-set-union} procedure returns the union of \vari{enum-set} and \varii{enum-set}.
The {\cf enum-set-intersection} procedure returns the intersection of \vari{enum-set} and \varii{enum-set}.
The {\cf enum-set-difference} procedure returns the difference of \vari{enum-set}
and \varii{enum-set}.

\begin{scheme}
(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (list (enum-set->list
         (enum-set-union (c '(blue)) (c '(red))))
        (enum-set->list
         (enum-set-intersection (c '(red green))
                                (c '(red blue))))
        (enum-set->list
         (enum-set-difference (c '(red green))
                              (c '(red blue))))))
\lev ((red blue) (red) (green))
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{enum-set-complement}{ enum-set}{procedure}}

Returns \var{enum-set}'s
complement with respect to its universe.


\begin{scheme}
(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (enum-set->list
    (enum-set-complement (c '(red)))))
\ev (green blue)
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{enum-set-projection}{ \vari{enum-set} \varii{enum-set}}{procedure}}

Projects \vari{enum-set} into the universe
of \varii{enum-set}, dropping any elements of \vari{enum-set} that do
not belong to the universe of \varii{enum-set}.  (If \vari{enum-set}
is a subset of the universe of its second, no elements are
dropped, and the injection is returned.)

\begin{scheme}
(let ((e1 (make-enumeration
            '(red green blue black)))
      (e2 (make-enumeration
            '(red black white))))
  (enum-set->list
    (enum-set-projection e1 e2))))
\ev (red black)
\end{scheme}
\end{entry}

\begin{entry}{}
\pproto{(define-enumeration \hyper{type-name}}{\exprtype}
\mainschindex{define-enumeration}{\tt\obeyspaces%
  (\hyper{symbol} \dotsfoo)\\
  \hyper{constructor-syntax})}

The {\cf define-enumeration} form defines an enumeration type and
provides two macros for constructing its members and sets of its
members.

A {\cf define-enumeration} form is a definition and can appear
anywhere any other \hyper{definition} can appear.

\hyper{Type-name} is an identifier that is bound as a syntactic keyword;
\hyper{symbol}~\dotsfoo{} are the symbols that comprise the
universe of the enumeration (in order).

{\cf (\hyper{type-name} \hyper{symbol})} checks at macro-expansion
time whether the name of \hyper{symbol} is in the universe associated with
\hyper{type-name}.  If it is, {\cf (\hyper{type-name}
  \hyper{symbol})} is equivalent to {\cf \hyper{symbol}}.  
It is a syntax violation if it is not.

\hyper{Constructor-syntax} is an identifier that is bound to a
macro that, given any finite sequence of the symbols in the universe,
possibly with duplicates, expands into an expression that evaluates
to the enumeration set of those symbols.

{\cf (\hyper{constructor-syntax} \hyper{symbol}~\dotsfoo{})} checks at
macro-expansion time whether every \hyper{symbol}~\dotsfoo{} is in the
universe associated with \hyper{type-name}.  It is a syntax violation
if one or more is not.
Otherwise
\begin{scheme}
(\hyper{constructor-syntax} \hyper{symbol}~\dotsfoo{})
\end{scheme}
%
is equivalent to
%
\begin{scheme}
((enum-set-constructor (\hyper{constructor-syntax}))
 '(\hyper{symbol}~\dotsfoo{}))\rm.
\end{scheme}

Example:

\begin{scheme}
(define-enumeration color
  (black white purple maroon)
  color-set)

(color black)                      \ev black
(color purpel)                     \ev \exception{\&syntax}
(enum-set->list (color-set))       \ev ()
(enum-set->list
  (color-set maroon white))        \ev (white maroon)
\end{scheme}

\begin{note}
  In {\cf (\hyper{type-name} \hyper{symbol})} and {\cf
    (\hyper{constructor-syntax} \hyper{symbol}~\dotsfoo{})} forms,
  only the names of the \hyper{symbol}s are significant.
\end{note}
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   43: complib.tex}
\chapter{Composite library}
% \label{complibchapter}

The \defthersixlibrary{} library is a composite of most of the libraries
described in this report.  The only exceptions are:
%
\begin{itemize}
\item \rsixlibrary{eval} (chapter~\ref{eval})
\item \rsixlibrary{mutable-pairs} (chapter~\ref{pairmutationchapter})
\item \rsixlibrary{mutable-strings} (chapter~\ref{stringmutationchapter})
\item \rsixlibrary{r5rs} (chapter~\ref{r5rscompatchapter})
\end{itemize}
%
The library exports all procedures and syntactic forms provided by the
component libraries.

All of the bindings exported by \thersixlibrary{} are exported for both {\cf run}
and {\cf expand}; see report section~\extref{report:phasessection}{Import and export levels}.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   44: eval.tex}
\chapter{\tt{eval}}
% \label{evalchapter}

The \rsixlibrary{eval} library allows a program to create Scheme
expressions as data at run time and evaluate them.

\begin{entry}{%
\proto{eval}{ expression environment}{procedure}}

Evaluates \var{expression} in the specified environment and returns its value.
\var{Expression} must be a syntactically valid Scheme expression represented as a
datum value, and \var{environment} must be an
\defining{environment}, which can be created using the {\cf
  environment} procedure described below.

If the first argument to {\cf eval} is determined not to be a syntactically correct
expression, then {\cf eval} must raise an exception with condition
type {\cf \&syntax}.  Specifically, if the first argument to {\cf
  eval} is a definition or a splicing {\cf begin} form containing a
definition, it must raise an exception with condition type {\cf
  \&syntax}.
\end{entry}

\begin{entry}{%
\proto{environment}{ import-spec \dots}{procedure}}

\domain{\var{Import-spec} must be a datum representing an
  \hyper{import spec} (see report
  section~\extref{report:librarysyntaxsection}{Library form}).}
The {\cf environment} procedure returns an environment corresponding
to \var{import-spec}.

The bindings of the environment represented by the specifier are
immutable: If {\cf eval} is applied to an expression that is
determined to contain an
assignment to one of the variables of the environment, then {\cf eval} must
raise an exception with a condition type {\cf\&assertion}.

\begin{scheme}
(library (foo)
  (export)
  (import (rnrs))
  (write
    (eval '(let ((x 3)) x)
          (environment '(rnrs))))) \\\> {\it writes} 3

(library (foo)
  (export)
  (import (rnrs))
  (write
    (eval
      '(eval:car (eval:cons 2 4))
      (environment
        '(prefix (only (rnrs) car cdr cons null?)
                 eval:))))) \\\> {\it writes} 2
\end{scheme}
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   45: setcar.tex}
\chapter{Mutable pairs}
% \label{pairmutationchapter}

The procedures provided by the \defrsixlibrary{mutable-pairs} library
allow new values to be assigned to the car and cdr fields of
previously allocated pairs.  

\begin{entry}{%
\proto{set-car!}{ pair obj}{procedure}}

Stores \var{obj} in the car field of \var{pair}.
The {\cf set-car!} procedure returns \unspecifiedreturn.

\begin{scheme}
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3)             \ev  \theunspecified
(set-car! (g) 3)             \ev  \unspecified\\\>; \textrm{should raise} \exception{\&assertion}
\end{scheme}

If an immutable pair is passed to {\cf set-car!}, an exception
with condition type {\cf\&assertion} should be raised.
\end{entry}


\begin{entry}{%
\proto{set-cdr!}{ pair obj}{procedure}}

Stores \var{obj} in the cdr field of \var{pair}.
The {\cf set-cdr!} procedure returns \unspecifiedreturn.


If an immutable pair is passed to {\cf set-cdr!}, an exception
with condition type {\cf\&assertion} should be raised.

\begin{scheme}
(let ((x (list 'a 'b 'c 'a))
      (y (list 'a 'b 'c 'a 'b 'c 'a)))
  (set-cdr! (list-tail x 2) x)
  (set-cdr! (list-tail y 5) y)
  (list
   (equal? x x)
   (equal? x y)
   (equal? (list x y 'a) (list y x 'b)))) \lev  (\schtrue{} \schtrue{} \schfalse{})
\end{scheme}
\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   46: stringset.tex}
\chapter{Mutable strings}
% \label{stringmutationchapter}

The {\cf string-set!} procedure provided by the \defrsixlibrary{mutable-strings}
library allows mutating the characters of a string in-place.

\begin{entry}{%
\proto{string-set!}{ string k char}{procedure}}

\domain{%\var{string} must be a string, 
\vr{K} must be a valid index of \var{string}%, and \var{char} must be a character
.}
The {\cf string-set!} procedure stores \var{char} in element \vr{k} of \var{string}
and returns \unspecifiedreturn.  % <!>

Passing an immutable string to {\cf string-set!} should cause an exception
with condition type {\cf\&assertion} to be raised.
\begin{scheme}
(define (f) (make-string 3 \sharpsign\backwhack{}*))
(define (g) "***")
(string-set! (f) 0 \sharpsign\backwhack{}?)  \ev  \theunspecified
(string-set! (g) 0 \sharpsign\backwhack{}?)  \ev  \unspecified
             ; \textrm{should raise \exception{\&assertion}}
(string-set! (symbol->string 'immutable)
             0
             \sharpsign\backwhack{}?)  \ev  \unspecified
             ; \textrm{should raise \exception{\&assertion}}%
\end{scheme}

\begin{note}
  Implementors should make {\cf string-set!} run in constant
  time.
\end{note}
\end{entry}

\begin{entry}{%
\proto{string-fill!}{ string char}{procedure}}

Stores \var{char} in every element of the given \var{string} and returns \unspecifiedreturn.  % <!>

\end{entry}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   47: r5rscompat.tex}
\chapter{R$^5$RS compatibility}
% \label{r5rscompatchapter}

The features described in this chapter are exported from the
\defrsixlibrary{r5rs} library and provide some functionality of the
preceding revision of this report~\cite{R5RS} that was omitted from
the main part of the current report.

\begin{entry}{%
\proto{exact->inexact}{ z}{procedure}
\proto{inexact->exact}{ z}{procedure}}

These are the same as the {\cf inexact} and {\cf exact}
procedures; see report section~\extref{report:inexact}{Generic conversions}.
\end{entry}

\begin{entry}{%
\proto{quotient}{ \vari{n} \varii{n}}{procedure}
\proto{remainder}{ \vari{n} \varii{n}}{procedure}
\proto{modulo}{ \vari{n} \varii{n}}{procedure}}

These procedures implement number-theoretic (integer)
division.  \varii{N} must be non-zero.  All three procedures
return integer objects.  If \vari{n}/\varii{n} is an integer object:
\begin{scheme}
    (quotient \vari{n} \varii{n})   \ev \vari{n}/\varii{n}
    (remainder \vari{n} \varii{n})  \ev 0
    (modulo \vari{n} \varii{n})     \ev 0
\end{scheme}
If \vari{n}/\varii{n} is not an integer object:
\begin{scheme}
    (quotient \vari{n} \varii{n})   \ev \var{n$_q$}
    (remainder \vari{n} \varii{n})  \ev \var{n$_r$}
    (modulo \vari{n} \varii{n})     \ev \var{n$_m$}
\end{scheme}
where \var{n$_q$} is $\vari{n}/\varii{n}$ rounded towards zero,
$0 < |\var{n$_r$}| < |\varii{n}|$, $0 < |\var{n$_m$}| < |\varii{n}|$,
\var{n$_r$} and \var{n$_m$} differ from \vari{n} by a multiple of \varii{n},
\var{n$_r$} has the same sign as \vari{n}, and
\var{n$_m$} has the same sign as \varii{n}.

Consequently, for integer objects \vari{n} and \varii{n} with
\varii{n} not equal to 0,
\begin{scheme}
     (= \vari{n} (+ (* \varii{n} (quotient \vari{n} \varii{n}))
           (remainder \vari{n} \varii{n})))
                                 \ev  \schtrue%
\end{scheme}
provided all number object involved in that computation are exact.

\begin{scheme}
(modulo 13 4)           \ev  1
(remainder 13 4)        \ev  1

(modulo -13 4)          \ev  3
(remainder -13 4)       \ev  -1

(modulo 13 -4)          \ev  -3
(remainder 13 -4)       \ev  1

(modulo -13 -4)         \ev  -1
(remainder -13 -4)      \ev  -1

(remainder -13 -4.0)    \ev  -1.0%
\end{scheme}

\begin{note}
  These procedures could be defined in terms of {\cf div} and {\cf
    mod} (see report section~\extref{report:div}{Arithmetic operations}) as follows (without checking of the
  argument types):
\begin{scheme}
(define (sign n)
  (cond
    ((negative? n) -1)
    ((positive? n) 1)
    (else 0)))

(define (quotient n1 n2)
  (* (sign n1) (sign n2) (div (abs n1) (abs n2))))

(define (remainder n1 n2)
  (* (sign n1) (mod (abs n1) (abs n2))))

(define (modulo n1 n2)
  (* (sign n2) (mod (* (sign n2) n1) (abs n2))))
\end{scheme}
\end{note}
\end{entry}

\begin{entry}{%
\proto{delay}{ \hyper{expression}}{\exprtype}}

The {\cf delay} construct is used together with the procedure \ide{force} to
implement \defining{lazy evaluation} or \defining{call by need}.
{\tt(delay~\hyper{expression})} returns an object called a
\defining{promise} which at some point in the future may be asked (by
the {\cf force} procedure) to evaluate
\hyper{expression}, and deliver the resulting value.
The effect of \hyper{expression} returning multiple values
is unspecified.

\end{entry}

\begin{entry}{%
\proto{force}{ promise}{procedure}}

{\var{Promise} must be a promise.}
The {\cf force} procedure forces the value of \var{promise}.  If no value has been computed for
the promise, then a value is computed and returned.  The value of the
promise is cached (or ``memoized'') so that if it is forced a second
time, the previously computed value is returned.

\begin{scheme}
(force (delay (+ 1 2)))   \ev  3
(let ((p (delay (+ 1 2))))
  (list (force p) (force p)))  
                               \ev  (3 3)

(define a-stream
  (letrec ((next
            (lambda (n)
              (cons n (delay (next (+ n 1)))))))
    (next 0)))
(define head car)
(define tail
  (lambda (stream) (force (cdr stream))))

(head (tail (tail a-stream)))  
                               \ev  2%
\end{scheme}

Promises are mainly intended for programs written in
functional style.  The following examples should not be considered to
illustrate good programming style, but they illustrate the property that
only one value is computed for a promise, no matter how many times it is
forced.

\begin{scheme}
(define count 0)
(define p
  (delay (begin (set! count (+ count 1))
                (if (> count x)
                    count
                    (force p)))))
(define x 5)
p                     \ev  {\it{}a promise}
(force p)             \ev  6
p                     \ev  {\it{}a promise, still}
(begin (set! x 10)
       (force p))     \ev  6%
\end{scheme}

Here is a possible implementation of {\cf delay} and {\cf force}.
Promises are implemented here as procedures of no arguments,
and {\cf force} simply calls its argument:

\begin{scheme}
(define force
  (lambda (object)
    (object)))%
\end{scheme}

The expression

\begin{scheme}
(delay \hyper{expression})%
\end{scheme}

has the same meaning as the procedure call

\begin{scheme}
(make-promise (lambda () \hyper{expression}))%
\end{scheme}

as follows

\begin{scheme}
(define-syntax delay
  (syntax-rules ()
    ((delay expression)
     (make-promise (lambda () expression))))),%
\end{scheme}

where {\cf make-promise} is defined as follows:

\begin{scheme}
(define make-promise
  (lambda (proc)
    (let ((result-ready? \schfalse)
          (result \schfalse))
      (lambda ()
        (if result-ready?
            result
            (let ((x (proc)))
              (if result-ready?
                  result
                  (begin (set! result-ready? \schtrue)
                         (set! result x)
                         result))))))))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{null-environment}{ n}{procedure}}

\domain{\var{N} must be the exact integer object 5.}  The {\cf
  null-environment} procedure returns an
environment specifier suitable for use with {\cf eval} (see
chapter~\ref{evalchapter}) representing an environment that is empty except
for the (syntactic) bindings for all keywords described in
the previous revision of this report~\cite{R5RS}, including bindings
for {\cf =>}, {\cf ...}, {\cf else}, and {\cf\_} that are the same as those in
the \rsixlibrary{base} library.
\end{entry}

\begin{entry}{%
\proto{scheme-report-environment}{ n}{procedure}}

\domain{\var{N} must be the exact integer object 5.}  The {\cf scheme-report-environment} procedure returns
an environment specifier for an environment that is empty except for
the bindings for the identifiers described in the previous
revision of this report~\cite{R5RS}, omitting {\cf load}, {\cf
  interaction-environment}, {\cf
  transcript-on}, {\cf transcript-off}, and {\cf char-ready?}.  The
variable bindings have as values the procedures of the same names described in
this report, and the keyword bindings, including
{\cf =>}, {\cf ...}, {\cf else}, and {\cf\_} are the same as those described
in this report.
\end{entry}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "r6rs-lib"
%%% End: 


\part{ðŸ“œ File   48: r6rs-rationale.tex}
\documentclass[twoside,twocolumn]{algol60}
%\documentclass[twoside]{algol60}

\pagestyle{headings} 
\showboxdepth=0
\makeindex
\input{commands}

\newcommand{\rn}[1]{R$^{#1}$RS}
\newcommand{\rsix}{\rn{6}}

\texonly
\externaldocument[report:]{r6rs}
\externaldocument[lib:]{r6rs-lib}
\externaldocument[app:]{r6rs-app}
\endtexonly

\def\headertitle{Revised$^{\rnrsrevision}$ Scheme Rationale}
\def\TZPtitle{Revised^\rnrsrevision{} Report on the Algorithmic Language Scheme - Non-Normative Appendices -}

\begin{document}

\thispagestyle{empty}

\topnewpage[{
\begin{center}   {\huge\bf
        Revised{\Huge$^{\mathbf{\htmlonly\tiny\endhtmlonly{}\rnrsrevision}}$} Report on the Algorithmic Language \\
                              \vskip 3pt
                              Scheme\\
                                \vskip 1.5ex
                              --- Rationale ---}

\vskip 1ex$$
\begin{tabular}{l@{\extracolsep{.5in}}lll}
\multicolumn{4}{c}{M\authorsc{ICHAEL} S\authorsc{PERBER}}
\\
\multicolumn{4}{c}{R.\ K\authorsc{ENT} D\authorsc{YBVIG},
  M\authorsc{ATTHEW} F\authorsc{LATT},
  A\authorsc{NTON} \authorsc{VAN} S\authorsc{TRAATEN}}
\\
\multicolumn{4}{c}{(\textit{Editors})} \\
\multicolumn{4}{c}{
  R\authorsc{ICHARD} K\authorsc{ELSEY}, W\authorsc{ILLIAM} C\authorsc{LINGER},
  J\authorsc{ONATHAN} R\authorsc{EES}} \\
\multicolumn{4}{c}{(\textit{Editors, Revised\itspace{}$^5$ Report on the
    Algorithmic Language Scheme})} \\
\multicolumn{4}{c}{\bf \rnrsrevisiondate}
\end{tabular}
$$



\end{center}

\chapter*{Summary}
\medskip

{\parskip 1ex
This document describes rationales for some of the design decisions
behind the \textit{Revised\itspace{}$^6$ Report on the Algorithmic Language
  Scheme}.  The focus is on changes made since the last revision on
the report.  Moreover, numerous fundamental design decisions of Scheme
are explained.  This report also contains some historical notes.
The formal comments submitted for drafts of the report and their
responses, as archived on \url{http://www.r6rs.org/}, provides additional
background information on many decisions that are reflected
in the report.

This document is not intended to be an exhaustive
justification for every decision and design aspect of the report.
Instead, it provides information about some of the issues
considered by the editors' committee when decisions were made, as
background information and as guidelines for future decision makers.
As such, the rationales given here may not be convincing to
every reader, but they convinced the editors at the time the
respective decisions were made.

This document frequently refers back to the \textit{Revised\itspace{}$^6$ Report
  on the Algorithmic Language Scheme}~\cite{R6RS}, the
\textit{Revised\itspace{}$^6$ Report on the Algorithmic Language Scheme ---
  Libraries ---}~\cite{R6RS-libraries}, and the \textit{Revised\itspace{}$^6$
  Report on the Algorithmic Language Scheme --- Non-Normative
  Appendices ---}~\cite{R6RS-appendices}; specific references to the
report are identified by designations such as ``report section'' or
``report chapter'', references to the library report are identified by
designations such as ``library section'' or ``library chapter'', and
references to the appendices are identified by designations such as
``appendix'' or ``appendix section''.  This document frequently refers
to the whole \textit{Revised\itspace{}$^6$ Report on the Algorithmic Language
  Scheme} as ``\rn{6}'', and to the \textit{Revised\itspace{}$^5$ Report
  on the Algorithmic Language Scheme} as ``\rn{5}''.
}

\medskip

We intend this report to belong to the entire Scheme community, and so
we grant permission to copy it in whole or in part without fee.  In
particular, we encourage implementors of Scheme to use this report as
a starting point for manuals and other documentation, modifying it as
necessary.
}]

\texonly\clearpage\endtexonly

\chapter*{Contents}
\addvspace{3.5pt}                  % don't shrink this gap
\renewcommand{\tocshrink}{-4.0pt}  % value determined experimentally
{%\footnotesize
\tableofcontents
}

\vfill

\texonly\clearpage\endtexonly

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Historical background}

The \textit{Revised\itspace{}$^6$ Report on the Algorithmic Language Scheme}
(\rn{6} for short) is the sixth of the Revised Reports on Scheme.

\vest The first description of Scheme was written by Gerald Jay
Sussman and Guy Lewis Steele Jr.\ in
1975~\cite{Scheme75}.  A revised report by Steele and
Sussman~\cite{Scheme78}
appeared in 1978 and described the evolution
of the language as its MIT implementation was upgraded to support an
innovative compiler~\cite{Rabbit}.  Three distinct projects began in
1981 and 1982 to use variants of Scheme for courses at MIT, Yale, and
Indiana University~\cite{Rees82,MITScheme,Scheme311}\nocite{Scheme84}.  An introductory
computer science textbook using Scheme was published in
1984~\cite{SICP}.  A number of textbooks describing and using Scheme
have been published since~\cite{tspl3}.

\vest As Scheme became more widespread,
local dialects began to diverge until students and researchers
occasionally found it difficult to understand code written at other
sites.
Fifteen representatives of the major implementations of Scheme therefore
met in October 1984 to work toward a better and more widely accepted
standard for Scheme.
Participating in this workshop were Hal Abelson, Norman Adams, David
Bartley, Gary Brooks, William Clinger, Daniel Friedman, Robert Halstead,
Chris Hanson, Christopher Haynes, Eugene Kohlbecker, Don Oxley, Jonathan Rees,
Guillermo Rozas, Gerald Jay Sussman, and Mitchell Wand.
Their report~\cite{RRRS}, edited by Will Clinger,
was published at MIT and Indiana University in the summer of 1985.
Further revision took place in the spring of 1986~\cite{R3RS} (edited
by Jonathan Rees and Will Clinger),
and in the spring of 1988~\cite{R4RS} (also edited by Will Clinger and
Jonathan Rees).  Another revision published in 1998, edited
by Richard Kelsey, Will Clinger and Jonathan Rees,
reflected further revisions agreed upon in a meeting at Xerox PARC in
June 1992~\cite{R5RS}.

Attendees of the Scheme Workshop in Pittsburgh in October 2002 formed
a Strategy Committee to discuss a process for producing new revisions
of the report.  The strategy committee drafted a charter for Scheme
standardization.  This charter, together with a process for selecting
editorial committees for producing new revisions of the report, was
confirmed by the attendees of the Scheme Workshop in Boston in
November 2003.  Subsequently, a Steering Committee according to the
charter was selected, consisting of Alan Bawden, Guy L.\ Steele Jr.,
and Mitch Wand.  An editors' committee charged with producing a new
revision of the report was
also formed at the end of 2003, consisting of Will Clinger,
R.\ Kent Dybvig, Marc Feeley, Matthew Flatt, Richard Kelsey, Manuel
Serrano, and Mike Sperber, with Marc Feeley acting as Editor-in-Chief.
Richard Kelsey resigned from the committee in April 2005, and was
replaced by Anton van Straaten.  
Marc Feeley and Manuel Serrano
resigned from the committee in January 2006.  Subsequently, the charter
was revised to reduce the size of the editors' committee to five and
to replace the office of Editor-in-Chief by a Chair and a Project
Editor~\cite{SchemeCharter2006}.  R.\ Kent Dybvig served as Chair, and
Mike Sperber served as Project Editor.  Will Clinger resigned from the
committee in May 2007.
Parts of the report were posted as Scheme Requests for Implementation
(SRFIs, see \url{http://srfi.schemers.org/})
and discussed by the community before being revised and finalized for
the report~\cite{srfi75,srfi76,srfi77,srfi83,srfi93}.
Jacob Matthews and Robby
Findler wrote the operational semantics for the language core,
 based on an earlier semantics for the language of the
``Revised$^5$ Report''~\cite{mf:scheme-op-sem}.


\chapter{Requirement levels}

\rn{6} distinguishes between different requirement levels, both for
the programmer and for the implementation.  Specifically, the
distinction between ``should'' and ``must'' is important: For example,
``should'' is used for restrictions on argument types that are
undecidable or potentially too expensive to enforce.  The use of
``should'' allows implementations to perform quite extensive checking
of restrictions on arguments (see section~\ref{argumentchecking}), but
also to eschew more expensive checks.


\chapter{Numbers}
% \label{numberschapter}

\section{Infinities, NaNs}
% \label{infinitiesnansection}

Infinities and NaNs are artifacts that help deal with the
inexactness of binary floating-point arithmetic.  The semantics
dealing with infinities and NaNs, or the circumstances leading to
their generation are somewhat arbitrary.  However, as most Scheme
implementation use an IEEE-754-conformant implementation~\cite{IEEE}
of flonums, \rn{6} uses the particular semantics from this standard as
the basis for the treatment of infinities and NaNs in the report.
This is also the reason why infinities and NaNs are flonums and thus
inexact real number objects, allowing Scheme systems to exploit the closure
properties arising from their being part of the standard IEEE-754
floating-point representation.  See
section~\ref{closurepropertiessection} for details on closure
properties.

Infinities and NaNs are not considered integers (or even rational) by
\rn{6}.
Despite this, the {\cf ceiling}, {\cf floor}, {\cf round}, and
{\cf truncate} procedures (and their {\cf fl}-prefixed counterparts) return an
infinity or NaN when given an infinity or NaN as an argument.
This has the advantage of allowing these procedures to take arbitrary
real (or flonum) arguments but the disadvantage that they do not always
return integer values.
The integer values of the mathematical equivalents of
these procedures are, in fact, infinite for infinite inputs.
Also, while infinities are not considered integers, they might
represent infinite integers.
So the extension to infinities, at least, makes sense.
The extension to NaNs is somewhat more arbitrary.

\rn{6} intentionally does not require a Scheme implementation to use
infinities and NaNs as specified in IEEE~754.  Hence, support for them
is optional.

\section{Distinguished -0.0}
 
A distinguished -0.0 is another artifact of IEEE~754, which can be
used to construct certain branch cuts.  A Scheme implementation is not
required to distinguish -0.0.  If it does, however, the behavior of
the transcendental functions is sensitive to the distinction.  

\chapter{Lexical syntax and datum syntax}

\section{Symbol and identifier syntax}

\subsection{Escaped symbol constituents}

While revising the syntax of symbols and identifiers, the editors'
goal was to make symbols subject to write/read invariance, i.e.\ to
allow each symbol to be written out using {\cf put-datum} (section
\extref{lib:put-datum}{Textual output}) or {\cf write}
(section~\extref{lib:write}{Simple I/O}), and
read back in using {\cf get-datum} (section
\extref{lib:get-datum}{Textual input}) or
{\cf read} (section \extref{lib:read}{Simple I/O}), yielding the same symbol.  This
was not the case in \rrs{5}, as symbols could contain arbitrary
characters such as spaces which could not be part of their external
representation.  Moreover, symbols could be distinguished internally by
case, whereas their external representation could not.

For representing unusual characters in the symbol syntax, the report
provides the {\cf\backwhack{}x} escape syntax, which allows an arbitrary
Unicode scalar value to be specified.  This also has the advantage that
arbitrary symbols can be represented using only ASCII, which allows
referencing them from Scheme programs restricted to ASCII or some
other subset of Unicode.

Among existing implementations of Scheme, a popular choice for
extending the set of characters that can occur in symbols is the
vertical-bar syntax of Common Lisp.  The vertical-bar syntax of Common
Lisp carries the risk of confusing the syntax of identifiers with that
of consecutive lexemes, and also does not allow representing arbitrary
characters using only ASCII.  Consequently, it was not adopted for
\rn{6}.

\subsection{Case sensitivity}
% \label{casesensitivityrationalesection}

The change from case-insensitive syntax in \rn{5} to case-sensitive
syntax is a major change.  Many technical arguments exist in favor of
both case sensitivity and case insensitivity, and any attempt to list
them all here would be incomplete.  
% [MF] So, don't bother with one argument against:
%  Switching to case sensitivity breaks backwards compatibility, and
%  might set a precedent for switching a technically more or less
%  arbitrary decision again in the future.

The editors decided to switch to case sensitivity, because they
perceived that a significant majority of the Scheme community favored
the change.  This perception has been strengthened by polls at the
2004 Scheme workshop, on the {\cf plt-scheme} mailing list, and the
{\cf r6rs-discuss} mailing list.

The suggested directives described in
appendix~\extref{app:caseinsensitivityappendix}{Optional case
  insensitivity} allow programs to specify that a section of the code (or other
syntactic data) was written under the old assumption of
case-insensitivity and therefore must be case-folded upon reading.

\subsection{Identifiers starting with {\tt ->}}

\rn{6} introduces a special rule in the lexical syntax for
identifiers starting with the characters {\cf ->}.  In \rn{5}, such
identifiers are not valid lexemes.  (In \rn{5}, a lexeme starting
with a {\cf -} character---except for {\cf -} itself---must be a
representation of a number object.)
However, many existing
Scheme implementations prior to \rn{6} already supported identifiers
starting with {\cf ->}.  (Many readers would classify any lexeme as an
identifier starting with {\cf -} for which {\cf string->number}
returns \schfalse{}.)  As a result, a significant amount of otherwise
portable Scheme code used identifiers starting with {\cf ->}, which
are a convenient choice for certain names.  Therefore, \rn{6} legalizes
these identifiers.  The separate production in the grammar is not particularly elegant.
However, designing a more elegant production that does not overlap with
representations of number objects or other lexeme classes has proven to be surprisingly
difficult.

 
\section{Comments}

While \rn{5} provides only the {\cf;} syntax for comments, the report
now describes three comment forms: In addition to {\cf;}, {\cf \#|}
and {\cf |\#} delimit block comments, and {\cf\sharpsign;} starts a
``datum comment''.  ({\cf\sharpsign!r6rs} is also a kind of comment,
albeit with a specific, fixed purpose.) 

Block comments provide a convenient way of writing multi-line
comments, and are an often-requested and often-implemented syntactic
addition to the language. 

A datum comment always comments out a single datum---no more, and no less,
something the other comment forms cannot reliably do.
Their uses include commenting out alternative versions of a form and
commenting out forms that may be required only in certain circumstances.
Datum comments are perhaps most useful during development and debugging
and may thus be less likely to appear in the final version of a
distributed library or top-level program; even so, a programmer or group
of programmers sometimes develop and debug a single piece of code
concurrently on multiple systems, in which case a standard notation for
commenting out a datum is useful.

\section{Future extensions}

The {\cf\sharpsign} is the prefix of several different kinds of
syntactic entities: vectors, bytevectors, syntactic abbreviations related
to syntax construction, nested comments, characters,
{\cf\sharpsign!r6rs}, and implementation-specific extensions to the
syntax that start with {\cf\sharpsign!}.  In each case, the character
following the {\cf\sharpsign} specifies what kind of syntactic datum follows.
In the case of bytevectors, the syntax anticipates several different
kinds of homogeneous vectors, even though \rn{6} specifies only
one. The {\cf u8} after the {\cf\sharpsign{}v} identifies the
components of the vector as unsigned 8-bit entities or octets.


\chapter{Semantic concepts}

\section{Argument and subform checking}
% \label{argumentchecking}

The report requires implementations to check the arguments of
procedures and subforms for syntactic forms for adherence to the
specification.  However, implementations are not required to detect
every violation of a specification.  Specifically, the report allows
the following exceptions:
%
\begin{enumerate}
\item Some restrictions are undecidable.  Hence, checking is not
  required, such as certain properties of procedures passed as
  arguments, or properties of subexpressions, whose macro expansion
  may not terminate.
\item Checking that an argument is a list where doing so would be
  impractical or expensive is not required.  Specifically, procedures that
  invoke another procedure passed as an argument are not required to
  check that a list remains a list after every invocation.
\item With some procedures, future extensions to the arguments they
  accept are explicitly allowed.
\end{enumerate}
%
The second item deserves special attention, as the specific decisions
made for the report are meant to enable ``picky'' implementations that
catch as many violations and unportable assumptions made by programs
as possible, while also enabling practical
implementations that execute programs quickly.

\section{Safety}

\rn{5} describes many situations not specified in the report as ``is
an error'': Portable \rn{5} programs cannot cause such situations, but
\rn{5} implementations are free to implement arbitrary behavior under this
umbrella.  Arbitrary behavior can include ``crashing'' the running program, or
somehow compromising the integrity of its execution model to result
in random behavior.  This situation stands in sharp contrast to the common assumption
that Scheme is a ``safe'' language, where each
violation of a restriction of the language standard or the
implementation would at least result in defined behavior (e.g.,
interrupting or aborting the program, or starting a debugger).

To avoid the problems associated with this arbitrary behavior, all
libraries specified in the report must be safe, and they react to
detected violations of the specification by raising
an exception, which allows the program to detect and react
to the violation itself.

The report allows implementations to provide ``unsafe'' libraries that
may compromise safety.

\section{Proper tail recursion}

Intuitively, no space is needed for an active tail call, because the
continuation that is used in the tail call has the same semantics as the
continuation passed to the procedure containing the call.  Although an improper
implementation might use a new continuation in the call, a return
to this new continuation would be followed immediately by a return
to the continuation passed to the procedure.  A properly tail-recursive
implementation returns to that continuation directly.

Proper tail recursion was one of the central ideas in Steele and
Sussman's original version of Scheme.  Their first Scheme interpreter
implemented both functions and actors.  Control flow was expressed using
actors, which differed from functions in that they passed their results
on to another actor instead of returning to a caller.  In the terminology
of the report, each actor finished with a tail call to another actor.

Steele and Sussman later observed that in their interpreter the code
for dealing with actors was identical to that for functions and thus
there was no need to include both in the language.

While a proper tail recursion has been a cornerstone property of
Scheme since its inception, it is difficult to implement efficiently
on some architectures, specifically those compiling to higher-level
intermediate languages such as C or to certain virtual-machine
architectures such as JVM or CIL.

Nevertheless, abandoning proper tail recursion as a language property
and relegating it to optional optimizations would have far-reaching
consequences: Many programs written with the assumption of proper tail
recursion would no longer work.  Moreover, the lack of proper tail
recursion would prevent the natural expression of certain programming
styles such as Actors-style message-passing systems, self-replacing
servers, or automata written as mutually recursive procedures.
Furthermore, if they did not exist, special ``loop'' constructs would
have to be added to the language to compensate for the lack of a general
iteration construct.  Consequently, proper tail recursion remains an
essential aspect of the Scheme language.

\chapter{Entry format}

While it is reasonable to require the programmer to adhere to
restrictions on arguments, some of these restrictions are either
undecidable or too expensive to always enforce (see
section~\ref{argumentchecking}).  Therefore, some entries have
an additional paragraph labelled ``\textit{Implementation
  responsibilities}'' that distinguishes the responsibilities of the
programmer from those of the implementation.

\chapter{Libraries}

The design of the library system was a challenging process: Many
existing Scheme implementations offer ``module systems'', but they
differ dramatically both in functionality and in the goals they
address.  The library system was designed with the primary
requirement of allowing programmers to write, distribute, and evolve
portable code.  A secondary requirement was to be able to separately
compile libraries in the sense that compiling a library requires only
having compiled its dependencies.  This entailed the following
corollary requirements:
%
\begin{itemize}
\item Composing libraries requires management of dependencies.
\item Libraries from different sources may have name conflicts.
  Consequently, name-space management is needed.
\item Macro definitions appear in portable code, requiring that macro
  bindings may be exported from libraries, with all the consequences
  dictated by the referential-transparency property of hygienic
  macros.
\end{itemize}
%
The library system does not address the following goals, which were
considered during the design process:
%
\begin{itemize}
\item independent compilation
\item mutually dependent libraries
\item separation of library interface from library implementation
\item local modules and local imports
\end{itemize}
%
This section discusses some aspects of the design of the library
system that have been controversial.

\section{Syntax}

A library definition is a single form, rather than a sequence of forms
where some forms are some kind of header and the remaining forms
contain the actual code.
It is not clear that a sequence of forms is more convenient than a
single form for processing and generation. Both syntactic choices have
technical merits and drawbacks. The single-form syntax chosen for
\rn{6} has the advantage of being self-delimiting.

A difference between top-level programs and libraries is that a
program contains only one top-level program but multiple libraries.
Thus, delimiting the text for a library body will be a
common need (in streams of various kinds) that it is worth
standardizing the delimiters; parentheses are the obvious choice.

\section{Local import}
% \label{localimportsection}

Some Scheme implementations feature module systems that allow a
module's bindings to be imported into a local environment.  While local
imports can be used to limit the scope of an import and thus lead to more
modular code and less need for the prefixing and renaming of imports,
the existence of local imports would mean that the set of libraries upon
which a library depends cannot be approximated as precisely from the
library header.
(The precise set of libraries used
cannot be determined even in the absense of local import,
because a library might be listed but its exports not used, and a library
not listed might still be imported at run time through the {\cf
environment} procedure.)
Leaving out local import for now does not preclude it from being added
later.

\section{Local modules}

Some Scheme implementations feature local libraries and/or modules, e.g.,
libraries or modules that appear within top-level libraries or within
local bodies.
This feature allows libraries and top-level programs to be further
subdivided into modular subcomponents, but it also complicates the scoping
rules of the language.
Whereas the library system allows bindings to be transported only from one
library top level to another, local modules allow bindings to be
transported from one local scope to another, which complicates the rules
for determining where identifiers are bound.
Leaving out local libraries and modules for now does
not preclude them from being added later.

\section{Fixed {\tt import} and {\tt export} clauses}

The {\cf import} and {\cf export} clauses of the {\cf library} form
are a fixed part of the library syntax.
This eliminates the need to specify in what language or language
version the clauses are written and simplifies the process of
approximating the set of libraries upon which a library depends, as
described in section~\ref{localimportsection}.
A downside is that {\cf import} and {\cf export} clauses cannot
be abstracted, i.e., cannot be the products of macro calls.

\section{Instantiation and initialization}

Opinions vary on how libraries should be instantiated and
initialized during the expansion and execution of library bodies,
whether library instances should be distinguished across phases,
and whether levels should be declared so that they constrain 
identifier uses to particular phases. This report therefore leaves
considerable latitude to implementations, while attempting to
provide enough guarantees to make portable libraries feasible.

Note that, if each right-hand side of the keyword definition and keyword
binding forms appearing in a program is a {\cf syntax-rules} or
{\cf identifier-syntax} form, {\cf syntax-rules} and {\cf identifier-syntax}
forms do not appear in any other contexts, and no {\cf import} form employs
{\cf for} to override the default import phases, 
then the program does not depend on whether instances are
distinguished across phases, and the phase of an identifier's use cannot
be inconsistent with the identifier's level.
Moreover, the phase of an identifier's use is never inconsistent with the
identifier's level if the implementation uses an implicit phasing model in
which references are allowed at any phase regardless of any phase
declarations.

\section{Immutable exports}

The asymmetry in the prohibitions against assignments to explicitly
and implicitly exported variables reflects the fact that the violation
can be determined for implicitly exported variables only when the
importing library is expanded.

\section{Compound library names}

Library names are compound.  This differs from the treatment of
identifiers in the rest of the language.  Using compound names
reflects experience across programming languages that a structured
top-level name space is necessary to avoid collisions.  Embedding a
hierarchy within a single string or symbol is certainly possible.
However, in Scheme, list data is the natural means for representing
hierarchical structure, rather than encoding it in a string or symbol.
The hierarchical structure makes it easy to formulate policies for
choosing unique names or possible storage formats in a file system.
See appendix~\extref{app:librarynamesappendix}{Unique library
  names}.
Consequently, despite the syntactic complexity of compound
names, and despite the potential mishandling of the hierarchy by
implementations, the editors chose the list representation.

\section{Versioning}

Libraries and {\cf import} clauses optionally carry versioning
information.  This allows reflecting the development history of a
library, but also significantly increases the complexity of the
library system.  Experience with module systems gathered in other
languages as well as with shared libraries at the operating-system
level consistently indicates that relying only on the name of a module
for identification causes conflicts impossible to rectify in the
absence of versioning information, and thus diminishes the
opportunities for sharing code.  Therefore, versioning is part of the
library system.

\section{Treatment of different versions}

Implementations are encouraged to prohibit two
libraries with the same name but different versions to coexist
within the same program.
While this prevents the combination of libraries and
programs that require different versions of the same library,
it eliminates the potential for having multiple copies of a
library's state, thus avoiding problems experienced with
other shared-library mechanisms,
including Windows DLLs and Unix shared objects.

\chapter{Top-level programs}

The notion of ``top-level program'' is new in \rn{6} and replaces the
notion of ``Scheme program'' in \rn{5}.  The two are quite different:
While a \rn{6} top-level program is defined to be a complete, textual
entity, an \rn{5} program can evolve by being entered piecemeal into
a running Scheme system.  Many Scheme systems have interactive
command-line environments based on the semantics of \rn{5} programs.
However, the specification of \rn{5} programs is not really
sufficient to describe how to operate an arbitrary Scheme system: The
\rn{5} is ambiguous on some aspects of the semantics such as binding.
Moreover, \rn{5}'s {\cf load} procedure does say how to load source
code into the running system; the pragmatics of {\cf load} would
often make compiling programs before execution problematic, in
particular with regard to macros.  Furthermore, Scheme implementations
handle treatment of and recovery from errors in different ways.

Tightening the specification of programs from \rn{5} would have been
possible, but could have restricted the design employed by Scheme
implementations in undesirable ways.  Moreover, alternative approaches
to structuring the user interface of a Scheme implementation have
emerged since \rn{5}.  Consequently, \rn{6} makes no attempt at trying
to specify the semantics of programs as in \rn{5}; the design of an
interactive environment is now completely in the hands of the
implementors.  On the other hand, being able to distribute portable
programs is one of the goals of the \rn{6} process.  As a result, the
notion of top-level program was added to the report.

By allowing the interleaving of definitions and expressions, top-level 
programs support exploratory and interactive development, without 
imposing unnecessary organizational overhead on code that might not be 
intended for reuse.

\chapter{Primitive syntax}

\section{Unspecified evaluation order}

The order in which the subexpressions of an application are evaluated
is unspecified, as is the order in which certain subexpressions of
some other forms such as {\cf letrec} are evaluated.  While this
causes occasional confusion, it encourages programmers to write
programs that do not depend on a specific evaluation order, and thus
may be easier to read.  Moreover, it allows the programmer to express
that the evaluation order really does not matter for the result.  A
secondary consideration is that some compilers are able to generate
better code if they can choose evaluation order.


\chapter{Expansion process}

The description of macro expansion in \rn{6} is considerably more involved than
in \rn{5}: One reason is that the specification of
expansion in \rn{5} is ambiguous in several important respects.  For
example, \rn{5} does not specify whether {\cf define} is a binding
form.  Also, it was not clear whether definitions of macros had to
precede their uses.  The fact that the set of available bindings may
influence the matching process of macro expansion further complicates
matters.  The specific algorithm \rn{6} describes is one of the
simplest expansion strategies that addresses these questions.  It has
the advantage that it visits every subform of the source code only
once.

The description of the expansion process specifically avoids
specifying the recursive case, where a macro use expands into a
definition whose binding would influence the expansion of the macro
use after the fact, as this might lead to confusing programs.
Implementations should detect such cases as syntax violations.

\chapter{Base library}

\section{Library organization}

The libraries of the Scheme standard are organized according to
projected use.  Hence, the \rsixlibrary{base} library exports
procedures and syntactic abstractions that are likely to be useful for
most Scheme programs and libraries.  Conversely, each of the libraries
relegated to the separate report on libraries is likely to be missing
from the imports of a substantial number of programs and libraries.
Naturally, the specific decisions about this organization and the
separation of concerns of the libraries are debatable, and represent a
best attempt of the editors.

A number of secondary criteria were also used in choosing the exports
of the base library.  In particular, macros transformers defined using
the facilities of the base library are guaranteed to be hygienic;
hygiene-breaking transformers are only available through the
\rsixlibrary{syntax-case} library.

Note that \rsixlibrary{base} is not a ``primitive library'' in the
sense that all other libraries of the Scheme standard can be
implemented portably using only its exports.  Moreover, the library
organization is generally not layered from more primitive to more advanced
libraries, even though some libraries can certainly be implemented in
terms of others.
Such an organization would have little benefit for users and may not
reflect the internal organization of any particular implementation.
Instead, libraries are organized by use.

The distinction between primitive and derived features was removed from
the report for similar reasons.

\section{Bodies}

In library bodies and local bodies, all definitions must precede all
expressions. \rn{6} treats bodies in top-level programs as a special
case.  Allowing definitions and expressions to be mixed in top-level
programs has ugly semantics, and introduces a special case, but was
allowed as a concession to convenience when constructing programs
rapidly via cut and paste.

Definitions are not interchangeable with expressions, so definitions
cannot be allowed to appear wherever expressions can appear.
Composition of definitions with expressions therefore must be
restricted in some way.  The question is what those restrictions
should be.

Historically, top-level definitions in Scheme have had a different
semantics from definitions in bodies.  In a body, definitions serve as
syntactic sugar for the bindings of a {\cf letrec} (or {\cf letrec*}
in \rn{6}) that is implicit at the head of every body.

That semantics can be stretched to cover top-level programs by
converting expressions to definitions of ignored variables, but does
not easily generalize to allow definitions to be placed anywhere
within expressions.  Different generalizations of definition placement
are possible, however a survey of current Scheme code found
surprisingly few places where such a generalization would be useful.

If such a generalization were adopted, programmers who are
familiar with Java and similar languages might expect definitions to
be allowed in the same kinds of contexts that allow declarations in
Java.  However, Scheme
definitions have {\cf letrec*} scope, while Java declarations (inside
a method body) have {\cf let*} scope and cannot be used to define
recursive procedures.  Moreover, Scheme's {\cf begin} expressions do not introduce
a new scope, while Java's curly braces do introduce a new scope.  Also, 
flow analysis is nontrivial in higher order languages, while Java can
use a trivial flow analysis to reject programs with undefined
variables.  Furthermore, Scheme's macro expander must locate all definitions,
while Java has no macro system.   And so on.  Rather than explain how
those facts justify restricting definitions to appear as top-level
forms of a body, it is simpler to explain that definitions are just
syntactic sugar for the bindings of an implicit {\cf letrec*} at the
head of each body, and to explain that the relaxation of that
restriction for top-level bodies is (like several other features of
top-level programs) an ad-hoc special case.

\section{Export levels}

The {\cf syntax-rules} and {\cf identifier-syntax} forms are
used to create macro transformers and are thus needed only at
expansion time, i.e., meta level $1$.  

The identifiers {\cf unquote}, {\cf unquote-splicing}, {\cf =>}, and
{\cf else} serve as literals in the syntax of one or more
syntactic forms; e.g., {\cf else} serves as a
literal in the syntax of {\cf cond} and {\cf case}.
Bindings of these identifiers are exported from the base library so
that they can be distinguished from other bindings of these identifiers
or renamed on import.
The identifiers {\cf ...}, {\cf \_}, and {\cf set!} serve as
literals in the syntax of {\cf syntax-rules} and
{\cf identifier-syntax} forms and are thus exported along with those
forms with level $1$.

\section{Binding forms}

The {\cf let-values} and {\cf let-values*} forms are compatible with
SRFI~11~\cite{srfi11}.

\section{Equivalence predicates}

\subsection{Treatment of procedures}

The definition of {\cf eqv?} allows implementations latitude in
their treatment of procedures: implementations are free either to
detect or to fail to detect that two procedures are equivalent to each
other, and can decide whether or not to merge representations of
equivalent procedures by using the same pointer or bit pattern to
represent both.  Moreover, they can use implementation techniques such
as inlining and beta reduction that duplicate otherwise equivalent
procedures.

\subsection{Equivalence of NaNs}

The basic reason why the behavior of {\cf eqv?} is not specified on
NaNs is that the IEEE-754 standard does not say much about how the
bits of a NaN are to be interpreted, and explicitly allows
implementations of that standard to use most of a NaN's bits to encode
implementation-dependent semantics.  The implementors of a Scheme
system should therefore decide how {\cf eqv?} should interpret those
bits.

Arguably, \rn{6} should require
%
\begin{scheme}
(let ((x \hyper{expression})) (eqv? x x))%
\end{scheme}
%
to evaluate to \schtrue{} when \hyper{expression} evaluates to a number object;
both \rn{5} and \rn{6} imply this for certain other types, and for
most numbers objects, but not for NaNs.  Since the IEEE~754 and draft
IEEE~754R~\cite{IEEE754R} both say that the interpretation of a NaN's
payload is left up to implementations, and implementations of Scheme
often do not have much control over the implementation of IEEE
arithmetic, it would be unwise for \rn{6} to insist upon the truth of
%
\begin{scheme}
(let ((x \hyper{expression}))
  (or (not (number? x))
      (eqv? x x)))%
\end{scheme}
even though that expression is likely to evaluate to \schtrue{} in most
systems.  For example, a system with delayed boxing of inexact real
number objects might box the two arguments to {\cf eqv?} separately, the boxing
process might involve a change of precision, and the two separate
changes of precision may result in two different payloads.

When \var{x} and \var{y} are flonums represented in IEEE floating
point or similar, it is reasonable to implement {\cf (eqv? \var{x}
  \var{y})} by a bitwise comparison of the floating-point
representations.  \rn{6} should not require this, however, because
%
\begin{enumerate}
\item \rn{6} does not require that flonums be represented by a
  floating-point representation,
\item the interpretation of a NaN's payload is explicitly
  implementation-dependent according to both the IEEE-754 standard and
  the current draft of its proposed replacement, IEEE~754R, and
\item the semantics of Scheme should remain independent
  of bit-level representations.
\end{enumerate}
%
For example, IEEE~754, IEEE~754R, and the draft \rn{6} all allow the
external representation {\cf +nan.0} to be read as a NaN whose payload
encodes the input port and position at which {\cf +nan.0} was read.
This is no different from any other external representation such as
{\cf ()}, {\cf \sharpsign()}, or {\cf 324}.  An implementation can
have arbitrarily many bit-level representations of the empty vector,
for example, and some do.  That is why the behavior of the {\cf eq?}
and {\cf eqv?} procedures on vectors cannot be defined by reference to
bit-level representations, and must instead be defined explicitly.

\subsection{{\tt eq?}}

It is usually possible to implement {\cf eq?}\ much more efficiently
than {\cf eqv?}, for example, as a simple pointer comparison instead
of as some more complicated operation.  One reason is that it may not
be possible to compute {\cf eqv?}\ of two number objects in constant time,
whereas {\cf eq?}\ implemented as pointer comparison will always
finish in constant time.  The {\cf eq?} predicate may be used like
{\cf eqv?}\ in applications using procedures to implement objects with
state since it obeys the same constraints as {\cf eqv?}.

\section{Arithmetic}

\subsection{Full numerical tower}

\rn{5} does not require implementations to support the full numeric
tower.  Consequently, writing portable \rn{5} programs that
perform substantial arithmetic is difficult; it is unnecessarily difficult even
to write programs whose arithmetic is portable between different
implementations in the same category.  The portability problems were
most easily solved by requiring all implementations to support the
full numerical tower.

\subsection{IEEE-754 conformance}

As mentioned in chapter~\ref{numberschapter}, the treatment of
infinities, NaNs and -0.0, if present in a Scheme implementation, are
in line with IEEE~754~\cite{IEEE} and IEEE~754R~\cite{IEEE754R}.
Analogously, the specification of branch cuts for certain
transcendental functions have been changed from \rn{5} to conform to
the IEEE standard.

\subsection{Transcendental functions}

The specification of the transcendental functions follows
Steele~\cite{CLtL}, which in turn cites Penfield~\cite{Penfield81};
refer to these sources for more detailed discussion of branch cuts,
boundary conditions, and implementation of these functions.

\subsection{Domains of numerical predicates}

The domains of the {\cf finite?}, {\cf infinite?}, and {\cf nan?}
procedures could be expanded to include all number objects, or perhaps even
all objects.  However, \rn{6} restricts them to real number objects.
Expanding {\cf nan?} to complex number objects would involve at least some
arbitrariness; not expanding its domain while expanding the domains of
the other two would introduce an irregularity into the domains of
these three procedures, which are likely to be used together.  It is
easier for programmers who wish to use these procedures with complex
number objects to express their intent in terms of the real-only versions
than it would be for the editors to guess their intent.

\subsection{Numerical types}

Scheme's numerical types are the exactness types exact and inexact,
the tower types integer, rational, real, complex, and number, and the
Cartesian product of the exactness types with the tower types, where
$\left< t_1, t_2 \right>$; is regarded as a subtype of both $t_1$ and
$t_2$.

These types have an aesthetic symmetry to them, but they are not equally
important
In practice,
there is reason to believe that the most important numerical types are
the exact integer objects, the exact rational number objects, the
inexact real number objects, and the
inexact complex number objects.  This section explores one of the reasons
those four types are important in practice, and why real number objects have an
exact zero as their imaginary part in \rn{6} (a change from \rn{5}).

\subsection{Closure Properties}
% \label{closurepropertiessection}

Each of the four types mentioned above corresponds to
a set of values that turns up repeatedly as the natural domain or
range of the functions that are computed by Scheme's standard
procedures.  The reason these types turn up so often is that they are
closed under certain sets of operations.

The exact integer objects, for example, are closed under the integral
operations of addition, subtraction, and multiplication.  The exact
rational number objects are closed under the rational operations, which consist of
the integral operations plus division (although division by zero is a special
case).  The real number objects (and inexact real number objects) are closed
under some (often inexact) interpretation of rational and irrational
operations such as {\cf exp} and {\cf sin}, but are not closed under operations
such as {\cf log}, {\cf sqrt}, and {\cf expt}.  The complex (and
inexact complex) number objects are closed under the largest set of
operations.

\subsubsection{Representation-specific operations}

A naive implementation of Scheme's arithmetic operations is slow
compared to the arithmetic operations of most other languages, mainly
because most operations must perform case dispatch on the
representation types of their arguments.  The potential for this case
dispatch arises when the type of an operation's argument is
represented by a union of two or more representation types, or because
the operation must raise an exception when given an argument of
an incorrect type.  (The second reason can be regarded as a special
case of the first.)

To make Scheme's arithmetic more efficient, many implementations
provide sets of operations whose domain is restricted to a single
representation type, and which are not expected to raise an exception
when given arguments of incorrect type when used in an unsafe mode.

Alternatively, or in addition, several compilers perform a
flow analysis that attempts to infer the representation types of
expressions.  When a single representation type can be inferred for
each argument of an operation, and those types match the types
expected by some representation-specific version of the operation,
then the compiler can substitute the specific version for the more
general version that was specified in the source code.

\subsubsection{Flow analysis}

Flow analysis is performed by solving the type and interval
constraints that arise from such things as:

\begin{itemize}
\item the types of literal constants, e.g.\ {\cf 2} is an exact
  integer object
  that is known to be within the interval $[2,2]$
  
\item conditional control flow that is predicated on known
  inequalities, e.g., {\cf (if (< i n) \hyperi{expression} \hyperii{expression})}
  
\item conditional control flow that is predicated on known type
  predicates, e.g., {\cf (if (real? x) \hyperi{expression} \hyperii{expression})}
  
\item the closure properties of known operations (for example, {\cf (+
    \vari{flonum} \varii{flonum})} always evaluates to a flonum)
\end{itemize}
  
The purpose of flow analysis (as motivated in this section) is to infer a
single representation type for each argument of an operation.  That
places a premium on predicates and closure properties from which a
single representation type can be inferred.

In practice, the most important single representation types are
fixnum, flonum, and compnum.  (A compnum is a pair of flonums,
representing an inexact complex number object.)  These are the representation
types for which a short sequence of machine code can be generated when
the representation type is known, but for which considerably less
efficient code will probably have to be generated when the
representation type cannot be inferred.

The fixnum representation type is not closed under any operation of
\rn{5}, so it is hard for flow analysis to infer the fixnum type from
portable code.  Sometimes the combination of a more general type (e.g.,
exact integer object) and an interval (e.g., $[0,n)$, where $n$ is known to
be a fixnum) can imply the fixnum representation type.  Adding
fixnum-specific operations that map fixnums to fixnums 
greatly increases the number of fixnum
representation types that a compiler can infer.

The flonum representation type is not closed under operations such as
{\cf sqrt} and {\cf expt}, so flow analysis tends to break down in the
presence of those operations.  This is unfortunate, because those
operations are normally used only with arguments for which the result
is expected to be a flonum.  Adding flonum-specific versions such as
{\cf flsqrt} and {\cf flexpt} improves the effectiveness of flow
analysis.

\rn{5} creates a more insidious problem by defining {\cf (real?
  \var{z})} to be true if and only if {\cf (zero? (imag-part
  \var{z}))} is true.  This means, for example, that {\cf -2.5+0.0i}
is real.  If {\cf -2.5+0.0i} is represented as a compnum, then the
compiler cannot rely on {\cf x} being a flonum in the consequent
of {\cf (if (real? x) \hyperi{expression} \hyperii{expression})}.  This
problem could be fixed by writing all of the arithmetic operations so
that any compnum with a zero imaginary part is converted to a flonum
before it is returned, but that merely creates an analogous problem
for compnum arithmetic, as explained below.  \rn{6} adopted a proposal
by Brad Lucier to fix the problem: {\cf (real? \var{z})} is now true
if and only if {\cf (imag-part \var{z})} is an exact zero.

The compnum representation type is closed under virtually all
operations, provided no operation that accepts two compnums as its
argument ever returns a flonum.  To work around the problem described
in the paragraph above, several implementations automatically convert
compnums with a zero imaginary part to the flonum representation.
This practice virtually destroys the effectiveness of flow analysis
for inferring the compnum representation, so it is not a good
workaround.  To improve the effectiveness of flow analysis, it is
better to change the definition of Scheme's real number objects as described
in the paragraph above.

\subsubsection{div and mod}

Given arithmetic on exact integer objects of arbitrary precision, it is a
trivial matter to derive signed and unsigned integer types of finite
range from it by modular reduction.  For example 32-bit signed
two-complement arithmetic behaves like computing with the residue
classes ``mod $2^{32}$'', where the set $\{-2^{31}, \ldots,
2^{31}-1\}$ has been chosen to represent the residue classes.
Likewise, unsigned 32-bit arithmetic also behaves like computing ``mod
$2^{32}$'', but with a different set of representatives $\{0, \ldots,
2^{32}-1\}$.

Unfortunately, the \rn{5} operations {\cf quotient}, {\cf remainder},
and {\cf modulo} are not ideal for this purpose.  In the following
example, {\cf remainder} fails to transport the additive group
structure of the integers over to the residues modulo 3.
%
\begin{scheme}
(remainder (+ -2 3) 3) \ev 1,
(remainder (+ (remainder -2 3)
              (remainder 3 3))
           3) \ev -2%
\end{scheme}
%
In fact, {\cf modulo} should have been used, producing residues in
$\{0,1,2\}$. For modular reduction with symmetric residues, i.e., in
$\{-1,0,1\}$ in the example, it is necessary to define a more
complicated reduction altogether.

Therefore, {\cf quotient}, {\cf remainder}, and {\cf modulo} have been
replaced in \rn{6} by the {\cf div}, {\cf mod}, {\cf div0}, and {\cf
  mod0} procedures, which are more useful when implementing modular
reduction.  The underlying mathematical functions $\mathrm{div}$,
$\mathrm{mod}$, $\mathrm{div}_0$, and $\mathrm{mod}_0$ (see report
section~\extref{report:integerdivision}{Integer division}) have been
adapted from the $\mathrm{div}$ and $\mathrm{mod}$ operations by Egner
et al.~\cite{cleaninguptower}.  They differ in the representatives
from the residue classes they return: $\mathrm{div}$ and $\mathrm{mod}$
always compute a non-negative residue, whereas $\mathrm{div}_0$ and
$\mathrm{mod}_0$ compute a residue from a set centered on 0.  The
former can be used, for example, to implement unsigned fixed-width
arithmetic, whereas the latter correspond to two's-complement arithmetic.

These operations differ slightly from the $\mathrm{div}$ and
$\mathrm{mod}$ operations from Egner et al.  The latter make both operations
available through a single pair of operations that distinguish
between the two cases for residues by the sign of the divisor (as well
as returning $0$ for a zero divisor).  Splitting the operations into
two sets of procedures avoids potential confusion.

The procedures {\cf modulo}, {\cf remainder}, and {\cf quotient} from
\rn{5} can easily be defined in terms of {\cf div} and {\cf mod}.

\subsection{Numerical predicates}

The behavior of the numerical type predicates {\cf complex?}, {\cf
  real?}, {\cf rational?}, and {\cf integer?} is motivated by
closure properties described in
section~\ref{closurepropertiessection}.  Conversely, the procedures
{\cf real-valued?}, {\cf rational-valued?}, and {\cf integer-valued?}
test whether a given number object can be coerced to the specified type
without loss of numerical accuracy.

\subsection{Notes on individual procedures}

\begin{description}
\item[{\tt round}]
The {\cf round} procedure rounds to even for consistency with the
default rounding mode specified by the IEEE floating-point standard.
\item[{\tt sqrt}]
The behavior of {\cf sqrt} is consistent with the IEEE floating-point
standard.
\item[{\tt number->string}]
If \var{z} is an inexact number object represented using binary floating
point, and the radix is 10, then the expression listed in the
specification is normally satisfied by a result containing a decimal
point.  The unspecified case allows for infinities, NaNs, and
representations other than binary floating-point.
\end{description}

\section{Characters and strings}

While \rn{5} specifies characters and strings in terms of its own,
limited character set, \rn{6} specifies characters and strings in
terms of Unicode.  The primary goal of the design change was to
improve the portability of Scheme programs that manipulate text, while
preserving a maximum of backward compatibility with \rn{5}.

\rn{6} defines characters to be representations of Unicode scalar
values, and strings to be indexed sequences of characters.  This is a
different representation for Unicode text than the representations
chosen by some other programming languages such as Java or
C\sharpsign{}, which use UTF-16 code units as the basis for the type
of characters.

The representation of Unicode text corresponds to the lowest semantic
level of the Unicode standard: The Unicode standard specifies most
semantic properties in terms of Unicode scalar values.  Thus, Unicode
strings in Scheme allow the straightforward implementation of
semantically sensitive algorithms on strings in terms of these scalar
values.

In contrast, UTF-16 is a specific encoding for Unicode text, and
performing semantic manipulation on UTF-16 representations of text is
awkward.  Choosing UTF-16 as the basis for the string representation
would have meant that a character object potentially carries no
semantic information at all, as surrogates have to be combined
pairwise to yield the corresponding Unicode scalar value.  (As a
result, Java provides some semantic operations on Unicode text 
in two overloadings, one for character objects and one for
integers that are Unicode scalar values.)

The surrogates cover a numerical range deliberately omitted from the
set of Unicode scalar values.  Hence, surrogates have no
representation as characters---they are merely an artifact of the
design of UTF-16.  Including surrogates in the set of characters
introduces complications similar to the complications of using UTF-16
directly.  In particular, most Unicode consortium standards and
recommendations explicitly prohibit unpaired surrogates, including the
UTF-8 encoding, the UTF-16 encoding, the UTF-32 encoding, and
recommendations for implementing the ANSI C {\cf wchar\_t} type.  Even
UCS-4, which originally permitted a larger range of values that
includes the surrogate range, has been redefined to match UTF-32
exactly. That is, the original UCS-4 range was shrunk and surrogates
were excluded.

Arguably, a higher-level model for text could be used as the basis for
Scheme's character and string types, such as grapheme clusters.
However, no design satisfying the goals stated above was available
when the report was written.

\section{Symbols}

Symbols have exactly the properties needed to represent
identifiers in programs, and so most implementations
of Scheme use them internally for that purpose.  Symbols are useful
for many other applications; for instance, they may be used the way
enumerated values are used in C and Pascal.

\section{Control features}

\subsection{{\tt call-with-current-continuation}}

\vest A common use of {\cf call-with-current-continuation} is for
structured, non-local exits from loops or procedure bodies, but in fact
{\cf call-with-current-continuation} is useful for implementing a
wide variety of advanced control structures.

Most programming languages incorporate one or more special-purpose
escape constructs with names like {\cf exit}, \hbox{{\cf return}}, or
even {\cf goto}.  In 1965, however, Peter Landin~\cite{Landin65}
invented a general-purpose escape operator called the J-operator.  John
Reynolds~\cite{Reynolds72} described a simpler but equally powerful
construct in 1972.  The {\cf catch} special form described by Sussman
and Steele in the 1975 report on Scheme is exactly the same as
Reynolds's construct, though its name came from a less general construct
in MacLisp.  Several Scheme implementors noticed that the full power of the
\ide{catch} construct could be provided by a procedure instead of by a
special syntactic construct, and the name
{\cf call-with-current-continuation} was coined in 1982.  This name is
descriptive, but opinions differ on the merits of such a long name, and
some people use the name \ide{call/cc} instead.

\subsection{{\tt dynamic-wind}}

The {\cf dynamic-wind} procedure was added more recently in \rn{5}.
It enables implementing a number of abstractions related to
continuations, such as implementing a general dynamic environment, and
making sure that finalization code runs when some dynamic extent
expires.  More generally, the {\cf dynamic-wind} procedure provides a
guarantee that
%
\begin{scheme}
(dynamic-wind \var{before} \var{thunk} \var{after})%
\end{scheme}
%
cannot call \var{thunk} unless \var{before} has been called, and it
cannot leave the dynamic extent of the call to \var{thunk} without
calling \var{after}. These evaluations are never nested.  As this
guarantee is crucial for enabling many of the uses of {\cf
  call-with-current-continuation} and {\cf dynamic-wind}, both are
specified jointly.


\subsection{Multiple values}

Many computations conceptually return several results.  Scheme
expressions implementing such computations can return the results as
several values using the {\cf values} procedure.  Of course, such
expressions could alternatively return the results as a single
compound value, such as a list, vector, or a record.  However, values
in programs usually represent conceptual wholes; in many cases,
multiple results yielded by a computation lack this coherence.
Moreover, this would be inefficient in many implementations, and a
compiler would need to perform significant optimization to remove the
boxing and unboxing inherent in packaging multiple results into a
single values.  Most importantly, the mechanism for multiple values in
Scheme establishes a standard policy for returning several results
from an expression, which makes constructing interfaces and using them
easier.

\rn{6} does not specify the semantics of multiple values completely.
In particular, it does not specify what happens when several
(or zero) values are returned to a continuation that implicitly
accepts only one value.  In particular:
%
\begin{scheme}
((lambda (x) x) (values 1 2)) \lev \unspecified%
\end{scheme}
%
Whether an implementation must raise an exception when evaluating such
an expression, or should exhibit some other, non-exceptional behavior
is a contentious issue.  Variations of two different and fundamentally
incompatible positions on this issue exist, each with its own merits:
%
\begin{enumerate}
\item Passing the wrong number of values to a continuation is
typically a violation, one that implementations ideally detect and report.

\item There is no such thing as returning the wrong number of values
  to a continuation.  In particular, continuations not created by {\cf
    begin} or {\cf call-with-values} should ignore all but the first
  value, and treat zero values as one unspecified value.
\end{enumerate}
%
\rn{6} allows an implementation to take either position.  Moreover, it
allows an implementation to let {\cf set!}, {\cf vector-set!}, and
other effect-only operators to pass zero values to their
continuations, preventing a program from making obscure use of the return
value.  This causes a potential compatibility problem with \rn{5},
which specifies that such expression return a single unspecified
value, but the benefits of the change were deemed to outweigh the costs.

\section{Macro transformers}

\subsection{{\tt syntax-rules}}

While the first subform of \hyper{srpattern} of a \hyper{syntax rule}
in a {\cf syntax-rules} form (see report
section~\extref{report:syntaxrulessection}{Macro transformers})
may be an identifier, the
identifier is not involved in the matching and is not considered a
pattern variable or literal identifier.  This is actually important,
as the identifier is most often the keyword used to identify the
macro.  The scope of the keyword is determined by the binding form or
syntax definition that binds it to the associated macro transformer.
If the keyword were a pattern variable or literal identifier, then the
template that follows the pattern would be within its scope regardless
of whether the keyword were bound by {\cf let-syntax}, {\cf
  letrec-syntax}, or {\cf define-syntax}.

\chapter{Formal semantics}

The operational semantics in report
chapter~\extref{report:formalsemanticschapter}{Formal semantics}
replaces the denotational semantics in \rn{5}.  The denotational
semantics in \rn{5} has several problems, most seriously its
incomplete treatment of the unspecific evaluation order of
applications: the denotational semantics suggests that a single
unspecified order is used.  Modelling nondeterminism is generally
difficult with denotational semantics, and an operational semantics
allows specifying the unspecified evaluation order precisely.


\chapter{Unicode}

\section{Case mapping}

The various case-mapping procedures of the \rsixlibrary{unicode}
library all operate in a locale-independent manner.  The Unicode
standard also offers locale-sensitive case operations, not implemented
by the procedures from the \rsixlibrary{unicode} library.  While the
library does not make available the full spectrum of case-related
functionality defined by the Unicode standard, it does provide the
most commonly used procedures.  In particular, this strategy has
allowed providing procedures mostly compatible with those provided by
\rn{5}.  (A minor exception is the case-insensitive procedures for
string comparison.  However, it is unlikely that this affects many
existing programs.)  Providing locale-sensitive operations would have
meant significant novel design effort without significant precedent,
which is why they are not part of \rn{6}.

The case-mapping procedures operating on characters are not sufficient
for implementing case mapping on strings.  For example, the upper-case
version of the German ``\ss{}'' in a string is ``SS''.  As {\cf
  char-upcase} can only return a single character, it must return
\ss{} for \ss.  This limits the usefulness of the procedures
operating on characters, but provides compatibility with \rn{5}
sufficient for many existing applications.  Moreover, it provides
direct access to the corresponding attributes of the Unicode character
database.

\chapter{Bytevectors}

Bytevectors are a representation for binary data, based on
SRFI~74~\cite{srfi74}.  The primary motivation for including them in
\rn{6} was to enable binary I/O.  Positions in bytevectors always
refer to certain bytes or octets.  However, the operations of the
\rsixlibrary{bytevectors} library provide access to binary data in
various byte-aligned formats, such as signed and unsigned integers of
various widths, IEEE floating-point representations, and textual
encodings.  This differs notably from representations for binary data
as homogeneous vectors of numbers.  In settings related to I/O, an
application often needs to access different kinds of entities from a
single binary block.  Providing operations for them on a single
datatype considerably reduces both programming effort and library
size.

Bytevectors can also be used to encode sequences of unboxed number objects.
Unencapsulated use of bytevectors for this purpose may lead
to aliasing, which may reduce the effectiveness of compiler
optimizations.  However, sealedness and
opacity of records, together with bytevectors, make it possible to
construct a portable implementation for new data types that
provides fast and memory-efficient arrays of homogeneous numerical
data.

\chapter{List utilities}

The \rsixlibrary{lists} library provides a small number of useful
procedures operating on lists, including several procedures from
\rn{5}.  The goal of the library is to provide only procedures likely
to be useful for many programs.  Consequently, the selection
represented by \rsixlibrary{lists} is less exhaustive than the widely
implemented SRFI~1~\cite{srfi1}.  Several changes were made with
respect to the corresponding procedures SRFI~1 to simplify the
specification, and to establish uniform naming conventions.

\section{Notes on individual procedures}

\begin{description}
\item[{\tt memp}, {\tt member}, {\tt memv}, and {\tt memq}]
Although they are ordinarily used as predicates, {\cf memp}, {\cf
  member}, {\cf memv}, and {\cf memq}, do not have question marks in
their names, because they return useful values rather than just
\schtrue{} or \schfalse{}.
\end{description}

\chapter{Sorting}

The procedures of the \rsixlibrary{sorting} library provide simple
interfaces to sorting algorithms useful to many programs.  In
particular, {\cf list-sort} and {\cf vector-sort} guarantee stable
sorting using $O(n \lg n)$ calls to the comparison procedure.
Straightforward implementations of merge sort~\cite{algorithms} have
the desired properties.  Note that, at least with merge sort,
stability carries no significant implementation or performance burden.

The choice of ``strictly less than'' for the comparison relation is
consistent with the most common choice of existing Scheme libraries
for sorting.  Moreover, using a procedure returning three possible
values (for less than, equal, and greater than) instead of a boolean
comparison procedure would make calling the sorting procedures less
convenient, with no discernible performance advantage.

The specification of the {\cf vector-sort!} procedure is meant to
allow an implementation using quicksort~\cite{quicksort}, hence the $O(n^2)$
bound on the number of calls to the comparison procedure, and the
omission of the stability requirement.

\chapter{Control structures}

\section{{\tt when} and {\tt unless}}

The {\cf when} and {\cf unless} forms are syntactic sugar for one-armed
{\cf if} expressions.
Because each incorporates an implicit {\cf begin}, they are sometimes more
convenient than one-armed {\cf if}.
Some programmers always use {\cf when} and {\cf unless} in lieu of
one-armed {\cf if} to make clear when a one-armed conditional is being
used.

\section{{\tt case-lambda}}

The {\cf case-lambda} form allows constructing procedures that
distinguish different numbers of arguments.  Using {\cf case-lambda}
makes this considerably easier than deconstructing a list containing
optional arguments explicitly.  Moreover, Scheme implementations might
optimize dispatch on the number of arguments when expressed as {\cf
  case-lambda}, which is considerably harder for code that explicitly
deconstructs argument lists.

\chapter{Records}


\section{Syntactic layer}

While the syntactic layer can be expressed portably in terms of the
procedural layer, standardizing a particular surface syntax
facilitates communication via code.

Moreover, the syntactic layer is designed to allow expansion-time
determination of record characteristics, including field offsets, so that,
for example, record accesses can be reduced to simple memory indirects
without flow analyses or any other nontrivial compiler support. 
(This property may be lost if the {\cf parent-rtd} clause is present, and
the parent is thus not generally known until run time.)
Thus, the syntactic layer facilitates the development of efficient
portable libraries that define and use record types and can serve as a
basis for other syntactic record definition constructs. 

\section{Positional access and field names}

The record and field names passed to {\cf make-\hp{}record-\hp{}type-\hp{}descriptor}
and appearing in the syntactic layer are for informational purposes
only, e.g., for printers and debuggers.  In particular, the accessor
and mutator creation routines do not use names, but rather field
indices, to identify fields.
Thus, field names are not required to be distinct in the procedural or
syntactic layers.  This relieves macros and other code generators from
the need to generate distinct names.

Moreover, not requiring distinctness prevents naming conflicts that
occur when a field in a base type is renamed such that it is the same
as in an extension Also, the record and field names are used in the
syntactic layer for the generation of accessor and mutator names, and
thus duplicate field names may lead to accessor and mutator naming
conflicts.

\section{Lack of multiple inheritance}

Multiple inheritance was considered but omitted from the records
facility, as it raises a number of semantic issues such as sharing
among common parent types.

\section{Constructor mechanism}

The constructor-descriptor mechanism is an infra\-struc\-ture for
creating specialized constructors, rather than just creating default
constructors that accept the initial values of all the fields as
arguments. This infrastructure achieves full generality while leaving
each level of an inheritance hierarchy in control over its own fields
and allowing child record definitions to be abstracted away from the
actual number and contents of parent fields.

The constructor mechanism allows the initial values of the fields to be specially
computed or to default to constant values. It also allows for
operations to be performed on or with the resulting record, such as
the registration of a record for finalization. Moreover, the
constructor-descriptor mechanism allows the creation of such
initializers in a modular manner, separating the initialization
concerns of the parent types from those of the extensions.

\section{Sealed record types}

Record types may be sealed.  This feature allows enforcing abstraction
barriers, which is useful in itself, but also allows more efficient
compilation.

In particular, when the implementor of an abstract data type chooses
to represent that ADT by a record type, and allows one of the record types
that represent the ADT to be exposed and extended, then the ADT is
no longer abstract.  Its implementors must expose enough information
to allow for effective subtyping, and must commit to enough of the
representation to allow those subtypes to continue to work even as
the ADT evolves.

A partial solution is to maintain independence of the child record type
from the specific fields of the parent, particularly by specifying a
record constructor descriptor for the parent type that is independent of
its specific fields.
When this is deemed to be insufficient, the record type can be sealed,
thereby preventing the ADT from being subtyped.
(This does not completely eliminate the problem, however, since the ADT
may be extended implicitly, i.e., used as a delegate for some other type.)

Moreover, making a record type sealed may prevent its accessors and
mutators from becoming polymorphic, which would make effective flow analysis and
optimization difficult.  This is particularly relevant for
Scheme implementations that use records to implement some of Scheme's
other primitive data types such as pairs.

\chapter{Conditions and exceptions}

\section{Exceptions}

The goals of the exception mechanism are to help programmers share
code which relies on exception handling, and to provide information on
violations of specifications of procedures and syntactic forms.  This
exception mechanism is an extension of SRFI~34~\cite{srfi34}, which
was primarily designed to meet the first goal.  However, it has proven
suitable for addressing the second goal of dealing with violations as
well.   (More on the second goal below in the discussion of the
condition system.)

For some violations such the use of unsupported NaNs or infinities, as
well as other applications, an exception handler may be able to
repair the cause of the exception, for example by substituting a
suitable object for the NaN or infinity.  Therefore, the exception
mechanism extends SRFI~34 by continuable exceptions, and specifies the
continuation of an exception handler

\section{Conditions}

Conditions are values that communicate information about exceptional
situations between parts of a program. Code that detects an exception
may be in a different part of the program than the code that handles
it. In fact, the former may have been written independently from the
latter.  Consequently, to facilitate effective handling of exceptions,
conditions should communicate as much information as possible as
accurately as possible, and still allow effective handling by code
that did not precisely anticipate the nature of the exception that has
occurred.

The \rsixlibrary{conditions} library provides two mechanisms to
enable this kind of communication:
%
\begin{itemize}
\item subtyping (through record types) among condition types allows
  handling code to determine the general nature of an exception even
  though it does not anticipate its exact nature,
\item compound conditions allow an exceptional situation to be
  described in multiple ways.
\end{itemize}
%
As an example, a networking error that occurs during a file operation
on a remote drive fits two descriptions: ``networking error'' and
``file-system error''.  An exception handler might only look for one of
the two.  Compound conditions are a simple solution to this problem.
Moreover, compound conditions also make providing auxiliary
information as part of the condition object, such as an error message,
easier.

The standard condition hierarchy makes an important distinction
between \emph{errors} and \emph{violations}: An error is an
exceptional situation in the environment, which the program cannot
avoid or prevent.  For example, I/O errors are represented by
condition types that are subtypes of {\cf\&error}.  Violations, on the
other hand, are exceptional situations that the program could have
avoided.  Violations are typically programming mistakes.  The
distinction between the two is not always clear, and it may be possible
but inordinately difficult or expensive to detect certain violations.
The use of {\cf eval} also blurs the distinction.  Nevertheless, many
cases do allow distinguishing between errors and violations.
Consequently, exception handlers that handle errors are common,
whereas programmers should introduce exception handlers that handle
violations with great care.


\chapter{I/O}

\section{File names}
% \label{filenamesection}

The file names in most common operating systems, despite their
appearance in most cases, are not text: For example, Unix uses
null-terminated byte sequences, and Windows uses null-terminated
sequences of UTF-16 code units.  On Unix, the textual representation
of a file name depends on the locale, an environmental setting.  In both
cases, a file name may be an invalid encoding and thus not correspond
to a string.  An appropriate representation for file names that covers
these cases while still offering convenient access to file-system
names through strings is still an open problem.  Therefore,
\rn{6} allows specifying file names as strings, but also allows an
implementation to add its own representation for file names.

\section{File options}

The flags specified for {\cf file-options} represent only a common
subset of meaningful options on popular platforms.  The {\cf
  file-options} form does not restrict the \hyper{file-options name}s,
so implementations can extend the file options by platform-specific
flags.

\section{End-of-line styles}

The set of end-of-line styles recognized by the \rsixlibrary{ports}
library is not closed, because end-of-line styles other than those
listed might become commonplace in the future.

\section{Error-handling modes}

The set of error-handling modes is not closed, because implementations
may support error-handling modes other than those listed.

\section{Binary and textual ports}

The plethora of widely used encodings for texts makes providing
textual I/O significantly more complicated than the simple model
offered by \rn{5}.  In particular, realistic textual I/O should
address encodings such as UTF-16 that include a header word
determining the ``actual'' encoding of the rest of the byte stream,
stateful encodings, and textual formats such as XML, which specify the
encoding in a header line.  Consequently, a library implementing
textual I/O should support specifying an encoding upon opening a port,
but should also support opening a port in ``binary mode'' to determine
the encoding and switch to ``text mode''.

In contrast, arbitrary switching between ``binary mode'' and ``text
mode'' is difficult to support, as it may interfere with efficient
buffering strategies, and because the semantics may be unclear in the
case of stateful encodings.  Consequently, the \rsixlibrary{io ports}
library allows switching from ``binary mode'' to ``text mode'' by
converting a binary port into a textual port, but not the other way
around.  The {\cf transcoded-port} procedure closes the binary port to
preclude interference between the binary port and the textual port
constructed from it.  Applications that read from sources that
intersperse binary and textual data should open a binary port and use
either {\cf bytevector->string} or the procedures from the
\rsixlibrary{bytevectors} library to convert the binary data to text.

The separation of binary and textual ports enables creating ports from
both binary and textual sources and sinks.  It also makes creating
both binary and textual versions of many procedures
necessary.

\section{File positions}

Transcoded ports do not always support the {\cf port-\hp{}position} and
{\cf set-port-position!} operations: The position of a transcoded port
may not be well-defined, and may be hard to calculate even when
defined, especially when transcoding is buffered.

\section{Freshness of standard ports}

The ports returned by {\cf standard-input-port}, {\cf
  standard-\hp{}output-\hp{}port}, and {\cf standard-error-port} are fresh so it
can be safely closed or converted to a textual port without risking
the usability of an existing port.


\section{Argument conventions}

While the \rsixlibrary{io simple} library provides mostly
\rn{5}-compatible procedures for performing textual I/O, the
\rsixlibrary{io ports} library uses a different convention for
argument ordering.  In particular, the port is always the first
argument.  This enables the use of optional arguments for information
about the data to be read or written, such as the range in a
bytevector.  As this convention is incompatible with the convention of
\rsixlibrary{io simple}, corresponding procedures have different
names.

\chapter{File system}

The \rsixlibrary{files} library provides a minimal set of procedures
useful in many programs: The {\cf file-exists?} procedure allows a
program to detect the presence of a file if it is going to overwrite
it, and {\cf delete-file} allows taking the appropriate action if the
old file is no longer useful.

Standardization of procedures that return or pass to another procedure
the name of a file is more difficult than standardization of {\cf
  file-exists?} and {\cf delete-file}, because strings are either
awkward or insufficient for representing file names on some platforms,
such as Unix and Windows.  See section~\ref{filenamesection}.

\chapter{Arithmetic}

\section{Fixnums and flonums}

Fixnum and flonum arithmetic is already supported by many systems,
mainly for efficiency. Standardization of fixnum and flonum arithmetic
increases the portability of code that uses it.  Standardizing the
precision of fixnum and flonum arithmetic would make it inefficient on
some systems, which would defeat its purpose.  Therefore, \rn{6}
specifies the syntax and much of the semantics of fixnum and flonum
arithmetic, but makes the precision implementation-dependent.

Existing implementations employ different implementation strategies
for fixnums: Some implement the model specified by \rn{6} (overflows
cause exceptions), some implement modular arithmetic (overflows ``wrap
around''), and others do not handle arithmetic overflows at all.  The
latter model violates the safety requirement of \rn{6}.  In programs
that use fixnums instead of generic arithmetic, overflows are
typically programming mistakes.  The model chosen for \rn{6} has the
advantage that such overflows do not get silently converted into
meaningless number objects, and that the programs gets notified of the
violation through the exception system.

\section{Bitwise operations}

The bitwise operations have been adapted from the operations described
in SRFIs 33~\cite{srfi33} and 60~\cite{srfi60}.

\section{Notes on individual procedures}

\begin{description}
\item[{\tt fx+} and {\tt fx*}]
These procedures are restricted to two arguments, because their
generalizations to three or more arguments would require
precision proportional to the number of arguments.
\item[{\tt real->flonum}]
This procedure is necessary, because not all real number objects are inexact, and
because some inexact real number objects may not be flonums.
\item[{\tt flround}]
The {\cf flround} procedure rounds to even for consistency with the default rounding
mode specified by the IEEE floating-point standard.
\item[{\tt flsqrt}]
The behavior of {\cf flsqrt} on $-0.0$ is consistent with the IEEE
floating-point standard.
\end{description}

\chapter{{\tt syntax-case}}

While many syntax transformers are succinctly expressed using the
high-level {\cf syntax-rules} form, others cannot be succinctly expressed.
Still others are impossible
to write, including transformers that introduce visible bindings for or references
to identifiers that do not appear explicitly in the input form, transformers that
maintain state or read from the file system, and transformers that construct new
identifiers.
The {\cf syntax-case} system~\cite{syntacticabstraction} 
allows the programmer to write transformers that perform these sorts of
transformations, and arbitrary additional transformations, without
sacrificing the default enforcement of hygiene or the high-level
pattern-based syntax matching and template-based output construction
provided by {\cf syntax-rules} (report
section~\extref{report:syntax-rules}{Macro transformers}).

\chapter{Hashtables}

\section{Caching}

The specification notes that hashtables are allowed to cache the
results of calling the hash function and equivalence function, and
that any hashtable operation may call the hash function more than
once.  Hashtable lookups are often followed by updates, so caching may
improve performance.  Hashtables are free to change their internal
representation at any time, which may result in many calls to the hash
function.

\section{Immutable hashtables}

Hashtable references may be less expensive with immutable hashtables.
Also, the creator of a hashtable may wish to prevent 
modifications, particularly by code outside of the creator's 
control.

\section{Hash functions}

The {\cf make-eq-hashtable} and {\cf make-eqv-hashtable} constructors
are designed to hide their hash function.  This allows implementations
to use the machine address of an object as its hash value, rehashing
parts of the table as necessary if a garbage collector moves
objects to different addresses.

\chapter{Enumerations}

Many procedures in many libraries accept arguments from a finite set,
or subsets of a finite set to describe a certain mode of operation,
or several flags to describe a mode of operation.  Examples in the
\rn{6} include the endianness for bytes-object operations, and file
and buffering modes in the I/O library.  Offering a default policy for
dealing with such values fosters portable and readable code, much as
records do for compound values, or multiple values for procedures
computing several values.  Moreover, representations of sets from a
finite set of options should offer the standard set operations, as
they tend to occur in practice.  One such set operation is the
complement, which makes lists of symbols a less than suitable
representation.

Different Scheme implementations have taken different approaches to
this problem in the past, which suggests that a default policy does
more than merely encode what any sensible programmer would do anyway.  As
possible uses occur quite frequently, this particular aspect of
interface construction has been standardized.


\chapter{Composite library}

The \thersixlibrary{} library is intended as a convenient import for
libraries where fine control over imported bindings is not necessary
or desirable. The \thersixlibrary{} library exports all bindings for
{\cf expand} as well as {\cf run} so that it is convenient for writing
{\cf syntax-case} macros as well as run-time code.

The \thersixlibrary{} library does not include a few select libraries:
%
\begin{itemize}
\item \rsixlibrary{eval}, as its presence may make creating
  self-contained programs more difficult;
\item \rsixlibrary{mutable-pairs}, as its absence from a program may enable compiler
  optimizations, and as mutable pairs might be deprecated in the future;
\item \rsixlibrary{mutable-strings}, for similar reasons as for
  \rsixlibrary{mutable-pairs};
\item \rsixlibrary{r5rs}, as its features are deprecated.
\end{itemize}

\chapter{Mutable pairs}

The presence of mutable pairs causes numerous problems:
%
\begin{itemize}
\item It complicates the specification of higher-order procedures that
  operate on lists.
\item It inhibits certain compiler optimizations such as
  deforestation.
\item It complicates reasoning about programs that use lists.
\item It complicates the implementation of procedures that accept
  variable numbers of arguments.
\end{itemize}
%
However, removing mutable pairs from the language entirely would have
caused significant compatibility problems for existing code.  As a
compromise, the {\cf set-car!} and {\cf set-cdr!} procedures were
moved to a separate library.  This facilitates statically determining
if a program ever mutates pairs, encourages writing programs that do
not mutate pairs, and may help deprecating or removing mutable pairs
in the future.

\chapter{Mutable strings}

The presence of mutable strings causes problems similar to some of the
problems caused by the presence of mutable pairs.  Hence, the same
reasoning applies for moving the mutation operations into a separate
library.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newpage                   %  Put bib on it's own page (it's just one)
%\twocolumn[\vspace{-.18in}]%  Last bib item was on a page by itself.
\renewcommand{\bibname}{References}

\bibliographystyle{plain}
\bibliography{abbrevs,rrs}

\end{document}


unity: = commands.tex revision.tex status.tex semantics-commands.tex r6rs.tex intro.tex struct.tex mustard.tex numbers.tex lex.tex basic.tex entry.tex library.tex programs.tex syntax.tex expansion.tex base.tex semantics.tex derived.tex repository.tex example.tex changes r6rs-app.tex rrs.bib abbrevs.bib r6rs-lib.tex unicode.tex bytevector.tex list.tex sort.tex control.tex records.tex exc.tex io.tex iocond.tex portio.tex convio.tex programlib.tex arith.tex syntax-case.tex hashtable.tex enum.tex complib.tex eval.tex setcar.tex stringset.tex r5rscompat.tex r6rs-rationale.tex
