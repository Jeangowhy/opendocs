===================================================
Mastering Regular Expressions
===================================================

.. figure:: https://tse1-mm.cn.bing.net/th/id/OIP-C.cJ_-FCke70sZXkGh6VdkQQHaJt
    :alt: Mastering Regular Expressions

.. sidebar:: 版权信息

    :书名: Mastering Regular Expressions
    :作者: Ben Forta
    :ISBN: 978-7-115-16474-2
    :reStructured: Jeango_

.. _Jeango: https://github.com/Jeangowhy/opendocs/blob/main/RegExp.rst
.. _cover: https://tse1-mm.cn.bing.net/th/id/OIP-C.cJ_-FCke70sZXkGh6VdkQQHaJt

目 录
===================================================

.. contents:: Table of Contents
.. sectnum:: :suffix: 💦
    :start: 0

.. Commented TOC
    * 版权声明
    * 引言
    * 第1章 正则表达式入门
    * 1.1 正则表达式的用途
    * 1.2 如何使用正则表达式
    * 1.3 什么是正则表达式
    * 1.4 使用正则表达式
    * 1.5 在继续学习之前
    * 1.6 小结
    * 第2章 匹配单个字符
    * 2.1 匹配纯文本
    * 2.2 匹配任意字符
    * 2.3 匹配特殊字符
    * 2.4 小结
    * 第3章 匹配一组字符
    * 3.1 匹配多个字符中的某一个
    * 3.2 利用字符集合区间
    * 3.3 取非匹配
    * 3.4 小结
    * 第4章 使用元字符
    * 4.1 对特殊字符进行转义
    * 4.2 匹配空白字符
    * 4.3 匹配特定的字符类别
    * 4.4 使用POSIX字符类
    * 4.5 小结
    * 第5章 重复匹配
    * 5.1 有多少个匹配
    * 5.2 匹配的重复次数
    * 5.3 防止过度匹配
    * 5.4 小结
    * 第6章 位置匹配
    * 6.1 边界
    * 6.2 单词边界
    * 6.3 字符串边界
    * 6.4 小结
    * 第7章 使用子表达式
    * 7.1 什么是子表达式
    * 7.2 子表达式
    * 7.3 子表达式的嵌套
    * 7.4 小结
    * 第8章 回溯引用：前后 一致匹配
    * 8.1 回溯引用有什么用
    * 8.2 回溯引用匹配
    * 8.3 回溯引用在替换操作中的应用
    * 8.4 小结
    * 第9章 前后查找
    * 9.1 前后查找
    * 9.2 向前查找
    * 9.3 向后查找
    * 9.4 把向前查找和向后查找结合起来
    * 9.5 对前后查找取非
    * 9.6 小结
    * 第10章 嵌入条件
    * 10.1 为什么要嵌入条件
    * 10.2 正则表达式里的条件
    * 10.3 小结
    * 附录A 常见应用软件 和编程语言中的 正则表达式
    * A.1 grep
    * A.2 JavaScript
    * A.3 Macromedia ColdFusion
    * A.4 Macromedia Dreamweaver
    * A.5 Macromedia HomeSite（和ColdFusion Studio）
    * A.6 Microsoft ASP
    * A.7 Microsoft ASP.NET
    * A.8 Microsoft C#
    * A.9 Microsoft .NET
    * A.10 Microsoft Visual Studio .NET
    * A.11 MySQL
    * A.12 Perl
    * A.13 PHP
    * A.14 Sun Java
    * 附录B 常见问题的正则表 达式解决方案
    * B.1 北美电话号码
    * B.2 美国邮政编码
    * B.3 加拿大邮政编码
    * B.4 英国邮政编码
    * B.5 美国社会安全号码
    * B.6 IP地址
    * B.7 URL地址
    * B.8 完整的URL地址
    * B.9 电子邮件地址
    * B.10 HTML注释
    * B.11 JavaScript注释
    * B.12 信用卡号码
    * B.13 小结
    * 附录C 正则表达式测试器
    * C.1 Regular Expression Tester软件
    * C.2 获得这套应用程序的一份副本
    * 附录D
    * 索引


版权声明
===================================================

Authorized translation from the English language edition, entitled Sams Teach Yourself Regular
Expressions In 10 Minutes, 0672325667 by FORTA, BEN, published by Pearson Education, Inc.,
publishing as Sams, Copyright © 2004 by Sams Publishing.

All rights reserved. No part of this book may be reproduced or transmitted in any form or by any
means, electronic or mechanical, including photocopying, recording or by any information storage
retrieval system, without permission from Pearson Education, Inc.

Simplified Chinese-language edition Copyright © 2007 by Posts & Telecommunications Press. All
rights reserved.

本书中文简体字版由 Pearson Education Inc. 授权人民邮电出版社独家出版。未经出版者 
书面许可，不得以任何方式复制或抄袭本书内容。
版权所有，侵权必究。


引 言
===================================================

正则表达式（regular expression）和正则表达式语言已经出现很多年了。正则表达式的 
专家们早就掌握了这种威力无比强大的武器，它可以用来完成各种复杂的文本处理工作。
更重要的是，这种武器可以在几乎所有的程序设计语言里和几乎所有的计算机平台上使用。

这是个好消息，但我还要告诉你一个坏消息：长期以来，只有一些真正的专家才能真正掌握 
正则表达式。甚至有很多人根本没有听说过正则表达式这个概念，更不用说用它们来解决问
题了。至于少数勇于涉猎正则表达式领域的人们，又往往会因为正则表达式难以理解而浅尝
辄止或总是在原地徘徊。这不能不说是一种悲哀，因为正则表达式其实并没有人们想像中的
那么复杂。只要你能清晰地理解你想要解决的问题并学会如何使用正则表达式，就可以轻而
易举地解决这些问题。

正则表达式不为大多数人所掌握的原因之一是关于这方面的好资料太少了。虽然有很多网站 
在吹嘘它们的正则表达式教程如何全面，但实际情况却是高质量的正则表达式学习资源相当
稀缺。即便能够找到几本介绍正则表达式的书籍，它们又往往过于偏重语法而显得不够实用
——知道如何定义{或是知道+与*之间的区别并不等于真正掌握了正则表达式的用法。在笔者
看来，那些书籍反而把简单的问题弄得更复杂了：在学习和使用正则表达式的时候，重要的
并不是你知道多少个特殊字符，而是你会不会运用它们去解决实际问题。

你拿在手里的这本书并不打算成为一本正则表达式的大全。如果你想要的是那样一本书，你
应该去阅读 Jeffrey Friedl 编写的 Mastering Regular Expressions（O'Reilly 出版公司，ISBN
0596002890）。Friedl 先生是业内公认的正则表达式专家，他的书绝对是这方面最权威和全面
的著作。本人对Friedl先生没有丝毫成见，但他的书不适合初学者也是实情；如果你只打算尽
快完成手头的工作而不是要钻研正则表达式的内部原理的话，他的书也不很适用。这并不是
说那本书里的信息没有用，只是它在你想要给HTML表单添加一些验证功能或者只想对解析
的文本进行替换的时候派不上什么用场。如果你想尽快学会正则表达式的基本用法，你将发
现自己陷入了一个两难境地：要么找不到简明易学的参考资料，要么找到的参考资料过于深
奥而让你不知该如何起步。

这正是促使笔者编写本书的原因。本书所讲授的关于正则表达式知识正是你们在刚起步时最 
需要的，我们将从简单的文本匹配开始循序渐进地向大家介绍许多复杂的专题，其中包括回
溯引用（backreference，或译为后向引用）、条件性求值（conditional evaluation）和前后查找
（looking- around），等等。本书最大的优势是所学到的知识可以立即运用于实践中：我们在
每章里都为大家准备了许多简明又实用的示例，它们可以帮助你全面、系统、快速地掌握正
则表达式并运用它们去解决实际问题，而每章在10分钟甚至更短的时间里就可以学完。

还等什么，赶快翻到第1章开始今天的学习吧，你肯定会立刻感受到正则表达式的强大威力。 

目标读者
===================================================

本书的目标读者是以下几类人员:

1. ● 第一次接触正则表达式。
2. ● 希望自己能够快速掌握正则表达式的基本用法。
3. ● 想使用一种强大的工具（虽然它不那么容易掌握）去解决实际问题。
4. ● 正在开发Web应用软件并需要进行复杂的表单和文本处理。
5. ● 正使用着Perl、ASP、Visual Basic、.NET、C#、Java、JSP、PHP、ColdFusion语言（或
    更多其他程序设计语言），希望在开发的应用程序里使用正则表达式。
6. ● 希望在不求助于其他人的前提下尽快掌握正则表达式。

致 谢
===================================================

首先，我要感谢正则表达式专家和我以前的合作者 Michael Dinowitz，他对本书的技术细节进 
行了严格的审校并提供了许多宝贵的意见和反馈。

本书的 附录C 向大家介绍了一种基于 Web 的正则表达式测试器，而我必须在此感谢这个测试器 
的原始作者 Nate Weiss（它最初是为 ColdFusion Web Application Construction Kit 一书而编写
的）。在 Nate 的许可和支持下，我对他用 ColdFusion 编写的正则表达式测试软件进行了改写以
配合本书使用，开发了相应的 JavaScript 版本。感谢 Qasim Rasheed 为这个测试器编写 ASP 
和 JSP 版本，感谢 Scott Van Vliet 为这个测试器编写 ASP.NET 版本。

最后，我还要感谢Sams出版公司里帮助我把本书从概念变成现实的人们，尤其是 
Michael Stephens 和 Mark Renfrow。没有他们的帮助和支持，本书是不可能与大家见面的。
谢谢大家。

——Ben Forta


===================================================
Chapter 01. 正则表达式入门
===================================================

在本章里，你将学习何为正则表达式以及它们可以帮助你做些什么。 


P1.1 正则表达式的用途
===================================================

正则表达式（regular expression，简称 regex）是一种工具，和其他工具一样，它是人们为了解 
决某一类专门的问题而发明的。要想理解正则表达式及其功用，最好的办法是了解它们可以
解决什么样的问题。

请考虑以下几个场景:


01. ● 你正在搜索一个文件，这个文件里包含着单词car（不区分字母大小写），但你并不想
    把包含着字符串car的其他单词（比如 scar、carry 和 incarcerate，等等）也找出来。

02. ● 你打算用一种应用服务器来动态地生成一个Web网页以显示从某个数据库里检索出来的
    文本。在那些文本里可能包含着一些URL地址字符串，而你希望那些URL地址在最终生
    成的页面里是可点击的（也就是说，你打算生成一些合法的 HTML 代码 ``<A HREF>``
    ``</A>``——而不仅仅是普通的文本）。

03. ● 你创建了一份包含着一张表单的Web页面，这张表单用来收集用户信息，其中包括一个
    电子邮件地址。你需要检查用户给出的电子邮件地址是否符合正确的语法格式。

04. ● 你正在编辑一段源代码并且要把所有的size都替换为isize，但这种替换仅限于单词
    size本身而不涉及那些包含着字符串size的其他单词。

05. ● 你正在显示一份计算机文件系统中所有文件的清单，但你只想把文件名里包含着
    Application字样的文件列举出来。

06. ● 你正在把一些数据导入应用程序。那些数据以制表符作为分隔符，但你的应用程序要支
    持CSV格式（每条记录独占一行，同一条记录里的各项数据之间用逗号分隔并允许被括
    在引号里面）。

07. ● 你需要在文件里搜索某个特定的文本，但你只想把出现在特定位置的（比如每行的开头
    或是每条语句的结尾）找出来。

以上场景都是大家在编写程序时经常会遇到的问题，用任何一种支持条件处理和字符串操作 
的编程语言都可以解决它们——但问题是你的解决方案将会变得十分复杂。比较容易想到的
办法是，用一些循环来依次遍历那些单词或字符并在循环体里面用一系列if语句来进行测试，
这往往意味着你需要使用大量的标志来标记你已经找到了什么，你还没有找到什么，还需要
检查空白字符和特殊字符，等等。而这一切都需要以手工方式来进行。

另一种解决方案是使用正则表达式。上述问题都可以用一些精心构造的语句——或者说 
一些由文本和特殊指令构成的高度简练的字符串来解决，比如像下面这样的语句::

    \b[Cc][Aa][Rr]\b

.. Note:: 注意

    如果你现在还看不懂这一行，先别着急。你很快就会知道它的含义是什么。


P1.2 如何使用正则表达式
===================================================

如果认真思考一下那些问题场景，你就会发现它们不外乎两种情况：一种是查找特定的信息 
（搜索），另一种是查找并编辑特定的信息（替换）。事实上，从根本上来讲，那正是正则
表达式的两种基本用途：搜索和替换。给定一个正则表达式，它要么匹配一些文本（进行一
次搜索），要么匹配并替换一些文本（进行一次替换）。 


P1.2.1 用正则表达式进行搜索
===================================================

正则表达式的主要用途之一是搜索变化多端的文本，比如刚才描述的搜索单词car的场景： 
你要把 car、CAR、Car，或 CaR 都找出来，但这只是整个问题比较简单的一部分（有许多搜
索工具都可以完成不区分字母大小写的搜索）。比较困难的部分是确保 scar、carry 和
incarcerate 之类的单词不会被匹配到。一些比较高级的编辑器提供了“Match Only Whole
Word（仅匹配整个单词）”选项，但还有许多编辑器并不具备这一功能，而你往往无法在你正
在编辑的文档里做出这种调整。使用正则表达式而不是纯文本car进行搜索就可以解决这个
问题。


.. Hint:: 提示

    想知道如何解决这个问题吗？你们其实已经见过答案了——它就是我们刚才给出的
    示例语句::

        \b[Cc][Aa][Rr]\b

    请注意，“等于”比较（比如说，用户给出的电子邮件地址是否匹配这个正则表达式？） 
    本质上也是一种搜索操作，这种搜索操作会对用户所提供的整个字符串进行搜索以寻找一
    个匹配。与此相对的是子字符串搜索，子字符串搜索是“搜索”这个词的普通含义。


P1.2.2 用正则表达式进行替换
===================================================

正则表达式搜索的威力非常强大，非常有用，而且比较容易学习和掌握。本书的许多章节和 
示例都与“匹配”有关。不过，正则表达式的真正威力体现在替换操作方面，比如我们刚才所
描述的需要把 URL 地址字符串替换为可点击 URL 地址的场景：这需要先把相关文本里的 URL 
地址字符串找出来（比如说，通过搜索以http://或https://开头、以句号、逗号或空白
字符结尾的字符串），再把找到的 URL 地址字符串替换为 HTML 语言的 
``<A HREF=…> … </A>`` 元素，如下所示::

    http://www.forta.com/

替换结果::

    <A HREF="http://www.forta.com">http://www.forta.com/</A>

绝大多数应用程序的“Search and Replace”（搜索和替换）选项都可以完成这种替换操作， 
但使用一个正则表达式来完成这个任务将简单得让人难以置信。


P1.3 什么是正则表达式
===================================================

现在，你已经知道正则表达式是用来干什么的了，我们再来给它下个定义。简单地说，正则 
表达式是一些用来匹配和处理文本的字符串。正则表达式是用正则表达式语言创建的，这种
语言的用途就是为了解决我们前面所描述的种种问题。与其他程序设计语言一样，正则表达
式语言也有需要你们去学习的特殊语法和指令，它们正是本书要教给大家的东西。

正则表达式语言并不是一种完备的程序设计语言，它甚至算不上是一种能够直接安装并运行 
的程序。更准确地说，正则表达式语言是内置于其他语言或软件产品里的“迷你”语言。好在
现在几乎所有的语言或工具都支持正则表达式，但是正则表达式与你正在使用的语言或工具
可以说毫无相似之处。正则表达式语言虽然也被称为一种语言，但它与人们对语言的印象相
去甚远。

.. Caution:: 注意

    正则表达式起源于1950年代在数学领域的一些研究工作。几年之后，计算机领域借 
    鉴那些研究工作的成果和思路开发出了Unix世界里的Perl语言和grep等工具程序。在许多
    年里，正则表达式只流行于Unix平台（Unix程序员用它们来解决我们前面所描述的各种问
    题），但这种情况早已发生了变化，现在几乎所有的计算平台都支持正则表达式，只是具
    体方式和支持程度略有差异而已。

说完这些掌故，我们再来看几个例子。下面都是合法的正则表达式（我们稍后再解释它们 
的用途）:

    1. ● ``Ben``
    2. ● ``.``
    3. ● ``www\.forta\.com``
    4. ● ``[a-zA-Z0-9_.]*``
    5. ● ``<[Hh]1>.*</[Hh]1>``
    6. ● ``\r\n\r\n``
    7. ● ``\d{3,3}-\d{3,3}-\d{4,4}``

请注意，语法是正则表达式最容易掌握的部分，真正的挑战是学会如何运用那些语法把实际 
问题分解为一系列正则表达式并最终解决。与学习其他程序设计语言一样，只靠读书是学不
会如何灵活运用语法正则的，你必须通过亲身实践才能真正掌握它们。


P1.4 使用正则表达式
===================================================

正如前面解释的那样，不存在所谓的正则表达式程序；它既不是可以直接运行的应用程序， 
也不是可以从哪里购买或下载来的软件。在绝大多数的软件产品、编程语言、工具程序和开
发环境里，正则表达式语言都已被实现。

正则表达式的使用方法和具体功能，在不同的应用程序/语言中各有不同。一般来说，应用程 
序大多使用菜单选项和对话框来访问正则表达式，而程序设计语言大都在函数或对象类中使
用正则表达式。

此外，并非所有的正则表达式实现都是一样的。在不同的应用程序/语言里，正则表达式的语 
法和功能往往会有明显（有时也不那么明显）的差异。

附录A对支持正则表达式的许多应用程序和语言在这方面的细节进行了汇总。在继续学习下一 
章之前，你应该先熟悉一下附录A，看看你们正在使用的应用程序或语言在正则表达式方面都
有哪些与众不同之处。

为了帮助大家尽快入门，我们在这本书的配套网页 http://www.forta.com/books/0672325667/ 
上准备了一个名为“Regular Expression Tester（正则表达式测试器）”的工具软件供大家下载。
这个基于 Web 的工具软件有好几种版本，它们分别对应着一些比较流行的应用服务器和编程语
言，还有一个版本是专门用来直接测试用 JavaScript 语言编写出来的正则表达式的。附录 C 对
这个工具软件的用法进行了介绍，这个工具可以简便、快速地对你们构造出来的正则表达式
进行测试，这对大家的学习肯定会有很大的帮助。


P1.5 在继续学习之前
===================================================

在继续学习之前，你还应该了解以下几个事实::


    1. ● 在使用正则表达式的时候，你将发现几乎所有的问题都有不止一种解决方案。它们有的
        比较简单，有的比较快速，有的兼容性更好，有的功能更全。这么说吧，在编写正则表
        达式的时候，只有对、错两种选择的情况是相当少见的——同一个问题往往会有多种解
        决方案。

    2. ● 正如我们前面讲过的那样，正则表达式的不同实现往往会有所差异。在编写本书的时
        候，我们已尽了最大努力来保证各章里的示例能适用于尽可能多的实现；但有些差异和
        不兼容是无法回避的，我们针对这种情况都尽可能地进行了注明。

    3. ● 与其他程序设计语言一样，学习正则表达式的关键是实践，实践，再实践。

.. Caution:: 注意

    我们强烈建议大家在学习本书的过程中能够亲自实践每一个示例。


P1.6 小结
===================================================

正则表达式是文本处理方面功能最强大的工具之一。正则表达式语言用来构造正则表达式 
（最终构造出来的字符串就称为正则表达式），正则表达式用来完成搜索和替换操作。

===================================================
Chapter 02. 匹配单个字符
===================================================

在本章里，你将学习如何对一个或多个字符进行简单的字符匹配。 


P2.1 匹配纯文本
===================================================

Ben 是一个正则表达式。因为本身是纯文本，所以看起来可能不像是一个正则表达式，但它 
的确是。正则表达式可以包含纯文本（甚至可以只包含纯文本）。当然，像这样使用正则表
达式是一种浪费，但把它作为我们学习正则表达式的起点还是很不错的。
我们来看一个例子:

:文本:

    .. code-block:: text

        Hello, my name is Ben. Please visit
        my website at http://www.forta.com/.

:正则表达式: Ben

:结果:

    .. code-block:: text

        Hello, my name is Ben. Please visit

.. Hint:: 分析

        这里使用的正则表达式是纯文本，它将匹配原始文本里的 Ben。

我们再来看一个例子，它使用了与刚才相同的原始文本和另外一个正则表达式: 

:文本:

    .. code-block:: text

        Hello, my name is Ben. Please visit
        my website at http://www.forta.com/.

:正则表达式: my

:结果:

    .. code-block:: text

        Hello, my name is Ben. Please visit
        my website at http://www.forta.com/.

.. Hint:: 分析

        正则表达式中的 my 也是静态文本，它在原始文本里找到了两个匹配结果。


P2.1.1 有多个匹配结果
===================================================

绝大多数正则表达式引擎的默认行为是只返回第 1 个匹配结果。具体到上面那个例子。 
怎样才能把两个或更多个匹配结果都找出来呢？绝大多数正则表达式的实现都提供了一种能
够把所有的匹配结果全部找出来的机制（通常返回为一个数组或是其他的专用格式）。比如
说，JavaScript 脚本可用 g（“global”）全局标志将返回一个包含着所有匹配的结果数组。

.. Caution:: 注意

    如果你想知道在你正在使用的语言或工具里如何进行全局匹配，请参阅本书的附
    录A。


P2.1.2 字母的大小写问题
===================================================

正则表达式是区分字母大小写的，所以 Ben 不匹配 ben。不过，绝大多数正则表达的式实现 
也支持字母大小写不敏感匹配操作。比如，JavaScript 用户可以用 i 标志来强制执行一次不区
分字母大小写的搜索。

.. Caution:: 注意

    如果你想知道你正在使用着的语言或工具里如何进行不区分字母大小写的搜索操
    作，请参阅本书的附录A。


P2.2 匹配任意字符
===================================================

前面见到的正则表达式都是些静态的纯文本，它们根本体现不出正则表达式的威力。下面， 
我们一起来看看如何使用正则表达式去匹配不可预知的字符。
在正则表达式里，特殊字符（或字符集合）用来给出要搜索的东西。.字符（英文句号）可以
匹配任何一个单个的字符。

.. Note:: 提示

    可能你曾经使用过 DOS 的文件搜索功能，正则表达式里的 . 字符相当于 DOS 的 ? 字符。
    SQL 用户将注意到正则表达式里的 . 字符相当于SQL中的 _（下划线）字符。

于是，用正则表达式 c.t 进行搜索将匹配到 cat 和 cot（还能匹配到一些毫无意义的单词）。 

:文本:

    .. code-block:: text

        sales1.xls
        orders3.xls
        sales2.xls
        sales3.xls
        apac1.xls
        europe2.xls
        na1.xls
        na2.xls
        sa1.xls

:正则表达式: sales.

:结果:

    .. code-block:: text

        sales1.xls
        sales2.xls
        sales3.xls

.. Hint:: 分析

        正则表达式 sales. 将从文本串中找出前缀 sales 的文件名，句点匹配任意一个字符。
        9 个文件里有 3 个与这个模式（pattern）相匹配。

.. Note:: 提示

    人们常用模式表示实际的正则表达式。

.. Caution:: 注意
    
    正则表达式可以用来匹配包含着字符串内容的模式。匹配的并不总是整个字符
    串，而是与某个模式相匹配的字符——即使它们只是整个字符串的一部分。在上面的例子
    里，我们使用的正则表达式并不能匹配整个文件名，它只匹配了文件名的一部分。如果你
    需要把某个正则表达式的匹配结果传递到其他代码或应用程序里做进一步处理，就必须记
    住这一细节差异。

. 字符可以匹配任何单个的字符、字母、数字甚至是.字符本身。

:文本:

    .. code-block:: text

        sales.xls
        sales1.xls
        orders3.xls
        sales2.xls
        sales3.xls
        apac1.xls
        europe2.xls
        na1.xls
        na2.xls
        sa1.xls

:正则表达式: sales.

:结果:

    .. code-block:: text

        sales.xls
        sales1.xls
        sales2.xls
        sales3.xls

.. Hint:: 分析

        这个例子比上一个多了一个 sales.xls 文件。因为 . 能够匹配任何一个单个的字符，
        所以这个文件也与模式 sales. 相匹配。

在同一个正则表达式里允许使用多个 . 字符，它们既可以连续出现，比如 .. 将 
匹配任意两个字符，也可以间隔着出现在模式的不同位置。

再来看一个使用了相同原始文本的例子：找出 na（表示北美）或 sa（表示南美）开头的 
文件，不管它们后面跟着一个什么数字。

:文本:

    .. code-block:: text

        sales1.xls
        orders3.xls
        sales2.xls
        sales3.xls
        apac1.xls
        europe2.xls
        na1.xls
        na2.xls
        sa1.xls

:正则表达式: .a.

:结果:

    .. code-block:: text

        sales1.xls
        sales2.xls
        sales3.xls
        apac1.xls
        na1.xls
        na2.xls
        sa1.xls

.. Hint:: 分析

        正则表达式 .a. 把 na1、na2 和 sa1 找了出来，但它同时还找到了 4 个预料之外
        的匹配结果。为什么会这样？因为模式匹配由任意字符包围的 a。

我们真正需要的是后面再紧跟着一个英文句号的.a.的模式。我们再来试一次: 

:文本:

    .. code-block:: text

        sales1.xls
        orders3.xls
        sales2.xls
        sales3.xls
        apac1.xls
        europe2.xls
        na1.xls
        na2.xls
        sa1.xls

:正则表达式: .a..

:结果:

    .. code-block:: text

        sales1.xls
        sales2.xls
        sales3.xls
        apac1.xls
        na1.xls
        na2.xls
        sa1.xls

.. Hint:: 分析

        .a.. 并不比 .a. 好多少；新增加的 . 将匹配任何一个多出来的字符（不管它是什么）。
        既然 . 是一个能够与任何一个单个字符相匹配的特殊字符，我们怎样才能搜索 . 本身呢？


P2.3 匹配特殊字符
===================================================

. 字符在正则表达式里有着特殊的含义。如果模式里需要一个 . 就要想办法来告诉正则表达
式你需要的是 . 字符本身，而不是它在正则表达式里的特殊含义。为此，必须在 . 的前面
加上 \ 反斜杠字符来对它进行转义。\ 是一个元字符（metacharacter，表示“这个字符有特
殊含义，而不是字符本身含义”）。

我们再来验证一次刚才的例子，这次我们使用了 \. 转义符号: 

:文本:

    .. code-block:: text

        sales1.xls
        orders3.xls
        sales2.xls
        sales3.xls
        apac1.xls
        europe2.xls
        na1.xls
        na2.xls
        sa1.xls

:正则表达式: ``.a.\.xls``

:结果:

    .. code-block:: text

        na1.xls
        na2.xls
        sa1.xls

.. Hint:: 分析

        .a.\.xls 解决了问题。第 1 个 . 匹配 n（在前两个匹配结果里）或 s（在第 3 
        个匹配结果里），第 2 个 . 匹配 1（在第 1 个和第 3 个匹配结果里）或 2
        （在第2个匹配结果里）。接下来，\. 匹配文件名与扩展名之间的分隔符 . 本身。
        最后的xls匹配它本身。（事实上，即使没有最后面的 xls，这次搜索的结果也会
        与我们预想的一样；加上 xls 可以避免匹配到诸如 sa3.doc 之类的文件名。）

正则表达式中 \ 字符永远出现在一个有着特殊含义的字符序列的开头，这个序列可以由一 
个或多个字符构成。刚才的是 \. 序列，在后面的章节里还会看到更多使用了 \ 字符的例子。

我们将在第 4 章里对特殊字符的用法做专题讲解。 

.. Caution:: 注意

    如果需要搜索\本身，就必须对\字符进行转义；相应的转义序列是两个连续的反
    斜杠字符\\。

.. Note:: 提示

    我们刚才讲过，.可以匹配任何一个字符，这一说法并非绝对准确。在绝大多数的
    正则表达式实现里，.只能匹配除换行符以外的任何单个字符。


P2.4 小结
===================================================

正则表达式经常被简称为模式，它们其实是一些由字符构成的字符串。这些字符可以是普通 
字符（纯文本）或元字符（有特殊含义的特殊字符）。在这一章里，我们介绍了如何使用普
通字符和元字符去匹配单个的字符。. 可以匹配任何字符。\ 用来对字符进行转义。在正则表
达式里，有特殊含义的字符序列总是以 \ 字符开头。

===================================================
Chapter 03. 匹配一组字符
===================================================

在本章里，你将学习如何与字符集合打交道。与可以匹配任意单个字符的 . 字符不同， 
（参见第 2 章）字符集合只能匹配特定的字符和字符区间。


P3.1 匹配多个字符中的某一个
===================================================


第 2 章介绍 . 字符可以匹配任意单个字符。在第 2 章的最后一个例子里，我们使用了 .a 
来匹配 na 和 sa。现在，如果在那份文件清单里增加了一个名为 ca1.xls 的文件，而你仍
只想找出 na 和 sa，你该怎么办？别忘了，. 也能匹配 c，所以文件名 cal.xls 也会被找出。

既然只想找出 n 和 s，使用匹配任意字符的 . 显然不行——我们不需要匹配任意字符， 
只要匹配 n 和 s 这两个字符。在正则表达式里，我们可以使用元字符 [ 和 ] 来定义一个
字符集合。在使用 [ 和 ] 定义的字符集合里，这两个元字符之间的所有字符都是该集合的
组成部分，字符集合的匹配结果是能够与该集合里的任意一个成员相匹配的文本。

下面这个例子与第 2 章里的最后一个例子相似，这次的正则表达式里使用了一个字符集合: 

:文本:

    .. code-block:: text

        sales1.xls
        orders3.xls
        sales2.xls
        sales3.xls
        apac1.xls
        europe2.xls
        na1.xls
        na2.xls
        sa1.xls
        ca1.xls

:正则表达式: ``[ns]a.\.xls``

:结果:

    .. code-block:: text

        na1.xls
        na2.xls
        sa1.xls

.. Hint:: 分析

        这里使用的正则表达式以 [ns] 开头；这个集合将匹配字符 n 或 s（但不匹配字符 c
        或其他字符）。[ 和 ] 不匹配任何字符，它们只负责定义一个字符集合。接下来，
        正则表达式里的字符 a 将匹配一个 a 字符，. 将匹配一个任意字符，\. 将匹配
        一个句点 . 字符本身，xls 将匹配字符串 xls。从结果上看，这个模式只匹配了 3
        个文件名，与我们的预期完全一致。

.. Caution:: 注意

    虽然结果正确，但模式 ``[ns]a.\.xls`` 并不是最正确的答案。如果那份文件清单里
    还有一个名为 usa1.xls 的文件，它也会被匹配出来。这里涉及了位置匹配问题，而我们
    将在第6章里对此做专题讨论。

.. Note:: 提示
    
    正如看到的那样，对正则表达式进行测试是很有技巧的。验证某个模式能不能获得预期
    的匹配结果并不困难，但如何验证它不会匹配到你不想要的东西可就没那么简单了。

字符集合在不需要区分字母大小写（或者是只须匹配某个特定部分）的搜索操作里比较常 
见。比如说:

:文本:

    .. code-block:: text

        The phrase "regular expression" is often
        abbreviated as RegEx or regex.

:正则表达式: [Rr]eg[Ee]x

:结果:

    .. code-block:: text

        abbreviated as RegEx or regex.

.. Hint:: 分析

        这里使用的模式包含着两个字符集合：[Rr] 负责匹配字母 R 和 r，[Ee] 负责匹配
        字母 E 和 e。这个模式可以匹配 RegEx 和 regex，但不匹配 REGEX。

.. Note:: 提示

    如果你打算进行一次不需要区分字母大小写的匹配，不使用这个技巧也能达到目的。
    这种模式最适合用在从全局看需要区分字母大小写，但在某个局部不需要区分字母大
    小写的搜索操作里。


P3.2 利用字符集合区间
===================================================

我们再来仔细看看那个从一份文件清单里找出特定文件的例子。我们刚才使用的模式[ns]a.
\.xls还存在着另外一个问题。如果那份文件清单里有一个名为sam.xls的文件，结果会怎
样？显然，因为.可以匹配所有的字符而不是仅限于数字，所以文件sam.xls也会出现在匹配
结果里。

这个问题可以用一个如下所示的字符集合来解决: 

:文本:

    .. code-block:: text

        sales1.xls
        orders3.xls
        sales2.xls
        sales3.xls
        apac1.xls
        europe2.xls
        sam.xls
        na1.xls
        na2.xls
        sa1.xls
        ca1.xls

:正则表达式: ``[ns]a[0123456789]\.xls``

:结果:

    .. code-block:: text

        sales1.xls
        orders3.xls
        sales2.xls
        sales3.xls
        apac1.xls
        europe2.xls
        sam.xls
        na1.xls
        na2.xls
        sa1.xls
        ca1.xls

.. Hint:: 分析

        在这个例子里，我们改用了另外一个模式，这个模式的匹配对象是：第 1 个字符必须是
        n 或 s，第2个字符必须是a，第3个字符可以是任何一个数字（因为我们使用了字符集合
        [0123456789]）。注意，文件名sam.xls没有出现在匹配结果里，这是因为m与我们给定
        的字符集合（10个数字）不相匹配。

在使用正则表达式的时候，会频繁地用到一些字符区间（0~9、A~Z，等等）。为了简化字符 
区间的定义，正则表达式提供了一个特殊的元字符——字符区间可以用-（连字符）来定义。
下面还是刚才那个例子，但我们这次使用了一个字符区间:

:文本:

    .. code-block:: text

        sales1.xls
        orders3.xls
        sales2.xls
        sales3.xls
        apac1.xls
        europe2.xls
        sam.xls
        na1.xls
        na2.xls
        sa1.xls
        ca1.xls

:正则表达式: ``[ns]a[0-9]\.xls``

:结果:

    .. code-block:: text

        na1.xls
        na2.xls
        sa1.xls

.. Hint:: 分析

        模式 [0-9] 的功能与 [0123456789] 完全等价，所以这次的匹配结果与刚才那个例子完全一
        样。

字符区间并不仅限于数字，以下这些都是合法的字符区间:

    1. ● A-Z，匹配从A到Z的所有大写字母。
    2. ● a-z，匹配从a到z的所有小写字母。
    3. ● A-F，匹配从A到F的所有大写字母。
    4. ● A-z，匹配的 ASCII 字符从 A 到 z 的所有字母。这个模式一般不常用，因为它还包
        含着 [ 和 ^ 等在 ASCII 字符表里排列在 Z 和 a 之间的字符。

字符区间的首、尾字符可以是 ASCII 字符表里的任意字符。但在实际工作中，最常用的字符区 
间还是数字字符区间和字母字符区间。

.. Note:: 提示

    在定义一个字符区间的时候，一定要避免让这个区间的尾字符小于它的首字符，
    例如 [3-1]。这种区间是没有意义的，而且往往会让整个模式失效。

.. Caution:: 注意

    -（连字符）是一个特殊的元字符，作为元字符它只能用在[和]之间。在字符集合
    以外的地方，-只是一个普通字符，只能与-本身相匹配。因此，在正则表达式里，-字符
    不需要被转义。

在同一个字符集合里可以给出多个字符区间。比如说，下面这个模式可以匹配任何一个字母 
（无论大小写）或数字，但除此以外的其他字符（既不是数字也不是字母的字符）都不匹
配::

    [A-Za-z0-9]

这个模式是下面这个字符集合的简写形式::

    [ABCDEFGHIJKLMNOPQRSTUVWXYZabcde
    ➥fghijklmnopqrstuvwxyz01234567890]

正如大家看到的那样，字符范围使得正则表达式的语法变得非常简明。 

下面是另一个例子，这次要查找的是RGB值（用一个十六进制数字给出的红、绿、蓝三基色 
的组合值，计算机可以根据 RGB 值把有关的文字或图象显示为由这三种颜色按给定比例调和
出来的色彩）。在网页里，RGB 值是以 #000000（黑色）、 #FFFFFF（白色）、
#FF0000（红色）的形式给出的。RGB 值用大写或小写字母给出均可，所以 #FF00ff（品红
色）也是合法的 RGB 值。下面就是这个例子:

:文本:

    .. code-block:: text

        <BODY BGCOLOR="#336633" TEXT="#FFFFFF"
        MARGINWIDTH="0" MARGINHEIGHT="0"
        TOPMARGIN="0" LEFTMARGIN="0">

:正则表达式: #[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]

:结果:

    .. code-block:: text

        <BODY BGCOLOR="#336633" TEXT="#FFFFFF"
        MARGINWIDTH="0" MARGINHEIGHT="0"
        TOPMARGIN="0" LEFTMARGIN="0">

.. Hint:: 分析

        这里使用的模式以普通字符#开头，随后是 6 个同样的[0-9A-Fa-f]字符集合。这将匹配一个
        由字符 # 开头，然后是 6 个数字或字母 A 到 F（大小写均可）的字符串。


P3.3 取非匹配
===================================================

字符集合通常用来指定一组必须匹配其中之一的字符。但在某些场合，我们需要反过来做， 
给出一组不需要得到的字符。换句话说，除了那个字符集合里的字符，其他字符都可以匹
配。

最先想到的办法是，用一个字符集合把你需要的字符一一列举出来，但如果只需要把一小部 
分字符排除在外的话，那么做既麻烦又容易有遗漏。其实这里有一个更简明的办法：用元字
符^来表明你想对一个字符集合进行取非匹配——这与逻辑非运算很相似，只是这里的操作数
是字符集合而已。

:文本:

    .. code-block:: text

        sales1.xls
        orders3.xls
        sales2.xls
        sales3.xls
        apac1.xls
        europe2.xls
        sam.xls
        na1.xls
        na2.xls
        sa1.xls
        ca1.xls

:正则表达式: ``[ns]a[^0-9]\.xls``

:结果:

    .. code-block:: text

        sam.xls

.. Hint:: 分析

    这个例子里使用的模式与前面的例子里使用的模式刚好相反。前面 **[0-9]** 只匹配数字，
    而这里 **[^0-9]** 匹配的是任何非数字符号。也就是说，**[ns]a[^0-9]\.xls** 将匹配
    sam.xls，但不匹配包含数字符号的 na1.xls、na2.xls 或 sa1.xls。

.. Note:: 注意

    ^的效果将作用于给定字符集合里的所有字符或字符区间，而不是仅限于紧跟在^
    字符后面的那一个字符或字符区间。


P3.4 小结
===================================================

元字符[和]用来定义一个字符集合，其含义是必须匹配该集合里的字符之一。定义一个字符 
集合的具体做法有两种：一是把所有的字符都列举出来；二是利用元字符 **-** 以字符区间的方式
给出。字符集合可以用元字符^来求非；这将把给定的字符集合强行排除在匹配操作以外——
除了该字符集合里的字符，其他字符都可以被匹配。

===================================================
Chapter 04. 使用元字符
===================================================

本书第一次提到元字符的章节是第2章。在这一章里，你们将学习如何使用更多的元字符 
去匹配特定的字符或字符类型。


P4.1 对特殊字符进行转义
===================================================

在介绍其他元字符的用法之前，我们认为应该先把特殊字符的转义问题向大家解释清楚。 
元字符是一些在正则表达式里有着特殊含义的字符。英文句号 **.** 是一个元字符，它可以用
来匹配任何一个单个字符（详见第2章）。类似地，左方括号 **[** 也是一个元字符，它标志
着一个字符集合的开始（详见第3章）。

因为元字符在正则表达式里有着特殊的含义，所以这些字符就无法用来代表它们本身。比如 
说，你不能使用一个 **[** 来匹配 **[** 本身，也不能使用 **.** 来匹配 **.** 本身。

来看一个例子，用一个正则表达式去匹配一个包含着 **[** 和 **]** 字符的 JavaScript 数组: 

:文本:

    .. code-block:: text

        var myArray = new Array();
        ...
        if (myArray[0] == 0) {
        ...
        }

:正则表达式: myArray[0]

:结果:

    .. code-block:: text

        var myArray = new Array();
        ...
        if (myArray[0] == 0) {
        ...
        }

.. Hint:: 分析

        在这个例子里，原始文本是一段 JavaScript 代码，正则表达式则是程序员在使用一个文本编辑
        器去编写 JavaScript 代码时经常会用到的搜索字符串。我们的本意是用这个正则表达式把代码
        里的 myArray[0] 记号找出来，可结果与预期完全不一样。为什么会这样？因为 [ 和 ] 在正则
        表达式里是用来定义一个字符集合的元字符，而不是 [ 和 ] 本身。所以，myArray[0] 将匹
        配 myArray 后面跟着一个该集合成员的情况，而那个集合只有一个成员0。因此，
        myArray[0] 只能匹配到 myArray0。

正如我们在第2章里解释的那样，在元字符的前面加上一个反斜杠就可以对它进行转义。 
转义序列 \. 将匹配 . 本身，转义序列 \[ 将匹配 [本身。每个元字符都可以给它加上
反斜杠前缀来转义，如此得到的转义序列将匹配那个字符本身而不是它特殊的元字符含
义。要想匹配 **[** 和 **]** ，就必须对这两个字符进行转义。下面的例子与刚才的问题完全一样，
但这次对正则表达式里的元字符都进行了转义:

:文本:

    .. code-block:: text

        var myArray = new Array();
        ...
        if (myArray[0] == 0) {
        ...
        }

:正则表达式: ``myArray\[0\]``

:结果:

    .. code-block:: text

        var myArray = new Array();
        ...
        if (myArray[0] == 0) {
        ...
        }

.. Hint:: 分析

        这次搜索取得了预期的结果。``\[`` 将匹配 ``[``，``\]`` 将匹配 ``]``，
        所以 ``myArray\[0\]`` 匹配到了 myArray[0]。

具体到这个例子，用一个正则表达式来进行搜索多少有点儿小题大做——因为一个简单的文 
本匹配操作已足以完成这一任务，而且还会更容易一些。但如果你想查找的不仅仅是
myArray[0]，还包括 myArray[1]、myArray[2] 等，用一个正则表达式来进行搜索就很有必要。
具体做法是，对 [ 和 ] 进行转义，再列出需要在它们之间得到匹配的字符。如果
你想匹配数组元素 0 到 9，你构造出来的正则表达式应该是下面这个样子::

    myArray\[[0-9]\]

.. Note:: 提示

    任何一个元字符都可以通过给它加上一个反斜杠字符（``\``）作为前缀的办法来转
    义，能够被转义的元字符并不仅局限于我们这里提到的那几个。

.. Warning:: 警告

    配对的元字符（比如 [ 或 ] ）不用作元字符时必须被转义，否则正则表达式分析器
    很可能会抛出一个错误。

对元字符进行转义需要用到 ``\`` 字符。这意味着 ``\`` 字符也是一个元字符——它的特殊 
含义是对其他元字符进行转义。正如你在第2章里看到的那样，在需要匹配 ``\`` 本身的时候，我们必须把它转义为 ``\\``。

看看下面这个简单的例子。例子中的原始文本是一个包含着反斜杠字符的文件路径（用于 
DOS 和 Windows 系统），而我们想在 Linux/Unix 系统上使用这个路径——也就是说，我
们需要把这个路径里的反斜杠字符（``\``）全部替换为正斜杠字符（/）:

:文本:

    .. code-block:: text

        \home\ben\sales\

:正则表达式: ``\\``

:结果:

    .. code-block:: text

        \home\ben\sales\

.. Hint:: 分析

    ``\\`` 匹配 ``\``，总共找到了 4 个匹配。如果你在这个正则表达式里只写出了一个
    ``\`` 的话，属于语法错误。正确的正则表达式里，字符 ``\`` 后面永远跟着另一个字符。


P4.2 匹配空白字符
===================================================

元字符大致可以分为两种：一种是用来匹配文本的（比如 . ），另一种是正则表达式的语法所 
要求的，比如 [ 和 ]。随着学习的深入，你将发现越来越多的这两种元字符，而我们现在要
介绍给大家的是一些用来匹配各种空白字符的元字符。

在进行正则表达式搜索的时候，我们经常会遇到需要对原始文本里的非打印空白字符进行匹 
配的情况。比如说，我们可能需要把所有的制表符找出来，或者我们需要把换行符找出来，
这类字符很难被直接输入到一个正则表达式里，但我们可以使用表 4-1 列出的特殊元字符来输
入它们。

表 4-1 空白元字符

=========  ==========================================
元字符          说  明
=========  ==========================================
``[\b]``         回退（并删除）一个字符（Backspace键）
``\f``           换页符
``\n``           换行符
``\r``           回车符
``\t``           制表符（Tab键）
``\v``           垂直制表符
=========  ==========================================

下一个例子中的原始文本包含着一些以逗号分隔（CSV格式）的数据记录， 任务是对 
这些记录做进一步处理之前，先把夹杂在这些数据里的空白行去掉:

:文本:

    .. code-block:: text

        "101","Ben","Forta"
        "102","Jim","James"
        "103","Roberta","Robertson"
        "104","Bob","Bobson"

:正则表达式: ``\r\n\r\n``

:结果:

    .. code-block:: text

        "101","Ben","Forta"
        "102","Jim","James"
        "103","Roberta","Robertson"
        "104","Bob","Bobson"

.. Hint:: 分析


    ``\r\n`` 匹配一个“回车换行”符号组合，Windows 操作系统把这个组合用作文本行结束。
    使用正则表达式 ``\r\n\r\n`` 进行的搜索将匹配两个连续的行尾标签，而那正是
    两条记录之间的空白行。

.. Note:: 提示

    ``\r\n`` 是 Windows 所使用的文本行结束标签。Unix/Linux 系统只使用一个换行符来
    结束一个文本行；换句话说，Unix/Linux 系统上匹配空白行只使用 ``\n\n`` 即可。
    同时适用于 Windows 和 Unix/Linux 系统的正则表达式应该包含一个可选的 ``\r`` 和
    一个必须被匹配的 ``\n``。你可以在下一章看到一个这样的例子。

一般来说，需要匹配 ``\r``、``\n`` 和 ``\t`` 制表符等空白字符的情况比较多见， 
需要匹配其他空白字符的情况要相对少一些。

.. Caution:: 注意

    你已经见过不少元字符了，但你注意到它们之间的差异了吗？.和[是元字符，但
    前提是你没有对它们进行转义。f和n也是元字符，但前提是你对它们进行了转义。如果
    你没有对f和n进行转义，它们将被解释为普通字符，只能匹配它们本身。


P4.3 匹配特定的字符类别
===================================================

到目前为止，你已经见过如何匹配特定的字符、如何匹配任意单个字符（用.）、如何匹配 
多个字符中的某一个（用[和]）以及如何进行取非匹配（用^）。字符集合（匹配多个字符中
的某一个）是最常见的匹配形式，而一些常用的字符集合可以用特殊元字符来代替。这些元
字符匹配的是某一类别的字符（术语称之为“字符类”）。类元字符并不是必不可少的东西
（你总是可以通过逐一列举有关字符或是通过定义一个字符区间的办法来匹配某一类字
符），但用它们构造出来的正则表达式简明易懂，在实践中很有用。

.. Caution:: 注意

    下面列出的字符类都是最基本的，几乎所有的正则表达式实现都支持它们。


P4.3.1 匹配数字（与非数字）
===================================================

我们在第 3 章讲过，[0-9] 是 [0123456789] 的简写形式，它可以用来匹配任何一个数字。 
如果你想匹配的是除数字以外的其他东西，那么把这个集合“反”过来写成 [^0-9] 就行了。
表 4-2 列出了用来匹配数字和非数字的类元字符。

表 4-2 数字元字符

=========  ===========================================
元字符         说 明
=========  ===========================================
``\d``          任何一个数字字符（等价于[0-9]）
``\D``          任何一个非数字字符（等价于[^0-9]）
=========  ===========================================

为了演示这些元字符的用法，我们来看一个在前面见过的例子: 

:文本:

    .. code-block:: text

        var myArray = new Array();
        ...
        if (myArray[0] == 0) {
        ...
        }

:正则表达式: ``myArray\[\d\]``

:结果:

    .. code-block:: text

        var myArray = new Array();
        ...
        if (myArray[0] == 0) {
        ...
        }

.. Hint:: 分析

        ``\[`` 匹配 [，``\d`` 匹配任意单个数字字符，``\]`` 匹配 ]， 所 以 myArray ``\[\d\]``
        匹 配 出 myArray[0]。``myArray\[\d\]`` 是 ``myArray\[[0-9]\]`` 的简写形式，而后者
        又是 ``myArray\[[0123456789]\]`` 的简写形式。这个正则表达式还可以匹配 myArray[1]、
        myArray[2] 等等，但不匹配 myArray[10]。

.. Note:: 提示

    正如大家看到的那样，在与正则表达式打交道的时候，同样的问题几乎总是有好几
    种不同的解决办法。这些办法并无优劣之分，你尽可以选择最熟悉的那种语法。

.. Warning:: 警告

    正则表达式的语法是区分字母大小写的。``\d`` 匹配数字，``\D`` 与 ``\d`` 的含义刚好相反。
    接下来将看到的其他类元字符也是如此。


P4.3.2 匹配字母和数字（与非字母和数字）
===================================================

字母和数字，A 到 Z（不分大小写）、数字 0 到 9、再加上下划线字符（_），这些是 
比较常用的字符集合；这些字符常见于各种名字里，如（文件名、子目录名、变量名、数据库
对象名，等等）。表 4-3 列出了用来匹配字母数字和非字母数字的类元字符。

表4-3 字母数字元字符

=========  =============================================
元字符          说 明
=========  =============================================
``\w``       任何一个字母数字字符（大小写均可）或下划线字符，等价于 ``[a-zA-Z0-9_]``
``\W``       任何一个非字母数字或非下划线字符，等价于 ``[^a-zA-Z0-9_]``
=========  =============================================

下面这个例子里的原始文本是一些来自某个数据库的记录，那些记录的内容是北美地区 
某些城市的邮政编码① :

:文本:

    .. code-block:: text

        11213
        A1C2E3
        48075
        48237
        M1B4F2
        90046
        H1H2H2

:正则表达式: ``\w\d\w\d\w\d``

:结果:

    .. code-block:: text

        A1C2E3
        M1B4F2
        H1H2H2

.. Hint:: 分析

        在这个模式里，交替出现的 \w 和 \d 元字符将使得匹配结果里只包含加拿大城市的邮政编码。


① 美国和加拿大城市的邮政编码规则参见附录 B 的 B.2 和 B.3 节。——编者注

.. Caution:: 注意

    在上面这个例子里，我们使用的正则表达式解决了我们的问题。但它正确吗？请大
    家思考一下，为什么美国的邮政编码没有被匹配出来？是因为它们只由数字构成、还是因
    为什么其他原因？

我们将不给出这个问题的答案，理由很简单——例子里的模式解决了问题。这里的关键是 
正则表达式很少有对错之分（当然，前提是它们能解决问题），我们更关心的是它们的复
杂程度——而这要由模式匹配操作的精确程度来决定；如果你需要更精确的匹配，就需要
构造更复杂的正则表达式。


P4.3.3 匹配空白字符（与非空白字符）
===================================================

另一种常见的字符类别是空白字符。在本章前面的内容里，我们向大家介绍了一些用来匹配 
某个特定的空白字符的元字符。表4-4列出了用来匹配所有空白字符的类元字符。

表4-4 空白字符元字符

===========  =========================================
元字符            说 明
===========  =========================================
``\s``          任何一个空白字符（等价于[\f\n\r\t\v]）
``\S``          任何一个非空白字符（等价于[^\f\n\r\t\v]）
===========  =========================================

.. Caution:: 注意

    用来匹配退格字符的 ``[\b]`` 元字符是一个特例：它不在类元字符 ``\s`` 的覆盖范围内，
    当然也就没有被排除在类元字符 ``\S`` 的覆盖范围外。


P4.3.4 匹配十六进制或八进制数值
===================================================

你或许不会遇到需要通过某个特定字符的十六进制值或八进制值来匹配它的情况， 
但我们希望大家明白这是可以做到的。

1.  使用十六进制值
    在正则表达式里，十六进制（逢16进1）数值要用前缀 ``\x`` 来给出。比如说，
    ``\x0A`` 对应于 ASCII 字符10（换行符），其效果等价于 ``\n``。

2.  使用八进制值
    在正则表达式里，八进制（逢8进1）数值要用前缀 ``\0`` 来给出，数值本身可以是两位
    或三位数字。比如说，``\011`` （9）对应于 ASCII 字符制表符，其效果等价于 ``\t``。

.. Caution:: 注意

    有不少正则表达式实现还允许使用 ``\c`` 前缀来指定各种控制字符。比如说，``\cZ`` 
    将匹配 Ctrl-Z。不过，在实际工作中，必须使用这种语法的情况相当少见。


P4.4 使用POSIX字符类
===================================================

对元字符以及各种字符集合进行的讨论，必须要提到 POSIX 字符类。许多（但不是所有） 
正则表达式实现都支持这一种简写形式。

.. Caution:: 注意

    JavaScript 不支持在正则表达式里使用 POSIX 字符类。

表 4-5 POSIX 字符类

==========  ======================================================
字符类      说 明
==========  ======================================================
[:alnum:]   任何一个字母或数字，等价于 ``[a-zA-Z0-9]``
[:alpha:]   任何一个字母，等价于 ``[a-zA-Z]``
[:blank:]   空格或制表符，等价于 ``[\t]`` ①
[:cntrl:]   ASCII控制字符，ASCII 0 到 31，再加上 ASCII 127
[:digit:]   任何一个数字，等价于 [0-9]
[:graph:]   和 [:print:] 一样，但不包括空格
[:lower:]   任何一个小写字母，等价于 [a-z]
[:print:]   任何一个可打印字符
[:punct:]   既不属于 [:alnum:] 也不属于 [:cntrl:] 的任何一个字符
[:space:]   任何一个空白字符，包括空格，等价于 ``[^\f\n\r\t\v]`` ②
[:upper:]   任何一个大写字母，等价于 ``[A-Z]``
[:xdigit:]  任何一个十六进制数字，等价于 ``[a-fA-F0-9]``
==========  ======================================================

1. ① 注意，字母 t 后有一个空格。——译者注
2. ② 注意，字母 v 后有一个空格。——译者注

POSIX 语法与我们此前见过的元字符不太一样。为了演示 POSIX 字符类的用法，来看一 
个前一章里的例子——利用正则表达式从一段 HTML 代码里把 RGB 值查找出来:

:文本:

    .. code-block:: text

        <BODY BGCOLOR="#336633" TEXT="#FFFFFF"
        MARGINWIDTH="0" MARGINHEIGHT="0"
        TOPMARGIN="0" LEFTMARGIN="0">

:正则表达式: #[[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]]

:结果:

    .. code-block:: text

        #336633
        #FFFFFF

.. Hint:: 分析

        在前一章里使用的模式是重复写出的 6 个 ``[0-9A-Fz-f]`` 字符集合，
        把那 6 个 ``[0-9A-Fz-f]`` 全
        部替换为 [[:xdigit:]] 就得到这里的模式。它们的匹配结果完全一样。

.. Caution:: 注意

    这里使用的模式以 [[ 开头、以 ]] 结束（两对方括号）。这是使用 POSIX 字符类所必
    须的。POSIX 字符类必须括在 [: 和 :] 之间，我们使用的 POSIX 字符类是 [:xdigit:]
    （不是 :xdigit: ）。外层的 [ 和 ] 字符用来定义一个字符集合，内层的 [ 和 ] 字符是
    POSIX 字符类本身的组成部分。

.. Warning:: 警告

    一般来说，支持 POSIX 标准的正则表达式实现都支持表 4-5 所列出的那 12 个
    POSIX 字符类，但在一些细节方面可能会与这里的描述有细微的差异。


P4.5 小结
===================================================

我们在第 2 章和第 3 章对字符匹配操作和字符集合匹配操进行了讨论。在此基础上， 
这一章对用来匹配特定字符（制表符、换行符，等等）和用来匹配一个字符集合或字符类
（数字、字母数字字符，等等）的元字符进行了讲解。这些简短的元字符和POSIX字符类可
以用来简化正则表达式模式。

===================================================
Chapter 05. 重复匹配
===================================================

在前几章里，你们学习了如何使用各种元字符、字符集合和字符类去匹配单个字符。 
在这一章里，你将学习如何匹配多个连续重复出现的字符或字符集合。


P5.1 有多少个匹配
===================================================

通过前面的学习，我们已经把正则表达式模式匹配操作的基础知识全都介绍给了大家， 
但我们给出的每个例子都有一个非常严格的限制。现在，请大家思考一下，如何构造一个
匹配电子邮件地址的正则表达式。电子邮件地址的基本格式应该是如下所示的样子::

    text@text.text

利用前一章讨论的元字符，你可能会写出一个如下所示的正则表达式::

    \w@\w\.\w

``\w`` 可以匹配所有的字母和数字字符（以及下划线字符 _，这个字符在电子邮件地址里是合法
的）；@ 字符不需要被转义，但.字符需要。

这个正则表达式本身没有任何错误，可它几乎没有任何实际的用处——它只能匹配 a@b.c 
形式的电子邮件地址（虽然在语法方面没有任何问题，但这显然不是一个合法的地址）。
导致这一结果的关键是 ``\w`` 只能匹配单个字符，而我们无法预知电子邮件地址的各个字段会
有多少个字符。举个最简单的例子，下面这些都是合法的电子邮件地址，但它们在 @ 前面的
字符个数都不一样。

    b@forta.com
    ben@forta.com
    bforta@forta.com

要想解决这类问题，我们需要一种能够匹配多个字符的办法，这可以通过使用几种特殊的 
元字符来做到。


P5.1.1 匹配一个或多个字符
===================================================

要想匹配同一个字符（或字符集合）的多次重复，只要简单地给这个字符（或字符集合） 
加上一个 + 字符作为后缀就行了。+ 匹配一个或多个字符（至少一个；不匹配零个字符的情
况）。比如，a 匹配一个 a 字符，a+ 将匹配一个或多个连续出现的 a。类似地，[0-9] 
匹配任意单个数字，[0-9]+ 将匹配一个或多个连续的数字。

.. Note:: 提示

    在给一个字符集合加上 + 后缀的时候，必须把 + 放在这个字符集合的外面。比如
    说，[0-9]+ 是正确的，[0-9+] 则不是。

    [0-9+] 其实也是一个合法的正则表达式，但它匹配的不是一个或多个数字；它定义了一
    个由数字0到9和+构成的字符集合，因而只能匹配一个单个的数字字符或加号。虽然合
    法，可它并不是我们需要的东西。

重新回到电子邮件地址的例子，我们这次将使用 + 来匹配一个或多个字符: 

:文本:

    .. code-block:: text

        Send personal email to ben@forta.com. For questions about a book use support@forta.com.
        Feel free to send unsolicited email to spam@forta.com (wouldn’t it be nice if it were
        that simple, huh?).

:正则表达式: ``\w+@\w+\.\w+``

:结果:

    .. code-block:: text

        ben@forta.com
        support@forta.com
        spam@forta.com

.. Hint:: 分析

        这个模式把原始文本里的3个电子邮件地址全都正确地匹配出来了。这个正则表达式
        先用第一个 ``\w+`` 匹配一个或多个字母数字字符，再用第二个 ``\w+`` 匹配 
        @ 后面的一个或多个字符，然后匹配一个.字符（使用转义序列 ``\.`` ），
        最后用第三个 ``\w+`` 匹配电子邮件地址的剩余部分。

    .. Note:: 提示

        ``+`` 是一个元字符。如果需要匹配 + 本身，就必须使用它的转义序列 ``\+``。

``+`` 还可以用来匹配一个或多个字符集合。为了演示这种用法，我们在下面这个例子 
使用了和刚才一样的正则表达式，但原始文本和上一个例子稍有不同:

:文本:

    .. code-block:: text

        Send personal email to ben@forta.com or
        ben.forta@forta.com. For questions about a
        book use support@forta.com. If your message
        is urgent try ben@urgent.forta.com. Feel
        free to send unsolicited email to
        spam@forta.com (wouldn’t it be nice if
        it were that simple, huh?).

:正则表达式: ``\w+@\w+\.\w+``

:结果:

    .. code-block:: text

        ben@forta.com
        forta@forta.com
        support@forta.com
        ben@urgent.forta
        spam@forta.com

.. Hint:: 分析

    这个正则表达式匹配到了 5 个电子邮件地址，但其中有两个不够完整。为什么会这样？
    构造这个正则表达式的时候只想到在 @ 字符的后面会有一个 . 字符分开两个字符串的情
    况，没有想到在 @ 字符的前面还会有 . 字符。因此，虽然 ben.forta@forta.com 是一个完全
    合法的电子邮件地址，但这个正则表达式只能匹配forta（而不是ben.forta）——别忘
    了，``\w`` 只能匹配字母和数字字符，不能匹配出现在字符串中间的.字符。

要想干净彻底地解决这个问题，我们需要匹配 ``\w`` 或 . 。用正则表达式的术语来说， 
我们需要匹配字符集合 ``[\w\.]``。下面是上面那个例子的改进版本:

:文本:

    .. code-block:: text

        Send personal email to ben@forta.com or
        ben.forta@forta.com. For questions about a
        book use support@forta.com. If your message
        is urgent try ben@urgent.forta.com. Feel
        free to send unsolicited email to
        spam@forta.com (wouldn’t it be nice if
        it were that simple, huh?).

:正则表达式: ``[\w.]+@[\w.]+\.\w+``

:结果:

    .. code-block:: text

        ben@forta.com
        ben.forta@forta.com
        support@forta.com
        ben@urgent.forta.com
        spam@forta.com

.. Hint:: 分析

    问题似乎得到了圆满解决。``[\w.]+`` 将匹配字符集合 ``[\w.]`` 的一次或多次
    重复出现，（字母数字字符、下划线和 .），ben.forta 完全符合这一条件。
    考虑到有些电子邮件地址会有多层域 名（或主机名），我们在 @ 字符的后面
    也使用了一个 ``[\w.]+``。

.. Caution:: 注意

    这个正则表达式的最后一部分是 ``\w+`` 而不是 ``[\w.]+`` ，你知道这是为什么吗？把
    ``[\w.]`` 用作这个模式的最后一部分会在第2、第3和第4个匹配上出问题，不妨试试。

.. Caution:: 注意

    细心的读者可能已经注意到了：我们没有对字符集合 ``[\w.]`` 里的.字符进行转义。
    尽管如此，它还是把原始文本里的.字符匹配出来了。一般来说，当在字符集合里使用的
    时候，像 . 和 + 这样的元字符将被解释为普通字符，不需要被转义——但转义了也没有坏
    处。``[\w.]`` 的使用效果与 ``[\w\.]`` 是一样的。


P5.1.2 匹配零个或多个字符
===================================================

``+`` 匹配一个或多个字符，但不匹配零个字符，最少也要匹配一个字符。那么，如果 
你想匹配一个可有可无的字符，也就是该字符可以出现零次或多次的情况，你该怎么办呢？

这种匹配需要用 ``*`` 元字符来完成。``*`` 的用法与+完全一样——只要把它放在一个字符 
（或一个字符集合）的后面，就可以匹配该字符（或字符集合）连续出现零次或多次的情况。
比如说，模式 ``B.*`` Forta将匹配 B Forta、B. Forta、Ben Forta和其他有类似规律的组
合。 为了演示 ``+`` 和 ``*`` 的区别，我们来看两个匹配电子邮件地址的例子。先看第一个:

:文本:

    .. code-block:: text

            Hello .ben@forta.com is my email address.

:正则表达式: ``[\w.]+@[\w.]+\.\w+``

:结果:

    .. code-block:: text

            Hello .ben@forta.com is my email address.

.. Hint:: 分析


    ``[\w.]+`` 将匹配字符集合 ``[\w.]`` （字母数字字符、下划线和.）的一次或多次重复出现，
    而 .ben 完全符合这一条件。这显然是一个打字错误（原始文本里多了一个.），
    但这并不是我们这里最关心的问题。问题的关键在于：虽然 . 是电子邮件地址的
    合法字符，但把它用作电子邮件地址的第一个字符就不合法了。

    一个电子邮件地址可以有任意多个字符，但它的第一个字符必须是一个字母或数字。
    根据这一要求，我们真正需要的是一个如下例所示的模式:

:文本:

    .. code-block:: text

            Hello .ben@forta.com is my email address.

:正则表达式: ``\w+[\w.]*@[\w.]+\.\w+``

:结果:

    .. code-block:: text

            Hello .ben@forta.com is my email address.

.. Hint:: 分析


        这个模式看起来相当复杂，但并不难理解。开头的 ``\w+`` 负责匹配电子邮件地址
        第一个字符（一个字母数字字符，不包括.字符）。接下来的 ``[\w.]*`` 负责匹配
        电子邮件地址里第一个字符之后、@ 字符之前的所有字符。这个部分可以包含
        零个或多个字母数字字符和.字符。至于这个模式的其他部分，我们已经在第4章
        里解释过了。在这个例子里，解决问题的关键是能不能想到用 ``[\w.]*`` 来匹配字符
        集合 ``[\w.]`` （字母数字字符、下划线和.）的零次或多次重复出现。

.. Caution:: 注意

    可以把 ``*`` 理解为一个用来表明这样一种含义的元字符：“在我前面的字符（或字符集
    合）是可选的”。 ``*`` 与+的区别是： +匹配一个或多个字符（或字符集合），最少要匹配一
    次； ``*`` 匹配零个或任意多个字符（或字符集合），可以没有匹配。
    提示 ``*`` 是一个元字符。如果需要匹配 ``*`` 本身，就必须使用它的转义序列 ``\*``。


P5.1.3 匹配零个或一个字符
===================================================

另一个非常有用的元字符是 ?，它能匹配一个字符（或字符集合）的零次或一次出现，最多 
不超过一次——请仔细体会 ? 与 + 和 * 的相似和区别之处。如果需要在一段文本里匹配
某个特定的字符（或字符集合）而该字符可能出现、也可能不出现，? 无疑是最佳的选择。
请看下面这个例子:

:文本:

    .. code-block:: text

        The URL is http://www.forta.com/, to connect
        securely use https://www.forta.com/ instead.

:正则表达式: ``http://[\w./]+``

:结果:

    .. code-block:: text

        http://www.forta.com/

.. Hint:: 分析

        这是一个用来匹配 URL 地址的模式：http:// 是普通文本，只能匹配它本身；随后的
        ``[\w./]+`` 匹配字符集合 ``[\w./]`` （字母数字字符、. 和 /）的一次或多次重复出现。这个模式
        只匹配到了第一个 URL 地址（以http://开头的那个），没能匹配到第二个（以https://
        开头的那个）。简单地在 http 的后面加上一个 s*（s的零次或多次重复）并不能真正解决这
        个问题，因为那会使得 httpsssss://（如此开头的URL地址显然是不合法的）也被认为是
        一个合法的匹配。

怎么办？看看下面这个例子，在 http 的后面加上一个 s?: 

:文本:

    .. code-block:: text

        The URL is http://www.forta.com/, to connect
        securely use https://www.forta.com/ instead.

:正则表达式: ``https?://[\w./]+``

:结果:

    .. code-block:: text

        http://www.forta.com/
        https://www.forta.com/

.. Hint:: 分析

        这个模式的开头部分是https?。? 在这里的含义是：我前面的字符（s）要么不出现，要么
        最多出现一次。换句话说，https?://既可以匹配 http://，也可以匹配 https://，但也
        就仅此而已。

在 4.3.3 节里有一个用模式 ``\r\n\r\n`` 去匹配空白行的例子。分析那个例子说过： 
在 Unix 或 Linux 系统上匹配空白行只使用 ``\n\n`` 即可，不需要加上 ``\r``；同时适用于
Windows 和 Unix/Linux 系统的正则表达式应该包含一个可选的 ``\r`` 和一个必须被匹配的 ``\n``。
现在，你应该想到可以用 ? 来解决这个问题了。下面还是那个例子，但这次将使用一个略
有不同的正则表达式:

:文本:

    .. code-block:: text

        "101","Ben","Forta"
        "102","Jim","James"
        "103","Roberta","Robertson"
        "104","Bob","Bobson"

:正则表达式: ``[\r]?\n[\r]?\n``

:结果:

    .. code-block:: text

        "101","Ben","Forta"
        "102","Jim","James"
        "103","Roberta","Robertson"
        "104","Bob","Bobson"

.. Hint:: 分析

        ``[\r]?\n`` 匹配一个可选的 ``\r`` 和一个必不可少的 ``\n``。

.. Note:: 提示

    细心的读者可能已经注意到了，上面这个例子里的正则表达式使用的是 ``[\r]?`` 而
    不是 ``\r?``。``[\r]`` 定义了一个字符集合，该集合只有元字符 ``\r`` 这一个成员，因而 ``[\r]?``
    在功能上与 ``\r?`` 完全等价。[ ] 常规用法是把多个字符定义为一个集合，但有不少程序员
    喜欢把一个字符也定义为一个集合。这么做的好处是可以增加可读性和避免产生误解，让
    人们一眼就可以看出哪个字符与哪个元字符相关联。这里必须提醒大家注意这样一个细
    节：如果你打算同时使用 [ ] 和 ?，千万记得应该把 ? 放在字符集合的外面。具体到刚才那
    个匹配 URL 地址的例子，写成 http[s]?:// 是正确的，若是写成 http[s?]:// 可就弄
    巧成拙了。

.. Note:: 提示

    ? 是一个元字符。如果需要匹配 ? 本身，就必须使用它的转义序列 ``\?``。


P5.2 匹配的重复次数
===================================================

正则表达式里的 +、* 和 ? 解决了许多问题，但有些问题光靠它们还不够。请思考以下问题: 

1. ● + 和 * 匹配的字符个数没有上限。我们无法为它们将匹配的字符个数设定一个最大值。
2. ● +、* 和 ? 至少匹配零个或一个字符。我们无法为它们将匹配的字符个数另行设定一个最
    小值。
3. ● 如果只使用 + 和 * ，我们无法把它们将匹配的字符个数设定为一个精确的数字。

为了解决这些问题并让程序员对重复性匹配有更多的控制，正则表达式语言提供了一个用来 
设定重复次数（interval）的语法。重复次数要用 { 和 } 字符来给出——把数值写在它们之间。

.. Caution:: 注意

    { 和 } 是元字符。如果需要匹配 { 和 } 本身，就应该用 ``\`` 对它们进行转义。
    不过，即使你没有对 { 和 } 进行转义，大部分正则表达式实现也能正确地处理它们，
    根据具体情况它们解释为普通字符或元字符。话虽如此，为了避免不必要的麻烦，
    最好不要依赖这种行为；在需要把{和}当做普通字符来匹配的场合，还是使用它们的
    转义序列 ``\{`` 和 ``\}`` 比较稳妥。


P5.2.1 为重复匹配次数设定一个精确的值
===================================================

如果你想为重复匹配次数设定一个精确的值，把那个数字写在 ``\{`` 和 ``\}`` 之间即可。 
比如说， {3} 意味着模式里的前一个字符或字符集合必须在原始文本里连续重复出现 3 次
才算是一个匹配；如果只重复了两次，则不算是一个匹配。

为了演示这种用法，再回看 RGB 值的例子（请对照第 3 章和第 4 章里的类似例子）。 
你应该记得，RGB值是一个十六进制数值，这个值分成3个部分，每个部分包括两位十
六数字。下面是我们在第3章里用来匹配RGB值的模式::

    #[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]
    ➥[0-9A-Fa-f]

下面是我们在第 4 章里用来匹配 RGB 值的模式，它使用了 POSIX 字符类::

    #[[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]][[
    ➥:xdigit:]]

这两个模式本身并无不妥，但美中不足的是你不得不重复写出 6 次相同的字符集合或 
POSIX 字符类。下面是一个同样的例子，但这次将使用 { } 语法来明确指定一个重复次数:

:文本:

    .. code-block:: text

        <BODY BGCOLOR="#336633" TEXT="#FFFFFF"
        MARGINWIDTH="0" MARGINHEIGHT="0"
        TOPMARGIN="0" LEFTMARGIN="0">

:正则表达式: #[[:xdigit:]]{6}

:结果:

    .. code-block:: text

        #336633
        #FFFFFF

.. Hint:: 分析

        [:xdigit] 匹配一个十六进制数字，{6} 要求这个 POSIX 字符类必须连续出现 6 次。
        类似地，使用模式 #[0-9A-Fa-f]{6} 也可以解决这个问题。


P5.2.2 为重复匹配次数设定一个区间
===================================================

{} 语法还可以用来为重复匹配次数设定一个区间——也就是为重复匹配次数设定一个最小值
和一个最大值。这种区间必须以 {2, 4} 这样的形式给出，它的含义是最少重复 2 次、
最多重复 4 次。在下面的例子里，我们将使用一个这样的正则表达式来检查日期的格式:

:文本:

    .. code-block:: text

        4/8/03
        10-6-2004
        2/2/2
        01-01-01

:正则表达式: ``\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4}``

:结果:

    .. code-block:: text

        4/8/03
        10-6-2004
        01-01-01

.. Hint:: 分析

        这里列出的日期是一些由用户通过某个表单字段输入的值——在对这些日期值做
        进一步处理之前，我们需要先检查它们的格式是否正确。``\d{1, 2}`` 将匹配一个或
        两个数字字符，匹配日子和月份。``\d{2, 4} `` 用来匹配年份。[-``\/]`` 用来匹配
        日期值里的分隔符 - 或 /（请注意，这里的 ``\/ `` 其实是一个 ``\`` 和一个 /）。
        我们总共匹配到了 3 个日期值，但 2/2/2 不在此列（因为它的年份太短了）。

.. Note:: 提示

    在这个例子里，我们使用了 / 的转义序列 ``\/`` 。这在许多正则表达式实现里是不必要
    的，但有些正则表达式分析器要求我们必须这样做。为避免不必要的麻烦，在需要匹配
    / 字符本身的时候，你最好总是使用它的转义序列。

.. Caution:: 注意

    上面这个例子里的模式并不能检查日期值是否有效；诸如 54/67/9999 之类的无效日
    期也能通过这一测试。它只能用来检查日期值的格式是否正确（这一环节通常安排在
    日期值本身的有效性检查之前）。

.. Caution:: 注意

    重复次数可以是 0。比如，{0, 3} 表示重复次数可以是 0、1、2 或 3。
    我们曾经讲过，?匹配它之前一个字符（或字符集合）的零次或一次出现。因此，
    从效果上看，? 等价于 {0, 1}。


P5.2.3 匹配“至少重复多少次”
===================================================

{ } 语法的最后一种用法是给出一个最小的重复次数（但不必给出一个最大值）。这种 
用法与我们用来为重复匹配次数设定一个区间的语法很相似，只是省略了最大值部分而
已。比如说，{3, } 表示至少重复 3 次，与之等价的说法是“必须重复 3 次或更多次”。
来看一个综合了本章主要内容的例子。在这个例子里，我们使用一个正则表达式把所有
大于或等于$100美元的金额找出来:

:文本:

    .. code-block:: text

        1001: $496.80
        1002: $1290.69
        1003: $26.43
        1004: $613.42
        1005: $7.61
        1006: $414.90
        1007: $25.00

:正则表达式: ``\d+: \$\d{3,}\.\d{2}``

:结果:

    .. code-block:: text

        1002: $1290.69
        1004: $613.42
        1006: $414.90

.. Hint:: 分析

        这个例子里的原始文本来自一份报表，它的第一列是定单号，第二列是定单金额。
        我们构造的正则表达式首先使用了一个 ``\d+:`` 来匹配定单号（这部分其实可以省略，
        可以只匹配金额部分而不是匹配包括定单号在内的一整行）。
        模式 ``\$\d{3, }\.\d{2}`` 用来匹配金额部分：
        ``\$`` 匹配 $、 ``\d{3,}`` 匹配至少 3 位连续数字、``\.`` 匹配小数点。
        ``\d{2}`` 匹配小数点后面的两位数字。
        整个模式从7条记录里正确地匹配到了4条符合要求的记录。

.. Note:: 提示

    在进行这种重复次数匹配的时候一定要小心。如果你遗漏了花括号里的逗号,，你
    的模式将变成（具体到这个例子）精确匹配3位数字而不再是匹配至少3位数字。


P5.3 防止过度匹配
===================================================

? 只能匹配零个或一个字符，{n} 和 {m, n} 也有一个重复次数的上限；换句话说，这几种语 
法所定义的“重复次数”都是有限的。但本章介绍的其他重复匹配语法在重复次数方面都没有
上限值，而这样做有时会导致过度匹配的现象。

到目前为止，我们选用的例子都不存在过度匹配的问题，但你迟早会遇到类似于下面这个例 
子的情况。这个例子里的原始文本来自一个Web页面，其中包含着两个 HTML ``<B>`` 标签；而
我们的任务是用一个正则表达式把那两个 ``<B>`` 标签里的文本匹配出来（为了对这些文本进行
替换或排版等）。下面就是这个例子:

:文本:

    .. code-block:: text

        This offer is not available to customers
        living in <B>AK</B> and <B>HI</B>.

:正则表达式: <[Bb]>.*</[Bb]>

:结果:

    .. code-block:: text

        <B>AK</B> and <B>HI</B>

.. Hint:: 分析

        <[Bb]>匹配<B>标签（大小写均可），</[Bb]>匹配</B>标签（也是大小写均可）。但这
        个模式只找到了一个匹配而不是预期中的两个：第一个<B>标签之后、最后一个</B>标签之
        前的所有东西 ``AK</B> and <B>HI`` 被 .* 一网打尽。虽然没有漏掉我们想要匹配的
        文本，但问题是第2个<B>标签不明不白地“失踪”了。

为什么会这样？因为``*``和``+``都是所谓的“贪婪型”元字符，它们在进行匹配时的 
行为模式是多多益善而不是适可而止的。它们会尽可能地从一段文本的开头一直匹配到
这段文本的末尾，而不是从这段文本的开头匹配到碰到第一个匹配时为止。
在不需要这种“贪婪行为”的时候该怎么办？答案是使用这些元字符的“懒惰型”版本（“懒惰”在
这里的含义是匹配尽可能少的字符——与“贪婪型”元字符的行为模式刚好相反）。懒惰型元
字符的写法很简单，只要给贪婪型元字符加上一个?后缀即可。表5-1列出了几个常用的贪婪
型元字符和它们的懒惰型版本。

表 5-1 常用的贪婪型元字符和它们的懒惰型版本 

=============  ==============
 贪婪型元字符        懒惰型元字符 
=============  ==============
     ``*``             ``*?``
     ``+``            ``+?``
     {n, }             {n, }?
=============  ==============

``*?`` 是 ``*`` 的懒惰型版本；下面是使用 ``*?`` 来解决刚才那个例子的做法:

:文本:

    .. code-block:: text

        This offer is not available to customers
        living in <B>AK</B> and <B>HI</B>.

:正则表达式: <[Bb]>.*?</[Bb]>

:结果:

    .. code-block:: text

        <B>AK</B>
        <B>HI</B>

问题得到了圆满解决。因为使用了懒惰的 ``*?``，第一个匹配将仅限于AK，原始文本里的 
<B>HI</B>成为了第二个匹配。


.. Note:: 注意

    这本书里的大多数例子使用的都是“贪婪型”元字符，而我们这么做的出发点是为
    了让那些示例模式尽可能地简明易懂。在实际工作中，请务必根据具体情况来选用
    “贪婪型”或“懒惰型”元字符。


P5.4 小结
===================================================

正则表达式的真正威力体现在重复次数匹配方面。本章介绍了 +（匹配字符或字符集合的一次 
或多次重复出现）、``*`` （匹配字符或字符集合的零次或多次重复出现）、?（匹配字符或字符
集合的零次或一次出现）等几个元字符的用法。要想获得更精确的控制，你可以用{ }语法
来精确地设定一个重复次数或是重复次数的最小值和最大值。元字符分“贪婪型”和“懒惰
型”两种；在需要防止过度匹配的场合下，请使用“懒惰型”元字符来构造你的正则表达式。

===================================================
Chapter 06. 位置匹配
===================================================

到目前为止，你已经学习了许多元字符的用法。只要灵活运用这些知识，你就可以对任意字 
符（或字符集合）及其各种组合和重复进行匹配——那些字符（或字符集合）可以出现在原
始文本里的任意位置。可是，在某些场合，你需要且只需要对某段文本的特定位置进行匹
配，这就引出了位置匹配的概念，而这个概念正是本章的学习重点。


P6.1 边界
===================================================

位置匹配用来解决在什么地方进行字符串匹配操作的问题。为了让大家对位置匹配及其相关 
概念有一个直观的认识，我们先来看一个例子:

:文本:

    .. code-block:: text

        The cat scattered his food all over the room.

:正则表达式: cat

:结果:

    .. code-block:: text

        cat cat

.. Hint:: 分析

        模式 cat 把原始文本里的所有 cat 都找了出来，单词 scattered 里的那个 cat 也不例外。
        但这一结果并不是所预期的，预期只要单词 cat 本身。我们本想用这种办法把所
        有的 cat 替换为 dog，但得到的结果却是一个毫无实际意义的句子:

        The dog sdogtered his food all over the room.

能够正确解决这个问题的办法只有一个：使用边界限定符，也就是在正则表达式里用一些特 
殊的元字符来表明我们想让匹配操作在什么位置（或边界）发生。


P6.2 单词边界
===================================================

第一种边界（也是最常用的边界）是由限定符 ``\b`` 指定的单词边界（boundary）。 
顾名思义，``\b`` 用来匹配一个单词的开始或结尾。

为了演示 ``\b`` 的用法，让我们回到刚才的例子再做一次尝试，但我们这次将用上单词边界: 

:文本:

    .. code-block:: text

        The cat scattered his food all over the room.

:正则表达式: ``\bcat\b``

:结果:

    .. code-block:: text

        cat

.. Hint:: 分析

        在原始文本里，单词cat的前后都有一个空格，而这将与模式 ``\bcat\b`` 相匹配
        （空格是用来分隔单词的字符之一）。单词 scattered 中的字符序列 cat 不能与
        这个模式相匹配，因为它的前一个字符是 s、后一个字符是 t
        （这两个字符都不能与 ``\b`` 相匹配）。


.. Note:: 注意

    ``\b``  到底匹配什么东西呢？正则表达式引擎不懂英语（事实上，它不懂任何人类语
    言），也不知道什么是单词边界。简单地说， ``\b`` 匹配的是一个这样的位置，这个位置位
    于一个能够用来构成单词的字符（字母、数字和下划线，也就是与 ``\w`` 相匹配的字符）和
    一个不能用来构成单词的字符（也就是与 ``\W`` 相匹配的字符）之间。

这里要特别注意的是，如果你想匹配一个完整的单词，就必须在你想要匹配的文本的前后都 
加上 ``\b`` 限定符。请看下面这个例子:

:文本:

    .. code-block:: text

        The captain wore his cap and cape proudly as
        he sat listening to the recap of how his
        crew saved the men from a capsized vessel.

:正则表达式: ``\bcap``

:结果:

    .. code-block:: text

                             cap     cap            
                                                
                                  cap             

.. Hint:: 分析

    模式 ``\bcap`` 将匹配以字符序列 cap 开头的任何一个单词。这里总共找到了 4 个匹配，
    其中有 3 个是以字符序列 cap 开头的其他单词而不是单词 cap 本身。

下面这个例子里的原始文本还是刚才那段文字，但在这次的正则表达式里只有一个后缀的 
``\b`` 限定符:

:文本:

    .. code-block:: text

        The captain wore his cap and cape proudly as
        he sat listening to the recap of how his
        crew saved the men from a capsized vessel.

:正则表达式: ``cap\b``

:结果:

    .. code-block:: text

                             cap                    
                                  cap

.. Hint:: 分析

        模式 ``cap\b`` 将匹配以字符序列 cap 结束的任何一个单词。这里总共找到了 2 个匹配，
        其中一个是以字符序列 cap 结束的其他单词而不是单词 cap 本身。
        如果你只想匹配单词 cap 本身，就必须使用 ``\bcap\b`` 做为模式，它才是你需要的正确答案。

注意 ``\b`` 匹配且只匹配一个位置，不匹配任何字符。用 ``\bcat\b`` 匹配到的字符串 
的长度是 3 个字符（c、a、t），不是 5 个字符。

如果你想表明不匹配一个单词边界 ，请使用 ``\B`` 。在下面的例子里，我们将使用 
``\B`` 来查找其前后都有多余空格的连字符:

:文本:

    .. code-block:: text

        Please enter the nine-digit id as it
        appears on your color - coded pass-key.

:正则表达式: ``\B-\B``

:结果:

    .. code-block:: text

        Please enter the nine-digit id as it
        appears on your color - coded pass-key.

.. Hint:: 分析

        ``\B-\B`` 将匹配一个前后都不是单词边界的连字符。nine-digit 和 pass-key 
        中的连字符不能与之匹配，但 color-coded 中的连字符可以与之匹配 。

正如我们在第 4 章里见到的那样，同一个元字符的大写形式与它的小写形式在功能上 
往往刚好相反。


.. Note:: 注意

    除了用来匹配单词边界（开头或结束均可）的 ``\b`` ，有些正则表达式实现还支持另
    外两个元字符： ``\<`` 只匹配单词的开头； ``\>`` 只匹配单词的结束。不过，虽然这两种元字符
    可以提供粒度更细的控制，但支持它们的正则表达式引擎却并不多见（据笔者所知，
    egrep程序是支持 ``\<`` 和 ``\>`` 的，但许多其他文本匹配工具则不支持它们）。


P6.3 字符串边界
===================================================

单词边界可以用来进行与单词有关的位置匹配（单词的开头、单词的结束、整个单词，等 
等）。字符串边界有着类似的用途，只不过是用来进行与字符串有关的位置匹配而已（字符
串的开头、字符串的结束、整个字符串，等等）。用来定义字符串边界的元字符有两个：一
个是用来定义字符串开头的^，另一个是用来定义字符串结尾的$。


.. Note:: 注意

    还记得吗？我们在第 3 章里已经见识过 ^ 元字符，但那时的它是一个用来对字符
    集合进行“求非”操作的元字符。那它还怎么用来表明一个字符串的开头呢？
    ^ 是几个有着多种用途的元字符之一。只有当它出现在一个字符集合里（被放在 [ 和 ] 之
    间）并紧跟在左方括号[的后面时，它才能发挥“求非”作用。如果是在一个字符集合的外
    面并位于一个模式的开头，^ 将匹配字符串的开头。

为了演示字符串边界的用法，我们在下面准备了一个例子。合法的XML文档都必须以 
``<?xml>`` 标签开头并有一些其他属性（比如一个版本号，如 ``<?xml version="1.0" ?>`` ）。
下面这个简单的测试可以检查一段文本是否是一篇 XML 文档:

:文本:

    .. code-block:: text

        <?xml version="1.0" encoding="UTF-8" ?>
        <wsdl:definitions targetNamespace="http://tips.cf"
        xmlns:impl="http://tips.cf" xmlns:intf="http://tips.cf"
        xmlns:apachesoap="http://xml.apache.org/xml-soap"

:正则表达式: ``<\?xml.*\?>``

:结果:

    .. code-block:: text

        <?xml version="1.0" encoding="UTF-8" ?>

.. Hint:: 分析

        这个模式似乎能够解决问题：``<\?xml`` 匹配 <?xml，.* 匹配随后的任意文本
        （ . 的零次或多次重复出现），``\?>`` 匹配 ?>。

这是一个非常不准确的测试。在下面的例子里，上例中的模式虽然匹配到了一个 XML 文档的 
开头部分，但位置却完全不对。它匹配到的语句位于文档的第 2 行而不是第1行。

:文本:

    .. code-block:: text

        This is bad, real bad!
        <?xml version="1.0" encoding="UTF-8" ?>
        <wsdl:definitions targetNamespace="http://tips.cf"
        xmlns:impl="http://tips.cf" xmlns:intf="http://tips.cf"
        xmlns:apachesoap="http://xml.apache.org/xml-soap"

:正则表达式: ``<\?xml.*\?>``

:结果:

    .. code-block:: text

        This is bad, real bad!
        **<?xml version="1.0" encoding="UTF-8" ?>**
        <wsdl:definitions targetNamespace="http://tips.cf"
        xmlns:impl="http://tips.cf" xmlns:intf="http://tips.cf"
        xmlns:apachesoap="http://xml.apache.org/xml-soap"

.. Hint:: 分析

        模式 ``<\?xml\?>`` 匹配到的是整个文本的第 2 行。虽然它也是XML文档的开始标签，
        但因为出现在文本的第 2 行，所以这份文档肯定不是一份合法的XML文档，把它当做一份 
        XML 文档来处理会导致种种问题。

这里需要的是一个能够确保被匹配到的 ``<?xml>`` 标签出现在字符串最开始处的测试， 
而这正是 ^ 元字符大显身手的地方；如下所示:

:文本:

    .. code-block:: text

        <?xml version="1.0" encoding="UTF-8" ?>
        <wsdl:definitions targetNamespace="http://tips.cf"
        xmlns:impl="http://tips.cf" xmlns:intf="http://tips.cf"
        xmlns:apachesoap="http://xml.apache.org/xml-soap"

:正则表达式: ``^\s*<\?xml.*\?>``

:结果:

    .. code-block:: text

        <?xml version="1.0" encoding="UTF-8" ?>

.. Hint:: 分析

    ^ 匹配一个字符串的开头位置，所以 ``^\s*`` 将匹配一个字符串的开头位置和随后的零个或多个
    空白字符（这解决了<?xml>标签前允许有空格、制表符、换行符等空白字符的问题）。作为
    一个整体，模式 ``^\s*<\?xml.*\?>`` 不仅能正确地匹配一个位置正确的 ``<?xml>`` 标签，还能对
    合法的空白字符做出妥善处理。

.. Hint:: 提示

    虽然模式 ``^\s*<\?xml.*\?>`` 解决了上例中的问题，但那只是因为这个例子里的
    原始文本并不完整而已。如果这段原始文本是一份完整的XML文档，这个例子将变成一
    个“贪婪型”元字符的典型示例。还好，我们已经知道解决“贪婪型”元字符问题的最佳办法
    是把 ``.*`` 替换为 ``.*?`` 。

除了位置上的差异，$的用法与^完全一样。比如说，在一份Web页面里，``</html>`` 标签的后 
面不应该再有任何实际内容，而这一点可以用下面这个模式来检查:


:正则表达式: ``</[Hh][Tt][Mm][Ll]>\s*$``


.. Hint:: 分析

    我们用了4个字符集合来分别匹配H、T、M、L等4个字符（这样就可以对这几个字符的各种大
    小写组合形式进行处理了），\s*$匹配一个字符串结尾处的零个或多个空白字符。


.. Note:: 注意

    模式 ``^.*$`` 是一个在语法上完全正确的正则表达式；它几乎总能找到一个匹配，但
    没有任何实际用途。你能分析出这个模式将匹配什么以及它在什么情况下会找不到任何匹
    配吗？

分行匹配模式

刚刚讲过，^ 匹配一个字符串的开头，$匹配一个字符串的结尾。但这一结论并非绝对正确， 
它还有一个例外或者说有一种改变这种行为的办法。
有许多正则表达式都支持使用一些特殊的元字符去改变另外一些元字符行为的做法，用来启
用分行匹配模式（multiline mode）的(?m)记号就是一个能够改变其他元字符行为的元字符序
列。分行匹配模式将使得正则表达式引擎把行分隔符当做一个字符串分隔符来对待。在分行
匹配模式下，^不仅匹配正常的字符串开头，还将匹配行分隔符（换行符）后面的开始位置
（这个位置是不可见的）；类似地，$不仅匹配正常的字符串结尾，还将匹配行分隔符（换行
符）后面的结束位置。
在使用时，``(?m)`` 必须出现在整个模式的最前面，就像下面这个例子里那样。在这个例子里，
我们将使用一个正则表达式把一段JavaScript代码里的注释内容全部查找出来:

:文本:

    .. code-block:: text

        <SCRIPT>
        function doSpellCheck(form, field) {
        // Make sure not empty
        if (field.value == ‘’) {
        return false;
        }
        // Init
        var windowName='spellWindow';
        var
        spellCheckURL='spell.cfm?formname=comment&fieldname='+field.
        ➥name;
        ...
        // Done
        return false;
        }
        </SCRIPT>

:正则表达式: ``(?m)^\s*//.*$``

:结果:

    .. code-block:: text

         <SCRIPT>
         function doSpellCheck(form, field) {
         **// Make sure not empty**
         if (field.value == ‘’) {
         return false;
         }
         **// Init**
         var windowName='spellWindow';
         var
         spellCheckURL='spell.cfm?formname=comment&fieldname='+field.
         ➥name;
         ...
         **// Done**
         return false;
         }
         </SCRIPT>

.. Hint:: 分析

    ``^\s*//.*$`` 将匹配一个字符串的开始，然后是任意多个空白字符，再后面是 
    //（JavaScript 代码里的注释标签），再往后是任意文本，最后是一个字符串的结束。
    不过，这个模式只能找出第一条注释（并认为这条注释将一直延续到文件的末尾，
    因为 ``*`` 是一个“贪婪型”元字符）。加上 ``(?m)`` 前缀之后，``(?m)^\s*//.*$`` 
    将把换行符视为一个字符串分隔符，这样就可
    以把每一行注释都匹配出来了。

.. Warning:: 警告

    有许多正则表达式实现不支持(?m)。


.. Note:: 注意

    有些正则表达式实现还支持使用 ``\A`` 来定义一个字符串的开始，以 ``\Z`` 
    来定义一个字 符串的结束的做法。此时， ``\A`` 和 ``\B`` 的作用将基本等价于
    ^ 和 $，但请注意， ``\A`` 和 ``\B`` 不会因 为加上了(?m)前缀而改变行为。
    换句话说，在跨行匹配模式下使用 ``\A`` 和 ``\B`` 的做法不会收 到在分行匹配模式
    下使用 ^ 和 $ 的效果。


P6.4 小结
===================================================

正则表达式不仅可以用来匹配任意长度的文本块，还可以用来匹配出现在字符串中特定位置 
的文本。 ``\b`` 用来指定一个单词边界（ ``\B`` 刚好相反）。^和$用来指定字符串边界（字符串的开
头和字符串的结束）。如果与(?m)配合使用，^和$还将匹配在一个换行符处开头或结束的字
符串（此时，换行符将被视为一个字符串分隔符）。

===================================================
Chapter 07. 使用子表达式
===================================================

元字符和字符是正则表达式的基本构件，它们的用法我们已经在此前的章节里演示过了。在 
这一章里，你们将学习如何运用子表达式（subexpression）的概念对表达式进行分组和归类。


P7.1 什么是子表达式
===================================================

在第 5 章学习了如何匹配一个字符的连续多次重复。正如讨论的那样，``\d+`` 将匹配 
一个或多个数字字符，而 https?:// 将匹配 http:// 或 https:// 。
在这两个例子里（事实上，是在我们此前见过的所有例子里），用来表明重复次数的元字符
（如 ? 或 * 或 {2}，等等）只作用于紧挨着它的前一个字符或元字符。
我们来看一个例子。有些短语（例如 Windows 2000）虽然由多个单词构成，但其实是一个整
体。有许多 HTML 程序员喜欢让这类短语在浏览器里显示在同一行上。为了确保这一点，他
们会在编写 HTML 文档时在这些短语的单词之间使用非换行型空格（&nbsp;，nbsp 是“non-
breaking space”的缩写，其含义是“不是换行符的空格”）而不是普通的空格。下面就是一个这
样的例子:

:文本:

    .. code-block:: text

        Hello, my name is Ben&nbsp;Forta, and I am
        the author of books on SQL, ColdFusion, WAP,
        Windows&nbsp;&nbsp;2000, and other subjects.

:正则表达式: &nbsp;{2,}

:结果:

    .. code-block:: text

        Hello, my name is Ben&nbsp;Forta, and I am
        the author of books on SQL, ColdFusion, WAP,
        Windows&nbsp;&nbsp;2000, and other subjects.

.. Hint:: 分析

    &nbsp; 是 HTML 语言中的非换行空格字符。在这里使用模式 &nbsp;{2, } 的本意是希望它
    能把 &nbsp; 连续两次或更多次的重复出现找出来，但它没能给出我们所预期的结果。为什么
    会这样？因为 {2, }只作用于紧挨着它的前一个字符——那是一个分号。如此一来，这个模
    式只能匹配像 &nbsp;;;;; 这样的文本，但无法匹配 &nbsp;&nbsp;。


P7.2 子表达式
===================================================

这就引出了子表达式的概念。子表达式是一个更大的表达式的一部分；把一个表达式划分为 
一系列子表达式的目的是为了把那些子表达式当作一个独立元素来使用。子表达式必须用
(和)括起来。


.. Hint:: 提示

    (和)是元字符。如果需要匹配(和)本身，就必须使用它的转义序列 ``\(`` 和 ``\)`` 。
    为了演示子表达式的用法，我们来看看刚才的那个例子:

:文本:

    .. code-block:: text

        Hello, my name is Ben&nbsp;Forta, and I am
        the author of books on SQL, ColdFusion, WAP,
        Windows&nbsp;&nbsp;2000, and other subjects.

:正则表达式: (&nbsp;){2,}

:结果:

    .. code-block:: text

        Hello, my name is Ben&nbsp;Forta, and I am
        the author of books on SQL, ColdFusion, WAP,
        Windows&nbsp;&nbsp;2000, and other subjects.

.. Hint:: 分析

    (&nbsp;) 是一个子表达式，它将被视为一个独立元素，而紧跟在它后面的 {2, } 将作用于
    这个子表达式（不仅仅是分号）。这个模式解决了我们的问题。

再来一个例子，这次是用一个正则表达式来查找 IP 地址。IP 地址的格式是以英文句号 
分隔的四组数字，例如 12.159.46.200。因为每组数字由 1 个、2 个或 3 个数字字符构成，
所以这 4 组数字可以统一使用模式 ``\d{1, 3}`` 来匹配。下面就是这个例子:

:文本:

    .. code-block:: text

        Pinging hog.forta.com [12.159.46.200]
        with 32 bytes of data:

:正则表达式: ``\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}``

:结果:

    .. code-block:: text

        Pinging hog.forta.com [**12.159.46.200**]
        with 32 bytes of data:

.. Hint:: 分析

    ``\d{1, 3}`` 在这个模式里重复了 4 次，它们分别匹配 IP 地址里的一组数字。IP 
    地址里的 4 组数字由 . 分隔，该字符由模式里的转义序列 ``\.`` 负责匹配。

稍微留意一下就会发现，在这个例子里，模式 ``\d{1, 3}\.`` （最多 3 个数字字符、 
后面跟着一个 .）连续出现了 3 次，它同样可以被表达为一个重复。下面是这个例子的
另一种解决方案:

:文本:

    .. code-block:: text

        Pinging hog.forta.com [12.159.46.200]
        with 32 bytes of data:

:正则表达式: ``(\d{1,3}\.){3}\d{1,3}``

:结果:

    .. code-block:: text

        Pinging hog.forta.com [**12.159.46.200**]
        with 32 bytes of data:

.. Hint:: 分析

    这个模式与前面那个有着同样的效果，但我们这次使用了另一种语法：先用 ( 和 )
    把表达式 ``\d{1, 3}\.`` 括起来使它成为一个子表达式，再用 ``\d{1, 3}\.){3}`` 
    把这个子表达式重复了 3 次（它们对应着 IP 地址里的前 3 组数字），最后面的
    ``\d{1, 3}`` 用来匹配 IP 地址里的最后一组数字。

.. Note:: 注意

    在上面这个例子里，使用 ``(\d{1, 3}\.){4}`` 作为模式是不妥当的。你能分析出
    为什么不能用它来解决这个问题吗？

.. Hint:: 提示

    为了提高可读性，有不少用户喜欢给表达式的每一个子表达式都加上括号。比如，
    把上面那个例子里的模式写成 ``(\d{1, 3}\.){3}(\d{1, 3})``。这种做法在语法上完
    全成立，对表达式的实际行为也没有任何不良影响（但视乎具体的正则表达式实现，这对
    匹配操作的速度可能会有点儿影响）。

子表达式是一个非常重要的概念，所以我们认为有必要再给大家看一个例子，它不涉及重复 
次数问题。在下面的例子里，我们的任务是把一条用户记录里的年份数字完整地匹配出来:

:文本:

    .. code-block:: text

        ID: 042
        SEX: M
        DOB: 1967-08-17
        Status: Active

:正则表达式: ``19|20\d{2}``

:结果:

    .. code-block:: text

        ID: 042
        SEX: M
        DOB: **19**67-08-17
        Status: Active

.. Hint:: 分析

    这个例子需要构造一个模式去查找一个 4 位数的年份数字。为了简化结果，把前两
    位数字限定为 19 和 20。这个模式里的 | 字符是正则表达式语言里的或操作符，
    19|20 将匹配数字序列 19 或 20。既然如此，模式 ``19|20\d{2}`` 应该匹配以
    19 或 20 开头的四位数字（ 19 或 20 的后面再跟着两位数字）。可是，这个模式的
    匹配结果与我们的预期并不相符，它只匹配到了 19，随后两位数字没有被匹配到。
    为什么会这样？因为 | 操作符是把位于它左边和右边的两个部分都作为一个整体
    来看待的，它会把模式 ``19|20\d{2}`` 解释为 19 或 ``20\d{2}`` ，也就是 {} 
    符号的运算优先级更高。换句话说，它将匹配数字序列 19 或以 20 开头的任意 
    4 位数字。最终的结果你们已经看到了，它只匹配到了 19。

这个例子的正确答案是把 19|20 归为一个子表达式，如下所示: 

:文本:

    .. code-block:: text

        ID: 042
        SEX: M
        DOB: 1967-08-17
        Status: Active

:正则表达式: ``(19|20)\d{2}``

:结果:

    .. code-block:: text

        ID: 042
        SEX: M
        DOB: **1967-08-17**
        Status: Active

.. Hint:: 分析

    我们把所有的选项都归纳到了一个子表达式里，这将向|表明我们打算匹配的是这个子表达式
    里的选项之一。``(19|20)\d{2}`` 正确地匹配到了 1967；当然，19 或 20 开头的任何一个 4 位
    数字都将与这个模式相匹配。今后（比如，从现在算起 100 年内），如果需要修改这段代码以
    包括以 21开头的年份，只要把这个模式改成 ``(19|20|21)\d{2}`` 就可以了。

本章讨论的只是子表达式的用途之一。子表达式还有另外一个非常重要的用途， 
我们将在第 8 章里对之进行讨论。


P7.3 子表达式的嵌套
===================================================

子表达式允许嵌套。事实上，子表达式允许多重嵌套，这种嵌套的层次在理论上没有限制， 
但在实际工作中还是应该遵循适可而止的原则。

多重嵌套的子表达式可以构造出功能极其强大的正则表达式来，但那难免会让模式变得难以 
阅读和理解，而这也正是很多人觉得正则表达式难以学习和掌握的原因之一。这种表面现象
掩盖了这样一个事实：绝大多数嵌套子表达式都没有它们看上去那么复杂。

为了演示嵌套子表达式的用法，我们再去看看刚才那个匹配 IP 地址的例子。下面是我们刚才 
使用的模式（先是一个连续重复 3 次的子表达式，然后是最后一组数字）:


:正则表达式: ``(\d{1,3}\.){3}\d{1,3}``


这个模式有什么不对的地方吗？从语法上讲，它完全正确。IP 地址由四组数字构成，每组数  
字由 1 到 3 个数字字符构成，它们之间以英文句号分隔。说这个模式正确，是因为所有合法的
IP 地址都与之相匹配。但深入研究一下就会发现，这个模式还可以匹配其他一些东西；说得
明白点儿，不合法的 IP 地址也能与之相匹配。

IP 地址由 4 个字节构成，IP 地址中的 4 组数字分别对应着那 4 个字节，所以每组数字 
的取值范围也就是单个字节的表示范围，即 0~255。这意味着 IP 地址里的每一组数字都不能大
于 255，可是上面那个模式还能匹配诸如 345、700、999 之类的数字序列，而这些数字在 IP 地
址里都是非法的。

.. Note:: 注意

    有句话希望你能牢牢记住：把必须匹配的情况考虑周全并写出一个匹配结果符合
    预期的正则表达式很容易，但把不需要匹配的情况也考虑周全并确保它们都将被排除在匹
    配结果以外往往要困难得多。

如果有办法设定各种取值范围的话，事情会简单得多，但可惜的是正则表达式只是一种工 
具，而且还是一种不懂数学运算的工具，它们在匹配字符的时候并不真正关心那些字符到底
是什么以及有什么含义。你的数学能力再好在这里也帮不上忙。

真的没有解决这个问题的办法吗？未必，只要你们能够充分发挥你们的逻辑思维能力，就能 
解决与正则表达式有关的任何难题。这里的基本思路是：在构造一个正则表达式的时候，一
定要把你想匹配什么和你不想匹配什么详尽地定义清楚。下面是一个合法的 IP 地址里的各组
数字必须且只能符合的规则，我们随后将根据这些规则来构造一个相应的模式:

    1. ● 任何一个1位或2位数字。
    2. ● 任何一个以1开头的3位数字。
    3. ● 任何一个以2开头、第2位数字在0~4之间的3位数字。
    4. ● 任何一个以25开头、第3位数字在0~5之间的3位数字。

像这样把所有的正则全部罗列出来之后，构造一个同时符合所有原则的模式的具体步骤也就 
清晰了。下面是这个例子的继续:

:文本:

    .. code-block:: text

        Pinging hog.forta.com [12.159.46.200]
        with 32 bytes of data:

:正则表达式: ``(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}``
        ➥ ``((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))``
:结果:

    .. code-block:: text

        Pinging hog.forta.com [12.159.46.200]
        with 32 bytes of data:

.. Hint:: 分析

    这个模式的使用效果显而易见，但它还是需要仔细研读才能看明白。这个模式由一系列嵌套
    子表达式构成。4 个子表达式构成的 ``(((\d{1, 2}) | (1\d{2}) | (2[0-4]\d) | (25[0-5])\.)``：
    ``(\d{1, 2})`` 匹配任意一位或两位数字（0~99）；
    ``(1\d{2})`` 匹配以1开头的任意三位数字（100~199）；
    ``(2[0-4]\d)`` 匹配整数 200~249；
    ``(25[0-5])`` 匹配整数 250~255。这几个子表达式通过|操作符结合为一个更大的子表达式
    （其含义是只需匹配这 4 个子表达式之一即可）。随后的 ``\.`` 用来匹配.字符，
    它与前 4 个子表达式构成的子表达式又构成了一个更大的子表达式（4 组数字选项和
    ``\.`` ），而接下来的 {3} 表明需要重复 3 次。最后，数值范围又重复了一次
    （这次省略了尾部的 ``\.`` ）以匹配 IP 地址里的最    后一组数字。通过把 4 
    组数字的取值范围都限制在 0~255 之间，这个模式准确无误地做到了只
    匹配合法的 IP 地址、不匹配非法的 IP 地址。


.. Hint:: 提示

    上面这个例子里的正则表达式看起来很难理解。把它们弄明白的关键是要把它们
    分解开、每次只分析和理解一个子表达式。在分析各个子表达式的时候，应该按照先内后
    外的原则来进行而不是从第一个字符开始一个字符一个字符地去尝试。你有过几次这样的
    经验之后就会发现，嵌套子表达式并不像它们看上去那么复杂。


P7.4 小结
===================================================

子表达式的作用是把同一个表达式的各个相关部分组合在一起。子表达式必须用 ( ) 包括义。 
子表达式的常见用途包括：对重复次数元字符的作用对象做出精确的设定和控制、对 | 操
作符的 OR 条件做出准确的定义，等等。如有必要，子表达式还允许嵌套使用。

===================================================
Chapter 08. 回溯引用：前后一致匹配
===================================================

第7章介绍了子表达式的基本用途之一：把一组字符编组为一个字符集合。这样的字符集合主 
要用于精确设定需要重复匹配的文本及其重复次数。本章将讨论子表达式的另一个重要用途 
——定义回溯引用（backreference）。


P8.1 回溯引用有什么用
===================================================

为了理解回溯引用的概念，我们最好是看一个例子。HTML 程序员经常使用标题标签（<H1> 
到 <H6>，以及配对的结束标签）来定义和排版 Web 页面里的标题文字。现在，不妨假设
你需要把某个 Web 页面里的所有标题文字全都查找出来，而不管它的级别是多少。下面就是
这个例子:

:文本:

    .. code-block:: text

        <BODY>
        <H1>Welcome to my Homepage</H1>
        Content is divided into two sections:<BR>
        <H2>ColdFusion</H2>
        Information about Macromedia ColdFusion.
        <H2>Wireless</H2>
        Information about Bluetooth, 802.11, and more.
        </BODY>

:正则表达式: <[hH]1>.*</[hH]1>

:结果:

    .. code-block:: text

        <BODY>
        **<H1>Welcome to my Homepage</H1>**
        Content is divided into two sections:<BR>
        <H2>ColdFusion</H2>
        Information about Macromedia ColdFusion.
        <H2>Wireless</H2>
        Information about Bluetooth, 802.11, and more.
        </BODY>

.. Hint:: 分析

    模式 ``<[hH]1>.*</[hH]1>`` 只能匹配一级标题（从<H1>或<h1>到</H1>或</h1>；HTML
    语言不区分字母的大小写）。但我们刚才说的是匹配任意级别的标题（HTML 文档里的标题
    总共有 6 个级别），这应该怎么办呢？

最容易想到的办法是用一个字符集合来代替 1，如下所示: 

:文本:

    .. code-block:: text

        <BODY>
        <H1>Welcome to my Homepage</H1>
        Content is divided into two sections:<BR>
        <H2>ColdFusion</H2>
        Information about Macromedia ColdFusion.
        <H2>Wireless</H2>
        Information about Bluetooth, 802.11, and more.
        </BODY>

:正则表达式: <[hH][1-6]>.*?</[hH][1-6]>

:结果:

    .. code-block:: text

        <BODY>
        **<H1>Welcome to my Homepage</H1>**
        Content is divided into two sections:<BR>
        **<H2>ColdFusion</H2>**
        Information about Macromedia ColdFusion.
        **<H2>Wireless</H2>**
        Information about Bluetooth, 802.11, and more.
        </BODY>

.. Hint:: 分析

        这个模式看来不错， ``<[hH][1-6]>`` 匹配任何一级标题的开始标签。
        具体到这个例子，它匹配到了 <H1> 和 <H2> 。

        ``</[hH][1-6]>`` 匹配任何一级标题的结束标签。
        具体到这个例子，它匹配到了 </H1> 和 </H2>。


.. Note:: 注意

    这里使用的是 ``.*?`` （懒惰型）而不是 ``.*`` （贪婪型）。第 5 章里讲过，
    这几个元字符是“贪婪型”元字符，所以模式 ``<[hH][1-6]>.*</[hH][1-6]>`` 有可能
    会从第 2 行的 <H1> 一直匹配到第 6 行的 </H2>，这可不是我们想要的结果；
    使用“懒惰型”元字符 ``.*?`` 解决了这个问题。

之所以说“有可能”而不是“肯定”，是因为在这个特定的例子里即便是使用了“贪婪型” 
元字符也不一定会有问题。一般来说，元字符 . 不匹配换行符，而上例中的每个标题都各自占
据一行。但在这里使用懒惰型元字符没有任何坏处——事前小心总比事后后悔好。
现在成功了吗？未必。看看下面这个例子（这次使用的是还是刚才那个模式），你就知道我
为什么这样说了:

:文本:

    .. code-block:: text

        <BODY>
        <H1>Welcome to my Homepage</H1>
        Content is divided into two sections:<BR>
        <H2>ColdFusion</H2>
        Information about Macromedia ColdFusion.
        <H2>Wireless</H2>
        Information about Bluetooth, 802.11, and more.
        <H2>This is not valid HTML</H3>
        </BODY>

:正则表达式: <[hH][1-6]>.*?</[hH][1-6]>

:结果:

    .. code-block:: text

        <BODY>
        **<H1>Welcome to my Homepage</H1>**
        Content is divided into two sections:<BR>
        **<H2>ColdFusion</H2>**
        Information about Macromedia ColdFusion.
        **<H2>Wireless</H2>**
        Information about Bluetooth, 802.11, and more.
        **<H2>This is not valid HTML</H3>**
        </BODY>

.. Hint:: 分析

    在这个例子里，其中最后一个标题是以 <H2> 开头、<H3> 结束的。显然是一个不合
    法的标题，但它与我们所使用的模式匹配上了。

    出现这种情况的根源是这个模式的第 2 部分（用来匹配结束标签的那个部分）对这个模式的第
    1部分（用来匹配开始标签的那个部分）毫无所知。要想彻底解决这个问题，就只能求助于回
    溯引用。


P8.2 回溯引用匹配
===================================================

我们等会儿再去解决匹配 HTML 标题的问题。先来看一个比较简单的例子，这个问题如果不 
使用回溯引用将根本无法解决。

假设你有一段文本，你想把这段文本里所有连续重复出现的单词（打字错误，其中有一个单 
词输了两遍）找出来。显然，在搜索某个单词的第二次出现时，这个单词必须是已知的。回
溯引用允许正则表达式模式引用前面的匹配结果（具体到这个例子，就是前面匹配到的单
词）。

把这个问题弄明白的最佳办法是看看它到底是如何工作的。下面是一段包含着3组重复单词的 
文本，它们就是我们要找的东西:

:文本:

    .. code-block:: text

        This is a block of of text,
        several words here are are
        repeated, and and they
        should not be.

:正则表达式: ``[ ]+(\w+)[ ]+\1``

:结果:

    .. code-block:: text

        This is a block of of text,
        several words here are are
        repeated, and and they
        should not be.

.. Hint:: 分析

        这个模式找到了我们想要的东西，但它是如何做到这一点的呢？[ ]+ 匹配一个或多个空
        格， ``\w+`` 匹配一个或多个字母数字字符，[ ]+ 匹配随后的空格。

        注意，``\w+`` 是括在括号里的，它是一个子表达式。这个子表达式不是用来进
        行重复匹配的，这里根本不涉及重复匹配的问题。这个子表达式只是把整个模式的
        一部分单独划分出来以便在后面引用。这个模式的最后一部分是 ``\1``；
        这是一个回溯引用，而它引用的正是前面划分出来的那个子表达式：当 ``(\w+)``
        匹配到单词 of 的时候，``\1`` 也匹配单词 of；当 ``(\w+)`` 匹配到单词 and
        的时候，``\1`` 也匹配单词 and。


.. Note:: 注意

    回溯引用指的是模式的后半部分引用在前半部分中定义的子表达式（如上例所示）。

``\1`` 到底代表着什么？它代表着模式里的第 1 个子表达式，``\2`` 代表着第 2 个
子表达式、``\3`` 代表着第 3 个；依次类推。于是，在上面那个例子里，
``[ ]+(\w+)[ ]+\1`` 将匹配同一个单词的连续两次重复出现。

.. Hint:: 提示

    你们可以把回溯引用想像成变量。

看过回溯引用的用法之后，我们再回过头来看看应该如何解决匹配 HTML 标题的问题。利用 
回溯引用，构造一个模式去匹配任何一级标题的开始标签和与之配对的结束标签（忽略任何
不配对的标签组合）对我们来说已经不是什么难题了。下面就是这个例子:

:文本:

    .. code-block:: text

        <BODY>
        <H1>Welcome to my Homepage</H1>
        Content is divided into two sections:<BR>
        <H2>ColdFusion</H2>
        Information about Macromedia ColdFusion.
        <H2>Wireless</H2>
        Information about Bluetooth, 802.11, and more.
        <H2>This is not valid HTML</H3>
        </BODY>

:正则表达式: ``<[hH]([1-6])>.*?</[hH]\1>``

:结果:

    .. code-block:: text

        <BODY>
        **<H1>Welcome to my Homepage</H1>**
        Content is divided into two sections:<BR>
        **<H2>ColdFusion</H2>**
        Information about Macromedia ColdFusion.
        **<H2>Wireless</H2>**
        Information about Bluetooth, 802.11, and more.
        <H2>This is not valid HTML</H3>
        </BODY>

.. Hint:: 分析

    总共找到了 3 个匹配：
    1 个一级标题（<H1>...</H1>）和
    2 个二级标题（<H2>...</H2>）。
    <[hH]([1-6])> 匹配任何一级标题的开始标签，但我们这次用 ( 和 ) 把 [1-6] 括了
    起来，使它成为了一个子表达式。这样一来，我们就可以在用来匹配标题结束标签的
    ``</[hH]\1>`` 用 ``\1`` 来引用这个子表达式了。子表达式 ``([1-6])`` 匹配数字1~6，
    ``\1`` 只匹配与之相同的数字。这样一来，文本的 <H2>This is not valid HTML</H3>就不会被匹配到了。

.. Note:: 注意

    不同的正则表达式在实现回溯引用的语法方面往往有着巨大的差异。
    JavaScript 使用 ``\`` 来标识回溯引用（ ``\`` 与 $ 配合进行替换操作时是例外），
    Macromedia ColdFusion 和 vi 也是如此。.NET 正则表达式将返回一个对象，该对象的 
    Groups 属性包含着所有的匹配。如果你使用的是 C# 语言，match.Groups[1] 对应着
    第一个匹配；Visual Basic .NET，match.Groups(1) 对应着第一个匹配。PHP 把这些信息
    返回为一个名为 $matches 数组，$matches[1] 对应着第 1 个匹配（但这一行为会根据你
    在匹配操作中具体使用的命令选项发生变化）。Java 和 Python 将返回一个包含着一个名为
    group 的数组的匹配对象。有关细节参阅附录A。

.. Warning:: 警告

    回溯引用只能用来引用模式里的子表达式（用(和)括起来的正则表达式片段）。

.. Hint:: 提示

    回溯引用匹配通常从 1 开始计数（ ``\1`` ``\2`` 等等）。在许多实现里，
    ``（\0）`` 可以用来代表整个正则表达式。

.. Note:: 注意

    正如看到的那样，子表达式是通过它们的相对位置来引用的：``\1`` 对应着第 1 个子表
    达式，``\5`` 对应着第 5 个子表达式，等等。虽然受到普遍的支持，但这种语法存在着一个严
    重的不足：如果子表达式的相对位置发生了变化，整个模式也许就不能再完成原来的工
    作，删除或添加子表达式的后果可能更为严重。

为了弥补这一不足，一些比较新的正则表达式实现还支持“命名捕获”（named capture）: 
给某个子表达式起一个唯一的名字，然后用这个名字（而不是相对位置）来引用这个子表
达式。因为命名捕获还没有得到广泛支持，而且已支持的实现具体的语法也极不统一，所
以本书没有对此进行讨论。但是，如果你正在使用的正则表达式实现支持命名捕获功能
（如 .NET），你应该充分利用。


P8.3 回溯引用在替换操作中的应用
===================================================

到目前为止，你们在这本书里见到的正则表达式都是用来执行搜索的，即在一段文本里查找 
特定的内容。你在今后的实际工作中也会发现，你所编写的绝大多数正则表达式模式也可以
用来搜索文本。但这并不是正则表达式的全部功能；正则表达式还可以用来完成各种复杂的
替换操作。

简单的文本替换操作无须使用正则表达式就可以完成。比如说，如果只是把某个文档里的 CA 
全部替换为California或把MI全部替换为Michigan的话，用正则表达式来完成这些替换
就未免有点儿大材小用了。这句话的意思并不是说正则表达式不能用来执行这种替换，只是
那么做没有什么实际价值。事实上，用普通的字符串处理函数来完成这种替换反而会更容易
一些。

正则表达式更适用于复杂的替换，尤其是需要使用回溯引用的场合，那才能体现出正则表达 
式的真正威力。下面是一个我们在第5章里见过的例子:

:文本:

    .. code-block:: text

        Hello, ben@forta.com is my email address.

:正则表达式: ``\w+[\w\.]*@[\w\.]+\.\w+``

:结果:

    .. code-block:: text

        Hello, ben@forta.com is my email address.

.. Hint:: 分析

        这个模式可以把原始文本里的电子邮件地址查找出来（详细分析见第5章）。

现在，假设你需要把原始文本里的电子邮件地址全都转换为可点击的链接，你该怎么办？ 
在 HTML 文档里，你需要使用 <A HREF="maito:user@address.com">user@address.com</A>
这样的语法来创建一个可点击的电子邮件地址。

能不能用一个正则表达式把一个电子邮件地址转换为这种可点击的地址格式呢？ 

当然能，而且非常容易——但前提是你得使用回溯引用，如下所示: 

:文本:

    .. code-block:: text

        Hello, ben@forta.com is my email address.

:正则表达式: ``(\w+[\w\.]*@[\w\.]+\.\w+)``
:替换: <A HREF="mailto:$1">$1</A>
:结果:

    .. code-block:: text

        Hello, <A HREF="mailto:ben@forta.com">ben@forta.com</A>
        is my email address.

.. Hint:: 分析

    替换操作需要用到两个正则表达式：一个用来给出搜索模式，另一个用来给出匹配文本的替
    换模式。回溯引用可以跨模式使用，在第一个模式里被匹配的子表达式可以用在第二个模式
    里。这里使用的模式(\w+[\w\ .]*@[\w\ .]+\ .\w+)与我们以前使用的完全一样（匹
    配电子邮件地址），但这次把它写成了一个子表达式。这样一来，被匹配到的文本就可以用
    在替换模式里了。<A HREF="mailto:$1">$1</A>使用了两次被匹配的子表达式：一次是
    在HREF属性里（来定义mailto：...），另一次是做为可点击文本。具体到这个例子，
    ben@forta.com变成了<A HREF="mailto:ben@forta.com"> ben@forta.com </
    A>，而这正是我们想要的结果。


.. Warning:: 警告

    我们刚才讲过，回溯引用语法在不同的正则表达式实现里有很大的差异:
    JavaScript 用户需要用 $ 来代替 ``\``；ColdFusion 用户在查找和替换操作里都必须使用 ``\``。

.. Hint:: 提示

    正如你在上面这个例子里看到的那样，同一个子表达式可以被引用任意多次——只
    要在需要用到它的地方写出它的回溯引用就行了。

我们再来看一个例子。在一个用来保存用户信息的数据库里，电话号码被保存为 
313-555-1234。现在，你需要把电话号码重新排版为(313) 555-1234。下面就是这个例子:

:文本:

    .. code-block:: text

        313-555-1234
        248-555-9999
        810-555-9000

:正则表达式: ``(\d{3})(-)(\d{3})(-)(\d{4})``
:替换: ($1) $3-$5
:结果:

    .. code-block:: text

        (313) 555-1234
        (248) 555-9999
        (810) 555-9000

.. Hint:: 分析

        和刚才一样，这里也使用了两个正则表达式模式。第1个模式看起来很复杂，我们来分析一
        下。(\d{3})(-)(\d{3})(-)(\d{4})用来匹配一个电话号码，它被划分为5个子表达式
        （5个组成部分）：第1个子表达式(\d{3})匹配前3位数字，第2个子表达式(-)匹配-字符，
        等等。最终的结果是一个电话号码被划分成了5个部分（每个部分分别对应着一个子表达
        式）：区号、一个连字符、电话号码的前3位数字、又一个连字符、电话号码的后4位数字。
        这5个部分都可以单独拿出来使用，负责重新排版电话号码的替换模式($1) $3-$5只用到了
        它们当中的3个，剩下的两个没有用到，但这已足以把313-555-1234转换为(313)
        555-1234。


.. Hint:: 提示

    在对文本进行重新排版的时候，把文本分解成多个子表达式的做法往往非常有用，
    这可以让我们对文本的排版效果做出更精确的控制。

大小写转换

有些正则表达式实现允许我们使用表8-1列出的元字符对字母进行大小写转换。 

表 8-1 用来进行大小写转换的元字符

=========  ================================
元字符              说 明
=========  ================================
``\E``             结束 ``\L`` 或 ``\U`` 转换
``\l``             把下一个字符转换为小写
``\L``             把 ``\L`` 到 ``\E`` 之间的字符全部转换为小写
``\u``             把下一个字符转换为大写
``\U``             把 ``\U`` 到 ``\E`` 之间的字符全部转换为大写
=========  ================================

``\l`` 和 ``\u`` 只能把下一个字符（或子表达式）转换为小写或大写。
``\L`` 和 ``\U`` 将把它后面的所有字符转换为小写或大写，
直到遇上 ``\E`` 为止。

下面是一个简单的例子，把一级标题（<H1>...</H1>）的标题文字转换为大写: 

:文本:

    .. code-block:: text

        <BODY>
        <H1>Welcome to my Homepage</H1>
        Content is divided into two sections:<BR>
        <H2>ColdFusion</H2>
        Information about Macromedia ColdFusion.
        <H2>Wireless</H2>
        Information about Bluetooth, 802.11, and more.
        <H2>This is not valid HTML</H3>
        </BODY>

:正则表式: (<[Hh]1>)(.*?)(</[Hh]1>)
:替换: $1\U$2\E$3
:结果:

    .. code-block:: text

        <BODY>
        **<H1>WELCOME TO MY HOMEPAGE</H1>**
        Content is divided into two sections:<BR>
        <H2>ColdFusion</H2>
        Information about Macromedia ColdFusion.
        <H2>Wireless</H2>
        Information about Bluetooth, 802.11, and more.
        <H2>This is not valid HTML</H3>
        </BODY>

.. Hint:: 分析

    模式 ``(<[Hh]1>)(.*?)(</[Hh]1>)`` 把一级标题分成了 3 个子表达式：开始标签、标题文
    字、结束标签。第2个模式再把文本重新组合起来：$1 包含着开始标签，``\U$2\E`` 
    把第 2 个子表达式（标题文字）转换为大写，$3 包含着结束标签。


P8.4 小结
===================================================

子表达式用来定义字符或表达式的集合。除了可以用在重复匹配操作中以外（详见第7章）， 
子表达式还可以在模式的内部被引用。这种引用被称为回溯引用。回溯引用的语法在不同的
正则表达式实现里有很大的差异。回溯引用在文本匹配和文本替换操作里非常有用。

===================================================
Chapter 09. 前后查找 lookahead vs. lookbehind
===================================================

到目前为止，我们见过的正则表达式都是用来匹配文本的，但有时我们还需要用正则表达式 
标记要匹配的文本的位置（而不仅仅是文本本身）。这就引出了前后查找（lookaround，对某
一位置的前、后内容进行查找）的概念，我们将在这一章对此做专题讨论。


P9.1 前后查找 
===================================================

我们还是先来看一个例子：你要把一个Web页面的页面标题提取出来。HTML 页面标题是出现 
在 <TITLE> 和 </TITLE> 标签之间的文字，而这对标签又必须嵌在 HTML 代码的 <HEAD>
部分里。下面就是这个例子:

:文本:

    .. code-block:: text

        <HEAD>
        <TITLE>Ben Forta’s Homepage</TITLE>
        </HEAD>

:正则表达式: <[tT][iI][tT][lL][eE]>.*</[tT][iI][tT][lL][eE]>

:结果:

    .. code-block:: text

        <HEAD>
        <TITLE>Ben Forta’s Homepage</TITLE>
        </HEAD>

.. Hint:: 分析

    ``<[tT][iI][tT][lL][eE]>.*</[tT][iI][tT][lL][eE]>`` 匹配 <TITLE> 标签（大写、
    小写或大小写混用）、</TITLE> 标签以及这两个标签之间的任何文字。这个模式的效果与
    我们的预期基本相符，但不够理想。

为什么这么说呢？因为只有页面标题才是我们需要的，而我们找到的匹配里还包含着 
<TITLE> 和 </TITLE> 标签。能不能只返回页面标题的文字部分呢？

办法之一是使用子表达式（参见第7章）。我们可以利用子表达式把被匹配文本划分为 3 
个部分：开始标签、标题文字、结束标签。把被匹配文本划分为多个部分之后，从它们当中
提取且只提取出我们需要的东西就很容易了。

可是，明知是自己并不真正需要的东西（比如上例中的 <TITLE> 和 </TITLE> 标签），还把 
它们检索出来岂不是毫无意义。“先想办法把它们检索出来、再以手动方式排除它们”这既浪
费时间，又容易招致不必要的后患。在遇到这类问题的时候，你真正需要的是这样一个模
式，它包含的匹配本身并不返回，而是用于确定正确的匹配位置，它并不是匹配结果的一部
分。换句话说，你需要进行“前后查找” ①。

①前后查找中的前、后指模式与被查找文本的相对位置而言，左为前。——编者注

.. Note:: 注意

    本章将对向前查找（lookahead）和向后查找（lookbehind）都进行讨论。常见的正
    则表达式实现都支持前者，但支持后者的就没那么多了。

    Java、.NET、PHP 和 Perl 都支持向后查找（但有一些限制），JavaScript 和 ColdFusion 
    不支持向后查找。


P9.2 向前查找 lookahead
===================================================

向前查找指定了一个必须匹配但不在结果中返回的模式。向前查找实际就是一个子表达式， 
而且从格式上看也确实如此。从语法上看，一个向前查找模式其实就是一个以 ?= 开头的子表
达式，需要匹配的文本跟在 = 的后面。

.. Hint:: 提示

    有些正则表达式文档使用术语“消费”（consume）来表述“匹配和返回文本”的含
    义。在向前查找里，被匹配的文本不包含在最终返回的匹配结果里，这被称为“不消费”。
    我们来看一个例子。例子里的原始文本是一些URL地址，而你的任务是把它们的协议名部分
    提取出来（为下一步处理做准备）。下面就是这个例子:

:文本:

    .. code-block:: text

        http://www.forta.com/
        https://mail.forta.com/
        ftp://ftp.forta.com/

:正则表达式: .+(?=:)

:结果:

    .. code-block:: text

        **http**://www.forta.com/
        **https**://mail.forta.com/
        **ftp**://ftp.forta.com/

.. Hint:: 分析

    在上面列出的 URL 地址里，协议名与主机名之间以一个:分隔。模式 .+ 匹配任意文本
    （第 1 个匹配是 http），子表达式 (?=:) 匹配 : 。

    注意，被匹配到的 : 并没有出现在最终的匹配结果里；用 ?= 向正则表达式引擎表明：
    只要找到 : 就行了，不要把它包括在最终的匹配结果里。用术语来说，就是“不消费”它。

为了更好地理解 ?= 的作用，再来看一个同样的例子，但这次不使用向前查找元字符: 

:文本:

    .. code-block:: text

        http://www.forta.com/
        https://mail.forta.com/
        ftp://ftp.forta.com/

:正则表达式: .+(:)

:结果:

    .. code-block:: text

        **http:**//www.forta.com/
        **https:**//mail.forta.com/
        **ftp:**//ftp.forta.com/

.. Hint:: 分析

        子表达式 (:) 正确地匹配到了 : 并消费了这个字符，最终 : 出现在匹配结果里。
        这两个例子的区别是前一个用来匹配 : 的模式是 (?=:)，后一个模式是 (:)。
        这两个模式所匹配的东西是一样的，都是紧跟在协议名后面的那个 :，
        它们之间的区别只是被匹配到的 : 字符有没有出现在最终的匹配结果里而已。
        在使用向前查找的时候，正则表达式分析器将向前查找并处理 : 匹配，
        但不会把它包括在最终的搜索结果里。模式 ``.+(:)`` 查找到并
        且匹配结果包含 :，模式 ``.+(?=:)`` 查找到但匹配结果不包含 :。


.. Note:: 注意

    向前查找（和向后查找）匹配本身其实是有返回结果的，只是这个结果的字节长
    度永远是 0 而已。因此，前后查找操作有时也被称为零宽度（zero-width）匹配操作。

.. Hint:: 提示

    任何一个子表达式都可以转换为一个向前查找表达式，只要给它加上一个 ?= 前缀
    即可。在同一个搜索模式里可以使用多个向前查找表达式，它们可以出现在模式里的任意
    位置（而不仅仅是出现在整个模式的开头——就像你们在上面看到的那样）。


P9.3 向后查找
===================================================

正如你刚看到的那样，?= 将向前查找（查找出现在被匹配文本之后的字符，但不消费那个字 
符）。因此，``?=`` 称为向前查找操作符。除了向前查找，许多正则表达式实现还支持向后查
找，也就是查找出现在被匹配文本之前的字符（但不消费它），向后查找操作符是 ``?<=`` 。

.. Hint:: 提示

    分不清 ?=、?<= 与其他 ? 的话，有个简单的办法可以帮你分辨它们：有小于号的是
    向后查找操作符——你可以把这个小于号想像成一个箭头，它指向文本阅读方向的后方。

?<= 与 ?= 的具体使用方法大同小异；它必须用在一个子表达式里，而且后跟要匹配的文本。
下面是一个例子。你从某个数据库里搜索出了一份产品目录，但你只需要把那些产品的价格
提取出来:

:文本:

    .. code-block:: text

        ABC01: $23.45
        HGG42: $5.31
        CFMX1: $899.00
        XTC99: $69.96
        Total items found: 4

:正则表达式: ``\$[0-9.]+``

:结果:

    .. code-block:: text

        ABC01: $23.45
        HGG42: $5.31
        CFMX1: $899.00
        XTC99: $69.96
        Total items found: 4

.. Hint:: 分析

        ``\$`` 匹配 $，``[0-9.]+`` 匹配价格。

如上所示的匹配结果符合你的预期。但如果你不想让 $ 出现在最终的匹配结果里， 
你该怎么办？从这个模式里简单地把 $ 去掉能达到目的吗？

:文本:

    .. code-block:: text

        ABC01: $23.45
        HGG42: $5.31
        CFMX1: $899.00
        XTC99: $69.96
        Total items found: 4

:正则表达式: [0-9.]+

:结果:

    .. code-block:: text

        ABC01: $23.45
        HGG42: $5.31
        CFMX1: $899.00
        XTC99: $69.96
        Total items found: 4

.. Hint:: 分析

        这显然不是你想要的结果。你需要 ``\$`` 来确定应该匹配哪些文本，
        你只是不想让 $ 出现在最终的匹配结果里而已。

怎么办？好办，这正是向后查找可以大显身手的地方，如下所示: 

:文本:

    .. code-block:: text

        ABC01: $23.45
        HGG42: $5.31
        CFMX1: $899.00
        XTC99: $69.96
        Total items found: 4

:正则表达式: ``(?<=\$)[0-9.]+``

:结果:

    .. code-block:: text

        ABC01: $**23.45**
        HGG42: $**5.31**
        CFMX1: $**899.00**
        XTC99: $**69.96**
        Total items found: 4

.. Hint:: 分析

    问题迎刃而解了。``(?<=\$)`` 只匹配 $，但不消费它；最终的匹配结果里
    只有价格数字（没有前缀的 $ 字符）。

对比一下这个例子的第一个和最后一个表达式： 
``\$[0-9.]+`` 匹配一个 $ 字符和一个美元金额；
``(?<=\$)[0-9.]+`` 也匹配一个$字符和一个美元金额。
这两个模式所查找的东西是一样的，它们之间的区别只体现在它们的匹配结果里。
前一个模式的匹配结果包含着 $，后一个模式的匹配结果不包含$字符，
虽然它必须通过匹配$字符才能正确地找到那些价格数字。

.. Warning:: 警告

    向前查找模式的长度是可变的，它们可以包含 . 和 + 之类的元字符，所以它们非常灵活。

    而向后查找模式只能是固定长度——这是一条几乎所有的正则表达式实现都遵守的限制。


P9.4 把向前查找和向后查找结合起来
===================================================

向前查找和向后查找可以组合在一起使用，就像下面这个例子所演示的那样（这个例子解决 
了我们在本章刚开始时提出的问题）:

:文本:

    .. code-block:: text

        <HEAD>
        <TITLE>Ben Forta’s Homepage</TITLE>
        </HEAD>

:正则表达式: (?<=<[tT][iI][tT][lL][eE]>).*(?=</[tT][iI][tT][lL][eE]>)

:结果:

    .. code-block:: text

        <HEAD>
        <TITLE>**Ben Forta’s Homepage**</TITLE>
        </HEAD>

.. Hint:: 分析

    问题解决了。(?<=<[tT][iI][tT][lL][eE]>) 是一个向后查找操作，它匹配（但不消
    费）<TITLE>；而 (?=</[tT][iI][tT][lL][eE]>) 是一个向前查找操作，它匹配（但不
    消费）</TITLE>。最终返回的匹配结果包含且仅包含标题文字（用术语来说，
    就是只有标题文字被消费了）。


.. Hint:: 提示

    为减少歧义，在上面这个例子里，你应该对需要匹配的第一个字符 < 进行一下
    转义，也就是把 ``(?<=<`` 替换为 ``(?<=\<`` 。


P9.5 对前后查找取非 positive vs. negative
===================================================

到目前为止正如你看到的那样，向前查找和向后查找通常用来匹配文本，其目的是为了确定 
将被返回为匹配结果的文本的位置（通过指定匹配结果的前后必须是哪些文本）。这种用法
被称为正向前查找（positive lookahead）和正向后查找（positive lookbehind）。术语“正”指的
是寻找匹配的事实。

前后查找还有一种不太常见的用法叫做负前后查找（negative lookaround）① 。负向前查找 
（negative lookahead）将向前查找不与给定模式相匹配的文本，负向后查找（negative
lookbehind）将向后查找不与给定模式相匹配的文本。

①此处的“负”译为“负面”“不允许”“取非”更好理解。——编者注

在第 3 章曾经介绍过一个用来对字符集合进行取非处理的操作符 ^，但 ^ 不能用来对前后查 
找进行取非处理。这里必须使用另外一种语法：前后查找必须用!来取非（它将替换掉 =）。

表 9-1 列出了所有的前后查找操作符。 

表 9-1 各种前后查找操作符 

=======  ================
操作符            说 明
=======  ================
(?=)               正向前查找
(?!)               负向前查找
(?               正向后查找
(?               负向后查找
=======  ================

.. Hint:: 提示

    一般来说，凡是支持向前查找的正则表达式实现都同时支持正向前查找和负向前查找。
    类似地，凡是支持向后查找的正则表达式实现都同时支持正向后查找和负向后查找。

为了演示正向后查找和负向后查找之间的区别，我们来看一个例子。下面是一段包含着一些 
数值的文本，其中既有价格又有数量。我们先来查找且只查找价格:

:文本:

    .. code-block:: text

        I paid $30 for 100 apples,
        50 oranges, and 60 pears.
        I saved $5 on this order.

:正则表达式: ``(?<=\$)\d+``

:结果:

    .. code-block:: text

        I paid $**30** for 100 apples,
        50 oranges, and 60 pears.
        I saved $**5** on this order.

.. Hint:: 分析

    这与我们刚见过的例子非常相似。``\d+`` 匹配数值（一个或多个数字字符），
    ``(?<=\$)`` 向后查找（但不消费）字符 $（这个字符在模式里被转义为 ``\$``）。
    这个模式正确地匹配到了两个用来表示价格的数值，那些用来表示数量的数字
    没有出现在最终的匹配结果里。

接下来，我们再去查找且只查找数量: 

:文本:

    .. code-block:: text

        I paid $30 for 100 apples,
        50 oranges, and 60 pears.
        I saved $5 on this order.

:正则表达式: ``\b(?<!\$)\d+\b``

:结果:

    .. code-block:: text

        I paid $30 for **100** apples,
        **50** oranges, and **60** pears.
        I saved $5 on this order.

.. Hint:: 分析

    ``\d+`` 还是匹配数值，但这次只匹配数量，不匹配价格。表达式 ``(?<!\$)`` 
    是一个负向后查找，它使得最终的匹配结果只包含那些不以 $ 开头的数值。
    把操作符 ``?<=`` 改为操作符 ``?<!`` 使得整个模式从一个正向后查找
    变成了一个负向后查找。

细心的读者可能已经注意到了，在上面这个例子里，我们还在那个负向后查找模式里用 ``\b`` 
元字符定义了两个单词边界。我们为什么要那么做呢？你看过下面这个没有使用单词边界的例
子里就明白了。

:文本:

    .. code-block:: text

        I paid $30 for 100 apples,
        50 oranges, and 60 pears.
        I saved $5 on this order.

:正则表达式: ``(?<!\$)\d+``

:结果:

    .. code-block:: text

        I paid $30 for 100 apples,
        50 oranges, and 60 pears.
        I saved $5 on this order.

.. Hint:: 分析

    请看，因为没有使用单词边界，$30里的0也出现在了最终的匹配结果里。这是因为那个0字
    符的前一个字符是3而不是$，它完全符合模式 ``(?<!\$)\d+`` 的匹配要求。
    把这个模式用 ``\b`` 括起来从根本上解决了这个问题。


P9.6 小结
===================================================

有了向后查找，我们就可以对最终的匹配结果包含且只包含哪些内容做出更精确的控制。 
前后查找操作使我们可以利用子表达式来指定文本匹配操作的发生位置，并收到只匹配不消费
的效果。正向前查找要用 ``(?=)`` 来定义，负向前查找要用 ``(?!)`` 来定义。有些正则表达式
实现还支持正向后查找（相应的操作符是 ``(?<=)`` ）和负向后查找（相应的操作符是 ``(?<!)`` ）。

===================================================
Chapter 10. 嵌入条件
===================================================

正则表达式语言还有一种威力强大（但不经常被用到）的功能——在表达式的内部嵌入条件 
处理功能。本章将对此做专题讨论。


P10.1 为什么要嵌入条件
===================================================

(123)456-7890 和 123-456-7890 都是可接受的北美电话号码格式，而 1234567890、 
(123)-456-7890 和 (123-456-7890) 虽然都包含着数目正确的数字字符，但它们的格式
都不对。如果让你来编写一个正则表达式并让它只匹配可接受的格式，不匹配其他格式，你
会怎么做？

这个问题看似简单，其实颇有难度。下面是最容易想到的解决方案: 

:文本:

    .. code-block:: text

        123-456-7890
        (123)456-7890
        (123)-456-7890
        (123-456-7890
        1234567890
        123 456 7890

:正则表达式: ``\(?\d{3}\)?-?\d{3}-\d{4}``

:结果:

    .. code-block:: text

        **123-456-7890**
        **(123)456-7890**
        **(123)-456-7890**
        **(123-456-7890**
        1234567890
        123 456 7890

.. Hint:: 分析

    ``\(?`` 匹配一个可选的左括号，这里必须对(进行转义；``\d{3}`` 匹配前三位数字；
    ``\)?`` 匹配一个可选的右括号；-? 匹配一个可选的连字符；``\d{3}-\d{4}`` 匹配
    剩余的七位数字，其中间用一个连字符分隔。原始文本中的最后两行不与这个模式匹配，
    但第 3 行和第 4 行与之匹配——这是不正确的，第 3 行的 ) 后面多了一个 -，
    第 4 行少了一个配对的右括号 )。

    把 ``\)?-?`` 替换为 ``[\]-]?`` 可以排除第 3 行，字符 ）或 - 只能出现一个，
    不允许两个同时出现。

    但第 4 行还是无法排除。正确的模式应该只在电话代码里有一个左括号 ( 的时候才
    去匹配右括号 )。更准确地说，应该是如果电话号码里有一个左括号 (，就必须去匹配 )；
    如果不是这样，它就必须去匹配 -。这种模式如果不使用条件处理根本无法编写。

.. Warning:: 警告

    并非所有的正则表达式实现都支持条件处理 。


P10.2 正则表达式里的条件
===================================================

正则表达式里的条件要用?来定义。事实上，你们已经见过几种非常特定的条件了: 

    1. ● ? 匹配前一个字符或表达式——如果它存在的话。
    2. ● ?= 和 ?<= 匹配前面或后面的文本——如果它存在的话。

嵌入条件语法也使用了 ?，这并没有什么让人感到吃惊的地方。因为嵌入条件不外乎以下两 
种情况:

    1. ● 根据一个回溯引用来进行条件处理。
    2. ● 根据一个前后查找来进行条件处理。


P10.2.1 回溯引用条件
===================================================

回溯引用条件只在一个前面的子表达式搜索取得成功的情况下才允许使用一个表达式。 
听起来很费解，还是用一个例子来说明好了：把一段文本里的 <IMG> 标签全都找出来；
不仅如此，如果某个 <IMG> 标签是一个链接（被括在<A>和</A>标签之间）的话，
还要把整个链接标签匹配出来。

用来定义这种条件的语法是 ?(backreference)true-regex)，其中 ? 表明这是一个条件， 
括号里的 backreference 是一个回溯引用，true-regex 是一个只在 backreference
存在时才会被执行的子表达式。 请看下面这个例子:

:文本:

    .. code-block:: text

        <!-- Nav bar -->
        <TD>
        <A HREF="/home"><IMG SRC="/images/home.gif">fff</A>
        <IMG SRC="/images/spacer.gif">
        <A HREF="/search"><IMG SRC="/images/search.gif"></A>
        <IMG SRC="/images/spacer.gif">
        <A HREF="/help"><IMG SRC="/images/help.gif"></A>
        </TD>

:正则表达式: ``(<[Aa]\s+[^>]+>\s*)?<[Ii][Mm][Gg]\s+[^>]+>(?(1)\s*</[Aa]>)``

:结果:

    .. code-block:: text

        <!-- Nav bar -->
        <TD>
        **<A HREF="/home"><IMG SRC="/images/home.gif"></A>**
        **<IMG SRC="/images/spacer.gif">**
        **<A HREF="/search"><IMG SRC="/images/search.gif"></A>**
        **<IMG SRC="/images/spacer.gif">**
        **<A HREF="/help"><IMG SRC="/images/help.gif"></A>**
        </TD>

.. Hint:: 分析

    这个模式不解释是不容易看明白的。``(<[Aa]\s+[^>]+>\s*)?`` 将匹配一个<A>或<a>标签
    （以及<A>或<a>标签的任意属性），这个标签可有可无（因为这个子表达式的最后有一
    个?）。接下来，``<[Ii][Mm][Gg]\s+[^>]+>`` 匹配一个<IMG>（大小写均可）及其任意属
    性。``(?(1)\s*</[Aa]>)`` 是一个回溯引用条件——?(1)的含义是：如果第一个回溯引用
    （具体到本例，就是<A>标签）存在，则使用\s*</[Aa]>继续进行匹配（换句话说，只有
    当前面的<A>标签匹配成功，才继续进行后面的匹配）。如果(1)存在，\s*</[Aa]>将匹配
    结束标签</A>之后出现的任意空白字符。


.. Note:: 注意

    ``?(1)`` 检查第一个回溯引用是否存在。在条件里，回溯引用编号（本例中的1）不
    需要被转义。因此，``?(1)`` 是正确的，``?(\1)`` 不正确（但后者通常也能工作）。
    
使用回溯的模式只在给定条件得到满足时才执行一个表达式。条件还可以有否则表达 
式，否则表达式只在给定的回溯引用不存在（也就是条件没有得到满足）时才会被执行。
用来定义这种条件的语法是 ``?(backer-ference)true-regex|false-regex)``，这个语法
接受一个条件和两个将分别在这个条件得到满足和没有得到满足时执行的子表达式。

这个语法提供了电话号码问题的解决方案，如下所示: 

:文本:

    .. code-block:: text

        123-456-7890
        (123)456-7890
        (123)-456-7890
        (123-456-7890
        1234567890
        123 456 7890

:正则表达式: ``(\()?\d{3}(?(1)\)|-)\d{3}-\d{4}``

:结果:

    .. code-block:: text

        **123-456-7890**
        **(123)456-7890**
        (123)-456-7890
        (123-456-7890
        1234567890
        123 456 7890

.. Hint:: 分析

        从结果看，这个模式解决了问题，但它是如何解决问题的呢？

        ``(\()?`` 也匹配一个可选的左括号，但这次把它用括号括起来得到了一个子表达式。
        随后 ``\d{3}`` 匹配 3 位数字的区号。``(?(1)\)|-)`` 是一个回溯引用条件，
        它将根据条件是否得到满足而去匹配 ``)``，
        或者条件 (1)存在（也就是找到了一个左括号），那么 ``\)`` 必须被匹配；
        否则，- 必须被匹配。 

        这样一来，只有配对出现的括号才会被匹配；如果没有使用括号或括号不配对，
        电话号码中的区号和其余数字之间的 - 分隔符必须被匹配。


.. Hint:: 提示

    嵌入了条件的模式看上去往往非常复杂，而这往往意味着调试工作会变得非常困
    难。如果别无选择，先对整个模式的各组成部分分别进行调试，再把它们拼装到一起，这
    通常是一种比较好的办法。


P10.2.2 前后查找条件
===================================================

前后查找条件只在一个向前查找或向后查找操作取得成功的情况下才允许一个表达式被使 
用。定义一个前后查找条件的语法与定义一个回溯引用条件的语法大同小异——只需把回溯
引用（括号里的回溯引用编号）替换为一个完整的前后查找表达式就行了。

.. Note:: 注意

    对前后查找操作的详细讨论见第 9 章。

作为一个例子，请你思考一下怎样匹配美国的邮政编码（简称 ZIP 编码）。美国邮政编码有两 
种格式，一种是 12345 形式的 ZIP 格式，另一种是 12345-6789 形式的 ZIP+4 格式。
只有 ZIP+4 格式才必须使用连字符来分隔前 5 位和后 4 位数字。下面是一种解决方法:

:文本:

    .. code-block:: text

        11111
        22222
        33333-
        44444-4444

:正则表达式: ``\d{5}(-\d{4})?``

:结果:

    .. code-block:: text

        **11111**
        **22222**
        **33333**-
        **44444-4444**

.. Hint:: 分析

    ``\d{5}`` 匹配前 5 位数字，``(-\d{4})?`` 匹配一个连字符和后4位数字，
    它们必须一起出现或一起不出现。

现在，请考虑这样一个问题：如果你不想匹配那些格式不正确的 ZIP 编码，你该怎么办？ 
比如说，在上面这个例子里，在第 3 行原始文本的末尾有一个不应该出现在那里的连字符，
但这个号码还是出现在了最终的匹配结果里。怎样才能让这个格式不正确的 ZIP 编码不出现
在最终的匹配结果里呢？

下面是用一个前后查找条件来解决这个问题的方法，虽然这个问题并非只有这一种解决办法。 

:文本:

    .. code-block:: text

        11111
        22222
        33333-
        44444-4444

:正则表达式: ``\d{5}(?(?=-)-\d{4})``

:结果:

    .. code-block:: text

        **11111**
        **22222**
        33333-
        **44444-4444**

.. Hint:: 分析

    ``\d{5}`` 匹配前 5 位数字。接下来 ``(?(?=-)-\d{4})`` 向前查找条件。这个条件使
    用了 ``?=-`` 来匹配一个连字符（但不消费），如果连字符存在，``-\d{4}``
    将匹配那个连字符和随后的 4 位数字。这样一来，33333- 排除在最终的匹配结果之外。
    它有一个连字符，满足给定条件，但那个连字符的后面没有必须出现的 4 位数字。


.. Hint:: 提示

    在实际工作中，嵌入了前后查找条件的模式相当少见，这是因为我们往往可以用更
    简单的办法来达到同样的目的。


P10.3 小结
===================================================

在正则表达式模式里可以嵌入条件，只有当条件得到（或者没有得到）满足时，相应的表达 
式才会被执行。这种条件可以是一个回溯引用（含义是检查该回溯引用是否存在），也可以
是一个前后查找操作。


===================================================
附录A 常见应用软件 和编程语言中的 正则表达式
===================================================

不同的正则表达式实现在基本的语法方面大都是一致的，但在正则表达式的具体用法方面往 
往有所不同。支持正则表达式的编程语言和应用软件各用各的调用方法，在许多细节上都有
自己的一套方法。本附录将对比较流行的应用软件和编程语言中的正则表达式的用法和一些
具体的注意事项进行描述。

.. Note:: 注意

    本附录里的信息只是些为了帮助你尽快入门而准备的速查资料，具体的示例和注
    意事项超出了本书的讨论范围，这方面的细节还请你自行参阅相关的应用软件或编程语言
    的文档。

A.1 grep
===================================================

grep 是一种用来对文件或标准输入文本进行文字搜索的 Unix 工具。 
根据你具体使用的命令选项，grep 支持基本、扩展和 Perl 正则表达式。

1. ● -E：使用扩展正则表达式。
2. ● -G：使用基本正则表达式。
3. ● -P：使用Perl正则表达式。


.. Hint:: 提示

    你使用的命令选项不同，grep 工具的功能和用途也就不同。大多数用户喜欢使用
    Perl 正则表达式（见稍后的描述），因为这些是最标准的。

请注意以下事项: 

1.  ● 在默认的情况下，grep将把包含着匹配的各个文本行全部显示出来；如果你只想查看匹
    配结果，请使用-o选项。
2.  ● 使用-v选项将对整个匹配操作进行求非——只显示不匹配的文本行。
3.  ● 使用-c选项将只显示匹配的总数而不是次匹配的细节。
4.  ● grep工具只能用来进行搜索操作，不能用来进行替换操作。换句话说，grep工具不支持
    替换功能。

A.2 JavaScript
===================================================

JavaScript 1.x 版本在 String 和 RegEx 对象的以下几个方法里实现了正则表达式处理。 

1. ● exec：一个用来搜索一个匹配的RegEx方法。
2. ● match：一个用来匹配一个字符串的String方法。
3. ● replace：一个用来完成替换操作的String方法。
4. ● search：一个用来测试在某给定字符串里是否存在着一个匹配的String方法。
5. ● split：一个用来把一个字符串拆分为多个子串的String方法。
6. ● test：一个用来测试在某给定字符串里是否存在着一个匹配的RegEx方法。

.. Note:: 注意

    JavaScript 2 的正则表达式处理（Mozilla 和另外几种比较新的浏览器可以支持）与
    JavaScript 1.x 向后兼容并提供了更多的功能。

JavaScript 对正则表达式的支持源自 Perl 语言，但需要注意以下几个问题: 

1. ● JavaScript 使用命令行选项来管理全局的区分大小写搜索：g选项激活全局搜索功能，i
    选项让匹配操作不区分字母的大小写，这两个选项可以组合为gi。
2. ● 其他命令行选项（版本 4 及以后的浏览器支持）包括：m，支持多行字符串；s，支持单
    行字符串；x，忽略正则表达式模式里的空白字符。
3. ● 在使用回溯引用的时候，$将返回被匹配字符串前面的所有东西，$ 将返回被匹配字符串
    后面的所有东西，$+ 将返回最后一个被匹配的子表达式，$& 将返回被匹配到的所有东西。
4. ● JavaScript 提供了一个名为 RegExp 的全局对象，在执行完一个正则表达式之后，你们可
    以通过这个对象获得与这次执行有关的信息。
5. ● JavaScript 不支持 POSIX 字符类。
6. ● JavaScript 不支持 ``\A`` 和 ``\Z`` 。

A.3 Macromedia ColdFusion
===================================================

ColdFusion 通过以下 4 个函数提供正则表达式支持。 

1. ● REFind()：执行搜索。
2. ● REFindNoCase()：执行不区分字母大小写的搜索。
3. ● REReplace()：执行替换。
4. ● REReplaceNoCase()：执行不区分字母大小写的替换。


.. Note:: 注意

    ColdFusion 还支持在 <CFINPUT> 标签里使用正则表达式进行输入检查的做法。不
    过，这个标签本身并不对正则表达式进行处理，它只负责把正则表达式传递到最终生成的
    客户端 JavaScript 代码里，对正则表达式的处理由 JavaScript 负责完成。因此，出现在
    <CFINPUT>标签里的正则表达式必须遵守JavaScript的有关正则和注意事项。

ColdFusion 支持与 Perl 语言兼容的正则表达式，但需要注意以下几个问题: 

1. ● .总是匹配换行符。
2. ● 在使用回溯引用的时候，必须使用 ``\n`` 代替$n来引用回溯引用变量。ColdFusion将自动地
    把替换字符串里的所有$字符解释为它们的转义含义。
3. ● 你不必对替换字符串里的反斜线字符进行转义。ColdFusion将自动地把它们解释为它们
    的转义含义，但大小写转换序列或它们的转义版本（例如 ``\u`` 或 ``\\u`` ）属于例外。
4. ● 嵌入限定符（(?i)、等）总是影响整个表达式，即使它们只是出现在某个子表达式的
    内部。
5. ● ColdFusion 不支持在替换字符串里使用 ``\Q`` 、 ``\u\L`` 或 ``\l\U`` 。
6. ● ColdFusion 不支持向后查找（?<=和?<!）。
7. ● ColdFusion 不支持条件处理。
8. ● ColdFusion 不支持 ``\x`` 、 ``\N`` 、 ``\p`` 和 ``\C`` 。

.. Note:: 注意

    在这本书里，我们提到 ColdFusion 的所有地方都指的是 ColdFusion MX 或更高版
    本。这些版本里的正则表达式引擎都经过了全面的改写，与早期版本里的大不一样；换句
    话说，本书没有对早期 ColdFusion 版本对正则表达式的支持进行讨论。

A.4 Macromedia Dreamweaver
===================================================

Macromedia Dreamweaver 支持在“搜索和替换”操作中使用正则表达式。 
要想使用正则表达式，请按以下步骤操作。

1. ● 在“Edit（编辑）”菜单里选择“Find and Replace（查找和替换）”，再选中“Use Regular
    Expression（使用正则表达式）”选择框。
    请注意以下事项。
2. ● 在替换模式里，必须使用$语法（例如 $1）来引用一个回溯引用。但如果是在同一个模
    式里，则必须使用 ``\`` 语法（例如 ``\1`` ）来引用一个回溯引用。
3. ● 正则表达式模式可以保存起来供以后再次使用。

A.5 Macromedia HomeSite 和 ColdFusion Studio
===================================================

Macromedia HomeSite（包括 ColdFusion Studio）支持在“搜索和替换”操作中使用正则表达式。
要想使用正则表达式，请按以下步骤操作:

1. ● 在“Search（搜索）”菜单里选择“Extended Find（扩展查找）”或“Extended Repalce（扩展
    替换）”。
2. ● 选中“Regular Expression（正则表达式）”选择框。

请注意以下事项: 

1. ● HomeSite 正则表达式支持与 ColdFusion 里的正则表达式基本一致。
2. ● HomeSite 不支持 POSIX 字符类。
3. ● HomeSite 支持回溯引用，但使用的是 ``\1`` 语法。
4. ● . 总是匹配换行符。
5. ● 正则表达式模式可以保存起来供以后再次使用。

A.6 Microsoft ASP
===================================================

所有的 ASP 脚本语言都支持正则表达式。正则表达式支持是通过一个名为 RegExp 的 
对象提供的，这个对象包含着以下几个方法。

1. ● **Excute()**：执行一个正则表达式搜索操作。
2. ● **Replace()**：执行一个“搜索和替换”操作。
3. ● **Test()**：检查一个字符串是否与一个给定的正则表达式相匹配。

ASP正则表达式支持还有一些局限性（ASP.NET 有着非常高级和复杂的正则表达式支持）。 
下面是一些你们必须注意的事项。

1. ● 在执行上述任何一个方法之前，必须先创建并填充一个RegExp对象的实例。
2. ● 正则表达式被存放在RegExp.Pattern里。
3. ● 支持全局限定符和大小写限定符。前者是一个存放在RegExp.Global里的布尔值，后
   者是一个存放在RegExp.IgnoreCase里的布尔值。
4. ● Excute()方法将返回一个Match对象，通过这个对象可以访问到所有的匹配。
5. ● 不支持向前查找（?=和?!）和向后查找（?<=和?<!）。

A.7 Microsoft ASP.NET
===================================================

ASP.NET 里的正则表达式支持由 .NET Framework 提供。参阅后面的 A.9。 

A.8 Microsoft C#
===================================================

C# 里的正则表达式支持由 .NET Framework 提供。参阅 A.9。 

A.9 Microsoft .NET
===================================================

.NET Framework 通过它的基本类库提供了强大和灵活的正则表达式支持，这些支持在
所有的 .NET 语言和工具（包括 ASP.NET、C# 和 Visual Studio .NET）里都可以使用。
.NET 里的正则表达式支持是通过 Regex 以及辅助类提供的。Regex 类有以下
一些方法。

1. ● IsMatch()：测试在某个给定的字符串里是否可以找到一个匹配。
2. ● Match()：搜索一个单个的匹配，该匹配将被为一个Match对象。
3. ● Matches()：搜索所有的匹配，它们将被返回为一个Match- Collection对象。
4. ● Replace()：在一个给定的字符串上进行替换操作。
5. ● Split()：把一个字符串拆分为一个字符串数组。

利用各种包装器函数，无须创建 Regex 类实例的情况下可以执行一个正则表达式。 

1. ● Regex.IsMatch()：在功能上等价于IsMatch()方法。
2. ● Regex.Match()：在功能上等价于Match()方法。
3. ● Regex.Matches()：在功能上等价于Matchex()方法。
4. ● Regex.Replace()：在功能上等价于Replace()方法。
5. ● Regex.Split()：在功能上等价于Split()方法。

下面是一些与 .NET 正则表达式支持有关的重要注意事项。 

1. ● 使用正则表达式，必须导入正则表达式对象“Imports System.Text.RegularExpressions”。
2. ● 如果只是临时需要使用正则表达式，上述包装器函数是理想的选择。
3. ● 正则表达式的选项需要使用 Regex.Options 属性给出，它是一个 RegexOption
   枚举集合，你可以对这个枚举集合的各有关成员如 IgnoreCase、Multiline、
   Singleline 等进行设置。
4. ● .NET 支持命名捕获，即允许对子表达式进行命名（这样就可以使用名字而不是
   编号来引用它们了）。命名一个子表达式的语法是 ?<name>，引用这个回溯引用的语法是
   ``\k<name>``，在一个替换模式里引用它的语法是 ${name}。
5. ● 在使用回溯引用的时候，$'（反引号）将返回被匹配字符串前面的所有东西，
    $'（单引号）将返回被匹配字符串后面的所有东西，$+ 将返回最后一个被匹配的
    子表达式，$_ 将返回整个原始字符串，$&将返回整个被匹配字符串。
6. ● .NET Framework 不支持使用 ``\E``、 ``\l``、 ``\L``、 ``\u`` 和 ``\U``
    进行大小写转换。
7. ● .NET Framework 不支持 POSIX 字符类。

A.10 Microsoft Visual Studio .NET
===================================================

Visual Studio .NET 里的正则表达式支持由 .NET Framework 提供。参阅前面的 A.9。 
要想使用正则表达式，请按以下步骤操作:

1. ● 在“Edit”菜单里选择“Find and Replace”。
2. ● 选择“Find”、“Replace”、“Find in Files”或“Replace in Files”。

打开“Use（使用）”下拉框，从下拉清单里选择“Regular expressions”。 

请注意以下事项: 

1. ● 使用 @ 代替 ``*?``。
2. ● 使用#代替 ``+?``。
3. ● 使用 ^n 代替 {n}。
4. ● 在替换操作里，可以用 ``\(w, n)`` 语法（其中的 w 是宽度，n 是一个回溯引用编号）
    来左对齐一个回溯引用，右对齐一个回溯引用的语法是 ``\(-w, n)``。
5. ● Visual Studio .NET 使用以下特殊元字符和符号来表示常用的字符集合:

    .. code:: text

        :a 　[a-zA-Z0-9]
        :c 　[a-zA-Z]
        :d 　\d
        :h 　[a-fA-F0-9]（十六进制数字）
        :i 　[a-zA-Z_$][a-zA-Z_0-9$]*（合法的.NET标识符）
        :q 　一个括在引号里的字符串
        :w 　[a-zA-Z]+
        :z 　\d+

  1. ● ``\n`` 是一个与平台无关的换行符。在替换操作里，它将插入一个新行。
  2. ● 支持以下几种特殊的字母匹配字符::

      :Lu　匹配任意大写字母
      :Ll　匹配任意小写字母
      :Lt　匹配单词的标题形式（首字母是大写的单词）
      :Lm　匹配任意标点符号

  3. ● 支持以下几种特殊的数字匹配字符::

      :Nd　[0-9]+（十进制数字）
      :Nl　罗马数字

  4. ● 支持以下几种特殊的标点符号匹配字符::

      :Ps　配对标点符号的开始符号（左括号、左引号，等等）
      :Pe　配对标点符号的结束符号（右括号、右引号，等等）
      :Pi 　双引号
      :Pf　单引号
      :Pd　短划线（连字符）
      :Pc　下划线
      :Po　其他标点符号

  5. ● 支持以下几种特殊的符号匹配字符::

      :Sm　数学符号
      :Sc　货币符号
      :Sk　重音和方言符号
      :So　其他符号

  6. ● 还有一些字符在 .NET Framework 里也有特殊含义，详细情况参阅 Visual Studio .NET 文档。

A.11 MySQL
===================================================

MySQL 是一个流行的开放源代码数据库软件。MySQL率先提供了正则表达式支持作为一种数 
据库搜索手段，这一点我们在其他数据库系统里还没有见过。

MySQL 对正则表达式的支持体现在允许在 WHERE 子句里使用如下格式的表达式::

    REGEXP "expression"

.. Note:: 注意

    下面是一条使用了正则表达式的 MySQL 语句的完整语法::

        SELECT * FROM table WHERE REGEXP "pattern"

MySQL 正则表达式支持很有用，功能也很强大，但它还算不上是一个完备的正则表达式实现。 

1. ● 只提供了搜索支持，不支持使用正则表达式进行替换操作。
2. ● 在默认的情况下，正则表达式搜索不区分字母的大小写。如果需要区分字母的大小写，
   必须再增加一个 BINARY 关键字（放在 REGEXP 和模式之间）。
3. ● 用 [[:<:]] 来匹配一个单词的开头，用 [[:>:]] 来匹配一个单词的结束。
4. ● 不支持向前预测。
5. ● 不支持嵌入条件。
6. ● 不支持八进制字符搜索。
7. ● 不支持 ``\a``、 ``\b``、 ``\e``、 ``\f`` 和 ``\v``。
8. ● 不支持回溯引用。

A.12 Perl
===================================================

Perl 可以说是各种正则表达式实现的“祖宗”，其他各种实现几乎都与 Perl 相兼容。 
正则表达式支持是 Perl 核心组件之一。如果需要在 Perl 脚本里使用正则表达式，
只要像下面这样给出一个操作和相应的模式即可。

1. ● m/pattern/　匹配给定的模式。
2. ● s/ pattern/pattern/　执行一个替换操作。
3. ● qr/pattern/　返回一个Regex对象供今后使用。
4. ● split()　把一个字符串拆分为子字符串。

下面是一些与Perl正则表达式有关的注意事项。 

1. ● 允许把限定符放在模式的后面。``\i`` 用来表明在搜索时不区分字母的大小写；
    ``\g`` 用来表
    明进行全局搜索（把所有的匹配都找出来）。
2. ● 在使用“回溯引用”的时候，
    $' 将返回被匹配字符串前面的所有东西，
    $' 将返回被匹配字符串后面的所有东西，
    $+ 将返回最后一个被匹配的子表达式，
    $& 将返回整个被匹配字符串。

A.13 PHP
===================================================

PHP通过它的PCRE组件提供了与Perl相兼容的正则表达式支持。 

.. Note:: 注意

    PHP 4.2.0 版本开始，PCRE 组件将自动安装。PHP 早期版本的用户需要自行编译
    PHP pcre-regex 软件包才能启用正则表达式支持。

下面是 PCRE 组件提供的一些正则表达式函数。 

1.  preg_grep()：进行一次搜索，匹配结果将作为数组返回。
2.  preg_match()：进行一次正则表达式搜索，返回第一个匹配。
3.  preg_match_all()：进行一次正则表达式搜索，返回所有的匹配。
4.  preg_quote()：这个函数的输入参数是一个模式，返回值是该模式的转义版本。
5.  preg_replace()：进行一次“搜索并替换”操作。
6.  preg_replace- callback()：进行一次“搜索并替换”操作，但使用一个回调
    （callback）函数来完成实际替换动作。
7.  preg_split()：把一个字符串拆分为子字符串。

请注意以下事项。 

1. ● 在默认的情况下，匹配操作不区分字母的大小写。如果不想区分字母的大小写，必须使
    用 i 限定符。
2. ● 在默认的情况下，匹配操作仅限于单行字符串。如果需要匹配多行字符串，必须使用m
    限定符。
3. ● preg_replace()、preg_replace_callback() 和 preg_split() 函数都支持一
    个可选的参数，该参数用来给出一个上限值——对字符串进行替换或拆分的最大次数。
4. ● preg_grep() 和 preg_replace_callback() 是从 PHP 4 才开始有的，其他函数都是
    从 PHP 3 开始就被支持。
5. ● PHP 4.0.4 和更高版本里，回溯引用可以用 Perl 语言的$语法（例如 $1）来引用；
    在较早的版本里必须用 ``\\`` 来代替 $。
6. ● 不支持 ``\l``、``\u``、``\L``、``\U``、``\Q`` 和 ``\v``。

A.14 Sun Java
===================================================

Java对正则表达式的支持是从1.4版本开始的，此前的JRE（Java Runtime Environment，Java运
行环境）版本不支持正则表达式。

.. Warning:: 警告

    版本低于1.4的JRE现在仍被广泛地使用着。如果你打算部署一个使用了正则表达

式的Java应用程序，千万不要忘记检查JRE的版本。 

.. Note:: 注意

    Sun 公司花了很长的时间才在Java里实现了正则表达式支持，而不少软件团队在几
    年前就开发出了各种非官方的正则表达式实现。因为篇幅的限制，本书没能对那些非官方
    Java 正则表达式实现进行介绍；以下注意事项只适用于由 Sun 公司正式发布的 Java 正则
    表达式支持。

Java 语言中的正则表达式匹配功能主要是通过 java.util.regex.matcher 类和以下这些方 
法实现的。

*  ● find()：在一个字符串里寻找一个给定模式的匹配。
*  ● lookingAt()：用一个给定的模式去尝试匹配一个字符串的开头。
*  ● matches()：用一个给定的模式去尝试匹配一个完整的字符串。
*  ● replaceAll()：进行替换操作，对所有的匹配都进行替换。
*  ● replaceFirst()：进行替换操作，只对第一个匹配进行替换。
    matcher 类还提供了几个能够让程序员对特定操作做出更细致调控的方法。此外
    java.util.regex.pattern 类也提供了几个简单易用的包装器方法。
*  ● compile()：把一个正则表达式编译成一个模式。
*  ● flags()：返回某给定模式的匹配标志。
*  ● matches()：在功能上等价于刚才介绍的matches()方法。
*  ● pattern()：把一个模式还原为一个正则表达式。
*  ● split()：把一个字符串拆分为子字符串。
    Sun公司发布的Java正则表达式支持与Perl语言基本兼容，但要注意以下几点。
*  ● 要想使用正则表达式，必须先用 ``import java.util.regex.*`` 语句导入正则表达式
    组件，这条语句将导入一个完整的软件包。
*  ● 不支持嵌入条件。
*  ● 不支持使用 ``\E``、 ``\l``、 ``\L``、 ``\u`` 和 ``\U`` 进行字母大小写转换。
*  ● 不支持使用 ``\b`` 匹配退格符。
*  ● 不支持 ``\z``。

附录B 常见问题的正则表 达式解决方案
===================================================

本附录收集了一些非常实用的正则表达式并对它们分别做了详细的解释。这些正则表达式所 
涉及的问题都是大家在实际工作中经常会遇到的。我们编写这个附录的目的有两个：一是通
过解决这些实际问题对全书内容做一个总结，二是向大家提供一些现成的模式以帮助大家节
省这方面的时间和精力。

.. Note:: 注意

    本附录里的示例不一定是相关问题的终极答案。事实上，正如我们在书中反复提
    到的那样，与正则表达式有关的问题很少会有一个终极的答案。更常见的情况是同时存在
    多种答案——它们没有绝对的对错之分，它们之间的区别只体现在你希望你的匹配操作严
    格到什么程度或者说你对匹配误差容忍到什么程度。在构造一个正则表达式模式的时候，
    我们不仅要考虑到匹配结果的准确性，还必须考虑到它的执行效率；而这两个因素往往难
    以两全。有了这样的认识，相信大家能够根据你们的具体情况选用这里给出的模式并在必
    要时对它们做出进一步改进。

B.1 电话号码
==================================================

中国固定电话号码的规律是，最开始的位一定是 0，表示长途，接着是两位、三位或者 
四位数字组成的区号，然后是 7 位或者 8 位的电话号码，其中首位不为 1（1用于特殊用
途）。而国内习惯的电话格式有：029 8845 7890，029 88457890，（029）8845 7890，
（029）88457890，029-8845 7890，029-88457890，029-8845-7890。对应的正则表达式可
以写为：\(?0[1-9]\d{1,3}\)?[-]?[2-9]\d{2,3}[-]?\d{4}。——编者注

North American Numbering Plan（北美编号方案）对北美地区的电话号码格式做出了定义。 
根据这一方案，北美地区（美国、加拿大、加勒比海地区大部以及其他几个地区）的电话号码
由一个 3 位数的区号和一个7位数的号码构成（这 7 位数字又分成一个 3 位数的局号和一个 
4 位数的线路号，局号和线路号之间用连字符分隔）。每位电话号码可以是任意数字，但区号和局
号的第一位数字不能是 0 或 1。在书写电话号码的时候，人们往往把区号放在括号里，而且还
往往会在区号与实际电话号码之间加上一个连字符来分隔它们。匹配 (555) 555-5555（右括号
的后面有一个空格）或 (555)555-5555 或 555-555-5555 其中之一，但要想编写一个能够同
时匹配这些电话号码的模式就不那么容易了。

:文本:

    .. code-block:: text

        J. Doe: 248-555-1234
        B. Smith: (313) 555-1234
        A. Lee: (810)555-1234

:正则表达式: ``\(?[2-9]\d\d\)?[ -]?[2-9]\d\d-\d{4}``

:结果:

    .. code-block:: text

        J. Doe: 248-555-1234
        B. Smith: (313) 555-1234
        A. Lee: (810)555-1234

.. Hint:: 分析

    这个模式的开头是样子很怪的 ``\(?``，它负责匹配用来括住区号的括号——这对括号是可选
    的： ``\(`` 匹配 ( 字符，? 表示匹配 ( 的零次或一次出现。接下来的 ``[2-9]\d\d`` 
    负责匹配一个 3 位数的区号（第 1 位数字只能是 2 到 9）。``\)?`` 
    匹配一个可选的右括号，``[ -]?`` 匹配一个空格或连字符——这个字符也是可选的。
    ``[2-9]\d\d-\d{4}`` 匹配电话号码的剩余部分：一个 3 位数的
    局号（第 1 位数字只能是 2 到 9）、一个连字符和最后 4 位数字。

只须稍做修改，这个模式就可以用来匹配北美电话号码的其他格式。比如像 555.555.5555 
这样的号码。

:文本:

    .. code-block:: text

        J. Doe: 248-555-1234
        B. Smith: (313) 555-1234
        A. Lee: (810)555-1234
        M. Jones: 734.555.9999

:正则表达式: ``[\(.]?[2-9]\d\d[\).]?[ -]?[2-9]\d\d[-.]\d{4}``

:结果:

    .. code-block:: text

        J. Doe: 248-555-1234
        B. Smith: (313) 555-1234
        A. Lee: (810)555-1234
        M. Jones: 734.555.9999

.. Hint:: 分析

    这个模式的开头部分使用了字符集合 ``[\(.]?`` 来匹配一个 ( 或 . 字符——它们都是可选的。
    类似地， ``[\).]?`` 匹配一个 ) 或 . 字符——它们也都是可选的；
    ``[-.]`` 匹配一个 - 或 . 字符。

    只要把这两个例子看明白了，你就可以轻而易举地把其他电话号码格式也添加到你的模式里。

B.2 美国邮政编码
===================================================

①中国邮政编码
我国邮政编码的规则是，前两位表示省、市、自治区，第三位代表邮区，第四位代表县、
市，最后两位代表投递邮局。共6位数字，其中第二位不为8（港澳前两位为99，其余省市
为0-7）。对应的正则表达式可以写为：``\d(9|[0-7])\d{4}``。——编者注

美国于 1963 年开始使用邮政编码，简称 ZIP 编码，Zone Improvement Plan的。 
美国目前有 40 000 多个 ZIP 编码，它们全都由数字构成（第 1 位数字代表从美国东部到西
部的一个地域，0 代表东海岸地区，9 代表西海岸地区）。1983 年美国邮政总局开始使用
扩展的 ZIP 编码，简称 ZIP+4 编码。新增加的 4 位数字对信件投送区域做了更细致的划分（细化
到某个特定的城市街区或某幢特定的建筑物），这大大提高了信件的投送效率和准确性。不
过，ZIP+4 编码的使用是可选的，所以对 ZIP 编码进行检查通常必须同时照顾到 5 位数字的 ZIP
编码和 9 位数字的 ZIP+4 编码（ZIP+4 编码中的后 4 位数字与前 5 位数字之间要用一个连字符隔
开）。

:文本:

    .. code-block:: text

        999 1st Avenue, Bigtown, NY, 11222
        123 High Street, Any City, MI 48034-1234

:正则表达式: ``\d{5}(-\d{4})?``

:结果:

    .. code-block:: text

        999 1st Avenue, Bigtown, NY, 11222
        123 High Street, Any City, MI 48034-1234

.. Hint:: 分析

    ``\d{5}`` 匹配任意5位数字，``(-\d{4})?`` 匹配一个连字符和后4位数字。因为后4位数字是可选
    的，所以要把 ``-\d{4}`` 用括号括起来（这使它成为了一个子表达式），再用一个 ? 来表明这个
    子表达式最多只允许出现一次。

B.3 加拿大邮政编码
===================================================

加拿大邮政编码由6个交替出现的字母和数字字符构成。每个编码分成两部分：前3个字符用 
来给出 FSA 代码（forward sortation area，地区代码），后 3 个字符用来给出 LDU 代码（local
delivery unit，街道代码）。FSA代码的第一个字符用来表明省、市或地区（这个字符有18种
合法的选择；比如A代表纽芬兰地区；B代表新斯科舍地区；K、L、N和P代表安大略省；M代
表多伦多市，等等），而我们的模式应该确保这第一个字符是合法的。在写出一个加拿大邮
政编码的时候，FSA代码和LDU代码之间通常要用一个空格隔开。

:文本:

    .. code-block:: text

        123 4th Street, Toronto, Ontario, M1A 1A1
        567 8th Avenue, Montreal, Quebec, H9Z 9Z9

:正则表达式: ``[ABCEGHJKLMNPRSTVXY]\d[A-Z] \d[A-Z]\d``

:结果:

    .. code-block:: text

        123 4th Street, Toronto, Ontario, M1A 1A1
        567 8th Avenue, Montreal, Quebec, H9Z 9Z9

.. Hint:: 分析

    [ABCEGHJKLMNPRSTVXY] 匹配那18个合法字符中的任何一个，
    ``\d[A-Z]`` 匹配一个数字和一个紧随其后的任意字母；合起来匹配一个合法的 FSA 代码。
    ``\d[A-Z]\d`` 匹配 LDU 代码，任意两个数字字符夹着任意一个字母。

.. Note:: 注意

    加拿大邮政编码不要求必须以大写形式写出，所以在使用上面这个正则表达式进行
    匹配时一般用不着区分字母的大小写。

B.4 英国邮政编码
===================================================

英国邮政编码由5个、6个或7个字符构成，这些编码是由英国皇家邮政局定义的。英国邮政编 
码由两部分构成：代表邮政区划的外码（outcode）和代表城市街道的内码（incode）。外码
是一个或两个字母后面跟着一位或两位数字，或者是一个或两个字母后面跟着一个数字和一
个字母。内码永远是一位数字后面跟着两个字母（除 C、I、K、O 和 V 以外的任意字母——合
法的英国邮政编码是不会在它的内码部分使用这5个字母的）。内码和外码之间要用一个空格
隔开。

:文本:

    .. code-block:: text

        171 Kyverdale Road, London N16 6PS
        33 Main Street, Portsmouth, P01 3AX
        18 High Street, London NW11 8AB

:正则表达式: ``[A-Z]{1,2}\d[A-Z\d]? \d[ABD-HJLNP-UW-Z]{2}``

:结果:

    .. code-block:: text

        171 Kyverdale Road, London N16 6PS
        33 Main Street, Portsmouth, P01 3AX
        18 High Street, London NW11 8AB

.. Hint:: 分析

    在这个模式里，``[A-Z]{1, 2}\d`` 匹配一个或两个字母紧跟着一位数字，
    随后的 ``[A-Z\d]?`` 匹配一个可选的字母或数字字符。
    于是，``[A-Z]{1, 2}\d[A-Z\d]?`` 将匹配任何一种合法的外码组合。
    内码部分由 ``\d[ABD-HJLNP-UW-Z]{2}`` 负责匹配，它将匹配任意一位数字和紧随其
    后的两个允许用在内码里的字母（A、B、D到H、J、L、N、P到U、W到Z）。


.. Note:: 注意

    英国邮政编码不要求必须以大写形式写出，所以在使用上面这个正则表达式进行匹
    配时一般用不着区分字母的大小写。

B.5 美国社会安全号码
===================================================

①中华人民共和国公民身份号码
可能是15位或者18位。前6位是户口所在地编码，其中第一位是1-8；此后是出生年月日，
出生年份的前两位只能是18、19、20，而且是可选的（兼顾15位），月份中第一位只能是
0或者1，日期的第一位只能是0-3；最后一位校验码是数字或者X，可选（兼顾15位）。对
应的正则表达式可以写为： 
``[1-8]\d{5}((18)|(19)|(20))?\d{2}[0-1]\d[0-3]\d{4}[\dx]?``。——编者注

美国的社会安全号码（social security number，简称SSN号码）由3组以连字符隔开的数字构 
成：第1组包含着3位数字，第2组包含着2位数字，第3组包含着4位数字。从1972年起，美国
政府开始根据SSN号码申请人提供的住址来分配第一组里的3位数字。

:文本:

    .. code-block:: text

        John Smith: 123-45-6789

:正则表达式: ``\d{3}-\d{2}-\d{4}``

:结果:

    .. code-block:: text

        John Smith: 123-45-6789

.. Hint:: 分析

    ``\d{3}-\d{2}-\d{4}`` 将依次匹配：任意3位数字、一个连字符、任意2位数字、一个连字
    符、任意4位数字。

.. Note:: 注意

    从理论上讲，SSN 号码可以是任意数字组合，但从现实看，它们必须满足以下几项
    要求。首先，在一个合法的 SSN 号码里不可能出现全零字段；其次，第 1 组数字（到目前
    为止）不得大于 728（因为 SSN 号码迄今为止还没用过那么大的数字，但未来可能会用
    到）。不过，一个能满足上述要求的模式会十分的复杂，因而比较简单的 
    ``\d{3}-\d{2}-\d{4}`` 更常见一些。

B.6 IP地址
===================================================

IP 地址由 4 个字节构成（这4个字节的取值范围都是0~255）。IP地址通常被写成4组以.字符隔
开的整数（每个整数由1~3位数字构成）。

:文本:

    .. code-block:: text

        localhost is 127.0.0.1.

:正则表达式: ``(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}``
        ➥ ``((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))``
:结果:

    .. code-block:: text

        localhost is 127.0.0.1.

.. Hint:: 分析

    这个模式使用了一系列嵌套子表达式。我们先来说说由4个子表达式构成的 
    ``(((\d{1, 2})|(1\d{2})|(2[0-4]\d)|(25[0-5])\.)`` ：
    ``(\d{1, 2})`` 匹配任意一位或两位数字（0~99）；
    ``(1\d{2})`` 匹配以 1 开头的任意三位数字（100~199）；
    ``(2[0-4]\d)`` 匹配整数 200~249；
    ``(25[0-5])`` 匹配整数 250~255。
    这几个子表达式通过 | 操作符结合为一个更大的子表达式
    （其含义是只须匹配这4个子表达式之一即可）。
    随后的 ``\.`` 用来匹配.字符，它与前 4 个子表达式构成的子表达式又构成了
    一个更大的子表达式，而接下来的 {3} 表明需要重复 3 次。

最后，数值范围又重复了一次（这次省略了尾部的\ .）以匹配IP地址里的最后一组数字。 
通过把4组以.分隔的数字的取值范围都限制在0~255之间，这个模式准确无误地做到了只匹配合
法的IP地址，但不匹配非法的IP地址。

.. Note:: 注意

    第7章对这个IP地址的例子做了详细的解释。

B.7 URL地址
===================================================

URL 地址进行匹配是一个有着相当难度的任务——其复杂性取决于你想获得多么精确的匹 
配结果。在最简单的情况下，你的 URL 匹配模式至少应该匹配到以下内容：协议名（ http 或
https）、一个主机名、一个可选的端口号、一个文件路径。

:文本:

    .. code-block:: text

        http://www.forta.com/blog
        https://www.forta.com:80/blog/index.cfm
        http://www.forta.com
        http://ben:password@www.forta.com/
        http://localhost/index.php?ab=1&c=2
        http://localhost:8500/

:正则表达式: ``https?://[-\w.]+(:\d+)?(/([\w/_.]*)?)?``

:结果:

    .. code-block:: text

        http://www.forta.com/blog
        https://www.forta.com:80/blog/index.cfm
        http://www.forta.com
        http://ben:password@www.forta.com/
        http://localhost/index.php?ab=1&c=2
        http://localhost:8500/

.. Hint:: 分析

        https?:// 匹配 http:// 或 https://（? 使得字符 s 是可选的）。
        ``[-\w.]+`` 匹配主机名。
        ``(:\d+)?`` 匹配一个可选的端口号（参见上例中的第 2 和第 6 行）。
        ``(/([\w/_.]*)?)?`` 负责匹配一个文件路径：
        外层的子表达式匹配一个可选的 / 字符，内层的子表达式匹配那个文件路径本身。
        正如大家看到的那样，这个模式不能正确处理查询字符串，也不能正确解读嵌在 URL
        地址里的“username:password（用户名:口令字）”。不过，对绝大多数 URL 地址而言，
        这个模式的使用效果（匹配到主机名、端口号和文件路径）还是令人满意的。


.. Note:: 注意

    URL 地址不要求必须以大写形式写出，所以在使用上面这个正则表达式进行匹配时
    一般用不着区分字母的大小写。

.. Hint:: 提示

    如果你还想匹配使用了 ftp 协议的 URL 地址，把 https?:// 替换为 (http|https|
    ftp) 即可。使用了其他协议的URL地址也可以按照类似的思路来匹配。

B.8 完整的 URL 地址
===================================================

下面是一个更完备（也更慢）的 URL 地址匹配模式，它还可以匹配 URL 查询字符串（嵌在 
URL 地址里的变量信息，这些信息与 URL 地址中的网址部分要用一个?隔开）以及可选的用户
登录信息。

:文本:

    .. code-block:: text

        http://www.forta.com/blog
        https://www.forta.com:80/blog/index.cfm
        http://www.forta.com
        http://ben:password@www.forta.com/
        http://localhost/index.php?ab=1&c=2
        http://localhost:8500/

:正则表达式: ``https?://(\w*:\w*@)?[-\w.]+(:\d+)?(/([\w/_.]*(\?\S+)?)?)?``

:结果:

    .. code-block:: text

        http://www.forta.com/blog
        https://www.forta.com:80/blog/index.cfm
        http://www.forta.com
        http://ben:password@www.forta.com/
        http://localhost/index.php?ab=1&c=2
        http://localhost:8500/

.. Hint:: 分析

    这个模式是在前一个例子的基础上改进而来的。这次紧跟在 https?:// 后面的是
    ``(\w*:\w*@)?``，它将匹配嵌在 URL 字符串里的用户名和口令字（用户名和口令字要用:隔开，它们
    的后面还跟着一个 @ 字符），参见这个例子里的第 4 行。

    另外，这次在路径信息的后面还多了一个子表达式 ``(\?\S+)?``，它负责匹配查询字符串。
    查询字符串是在URL字符串里出现在 ? 后面的文本，这些文本是可选的，
    所以这个子表达式的后面还紧跟着一个?。


.. Note:: 注意

    URL 地址不要求必须以大写形式给出，所以在使用上面这个正则表达式进行匹配
    时一般用不着区分字母的大小写。

.. Hint:: 提示

    能不能总是使用这个更完备的模式来取代前一个呢？从理论上讲，这没有什么不
    妥，但在实际工作中，因为这个模式比较复杂、处理速度也比较慢，所以如果没有特殊的
    必要，还是不使用它比较好。

B.9 电子邮件地址
===================================================

用一个正则表达式来匹配电子邮件地址是一项很常见的任务。一般来说，如果需要匹配的电 
子邮件地址比较简单，相应的正则表达式就不会很复杂。

:文本:

    .. code-block:: text

        My name is Ben Forta, and my
        email address is ben@forta.com.

:正则表达式: ``(\w+\.)*\w+@(\w+\.)+[A-Za-z]+``

:结果:

    .. code-block:: text

        My name is Ben Forta, and my
        email address is ben@forta.com.

.. Hint:: 分析

    ``(\w+\.)*\w+`` 负责匹配电子邮件地址里的用户名部分（@之前的所有文本）：
    ``(\w+\.)*`` 匹配一些由.结束的文本的零次或多次重复出现，``\w+`` 匹配必
    不可少的文本（这个组合将匹配 ben 和 ben.forta，等等）。接下来，@ 匹配 @ 字符本身，
    ``(\w+\.)`` 匹配至少一个以.结束的字符串，[A-Za-z]+ 匹配顶级域名（com、edu、us或uk，等等）。

合法的电子邮件地址必须在排版格式方面同时满足许多项规定。这个模式不能用来匹配每一 
种可能的电子邮件地址。比如说，这个模式会认为 ben..forta@forta.com 是一个合法匹
配（但这显然不是一个合法的电子邮件地址），它不能用来匹配以IP地址做为主机名的电子
邮件地址（但这种电子邮件地址是合法的）。不过，因为绝大多数电子邮件地址都能与这个
模式相匹配，所以你不妨先用它试试，如果效果不佳再考虑对之进行改进。

.. Note:: 注意

    电子邮件地址不要求必须以大写形式写出，所以在使用上面这个正则表达式进行匹
    配时一般用不着区分字母的大小写。

B.10 HTML注
==================================================

HTML页面里的注释必须被放在<!--和-->标签之间（这两个标签必须至少包含两个连字 
符，多于两个没有关系）。在浏览（或调试）Web页面的时候，我们往往需要把所有的注释
都找出来。

:文本:

    .. code-block:: text

        <!-- Start of page -->
        <HTML>
        <!-- Start of head -->
        <HEAD>
        <TITLE>My Title</TITLE> <!-- Page title -->
        </HEAD>
        <!-- Body -->
        <BODY>

:正则表达式: <!-{2,}.*?-{2,}>

:结果:

    .. code-block:: text

        <!-- Start of page -->
        <HTML>
        <!-- Start of head -->
        <HEAD>
        <TITLE>My Title</TITLE> <!-- Page title -->
        </HEAD>
        <!-- Body -->
        <BODY>

.. Hint:: 分析

        <!-{2, }匹配 HTML 注释的开始标签，也就是<!后面紧跟着两个或更多个连字符的情
        况。``.*?`` 匹配 HTML 注释的文字部分（注意，这里用的是一个懒惰型元字符）。
        ``-{2, }>`` 匹配 HTML 注释的结束标签。


.. Note:: 注意

    这个模式匹配两个或更多个连字符，所以还可以用来查找 CFML 注释（这种注释的
    开始 / 结束标签里包含着3个连字符）。不过，这个模式没有对 HTML 注释的开始标签和结
    束标签所包含的连字符的个数是否配对进行检查（那可以用来检查 HTML 注释的格式是否
    有误）。

B.11 JavaScript注
==================================================

JavaScript（其他脚本语言如 ActionScript 和 ECMA Script 的其他变体等）代码里的注释都以//
开头。正如刚才那个 HTML 注释的例子所示，把某给定页面里的所有注释全部查找出来是很
有用的。

:文本:

    .. code-block:: text

        <SCRIPT LANGUAGE="JavaScript">
        // Turn off fields used only by replace
        function hideReplaceFields() {
        document.getElementById('RegExReplace').disabled=true;
        document.getElementById('replaceheader').disabled=true;
        }
        // Turn on fields used only by replace
        function showReplaceFields() {
        document.getElementById('RegExReplace').disabled=false;
        document.getElementById('replaceheader').disabled=false;
        }

:正则表达式: //.*

:结果:

    .. code-block:: text

        <SCRIPT LANGUAGE="JavaScript">
        // Turn off fields used only by replace
        function hideReplaceFields() {
        document.getElementById('RegExReplace').disabled=true;
        document.getElementById('replaceheader').disabled=true;
        }
        // Turn on fields used only by replace
        function showReplaceFields() {
        document.getElementById('RegExReplace').disabled=false;
        document.getElementById('replaceheader').disabled=false;
        }

.. Hint:: 分析

        这是一个很简单的模式：``//.*`` 匹配 // 和紧随其后的注释内容。
        如果代码是： ``var precious="some//trick";`` 怎么处理！？

.. Note:: 注意
    
    与绝大多数正则表达式实现不同，在 ColdFusion 里，总是匹配换行符。因此，如果
    你正在使用的是ColdFusion，你将需要把这个模式修改成使用懒惰型元字符的样子，把.*
    替换为 ``.*?``。

B.12 信用卡号
==================================================

信用卡号码本身是否合法不能用正则表达式来检查，最终的结论要由信用卡的发行机构做 
出。我们这里说的检查是指使用正则表达式来检查信用卡号码的格式是否符合有关规定，其
主要目的是为了——在对信用卡号码做进一步处理之前——把有打字错误的信用卡号码（比
如多输入一位数字或少输入一位数字等情况）排除在外。

.. Note:: 注意

    这里使用的模式都有这样一个前提假设：信用卡号码里的空格和连字符已提前被
    去掉。一般来说，在使用正则表达式对信用卡号码进行匹配处理之前，先把其中的非数字
    字符去掉会给匹配操作带来很多便利；但这只是经验之谈，你应该根据具体情况来掌握。
    所有的信用卡都遵守着同一种基本的编码模式——以特定的数字序列开头，号码的总位数是
    一个固定的值。

我们先来看看MasterCard卡的情况。

:文本:

    .. code-block:: text

        MasterCard: 5212345678901234
        Visa 1: 4123456789012
        Visa 2: 4123456789012345
        Amex: 371234567890123
        Discover: 601112345678901234
        Diners Club: 38812345678901

:正则表达式: ``5[1-5]\d{14}``

:结果:

    .. code-block:: text

        MasterCard: 5212345678901234
        Visa 1: 4123456789012
        Visa 2: 4123456789012345
        Amex: 371234567890123
        Discover: 601112345678901234
        Diners Club: 38812345678901

.. Hint:: 分析

        MasterCard 卡的号码总长度是16位数字；第1位数字永远是5，第2位数字是1到5之一。
        5[1-5] 匹配前两位数字；{14} 匹配随后的14位数字。

Visa卡的情况稍微复杂一些。

:文本:

    .. code-block:: text

        MasterCard: 5212345678901234
        Visa 1: 4123456789012
        Visa 2: 4123456789012345
        Amex: 371234567890123
        Discover: 601112345678901234
        Diners Club: 38812345678901

:正则表达式: ``4\d{12}(\d{3})?``

:结果:

    .. code-block:: text

        MasterCard: 5212345678901234
        Visa 1: 4123456789012
        Visa 2: 4123456789012345
        Amex: 371234567890123
        Discover: 601112345678901234
        Diners Club: 38812345678901

.. Hint:: 分析

        Visa 卡的第1位号码永远是4，总长度是13或16位数字（不包括14或15，所以这里不能使用一
        个数字区间）。4匹配字符4本身，``\d{12}`` 匹配接下来的12位数字，(``\d{3})?`` 匹配可选的最
        后3位数字。

用来匹配美国运通卡号的模式相对要简单得多。

:文本:

    .. code-block:: text

        MasterCard: 5212345678901234
        Visa 1: 4123456789012
        Visa 2: 4123456789012345
        Amex: 371234567890123
        Discover: 601112345678901234
        Diners Club: 38812345678901

:正则表达式: ``3[47]\d{13}``

:结果:

    .. code-block:: text

        MasterCard: 5212345678901234
        Visa 1: 4123456789012
        Visa 2: 4123456789012345
        Amex: 371234567890123
        Discover: 601112345678901234
        Diners Club: 38812345678901

.. Hint:: 分析

        美国运通卡的号码总长度是15位，前两位号码必须是34或37。3[47]匹配前两位数
        字，``\d{13}`` 匹配剩余的13位数字。

用来匹配Discover卡号的模式也很简单。

:文本:

    .. code-block:: text

        MasterCard: 5212345678901234
        Visa 1: 4123456789012
        Visa 2: 4123456789012345
        Amex: 371234567890123
        Discover: 601112345678901234
        Diners Club: 38812345678901

:正则表达式: ``6011\d{14}``

:结果:

    .. code-block:: text

        MasterCard: 5212345678901234
        Visa 1: 4123456789012
        Visa 2: 4123456789012345
        Amex: 371234567890123
        Discover: 601112345678901234
        Diners Club: 38812345678901

.. Hint:: 分析

        Discover卡的号码总长度是16位，前4位号码必须是6011。6011\d {14}解决了问题。

Diners Club卡的情况稍微复杂一些。

:文本:

    .. code-block:: text

        MasterCard: 5212345678901234
        Visa 1: 4123456789012
        Visa 2: 4123456789012345
        Amex: 371234567890123
        Discover: 601112345678901234
        Diners Club: 38812345678901

:正则表达式: ``(30[0-5]|36\d|38\d)\d{11}``

:结果:

    .. code-block:: text

        MasterCard: 5212345678901234
        Visa 1: 4123456789012
        Visa 2: 4123456789012345
        Amex: 371234567890123
        Discover: 601112345678901234
        Diners Club: 38812345678901

.. Hint:: 分析

        Diners Club卡的号码总长度是14位，必须以300到305、36或38开头。如果前三位号码是300到
        305，后面必须再有11位数字；如果前两位号码是36或38，则后面必须再有12位数字。我们这
        里采用了一个比较简单的办法：
        先匹配前3位数字，``(30[0-5]|36\d|38\d)`` 包含3个子表达式，只要其中之一得到匹配即可；
        其中30[0-5]匹配300~305，``36\d`` 匹配以36开头的任意
        3位数，``38\d`` 匹配以38开头的任意3位数。最后，``\d{11}`` 匹配剩余的11位数字。

现在，只要把上述5种信用卡号码的匹配模式组合成一个更大的模式就可以全面解决这个问题了: 

:文本:

    .. code-block:: 

        MasterCard: 5212345678901234
        Visa 1: 4123456789012
        Visa 2: 4123456789012345
        Amex: 371234567890123
        Discover: 601112345678901234
        Diners Club: 38812345678901

:正则表达式: ``(5[1-5]\d{14})|(4\d{12}(\d{3})?)|(3[47]\d{13})|``
    ➥ ``(6011\d{14})|((30[0-5]|36\d|38\d)\d{11})``
:结果:

    .. code-block:: 

        MasterCard: 5212345678901234
        Visa 1: 4123456789012
        Visa 2: 4123456789012345
        Amex: 371234567890123
        Discover: 601112345678901234
        Diners Club: 38812345678901

.. Hint:: 分析

    这个模式用|操作符（正则表达式语言中的逻辑或操作符）把前面得到的5个模式结合到了一
    起。有了它，我们就可以一次完成对5种常见信用卡的号码格式进行检查了。

.. Note:: 注意

    这里使用的模式只能检查信用卡的号码是不是以正确的数字序列开头和是不是有
    着正确的总长度。不过，并非所有以4开头的13位数字都是合法的Visa卡号——信用卡号
    码还必须满足一个名为Mod 10的数学算法（这个算法适用于所有的信用卡类型）。在对
    信用卡进行编程处理的时候，Mod 10算法是一个必不可少的重要环节，但这项检查不属
    于正则表达式的工作——因为正则表达式不涉及数学运算。

B.13 小结
==================================================

在本附录里，你看到了我们在前面的章程里介绍的许多概念和思路在实际工作中的应用例 
子。根据你遇到的具体问题，这些例子里的模式或者可以直接拿过来使用，或者需要稍做改
动。我们把这些模式作为欢迎大家进入正则表达式世界的礼物，希望它们能帮助你拓展思路
并在此基础上构造出更精彩更实用的模式来。

附录C 正则表达式测试器
===================================================

测试和试用正则表达式必须借助于一个应用软件或一种编程语言（很可能还需要编写一些代 
码）。为了帮助你学习和测试正则表达式，我们在本书的配套网站上提供了一个可以独立使
用的Regular Expression Tester（正则表达式测试器）软件。本附录将简要地对这个软件的使用
方法做一个介绍。

C.1 Regular Expression Tester软件
===================================================

正则表达式不是一个应用程序，你不能通过点击某个链接的办法来使用它们。它们需要你编 
写正则表达式代码或是使用一个支持正则表达式的应用软件。
为了帮助你掌握正则表达式的用法，我们编写了一个简单的Web应用程序，它可以让你使用
一个Web浏览器来测试和试用正则表达式。
这个应用程序只有一个页面，该页面包含着一个HTML表单和所有的正则表达式处理功能。
你只要把有关的文件下载到你的计算机里就可以使用这个应用程序了。这个应用程序有许多
种 版 本， 其 中 包 括 一 个 对 应 于 Microsoft ASP 和 ASP.NET 以 及 一 个 对 应 于 Macromedia
ColdFusion的版本（它们都需要访问相应的服务器软件）和一个纯客户端的JavaScript版本。
提示 使用多个版本可以帮助大家测试某个模式的兼容性。

.. Note:: 注意

    我们将根据需要或读者的要求进一步提供针对其他平台的版本。如果你想获得一
    份这个测试器的副本或是希望了解都有哪些版本可供选择，访问我们在本附录的最后一节
    给出的URL地址。

C.1.1 进行查找操作
===================================================

这个应用程序支持查找和替换操作。如果你想进行查找操作，请按以下步骤进行。 

1. ● 把这个应用程序的页面加载到你的浏览器里。
2. ● 单击“Find”按钮。
3. ● 在顶部的字段里输入你的正则表达式。
4. ● 如有必要，选中“Case Sensitive”单选框。
5. ● 在那个较大的文本框里输入（或通过剪贴操作）将被搜索的原始文本。
6. ● 单击“Match Now”按钮。

查找结果将以一个表格的形式显示在这个表单的下部。 

C.1.2 进行替换操作
===================================================

替换操作需要用到两个模式。如果你想进行替换操作，请按以下步骤进行。 

1. ● 把这个应用程序的页面加载到你的浏览器里。
2. ● 单击“Replace”按钮。
3. ● 在顶部的字段里输入搜索正则表达式。
4. ● 在第二个字段里输入替换正则表达式。
5. ● 如有必要，请选中“Case Sensitive”单选框。
6. ● 在那个较大的文本框里输入（或通过剪贴操作）将被搜索的原始文本。
7. ● 单击“Match Now”按钮。

替换结果将显示在这个表单的下部。 

C.2 获得这套应用程序的一份副本
===================================================

要想获得这套应用程序的一份副本，请访问本书的配套网页。 
http：//www.forta.com/books/0672325667/
该页面的内容主要包括以下几项。

1. ● Regular Expression Tester软件的现有版本和下载链接。
2. ● 使用该软件的在线版本来测试各种正则表达式。
3. ● 其他正则表达式资源的访问链接。
4. ● 本书的勘误表（欢迎大家批评指正）。
5. ● 如果你有兴趣把这个正则表达式测试器软件移植到其他平台上去的话，你还可以在那里

找到申请加入相关团队的联系办法。 
最后，欢迎大家进入正则表达式的精彩世界！

附录 D
===================================================

.. code-block::

    基本的元字符 
    元字符 说 明 章
    . 匹配任意单个字符 2
    | 逻辑或操作符 3
    [] 匹配字符集合中的一个字符 3
    [^] 对字符集合求非 3
    - 定义一个区间（例如 [A-Z] ） 3
    \ 对下一个字符转义 2
    数量元字符
    元字符 说 明 章
    * 匹配前一个字符（子表达式）的零次或多次重复 5
    *?
    * 的懒惰型版本 5
    + 匹配前一个字符（子表达式）的一次或多次重复 5
    +?
    + 的懒惰型版本 5
    ? 匹配前一个字符（子表达式）的零次或一次重复 5
    {n} 匹配前一个字符（子表达式）的 n 次重复 5
    {m, n} 匹配前一个字符（子表达式）至少 m 次且至多 n 次重复 5
    {n, } 匹配前一个字符（子表达式） n 次或更多次重复 5
    {n, }?
    {n } 的懒惰型版本 5
    位置元字符
    元字符 说 明 章
    ^ 匹配字符串的开头 6
    \A 匹配字符串的开头 6
    $ 匹配字符串的结束 6
    \Z 匹配字符串的结束 6
    \ 匹配单词的开头 6
    \> 匹配单词的结束 6
    \b 匹配单词边界（开头和结束） 6
    \B
    \b 的反义 6
    特殊字符元字符
    元字符 说 明 章
    [\b] 退格字符 4
    \c 匹配一个控制字符 4
    \d 匹配任意数字字符 4
    \D
    \d 的反义 4
    \f 换页符 4
    \n 换行符 4
    \r 回车符 4
    \s 匹配一个空白字符 4
    \S
    \s 的反义 4
    \t 制表符（Tab字符） 4
    \v 垂直制表符 4
    \w 匹配任意字母数字字符或下划线字符 4
    \W
    \w 的反义 4
    \x 匹配一个十六进制数字 4
    \0 匹配一个八进制数字 4
    回溯引用和前后查找
    元字符 说 明 章
    () 定义一个子表达式 7
    \1 匹配第1个子表达式； \2 代表第2个子表达式，依次类
    推
    8
    ?= 向前查找 9
    ? 向后查找 9
    ?! 负向前查找 9
    ?!= 负向后查找 9
    ?() 条件（ if then ） 10
    ?()| 条件（ if then else ） 10
    大小写转换
    元字符 说 明 章
    \E
    结束 \L 或 \U 转换 8
    \l
    把下一个字符转换为小写 8
    \L
    把后面的字符转换为小写，直到遇见 \E 为止 8
    \u
    把下一个字符转换为大写 8
    \U
    把后面的字符转换为大写，直到遇见 \E 为止 8
    匹配模式
    元字符 说 明 章
    (?m)
    分行匹配模式 6


索  引
===================================================

索引中页码为英文原书页码，与本书中页边标注的页码一致。

.. code-block::

    Symbols
    （asterisk）,zero or more character searches （（星号），零个或多个字符搜索），44-45
    \（backslashes）（\（反斜线）），60
    metacharacters, escaping（元字符、转义），28-29
    special character searches（特殊字符搜索），16-17
    \< metacharacters（元字符），60
    \A metacharacters（元字符），65
    \B metacharacters（元字符），59
    \b word boundaries（单词边界），57-59
    \Z metacharacters（元字符），65
    [ ]（brackets），（[ ]（方括号））
    character set matches（字符集合匹配），19-21，27
    character set range matches（字符集合区间匹配），21-22
    escaping（转义），28-29
    ^（carrot），（^（上箭头））
    ?m metacharacters（?m元字符），65
    “anything but” character set matches（“取非”字符集合匹配），25-26
    character set matches（字符集合匹配），60
    string boundaries（字符串边界），60-63
    {}（curly brackets）（{}（花括号））
    “at least” interval matches（“至少重复多少次”匹配），51-52
    exact interval matches（“精确重复多少次”匹配），49-50
    range interval matches（重复次数的区间），50-51
    $（dollar sign） （$（美元符号））
    ?m metacharacters（?m元字符），65
    string boundaries（字符串边界），60-63
    -（hyphen），character set range matches（-（连字符），字符集合区间匹配），22-24
    ()（parentheses），metacharacters subexpressions, （( )（圆括号），元字符子表达式），67-73
    .（period）（英文句号）
    special character searches（特殊字符搜索），12, 16-18, 27
    unknown character searches（未知字符搜索），12
    +（plus sign），（+（加号））
    character set searches（字符集合搜索），41-43
    one or more character searches（一个或多个字符搜索），41-42
    ?（question mark），zero or more character searches （?（问号）零个或多个字符搜索），
    46-48
    ?=（lookahead operators）（?=（向前查找操作符）），87-89, 92-93
    ?!（negative lookahead operators）（?!（负向前查找操作符）），93
    ?<=（lookbehind operators）（?<=（向后查找操作符）），89-91
    ?=（lookahead operators），combining with （?=（向前查找操作符），组合使用），92-93
    versus ?
    ?
    ?m metacharacters （?m元字符），63-64
    A
    alphanumeric metacharacters（字母数字元字符），34-35
    American Express credit cards (regular expression examples),（美国运通信用卡（正则表达式的
    例子）），132
    any character matches（任意字符匹配），12-16
    “anything but” character set matches（“取非”字符集合匹配），25-26
    ASP usage examples (regular expressions)（ASP用法示例（正则表达式）），109-110
    ASP.NET usage examples (regular expressions) （ASP.NET用法示例（正则表达式）），110
    asterisk (), zero or more character searches（星号（），零个或多个字符搜索），44-45
    “at least” interval matches（“至少重复多少次”匹配），51-52
    B
    backreference conditions, syntax of（回溯引用条件，语法），98-99
    backreferences（回溯引用），74-80
    conditions, syntax of（条件，语法），98-99
    lazy quantifiers（懒惰型限定符），76
    replaces（替换），81-83
    syntax of（语法），79
    backslashes ()（反斜线（\））
    metacharacters, escaping（元字符，转义），28-29
    special character searches（特殊字符搜索），16-17
    brackets（[ ]），（方括号）（[ ]）
    character set matches（字符集合匹配），19-21, 27
    character set range matches（字符集合区间匹配），21-22
    escaping（转义），28-29
    C
    C# usage examples (regular expressions)（C#用法示例（正则表达式）），110
    Canadian postal codes (regular expression examples)（加拿大邮政编码（正则表达式的例
    子）），121
    carrot（^）（上箭头符号（^））
    ?m metacharacters（?m元字符），65
    “anything but” character set matches（“取非”字符集合匹配），25-26
    character set matches（字符集合匹配），60
    string boundaries（字符串边界），60-63
    case conversion matacharacters（大小写转换元字符），84-85
    case sensitivity（区分字母的大小写情况），12
    character set matches（字符集合匹配），21
    digit matacharacters（数字元字符），34
    character set matches（字符集合匹配）
    ^（carrot），^（上箭头符号），60
    case sensitivity（区分字母的大小写情况），21
    multiple character matches（多字符匹配），19-21
    character set range matches（字符集合区间匹配），21-25
    character set searches（字符集合搜索），41-43
    characters, converting case（字符，大小写转换），84-85
    ColdFusion usage examples (regular expressions)（ColdFusion用法示例（正则表达式）），
    107-108
    combining（组合）
    multiple character set range（多个字符集合区间），24
    whitespace metacharacters（空白元字符），31
    conditions （条件）
    backreference conditions, syntax of（回溯引用条件，语法），98-99
    defining（定义），98
    else expressions, syntax of（else表达式，语法），100-101
    embedding（嵌入），97-98
    lookaround conditions（向前查找条件），101-103
    credit card numbers (regular expression examples)（信用卡号码（正则表达式的例子）），
    130-135
    curly brackets（{}）（花括号（{}））
    “at least” interval matches（“至少重复多少次”匹配），51-52
    exact interval matches（“精确重复多少次”匹配），49-50
    range interval matches（重复次数的区间），50-51
    D
    defining（定义）
    conditions（条件），98
    regular expressions（正则表达式），6
    development of regular expressions（正则表达式的发展史），7
    digit metacharacters（数字元字符），33-34
    Diners Club credit cards (regular expression examples)（Diners Club信用卡（正则表达式的例
    子）），133-134
    Discover credit cards (regular expression examples)（Discover信用卡（正则表达式的例子）），
    133
    Dreamweaver usage examples (regular expressions)（Dreamweaver用法示例（正则表达式）），
    108
    E
    else expressions（else表达式）
    email addresses (regular expression examples)（电子邮件地址（正则表达式的例子）），127
    embedding conditions（嵌入条件），97-98
    escaping（转义）
    metacharacters（元字符），28-29, 32
    special characters（特殊字符），17
    \ (backslash)（\（反斜线）），16
    . (period)（英文句号），12,18,27
    exact interval matches（“精确重复多少次”匹配），49-50
    examples of regular expressions（正则表达式的例子），7
    Canadian postal codes（加拿大邮政编码），121
    credit card numbers（信用卡号码），130-135
    email addresses（电子邮件地址）,127
    HTML comments（HTML注释），128-129
    IP addresses（IP地址），124
    JavaScript comments（JavaScript注释），129-130
    North American Phone Numbers（北美电话号码），118-120
    United Kingdom postcodes（英国邮政编码），122
    URLs（URL地址），125-127
    U.S. social security numbers（美国社会安全号码），123
    U.S. ZIP codes（美国邮政编码（ZIP编码）），120-121
    usage examples（用法示例）
    ASP，109-110
    ASP.NET，110
    C#，110
    ColdFusion，107-108
    Dreamweaver，108
    grep，104-105
    HomeSite，108-109
    Java，116-117
    JavaScript, 105-106
    MySQL, 113-114
    .NET, 110-112
    Perl, 114
    PHP, 115
    Visual Studio .NET, 112-113
    F
    find operations (Regular Expression Tester)（查找操作（见附录C）），137
    functionality of regular expressions（正则表达式的用途），7-8
    G
    greedy quantifiers（贪婪型限定符），53-55
    grep usage examples (regular expressions)（grep用法示例（正则表达式））104-105
    grouping subexpressions（子表达式的划分），67-71
    H
    hexadecimal value metacharacters（十六进制值元字符），36
    HomeSite usage examples (regular expressions)（HomeSite用法示例（正则表达式）），108-109
    HTML comments (regular expression examples)（HTML注释（正则表达式的例子）），128-129
    hyphen (-), character set range matches（连字符（-），字符集合区间匹配），22-24
    I
    intervals（重复次数），49
    “at least” interval matches（“至少重复多少次”匹配），51-52
    exact interval matches（“精确重复多少次”匹配），49-50
    range interval matches（重复次数的区间），50-51
    IP addresses (regular expression examples)（IP地址（正则表达式的例子）），124
    J
    Java usage examples (regular expressions)（Java用法示例（正则表达式）），116-117
    JavaScript comments (regular expression examples)（JavaScript注释（正则表达式的例子）），
    129-130
    JavaScript usage examples (regular expressions) （JavaScript 用 法 示 例 （正 则 表 达 式）），
    105-106
    L
    language of regular expression（正则表达式语言），6
    lazy quantifiers（懒惰型限定符），53-55, 76
    literal text matches（纯文本匹配），10-11
    lookahead operators (?=)（向前查找操作符（?=）），87-89, 92-93
    lookarounds（前后查找），86
    conditions（条件），101-103
    lookahead expressions（向前查找表达式），87-89, 92-93
    lookbehind expressions（向后查找表达式），89-91
    combining with lookahead expressions（与向前查找表达式结合使用），92-93
    versus negative lookbehind expressions（对向后查找表达式进行取非），94-95
    lookbehind operators（?<=）（向后查找操作符（?<=）），89-91
    lookahead operators（?=），combining with（与向前查找操作符（?=）结合使用），92-93
    versus negative lookbehind operators（?
    lowercase character conversion（小写字符转换），84-85
    M
    Macromedia ColdFusion usage examples (regular expressions), Macromedia Cold- Fusion（用法示
    例（正则表达式）），107-108
    Macromedia Dreamweaver usage examples (regular expressions), Macromedia Dreamweaver（用法
    示例（正则表达式）），108
    Macromedia HomeSite usage examples (regular expressions), Macromedia HomeSite（用法示例
    （正则表达式）），108-109
    MasterCard credit cards (regular expression examples)（MasterCard信用卡（正则表达式的例
    子）），130-131
    matching（匹配）
    alphanumeric metacharacters（字母数字元字符），34-35
    any characters（任意字符），12-16
    “anything but” character sets（“取非”字符集合），25-26
    “at least” intervals（“至少重复多少次”匹配），51-52
    backreferences,（回溯引用），77-80
    character sets（字符集合）
    ^ (carrot)（^（上箭头符号）），60
    + (plus sign) metacharacters（+（加号）元字符），41-43
    case sensitivity（区分字母的大小写情况），21
    multiple character matches（多字符匹配），19-21
    ranges（区间），21-25
    digit metacharacters（数字元字符），33-34
    exact intervals（“精确重复多少次”匹配），49-50
    hexadecimal value metacharacters（十六进制值元字符），36
    literal text（纯文本），10-11
    multiple characters（多字符）
    “anything but” character set matches（“取非”字符集合匹配），25-26
    character set matches（字符集合匹配），19-21
    character set range matches（字符集合区间匹配），21-25
    nonwhitespace metacharacters（非空白元字符），36
    octal value metacharacters（八进制值元字符），36
    one or more characters（一个或多个字符），41-42
    over matching（过度匹配），53-55
    position matching（位置匹配），56
    \b word boundaries（\b 边界单词），57-59
    ^ (carrot) string boundaries（^（上箭头符号）字符串边界），60-63
    $ (dollar sign) string boundaries, $（（美元符号）字符串边界），60-63
    range intervals（重复次数的区间），50-51
    single characters（单个字符）
    case sensitivity（区分字母的大小写），12
    literal text matches（纯文本匹配），10-11
    special character matches,（特殊字符匹配），16-18
    unknown character matches（未知字符匹配）
    special characters（特殊字符），16-18
    static text（静态文本），10-11
    unknown characters（未知字符），12-16
    whitespace metacharacters（空白元字符），30-31, 36
    zero or more characters（零个或多个字符），44-45
    zero or one character（零个或一个字符），46-48
    metacharacter searches（元字符搜索）
    . (period)（.（英文句号）），12, 18
    \ (backslash)（\（反斜线）），16-17
    metacharacters（元字符）
    (asterisk), zero or more character searches（（星号），零个或多个字符搜索），44-45
    \<，60
    \A，65
    \B，59
    \b word boundaries（\b 单词边界），57-59
    \Z，65
    [ ] (brackets)（[ ]（方括号））
    character set matches（字符集合匹配），19-21, 27
    character set range matches（字符集合区间匹配），21-22
    escaping,（转义），28-29
    ^ (carrot)（ ^（上箭头））
    ?m metacharacters（?m元字符），65
    “anything but” character set matches（“取非”字符集合匹配），25-26
    character set matches（字符集合匹配），60
    string boundaries（字符串边界），60-63
    {} (curly brackets)（{}（花括号））
    “at least” interval matches（“至少重复多少次”匹配），51-52
    exact interval matches（“精确重复多少次”匹配），49-50
    range interval matches（重复次数的区间），50-51
    $ (dollar sign)（$（美元符号））
    ?m metacharacters（?m元字符），65
    string boundaries（字符串边界），60-63
    - (hyphen), character set range matches（-（连字符）， 字符集合区间匹配），22-24
    ( ) (parentheses) , metacharacters subex- pressions（( )（圆括号），元字符子表达式），67-73
    .(period)（英文句号），12, 16-18, 27
    + (plus sign)（+（加号））
    character set searches（字符集合搜索），41-43
    one or more character searches（一个或多个字符搜索），41-42
    ? (question mark), zero or more character searches（（问号），零个或多个字符搜索），46-48
    ?m metacharacterc（?m元字符），63-64
    alphanumeric（字母数字），34-35
    character case conversion（字母大小写转换），84-85
    digit（数字），33-34
    escaping（转义），28-29, 32
    hexadecimal value（十六进制值），36
    nonwhitespace（非空白字符），36
    octal value（八进制值），36
    POSIX character classes（POSIX字符类），37-38
    whitespace（空白字符），30-31, 36
    Microsoft ASP usage examples (regular expressions)（Microsoft ASP用法示例（正则表达式））
    109-110
    Microsoft ASP.NET usage examples (regular expressions)（Microsoft ASP.NET用法示例（正则表
    达式）），110
    Microsoft C# usage examples (regular expressions)（Microsoft C#用法示例（正则表达式）），
    110
    Microsoft .NET usage examples (regular expressions)（Microsoft .NET用法示例（正则表达
    式）），110-112
    Microsoft Visual Studio .NET usage examples (regular expressions)（Microsoft Visual Studio .NET
    用法示例（正则表达式）），112-113
    multiple character matches（多字符匹配）
    “anything but” character set matches（“取非”字符集合匹配），25-26
    character set matches（字符集合匹配），19-21
    character set range matches（字符集合区间匹配），21-25
    multiple character set ranges, combining（多个字符集合区间，组合），24
    multiple lookahead expressions（多个向前查找表达式），89
    multiline mode（“分行匹配”模式），63-64
    MySQL usage examples (regular expressions)（MySQL用法示例（正则表达式）），113-114
    N
    named captures（命名捕获），80
    negative lookahead operators (?!)（负向前查找操作符（?!）），93
    negative lookarounds（负前后查找），93-95
    negative lookbehind operators (?
    nesting subexpressions（嵌套子表达式），71-73
    .NET usage examples (regular expressions)（.NET用法示例（正则表达式）），110-112
    nonwhitespace metacharacters（非空白元字符），36
    North American Phone numbers(regular expression examples)（北美电话号码（正则表达式的例
    子）），118-120
    O
    octal value metacharacters（八进制值元字符），36
    one or more character searches, + (plus sign) metacharacters（一个或多个字符搜索，+（加号）元
    字符），41-42
    over matching（过度匹配），53-55
    P
    parentheses ( ) metacharacter subexpressions（圆括号（）元字符子表达式）
    grouping（分组），67-71
    nesting（嵌套），71-73
    patterns（模式，见正则表达式）
    period (.) 英文句号（.）
    special character searches（特殊字符搜索），12, 16-18, 27
    unknown character searches（未知字符搜索），12
    Perl usage examples (regular expressions)（Perl用法示例（正则表达式）），114
    PHP usage examples (regular expressions)（PHP用法示例（正则表达式）），115
    plus sign (+), one or more character searches（加号（+），一个或多个字符搜索），41-42
    position matching（位置匹配），56
    \b word boundaries（单词边界），57-59
    ^ (corrot) string boundaries（^（上箭头）字符串边界），60-63
    $ (dollar sign) string boundaries（（美元符号）字符串边界），60-63
    positive lookarounds（正前后查找）
    See lookarounds（参见“前后查找”）
    POSIX character classes（POSIX字符类），37-38
    problem scenarios（问题场景），3-4
    Q question mark (?), zero or more character searches（问号（?），零个或多个字符搜索），
    46-48
    R
    range interval matches（重复次数的区间），50-51
    reformatting text（对文本进行重新排版），83
    Regular Expression Tester（正则表达式测试器），136
    downloading（下载），138
    find operations（查找操作），137
    replace operations（替换操作），137-138
    Web site（Web站点），8
    replace operations (Regular Expression Tester)（替换操作（正则表达式测试器）），137-138
    replaces（替换），6, 81-83
    replacing text（替换文本），81
    S
    searches（搜索），5
    single character matches（单个字符匹配）
    case sensitivity（区分字母的大小写情况），12
    literal text matches（纯文本匹配），10-11
    special character matches（特殊字符匹配），16-18
    unknown character matches（未知字符匹配），12-16
    special character matches（特殊字符匹配），16-18
    static text matches（静态文本匹配），10-11
    string boundaries（字符串边界）
    ^ (carrot)（^（上箭头）），60-63
    $ dollar sign)（$（美元符号）），60-63
    multiline mode（“分行匹配”模式），63-64
    subexpressions（子表达式）66
    backreferences（回溯引用），74-80
    lazy quantifiers（懒惰型限定符），76
    replaces（替换），81-83
    syntax of（语法），79
    grouping（划分），67-71
    named captures（命名捕获），80
    nesting（嵌套），71-73
    syntax of（语法），80
    text, reformatting（文本，重新排版），80
    Sun Java usage examples (regular expressions)（Sun Java用法示例（正则表达式）），116-117
    T
    text（文本）
    reformatting（重新排版），83
    replacing（替换），81
    U
    U.S. social security numbers (regular expression examples)（美国社会安全号码（正则表达式的
    例子）），123
    U.S. ZIP codes (regular expression examples)（美国邮政编码（正则表达式的例子）），120-121
    United Kingdom postcodes (regular expres- sion examples)（英国邮政编码（正则表达式的例
    子）），122
    unknown character matches（未知字符匹配），12-16
    uppercase character conversion（大写字母转换），84-85
    URLs (regular expression examples)（URL地址（正则表达式的例子）），125-127
    usage examples (regular expressions)（用法示例（正则表达式））
    ASP 109-110
    ASP.NET 110
    C# 110
    ColdFusion 107-108
    Dreamweaver 108
    grep 104-105
    HomeSite 108-109
    Java 116-117
    JavaScript 105-106
    MySQL 113-114
    .NET 110-112
    Perl 114
    PHP 115
    Visual Studio .NET 112-113
    V
    Visa credit cards (regular expression examples)（Visa信用卡（正则表达式的例子）），132
    Visual Studio .NET usage examples (regular expressions)（Visual Studio .NET用法示例（正则表
    达式）），112-113
    W
    whitespace metacharacters（空白元字符），30-31, 36
    word boundaries（单词边界），57-59
    X - Y - Z
    zero or more character searches（零个或多个字符搜索）
    * (asterisk) metacharacters（*（星号）元字符），44-45
    ? (question mark) metacharacters（?（问号）元字符），46-48

