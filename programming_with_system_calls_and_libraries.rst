#!/usr/bin/env bash
#::

  # http://osr600doc.xinuos.com/en/SDK_sysprog/CONTENTS.html
  while read it ; do
    pandoc -r html "http://osr600doc.xinuos.com/en/SDK_sysprog/$it" -t rst
  done <<EOF
  CONTENTS.html
  EOF
  exit

/Programming with system calls and libraries
============================================


- 1. Application programming
- 2. System calls and libraries
- 3. File and device input/output
- 4. Process management
- 5. Terminal device control
- 6. Internationalization
- 7. Directory and file management
- 8. Signals, job control and pipes
- 9. Threads
- 10. Interprocess communication
- 11. STREAMS polling and multiplexing
- 12. Asynchronous I/O
- 13. Guidelines for writing trusted software


  1 `Application programming <_ApplProg.html>`__
  - `SCO OpenServer tools and languages <_ApplProg.html#Tools_and_Languages>`__
  - `Programming tools and languages in the SCO OpenServer environment <_Programming_Env.html>`__
    - `The C language <_Programming_Env.html#_C_Lang>`__
    - `The C++ language <_Programming_Env.html#_Cpp_lang>`__
    - `The Java language <_Programming_Env.html#_Java_lang>`__
    - `Shell <_Programming_Env.html#SDK_sysprog_pref_Shell>`__
    - `awk <_Programming_Env.html#SDK_sysprog_pref_awk>`__
    - `lex <_Programming_Env.html#SDK_sysprog_pref_lex>`__
    - `yacc <_Programming_Env.html#SDK_sysprog_pref_yacc>`__
    - `m4 <_Programming_Env.html#SDK_sysprog_pref_m4>`__
    - `Perl and PHP <_Programming_Env.html#perlandphp>`__
  - `Character user interfaces <SDK_sysprog_pref_Character_User_Interfaces.html>`__
    - `curses <SDK_sysprog_pref_Character_User_Interfaces.html#SDK_sysprog_pref_curses>`__
    - `FMLI <SDK_sysprog_pref_Character_User_Interfaces.html#SDK_sysprog_pref_FMLI>`__
    - `ETI <SDK_sysprog_pref_Character_User_Interfaces.html#SDK_sysprog_pref_ETI>`__
  - `Graphical user interfaces <SDK_sysprog_pref_GUIs.html>`__
    - `SCO OpenServer X server <SDK_sysprog_pref_GUIs.html#SDK_sysprog_pref_X_Server>`__
    - `Motif graphical user interface <SDK_sysprog_pref_GUIs.html#SDK_sysprog_pref_Motif>`__
  - `System calls and libraries <SDK_sysprog_pref_SysCalls.html>`__
    - `File and device input/output <SDK_sysprog_pref_FD_IO.html>`__
      - `STREAMS input/output <SDK_sysprog_pref_FD_IO.html#SDK_sysprog_pref_STREAMS_IO>`__
      - `File and record locking <SDK_sysprog_pref_FD_IO.html#SDK_sysprog_pref_File_Locking>`__
      - `Where to find more information <SDK_sysprog_pref_FD_IO.html#_Where_1>`__
    - `Memory management <SDK_sysprog_pref_MemMgmt.html>`__
      - `The memory mapping interface <SDK_sysprog_pref_MemMgmt.html#SDK_sysprog_pref_Memory_Mapping>`__
      - `Where to find more information <SDK_sysprog_pref_MemMgmt.html#_Where_2>`__
    - `Process management and scheduling <SDK_sysprog_pref_PM_Sched.html>`__
      - `Where to find more information <SDK_sysprog_pref_PM_Sched.html#_Where_3>`__
    - `Interprocess communication <SDK_sysprog_pref_IPC.html>`__
      - `Where to find more information <SDK_sysprog_pref_IPC.html#_Where_4>`__
    - `Symbolic links <SDK_sysprog_pref_SymLinks.html>`__
      - `Where to find more information <SDK_sysprog_pref_SymLinks.html#_Where_5>`__

  2 `System calls and libraries <SysCallsLibraries.html>`__
  - `Libraries and header files <_Libraries_and_Header_Files.html>`__
    - `Header files <_Header_Files.html>`__
    - `How to use library functions <_How_to_Use_Library_Functions.html>`__
    - `C library (libc) <_C_Library_libc.html>`__
      - `String and Character routines <_C_Library_libc.html#_Subsection_3C_Routines>`__
      - `Standard I/O routines <_C_Library_libc.html#_Subsection_3S_Routines>`__
    - `Math library (libm) <_Math_Library_libm.html>`__
    - `General purpose library (libgen) <_General_Purpose_Library_libgen.html>`__
    - `Standard I/O library <_Standard_IO_Library.html>`__
      - `Three files you always have <_Standard_IO_Library.html#_Three_Files_You_Always_Have>`__
      - `Named files <_Standard_IO_Library.html#_Named_Files>`__
    - `BSD system libraries and header files <SCL_BSDSysLibrariesHeaderFls.html>`__
      - `Accessing BSD libraries and header files <SCL_BSDSysLibrariesHeaderFls.html#_Accessing_BSD_Libraries_and_Hea>`__
      - `BSD library routines <SCL_BSDSysLibrariesHeaderFls.html#_BSD_Library_Routines>`__
      - `BSD header files <SCL_BSDSysLibrariesHeaderFls.html#_BSD_Header_Files>`__
    - `How C programs communicate with the shell <_How_C_Programs_Communicate_with.html>`__
      - `Passing command line arguments <_How_C_Programs_Communicate_with.html#_Passing_Command_Line_Arguments>`__
  - `System calls <_System_Calls.html>`__
    - `File and device I/O <_File_and_Device_IO.html>`__
    - `Terminal device control <_Terminal_Device_Control.html>`__
    - `Directory and file system control <_Directory_and_File_System_Contr.html>`__
    - `Processes <_Processes.html>`__
    - `Signals <_Signals_syscalls.html>`__
    - `IPC system calls <IPC_syscalls.html>`__
    - `Advanced interprocess communication <_Advanced_Interprocess_Communica.html>`__
    - `Memory management <MemMgmtSysCalls.html>`__
    - `Miscellaneous system calls <_Miscellaneous_System_Calls.html>`__
    - `BSD system calls <_BSD_System_Calls.html>`__
    - `System call error handling <SCL_SysCallErrHdl.html>`__

  3 `File and device input/output <FlDevIO.html>`__
  - `Input/output system calls <_InputOutput_System_Calls.html>`__
    - `File descriptors <_File_Descriptors.html>`__
    - `Reading and writing files <_Reading_and_Writing_Files.html>`__
    - `Positioning and reading/writing files <_Positioning_and_ReadingWriting_.html>`__
    - `Opening, creating and closing files <_Opening_Creating_and_Closing_Fi.html>`__
    - `Random access -- lseek <_Random_Access_em_lseek.html>`__
  - `File and record locking <_File_and_Record_Locking.html>`__
    - `Terminology <_Terminology.html>`__
    - `File protection <Lock_File_Protection.html>`__
      - `Opening a file for record locking <_Opening_a_File_for_Record_Locki.html>`__
      - `Setting a file lock <_Setting_a_File_Lock.html>`__
      - `Setting and removing record locks <_Setting_and_Removing_Record_Loc.html>`__
      - `Getting lock information <_Getting_Lock_Information.html>`__
      - `Deadlock handling <_Deadlock_Handling.html>`__
    - `Selecting advisory or mandatory locking <_Selecting_Advisory_or_Mandatory.html>`__
      - `Advisory versus mandatory locking <_Selecting_Advisory_or_Mandatory.html#_Caveat_EmptoremMandatory_Lockin>`__
    - `Record locking and future releases of the UNIX system <_Record_Locking_and_Future_Relea.html>`__
  - `Basic STREAMS operations <FDIO_STMSOps.html>`__
  - `Benefits of STREAMS <_Benefits_of_STREAMS.html>`__
    - `Standardized service interfaces <_Standardized_Service_Interfaces.html>`__
    - `Manipulating modules <_Manipulating_Modules.html>`__
      - `Protocol portability <_Manipulating_Modules.html#_Protocol_Portability>`__
      - `Protocol substitution <_Manipulating_Modules.html#_Protocol_Substitution>`__
      - `Protocol migration <_Manipulating_Modules.html#_Protocol_Migration>`__
      - `Module reusability <_Manipulating_Modules.html#_Module_Reusability>`__
  - `STREAMS mechanism <_STREAMS_Mechanism.html>`__
    - `STREAMS system calls <_STREAMS_System_Calls.html>`__
      - `getmsg and putmsg <_STREAMS_System_Calls.html#_getmsg_and_putmsg>`__
      - `poll <_STREAMS_System_Calls.html#_poll>`__
    - `Opening a STREAMS device file <_Opening_a_STREAMS_Device_File.html>`__
    - `Creating a STREAMS-based pipe <_Creating_a_STREAMS-based_Pipe.html>`__
    - `Adding and removing modules <_Adding_and_Removing_Modules.html>`__
    - `Closing the stream <_Closing_the_Stream.html>`__
    - `Stream construction example <_Stream_Construction_Example.html>`__
      - `Inserting modules <_Stream_Construction_Example.html#_Inserting_Modules>`__
      - `Module and driver control <_Stream_Construction_Example.html#_Module_and_Driver_Control>`__

  4 `Process management <_Process_Management.html>`__
  - `Program execution - exec <_Program_Execution_-_exec.html>`__
  - `Process creation - fork <_Process_Creation_-_fork.html>`__
  - `Control of processes - fork and wait <_Control_of_Processes_-_fork_and.html>`__
  - `Process termination <PM_ProcTerm.html>`__
  - `Timer operations <_Timer_Operations.html>`__
  - `Process scheduling <_Process_Scheduling.html>`__
    - `How the process scheduler works <PM_HowProcSchedWorks.html>`__
      - `Time-sharing class and fixed class <_Time-Sharing_Class_and_Fixed_Cl.html>`__
      - `System class <_System_Class.html>`__
      - `Fixed priority class <_Fixed_Priority_Class.html>`__
    - `Scheduler commands and function calls <PM_SchedCmdsFuncCalls.html>`__
      - `The priocntl command <_The_priocntl_Command.html>`__
      - `The priocntl system call <_The_priocntl_System_Call.html>`__
      - `The priocntllist system call <_The_priocntllist_System_Call.html>`__
      - `The priocntlset system call <_The_priocntlset_System_Call.html>`__
    - `Scheduler interaction with other functions <PM_SchedIntaFuncs.html>`__
      - `fork, exec <PM_SchedIntaFuncs.html#_fork_exec>`__
      - `nice <PM_SchedIntaFuncs.html#_nice>`__
      - `init <PM_SchedIntaFuncs.html#_init>`__
    - `Scheduler performance <_Scheduler_Performance.html>`__
      - `LWP state transition <_LWP_State_Transition.html>`__
      - `Software latencies <_Software_Latencies.html>`__
    - `Managing processors and processes <PM_MngProcorsProces.html>`__
      - `Taking processors online and offline <PM_MngProcorsProces.html#_Taking_Processors_Online_and_Of>`__
      - `Binding processes to processors <PM_MngProcorsProces.html#_Binding_Processes_to_Processors>`__
      - `Placing processors in an exclusive binding mode <PM_MngProcorsProces.html#_Placing_Processors_in_an_Exclus>`__
  - `Memory management facilities <_Memory_Management_Facilities.html>`__
    - `Virtual memory, address spaces and mapping <_Virtual_Memory_Address_Spaces_a.html>`__
    - `Networking, heterogeneity and integrity <_Networking_Heterogeneity_and_In.html>`__
    - `Memory management interfaces <_Memory_Management_Interfaces.html>`__
      - `Creating and using mappings <_Creating_and_Using_Mappings.html>`__
      - `Removing mappings <_Removing_Mappings.html>`__
      - `Cache control <_Cache_Control.html>`__
      - `Other mapping functions <_Other_Mapping_Functions.html>`__
    - `Address space layout <_Address_Space_Layout.html>`__

  5 `Terminal device control <TermDevCntl.html>`__
  - `General terminal interface <_General_Terminal_Interface.html>`__
    - `Baud rates <_Baud_Rates.html>`__
    - `Input modes <TDC_InModes.html>`__
    - `Output modes <TDC_OutModes.html>`__
    - `Control modes <TDC_CntlModes.html>`__
    - `Local modes and line disciplines <TDC_LocalModesLnDisciplines.html>`__
    - `Special control characters <TDC_SpecialCntlChars.html>`__
  - `Opening a terminal device file <_Opening_a_Terminal_Device_File.html>`__
  - `Input processing and reading data <TDC_InProcReadData.html>`__
    - `Canonical mode input processing <TDC_CanonicalModeInProc.html>`__
    - `Non-canonical mode input processing <TDC_Non-CanonicalModeInProc.html>`__
  - `Writing data and output processing <TDC_WritDataOutProc.html>`__
  - `Closing a terminal device file <_Closing_a_Terminal_Device_File.html>`__
  - `Special characters <TDC_SpecialChars.html>`__
  - `The controlling-terminal and process-groups <_The_Controlling-Terminal_and_Pr.html>`__
  - `Session management and job control <_Session_Management_and_Job_Cont.html>`__
  - `Improving terminal I/O performance <_Improving_Terminal_IO_Performan.html>`__
    - `TTY in canonical mode <_TTY_in_Canonical_Mode.html>`__
    - `TTY in raw mode <_TTY_in_Raw_Mode.html>`__
    - `TTY flow control <_TTY_Flow_Control.html>`__
  - `STREAMS-based terminal subsystem <_STREAMS-Based_Terminal_Subsyste.html>`__
    - `Line discipline module <STREAMS_Line_Discipline_Module.html>`__
      - `Default settings <STREAMS_Line_Discipline_Module.html#_Default_Settings>`__
      - `Open and close routines <STREAMS_Line_Discipline_Module.html#_Open_and_Close_Routines>`__
      - `EUC handling in ldterm <STREAMS_Line_Discipline_Module.html#_EUC_Handling_in_ldterm>`__
    - `Support of termiox <_Support_of_termiox.html>`__
    - `Hardware emulation module <_Hardware_Emulation_Module.html>`__
  - `STREAMS-based pseudo-terminal subsystem <_STREAMS-based_Pseudo-Terminal_S.html>`__
    - `Line discipline module <pty_Line_Discipline_Module.html>`__
    - `Pseudo-tty emulation module -- ptem <_Pseudo-tty_Emulation_Module_em_.html>`__
    - `Remote mode <_Remote_Mode.html>`__
    - `Packet mode <_Packet_Mode.html>`__
    - `Pseudo-tty drivers -- ptm and pts <_Pseudo-tty_Drivers_em_ptm_and_p.html>`__
      - `grantpt <_Pseudo-tty_Drivers_em_ptm_and_p.html#_grantpt>`__
      - `unlockpt <_Pseudo-tty_Drivers_em_ptm_and_p.html#_unlockpt>`__
      - `ptsname <_Pseudo-tty_Drivers_em_ptm_and_p.html#_ptsname>`__

  6 `Internationalization <Intization.html>`__
  - `Discussion <_Discussion.html>`__
  - `Organization <_Organization.html>`__
  - `Locales <_Locales.html>`__
  - `Character representation <I_CharRep.html>`__
    - `\``8-bit clean'' <_8-bit_Clean.html>`__
    - `Character classification and conversion <_Character_ClassConv.html>`__
      - `Sign extension <_Character_ClassConv.html#_Sign_Extension>`__
      - `Characters used as indices <_Character_ClassConv.html#_Characters_Used_as_Indices>`__
    - `Wide characters <_Wide_Characters.html>`__
      - `Multibyte and wide-character conversion <_Wide_Characters.html#_Multibyte_and_Wide-character_Co>`__
      - `Input/output <_Wide_Characters.html#_InputOutput>`__
      - `Character classification and conversion <_Wide_Characters.html#multibyte_Char_Class_Conv>`__
      - `curses support <_Wide_Characters.html#_curses_Support>`__
      - `C language features <_Wide_Characters.html#_C_Language_Features>`__
    - `System-defined words <_System-defined_Words.html>`__
  - `Cultural and language conventions <I_CulturalLangConventions.html>`__
    - `Date and time <_Date_and_Time.html>`__
    - `Numeric and monetary information <_Numeric_and_Monetary_Informatio.html>`__
    - `String collation <_String_Collation.html>`__
  - `Message handling <I_MsgHdl.html>`__
    - `mkmsgs and gettxt (OS-specific) <_mkmsgs_and_gettxt-spec.html>`__
    - `exstr and srchtxt (OS-specific) <_exstr_and_srchtxt-spec.html>`__
    - `catopen and catclose (X/Open) <_catopen_and_catclose_XOpen.html>`__
    - `gencat and catgets (X/Open) <_gencat_and_catgets_XOpen.html>`__
    - `%\ n\ $ conversion specifications <_PnP_Conversion_Specifications.html>`__

  7 `Directory and file management <DirFlMgmt.html>`__
  - `Types of files <_Types_of_Files.html>`__
    - `Regular files <_Types_of_Files.html#_Regular_Files>`__
    - `Directory files <_Types_of_Files.html#DFM_DirFls>`__
    - `Special files <_Types_of_Files.html#_Special_Files>`__
  - `Organization of files <_Organization_of_Files.html>`__
  - `File naming <_File_Naming.html>`__
  - `Path names <_Path_Names.html>`__
    - `Full pathnames <_Full_Pathnames.html>`__
    - `Relative pathnames <_Relative_Pathnames.html>`__
  - `Symbolic links <DFM_SymicLinks.html>`__
    - `Properties of symbolic links <_Properties_of_Symbolic_Links.html>`__
    - `Using symbolic links <_Using_Symbolic_Links.html>`__
      - `Creating symbolic links <_Using_Symbolic_Links.html#_Creating_Symbolic_Links>`__
      - `Removing symbolic links <_Using_Symbolic_Links.html#_Removing_Symbolic_Links>`__
      - `Accessing symbolic links <_Using_Symbolic_Links.html#_Accessing_Symbolic_Links>`__
      - `Copying symbolic links <_Using_Symbolic_Links.html#_Copying_Symbolic_Links>`__
      - `Linking symbolic links <_Using_Symbolic_Links.html#_Linking_Symbolic_Links>`__
      - `Moving symbolic links <_Using_Symbolic_Links.html#_Moving_Symbolic_Links>`__
      - `File ownership and permissions <_Using_Symbolic_Links.html#_File_Ownership_and_Permissions>`__
    - `Using symbolic links with NFS <_Using_Symbolic_Links_with_NFS.html>`__
    - `Archiving commands <_Archiving_Commands.html>`__
  - `Summary of UNIX system files & directories <_Summary_of_u1_System_Files__Dir.html>`__
    - `UNIX system directories <_u1_System_Directories.html>`__
  - `File access controls <_File_Access_Controls.html>`__
    - `File protection <_File_Protection.html>`__
      - `File permissions <DFM_FlPermissions.html>`__
      - `Setting default permissions <_Setting_Default_Permissions.html>`__
      - `How to determine existing permissions <_How_to_Determine_Existing_Permi.html>`__
      - `How to change existing permissions <_How_to_Change_Existing_Permissi.html>`__
      - `A note on permissions and directories <_A_Note_on_Permissions_and_Direc.html>`__
      - `An alternative method <_An_Alternative_Method.html>`__
  - `Security considerations <_Security_Considerations.html>`__
    - `What security means to programmers <_What_Security_Means_to_Programm.html>`__
      - `What is security? <_What_Is_Security.html>`__
      - `How basic security works <_How_Basic_Security_Works.html>`__
    - `Privileges <DFM_Privs.html>`__
      - `Privileges associated with a file <_Privileges_Associated_with_a_Fi.html>`__
      - `Manipulating file privileges <_Manipulating_File_Privileges.html>`__
      - `Privileges associated with a process <_Privileges_Associated_with_a_Pr.html>`__
      - `Manipulating process privileges <_Manipulating_Process_Privileges.html>`__

  8 `Signals, job control and pipes <SigsJobCntlPipes.html>`__
  - `Signals <_Signals.html>`__
    - `Signal types <_Signal_Types.html>`__
    - `Signal actions <_Signal_Actions.html>`__
    - `Signal handlers <_Signal_Handlers.html>`__
    - `Protecting critical sections <_Protecting_Critical_Sections.html>`__
    - `Signal stacks <SJCP_SigSs.html>`__
    - `Sending signals <_Sending_Signals.html>`__
  - `Job control and session management <_Job_Control_and_Session_Managem.html>`__
    - `Overview of job control <_Overview_of_Job_Control.html>`__
      - `Job control terminology <_Job_Control_Terminology.html>`__
      - `Job control signals <_Job_Control_Signals.html>`__
      - `The controlling terminal and process-groups <_The_Controlling_Terminal_and_Pr.html>`__
      - `Terminal access control <SJCP_TermAccCntl.html>`__
      - `Modem disconnect <_Modem_Disconnect.html>`__
    - `STREAMS-based job control <_STREAMS-based_Job_Control.html>`__
      - `Allocation and deallocation <_Allocation_and_Deallocation.html>`__
      - `Hung-up streams <_Hung-up_Streams.html>`__
      - `Hangup signals <_Hangup_Signals.html>`__
      - `Accessing the controlling terminal <SJCP_AccCntllTerm.html>`__
  - `Basic interprocess communication - Pipes <_Basic_Interprocess_Communicatio.html>`__
  - `STREAMS-based pipes and FIFOs <_STREAMS-Based_Pipes_and_FIFOs.html>`__
    - `Creating and opening pipes and FIFOs <_Creating_and_Opening_Pipes_and_.html>`__
      - `Accessing pipes and FIFOs <_Accessing_Pipes_and_FIFOs.html>`__
      - `Flushing pipes and FIFOs <_Flushing_Pipes_and_FIFOs.html>`__
      - `Named streams <_Named_Streams.html>`__
      - `Unique connections <_Unique_Connections.html>`__

  9 `Threads <ProgThdsLib.html>`__
  - `What is concurrent programming? <_What_is_Concurrent_Programming.html>`__
  - `What are threads? <_What_are_Threads.html>`__
    - `Threads illustrated <_What_are_Threads.html#_Threads_Illustrated>`__
  - `Basic threads management <PTL_ThdsMgmt.html>`__
    - `Creating a new thread <_Creating_a_New_Thread.html>`__
    - `Terminating a thread <PTL_TerminatThd.html>`__
      - `Termination of the process <PTL_TerminatThd.html#PTL_TermProc>`__
    - `Waiting for thread termination <PTL_WaitThdTerm.html>`__
      - `Detached threads <PTL_WaitThdTerm.html#_Detached_Threads>`__
    - `Thread-specific data <PTL_Thd-SpecificData.html>`__
    - `Threads and signals <PTL_ThdsSigs.html>`__
      - `Asynchronously-generated signals <PTL_ThdsSigs.html#_Asynch-Generated_Signal>`__
      - `Synchronously-generated signals <PTL_ThdsSigs.html#_Synchronously-Generated_Signals>`__
      - `Thread-to-thread signaling <PTL_ThdsSigs.html#_Thread-to-Thread_Signaling>`__
    - `Lightweight processes and threads concurrency level <_Threads_Concurrency_Level.html>`__
      - `Multiplexed threads <_Multiplexed_Threads.html>`__
      - `Managing threads concurrency <PTL_MngThdsConcurrency.html>`__
      - `Bound threads <_Bound_Threads.html>`__
    - `Thread scheduling <_Thread_Scheduling.html>`__
      - `Multiplexed thread scheduling <PTL_MultxedThdSchedul.html>`__
      - `Bound thread scheduling <PTL_BoundThdSchedul.html>`__
      - `Managing thread scheduling <PTL_MngThdSchedul.html>`__
  - `Synchronizing threads <PTL_SynchronizThds.html>`__
    - `Locks <_Locks.html>`__
      - `Mutual exclusion locks <_Mutual_Exclusion_Locks.html>`__
      - `Spin locks <_Spin_Locks.html>`__
      - `Recursive mutual exclusion <_Recursive_Mutual_Exclusion.html>`__
      - `Reader-writer locks <_Reader-Writer_Locks.html>`__
    - `Semaphores <Threads_Semaphores.html>`__
    - `Barriers <_Barriers.html>`__
    - `Condition variables <_Condition_Variables.html>`__
    - `Awakening threads for synchronization mechanisms <_Awakening_Threads_for_Synchroni.html>`__
    - `Further considerations for synchronization mechanisms <PTL_SyncMechs.html>`__
    - `Initialization of synchronization mechanisms <PTL_InitSyncMechs.html>`__
      - `Alternative initialization <PTL_InitSyncMechs.html#_Alternative_Initialization>`__
    - `Invalidation of synchronization mechanisms <_Invalidation_of_Synchronization.html>`__
  - `Compilation environment <_Compilation_Environment.html>`__
    - `Error returns <_Error_Returns.html>`__
    - `Thread-safe libraries <_Thread-Safe_Libraries.html>`__
    - `System call wrappers <_System_Call_Wrappers.html>`__
    - `Timers <_Timers.html>`__
  - `Debugging multithreaded programs <_Debugging_Multithreaded_Program.html>`__
    - `Tracing multithreaded programs <PTL_TracMulthdProgs.html>`__
      - `Trace data files <PTL_TracMulthdProgs.html#_Trace_Data_Files>`__
      - `Format of the trace data files <PTL_TracMulthdProgs.html#_Format_of_the_Trace_Data_Files>`__
      - `Merging trace files <PTL_TracMulthdProgs.html#_Merging_Trace_Files>`__
      - `Using trace file data <PTL_TracMulthdProgs.html#_Using_Trace_File_Data>`__
  - `Examples <PTL_Exs.html>`__
    - `hello, world <_hello_world.html>`__
    - `Basic threads management example <PTL_ThdsMgmt_example.html>`__
    - `Dining philosophers <_Dining_Philosophers.html>`__
    - `Producer/consumer <_ProducerConsumer.html>`__

  10 `Interprocess communication <IPC.html>`__
  - `Messages <IC_Msgs.html>`__
    - `Using messages <_Using_Messages.html>`__
    - `Getting message queues <_Getting_Message_Queues.html>`__
      - `Using msgget <_Getting_Message_Queues.html#IC_msgget>`__
      - `Example program <_Getting_Message_Queues.html#_Example_Program1>`__
    - `Controlling message queues <IC_CntllMsgQueues.html>`__
      - `Using msgctl <IC_CntllMsgQueues.html#_Using_msgctl>`__
      - `Example program <IC_CntllMsgQueues.html#_Example_Program2>`__
    - `Operations for messages <IC_OpsMsgs.html>`__
      - `Using message operations: msgsnd and msgrcv <IC_OpsMsgs.html#_Using_Message_Operations_msgsnd>`__
      - `Example program <_Example_Program3.html>`__
  - `Semaphores <_Semaphores.html>`__
    - `Using semaphores <_Using_Semaphores.html>`__
    - `Getting semaphores <_Getting_Semaphores.html>`__
      - `Using semget <_Getting_Semaphores.html#IC_semget>`__
      - `Example program <_Example_Program4.html>`__
    - `Controlling semaphores <IC_CntllSems.html>`__
      - `Using semctl <IC_CntllSems.html#_Using_semctl>`__
      - `Example program <_Example_Program5.html>`__
    - `Operations on semaphores <IC_OpsSems.html>`__
      - `Using semop <IC_OpsSems.html#_Using_semop>`__
      - `Example program <_Example_Program6.html>`__
  - `Shared memory <_Shared_Memory.html>`__
    - `Using shared memory <_Using_Shared_Memory.html>`__
    - `Getting shared memory segments <_Getting_Shared_Memory_Segments.html>`__
      - `Using shmget <_Getting_Shared_Memory_Segments.html#IC_shmget>`__
      - `Example program <_Example_Program7.html>`__
    - `Controlling shared memory <IC_CntllShMem.html>`__
      - `Using shmctl <IC_CntllShMem.html#_Using_shmctl>`__
      - `Example program <_Example_Program8.html>`__
    - `Operations for shared memory <IC_OpsShMem.html>`__
      - `Using shared memory operations: shmat and shmdt <IC_OpsShMem.html#_Using_Shared_Memory_Operations_>`__
      - `Example program <_Example_Program9.html>`__
  - `IPC programming example for liber <_IPC_Programming_Example_for_lib.html>`__

  11 `STREAMS polling and multiplexing <_STREAMS_Polling_and_Multiplexin.html>`__
  - `STREAMS input/output polling <_STREAMS_InputOutput_Polling.html>`__
    - `Synchronous input/output <_Synchronous_InputOutput.html>`__
    - `Asynchronous input/output <_Asynchronous_InputOutput.html>`__
    - `Signals <STREAMS_Signals.html>`__
    - `Extended signals <_Extended_Signals.html>`__
  - `STREAMS input/output multiplexing <_STREAMS_InputOutput_Multiplexin.html>`__
    - `STREAMS multiplexors <_STREAMS_Multiplexors.html>`__
    - `Building a multiplexor <_Building_a_Multiplexor.html>`__
    - `Dismantling a multiplexor <_Dismantling_a_Multiplexor.html>`__
    - `Routing data through a multiplexor <_Routing_Data_through_a_Multiple.html>`__
  - `Persistent links <_Persistent_Links.html>`__

  12 `Asynchronous I/O <_Asynchronous_IO.html>`__
  - `Notation conventions <_Asynchronous_IO.html#_Notation_Conventions>`__
  - `Advantages of asynchronous I/O <_Advantages_of_Asynchronous_IO.html>`__
    - `Performance <_Advantages_of_Asynchronous_IO.html#_Performance>`__
  - `Using asynchronous I/O <_Using_Asynchronous_IO.html>`__
    - `Asynchronous I/O control block <_Asynchronous_IO_Control_Block.html>`__
    - `Threads-based Interface <_Threads-based_Interface.html>`__
      - `Threads-based interface operations <_Threads-based_Interface.html#_Threads-based_Interface_Operati>`__
      - `Single threaded and multithreaded applications <_Threads-based_Interface.html#_Single_Threaded_and_Multithread>`__
    - `Kernel implementation <_Kernel_Implementation.html>`__
      - `Accessing raw disk slices <_Kernel_Implementation.html#_Accessing_Raw_Disk_Slices>`__
      - `Using the asynchronous I/O memory lock <_Kernel_Implementation.html#_Using_the_Asynchronous_IO_Memor>`__
    - `Error handling <_Error_Handling.html>`__
      - `Error behavior <_Error_Handling.html#_Error_Behavior>`__
  - `Using the interface functions <_Using_the_Interface_Functions.html>`__
    - `aio_read and aio_write <_Using_the_Interface_Functions.html#_aio_read_and_aio_write>`__
    - `aio_suspend <_Using_the_Interface_Functions.html#_aio_suspend>`__
    - `aio_cancel <_Using_the_Interface_Functions.html#_aio_cancel>`__
  - `Using other system calls with asynchronous I/O <_Using_Other_System_Calls_with_A.html>`__
    - `fork and forkall <_Using_Other_System_Calls_with_A.html#_fork_and_forkall>`__
    - `exec and exit <_Using_Other_System_Calls_with_A.html#_exec_and_exit>`__
    - `close <_Using_Other_System_Calls_with_A.html#_close>`__
  - `How to use asynchronous I/O with your application <AIO_HowUseAsynchronousIOApp.html>`__

  13 `Guidelines for writing trusted software <_Guidelines_for_Writing_Trusted_.html>`__
  - `How to use this topic <_How_to_Use_This_Chapter.html>`__
  - `Scope of trust <_Scope_of_Trust.html>`__
  - `How trust is achieved <_How_Trust_Is_Achieved.html>`__
  - `Trust and security <_Trust_and_Security.html>`__
    - `Privilege <GWTS_Priv.html>`__
    - `Trusted facility management <GWTS_TrustedFctyMgmt.html>`__
    - `Discretionary Access Control <_DAC.html>`__
    - `Discretionary access isolation <_DAC.html#_Discretionary_Access_Isolation>`__
  - `Writing trusted commands <GWTS_WritTrustedCmds.html>`__
    - `User documentation <User_Doc1.html>`__
    - `Parameter and process attribute checking <_Parameter_Attribute_Checking.html>`__
    - `Privilege and special access <_Priv_Special_Access.html>`__
      - `Set-id commands <_Priv_Special_Access.html#_Set-id_Commands>`__
    - `Privilege and special access in shared private routines <_Priv_Access_Shared.html>`__
    - `Error checking <Trusted_Error_Checking1.html>`__
    - `Signal handling <Trusted_Signal_Handling1.html>`__
    - `Handling sensitive data <_Handling_Sensitive_Data1.html>`__
    - `Executing other commands <GWTS_ExecutCmds.html>`__
    - `Using library routines <Trusted_Using_Library_Routines.html>`__
  - `Trusting shell scripts <_Trusting_Shell_Scripts.html>`__
    - `User documentation <_Trusting_Shell_Scripts.html#Trusted_User_Documentation2>`__
    - `Privilege and special access <_Trusting_Shell_Scripts.html#_Privilege_and_Special_Access1>`__
    - `Error checking <_Trusting_Shell_Scripts.html#Trusted_Error_Checking2>`__
  - `Trusting public library routines <_Trusting_Public_Library_Routine.html>`__
    - `Documentation <_Trusting_Public_Library_Routine.html#Trusted_Library_Documentation>`__
    - `Privilege and special access <_Trusting_Public_Library_Routine.html#_Privilege_and_Special_Access2>`__
    - `Reporting errors <_Trusting_Public_Library_Routine.html#_Reporting_Errors>`__
    - `Handling sensitive data <_Trusting_Public_Library_Routine.html#_Handling_Sensitive_Data>`__
    - `Executing commands <_Trusting_Public_Library_Routine.html#_Executing_Commands>`__
  - `Installing trusted commands and data <_Installing_Trusted_Commands_and.html>`__
    - `Assigning access controls <_Assigning_Access_Controls.html>`__
    - `Assigning privileges and special permissions <_Assigning_Privileges_and_Specia.html>`__
  - `Summary <_Summary.html>`__

--------------

/1. Application programming
============================

This topic introduces application programming in an SCO OpenServer
environment. It briefly describes what application programming is and
then moves on to a discussion on SCO OpenServer tools and where you can
read about them, and to languages supported in the SCO OpenServer
environment and where you can read about them.

Programmers working on application programs develop software for the
benefit of other, nonprogramming users. Most large commercial computer
applications involve a team of applications development programmers.
They may be employees of the end-user organization or they may work for
a software development firm. Some of the people working in this
environment may be more in the project management area than working
programmers.

Application programming has some of the following characteristics: 

-  Applications are often large and are developed by a team of people
   who write requirements, designs, tests, and end-user documents. This
   implies use of a project management methodology, including version
   control (described in `Software development
   tools <../SDK_tools/CONTENTS.html>`__), change requests, tracking,
   and so on.

-  Applications must be developed more robustly.

   -  They must be easy to use, implying character or graphical user
      interfaces.
   -  They must check all incoming data for validity (for example, using
      the Data Validation Tools described in `Software development
      tools <../SDK_tools/CONTENTS.html>`__).
   -  They should be able to handle large amounts of data.

-  Applications must be easy to install and administer

   (see `\``Packaging your software
   applications'' <../SDK_tools/CTOC-PackagSWApps.html>`__ and
   `\``Writing a SCOadmin
   manager'' <../SDK_scoadmin/CTOC-sdgN.writeman.html>`__).

SCO OpenServer tools and languages
----------------------------------

The term \``SCO OpenServer tools'' means an existing piece of software
used as a component in a new task. In a broader context, the term is
used often to refer to elements of SCO OpenServer that might also be
called features, utilities, programs, filters, commands, languages,
functions, and so on. It gets confusing because any of the things that
might be called by one or more of these names can be, and often are,
used simply as components of the solution to a programming problem. The
aim of this section is to give you some sense of the situations in which
you use these tools, and how the tools fit together. It refers you to
other parts of this topic or to other documents for more details.

--------------

/Programming tools and languages in the SCO OpenServer environment
===================================================================

In this section we describe a variety of programming tools supported in
the SCO OpenServer environment. By \``programming tools'' we mean those
offered for use on a computer running a current release of SCO
OpenServer. Since these are separately purchasable items, not all of
them will necessarily be installed on your machine. On the other hand,
you may have programming tools and languages available on your machine
that came from another source and are not mentioned in this discussion.

The C language
--------------

C is intimately associated with the UNIX system since it was originally
developed for use in recoding the UNIX system kernel. If you need to use
a lot of SCO OpenServer function calls for low-level I/O, memory or
device management, or interprocess communication, C is a logical first
choice. Most programs, however, do not require such direct interfaces
with the operating system, so the decision to choose C might better be
based on one or more of the following characteristics: 

-  a variety of data types: characters, integers of various sizes, and
   floating point numbers
-  low-level constructs (most of the UNIX system kernel is written in C)
-  derived data types such as arrays, functions, pointers, structures,
   and unions
-  multidimensional arrays
-  scaled pointers and the ability to do pointer arithmetic
-  bitwise operators
-  a variety of flow-of-control statements: **if**, **if**-**else**,
   **switch**, **while**, **do**-**while**, and **for**
-  a high degree of portability

Refer to `Programming in standard C and 
C++ <../SDK_cprog/CONTENTS.html>`__ for complete details on C.

It takes fairly concentrated use of the C language over a period of
several months to reach your full potential as a C programmer. If you
are a casual programmer, you might make it easier for yourself if you
choose a scripting-based alternative. Most of the discussion of system
programming in this chapter are expressed in terms of C, although all of
these interfaces may be used from C++ as well.

.. _the-c-language-1: 

The C++ language
----------------

C++ is a general purpose programming language with a bias towards
systems programming that: 

-  is intended to be a better C
-  supports data abstraction
-  supports object-oriented programming
-  supports generic programming

The Java language
-----------------

Java is a general purpose programming language with a bias towards
network programming that: 

-  is intended to be a better C++
-  supports an architecture-neutral runtime model
-  supports secure programming
-  supports dynamic, distributed programming

Shell
-----

You can use the shell to create programs (new commands). Such programs
are also called shell procedures. Refer to `Software development
tools <../SDK_tools/CONTENTS.html>`__ for information on how to create
and execute shell programs using commands, variables, positional
parameters, return codes, and basic programming control structures.

awk
---

The **awk** program (its name is an acronym constructed from the
initials of its developers) scans an input file for lines that match
pattern(s) described in a specification file. When **awk** finds a line
that matches a pattern, it performs actions also described in the
specification. It is not uncommon that an **awk** program can be written
in a couple of lines to do functions that would take a couple of pages
to describe in a programming language like FORTRAN or C. For example,
consider a case where you have a set of records that consist of a key
field and a second field that represents a quantity, and the task is to
output the sum of the quantities for each key. The pseudocode for such a
program might look like this: 

::

      SORT RECORDS
      Read the first record into a hold area;
      Read additional records until EOF;
      {
      If the key matches the key of the record in the hold area,
        add the quantity to the quantity field of the held record;
      If the key does not match the key of the held record,
        write the held record,
        move the new record to the hold area;
      }
      At EOF, write out the last record from the hold area.

An **awk** program to accomplish this task would look like this: 

::

          { qty[$1] += $2 }
      END  { for (key in qty) print key, qty[key] }

This illustrates only one characteristic of **awk**; its ability to work
with associative arrays. With **awk**, the input file does not have to
be sorted, which is a requirement of the pseudoprogram.

For detailed information on **awk**, see `\``Programming with
awk'' <../SDK_tools/Progawk.html>`__ and
`awk\ (C) <../man/html.C/awk.C.html>`__.

lex
---

**lex** is a lexical analyzer that can be added to C or FORTRAN
programs. A lexical analyzer is interested in the vocabulary of a
language rather than its grammar, which is a system of rules defining
the structure of a language. **lex** can produce C language subroutines
that recognize regular expressions specified by the user, take some
action when a regular expression is recognized, and pass the output
stream on to the next program.

For detailed information on **lex**, see `\``Lexical analysis with
lex'' <../SDK_tools/LexicalAnallex.html>`__ and
`lex\ (CP) <../man/html.CP/lex.CP.html>`__.

yacc
----

**yacc** (Yet Another Compiler Compiler) is a tool for describing an
input language to a computer program. **yacc** produces a C language
subroutine that parses an input stream according to rules laid down in a
specification file. The **yacc** specification file establishes a set of
grammatical rules together with actions to be taken when tokens in the
input match the rules. **lex** may be used with **yacc** to control the
input process and pass tokens to the parser that applies the grammatical
rules.

For detailed information on **yacc**, see `\``Parsing with
yacc'' <../SDK_tools/Parsyacc.html>`__ and
`yacc\ (CP) <../man/html.CP/yacc.CP.html>`__.

m4
--

**m4** is a macro processor that can be used as a preprocessor for
assembly language and C programs. For details, see `\``m4 macro
processor'' <../SDK_cprog/m4MacroProcor.html>`__ and
`m4\ (C) <../man/html.C/m4.C.html>`__.

Perl and PHP
------------

These are two popular scripting languages for which pre-built open
source implementations are available. Perl is oriented towards system
utility tasks, while PHP is oriented towards web-based applications.

--------------

/Character user interfaces
==========================

The character user interfaces include curses, FMLI, and ETI.

curses
------

Actually a library of C functions, **curses** is included in this list
because the set of functions comprise a sublanguage for dealing with
terminal screens. If you are writing programs that include interactive
user screens, you will want to become familiar with this group of
functions.

SCO OpenServer supports both UNIX\ :sup:`®` System V Release 4 (SVR4)
**curses** and POSIX **curses**.

For detailed information on SVR4 **curses**, see `Character user
interface programming <CONTENTS.html>`__. For details on POSIX curses,
see `Intro\ (S) <../man/html.S/Intro.S.html>`__.

FMLI
----

The Form and Menu Language Interpreter (FMLI) is a high-level
programming tool with two main parts: 

-  The Form and Menu Language, a programming language for writing
   scripts that define how an application will be presented to users.
   The syntax of the Form and Menu Language is very similar to that of
   the system shell programming language, including variable setting and
   evaluation, built-in commands and functions, use of and escape from
   special characters, redirection of input and output, conditional
   statements, interrupt signal handling, and the ability to set various
   terminal attributes. The Form and Menu Language also includes sets of
   \``descriptors,'' which are used to define or customize attributes of
   frames and other objects in your application.
-  The Form and Menu Language Interpreter, **fmli**, which is a command
   interpreter that sets up and controls the video display screen on a
   terminal, using instructions from your scripts to supplement FMLI's
   predefined screen control mechanisms. FMLI scripts can also invoke
   SCO OpenServer commands and C executables, either in the background
   or in full screen mode. The Form and Menu Language Interpreter
   operates similarly to the SCO OpenServer command interpreter **sh**.
   At run time it parses the scripts you have written, thus giving you
   the advantages of quick prototyping and easy maintenance.

FMLI provides a framework for developers to write applications and
application interfaces that use menus and forms. It controls many
aspects of screen management for you. This means that you do not have to
be concerned with the low-level details of creating or placing frames,
providing users with a means of navigating between or within frames, or
processing the use of forms and menus. Nor do you need to worry about on
which kind of terminal your application will be run. FMLI takes care of
all that for you.

For details see `Character user interface programming <CONTENTS.html>`__.

ETI
---

The Extended Terminal Interface (ETI) is a set of C library routines
that promote the development of application programs displaying and
manipulating windows, panels, menus, and forms and that run under SCO
OpenServer. ETI consists of

-  the low-level **curses** library
-  the **panel** library
-  the **menu** library
-  the **form** library
-  the TAM Transition library

The routines are C functions and macros; many of them resemble routines
in the standard C library. For example, there is a routine **printw**
that behaves much like **printf** and another routine **getch** that
behaves like **getc**. The automatic teller program at your bank might
use **printw** to print its menus and **getch** to accept your requests
for withdrawals (or, better yet, deposits). A visual screen editor like
the SCO OpenServer screen editor **vi** might also use these and other
ETI routines.

| A major feature of ETI is cursor optimization. Cursor optimization
  minimizes the amount a cursor has to move around a screen to update
  it. For example, if you designed a screen editor program with ETI
  routines and edited the sentence
| **ETI is a great package for creating forms and menus.**

| to read
| **ETI is the best package for creating forms and menus.**

the program would change only \`\`\ **the best**'' in place of \`\`\ **a
great**''. The other characters would be preserved. Because the amount
of data transmitted--the output--is minimized, cursor optimization is
also referred to as output optimization.

Cursor optimization takes care of updating the screen in a manner
appropriate for the terminal on which an ETI program is run. This means
that ETI can do whatever is required to update many different terminal
types. It searches the *terminfo* database to find the correct
description for a terminal.

How does cursor optimization help you and those who use your programs?
First, it saves you time in describing in a program how you want to
update screens. Second, it saves a user's time when the screen is
updated. Third, it reduces the load on your system's communication lines
when the updating takes place. Fourth, you do not have to worry about
the myriad of terminals on which your program might be run.

Here is a simple ETI program. It uses some of the basic ETI routines to
move a cursor to the middle of a terminal screen and print the character
string ``BullsEye``. For now, just look at their names and you will get
an idea of what each of them does: 

::

      #include <curses.h>
      
      main()
      {
         initscr();
      
         move( LINES/2 - 1, COLS/2 - 4 );
         addstr("Bulls");
         refresh();
         addstr("Eye");
         refresh();
         endwin();
      }

**A simple ETI program**

For complete information on ETI, see `Character user interface
programming <CONTENTS.html>`__.

--------------

/Graphical user interfaces
==========================

The graphical user interfaces include SCO OpenServer X server and the
Motif graphical user interface.

SCO OpenServer X server
-----------------------

The graphical user interface is based on release X11R6 of the X Window
System, a network- and operating system-independent windowing system. X
displays, containing the X \``server,'' run on computers with either
monochrome or color bitmap display hardware. The server distributes user
input to and accepts output requests from various application programs
(referred to as \``clients''), which may be running locally or across
the network. The X server \``serves'' the needs of the applications
(clients) for presenting graphical output to the user and getting user
input from a keyboard and mouse.

At the lowest level, X clients can use Xlib, a C library, to interface
with the windowing system by means of a stream connection.

At the next level is the C library for the X Intrinsics, which offer a
base for creating user interface \``widgets.'' Widgets are a set of code
and data that provide the look and feel of a user interface. The
intrinsics are built on top of Xlib, and they monitor events related to
user interactions, and dispatch the correct widget code to handle the
display. Widgets can call application-registered routines (called
\``callbacks'') to handle the specific application semantics of an
interaction. The X Intrinsics also monitor application-registered,
non-graphical events and dispatch application routines to handle them.

Clients usually use a higher level library of the X Intrinsics and a set
of widgets in addition to Xlib. This higher level interface is the Motif
graphical user interface.

Motif graphical user interface
------------------------------

The Motif Graphical User Interface is an application programming
interface that provides a user-friendly graphical environment for the
UNIX system. It allows traditional UNIX system commands to be replaced
with graphics tools that include windows, menus, icons, and other
symbols. Using a hand-held pointing device (a \``mouse''), you
manipulate windows by moving them, changing their size and running them
in the background. You can have multiple applications running at the
same time by creating more than one window on your screen.

--------------


/System calls and libraries
===========================

This topic describes the system services supplied by system calls and
libraries for the C programming language. It introduces such subjects as
the process scheduler, virtual memory, interprocess communication, file
and record locking, and symbolic links. The system calls and libraries
that programs use to access these system services are described in
detail later in this topic.

--------------


/File and device input/output
=============================

SCO OpenServer applications can do all I/O by reading or writing files,
because all I/O devices, even a user's terminal, are files in the file
system. Each peripheral device has an entry in the file system
hierarchy, so that device names have the same structure as filenames,
and the same protection mechanisms apply to devices as to files. Using
the same I/O calls on a terminal as on any file makes it easy to
redirect the input and output of commands from the terminal to another
file. Besides the traditionally available devices, names exist for disk
devices regarded as physical units outside the file system, and for
absolutely addressed memory.

STREAMS input/output
--------------------

STREAMS is a general, flexible facility and a set of tools for
development of SCO OpenServer communication services. It supports the
implementation of services ranging from complete networking protocol
suites to individual device drivers. STREAMS defines standard interfaces
for character input/output within the kernel, and between the kernel and
the rest of SCO OpenServer. The associated mechanism is simple and
open-ended. It consists of a set of system calls, kernel resources, and
kernel routines.

The standard interface and mechanism enable modular, portable
development and easy integration of high-performance network services
and their components. STREAMS does not impose any specific network
architecture. The STREAMS user interface is upwardly compatible with the
character I/O user level functions such as **open**, **close**,
**read**, **write**, and **ioctl**. Benefits of STREAMS are discussed in
more detail later in this section.

A \``Stream'' is a full-duplex processing and data transfer path between
a STREAMS driver in kernel space and a process in user space.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/sstreams.gif

**Simple Streams**

In the kernel, a Stream is constructed by linking a Stream head, a
driver, and zero or more modules between the Stream head and driver. The
\``Stream head'' is the end of the Stream nearest to the user process.
All system calls made by a user level process on a Stream are processed
by the Stream head.

Pipes are also STREAMS-based. A STREAMS-based pipe is a full-duplex
(bidirectional) data transfer path in the kernel. It implements a
connection between the kernel and one or more user processes and also
shares properties of STREAMS-based devices.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/strpipe.gif

**STREAMS-based pipe**

A STREAMS driver may be a device driver that provides the services of an
external I/O device, or a software driver, commonly referred to as a
pseudo-device driver. The driver typically handles data transfer between
the kernel and the device and does little or no processing of data other
than conversion between data structures used by the STREAMS mechanism
and data structures that the device understands.

A STREAMS module represents processing functions to be performed on data
flowing on the Stream. The module is a defined set of kernel-level
routines and data structures used to process data, status, and control
information. Data processing may involve changing the way the data is
represented, adding/deleting header and trailer information to data,
and/or packetizing/depacketizing data. Status and control information
includes signals and input/output control information.

Each module is self-contained and functionally isolated from any other
component in the Stream except its two neighboring components. The
module communicates with its neighbors by passing messages. The module
is not a required component in STREAMS, whereas the driver is, except in
a STREAMS-based pipe where only the Stream head is required.

One or more modules may be inserted into a Stream between the Stream
head and driver to perform intermediate processing of messages as they
pass between the Stream head and driver. STREAMS modules are dynamically
interconnected in a Stream by a user process. No kernel programming,
assembly, or link editing is required to create the interconnection.

STREAMS uses queue structures to keep information about given instances
of a pushed module or opened STREAMS device. A queue is a data structure
that contains status information, a pointer to routines for processing
messages, and pointers for administering the Stream. Queues are always
allocated in pairs; one queue for the read-side and the other for the
write-side. There is one queue pair for each driver and module, and the
Stream head. The pair of queues is allocated whenever the Stream is
opened or the module is pushed (added) onto the Stream.

Data is passed between a driver and the Stream head and between modules
in the form of messages. A message is a set of data structures used to
pass data, status, and control information between user processes,
modules, and drivers. Messages that are passed from the Stream head
toward the driver or from the process to the device, are said to travel
downstream (also called write-side). Similarly, messages passed in the
other direction, from the device to the process or from the driver to
the Stream head, travel upstream (also called read-side).

A STREAMS message is made up of one or more message blocks. Each block
consists of a header, a data block, and a data buffer. The Stream head
transfers data between the data space of a user process and STREAMS
kernel data space. Data to be sent to a driver from a user process is
packaged into STREAMS messages and passed downstream. When a message
containing data arrives at the Stream head from downstream, the message
is processed by the Stream head, which copies the data into user
buffers.

Within a Stream, messages are distinguished by a type indicator. Certain
message types sent upstream may cause the Stream head to perform
specific actions, such as sending a signal to a user process. Other
message types are intended to carry information within a Stream and are
not directly seen by a user process.

File and record locking
-----------------------

The provision for locking files, or portions of files, is primarily used
to prevent the sort of error that can occur when two or more users of a
file try to update information at the same time. The classic example is
the airlines reservation system where two ticket agents each assign a
passenger to Seat A, Row 5 on the 5 o'clock flight to Detroit. A locking
mechanism is designed to prevent such mishaps by blocking Agent B from
even seeing the seat assignment file until Agent A's transaction is
complete.

File locking and record locking are really the same thing, except that
file locking implies the whole file is affected; record locking means
that only a specified portion of the file is locked. (Remember, in SCO
OpenServer, file structure is undefined; a record is a concept of the
programs that use the file.)

Two types of locks are available: read locks and write locks. If a
process places a read lock on a file, other processes can also read the
file but all are prevented from writing to it, that is, changing any of
the data. If a process places a write lock on a file, no other processes
can read or write in the file until the lock is removed. Write locks are
also known as exclusive locks. The term shared lock is sometimes applied
to read locks.

Another distinction needs to be made between mandatory and advisory
locking. Mandatory locking means that the discipline is enforced
automatically for the system calls that read, write, or create files.
This is done through a permission flag established by the file's owner
(or the superuser). Advisory locking means that the processes that use
the file take the responsibility for setting and removing locks as
needed. Thus, mandatory may sound like a simpler and better deal, but it
is not so. The mandatory locking capability is included in the system to
comply with an agreement with */usr/group*, an organization that
represents the interests of SCO OpenServer users. The principal weakness
in the mandatory method is that the lock is in place only while the
single system call is being made. It is extremely common for a single
transaction to require a series of reads and writes before it can be
considered complete. In cases like this, the term atomic is used to
describe a transaction that must be viewed as an indivisible unit. The
preferred way to manage locking in such a circumstance is to make
certain the lock is in place before any I/O starts, and that it is not
removed until the transaction is done. That calls for locking of the
advisory variety.

Where to find more information
------------------------------

See `\``File and device input/output'' <FlDevIO.html>`__ for a
discussion of file and device I/O including file and record locking in
detail with a number of examples. There is an example of file and record
locking in the sample application in `\``System calls and
libraries'' <SysCallsLibraries.html>`__. The manual pages that
specifically address file and record locking are
`fcntl\ (S) <../man/html.S/fcntl.S.html>`__,
`lockf\ (S) <../man/html.S/lockf.S.html>`__,
`chmod\ (S) <../man/html.S/chmod.S.html>`__, and
`fcntl\ (M) <../man/html.M/fcntl.M.html>`__.
`fcntl\ (S) <../man/html.S/fcntl.S.html>`__ describes the system call
for file and record locking (although it is not limited to that only).
`fcntl\ (M) <../man/html.M/fcntl.M.html>`__ tells you the file control
options. The subroutine `lockf\ (S) <../man/html.S/lockf.S.html>`__ can
also be used to lock sections of a file or an entire file. Setting
**chmod** so that all portions of a file are locked will ensure that
parts of files are not corrupted.

--------------

/Memory management
==================

SCO OpenServer includes a complete set of memory-mapping mechanisms.
Process address spaces are composed of a vector of memory pages, each of
which can be independently mapped and manipulated. The memory-management
facilities

-  unify the system's operations on memory
-  provide a set of kernel mechanisms powerful and general enough to
   support the implementation of fundamental system services without
   special-purpose kernel support
-  maintain consistency with the existing environment, in particular
   using the SCO OpenServer file system as the name space for named
   virtual-memory objects

The system's virtual memory consists of all available physical memory
resources including local and remote file systems, processor primary
memory, swap space, and other random-access devices. Named objects in
the virtual memory are referenced though the SCO OpenServer file system.
However, not all file system objects are in the virtual memory; devices
that SCO OpenServer cannot treat as storage, such as terminal and
network device files, are not in the virtual memory. Some virtual memory
objects, such as private process memory and shared memory segments, do
not have names.

The memory mapping interface
----------------------------

The applications programmer gains access to the facilities of the
virtual memory system through several sets of system calls.

-  **mmap** establishes a mapping between a process's address space and
   a virtual memory object.
-  **mprotect** assigns access protection to a block of virtual memory.
-  **munmap** removes a memory mapping.
-  **mincore** tells whether mapped memory pages are in primary memory.

Where to find more information
------------------------------

See `\``Process management'' <_Process_Management.html>`__ for a
detailed description of the virtual memory system. Refer to
`mmap\ (S) <../man/html.S/mmap.S.html>`__,
`mprotect\ (S) <../man/html.S/mprotect.S.html>`__,
`munmap\ (S) <../man/html.S/munmap.S.html>`__, and **mincore**\ (S).

--------------


/Process management and scheduling
==================================

Beginning with System V Release 4.2 MP (SVR4.2 MP), the schedulable
entity is always a lightweight process (LWP). Scheduling priorities and
classes are attributes of LWPs and not processes. When scheduling system
calls accept a process on which to operate, the operation is applied to
each LWP in the process. The SCO OpenServer system scheduler determines
when LWPs run. It maintains priorities based on configuration
parameters, process behavior, and user requests; it uses these
priorities to assign LWPs to the CPU.

SCO OpenServer gives users absolute control over the sequence in which
certain LWPs run, and the amount of time each LWP may use the CPU before
another LWP gets a chance.

By default, the scheduler uses a time-sharing policy similar to the
policy used in previous releases. A time-sharing policy adjusts
priorities dynamically in an attempt to provide good response time to
interactive LWPs and good throughput to CPU-intensive LWPs.

A fixed class scheduling policy is available, also. It is similar to the
time-sharing policy except that the time slices given to fixed class
processes or LWPs do not degrade over time.

The scheduler offers a fixed priority scheduling policy as well as a
time-sharing policy. Fixed priority scheduling allows users to set fixed
priorities on a per-process or LWP basis. The highest-priority fixed
priority LWP always gets the CPU as soon as it is runnable, even if
system processes are runnable. An application can therefore specify the
exact order in which LWPs run. An application may also be written so
that its fixed priority LWPs have a guaranteed response time from the
system.

For most UNIX environments, the default scheduler configuration works
well and no fixed priority LWPs are needed: administrators should not
change configuration parameters and users should not change scheduler
properties of their applications. However, for some applications with
strict timing constraints, fixed priority LWPs are the only way to
guarantee that the application's requirements are met.

Where to find more information
------------------------------

`\``Process management'' <_Process_Management.html>`__ gives detailed
information on the process scheduler, along with relevant code examples.
See also **priocntl**\ (C), **priocntl**\ (S), and **dispadmin**\ (ADM).

--------------

/Interprocess communication
===========================

Pipes, named pipes, and signals are all forms of interprocess
communication. Business applications running on an SCO OpenServer
system, however, often need more sophisticated methods of communication.
In applications, for example, where fast response is critical, a number
of processes may be brought up at the start of a business day to be
constantly available to handle transactions on demand. This cuts out
initialization time that can add seconds to the time required to deal
with the transaction. To go back to the ticket reservation example again
for a moment, if a customer calls to reserve a seat on the 5 o'clock
flight to Detroit, you do not want to have to say, \``Yes, sir; just
hang on a minute while I start up the reservations program.'' In
transaction-driven systems, the normal mode of processing is to have all
the components of the application standing by waiting for some sort of
an indication that there is work to do.

To meet requirements of this type, SCO OpenServer offers a set of nine
system calls and their accompanying header files, all under the umbrella
name of interprocess communications (IPC).

The IPC system calls come in sets of three; one set each for messages,
semaphores, and shared memory. These three terms define three different
styles of communication between processes: 

messages
   Communication is in the form of data stored in a buffer. The buffer
   can be either sent or received.
semaphores
   Communication is in the form of positive integers with a value
   between 0 and 32,767. Semaphores may be contained in an array the
   size of which is determined by the system administrator. The default
   maximum size for the array is 25.
shared memory
   Communication takes place through a common area of main memory. One
   or more processes can attach a segment of memory and as a consequence
   can share whatever data is placed there.

The sets of IPC system calls are: 

  ====== ====== ======
  msgget semget shmget
  msgctl semctl shmctl
  msgop  semop  shmop
  ====== ====== ======

The \`\`\ **get**'' calls each return to the calling program an
identifier for the type of IPC facility that is being requested.

The \`\`\ **ctl**'' calls provide a variety of control operations that
include obtaining (**IPC_STAT**), setting (**IPC_SET**) and removing
(**IPC_RMID**), the values in data structures associated with the
identifiers picked up by the \`\`\ **get**'' calls.

The \`\`\ **op**'' manual pages describe calls that are used to perform
the particular operations characteristic of the type of IPC facility
being used. **msgop** has calls that send or receive messages. **semop**
(the only one of the three that is actually the name of a system call)
is used to increment or decrement the value of a semaphore, among other
functions. **shmop** has calls that attach or detach shared memory
segments.

Where to find more information
------------------------------

See `\``Interprocess communication'' <IPC.html>`__ for a detailed
description of IPC, with many code examples that use the IPC system
calls. An example of the use of some IPC features is included in the
**liber** application in `\``Interprocess communication'' <IPC.html>`__.

--------------

/Symbolic links
===============

A symbolic link is a special type of file that represents another file.
The data in a symbolic link consists of the path name of a file or
directory to which the symbolic link file refers. The link that is
formed is called symbolic to distinguish it from a regular (also called
a hard) link. A symbolic link differs functionally from a regular link
in three major ways.

-  Files from different file systems may be linked.
-  Directories, as well as regular files, may be symbolically linked by
   any user.
-  A symbolic link can be created even if the file it represents does
   not exist.

When a user creates a regular link to a file, a new directory entry is
created containing a new filename and the inode number of an existing
file. The link count of the file is incremented.

In contrast, when a user creates a symbolic link (using the
`ln\ (C) <../man/html.C/ln.C.html>`__ command with the **-s** option),
both a new directory entry and a new inode are created. A data block is
allocated to contain the path name of the file to which the symbolic
link refers. The link count of the referenced file is not incremented.

Symbolic links can be used to solve a variety of common problems. For
example, it frequently happens that a disk partition (such as *root*)
runs out of disk space. With symbolic links, an administrator can create
a link from a directory on that file system to a directory on another
file system. Such a link provides extra disk space and is, in most
cases, transparent to both users and programs.

Symbolic links can also help deal with the built-in path names that
appear in the code of many commands. Changing the path names would
require changing the programs and recompiling them. With symbolic links,
the path names can effectively be changed by making the original files
symbolic links that point to new files.

In a shared resource environment like NFS, symbolic links can be very
useful. For example, if it is important to have a single copy of certain
administrative files, symbolic links can be used to help share them.
Symbolic links can also be used to share resources selectively. Suppose
a system administrator wants to do a remote mount of a directory that
contains sharable devices. These devices must be in */dev* on the client
system, but this system has devices of its own so the administrator does
not want to mount the directory onto */dev*. Rather than do this, the
administrator can mount the directory at a location other than */dev*
and then use symbolic links in the */dev* directory to refer to these
remote devices. (This is similar to the problem of built-in path names
since it is normally assumed that devices reside in the */dev*
directory.)

Finally, symbolic links can be valuable within the context of the
virtual file system (VFS) architecture. With VFS, new services, such as
higher performance files and network IPC, may be provided on a file
system basis. Symbolic links can be used to link these services to home
directories or to places that make more sense to the application or
user. Thus, you might create a data base index file in a RAM-based file
system type and symbolically link it to the place where the data base
server expects it and manages it.

Where to find more information
------------------------------

`\``Directory and file management'' <DirFlMgmt.html>`__ discusses
symbolic links in detail. Refer to
`symlink\ (S) <../man/html.S/symlink.S.html>`__ for information on
creating symbolic links. See also
`stat\ (S) <../man/html.S/stat.S.html>`__,
`rename\ (S) <../man/html.S/rename.S.html>`__,
`link\ (S) <../man/html.S/link.S.html>`__,
`readlink\ (S) <../man/html.S/readlink.S.html>`__,
`unlink\ (S) <../man/html.S/unlink.S.html>`__, and
`ln\ (C) <../man/html.C/ln.C.html>`__.

--------------

/System calls and libraries
===========================

This section introduces the system calls and other system services you
can use to develop application programs. Each application performs a
different function, but goes through the same basic steps: input,
processing, and output. For the input and output steps, most
applications interact with an end user at a terminal. During the
processing step, sometimes an application needs access to special
services provided by the operating system (for example, to interact with
the file system, control processes, manage memory, and more). Some of
these services are provided through system calls and some through
libraries of functions.

--------------


/Libraries and header files
===========================

The standard libraries supplied by the C compilation system contain
functions that you can use in your program to perform input/output,
string handling, and other high-level operations that are not explicitly
provided by the C language. Header files contain definitions and
declarations that your program will need if it calls a library function.
They also contain function-like macros that you can use in your program
as you would a function.

In this part, we'll talk a bit more about header files and show you how
to use library functions in your program. We'll also describe the
contents of some of the more important standard libraries. We'll close
with a brief discussion of standard I/O.

--------------

/Header files
=============

Header files serve as the interface between your program and the
libraries supplied by the C compilation system. Because the functions
that perform standard I/O, for example, very often use the same
definitions and declarations, the system supplies a common interface to
the functions in the header file *<stdio.h>*. By the same token, if you
have definitions or declarations that you want to make available to
several source files, you can create a header file with any editor,
store it in a convenient directory, and include it in your program as
described in the first part of this section.

Header files traditionally are designated by the suffix **.h**, and are
brought into a program at compile time. The preprocessor component of
the compiler does this because it interprets the **#include** statement
in your program as a directive. The two most commonly used directives
are **#include** and **#define**. As we have seen, the **#include**
directive is used to call in and process the contents of the named file.
The **#define** directive is used to define the replacement token string
for an identifier. For example,

::

      #define NULL   0

defines the macro **NULL** to have the replacement token sequence **0**.
See `\``C and C++ compilation
system'' <../SDK_cprog/CCCompilationSys.html>`__ for the complete list
of preprocessing directives.

When you use a library function in your program, the manual page will
tell you which header file, if any, needs to be included. If a header
file is mentioned, it should be included before you use any of the
associated functions or declarations in your program. It's generally
best to put the **#include** right at the top of a source file. These
are some frequently used header files: 

========== ======================
*assert.h* assertion checking
*ctype.h*  character handling
*errno.h*  error conditions
*float.h*  floating point limits
*limits.h* other data type limits
*locale.h* program's locale
*math.h*   mathematics
*setjmp.h* nonlocal jumps
*signal.h* signal handling
*stdarg.h* variable arguments
*stddef.h* common definitions
*stdio.h*  standard input/output
*stdlib.h* general utilities
*string.h* string handling
*time.h*   date and time
*unistd.h* system calls
========== ======================

--------------

/How to use library functions
=============================

The manual page for each function describes how you should use the
function in your program. Manual pages follow a common format; although,
some manual pages may omit some sections: 

**name**
   The manual page names its components and briefly states its purpose.
   Some manual pages cover several commands, functions or other SCO
   OpenServer components; thus, components defined along with other
   related components share the same manual page title. For example,
   references to the function **calloc** cite
   `malloc\ (S) <../man/html.S/malloc.S.html>`__ because the function
   **calloc** is described with the function **malloc** on the
   `malloc\ (S) <../man/html.S/malloc.S.html>`__ manual page.
Synopsis
   Specifies the C language programming interface(s). It summarizes the
   component interface by compactly representing the order of any
   arguments for the component, the type of each argument (if any) and
   the type of value the component returns.
Description
   Details the behavior of the component(s), including the built-in file
   names, the return values, and possible errors. It specifies the
   functionality of components without stipulating the implementation;
   it excludes the details of how SCO OpenServer implements these
   components and concentrates on defining the external features of a
   standard computing environment instead of the internals of the
   operating system, such as the scheduler or memory manager. Portable
   software should avoid using any features or side-effects not
   explicitly defined.
Examples
   Gives code samples, caveats and guidance on usage.
References
   Lists related component interface descriptions. These may be other
   related manual pages in the SCO OpenServer reference manual set as
   well as other documents.

As an example manual page, we'll look at the **strcmp** function, which
compares character strings. The routine is described on the
`string\ (S) <../man/html.S/string.S.html>`__ manual page. Related
functions are described there as well, but only the sections relevant to
**strcmp** are shown in the following figure.

::

      string: strcat, strdup, strncat,
      strcmp, strncmp, strcpy, strncpy,
      strlen, strchr, strrchr, strpbrk,
      strspn, strcspn, strok - string operations
      
      Synopsis
      
      #include <string.h>
      
      int strcmp(const char *sptr1, const char *sptr2);
      
      Description
      . . .
      strcmp compares its arguments and
      returns an integer less than, equal to, or
      greater than 0, according as the first argument is lexicographically less than,
      equal to, or greater than the second . . .

As shown, the \``Description'' section tells you what the function or
macro does. It is the \``Synopsis'' section, though, that contains the
critical information about how you use the function or macro in your
program. Note that the first line in the \``Synopsis'' is

::

   #include <string.h>

That means that you should include the header file *<string.h>* in your
program because it contains useful definitions or declarations relating
to **strcmp**.

In fact, *<string.h>* contains the **strcmp** \``function prototype'' as
follows: 

::

   extern int strcmp(const char *, const char *);

A function prototype describes the kinds of arguments expected and
returned by a C language function. Function prototypes afford a greater
degree of argument type checking than old-style function declarations,
and reduce the chance of using the function incorrectly. Including
*<string.h>*, assures that the C compiler checks calls to **strcmp**
against the official interface. You can, of course, examine *<string.h>*
in the standard place for header files on your system, usually the
*/usr/include* directory.

The \``Synopsis'' for a C library function closely resembles the C
language declaration of the function and its arguments. The
\``Synopsis'' tells the reader: 

-  the type of value returned by the function
-  the arguments the function expects to receive when called, if any
-  the argument types

For example, the \``Synopsis'' for the macro **feof** is: 

::

   #include <stdio.h>

   int feof( FILE *sfp )

The \``Synopsis'' section for **feof** shows that: 

-  The macro **feof** requires the header file *<stdio.h>*
-  The macro **feof** returns a value of type **int**
-  The argument **sfp** is a pointer to an object of type **FILE**,
   defined in *<stdio.h>*.

To use **feof** in a program, you need only write the macro call,
preceded at some point by the **#include** control line, as in the
following: 

::

      #include <stdio.h>   /* include definitions */
      
      main() {
         FILE *infile;     /* define a file pointer */
      
         . . .
      
         while (!feof(infile)) {   /* until end-of-file */
            /* operations on the file */
         }
      
      }

By way of further illustration, let us look at how you might use
**strcmp** in your own code. The following figure shows a program
fragment that will find the bird of your choice in an array of birds.

::

      #include <string.h>
      
      /* birds must be in alphabetical order */
      char *birds[] = { "albatross",  "canary", "cardinal", "ostrich", "penguin" };
      
      /* Return the index of the bird in the array. */
      /* If the bird is not in the array, return -1 */
      
      int is_bird(const char *string)
      {
       int low, high, midpoint;
       int cmp_value;
      
       /* use a binary search to find the bird */
       low = 0;
       high = sizeof(birds)/sizeof(char *) - 1;
       while(low <= high)
       {
           midpoint = (low + high)/2;
           cmp_value = strcmp(string, birds[midpoint]);
           if (cmp_value < 0)
               high = midpoint - 1;
           else if (cmp_value > 0)
               low = midpoint + 1;
           else /* found a match */
               return midpoint;
       }
       return -1;
      }

**How strcmp is used in a program**

The format of a \``Synopsis'' section only resembles, but does not
duplicate, the format of C language declarations. To show that some
components take varying numbers of arguments, the \``Synopsis'' section
uses additional conventions not found in actual C function declarations: 

-  Text in **courier** represents source-code typed just as it appears.
-  Text in *italic* usually represents substitutable argument
   prototypes.
-  Square brackets [ ] around arguments indicate optional arguments.
-  Ellipses . . . indicate that the previous arguments may repeat.
-  If the type of an argument may vary, the \``Synopsis'' omits the
   type.

For example, the \``Synopsis'' for the function **printf** is: 

::

   #include <stdio.h>

   int printf( char *fmt [ , arg . . . ] )

The \``Synopsis'' section for **printf** shows that the argument **arg**
is optional, may be repeated and is not always of the same data type.
The \``Description'' section of the manual page provides any remaining
information about the function **printf** and the arguments to it.

The \``Return values'' section specifies return values. The text in the
\``Return values'' takes a conventional form that describes the return
value in case of successful completion followed by the consequences of
an unsuccessful completion, as in the following example: 

::

      On success, lseek returns a non-negative integer
      indicating the file pointer value.
      On failure, lseek returns -1,
      sets errno to identify the error,
      and the file pointer remains unchanged.

The \``Errors'' section lists the possible error conditions and their
symbolic values from the header file *errno.h*, as in the following
example: 

**EBADF**
   **fildes** is not an open file descriptor.
**ESPIPE**
   **fildes** is associated with a pipe or fifo.
**EINVAL**
   The resulting file pointer would be negative.

The *errno.h* symbolic names for error conditions are described in
**intro**\ (S). For more information on error conditions, see `\``System
call error handling'' <SCL_SysCallErrHdl.html>`__.

--------------

/C library (libc)
=================

In this section, we describe some of the more important routines in the
standard C library. As we indicated previously, **libc** contains the
system calls described in the Section S manual pages, and the C language
functions described in Section S. We'll explain what each of these
subsections contains below. We'll look at system calls at the end of the
section.

String and Character routines
-----------------------------

String and character functions and macros perform a variety of tasks: 

-  string manipulation
-  character classification
-  character conversion

`\``String operations'' <_C_Library_libc.html#syssvc_c3>`__ lists
string-handling functions that appear on the
`string\ (S) <../man/html.S/string.S.html>`__ manual page. Programs that
use these functions should include the header file *<string.h>*.

**String operations**

+-------------+-------------------------------------------------------+
| **strcat**  | Append a copy of one string to the end of another.    |
+-------------+-------------------------------------------------------+
| **strncat** | Append no more than a given number of characters from |
|             | one string to the end of another.                     |
+-------------+-------------------------------------------------------+
| **strcmp**  | Compare two strings. Returns an integer less than,    |
|             | greater than, or equal to 0 to show that one is       |
|             | lexicographically less than, greater than, or equal   |
|             | to the other.                                         |
+-------------+-------------------------------------------------------+
| **strncmp** | Compare no more than a given number of characters     |
|             | from the two strings. Results are otherwise identical |
|             | to **strcmp**.                                        |
+-------------+-------------------------------------------------------+
| **strcpy**  | Copy a string.                                        |
+-------------+-------------------------------------------------------+
| **strncpy** | Copy a given number of characters from one string to  |
|             | another. The destination string will be truncated if  |
|             | it is longer than the given number of characters, or  |
|             | padded with null characters if it is shorter.         |
+-------------+-------------------------------------------------------+
| **strdup**  | Return a pointer to a newly allocated string that is  |
|             | a duplicate of a string pointed to.                   |
+-------------+-------------------------------------------------------+
| **strchr**  | Return a pointer to the first occurrence of a         |
|             | character in a string, or a null pointer if the       |
|             | character is not in the string.                       |
+-------------+-------------------------------------------------------+
| **strrchr** | Return a pointer to the last occurrence of a          |
|             | character in a string, or a null pointer if the       |
|             | character is not in the string.                       |
+-------------+-------------------------------------------------------+
| **strlen**  | Return the number of characters in a string.          |
+-------------+-------------------------------------------------------+
| **strpbrk** | Return a pointer to the first occurrence in one       |
|             | string of any character from the second, or a null    |
|             | pointer if no character from the second occurs in the |
|             | first.                                                |
+-------------+-------------------------------------------------------+
| **strspn**  | Return the length of the initial segment of one       |
|             | string that consists entirely of characters from the  |
|             | second string.                                        |
+-------------+-------------------------------------------------------+
| **strcspn** | Return the length of the initial segment of one       |
|             | string that consists entirely of characters not from  |
|             | the second string.                                    |
+-------------+-------------------------------------------------------+
| **strstr**  | Return a pointer to the first occurrence of the       |
|             | second string in the first string, or a null pointer  |
|             | if the second string is not found.                    |
+-------------+-------------------------------------------------------+
| **strtok**  | Break up the first string into a sequence of tokens,  |
|             | each of which is delimited by one or more characters  |
|             | from the second string. Return a pointer to the       |
|             | token, or a null pointer if no token is found.        |
+-------------+-------------------------------------------------------+

`\``Classifying 8-Bit character-coded integer
values'' <_C_Library_libc.html#syssvc_c4>`__ lists functions and macros
that classify 8-bit character-coded integer values. These routines
appear on the **conv**\ (S) and
`ctype\ (S) <../man/html.S/ctype.S.html>`__ manual pages. Programs that
use these routines should include the header file *<ctype.h>*.

**Classifying 8-Bit character-coded integer values**

+---------------+-----------------------------------------------------+
| **isalpha**   | Is **c** a letter?                                  |
+---------------+-----------------------------------------------------+
| **isupper**   | Is **c** an uppercase letter?                       |
+---------------+-----------------------------------------------------+
| **islower**   | Is **c** a lowercase letter?                        |
+---------------+-----------------------------------------------------+
| **isdigit**   | Is **c** a digit [0-9]?                             |
+---------------+-----------------------------------------------------+
| **isxdigit**  | Is **c** a hexadecimal digit [0-9], [A-F], or       |
|               | [a-f]?                                              |
+---------------+-----------------------------------------------------+
| **isalnum**   | Is **c** alphanumeric (a letter or digit)?          |
+---------------+-----------------------------------------------------+
| **isspace**   | Is **c** a space, horizontal tab, vertical tab,     |
|               | new-line, form-feed, or carriage return?            |
+---------------+-----------------------------------------------------+
| **ispunct**   | Is **c** a punctuation character (neither control   |
|               | nor alphanumeric)?                                  |
+---------------+-----------------------------------------------------+
| **isprint**   | Is **c** a printing character?                      |
+---------------+-----------------------------------------------------+
| **isgraph**   | Same as **isprint** except false for a space.       |
+---------------+-----------------------------------------------------+
| **iscntrl**   | Is **c** a control character or a delete character? |
+---------------+-----------------------------------------------------+
| **isascii**   | Is **c** an ASCII character?                        |
+---------------+-----------------------------------------------------+
| **toupper**   | Change lower case to upper case.                    |
+---------------+-----------------------------------------------------+
| **\_toupper** | Macro version of **toupper**.                       |
+---------------+-----------------------------------------------------+
| **tolower**   | Change upper case to lower case.                    |
+---------------+-----------------------------------------------------+
| **\_tolower** | Macro version of **tolower**.                       |
+---------------+-----------------------------------------------------+
| **toascii**   | Turn off all bits that are not part of a standard   |
|               | ASCII character; intended for compatibility with    |
|               | other systems.                                      |
+---------------+-----------------------------------------------------+

`\``Converting characters, integers, or
strings'' <_C_Library_libc.html#syssvc_c5>`__ lists functions and macros
in Section 3C that are used to convert characters, integers, or strings
from one representation to another. The left-hand column contains the
name that appears at the top of the manual page; the other names in the
same row are related functions or macros described on the same manual
page. Programs that use these routines should include the header file
*<stdlib.h>*.

**Converting characters, integers, or strings**

============================ ==========================================
**strtod** **atof**          Convert string to double-precision number.
**strtol** **atol** **atoi** Convert string to integer.
**strtoul**                  Convert string to unsigned long.
**sprintf**                  Print formatted output.
============================ ==========================================

Standard I/O routines
---------------------

The standard I/O library routines for C programs are listed below.
Frequently, one manual page describes several related functions or
macros. In `\``Standard I/O functions and
macros'' <_C_Library_libc.html#syssvc_c6>`__, the left-hand column
contains the name that appears at the top of the manual page; the other
names in the same row are related functions or macros described on the
same manual page. Programs that use these routines should include the
header file *<stdio.h>*. We will talk a bit more about standard I/O in
`\``Standard I/O library'' <_Standard_IO_Library.html>`__.

**Standard I/O functions and macros**

+----------------------------------+----------------------------------+
| **fclose** **fflush**            | Close or flush a stream.         |
+----------------------------------+----------------------------------+
| **ferror** **feof** **clearerr** | Stream status inquiries.         |
| **fileno**                       |                                  |
+----------------------------------+----------------------------------+
| **fopen** **freopen** **fdopen** | Open a stream.                   |
+----------------------------------+----------------------------------+
| **fread** **fwrite**             | Input/output.                    |
+----------------------------------+----------------------------------+
| **fseek** **rewind** **ftell**   | Reposition a file pointer in a   |
|                                  | stream.                          |
+----------------------------------+----------------------------------+
| **getc** **getchar** **fgetc**   | Get a character or word from a   |
| **getw**                         | stream.                          |
+----------------------------------+----------------------------------+
| **gets** **fgets**               | Get a string from a stream.      |
+----------------------------------+----------------------------------+
| **popen** **pclose**             | Begin or end a pipe to/from a    |
|                                  | process.                         |
+----------------------------------+----------------------------------+
| **printf** **fprintf**           | Print formatted output.          |
| **sprintf**                      |                                  |
+----------------------------------+----------------------------------+
| **putc** **putchar** **fputc**   | Put a character or word on a     |
| **putw**                         | stream.                          |
+----------------------------------+----------------------------------+
| **puts** **fputs**               | Put a string on a stream.        |
+----------------------------------+----------------------------------+
| **scanf** **fscanf** **sscanf**  | Convert formatted input.         |
+----------------------------------+----------------------------------+
| **setbuf** **setvbuf**           | Assign buffering to a stream.    |
+----------------------------------+----------------------------------+
| **system**                       | Issue a command through the      |
|                                  | shell.                           |
+----------------------------------+----------------------------------+
| **tmpfile**                      | Create a temporary file.         |
+----------------------------------+----------------------------------+
| **tmpnam** **tempnam**           | Create a name for a temporary    |
|                                  | file.                            |
+----------------------------------+----------------------------------+
| **ungetc**                       | Push character back into input   |
|                                  | stream.                          |
+----------------------------------+----------------------------------+
| **vprintf** **vfprintf**         | Print formatted output of a      |
| **vsprintf**                     | **varargs** argument list.       |
+----------------------------------+----------------------------------+

--------------


/Math library (libm)
====================

The math library, **libm**, contains the mathematics functions supplied
by the C compilation system. These are described on the Section S manual
pages. Here we describe some of the major functions. Note that functions
whose names end with the letter **f** are single-precision versions,
which means that their argument and return types are **float**.
Functions whose names end with the letter **l** are long
double-precision versions, which means that their argument and return
types are **long double**. The header file *math.h* should be included
in programs that use math functions.

**Math functions**

+-------------+-------------+-------------+-------------+-------------+
| **bessel**  | j0          | j1          | jn          | Bessel      |
|       \ (S) |             |             |             | functions   |
+-------------+-------------+-------------+-------------+-------------+
|             | y0          | y1          | yn          | Bessel      |
|             |             |             |             | functions   |
+-------------+-------------+-------------+-------------+-------------+
| **erf**     | erfc        | erfcf       | erfcl       | return      |
|       \ (S) |             |             |             | co          |
|             |             |             |             | mplementary |
|             |             |             |             | error       |
|             |             |             |             | function of |
|             |             |             |             | **x**       |
+-------------+-------------+-------------+-------------+-------------+
|             | erf         | erff        | erfl        | return      |
|             |             |             |             | error       |
|             |             |             |             | function of |
|             |             |             |             | **x**       |
+-------------+-------------+-------------+-------------+-------------+
| **exp**     | cbrt        | cbrtf       | cbrtl       | cube root   |
|       \ (S) |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | exp         | expf        | expl        | exponential, |
|             |             |             |             | mod, power, |
|             |             |             |             | square root |
|             |             |             |             | functions   |
+-------------+-------------+-------------+-------------+-------------+
|             | exp2        | exp2f       | exp2l       | exponential |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | expm1       | expm1f      | expm1l      | exponential |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | frexp       | frexpf      | frexpl      | exponential |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | ldexp       | ldexpf      | ldexpl      | exponential |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | modf        | modff       | modfl       | modulus     |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | pow         | powf        | powl        | power       |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | pown        | pownf       | pownl       | power       |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | scalbln     | scalblnf    | scalblnl    | scalbln     |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | scalbn      | scalbnf     | scalbnl     | scalbn      |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | sqrt        | sqrtf       | sqrtl       | square root |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
| **fdim**    | fdim        | fdimf       | fdiml       | return      |
|       \ (S) |             |             |             | positive    |
|             |             |             |             | difference  |
|             |             |             |             | between two |
|             |             |             |             | arguments   |
+-------------+-------------+-------------+-------------+-------------+
| **floor**   | ceil        | ceilf       | ceill       | return      |
|       \ (S) |             |             |             | smallest    |
|             |             |             |             | integer not |
|             |             |             |             | smaller     |
|             |             |             |             | than **x**  |
+-------------+-------------+-------------+-------------+-------------+
|             | copysign    | copysignf   | copysignl   | return      |
|             |             |             |             | **x** with  |
|             |             |             |             | the sign of |
|             |             |             |             | **y**       |
+-------------+-------------+-------------+-------------+-------------+
|             | fabs        | fabsf       | fabsl       | return the  |
|             |             |             |             | absolute    |
|             |             |             |             | value of    |
|             |             |             |             | **x**,      |
|             |             |             |             | **\|x\|**   |
+-------------+-------------+-------------+-------------+-------------+
|             | floor       | floorf      | floorl      | return      |
|             |             |             |             | largest     |
|             |             |             |             | integer not |
|             |             |             |             | greater     |
|             |             |             |             | than **x**  |
+-------------+-------------+-------------+-------------+-------------+
|             | fmod        | fmodf       | fmodl       | return the  |
|             |             |             |             | floating    |
|             |             |             |             | point       |
|             |             |             |             | remainder   |
|             |             |             |             | of the      |
|             |             |             |             | division of |
|             |             |             |             | **x** by    |
|             |             |             |             | **y**       |
+-------------+-------------+-------------+-------------+-------------+
|             | nan         | nanf        | nanl        | return a    |
|             |             |             |             | quiet NaN,  |
|             |             |             |             | if          |
|             |             |             |             | available,  |
|             |             |             |             | with        |
|             |             |             |             | content     |
|             |             |             |             | indicated   |
|             |             |             |             | by tagp     |
+-------------+-------------+-------------+-------------+-------------+
|             | nearbyint   | nearbyintf  | nearbyintl  | return      |
|             |             |             |             | nearest     |
|             |             |             |             | integer     |
|             |             |             |             | value to    |
|             |             |             |             | floating    |
|             |             |             |             | point       |
|             |             |             |             | argument    |
|             |             |             |             | **x**       |
+-------------+-------------+-------------+-------------+-------------+
|             | nextafter   | nextafterf  | nextafterl  | return the  |
|             |             |             |             | next        |
|             |             |             |             | re          |
|             |             |             |             | presentable |
|             |             |             |             | value in    |
|             |             |             |             | the         |
|             |             |             |             | specified   |
|             |             |             |             | format      |
|             |             |             |             | after **x** |
|             |             |             |             | in the      |
|             |             |             |             | direction   |
|             |             |             |             | of **y**    |
+-------------+-------------+-------------+-------------+-------------+
|             | nexttoward  | nexttowardf | nexttowardl | return the  |
|             |             |             |             | next        |
|             |             |             |             | re          |
|             |             |             |             | presentable |
|             |             |             |             | value in    |
|             |             |             |             | the         |
|             |             |             |             | specified   |
|             |             |             |             | format      |
|             |             |             |             | after **x** |
|             |             |             |             | in the      |
|             |             |             |             | direction   |
|             |             |             |             | of **y**    |
+-------------+-------------+-------------+-------------+-------------+
| **fma**     | fma         | fmaf        | fmal        | return      |
|       \ (S) |             |             |             | rounded     |
|             |             |             |             | result of   |
|             |             |             |             | (**x** x    |
|             |             |             |             | **y**) +    |
|             |             |             |             | **z**       |
+-------------+-------------+-------------+-------------+-------------+
| **fmax**    | fmax        | fmaxf       | fmaxl       | return      |
|       \ (S) |             |             |             | maximum     |
|             |             |             |             | numeric     |
|             |             |             |             | value of    |
|             |             |             |             | two         |
|             |             |             |             | arguments   |
+-------------+-------------+-------------+-------------+-------------+
|             | fmin        | fminf       | fminl       | return      |
|             |             |             |             | minimum     |
|             |             |             |             | numeric     |
|             |             |             |             | value of    |
|             |             |             |             | two         |
|             |             |             |             | arguments   |
+-------------+-------------+-------------+-------------+-------------+
| **fpclas    | isfinite    |             |             | determines  |
| sify**\ (S) |             |             |             | whether     |
|             |             |             |             | **x** has a |
|             |             |             |             | finite      |
|             |             |             |             | value       |
+-------------+-------------+-------------+-------------+-------------+
|             | isgreater   |             |             | determines  |
|             |             |             |             | whether     |
|             |             |             |             | **x** is    |
|             |             |             |             | greater     |
|             |             |             |             | than **y**  |
+-------------+-------------+-------------+-------------+-------------+
|             | isg         |             |             | determines  |
|             | reaterequal |             |             | whether     |
|             |             |             |             | **x** is    |
|             |             |             |             | greater     |
|             |             |             |             | than or     |
|             |             |             |             | equal to    |
|             |             |             |             | **y**       |
+-------------+-------------+-------------+-------------+-------------+
|             | isinf       |             |             | determines  |
|             |             |             |             | whether     |
|             |             |             |             | **x** is    |
|             |             |             |             | positive or |
|             |             |             |             | negative    |
|             |             |             |             | infinity    |
+-------------+-------------+-------------+-------------+-------------+
|             | isles       |             |             | determines  |
|             |             |             |             | whether     |
|             |             |             |             | **x** is    |
|             |             |             |             | less than   |
|             |             |             |             | **y**       |
+-------------+-------------+-------------+-------------+-------------+
|             | islessequal |             |             | determines  |
|             |             |             |             | whether     |
|             |             |             |             | **x** is    |
|             |             |             |             | less than   |
|             |             |             |             | or equal to |
|             |             |             |             | **y**       |
+-------------+-------------+-------------+-------------+-------------+
|             | is          |             |             | determines  |
|             | lessgreater |             |             | whether     |
|             |             |             |             | **x** is    |
|             |             |             |             | less than   |
|             |             |             |             | or greater  |
|             |             |             |             | than **y**  |
+-------------+-------------+-------------+-------------+-------------+
|             | isnan       |             |             | determines  |
|             |             |             |             | whether     |
|             |             |             |             | **x** is a  |
|             |             |             |             | NaN         |
+-------------+-------------+-------------+-------------+-------------+
|             | isnormal    |             |             | determines  |
|             |             |             |             | whether     |
|             |             |             |             | **x** is    |
|             |             |             |             | not zero,   |
|             |             |             |             | subnormal,  |
|             |             |             |             | infinite,   |
|             |             |             |             | or a NaN    |
+-------------+-------------+-------------+-------------+-------------+
|             | isunordered |             |             | determines  |
|             |             |             |             | whether     |
|             |             |             |             | **x** and   |
|             |             |             |             | **y** are   |
|             |             |             |             | unordered   |
+-------------+-------------+-------------+-------------+-------------+
|             | signbit     |             |             | determines  |
|             |             |             |             | whether the |
|             |             |             |             | sign of     |
|             |             |             |             | **x** is    |
|             |             |             |             | negative    |
+-------------+-------------+-------------+-------------+-------------+
| **gamma**   | gamma       | gammaf      | gammal      | log gamma   |
|       \ (S) |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | lgamma      | lgammaf     | lgammal     | log gamma   |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | signgam     |             |             | storage for |
|             |             |             |             | sign for    |
|             |             |             |             | gamma and   |
|             |             |             |             | lgamma      |
+-------------+-------------+-------------+-------------+-------------+
|             | tgamma      | tgammaf     | tgammal     | gamma       |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
| **hypot**   | hypot       | hypotf      | hypotl      | return      |
|       \ (S) |             |             |             | result of   |
|             |             |             |             | sqrt((**x** |
|             |             |             |             | x **x**) +  |
|             |             |             |             | (**y** x    |
|             |             |             |             | **y**))     |
+-------------+-------------+-------------+-------------+-------------+
| **log**     | ilogb       | ilogbf      | ilogbl      | logarithm   |
|       \ (S) |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | log         | logf        | logl        | logarithm   |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | log10       | log10f      | log10l      | logarithm   |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | log1p       | log1pf      | log1pl      | logarithm   |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | log2        | log2f       | log2l       | logarithm   |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
|             | logb        | logbf       | logbl       | logarithm   |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
| **matherr** | matherr     | matherrl    |             | err         |
|       \ (S) |             |             |             | or-handling |
|             |             |             |             | function    |
+-------------+-------------+-------------+-------------+-------------+
| **remai     | remainder   | remainderf  | remainderl  | return      |
| nder**\ (S) |             |             |             | floating    |
|             |             |             |             | point       |
|             |             |             |             | remainder   |
|             |             |             |             | of division |
|             |             |             |             | of **x** by |
|             |             |             |             | **y**       |
+-------------+-------------+-------------+-------------+-------------+
|             | remquo      | remquof     | remquol     | return      |
|             |             |             |             | floating    |
|             |             |             |             | point       |
|             |             |             |             | remainder   |
|             |             |             |             | of division |
|             |             |             |             | of **x** by |
|             |             |             |             | **y**       |
+-------------+-------------+-------------+-------------+-------------+
| **rint**    | llrint      | llrintf     | llrintl     | return      |
|       \ (S) |             |             |             | nearest     |
|             |             |             |             | integer     |
|             |             |             |             | value to    |
|             |             |             |             | floating    |
|             |             |             |             | point       |
|             |             |             |             | argument    |
|             |             |             |             | **x**       |
+-------------+-------------+-------------+-------------+-------------+
|             | llround     | llroundf    | llroundl    | return the  |
|             |             |             |             | rounded     |
|             |             |             |             | integer     |
|             |             |             |             | value of    |
|             |             |             |             | **x**       |
+-------------+-------------+-------------+-------------+-------------+
|             | lrint       | lrintf      | lrintl      | return      |
|             |             |             |             | nearest     |
|             |             |             |             | integer     |
|             |             |             |             | value to    |
|             |             |             |             | floating    |
|             |             |             |             | point       |
|             |             |             |             | argument    |
|             |             |             |             | **x**       |
+-------------+-------------+-------------+-------------+-------------+
|             | lround      | lroundf     | lroundl     | return the  |
|             |             |             |             | rounded     |
|             |             |             |             | integer     |
|             |             |             |             | value of    |
|             |             |             |             | **x**       |
+-------------+-------------+-------------+-------------+-------------+
|             | rint        | rintf       | rintl       | return      |
|             |             |             |             | nearest     |
|             |             |             |             | integer     |
|             |             |             |             | value to    |
|             |             |             |             | floating    |
|             |             |             |             | point       |
|             |             |             |             | argument    |
|             |             |             |             | **x**       |
+-------------+-------------+-------------+-------------+-------------+
|             | round       | roundf      | roundl      | return the  |
|             |             |             |             | rounded     |
|             |             |             |             | integer     |
|             |             |             |             | value of    |
|             |             |             |             | **x**       |
+-------------+-------------+-------------+-------------+-------------+
|             | trunc       | truncf      | truncl      | return the  |
|             |             |             |             | truncated   |
|             |             |             |             | integer     |
|             |             |             |             | value of    |
|             |             |             |             | **x**       |
+-------------+-------------+-------------+-------------+-------------+
| **sinh**    | acosh       | acoshf      | acoshl      | return      |
|       \ (S) |             |             |             | inverse     |
|             |             |             |             | hyperbolic  |
|             |             |             |             | cosine of   |
|             |             |             |             | argument    |
+-------------+-------------+-------------+-------------+-------------+
|             | asinh       | asinhf      | asinhl      | return      |
|             |             |             |             | inverse     |
|             |             |             |             | hyperbolic  |
|             |             |             |             | sine of     |
|             |             |             |             | argument    |
+-------------+-------------+-------------+-------------+-------------+
|             | atanh       | atanhf      | atanhl      | return      |
|             |             |             |             | inverse     |
|             |             |             |             | hyperbolic  |
|             |             |             |             | tangent of  |
|             |             |             |             | argument    |
+-------------+-------------+-------------+-------------+-------------+
|             | cosh        | coshf       | coshl       | return      |
|             |             |             |             | hyperbolic  |
|             |             |             |             | cosine of   |
|             |             |             |             | argument    |
+-------------+-------------+-------------+-------------+-------------+
|             | sinh        | sinhf       | sinhl       | return      |
|             |             |             |             | hyperbolic  |
|             |             |             |             | sine of     |
|             |             |             |             | argument    |
+-------------+-------------+-------------+-------------+-------------+
|             | tanh        | tanhf       | tanhl       | return      |
|             |             |             |             | hyperbolic  |
|             |             |             |             | tangent of  |
|             |             |             |             | argument    |
+-------------+-------------+-------------+-------------+-------------+
| **trig**    | acos        | acosf       | acosl       | return the  |
|       \ (S) |             |             |             | arccosine   |
|             |             |             |             | of an       |
|             |             |             |             | argument in |
|             |             |             |             | radians     |
+-------------+-------------+-------------+-------------+-------------+
|             | asin        | asinf       | asinl       | return the  |
|             |             |             |             | arcsine of  |
|             |             |             |             | an argument |
|             |             |             |             | in radians  |
+-------------+-------------+-------------+-------------+-------------+
|             | atan        | atanf       | atanl       | return the  |
|             |             |             |             | arctangent  |
|             |             |             |             | of an       |
|             |             |             |             | argument in |
|             |             |             |             | radians     |
+-------------+-------------+-------------+-------------+-------------+
|             | atan2       | atan2f      | atan2l      | return the  |
|             |             |             |             | arctangent  |
|             |             |             |             | of          |
|             |             |             |             | **y**/**x** |
|             |             |             |             | in radians  |
+-------------+-------------+-------------+-------------+-------------+
|             | cos         | cosf        | cosl        | return the  |
|             |             |             |             | cosine of   |
|             |             |             |             | an argument |
|             |             |             |             | in radians  |
+-------------+-------------+-------------+-------------+-------------+
|             | sin         | sinf        | sinl        | return the  |
|             |             |             |             | sine of an  |
|             |             |             |             | argument in |
|             |             |             |             | radians     |
+-------------+-------------+-------------+-------------+-------------+
|             | tan         | tanf        | tanl        | return the  |
|             |             |             |             | tangent of  |
|             |             |             |             | an argument |
|             |             |             |             | in radians  |
+-------------+-------------+-------------+-------------+-------------+

--------------


/General purpose library (libgen)
=================================

**libgen** contains general purpose functions, and functions designed to
facilitate internationalization. These are described on the Section S
manual pages. `\`\`\ libgen
functions'' <_General_Purpose_Library_libgen.html#syssvc_c8>`__
describes functions in **libgen**. The header files *<libgen.h>* and,
occasionally, *<regexp.h>* should be included in programs that use these
functions.

**libgen functions**

+-------------------------+-------------------------------------------+
| **advance** **step**    | Execute a regular expression on a string. |
+-------------------------+-------------------------------------------+
| **basename**            | Return a pointer to the last element of a |
|                         | path name.                                |
+-------------------------+-------------------------------------------+
| **bgets**               | Read a specified number of characters     |
|                         | into a buffer from a stream until a       |
|                         | specified character is reached.           |
+-------------------------+-------------------------------------------+
| **bufsplit**            | Split the buffer into fields delimited by |
|                         | tabs and new-lines.                       |
+-------------------------+-------------------------------------------+
| **compile**             | Return a pointer to a compiled regular    |
|                         | expression that uses the same syntax as   |
|                         | **ed**.                                   |
+-------------------------+-------------------------------------------+
| **copylist**            | Copy a file into a block of memory,       |
|                         | replacing new-lines with null characters. |
|                         | It returns a pointer to the copy.         |
+-------------------------+-------------------------------------------+
| **dirname**             | Return a pointer to the parent directory  |
|                         | name of the file path name.               |
+-------------------------+-------------------------------------------+
| **eaccess**             | Determine if the effective user ID has    |
|                         | the appropriate permissions on a file.    |
+-------------------------+-------------------------------------------+
| **gmatch**              | Check if name matches shell file name     |
|                         | pattern.                                  |
+-------------------------+-------------------------------------------+
| **isencrypt**           | Use heuristics to determine if contents   |
|                         | of a character buffer are encrypted.      |
+-------------------------+-------------------------------------------+
| **mkdirp**              | Create a directory and its parents.       |
+-------------------------+-------------------------------------------+
| **p2open** **p2close**  | **p2open** is similar to **popen** (see   |
|                         | `popen\ (S) <../man/html.S/popen.S.html>`__). |
|                         | It establishes a two-way connection       |
|                         | between the parent and the child.         |
|                         | **p2close** closes the pipe.              |
+-------------------------+-------------------------------------------+
| **pathfind**            | Search the directories in a given path    |
|                         | for a named file with given mode          |
|                         | characteristics. If the file is found, a  |
|                         | pointer is returned to a string that      |
|                         | corresponds to the path name of the file. |
|                         | A null pointer is returned if no file is  |
|                         | found.                                    |
+-------------------------+-------------------------------------------+
| **regcmp**              | Compile a regular expression and return a |
|                         | pointer to the compiled form.             |
+-------------------------+-------------------------------------------+
| **regex**               | Compare a compiled regular expression     |
|                         | against a subject string.                 |
+-------------------------+-------------------------------------------+
| **rmdirp**              | Remove the directories in the specified   |
|                         | path.                                     |
+-------------------------+-------------------------------------------+
| **strccpy** **strcadd** | **strccpy** copies the input string to    |
|                         | the output string, compressing any C-like |
|                         | escape sequences to the real character.   |
|                         | **strcadd** is a similar function that    |
|                         | returns the address of the null byte at   |
|                         | the end of the output string.             |
+-------------------------+-------------------------------------------+
| **strecpy**             | Copy the input string to the output       |
|                         | string, expanding any non-graphic         |
|                         | characters with the C escape sequence.    |
|                         | Characters in a third argument are not    |
|                         | expanded.                                 |
+-------------------------+-------------------------------------------+
| **strfind**             | Return the offset of the first occurrence |
|                         | of the second string in the first string. |
|                         | **-1** is returned if the second string   |
|                         | does not occur in the first.              |
+-------------------------+-------------------------------------------+
| **strrspn**             | Trim trailing characters from a string.   |
|                         | It returns a pointer to the last          |
|                         | character in the string not in a list of  |
|                         | trailing characters.                      |
+-------------------------+-------------------------------------------+
| **strtrns**             | Return a pointer to the string that       |
|                         | results from replacing any character      |
|                         | found in two strings with a character     |
|                         | from a third string. This function is     |
|                         | similar to the **tr** command.            |
+-------------------------+-------------------------------------------+

--------------

/Standard I/O library
=====================

The functions in the standard I/O library for C programs are described
below. In this section, we want to discuss standard I/O in a bit more
detail. First, let's briefly define what I/O involves. It has to do with

-  reading information from a file or device to your program;
-  writing information from your program to a file or device;
-  opening and closing files that your program reads from or writes to.

Three files you always have
---------------------------

Programs automatically start off with three open files: standard input,
standard output, and standard error. These files with their associated
buffering are called streams, and are designated **stdin**, **stdout**,
and **stderr**, respectively. The shell associates all three files with
your terminal by default.

This means that you can use functions and macros that deal with
**stdin**, **stdout**, or **stderr** without having to open or close
files. **scanf**, for example, reads a string from **stdin**; **printf**
writes a string to **stdout**. Other functions and macros read from or
write to files in different ways: character at a time, **getc** and
**putc**; formatted, **scanf** and **printf**; and so on. You can
specify that output be directed to **stderr** by using a function such
as **fprintf**. **fprintf** works the same way as **printf** except that
it delivers its formatted output to a named stream, such as **stderr**.

Named files
-----------

Any file other than standard input, standard output, and standard error
must be explicitly opened by you before your program can read from or
write to the file. You open a file with the standard library function
**fopen**. **fopen** takes a path name, asks the system to keep track of
the connection between your program and the file, and returns a pointer
that you can then use in functions that perform other I/O operations.

The pointer is to a structure called *FILE*, defined in *<stdio.h>*,
that contains information about the file: the location of its buffer,
the current character position in the buffer, and so on. In your
program, then, you need to have a declaration such as

::

      FILE *fin;

which says that **fin** is a pointer to a **FILE**. The statement

::

   fin = fopen("filename", "r");

associates a **FILE** structure with **filename**, the path name of the
file to open, and returns a pointer to it. The \`\`"r"'' means that the
file is to be opened for reading. This argument is known as the mode.
There are modes for reading, writing, and both reading and writing.

In practice, the file open function is often included in an **if**
statement: 

::

   if ((fin = fopen("filename", "r")) == NULL)
       (void)fprintf(stderr,"Cannot open input file %s\n",
           "filename");

which takes advantage of the fact that **fopen** returns a **NULL**
pointer if it cannot open the file. To avoid falling into the
immediately following code on failure, you can call **exit**, which
causes your program to quit: 

::

   if ((fin = fopen("filename", "r")) == NULL) {
       (void)fprintf(stderr,"Cannot open input file %s\n",
           "filename");
       exit(1);
   }

Once you have opened the file, you use the pointer **fin** in functions
or macros to refer to the stream associated with the opened file: 

::

   int c;
   c = getc(fin);

brings in one character from the stream into an integer variable called
**c**. The variable **c** is declared as an integer even though we are
reading characters because **getc** returns an integer. Getting a
character is often incorporated in some flow-of-control mechanism such
as

::

   while ((c = getc(fin)) != EOF)
        .
        .
        .

that reads through the file until **EOF** is returned. **EOF**,
**NULL**, and the macro **getc** are all defined in *<stdio.h>*.
**getc** and other macros in the standard I/O package keep advancing a
pointer through the buffer associated with the stream; SCO OpenServer
and the standard I/O functions are responsible for seeing that the
buffer is refilled if you are reading the file, or written to the output
file if you are producing output, when the pointer reaches the end of
the buffer.

Your program may have multiple files open simultaneously, 20 or more
depending on system configuration. If, subsequently, your program needs
to open more files than it is permitted to have open simultaneously, you
can use the standard library function **fclose** to break the connection
between the **FILE** structure in *<stdio.h>* and the path names of the
files your program has opened. Pointers to **FILE** may then be
associated with other files by subsequent calls to **fopen**. For output
files, an **fclose** call makes sure that all output has been sent from
the output buffer before disconnecting the file. **exit** closes all
open files for you, but it also gets you completely out of your process,
so you should use it only when you are sure you are finished.

--------------

/BSD system libraries and header files
======================================

If you are migrating to SCO OpenServer from a BSD System environment, or
want to run BSD system applications, you may need to install and access
the BSD libraries and header files included in the BSD Compatibility
Package.

The BSD Compatibility Package is a separately installed, optional
package that contains the following, which are either different from SCO
OpenServer or don't exist in SCO OpenServer: 

-  BSD commands
-  Library routines
   For example, **printf** returns different values under BSD and SCO
   OpenServer; the BSD routine **re_comp** does not exist in SCO
   OpenServer.
-  Header files
   For example, *sysexits.h* does not exist in SCO OpenServer; and the
   BSD *sys/file.h* has additional **#define**\ s not in SCO OpenServer.
-  System Calls and Signals
   Routines to emulate BSD system calls. For example, the BSD system
   call, **killpg**, has been implemented as a library routine with the
   same name.

By using the BSD Compatibility Package, you can take advantage of a
comprehensive BSD environment compatibility.

The subsections below discuss BSD header files, libraries, and how to
access them.

Accessing BSD libraries and header files
----------------------------------------

Once the BSD Compatibility Package is installed, compatibility package
header files and libraries called by the C compiler (**cc**) and linker
(**ld**) are located in **/usr/ucbinclude** and **/usr/ucblib**. To
access these header files and libraries, set your **PATH** variable so
that **/usr/ucb** comes before the default SCO OpenServer path
directories */sbin*, */usr/sbin*, */usr/bin*, and */usr/ccs/bin*.

To find out what your path is currently, use the **echo** command as
shown in the following example.

::

      $ echo $PATH
      PATH=.:/home/medici/bin:/usr/bin:/usr/ucb:/etc
      $

To make the BSD Compatibility Package commands the default, change the
order of the directories in your path, as shown in the example below: 

::

      $ PATH=.:/home/medici/bin:/usr/ucb:/usr/bin:/etc
      $

To make this change permanent, put a line like the above **PATH**
command in your **.profile** file (or your **.cshrc** file, if you're
using the C shell).

By setting your path as shown above, you'll use **/usr/ucb/cc** when you
compile C programs. **/usr/ucb/cc** sets its default paths to pick up,
in this order: 

#. user-specified include directories and libraries
#. the compatibility include files and directories
#. the default SCO OpenServer headers and libraries, if unresolved
   symbols remain

BSD library routines
--------------------

The BSD Compatibility Package libraries contain the routines listed in
the following table. These routines are either not in SCO OpenServer or
have a different interface and a different system call \``wrapper'' than
their SCO OpenServer counterparts; these latter routines are marked with
an asterisk (\*).

Not all entries in this table appear on their own manual pages. You can
use the Search capability of the online browser or see the permuted
index in the printed version of the **Operating System API Reference**
for the name of the manual page that explains a particular routine.

======================= ================== =====================
**\_longjmp**           **getwd**          **setreuid**
**\_setjmp**            **ieee_functions** **setstate**
**alloca**              **ieee_handler**   **settimeofday**\ \*
**alphasort**           **index**          **setusershell**
**bcmp**                **initstate**      **setvbuf**\ \*
**bcopy**               **itom**           **sfconvert**
**closelog**            **killpg**         **sgconvert**
**copysign**            **longjmp**\ \*    **sigblock**
**dbm_clearerr**        **madd**           **sigfpe**
**dbm_close**           **mcmp**           **siginterrupt**
**dbm_delete**          **mctl**           **siglongjmp**\ \*
**dbm_error**           **mdiv**           **sigmask**
**dbm_fetch**           **mfree**          **signal**\ \*
**dbm_firstkey**        **min**            **sigpause**
**dbm_nextkey**         **mkstemp**        **sigsetjmp**\ \*
**dbm_open**            **mout**           **sigsetmask**
**dbm_store**           **msqrt**          **sigstack**
**dbminit**             **msub**           **sigvec**
**decimal_to_double**   **mtox**           **single_to_decimal**
**decimal_to_extended** **mult**           **sleep**\ \*
**decimal_to_single**   **nextkey**        **sprintf**\ \*
**delete**              **nice**\ \*       **srand**\ \*
**double_to_decimal**   **nlist**\ \*      **srandom**
**econvert**            **pow**            **stejmp**\ \*
**endusershell**        **printf**\ \*     **store**
**extended_to_decimal** **psignal**\ \*    **strcasecmp**
**fconvert**            **rand**\ \*       **strncasecmp**
**fetch**               **random**         **sys_siglist**
**firstkey**            **re_comp**        **syscall**
**floatingpoint**       **re_exec**        **syslog**
**fopen**\ \*           **reboot**         **times**\ \*
**fp_class**            **reboot**         **ualarm**
**fprintf**\ \*         **regex**\ \*      **usleep**
**freopen**\ \*         **rindex**         **utimes**
**ftime**               **rpow**           **vfprintf**\ \*
**gcd**                 **scalbn**         **vprintf**\ \*
**gconvert**            **scandir**        **vsprintf**\ \*
**getdtablesize**       **sdiv**           **wait3**
**gethostid**           **seconvert**      **wait**\ \*
**gethostname**         **setbuf**\ \*     **wiFEXITED**
**getpagesize**         **setbuffer**      **wiFSIGNALED**
**getpriority**         **sethostname**    **wiFSTOPPED**
**getrusage**           **setlinebuf**     **xtom**
**gettimeofday**\ \*    **setpriority**     
**getusershell**        **setregid**        
======================= ================== =====================

BSD header files
----------------

The BSD Compatibility Package includes a set of header files that
provide a high degree of source compatibility for applications that were
originally written to work on BSD.

Some BSD header files do not exist in SCO OpenServer. Others differ in
ways that cannot be reconciled in a single file and are listed in the
following table with an asterisk (\*).

============== ================== ====================
*assert.h*\ \* *strings.h*        *sys/reboot.h*
*dbm.h*        *struct.h*         *sys/resource.h*\ \*
*fp.h*         *sunfp.h*          *sys/signal.h*\ \*
*mp.h*         *sys/dirent.h*\ \* *sys/types.h*\ \*
*ndbm.h*       *sys/fcntl.h*\ \*  *sys/vfs.h*\ \*
*regexp.h*\ \* *sys/file.h*\ \*   *sys/wait.h*\ \*
*setjmp.h*\ \* *sys/ieeefp.h*     *sysexits.h*
*signal.h*\ \* *sys/mtio.h*       *ufs/quota.h*
*stdio.h*\ \*  *sys/param.h*\ \*  *unistd.h*\ \*
============== ================== ====================

--------------


/How C programs communicate with the shell
==========================================

Information or control data can be passed to a C program as an argument
on the command line, which is to say, by the shell. When you execute a C
program, command line arguments are made available to the function
**main** in two parameters, an argument count, conventionally called
**argc**, and an argument vector, conventionally called **argv**. (Every
C program is required to have an entry point named **main**.) **argc**
is the number of arguments with which the program was invoked. **argv**
is an array of pointers to character strings that contain the arguments,
one per string. Since the command name itself is considered to be the
first argument, or **argv[0]**, the count is always at least one. Here
is the declaration for **main**: 

::

   int
   main(int argc, char *argv[])

For two examples of how you might use run-time parameters in your
program, see `\``Passing command line
arguments'' <_How_C_Programs_Communicate_with.html#_Passing_Command_Line_Arguments>`__.

The shell, which makes arguments available to your program, considers an
argument to be any sequence of non-blank characters. Characters enclosed
in single quotes (**'abc def'**) or double quotes (\`\`"abc def"'') are
passed to the program as one argument even if blanks or tabs are among
the characters. You are responsible for error checking and otherwise
making sure that the argument received is what your program expects it
to be.

In addition to **argc** and **argv**, you can use a third argument: 
**envp** is an array of pointers to environment variables. You can find
more information on **envp** on the
`exec\ (S) <../man/html.S/exec.S.html>`__ and
`environ\ (M) <../man/html.M/environ.M.html>`__ manual pages.

C programs exit voluntarily, returning control to the operating system,
by returning from **main** or by calling the **exit** function. That is,
a **return(n)** from **main** is equivalent to the call **exit(n)**.
(Remember that **main** has type \``function returning **int**.'') Your
program should return a value to say whether it completed successfully
or not. The value gets passed to the shell, where it becomes the value
of the **$?** shell variable if you executed your program in the
foreground. By convention, a return value of zero denotes success, a
non-zero return value means some sort of error occurred. You can use the
macros **EXIT_SUCCESS** and **EXIT_FAILURE**, defined in the header file
*<stdlib.h>*, as return values from **main** or argument values for
**exit**.

Passing command line arguments
------------------------------

As described above, information or control data can be passed to a C
program as an argument on the command line. When you execute the
program, command line arguments are made available to the function
**main** in two parameters, an argument count, conventionally called
**argc**, and an argument vector, conventionally called **argv**.
**argc** is the number of arguments with which the program was invoked.
**argv** is an array of pointers to characters strings that contain the
arguments, one per string. Since the command name itself is considered
to be the first argument, or **argv[0]**, the count is always at least
one.

If you plan to accept run-time parameters in your program, you need to
include code to deal with the information. `\``Using argv[1] to pass a
file name'' <_How_C_Programs_Communicate_with.html#syssvc_c9>`__ and
`\``Using command line arguments to set
flags'' <_How_C_Programs_Communicate_with.html#syssvc_cA>`__ show
program fragments that illustrate two common uses of run-time
parameters: 

-  `\``Using argv[1] to pass a file
   name'' <_How_C_Programs_Communicate_with.html#syssvc_c9>`__ shows how
   you provide a variable file name to a program, such that a command of
   the form

   ::

         $ prog filename

   will cause **prog** to attempt to open the specified file.

-  `\``Using command line arguments to set
   flags'' <_How_C_Programs_Communicate_with.html#syssvc_cA>`__ shows
   how you set internal flags that control the operation of a program,
   such that a command of the form

   ::

         $ prog -opr

   will cause **prog** to set the corresponding variables for each of
   the options specified. The **getopt** function used in the example is
   the most common way to process arguments in SCO OpenServer programs.
   See `getopt\ (S) <../man/html.S/getopt.S.html>`__.

::

      #include <stdio.h>
      
      int
      main(int argc, char *argv[])
      {
            FILE *fin;
            int ch;
      
            switch (argc)
            {
            case 2: 
                  if ((fin = fopen(argv[1], "r")) == NULL)
                  {
                        /* First string (%s) is program name (argv[0]).  */
                        /* Second string (%s) is name of file that could */
                        /* not be opened (argv[1]). */
      
                        (void)fprintf(stderr, "%s: Cannot open input file %s\n",
                              argv[0], argv[1]);
                        return(2);
                  }
                  break;
            case 1: 
                  fin = stdin;
                  break;
      
            default: 
                  (void)fprintf(stderr, "Usage: %s [file]\n", argv[0]);
                  return(2);
            }
      
            while ((ch = getc(fin)) != EOF)
                  (void)putchar(ch);
      
            return (0);
      
      }

**Using argv[1] to pass a file name**

::

      #include <stdio.h>
      #include <stdlib.h>
      
      int
      main(int argc, char *argv[])
      {
            int oflag = 0;
            int pflag = 0; /* Function flags */
            int rflag = 0;
            int ch;
      
            while ((ch = getopt(argc, argv, "opr")) != -1)
            {
                  /* For options present, set flag to 1.              */
                  /* If unknown options present, print error message. */
      
                  switch (ch)
                  {
                  case 'o': 
                        oflag = 1;
                        break;
                  case 'p': 
                        pflag = 1;
                        break;
                  case 'r': 
                        rflag = 1;
                        break;
                  default: 
                        (void)fprintf(stderr, "Usage: %s [-opr]\n", argv[0]);
                        return(2);
                  }
            }
            /* Do other processing controlled by oflag, pflag, rflag. */
            return(0);
      }

**Using command line arguments to set flags**

--------------

/System calls
=============

System calls are the interface between the kernel and the user programs
that run on top of it. The system kernel is the software on which
everything else in the SCO OpenServer operating system depends. The
kernel manages system resources, maintains file systems and supports
system calls. The system calls provide the basic system services upon
which the entire system is built. Strictly speaking, they are the only
way to access such facilities as the file system, interprocess
communication primitives, and multitasking mechanisms.

Most programs do not need to invoke system calls directly to gain access
to these facilities, but use library functions instead, which use the
system calls to access system services. When you use such functions, the
details of their implementation are transparent to the program. For
example, the system call **read** underlies the **fread** implementation
in the standard C library. Because of this, the program will generally
be portable to any system with a conforming C implementation. (See the
`Programming in standard C and C++ <../SDK_cprog/CONTENTS.html>`__ guide
for a discussion of the standard C library.)

In contrast, programs that invoke system calls directly are portable
only to other UNIX or UNIX-like systems; for that reason, you would not
use **read** in a program that performed a simple input/output
operation. Other operations, however, including most multitasking
mechanisms, do require direct interaction with the SCO OpenServer system
kernel. These operations are the subject of the first part of this
topic. The following sections list the system calls in functional
groups, and includes brief discussions of error handling.

A C program is automatically linked with the system calls you have
invoked when you compile the program. The procedure may be different for
programs written in other languages. Check the `Programming in standard
C and C++ <../SDK_cprog/CONTENTS.html>`__ guide for details on the
language you are using.

--------------


/File and device I/O
====================

These system calls perform basic input/output operations on SCO
OpenServer system files.

**File and device I/O functions**

===================== ============================================
**open**              open a file for reading or writing
**creat**             create a new file or rewrite an existing one
**close**             close a file descriptor
**read** **write**    transfer data from/onto a file or device
**getmsg** **putmsg** get/put message from/onto a stream
**lseek**             move file I/O pointer
**fcntl**             file I/O control
**ioctl**             device I/O control
===================== ============================================

--------------

/2. Terminal device control
============================

These system calls deal with a general terminal interface for the
control of asynchronous communications ports.

**Terminal device control functions**

=============================== ========================================
**tcgetattr** **tcsetattr**     get and set terminal attributes
**tcdrain** **tcflush**         line control functions
**tcflow** **tcsendbreak**      line control functions
**cfgetispeed** **cfgetospeed** get baud rate functions
**cfsetispeed** **cfsetospeed** set baud rate functions
**tcgetsid**                    get terminal session ID
**tcgetpgrp**                   get terminal foreground process group ID
**tcsetpgrp**                   set terminal foreground process group ID
=============================== ========================================

--------------

/Directory and file system control
==================================

These system calls allow creation of new directories (and other types of
files), linking to existing files, obtaining or modifying file status
information, and allow you to control various aspects of the file
system.

**Directory and file system control functions**

+----------------------------------+----------------------------------+
| **link**                         | link to a file                   |
+----------------------------------+----------------------------------+
| **access**                       | determine accessibility of a     |
|                                  | file                             |
+----------------------------------+----------------------------------+
| **mknod**                        | make a directory, special, or    |
|                                  | regular file                     |
+----------------------------------+----------------------------------+
| **chdir** **fchdir**             | change working directory         |
+----------------------------------+----------------------------------+
| **chmod** **fchmod**             | change mode of file              |
+----------------------------------+----------------------------------+
| **chown** **fchown** **lchown**  | change owner and group of a file |
+----------------------------------+----------------------------------+
| **utime**                        | set file access and modification |
|                                  | times                            |
+----------------------------------+----------------------------------+
| **stat** **fstat** **lstat**     | get file status                  |
+----------------------------------+----------------------------------+
| **pathconf** **fpathconf**       | get configurable path name       |
|                                  | variables                        |
+----------------------------------+----------------------------------+
| **getdents**                     | read directory entries and put   |
|                                  | in file system-independent       |
|                                  | format                           |
+----------------------------------+----------------------------------+
| **mkdir**                        | make a directory                 |
+----------------------------------+----------------------------------+
| **readlink**                     | read the value of a symbolic     |
|                                  | link                             |
+----------------------------------+----------------------------------+
| **rename**                       | change the name of a file        |
+----------------------------------+----------------------------------+
| **rmdir**                        | remove a directory               |
+----------------------------------+----------------------------------+
| **symlink**                      | make a symbolic link to a file   |
+----------------------------------+----------------------------------+
| **unlink**                       | remove directory entry           |
+----------------------------------+----------------------------------+
| **ustat**                        | get file system statistics       |
+----------------------------------+----------------------------------+
| **sync**                         | update super block               |
+----------------------------------+----------------------------------+
| **mount** **umount**             | mount/unmount a file system      |
+----------------------------------+----------------------------------+
| (**f**)\ **statfs**              | get file system information      |
| (**f**)\ **statvfs**             |                                  |
+----------------------------------+----------------------------------+
| **sysfs**                        | get file system type information |
+----------------------------------+----------------------------------+

--------------


/Processes
==========

These system calls control user processes.

**Process management functions**

+----------------------------------+----------------------------------+
| **fork**                         | create a new process             |
+----------------------------------+----------------------------------+
| **execl** **execle** **execlp**  | execute a file with a list of    |
|                                  | arguments                        |
+----------------------------------+----------------------------------+
| **execv** **execve** **execvp**  | execute a file with a variable   |
|                                  | list                             |
+----------------------------------+----------------------------------+
| **exit** **\_exit**              | terminate process                |
+----------------------------------+----------------------------------+
| **wait** **waitpid** **waitid**  | wait for child process to change |
|                                  | state                            |
+----------------------------------+----------------------------------+
| **setuid** **setgid**            | set user and group IDs           |
+----------------------------------+----------------------------------+
| **getpgrp** **setpgrp**          | get and set process group ID     |
+----------------------------------+----------------------------------+
| **chdir** **fchdir**             | change working directory         |
+----------------------------------+----------------------------------+
| **chroot**                       | change root directory            |
+----------------------------------+----------------------------------+
| **nap**                          | suspend current process for a    |
|                                  | short interval                   |
+----------------------------------+----------------------------------+
| **nice**                         | change priority of a process     |
+----------------------------------+----------------------------------+
| **getcontext** **setcontext**    | get and set current user context |
+----------------------------------+----------------------------------+
| **getgroups** **setgroups**      | get or set supplementary group   |
|                                  | IDs                              |
+----------------------------------+----------------------------------+
| **getpid** **getppid**           | get process and parent process   |
| **getpgid**                      | IDs                              |
+----------------------------------+----------------------------------+
| **getuid** **geteuid**           | get real user and effective user |
+----------------------------------+----------------------------------+
| **getgid** **getegid**           | get real group and effective     |
|                                  | group                            |
+----------------------------------+----------------------------------+
| **pause**                        | suspend process until signal     |
+----------------------------------+----------------------------------+
| **priocntl**                     | process scheduler control        |
+----------------------------------+----------------------------------+
| **setpgid**                      | set process group ID             |
+----------------------------------+----------------------------------+
| **setsid**                       | set session ID                   |
+----------------------------------+----------------------------------+
| **kill**                         | send a signal to a process or    |
|                                  | group of processes               |
+----------------------------------+----------------------------------+

--------------


/Signals
========

Signals are messages passed by system to running processes.

**Signal management functions**

+----------------------------+----------------------------------------+
| **sigaction**              | detailed signal management             |
+----------------------------+----------------------------------------+
| **sigaltstack**            | set/get signal alternate stack context |
+----------------------------+----------------------------------------+
| **sigignore** **sigpause** | simplified signal management           |
+----------------------------+----------------------------------------+
| **sighold** **sigrelse**   | simplified signal management           |
+----------------------------+----------------------------------------+
| **sigset** **signal**      | simplified signal management           |
+----------------------------+----------------------------------------+
| **sigpending**             | examine blocked and pending signals    |
+----------------------------+----------------------------------------+
| **sigprocmask**            | change or examine signal mask          |
+----------------------------+----------------------------------------+
| **sigsuspend**             | install a signal mask and suspend      |
|                            | process                                |
+----------------------------+----------------------------------------+
| **sigsend** **sigsendset** | send a signal to a process or group of |
|                            | processes                              |
+----------------------------+----------------------------------------+

--------------

/IPC system calls
=================

These system calls connect processes so they can communicate. **pipe**
is the system call for creating an interprocess channel. **dup** is the
call for duplicating an open file descriptor. (These IPC mechanisms are
not applicable for processes on separate hosts.)

**Basic interprocess communication functions**

======== =================================
**pipe** open file-descriptors for a pipe
**dup**  duplicate an open file-descriptor
======== =================================

--------------


/Advanced interprocess communication
====================================

These system calls support interprocess messages, semaphores, and shared
memory and are effective in data base management. (These IPC mechanisms
are also not applicable for processes on separate hosts.)

**Advanced interprocess communication functions**

========== ====================================
**msgget** get message queue
**msgctl** message control operations
**msgop**  message operations
**semget** get set of semaphores
**semctl** semaphore control operations
**semop**  semaphore operations
**shmget** get shared memory segment identifier
**shmctl** shared memory control operations
**shmop**  shared memory operations
========== ====================================

--------------


/Memory management
==================

These system calls give you access to virtual memory facilities.

**Memory management functions**

================ =====================================
**getpagesize**  get system page size
**memcntl**      memory management control
**mmap**         map pages of memory
**mprotect**     set protection of memory mapping
**munmap**       unmap pages of memory
**plock**        lock process, text, or data in memory
**brk** **sbrk** dynamically allocate memory space
================ =====================================

--------------

/Miscellaneous system calls
===========================

These are system calls for such things as administration, timing, and
other miscellaneous purposes.

**Miscellaneous system functions**

+-----------------------------+---------------------------------------+
| **acct**                    | enable or disable process accounting  |
+-----------------------------+---------------------------------------+
| **alarm**                   | set a process alarm clock             |
+-----------------------------+---------------------------------------+
| **getrlimit** **setrlimit** | control maximum system resource       |
|                             | consumption                           |
+-----------------------------+---------------------------------------+
| **modload**                 | loads dynamically loadable kernel     |
|                             | module                                |
+-----------------------------+---------------------------------------+
| **moduload**                | unloads kernel module                 |
+-----------------------------+---------------------------------------+
| **modpath**                 | change path from which modules are    |
|                             | loaded                                |
+-----------------------------+---------------------------------------+
| **modadm**                  | module administration                 |
+-----------------------------+---------------------------------------+
| **profil**                  | execution time profile                |
+-----------------------------+---------------------------------------+
| **sysconf**                 | method for application's              |
|                             | determination of value for system     |
|                             | configuration                         |
+-----------------------------+---------------------------------------+
| **sysi86**                  | machine-specific functions (available |
|                             | only on Intel processors)             |
+-----------------------------+---------------------------------------+
| **time** **stime**          | get/set time                          |
+-----------------------------+---------------------------------------+
| **uadmin**                  | administrative control                |
+-----------------------------+---------------------------------------+
| **ulimit**                  | get and set user limits               |
+-----------------------------+---------------------------------------+
| **uname**                   | get/set name of current host system   |
+-----------------------------+---------------------------------------+

--------------

/BSD system calls
=================

The optional BSD Compatibility Package includes system calls and library
routines that provide BSD system call functionality not present in or
different from SCO OpenServer's system call functionality. See `\``BSD
system libraries and header
files'' <SCL_BSDSysLibrariesHeaderFls.html>`__ for details.

--------------


/System call error handling
===========================

System calls that fail to complete successfully almost always return a
value of **-1** to your program. (If you look through the system calls
in Section 2, you will see that there are a few calls for which no
return value is defined, but they are the exceptions.) In addition to
the **-1** returned to the program, the unsuccessful system call places
an integer in an externally declared variable, **errno**. In a C
program, you can determine the value in **errno** if your program
contains the following statement: 

::

   #include <errno.h>

The C language function `perror\ (S) <../man/html.S/perror.S.html>`__
can be used to print an error message (on **stderr**) based on the value
of **errno**. The value in **errno** is not cleared on successful calls,
so your program should check it only if the system call returned a
**-1** indicating an error. The following list identifies the error
numbers and symbolic names defined in the *<errno.h>* header file, and
described in **intro**\ (S).

1 **EPERM** 
   Not privileged. Typically this error indicates an attempt to modify a
   file in some way forbidden except to its owner or a process with the
   appropriate privilege. It is also returned for attempts by ordinary
   users to do things allowed only to the super-user.
2 **ENOENT** 
   No such file or directory. A file name is specified and the file
   should exist but fails to, or one of the directories in a path name
   fails to exist.
3 **ESRCH** 
   No such process. No process can be found corresponding to the that
   specified by PID in the\ **kill** or\ **ptrace** routine.
4 **EINTR** 
   Interrupted system call. An asynchronous signal (such as interrupt or
   quit), which the user has elected to catch, occurred during a system
   service routine. If execution is resumed after processing the signal,
   it will appear as if the interrupted routine call returned this error
   condition.
5 **EIO** 
   I/O error. Some physical I/O error has occurred. This error may in
   some cases occur on a call following the one to which it actually
   applies.
6 **ENXIO** 
   No such device or address. I/O on a special file refers to a
   subdevice which does not exist, or exists beyond the limit of the
   device. It may also occur when, for example, a tape drive is not
   on-line or no disk pack is loaded on a drive.
7 **E2BIG** 
   Arg list too long. An argument list longer than **ARG_MAX** bytes is
   presented to a member of the **exec** family of routines. The
   argument list limit is sum of the size of the argument list plus the
   size of the environment's exported shell variables.
8 **ENOEXEC** 
   Exec format error. A request is made to execute a file which,
   although it has the appropriate permissions, does not start with a
   valid format (see *a.out*\ (4)).
9 **EBADF** 
   Bad file number. Either a file descriptor refers to no open file, or
   a **read** [respectively, **write**] request is made to a file that
   is open only for writing (respectively, reading).
10 **ECHILD** 
   No child processes. A **wait** routine was executed by a process that
   had no existing or unwaited-for child processes.
11 **EAGAIN** 
   Resource is temporarily unavailable. For example, the **fork** 
   routine failed because the system's process table is full or the user
   is not allowed to create any more processes. Or a system call failed
   because of insufficient memory or swap space.
12 **ENOMEM** 
   Not enough space. During execution of an **exec**, **brk**, or
   **sbrk** routine, a program asks for more space than the system is
   able to supply. This is not a temporary condition; the maximum size
   is a system parameter. The error may also occur if the arrangement of
   text, data, and stack segments requires too many segmentation
   registers, or if there is not enough swap space during the\ **fork** 
   routine.
13 **EACCES** 
   Permission denied. An attempt was made to access a file in a way
   forbidden by the protection system.
14 **EFAULT** 
   Bad address. The system encountered a hardware fault in attempting to
   use an argument of a routine. For example,\ **errno** potentially may
   be set to\ **EFAULT** any time a routine that takes a pointer
   argument is passed an invalid address, if the system can detect the
   condition. Because systems will differ in their ability to reliably
   detect a bad address, on some implementations passing a bad address
   to a routine will result in undefined behavior.
15 **ENOTBLK** 
   Block device required. A non-block file was mentioned where a block
   device was required (for example, in a call to the **mount** 
   routine).
16 **EBUSY** 
   Device busy. An attempt was made to mount a device that was already
   mounted or an attempt was made to dismount a device on which there is
   an active file (open file, current directory, mounted-on file, active
   text segment). It will also occur if an attempt is made to enable
   accounting when it is already enabled. The device or resource is
   currently unavailable.
17 **EEXIST** 
   File exists. An existing file was mentioned in an inappropriate
   context (for example, call to the **link** routine).
18 **EXDEV** 
   Cross-device link. A link to a file on another device was attempted.
19 **ENODEV** 
   No such device. An attempt was made to apply an inappropriate
   operation to a device (for example, read a write-only device).
20 **ENOTDIR** 
   Not a directory. A non-directory was specified where a directory is
   required (for example, in a path prefix or as an argument to the
   **chdir** routine).
21 **EISDIR** 
   Is a directory. An attempt was made to write on a directory.
22 **EINVAL** 
   Invalid argument. An invalid argument was specified (for example,
   unmounting a non-mounted device, mentioning an undefined signal in a
   call to the **signal** or **kill** routine. Also set by the functions
   described in the math package (S).
23 **ENFILE** 
   File table overflow. The system file table is full (that is,
   **SYS_OPEN** files are open, and temporarily no more files can be
   opened).
24 **EMFILE** 
   Too many open files. No process may have more than **OPEN_MAX** file
   descriptors open at a time.
25 **ENOTTY** 
   Not a typewriter. A call was made to the\ **ioctl** routine
   specifying a file that is not a special character device.
26 **ETXTBSY** 
   Text file busy. An attempt was made to execute a pure-procedure
   program that is currently open for writing. Also an attempt to open
   for writing or to remove a pure-procedure program that is being
   executed.
27 **EFBIG** 
   File too large. The size of a file exceeded the maximum file size,
   **FCHR_MAX** (see
   `getrlimit\ (S) <../man/html.S/getrlimit.S.html>`__).
28 **ENOSPC** 
   No space left on device. While writing an ordinary file or creating a
   directory entry, there is no free space left on the device. In
   the\ **fcntl** routine, the setting or removing of record locks on a
   file cannot be accomplished because there are no more record entries
   left on the system.
29 **ESPIPE** 
   Illegal seek. A call to the **lseek** routine was issued to a pipe.
30 **EROFS** 
   Read-only file system. An attempt to modify a file or directory was
   made on a device mounted read-only.
31 **EMLINK** 
   Too many links. An attempt to make more than the maximum number of
   links, **LINK_MAX**, to a file.
32 **EPIPE** 
   Broken pipe. A write on a pipe for which there is no process to read
   the data. This condition normally generates a signal; the error is
   returned if the signal is ignored.
33 **EDOM** 
   Math argument out of domain of func. The argument of a function in
   the math package is out of the domain of the function.
34 **ERANGE** 
   Math result not representable. The value of a function in the math
   package is not representable within machine precision.
35 **ENOMSG** 
   No message of desired type. An attempt was made to receive a message
   of a type not existing on the specified message queue (see
   `msgop\ (S) <../man/html.S/msgop.S.html>`__).
36 **EIDRM** 
   Identifier removed. This error is returned to processes that resume
   execution due to the removal of an identifier from the file system's
   name space (see `msgctl\ (S) <../man/html.S/msgctl.S.html>`__,
   `semctl\ (S) <../man/html.S/semctl.S.html>`__, and
   `shmctl\ (S) <../man/html.S/shmctl.S.html>`__).
37 **ECHRNG** 
   Channel number out of range.
38 **EL2NSYNC** 
   Level 2 not synchronized.
39 **EL3HLT** 
   Level 3 halted.
40 **EL3RST** 
   Level 3 reset.
41 **ELNRNG** 
   Link number out of range.
42 **EUNATCH** 
   Protocol driver not attached.
43 **ENOCSI** 
   No CSI structure available.
44 **EL2HLT** 
   Level 2 halted.
45 **EDEADLK** 
   Deadlock condition. A deadlock situation was detected and avoided.
   This error pertains to file and record locking.
46 **ENOLCK** 
   No record locks available. There are no more locks available. The
   system lock table is full (see
   `fcntl\ (S) <../man/html.S/fcntl.S.html>`__).
60 **ENOSTR** 
   Device not a stream. A **putmsg** or\ **getmsg** system call was
   attempted on a file descriptor that is not aSTREAMS device.
61 **ENODATA** 
   No data available.
62 **ETIME** 
   Timer expired. The timer set for aSTREAMS\ **ioctl** call has
   expired. The cause of this error is device specific and could
   indicate either a hardware or software failure, or perhaps a timeout
   value that is too short for the specific operation. The status of
   the\ **ioctl** operation is indeterminate.
63 **ENOSR** 
   Out of stream resources. During a STREAMS\ **open**, either no
   STREAMS queues or no STREAMS head data structures were available.
   This is a temporary condition; one may recover from it if other
   processes release resources.
65 **ENOPKG** 
   Package not installed. This error occurs when users attempt to use a
   system call from a package which has not been installed.
71 **EPROTO** 
   Protocol error. Some protocol error occurred. This error is device
   specific, but is generally not related to a hardware failure.
77 **EBADMSG** 
   Not a data message. During a\ **read**,\ **getmsg**,
   or\ **ioctlI_RECVFD** system call to aSTREAMS device, something has
   come to the head of the queue that cannot be processed. That
   something depends on the system call: **read**: control information
   or a passed file descriptor. **getmsg**: passed file descriptor.
   **ioctl**: control or data information.
78 **ENAMETOOLONG** 
   File name too long. The length of the path argument
   exceeds\ **PATH_MAX**, or the length of a path component
   exceeds\ **NAME_MAX** while **\_POSIX_NO_TRUNC** is in effect; (see
   *limits*\ (4)).
79 **EOVERFLOW** 
   Value too large to be stored in data type.
80 **ENOTUNIQ** 
   Name not unique on network. Given log name not unique.
81 **EBADFD** 
   File descriptor in bad state. Either a file descriptor refers to no
   open file or a read request was made to a file that is open only for
   writing.
82 **EREMCHG** 
   Remote address changed.
83 **ELIBACC** 
   Cannot access a needed shared library. Trying to\ **exec** 
   an\ *a.out* that requires a shared library and the shared library
   doesn't exist or the user doesn't have permission to use it.
84 **ELIBBAD** 
   Accessing a corrupted shared library. Trying to\ **exec** an\ *a.out* 
   that requires a shared library (to be linked in) and\ **exec** could
   not load the shared library. The shared library is probably
   corrupted.
85 **ELIBSCN** 
   **.lib** section in\ *a.out* corrupted Trying to\ **exec** 
   an\ *a.out* that requires a shared library (to be linked in) and
   there was erroneous data in the\ **.lib** section of the\ *a.out*.
   The\ **.lib** section tells\ **exec** what shared libraries are
   needed. The\ *a.out* is probably corrupted.
86 **ELIBMAX** 
   Attempting to link in more shared libraries than system limit. Trying
   to\ **exec** an\ *a.out* that requires more static shared libraries
   than is allowed on the current configuration of the system.
87 **ELIBEXEC** 
   Cannot\ **exec** a shared library directly. Attempting to\ **exec** a
   shared library directly.
88 **EILSEQ** 
   Illegal byte sequence. Handle multiple characters as a single
   character.
89 **ENOSYS** 
   Operation not applicable.
90 **ELOOP** 
   Number of symbolic links encountered during path name traversal
   exceeds\ **MAXSYMLINKS** 
91 **ERESTART** 
   Interrupted system call should be restarted.
92 **ESTRPIPE** 
   Streams pipe error (not externally visible).
93 **ENOTEMPTY** 
   Directory not empty.
94 **EUSERS** 
   Too many users. Too many users.
95 **ENOTSOCK** 
   Socket operation on non-socket. Self-explanatory.
96 **EDESTADDRREQ** 
   Destination address required. A required address was omitted from an
   operation on a transport endpoint. Destination address required.
97 **EMSGSIZE** 
   Message too long. A message sent on a transport provider was larger
   than the internal message buffer or some other network limit.
98 **EPROTOTYPE** 
   Protocol wrong type for socket. A protocol was specified that does
   not support the semantics of the socket type requested.
99 **ENOPROTOOPT** 
   Protocol not available. A bad option or level was specified when
   getting or setting options for a protocol.
120 **EPROTONOSUPPORT** 
   Protocol not supported. The protocol has not been configured into the
   system or no implementation for it exists.
121 **ESOCKTNOSUPPORT** 
   Socket type not supported. The support for the socket type has not
   been configured into the system or no implementation for it exists.
122 **EOPNOTSUPP** 
   Operation not supported on transport endpoint. For example, trying to
   accept a connection on a datagram transport endpoint.
123 **EPFNOSUPPORT** 
   Protocol family not supported. The protocol family has not been
   configured into the system or no implementation for it exists. Used
   for the Internet protocols.
124 **EAFNOSUPPORT** 
   Address family not supported by protocol family. An address
   incompatible with the requested protocol was used.
125 **EADDRINUSE** 
   Address already in use. User attempted to use an address already in
   use, and the protocol does not allow this.
126 **EADDRNOTAVAIL** 
   Cannot assign requested address. Results from an attempt to create a
   transport endpoint with an address not on the current machine.
127 **ENETDOWN** 
   Network is down. Operation encountered a dead network.
128 **ENETUNREACH** 
   Network is unreachable. Operation was attempted to an unreachable
   network.
129 **ENETRESET** 
   Network dropped connection because of reset. The host you were
   connected to crashed and rebooted.
130 **ECONNABORTED** 
   Software caused connection abort. A connection abort was caused
   internal to your host machine.
131 **ECONNRESET** 
   Connection reset by peer. A connection was forcibly closed by a peer.
   This normally results from a loss of the connection on the remote
   host due to a timeout or a reboot.
132 **ENOBUFS** 
   No buffer space available. An operation on a transport endpoint or
   pipe was not performed because the system lacked sufficient buffer
   space or because a queue was full.
133 **EISCONN** 
   Transport endpoint is already connected. A connect request was made
   on an already connected transport endpoint; or, a\ **sendto** 
   or\ **sendmsg** request on a connected transport endpoint specified a
   destination when already connected.
134 **ENOTCONN** 
   Transport endpoint is not connected. A request to send or receive
   data was disallowed because the transport endpoint is not connected
   and (when sending a datagram) no address was supplied.
143 **ESHUTDOWN** 
   Cannot send after transport endpoint shutdown. A request to send data
   was disallowed because the transport endpoint had already been shut
   down.
144 **ETOOMANYREFS** 
   Too many references: cannot splice.
145 **ETIMEDOUT** 
   Connection timed out. A connect or send request failed because the
   connected party did not properly respond after a period of time. (The
   timeout period is dependent on the communication protocol.)
146 **ECONNREFUSED** 
   Connection refused. No connection could be made because the target
   machine actively refused it. This usually results from trying to
   connect to a service that is inactive on the remote host.
147 **EHOSTDOWN** 
   Host is down. A transport provider operation failed because the
   destination host was down.
148 **EHOSTUNREACH** 
   No route to host. A transport provider operation was attempted to an
   unreachable host.
149 **EALREADY** 
   Operation already in progress. An operation was attempted on a
   non-blocking object that already had an operation in progress.
150 **EINPROGRESS** 
   Operation now in progress. An operation that takes a long time to
   complete (such as a\ **connect**) was attempted on a non-blocking
   object.
151 **ESTALE** 
   Stale NFS file handle.
152 **ENOLOAD** 
   Cannot load required module. An attempt made to load a module failed.
153 **ERELOC** 
   Relocation error in loading module. Symbolic referencing error.
154 **ENOMATCH** 
   No symbol is found matching the given spec.
156 **EBADVER** 
   Version number mis-matched. The version number associated with a
   module is not supported by the kernel.
157 **ECONFIG** 
   Configured kernel resource exhausted.
158 **ECANCELLED** 
   Asynchronous I/O cancelled.

--------------

/3. File and device input/output
=================================

This section discusses the SCO OpenServer (UNIX System V) file and
record locking facility. Mandatory and advisory file and record locking
are both available on current releases of the SCO OpenServer System. The
intent of this capability is to provide a synchronization mechanism for
programs accessing the same stores of data simultaneously. Such
processing is characteristic of many multiuser applications, and the
need for a standard method of dealing with the problem has been
recognized by standards advocates like */usr/group*, an organization of
SCO OpenServer System users from businesses and campuses across the
country.

Advisory file and record locking can be used to coordinate
self-synchronizing processes. In mandatory locking, the standard I/O
subroutines and I/O system calls enforce the locking protocol. In this
way, at the cost of a little efficiency, mandatory locking double checks
the programs against accessing the data out of sequence.

Also included in this section is a description of how file and record
locking capabilities can be used. Examples are given for the correct use
of record locking. Misconceptions about the amount of protection that
record locking affords are dispelled. Record locking should be viewed as
a synchronization mechanism, not a security mechanism.

The remainder of this section describes the STREAMS mechanism as it
relates to input/output operations.

--------------

/Input/output system calls
==========================

The lowest level of I/O in UNIX System V provides no buffering or other
such services, but it offers the most control over what happens. System
calls that represent direct entries into the UNIX System V kernel
control all user I/O. UNIX System V keeps the system calls that do I/O
simple, uniform and regular to eliminate differences between files,
devices and styles of access. The same read and write system calls apply
to ordinary disk files and I/O devices such as terminals, tape-drives
and line-printers. They do not distinguish between \``random'' and
\``sequential'' I/O, nor do they impose any logical record size on
files. Thus, a single, uniform interface handles all communication
between programs and peripheral devices, and programmers can defer
specifying devices from program-development until program-execution
time.

All I/O is done by reading or writing files, because all peripheral I/O
devices, even a user's terminal, are files in the file system. Each
supported device has an entry in the file system hierarchy, so that
device names have the same structure as filenames, and the same
protection mechanisms work on both devices and files.

A file is an ordered set of bytes of data on a I/O-device. The size of
the file on input is determined by an end-of-file condition dependent on
device-specific characteristics. The size of a regular file is
determined by the position and number of bytes written on it, no
predetermination of the size of a file is necessary or possible.

Besides the traditionally available devices, names exist for disk
devices regarded as physical units outside the file system, and for
absolutely addressed memory. The most important device in practice is
the user's terminal. Treating a communication-device in the same way as
any file by using the same I/O calls make it easy to redirect the input
and output of commands from the terminal to another file; although, some
differences are inevitable. For example, UNIX System V ordinarily treats
terminal input in units of lines because character-erase and line-delete
processing cannot be completed until a full line is typed. Programs
trying to read some large number of bytes from a terminal must wait
until a full line is typed, and then may be notified that some smaller
number of bytes were actually read. All programs must prepare for this
eventuality in any case, because a read from any disk file returns fewer
bytes than requested when it reaches the end of the file. Ordinarily,
reads from a terminal are fully compatible with reads from a disk file.

--------------

/File descriptors
=================

SCO OpenServer System V File and Device I/O functions denote a file by a
small positive integer called a \``file-descriptor'' and declared as
follows: 

::

      int fildes

where **fildes** represents the file-descriptor, and the file-descriptor
denotes an open file from which data is read or onto which data is
written. UNIX System V maintains all information about an open file; the
user program refers to the file only by the file-descriptor. Any I/O on
the file uses the file-descriptor instead of the filename to denote the
file.

Multiple file-descriptors may denote the same file, and each
file-descriptor has associated with it information used to do I/O on the
file: 

-  a file-offset that shows which byte in the file to read or write
   next;
-  file-status and access-modes (e.g., \``read'', \``write'',
   \``read/write'') (see `open\ (S) <../man/html.S/open.S.html>`__);
-  the \`close-on-exec' flag (see `fcntl\ (S) <../man/html.S/fcntl.S.html>`__).

Doing I/O on the user's terminal occurs commonly enough that special
arrangements make this convenient. When the command interpreter (the
\``shell'') runs a program, it opens three files, called the *standard
input*, the *standard output* and the *standard error output*, with
file-descriptors **0**, **1** and **2**. All of these are normally
connected to the terminal; thus, a program reading file-descriptor **0**
and writing file-descriptors **1** and **2**, can do terminal I/O
without opening the files. If I/O is redirected to and from files with
*<* and *>*, as in: 

::

   prog <infile >outfile

the shell changes the default assignments for file-descriptors **0** and
**1** from the terminal to the named files. Similar conventions hold for
I/O on a pipe. Normally file-descriptor **2** remains attached to the
terminal, so error messages can go there. In all cases, the shell
changes the file assignments, the program does not. The program can
ignore where its output goes, as long as it uses file-descriptor **0**
for input and **1** and **2** for output.

--------------

/Reading and writing files
==========================

The functions **read** and **write** do I/O on files. For both, the
first argument is a file-descriptor, the second argument is a buffer in
the user program where the data comes from or goes to and the third
argument is the number of bytes of data to transfer. Each call returns a
count of the number of bytes actually transferred. These calls look
like: 

::

   n = read(fildes, buffer, count);

   n = write(fildes, buffer, count);

   n = readv(fildes, iov, iovcnt);

   n = writev(fildes, iov, iovcnt);

Up to **count** bytes are transferred between the file denoted by
**fildes** and the byte array pointed to by **buffer**. The returned
value **n** is the number of bytes actually transferred.

For writing, the returned value is the number of bytes actually written;
it is generally an error if this fails to equal the number of bytes
requested. In the **write** case, **n** is the same as **count** except
under exceptional conditions, such as I/O errors or end of physical
medium on special files; in a **read**, however, **n** may without error
be less than **count**.

**writev** performs the same action as **write**, but gathers the output
data from the **iovcnt** buffers specified by the members of the **iov**
array: **iov[0]**, **iov[1]**, . . ., **iov [iovcnt-1]**. The **iovcnt**
is valid only if greater than 0, and less than or equal to
{**IOV_MAX**}.

Each *iovec* entry specifies the base address and length of an area in
memory from which data should be written. **writev** always writes a
complete area before proceeding to the next.

For reading, the number of bytes returned may be less than the number
requested, because fewer than **count** bytes remained to be read. If
the file-offset is so near the end of the file that reading **count**
characters would cause reading beyond the end, only sufficient bytes are
transferred to reach the end of the file, also, typewriter-like
terminals never return more than one line of input. (When the file is a
terminal, **read** normally reads only up to the next new-line, which is
generally less than what was requested.)

**readv** performs the same action as **read**, but places the input
data into **iovcnt** buffers specified by the members of the **iov**
array: **iov[0]**, **iov[1]**, . . ., **iov [iovcnt-1]**.

Each *iovec* entry specifies the base address and length of an area in
memory where data should be placed. **readv** always fills one buffer
completely before proceeding to the next.

When a **read** call returns with **n** equal to zero, the end of the
file has been reached. For disk files this occurs when the file-offset
equals the current size of the file. It is possible to generate an
end-of-file from a terminal by use of an escape sequence that depends on
the device used. The function **read** returns **0** to signify
end-of-file, and returns **-1** to signify an error.

The number of bytes to be read or written is quite arbitrary. The two
most common values are **1**, which means one character at a time
(\``unbuffered''), and **512**, which corresponds to a physical block
size on many peripheral devices. This latter size is most efficient, but
even character at a time I/O is not overly expensive. Bytes written
affect only those parts of a file implied by the position of the
file-offset and the count; no other part of the file is changed. If the
last byte lies beyond the end of the file, the file grows as needed.

A simple program using the **read** and **write** functions to copy its
input to its output can copy anything, since the input and output can be
redirected to any file or device.

::

   #define  BUFSIZE  512

   main()   /* copy input to output */
   {
      char buf[BUFSIZE];
      int  n;

      while ((n = read(0, buf, BUFSIZE)) > 0)
         write( 1, buf, n);
      exit(0);
   }

If the file size is not a multiple of **BUFSIZE**, some **read** will
return a smaller number of bytes to be written by **write**: the next
call to **read** after that will return zero indicating end-of-file.

To see how **read** and **write** can be used to construct higher level
functions like **getchar** and **putchar**, here is an example of
**getchar** which does unbuffered input: 

::

   #define  CMASK   0377  /* for making char's > 0 */

   getchar() /* unbuffered single character input */
   {
      char c;

      return((read(0, &c, 1) > 0) ? c & CMASK : EOF);
   }

The variable **c** must be declared **char**, because **read** accepts a
character pointer. The character returned must be masked with **0377**
to ensure that it is positive; otherwise, sign extension may make it
negative.

The second version of **getchar** does input in big chunks, and hands
out the characters one at a time.

::

   #define  CMASK   0377  /* for making char's > 0 */
   #define  BUFSIZE  512

   getchar()  /* buffered version */
   {
      static char    buf[BUFSIZE];
      static char    *bufp = buf;
      static int     n = 0;

      if (n == 0)  {   /* buffer is empty */
         n = read(0, buf, BUFSIZE);
         bufp = buf;
      }
      return((--n >= 0) ? *bufp++ & CMASK : EOF);
   }

--------------


/Positioning and reading/writing files
======================================

The **pread** and **pwrite** system calls do atomic position-and-read or
write, eliminating the necessity of using a locking mechanism when both
operations are desired and file descriptors are shared. They accomplish
this using a fourth argument, **offset**. The synopsis for these system
calls are as follows: 

::

   n = pread(fildes, buffer, count), offset);

   n = pwrite(fildes, buffer, count), offset);

The **read** or **write** is done as if an **lseek** to **offset** (from
the beginning of the file) were done first. Note that (though the
semantics are analogous) an **lseek** is not actually performed; the
file pointer is not affected by **pread** or **pwrite**. The **read** or
**write** of **n**\ bytes then starts at the specified **offset**.

The atomicity of **pread** and **pwrite** enable processes or threads
that share file descriptors to read or write from a shared file at a
particular **offset** without using a locking mechanism that would be
necessary to achieve the same result in separate **lseek** and **read**
or **write** system call. Atomicity is required as the file pointer is
shared and one thread might move the pointer using **lseek** after
another process completes an **lseek** but prior to the **read** or
**write**.

On success, **pread** returns the number of bytes actually read and
placed in **buf**; **pwrite** will return the number of bytes actually
written from **buf** on success. A value of 0 is returned for **pread**
when an end-of-file has been reached. On failure, **pread** and
**pwrite** return **-1** and set **errno** to identify the error.

--------------

/Opening, creating and closing files
====================================

Other than the default standard input, output and error files, you must
explicitly open files in order to read or write them. The two functions
that do this are: **open** and **creat** (see
`open\ (S) <../man/html.S/open.S.html>`__ and
`creat\ (S) <../man/html.S/creat.S.html>`__). To read or write a file
assumed to exist already, it must be opened by the following call: 

::

   fildes = open(name, oflag);

| The argument **name** is a character string that represents a UNIX
  System V file system pathname. The **oflag** argument indicates
  whether the file is to be read, written, or \``updated'', that is,
  read and written simultaneously. The returned value **fildes** is a
  file-descriptor used to denote the file in subsequent calls that read,
  write or otherwise manipulate the file.

The function **open** resembles the function **fopen** in the Standard
I/O Library, except that instead of returning a pointer to *FILE*,
**open** returns a file-descriptor which is just an *int* (see
`fopen\ (S) <../man/html.S/fopen.S.html>`__ and
`Intro\ (S) <../man/html.S/Intro.S.html>`__). Moreover, the values for
the access mode argument **oflag** are different (the flags are found in
*/usr/include/fcntl.h*): 

-  **O_RDONLY** for read access.
-  **O_WRONLY** for write access.
-  **O_RDWR** for read and write access.

The function **open** returns **-1** if any error occurs; otherwise, it
returns a valid open file-descriptor.

Trying to **open** a file that does not exist causes an error; hence,
**creat** is used to create new files, or to re-write old ones. The
**creat** system call creates the given file if it does not exist, or
truncates it to zero length if it does exist; **creat** also opens the
new file for writing and, like **open**, returns a file-descriptor.
Calling **creat** as follows: 

::

   fildes = creat(name, pmode);

returns a file-descriptor if it created the file identified by the
string *name*, and **-1** if it did not. Trying to **creat** a file that
already exists does not cause an error, but if the file already exists,
**creat** truncates it to zero length.

| If the file is brand new, **creat** creates it with the protection
  mode specified by the **pmode** argument. The UNIX System V file
  system associates nine bits of protection information with a file,
  controlling \``read'', \``write'' and \``execute'' permission for the
  \``owner'' of the file, for the owner's \``group'', and for any
  \``other'' users. Thus, a three-digit octal number specifies the
  permissions most conveniently. For example, **0755** specifies
  \``read'', \``write'' and \``execute'' permission for the \``owner'',
  and \``read'' and \``execute'' permission for the \``group'' and all
  \``other'' users.

A simplified version of the UNIX System V utility **cp** (a program
which copies one file to another) illustrates this: 

::

   #define  NULL 0
   #define  BUFSIZE 512
   #define  PMODE 0644 /* RW owner, R group & others */

   main(argc, argv)    /* cp: copy fd1 to fd2 */
      int argc;
      char *argv[ ];
   {
      int  fd1, fd2, n;
      char buf[BUFSIZE];

      if (argc != 3)
         error("Usage: cp from to", NULL);
      if ((fd1 = open(argv[1], 0)) == -1)
         error("cp: can't open %s", argv[1]);
      if ((fd2 = creat(argv[2], PMODE)) == -1)
         error("cp: can't create %s", argv[2]);

      while ((n = read(fd1, buf, BUFSIZE)) > 0)
         if (write(fd2, buf, n) != n)
            error("cp: write error", NULL);

      exit(0);
   }

   error(s1, s2)  /* print error message and die */
      char *s1, *s2;
   {
      printf(s1, s2);
      printf("\n");

      exit(1);
   }

**Simplified version of cp**

| The main simplification is that this version copies only one file, and
  does not permit the second argument to be a directory.

As stated earlier, there is a limit, **OPEN_MAX**, on the number of
files which a process may have open simultaneously. Accordingly, any
program which intends to process many files must be prepared to re-use
file-descriptors. The function **close** breaks the connection between a
file-descriptor and an open file, and frees the file-descriptor for use
with some other file. Termination of a program via **exit** or return
from the main program closes all open files.

--------------


/Random access -- lseek
=======================

Normally, file I/O is sequential: each **read** or **write** proceeds
from the point in the file right after the previous one. This means that
if a particular byte in the file was the last byte written (or read),
the next I/O call implicitly refers to the immediately following byte.
For each open file, UNIX System V maintains a file-offset that indicates
the next byte to be read or written. If **n** bytes are read or written,
the file-offset advances by **n** bytes. When necessary, however, a file
can be read or written in any arbitrary order using **lseek** to move
around in a file without actually reading or writing.

To do random (direct-access) I/O it is only necessary to move the
file-offset to the appropriate location in the file with a call to
**lseek**. Calling **lseek** as follows: 

::

   lseek(fildes, offset, whence);

or as follows: 

::

   location = lseek(fildes, offset, whence);

| forces the current position in the file denoted by file-descriptor
  **fildes** to move to position **offset** as specified by **whence**.
  Subsequent reading or writing begins at the new position. The
  file-offset associated with **fildes** is moved to a position
  **offset** bytes from the beginning of the file, from the current
  position of the file-offset or from the end of the file, depending on
  **whence**; **offset** may be negative. For some devices (e.g., paper
  tape and terminals) **lseek** calls are ignored. The value of
  **location** equals the actual offset from the beginning of the file
  to which the file-offset was moved. The argument **offset** is of type
  **off_t** defined by the header file *<types.h>* as a **long**;
  **fildes** and **whence** are **int**'s.
| The argument **whence** can be **SEEK_SET**, **SEEK_CUR** or
  **SEEK_END** to specify that **offset** is to be measured from the
  beginning, from the current position, or from the end of the file
  respectively. For example, to append a file, seek to the end before
  writing: 

::

   lseek(fildes, 0L, SEEK_END);

To get back to the beginning (\``rewind''), 

::

   lseek(fildes, 0L, SEEK_SET);

Notice the **0L** argument; it could also be written as **(long) 0**.

With **lseek**, you can treat files more or less like large arrays, at
the price of slower access. For example, the following simple function
reads any number of bytes from any arbitrary point in a file: 

::

   get(fd, p, buf, n) /* read n bytes from position p */
      int fd, n;
      long p;
      char *buf;
   {
      lseek(fd, p, SEEK_SET);  /* move to p */
      return(read(fd, buf, n));
   }

--------------


/File and record locking
========================

Mandatory and advisory file and record locking both are available on
current releases of the UNIX system. The intent of this capability to is
provide a synchronization mechanism for programs accessing the same
stores of data simultaneously. Such processing is characteristic of many
multiuser applications, and the need for a standard method of dealing
with the problem has been recognized by standards advocates like
**/usr/group**, an organization of UNIX system users from businesses and
campuses across the country.

Advisory file and record locking can be used to coordinate
self-synchronizing processes. In mandatory locking, the standard I/O
subroutines and I/O system calls enforce the locking protocol. In this
way, at the cost of a little efficiency, mandatory locking double checks
the programs against accessing the data out of sequence.

The remainder of this section describes how file and record locking
capabilities can be used. Examples are given for the correct use of
record locking. Misconceptions about the amount of protection that
record locking affords are dispelled. Record locking should be viewed as
a synchronization mechanism, not a security mechanism.

The manual pages for the **fcntl** system call, the **lockf** library
function, and **fcntl** data structures and commands are referred to
throughout this section (see `fcntl\ (M) <../man/html.M/fcntl.M.html>`__). 
You should read them before continuing.

--------------


/Terminology
============

Before discussing how to use record locking, let us first define a few
terms.

Record
   A contiguous set of bytes in a file. The UNIX operating system does
   not impose any record structure on files. This may be done by the
   programs that use the files.
Cooperating Processes
   Processes that work together in some well-defined fashion to
   accomplish the tasks at hand. Processes that share files must request
   permission to access the files before using them. File access
   permissions must be carefully set to restrict noncooperating
   processes from accessing those files. The term process will be used
   interchangeably with cooperating process to refer to a task obeying
   such protocols.
Read (Share) Locks
   These are used to gain limited access to sections of files. When a
   read lock is put on a record, other processes may also read lock that
   record, in whole or in part. No other process, however, may have or
   obtain a write lock on an overlapping section of the file. If a
   process holds a read lock it may assume that no other process will be
   writing or updating that record at the same time. This access method
   also lets many processes read the given record. This might be
   necessary when searching a file, without the contention involved if a
   write or exclusive lock were used.
Write (Exclusive) Locks
   These are used to gain complete control over sections of files. When
   a write lock is put on a record, no other process may read or write
   lock that record, in whole or in part. If a process holds a write
   lock it may assume that no other process will be reading or writing
   that record at the same time.
Advisory Locking
   A form of record locking that does not interact with the I/O
   subsystem. Advisory locking is not enforced, for example, by
   **creat**, **open**, **read**, or **write**. The control over records
   is accomplished by requiring an appropriate record lock request
   before I/O operations. If appropriate requests are always made by all
   processes accessing the file, then the accessibility of the file will
   be controlled by the interaction of these requests. Advisory locking
   depends on the individual processes to enforce the record locking
   protocol; it does not require an accessibility check at the time of
   each I/O request.
Mandatory Locking
   A form of record locking that does interact with the I/O subsystem.
   Access to locked records is enforced by the **creat**, **open**,
   **read** and **write** system calls. If a record is locked, then
   access of that record by any other process is restricted according to
   the type of lock on the record. The control over records should still
   be performed explicitly by requesting an appropriate record lock
   before I/O operations, but an additional check is made by the system
   before each I/O operation to ensure the record locking protocol is
   being honored. Mandatory locking offers an extra synchronization
   check, but at the cost of some additional system overhead.

--------------


/File protection
================

There are access permissions for UNIX system files to control who may
read, write, or execute such a file. These access permissions may only
be set by the owner of the file or by a process with the appropriate
privilege. The permissions of the directory in which the file resides
can also affect the ultimate disposition of a file. Note that if the
directory permissions allow anyone to write in it, then files within the
directory may be removed, even if those files do not have read, write or
execute permission for that user. Any information that is worth
protecting, is worth protecting properly. If your application warrants
the use of record locking, make sure that the permissions on your files
and directories are set properly. A record lock, even a mandatory record
lock, will only protect the portions of the files that are locked. Other
parts of these files might be corrupted if proper precautions are not
taken.

Only a known set of programs and/or administrators should be able to
read or write a data base. This can be done easily by setting the
set-group-ID bit of the data base accessing programs (see
`chmod\ (C) <../man/html.C/chmod.C.html>`__). The files can then be
accessed by a known set of programs that obey the record locking
protocol. An example of such file protection, although record locking is
not used, is the **mail** command. In that command only the particular
user and the **mail** command can read and write in the unread mail
files.

--------------


/Opening a file for record locking
==================================

The first requirement for locking a file or segment of a file is having
a valid open file descriptor. If read locks are to be done, then the
file must be opened with at least read accessibility, and with write
accessibility for write locks.

--------------

**NOTE:** Mapped files cannot be locked: if a file has been mapped, any
attempt to use file or record locking on the file fails. See
**mmap**\ (S).

--------------

For our example we will open our file for both read and write access: 

::

   #include <stdio.h>
   #include <errno.h>
   #include <fcntl.h>

   int fd;     /* file descriptor */
   char *filename;

   main(argc, argv)
   int argc;
   char *argv[];
   {
         extern void exit(), perror();

         /* get data base file name from command line and open the
          * file for read and write access.
          */
         if (argc < 2) {
              (void) fprintf(stderr, "usage: %s filename\n", argv[0]);
              exit(2);
          }
         filename = argv[1];
         fd = open(filename, O_RDWR);
         if (fd < 0) {
              perror(filename);
              exit(2);
              }
         .
         .
         .

The file is now open for us to perform both locking and I/O functions.
We then proceed with the task of setting a lock.

--------------

/Setting a file lock
====================

There are several ways for us to set a lock on a file. In part, these
methods depend on how the lock interacts with the rest of the program.
There are also questions of performance as well as portability. Two
methods will be given here, one using the **fcntl** system call, the
other using the **/usr/group** standards compatible **lockf** library
function call.

Locking an entire file is just a special case of record locking. For
both these methods the concept and the effect of the lock are the same.
The file is locked starting at a byte offset of zero (0) until the end
of the maximum file size. This point extends beyond any real end of the
file so that no lock can be placed on this file beyond this point. To do
this the value of the size of the lock is set to zero. The code using
the **fcntl** system call is as follows: 

::

      #include <fcntl.h>
      #define MAX_TRY  10
      int try;
      struct flock lck;
      
      try = 0;
      
      /* set up the record locking structure, the address of which
       * is passed to the fcntl system call.
       */
      lck.l_type = F_WRLCK;   /* setting a write lock */
      lck.l_whence = 0;       /* offset l_start from beginning of file */
      lck.l_start = 0L;
      lck.l_len = 0L;         /* until the end of the file address space */
      
      /* Attempt locking MAX_TRY times before giving up.
       */
      while (fcntl(fd, F_SETLK, &lck) < 0) {
              if (errno == EAGAIN || errno == EACCES) {
                      /* there might be other errors cases in which
                       * you might try again.
                       */
                      if (++try < MAX_TRY) {
                              (void) sleep(2);
                              continue;
                      }
                      (void) fprintf(stderr,"File busy try again later!\n");
                      return;
              }
              perror("fcntl");
              exit(2);
      }
              .
              .
              .

This portion of code tries to lock a file. This is attempted several
times until one of the following things happens: 

-  the file is locked
-  an error occurs
-  it gives up trying because **MAX_TRY** has been exceeded

To perform the same task using the **lockf** function, the code is as
follows: 

::

      #include <unistd.h>
      #define MAX_TRY  10
      int try;
      try = 0;
      
      /* make sure the file pointer
       * is at the beginning of the file.
       */
      lseek(fd, 0L, 0);
       
      /* Attempt locking MAX_TRY times before giving up.
       */
      while (lockf(fd, F_TLOCK, 0L) < 0) {
       if (errno == EAGAIN || errno == EACCES) {
           /* there might be other errors cases in which
            * you might try again.
            */
           if (++try < MAX_TRY) {
               sleep(2);
               continue;
           }
           (void) fprintf(stderr,"File busy try again later!\n");
           return;
       }
       perror("lockf");
       exit(2);
      }
       .
       .
       .

It should be noted that the **lockf** example appears to be simpler, but
the **fcntl** example exhibits additional flexibility. Using the
**fcntl** method, it is possible to set the type and start of the lock
request simply by setting a few structure variables. **lockf** merely
sets write (exclusive) locks; an additional system call, **lseek**, is
required to specify the start of the lock.

--------------

/Setting and removing record locks
==================================

Locking a record is done the same way as locking a file except for the
differing starting point and length of the lock. We will now try to
solve an interesting and real problem. There are two records (these
records may be in the same or different file) that must be updated
simultaneously so that other processes get a consistent view of this
information. (This type of problem comes up, for example, when updating
the interrecord pointers in a doubly linked list.) To do this you must
decide the following questions: 

-  What do you want to lock?
-  For multiple locks, in what order do you want to lock and unlock the
   records?
-  What do you do if you succeed in getting all the required locks?
-  What do you do if you fail to get all the locks?

In managing record locks, you must plan a failure strategy if you cannot
obtain all the required locks. It is because of contention for these
records that we have decided to use record locking in the first place.
Different programs might: 

-  wait a certain amount of time, and try again
-  abort the procedure and warn the user
-  let the process sleep until signaled that the lock has been freed
-  some combination of the above

Let us now look at our example of inserting an entry into a doubly
linked list. For the example, we will assume that the record after which
the new record is to be inserted has a read lock on it already. The lock
on this record must be changed or promoted to a write lock so that the
record may be edited.

Promoting a lock (generally from read lock to write lock) is permitted
if no other process is holding a read lock in the same section of the
file. If there are processes with pending write locks that are sleeping
on the same section of the file, the lock promotion succeeds and the
other (sleeping) locks wait. Promoting (or demoting) a write lock to a
read lock carries no restrictions. In either case, the lock is merely
reset with the new lock type. Because the **/usr/group** **lockf**
function does not have read locks, lock promotion is not applicable to
that call. An example of record locking with lock promotion follows: 

::

      struct record {
       .
       .   /* data portion of record */
       .
       long prev;  /* index to previous record in the list */
       long next;  /* index to next record in the list */
      };
      
      /* Lock promotion using fcntl(S)
       * When this routine is entered it is assumed that there are read
       * locks on "here" and "next".
       * If write locks on "here" and "next" are obtained: 
       *    Set a write lock on "this".
       *    Return index to "this" record.
       * If any write lock is not obtained: 
       *    Restore read locks on "here" and "next".
       *    Remove all other locks.
       *    Return a -1.
       */
      long
      set3lock (this, here, next)
      long this, here, next;
      {
       struct flock lck;
      
       lck.l_type = F_WRLCK;   /* setting a write lock */
       lck.l_whence = 0;       /* offset l_start from beginning of file */
       lck.l_start = here;
       lck.l_len = sizeof(struct record);
      
       /* promote lock on "here" to write lock */
       if (fcntl(fd, F_SETLKW, &lck) < 0) {
              return (-1);
       }
       /* lock "this" with write lock */
       lck.l_start = this;
       if (fcntl(fd, F_SETLKW, &lck) < 0) {
              /* Lock on "this" failed;
               * demote lock on "here" to read lock.
               */
              lck.l_type = F_RDLCK;
              lck.l_start = here;
              (void) fcntl(fd, F_SETLKW, &lck);
              return (-1);
       }
       /* promote lock on "next" to write lock */
       lck.l_start = next;
       if (fcntl(fd, F_SETLKW, &lck) < 0) {
              /* Lock on "next" failed;
               * demote lock on "here" to read lock,
               */
               lck.l_type = F_RDLCK;
           lck.l_start = here;
               (void) fcntl(fd, F_SETLK, &lck);
               /* and remove lock on "this".
                */
               lck.l_type = F_UNLCK;
               lck.l_start = this;
               (void) fcntl(fd, F_SETLK, &lck);
               return (-1);    /* cannot set lock, try again or quit */
       }
      
       return (this);
      }

The locks on these three records were all set to wait (sleep) if another
process was blocking them from being set. This was done with the
**F_SETLKW** command. If the **F_SETLK** command was used instead, the
**fcntl** system calls would fail if blocked. The program would then
have to be changed to handle the blocked condition in each of the error
return sections.

Let us now look at a similar example using the **lockf** function. Since
there are no read locks, all (write) locks will be referenced
generically as locks.

::

      /* Lock promotion using lockf(3)
       * When this routine is entered it is assumed that there are
       * no locks on "here" and "next".
       * If locks are obtained: 
       *    Set a lock on "this".
       *    Return index to "this" record.
       * If any lock is not obtained: 
       *    Remove all other locks.
       *    Return a -1.
       */
      
      #include <unistd.h>
      
      long
      set3lock (this, here, next)
      long this, here, next;
      
      {
      
       /* lock "here" */
       (void) lseek(fd, here, 0);
       if (lockf(fd, F_LOCK, sizeof(struct record)) < 0) {
           return (-1);
       }
       /* lock "this" */
       (void) lseek(fd, this, 0);
       if (lockf(fd, F_LOCK, sizeof(struct record)) < 0) {
           /* Lock on "this" failed.
            * Clear lock on "here".
            */
           (void) lseek(fd, here, 0);
           (void) lockf(fd, F_ULOCK, sizeof(struct record));
           return (-1);
      
       }
      
       /* lock "next" */
       (void) lseek(fd, next, 0);
       if (lockf(fd, F_LOCK, sizeof(struct record)) < 0) {
      
           /* Lock on "next" failed.
            * Clear lock on "here",
            */
           (void) lseek(fd, here, 0);
           (void) lockf(fd, F_ULOCK, sizeof(struct record));
      
           /* and remove lock on "this".
            */
           (void) lseek(fd, this, 0);
           (void) lockf(fd, F_ULOCK, sizeof(struct record));
           return (-1);    /* cannot set lock, try again or quit */
      
       }
      
       return (this);
      }

Locks are removed in the same manner as they are set, only the lock type
is different (**F_UNLCK** or **F_ULOCK**). An unlock cannot be blocked
by another process and will only affect locks that were placed by this
process. The unlock only affects the section of the file defined in the
previous example by **lck**. It is possible to unlock or change the type
of lock on a subsection of a previously set lock. This may cause an
additional lock (two locks for one system call) to be used by the
operating system. This occurs if the subsection is from the middle of
the previously set lock.

--------------


/Getting lock information
=========================

You can determine which processes, if any, are blocking a lock from
being set. This can be used as a simple test or as a means to find locks
on a file. A lock is set up as in the previous examples and the
**F_GETLK** command is used in the **fcntl** call. If the lock passed to
**fcntl** would be blocked, the first blocking lock is returned to the
process through the structure passed to **fcntl**. That is, the lock
data passed to **fcntl** is overwritten by blocking lock information.
This information includes two pieces of data that have not been
discussed yet, **l_pid** and **l_sysid**, that are only used by
**F_GETLK**. (For systems that do not support a distributed architecture
the value in **l_sysid** should be ignored.) These fields uniquely
identify the process holding the lock.

If a lock passed to **fcntl** using the **F_GETLK** command would not be
blocked by another process's lock, then the **l_type** field is changed
to **F_UNLCK** and the remaining fields in the structure are unaffected.
Let us use this capability to print all the segments locked by other
processes. Note that if there are several read locks over the same
segment only one of these will be found.

::

      struct flock lck;
      
      /* Find and print "write lock" blocked segments of this file. */
       (void) printf("sysid   pid type    start   length\n");
       lck.l_start = 0L;
       do {
           lck.l_whence = 0;
           lck.l_len = 0L;
           lck.l_type = F_WRLCK;
           (void) fcntl(fd, F_GETLK, &lck);
           if (lck.l_type != F_UNLCK) {
               (void) printf("%5d %5d   %c  %8d %8d\n",
                   lck.l_sysid,
                   lck.l_pid,
                   (lck.l_type == F_WRLCK) ? 'W' : 'R',
                   lck.l_start,
                   lck.l_len);
               /* if this lock goes to the end of the address
                * space, no need to look further, so break out.
                */
               if (lck.l_len == 0)
                   break;
               /* otherwise, look for new lock after the one
                * just found.
                */
               lck.l_start += lck.l_len;
           }
       } while (lck.l_type != F_UNLCK);

**fcntl** with the **F_GETLK** command will always return correctly
(that is, it will not sleep or fail), if the values passed to it as
arguments are valid.

Note that the statement: 

::

      lck.l_whence = 0;

is not strictly necessary within the loop, since the **F_GETLK** command
always returns ``l_whence`` set to **SEEK_SET** (defined as 0) for the
blocking lock.

The **lockf** function with the **F_TEST** command can also be used to
test if there is a process blocking a lock. This function does not,
however, return the information about where the lock actually is and
which process owns the lock. A routine using **lockf** to test for a
lock on a file follows: 

::

      /* find a blocked record. */
      /* seek to beginning of file */
      (void) lseek(fd, 0, 0L);
      /* set the size of the test region to zero (0)
       * to test until the end of the file address space.
       */
      if (lockf(fd, F_TEST, 0L) < 0) {
       switch (errno) {
           case EACCES: 
           case EAGAIN: 
           (void) printf("file is locked by another process\n");
           break;
           case EBADF: 
           /* bad argument passed to lockf */
           perror("lockf");
           break;
           default: 
           (void) printf("lockf: unknown error <%d>\n", errno);
           break;
           }
       }

When a process forks, the child receives a copy of the file descriptors
that the parent has opened. The parent and child also share a common
file pointer for each file. If the parent were to seek to a point in the
file, the child's file pointer would also be at that location. This
feature has important implications when using record locking. The
current value of the file pointer is used as the reference for the
offset of the beginning of the lock, as described by **l_start**, when
using a **l_whence** value of **1**. If both the parent and child
process set locks on the same file, there is a possibility that a lock
will be set using a file pointer that was reset by the other process.
This problem appears in the **lockf** function call as well and is a
result of the **/usr/group** requirements for record locking. If forking
is used in a record locking program, the child process should close and
reopen the file if either locking method is used. This will result in
the creation of a new and separate file pointer that can be manipulated
without this problem occurring. Another solution is to use the **fcntl**
system call with a **l_whence** value of **0** or **2**. This makes the
locking function atomic, so that even processes sharing file pointers
can be locked without difficulty.

--------------


/Deadlock handling
==================

There is a certain level of deadlock detection/avoidance built into the
record locking facility. This deadlock handling provides the same level
of protection granted by the **/usr/group** standard **lockf** call.
This deadlock detection is only valid for processes that are locking
files or records on a single system. Deadlocks can only potentially
occur when the system is about to put a record locking system call to
sleep. A search is made for constraint loops of processes that would
cause the system call to sleep indefinitely. If such a situation is
found, the locking system call will fail and set **errno** to the
deadlock error number. If a process wishes to avoid the use of the
system's deadlock detection, it should set its locks using **F_SETLK**
instead of **F_SETLKW**.

--------------

/Selecting advisory or mandatory locking
========================================

The use of mandatory locking is not recommended for reasons that will be
made clear in a subsequent section. Whether or not locks are enforced by
the I/O system calls is determined at the time the calls are made by the
permissions on the file (see
`chmod\ (S) <../man/html.S/chmod.S.html>`__). For locks to be under
mandatory enforcement, the file must be a regular file with the
set-group-ID bit on and the group execute permission off. If either
condition fails, all record locks are advisory. Mandatory enforcement
can be assured by the following code: 

::

      #include <sys/types.h>
      #include <sys/stat.h>
      
      int mode;
      struct stat buf;
           .
           .
           .
       if (stat(filename, &buf) < 0) {
           perror("program");
           exit (2);
       }
       /* get currently set mode */
       mode = buf.st_mode;
       /* remove group execute permission from mode */
       mode &= ~(S_IEXEC>>3);
       /* set 'set group id bit' in mode */
       mode |= S_ISGID;
       if (chmod(filename, mode) < 0) {
           perror("program");
           exit(2);
       }
           .
           .
           .

Files that are to be record locked should never have any type of execute
permission set on them. This is because the operating system does not
obey the record locking protocol when executing a file.

The `chmod\ (C) <../man/html.C/chmod.C.html>`__ command can also be
easily used to set a file to have mandatory locking. This can be done
with the command: 

::

      chmod +l file

The `ls\ (C) <../man/html.C/ls.C.html>`__ command shows this setting
when you ask for the long listing format: 

::

      ls -l file

| causes the following to be printed: 
| -rw---l--- 1 **user** **group** **size** **mod_time** **file**

Advisory versus mandatory locking
---------------------------------

Note the following points when choosing whether to implement advisory or
mandatory locking: 

-  Mandatory locking only protects those portions of a file that are
   locked. Other portions of the file that are not locked may be
   accessed according to normal UNIX system file permissions.
-  If multiple reads or writes are necessary for an atomic transaction,
   the process should explicitly lock all such pieces before any I/O
   begins. Thus advisory enforcement is sufficient for all programs that
   perform in this way.
-  As stated earlier, arbitrary programs should not have unrestricted
   access permission to files that are important enough to record lock.
-  Advisory locking is more efficient because a record lock check does
   not have to be performed for every I/O request.

--------------


/Record locking and future releases of the UNIX system
======================================================

Provisions have been made for file and record locking in a UNIX system
environment. In such an environment the system on which the locking
process resides may be remote from the system on which the file and
record locks reside. In this way multiple processes on different systems
may put locks upon a single file that resides on one of these or yet
another system. The record locks for a file reside on the system that
maintains the file. It is also important to note that deadlock
detection/avoidance is only determined by the record locks being held by
and for a single system. Therefore, it is necessary that a process only
hold record locks on a single system at any given time for the deadlock
mechanism to be effective. If a process needs to maintain locks over
several systems, it is suggested that the process avoid the
sleep-when-blocked features of **fcntl** or **lockf** and that the
process maintain its own deadlock detection. If the process uses the
sleep-when-blocked feature, then a timeout mechanism should be provided
by the process so that it does not hang waiting for a lock to be
cleared.

--------------


/Basic STREAMS operations
=========================

This section describes the basic set of operations for manipulating
STREAMS entities.

A STREAMS driver is similar to a traditional character I/O driver in
that it has one or more nodes associated with it in the file system, and
it is accessed using the **open** system call. Typically, each file
system node corresponds to a separate minor device for that driver.
Opening different minor devices of a driver causes separate Streams to
be connected between a user process and the driver. The file descriptor
returned by the **open** call is used for further access to the Stream.
If the same minor device is opened more than once, only one Stream is
created; the first **open** call creates the Stream, and subsequent
**open** calls return a file descriptor that references that Stream.
Each process that opens the same minor device shares the same Stream to
the device driver.

Once a device is opened, a user process can send data to the device
using the **write** system call and receive data from the device using
the **read** system call. Access to STREAMS drivers using **read** and
**write** is compatible with the traditional character I/O mechanism.

The **close** system call closes a device and dismantles the associated
Stream when the last open reference to the Stream is given up.

The following example shows how a simple Stream is used. In the example,
the user program interacts with a communications device that provides
point-to-point data transfer between two computers. Data written to the
device transmitted over the communications line, and data arriving on
the line can be retrieved by reading from the device.

::

      #include <fcntl.h>
      
      main()
      {
       char buf[1024];
       int fd, count;
      
       if ((fd = open("/dev/comm/01", O_RDWR)) < 0) {
           perror("open failed");
           exit(1);
       }
      
       while ((count = read(fd, buf, 1024)) > 0) {
           if (write(fd, buf, count) != count) {
               perror("write failed");
               break;
           }
       }
       exit(0);
      }

In the example, */dev/comm/01* identifies a minor device of the
communications device driver. When this file is opened, the system
recognizes the device as a STREAMS device and connects a Stream to the
driver. `\``Stream to communication
driver'' <FDIO_STMSOps.html#fdio_f2>`__ shows the state of the Stream
following the call to **open**.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog//strtodrv.gif

**Stream to communication driver**

This example illustrates a user reading data from the communications
device and then writing the input back out to the same device. In short,
this program echoes all input back over the communications line. The
example assumes that a user sends data from the other side of the
communications line. The program reads up to 1024 bytes at a time, and
then writes the number of bytes just read.

The **read** call returns the available data, which may contain fewer
than 1024 bytes. If no data is currently available at the Stream head,
the **read** call blocks until data arrive.

Similarly, the **write** call attempts to send **count** bytes to
*/dev/comm/01*. However, STREAMS implements a flow control mechanism
that prevents a user from exhausting system resources by flooding a
device driver with data.

Flow control controls the rate of message transfer among the modules,
drivers, Stream head, and processes. Flow control is local to each
Stream and advisory (voluntary). It limits the number of characters that
can be queued for processing at any queue in a Stream, and limits
buffers and related processing at any queue and in any one Stream, but
does not consider buffer pool levels or buffer usage in other Streams.
Flow control is not applied to high-priority messages.

If the Stream exerts flow control on the user, the **write** call blocks
until flow control is relieved. The call does not return until it has
sent **count** bytes to the device. **exit**, which is called to
terminate the user process, also closes all open files, and thereby
dismantling the Stream in this example.

--------------

/Benefits of STREAMS
====================

STREAMS provides the following benefits: 

-  A flexible, portable, and reusable set of tools for development of
   UNIX system communication services.
-  Easy creation of modules that offer standard data communications
   services and the ability to manipulate those modules on a Stream.
-  From user level, modules can be dynamically selected and
   interconnected; kernel programming, assembly, and link editing are
   not required to create the interconnection.

STREAMS also greatly simplifies the user interface for languages that
have complex input and output requirements.

--------------


/Standardized service interfaces
================================

STREAMS simplifies the creation of modules that present a service
interface to any neighboring application program, module, or device
driver. A service interface is defined at the boundary between two
neighbors. In STREAMS, a service interface is a specified set of
messages and the rules that allow passage of these messages across the
boundary. A module that implements a service interface receives a
message from a neighbor and responds with an appropriate action (for
example, sends back a request to retransmit) based on the specific
message received and the preceding sequence of messages.

In general, any two modules can be connected anywhere in a Stream.
However, rational sequences are generally constructed by connecting
modules with compatible protocol service interfaces. For example, a
module that implements an X.25 protocol layer, as shown in `\``Stream to
communication driver'' <FDIO_STMSOps.html#fdio_f2>`__, presents a
protocol service interface at its input and output sides. In this case,
other modules should only be connected to the input and output side if
they have the compatible X.25 service interface.

--------------

/Manipulating modules
=====================

STREAMS provides the capabilities to manipulate modules from the user
level, to interchange modules with common service interfaces, and to
change the service interface to a STREAMS user process. These
capabilities yield further benefits when implementing networking
services and protocols, including: 

-  User level programs can be independent of underlying protocols and
   physical communication media.
-  Network architectures and higher level protocols can be independent
   of underlying protocols, drivers, and physical communication media.
-  Higher level services can be created by selecting and connecting
   lower level services and protocols.

The following examples show the benefits of STREAMS capabilities for
creating service interfaces and manipulating modules. These examples are
only illustrations and do not necessarily reflect real situations.

Protocol portability
--------------------

`\``X.25 multiplexing stream'' <_Manipulating_Modules.html#fdio_f3>`__
shows how the same X.25 protocol module can be used with different
drivers on different machines by implementing compatible service
interfaces. The X.25 protocol module interfaces are Connection Oriented
Network Service (CONS) and Link Access Protocol - Balanced (LAPB).

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/x25muxst.gif

**X.25 multiplexing stream**

Protocol substitution
---------------------

Alternate protocol modules (and device drivers) can be interchanged on
the same machine if they are implemented to an equivalent service
interface.

Protocol migration
------------------

`\``Protocol migration'' <_Manipulating_Modules.html#fdio_f4>`__
illustrates how STREAMS can move functions between kernel software and
front-end firmware. A common downstream service interface allows the
transport protocol module to be independent of the number or type of
modules below. The same transport module connects without change to
either an X.25 module or X.25 driver that has the same service
interface.

By shifting functions between software and firmware, developers can
produce cost effective, functionally equivalent systems over a wide
range of configurations. They can rapidly incorporate technological
advances. The same transport protocol module can be used on a lower
capacity machine, where economics may preclude the use of front-end
hardware, and also on a larger scale system where a front-end is
economically justified.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/protmig.gif

**Protocol migration**

Module reusability
------------------

`\``Module reusability'' <_Manipulating_Modules.html#fdio_f5>`__ shows
the same canonical module (for example, one that provides delete and
kill processing on character strings) reused in two different Streams.
This module is typically implemented as a filter, with no downstream
service interface. In both cases, a tty interface is presented to the
Stream's user process because the module is nearest to the Stream head.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/modreuse.gif

**Module reusability**

--------------





/STREAMS mechanism
==================

This section shows how to construct, use, and dismantle a Stream using
STREAMS-related systems calls. General and STREAMS-specific system calls
provide the user level facilities required to implement application
programs. This system call interface is upwardly compatible with the
traditional character I/O facilities. The **open** system call
recognizes a STREAMS file and creates a Stream to the specified driver.
A user process can receive and send data on STREAMS files using **read**
and **write** in the same way as with traditional character files. The
**ioctl** system call enables users to perform functions specific to a
particular device. STREAMS **ioctl** commands (see
`streamio\ (M) <../man/html.M/streamio.M.html>`__) support a variety of
functions for accessing and controlling Streams. The last **close** in a
Stream dismantles a Stream.

In addition to the traditional **ioctl** commands and system calls,
there are other system calls used by STREAMS. The **poll** system call
enables a user to poll multiple Streams for various events. The
**putmsg** and **getmsg** system calls enable users to send and receive
STREAMS messages, and are suitable for interacting with STREAMS modules
and drivers through a service interface.

STREAMS provides kernel facilities and utilities to support development
of modules and drivers. The Stream head handles most system calls so
that the related processing does not have to be incorporated in a module
or driver.

--------------

/STREAMS system calls
=====================

The STREAMS-related system calls are as follows: 

**open**
   Open a Stream
**close**
   Close a Stream
**read**
   Read data from a Stream
**write**
   Write data to a Stream
**ioctl**
   Control a Stream
**getmsg**
   Receive a message at the Stream head
**putmsg**
   Send a message downstream
**poll**
   Notify the application program when selected events occur on a Stream
**pipe**
   Create a channel that provides a communication path between multiple
   processes

A STREAMS device responds to the standard character I/O system calls,
such as **read** and **write**, by turning the request into a message.
This feature ensures that STREAMS devices may be accessed from the user
level in the same manner as non-STREAMS character devices. However,
additional system calls provide other capabilities.

getmsg and putmsg
-----------------

The **putmsg** and **getmsg** system calls enable a user process to send
and receive STREAMS messages, in the same form the messages have in
kernel modules and drivers. **read** and **write** are not designed to
include the message boundaries necessary to encode messages.

The advantage of this capability is that a user process, as well as a
STREAMS module or driver, can implement a service interface.

poll
----

The **poll** system call allows a user process to monitor a number of
streams to detect expected I/O events. Such events might be the
availability of a device for writing, input data arriving from a device,
a hangup occurring, an error being detected, or the arrival of a
priority message. See `poll\ (S) <../man/html.S/poll.S.html>`__ for more
information.

--------------


/Opening a STREAMS device file
==============================

One way to construct a Stream is to open (see 
`open\ (S) <../man/html.S/open.S.html>`__) a STREAMS-based driver file.

If the **open** call is the initial file open, a Stream is created.
(There is one Stream per major/minor device pair.)

If this is the initial open of this Stream, the driver open routine is
called. If modules have been specified to be autopushed, they are pushed
immediately after the driver open. When a Stream is already open,
further opens of the same Stream result in calls to the open procedures
of all pushable modules and the driver open. Note that this is done in
the reverse order from the initial Stream open. In other words, the
initial open processes from the Stream end to the Stream head, while
later opens process from the Stream head to the Stream end.

--------------


/Creating a STREAMS-based pipe
==============================

In addition to opening a STREAMS-based driver, a Stream can be created
by creating a pipe (see `pipe\ (S) <../man/html.S/pipe.S.html>`__).
Because pipes are not character devices, STREAMS creates and initializes
a *streamtab* structure for each end of the pipe.

When the **pipe** system call is executed, two Streams are created.
STREAMS follows the procedures similar to those of opening a driver;
however, duplicate data structures are created. That is, two entries are
allocated in the user's file table and two **vnode**\ s are created to
represent each end of the pipe. The file table entries are initialized
to point to the allocated **vnode**\ s and each **vnode** is initialized
to specify a file of type **FIFO**.

Each Stream header represents one end of the pipe, and it points to the
downstream half of each Stream head queue pair. Unlike STREAMS-based
devices, however, the downstream portion of the Stream terminates at the
upstream portion of the other Stream.

--------------

/Adding and removing modules
============================

As part of constructing a Stream, a module can be added (pushed) with an
**ioctl** **I_PUSH** (see
`streamio\ (M) <../man/html.M/streamio.M.html>`__) system call. The push
inserts a module beneath the Stream head. Because of the similarity of
STREAMS components, the push operation is similar to the driver open.
First, the address of the *qinit* structure for the module is obtained.

Next, STREAMS allocates a pair of *queue* structures and initializes
their contents as in the driver open.

Then, **q_next** values are set and modified so that the module is
interposed between the Stream head and its neighbor immediately
downstream. Finally, the module open procedure (located using *qinit*)
is called.

Each push of a module is independent, even in the same Stream. If the
same module is pushed more than once on a Stream, there will be multiple
occurrences of that module in the Stream. The total number of pushable
modules that may be contained on any one Stream is limited by the kernel
parameter **NSTRPUSH**.

An **ioctl** **I_POP** (see 
`streamio\ (M) <../man/html.M/streamio.M.html>`__) system call removes
(pops) the module immediately below the Stream head. The pop calls the
module close procedure. On return from the module close, any messages
left on the module's message queues are freed (deallocated). Then,
STREAMS connects the Stream head to the component previously below the
popped module and deallocates the module's *queue* pair. **I_PUSH** and
**I_POP** enable a user process to alter dynamically the configuration
of a Stream by pushing and popping modules as required. For example, a
module may be removed and a new one inserted below the Stream head. Then
the original module can be pushed back after the new module has been
pushed.

--------------


/Closing the stream
===================

The last **close** to a STREAMS file dismantles the Stream. Dismantling
consists of popping any modules on the Stream and closing the driver.
Before a module is popped, the **close** may delay to allow any messages
on the write message queue of the module to be drained by module
processing. Similarly, before the driver is closed, the **close** may
delay to allow any messages on the write message queue of the driver to
be drained by driver processing. If **O_NDELAY** (or **O_NONBLOCK**) is
clear, **close** waits up to 15 seconds for each module to drain and up
to 15 seconds for the driver to drain (see
`open\ (S) <../man/html.S/open.S.html>`__). If **O_NDELAY** (or
**O_NONBLOCK**) is set, the pop is performed immediately and the driver
is closed without delay. Messages can remain queued, for example, if
flow control is inhibiting execution of the write queue **service**
procedure. When all modules are popped and any wait for the driver to
drain is completed, the driver close routine is called. On return from
the driver close, any messages left on the driver's queues are freed,
and the **queue** and **stdata** structures are deallocated.

--------------

**NOTE:** STREAMS frees only the messages contained on a message queue.
Any message or data structures used internally by the driver or module
must be freed by the driver or module close procedure.

--------------

Finally, the user's file table entry and the **vnode** are deallocated
and the file is closed.

--------------

/Stream construction example
============================

The following example extends the previous communications device echoing
example (see `\``Basic STREAMS operations'' <FDIO_STMSOps.html>`__) by
inserting a module in the Stream. The (hypothetical) module in this
example can convert (change case, delete, and/or duplicate) selected
alphabetic characters.

Inserting modules
-----------------

An advantage of STREAMS over the traditional character I/O mechanism
stems from the ability to insert various modules into a Stream to
process and manipulate data that pass between a user process and the
driver. In the example, the character conversion module is passed a
command and a corresponding string of characters by the user. All data
passing through the module are inspected for instances of characters in
this string; the operation identified by the command is performed on all
matching characters. The necessary declarations for this program are
shown below: 

::

      #include <string.h>
      #include <fcntl.h>
      #include <stropts.h>
      
      #define  BUFLEN      1024
      
      /*
       * These defines would typically be
       * found in a header file for the module
       */
      #define  XCASE       1   /* change alphabetic case of char */
      #define  DELETE      2   /* delete char */
      #define  DUPLICATE   3   /* duplicate char */
      
      main()
      {
       char buf[BUFLEN];
       int fd, count;
       struct strioctl strioctl;

The first step is to establish a Stream to the communications driver and
insert the character conversion module. The following sequence of system
calls accomplishes the following display: 

::

       if ((fd = open("/dev/comm/01", O_RDWR)) < 0) {
           perror("open failed");
           exit(1);
       }
      
       if (ioctl(fd, I_PUSH, "chconv") < 0) {
           perror("ioctl I_PUSH failed");
           exit(2);
       }

The **I_PUSH** **ioctl** call directs the Stream head to insert the
character conversion module between the driver and the Stream head,
creating the Stream shown in `\``Case converter
module'' <_Stream_Construction_Example.html#fdio_f6>`__. As with
drivers, this module resides in the kernel and must have been configured
into the system before it was booted, unless the system has an autoload
capability.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/caconmod.gif

**Case converter module**

An important difference between STREAMS drivers and modules is
illustrated here. Drivers are accessed through a node or nodes in the
file system and may be opened just like any other device. Modules, on
the other hand, do not occupy a file system node. Instead, they are
identified through a separate naming convention, and are inserted into a
Stream using **I_PUSH**. The name of a module is defined by the module
developer.

Modules are pushed onto a Stream and removed from a Stream in
Last-In-First-Out (LIFO) order. Therefore, if a second module was pushed
onto this Stream, it would be inserted between the Stream head and the
character conversion module.

Module and driver control
-------------------------

The next step in this example is to pass the commands and corresponding
strings to the character conversion module. This can be done by issuing
**ioctl** calls to the character conversion module as follows: 

::

          /* change all upper case vowels to lower case */
       strioctl.ic_cmd = XCASE;
       strioctl.ic_timout = 0;     /* default timeout (15 sec) */
       strioctl.ic_dp = "AEIOU";
       strioctl.ic_len = strlen(strioctl.ic_dp);
      
       if (ioctl(fd, I_STR, &strioctl) < 0) {
           perror("ioctl I_STR failed");
           exit(3);
       }
      
       /* delete all instances of the chars 'x' and 'X' */
       strioctl.ic_cmd = DELETE;
       strioctl.ic_dp = "xX";
       strioctl.ic_len = strlen(strioctl.ic_dp);
      
       if (ioctl(fd, I_STR, &strioctl) < 0) {
           perror("ioctl I_STR failed");
           exit(4);
       }

**ioctl** requests are issued to STREAMS drivers and modules indirectly,
using the **I_STR** **ioctl** call (see
`streamio\ (M) <../man/html.M/streamio.M.html>`__). The argument to
**I_STR** must be a pointer to a **strioctl** structure, which specifies
the request to be made to a module or driver. This structure is defined
in *<stropts.h>* and has the following format: 

::

      struct strioctl {
       int ic_cmd;     /* ioctl request */
       int ic_timout;  /* ACK/NAK timeout */
       int ic_len;     /* length of data argument */
       char    *ic_dp;     /* ptr to data argument */
      };

where ``ic_cmd`` identifies the command intended for a module or driver,
``ic_timout`` specifies the number of seconds an **I_STR** request
should wait for an acknowledgement before timing out, ``ic_len`` is the
number of bytes of data to accompany the request, and ``ic_dp`` points
to that data.

In the example, two separate commands are sent to the character
conversion module. The first sets ``ic_cmd`` to the command **XCASE**
and sends as data the string \``AEIOU''; it converts all upper case
vowels in data passing through the module to lower case. The second sets
``ic_cmd`` to the command **DELETE** and sends as data the string
\``xX''; it deletes all occurrences of the characters \`x' and \`X' from
data passing through the module. For each command, the value of
``ic_timout`` is set to zero, which specifies the system default timeout
value of 15 seconds. The ``ic_dp`` field points to the beginning of the
data for each command; ``ic_len`` is set to the length of the data.

**I_STR** is intercepted by the Stream head, which packages it into a
message, using information contained in the **strioctl** structure, and
sends the message downstream. Any module that does not understand the
command in ``ic_cmd`` passes the message further downstream. The request
will be processed by the module or driver closest to the Stream head
that understands the command specified by ``ic_cmd``. The **ioctl** call
will block up to ``ic_timout`` seconds, waiting for the target module or
driver to respond with either a positive or negative acknowledgement
message. If an acknowledgement is not received in ``ic_timout`` seconds,
the **ioctl** call will fail.

--------------

**NOTE:** Only one **I_STR** request can be active on a Stream at one
time. Further requests will block until the active **I_STR** request is
acknowledged and the system call completes.

--------------

The **strioctl** structure is also used to retrieve the results, if any,
of an **I_STR** request. If data is returned by the target module or
driver, ``ic_dp`` must point to a buffer large enough to hold that data,
and ``ic_len`` will be set on return to show the amount of data
returned: 

::

          while ((count = read(fd, buf, BUFLEN)) > 0) {
           if (write(fd, buf, count) != count) {
               perror("write failed");
               break;
           }
       }
       exit(0);
      }

Note that the character conversion processing was realized with no
change to the communications driver.

The **exit** system call dismantles the Stream before terminating the
process. The character conversion module is removed from the Stream
automatically when it is closed. Alternatively, modules may be removed
from a Stream using the **I_POP** **ioctl** call described in
`streamio\ (M) <../man/html.M/streamio.M.html>`__. This call removes the
topmost module on the Stream, and enables a user process to alter the
configuration of a Stream dynamically, by popping modules as needed.

A few of the important **ioctl** requests supported by STREAMS have been
discussed. Several other requests are available to support operations
such as determining if a given module exists on the Stream, or flushing
the data on a Stream. These requests are described fully in
`streamio\ (M) <../man/html.M/streamio.M.html>`__.

--------------




/4. Process management
=======================

A process is the execution of a program; most SCO OpenServer (UNIX
System V) commands execute as separate processes. Each process is a
distinct entity, able to execute and terminate independently of all
other processes. Each user can have many processes in the system
simultaneously. In fact, it is not always necessary for the user to be
logged into the system while those processes are executing.

In SCO OpenServer, the operating system supports a schedulable entity
called a \``lightweight process'' (LWP). Each process contains one or
more LWPs. LWPs allow multiple threads of control within a single
process. The Threads Library provides interfaces with which applications
may be multithreaded. See `\``Threads'' <ProgThdsLib.html>`__ for
information about threads and LWPs. When a process does not explicitly
create any new LWPs, it contains one LWP and has the same semantics that
a process had in previous releases.

Whenever you execute a command in the UNIX system you are initiating a
process that is numbered and tracked by the operating system. A flexible
feature of the UNIX system is that processes can be generated by other
processes. This happens more than you might ever be aware of. For
example, when you log in to your system you are running a process, very
probably the shell. If you then use an editor such as **vi**, take the
option of invoking the shell from **vi**, and execute the **ps**
command, you will see a display something like the one in the following
figure (which shows the results of a **ps -f** command): 

::

      UID    PID PPID    C   STIME   TTY TIME    COMD
      abc  24210   1   0   06:13:14    tty29   0:05    -sh
      abc  24631   24210   0   06:59:07    tty29   0:13    vi c2.uli
      abc  28441   28358   80  09:17:22    tty29   0:01    ps -f
      abc  28358   24631   2   09:15:14    tty29   0:01    sh -i

**Process status**

As you can see, user *abc* (who went through the steps described above)
now has four processes active. It is an interesting exercise to trace
the chain that is shown in the Process ID (PID) and Parent Process ID
(PPID) columns. The shell that was started when user abc logged on is
process 24210; its parent is the initialization process (process ID 1).
Process 24210 is the parent of process 24631, and so on.

The four processes in the example above are all UNIX system shell-level
commands, but you can spawn new processes from your own program. You
might think, \``Well, it's one thing to switch from one program to
another when I'm at my terminal working interactively with the computer;
but why would a program want to run other programs, and if one does, why
wouldn't I just put everything together into one big executable
module?''

Overlooking the case where your program is itself an interactive
application with diverse choices for the user, your program may need to
run one or more other programs based on conditions it encounters in its
own processing. (If it is the end of the month, go do a trial balance,
for example.) The usual reasons why it might not be practical to create
one large executable are: 

-  The load module may get too big to fit in the maximum process size
   for your system.
-  You may not have control over the object code of all the other
   modules you want to include.

Suffice it to say, there are legitimate reasons why this creation of new
processes might need to be done. There are two ways to do it: 

-  `exec\ (S) <../man/html.S/exec.S.html>`__--stop this process and
   start another
-  `fork\ (S) <../man/html.S/fork.S.html>`__--start an additional copy
   of this process

--------------

/Program execution - exec
=========================

Overlays, performed by the family of **exec** system calls, can change
the executing program, but can not create new processes. Processes are
created (or spawned) by the system call **fork**, which is discussed
later.

**exec** is the name of a family of functions that includes **execl**,
**execv**, **execle**, **execve**, **execlp**, and **execvp**. They all
have the function of transforming the calling process into a new
process. The reason for the variety is to provide different ways of
pulling together and presenting the arguments of the function. An
example of one version (**execl**) might be: 

::

   execl("/usr/bin/prog2", "prog", progarg1, progarg2, (char *)0);

| For **execl** the argument list is
| */usr/bin/prog2* path name of the new process file
| **prog** the name the new process gets in its **argv[0]**
| **progarg1**, arguments to **prog2** as **char \***'s
| **progarg2**
| **(char \*)0** a null **char** pointer to mark the end of the
  arguments

Check the `exec\ (S) <../man/html.S/exec.S.html>`__ manual page for the
rest of the details. The key point of the **exec** family is that there
is no return from a successful execution: the new process overlays the
process that makes the **exec** system call. The new process also takes
over the process ID and other attributes of the old process. If the call
to **exec** is unsuccessful, control is returned to your program with a
return value of **-1**. You can check **errno** to learn why it failed.

The system call **execl** executes another program, *without returning*;
thus, to print the date as the last action of a running program, use: 

::

   execl("/bin/date", "date", NULL);

The first argument to **execl** is the **filename** of the command; you
have to know where it is found in the file system. The second argument
is conventionally the program name (that is, the last component of the
filename), but this is seldom used except as a placeholder. If the
command takes arguments, they are strung out after this; the end of the
list is marked by a **NULL** argument.

The **execl** call overlays the existing program with the new one, runs
that, then exits, without returning to the original program.

--------------

**NOTE:** When a multithreaded process calls **exec**, the new process
will be created with a single thread (and LWP), effectively terminating
all other threads (and LWPs) in the process. If **exec** fails, no
threads (or LWPs) are terminated.

--------------

The one exception to the rule that the original program never gets
control back occurs when there is an error, for example if the file
cannot be found or is not executable. If you do not know where **date**
is located, say: 

::

   execl("/bin/date", "date", NULL);
   execl("/usr/bin/date", "date", NULL);
   printf(stderr, "Someone stole 'date'\n");

A variant of **execl** called **execv** is useful when you do not know
in advance how many arguments there are going to be. The call is: 

::

   execv(filename, argp);

Where **argp** is an array of pointers to the arguments; the last
pointer in the array must be **NULL** so **execv** can tell where the
list ends. As with **execl**, **filename** is the file in which the
program is found, and **argp[0]** is the name of the program. (This
arrangement is identical to the **argv** array for C program arguments.)

Neither of these functions provides the niceties of normal command
execution. There is no automatic search of multiple directories - you
have to know precisely where the command is located. Nor do you get the
expansion of metacharacters like \`\`\ **<**'', \`\`\ **>**'',
\`\`\ **\***'', \`\`\ **?**'' and \`\`\ **[]**'' in the argument list.
If you want these, use **execl** to invoke the shell **sh**, which then
does all the work. Construct a string **cmdline** that contains the
complete command as it would have been typed at the terminal, then say: 

::

   execl("/bin/sh", "sh", "-c", cmdline, NULL);

The shell is assumed to be at a fixed place, */bin/sh*. Its argument
**-c** says to treat the next argument as a whole command line, so it
does just what you want. The only problem is in constructing the right
information in **cmdline**.

To get automatic search of multiple directories, you have to use the
**execvp** or **execlp** variants.

To summarize: 

-  Any process may **exec** (cause execution of) a file.
-  Doing an **exec** does not change the process ID; the process that
   did the **exec** persists, but after the **exec** it is executing a
   different program.
-  Files that were open before the **exec** remain open afterwards.

Many programs want to regain control after **exec**\ ing another
program; these should use a combination of **fork** and **exec** (see
the next section). However, a program with two or more phases that
communicate only through temporary files might use an **exec** function
without a **fork**. Here it is natural to make the second pass simply an
**execl** call from the first. For example, the first pass of a compiler
might overlay itself with the second pass of the compiler. This is
analogous to a \``goto'' in programming.

--------------

/Process creation - fork
========================

If a process wishes to regain control after **exec**\ ing a second
program, it should **fork** a child process, have the child **exec** the
second program, and the parent **wait** for the child. This is analogous
to a \``call'' except that the **fork** system call creates a new
process that is an exact copy of the calling process. The following
figure depicts what is involved in executing a program with a typical
**fork** as the first step: 

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/procprim.gif

**Process primitives**

| Because the **exec** functions simply overlay the new program on the
  old one, to save the old one requires that it first be split into two
  copies; one of these can be overlaid, while the other waits for the
  new overlaying program to finish.
| The system call **fork** does the splitting as in the following call: 

::

   proc_id = fork();

The newly created process, known as the \``child process'', is a copy of
the image of the original process, called the \``parent process''. The
system call **fork** splits the program into two copies, both of which
continue to run, and which differ only in the value returned in
**proc_id**. In the child process, **proc_id** equals zero; in the
parent process, **proc_id** equals a non-zero value that is the process
number of the child process. Thus, the basic way to call, and return
from, another program is: 

::

   if (fork() == 0)   /* in child */
      execl("/bin/sh", "sh", "-c", cmd, NULL);

And in fact, except for handling errors, this is sufficient. The
**fork** is zero, so it calls **execl** which does the **cmd** and then
dies. In the parent, **fork** returns non-zero so it skips the
**execl**. (If there is any error, **fork** returns **-1**).

A child inherits its parent's permissions, working-directory,
root-directory, open files, etc. This mechanism permits processes to
share common input streams in various ways. Files that were open before
the **fork** are shared after the **fork**. The processes are informed
through the return value of **fork** as to which is the parent and which
is the child. In any case the child and parent differ in three important
ways: 

-  The child has a different process ID.
-  The child has a different parent process ID.
-  All accounting variables are reset to appropriate values in the
   child.

--------------

**NOTE:** Two variations of **fork**, **forkall** and **fork1**, are
intended for use in multithreaded programs. **forkall** (which is a
synonym for **fork**) duplicates in the new process the set of threads
and underlying LWPs that exist in the calling process. **fork1**, on the
other hand, creates a new process with a single thread and a single LWP.
**fork1** should be used by multithreaded processes that will have the
new process call **exec**. Since **exec** will terminate all but one
thread (and LWP), there is no need to duplicate all threads with
**forkall**.

--------------

The **fork** system call creates a child process with code and data
copied from the parent process that created the child process. Once the
copying is completed, the new (child) process is placed on the runnable
queue to be scheduled. Each child process executes independently of its
parent process, although the parent may explicitly wait for the
termination of that child or any of its children. Usually the parent
waits for the death of its child at some point, since this **wait** call
is used to free the process-table entry used by the child. See the
discussion in `\``Process termination'' <PM_ProcTerm.html>`__ for more
detail.

Calling **fork** creates a new process that is an exact copy of the
calling process. The one major difference between the two processes is
that the child gets its own unique process ID. When the **fork** process
has completed successfully, it returns a **0** to the child process and
the child's process ID to the parent. If the idea of having two
identical processes seems a little funny, consider this: 

-  Because the return value is different between the child process and
   the parent, the program can contain the logic to determine different
   paths.
-  The child process could say, \``Okay, I'm the child; I'm supposed to
   issue an **exec** for an entirely different program.''
-  The parent process could say, \``My child is going to **exec** a new
   process; I'll issue a **wait** until I get word that the new process
   is finished.''

Your code might include statements like the following: 

::

   #include <errno.h>

   pid_t ch_pid;
   int ch_stat, status;
   char *p_arg1, *p_arg2;
   void exit();

       if ((ch_pid = fork()) < 0) {

           /* Could not fork... check errno */

       }
       else if (ch_pid == 0) {         /* child */
           (void)execl("/usr/bin/prog2", "prog", p_arg1, p_arg2, (char *)NULL);
           exit(2);    /* execl() failed */
       }
       else {          /* parent */
           while ((status = wait(&ch_stat)) != ch_pid) {
               if (status < 0 && errno == ECHILD)
                   break;
               errno = 0;
           }
       }

**Example of fork**

| 

Because the new **exec**'d process takes over the child process ID, the
parent knows the ID. What this boils down to is a way of leaving one
program to run another, returning to the point in the first program
where processing left off.

Keep in mind that the fragment of code above includes minimal checking
for error conditions, and has potential for confusion about open files
and which program is writing to a file. Leaving out the possibility of
named files, the new process created by the **fork** or **exec** has the
three standard files that are automatically opened: **stdin**,
**stdout**, and **stderr**. If the parent has buffered output that
should appear before output from the child, the buffers must be flushed
before the fork. Also, if the parent and the child processes both read
input from a stream, whatever is read by one process will be lost to the
other. That is, once something has been delivered from the input buffer
to a process the pointer has moved on.

Process creation is essential to the basic operation of SCO OpenServer
because each command run by the Shell executes in its own process. In
fact, execution of a Shell command or Shell procedure involves both a
**fork** and an overlay. This scheme makes a number services easy to
provide. I/O redirection, for example, is basically a simple operation;
it is performed entirely in the child process that executes the command,
and thus no memory in the Shell parent process is required to rescind
the change in standard input and output. Background processes likewise
require no new mechanism; the Shell merely refrains from waiting for
commands executing in the background to complete. Finally, recursive use
of the Shell to interpret a sequence of commands stored in a file is in
no way a special operation.

--------------




/Control of processes - fork and wait
=====================================

A parent process can suspend its execution to wait for termination of a
child process with **wait** or **waitpid**. More often, the parent wants
to wait for the child to terminate before continuing itself as follows: 

::

   int status;

   if (fork() == 0)
      execl( ... );
   wait(&status);

The previous code fragment avoids handling any abnormal conditions, such
as a failure of the **execl** or **fork**, or the possibility that there
might be more than one child running simultaneously. (The function
**wait** returns the process-id of the terminated child, which can be
checked against the value returned by **fork**.) In addition, this
fragment avoids dealing with any funny behavior on the part of the child
(which is reported in **status**).

The low-order eight bits of the value returned by **wait** encodes the
termination status of the child process; **0** signifies normal
termination and non-zero to signify various kinds of abnormalities. The
next higher eight bits are taken from the argument of the call to
**exit** which caused a normal termination of the child process. It is
good coding practice for all programs to return meaningful status.

When a program is called by the shell, the three file-descriptors are
available for use. When this program calls another one, correct
etiquette suggest making sure the same conditions hold. Neither **fork**
nor the **exec** calls affects open files in any way. If the parent is
buffering output that must come out before output from the child, the
parent must flush its buffers before the **execl**. Conversely, if a
caller buffers an input stream, the called program loses any information
that has been read by the caller.

--------------

/Process termination
====================

Processes terminate in one of two ways: 

-  Normal Termination occurs by a return from **main** or when requested
   by an explicit call to **exit** or **\_exit**.
-  Abnormal Termination occurs as the default action of a signal or when
   requested by **abort**.

On receiving a signal, a process looks for a signal-handling function.
Failure to find a signal-handling function forces the process to call
**exit**, and therefore to terminate. The functions **\_exit**, **exit**
and **abort** terminate a process with the same effects except that
**abort** makes available to **wait** or **waitpid** the status of a
process terminated by the signal **SIGABRT** (see
`exit\ (S) <../man/html.S/exit.S.html>`__ and
`abort\ (S) <../man/html.S/abort.S.html>`__).

As a process terminates, it can set an eight-bit exit status code
available to its parent. Usually, this code indicates success (zero) or
failure (non-zero), but it can be used in any manner the user wishes. If
a signal terminated the process, the system first tries to dump an image
of core, then modifies the exit code to indicate which signal terminated
the process and whether core was dumped. This is provided that the
signal is one that produces a core dump (see
`signal\ (M) <../man/html.M/signal.M.html>`__). Next, all signals are
set to be ignored, and resources owned by the process are released,
including open files and the working directory. The terminating process
is now a \``zombie'' process, with only its process-table entry
remaining; and that is unavailable for use until the process has finally
terminated. Next, the process-table is searched for any child or zombie
processes belonging to the terminating process. Those children are then
adopted by **init** by changing their parent process ID to **1**). This
is necessary since there must be a parent to record the death of the
child. The last actions of **exit** are to record the accounting
information and exit code for the terminated process in the zombie
process-table entry and to send the parent the death-of-child signal,
**SIGCHLD** (see `\``Signals, job control and
pipes'' <SigsJobCntlPipes.html>`__).

If the parent wants to wait until a child terminates before continuing
execution, the parent can call **wait**, which causes the parent to
sleep until a child zombie is found (meaning the child terminated). When
the child terminates, the death-of-child signal is sent to the parent
although the parent ignores this signal. (Ignore is the default
disposition. Applications that fork children and need to know the return
status should set this signal to other than ignore.) The search for
child zombies continues until the terminated child is found; at which
time, the child's exit status and accounting information is reported to
the parent (remember the call to **exit** in the child put this
information in the child's process-table entry) and the zombie
process-table entry is freed. Now the parent can wake up and continue
executing.

--------------


/Timer operations
=================

A process can suspend itself for a specific period of time with the
function **sleep** or suspend itself indefinitely with the function
**pause** until a signal arrives to reactivate the process. The function
**alarm** schedules a signal to arrive at a specific time, so a
**pause** suspension need not be indefinite.

::

   #include <stdio.h>
   #include <signal.h>

   struct sigaction new_act, old_act;
   int alarm_count = 5;    /* initialize number of alarms */

   main () {
      void alarm_action();
   /*
    * pass signal and function to sigaction
    */
      new_act.sa_handler = alarm_action;
      sigaction(SIGALRM, &new_act, &old_act);

      alarm(5);          /* set alarm clock for 5 seconds */

      pause(); /* suspend process until receipt of signal */
   }

   void alarm_action() {
   /*
    * print the number of alarms remaining
    */
      printf("\t<%d\007>", alarm_count);
   /*
    * pass signal and function to sigaction
    */
      new_act.sa_handler = alarm_action;
      sigaction(SIGALRM, &new_act, &old_act);

      alarm(5);            /* set alarm clock for 5 seconds */
      if (--alarm_count)   /* decrement alarm count */
         pause();          /* suspend process */
   }

The preceding example shows how you can use the **signal**, **alarm**
and **pause** system calls to alternately suspend and resume a program.

--------------

/Process scheduling
===================

In SCO OpenServer, the schedulable entity is always a lightweight
process (LWP). Scheduling priorities and classes are attributes of LWPs
and not processes. When scheduling system calls accept a process on
which to operate, the operation is applied to each LWP in the process.
The UNIX system scheduler determines when LWPs run. It maintains
priorities based on configuration parameters, process behavior, and user
requests; it uses these priorities to assign LWPs to the CPU.

SCO OpenServer gives users absolute control over the sequence in which
certain LWPs run, and the amount of time each LWP may use the CPU before
another LWP gets a chance.

By default, the scheduler uses a time-sharing policy similar to the
policy used in previous releases. A time-sharing policy adjusts
priorities dynamically in an attempt to provide good response time to
interactive LWPs and good throughput to CPU-intensive LWPs.

The scheduler offers a fixed priority scheduling policy as well as a
time-sharing policy. Fixed priority scheduling allows users to set fixed
priorities on a per-process or LWP basis. The highest-priority fixed
priority LWP always gets the CPU as soon as it is runnable, even if
system processes are runnable. An application can therefore specify the
exact order in which LWPs run. An application may also be written so
that its fixed priority LWPs have a guaranteed response time from the
system.

For most UNIX environments, the default scheduler configuration works
well and no fixed priority LWPs are needed: administrators should not
change configuration parameters and users should not change scheduler
properties of their applications. However, for some applications with
strict timing constraints, fixed priority LWPs are the only way to
guarantee that the application's requirements are met.

--------------

**NOTE:** Fixed priority LWPs used carelessly can have a dramatic
negative effect on the performance of time-sharing LWPs.

--------------

| You can manage the relationship between processes and processors.
  Processes can be bound to a specific processor and processors can be
  bound exclusively by a process. Note that exclusive binding applies
  only to user level processes and not to kernel drivers. That is,
| the exclusive binding of a user level process excludes other user
  level processes, but not a kernel driver.

| This section is addressed to programmers who need more control over
  order of process and LWP execution than they get using default
  scheduler parameters.

Because changes in scheduler administration can affect scheduler
behavior, programmers may also need to know about scheduler
administration. There are a few reference manual entries with
information on scheduler administration: 

-  **dispadmin**\ (ADM) tells how to change scheduler configuration in a
   running system.
-  *ts_dptbl*\ (M), *fc_dptbl*\ (M), and *fp_dptbl*\ (M) describe the
   time-sharing, fixed class, and fixed priority parameter tables that
   are used to configure the scheduler.

The rest of this section is organized as follows: 

-  `\``How the process scheduler works'' <PM_HowProcSchedWorks.html>`__
   describes what the scheduler does and how it does it. It also
   introduces scheduler classes.
-  `\``Scheduler commands and function
   calls'' <PM_SchedCmdsFuncCalls.html>`__ describes and gives examples
   of the **priocntl**\ (CP) command and the **priocntl**\ (S),
   **priocntllist**\ (S), and **priocntlset**\ (S) system calls, the
   user interface to scheduler services. The **priocntl** functions
   allow you to retrieve scheduler configuration information and to get
   or set scheduler parameters for a process or LWP, or a set of
   processes or LWPs.
-  `\``Scheduler interaction with other
   functions'' <PM_SchedIntaFuncs.html>`__ describes the interactions
   between the scheduler and related functions.
-  `\``Scheduler performance'' <_Scheduler_Performance.html>`__
   discusses scheduler latencies of which some applications must be
   aware, and mentions some considerations other than the scheduler that
   application designers must take into account to ensure that their
   requirements are met.
-  `\``Managing processors and processes'' <PM_MngProcorsProces.html>`__
   describes how you can manage the relationship between processors and
   processes. It tells how you can take processors offline or bring them
   online.

--------------


/How the process scheduler works
================================

The following figure shows how the UNIX System V Release 4 process and
LWP scheduler works. Fixed Class Priorities overlap the default
Time-Sharing Priorities.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/sched.gif

**The UNIX System V Release 4 process scheduler**

When a process or LWP is created, it inherits its scheduler parameters,
including scheduler class and a priority within that class. A process or
LWP changes class only as a result of a user request. The system manages
the priority of an LWP based on user requests and a policy associated
with the scheduler class of the LWP.

In the default configuration, the initialization process belongs to the
time-sharing class. Because processes inherit their scheduler
parameters, all user login shells begin as time-sharing processes in the
default configuration.

The scheduler converts class-specific priorities into global priorities.
The global priority of an LWP determines when it runs--the scheduler
always runs the runnable LWP with highest global priority. Numerically
higher priorities run first. Once the scheduler assigns an LWP to the
CPU, the LWP runs until it uses up its time slice, sleeps, or is
preempted by a higher-priority LWP. LWPs with the same priority run
round-robin.

Administrators specify default time slices in the configuration tables,
but users may assign time slices to fixed priority LWPs.

You can display the global priority of a process or LWP with the **-cl**
options of the **ps**\ (C) command. You can display configuration
information about class-specific priorities with the **priocntl**\ (CP)
command and the **dispadmin**\ (ADM) command.

By default, all fixed priority processes or LWPs have higher priorities
than any kernel process, and all kernel processes have higher priorities
than any time-sharing process.

--------------

**NOTE:** As long as there is a runnable fixed priority fixed priority
process or LWP, no kernel process and no time-sharing process runs.

--------------

The following sections describe the scheduling policies of the default
classes.

--------------

/Time-sharing class and fixed class
===================================

The goal of the time-sharing policy is to provide good response time to
interactive processes and LWPs and good throughput to CPU-bound
processes and LWPs. The scheduler switches CPU allocation frequently
enough to provide good response time, but not so frequently that it
spends too much time doing the switching. Time slices are typically a
few hundred milliseconds.

The time-sharing policy changes priorities dynamically and assigns time
slices of different lengths. The scheduler raises the priority of an LWP
that sleeps after only a little CPU use (an LWP sleeps, for example,
when it starts an I/O operation such as a terminal read or a disk read);
frequent sleeps are characteristic of interactive tasks such as editing
and running simple shell commands. On the other hand, the time-sharing
policy lowers the priority of an LWP that uses the CPU for long periods
without sleeping.

The default time-sharing policy gives larger time slices to LWPs with
lower priorities. An LWP with a low priority is likely to be CPU-bound.
Other LWPs get the CPU first, but when a low-priority LWP finally gets
the CPU, it gets a bigger chunk of time. If a higher-priority LWP
becomes runnable during a time slice, however, it preempts the running
process or LWP.

The scheduler manages time-sharing processes and LWPs using configurable
parameters in the time-sharing parameter table **ts_dptbl**. This table
contains information specific to the time-sharing class.

The default fixed class policy is similar to the default time-sharing
policy except that the priorities and time slices given to fixed class
processes or LWPs do not degrade over time. The **fc_dptbl** parameter
table contains information specific to the fixed class.

--------------


/System class
=============

The system class uses a fixed-priority policy to run kernel processes
such as servers and housekeeping processes like the paging demon. The
system class is reserved for use by the kernel; users may neither add
nor remove a process from the system class. Priorities for system class
processes are set up in the kernel code for those processes; once
established, the priorities of system processes do not change. (User
processes and LWPs running in kernel mode are not in the system class.)

--------------


/Fixed priority class
=====================

The fixed priority class uses a fixed-priority scheduling policy so that
critical processes and LWPs can run in predetermined sequence. Real-time
Fixed priorities never change except when a user requests a change.
Contrast this fixed-priority policy with the time-sharing policy, for
which the system changes priorities to provide good interactive response
time.

Privileged users can use the **priocntl** command or the **priocntl**
system call to assign fixed priorities.

The scheduler manages fixed priority processes and LWPs using
configurable parameters in the fixed priority parameter table
**fp_dptbl**. This table contains information specific to the fixed
priority class.

--------------


/Scheduler commands and function calls
======================================

Below is a programmer's view of default LWP priorities. Fixed Class
Priorities overlap the default Time-Sharing Priorities.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/priorty.gif

**Process priorities (programmer view)**

From a user or programmer's point of view, a process or LWP priority has
meaning only in the context of a scheduler class. You specify an LWP
priority by specifying a class and a class-specific priority value. The
class and class-specific value are mapped by the system into a global
priority that the system uses to schedule LWPs.

-   Fixed priorities run from zero to a configuration-dependent maximum.
   The system maps them directly into global priorities. They never
   change except when a user changes them.

-   System priorities are controlled entirely in the kernel. Users
   cannot affect them.

-   Time-sharing priorities have a user-controlled component (the
   \``user priority'') and a component controlled by the system. The
   system does not change the user priority except as the result of a
   user request. The system changes the system-controlled component
   dynamically on a per-process or LWP basis to provide good overall
   system performance; users cannot affect the system-controlled
   component. The scheduler combines these two components to get the
   process or LWP global priority.

   The user priority runs from the negative of a configuration-dependent
   maximum to the positive of that maximum. A process or LWP inherits
   its user priority. Zero is the default initial user priority.

   The \``user priority limit'' is the configuration-dependent maximum
   value of the user priority. You may set a user priority to any value
   below the user priority limit. With appropriate privilege, you may
   raise the user priority limit. Zero is the default user priority
   limit.

   You may lower the user priority of a process or LWP to give the
   process or LWP reduced access to the CPU or, with the appropriate
   privilege, raise the user priority to get better service. Because you
   cannot set the user priority above the user priority limit, you must
   raise the user priority limit before you raise the user priority if
   both have their default values of zero.

   An administrator configures the maximum user priority independent of
   global time-sharing priorities. In the default configuration, for
   example, a user may set a user priority only in the range from -20 to
   +20, but 60 time-sharing global priorities are configured.

A system administrator's view of priorities is different from that of a
user or programmer. When configuring scheduler classes, an administrator
deals directly with global priorities. The system maps priorities
supplied by users into these global priorities. See `\``Process
scheduling'' <_Process_Scheduling.html>`__.

The **ps -cel** command reports global priorities for all active
processes and LWPs. The **priocntl** command reports the class-specific
priorities that users and programmers use.

--------------

**NOTE:** Global priorities and user-supplied priorities are in
ascending order: numerically higher priorities run first.

--------------

The **priocntl**\ (CP) command and the **priocntl**\ (S),
**priocntllist**\ (S), and **priocntlset**\ (S) system calls set or
retrieve scheduler parameters for processes and LWPs. Setting priorities
is similar for all these functions: 

-  Specify the target processes and LWPs.
-  Specify the scheduler parameters you want for those processes and
   LWPs.
-  Do the command or system call to set the parameters for the processes
   and LWPs.

You specify the target processes and LWPs using an ID type and an ID.
The ID type tells how to interpret the ID. (This concept of a set of
processes and LWPs applies to signals as well as to the scheduler; see
`sigsend\ (S) <../man/html.S/sigsend.S.html>`__). The following is a
list of the valid **priocntl** ID types that you may specify.

+--------------------+
| LWP ID             |
+--------------------+
| process ID         |
+--------------------+
| parent process ID  |
+--------------------+
| process group ID   |
+--------------------+
| session ID         |
+--------------------+
| class ID           |
+--------------------+
| effective user ID  |
+--------------------+
| effective group ID |
+--------------------+
| all processes      |
+--------------------+

These IDs are basic properties of UNIX processes and LWPs. (See
**intro**\ (S)). The class ID refers to the scheduler class of the
process or LWP. **priocntl** works only for the time-sharing, fixed
class, and the fixed priority classes, not for the system class.
Processes in the system class have fixed priorities assigned when they
are started by the kernel.

--------------




/The priocntl command
=====================

The **priocntl** command comes in four forms: 

**priocntl -l**
   This displays configuration information. Here is the output for the
   default configuration.

   ::

         $ priocntl -l
         CONFIGURED CLASSES
         ==================
         
         SYS (System Class)
         
         FC (Time sharing)
          Configured FC User Priority Range: -30 through 30
         
         TS (Time Sharing)
                 Configured TS User Priority Range: -20 through 20
         
         FP (Fixed Priority)
                 Maximum Configured FP Priority: 59

**priocntl -d**
   This displays the scheduler parameters of a process or LWP or a set
   of processes or LWPs. The syntax for this option is

   ::

         priocntl -d -i idtype  idlist

   **idtype** tells what kind of IDs are in **idlist**. **idlist** is a
   list of IDs separated by white space. Here are the valid values for
   **idtype** and their corresponding ID types in **idlist**: 

   ========== ==============================
   **idtype** **idlist**
   ========== ==============================
   ``lwpid``  LWP IDs
   ``pid``    process IDs
   ``ppid``   parent process IDs
   ``pgid``   process group IDs
   ``sid``    session IDs
   ``class``  class names (**TS** or **FP**)
   ``uid``    effective user IDs
   ``gid``    effective group IDs
   ``all``     
   ========== ==============================

   Here are some examples of the **-d** option of **priocntl**: 

   ::

         $ # display info on all processes and LWPs
         $ priocntl -d -i all
          .
          .
          .
         $ # display info on all time-sharing processes and LWPs: 
         $ priocntl -d -i class TS
          .
          .
          .
         $ # display info on all processes and LWPs with user ID 103 or 6626
         $ priocntl -d -i uid 103 6626
          .
          .
          .

**priocntl -s**
   This sets scheduler parameters for a process or LWP or a set of
   processes or LWPs. The syntax for this option is

   ::

         priocntl -s -c class  class_options -i idtype  islist

   **idtype** and **idlist** are the same as for the **-d** option
   described above.

   **class** is **TS** for time-sharing or **FP** for fixed priority.
   You must have appropriate privilege to create a fixed priority
   process or LWP, to raise a time-sharing user priority above a
   per-process or LWP limit, or to raise the per-process or LWP limit
   above zero. Class options are class-specific: 

   **Class-specific options for priocntl**

   +-----------------+-----------------+-----------------+-----------------+
   | Class           | ``-c``          | Options         | Meaning         |
   |                 | \ **``class``** |                 |                 |
   +=================+=================+=================+=================+
   | fixed priority  | ``FP``          | -p **pri**      | priority        |
   |                 |                 | -t **tslc**     | time slice      |
   |                 |                 | -r **res**      | resolution      |
   +-----------------+-----------------+-----------------+-----------------+
   | time-sharing    | ``TS``          | -p **upri**     | user priority   |
   |                 |                 | -m **uprilim**  | user priority   |
   |                 |                 |                 | limit           |
   +-----------------+-----------------+-----------------+-----------------+
   | fixed class     | ``FC``          | -p **upri**     | user priority   |
   |                 |                 | -m **uprilim**  | user priority   |
   |                 |                 |                 | limit           |
   +-----------------+-----------------+-----------------+-----------------+

   For a fixed priority process or LWP you may assign a priority and a
   time slice.

   -  The priority is a number from 0 to the fixed priority maximum as
      reported by **priocntl -l**; the default maximum is 59.
   -  You specify the time slice as a number of clock intervals and the
      resolution of the interval. Resolution is specified in intervals
      per second. The time slice, therefore, is **tslc/res** seconds. To
      specify a time slice of one-tenth of a second, for example, you
      could specify a **tslc** of 1 and a **res** of 10. If you specify
      a time slice without specifying a resolution, millisecond
      resolution (a **res** of 1000) is assumed.

   If you change a time-sharing process or LWP into a fixed priority
   process or LWP, it gets a default priority and time slice if you do
   not specify one. If you want to change only the priority of a fixed
   priority process or LWP and leave its time slice unchanged, omit the
   **-t** option. If you want to change only the time slice of a fixed
   priority process or LWP and leave its priority unchanged, omit the
   **-p** option.

   For a time-sharing process or LWP you may assign a user priority and
   a user priority limit.

   -  The user priority is the user-controlled component of a
      time-sharing priority. The scheduler calculates the global
      priority of a time-sharing process or LWP by combining this user
      priority with a system-controlled component that depends on
      process or LWP behavior. The user priority has the same effect as
      a value set by **nice** (except that **nice** uses higher numbers
      for lower priority).
   -  The user priority limit is the maximum user priority a process or
      LWP may set for itself without being a privileged user. By
      default, the user priority limit is 0. You must have appropriate
      privilege to set a user priority limit above 0.

   Both the user priority and the user priority limit must be within the
   user priority range reported by the **priocntl -l** command. The
   default range is -20 to +20.

   There is no limit for the number of times a process or LWP may lower
   and raise its user priority, as long as the value is below its user
   priority limit. As a courtesy to other users, lower your user
   priority for big chunks of low-priority work. However, remember that
   if you lower your user priority limit, you must have appropriate
   privilege to raise it. A typical use of the user priority limit is to
   reduce permanently the priority of child processes or LWPs, or
   another set of low-priority processes or LWPs.

   The user priority can never be greater than the user priority limit.
   If you set the user priority limit below the user priority, the user
   priority is lowered to the new user priority limit. If you attempt to
   set the user priority above the user priority limit, the user
   priority is set to the user priority limit.

   Here are some examples of the **-s** option of **priocntl**: 

   ::

         # # make process with ID 24668 a fixed priority process with default parameters: 
         # priocntl -s -c FP -i pid 24668
         
         # # make 3608 FP with priority 55 and a one-fifth second time slice: 
         # priocntl -s -c FP -p 55 -t 1 -r 5 -i pid 3608
         
         # # change all processes or LWPs into time-sharing processes or LWPs: 
         # priocntl -s -c TS -i all
         
         # # for uid 1122, reduce TS user priority and user priority limit to -10: 
         # priocntl -s -c TS -p -10 -m -10 -i uid 1122

**priocntl -e**
   This sets scheduler parameters for a specified command and executes
   the command. The syntax for this option is

   ::

         priocntl -e -c class  class_options  command  [command arguments]

   The class and class options are the same as for the **-s** option
   described above.

   ::

         # # start a fixed priority shell with default fixed priority: 
         # priocntl -e -c FP /bin/sh
         
         $ # run make with a time-sharing  user priority of -10: 
         $ priocntl -e -c TS -p -10 make bigprog

   The **priocntl** command subsumes the function of **nice**, which
   continues to work as in previous releases. **nice** works only on
   time-sharing processes and LWPs and uses higher numbers to assign
   lower priorities. The final example above is equivalent to using
   **nice** to set an \``increment'' of 10: 

   ::

         nice -10 make bigprog

--------------

/The priocntl system call
=========================

::

      #include    <sys/types.h>
      #include <sys/procset.h>
      #include <sys/priocntl.h>
      #include <sys/fppriocntl.h>
      #include <sys/tspriocntl.h>
      
      long priocntl(idtype_t idtype, id_t id, int cmd, void *arg);

The **priocntl** system call gets or sets scheduler parameters of a set
of processes or LWPs. The input arguments: 

-  **idtype** is the type of ID you are specifying.
-  **id** is the ID.
-  **cmd** specifies which **priocntl** function to perform. The
   functions are listed in the table below.
-  **arg** is a pointer to a structure that depends on **cmd**.

Here are the valid values for **idtype** that are defined in
*<priocntl.h>*, and their corresponding ID types in **id**. In this
table, \``process'' also means LWP.

=========== ================================
**idtype**  Interpretation of **id**
=========== ================================
``P_PID``   process ID (of a single process)
``P_PPID``  parent process ID
``P_PGID``  process group ID
``P_LWPID`` LWP ID
``P_SID``   session ID
``P_CID``   class ID
``P_UID``   effective user ID
``P_GID``   effective group ID
``P_ALL``   all processes and LWPs
=========== ================================

| 

Here are the valid values for **cmd**, their meanings, and the type of
**arg**: 

**priocntl commands**

================ ============= ===================================
**cmd**          **arg** Type  Function
================ ============= ===================================
``PC_GETCID``    ``pcinfo_t``  get class ID and attributes
``PC_GETCLINFO`` ``pcinfo_t``  get class name and attributes
``PC_SETPARMS``  ``pcparms_t`` set class and scheduling parameters
``PC_GETPARMS``  ``pcparms_t`` get class and scheduling parameters
================ ============= ===================================

Here are the values **priocntl** returns on success: 

-  The **GETCID** and **GETCLINFO** commands return the number of
   configured scheduler classes.
-  **PC_SETPARMS** returns 0.
-  **PC_GETPARMS** returns the process ID of the process or LWP whose
   scheduler properties it is returning.

On failure, **priocntl** returns **-1** and sets **errno** to indicate
the reason for the failure. See **priocntl**\ (S) for the complete list
of error conditions.

PC_GETCID, PC_GETCLINFO
-----------------------

The **PC_GETCID** and **PC_GETCLINFO** commands retrieve scheduler
parameters for a class based on the class ID or class name. Both
commands use the **pcinfo** structure to send arguments and receive
return values: 

::

      typedef struct pcinfo {
         id_t  pc_cid;                  /* class id */
         char  pc_clname[PC_CLNMSZ];    /* class name */
         long  pc_clinfo[PC_CLINFOSZ];  /* class information */
      } pcinfo_t;

| The **PC_GETCID** command gets scheduler class ID and parameters given
  the class name. The class ID is used in some of the other **priocntl**
  commands to specify a scheduler class. The valid class names are
  **TS** for time-sharing, **FC** for fixed class, and **FP** for fixed
  priority.

For the fixed priority class, **pc_clinfo** contains an **fpinfo**
structure, which holds **fp_maxpri**, the maximum valid fixed priority;
in the default configuration, this is the highest priority any process
or LWP can have. The minimum valid fixed priority is zero. **fp_maxpri**
is a configurable value; see `\``Process
scheduling'' <_Process_Scheduling.html>`__ for information on how to
configure process and LWP priorities.

::

      typedef struct fpinfo {
         short  fp_maxpri;  /* maximum fixed priority */
      } fpinfo_t;

For the time-sharing class, **pc_clinfo** contains a **tsinfo**
structure, which holds **ts_maxupri,** the maximum time-sharing user
priority. The minimum time-sharing user priority is **-ts_maxupri**.
**ts_maxupri** is also a configurable value.

::

      typedef struct tsinfo {
         short  ts_maxupri;  /* limits of user priority range */
      } tsinfo_t;

For the fixed class, **pc_clinfo** contains a **fcinfo** structure,
which holds **fc_maxupri,** the maximum fixed class user priority. The
minimum fixed class user priority is **-fc_maxupri**. **fc_maxupri** is
also a configurable value.

::

      typedef struct fcinfo {
         short  fc_maxupri;  /* limits of user priority range */
      } fcinfo_t;

The following program is a cheap substitute for **priocntl -l**; it gets
and prints the range of valid priorities for the time-sharing and fixed
priority scheduler classes.

::

   /*
    *  Get scheduler class IDs and priority ranges.
    */

   #include <sys/types.h>
   #include <sys/priocntl.h>
   #include <sys/fppriocntl.h>
   #include <sys/tspriocntl.h>
   #include <stdio.h>
   #include <string.h>
   #include <stdlib.h>
   #include <errno.h>

   main ()
   {
           pcinfo_t        pcinfo;
           tsinfo_t        *tsinfop;
           fpinfo_t        *fpinfop;
           short           maxtsupri, maxfppri;

      /* time sharing */
           (void) strcpy (pcinfo.pc_clname, "TS");
           if (priocntl (0L, 0L, PC_GETCID, &pcinfo) == -1L) {
                   perror ("PC_GETCID failed for time-sharing class");
                   exit (1);
           }
           tsinfop = (struct tsinfo *) pcinfo.pc_clinfo;
           maxtsupri = tsinfop->ts_maxupri;
           (void) printf("Time sharing: ID %ld, priority range -%d through %d\n",
                   pcinfo.pc_cid, maxtsupri, maxtsupri);

      /* fixed priority */
           (void) strcpy(pcinfo.pc_clname, "FP");
           if (priocntl (0L, 0L, PC_GETCID, &pcinfo) == -1L) {
                   perror ("PC_GETCID failed for fixed priority class");
                   exit (2);
           }
           fpinfop = (struct fpinfo *) pcinfo.pc_clinfo;
           maxfppri = fpinfop->fp_maxpri;
           (void) printf("Fixed priority:    ID %ld, priority range 0 through %d\n",
                   pcinfo.pc_cid, maxfppri);
           return (0);
   }

| The following screen shows the output of this program, called
  **getcid** in this example.
| $ getcid
| Time sharing: ID 1, priority range -20 through 20
| Fixed priority: ID 2, priority range 0 through 59

The following function is useful in the examples below. Given a class
name, it uses **PC_GETCID** to return the class ID and maximum priority
in the class.

--------------

**NOTE:** All the following examples omit the lines that include header
files. The examples compile with the same header files as in the first
example above.

--------------

::

   /*
    *  Return class ID and maximum priority.
    *  Input argument name is class name.
    *  Maximum priority is returned in *maxpri.
    */

   id_t
   schedinfo (name, maxpri)
           char *name;
           short *maxpri;
   {
           pcinfo_t        info;
           tsinfo_t        *tsinfop;
           fpinfo_t        *fpinfop;

           (void) strcpy(info.pc_clname, name);
           if (priocntl (0L, 0L, PC_GETCID, &info) == -1L) {
                   return (-1);
           }
           if (strcmp(name, "TS") == 0) {
                   tsinfop = (struct tsinfo *) info.pc_clinfo;
                   *maxpri = tsinfop->ts_maxupri;
           } else if (strcmp(name, "FP") == 0) {
                   fpinfop = (struct fpinfo *) info.pc_clinfo;
                   *maxpri = fpinfop->fp_maxpri;
           } else {
                   return (-1);
           }
           return (info.pc_cid);
   }

The **PC_GETCLINFO** command gets a scheduler class name and parameters
given the class ID. This command makes it easy to write applications
that make no assumptions about what classes are configured.

The following program uses **PC_GETCLINFO** to get the class name of a
process or LWP based on the process ID. This program assumes the
existence of a function **getclassID**, that retrieves the class ID of a
process or LWP given the process ID; this function is given in the
following section.

::

   /*  Get scheduler class name given process ID. */

   main (argc, argv)
           int argc;
           char *argv[];
   {
           pcinfo_t        pcinfo;
           id_t            pid, classID;
           id_t            getclassID();

           if ((pid = atoi(argv[1])) <= 0) {
                   perror ("bad pid");
                   exit (1);
           }
           if ((classID = getclassID(pid)) == -1) {
                   perror ("unknown class ID");
                   exit (2);
           }
           pcinfo.pc_cid = classID;
           if (priocntl (0L, 0L, PC_GETCLINFO, &pcinfo) == -1L) {
                   perror ("PC_GETCLINFO failed");
                   exit (3);
           }
           (void) printf("process ID %d, class %s\n", pid, pcinfo.pc_clname);
   }

PC_GETPARMS, PC_SETPARMS
------------------------

The **PC_GETPARMS** command gets and the **PC_SETPARMS** command sets
scheduler parameters for processes and LWPs. Both commands use the
**pcparms** structure to send arguments or receive return values: 

::

      typedef struct pcparms {
         id_t  pc_cid;                   /* process or LWP class */
         long  pc_clparms[PC_CLPARMSZ];  /* class specific */
      } pcparms_t;

Ignoring class-specific information for the moment, we can write a
simple function for returning the scheduler class ID of a process or
LWP, as promised in the previous section.

::

   /*
    *  Return scheduler class ID of process or LWP with ID pid.
    */

   getclassID (pid)
           id_t pid;
   {
           pcparms_t       pcparms;

           pcparms.pc_cid = PC_CLNULL;
           if (priocntl(P_PID, pid, PC_GETPARMS, &pcparms) == -1) {
                   return (-1);
           }
           return (pcparms.pc_cid);
   }

For the real-time class, For the fixed priority class, **pc_clparms**
contains an **fpparms** structure. **fpparms** holds scheduler
parameters specific to the

::

      typedef struct fpparms {
         short  fp_pri;      /* fixed priority */
         ulong  fp_tqsecs;   /* seconds in time quantum */
         long   fp_tqnsecs;  /* additional nsecs in quantum */
      } fpparms_t;

**fp_pri** is the fixed priority; **fp_tqsecs** is the number of seconds
and **fp_tqnsecs** is the number of additional nanoseconds in a time
slice. That is, **fp_tqsecs** seconds plus **fp_tqnsecs** nanoseconds is
the interval an LWP may use the CPU without sleeping before the
scheduler gives another LWP a chance at the CPU.

For the time-sharing class, **pc_clparms** contains a **tsparms**
structure. **tsparms** holds the scheduler parameter specific to the
time-sharing class: 

::

      typedef struct tsparms {
         short  ts_uprilim;  /* user priority limit */
         short  ts_upri;     /* user priority */
      } tsparms_t;

**ts_upri** is the user priority, the user-controlled component of a
time-sharing priority. **ts_uprilim** is the user priority limit, the
maximum user priority a process or LWP may set for itself without being
a privileged user. These values are described above in the discussion of
the **-s** option of the **priocntl** command. Both the user priority
and the user priority limit must be within the range reported by the
**priocntl -l** command; this range is also reported by the
**PC_GETCID** and **PC_GETCLINFO** commands to the **priocntl** system
call.

The **PC_GETPARMS** command gets the scheduler class and parameters of a
single process or LWP. The return value of the **priocntl** is the
process ID of the process or LWP whose parameters are returned in the
**pcparms** structure. The process or LWP chosen depends on the
**idtype** and **id** arguments to **priocntl** and on the value of
**pcparms.pc_cid**, which contains **PC_CLNULL** or a class ID returned
by **PC_GETCID**: 

**What gets returned by PC_GETPARMS**

+-----------------+-----------------+-----------------+-----------------+
|                 | pc_cid          |                 |                 |
+=================+=================+=================+=================+
| Number of       | FP class ID     | TS class ID     | PC_CLNULL       |
| processes       |                 |                 |                 |
| selected by     |                 |                 |                 |
| idtype and id   |                 |                 |                 |
+-----------------+-----------------+-----------------+-----------------+
| 1               | FP parameters   | TS parameters   | class and       |
|                 | of process or   | of process or   | parameters of   |
|                 | LWP selected    | LWP selected    | process or LWP  |
|                 |                 |                 | selected        |
+-----------------+-----------------+-----------------+-----------------+
| More than 1     | FP parameters   | TS parameters   | (error)         |
|                 | of              | of process or   |                 |
|                 | h               | LWP with        |                 |
|                 | ighest-priority | highest user    |                 |
|                 | FP process or   | priority        |                 |
|                 | LWP             |                 |                 |
+-----------------+-----------------+-----------------+-----------------+

If **idtype** and **id** select a single process or LWP and **pc_cid**
does not conflict with the class of that process or LWP, **priocntl**
returns the scheduler parameters of the process or LWP. If they select
more than one process or LWP of a single scheduler class, **priocntl**
returns parameters using class-specific criteria as shown in the table.
**priocntl** returns an error in the following cases: 

-  **idtype** and **id** select one or more processes or LWPs and none
   is in the class specified by **pc_cid**.
-  **idtype** and **id** select more than one process or LWP and
   **pc_cid** is **PC_CLNULL**.
-  **idtype** and **id** select no processes or LWPs.

The following program takes a process ID as its input and prints the
scheduler class and class-specific parameters of that process or LWP: 

::

   /*
    *  Get scheduler class and parameters of
    *  process or LWP whose pid is input argument.
    */

   main (argc, argv)
           int argc;
           char *argv[];
   {
           pcparms_t       pcparms;
           fpparms_t       *fpparmsp;
           tsparms_t       *tsparmsp;
           id_t            pid, fpID, tsID;
           id_t            schedinfo();
           short           priority, tsmaxpri, fpmaxpri;
           ulong           secs;
           long            nsecs;

           pcparms.pc_cid = PC_CLNULL;
           fpparmsp = (fpparms_t *) pcparms.pc_clparms;
           tsparmsp = (tsparms_t *) pcparms.pc_clparms;
           if ((pid = atoi(argv[1])) <= 0) {
                   perror ("bad pid");
                   exit (1);
           }

      /* get scheduler properties for this pid */
           if (priocntl(P_PID, pid, PC_GETPARMS, &pcparms) == -1) {
                   perror ("GETPARMS failed");
                   exit (2);
           }

      /* get class IDs and maximum priorities for TS and FP */
           if ((tsID = schedinfo ("TS", &tsmaxpri)) == -1) {
                   perror ("schedinfo failed for TS");
                   exit (3);
           }
           if ((fpID = schedinfo ("FP", &fpmaxpri)) == -1) {
                   perror ("schedinfo failed for FP");
                   exit (4);
           }

      /* print results */
           if (pcparms.pc_cid == fpID) {
                   priority = fpparmsp->fp_pri;
                   secs = fpparmsp->fp_tqsecs;
                   nsecs =  fpparmsp->fp_tqnsecs;
                   (void) printf ("process %d: FP priority %d\n",
                           pid, priority);
                   (void) printf ("time slice %ld secs, %ld nsecs\n",
                           secs, nsecs);
           } else if (pcparms.pc_cid == tsID) {
                   priority = tsparmsp->ts_upri;
                   (void) printf ("process %d: TS priority %d\n",
                           pid, priority);
           } else {
                   printf ("Unknown scheduler class %d\n",
                           pcparms.pc_cid);
                   exit (5);
           }
           return (0);
   }

The **PC_SETPARMS** command sets the scheduler class and parameters of a
set of processes or LWPs. The **idtype** and **id** input arguments
specify the processes or LWPs to be changed. The **pcparms** structure
contains the new parameters: **pc_cid** contains the ID of the scheduler
class to which the processes or LWPs are to be assigned, as returned by
**PC_GETCID**; **pc_clparms** contains the class-specific parameters: 

-  If **pc_cid** is the fixed priority class ID, **pc_clparms** contains
   an **fpparms** structure in which **fp_pri** contains the fixed
   priority and **fp_tqsecs** plus **fp_tqnsecs** contains the time
   slice to be assigned to the processes or LWPs.
-  If **pc_cid** is the time-sharing class ID, **pc_clparms** contains a
   **tsparms** structure in which **ts_uprilim** contains the user
   priority limit and **ts_upri** contains the user priority to be
   assigned to the processes or LWPs.

The following program takes a process ID as input, makes the process or
LWP a fixed priority process or LWP with the highest valid priority
minus 1, and gives it the default time slice for that priority. The
program calls the **schedinfo** function listed above to get the
real-time fixed priority class ID and maximum priority.

::

   /*
    *  Input arg is proc ID.  Make process or LWP a fixed priority
    *  process or LWP with highest priority minus 1.
    */

   main (argc, argv)
           int argc;
           char *argv[];
   {
           pcparms_t       pcparms;
           fpparms_t       *fpparmsp;
           id_t            pid, fpID;
           id_t            schedinfo();
           short           maxrtpri;
           short           maxfppri;

           if ((pid = atoi(argv[1])) <= 0) {
                   perror ("bad pid");
                   exit (1);
           }

      /* Get highest valid FP priority. */
           if ((fpID = schedinfo ("FP", &maxfppri)) == -1) {
                   perror ("schedinfo failed for FP");
                   exit (2);
           }

      /*  Change proc to FP, highest prio - 1, default time slice */
           pcparms.pc_cid = fpID;
           fpparmsp = (struct fpparms *) pcparms.pc_clparms;
           fpparmsp->fp_pri = maxfppri - 1;
           fpparmsp->fp_tqnsecs = FP_TQDEF;

           if (priocntl(P_PID, pid, PC_SETPARMS, &pcparms) == -1) {
                   perror ("PC_SETPARMS failed");
                   exit (3);
           }
   }

The following table lists the special values **fp_tqnsecs** can take
when **PC_SETPARMS** is used on fixed priority processes and LWPs. When
any of these is used, **fp_tqsecs** is ignored. These values are defined
in the header file **fppriocntl.h**: 

=============== ==========
fp_tqnsecs      Time slice
=============== ==========
``FP_TQINF``    infinite
``FP_TQDEF``    default
``FP_NOCHANGE`` unchanged
=============== ==========

**FP_TQINF** specifies an infinite time slice. **FP_TQDEF** specifies
the default time slice configured for the fixed priority being set with
the **SETPARMS** call. **FP_NOCHANGE** specifies no change from the
current time slice; this value is useful, for example, when you change
process or LWP priority but do not want to change the time slice. (You
can also use **FP_NOCHANGE** in the **fp_pri** field to change a time
slice without changing the priority.)

--------------


/The priocntllist system call
=============================

::

      #include    <sys/types.h>
      #include <sys/procset.h>
      #include <sys/priocntl.h>
      #include <sys/fppriocntl.h>
      #include <sys/tspriocntl.h>
      
      long priocntllist(lwpid_t *lwpidp, int idcnt, int cmd, void *arg);

The **priocntllist** system call provides the programming interface to
scheduling policies and policy specific parameters for an arbitrary list
of LWPs within the calling process. **priocntllist** has the same
functions as **priocntl** system call, but a more general way of
specifying the set of LWPs whose scheduling properties are to be
changed. The input argument **lwpidp** points to an array in user memory
of LWP IDs that identify the LWPs to which the system call applies, and
**idcnt** is the number of elements in the array. **cmd** specifies the
function to be performed and **arg** is a pointer to a structure whose
type depends on **cmd**.

--------------

/The priocntlset system call
============================

::

      #include    <sys/types.h>
      #include <sys/signal.h>
      #include <sys/procset.h>
      #include <sys/priocntl.h>
      #include <sys/fppriocntl.h>
      #include <sys/tspriocntl.h>
      
      long priocntlset(procset_t *psp, int cmd, void *arg);

The **priocntlset** system call changes scheduler parameters of a set of
processes or LWPs, just like **priocntl**. **priocntlset** has the same
command set as **priocntl**; the **cmd** and **arg** input arguments are
the same. But while **priocntl** applies to a set of processes or LWPs
specified by a single **idtype/id** pair, **priocntlset** applies to a
set of processes or LWPs that results from a logical combination of two
**idtype/id** pairs. The input argument **psp** points to a **procset**
structure that specifies the two *idtype/id* pairs and the logical
operation to perform. This structure is defined in **procset.h**: 

::

      typedef struct procset {
              idop_t    p_op;         /* operator connecting */
                                      /* left and right sets */
         /* left set:  */
              idtype_t  p_lidtype;    /* left ID type */
              id_t      p_lid;        /* left ID */
      
         /* right set:  */
              idtype_t  p_ridtype;    /* right ID type */
              id_t      p_rid;        /* right ID */
      } procset_t;

**p_lidtype** and **p_lid** specify the ID type and ID of one
(\``left'') set of processes or LWPs; **p_ridtype** and **p_rid**
specify the ID type and ID of a second (\``right'') set of processes or
LWPs. **p_op** specifies the operation to perform on the two sets of
processes or LWPs to get the set of processes or LWPs to operate on. The
valid values for **p_op** and the processes or LWPs they specify are: 

-  **POP_DIFF**: set difference--processes or LWPs in left set and not
   in right set
-  **POP_AND**: set intersection--processes or LWPs in both left and
   right sets
-  **POP_OR**: set union--processes or LWPs in either left or right sets
   or both
-  **POP_XOR**: set exclusive-or--processes or LWPs in left or right set
   but not in both

The following macro, also defined in **procset.h**, offers a convenient
way to initialize a **procset** structure : 

::

      #define setprocset(psp, op, ltype, lid, rtype, rid) \
           (psp)->p_op       = (op); \
           (psp)->p_lidtype  = (ltype); \
           (psp)->p_lid      = (lid); \
           (psp)->p_ridtype  = (rtype); \
           (psp)->p_rid      = (rid);

Here is a situation where **priocntlset** can be useful: an application
has both real-time fixed priority and time-sharing processes that run
under a single user ID. If the application wants to change the priority
of only its fixed priority processes without changing the time-sharing
processes to fixed priority processes, it can do so as follows. (This
example uses the function **schedinfo**, which is defined above in the
section on **PC_GETCID**.)

::

   /*
    *  Change fixed priorities of this uid
    *  to highest fixed priority minus 1.
    */

   main (argc, argv)
           int argc;
           char *argv[];
   {
           procset_t       procset;
           pcparms_t       pcparms;
           struct fpparms  *fpparmsp;
           id_t            fpclassID;
           id_t            schedinfo();
           short           maxfppri;

      /* left set: select processes with same uid as this process */
           procset.p_lidtype = P_UID;
           procset.p_lid = getuid();

      /* get info on fixed priority class */
           if ((fpclassID = schedinfo ("FP", &maxfppri)) == -1) {
                   perror ("schedinfo failed");
                   exit (1);
           }

      /* right set: select fixed priority processes */
           procset.p_ridtype = P_CID;
           procset.p_rid = fpclassID;

      /* select only my FP processes */
           procset.p_op = POP_AND;

      /* specify new scheduler parameters */
           pcparms.pc_cid = fpclassID;
           fpparmsp = (struct fpparms *) pcparms.pc_clparms;
           fpparmsp->fp_pri = maxfppri - 1;
           fpparmsp->fp_tqnsecs = FP_NOCHANGE;
           if (priocntlset (&procset, PC_SETPARMS, &pcparms) == -1) {
                   perror ("priocntlset failed");
                   exit (2);
           }
   }

**priocntl** offers a simple scheduler interface that is adequate for
many applications; applications that need a more powerful way to specify
sets of processes or LWPs can use **priocntlset**.

--------------

/Scheduler interaction with other functions
===========================================

The kernel assigns its demon and housekeeping processes to the system
scheduler class. Users may neither add processes or LWPs to nor remove
processes or LWPs from this class, nor may they change the priorities of
these processes or LWPs. The command **ps -cel** lists the scheduler
class of all processes or LWPs. Processes in the system class are
identified by a **SYS** entry in the **CLS** column.

If the workload on a machine contains fixed priority processes or LWPs
that use too much CPU, they can lock out system processes, which can
lead to all sorts of trouble. Fixed priority applications must ensure
that they leave some CPU time for system and other processes and LWPs.

fork, exec
----------

Scheduler class, priority, and other scheduler parameters are inherited
across the `fork\ (S) <../man/html.S/fork.S.html>`__ and
`exec\ (S) <../man/html.S/exec.S.html>`__ system calls.

nice
----

The `nice\ (C) <../man/html.C/nice.C.html>`__ command and the
`nice\ (S) <../man/html.S/nice.S.html>`__ system call work as in
previous versions of the UNIX system. They allow you to change the
priority of only a time-sharing process or LWP. You still use lower
numeric values to assign higher time-sharing priorities with these
functions.

To change the scheduler class of a process or LWP or to specify a fixed
priority, you must use one of the **priocntl** functions. Use higher
numeric values to assign higher priorities with the **priocntl**
functions.

init
----

The **init** process (process ID 1) may be assigned to any class
configured on the system. Because most processes and LWPs normally
inherit the scheduler properties of **init**, **init** must be the only
process specified by **idtype** and **id** or by the **procset**
structure. However, **init** should be assigned to the time-sharing
class unless there are compelling reasons to do otherwise.

--------------


/Scheduler performance
======================

Because the scheduler determines when and for how long LWPs run, it has
an overriding importance in the performance and perceived performance of
a system.

By default, all processes and LWPs are time-sharing processes or LWPs. A
process or LWP changes class only as a result of one of the **priocntl**
functions.

In the default configuration, all real-time fixed priority process
priorities are above any time-sharing process priority. This implies
that as long as any fixed priority process or LWP is runnable, no
time-sharing process or LWP or system process ever runs. So if a fixed
priority application is not written carefully, it can completely lock
out users and essential kernel housekeeping.

Besides controlling process and LWP class and priorities, a fixed
priority application must also control several other factors that
influence its performance. The most important factors in performance are
CPU power, amount of primary memory, and I/O throughput. These factors
interact in complex ways. In particular, the
`sar\ (ADM) <../man/html.ADM/sar.ADM.html>`__ command has options for
reporting on all the factors discussed in this section.

--------------

/LWP state transition
=====================

Applications that have strict fixed priority constraints may need to
prevent processes and LWPs from being swapped or paged out to secondary
memory. Here's a simplified overview of UNIX system LWP states and the
transitions between states: 

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/statrans.gif

**LWP state transition diagram**

An active LWP is normally in one of the five states in the diagram. The
arrows show how it changes states.

-  An LWP is running if it is assigned to a CPU. An LWP is
   preempted--that is, removed from the running state--by the scheduler
   if an LWP with a higher priority becomes runnable. An LWP is also
   preempted if it consumes its entire time slice and An LWP of equal
   priority is runnable.
-  An LWP is runnable in memory if it is in primary memory and ready to
   run, but is not assigned to a CPU.
-  An LWP is sleeping in memory if it is in primary memory but is
   waiting for a specific event before it can continue execution. For
   example, an LWP is sleeping if it is waiting for an I/O operation to
   complete, for a locked resource to be unlocked, or for a timer to
   expire. When the event occurs, the process is sent a wakeup; if the
   reason for its sleep is gone, the LWP becomes runnable.
-  An LWP is runnable and swapped if it is not waiting for a specific
   event but has had its whole address space written to secondary memory
   to make room in primary memory for other LWPs.
-  An LWP is sleeping and swapped if it is both waiting for a specific
   event and has had its whole address space written to secondary memory
   to make room in primary memory for other processes or LWPs.

If a machine does not have enough primary memory to hold all its active
processes and LWPs, it must page or swap some address space to secondary
memory: 

-  When the system is short of primary memory, it writes individual
   pages of some processes and LWPs to secondary memory but leaves those
   processes and LWPs runnable. When an LWP runs, if it accesses those
   pages, it must sleep while the pages are read back into primary
   memory.
-  When the system gets into a more serious shortage of primary memory,
   it writes all the pages of some processes and LWPs to secondary
   memory and marks those processes and LWPs as swapped. Such processes
   and LWPs get back into a schedulable state only by being chosen by
   the system scheduler demon process, then read back into memory.

Both paging and swapping, and especially swapping, introduce delay when
a process or LWP is ready to run again. For processes and LWPs that have
strict timing requirements, this delay can be unacceptable. To avoid
swapping delays, fixed priority processes and LWPs are never swapped,
though parts of them may be paged. An application can prevent paging and
swapping by locking its text and data into primary memory. For more
information see **memcntl**\ (S). Of course, how much can be locked is
limited by how much memory is configured. Also, locking too much can
cause intolerable delays to processes and LWPs that do not have their
text and data locked into memory. Tradeoffs between performance of fixed
priority processes and LWPs and performance of other processes and LWPs
depend on local needs. On some systems, process locking may be required
to guarantee the necessary fixed priority response.

--------------




/Software latencies
===================

Designers of some fixed priority applications must have information on
software latencies to analyze the performance characteristics of their
applications and to predict whether performance constraints can be met.
These latencies depend on kernel implementation and on system hardware,
so it is not practical to list the latencies. It is useful, however, to
describe some of the most important latencies. Consider the following
time-line: 

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/latent.gif

L1 and L2 represent LWPs; t1 through t6 represent points in time.
Suppose that L1 has a higher priority than all other active LWPs,
including L2. L1 runs and does a system call that causes it to sleep at
time t1, waiting for I/O. L2 runs. The I/O device interrupts, resulting
in a wakeup at time t3 that makes L1 runnable. If L2 is running in user
mode at time t3, it is preempted immediately and the interval (t4 - t3)
is, for practical purposes, zero. If L2 is running in kernel mode at
time t3, it is preempted as soon as it gets to a safe place for
preemption, a point in kernel code where no spin locks are held and
where the state of the current LWP (L2 in this example) may be saved and
a different LWP run. Therefore, if L2 is running in kernel mode at time
t3, the interval (t4 - t3) depends on how long the kernel code needs to
run before getting to such a safe point. It is useful to know both a
typical time to preemption and a maximum time to preemption; these times
depend on kernel implementation and on hardware. Eventually, the
scheduler runs (at time t4), finds that a higher-priority LWP L1 is
runnable, and runs it. We refer to the interval (t5 - t4) as the
software switch latency of the system. This latency is, for practical
purposes, a constant; again, it is an implementation-dependent value. At
time t6, L1 returns to the user program from the system call that put it
to sleep at time t1. For simplicity, suppose that the program is getting
only a few bytes of data from the I/O device. In this simple case, the
interval (t6 - t5) consists primarily of the overhead of getting out of
the system call. We refer to the interval (t6 - t3) as the software
wakeup latency of the system; this is the interval from the I/O device
interrupt until the user LWP returns to application level to deal with
the interrupt (if it is the highest priority LWP). So the software
wakeup latency is composed of a preemption latency, context-switch time,
and a part of system call overhead. Of course, the latency increases as
the system call asks for more data.

This discussion of latencies assumes that the text and data of the
processes and LWPs are in primary memory. An application may have to use
process locking to guarantee that its processes and LWPs do not get
swapped or paged out of primary memory. See the discussion in the
previous section.

--------------




/Managing processors and processes
==================================

The following sections discuss how to manage a system's processors and
processes.

Processor administration information
------------------------------------

Processors are identified with a processor ID number that gives them a
unique tag within the system. The state of the processors in your system
can be examined by using the **psrinfo**\ (ADM) command or the
**processor_info**\ (S) system call. They report whether the processor
is online or offline.

Taking processors online and offline
------------------------------------

When a processor is online, it can dispatch processes and perform normal
operating system functions. You can bring a processor online with the
**psradm**\ (ADM) command or the **p_online**\ (S) system call. Taking a
processor offline removes the processor from operational status. The
processor retains its place in the system but does not perform any
useful operations while it is idle.

Only processors with no bound processes can be taken offline. Some
hardware platforms may require some processors to be online at all
times. A processor can be taken offline with the **psradm**\ (ADM)
command or the **p_online**\ (S) system call. Once a processor has been
taken offline, it remains idle until it is brought back online using the
**psradm**\ (ADM) command or the **p_online**\ (S) system call.

Binding processes to processors
-------------------------------

By default, an LWP can execute on any processor in the system. You can
use the **pbind**\ (ADM) command or the **processor_bind**\ (S) system
call to bind a process (all of the associated LWPs) or LWP to a
processor. This restricts the LWPs to execute only on the specified
processor. Once bound, all child processes created by this process or
timeout routines requested by this process are bound by default to the
same processor. The **-P** option of the
`ps\ (C) <../man/html.C/ps.C.html>`__ command can be used to display the
processor binding status of all processes in the system. The
**pbind**\ (ADM) command can also be used to unbind a process (all the
associated LWPs) or LWP from a processor. Once unbound, the process or
LWP can execute on any processor in the system.

Placing processors in an exclusive binding mode
-----------------------------------------------

You can use the **pexbind**\ (ADM) command or the 
**processor_exbind**\ (S) system call to place a processor in an
exclusive binding mode, or to unbind it. When a processor has been
placed in an exclusive binding mode, it will execute only LWPs bound to
that processor. It will not execute any other LWPs in the system even
when the processor is idle. If a kernel driver requires a resource that
is available only in the exclusively bound processor, the processor is
still available for the kernel driver even though it is not available
for user level LWPs that are not exclusively bound to it.

For example, if a driver is exclusively bound to the processor, and a
process requires the service of this device driver, the operating system
will temporarily bind the process to the processor and execute the
process on the processor for the duration of the driver routine. Once
the driver operation is complete, the operating system will unbind the
outside process from the processor and restrict itself again only to
processes that are bound to the processor. Also, processes that are
exclusively bound to a processor are restricted to run only on that
processor.

--------------


/Memory management facilities
=============================

The SCO OpenServer system provides a complete set of memory management
mechanisms, providing applications complete control over the
construction of their address space and permitting a wide variety of
operations on both process address spaces and the variety of memory
objects in the system. Process address spaces are composed of a vector
of memory pages, each of which can be independently mapped and
manipulated. Typically, the system presents the user with mappings that
simulate the traditional UNIX process memory environment, but other
views of memory are useful as well.

The SCO OpenServer memory-management facilities: 

-   Unify the system's operations on memory.
-  Provide a set of kernel mechanisms powerful and general enough to
   support the implementation of fundamental system services without
   special-purpose kernel support.
-  Maintain consistency with the existing environment, in particular
   using the UNIX file system as the name space for named virtual-memory
   objects.

--------------

/Virtual memory, address spaces and mapping
===========================================

The system's virtual memory (VM) consists of all available physical
memory resources. Examples include local and remote file systems,
processor primary memory, swap space, and other random-access devices.
Named objects in the virtual memory are referenced though the UNIX file
system. However, not all file system objects are in the virtual memory;
devices that cannot be treated as storage, such as terminal and network
device files, are not in the virtual memory. Some virtual memory
objects, such as private process memory and shared memory segments, do
not have names.

A process's address space is defined by mappings onto objects in the
system's virtual memory (usually files). Each mapping is constrained to
be sized and aligned with the page boundaries of the system on which the
process is executing. Each page may be mapped (or not) independently.
Only process addresses which are mapped to some system object are valid,
for there is no memory associated with processes themselves--all memory
is represented by objects in the system's virtual memory.

Each object in the virtual memory has an object address space defined by
some physical storage. A reference to an object address accesses the
physical storage that implements the address within the object. The
virtual memory's associated physical storage is thus accessed by
transforming process addresses to object addresses, and then to the
physical store.

A given process page may map to only one object, although a given object
address may be the subject of many process mappings. An important
characteristic of a mapping is that the object to which the mapping is
made is not affected by the mere existence of the mapping. Thus, it
cannot, in general, be expected that an object has an \``awareness'' of
having been mapped, or of which portions of its address space are
accessed by mappings; in particular, the notion of a \``page'' is not a
property of the object. Establishing a mapping to an object simply
provides the potential for a process to access or change the object's
contents.

The establishment of mappings provides an access method that renders an
object directly addressable by a process. Applications may find it
advantageous to access the storage resources they use directly rather
than indirectly through **read** and **write**. Potential advantages
include efficiency (elimination of unnecessary data copying) and reduced
complexity (single-step updates rather than the **read**, modify buffer,
**write** cycle). The ability to access an object and have it retain its
identity over the course of the access is unique to this access method,
and facilitates the sharing of common code and data.

--------------

/Networking, heterogeneity and integrity
========================================

VM is designed to fit well with the larger UNIX heterogeneous
environment. This environment makes extensive use of networking to
access file systems--file systems that are now part of the system's
virtual memory. Networks are not constrained to consist of similar
hardware or to be based upon a common operating system; in fact, the
opposite is encouraged, for such constraints create serious barriers to
accommodating heterogeneity. While a given set of processes may apply a
set of mechanisms to establish and maintain the properties of various
system objects--properties such as page sizes and the ability of objects
to synchronize their own use--a given operating system should not impose
such mechanisms on the rest of the network.

| As it stands, the access method view of a virtual memory maintains the
  potential for a given object (say a text file) to be mapped by systems
  running the UNIX memory management system and also to be accessed by
  systems for which virtual memory and storage management techniques
  such as paging are totally foreign, such as PC-DOS. Such systems can
  continue to share access to the object, each using and providing its
  programs with the access method appropriate to that
| system. The unacceptable alternative would be to prohibit access to
  the object by less capable systems.

Another consideration arises when applications use an object as a
communications channel, or otherwise try to access it simultaneously. In
both cases, the object is shared; thus, applications must use some
synchronization mechanism to maintain the integrity of their actions on
it. The scope and nature of the synchronization mechanism is best left
to the application. For example, file access on systems which do not
support virtual memory access methods must be indirect, by way of
**read** and **write**. Applications sharing files on such systems must
coordinate their access using semaphores, file locking, or some
application-specific protocols. What is required in an environment where
mapping replaces **read** and **write** as the access method is an
operation, such as **fsync**, that supports atomic update operations.

The nature and scope of synchronization over shared objects is
application-defined from the outset. If the system tried to impose
automatic semantics for sharing, it might prohibit other useful forms of
mapped access that have nothing to do with communication or sharing. By
providing the mechanism to support integrity, and leaving it to
cooperating applications to apply the mechanism, the needs of
applications are met without eliminating diversity. Note that this
design does not prohibit the creation of libraries that provide
abstractions for common application needs. Not all abstractions on which
an application builds need be supplied by the \``operating system.''

--------------

/Memory management interfaces
=============================

The applications programmer gains access to VM facilities through
several sets of system calls. The next sections summarize these calls,
and provide examples of their use.

--------------

/Creating and using mappings
============================

::

   caddr_t
   mmap(caddr_t addr, size_t len, int prot, int flags, int fd, off_t off);

**mmap** establishes a mapping between a process's address space and an
object in the system's virtual memory. All other system functions that
contribute to the definition of an address space are built from
**mmap**, the system's most fundamental function for defining the
contents of an address space. The format of an **mmap** call is: 

::

   paddr = mmap(addr, len, prot, flags, fd, off);

**mmap** establishes a mapping from the process's address space at an
address **paddr** for **len** bytes to the object specified by **fd** at
offset **off** for **len** bytes. A successful call to **mmap** returns
**paddr** as its result, which is an implementation-dependent function
of the parameter **addr** and the setting of the **MAP_FIXED** bit of
**flags**, as described below. The address range **[paddr, paddr +
len)** must be valid for the address space of the process and the range
**[off, off + len)** must be valid for the virtual memory object. (The
notation **[start, end)** denotes the interval from **start** to
**end**, including **start** but excluding **end**.)

--------------

**NOTE:** The mapping established by **mmap** replaces any previous
mappings for the process's pages in the range **[paddr, paddr + len)**.

--------------

The parameter **prot** determines whether read, execute, write or some
combination of accesses are permitted to the pages being mapped. To deny
all access, set **prot** to **PROT_NONE**. Otherwise, specify
permissions by an OR of **PROT_READ**, **PROT_EXECUTE**, and
**PROT_WRITE**.

A write access must fail if **PROT_WRITE** has not been set, though the
behavior of the write can be influenced by setting **MAP_PRIVATE** in
the **flags** parameter, which provides other information about the
handling of mapped pages, as described below: 

-  **MAP_SHARED** and **MAP_PRIVATE** specify the mapping type, and one
   of them must be specified. The mapping type describes the disposition
   of store operations made by this process into the address range
   defined by the mapping operation. If **MAP_SHARED** is specified,
   write references will modify the mapped object. No further operations
   on the object are necessary to effect a change -- the act of storing
   into a **MAP_SHARED** mapping is equivalent to doing a **write**
   system call.

   --------------

   **NOTE:** The private copy is not created until the first write;
   until then, other users who have the object mapped **MAP_SHARED** can
   change the object. That is, if one user has an object mapped
   **MAP_PRIVATE** and another user has the same object mapped
   **MAP_SHARED**, and the **MAP_SHARED** user changes the object before
   the **MAP_PRIVATE** user does the first write, then the changes
   appear in the **MAP_PRIVATE** user's copy that the system makes on
   the first write. If an application needs isolation from changes made
   by other processes, it should use **read** to make a copy of the data
   it wishes to keep isolated.

   --------------

   On the other hand, if **MAP_PRIVATE** is specified, an initial write
   reference to a page in the mapped area will create a copy of that
   page and redirect the initial and successive write references to that
   copy. This operation is sometimes referred to as copy-on-write and
   occurs invisibly to the process causing the store. Only pages
   actually modified have copies made in this manner. **MAP_PRIVATE**
   mappings are used by system functions such as
   `exec\ (S) <../man/html.S/exec.S.html>`__ when mapping files
   containing programs for execution. This permits operations by
   programs such as debuggers to modify the \``text'' (code) of the
   program without affecting the file from which the program is
   obtained.

   The mapping type is retained across a **fork**.

-  **MAP_FIXED** informs the system that the value returned by **mmap**
   must be **addr**, exactly. The use of **MAP_FIXED** is discouraged,
   as it may prevent an implementation from making the most effective
   use of system resources. When **MAP_FIXED** is not set, the system
   uses **addr** as a hint to arrive at **paddr**. The **paddr** so
   chosen is an area of the address space that the system deems suitable
   for a mapping of **len** bytes to the specified object. An **addr**
   value of zero grants the system complete freedom in selecting
   **paddr**, subject to constraints described below. A non-zero value
   of **addr** is taken as a suggestion of a process address near which
   the mapping should be placed. When the system selects a value for
   **paddr**, it never places a mapping at address 0, nor replaces any
   extant mapping, nor maps into areas considered part of the potential
   data or stack \``segments.'' The system strives to choose alignments
   for mappings that maximize the performance of the its hardware
   resources.

The file descriptor used in a **mmap** call need not be kept open after
the mapping is established. If it is closed, the mapping will remain
until such time as it is replaced by another call to **mmap** that
explicitly specifies the addresses occupied by this mapping; or until
the mapping is removed either by process termination or a call to
**munmap**. Although the mapping endures independent of the existence of
a file descriptor, changes to the file can influence accesses to the
mapped area, even if they do not affect the mapping itself. For
instance, should a file be shortened by a call to **truncate**, such
that the mapping now \``overhangs'' the end of the file, then accesses
to that area of the file which \``does not exist'' will result in
**SIGBUS** signals. It is possible to create the mapping in the first
place such that it \``overhangs'' the end of the file -- the only
requirement when creating a mapping is that the addresses, lengths, and
offsets specified in the operation be possible (that is, within the
range permitted for the object in question), not that they exist at the
time the mapping is created (or subsequently.)

| Similarly, if a program accesses an address in a manner inconsistently
  with how it has been mapped (for instance, by attempting a store
  operation into a mapping that was established with only **PROT_READ**
  access), then a **SIGSEGV** signal will
| result. **SIGSEGV** signals will also result on any attempt to
  reference an address not defined by any mapping.

In general, if a program makes a reference to an address that is
inconsistent with the mapping (or lack of a mapping) established at that
address, the system will respond with a **SIGSEGV** violation. However,
if a program makes a reference to an address consistent with how the
address is mapped, but that address does not evaluate at the time of the
access to allocated storage in the object being mapped, then the system
will respond with a **SIGBUS** violation. In this manner a program (or
user) can distinguish between whether it is the mapping or the object
that is inconsistent with the access, and take appropriate remedial
action.

Using **mmap** to access system memory objects can simplify programs in
a variety of ways. Keeping in mind that **mmap** can really be viewed as
just a means to access memory objects, it is possible to program using
**mmap** in many cases where you might program with **read** or
**write**. However, it is important to realize that **mmap** can only be
used to gain access to memory objects -- those objects that can be
thought of as randomly accessible storage. Thus, terminals and network
connections cannot be accessed with **mmap** because they are not
\``memory.'' Magnetic tapes, even though they are memory devices, can
not be accessed with **mmap** because storage locations on the tape can
only be addressed sequentially. Some examples of situations which can be
thought of as candidates for use of **mmap** over more traditional
methods of file access include: 

-  Random access operations -- either map the entire file into memory
   or, if the address space can not accommodate the file or if the file
   size is variable, create \``windows'' of mappings to the object.
-  Efficiency -- even in situations where access is sequential, if the
   object being accessed can be accessed via **mmap**, an efficiency
   gain may be obtained by avoiding the copying operations inherent in
   accesses via **read** or **write**.
-  Structured storage -- if the storage being accessed is collected as
   tables or data structures, algorithms can be more conveniently
   written if access to the file is treated just as though the tables
   were in memory. Previously, programs could not simply make storage or
   table alterations in memory and save them for access in subsequent
   runs; however, when the addresses of a table are defined by mappings
   to a file, then changes to that storage are changes to the file, and
   are thus automatically recorded in it.
-  Scattered storage -- if a program requires scattered regions of
   storage, such as multiple heaps or stack areas, such areas can be
   defined by mapping operations during program operation.

The remainder of this section will illustrate some other concepts
surrounding mapping creation and use.

Mapping **/dev/zero** gives the calling program a block of zero-filled
virtual memory of the size specified in the call to **mmap**.
**/dev/zero** is a special device, that responds to **read** as an
infinite source of bytes with the value 0, but when mapped creates an
unnamed object to back the mapped region of memory. The following code
fragment demonstrates a use of this to create a block of scratch storage
in a program, at an address of the system's choosing.

::

   /*
    * Function to allocate a block of zeroed storage.  Parameter
    * is the number of bytes desired.  The storage is mapped as
    * MAP_SHARED, so that if a fork occurs, the child process
    * will be able to access and modify the storage.  If we wished
    * to cause the child's modifications (as well as those by the
    * parent) to be invisible to the ancestry of processes, we
    * would use MAP_PRIVATE.
    */
   caddr_t
   get_zero_storage(int len);
   {
       int fd;
       caddr_t result;

       if ((fd = open("/dev/zero", O_RDWR)) == -1)
           return ((caddr_t)-1);
       result = mmap(0, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
       (void) close(fd);
       return (result);
   }

As written, this function permits a hierarchy of processes to use the
area of allocated storage as a region of communication (for implicit
interprocess communication purposes). Later in this section we will
describe a set of system facilities that provide a similar function
packaged for accomplishing the same purpose without requiring that the
processes be in a parent-child hierarchy.

In some cases, devices or files are only useful if accessed via mapping.
An example of this is frame buffer devices used to support bit-mapped
displays, where display management algorithms function best if they can
operate randomly on the addresses of the display directly.

Finally, it is important to remember that mappings can be operated upon
at the granularity of a single page. Even though a mapping operation may
define multiple pages of an address space, there is no restriction that
subsequent operations on those addresses must operate on the same number
of pages. For instance, an **mmap** operation defining ten pages of an
address space may be followed by subsequent **munmap** (see below)
operations that remove every other page from the address space, leaving
five mapped pages each followed by an unmapped page. Those unmapped
pages may subsequently be mapped to different locations in the same or
different objects, or the whole range of pages (or any partition,
superset, or subset of the pages) used in other **mmap** or other memory
management operations. Further, it must be noted that any mapping
operation that operates on more than a single page can \``partially
succeed'' in that some parts of the address range can be affected even
though the call returns a failure. Thus, an **mmap** operation that
replaces another mapping, if it fails, may have deleted the previous
mapping and failed to replace it. Similarly, other operations (unless
specifically stated otherwise) may process some pages in the range
successfully before operating on a page where the operation fails.

Not all device drivers support memory mapping. **mmap** fails if you try
to map a device that does not support mapping.

--------------


/Removing mappings
==================

::

   int
   munmap(caddr_t addr, size_t len);

**munmap** removes all mappings for pages in the range **[addr, addr +
len)** from the address space of the calling process. It is not an error
to remove mappings from addresses that do not have them, and any
mapping, no matter how it was established, can be removed with
**munmap**. **munmap** does not in any way affect the objects that were
mapped at those addresses.

--------------


/Cache control
==============

The SCO OpenServer memory management system can be thought of as a form
of \``cache management'', in which a processor's primary memory is used
as a cache for pages from objects from the system's virtual memory.
Thus, there are a number of operations which control or interrogate the
status of this \``cache'', as described in this section.

Memory cache control
--------------------

::

   int
   memcntl(caddr_t addr, size_t len, int cmd, caddr_t arg, int attr, int mask);

**memcntl** provides several control operations over mappings in the
range **[addr, addr + len)**, including locking pages into physical
memory, unlocking them, and writing pages to secondary storage. The
functions described in the rest of this section offer simplified
interfaces to the **memcntl** operations.

Memory page locking
-------------------

::

   int
   mlock(caddr_t addr, size_t len);

   int
   munlock(caddr_t addr, size_t len);

**mlock** causes the pages referenced by the mapping in the range
**[addr, addr + len)** to be locked in physical memory. References to
those pages (through other mappings in this or other processes) will not
result in page faults that require an I/O operation to obtain the data
needed to satisfy the reference. Because this operation ties up physical
system resources, and has the potential to disrupt normal system
operation, use of this facility is restricted to the superuser. The
system prohibits more than a configuration-dependent limit of pages to
be locked in memory simultaneously, the call to **mlock** will fail if
this limit is exceeded.

**munlock** releases the locks on physical pages. If multiple **mlock**
calls are made through the same mapping, only a single **munlock** call
will be required to release the locks (in other words, locks on a given
mapping do not nest.) However, if different mappings to the same pages
are processed with **mlock**, then the pages will stay locked until the
locks on all the mappings are released.

| Locks are also released when a mapping is removed, either through
  being replaced with an **mmap** operation or removed explicitly with
  **munmap**. A lock will be transferred between pages on the
  \``copy-on-write'' event associated with a **MAP_PRIVATE** mapping,
  thus locks on an address range that includes **MAP_PRIVATE** mappings
  will be retained transparently along with the copy-on-write
  redirection (see **mmap** above for a discussion of this redirection).
| 

Address space locking
---------------------

::

   int
   mlockall(int flags);

   int
   munlockall(void);

**mlockall** and **munlockall** are similar in purpose and restriction
to **mlock** and **munlock**, except that they operate on entire address
spaces. **mlockall** accepts a **flags** argument built as a bit-field
of values from the set: 

  =========== ================
  MCL_CURRENT Current mappings
  MCL_FUTURE  Future mappings
  =========== ================

If **flags** is **MCL_CURRENT**, the lock is to affect everything
currently in the address space. If **flags** is **MCL_FUTURE**, the lock
is to affect everything added in the future. If **flags** is
**(MCL_CURRENT \| MCL_FUTURE)**, the lock is to affect both current and
future mappings.

**munlockall** removes all locks on all pages in the address space,
whether established by **mlock** or **mlockall**.

Memory cache synchronization
----------------------------

::

   int
   msync(caddr_t addr, size_t len, int flags);

**msync** supports applications which require assertions about the
integrity of data in the storage backing their mapping, either for
correctness or for coherent communications in a distributed environment.
**msync** causes all modified copies of pages over the range **[addr,
addr + len)** to be flushed to the objects mapped by those addresses. In
the cache analogy discussed previously, **msync** is the cache
\``write-back,'' or flush, operation. It is similar in purpose to the
**fsync** operation for files.

**msync** optionally invalidates such cache entries so that further
references to the pages cause the system to obtain them from their
permanent storage locations.

The **flags** argument provides a bit-field of values that influences
the behavior of **msync**. The bit names and their interpretations are: 

============= ==================
MS_SYNC       synchronized write
MS_ASYNC      return immediately
MS_INVALIDATE invalidate caches
============= ==================

**MS_SYNC** causes **msync** to return only after all I/O operations are
complete. **MS_ASYNC** causes **msync** to return immediately once all
I/O operations are scheduled. **MS_INVALIDATE** causes all cached copies
of data from mapped objects to be invalidated, requiring them to be
reobtained from the object's storage upon the next reference.

Memory page residency
---------------------

::

   int
   mincore(caddr_t addr, size_t len, char *vec);

**mincore** determines the residency of the memory pages in the address
space covered by mappings in the range **[addr, addr + len)**. Using the
\``cache concept'' described earlier, this function can be viewed as an
operation that interrogates the status of the cache, and returns an
indication of what is currently resident in the cache. The status is
returned as a char-per-page in the character array referenced by
**\*vec** (which the system assumes to be large enough to encompass all
the pages in the address range). Each character contains either a \``1''
(indicating that the page is resident in the system's primary storage),
or a \``0'' (indicating that the page is not resident in primary
storage.) Other bits in the character are reserved for possible future
expansion -- therefore, programs testing residency should test only the
least significant bit of each character.

**mincore** returns residency information that is accurate at an instant
in time. Because the system may frequently adjust the set of pages in
memory, this information may quickly be outdated. Only locked pages are
guaranteed to remain in memory.

--------------

/Other mapping functions
========================

::

   long
   sysconf(PAGESIZE);

**sysconf** returns the system-dependent size of a memory page. For
portability, applications should not embed any constants specifying the
size of a page, and instead should make use of **sysconf** to obtain
that information. Note that it is not unusual for page sizes to vary
even among implementations of the same instruction set, increasing the
importance of using this function for portability.

::

   int
   mprotect(caddr_t addr, size_t len, int prot);

**mprotect** has the effect of assigning protection **prot** to all
pages in the range **[addr, addr + len)**. The protection assigned can
not exceed the permissions allowed on the underlying object. For
instance, a read-only mapping to a file that was opened for read-only
access can not be set to be writable with **mprotect** (unless the
mapping is of the **MAP_PRIVATE** type, in which case the write access
is permitted since the writes will modify copies of pages from the
object, and not the object itself).

--------------

/Address space layout
=====================

Traditionally, the address space of a SCO OpenServer process has
consisted of exactly three segments: one each for write-protected
program code (text), a heap of dynamically allocated storage (data), and
the process's stack. Text is read-only and shared, while the data and
stack segments are private to the process.

System V Release 4 still uses text, data, and stack segments, though
these should be thought of as constructs provided by the programming
environment rather than by the operating system. As such, it is possible
to construct processes that have multiple segments of each \``type,'' or
of types of arbitrary semantic value -- no longer are programs
restricted to being built only from objects the system was capable of
representing directly. For instance, a process's address space may
contain multiple text and data segments, some belonging to specific
programs and some shared among multiple programs. Text segments from
shared libraries, for example, typically appear in the address spaces of
many processes. A process's address space is simply a vector of pages,
and there is no necessary division between different address-space
segments. Process text and data spaces are simply groups of pages mapped
in ways appropriate to the function they provide the program.

While the system may have multiple areas that can be considered
\``data'' segments, for programming convenience the system maintains
operations to operate on an area of storage associated with a process's
initial \``heap storage area.'' A process can manipulate this area by
calling **brk** and **sbrk**: 

::

   caddr_t
   brk(caddr_t addr);

   caddr_t
   sbrk(int incr);

**brk** sets the system's idea of the lowest data segment location not
used by the caller to **addr** (rounded up to the next multiple of the
system's page size).

**sbrk**, the alternate function, adds **incr** bytes to the caller's
data space and returns a pointer to the start of the new data area.

A process's address space is usually sparsely populated, with data and
text pages intermingled. The precise mechanics of the management of
stack space is machine-dependent. By convention, page 0 is not used.
Process address spaces are often constructed through dynamic linking
when a program is **exec**'ed. Operations such as **exec** and dynamic
linking build upon the mapping operations described previously. Dynamic
linking is described further in `Programming in standard C and
C++ <../SDK_cprog/CONTENTS.html>`__.

--------------

/5. Terminal device control
============================

This section discusses the general terminal interface to control
asynchronous communication ports. The functions on the
`termio\ (M) <../man/html.M/termio.M.html>`__ manual page are used to
access and configure the hardware interface to a terminal.

Also included is a discussion of the mechanisms involved with opening
and closing a terminal device file, as well as input/output processing.

The remainder of this section addresses the STREAMS mechanism as it
relates to terminal device control. The STREAMS-based terminal subsystem
provides a uniform interface for implementing character I/O devices and
networking protocols in the kernel. Also discussed here is the notion of
the STREAMS-based pseudo-terminal subsystem which provides the user with
an identical interface to the STREAMS-based terminal subsystem.

--------------

/General terminal interface
===========================

Terminal Device Control functions offer a general terminal interface for
controlling asynchronous communication-ports in a device-independent
manner using parameters stored in the **termios** structure which is
defined by the *<termios.h>* header file (see
`termio\ (M) <../man/html.M/termio.M.html>`__). UNIX System V also uses
**termios** to control the operation of network-connections.

**Terminal device control functions**

=============== ===============================
Function        Description
=============== ===============================
**cfgetospeed** get output baud-rate
**cfsetospeed** set output baud-rate
**cfgetispeed** get input baud-rate
**cfsetispeed** set input baud-rate
**tcgetattr**   get state of terminal
**tcsetattr**   set state of terminal
**tcsendbreak** line control function
**tcdrain**     line control function
**tcflush**     line control function
**tcflow**      line control function
**tcgetpgrp**   get foreground process-group-id
**tcsetpgrp**   set foreground process-group-id
=============== ===============================

The **termios** structure stores the values of settable terminal I/O
parameters used by functions to control terminal I/O characteristics and
the operation of a terminal-device-file. The *<termios.h>* header file
defines the **termios** structure to contain at least the following
members (see `termio\ (M) <../man/html.M/termio.M.html>`__): 

::

      tcflag_t  c_iflag;      /* input modes */
      tcflag_t  c_oflag;      /* output modes */
      tcflag_t  c_cflag;      /* control modes */
      tcflag_t  c_lflag;      /* local modes */
      cc_t      c_cc[NCCS];   /* control chars */

The *<termios.h>* header file defines the type **tcflag_t** as **long**,
the type **cc_t** as **char**. The *<termios.h>* header file also
defines the symbolic-constant **NCCS** as the size of the
control-character array.

--------------

/Baud rates
===========

The structure **termios** stores the input and output baud-rates in
*c_cflag*. The table below shows symbolic names defined in *<termios.h>*
and the baud-rate each represents: 

========== ===========
Name       Description
========== ===========
**B0**     hang up
**B50**    50 baud
**B75**    75 baud
**B110**   110 baud
**B134**   134.5 baud
**B150**   150 baud
**B200**   200 baud
**B300**   300 baud
**B600**   600 baud
**B1200**  1200 baud
**B1800**  1800 baud
**B2400**  2400 baud
**B4800**  4800 baud
**B9600**  9600 baud
**B19200** 19200 baud
**B38400** 38400 baud
========== ===========

Note that the zero baud-rate, **B0**, is used to terminate the
connection. If **B0** is specified, the modem control lines are no
longer asserted; normally, this disconnects the line (see
**cfsetospeed** and **tcsetattr** in
`termios\ (S) <../man/html.S/termios.S.html>`__): 

The **termios** structure members ``c_iflag``, ``c_oflag``, ``c_cflag``
and ``c_lflag`` take as values the bitwise inclusive-OR of bitwise
distinct masks with symbolic names defined by the *<termios.h>* header
file (see `termio\ (M) <../man/html.M/termio.M.html>`__).

--------------


/Input modes
============

The input-modes field **c_iflag** specifies treatment of terminal input.
Calling **read** on a terminal-device-file works as described in
`\``Input processing and reading data'' <TDC_InProcReadData.html>`__ and
the value of **c_iflag** along with the value of **c_lflag** determine
how to process input read from the terminal (see `\``Input
modes'' <TDC_InModes.html>`__ and `\``Local modes and line
disciplines'' <TDC_LocalModesLnDisciplines.html>`__ in
`termio\ (M) <../man/html.M/termio.M.html>`__).

--------------

/Output modes
=============

The output-modes field **c_oflag** specifies treatment of terminal
output. Calling **write** on a terminal-device-file works as described
in `\``Writing data and output
processing'' <TDC_WritDataOutProc.html>`__ and the value of **c_oflag**
determines how to process output written to the terminal (see `\``Output
modes'' <TDC_OutModes.html>`__ in
`termio\ (M) <../man/html.M/termio.M.html>`__).

--------------

/Control modes
==============

The control-modes field **c_cflag** specifies communication control for
terminals. The value of **c_cflag** controls characteristics of the
communications-port to a terminal-device, but the underlying hardware
may fail to support all **c_cflag** values (see `\``Control
modes'' <TDC_CntlModes.html>`__ in
`termio\ (M) <../man/html.M/termio.M.html>`__). A communication-port
other than an asynchronous serial connection may ignore some of the
control-modes; for example, if an attempt is made to set the baud-rate
on a network-connection to a terminal on another host, the baud-rate may
or may not be set on the connection between the terminal and the machine
it is directly connected to.

--------------


/Local modes and line disciplines
=================================

The local-modes field **c_lflag** specifies the \``line-discipline'' for
the terminal. The line-discipline works as described in `\``Canonical
mode input processing'' <TDC_CanonicalModeInProc.html>`__ and
`\``Non-canonical mode input
processing'' <TDC_Non-CanonicalModeInProc.html>`__ and the value of
**c_lflag** along with the value of **c_iflag** determine how the
line-discipline acts on input from a terminal-device-file (see `\``Local
modes and line disciplines'' <TDC_LocalModesLnDisciplines.html>`__ and
`\``Input modes'' <TDC_InModes.html>`__ in
`termio\ (M) <../man/html.M/termio.M.html>`__).

--------------

/Special control characters
===========================

The array **c_cc** specifies the special control-characters that affect
the operation of the communication-port and the processing of terminal
input and output as described in the `\``Special
characters'' <TDC_SpecialChars.html>`__ section below. For each entry of
the control-character array **c_cc**, the following are typical default
values: 

**Terminal device control character array**

=============== ============== =============== =====================
Subscript value Subscript name Character value Character description
=============== ============== =============== =====================
0               VINTR          ASCII DEL       INTR character
1               VNUIT          ASCII FS        QUIT character
2               VERASE         ^h              ERASE character
3               VKILL          ^u              KILL character
4               VEOF           ASCII EOT       EOF character
5               VEOL           ASCII NUL       EOL character
6               reserved                        
7               reserved                        
8               VSTART         ASCII DC1       START character
9               VSTOP          ASCII DC3       STOP character
10              VSUSP          ASCII SUB       SUSP character
=============== ============== =============== =====================

The subscript values are unique, except that the **VMIN** and **VTIME**
subscripts may have the same value as the **VEOF** and **VEOL**
subscripts respectively. The *<termios.h>* header file defines the
relative positions, subscript names and default values for the
control-character array **c_cc** (see `\``Special control
characters'' <TDC_SpecialCntlChars.html>`__ in
`termio\ (M) <../man/html.M/termio.M.html>`__).

The NL and CR character cannot be changed. The INTR, QUIT, ERASE, KILL,
EOF, EOL, SUSP, STOP and START characters can be changed as follows: 

::

      struct termios term;
      term.c_cc[VINTR] = `a';
      term.c_cc[VQUIT] = `b';
      term.c_cc[VERASE] = `c';
      term.c_cc[VKILL] = `d';
      term.c_cc[VEOF] = `e';
      term.c_cc[VEOL] = `f';
      term.c_cc[VSUSP] = `g';
      term.c_cc[VSTOP] = `h';
      term.c_cc[VSTART] = `i';

where **a**, **b**, **c**, **d**, **e**, **f**, **g**, **h** and **i**
are the INTR, QUIT, ERASE, KILL, EOF, EOL, SUSP, STOP and START
characters respectively.

Implementations which prohibit changing the START and STOP characters
may ignore the character values in the **c_cc** array indexed by the
**VSTART** and **VSTOP** subscripts when **tcsetattr** is called, but
return the character value when **tcsetattr** is called (see
**tcsetattr** in `termios\ (S) <../man/html.S/termios.S.html>`__).

If **\_POSIX_VDISABLE** is defined for the terminal-device-file, and the
value of one of the changeable special control-characters equals
**\_POSIX_VDISABLE**, that function is disabled; that is, the special
character is ignored on input and is not recognized (see `\``Special
characters'' <TDC_SpecialChars.html>`__ section below). If **ICANON** is
clear, the value of **\_POSIX_VDISABLE** lacks any special meaning for
the **VMIN** and **VTIME** entries of the **c_cc** array.

--------------

/Opening a terminal device file
===============================

When a terminal-device-file is opened, it normally causes the process to
wait until a connection is established. In practice,
application-programs seldom open such files; instead, at
system-initialization time special-programs open terminal-device-files
as the \``standard input'', \``standard output'' and \``standard error''
files (see `Intro\ (S) <../man/html.S/Intro.S.html>`__).

Opening a terminal-device-file with the flag **O_NONBLOCK** clear on the
**open** system call causes the process to block until the
terminal-device is ready and available (see
`open\ (S) <../man/html.S/open.S.html>`__). The flag **CLOCAL** can also
affect the **open** system call (see `\``Control
modes'' <TDC_CntlModes.html>`__ in
`termio\ (M) <../man/html.M/termio.M.html>`__).

--------------

/Input processing and reading data
==================================

A terminal-device accessed through an open terminal-device-file
ordinarily operates in full-duplex mode. This means data may arrive at
any time, even while output is occurring. Each terminal-device-file has
associated with it an \``input-queue'', into which the system stores
incoming data before the process reads that data. The system imposes a
limit of **MAX_INPUT**, the maximum allowable number of bytes of input
data, on the number of bytes of data that it stores in the input-queue.
Data is lost only when the input-queue becomes completely full, or when
an input line exceeds **MAX_INPUT**. The behavior of the system when
this limit is exceeded is implementation-dependent.

In UNIX System V, if the data in the terminal-device-file input-queue
exceeds **MAX_INPUT** and **IMAXBEL** is clear, all the bytes of data
saved up to that point are discarded without any notice, but if
**IMAXBEL** is set and the data in the terminal-device-file input-queue
exceeds **MAX_INPUT**, the ASCII BEL character is echoed. Further input
is not stored, and any data already present in the input-queue remains
undisturbed.

Two general kinds of input processing are available, determined by
whether the terminal-device-file is operating in canonical mode or
non-canonical mode. These modes are described in `\``Canonical mode
input processing'' <TDC_CanonicalModeInProc.html>`__ and
`\``Non-canonical mode input
processing'' <TDC_Non-CanonicalModeInProc.html>`__. Additionally, input
is processed according to the **c_iflag** and **c_lflag** fields (see
`\``Input modes'' <TDC_InModes.html>`__ and `\``Local modes and line
disciplines'' <TDC_LocalModesLnDisciplines.html>`__ in
`termio\ (M) <../man/html.M/termio.M.html>`__). Such processing can
include \``echoing'', which in general means transmitting input data
bytes immediately back to the terminal when they are received from the
terminal. This is useful for terminals that can operate in full-duplex
mode.

The way a process reading from a terminal-device-file gets data depends
on whether the terminal-device-file is operating in canonical mode or
non-canonical mode. How **read** operates on a terminal-device-file also
depends on how `open\ (S) <../man/html.S/open.S.html>`__ or
`fcntl\ (S) <../man/html.S/fcntl.S.html>`__ sets the flag **O_NONBLOCK**
for the file: 

-  If **O_NONBLOCK** and **O_NDELAY** are clear, **read** blocks until
   data is available or a signal interrupts the **read** operation.
-  If **O_NONBLOCK** is set, **read** completes, without blocking, in
   one of the following three ways: 

   1. If enough bytes of data are available to satisfy the entire
      request, **read** completes successfully and returns the number of
      bytes it transferred.
   2. If too few bytes of data are available to satisfy the entire
      request, **read** completes successfully, having transferred as
      much data as it could, and returns the number of bytes it actually
      transferred.
   3. If *no* data is available, **read** returns **-1** and **errno**
      equals **EAGAIN**.

When data become available depends on whether the input-processing mode
is canonical or non-canonical. The following sections, `\``Canonical
mode input processing'' <TDC_CanonicalModeInProc.html>`__ and
`\``Non-canonical mode input
processing'' <TDC_Non-CanonicalModeInProc.html>`__, describe each of
these input-processing modes.

--------------

/Canonical mode input processing
================================

In canonical mode input processing, terminal input is processed in units
of lines. A line is delimited by the new-line (**'\\n'**) character,
end-of-file (EOF) character or end-of-line (EOL) character (see
`\``Special characters'' <TDC_SpecialChars.html>`__ section below for
more information on EOF and EOL).

Processing terminal input in units of lines means that a program
attempting a **read** from a terminal-device-file is suspended until an
entire line is typed, or a signal is received. Also, no matter how many
bytes of data a **read** may request from a terminal-device-file, it
transfers at most one line of input. It is not, however, necessary to
read the entire line at once; a **read** may request any number of bytes
of data, even one, without losing any data remaining in the line of
input.

If **MAX_CANON** is defined for this terminal-device, it is a limit on
the number of bytes in a line. The behavior of the system when this
limit is exceeded is implementation-dependent. If **MAX_CANON** is not
defined for this terminal-device, there is no such limit.

It should be noted that there is a possible inherent deadlock if the
program and the implementation conflict on the value of **MAX_CANON**.
With both **ICANON** and **IXOFF** set when more than **MAX_CANON**
characters transmitted without a line-feed, transmission is stopped, the
line-feed (or carriage-return if **ICRLF** is set) never arrives, and
the **read** is never satisfied.

A program should never set **IXOFF** if it is using canonical-mode
unless it knows that (even in the face of a transmission error) the
conditions described previously cannot be met or unless it is prepared
to deal with the possible deadlock in some other way, such as time-outs.

--------------

**NOTE:** This would only occur if the transmitting side was a
communications device (for example, an asynchronous port). This normally
will not happen since the transmitting side is a user at a terminal.

--------------

It should also be noted that this can be made to happen in
non-canonical-mode if the number of characters received that would cause
**IXOFF** to be sent is less than **VMIN** when **VTIME** equals zero.

In UNIX System V, if the data in the line-discipline buffer exceeds
**MAX_CANON** in canonical mode and **IMAXBEL** is clear, all the bytes
of data saved in the buffer up to that point are discarded without any
notice, but if **IMAXBEL** is set and the data in the line-discipline
buffer exceeds **MAX_INPUT**, the ASCII BEL character is echoed. Further
input is not stored, and any data already present in the input-queue
remains undisturbed.

During input, *erase* and *kill* processing occurs whenever either of
two special characters, the ERASE and KILL characters is received (see
`\``Special characters'' <TDC_SpecialChars.html>`__). This processing
affects data in the input-queue that has yet to be delimited by a
new-line, EOF or EOL character. This un-delimited data makes up the
current line. The ERASE character deletes the last character (if any) in
the current line; it does not erase beyond the beginning of the line.
The KILL character deletes all data (if any) in the current line; it
optionally outputs a new-line character. The ERASE and KILL characters
have no effect if the current line lacks any data.

Both the ERASE and KILL characters operate on a key-stroke basis
independently of any backspacing or tabbing. Typically, **#** is the
default ERASE character, and **@** is the default KILL character. The
ERASE and KILL characters themselves are not placed in the input-queue.

--------------

/Non-canonical mode input processing
====================================

In non-canonical input processing, input bytes are not assembled into
lines, and erase and kill processing does not occur. The values of the
MIN and TIME members of the **c_cc** array determine how to process any
data received.

MIN is the minimum number of bytes of data that a **read** should return
when it completes successfully. If MIN exceeds **MAX_INPUT**, the
response to the request is implementation-defined. In UNIX System V, the
maximum value that can be stored for MIN in **c_cc[VMIN]** is 256, less
than **MAX_INPUT** which equals 512; thus, the MIN value can never
exceed **MAX_INPUT**. TIME is a read-timer with a 0.10 second
granularity used to time-out bursty and short-term data transmissions.
The four possible interactions between MIN and TIME follow: 

1. (MIN\ **>0**, TIME\ **>0**).

   Because TIME\ **>0**, it serves as an inter-byte timer activated on
   receipt of the first byte of data, and reset on receipt of each byte
   of data. MIN and TIME interact as follows: 

   -  As soon as a byte of data is received, the inter-byte timer starts
      (remember that the timer is reset on receipt of each byte)
   -  If MIN bytes of data are received before the inter-byte timer
      expires, the **read** completes successfully.
   -  If the inter-byte timer expires before MIN bytes of data are
      received, the **read** transfers any bytes received up until then.

   When TIME expires, a **read** transfers at least one byte of data
   because the inter-byte timer is enabled if and only if a byte of data
   was received. A program using this case must wait for at least one
   byte of data to be read before proceeding. In case
   (MIN\ **>0**, TIME\ **>0**), a **read** blocks until receiving a byte
   of data activates MIN and TIME, or a signal interrupts the **read**.
   Thus, the **read** transfers at least one byte of data.

2. (MIN\ **>0**, TIME\ **=0**).

   | Because TIME\ **=0**, the timer plays no role and only MIN is
     significant. A **read** completes successfully only on receiving
     MIN bytes of data (i.e., the pending **read** blocks until MIN
     bytes of data are received) or a signal interrupts the **read**.
     Use these values only when the program cannot continue until a
     predetermined number of bytes of data are read. A program using
     this case to do record-based terminal I/O may block indefinitely in
     a **read**.

3. (MIN\ **=0**, TIME\ **>0**).

   Because MIN\ **=0**, TIME no longer serves as an inter-byte timer,
   but now serves as a read-timer activated when a **read** is processed
   (in canon). A **read** completes successfully as soon as any bytes of
   data are received or the read-timer expires. A **read** does not
   transfer any bytes of data if the read-timer expires. If the
   read-timer does not expire, a **read** completes successfully if and
   only if some bytes of data are received. In case
   (MIN\ **=0**, TIME\ **>0**), the **read** does not block indefinitely
   waiting for a byte of data. If no bytes of data are received within
   TIME*0.10 seconds after the **read** starts, it returns **0** having
   read no data. If the buffer holds data when a **read** starts, the
   read-timer starts as if it received data immediately. MIN and TIME
   are useful when a program can assume that data is not available after
   a TIME interval and other processing can be done before data is
   available.

4. (MIN\ **=0**, TIME\ **=0**).

   Without waiting for more bytes of data to be received, a **read**
   returns the minimum of either the number of bytes of data requested
   or the number of bytes of data currently available. In this case, a
   **read** immediately transfers any bytes of data present, or if no
   bytes of data are available, it returns **0** having read no data. In
   case (MIN\ **=0**, TIME\ **=0**), **read** operates identically to
   the **O_NDELAY** flag in canonical mode.

MIN/TIME interactions serve different purposes and thus do not parallel
one another. In case [2]: (MIN\ **>0**, TIME\ **=0**), TIME lacks
effect, but with the conditions reversed in case [3]: 
(MIN\ **=0**, TIME\ **>0**), both MIN and TIME play a role in that
receiving a single byte satisfies the MIN criteria. Furthermore, in case
[3]: (MIN\ **=0**, TIME\ **>0**), TIME represents a read-timer, while in
case [1]: (MIN\ **>0**, TIME\ **>0**), TIME represents an inter-byte
timer,

Cases [1] and [2], where MIN\ **>0**, handle burst mode activity (e.g.,
file-transfers), where programs need to process at least MIN bytes of
data at a time. In case [1], the inter-byte timer acts as a safety
measure; in case [2], the timer is turned off.

Cases [3] and [4] handle single byte, timed transfers like those used by
screen-based programs that need to know if a byte of data is present in
the input-queue before refreshing the screen. In case [3], the **read**
is timed, while in case [4], it is not.

One should also note that MIN is always just a minimum, and does not
define a record length. Thus, if a program tries a **read** of 20 bytes
when 25 bytes of data are present and MIN is 10, the **read** returns 20
bytes of data. In the special case of MIN\ **=0**, this still applies: 
if more than one byte of data is available, all data is returned
immediately.

--------------

/Writing data and output processing
===================================

When a process writes data onto a terminal-device-file, **c_oflag**
controls how to process those bytes (see `\``Output
modes'' <TDC_OutModes.html>`__ in
`termio\ (M) <../man/html.M/termio.M.html>`__). UNIX System V provides
buffering such that a call to **write** schedules data for transfer to
the device, but has not necessarily completed the transfer when the call
returns (see `write\ (S) <../man/html.S/write.S.html>`__ for the effects
of **O_NONBLOCK** on **write**).

--------------

/Closing a terminal device file
===============================

The last process to close a terminal-device-file causes any output
remaining to be sent to the device and any input remaining to be
discarded. Following these actions, if the flag **HUPCL** is set in the
control-modes and the communication-port supports a disconnect function,
the terminal-device does a disconnect.

Because the POSIX.1 standard is silent on whether a **close** blocks
waiting for transmission to drain, or even if a **close** might flush
any pending output, a program concerned about how data in terminal input
and output-queues are handled should call the appropriate functions such
as **tcdrain** to ensure the desired behavior (see
`close\ (S) <../man/html.S/close.S.html>`__ and **tcdrain** in
`termios\ (S) <../man/html.S/termios.S.html>`__).

--------------


/Special characters
===================

Certain characters have special functions on input or output or both.
These functions and their typical default character values are
summarized below: 

INTR
   (typically, rubout or ASCII <Del>) sends an \``interrupt'' signal,
   **SIGINT**, to all processes in the foreground process-group for
   which the terminal is the controlling-terminal. Receiving the signal
   **SIGINT** normally forces a process to terminate, but a process may
   arrange to ignore the signal or to call a signal-catching function
   (see `sigaction\ (S) <../man/html.S/sigaction.S.html>`__).
   If **ISIG** is set, the INTR character is recognized and acts as a
   special character on input and is discarded when processed (see
   `\``Local modes and line
   disciplines'' <TDC_LocalModesLnDisciplines.html>`__ in
   `termio\ (M) <../man/html.M/termio.M.html>`__).
QUIT
   (typically, control-**\\** or ASCII FS) sends a *quit* signal,
   **SIGQUIT**, to all processes in the foreground process-group for
   which the terminal is the controlling-terminal. Receiving the signal
   **SIGQUIT** normally forces a process to terminate just as the signal
   **SIGINT** does except that, unless a receiving process makes other
   arrangements, it not only terminates but a core image file (called
   *CORE*) will be created in the current working directory of the
   process (see `sigaction\ (S) <../man/html.S/sigaction.S.html>`__).
   If **ISIG** is set, the QUIT character is recognized and acts as a
   special character on input and is discarded when processed (see
   `\``Local modes and line
   disciplines'' <TDC_LocalModesLnDisciplines.html>`__ in
   `termio\ (M) <../man/html.M/termio.M.html>`__).
ERASE
   (typically, the character **#**) erases the most recently input
   character in the current line (see `\``Canonical mode input
   processing'' <TDC_CanonicalModeInProc.html>`__). It does not erase
   beyond the start of a line.
   If **ICANON** is set, the ERASE character is recognized and acts as a
   special character on input and is discarded when processed (see
   `\``Local modes and line
   disciplines'' <TDC_LocalModesLnDisciplines.html>`__ in
   `termio\ (M) <../man/html.M/termio.M.html>`__).
KILL
   (typically, the character **@**) deletes the entire line, as
   delimited by an EOF, EOL or NL character.
   If **ICANON** is set, the KILL character is recognized and acts as a
   special character on input and is discarded when processed (see
   `\``Local modes and line
   disciplines'' <TDC_LocalModesLnDisciplines.html>`__ in
   `termio\ (M) <../man/html.M/termio.M.html>`__).
EOF
   (typically, control-**d** or ASCII EOT) generates an EOF, from a
   terminal. On receiving EOF, a **read** immediately passes any bytes
   of data it holds to the process without waiting for a new-line, and
   discards the EOF. If EOF occurred at the beginning of a line, a
   **read** holds no bytes of data, and returns a byte count of zero,
   the standard end-of-file indication.
   If **ICANON** is set, the EOF character is recognized and acts as a
   special character on input and is discarded when processed (see
   `\``Local modes and line
   disciplines'' <TDC_LocalModesLnDisciplines.html>`__ in
   `termio\ (M) <../man/html.M/termio.M.html>`__).
NL
   (ASCII LF) is the normal line delimiter, (**'\\n'**), which can not
   be changed or escaped.
   If **ICANON** is set, the NL character is recognized and acts as a
   special character on input (see `\``Local modes and line
   disciplines'' <TDC_LocalModesLnDisciplines.html>`__ in
   `termio\ (M) <../man/html.M/termio.M.html>`__).
EOL
   (typically, ASCII NUL) is an additional line delimiter, like the NL
   character. EOL is not normally used.
   If **ICANON** is set, the EOL character is recognized and acts as a
   special character on input (see `\``Local modes and line
   disciplines'' <TDC_LocalModesLnDisciplines.html>`__ in
   `termio\ (M) <../man/html.M/termio.M.html>`__).
SUSP
   (typically, control-**z** or ASCII SUB) sends an *stop* signal,
   **SIGTSTP**, to all processes in the foreground process-group for
   which the terminal is the controlling-terminal.
   If job-control is supported and **ISIG** is set, the SUSP character
   is recognized and acts as a special character on input and is
   discarded when processed (see `\``Local modes and line
   disciplines'' <TDC_LocalModesLnDisciplines.html>`__ in
   `termio\ (M) <../man/html.M/termio.M.html>`__).
STOP
   (typically, control-**s** or ASCII DC3) temporarily suspends output.
   It is useful with CRT terminals to prevent output from disappearing
   before it can be seen. While output is suspended, STOP characters are
   ignored not read. The STOP character can be changed through the
   **c_cc** array (see `\``Special control
   characters'' <TDC_SpecialCntlChars.html>`__ in
   `termio\ (M) <../man/html.M/termio.M.html>`__).
   If **IXON** (output control) is set or **IXOFF** (input control) is
   set, the STOP character is recognized and acts as a special character
   on both input and output. If **IXON** is set, the STOP character is
   discarded when processed (see `\``Input modes'' <TDC_InModes.html>`__
   in `termio\ (M) <../man/html.M/termio.M.html>`__).
START
   (typically, control-**q** or ASCII DC1) resumes output suspended by a
   STOP character. While output is not suspended, START characters are
   ignored and not read. The START character can be changed through the
   **c_cc** array (see `\``Special control
   characters'' <TDC_SpecialCntlChars.html>`__ in
   `termio\ (M) <../man/html.M/termio.M.html>`__).
   If **IXON** (output control) is set or **IXOFF** (input control) is
   set, the START character is recognized and acts as a special
   character on both input and output. If **IXON** is set, the START
   character is discarded when processed (see `\``Input
   modes'' <TDC_InModes.html>`__ in
   `termio\ (M) <../man/html.M/termio.M.html>`__).
CR
   (ASCII CR) is a line delimiter, (**'\\r'**), which is translated into
   the NL character, and it has the same effect as the NL character if
   **ICANON** and **ICRNL** are set and **IGNCR** is clear.
   If **ICANON** is set, the NL character is recognized and acts as a
   special character on input (see `\``Local modes and line
   disciplines'' <TDC_LocalModesLnDisciplines.html>`__ in
   `termio\ (M) <../man/html.M/termio.M.html>`__).
MIN
   controls terminal I/O during raw mode (**ICANON** off) processing
   (see `\``Non-canonical mode input
   processing'' <TDC_Non-CanonicalModeInProc.html>`__).
TIME
   controls terminal I/O during raw mode (**ICANON** off) processing
   (see `\``Non-canonical mode input
   processing'' <TDC_Non-CanonicalModeInProc.html>`__).

The NL and CR character cannot be changed. The INTR, QUIT, ERASE, KILL,
EOF, EOL, SUSP, STOP and START characters can be changed through the
**c_cc** array (see `\``Special control
characters'' <TDC_SpecialCntlChars.html>`__ in
`termio\ (M) <../man/html.M/termio.M.html>`__).

The ERASE, KILL and EOF characters may be entered literally (their
special meaning escaped) by preceding them with the escape character
(**'\\'**). In this case, no special function is done and the escape
character is not read as input.

--------------

/The controlling-terminal and process-groups
============================================

A terminal may belong to a process as its controlling-terminal, which is
a terminal uniquely associated with one session. Each process of a
session with a controlling-terminal has the same controlling-terminal
assigned to it. Each session may have at most one controlling-terminal
associated with it and vice versa. A terminal may be assigned to at most
one session as the controlling-terminal. Certain input sequences from
the controlling-terminal cause signals to be sent to all processes in
the process-group for the controlling-terminal (see
`termio\ (M) <../man/html.M/termio.M.html>`__). The controlling-terminal
plays a special role in handling *quit* and \``interrupt'' signals (see
`\``Special characters'' <TDC_SpecialChars.html>`__).

The controlling-terminal for a session is acquired by the
session-leader, which is the process that created the session; the
session-id of a session equals the process-id of the session-leader.
When a session-leader acquires a controlling-terminal for its session,
it thereby becomes the controlling-process of that session (see
`setsid\ (S) <../man/html.S/setsid.S.html>`__). Should the terminal
later cease to be a controlling-terminal for the session of the
session-leader, the session-leader ceases to be a controlling-process.

When a session-leader without a controlling-terminal opens a
terminal-device-file and the flag **O_NOCTTY** is clear on **open**,
that terminal becomes the controlling-terminal assigned to the
session-leader if the terminal is not already assigned to some session
(see `open\ (S) <../man/html.S/open.S.html>`__). When any process other
than a session-leader opens a terminal-device-file, or the flag
**O_NOCTTY** is set on **open**, that terminal does not become the
controlling-terminal assigned to the calling-process.

A controlling-terminal distinguishes one of the process-groups in the
session assigned to it as the \``foreground'' process-group; all other
process-groups in the session are \``background'' process-groups. By
default, when the session-leader acquires a controlling-terminal, the
process-group of the session-leader becomes the foreground process-group
of the controlling-terminal. The foreground process-group plays a
special role in handling signal-generating input characters (see
`\``Special characters'' <TDC_SpecialChars.html>`__ above).

| A new process inherits the controlling-terminal through the **fork**
  operation (see `fork\ (S) <../man/html.S/fork.S.html>`__). When a
  process calls **setsid** to create a new session, the process
  relinquishes its controlling-terminal; other processes remaining in
  the old session with that terminal as their controlling-terminal
  continue to have it (see
  `setsid\ (S) <../man/html.S/setsid.S.html>`__). When all
  file-descriptors that denote the controlling-terminal in the system
  are closed (whether or not it is in the current session), it is
  unspecified whether all processes that had that terminal as their
  controlling-terminal cease to have any controlling-terminal. Whether
  and how a session-leader can reacquire a controlling-terminal after
  the controlling-terminal is relinquished in this fashion is
  unspecified. A process does not relinquish its controlling-terminal
  simply by
| closing all of its file-descriptors that denote the
  controlling-terminal if other processes continue to have it open.

When a session-leader terminates, the current session relinquishes the
controlling-terminal allowing a new session-leader to acquire it. Any
further attempts to access the terminal by other processes in the old
session may be denied and treated as if modem-disconnect was detected on
the terminal.

--------------


/Session management and job control
===================================

If **\_POSIX_JOB_CONTROL** is defined, UNIX System V supports
job-control and command interpreter processes supporting job-control can
assign the terminal to different jobs, or process-groups, by placing
related processes in a single process-group and assigning the
process-group with the terminal. A process may examine or change the
foreground process-group of a terminal assuming the process has the
required permissions (see **tcgetpgrp** and **tcsetpgrp** in
`termios\ (S) <../man/html.S/termios.S.html>`__). The **termios**
facility aids in this assignment by restricting access to the terminal
by processes outside of the foreground process-group (see the sections
on job control in `\``Signals, job control and
pipes'' <SigsJobCntlPipes.html>`__).

When there is no longer any process whose process-id or process-group-id
matches the process-group-id of the foreground process-group, the
terminal lacks any foreground process-group. It is unspecified whether
the terminal has a foreground process-group when there is no longer any
process whose process-group-id matches the process-group-id of the
foreground process-group, but there is a process whose process-id
matches the process-group-id of the foreground process-group. Only a
successful call to **tcsetpgrp** or assignment of the
controlling-terminal as described can make a process-group the
foreground process-group of a terminal (see **tcsetpgrp** in
`termios\ (S) <../man/html.S/termios.S.html>`__).

Background process-groups in the session of the session-leader are
subject to a job-control line-discipline when they attempt to access
their controlling-terminal. Typically, they are sent a signal that
causes them to stop, unless they have made other arrangements (see
`signal\ (M) <../man/html.M/signal.M.html>`__). An exception is made for
processes that belong to a orphaned process-group, which is a
process-group none of whose members have a parent in another
process-group within the same session and thus share the same
controlling-terminal. When these processes attempt to access their
controlling-terminal, they return errors, because there is no process to
continue them if they should stop (see the sections on job control in
`\``Signals, job control and pipes'' <SigsJobCntlPipes.html>`__).

--------------

/Improving terminal I/O performance
===================================

For user-level programs that read and write to terminals, the TTY
subsystem in UNIX System V provides a flexible interface, known as the
*termio* facility. The flexibility of the *termio* facility enables
users to perform efficient TTY I/O in a wide range of applications.
However, the improper use of this *termio* can result in inefficient
user programs. This section discusses writing programs that use *termio*
and focuses on the topics of buffer size, canonical mode, raw mode and
flow control and provides several code examples.

User programs that read from terminal devices must read from TTYs in
either canonical mode or raw mode.

--------------


/TTY in canonical mode
======================

In canonical mode, characters are read from the device and processed
before being returned. This processing translates kill and erase
characters. Characters are not returned until a new line (NL), end of
file (EOF), or end of line (EOL) is read, which means that characters
are returned a line at a time. Canonical mode is usually associated with
terminals.

An important factor to consider when using canonical mode is what to do
when reading from a TTY device for which characters are not available.
If the **O_NDELAY** flag has been set for the TTY, then such **read**\ s
return a **0**, indicating that no characters are available. Otherwise,
**read**\ s will not return until a character is available. If a program
can perform other processing when characters are not available from a
TTY, then the **O_NDELAY** flag should be set for the TTY. This might
require programs to be more complicated, but the complication are offset
by an increase in efficiency.

The following function opens a TTY device for reading or writing (line
12), places it in canonical mode (line 23), and sets the **O_NDELAY**
option so that **read**\ s are not blocked when characters are not
available (line 12).

::

    1  #include <fcntl.h>
    2  #include <termio.h>
    3
    4  extern struct termio old_term;
    5
    6  setup1(TTY)
    7  char *TTY;
    8  {
    9        int fid;
   10        struct termio new_term;
   11
   12        if ((fid = open(TTY, O_RDWR|O_NDELAY)) == -1)
   13        {
   14                printf("open failed.\n");
   15                exit(1);
   16        }
   17                else if (ioctl(fid, TCGETA, &old_term) == -1)
   18                     {
   19                        printf("ioctl get failed.\n");
   20                        exit(1);
   21                     }
   22        new_term = old_term;
   23        new_term.c_lflag |= ICANON;
   24        if (ioctl(fid, TCSETA, &new_term) == -1)
   25        {
   26                printf("ioctl set failed.\n");
   27                exit(1);
   28        }
   29        return fid;
   30  }

**Improving TTY performance - canonical mode**

--------------


/TTY in raw mode
================

In raw mode, characters are read and returned as is; that is, without
being processed. Reading from a TTY device in raw mode is faster than
reading from a TTY device in canonical mode. In the interest of
efficiency, raw mode should be used when characters do not need to be
canonically processed.

Just as in canonical mode, TTY devices that are in raw mode must deal
with the problem of what to do when reading from a device for which
characters are not available. The **O_NDELAY** flag only applies to TTY
devices that are in canonical mode. The same function is provided by the
MIN and TIME values for raw TTY devices. By choosing appropriate values
of MIN and TIME, a programmer can help maximize efficiency when reading
from TTY devices in raw mode.

The following function inputs a TTY that has previously been opened in
raw mode and sets the MIN and TIME options to be **0** so that
**read**\ s will not be blocked when characters are not available.

::

    1  #include <termio.h>
    2
    3  extern struct termio old_term;
    4
    5  setup2(fid)
    6  int fid;
    7  {
    8        struct termio new_term;
    9
   10       if (ioctl(fid, TCGETA, &old_term) == -1)
   11        {
   12                printf("ioctl get failed.\n");
   13                exit(1);
   14        }
   15
   16        new_term = old_term;
   17        new_term.c_lflag &= ~ICANON;
   18        new_term.c_cc[VMIN] = 0;
   19        new_term.c_cc[VTIME] = 0;
   20
   21        if (ioctl(fid, TCSETA, &new_term) == -1)
   22        {
   23                printf("ioctl set failed.\n");
   24                exit(1);
   25        }
   26  }

**Improving TTY performance - raw mode**

--------------


/TTY flow control
=================

Flow control becomes a problem when a program that reads from a TTY
device that cannot keep up with the number of characters that are coming
into the TTY. If this happens, characters are over-written in the TTY
input queue before they can be read by the program.

Conversely, when a program writes to a TTY, the device might not be able
to keep up with the TTY. When this happens, characters that are written
by a program to a TTY are not being seen by the appropriate device.

The *termio* facility provides a mechanism called software flow control
to solve this problem. If a program cannot keep up with the characters
coming into a TTY, the TTY sends a STOP character to the originator. The
originator, upon receipt of the STOP character, stops sending characters
to the TTY until it received a START character. The TTY sends the START
character when the program has sufficiently emptied its input queue.

If a device cannot keep up with a TTY, the device sends a STOP character
to the TTY. Upon receipt of the STOP character, the TTY stops sending
characters to the terminal until it receives a START character. The
terminal sends the START character when it has sufficiently emptied its
input queue. The TTY then blocks **write**\ s to the TTY until the TTY's
output has sufficiently emptied.

Three different options are provided for flow control: **IXON**,
**IXOFF**, and **IXANY**. If **IXOFF** is set, then software flow
control is enabled on the TTY's input queue. The TTY transmits a STOP
character when the program cannot keep up with its input queue and
transmits a START character when its input queue in nearly empty again.

If **IXON** is set, software flow control is enabled on the TTY's output
queue. The TTY blocks **write**\ s by the program when the device to
which it is connected cannot keep up with it. If **IXANY** is set, then
any character received by the TTY from the device restarts the output
that has been suspended.

The following function (see the following figure) sets the **IXANY**,
**IXOFF**, and **IXANY** options for a TTY device that has previously
been opened so that software flow control is enabled for both input and
output.

::

    1  #include <termio.h>
    2
    3  extern struct termio old_term;
    4
    5  setup3(fid)
    6  int fid;
    7  {
    8          struct termio new_term;
    9
   10         if (ioctl(fid, TCGETA, &old_term) == -1)
   11         {
   12                  printf("ioctl get failed.\n");
   13                  exit(1);
   14         }
   15
   16         new_term = old_term;
   17         new_term.c_iflag |= IXON | IXOFF | IXANY;
   18
   19         if (ioctl(fid, TCSETA, &new_term) == -1)
   20         {
   21                  printf("ioctl set failed.\n");
   22                  exit(1);
   23         }
   24  }

**Improving TTY performance - flow control**

When you design programs that read and write for the TTY subsystem,
remember to address buffer size, canonical/raw mode and flow control
concerns to ensure programming efficiency. For further information, see
`termio\ (M) <../man/html.M/termio.M.html>`__,
`open\ (S) <../man/html.S/open.S.html>`__,
`read\ (S) <../man/html.S/read.S.html>`__, and
`ioctl\ (S) <../man/html.S/ioctl.S.html>`__.

--------------

/STREAMS-based terminal subsystem
=================================

Beginning with UNIX System V Release 4, the terminal subsystem is
implemented by STREAMS. The STREAMS-based terminal subsystem (see
`\``STREAMS-based terminal
subsystem'' <_STREAMS-Based_Terminal_Subsyste.html#tty_t4>`__) provides
many benefits: 

-  Reusable line discipline modules. The same module can be used in many
   STREAMS where the configuration of these STREAMS may be different.
-  Line discipline substitution. Although UNIX System V provides a
   standard terminal line discipline module, another one conforming to
   the interface may be substituted. For example, a remote login feature
   may use the terminal subsystem line discipline module to provide a
   terminal interface to the user.
-  Internationalization. The modularity and flexibility of the
   STREAMS-based terminal subsystem enables an easy implementation of a
   system that supports multiple byte characters for
   internationalization. This modularity also allows easy addition of
   new features to the terminal subsystem.
-  Easy customizing. Users may customize their terminal subsystem
   environment by adding and removing modules of their choice.
-  The pseudo-terminal subsystem. The pseudo-terminal subsystem can be
   easily supported.
-  Merge with networking. By pushing a line discipline module on a
   network line, you can make the network look like a terminal line.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/strmtrm.gif

**STREAMS-based terminal subsystem**

The initial setup of the STREAMS-based terminal subsystem is handled
with the **ttymon**\ (ADM) command within the framework of the Service
Access Facility (SAF) or the autopush facility.

The STREAMS-based terminal subsystem supports *termio*, the **termios**
specification of the POSIX standard, multiple byte characters for
internationalization, the interface to asynchronous hardware flow
control and peripheral controllers for asynchronous terminals (see
`termio\ (M) <../man/html.M/termio.M.html>`__, and *termiox*\ (M)). BSD
compatibility can also be provided by pushing the *ttcompat* module (see
*ttcompat*\ (M)).

--------------




/Line discipline module
=======================

A STREAMS line discipline module called *ldterm* (see *ldterm*\ (M)) is
a key part of the STREAMS-based terminal subsystem. Throughout this
section, the terms \``line discipline'' and *ldterm* are used
interchangeably and refer to the STREAMS version of the standard line
discipline and not the traditional character version.

The *termio* and **termios** specifications describe four flags that are
used to control the terminal: **c_iflag** (defines input modes),
**c_oflag** (defines output modes), **c_cflag** (defines hardware
control modes), and **c_lflag** (defines terminal functions used by
*ldterm*). To process these flags elsewhere (for example, in the
firmware or in another process), a mechanism is in place to turn on and
off the processing of these flags. When *ldterm* is pushed, it sends an
**M_CTL** message downstream, which asks the driver which flags the
driver will process. The driver sends back that message in response if
it needs to change *ldterm*'s default processing. By default, *ldterm*
assumes that it must process all flags except **c_cflag**, unless it
receives a message telling otherwise.

Default settings
----------------

When *ldterm* is pushed on the Stream, the open routine initializes the
settings of the *termio* flags. The default settings are

::

      c_iflag = BRKINT|ICRNL|IXON|ISTRIP
      c_oflag = OPOST|ONLCR|TAB3
      c_cflag = 0
      c_lflag = ISIG|ICANON|ECHO|ECHOK

In canonical mode (**ICANON** flag in **c_lflag** is turned on),
**read** from the terminal file descriptor is in message nondiscard
(**RMSGN**) mode (see
`streamio\ (M) <../man/html.M/streamio.M.html>`__). This implies that in
canonical mode, **read** on the terminal file descriptor always returns
at most one line regardless of how many characters have been requested.
In noncanonical mode, **read** is in byte-stream (**RNORM**) mode.

Open and close routines
-----------------------

The open routine of the *ldterm* module allocates space for holding
state information.

The *ldterm* module establishes a controlling tty for the line when an
**M_SETOPTS** message (**so_flags** is set to **SO_ISTTY**) is sent
upstream. The Stream head allocates the controlling tty on the open, if
one is not already allocated.

To maintain compatibility with existing application-programs that use
the **O_NDELAY** flag, the **open** routine sets the **SO_NDELON** flag
on in the **so_flags** field of the *stroptions* structure in the
**M_SETOPTS** message.

The open routine fails if there is insufficient space for allocating the
state structure, or when an interrupt occurs while the open is sleeping
until memory becomes available.

The close routine frees all the outstanding buffers allocated by this
Stream. It also sends an **M_SETOPTS** message to the Stream head to
undo the changes made by the open routine. The *ldterm* module also
sends **M_START** and **M_STARTI** messages downstream to undo the
effect of any previous **M_STOP** and **M_STOPI** messages.

EUC handling in ldterm
----------------------

The idea of letting post-processing (the **o_flags**) happen off the
host processor is not recommended unless the board software is prepared
to deal with international (EUC) character sets properly. The reason for
this is that post-processing must take the EUC information into account.
*ldterm* knows about the screen width of characters (that is, how many
columns are taken by characters from each given code set on the current
physical display) and it takes this width into account when calculating
tab expansions. When using multibyte characters or multicolumn
characters *ldterm* automatically handles tab expansion (when **TAB3**
is set) and does not leave this handling to a lower module or driver.

By default, multibyte handling by *ldterm* is turned off. When *ldterm*
receives an **EUC_WSET** **ioctl** call, it turns multibyte processing
on, if it is essential to handle properly the indicated code set. Thus,
if one is using single byte 8-bit codes and has no special multicolumn
requirements, the special multicolumn processing is not used at all.
This means that multibyte processing does not reduce the processing
speed or efficiency of *ldterm* unless it is actually used.

The following describes how the EUC handling in *ldterm* works: 

First, the multibyte and multicolumn character handling is only enabled
when the **EUC_WSET** **ioctl** indicates that one of the following
conditions is met: 

-  Code set consists of more than one byte (including the **SS2** and/or
   **SS3**) of characters.
-  Code set requires more than one column to display on the current
   device, as indicated in the **EUC_WSET** structure.

Assuming that one or more of the above conditions, EUC handling is
enabled. At this point, a parallel array, used for other information, is
allocated. When a byte with the high bit arrives, it is checked to see
if it is **SS2** or **SS3**. If so, it belongs to code set 2 or 3.
Otherwise, it is a byte that comes from code set 1. Once the extended
code set flag has been set, the input processor retrieves the subsequent
bytes, as they arrive, to build one multibyte character. A counter field
tells the input processor how many bytes remain to be read for the
current character. The parallel array holds the display width of each
logical character in the canonical buffer. During erase processing,
positions in the parallel array are consulted to figure out how many
backspaces need to be sent to erase each logical character. (In
canonical mode, one backspace of input erases one logical character, no
matter how many bytes or columns that character consumes.) This greatly
simplifies erase processing for EUC.

There are two relevant files for handling multibyte characters: 
*<euc.h>* and *<eucioctl.h>*. The *<eucioctl.h>* header contains the
structure that is passed with **EUC_WSET** and **EUC_WGET** calls. The
normal way to use this structure is to get **CSWIDTH** (see note below)
from the locale using a mechanism such as **getwidth** or **setlocale**
and then copy the values into the structure in *<eucioctl.h>*, and send
the structure using an **I_STR** **ioctl** call. The **EUC_WSET** call
informs the *ldterm* module about the number of bytes in extended
characters and how many columns the extended characters from each set
consume on the screen. This allows *ldterm* to treat multibyte
characters as single entities for erase processing and to calculate
correctly tab expansions for multibyte characters.

--------------

**NOTE:** **LC_CTYPE** (instead of **CSWIDTH**) should be used in the
environment in UNIX System V Release 4 systems. See **chrtbl**\ (ADM)
for more information.

--------------

The file *<euc.h>* has the structure with fields for EUC width, screen
width, and wide character width. The following functions are used to set
and get EUC widths (these functions assume the environment where the
**eucwidth_t** structure is needed and available): 

::

      #include <eucioctl.h> /* need some other things too, like
                               stropts.h */
      
      struct eucioc eucw;  /* for EUC_WSET/EUC_WGET to line discipline */
      eucwidth_t width;        /* return struct from _getwidth() */
      
      /*
       * set_euc   Send EUC code widths to line discipline.
       */
      
      set_euc(e)
       set_euc(struct eucioc *e)
       {
       struct strioctl sb;
      
       sb.ic_cmd = EUC_WSET;
       sb.ic_timout = 15;
       sb.ic_len = sizeof(struct eucioc);
       sb.ic_dp = (char *) e;
      
       if (ioctl(0, I_STR, &sb) < 0)
           fail();
       }
      /*
       * euclook   Get current EUC code widths from line discipline.
       */
      
      euclook(e)
       euclook(struct eucioc *e)
       {
       struct strioctl sb;
      
       sb.ic_cmd = EUC_WGET;
       sb.ic_timout = 15;
       sb.ic_len = sizeof(struct eucioc);
       sb.ic_dp = (char *) e;
       if (ioctl(0, I_STR, &sb) < 0)
           fail();
       printf("CSWIDTH=%d:%d,%d:%d,%d:%d\n",
                       e->eucw[1], e->scrw[1],
                       e->eucw[2], e->scrw[2],
                       e->eucw[3], e->scrw[3]);
       }

The brief discussion of multiple byte character handling by the *ldterm*
module was provided here for those interested in internationalization
applications in UNIX System V operating systems such as SCO OpenServer.

--------------


/Support of termiox
===================

|  The SCO OpenServer operating system includes the extended general
  terminal interface (see *termiox*\ (M)) that supplements the
  `termio\ (M) <../man/html.M/termio.M.html>`__ general terminal
  interface by adding for asynchronous hardware flow control,
  isochronous flow control and clock modes, and local implementations of
  additional asynchronous features.
| *termiox*\ (M) is handled by hardware drivers if the board supports
  it.

Hardware flow control supplements the 
`termio\ (M) <../man/html.M/termio.M.html>`__ **IXON**, **IXOFF**, and
**IXANY** character flow control. The *termiox*\ (M) interface allows
for both unidirectional and bidirectional hardware flow control.
Isochronous communication is a variation of asynchronous communication
where two communicating devices provide transmit and/or receive clock to
each other. Incoming clock signals can be taken from the baud rate
generator on the local isochronous port controller. Outgoing signals are
sent on the receive and transmit baud rate generator on the local
isochronous port controller.

Terminal parameters are specified in the *termiox* structure that is
defined in the \``<termiox.h>''.

--------------

/Hardware emulation module
==========================

If a Stream supports a terminal interface, a driver or module that
understands all **ioctl**\ s to support terminal semantics (specified by
*termio* and **termios**) is needed. If there is no hardware driver that
understands all **ioctl** commands downstream from the *ldterm* module,
a hardware emulation module must be placed downstream from the *ldterm*
module. The function of the hardware emulation module is to understand
and acknowledge the **ioctl**\ s that may be sent to the process at the
Stream head and to mediate the passage of control information
downstream. The combination of the *ldterm* module and the hardware
emulation module behaves as if there were a terminal on that Stream.

The hardware emulation module is necessary whenever there is no tty
driver at the end of the Stream. For example, it is necessary in a
pseudo-tty situation where there is process-to-process communication on
one system and in a network situation where a *termio* interface is
expected (for example, remote login) but there is no tty driver on the
Stream.

Most actions taken by the hardware emulation module are the same
regardless of the underlying architecture. However, some actions differ
depending on whether the communication is local or remote and whether
the underlying transport protocol supports the remote connection.

Each hardware emulation module has an open, close, read queue **put**
procedure, and write queue **put** procedure.

The hardware emulation module does the following: 

-  Processes, if appropriate, and acknowledges receipt of the following
   **ioctl**\ s on its write queue by sending an **M_IOCACK** message
   back upstream: **TCSETA**, **TCSETAW**, **TCSETAF**, **TCSETS**,
   **TCSETSW**, **TCSETSF**, **TCGETA**, **TCGETS**, and **TCSBRK**.
-  Acknowledges the Extended UNIX Code (EUC) **ioctl**\ s.
-  If the environment supports windowing, it acknowledges the windowing
   **ioctl**\ s **TIOCSWINSZ**, **TIOCGWINSZ**, and **JWINSIZE**. If the
   environment does not support windowing, an **M_IOCNAK** message is
   sent upstream.
-  If any other **ioctl**\ s are received on its write queue, it sends
   an **M_IOCNAK** message upstream.
-  When the hardware emulation module receives an **M_IOCTL** message of
   type **TCSBRK** on its write queue, it sends an **M_IOCACK** message
   upstream and the appropriate message downstream. For example, an
   **M_BREAK** message could be sent downstream.
-  When the hardware emulation module receives an **M_IOCTL** message on
   its write queue to set the baud rate to 0 (**TCSETAW** with **CBAUD**
   set to **B0**), it sends an **M_IOCACK** message upstream and an
   appropriate message downstream; for networking situations this
   probably is an **M_PROTO** message, which is a TPI **T_DISCON_REQ**
   message requesting the transport provider to disconnect.
-  All other messages (**M_DATA**, and so forth) not mentioned here are
   passed to the next module or driver in the Stream.

The hardware emulation module processes messages in a way consistent
with the driver that exists below.

--------------


/STREAMS-based pseudo-terminal subsystem
========================================

The pseudo-terminal subsystem (pseudo-tty) supports a pair of
STREAMS-based devices called the \``master'' device and \``slave''
device. The slave device provides processes with an interface that is
identical to the terminal interface. However, where all devices that
provide the terminal interface have some hardware device behind them,
the slave device has another process manipulating it through the master
half of the pseudo terminal. Anything written on the master device is
given to the slave as an input and anything written on the slave device
is presented as an input on the master-side.

`\``Pseudo-tty subsystem
architecture'' <pty_Line_Discipline_Module.html#tty_t5>`__ illustrates
the architecture of the STREAMS-based pseudo-terminal subsystem. The
master driver called **ptm** is accessed through the clone driver (see
`clone\ (M) <../man/html.M/clone.M.html>`__) and is the controlling part
of the system. The slave driver called **pts** works with the *ldterm*
module and the hardware emulation module to provide a terminal interface
to the user process. An optional packetizing module called *pckt* is
also provided. It can be pushed on the master-side to support packet
mode.

--------------

/Line discipline module
=======================

In the pseudo-tty subsystem (see `\``Pseudo-tty subsystem
architecture'' <pty_Line_Discipline_Module.html#tty_t5>`__), the line
discipline module *ldterm* is pushed on the slave side to present the
user with the terminal interface.

*ldterm* may turn off the processing of the **c_iflag**, **c_oflag**,
and **c_lflag** fields to allow processing to take place elsewhere. The
*ldterm* module may also turn off all canonical processing when it
receives an **M_CTL** message with the **MC_NO_CANON** command to
support remote mode. Although *ldterm* passes through messages without
processing them, the appropriate flags are set when a \``get''
**ioctl**, such as **TCGETA** or **TCGETS**, is issued to show that
canonical processing is being performed.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/pseudtty.gif

**Pseudo-tty subsystem architecture**

--------------




/Pseudo-tty emulation module -- ptem
====================================

Because the pseudo-tty subsystem has no hardware driver downstream from
the *ldterm* module to process the terminal **ioctl** calls, another
module that understands the **ioctl** commands is placed downstream from
the *ldterm*. This module, known as *ptem*, processes all the terminal
**ioctl** commands and mediates the passage of control information
downstream.

*ldterm* and *ptem* together behave like a real terminal. Because there
is no real terminal or modem in the pseudo-tty subsystem, some of the
**ioctl** commands are ignored and cause only an acknowledgement of the
command. The *ptem* module keeps track of the terminal parameters set by
the various \``set'' commands such as **TCSETA** or **TCSETAW** but does
not usually perform any action. For example, if one of the \``set''
**ioctl**\ s is called, none of the bits in the **c_cflag** field of
*termio* has any effect on the pseudo-terminal except if the baud rate
is set to 0. When setting the baud rate to 0, it has the effect of
hanging up the pseudo-terminal.

The pseudo-terminal has no concept of parity so none of the flags in the
**c_iflag** that control the processing of parity errors have any
effect. The delays specified in the **c_oflag** field are not also
supported.

The *ptem* module does the following: 

-  Processes, if appropriate, and acknowledges receipt of the following
   **ioctl**\ s on its write queue by sending an **M_IOCACK** message
   back upstream: 

   **TCSETA**, **TCSETAW**, **TCSETAF**, **TCSETS**, **TCSETSW**,
   **TCSETSF**, **TCGETA**, **TCGETS**, and **TCSBRK**.

-  Keeps track of the window size; information needed for the
   **TIOCSWINSZ**, **TIOCGWINSZ**, and **JWINSIZE** **ioctl** commands.

-  When it receives any other **ioctl** on its write queue, it sends an
   **M_IOCNAK** message upstream.

-  It passes downstream the following **ioctl**\ s after processing
   them: 

   **TCSETA**, **TCSETAW**, **TCSETAF**, **TCSETS**, **TCSETSW**,
   **TCSETSF**, **TCSBRK**, and **TIOCSWINSZ**.

-  *ptem* frees any **M_IOCNAK** messages it receives on its read queue
   in case the *pckt* module is not on the pseudo-terminal subsystem and
   the above **ioctl**\ s get to the master's Stream head, which then
   sends an **M_IOCNAK** message.

-  In its open routine, the *ptem* module sends an **M_SETOPTS** message
   upstream requesting allocation of a controlling tty.

-   When the *ptem* module receives an **M_IOCTL** message of type
   **TCSBRK** on its read queue, it sends an **M_IOCACK** message
   downstream and an **M_BREAK** message upstream.

-  When it receives an **ioctl** message on its write queue to set the
   baud rate to 0 (**TCSETAW** with CBAUD set to B0), it sends an
   **M_IOCACK** message upstream and a 0-length message downstream.

-  When it receives an **M_IOCTL** of type **TIOCSIGNAL** on its read
   queue, it sends an **M_IOCACK** downstream and an **M_PCSIG**
   upstream where the signal number is the same as in the **M_IOCTL**
   message.

-  When the *ptem* module receives an **M_IOCTL** of type **TIOCREMOTE**
   on its read queue, it sends an **M_IOCACK** message downstream and
   the appropriate **M_CTL** message upstream to enable/disable
   canonical processing.

-  When it receives an **M_DELAY** message on its read or write queue,
   it discards the message and does not act on it.

-  When it receives an **M_IOCTL** message with type **JWINSIZE** on its
   write queue and if the values in the **jwinsize** structure of *ptem*
   are not zero, it sends an **M_IOCACK** message upstream with the
   **jwinsize** structure. If the values are zero, it sends an
   **M_IOCNAK** message upstream.

-  When it receives an **M_IOCTL** message of type **TIOCGWINSZ** on its
   write queue and if the values in the **winsize** structure are not
   zero, it sends an **M_IOCACK** message upstream with the **winsize**
   structure. If the values are zero, it sends an **M_IOCNAK** message
   upstream. It also saves the information passed to it in the
   **winsize** structure and sends a STREAMS signal message for signal
   **SIGWINCH** upstream to the slave process if the size changed.

-  When the *ptem* module receives an **M_IOCTL** message with type
   **TIOCGWINSZ** on its read queue and if the values in the **winsize**
   structure are not zero, it sends an **M_IOCACK** message downstream
   with the **winsize** structure. If the values are zero, it sends an
   **M_IOCNAK** message downstream. It also saves the information passed
   to it in the **winsize** structure and sends a STREAMS signal message
   for signal **SIGWINCH** upstream to the slave process if the size
   changed.

-  All other messages not mentioned above are passed to the next module
   or driver.

--------------


/Remote mode
============

A feature known as remote mode is available with the pseudo-tty
subsystem. This feature is used for applications that perform the
canonical function normally done by the *ldterm* module and tty driver.
The remote mode allows applications on the master-side to turn off the
canonical processing. An **ioctl** **TIOCREMOTE** with a nonzero
parameter [**ioctl(fd, TIOCREMOTE, 1)**] is issued on the master-side to
enter the remote mode. When this occurs, an **M_CTL** message with the
command **MC_NO_CANON** is sent to the *ldterm* module indicating that
data should be passed when received on the read-side and no canonical
processing is to take place. The remote mode may be disabled by
**ioctl(fd, TIOCREMOTE, 0)**.

--------------


/Packet mode
============

The STREAMS-based pseudo-terminal subsystem also supports a feature
called packet mode. This is used to inform the process on the
master-side when \``state'' changes have occurred in the pseudo-tty.
Packet mode is enabled by pushing the *pckt* module on the master-side.
Data written on the master-side is processed normally. When data is
written on the slave-side or when other messages are encountered by the
*pckt* module, a header is added to the message so it can be retrieved
later by the master-side with a **getmsg** operation.

The *pckt* module does the following: 

-  When a message is passed to this module on its write queue, the
   module does no processing and passes the message to the next module
   or driver.

-  The *pckt* module creates an **M_PROTO** message when one of the
   following messages is passed to it: 

   **M_DATA**, **M_IOCTL**, **M_PROTO**/**M_PCPROTO**, **M_FLUSH**,
   **M_START**/**M_STOP**, **M_STARTI**/**M_STOPI**, and **M_READ**.

   All other messages are passed through. The **M_PROTO** message is
   passed upstream and retrieved when the user issues
   `getmsg\ (S) <../man/html.S/getmsg.S.html>`__.

-  If the message is an **M_FLUSH** message, *pckt* does the following: 

   If the flag is **FLUSHW**, it is changed to **FLUSHR** (because
   **FLUSHR** was the original flag before the **pts** driver changed
   it), packetized into an **M_PROTO** message, and passed upstream. To
   prevent the Stream head's read queue from being flushed, the original
   **M_FLUSH** message must not be passed upstream.

   If the flag is **FLUSHR**, it is changed to **FLUSHW**, packetized
   into an **M_PROTO** message, and passed upstream. To flush the write
   queues properly, an **M_FLUSH** message with the **FLUSHW** flag set
   is also sent upstream.

   If the flag is **FLUSHRW**, the message with both flags set is
   packetized and passed upstream. An **M_FLUSH** message with the
   **FLUSHW** flag set is also sent upstream.

--------------


/Pseudo-tty drivers -- ptm and pts
==================================

In order to use the pseudo-tty subsystem, a node for the master-side
driver */dev/ptmx* and **N** number of slave drivers must be installed.
(**N** is determined at installation time.) The names of the slave
devices are */dev/pts/*\ **M** where **M** has the values 0 through
**N**-1. A user accesses a pseudo-tty device through the master device
(called **ptm**) that in turn is accessed through the clone driver (see
`clone\ (M) <../man/html.M/clone.M.html>`__). The master device is set
up as a clone device where its major device number is the major for the
clone device and its minor device number is the major for the **ptm**
driver.

The master pseudo-driver is opened by the **open** system call with
*/dev/ptmx* as the device to be opened. The clone open finds the next
available minor device for that major device; a master device is
available only if it and its corresponding slave device are not already
open. There are no nodes in the file system for master devices.

When the master device is opened, the corresponding slave device is
automatically locked out. No user may open that slave device until it is
unlocked. A user may invoke a function **grantpt** that will change the
owner of the slave device to that of the user who is running this
process, change the group ID to **tty**, and change the mode of the
device to **0620**. Once the permissions have been changed, the device
may be unlocked by the user. Only the owner or superuser can access the
slave device. The user must then invoke the **unlockpt** function to
unlock the slave device. Before opening the slave device, the user must
call the **ptsname** function to obtain the name of the slave device.
The functions **grantpt**, **unlockpt**, and **ptsname** are called with
the file descriptor of the master device. The user may then invoke the
**open** system call with the name that was returned by the **ptsname**
function to open the slave device.

The following example shows how a user may invoke the pseudo-tty
subsystem (no error checking is included to keep the example simple): 

::

      int fdm fds;
      char *slavename;
      extern char *ptsname();
      
      fdm = open("/dev/ptmx", O_RDWR);     /* open master */
      grantpt(fdm);                        /* change permission of slave */
      unlockpt(fdm);                       /* unlock slave */
      slavename = ptsname(fdm);            /* get name of slave */
      fds = open(slavename, O_RDWR);       /* open slave */
      ioctl(fds, I_PUSH, "ptem");          /* push ptem */
      ioctl(fds, I_PUSH, "ldterm");        /* push ldterm */

Unrelated processes may open the pseudo-device. The initial user may
pass the master file descriptor using a STREAMS-based pipe or a slave
name to another process to enable it to open the slave. After the slave
device is open, the owner is free to change the permissions.

--------------

**NOTE:** Certain programs such as **write** and **wall** are set
group-ID (**setgid**) to **tty** and are also able to access the slave
device.

--------------

After both the master and slave have been opened, the user has two file
descriptors that provide full-duplex communication using two Streams.
The two Streams are automatically connected. The user may then push
modules onto either side of the Stream. The user also needs to push the
*ptem* and *ldterm* modules onto the slave-side of the pseudo-terminal
subsystem to get terminal semantics.

The master and slave drivers pass all STREAMS messages to their adjacent
queues. Only the **M_FLUSH** needs some processing. Because the read
queue of one side is connected to the write queue of the other, the
**FLUSHR** flag is changed to **FLUSHW** flag and vice versa.

When the master device is closed, an **M_HANGUP** message is sent to the
slave device that will render the device unusable. The process on the
slave-side gets the **errno** **ENXIO** when attempting to write on that
Stream but it will be able to read any data remaining on the Stream head
read queue. When all the data has been read, **read** returns **0**
indicating that the Stream can no longer be used.

On the last close of the slave device, a 0-length message is sent to the
master device. When the application on the master-side issues a **read**
or **getmsg** and **0** is returned, the user of the master device
decides whether to issue a **close** that dismantles the pseudo-terminal
subsystem. If the master device is not closed, the pseudo-tty subsystem
will be available to another user to open the slave device.

Because 0-length messages are used to indicate that the process on the
slave-side has closed and should be interpreted that way by the process
on the master-side, applications on the slave-side should not **write**
0-length messages. If that occurs, the **write** returns **0**, and the
0-length message is discarded by the *ptem* module.

The standard STREAMS system calls can access the pseudo-tty devices. The
slave devices support the **O_NDELAY** and **O_NONBLOCK** flags. Because
the master-side does not act like the terminal, if **O_NONBLOCK** or
**O_NDELAY** is set, **read** on the master side returns **-1** with
**errno** set to **EAGAIN** if no data is available, and **write**
returns **-1** with **errno** set to **EAGAIN** if there is internal
flow control.

The master driver supports the **ISPTM** and **UNLKPT** **ioctl**\ s
that are used by the functions **grantpt**, **unlockpt**, and
**ptsname** (see `grantpt\ (S) <../man/html.S/grantpt.S.html>`__,
`unlockpt\ (S) <../man/html.S/unlockpt.S.html>`__,
`ptsname\ (S) <../man/html.S/ptsname.S.html>`__). The **ioctl**
**ISPTM** determines whether the file descriptor is that of an open
master device. On success, it returns the major/minor number (type
**dev_t**) of the master device that can be used to determine the name
of the corresponding slave device. The **ioctl** **UNLKPT** unlocks the
master and slave devices. It returns **0** on success. On failure, the
**errno** is set to **EINVAL** indicating that the master device is not
open.

The format of these commands is

::

      int ioctl (int fd, int command, int arg)

where **command** is either **ISPTM** or **UNLKPT** and **arg** is
**0**. On failure, **-1** is returned.

When data is written to the master-side, the entire block of data
written is treated as a single line. The slave-side process reading the
terminal receives the entire block of data. Data is not input-edited by
the *ldterm* module regardless of the terminal mode. The master-side
application is responsible for detecting an interrupt character and
sending an interrupt signal **SIGINT** to the process in the slave-side.
This can be done as follows: 

::

      ioctl (fd, TIOCSIGNAL, SIGINT)

where **SIGINT** is defined in the file *<signal.h>*. When a process on
the master-side issues this **ioctl**, the argument is the number of the
signal that should be sent. The specified signal is then sent to the
process group on the slave-side.

To summarize, the master driver and slave driver have the following
characteristics: 

-  Each master driver has a one-to-one relationship with a slave device
   based on major/minor device numbers.
-  Only one open is allowed on a master device. Multiple opens are
   allowed on the slave device according to standard file mode and
   ownership permissions.
-  Each slave driver minor device has a node in the file system.
-  An open on a master device automatically locks out an open on the
   corresponding slave driver.
-  A slave cannot be opened unless the corresponding master is open and
   has unlocked the slave.
-  To provide a tty interface to the user, the *ldterm* and *ptem*
   modules are pushed on the slave-side.
-  A **close** on the master sends a hang-up to the slave and renders
   both Streams unusable after all data has been consumed by the process
   on the slave side.
-  The last **close** on the slave-side sends a 0-length message to the
   master but does not sever the connection between the master and slave
   drivers.

grantpt
-------

The **grantpt** function changes the mode and the ownership of the slave
device that is associated with the given master device. Given a file
descriptor **fd**, **grantpt** first checks that the file descriptor is
that of the master device. If so, it obtains the name of the associated
slave device and sets the user ID to that of the user running the
process and the group ID to **tty**. The mode of the slave device is set
to **0620**.

If the process is already running as root, the permission of the slave
can be changed directly without invoking this function. The interface is

::

      grantpt (int fd)

The **grantpt** function returns **0** on success and **-1** on failure.
It fails if one or more of the following occurs: **fd** is not an open
file descriptor, **fd** is not associated with a master device, the
corresponding slave could not be accessed, or a system call failed
because no more processes could be created.

unlockpt
--------

The **unlockpt** function clears a lock flag associated with a
*master/slave* device pair. Its interface is

::

      unlockpt (int fd)

The **unlockpt** returns **0** on success and **-1** on failure. It
fails if one or more of the following occurs: **fd** is not an open file
descriptor or **fd** is not associated with a master device.

ptsname
-------

The **ptsname** function returns the name of the slave device that is
associated with the given master device. It first checks that the file
descriptor is that of the master. If it is, it then determines the name
of the corresponding slave device */dev/pts/*\ **M** and returns a
pointer to a string containing the null-terminated pathname. The return
value points to static data whose content is overwritten by each call.
The interface is

::

      char *ptsname (int fd)

The **ptsname** function returns a non-**NULL** pathname on success and
a **NULL** pointer upon failure. It fails if one or more of the
following occurs: **fd** is not an open file descriptor or **fd** is not
associated with the master device.

--------------

/6. Internationalization
=========================

This section describes the programming interface to the SCO OpenServer
internationalization feature. Its primary audience is the application
programmer in C, although it may be of interest to system programmers
and, to a lesser extent, administrators. We assume that readers are
experienced in the SCO OpenServer system and the C language.

The section consists of a discussion of the programming interface, and
covers only as much of the interface as programmers will need to get
started. Much of the details can be found in the manual pages of the
reference set.

For the most part, the discussion concentrates on the SCO OpenServer
implementation of ANSI standard C functions. Of course, SCO OpenServer
goes beyond the ANSI C standard in various other ways, most importantly
in providing facilities for handling program messages in international
contexts. In this regard, note that SCO OpenServer offers two distinct
approaches to message handling, only one of which is standard to X/Open.
Although we describe both approaches below, keep in mind that the X/Open
method is employed throughout much of Europe, so you can generally count
on wider support for it than for the SCO OpenServer-specific method. By
and large, SCO OpenServer internationalization is aligned with the
X/Open *Portability Guide Issue 4*.


/Discussion
===========

This section describes C language functions that you can use to write
SCO OpenServer applications that will process input and generate output
in a user's native language or cultural environment. It shows you how to
use these functions and some associated commands to create programs that
make no assumptions about the language environments in which they will
be run, and so are portable across these environments.

The basic idea behind the internationalization interface is that at any
time a C program has a current \``locale'': a collection of information
on which it relies for language- or culture-dependent processing. This
information is supplied by implementations and seen by the program only
at run time. Because the information is stored externally to the
program, applications need not make -- and should not make if they mean
to be portable -- any assumptions about

-  the *code sets* used by the implementation in which they are
   executed. The 7-bit US ASCII code set, for example, cannot represent
   every member of the Spanish character set; the 8-bit code sets used
   for most European languages cannot represent every ideogram and
   phonogram in the Japanese language.
-  the *cultural and language conventions* of the application's users.
   The same date is formatted in the United States as **6/14/90**, in
   Great Britain as **14/6/90**, in Germany as **14.6.90**. Similar
   problems arise in formatting numeric and monetary values. By language
   conventions we mean, for instance, that the sharp **s** in German is
   collated as **ss**; the character **ch** in Spanish collated after
   all other character sequences starting with **c**.
-  the *language of the messages* in which the program communicates with
   the user. Interactive applications in an English-speaking setting
   usually will query users at some point for a **yes** or **no**
   response; in a German-language setting the responses will be **ja**
   or **nein**; in a French one **oui** or **non**. Program error
   messages will differ much more widely than that across languages: 
   **File not found**, **Fichier inexistent**, and so on.

A typical locale, then, consists of an encoding scheme; databases that
describe the conventions appropriate to some nationality, culture, and
language; and a file which you supply, that contains your program's
message strings in whatever language the locale implements.

--------------

/Organization
=============

The discussion is organized in terms of these three elements of a
locale. `\``Character representation'' <I_CharRep.html>`__ describes the
character encoding used by SCO OpenServer, and the ANSI C library
functions that perform codeset-dependent tasks. It also discusses the
sequences of bytes, or \``multibyte characters,'' that are needed to
encode Asian-language ideograms. `\``Cultural and language
conventions'' <I_CulturalLangConventions.html>`__ looks at ANSI C
functions that collate strings and format cultural information in
locale-dependent ways. `\``Message handling'' <I_MsgHdl.html>`__
describes the functions you use to generate program messages in a user's
native language. Before we turn to this material, there's some
background we need to give on how C programs determine their locales.

--------------

**NOTE:** For the relationship of SCO OpenServer internationalization to
the ANSI C and X/Open standards, see
`\``Internationalization'' <Intization.html>`__.

--------------

--------------

/Locales
========

Each SCO OpenServer program begins in the \`\`"C"'' locale, which causes
all library functions to behave as they have historically; any other
locale will cause certain of these functions to behave in the
appropriate language- or culture-dependent ways. Locales have names that
are strings -- \`\`"es"'', \`\`"fr"'' and \`\`"de"'', and so forth,
following ISO conventions (corresponding to the Spanish, French and
German locales, respectively) -- but only \`\`"C"'' and \`\`""'' are
guaranteed. When given as the second argument to the ANSI C
**setlocale** function, the string \`\`""'' tells the program to change
its current locale to the one set by the user, or the system
administrator for all users, in the SCO OpenServer system shell
environment. Any other argument will cause the program to change its
current locale to the one specified by the string.

Locales are partitioned into categories: 

**LC_CTYPE**
   character representation information
**LC_TIME**
   date and time printing information
**LC_MONETARY**
   currency printing information
**LC_NUMERIC**
   numeric printing information
**LC_COLLATE**
   sorting information
**LC_MESSAGES**
   message information

|  In the implementation's view, these categories are files in
  directories named
| for each locale it supports; the directories themselves are usually
  kept in */usr/lib/locale*. In the user's view, the categories are
  environment variables that can be set to given locales: 

::

      $ LC_COLLATE=de export LC_COLLATE
      $ LC_CTYPE=fr export LC_CTYPE
      $ LC_MESSAGES=fr export LC_MESSAGES

In the program's view, the categories are macros that can be passed as
the first argument to **setlocale** to specify that it change the
program's locale for just that category. That is,

::

      setlocale(LC_COLLATE, "");

tells the program to use the sorting information for the locale
specified in the environment, in this case, **german**, but leaves the
other categories unchanged.

**LC_ALL** is the macro that specifies the entire locale. Given the
environment setup above, the code

::

      setlocale(LC_ALL, "");

would allow a user to work in a French interface to a program while
sorting German text files. Incidentally, the **LANG** environment
variable is the user equivalent of **LC_ALL**; setting it to **es**, for
instance, causes all the categories to be set to **es** in the
environment. **LANG** is checked after the environment variables for
individual categories, so a user could set a category to **fr** and use
**LANG** to set the other categories to **es**.

**setlocale**, then, is the interface to the program's locale. Any
program that has a need to use language or cultural conventions should
put a call such as

::

   #include <locale.h>
   /*...*/
   setlocale(LC_ALL, "");

early in its execution path. You will generally want to use \`\`""'' as
the second argument to **setlocale** so that your application will
change locales correctly for whatever language environment in which it
is run. Occasionally, though, you may want to change the locale or a
portion of it for a limited duration in a way that's transparent to the
user.

Suppose, for example, there are parts of your program that need only the
ASCII upper- and lower case characters guaranteed by ANSI C in the
*<ctype.h>* header. In these parts, in other words, you want the program
to see the character classification information in **LC_CTYPE** for the
\`\`"C"'' locale. Since the user of the program in a non-ASCII
environment will presumably have set **LC_CTYPE** to a locale other than
\`\`"C"'', and will not be able to change its setting mid-program, you
will have to arrange for the program to change its **LC_CTYPE** locale
whenever it is in those parts. **setlocale** returns the name of the
current locale for a given category and serves in an inquiry-only
capacity when its second argument is a null pointer. So you might want
to use code something like this: 

::

   char *oloc;
   /*...*/
   oloc = setlocale(LC_CTYPE, NULL);
   if (setlocale(LC_CTYPE, "C") != 0)
   {
      /* use temporarily changed locale */
      (void)setlocale(LC_CTYPE, oloc);
   }

The `setlocale\ (S) <../man/html.S/setlocale.S.html>`__ function is
described in section (S) of the reference manual set.

--------------

/Character representation
=========================

SCO OpenServer can represent up to four code sets concurrently in an
8-bit byte stream. The code sets are configured in a scheme called
\``extended UNIX code,'' or EUC. The primary code set (code set 0) is
always 7-bit US ASCII. Each byte of any character in a supplementary
code set (code sets 1,2, or 3) has the high-order bit set; code sets 2
and 3 are distinguished from code set 1 and each other by their use of a
special \``shift byte'' before each character.

**EUC code set representations**

  ======== ==================================
  Code set EUC representation
  ======== ==================================
  0        ``0xxxxxxx``
  1        ``1xxxxxxx [ 1xxxxxxx [...]]``
  2        ``SS2 1xxxxxxx [ 1xxxxxxx [...]]``
  3        ``SS3 1xxxxxxx [ 1xxxxxxx [...]]``
  ======== ==================================

**SS2** is represented in hexadecimal by **0x8e**, **SS3** by **0x8f**.

EUC is provided mainly to support the huge number of ideograms needed
for I/O in an Asian-language environment. To work within the constraints
of usual computer architectures, these ideograms are encoded as
sequences of bytes, or \``multibyte characters.'' Because single-byte
characters (the digits 0-9, say) can be intermixed with multibyte
characters, the sequence of bytes needed to encode an ideogram must be
self-identifying: regardless of the supplementary code set used, each
byte of a multibyte character will have the high-order bit set; if code
sets 2 or 3 are used, each multibyte character will also be preceded by
a shift byte. In a moment, we will take a closer look at multibyte
characters and at the implementation-defined integral type ``wchar_t``
that lets you manipulate variable width characters as uniformly sized
data objects called \``wide characters.'' We will also discuss the
functions you use to manage multibyte and wide characters.

Of course, programmers developing applications for less complex
linguistic environments need not concern themselves with the details of
multibyte or wide character processing. In Europe, for instance, a
single 8-bit code set can hold all the characters of the major
languages. In these environments, at least one 8-bit character set will
be represented in the EUC code sets, usually code sets 0 and 1. Other
character sets may be represented simultaneously, in various
combinations. Applications will work correctly with any standard 7- or
8-bit character set, provided (1) they are \``8-bit clean'' -- they make
no assumptions about the contents of the high-order bit when processing
characters; and (2) they use correctly the functions supplied by the
interface for codeset-dependent tasks -- character classification and
conversion, in other words. We will take a brief look at these issues
now.

--------------

/\``8-bit clean''
=================

SCO OpenServer system applications written for 7-bit US ASCII
environments have sometimes assumed that the high-order bit is available
for purposes other than character processing. In data communications,
for instance, it was often used as a parity bit. On receipt and after a
parity check, the high-order bit was stripped either by the line
discipline or the program to obtain the original 7-bit character: 

::

      char c;
      /* bitwise AND with octal value 177 strips high-order bit */
      c &= 0177;   

Other programs used the high-order bit as a private data storage area,
usually to test a flag: 

::

      char c;
      /*...*/
      c |= 0200;   /* bitwise OR with octal value 200 sets flag */
      /*...*/
      c &= 0177;   /* bitwise AND removes flag */
      /*...*/
      if (c & 0200)    /* test if flag set */
      {
      /*...*/
      }
      c &= 0177;   /* original character */

Neither of these practices will work with 8-bit or larger code sets. To
show you how to store data in a codeset-independent way, we will look at
code fragments from a SCO OpenServer system program before and after it
was made 8-bit clean. In the first fragment, the program sets the
high-order bit of characters quoted on the command line: 

::

   #define LITERAL '\''
   #define QUOTE 0200
   register int c;
   register char *argp = arg->argval;

   if (c == LITERAL)   /* character is a single quote */
   {
       /* get next character until next single quote */
       while ((c = getc()) && c != LITERAL)
       {
           *argp++ = (c | QUOTE);
       }
   }

In the next fragment, the same data are stored by internally placing
backslashes before quoted characters in the command string: 

::

   #define LITERAL '\''
   register int c;
   register unsigned char *argp = arg->argval;

   if (c == LITERAL)
   {
       while ((c = getc()) && c != LITERAL)
       {
       /* precede each character within single quotes with a backslash */
           *argp++ = '\\';
           *argp++ = c;
       }
   }

Because the data are stored in 8-bit character values rather than the
high-order bit of the quoted characters, the program will work correctly
with code sets other than US ASCII. Note, by the way, the use of the
type ``unsigned char`` in the declaration of the character pointer in
the second fragment. We will discuss the reasons why you use it in the
next section.

--------------


/Character classification and conversion
========================================

The ANSI C functions declared in the *<ctype.h>* header file classify or
convert character-coded integer values according to type and conversion
information in the program's locale. All the classification functions
except **isdigit** and **isxdigit** can return nonzero (true) for
single-byte supplementary code set characters when the **LC_CTYPE**
category of the current locale is other than \`\`"C"''. In a Spanish
locale, **isalpha('n[~]')** should be true. Similarly, the case
conversion functions **toupper** and **tolower** will appropriately
convert any single-byte supplementary code set characters identified by
the **isalpha** function.

The point of these functions is to let you determine a character's type
or case without reference to its numeric value in a given code set.
Whereas a program written for a US ASCII environment might test whether
a character is printable with the code

::

      if ( c <= 037 || c == 0177 )

a codeset-independent program will use **isprint**: 

::

      if ( !isprint(c) )

Similarly,

::

      c = toupper(c);

will do the same thing as

::

      if( c >= 'a' && c <= 'z')
       c += 'a' -'A';

without relying on the fact that upper- and lower case characters are
numerically contiguous in the US ASCII code set.

The *<ctype.h>* functions are almost always macros that are implemented
using table lookups indexed by the character argument. Their behavior is
changed by resetting the table(s) to the new locale's values, so there
should be no performance impact. The classification functions are
described on the `ctype\ (S) <../man/html.S/ctype.S.html>`__ manual
page, the conversion functions on the **conv**\ (S) page. Both single-
and multibyte character classification and conversion routines are
declared in the *<wchar.h>* header, and described on the pages
`wctype\ (S) <../man/html.S/wctype.S.html>`__ and **wconv**\ (S). Note
that the multibyte routines are not part of the ANSI C standard, nor are
the single-byte functions **isascii** and **toascii**.

Sign extension
--------------

In some C language implementations, character variables that are not
explicitly declared ``signed`` or ``unsigned`` are treated as
nonnegative quantities with a range typically from 0 to 255. In other
implementations, they are treated as signed quantities with a range
typically from -128 to 127. When a signed object of type ``char`` is
converted to a wider integer, the machine is obliged to propagate the
sign, which is encoded in the high-order bit of the new integer object.
If the character variable holds an eight-bit character with the
high-order bit set, the sign bit will be propagated the full width of an
object of type ``int`` or ``long``, producing a negative value.

You can avoid this problem (which typically occurs with the **ctype**
functions) by declaring as ``unsigned`` any object of type ``char`` that
is liable to be converted to a wider integer. In the example we showed
earlier, for instance, the declaration of the character pointer as of
type ``unsigned char`` would guarantee that on any implementation the
values pointed at will be nonnegative.

Characters used as indices
--------------------------

A related problem arises when characters are used as indices into arrays
and tables. If a table has been defined to contain only 128 possible
characters, the amount of allocated memory will be exceeded if an
eight-bit character whose value is greater than 127 is used as an index.
Moreover, if the character is signed, the index may be negative.

The solution, at least when dealing with 8-bit code sets, is obviously
to increase the size of the table from the 7-bit maximum of 128 to the
8-bit maximum of 256. And again, to declare the object that will hold
the character as type ``unsigned char``.

--------------

/Wide characters
================

Earlier in this section we looked at the encoding scheme used for the
multibyte characters that are needed to represent Asian-language
ideograms. We noted that because single-byte characters can be
intermixed with multibyte characters, the sequence of bytes needed to
encode an ideogram must be self-identifying: regardless of the
supplementary code set used, each byte of a multibyte character will
have the high-order bit set. In this way, any byte of a multibyte
character can always be distinguished from a member of the primary,
7-bit US ASCII code set, whose high-order bit is not set (or "0"). If
code sets 2 or 3 are used, each multibyte character will also be
preceded by a shift byte; that is, if code set 1 were dedicated to a
single-byte character set, either of code sets 2 or 3 could be used to
represent multibyte characters. Given some set of these encodings, then
any program interested in the next character will be able to determine
whether the next byte represents a single-byte character or the first
byte of a multibyte character. If the latter, then the program will have
to retrieve bytes until the character is complete.

Some of the inconvenience of handling multibyte characters would be
eliminated, of course, if all characters were a uniform number of bytes.
ANSI C provides the implementation-defined integral type ``wchar_t`` to
let you manipulate variable-width characters as uniformly sized data
objects called wide characters. Since there can be thousands or tens of
thousands of ideograms in an Asian-language set, programs should use a
32-bit sized integral value to hold all members. ``wchar_t`` is defined
in the headers *<stdlib.h>* and *<wchar.h>* as a **typedef** of a 32 bit
signed integer.

Implementations provide appropriate libraries with functions that you
can use to manage multibyte and wide characters. We will look at these
functions below.

| For each wide character there is a corresponding EUC representation
  and vice versa; the wide character that corresponds to a regular
  single-byte character has the same numeric value as its single-byte
  value, including the null character. There is no guarantee that the
  value of the macro **EOF** can be stored in a ``wchar_t``, just as
  **EOF** might not be representable as a ``char``.
| 

**EUC and corresponding 32-bit wide-character representation**

+----------+----------------------------+----------------------------+
| Code set | EUC code representation    | Wide-character             |
|          |                            | representation             |
+==========+============================+============================+
| 0        | ``0xxxxxxx``               | ``00000000                 |
|          |                            | 00000000000000000xxxxxxx`` |
+----------+----------------------------+----------------------------+
| 1        | ``1xxxxxxx``               | ``00110000                 |
|          |                            | 00000000000000000xxxxxxx`` |
+----------+----------------------------+----------------------------+
|          | ``1xxxxxxx1xxxxxxx``       | ``00110000                 |
|          |                            | 0000000000xxxxxxxxxxxxxx`` |
+----------+----------------------------+----------------------------+
|          | ``                         | ``00110000                 |
|          | 1xxxxxxx1xxxxxxx1xxxxxxx`` | 000xxxxxxxxxxxxxxxxxxxxx`` |
+----------+----------------------------+----------------------------+
| 2        | ``SS2 1xxxxxxx``           | ``00010000                 |
|          |                            | 00000000000000000xxxxxxx`` |
+----------+----------------------------+----------------------------+
|          | ``SS2 1xxxxxxx1xxxxxxx``   | ``00010000                 |
|          |                            | 0000000000xxxxxxxxxxxxxx`` |
+----------+----------------------------+----------------------------+
|          | ``SS2                      | ``00010000                 |
|          | 1xxxxxxx1xxxxxxx1xxxxxxx`` | 000xxxxxxxxxxxxxxxxxxxxx`` |
+----------+----------------------------+----------------------------+
| 3        | ``SS3 1xxxxxxx``           | ``00100000                 |
|          |                            | 00000000000000000xxxxxxx`` |
+----------+----------------------------+----------------------------+
|          | ``SS3 1xxxxxxx1xxxxxxx``   | ``00100000                 |
|          |                            | 0000000000xxxxxxxxxxxxxx`` |
+----------+----------------------------+----------------------------+
|          | ``SS3                      | ``00100000                 |
|          | 1xxxxxxx1xxxxxxx1xxxxxxx`` | 000xxxxxxxxxxxxxxxxxxxxx`` |
+----------+----------------------------+----------------------------+

Most of the functions provided let you convert multibyte characters into
wide characters and back again. Before we turn to the functions, we
should note that most application programs will not need to convert
multibyte characters to wide characters in the first place. Programs
such as **diff**, for example, will read in and write out multibyte
characters, needing only to check for an exact byte-for-byte match. More
complicated programs such as **grep**, that use regular expression
pattern matching, may need to understand multibyte characters, but only
the common set of functions that manages the regular expression needs
this knowledge. The program **grep** itself requires no other special
multibyte character handling. Finally, note that except for **libc**,
the libraries described below are archives, not shared objects. They
cannot be dynamically linked with your program.

Multibyte and wide-character conversion
---------------------------------------

| ANSI C provides five library functions that manage multibyte and wide
  characters: 
| **mblen** length of next multibyte character
| **mbtowc** convert multibyte character to wide character
| **wctomb** convert wide character to multibyte character
| **mbstowcs** convert multibyte character string to wide character
  string
| **wcstombs** convert wide character string to multibyte character
  string

The first three functions are described on the 
`mbchar\ (S) <../man/html.S/mbchar.S.html>`__ manual page, the last two
on the `mbstring\ (S) <../man/html.S/mbstring.S.html>`__ page.

Input/output
------------

Since most programs will convert between multibyte and wide characters
just before or after performing I/O, **libc** provides routines that let
you manage the conversion within the I/O function itself as if the input
or output stream were wide characters instead of multibyte characters.
**fgetwc**, for instance, reads bytes from a stream until a complete EUC
character has been seen and returns it in its wide-character
representation. **fgetws** does the same thing for strings; **fputwc**
and **fputws** are the corresponding write versions. Of course, these
routines and others are functionally similar to the
`Intro\ (S) <../man/html.S/Intro.S.html>`__ functions; they differ only
in their handling of EUC representations. See their manual pages for
details. Here is a look at how you can expect the functions to work.

Given the following declarations

::

      #include <stdio.h>
      #include <wchar.h>
      
      wchar_t s1[BUFSIZ];  /* declare array s1 to store wide characters */
      char    s2[BUFSIZ];  /* declare array s2 of characters for EUC
                              representation */

a multibyte string can be input into ``s1`` using **fgetws**: 

::

      fgetws(s1, BUFSIZ, stdin);  /* read EUC string from stdin and
                                     convert to process code string in s1 */

**fgets** and **mbstowcs**: 

::

      fgets(s2, BUFSIZ, stdin);   /* read EUC string from stdin into s2 */
      mbstowcs(s1, s2, BUFSIZ);   /* convert EUC string in s2 to process
                                     code string in s1 */

the **%S** conversion specifier for **scanf**: 

::

      scanf("%S", s1);     /* read EUC string from stdin and convert
                              to process code string in s1 */

the **%S** conversion specifier for **scanf** and **mbstowcs**: 

::

      scanf("%S", s2);            /* read EUC string from stdin into s2 */
      mbstowcs(s1, s2, BUFSIZ);   /* convert EUC string in s2 to process
                                     code string in s1 */

You can use **fputws, wcstombs**, and the **%S** conversion specifier
for **printf** (see `fprintf\ (S) <../man/html.S/fprintf.S.html>`__) in
the same way for output.

Character classification and conversion
---------------------------------------

Single- and multibyte character classification and conversion functions
are provided in **libc**. You can use these routines to test 7-bit US
ASCII characters, for instance, in their wide-character representations,
or to determine whether multibyte characters are ideograms, phonograms,
or the like. See the `wctype\ (S) <../man/html.S/wctype.S.html>`__ and
**wconv**\ (S) manual pages for details.

As noted, these routines are declared in the *<wcchar.h>* header.

curses support
--------------

32-bit versions of certain UNIX System V Release 4 (SVR4) **curses**
functions are provided in **libocurses** and declared in
**<ocurses.h>**. Check the
`curses\ (S) <../man/html.S/curses.S.html>`__, manual page for some of
the things you need to look out for in using these functions.

The POSIX curses library (**libcurses**) supports the wide character
functions specified in the POSIX standard. See
`Intro\ (S) <../man/html.S/Intro.S.html>`__.

C language features
-------------------

To give even more flexibility to the programmer in an Asian environment,
ANSI C provides 32-bit wide character constants and wide string
literals. These have the same form as their non-wide versions except
that they are immediately prefixed by the letter **L**: 

**'x'**
   regular character constant
**'¥'**
   regular character constant
**L'x'**
   wide character constant
**L'¥'**
   wide character constant
**abc¥xyz**
   regular string literal
**Labc¥xyz**
   wide string literal

Note that multibyte characters are valid in both the regular and wide
versions. The sequence of bytes necessary to produce the ideogram ¥ is
encoding-specific, but if it consists of more than one byte, the value
of the character constant **'¥'** is implementation-defined, just as the
value of **'ab'** is implementation-defined. A regular string literal
contains exactly the bytes (except for escape sequences) specified
between the quotes, including the bytes of each specified multibyte
character.

When the compilation system encounters a wide character constant or wide
string literal, each multibyte character is converted (as if by calling
the **mbtowc** function) into a wide character. Thus the type of
**L'¥'** is ``wchar_t`` and the type of **L"abc¥xyz"** is array of
``wchar_t`` with length eight. (Just as with regular string literals,
each wide string literal has an extra zero-valued element appended, but
in these cases it is a ``wchar_t`` with value zero.)

Just as regular string literals can be used as a short-hand method for
character array initialization, wide string literals can be used to
initialize ``wchar_t`` arrays: 

::

      wchar_t *wp = L"a¥z";
      wchar_t x[] = L"a¥z";
      wchar_t y[] = {L'a', L'¥', L'z', 0};
      wchar_t z[] = {'a', L'¥', 'z', '\0'};

In the above example, the three arrays **x**, **y** and **z** as well as
the array pointed to by **wp**, have the same length and all are
initialized with identical values.

Adjacent wide string literals will be concatenated, just as with regular
string literals. Adjacent regular and wide string literals produce
undefined behavior.

--------------


/System-defined words
=====================

The SCO OpenServer system uses a number of special words to identify
system resources, user and group names, process IDs, peripherals, and
other information. The following should be specified only with
characters from the primary code set: 

-  process ID numbers
-  message queue, semaphore, and shared memory identifiers
-  external symbol names and fill patterns for the **cc** and **as**
   commands
-  layer names
-  user names
-  group names

Although the following can be specified with supplementary code set
characters, we recommend against it: 

-  passwords
-  names of devices, terminals, and special devices
-  printer names and printer class names
-  system names
-  disk pack, diskette, and tape label/volume names
-  names visible to other machines on a network
-  environment variable names

The following can be specified with primary or supplementary code set
characters, subject to length limitations imposed by the file system: 

-  file names
-  directory names
-  command names
-  file system names

File name prefixes of the form **s.**, or suffixes of the form **.c**,
must be specified with characters from the primary code set.

--------------


/Cultural and language conventions
==================================

In the following sections we will look at how programs interpret or
print the formatted date and time, or formatted numeric and monetary
values, in locale-dependent ways. We will also look at the functions you
use to collate strings according to the rules of the language the locale
implements.

--------------

/Date and time
==============

The ANSI C function **strftime** provides a **sprintf**-like formatting
of the values in a ``struct tm``, along with some date and time
representations that depend on the **LC_CTIME** category of the current
locale. (**strftime** supersedes **ctime** and **ascftime**, although,
for the sake of compatibility with older systems, these routines format
the date and time correctly for a given locale.) Here is how you might
use **strftime** to print the current date in a locale-dependent way: 

::

   #include <stdio.h>
   #include <locale.h>
   #include <time.h>

   main()
   {
       time_t tval;
       struct tm *tmptr;
       char buf [BUFSIZ];

       tval = time(NULL);
       tmptr = localtime(&tval);

       setlocale(LC_ALL, "");

       strftime(buf, BUFSIZE, "%x", tmptr);
       puts(buf);
   }

| In this case, **strftime** puts characters into the array pointed to
  by *buf*, as controlled by the string pointed to by **%x**. **%x** is
  a directive that provides an implementation-defined date
  representation appropriate to the locale. In a Spanish locale, for
  example, the current date June 14, 1990, might be represented as **14
  Junio 1990** or *14/6/90* or any other way the implementation deems
  appropriate to the locale. No particular format is guaranteed.
| Use the **%X** directive to obtain the locale's appropriate time
  representation: 

::

      strftime(buf, BUFSIZE, "%x %X", tmptr)

or **%c** to obtain both the date and time representation. Check the
`strftime\ (S) <../man/html.S/strftime.S.html>`__ manual page for the
other directives.

Although it requires a bit more work, you can control the format of the
date and time for different locales by using **printf** with the message
retrieval functions **gettxt** or **catgets**. Suppose, for example, you
want the current date June 14, 1990, to be displayed in a British locale
as **14/6/90**, in a German locale as **14.6.90**, and in a U.S. locale
as **6/14/90**. What you need, in other words, is some way to switch the
arguments to **printf** depending on the program's current locale. The
**%\ n\ $** form of conversion specification lets you convert the
**n**\ th argument in a **printf** argument list rather than the next
unused argument. That is,

::

      printf(gettxt("progmsgs:9", "%d/%d/%d\n"),
       tm->tm.mon,
       tm->tm.mday,
       tm->tm.year);

will produce the locale-dependent date displays we want, so long as the
string whose index is **9** in the message file *progmsgs* reads, in the
British locale

::

      "%2$d/%1$d/%3$d\n"

in the German locale

::

      "%2$d.%1$d.%3$d\n"

and in the U.S. locale

::

      "%1$d/%2$d/%3$d\n" /* or simply "%d/%d/%d\n" */

You can use **scanf** in a similar way to interpret formatted dates in
the input: 

::

      int month, day, year;
      scanf(gettxt("progmsgs:9", "%d/%d/%d\n"),
       &month, &day, &year);

Note that the **%\ n\ $** form of conversion specification has a wider
application than the one we've described here, as we will show in
`\``Message handling'' <I_MsgHdl.html>`__. There, too, we will take a
closer look at **gettxt** and **catgets**. See
`fprintf\ (S) <../man/html.S/fprintf.S.html>`__,
`fscanf\ (S) <../man/html.S/fscanf.S.html>`__,
`gettxt\ (S) <../man/html.S/gettxt.S.html>`__ and
`catgets\ (S) <../man/html.S/catgets.S.html>`__.

--------------

/Numeric and monetary information
=================================

The ANSI C **localeconv** function returns a pointer to a structure
containing information useful for formatting numeric and monetary
information appropriate to the current locale's **LC_NUMERIC** and
**LC_MONETARY** categories. (This is the only function whose behavior
depends on more than one category.) For numeric values the structure
describes the decimal-point (radix) character, the thousands separator,
and where the separator(s) should be located. Other structure members
describe how to format monetary values, as in the following, somewhat
contrived example. Assuming **setlocale** has been called, the code

::

   int thousands = 1;
   int rest = 234;
   int frac = 56;

   struct lconv *lptr;
   lptr = localeconv();

   printf("%s%d%c%d%c%d\n",
       lptr->currency_symbol,
       thousands, lptr->mon_thousands_sep[0], rest,
       lptr->mon_decimal_point[0], frac);

will print ``kr1.234,56`` in a Norwegian locale, ``F 1.234,56`` in a
Dutch locale, and ``SFrs.1,234.56`` in a Swiss locale. Check
`localeconv\ (S) <../man/html.S/localeconv.S.html>`__ for details.

**localeconv** aside, functions that write or interpret printable
floating values -- **printf** and **scanf**, for example -- will use a
decimal-point character other than a period (\`\`.'') when the
**LC_NUMERIC** category of the current locale is other than \`\`"C"''.
There is no provision for converting numeric values to printable form
with thousands separator-type characters, but when converting from a
printable form to an internal form, implementations are allowed to
accept such additional forms, again in other than the \`\`"C"'' locale.
Functions that make use of the decimal-point character are the
**printf** and **scanf** families, **atof**, and **strtod**. Functions
that are allowed implementation-defined extensions for the thousands
separator are **atof**, **atoi**, **atol**, **strtod**, **strtol**,
**strtoul**, and the **scanf** family.

--------------

/String collation
=================

|  ANSI C provides two functions for locale-dependent string compares.
  **strcoll** is analogous to **strcmp** except that the two strings are
  compared according to the **LC_COLLATE** category of the current
  locale. (See the `strcoll\ (S) <../man/html.S/strcoll.S.html>`__
  manual page and **strcmp** on the
  `string\ (S) <../man/html.S/string.S.html>`__ manual page).
  Conceptually, collation occurs in two passes to obtain an appropriate
  ordering of accented characters, two-character sequences that should
  be treated as one (the Spanish character **ch**, for example), and
  single characters that should be treated as two (the sharp **s** in
  German, for instance). Since this comparison is not necessarily as
  inexpensive as **strcmp**, the **strxfrm** function is provided to
  transform a string into another. Therefore, any two such
  after-translation strings can be passed to **strcmp** to get an
  ordering identical to what **strcoll** would have returned if passed
  the two pre-translation strings. You are responsible for keeping track
  of the strings in their translated and printable forms. Generally, you
  should use **strxfrm** when a string will be compared a number of
  times.

The following example uses `qsort\ (S) <../man/html.S/qsort.S.html>`__
and `strcoll\ (S) <../man/html.S/strcoll.S.html>`__ to sort lines in a
text file: 

::

   #include <stdio.h>
   #include <string.h>
   #include <locale.h>

   char table [ELEMENTS] [WIDTH];

   main(argc, argv)
   int argc;
   char **argv;
   {
       FILE *fp;
       int nel, i;

       setlocale(LC_ALL, "");

       if ((fp = fopen(argv[1], "r")) == NULL) {
           fprintf(stderr, gettxt("progmsgs:2",
               "Can't open %s\n", argv[1]);
           exit(2);
       }
       for (nel = 0; nel < ELEMENTS &&
           fgets(table[nel], WIDTH, fp); ++nel);

       fclose(fp);

       if (nel >= ELEMENTS) {
           fprintf(stderr, gettxt("progmsgs:3",
               "File too large\n");
           exit(3);
       }
       qsort(table, nel, WIDTH, strcoll);
       for (i = 0; i < nel; ++i)
           fputs(table(i), stdout);
       return(0);
   }

| 

The next example does the same thing with a function that uses
**strxfrm**: 

::

   compare (s1, s2)
   char *s1, *s2;
   {
       char *tmp;
       int result;
       size_t n1 = strxfrm(NULL, s1, 0) + 1;
       size_t n2 = strxfrm(NULL, s2, 0) + 1;

       if ((tmp = malloc(n1 + n2)) == NULL)
           return strcmp(s1, s2);

       (void)strxfrm(tmp, s1, n1);
       (void)strxfrm(tmp + n1 + 1, s2, n2);

       result = strcmp(tmp, tmp + n1 + 1);
       free(tmp);
       return(result);
   }

Assuming **malloc** succeeds, the return value of **compare (s1, s2)**
should correspond to the return value of **strcoll(s1, s2)**. Although
it is too complicated to show here, it would probably be better to hold
onto the strings for subsequent comparisons rather than transforming
them each time the function is called. See the
`strcoll\ (S) <../man/html.S/strcoll.S.html>`__ and
`strxfrm\ (S) <../man/html.S/strcoll.S.html>`__ manual pages.

--------------


/Message handling
=================

As the examples in earlier sections may have suggested, the general
approach behind the message handling feature is to separate messages
from program source code, replacing hard-coded character strings with
function calls that fetch the strings from a file. You supply the file,
which contains your program's messages in whatever language the locale
implements. You can adapt your applications to different locales, then,
without having to change and recompile source code.

In this section we will look at the SCO OpenServer-specific and X/Open
message handling facilities as they might be used to adapt an
\``English-speaking'' program to a French locale. The code fragment
below queries the English-speaking user for an affirmative or negative
response, and reads the response: 

::

   #include <stdio.h>

   main()
   {
       int yes();

       while(1)
       {
           puts("Choose (y/n)");
           if (yes())
               puts("yes");
           else
               puts("no");
       }
   }

   static int
   yes()
   {
       int i, b;

       i = b = getchar();
       while (b != '\n' && b != '\0' && b != EOF)
           b = getchar();
       return(i == 'y');
   }

--------------


/mkmsgs and gettxt (OS-specific)
================================

You use the **mkmsgs** command to store the strings for a given locale
in a file that can be read by the message retrieval function **gettxt**.
**mkmsgs** accepts an input file consisting of text strings separated by
newlines. If the file **fr.str** contains

::

      Votre choix (o/n)
      oui
      non

the command

::

      $ mkmsgs -o -i fr fr.str progmsgs

will generate a file called *progmsgs* that, when installed in the
directory */usr/lib/locale/fr/LC_MESSAGES*, can be read by **gettxt**
such that

::

      puts(gettxt("progmsgs:1", "Choose (y/n)"));

will display

::

      Votre choix (o/n)

in a French locale. **gettxt** takes as its first argument the name of
the file created by **mkmsgs** and the number of the string in the file,
counting from 1. You hard-code the second argument, not necessarily in
English, in case **gettxt** fails to retrieve the message string from
the current locale, or the \`\`"C"'' locale.

--------------


/exstr and srchtxt (OS-specific)
================================

Once you have created the message files for the different locales, you
can use the **exstr** command to extract the strings from the original
source code and replace them with calls to **gettxt**. If the name of
the source file is *prog.c*, the command

::

      $ exstr -e prog.c > prog.strings

will produce the following output in *prog.strings*: 

::

      prog.c:9:8:::Choose (y/n)
      prog.c:11:8:::yes
      prog.c:13:8:::no

The first three fields in each entry are the file name, the line number
in which the string appears in the file, and the character position of
the string in the line. You fill in the next two fields with the name of
the message file and the index of the string in the file: 

::

      prog.c:9:8:progmsgs:1:Choose (y/n)
      prog.c:11:8:progmsgs:2:yes
      prog.c:13:8:progmsgs:3:no

Now the command

::

      $ exstr -rd prog.c < prog.strings > intl.c

will produce in *intl.c* 

::

   #include <stdio.h>

   extern char *gettxt();
   main()
   {
       int yes();

       while(1)
       {
           puts(gettxt("progmsgs:1", "Choose (y/n)"));
           if (yes())
               puts(gettxt("progmsgs:2", "yes"));
           else
               puts(gettxt("progmsgs:3", "no"));
       }
   }

   static int
   yes()
   {
       int i, b;

       i = b = getchar();
       while (b != '\n' && b != '\0' && b != EOF)
           b = getchar();
       return(i == 'y');
   }

The completed source code would look like this: 

::

   #include <stdio.h>
   #include <unistd.h>
   #include <string.h>
   #include <locale.h>
   #define RESPLEN 16

   char yesstr[RESPLEN];   /* assumed to be long enough */
   extern char *gettxt();
   main()
   {
       int yes();

       setlocale(LC_ALL, "");

       /* save local yes string for subsequent comparisons */
       strcpy(yesstr, gettxt("progmsgs:2", "yes"));

       while(1)
       {
           puts(gettxt("progmsgs:1", "Choose (y/n)"));
           if (yes())
               puts(yesstr);
           else
               puts(gettxt("progmsgs:3", "no"));
       }
   }

   static int
   yes()
   {
       int i, b;

       i = b = getchar();
       while (b != '\n' && b != '\0' && b != EOF)
           b = getchar();
       return(i == (int) yesstr[0]);
   }

The **srchtxt** command lets you display or search for text strings in
message files installed in a given locale. Among other ways, you might
want to use it to see how other programs have translated messages
similar to yours. See the
`mkmsgs\ (CP) <../man/html.CP/mkmsgs.CP.html>`__, **exstr**\ (CP),
**srchtxt**\ (CP) and `gettxt\ (S) <../man/html.S/gettxt.S.html>`__
manual pages.

--------------

/catopen and catclose (X/Open)
==============================

As noted in `\``Internationalization'' <Intization.html>`__' the X/Open
messaging interface is the de facto standard throughout much of Europe,
so you can generally count on wider support for it than for the SCO
OpenServer-specific version. The principal difference between the
interfaces lies in where your message files, or message catalogs, to use
the X/Open terminology, are located on the target system. SCO
OpenServer-specific message files must be installed in the standard
place. X/Open message catalogs can be installed anywhere on the system,
which means that programs must search their environments for the
location of message catalogs at run time.

Users specify message catalog search paths with the **NLSPATH**
environment variable. The value of **NLSPATH** is used by the function
**catopen** to locate the message catalog named in its first argument.
Users will almost always find it convenient to use the \``%L'' and
\``%N'' substitution fields when setting **NLSPATH**: 

::

      $ NLSPATH="%L/%N" export NLSPATH

In this example, the value of the **LC_MESSAGES** locale category is
substituted for \``%L''. The value of the first argument to **catopen**
is substituted for \``%N''. So if the name of the catalog given to
**catopen** is *progmsgs*, and if the environment variable
**LC_MESSAGES** is set to **french**, then the value of **NLSPATH**
would be */usr/lib/locale/french/LC_MESSAGES/progmsgs* on a SCO
OpenServer implementation. For more on **NLSPATH**, see the
`catopen\ (S) <../man/html.S/catopen.S.html>`__ manual page.

The call to **catopen** would look like: 

::

      nl_catd catd;
      catd = catopen("progmsgs", 0);

where **catopen** and the type **nl_catd** are defined in the header
*<nl_types.h>*. **catd** is a message catalog descriptor that can be
passed as an argument to subsequent calls of the **catgets** and
**catclose** functions. We will look at **catgets** in the next section;
**catclose** closes the message catalog identified by **catd**. The
second argument to **catopen** is not used by implementations currently
and should be set to **0**.

--------------

/gencat and catgets (X/Open)
============================

You use the **gencat** command to store the strings for a given locale
in a catalog that can be read by the message retrieval function
**catgets**. The **gencat** input file for our example would be: 

::

      $set
      1 votre choix (o/n)
      2 oui
      3 non

The **$set** directive specifies that the three messages are members of
set 1. A subsequent **$set** directive would mean that the following
messages are members of set 2, and so on. The messages for each module
of an application, then, can be assigned to different sets, making it
easier to keep track of message numbers across source files: the
messages for any given module will always be numbered consecutively from
1. Note that each message in a **gencat** input file must be numbered.
For details of the input file syntax, see the
`gencat\ (CP) <../man/html.CP/gencat.CP.html>`__ manual page.

If the **gencat** input file is named *fr.str*, the command

::

      $ gencat progmsgs fr.str

will generate a catalog called ``progmsgs`` that, when installed in the
appropriate directory, can be read by **catgets** such that

::

      puts(catgets(catd, 1, 1, "Choose (y/n)"));

will display

::

      Votre choix (o/n)

in a French locale. **catd** is the message catalog descriptor returned
by the earlier call to **catopen**; the second and third arguments are
the set and message numbers, respectively, of the string in the catalog.
Again, you hard-code the final argument in case **catgets** fails. see
the `gencat\ (CP) <../man/html.CP/gencat.CP.html>`__,
`catgets\ (S) <../man/html.S/catgets.S.html>`__, and
`catopen\ (S) <../man/html.S/catopen.S.html>`__ manual pages.

The X/Open version of our example follows: 

::

   #include <stdio.h>
   #include <nl_types.h>
   #include <string.h>
   #include <locale.h>
   #define RESPLEN 16

   char yesstr[RESPLEN];   /* assumed to be long enough */
   extern char *catgets();
   main()
   {
       int yes();
       nl_catd catd;
       setlocale(LC_ALL, "");
       catd = catopen("progmsgs", 0);

       /* save local yes string for subsequent comparisons */
       strcpy(yesstr, catgets(catd, 1, 2, "yes"));

       while(1)
       {
           puts(catgets(catd, 1, 1, "Choose (y/n)"));
           if (yes())
               puts(yesstr);
           else
               puts(catgets(catd, 1, 3, "no"));
       }
   }

   static int
   yes()
   {
       int i, b;
       i = b = getchar();
       while (b != '\n' && b != '\0' && b != EOF)
           b = getchar();
       return(i == (int) yesstr[0]);
   }

--------------

/%n$ conversion specifications
==============================

|  Earlier we noted that the **%\ n\ $** form of conversion
  specification lets you convert the **n**\ th argument in a **printf**
  or **scanf** argument list rather than the next unused argument. We
  showed you how you could use the feature to control the format of the
  date and time in different locales, and suggested that **%\ n\ $** had
  a wider
| application than that. What we had in mind were cases in which the
  rules of a given language were built into print statements such as

::

      printf("%s %s\n",
       func == MAP ? "Can't map" : "Can't create", pathname);

The problem with this code is that it assumes that the verb precedes the
object of the sentence, which is not the case in many languages. In
other words, even if we rewrote the fragment to use **gettxt**, and
stored translations of the strings in message files in the appropriate
locales, we would still want to use the **%\ n\ $** conversion
specification to switch the arguments to **printf** depending on the
locale. That is, the **printf** format string

::

      "%1$s %2$s\n"

in an English-language locale would be written

::

      "%2$s %1$s\n"

in a locale in which the object of the sentence precedes the predicate.

--------------

/7. Directory and file management
==================================

SCO OpenServer File System functions create and remove files and
directories, and inspect and modify their characteristics. Processes use
these functions to access files and directories for subsequent I/O
operations. One of the most important services provided by an operating
system is to maintain a consistent, orderly and easily accessed file
system. The SCO OpenServer file system contains directories of files
arranged in a tree-like structure. The Unixware file system is simple in
structure; nevertheless, it is more powerful and general than those
often found even in considerably larger operating systems.

All SCO OpenServer files have a consistent structure to conceal physical
properties of the device storing the file, such as the size of a disk
track. It is not necessary, nor even possible, to preallocate space for
a file. The size of a file is the number of bytes in it, with the last
byte determined by the high-water mark of writes to the file. SCO
OpenServer presents each file as a featureless, randomly addressable
sequence of bytes arranged as a one-dimensional array of bytes ending
with **EOF**.

The SCO OpenServer file system organizes files and directories into a
tree-like structure of directories with files attached anywhere (and
possibly multiply) into this hierarchy of directories. Files can be
accessed by a \``full pathname'' or \``relative pathname'', have
independent protection modes, are automatically allocated and
de-allocated, and can be linked across directories.

In the hierarchically arranged directory tree-structure, each directory
contains a list of names (character strings) and the associated file
index, which implicitly refers to the same device as does the directory.
Because directories are themselves files, the naming structure is
potentially an arbitrary directed graph. Administrative rules restrict
it to have the form of a tree, except that non-directory-files may have
several names (entries in various directories).

The same non-directory-file may appear in several directories under
possibly different names. This feature is called \``linking''; a
directory-entry for a file is sometimes called a \``link''. SCO
OpenServer differs from other systems in which linking is permitted in
that all links to a file have equal status. That is, a file does not
exist within a particular directory; the directory-entry for a file
consists merely of its name and a pointer to the information actually
describing the file. Thus, a file exists independently of any
directory-entry, although in practice a file is removed along with the
last link to it.


/Types of files
===============

From the point of view of the user, there are three types of files: 

1. regular files
2. directory files
3. special files

The user and user application programs access all three types of files
simply as a string of bytes, and must interpret the file appropriately.
In SCO OpenServer, files normally reside on a disk.

Regular files
-------------

Regular files contain whatever information users write onto them (for
example, character data, source programs or binary objects). Any file
other than a special file or a directory file is a regular file. Every
file is a (one-dimensional) array of bytes; SCO OpenServer imposes no
further structure on the contents of files. A file of text consists
simply of a string of characters, with the new-line character delimiting
lines. Binary files are sequences of machine instructions as they appear
in memory when the file executes. Some programs operate on files with
more structure; for example, the assembler generates, and the loader
expects, object files in a specific format. The programs that use files
dictate their structure, not the system.

Directory files
---------------

Directory files (also called \``directories'') provide the mapping
(paths) between the names of files and the files themselves. Directories
induce a tree-like structure on the file system as a whole to create a
hierarchical system of files with directories as the nodes in the
hierarchy. A directory is a file that catalogs the files, including
directories (sub-directories), directly beneath it in the hierarchy.

Each user owns a directory of files, and may also create sub-directories
to contain groups of files conveniently treated together. A directory
behaves exactly like a regular file except that only the operating
system can write onto it. SCO OpenServer controls the contents of
directories; however, users with permission may read a directory just
like any other file.

The operating system maintains several directories for its own use. One
of these is the *root-directory*. Each file in the file system can be
found by tracing a path from the root-directory through a chain of
directories until the desired file is reached. Other system directories
contain any programs provided for general use; that is, all
\``commands''; however, it is by no means necessary that a program
reside in one of these directories for it to be executed.

Entries in a directory file are called **links**. A link associates a
file-identifier with a filename. Each directory has at least two links,
\`\`.'' (dot) and \`\`..'' (dot-dot). The link dot refers to the
directory itself; while dot-dot refers to the parent of the directory in
which dot-dot appears. Programs may read the current-directory using
\`\`.'' without knowing its complete pathname.

The root-directory, which is the top-most node of the hierarchy, has
itself as its parent-directory; thus, \`\`\ */*'' is the pathname of
both the root-directory and the parent-directory of the root-directory.

The directory structure is constrained to have the form of a rooted
tree. Except for the special entries \`\`.'' and \`\`..'', each
directory must appear as an entry in exactly one other directory, which
is its parent. The reason for this is to simplify the writing of
programs that visit sub-trees of the directory structure, and more
important, to avoid the separation of portions of the hierarchy. If
arbitrary links to directories were permitted, it would be quite
difficult to detect when the last connection from the root-directory to
a directory was severed.

Special files
-------------

Special files constitute the most unusual feature of the SCO OpenServer
file system. Each supported I/O device is associated with at least one
special file. Special files are read and written just like regular
files, but requests to read or write result in activation of the
associated device-handler (driver) rather than the normal file
mechanism.

An entry for each special file resides under the directory
\`\`\ */dev*'', although a link may be made to one of these files just
as it may to a regular file. For example, to write on magnetic tape one
may write on the file \`\`\ */dev/rmt*''. Special files exist for
peripheral devices such as terminal ports, communication links, disk
drives, tape drives and for physical main memory. Of course, the active
disks and memory special files are protected from indiscriminate access
by appropriate read and write permissions.

There are several advantages to treating I/O devices this way: 

-  file and device I/O are as similar as possible; all I/O is treated
   uniformly, and the same system calls work on all types of files.
-  file and device names have the same syntax and meaning, so that a
   program expecting a filename as a parameter can be passed a device
   name.
-  the same protection mechanism works on special files, directory files
   and regular files.

--------------

/Organization of files
======================

The file system is made up of a set of regular files, special files,
symbolic links, and directories. These components provide a way to
organize, retrieve, and manage information electronically. `\``File and
device input/output'' <FlDevIO.html>`__ introduced some of the
properties of directories and files; this section will review them
briefly before discussing how to use them.

-  A regular file is a collection of characters stored on a disk. It may
   contain text for a report or code for a program.
-  A special file represents a physical device, such as a terminal or
   disk.
-  A symbolic link is a file that points to another file.
-  A directory is a collection of files and other directories (sometimes
   called subdirectories). Use directories to group files together on
   the basis of any criteria you choose. For example, you might create a
   directory for each product that your company sells or for each of
   your student's records.

The set of all the directories and files is organized into a tree shaped
structure. `\``A sample file
system'' <_Organization_of_Files.html#dfm_d1>`__ shows a sample file
structure with a directory called root (/) as its source. By moving down
the branches extending from root, you can reach several other major
system directories. By branching down from these, you can, in turn,
reach all the directories and files in the file system.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/filesys.gif

**A sample file system**

| In this hierarchy, files and directories that are subordinate to a
  directory have what is called a parent/child relationship. This type
  of relationship is possible for many layers of files and directories.
  In fact, there is no limit to the number of files and directories you
  may create in any directory that you own. Neither is there a limit to
  the number of layers of directories that you may create. Thus, you
  have
| the capability to organize your files in a variety of ways, as shown
  in the preceding figure.

--------------




/File naming
============

Strings of 1 or more characters may be used to name a regular file,
directory file or special file. The characters may be any from the set
of all character values excluding \``null'' and \``slash'', \`\`\ */*''.
The following are examples of legal directory or file names: 

::

          memo    MEMO    section2    ref:list
       file.d  chap3+4 item1-10    outline

A regular file, special file or directory may have any name that
conforms to the following rules: 

-  All characters other than */* are legal.
-  Non-printing characters including space, tab and backspace, are best
   avoided. If you use a space or tab in a directory or filename, you
   must enclose the name in quotation-marks on the command-line.
-  Note that it is generally unwise to use \``\*'', \`\`?'', \`\`!'',
   \``['' or \`\`]'' as part of filenames because of the special meaning
   given these characters for filename expansion by the command
   interpreter (see `system\ (S) <../man/html.S/system.S.html>`__).
   Other characters to avoid are the hyphen, \``<'', \`\`>'', backslash,
   single and double quotes, accent grave, vertical bar, caret, curly
   braces and parentheses.
-  Avoid using a \``+'', \`\`-'' or \`\`.'' as the first character in a
   filename.
-  Upper case and lower case characters are distinct to the UNIX system.
   For example, the system considers a directory (or file) named *draft*
   to be different from one named *DRAFT*.

--------------

/Path names
===========

The name of a file may take the form of a \``pathname'', which is a
sequence of directory names separated from one another by \`\`\ */*''
and ending in a filename. A pathname is a null-terminated
character-string starting with an optional slash, \`\`\ */*'', followed
by zero or more directory-names separated by slashes and optionally
followed by a filename.

More precisely, a pathname is a null-terminated character-string as
follows: 

::

      <path_name>::=<file_name>|<path_prefix><file_name>|/|``.''|``..''
      <path_prefix>::=<rtprefix>|/<rtprefix>|empty
      <rtprefix>::=<dirname>/|<rtprefix><dirname>/

where **<file_name>** is a string of 1 or more significant characters
(other than slash and null), and **<dirname>** is a string of 1 or more
significant characters (other than slash and null) that names a
directory. The result of names not produced by the grammar are
undefined. A null string is undefined and may be considered an error. As
a limiting case, the pathname \``/'' refers to the root-directory
itself. An attempt to create or delete the pathname slash by itself is
undefined and may be considered an error. The meanings of \`\`.'' and
\`\`..'' are defined in `\``Directory
files'' <_Types_of_Files.html#DFM_DirFls>`__.

The sequence of directories preceding the filename is called a
*path-prefix*, and if the path-prefix begins with a slash, the search
begins in the root-directory. This is called a *full pathname*.

--------------

/Full pathnames
===============

A full pathname (sometimes called an \``absolute pathname'') starts in
the root directory and leads down through a unique sequence of
directories to a particular directory or file. Because a full pathname
always starts at the root of the file system, its leading character is
always a */* (slash). The final name in a full pathname can be either a
file name or a directory name. All other names in the path must be
directories. You can use a full pathname to reach any file or directory
in the UNIX system in which you are working.

| To understand how a full pathname is constructed and how it directs
  you, consider the following example. Suppose you are working in the
  *starship* directory, located in */home*. You issue the **pwd**
  command and the system responds by printing the full pathname of your
  working directory: */home/starship*.

The following figure and key diagrams the elements of this pathname: 

+------------------+--------------------------------------------------+
| */* (leading)    | the slash that appears as the first character in |
|                  | the pathname is the root of the file system      |
+------------------+--------------------------------------------------+
| *home*           | system directory one level below root in the     |
|                  | hierarchy to which root points or branches       |
+------------------+--------------------------------------------------+
| */* (subsequent) | the next slash separates or delimits the         |
|                  | directory names *home* and *starship*            |
+------------------+--------------------------------------------------+
| *starship*       | current working directory                        |
+------------------+--------------------------------------------------+

**Diagram of a full pathname**

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/pathprts.gif

The following pathname: 

::

   /usr/bin/send

causes a search of the root-directory for directory \`\`\ *usr*'', then
a search of \`\`\ *usr*'' for \`\`\ *bin*'', finally to find
\`\`\ **send**'' in \`\`\ *bin*''. The file \`\`\ **send**'' may be a
directory, regular or special file. A null-prefix (or for that matter,
any path-prefix without an initial ''*/*'') causes the search to begin
in the current-directory of the user. Thus, the simplest form of
pathname, \`\`\ *alpha*'', refers to a file found in the
current-directory, and the pathname \`\`\ *alpha/beta*'' specifies the
file named \`\`\ *beta*'' in sub-directory \`\`\ *alpha*'' of the
current-directory. This **relative pathname** allows a user to quickly
specify a sub-directory without needing to know (or input) the full
pathname.

The dashed lines in `\``Full pathname of the /home/starship
directory'' <_Full_Pathnames.html#dfm_d3>`__ trace the full path to
*/home/starship*.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/fullstar.gif

**Full pathname of the /home/starship directory**

--------------


/Relative pathnames
===================

A relative pathname gives directions that start in your current working
directory and lead you up or down through a series of directories to a
particular file or directory. By moving down from your current
directory, you can access files and directories you own.

For example, suppose you are in the directory *starship* in the sample
system and *starship* contains directories named *draft*, *letters*, and
*bin* and a file named *mbox*. The relative pathname to any of these is
simply its name, such as *draft* or *mbox*. `\``Relative pathname of the
draft directory'' <_Relative_Pathnames.html#dfm_d4>`__ traces the
relative path from *starship* to *draft*.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/reldraft.gif

**Relative pathname of the draft directory**

The *draft* directory belonging to *starship* contains the files
*outline* and *table*. The relative pathname from *starship* to the file
*outline* is *draft/outline*.

`\``Relative pathname from starship to
outline'' <_Relative_Pathnames.html#dfm_d5>`__ traces this relative
path. Notice that the slash in this pathname separates the directory
named *draft* from the file named *outline*. Here, the slash is a
delimiter showing that *outline* is subordinate to *draft*; that is,
*outline* is a child of its parent, *draft*.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/relstar.gif

**Relative pathname from starship to outline**

So far, the discussion of relative pathnames has covered how to specify
names of files and directories that belong to, or are children of, the
current directory. You can move down the system hierarchy level by level
until you reach your destination. You can also, however, ascend the
levels in the system structure or ascend and subsequently descend into
other files and directories.

By moving up from your current directory, you pass through layers of
parent directories to the grandparent of all system directories, root.
From there you can move anywhere in the file system.

The relative pathname is just one of the mechanisms built into the file
system to alleviate the need to use full pathnames. By convention, the
path-prefix \`\`..'' refers to the parent-directory (that is, the
directory containing the current-directory), and the path-prefix \`\`.''
refers to the current-directory.

A relative pathname begins with one of the following: a directory or
file name; a \`\`.'' (pronounced dot), which is a shorthand notation for
your current directory; or a \`\`..'' (pronounced dot dot), which is a
shorthand notation for the directory immediately above your current
directory in the file system hierarchy. The directory represented by
\`\`..'' (dot dot) is called the parent directory of \`\`.'' (your
current directory).

To ascend to the parent of your current directory, you can use the
\`\`..'' notation. This means that if you are in the directory named
\`\`\ *draft*'' in the sample file system, \`\`..'' is the pathname to
\`\`\ *starship*'', and ''*../..*'' is the pathname to
\`\`\ *starship*'''s parent directory, \`\`\ *home*''.

From \`\`\ *draft*'', you can also trace a path to the file
\`\`\ *sanders*'' by using the pathname \`\`\ *../letters/sanders*''.
The \`\`..'' brings you up to \`\`\ *starship*''. Then the names
\`\`\ *letters*'' and \`\`\ *sanders*'' take you down through the
\`\`\ *letters*'' directory to the \`\`\ *sanders*'' file.

Keep in mind that you can always use a full pathname in place of a
relative one.

`\``Example pathnames'' <_Relative_Pathnames.html#dfm_d6>`__ shows some
examples of full and relative pathnames.

**Example pathnames**

+-----------------------------------+-----------------------------------+
| Path Name                         | Meaning                           |
+===================================+===================================+
|  */*                              | full pathname of the root         |
|                                   | directory                         |
+-----------------------------------+-----------------------------------+
|  */usr/bin*                       | full pathname of the *bin*        |
|                                   | directory that belongs to the     |
|                                   | *usr* directory that belongs to   |
|                                   | *root* (contains most executable  |
|                                   | programs and utilities)           |
+-----------------------------------+-----------------------------------+
|  */home/starship/bin/tools*       | full pathname of the *tools*      |
|                                   | directory belonging to the *bin*  |
|                                   | directory that belongs to the     |
|                                   | *starship* directory belonging to |
|                                   | *home* that belongs to root       |
+-----------------------------------+-----------------------------------+
|  *bin/tools*                      | relative pathname to the file or  |
|                                   | directory *tools* in the          |
|                                   | directory *bin*.                  |
|                                   | If the current directory is */*,  |
|                                   | then the UNIX system searches for |
|                                   | */usr/bin/tools*. However, if the |
|                                   | current directory is *starship*,  |
|                                   | then the system searches the full |
|                                   | path */home/starship/bin/tools*.  |
+-----------------------------------+-----------------------------------+
|  *tools*                          | relative pathname of a file or    |
|                                   | directory *tools* in the current  |
|                                   | directory.                        |
+-----------------------------------+-----------------------------------+

Moving files to the directory \`\`.'' moves them into the
current-directory. In addition, files can be linked across directories.
Linking a file to the current-directory obviates the need to supply a
path-prefix when accessing the file. When created, a process has one
current-directory and one root-directory associated with it, which can
differ for other processes. See `\``Process
management'' <_Process_Management.html>`__ for more detail on processes.

--------------



/Symbolic links
===============

A symbolic link is a special type of file that represents another file.
The data in a symbolic link consists of the pathname of a file or
directory to which the symbolic link file is linked. The link that is
formed is called symbolic to distinguish it from a regular (also called
a hard) link such as can be created by using the
`ln\ (C) <../man/html.C/ln.C.html>`__ command. A symbolic link differs
functionally from a regular link in three major ways: files from
different file systems may be linked together; directories as well as
regular files may be symbolically linked by any user; and a symbolic
link can be created even if the file it represents does not exist.

In order to understand how a symbolic link works, it is necessary to
understand how the UNIX operating system views files. (The following
description pertains to files that belong to the standard System V file
system type.) The internal representation of a file is contained in an
inode, which contains a description of the layout of the file data on
disk as well as information about the file, such as the file owner, the
access permissions, and the access times. Every file has one inode, but
a file may have several names, all of which point to the inode. Each
name is called a regular (or hard) link.

When a file is created, an inode is allocated for it, the file contents
are stored in data blocks, and an entry is created in a directory. A
directory is a file whose data is a sequence of entries, each consisting
of an inode number and the name of a file. The inode initially has a
link count of one, which means that this file has one name (or one link
to it).

We are now in a position to understand the difference between the
creation of a regular and a symbolic link. When a user creates a regular
link to a file with the `ln\ (C) <../man/html.C/ln.C.html>`__ command, a
new directory entry is created containing a new file name and the inode
number of an existing file. The link count of the file is incremented.

In contrast, when a user creates a symbolic link both a new directory
entry and a new inode are created. A data block is allocated to contain
the pathname of the file to which the symbolic link refers. The link
count of the referenced file is not incremented.

Symbolic links can be used to solve a variety of common problems. For
example, it frequently happens that a disk partition (such as root) runs
out of disk space. With symbolic links, an administrator can create a
link from a directory on that file system to a directory on another file
system. Such a link provides extra disk space and is, in most cases,
transparent to both users and programs.

Symbolic links can also help deal with the built-in pathnames that
appear in the code of many commands. Changing the pathnames would
require changing the programs and recompiling them. With symbolic links,
the pathnames can effectively be changed by making the original files
symbolic links that point to new files.

In a shared resource environment like NFS, symbolic links can be very
useful. For example, if it is important to have a single copy of certain
administrative files, symbolic links can be used to help share them.
Symbolic links can also be used to share resources selectively. Suppose
a system administrator wants to do a remote mount of a directory that
contains sharable devices. These devices must be in */dev* on the client
system, but this system has devices of its own so the administrator does
not want to mount the directory onto */dev*. Rather than do this, the
administrator can mount the directory at a location other than */dev*
and then use symbolic links in the */dev* directory to refer to these
remote devices. (This is similar to the problem of built-in pathnames
since it is normally assumed that devices reside in the */dev*
directory.)

Finally, symbolic links can be valuable within the context of the
virtual file system (VFS) architecture. With VFS new services, such as
higher performance files, events, and network IPC, may be provided on a
file system basis. Symbolic links can be used to link these services to
home directories or to places that make more sense to the application or
user. Thus one might create a database index file in a RAM-based file
system type and symbolically link it to the place where the database
server expects it and manages it.

--------------

**NOTE:** The phrases \``following symbolic links'' and \``not following
symbolic links'' as they are used in this document refer to the
evaluation of the last component of a pathname. In the evaluation of a
pathname, if any component other than the last is a symbolic link, the
symbolic link is followed and the referenced file is used in the
pathname evaluation. However, if the last component of a pathname is a
symbolic link, the link may or may not be followed.

--------------

--------------


/Properties of symbolic links
=============================

This section summarizes some of the essential characteristics of
symbolic links. Succeeding sections describe how symbolic links may be
used, based on the characteristics outlined here.

| As we have seen above, a symbolic link is a new type of file that
  represents another file. The file to which it refers may be of any
  type; a regular file, a directory, a character-special, block-special,
  or FIFO-special file, or another symbolic link. The file may be on the
  local system or on a remote system. In fact, the file to
| which a symbolic link refers does not even have to exist. In
  particular, the file does not have to exist when the symbolic link is
  created or when it is removed.

Creation and removal of a symbolic link follow the same rules that apply
to any file. To do either, the user must have write permission in the
directory that contains the symbolic link. The ownership and the access
permissions (mode) of the symbolic link are ignored for all accesses of
the symbolic link. It is the ownership and access permissions of the
referenced file that are used.

A symbolic link cannot be opened or closed and its contents cannot be
changed once it has been created.

If */usr/jan/junk* is a symbolic link to the file */etc/passwd*, in
effect the file name */etc/passwd* is substituted for *junk* so that
when the user executes

::

      cat /usr/jan/junk

it is the contents of the file */etc/passwd* that are printed.

Similarly, if */usr/jan/junk* is a symbolic link to the file *../junk2*,
executing

::

      cat /usr/jan/junk

is the same as executing 

::

      cat /usr/jan/../junk2

or

::

      cat /usr/junk2

When a symbolic link is followed and brings a user to a different part
of the file tree, we may distinguish between where the user really is
(the physical path) and how the user got there (the virtual path). The
behavior of */usr/bin/pwd*, the shell built-in **pwd**, and \`\`..'' are
all based on the physical path. In practical terms this means that there
is no way for the user to retrace the path which brought the user to the
current position in the file tree.

--------------

**CAUTION:** Other shells may use the virtual path. For example, by
default the Korn shell **pwd** uses the virtual path, though there is an
option allowing the user to make it use the physical path.

--------------

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/symlink.gif

**File tree with symbolic link**

Consider the case shown in `\``File tree with symbolic 
link'' <_Properties_of_Symbolic_Links.html#dfm_d7>`__ where
*/usr/include/sys* is a symbolic link to */usr/src/uts/sys*. Here if a
user enters

::

      cd /usr/include/sys

and then enters **pwd**, the result is

::

      /usr/src/uts/sys

If the user then enters **cd ..** followed by **pwd**, the result is

::

      /usr/src/uts

--------------




/Using symbolic links
=====================

This section discusses creating, removing, accessing, copying, and
linking symbolic links.

Creating symbolic links
-----------------------

To create a symbolic link, the new system call 
`symlink\ (S) <../man/html.S/symlink.S.html>`__ is used and the owner
must have write permission in the directory where the link will reside.
The file is created with the user's user-id and group-id but these are
subsequently ignored. The mode of the file is created as 0777.

--------------

**CAUTION:** No checking is done when a symbolic link is created. There
is nothing to stop a user from creating a symbolic link that refers to
itself or to an ancestor of itself or several links that loop around
among themselves. Therefore, when evaluating a pathname, it is important
to put a limit on the number of symbolic links that may be encountered
in case the evaluation encounters a loop. The variable **MAXSYMLINKS**
is used to force the error **ELOOP** after **MAXSYMLINKS** symbolic
links have been encountered. The value of **MAXSYMLINKS** should be at
least 20.

--------------

To create a symbolic link, the **ln** command is used with the **-s**
option (see `ln\ (C) <../man/html.C/ln.C.html>`__). If the **-s** option
is not used and a user tries to create a link to a file on another file
system, a symbolic link will not be created and the command will fail.

The syntax for creating symbolic links is as follows: 

::

      ln -s sourcefile1 [ sourcefile2 ... ] target

With two arguments: 

-  **sourcefile1** may be any pathname and need not exist.
-  **target** may be an existing directory or a non-existent file.
-  If **target** is an existing directory, a file is created in
   directory *target* whose name is the last component of
   **sourcefile1** (**\`\ basename** **sourcefile1\ \`**). This file is
   a symbolic link that references **sourcefile1**.
-  If **target** does not exist, a file with name *target* is created
   and it is a symbolic link that references **sourcefile1**.
-  If *target* already exists and is not a directory, an error is
   returned.
-  **sourcefile1** and **target** may reside on different file systems.

With more than two arguments: 

-  For each **sourcefile**, a file is created in *target* whose name is
   *sourcefile* or its last component (*\`basename* *sourcefile\`*) and
   is a symbolic link to *sourcefile*.
-  If **target** is not an existing directory, an error is returned.
-  Each **sourcefile** and **target** may reside on different file
   systems.

Examples
~~~~~~~~

The following examples show how symbolic links may be created.

::

      ln -s /usr/src/uts/sys  /usr/include/sys

In this example */usr/include* is an existing directory. But file *sys*
does not exist so it will be created as a symbolic link that refers to
*/usr/src/uts/sys*. The result is that when file */usr/include/sys/x* is
accessed, the file */usr/src/uts/sys/x* will actually be accessed.

This kind of symbolic link may be used when files exist in the directory
*/usr/src/uts/sys* but programs often refer to files in
*/usr/include/sys*. Rather than creating corresponding files in
*/usr/include/sys* that are hard links to files in */usr/src/uts/sys*,
one symbolic link can be used to link the two directories. In this
example */usr/include/sys* becomes a symbolic link that links the former
*/usr/include/sys* directory to the */usr/src/uts/sys* directory.

::

      ln -s  /etc/group  .

In this example the *target* is a directory (the current directory), so
a file called *group* (*\`basename* */etc/group\`*) is created in the
current directory that is a symbolic link to */etc/group*.

::

      ln -s  /fs1/jan/abc  /var/spool/abc

In this example we imagine that */fs1/jan/abc* does not exist at the
time the command is issued. Nevertheless, the file */var/spool/abc* is
created as a symbolic link to */fs1/jan/abc*. Later, */fs1/jan/abc* may
be created as a directory, regular file, or any other file type.

The following example illustrates the use of more than two arguments: 

::

      ln -s  /etc/group  /etc/passwd  .

The user would like to have the *group* and **passwd** files in the
current directory but cannot use hard links because */etc* is a
different file system. When more than two arguments are used, the last
argument must be a directory; here it is the current directory. Two
files, *group* and **passwd**, are created in the current directory,
each a symbolic link to the associated file in */etc*.

Removing symbolic links
-----------------------

Normally, when accessing a symbolic link, one follows the link and
actually accesses the referenced file. However, this is not the case
when one attempts to remove a symbolic link. When the
`rm\ (C) <../man/html.C/rm.C.html>`__ command is executed and the
argument is a symbolic link, it is the symbolic link that is removed;
the referenced file is not touched.

Accessing symbolic links
------------------------

Suppose **abc** is a symbolic link to file **def**. When a user accesses
the symbolic link **abc**, it is the file permissions (ownership and
access) of file **def** that are actually used; the permissions of
**abc** are always ignored. If file **def** is not accessible (that is,
either it does not exist or it exists but is not accessible to the user
because of access permissions) and a user tries to access the symbolic
link **abc**, the error message will refer to **abc**, not file **def**.

Copying symbolic links
----------------------

This section describes the behavior of the 
`cp\ (C) <../man/html.C/cp.C.html>`__ command when one or more arguments
are symbolic links. With the `cp\ (C) <../man/html.C/cp.C.html>`__
command, if any argument is a symbolic link, that link is followed.
Suppose the command line is

::

      cp sym file3

where *sym* is a symbolic link that references a regular file *test1*
and *file3* is a regular file. After execution of the command, *file3*
gets overwritten with the contents of the file *test1*.

If the last argument is a symbolic link that references a directory,
then files are copied to that directory. Suppose the command line is

::

      cp file1 sym symd

where *file1* is a regular file, *sym* is a symbolic link that
references a regular file *test1*, and *symd* is a symbolic link that
references a directory *DIR*. After execution of the command, there will
be two new files, *DIR/file1* and *DIR/sym* that have the same contents
as *file1* and *test1*.

Linking symbolic links
----------------------

This section describes the behavior of the 
`ln\ (C) <../man/html.C/ln.C.html>`__ command when one or more arguments
are symbolic links. To understand the difference in behavior between
this and the `cp\ (C) <../man/html.C/cp.C.html>`__ command, it is useful
to think of a copy operation as dealing with the contents of a file
while the link operation deals with the name of a file.

Let us look at the case where the source argument to **ln** is a
symbolic link. If the **-s** option is specified to **ln**, the command
calls the **symlink** system call (see
`symlink\ (S) <../man/html.S/symlink.S.html>`__). **symlink** does not
follow the symbolic link specified by the source argument and creates a
symbolic link to it. If **-s** is not specified, **ln** invokes the
`link\ (S) <../man/html.S/link.S.html>`__ system call. **link** follows
the symbolic link specified by the source argument and creates a hard
link to the file referenced by the symbolic link.

For the target argument, **ln** invokes a **stat** system call (see
`stat\ (S) <../man/html.S/stat.S.html>`__). If **stat** indicates that
the target argument is a directory, the files are linked in that
directory. Otherwise, if the target argument is an existing file, it is
overwritten. This means that if the second argument is a symbolic link
to a directory, it is followed, but if it is a symbolic link to a
regular file, the symbolic link is overwritten.

For example, if the command line is

::

      ln sym file1

where *sym* is a symbolic link that references a regular file *foo*, and
*file1* is a regular file, *file1* is overwritten and hard-linked to
*foo*. Thus a hard link to a regular file has been created.

If the command is

::

      ln -s sym file1

where the files are the same as in first example, *file1* is overwritten
and becomes a symbolic link to *sym*.

If the command is

::

      ln file1 sym

where the files are the same as in the first example, *sym* is
overwritten and hard-linked to *file1*.

When the last argument is a directory as in

::

      ln file1 sym symd

where *symd* is a symbolic link to a directory *DIR*, and *file1* and
*sym* are the same as in the first example, the file *DIR/file1* is
hard-linked to *file1* and *DIR/sym* is hard-linked to *foo*.

Moving symbolic links
---------------------

This section describes the behavior of the 
`mv\ (C) <../man/html.C/mv.C.html>`__ command. Like the
`ln\ (C) <../man/html.C/ln.C.html>`__ command,
`mv\ (C) <../man/html.C/mv.C.html>`__ deals with file names rather than
file contents. With two arguments, a user invokes the
`mv\ (C) <../man/html.C/mv.C.html>`__ command to rename a file.
Therefore, one would not want to follow the first argument if it is a
symbolic link because it is the name of the file that is to be changed
rather than the file contents. Suppose that *sym* is a symbolic link to
*/etc/passwd* and *abc* is a regular file. If the command

::

      mv sym abc

is executed, the file *sym* is renamed *abc* and is still a symbolic
link to */etc/passwd*. If *abc* existed (as a regular file or a symbolic
link to a regular file) before the command was executed, it is
overwritten.

Suppose the command is

::

      mv sym1 file1 symd

where *sym1* is a symbolic link to a regular file *foo*, *file1* is a
regular file, and *symd* is a symbolic link that references a directory
*DIR*. When the command is executed, the files *sym1* and *file1* are
moved from the current directory to the *DIR* directory so that there
are two new files, *DIR/sym1*, which is still a symbolic link to *foo*,
and *DIR/file1*.

In SCO OpenServer, the `mv\ (C) <../man/html.C/mv.C.html>`__ command
uses the `rename\ (S) <../man/html.S/rename.S.html>`__ system call. If
the first argument to `rename\ (S) <../man/html.S/rename.S.html>`__ is a
symbolic link, `rename\ (S) <../man/html.S/rename.S.html>`__ does not
follow it; instead it renames the symbolic link itself. In System V
prior to Release 4, a file was moved using the
`link\ (S) <../man/html.S/link.S.html>`__ system call followed by the
`unlink\ (S) <../man/html.S/unlink.S.html>`__ system call. Since
`link\ (S) <../man/html.S/link.S.html>`__ and
`unlink\ (S) <../man/html.S/unlink.S.html>`__ do not follow symbolic
links, the result of those two operations is the same as the result of a
call to `rename\ (S) <../man/html.S/rename.S.html>`__.

File ownership and permissions
------------------------------

The system calls **chmod**, **chown** and **chgrp** are used to change
the mode and ownership of a file. If the argument to **chmod**,
**chown** or **chgrp** is a symbolic link, the mode and ownership of the
referenced file rather than of the symbolic link itself will be changed
(see `\``Symbolic links'' <DFM_SymicLinks.html>`__). In such cases, the
link is followed.

Once a symbolic link has been created, its permissions cannot be
changed. By default, the `chown\ (C) <../man/html.C/chown.C.html>`__ and
`chgrp\ (C) <../man/html.C/chgrp.C.html>`__ commands change the owner
and group of the referenced file. However, a new **-h** option enables
the user to change the owner and group of the symbolic link itself. This
is useful for removing files from sticky directories.

--------------

/Using symbolic links with NFS
==============================

When using symbolic links in an NFS environment, it is important to
understand how pathnames are evaluated. The rule by which evaluations
are performed is simple. Symbolic links that a client encounters on the
server are interpreted in accordance with the client's view of the file
tree.

Users on a server system must keep this rule in mind when they create
symbolic links in order to avoid problems. The examples that follow
illustrate situations in which failure to consider the client's view of
the file tree can lead to problems.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/slnknfs1.gif

**Symbolic links with NFS: example 1**

In the example shown in `\``Symbolic links with NFS: example
1'' <_Using_Symbolic_Links_with_NFS.html#dfm_d8>`__, the server
advertises its */xenv* file system as XENV. If the server creates the
symbolic link */xenv/include/sys* as an absolute pathname to
*/xenv/src/uts/sys*, evaluation of the link will work as intended as
long as a client mounts XENV as */xenv*. Another way of saying this is
that if the file tree naming conventions are the same on the client and
the server, things will work as intended. However, if the client mounts
XENV as */mnt/xenv*, when the symbolic link */xenv/src/uts/sys* is
evaluated, the evaluation will be done with respect to the client's view
of the file tree and will not cross the mount point back to the server
but will remain on the client. Thus the client will not access the file
intended. In this situation the server should create the symbolic link
as a relative pathname, *../src/uts/sys*, so that evaluation will
produce the desired results regardless of where the client mounts XENV.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/slnknfs2.gif

**Symbolic links with NFS: example 2**

`\``Symbolic links with NFS: example
2'' <_Using_Symbolic_Links_with_NFS.html#dfm_d9>`__ shows another
potential problem situation in which the server advertises its */xenv*
file system as XENV. But in this case the server has a symbolic link
from */xenv/src/uts/sys/new.h* to */foo/xenv/src/uts/sys/new.h*. Because
the referenced file, */foo/xenv/src/uts/sys/new.h*, is outside of the
advertised resource, users on the server can access this file but users
on the client cannot. In this example, it would make no difference if
the symbolic link was a relative rather than an absolute pathname,
because the directory */foo* on the server is not part of the client's
name space. When the system evaluates the symbolic link, it will look
for the file on the client and will not follow the link as intended.

--------------



/Archiving commands
===================

The `cpio\ (C) <../man/html.C/cpio.C.html>`__ command copies file
archives usually to or from a storage medium such as tape, disk, or
diskette. By default, **cpio** does not follow symbolic links, unless
the **-L** option used with the **-o** and **-p** options to indicates
that symbolic links should be followed. Note that this option is *not*
valid with the **-i** option.

Normally, a user invokes the `find\ (C) <../man/html.C/find.C.html>`__
command to produce a list of filenames and pipes this into the
`cpio\ (C) <../man/html.C/cpio.C.html>`__ command to create an archive
of the files listed. The `find\ (C) <../man/html.C/find.C.html>`__
command also has a new option **-follow** to indicate that symbolic
links should be followed. If a user invokes
`find\ (C) <../man/html.C/find.C.html>`__ with the **-follow** option,
then `cpio\ (C) <../man/html.C/cpio.C.html>`__ must also be invoked with
its new option **-L** to indicate that it too should follow symbolic
links.

When evaluating the output from 
`find\ (C) <../man/html.C/find.C.html>`__, following or not following
symbolic links only makes a difference when a symbolic link to a
directory is encountered. For example, if */usr/jan/symd* is a symbolic
link to the directory *../joe/test* and files *test1* and *test2* are in
directory */usr/joe/test*, the output of a **find** starting from
*/usr/jan* includes the file */usr/jan/symd* if symbolic links are not
followed, but includes */usr/jan/symd/test1* and */usr/jan/symd/test2*
as well as */usr/jan/symd* if symbolic links are followed.

If the user wants to preserve the structure of the directories being
archived, it is recommended that symbolic links not be followed on both
commands. (This is the default.) When this is done symbolic links will
be preserved and the directory hierarchy will be duplicated as it was.
If the user is more concerned that the contents of the files be saved,
then the user should use the **-L** option to
`cpio\ (C) <../man/html.C/cpio.C.html>`__ and the **-follow** option to
`find\ (C) <../man/html.C/find.C.html>`__ to follow symbolic links.

--------------

**CAUTION:** The user should take care not to mix modes, that is, the
user should either follow or not follow symbolic links for both
`cpio\ (C) <../man/html.C/cpio.C.html>`__ and
`find\ (C) <../man/html.C/find.C.html>`__. If modes are mixed, an
archive will be created but the resulting hierarchy created by **cpio
-i** may exhibit unexpected and undesirable results.

--------------

The **-i** option to `cpio\ (C) <../man/html.C/cpio.C.html>`__ copies
symbolic links as is. So if a user creates an archive to be read in on a
pre-System V Release 4 system, it may be more useful to follow symbolic
links because System V prior to Release 4 lacked symbolic links and the
result of copying in a symbolic link will be a regular file containing
the pathname of the referenced file.

--------------

/Summary of UNIX system files & directories
===========================================

UNIX system files are organized in a hierarchy; their structure is often
described as an inverted tree. At the top of this tree is the root
directory, the source of the entire file system. It is designated by a
*/* (slash). All other directories and files descend and branch out from
root, as shown in the following figure: 

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/treeroot.gif

**Directory tree from root**

The following section provides brief descriptions of the root directory
and the system directories under it, as shown in an earlier figure.

--------------




/UNIX system directories
========================

*/*
   the source of the file system (called the root directory)
*/stand*
   contains programs and data files used in the booting process
*/sbin*
   contains essential executables used in the booting process and in
   manual system recovery
*/dev*
   contains special files that represent peripheral devices, such as: 

   ========= ================
   *console* console
   *lp*      line printer
   *term/\** user terminal(s)
   *dsk/\**  disks
   ========= ================
*/dev/fd*
   contains files accessible through file descriptors
*/etc*
   contains machine-specific administrative configuration files and
   system administration databases
*/home*
   the root of a subtree for user directories
*/tmp*
   contains temporary files, such as the buffers created for editing a
   file
*/var*
   the root of a subtree for varying files such as log files
*/usr*
   contains other directories, including *lib* and *bin*
*/usr/bin*
   contains many executable programs and utilities, including the
   following: 

   ::

         cat
         date
         login
         grep
         mkdir
         who

*/usr/lib*
   contains libraries for programs and languages
*/proc*
   contains files which provide access to the image of each active
   process in the system

--------------


/File access controls
=====================

|  When the **ls -l** command displays the contents of a directory, the
  first column of output describes the \``mode'' of the file. This
  information tells you not only what type of file it is, but who has
  permission to access it. This first field is 10 characters long. The
  first character defines the file type and can be one of the following
  types: 
| 

**File types**

========================= =========
Type                      Symbol
========================= =========
Text, programs, etc.      **``-``**
Directories               **``d``**
Character special         **``c``**
Block special             **``b``**
FIFO (named pipe) special **``p``**
Symbolic links            **``l``**
========================= =========

Using this key to interpret the previous screen, you can see that the
*starship* directory contains three directories and two regular disk
files.

The next several characters, which are either letters or hyphens,
identify who has permission to read and use the file or directory.
(Permissions are discussed in `\``File
permissions'' <DFM_FlPermissions.html>`__)

The following number is the link count. For a file, this equals the
number of users linked to that file. For a directory, this number shows
the number of directories immediately under it plus two (for the
directory itself and its parent directory).

Next, the login name of the file's owner appears (here it is
*starship*), followed by the group name of the file or directory
(*project*).

The following number shows the length of the file or directory entry
measured in units of information (or memory) called bytes. The month,
day, and time that the file was last modified is given next. Finally,
the last column shows the name of the directory or file.

`\``Description of output produced by the ls -l
command'' <_File_Access_Controls.html#dfm_dE>`__ identifies each column
in the rows of output from the **ls -l** command.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/ls_out.gif

**Description of output produced by the ls -l command**

--------------

/File protection
================

Because the UNIX operating system is a multi-user system, you usually do
not work alone in the file system. System users can follow pathnames to
various directories and read and use files belonging to one another, as
long as they have permission to do so.

If you own a file, you can decide who has the right to read it, write in
it (make changes to it), or, if it is a program, to execute it. You can
also restrict permissions for directories. When you grant execute
permission for a directory, you allow the specified users to change
directory to it and list its contents with the **ls** command (see
`ls\ (C) <../man/html.C/ls.C.html>`__). Only the owner or a privileged
user can define the following: 

-  which users have permission to access data
-  which types of permission they have (that is, how they are allowed to
   use the data)

This section introduces access-permissions for files and discusses file
protection.

--------------


/File permissions
=================

SCO OpenServer defines access-control and privilege mechanisms to allow
for extended-security-controls that implement security policies
different from those in SCO OpenServer, but which avoid altering or
overriding the defined semantics of any functions in SCO OpenServer.
Although quite simple, the access-control scheme has some unusual
features. Each SCO OpenServer user has a unique user-identification
(user-id) number, as well as a shared group-identification (group-id)
number. A file is tagged with the user-id and group-id of its owner, and
a set of access-permission-bits when created by **open**, **creat**,
**mkdir**, **mknod** and **mkfifo** (see
`open\ (S) <../man/html.S/open.S.html>`__,
`creat\ (S) <../man/html.S/creat.S.html>`__,
`mkdir\ (S) <../man/html.S/mkdir.S.html>`__,
`mknod\ (S) <../man/html.S/mknod.S.html>`__ and
`mkfifo\ (S) <../man/html.S/mkfifo.S.html>`__). SCO OpenServer
file-access-control uses the access-permission-bits to specify
independent read, write and execute permissions for the \``owner'' of
the file, for any members of the owner's \``group'' and for any
\``other'' users. For directories, execute permission means \``search''
permission. These access-permission-bits are changed by **chmod**, and
are read by **stat** and **fstat** (see
`chmod\ (S) <../man/html.S/chmod.S.html>`__,
`stat\ (S) <../man/html.S/stat.S.html>`__ and **fstat** on the
`stat\ (S) <../man/html.S/stat.S.html>`__ manual page).

When a process requests file-access-permission for read, write or
execute/search, access is determined as follows: 

#. If the effective-user-id of the process is a user with appropriate
   access-permissions (such as a privileged user).

   #. If read, write or directory search permission is requested, access
      is granted.
   #. If execute permission is requested, access is granted if execute
      permission is granted to at least one user by the
      file-permission-bits or by an alternate-access-control mechanism;
      otherwise, access is denied.

#. Otherwise: 

   #. The read, write and execute/search access-permissions on a file
      are granted to a process if one or more of the following are true
      (see `chmod\ (S) <../man/html.S/chmod.S.html>`__): 

      -  The appropriate access-permission-bit of the \``owner'' portion
         of the file-mode is set and the effective-user-id of the
         process matches the user-id of the owner of the file
      -  The appropriate access-permission-bit of the \``group'' portion
         of the file-mode is set, the effective-group-id of the process
         matches the group-id of the file and the effective-user-id of
         the process fails to match the user-id of the owner of the
         file.
      -  The appropriate access-permission-bit of the \``other'' portion
         of the file-mode is set, the effective-group-id of the process
         fails to match the group-id of the file and the
         effective-user-id of the process fails to match the user-id of
         the owner of the file.

      Otherwise, the corresponding access-permissions on a file are
      denied to the process.

   #. Access is granted if an alternate-access-control mechanism is not
      enabled and the requested access-permission-bit is set for the
      class to which the process belongs, or if an
      alternate-access-control mechanism is enabled and it allows the
      requested access; otherwise, access is denied.

Implementations may provide additional-file-access-control or
alternate-file-access-control mechanisms, or both. An
additional-access-control mechanism only further restricts the
file-access-permissions defined by the file-permission-bits. An
alternate-access-control mechanism shall: 

#. specify file-permission-bits for the file-owner-class,
   file-group-class and file-other-class of the file, corresponding to
   the access-permissions, that **stat** and **fstat** return.
#. Be enabled only by explicit user action, on a per-file basis by the
   file-owner or a user with the appropriate-privilege.
#. Be disabled for a file after the file-permission-bits are changed for
   that file with **chmod**. The disabling of the alternate mechanism
   need not disable any additional mechanisms defined by an
   implementation.

SCO OpenServer recognizes one particular user-id, the \``super-user'',
as exempt from the usual constraints on file access; thus, for example,
programs may be written to dump and reload the file system without
unwanted interference from the protection system. A process is
recognized as a super-user process and is granted special privileges if
its effective-user-id is **0**.

--------------


/Setting default permissions
============================

When a file is created its default permissions are set. These default
settings may be changed by placing an appropriate **umask** command in
the system profile (*/etc/profile*).

**umask settings for different security levels**

================= ======== ===================================
Level of security umask    Disallows
================= ======== ===================================
Permissive        ``0002`` **w** for others
Moderate          ``0027`` **w** for group, **rwx** for others
Severe            ``0077`` **rwx** for group and others
================= ======== ===================================

--------------


/How to determine existing permissions
======================================

You can determine what permissions are currently in effect on a file or
a directory by using **ls -l** to produce a long listing of a
directory's contents.

| In the first field of the **ls -l** output, the next nine characters
  are interpreted as three sets of three bits each. The first set refers
  to the owner's permissions; the next to permissions of members in the
  file's group; and the last to all others. Within each set, the three
  characters show permission to read, to write, and to execute the file
  as a program, respectively. For a directory, \``execute'' permission
  is interpreted to mean permission to search the directory for a
  specified file. For example, typing **ls -l** while in the directory
  named *starship/bin* in the sample file system produces the following
  output: 
| $ ls -l
| total 35
| -rwxr-xr-x 1 starship project 9346 Nov 1 08:06 display
| -rw-r--r-- 1 starship project 6428 Dec 2 10:24 list
| drwx--x--x 2 starship project 32 Nov 8 15:32 tools
| $

| Permissions for the *display* and *list* files and the *tools*
  directory are shown on the left of the screen under the line
  ``total 35``, and appear in this format: 
| **-rwxr-xr-x** (for the *display* file)
| **-rw-r--r--** (for the *list* file))
| **drwx--x--x** (for the *tools* directory)

After the initial character, which describes the file type (for example,
a ``-`` (dash) symbolizes a regular file and a ``d`` a directory), the
other nine characters that set the permissions comprise three sets of
three characters. The first set refers to permissions for the ``owner``,
the second set to permissions for ``group`` members, and the last set to
permissions for all ``other`` system users. Within each set of
characters, the ``r``, ``w`` and ``x`` show the permissions currently
granted to each category. If a dash appears instead of an ``r``, ``w``
or ``x`` permission to read, write or execute is denied.

The following diagram summarizes this breakdown for the file named
*display*.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/perms.gif

As you can see, the owner has ``r``, ``w``, and ``x`` permissions and
members of the group and other system users have ``r`` and ``x``
permissions.

There are two exceptions to this notation system. Occasionally the
letter ``s`` or the letter ``l`` may appear in the permissions line,
instead of an ``r``, ``w`` or ``x``. The letter ``s`` (short for set
user ID or set group ID) represents a special type of permission to
execute a file. It appears where you normally see an ``x`` (or ``-``)
for the user or group (the first and second sets of permissions). From a
user's point of view it is equivalent to an ``x`` in the same position;
it implies that execute permission exists. It is significant only for
programmers and system administrators. (See `\``Setting and changing
user and group IDs (UID/GID)'' <../UG_admin/uaT.chguid.html>`__ for
details about setting the user or group ID.) The letter ``l`` indicates
that locking will occur when the file is accessed. It does not mean that
the file has been locked. The permissions are as follows: 

**File access permissions**

+--------+------------------------------------------------------------+
| Symbol | Explanation                                                |
+========+============================================================+
| ``r``  | The file is readable.                                      |
+--------+------------------------------------------------------------+
| ``w``  | The file is writable.                                      |
+--------+------------------------------------------------------------+
| ``x``  | The file is executable.                                    |
+--------+------------------------------------------------------------+
| **-**  | This permission is *not* granted.                          |
+--------+------------------------------------------------------------+
| ``l``  | Mandatory locking will occur during access. (The           |
|        | set-group-ID bit is on and the \``group'' execution bit is |
|        | off.)                                                      |
+--------+------------------------------------------------------------+
| ``s``  | The ``s``\ et-user-ID or ``s``\ et-group-ID bit is on, and |
|        | the corresponding \``user'' or \``group'' execution bit is |
|        | also on.                                                   |
+--------+------------------------------------------------------------+
| ``S``  | The set-user-ID bit is on and the \``user'' execution bit  |
|        | is off.                                                    |
+--------+------------------------------------------------------------+
| ``t``  | The sticky and the execution bits for \``other'' are on.   |
+--------+------------------------------------------------------------+
| ``T``  | The sticky bit is turned on, and the execution bit for     |
|        | \``other'' is off.                                         |
+--------+------------------------------------------------------------+

**Directory access permissions**

+--------+------------------------------------------------------------+
| Symbol | Explanation                                                |
+========+============================================================+
| ``r``  | The directory is readable.                                 |
+--------+------------------------------------------------------------+
| ``w``  | The directory may be altered (files may be added or        |
|        | removed).                                                  |
+--------+------------------------------------------------------------+
| ``x``  | The directory may be searched. (This permission is         |
|        | required to **cd** to the directory.)                      |
+--------+------------------------------------------------------------+
| ``t``  | File removal from a writable directory is limited to the   |
|        | owner of the directory or file unless the file is          |
|        | writable.                                                  |
+--------+------------------------------------------------------------+

--------------




/How to change existing permissions
===================================

After you have determined what permissions are in effect, you can change
them by calling the **chmod** command in the following format: 

::

      chmod who+permission file(s)

or

::

      chmod who-permission file(s)

The following list defines each component of this command line.

+-----------------------------------+-----------------------------------+
| **chmod**                         | name of the program               |
+===================================+===================================+
| **who**                           | one of three user groups:         |
|                                   | **u**\ ser                        |
|                                   | **g**\ roup                       |
|                                   | **o**\ hers                       |
+-----------------------------------+-----------------------------------+
| **+** or **-**                    | instruction that grants (**+**)   |
|                                   | or denies (**-**) permission      |
+-----------------------------------+-----------------------------------+
| **permission**                    | any combination of three          |
|                                   | authorizations:                   |
|                                   | **r**\ ead                        |
|                                   | **w**\ rite                       |
|                                   | e\ **x**\ ecute                   |
+-----------------------------------+-----------------------------------+
| **file(s)**                       | file (or directory) name(s)       |
|                                   | listed; assumed to be branches    |
|                                   | from your current directory,      |
|                                   | unless you use full pathnames     |
+-----------------------------------+-----------------------------------+

--------------

**NOTE:** The **chmod** command will not work if you type a space(s)
between **who**, the instruction that gives (**+**) or denies (**-**)
permission, and the **permission**.

--------------

The following examples show a few possible ways to use the **chmod**
command. As the owner of *display*, you can read, write, and run this
executable file. You can protect the file against being accidentally
changed by denying yourself write (**w**) permission. To do this, type
the command line: 

::

      chmod u-w display

| After receiving the prompt, type **ls -l** and press the <Return> key
  to verify that this permission has been changed, as shown in the
  following screen.
| $ chmod u-w display
| $ ls -l
| total 35
| -r-xr-xr-x 1 starship project 9346 Nov 1 08:06 display
| rw-r--r-- 1 starship project 6428 Dec 2 10:24 list
| drwx--x--x 2 starship project 32 Nov 8 15:32 tools
| $

As you can see, you no longer have permission to write changes into the
file. You will not be able to change this file until you restore write
permission for yourself.

Now consider another example. Notice that permission to write into the
file *display* has been denied to members of your group and other system
users. However, they do have read permission. This means they can copy
the file into their own directories and then make changes to it. To
prevent all system users from copying this file, you can deny them read
permission by typing: 

::

      chmod go-r display

| The **g** and **o** stand for group members and all other system
  users, respectively, and the **-r** denies them permission to read or
  copy the file. Check the results with the **ls -l** command.
| $ chmod go-r display
| $ ls -l
| total 35
| -rwx--x--x 1 starship project 9346 Nov 1 08:06 display
| rw-r--r-- 1 starship project 6428 Dec 2 10:24 list
| drwx--x--x 2 starship project 32 Nov 8 15:32 tools
| $

For more information, refer to `ls\ (C) <../man/html.C/ls.C.html>`__ and
`chmod\ (C) <../man/html.C/chmod.C.html>`__.

--------------

/A note on permissions and directories
======================================

You can use the **chmod** command to grant or deny permission for
directories as well as files. Simply specify a directory name instead of
a file name on the command line.

However, consider the impact on various system users of changing
permissions for directories. For example, suppose you grant read
permission for a directory to yourself (**u**), members of your group
(**g**), and other system users (**o**). Every user who has access to
the system will be able to read the names of the files contained in that
directory by running the **ls -l** command. Similarly, granting write
permission allows the designated users to create new files in the
directory and remove existing ones. Granting permission to execute the
directory allows designated users to move to that directory (and make it
their current directory) by using the **cd** command.

--------------


/An alternative method
======================

There are two methods by which the **chmod** command can be executed.
The method described above, in which symbols such as **r**, **w** and
**x** are used to specify permissions, is called the symbolic method.

An alternative method is the octal method. Its format requires you to
specify permissions using three octal numbers, ranging from 0 to 7. (The
octal number system is different from the decimal system that we
typically use on a day-to-day basis.) To learn how to use the octal
method, see the `chmod\ (C) <../man/html.C/chmod.C.html>`__ manual page.

--------------


/Security considerations
========================

This section gives the software developer information on various
security features and their impact on writing applications. While many
of the security features, like Mandatory Access Control, are available
only if the Enhanced Security Utilities are installed and running, it is
to your advantage to program your application so that it will run on SCO
OpenServer with and without the Enhanced Security Utilities installed.
This way, you can avoid programming the same application for each
environment.

--------------


/What security means to programmers
===================================

As a programmer on SCO OpenServer, you need a general understanding of
how security affects you and protects your files on the computer system.
You also need to understand the difference between basic security and
enhanced security. Finally, you need to understand the term Trusted
Computing Base (TCB), an all-encompassing term which describes the
mechanisms used to enforce Enhanced Security.

--------------


/What is security?
==================

Security for a computing system means that the information on the system
is protected from unauthorized disclosure or modification. If each user
had a personal non-networked computing system that was kept locked up,
each user's files would be secure. But isolation and physical security
are not practical in most circumstances.

On a computer system that many people share, the simplest security
mechanism would be to allow only the owner of a file to access that
file. That would be inconvenient, however, since one of the benefits of
a computer system is the sharing of resources. For example, it would be
wasteful for each user to have a private copy of each command. Commands
are usually shared, but users often want to restrict access to the
contents of data files.

On a secure system, each user has a unique identity and a level of
authorization associated with that identity. For security to work, the
computer system must have some way of identifying users, their level of
authorization, and their files. For the most part, while you are logged
in, all data you enter, create, and process belongs to you. Data is
stored in named files on the computer system. Each file you own is kept
separate from the rest of your files and from the files belonging to
other users.

As a programmer, you are also concerned with the impact of security on
users who run your programs.

A secure computer system must have a mechanism that makes access
decisions, that is, one that decides who can access what, based upon
user identity and authorization.

There are many ways in which the security of a computer system can be
violated. Unauthorized access to read or write files can be the result
of: 

-  the abuse of privileges by administrators
-  malicious programs that gain privileges or access to files
-  idle browsing of files that are inadequately protected

Most computer systems provide some degree of basic security.

--------------

/How basic security works
=========================

An operating system stores and processes information in the form of
electronic data. In doing so, it provides an interface between you, the
user of the computer, and the computer. An operating system provides you
with commands, library routines, functions, and programs that allow you
to tell the computer how to store and process the information that
belongs to you.

A computer system enforces basic security by making access decisions,
that is, by deciding who can access what. In order to make access
decisions, a computer system uniquely identifies each user on the system
and stores information in named files, each of which belongs to a single
user on the system. It would be a potential violation of security if
users could access any files at will.

SCO OpenServer supplies basic security through the use of the **login**
and **passwd** (password) mechanisms, which identify you to the system
and put you in control of your data. Also included in basic security are
**access mode bits,** which give users some control over what other
users can access their files. It is not a violation of basic security
for users to have the ability to share individual files with specific
other users.

--------------

/Privileges
===========

Privilege, in the simplest terms, is the ability to override system
restrictions on the actions of users. All operating systems allow users
to exercise special privilege, under certain conditions, to perform
sensitive system operations. Sensitive system operations are those which
affect the configuration of the system or its availability to users.

Most users cannot, for example, execute commands affecting the hardware
or software configuration of the system. Activities such as mounting and
checking file systems, adding users, modifying user profiles, adding and
removing peripherals, installing application software, password
administration, and administration of the user terminal lines, are
restricted to certain users.

In UNIX System V Release 4.0 and previous releases, the restriction of
privilege is implemented by designating a special user identifier (UID)
of **0**; the login name historically associated with this UID is
*root*.

When a person logs in as *root*, that person has unrestricted access to
every file on the system, and the ability to alter system operation.
Commands that execute sensitive system operations check to see whether
the effective UID of the process requesting the operation is **0**. If
it is, the user process is given unlimited access to the system.

The **root** login in UNIX System V Release 4.0 and previous releases
possesses, in effect, the one privilege necessary to override all system
restrictions on command execution and access: the superuser privilege.

In releases after 4.0, this privilege mechanism is supplemented with a
more flexible mechanism to suit the needs of the user community. Now,
rather than investing the power to issue any command on the system to
one user, you can give partial super-user power to several users. By
assigning privileges linked to specific tasks, you essentially assign a
role to each such user.

This privilege mechanism is actually a combination of the old UID
functionality supported in the UNIX operating system for over 20 years,
and new, discrete privilege functionality.

The most important advantage of this privilege mechanism over the pure
UID-based privilege mechanism is the fine granularity with which it can
apportion system privileges to executing processes. For example, you
might assign someone to the role of mail administrator. That person
would have all the privileges necessary to oversee maintenance and
troubleshooting of the mail subsystem, but no others; he or she would
not be able to add and delete user accounts, reorganize file systems, or
do any other administrative work unrelated to electronic mail.

The superuser privilege can be replaced by a list of discrete privileges
based on the categorization of sensitive system operations into groups
of operations exercising the same kind of privilege. In other words,
many different commands might need to override discretionary read access
restrictions on files to perform their functions; defining a privilege
such as **P_DACREAD**, and designating it as one of the possible
privileges a command can have allows for a more controlled propagation
of privileges by processes than the superuser privilege.

This means that there are two ways to acquire privilege with the
superuser module (SUM) provided in SCO OpenServer: first, when the
effective UID of a new process is equal to the tunable parameter
**PRIVID**, and also, when an executable with fixed privileges is
executed. With **PRIVID** set equal to **0**, this behavior preserves
the omnipotence of a process with effective **uid 0**. The system is
delivered with **PRIVID** equal to **0**.

It is important to recognize that the list of system privileges, and
fixed privileges on files, are all part of the basic privilege mechanism
provided by the operating system.

--------------

/Privileges associated with a file
==================================

For every executable file there may be a set of privileges that are
acquired when that program is executed via an **exec** system call. This
set of privileges is known as fixed privileges: they are always given to
the new program, independent of the privileges of the parent or
calling-process. Each executable file can have two sets of privileges
associated with it that are propagated when that program is executed via
an **exec** system call: 

-  Fixed privileges are always given to the new program, independent of
   the calling or parent process's privileges.
-  Inheritable privileges will exist in the new program only if they
   existed in the previous program. Inheritable privileges are given to
   the new program only if they exist in the calling process's privilege
   set; inheritable privileges are only used by the LPM privilege
   module, not by the SUM privilege module (see
   `\``Privileges'' <DFM_Privs.html>`__).

These sets are disjoint, that is, a privilege can not be defined as both
fixed and inheritable for the same file. If an executable file does not
require any privileges then this set is empty.

--------------

**CAUTION:** Privileges associated with a file are removed when the
validity information for the file changes (for example, when the file is
opened for writing or when the modes of the file change). This removes
the file from the Trusted Computing Base; the privileges must be set
again in order for the command to run with privilege.

--------------

--------------


/Manipulating file privileges
=============================

Use the **filepriv** system call to set, retrieve, or count the
privileges associated with a file (see **filepriv**\ (S)). An
administrative command also provides these same basic functions (see
**filepriv**\ (ADM)).

The **filepriv** system call has three command types: 

-  **PUTPRV** sets the privileges associated with a file. This is an
   absolute setting; the specified privileges replace any previously
   existing privileges for the file.
-  **GETPRV** retrieves the privileges associated with a file.
-  **CNTPRV** returns the number of privileges associated with a file.

*privilege*\ (5) lists the names of the privileges as well as some other
important items. *priv*\ (5) lists some functions used to easily
indicate to **filepriv** the particular privilege set to which a
privilege belongs.

Some of the above command types require a list of privileges or return
such a list. **PUTPRV** requires an array of privilege descriptors that
lists the privileges to be set. A privilege descriptor is an integral
data type that is assigned a value defining the privilege and the set it
is in. Functions have been defined to make this task simplier. Use
**pm_inher** to indicate an inheritable privilege. For example,
**pm_fixed(P_DACREAD)** would indicate the **P_DACREAD** privilege in
the fixed set. Similarly **pm_inher(P_MACREAD)** would indicate the
**P_MACREAD** privilege in the inheritable set.

`\``Setting file
privileges'' <_Manipulating_File_Privileges.html#dfm_p1>`__ shows a code
fragment that sets file privileges. Some of the privilege sets indicated
in this example may or may not exist or be valid for your particular
system.

::

   #include <priv.h>

   priv_t privd[3];
   /*
    * Set P_DACREAD and P_DACWRITE as inheritable and
    * P_SETUID as fixed for file /sbin/testprog.
    * This process must have P_SETFPRIV, P_DACREAD, P_DACWRITE, and
    * P_SETUID in its maximum set.
    */
   privd[0] = pm_inher(P_DACREAD);
   privd[1] = pm_inher(P_DACWRITE);
   privd[2] = pm_fixed(P_SETUID);
   if (filepriv("/sbin/testprog", PUTPRV, privd, 3) == -1) {
       /* Some error occurred, display the error and exit. */
       perror("filepriv PUTPRV error");
       exit(1);
   }

**Setting file privileges**

In this example, privileges are being set for the executable file
**/sbin/testprog**. The privileges **P_DACREAD** and **P_DACWRITE** are
made inheritable, while **P_SETUID** is made fixed. **pm_inher** and
**pm_fixed** are used to assign values to the privilege descriptors; the
**pm_inher** function marks **P_DACREAD** and **P_DACWRITE** as
inheritable while **pm_fixed** marks **P_SETUID** as fixed. The call to
**filepriv** using **PUTPRV** will set the indicated privileges for the
file. If an error occurred, **perror** is called to display an error
message (see `perror\ (S) <../man/html.S/perror.S.html>`__) and the
program terminates.

--------------

**NOTE:** A privilege that is being set for a file must exist in the
maximum set of the process making the **filepriv** system call.

--------------

--------------

**NOTE:** Since the **PUTPRV** command for **filepriv** is a privileged
operation, a process using this system call must have the appropriate
privilege in its working set. See **intro**\ (S) for a list of
privileges.

--------------

Use the **GETPRV** command for the **filepriv** system call to determine
the privileges associated with a file. This command also requires a
pointer to an array of privilege descriptors. You must ensure that the
array is large enough to contain all the privileges associated with the
file.

`\``Retrieving file
privileges'' <_Manipulating_File_Privileges.html#dfm_p2>`__ shows a code
fragment that will retrieve the privileges associated with a file.

::

   #include <priv.h>

   priv_t *privp;
   int cnt;
   /*
    * Determine the number of privileges for /sbin/testprog.
    */
   if ((cnt = filepriv("/sbin/testprog", CNTPRV, (priv_t *)0, 0)) == -1) {
       /* filepriv failed; display error and exit. */
       perror("filepriv CNTPRV error");
       exit(1);
   }
   if (cnt > 0) {
       /*
        * malloc some memory and get the privileges.
        */
       if ((privp = (priv_t *)malloc(cnt * sizeof(priv_t)) == NULL) {
           exit(1);   /* Couldn't malloc so exit. */
       }
       if (filepriv("/sbin/testprog", GETPRV, privp, cnt) == -1) {
           /* filepriv failed; display error and exit. */
           perror("filepriv GETPRV error");
           exit(1);
       }
   }

**Retrieving file privileges**

In this example, the **CNTPRV** command is used to determine the number
of privileges. This number is then used to determine the amount of
memory to request when calling **malloc** for an array large enough to
contain all the privileges (see
`malloc\ (S) <../man/html.S/malloc.S.html>`__). **filepriv** is then
called with the **GETPRV** command to retrieve the actual privileges.

--------------

/Privileges associated with a process
=====================================

After a **fork**, the privileges of the parent and child processes are
identical. However, when an **exec** system call is performed, the
privileges of the new program are determined from those of the program
performing the **exec** and from the privileges associated with the
executable file.

Each process has three sets of privileges: 

-  The maximum set contains all the privileges granted to the process.
-  The working set contains all the privileges currently being used by
   the process.
-  The saved set contains all privileges acquired by executing files
   with fixed privileges.

How the privileges for a new process are determined is specific to the
privilege (policy) module installed.

--------------

/Manipulating process privileges
================================

Use the **procpriv** system call to add, put, remove, retrieve, or count
privileges associated with the calling process. This system call has
five command types: 

-  **SETPRV** adds the requested privileges to the working set for the
   current process. Privileges already in the working set are not
   affected; they remain in the set. Requested privileges not in the
   current maximum set are ignored.
-  **PUTPRV** sets the working and maximum sets for the current process.
   This is an absolute setting; the specified privileges replace the
   current working and maximum sets. Privileges requested which are not
   in the current maximum set are ignored.
-  **CLRPRV** removes the requested privileges from either the working
   or maximum set. If a privilege is removed from the maximum set, it is
   also removed from the working set if it exists there, since the
   working set is always a subset of the maximum set.
-  **GETPRV** retrieves the working and maximum privilege sets for the
   current process.
-  **CNTPRV** returns the number of privileges associated with the
   current process.

`\``Adding and clearing process
privileges'' <_Manipulating_Process_Privileges.html#dfm_p4>`__ shows a
code fragment that does a **setuid** and uses **procpriv** to set and
clear the appropriate privilege as needed.

::

   #include <priv.h>

   priv_t privd[2];
   int uid;

   privd[0] = pm_work(P_SETUID);
   privd[1] = pm_max(P_SETUID);
   /*
    * Add P_SETUID to the working set of the current process.  P_SETUID
    * must be in the maximum working set to be successful.
    */
   if (procpriv(SETPRV, privd, 1) == -1) {
       /* It failed, so display error and exit. */
       perror("procpriv SETPRV error");
       exit(1);
   }
   /*
    * Change to user id "uid" (previously initialized)
    */
   if (setuid(uid) == -1) {
       /*
        * It failed, perhaps P_SETUID wasn't in our maximum working
        * set.  Display error and exit.
        */
       perror("setuid error");
       exit(1);
   }
   /*
    * We don't need P_SETUID any more so remove it from the working
    * and maximum sets.
    */
   if (procpriv(CLRPRV, privd, 2) == -1) {
       /*
        * It failed, so display error and exit.
        */
       perror("procpriv CLRPRV error");
       exit(1);
   }

**Adding and clearing process privileges**

The first call to **procpriv** sets the **P_SETUID** privilege in the
process's working set. Note that the count of 1 in the system call
indicates that only one (the first) element of the array **privd** is to
be used. Once the privilege is in the working set, **setuid** is called.
Since **P_SETUID** will not be required by the program any more,
**procpriv** is again called, this time with the **CLRPRV** command.

Note in this case that the count of 2 indicates that both elements of
array **privd** are to be used, thus removing the privilege from both
the maximum and working sets. Note that if the privilege had only been
removed from the maximum set, the system would have also removed it from
the working set, since the working set must be a subset of the maximum
set, that is, the working set can not contain privileges which are not
in the maximum set.

Use the **PUTPRV** command for **procpriv** similarly to **SETPRV,** but
remember that the setting is absolute, that is, the indicated privileges
replace both the current working and maximum sets. The privileges you
request must exist in the current maximum set.

`\``Setting process privileges using
PUTPRV'' <_Manipulating_Process_Privileges.html#dfm_p5>`__ shows a code
fragment that uses the **PUTPRV** command to set the maximum and working
sets.

::

   #include <priv.h>

   priv_t privd[2];

   privd[0] = pm_max(P_SETUID);
   /*
    * Set the maximum set to P_SETUID.  The working set is empty since
    * it is not set here.
    */
   if (procpriv(PUTPRV, privd, 1) == -1) {
       /* It failed, so display error and exit. */
       perror("procpriv PUTPRV error");
       exit(1);
   }

**Setting process privileges using PUTPRV**

In this example, the privilege descriptor is set to **P_SETUID** in the
maximum set. If **P_SETUID** is already in the maximum set, **procpriv**
causes the new maximum set to contain only **P_SETUID**. The new working
set will be empty, since no privileges are defined for it.

The **GETPRV** and **CNTPRV** commands work in a manner similar to their
counterparts in the **filepriv** system call. `\``Retrieving process
privileges'' <_Manipulating_Process_Privileges.html#dfm_p6>`__ shows a
code fragment that will retrieve the privileges associated with a
process.

::

   #include <priv.h>

   priv_t *privp;
   int cnt;

   /*
    * Determine the number of privileges for this process.
    */
   if ((cnt = procpriv(CNTPRV, (priv_t *)0, 0)) == -1) {
       /* procpriv failed; display error and exit. */
       perror("procpriv CNTPRV error");
       exit(1);
   }
   if (cnt > 0) {
       /*
        * malloc some memory and get the privileges.
        */
       if ((privp = (priv_t *)malloc(cnt * sizeof(priv_t)) == NULL) {
           /* Couldn't malloc so exit. */
           exit(1);
       }
       if (procpriv(GETPRV, privp, cnt) == -1) {
           /* procpriv failed; display error and exit. */
           perror("procpriv GETPRV error");
           exit(1);
       }
   }

**Retrieving process privileges**

In this example, the number of privileges returned by the **CNTPRV**
command to **procpriv** is used to determine the amount of memory to
request when calling **malloc**. **procpriv** is then called with the
**GETPRV** command to retrieve the actual privileges.

With proper use, the privilege mechanism provides a way to restrict
execution of sensitive system functions and improves the security of the
system. See `\``Guidelines for writing trusted
software'' <_Guidelines_for_Writing_Trusted_.html>`__.

--------------

/8. Signals, job control and pipes
===================================

The SCO OpenServer kernel provides several means by which processes can
communicate with each other. This section provides a detailed discussion
on three of these facilities: signals, pipes, and job control.

Signals are a communications mechanism between processes and the kernel.
They notify a process that a certain event has occurred, and they can be
sent to a process or a group of processes. Based on the type of signal
received, a process might take some necessary action. Included is a
discussion on the types of signals, signal handlers, how signals are
sent, and the signal stack feature.

Job control provides a means of managing processes during a login
session. The discussion here includes an overview of job control, and
STREAMS-based job control.

Also included are discussions of pipes, STREAMS-based pipes and FIFOs.
Pipes are a mechanism which provide a means of passing information from
one running process to another. As of UNIX System V Release 4, pipes and
FIFOs have become STREAMS-based for network applications. For
completeness, a discussion of this subject has also been included.


/Signals
========

A \``signal'' is an asynchronous notification of an event, and is said
to be \``generated for'' (or \``sent to'') a process when the event that
causes the signal first occurs. A signal may be sent to a process by
another process, from the terminal or by the system itself. A signal can
be generated several ways, including: 

-  An error during a system call.
-  Some condition raised at the controlling-terminal of a process (such
   as break or hangup).
-  An explicit system call to **kill**\ (S),
   `sigsend\ (S) <../man/html.S/sigsend.S.html>`__, or
   `raise\ (S) <../man/html.S/raise.S.html>`__.
-  Expiration of the alarm clock timer or the generation of the trap
   signal during process tracing.

Signals are the most frequently used means to notify a process of the
occurrence of some event that may have an impact on that process. In
some circumstances, the same event generates signals for multiple
processes. `sigaction\ (S) <../man/html.S/sigaction.S.html>`__). All
signals have the same \``priority''. If multiple signals are pending
simultaneously, the order in which they are delivered to a process is
implementation-specific.

Multithreading brings additional complexity and additional capabilities
to signal management. Signal semantics for multithreaded applications
are described in `\``Threads'' <ProgThdsLib.html>`__. This also
describes the recommended paradigm for signal management in
multithreaded programs.

--------------


/Signal types
=============

There are two categories of signals, those generated externally, such as
a break from a terminal, and those generated internally (a process
fault). Both types are treated identically. The file
**/usr/include/signal.h** defines the signals that may be delivered to a
process.

SCO OpenServer supports the following signals required by POSIX.1: 

+---------------+-----------------------------------------------------+
| Symbolic name | Signal event description                            |
+===============+=====================================================+
| **SIGABRT**   | Abnormal termination (see                           |
|               | `abort\ (S) <../man/html.S/abort.S.html>`__)        |
+---------------+-----------------------------------------------------+
| **SIGALRM**   | Alarm time out (see                                 |
|               | `alarm\ (S) <../man/html.S/alarm.S.html>`__)        |
+---------------+-----------------------------------------------------+
| **SIGFPE**    | Floating-Point Exception / Erroneous Arithmetic     |
|               | Operation                                           |
+---------------+-----------------------------------------------------+
| **SIGHUP**    | Hangup on controlling-terminal (see                 |
|               | `termios\ (S) <../man/html.S/termios.S.html>`__)    |
+---------------+-----------------------------------------------------+
| **SIGILL**    | Illegal hardware instruction / Invalid function     |
|               | image                                               |
+---------------+-----------------------------------------------------+
| **SIGINT**    | Interactive attention - \``interrupt'' (see         |
|               | `termios\ (S) <../man/html.S/termios.S.html>`__)    |
+---------------+-----------------------------------------------------+
| **SIGKILL**   | Termination (cannot be caught or ignored)           |
+---------------+-----------------------------------------------------+
| **SIGPIPE**   | Write onto pipe without readers (see                |
|               | `write\ (S) <../man/html.S/write.S.html>`__)        |
+---------------+-----------------------------------------------------+
| **SIGQUIT**   | Interactive termination - \``quit'' (see            |
|               | `termios\ (S) <../man/html.S/termios.S.html>`__)    |
+---------------+-----------------------------------------------------+
| **SIGSEGV**   | Invalid memory (segmentation) reference             |
+---------------+-----------------------------------------------------+
| **SIGTERM**   | Termination                                         |
+---------------+-----------------------------------------------------+
| **SIGUSR1**   | Reserved as application-defined signal 1            |
+---------------+-----------------------------------------------------+
| **SIGUSR2**   | Reserved as application-defined signal 2            |
+---------------+-----------------------------------------------------+

SCO OpenServer supports the following job control signals: 

+---------------+-----------------------------------------------------+
| Symbolic name | Signal event description                            |
+===============+=====================================================+
| **SIGCHLD**   | Child Status Changed                                |
+---------------+-----------------------------------------------------+
| **SIGCONT**   | Continue process execution                          |
+---------------+-----------------------------------------------------+
| **SIGSTOP**   | Stop process execution                              |
+---------------+-----------------------------------------------------+
| **SIGTSTP**   | Interactive stop (see                               |
|               | `termios\ (S) <../man/html.S/termios.S.html>`__)    |
+---------------+-----------------------------------------------------+
| **SIGTTIN**   | Stop tty input (see                                 |
|               | `termios\ (S) <../man/html.S/termios.S.html>`__)    |
+---------------+-----------------------------------------------------+
| **SIGTTOU**   | Stop tty output (see                                |
|               | `termios\ (S) <../man/html.S/termios.S.html>`__)    |
+---------------+-----------------------------------------------------+

SCO OpenServer supports the following additional signals: 

+----------------+----------------------------------------------------+
| Symbolic name  | Signal event description                           |
+================+====================================================+
| **SIGBUS**     | Bus Error                                          |
+----------------+----------------------------------------------------+
| **SIGEMT**     | Emulation Trap                                     |
+----------------+----------------------------------------------------+
| **SIGPOLL**    | Pollable Event (see                                |
|                | `streamio\ (M) <../man/html.M/streamio.M.html>`__) |
+----------------+----------------------------------------------------+
| **SIGPWR**     | Power Fail / Restart                               |
+----------------+----------------------------------------------------+
| **SIGSYS**     | Bad System Call                                    |
+----------------+----------------------------------------------------+
| **SIGTRAP**    | Trace / Breakpoint Trap                            |
+----------------+----------------------------------------------------+
| **SIGWINCH**   | Window Size Change                                 |
+----------------+----------------------------------------------------+
| **SIGXCPU**    | CPU time limit exceeded (see                       |
|                | `g                                                 |
|                | etrlimit\ (S) <../man/html.S/getrlimit.S.html>`__) |
+----------------+----------------------------------------------------+
| **SIGXFSZ**    | File size limit exceeded (see                      |
|                | `g                                                 |
|                | etrlimit\ (S) <../man/html.S/getrlimit.S.html>`__) |
+----------------+----------------------------------------------------+
| **SIGWAITING** | All LWPs blocked                                   |
+----------------+----------------------------------------------------+
| **SIGLWP**     | Virtual interprocessor interrupt for the Threads   |
|                | Library                                            |
+----------------+----------------------------------------------------+
| **SIGAIO**     | Asynchronous I/O                                   |
+----------------+----------------------------------------------------+

The signals fall into one of the following classes: 

-  hardware conditions
-  software conditions
-  input/output notification
-  job control
-  resource control

Hardware signals are derived from exceptional conditions which may occur
during execution. Such signals include **SIGBUS** for accesses that
result in hardware-related errors, **SIGFPE** representing
floating-point and other arithmetic exceptions, **SIGILL** for invalid
instruction execution, and **SIGSEGV** for addresses outside the
currently assigned area of memory or for accesses that violate memory
protection constraints. Other, more CPU-specific hardware signals such
as **SIGABRT**, **SIGEMT** and **SIGTRAP** may be defined by a specific
implementation.

Software signals reflect interrupts generated by user request: 
**SIGINT** for the normal interrupt signal; **SIGQUIT** for the more
powerful quit signal that normally causes a core image to be generated;
**SIGHUP** and **SIGTERM** that cause graceful process termination,
either because a user has \``hung up'', or by user or program request;
and **SIGKILL**, a more powerful termination signal that a process
cannot catch or ignore. Programs may define their own asynchronous
events using **SIGUSR1** and **SIGUSR2**. Other software signals, such
as **SIGALRM**, **SIGVTALRM**, **SIGPROF**, indicate the expiration of
interval timers.

A process can request notification via the signal **SIGPOLL** when input
or output is possible on a file descriptor, or when a \``non-blocking''
operation completes. A process may request to receive the signal
**SIGURG** when an urgent condition arises.

A process may be \``stopped'' by a signal sent to it or the members of
its process group (see `\``Terminal device
control'' <TermDevCntl.html>`__ and
`termios\ (S) <../man/html.S/termios.S.html>`__). The signal **SIGSTOP**
is a powerful stop signal, because it cannot be caught. Other stop
signals **SIGTSTP**, **SIGTTIN** and **SIGTTOU** are used when a user
request, input request, or output request respectively is the reason for
stopping the process. The signal **SIGCONT** is sent to a process when
it is continued from a stopped state. Processes may receive notification
with the signal **SIGCHLD** when a child process changes state, either
by stopping or by terminating (see
`wait\ (S) <../man/html.S/wait.S.html>`__).

Exceeding resource limits may cause signals to be generated. **SIGXCPU**
occurs when a process nears its CPU time limit and **SIGXFSZ** warns
that the limit on file size limit has been reached.

Three system signals, **SIGLWP**, **SIGWAITING**, and **SIGAIO**, are
generated by the operating system for internal use by the Threads
Library.

--------------

/Signal actions
===============

Signals interrupt the normal flow of control in a process. Signals do
not direct the execution of a process; but rather, request that the
process take some action. For most signals, a process can arrange to
respond in one of the following ways: 

-  terminate on receipt of the signal
-  ignore it completely
-  catch it and act on it in some way defined by the user process.

The chosen response for each signal is known as the signal's
\``disposition''.

For example, an interrupt signal may be sent by pressing an appropriate
key on the terminal (\``delete'', \``break'' or \``rubout''). The action
taken depends on the requirements of the specific program being
executed. For example: 

-  The shell invokes most commands in such a way that they stop
   executing immediately (die) when an interrupt is received. For
   example, the **pr** (print) command normally dies, allowing the user
   to stop unwanted output.
-  The shell itself ignores interrupts when reading from the terminal
   because the shell should continue execution even when the user stops
   a command like **pr**.
-  The editor **ed** chooses to catch interrupts so that it can halt its
   current action (especially printing) without allowing itself to be
   terminated.

A signal is said to be \``delivered'' to a process when the process
receives the signal and takes the action established for it. Signal
delivery resembles the occurrence of a hardware interrupt: the signal is
normally blocked from further occurrence, the current process context is
saved, and a new one is built.

--------------

/Signal handlers
================

A process calls `sigaction\ (S) <../man/html.S/sigaction.S.html>`__ to
set the disposition for a signal. If the signal is to be caught, a
process specifies the \``handler'' function, which will be called when
the signal occurs. Alternatively, a process can specify that the signal
is to be \``blocked'' or \``ignored'', or it may specify that the
\``default'' action is to be taken when the signal occurs.

For each signal, the *<signal.h>* header file establishes the default
signal action to be one of the following: 

Abort
   On receipt of the signal, the receiving process terminates abnormally
   with all the consequences outlined in
   `exit\ (S) <../man/html.S/exit.S.html>`__. In addition, a core image
   file is created, which contains the current memory image of the
   process for use in post-mortem debugging.
Exit
   On receipt of the signal, the receiving process terminates normally
   with all the consequences outlined in
   `exit\ (S) <../man/html.S/exit.S.html>`__.
Ignore
   On receipt of the signal, the receiving process ignores it.
Stop
   On receipt of the signal, the receiving process stops.

As the default action for a signal typically is to terminate a process,
a process wanting to continue processing after a signal must use the
function **sigaction** to arrange alternative handling of the signal
(see `sigaction\ (S) <../man/html.S/sigaction.S.html>`__). To control
the way a signal is delivered, a process calls **sigaction** to
associate a handler with that signal. The call

::

   #include <signal.h>

   sigaction(signo, sa, osa)
       int signo;
       struct sigaction *sa;
       struct sigaction *osa;

assigns the address of the interrupt handler specified by **sa** to the
signal specified by **signo**. If **osa** is non-zero, **sigaction**
stores the previous signal action at that address.

The first argument to the function **sigaction** is just an integer code
number that represents a signal. The *<signal.h>* header file defines
symbolic names for the signal numbers and must always be included when
signals are used.

The second and third arguments to **sigaction** are pointers to the
**sigaction** structure defined by the *<signal.h>* header file to
contain the following members (see
`signal\ (S) <../man/html.S/signal.S.html>`__): 

::

   void      (*sa_handler)();
   sigset_t  sa_mask;
   int       sa_flags;

The member ``sa_handler`` specifies what action to take on receipt of
the signal. Assigning one of the following values to ``sa_handler``
establishes the signal action as follows: 

**SIG_IGN**
   ignore the signal
**SIG_DFL**
   take the default action for the signal
**a pointer to a signal handler**
   handle the signal by calling a function

The *<signal.h>* header file defines the special values used to request
that the signal be ignored (**SIG_IGN**) or that the default action for
the signal be taken (**SIG_DFL**) each of which the *<signal.h>* header
file expands into a distinct constant expression of the type
**(void(\*)())**, whose value matches no declarable function.

The **sa_handler** routine is called by a C call of the form

::

   (*sa_handler)(signo, infop, ucp);
       int signo;
       siginfo_t *infop;
       ucontext_t *ucp;

**signo** gives the number of the signal that occurred. **infop** is
either equal to 0, or points to a structure that contains information
detailing the reason why the signal was generated. This information must
be explicitly asked for when the signal's action is specified. The
**ucp** parameter is a pointer to a structure containing the process's
context prior to the delivery of the signal, and will be used to restore
the process's context upon return from the signal handler.

**sa_mask** specifies the set of signals to be masked when the signal
handler is invoked; it implicitly includes the signal which invoked the
signal handler. When a signal condition arises for a process, the signal
is added to a set of signals pending for the process. If the signal is
not currently blocked by the process then it is delivered. The process
of signal delivery adds the signal to be delivered and those signals
specified in the **sa_mask** for the associated signal handler to a set
of those masked for the process, saves the current process context, and
places the process in the context of the signal-handling routine. The
call is arranged so that if the signal-handling routine exits normally,
the signal mask is restored and the process resumes execution in the
original context. Should the process wish to resume in a different
context, it must arrange to restore the signal mask itself.

Signal masks are usually constructed with the following routines (see
**sigsetops**\ (S)): 

**sigemptyset**
   empty a set
**sigfillset**
   fill a set with every signal currently supported
**sigaddset**
   add specified signals to a set
**sigdelset**
   delete specified signals from a set
**sigismember**
   test membership in a set

Signal sets should always be initialized with a call to **sigemptyset**
or **sigfillset**.

The mask of blocked signals is independent of signal handlers for
delays. It delays the delivery of signals much as a raised hardware
interrupt priority level delays hardware interrupts. Preventing an
interrupt from occurring by changing the handler is analogous to
disabling a device from further interrupts.

The member **sa_flags** specifies special properties of the signal, such
as whether system calls should be restarted if the signal handler
returns, if the signal action should be reset to **SIG_DFL** when it is
caught, and whether the signal handler should operate on the normal
run-time stack or a special signal stack (see `\``Signal
stacks'' <SJCP_SigSs.html>`__ and
`sigaction\ (S) <../man/html.S/sigaction.S.html>`__).

Initially, all signals are set to **SIG_DFL** or **SIG_IGN** prior to
entry of the function **main** (see
`exec\ (S) <../man/html.S/exec.S.html>`__). Once an action is
established for a specific signal, it usually remains established until
another action is explicitly established by a call to either
**signal**\ (2), **sigset**\ (2), **sigignore**\ (2), or
**sigaction**\ (2) explicitly establishes another action, or until the
process calls **fork**\ (2) or an
`exec\ (S) <../man/html.S/exec.S.html>`__ function. A child process
inherits the actions of the parent for the defaulted and ignored
signals. Caught signals are reset to the default action in the child
process. This is necessary since the address linkage for signal-handling
routines specified in the parent are no longer appropriate in the child.
When a process **exec**\ s, all signals set to catch the signal are
reset to **SIG_DFL**. Alternatively, a process may request that the
action for a signal automatically be reset to **SIG_DFL** after catching
it (see `signal\ (S) <../man/html.S/signal.S.html>`__ and
`sigaction\ (S) <../man/html.S/sigaction.S.html>`__).

In the following example, the first call to **sigaction** causes
interrupts to be ignored; while the second call to **sigaction**
restores the default action for interrupts, which is to terminate the
process. In both cases, **sigaction** returns the previous signal action
in the final argument **old_act**.

::

   #include <signal.h>

   main() {
      struct sigaction new_act, old_act;

      new_act.sa_handler = SIG_IGN;
      sigaction(SIGINT, &new_act, &old_act);

      /* do processing */

      new_act.sa_handler = SIG_DFL;
      sigaction(SIGINT, &new_act, &old_act);
   }

Instead of the special values **SIG_IGN** or **SIG_DFL**, the second
argument to **sigaction** may specify a signal-handling routine; in
which case, the specified function is called when the signal occurs.
Most commonly this facility is used to allow the program to clean up
unfinished business before terminating, for example to delete a
temporary file, as in the following example: 

::

   #include <signal.h>

   main() {
      struct sigaction new_act, old_act;
      void on_intr();

      new_act.sa_handler = SIG_IGN;
      sigaction(SIGINT, &new_act, &old_act);

      if (old_act.sa_handler != SIG_IGN) {
         new_act.sa_handler = on_intr;
         sigaction(SIGINT, &new_act, &old_act);
      }

      /* do processing */

      exit(0);       /* exit with normal status */
   }

   void on_intr() {

      unlink(tempfile);

      exit(1);       /* exit with interrupted status */
   }

**Signal programming example**

Before establishing **on_intr** as the signal handler for **SIGINT**,
the program tests the state of interrupt handling, and continues to
ignore interrupts if they are already being ignored. This is needed
because **SIGINT** is sent to *all* processes started from a specific
terminal. Accordingly, when a program is initiated with \`\`\ **&**'' to
run without any interaction in the background, the shell turns off
interrupts for it so it will not be stopped by interrupts intended for
foreground processes. If this program began by setting **on_intr** to
catch all interrupts regardless, that would undo the shell's efforts to
protect it when run in the background. The solution, shown above, is to
call **sigaction** for **SIGINT** first to get the signal action
currently established for the interrupt signal, which is returned in the
third argument to **sigaction**. If interrupt signals were already being
ignored, the process should continue to ignore them; otherwise, they
should be caught. In that case, the second call to **sigaction** for
**SIGINT** establishes a new signal action which specifies **on_intr**
as the signal handler.

A more sophisticated program may wish to intercept and interpret
**SIGINT** as a request to stop what it is doing and return to its own
command processing loop. Think of a text editor: interrupting a long
printout should not cause it to terminate and lose the work already
done. The outline of the code for this case is probably best written as
follows: 

::

   #include <signal.h>
   #include <setjmp.h>
   jmp_buf sjbuf;

   main() {
      struct sigaction new_act, old_act;
      void on_intr();

      new_act.sa_handler = SIG_IGN;
      sigaction(SIGINT, &new_act, &old_act);

      setjmp(sjbuf);   /* save current stack position */

      if (old_act.sa_handler != SIG_IGN) {
         new_act.sa_handler = on_intr;
         sigaction(SIGINT, &new_act, &old_act);
      }
   /*
    * main command processing loop
    */
      exit(0)
   }

   void on_intr() {

      printf("\nInterrupt\n");   /* print message */

      longjmp(sjbuf);   /* return to saved state */
   }

**Signal programming example**

The *<setjmp.h>* header file declares the type **jmp_buf** for a buffer
in which the state can be saved, and the program above declares
**sjbuf** to be of type **jmp_buf** which is an array of some type. The
function **setjmp** saves the current context of the user process in
**sjbuf**. When an interrupt occurs, a call to the function **on_intr**
is forced, which prints a message and could set flags or do something
else. The function **longjmp** takes as argument an object stored into
by **setjmp**, and restores control to the location after the call to
**setjmp**, so control (and the stack level) pops back to place in the
program **main** where the signal is set up and the main loop entered.
Notice, by the way, that the signal gets set again after an interrupt
occurs. This is necessary; most signals are automatically reset to their
default action when they occur.

Some programs that want to detect signals simply cannot be stopped at an
arbitrary point, for example in the middle of updating a linked list. If
the function called on occurrences of a signal sets a flag and then
returns instead of calling **exit** or **longjmp**, execution resumes at
the exact point it was interrupted. The interrupt flag can then be
tested later.

This approach has the following difficulty. Suppose the program is
reading the terminal when the interrupt is sent. The specified function
is duly called; it sets its flag and returns. If it were really true, as
said earlier, that \``execution resumes at the exact point it was
interrupted,'' the program would continue reading the terminal until the
user typed another line. This behavior might well be confusing, since
the user might not know the program is reading, and presumably would
prefer to have the signal take effect instantly. The method chosen to
resolve this difficulty is to terminate the **read** from the terminal
when execution resumes after the signal, with **read** returning an
error code (**EINTR**) which indicates the interruption.

As a consequence, programs which catch and resume execution after
signals should be prepared for \``errors'' caused by interrupted system
calls. (The ones to watch out for in particular are **wait** and
**pause** as well as any **read** from the terminal).

A program whose **on_intr** function just sets **intflag**, resets the
interrupt signal, and returns, should usually include code like the
following when it reads the standard input or directly from a terminal
device.

::

   if (getchar() == EOF)
      if (intflag)
         /* EOF caused by interrupt */
      else
         /* actual end-of-file */

A final subtlety to keep in mind becomes important when signal handling
is combined with execution of other programs. Suppose a program handles
interrupts, and also includes a method (like \`\`\ **!**'' in the
editor) whereby other programs can be executed. Then the code should
look something like this: 

::

   if (fork() == 0)
      exec( ... );

   new_act.sa_handler = SIG_IGN;  /* ignore interrupts */
   sigaction(SIGINT, &new_act, &old_act);

   wait(&status);         /* until the child completes */

   new_act.sa_handler = on_intr;  /* restore interrupts */
   sigaction(SIGINT, &new_act, &old_act);

Why is this? Again, its not obvious but not really difficult. Suppose
the program called catches its own interrupts. When this subprogram gets
interrupted, it receives the signal, returns to its main loop and
probably tries to read the terminal. But the calling program also pops
out of its wait for the subprogram and tries to read the terminal. Two
processes trying to read the terminal is very unfortunate, since the
system randomly decides which should get each line of input. A simple
solution is for the parent to ignore interrupts until the child
completes.

This reasoning is reflected in the function **system** as follows: 

::

   #include <signal.h>

   system(cmd_str) /* run command string */
      char *cmd_str;
   {
      int status;
      pid_t wpid, xpid;
      struct sigaction sig_act, i_stat, q_stat;

      if ((xpid=fork()) == 0) {
         execl("/bin/sh", "sh", "-c", cmd_str, 0);
         _exit(127);
      }

      sig_act.sa_handler = SIG_IGN;
      sigaction(SIGINT, &sig_act, &i_stat);

      sig_act.sa_handler = SIG_IGN;
      sigaction(SIGQUIT, &sig_act, &q_stat);

      while ( ((wpid=wait(&status)) != xpid) && (wpid != -1) )
         ;
      if (wpid == -1)
         status = -1;

      sigaction(SIGINT, &i_stat, &sig_act);
      sigaction(SIGQUIT, &q_stat, &sig_act);

      return(status);
   }

**system - signal programming example**

--------------


/Protecting critical sections
=============================

Signal-handling routines normally execute with the signal that caused
their invocation to be \``blocked'', but other signals may yet occur.
Mechanisms are provided whereby \``critical-sections'' of code may
protect themselves against the occurrence of specified signals.

To block a section of code against one or more signals, a call to
**sigprocmask** may be used to add a set of signals to the existing mask
and return the old mask: 

::

      sigprocmask ( SIG_BLOCK ,
       sigset_t *new_mask ,
       sigset_t *old_mask )

The old mask can then be restored later with **sigprocmask**, as
follows: 

::

   sigprocmask ( SIG_UNBLOCK ,
       sigset_t *new_mask ,
       sigset_t *old_mask )

The function **sigprocmask** can be used to read the current mask
without changing it by specifying a null-pointer as its second argument.

It is possible to check conditions with some signals blocked and then to
pause waiting for a signal and restoring the mask, by using: 

::

   sigsuspend (
       sigset_t *sig_mask )

--------------


/Signal stacks
==============

Applications that maintain complex or fixed-size stacks can use the call

::

   struct sigaltstack {
       caddr_t ss_sp;
       int     ss_size;
       int ss_flags;
   };

::

   sigaltstack(ss, oss)
       struct sigaltstack *ss;
       struct sigaltstack *oss;

to provide the system with a stack based at **ss_sp** of size
**ss_size** for delivery of signals. The system automatically adjusts
for direction of stack growth. The member **ss_flags** indicates whether
the process is currently on the signal stack and whether the signal
stack is disabled.

When a signal is to be delivered and the process has requested that it
be delivered on the alternate stack, the system checks whether the
process is on a signal stack (see
`sigaction\ (S) <../man/html.S/sigaction.S.html>`__). If it is not, then
the process is switched to the signal stack for delivery, with the
return from the signal arranged to restore the previous stack.

If the process wishes to take a non-local exit from the signal-handling
routine or run code from the signal stack that uses a different stack, a
**sigaltstack** call should be used to reset the signal stack (see
`sigaltstack\ (S) <../man/html.S/sigaltstack.S.html>`__).

--------------


/Sending signals
================

A process can send a signal to another process or group of processes
using either `kill\ (S) <../man/html.S/kill.S.html>`__ or
`sigsend\ (S) <../man/html.S/sigsend.S.html>`__: 

::

   kill(pid, signo);
       int pid, signo;

::

   sigsend(idtype, id, signo);
       idtype_t idtype;
       id_t id;

Unless the process sending the signal is privileged, its real or
effective user- ID must be equal to the receiving process's real or
saved user-ID.

A process can send a signal to itself using the function **raise** as
follows (see `raise\ (S) <../man/html.S/raise.S.html>`__): 

::

   raise ( int sig_val );

Signals can also be sent from a terminal device to the process group or
session leader associated with the terminal (see
`termio\ (M) <../man/html.M/termio.M.html>`__).

--------------


/Job control and session management
===================================

|  An overview of Job Control is provided here for completeness and
  because it interacts with the STREAMS-based terminal subsystem. This
  section describes how to use a Stream as a controlling terminal. More
  information on Job Control can be obtained from the following manual
  pages: `exit\ (S) <../man/html.S/exit.S.html>`__,
  `getpid\ (S) <../man/html.S/getpid.S.html>`__,
  `getsid\ (S) <../man/html.S/getsid.S.html>`__,
  `kill\ (S) <../man/html.S/kill.S.html>`__,
  `setpgid\ (S) <../man/html.S/setpgid.S.html>`__,
  `setpgrp\ (S) <../man/html.S/setpgrp.S.html>`__,
  `setsid\ (S) <../man/html.S/setsid.S.html>`__,
| `sigaction\ (S) <../man/html.S/sigaction.S.html>`__,
  `signal\ (S) <../man/html.S/signal.S.html>`__,
  `sigsend\ (S) <../man/html.S/sigsend.S.html>`__,
  `termios\ (S) <../man/html.S/termios.S.html>`__,
  `waitid\ (S) <../man/html.S/waitid.S.html>`__,
  `waitpid\ (S) <../man/html.S/waitpid.S.html>`__,
  `signal\ (M) <../man/html.M/signal.M.html>`__, and
  `termio\ (M) <../man/html.M/termio.M.html>`__.

--------------

/Overview of job control
========================

Job Control is a feature supported by the BSD UNIX operating system. It
is also an optional part of the IEEE P1003.1 POSIX standard. Job Control
breaks a login session into smaller units called jobs. Each job consists
of one or more related and cooperating processes. One job, the
foreground job, is given complete access to the controlling terminal.
The other jobs, called background jobs, are denied read access to the
controlling terminal and given conditional write and **ioctl** access to
it. The user may stop an executing job and resume the stopped job either
in the foreground or in the background.

Under Job Control, background jobs do not receive events generated by
the terminal and are not informed with a hangup indication when the
controlling process exits. Background jobs that linger after the login
session has been dissolved are prevented from further access to the
controlling terminal, and do not interfere with the creation of new
login sessions.

If **\_POSIX_JOB_CONTROL** is defined, SCO OpenServer supports
job-control and command interpreter processes supporting job-control can
assign the terminal to different jobs, or process-groups, by placing
related processes in a single process-group and assigning the
process-group with the terminal. A process may examine or change the
foreground process-group of a terminal assuming the process has the
required permissions (see **tcgetpgrp** in
`termios\ (S) <../man/html.S/termios.S.html>`__ and **tcsetpgrp** in
`termios\ (S) <../man/html.S/termios.S.html>`__). The **termios**
facility aids in this assignment by restricting access to the terminal
by processes outside of the foreground process-group (see `\``Terminal
access control'' <SJCP_TermAccCntl.html>`__).

When there is no longer any process whose process-id or process-group-id
matches the process-group-id of the foreground process-group, the
terminal lacks any foreground process-group. It is unspecified whether
the terminal has a foreground process-group when there is no longer any
process whose process-group-id matches the process-group-id of the
foreground process-group, but there is a process whose process-id
matches the process-group-id of the foreground process-group. Only a
successful call to **tcsetpgrp** or assignment of the controlling
terminal as described can make a process-group the foreground
process-group of a terminal (see **tcsetpgrp** in
`termios\ (S) <../man/html.S/termios.S.html>`__).

Background process-groups in the session of the session-leader are
subject to a job-control line-discipline when they attempt to access
their controlling terminal. Typically, they are sent a signal that
causes them to stop, unless they have made other arrangements (see
`signal\ (M) <../man/html.M/signal.M.html>`__). An exception is made for
processes that belong to a orphaned process-group, which is a
process-group none of whose members have a parent in another
process-group within the same session and thus share the same
controlling terminal. When these processes attempt to access their
controlling terminal, they return errors, because there is no process to
continue them if they should stop (see `\``Terminal access
control'' <SJCP_TermAccCntl.html>`__).

--------------


/Job control terminology
========================

The following defines terms associated with Job Control: 

-  Background Process-group -- a process-group that is a member of a
   session that established a connection with a controlling terminal and
   is not the foreground process-group.
-  Controlling Process -- a session leader that established a connection
   to a controlling terminal.
-  Controlling Terminal -- a terminal that is associated with a session.
   Each session may have at most one controlling terminal associated
   with it and a controlling terminal may be associated with at most one
   session. Certain input sequences from the controlling terminal cause
   signals to be sent to the process-groups in the session associated
   with the controlling terminal.
-  Foreground Process Group -- each session that establishes a
   connection with a controlling terminal distinguishes one
   process-group of the session as a foreground process-group. The
   foreground process-group has certain privileges that are denied to
   background process-groups when accessing its controlling terminal.
-  Orphaned Process Group -- a process-group in which the parent of
   every member in the group is either a member of the group, or is not
   a member of the process-group's session.
-  Process Group -- each process in the system is a member of a
   process-group that is identified by a process-group ID. Any process
   that is not a process-group leader may create a new process-group and
   become its leader. Any process that is not a process-group leader may
   join an existing process-group that shares the same session as the
   process. A newly created process joins the process-group of its
   creator.
-  Process Group Leader -- a process whose process ID is the same as its
   process group ID.
-  Process Group Lifetime -- a time period that begins when a
   process-group is created by its process-group leader and ends when
   the last process that is a member in the group leaves the group.
-  Process ID -- a positive integer that uniquely identifies each
   process in the system. A process ID may not be reused by the system
   until the process lifetime, process-group lifetime, and session
   lifetime ends for any process ID, process-group ID, and session ID
   sharing that value.
-  Process Lifetime -- a time period that begins when the process is
   forked and ends after the process exits, when its termination has
   been acknowledged by its parent process.
-  Session -- each process-group is a member of a session that is
   identified by a session ID.
-  Session ID -- a positive integer that uniquely identifies each
   session in the system. It is the same as the process ID of its
   session leader.
-  Session Leader -- a process whose session ID is the same as its
   process and process-group ID.
-  Session Lifetime -- a time period that begins when the session is
   created by its session leader and ends when the lifetime of the last
   process-group that is a member of the session ends.

--------------


/Job control signals
====================

The following signals manage Job Control (see also 
`signal\ (M) <../man/html.M/signal.M.html>`__): 

**SIGCONT**
   Sent to a stopped process to continue it.
**SIGSTOP**
   Sent to a process to stop it. This signal cannot be caught or
   ignored.
**SIGTSTP**
   Sent to a process to stop it. It is typically used when a user
   requests to stop the foreground process.
**SIGTTIN**
   Sent to a background process to stop it when it attempts to read from
   the controlling terminal.
**SIGTTOU**
   Sent to a background process to stop it when one attempts to write to
   or modify the controlling terminal.

--------------

/The controlling terminal and process-groups
============================================

A session may be allocated a controlling terminal. For every allocated
controlling terminal, Job Control elevates one process group in the
controlling process's session to the status of foreground process group.
The remaining process-groups in the controlling process's session are
background process-groups. A controlling terminal gives a user the
ability to control execution of jobs within the session.
Controlling-terminals play a central role in Job Control. A user may
cause the foreground job to stop by typing a predefined key on the
controlling terminal. A user may inhibit access to the controlling
terminal by background jobs. Background jobs that attempt to access a
terminal that has been so restricted will be sent a signal that
typically causes the job to stop. (see `\``Accessing the controlling
terminal'' <SJCP_AccCntllTerm.html>`__).

--------------

/Terminal access control
========================

If a process is in the foreground process-group of its controlling
terminal, **read** works as described in `\``Input processing and
reading data'' <TDC_InProcReadData.html>`__. If any process in a
background process-group attempts to read from its controlling terminal
when job-control is supported, the signal **SIGTTIN** is sent to its
process-group unless one of these special cases apply: 

-  If the reading process either ignores or blocks the signal
   **SIGTTIN** or if the reading process is a member of an orphaned
   process-group, attempting to read the controlling terminal fails
   without sending the signal **SIGTTIN**, the **read** returns **-1**
   and **errno** equals **EIO**.

The default action of the signal **SIGTTIN** is to stop the process to
which it is sent (see `signal\ (M) <../man/html.M/signal.M.html>`__).

If a process is in the foreground process-group of its controlling
terminal, **write** works as described in `\``Writing data and output
processing'' <TDC_WritDataOutProc.html>`__. If any process in a
background process-group attempts to write onto its controlling terminal
when the flag **TOSTOP** is set in the **c_lflag** field of the
**termios** structure, the signal **SIGTTOU** is sent to the
process-group unless one of these special cases apply: 

-  If the writing process either ignores or blocks the signal
   **SIGTTOU**, attempting to write the controlling terminal proceeds
   without sending the signal **SIGTTOU**.
-  If the writing process neither ignores nor blocks the signal
   **SIGTTOU** and if the writing process is a member of an orphaned
   process-group, attempting to write the controlling terminal fails
   without sending the signal **SIGTTOU**, the **write** returns **-1**
   and **errno** equals **EIO**.

If the flag **TOSTOP** is clear, attempting to write the controlling
terminal proceeds without sending the signal **SIGTTOU**.

Certain calls that set terminal parameters are treated the same as
**write** calls, except that the flag **TOSTOP** is ignored; thus, the
effect is the same as terminal **write** calls when the flag **TOSTOP**
is set (see **tcgetattr** in
`termios\ (S) <../man/html.S/termios.S.html>`__ and **tcsetattr** in
`termios\ (S) <../man/html.S/termios.S.html>`__).

If the implementation supports job-control, unless otherwise noted,
processes in a background process-group are restricted in their use of
the terminal-control-functions (see
`termios\ (S) <../man/html.S/termios.S.html>`__). Attempts to perform
these functions cause the process-group to be sent the signal
**SIGTTOU**. If the calling process either ignores or blocks the signal
**SIGTTOU**, attempting to perform a control-function proceeds without
sending the signal **SIGTTOU**.

The default action of the signal **SIGTTOU** is to stop the process to
which it is sent (see `signal\ (M) <../man/html.M/signal.M.html>`__).

All terminal-control-functions operate on an open file-descriptor and
they affect the underlying terminal-device-file denoted by the
file-descriptor, not the open-file-description that represents it.

If a member of a background process-group attempts to invoke an
**ioctl** on its controlling terminal, and that **ioctl** modifies
terminal parameters (e.g., **TIOCSPGRP**, **TCSETA**, **TCSETAW** or
**TCSETAF**) its process-group is sent **SIGTTOU**, which normally
causes the members of that process-group to stop.

-  If the calling process either ignores or blocks the signal
   **SIGTTOU**, attempting to perform a terminal-control-function on the
   controlling terminal proceeds without sending the signal **SIGTTOU**.
-  If the calling process neither ignores nor blocks the signal
   **SIGTTOU** and if the calling process is a member of an orphaned
   process-group, attempting to perform a terminal-control-function on
   the controlling terminal fails without sending the signal
   **SIGTTOU**, the **ioctl** returns **-1** and **errno** equals
   **EIO**.

The terminal access controls described in this section apply only to a
process accessing its controlling terminal because these controls are
for the purpose of job-control, not security, and job-control relates
only to a controlling terminal for a process. Normal
file-access-permissions handle security. A process accessing a terminal
other than the controlling terminal is effectively treated the same as a
member of the foreground process-group.

If a process in a background orphaned process-group calls **read** or
**write**, stopping the process-group is undesirable, as it is no longer
under the control of a job-control shell that can put it into foreground
again. Accordingly, calls to **read** and **write** by such processes
receive an immediate return error.

The terminal-driver must repeatedly do a foreground/background/orphaned
process-group check until either the process-group of the calling
process is orphaned or the calling process moves into the foreground. If
a calling process is in the background and should receive a job-control
signal, the terminal-driver sends the appropriate signal (**SIGTTIN** or
**SIGTTOU**) to every process in the process-group of the calling
process then lets the calling process receive the signal immediately,
usually by blocking the process so it reacts to the signal right away.
Note, however, that after the process catches the signal and the
terminal-driver regains control, the driver must repeat the
foreground/background/orphaned process-group check. The process may
still be in the background, either because a job-control shell continued
the process in the background, or because the process caught the signal
and did nothing.

The terminal-driver repeatedly does the foreground/background/orphaned
process-group check whenever a process tries to access the terminal. For
**write** or the line-control functions, the check is done on entering
the function. For **read**, the check is done not only on entering the
function but also after blocking the process to wait for input data (if
necessary). If the process calling **read** is in the foreground, the
terminal-driver tries to get data from the input-queue, and if the queue
is empty, blocks the process to wait for data. When data are input and
the terminal-driver regains control, it must repeat the
foreground/background/orphaned process-group check again because the
process may have moved to the background from the foreground while it
blocked to wait for input data.

--------------


/Modem disconnect
=================

The following arrangements are made to allow processes that read from a
terminal-device-file and test for end-of-file to terminate appropriately
when a modem-disconnect is detected on the terminal-device: 

-  All processes with that terminal as the controlling terminal receive
   a hang-up signal, **SIGHUP**, if **CLOCAL** is clear in the
   **c_cflags** for the terminal (see `\``Control
   modes'' <TDC_CntlModes.html>`__ and
   `termios\ (S) <../man/html.S/termios.S.html>`__). Unless other
   arrangements are made, the signal **SIGHUP** forces the processes to
   terminate (see `signal\ (M) <../man/html.M/signal.M.html>`__ and
   `sigaction\ (S) <../man/html.S/sigaction.S.html>`__). If the signal
   **SIGHUP** is ignored or caught by a signal-catching function, any
   subsequent **read** returns **0** to indicate end-of-file until the
   terminal-device-file is closed (see
   `read\ (S) <../man/html.S/read.S.html>`__).
-  If the controlling process is not in the foreground process group of
   the terminal, the signal **SIGTSTP** is sent to all processes in the
   foreground process group for which the terminal is the controlling
   terminal. Unless other arrangements are made, the signal **SIGTSTP**
   forces the processes to terminate (see
   `signal\ (M) <../man/html.M/signal.M.html>`__ and
   `sigaction\ (S) <../man/html.S/sigaction.S.html>`__).
-  Processes in background process groups that try a **read** or a
   **write** of the controlling terminal after a modem-disconnect while
   the terminal is still assigned to the session receive the appropriate
   signal, **SIGTTIN** or **SIGTTOU** respectively (see
   `read\ (S) <../man/html.S/read.S.html>`__ and
   `write\ (S) <../man/html.S/write.S.html>`__). Unless other
   arrangements are made, the signal **SIGTTIN** or **SIGTTOU** forces
   the processes to terminate (see
   `signal\ (M) <../man/html.M/signal.M.html>`__ and
   `sigaction\ (S) <../man/html.S/sigaction.S.html>`__).

--------------


/STREAMS-based job control
==========================

Job Control requires support from a line discipline module on the
controlling terminal's Stream. The **TCSETA**, **TCSETAW**, and
**TCSETAF** commands of `termio\ (M) <../man/html.M/termio.M.html>`__
allow a process to set the following line discipline values relevant to
Job Control: 

**SUSP** character
   A user defined character that, when typed, causes the line discipline
   module to request that the Stream head sends a **SIGTSTP** signal to
   the foreground process with an **M_PCSIG** message, which by default
   stops the members of that group. If the value of **SUSP** is zero,
   the **SIGTSTP** signal is not sent, and the **SUSP** character is
   disabled.
**TOSTOP** flag
   If **TOSTOP** is set, background processes are inhibited from writing
   to their controlling terminal.

A line discipline module must record the **SUSP** suspend character and
notify the Stream head when the user has typed it, and record the state
of the **TOSTOP** bit and notify the Stream head when the user has
changed it.

--------------


/Allocation and deallocation
============================

A Stream is allocated as a controlling terminal for a session if

-  The Stream is acting as a terminal
-  The Stream is not already allocated as a controlling terminal
-  The Stream is opened by a session leader that does not have a
   controlling terminal.

Drivers and modules can inform the Stream head to act as a terminal
Stream by sending an **M_SETOPTS** message with the **SO_ISTTY** flag
set upstream. This state may be changed by sending an **M_SETOPTS**
message with the **SO_ISNTTY** flag set upstream.

Controlling-terminals are allocated with the 
`open\ (S) <../man/html.S/open.S.html>`__ system call. A Stream head
must be informed that it is acting as a terminal by an **M_SETOPTS**
message sent upstream before or while the Stream is being opened by a
potential controlling process. If the Stream head is opened before
receiving this message, the Stream is not allocated as a controlling
terminal.

--------------


/Hung-up streams
================

When a Stream head receives an **M_HANGUP** message, it is marked as
hung-up. Streams that are marked as hung-up are allowed to be reopened
by their session leader if they are allocated as a controlling terminal,
and by any process if they are not allocated as a controlling terminal.
This way, the hangup error can be cleared without forcing all file
descriptors to be closed first.

If the reopen is successful, the hung-up condition is cleared.

--------------


/Hangup signals
===============

When the **SIGHUP** signal is generated by an **M_HANGUP** message
(instead of an **M_SIG** or **M_PCSIG** message), the signal is sent to
the controlling process instead of the foreground process-group, since
the allocation and deallocation of controlling terminals to a session is
the responsibility of that process-group.

--------------


/Accessing the controlling terminal
===================================

If a process attempts to access its controlling terminal after it has
been deallocated, access is denied. If the process is not holding or
ignoring **SIGHUP**, it is sent a **SIGHUP** signal. Otherwise, the
access fails with an **EIO** error.

Members of background process-groups have limited access to their
controlling terminals: 

-  If the background process is ignoring or holding the **SIGTTIN**
   signal or is a member of an orphaned process-group, an attempt to
   read from the controlling terminal fails with an **EIO** error.
   Otherwise, the process is sent a **SIGTTIN** signal, which by default
   stops the process.

-  If the process is attempting to write to the terminal and if the
   terminal's **TOSTOP** flag is clear, the process is allowed access.

   The **TOSTOP** flag is set on reception of an **M_SETOPTS** message
   with the **SO_TOSTOP** flag set in the **so_flags** field. It is
   cleared on reception of an **M_SETOPTS** message with the
   **SO_TONSTOP** flag set.

-  If the terminal's **TOSTOP** flag is set and a background process is
   attempting to write to the terminal, the write succeeds if the
   process is ignoring or holding **SIGTTOU**. Otherwise, the process
   stops except when it is a member of an orphaned process-group, in
   which case, it is denied access to the terminal and it is returned an
   **EIO** error.

-  If a background process is attempting to perform a destructive
   **ioctl** (an **ioctl** that modifies terminal parameters), the
   **ioctl** call succeeds if the process is ignoring or holding
   **SIGTTOU**. Otherwise, the process will stop except when the process
   is a member of the orphaned process-group. In that case, the access
   to the terminal is denied and an **EIO** error is returned.

--------------


/Basic interprocess communication - Pipes
=========================================

The system call **pipe** creates a \``pipe'', a type of unnamed FIFO
(First In First Out) file used as an I/O channel between two cooperating
processes: one process writes onto the pipe, while the other reads from
it. Most pipes are created by the shell, as in: 

::

   ls | pr

which connects the standard output of **ls** to the standard input of
**pr**. Sometimes, however, it is most convenient for a process to set
up its own plumbing; this section illustrates how to establish and use
the pipe connection.

Since a pipe is both for reading and writing, **pipe** returns two
file-descriptors as follows: 

::

   int  fd[2];

   stat = pipe(fd);


   if (stat == -1)
       /* there was an error ... */

where *fd* is an array of two file-descriptors, with **fd[0]** for the
read end of the pipe and **fd[1]** for the write end of the pipe. These
may be used in **read**, **write** and **close** calls just like any
other file-descriptors.

Implementation of pipes consists of implied **lseek** operations before
each **read** or **write** in order to implement first-in-first-out. The
system looks after buffering the data and synchronizing the two
processes to prevent the writer from grossly out-producing the reader
and to prevent the reader from overtaking the writer. If a process reads
a pipe which is empty, it will wait until data arrive; if a process
writes into a pipe which is full, it will wait until the pipe empties
somewhat. If the write end of the pipe is closed, a subsequent **read**
will encounter end-of-file.

To illustrate the use of pipes in a realistic setting, consider a
function **popen(cmd,mode)**, which creates a process **cmd**, and
returns a file-descriptor that will either read or write that process,
according to **mode**; thus, the call

::

   fout = popen("pr", WRITE);

creates a process that executes the **pr** command; subsequent **write**
calls using the file-descriptor **fout** send data to that process
through the pipe.

::

   #include <stdio.h>

   #define   READ   0
   #define   WRITE  1
   #define   tst(a, b) (mode == READ ? (b) : (a))
   static    int popen_pid;

   popen(cmd, mode)
      char *cmd;
      int  mode;
   {
      int p[2];

      if (pipe(p) < 0)
         return(NULL);

      if ((popen_pid = fork( )) == 0) {
         close(tst(p[WRITE], p[READ]));
         close(tst(0, 1));
         dup(tst(p[READ], p[WRITE]));
         close(tst(p[READ], p[WRITE]));
         execl("/bin/sh", "sh", "-c", cmd, 0);
         _exit(1) /* disaster occurred if we got here */
      }
      if (popen_pid == -1)
         return(NULL);

      close(tst(p[READ], p[WRITE]));
      return(tst(p[WRITE], p[READ]));
   }

**popen**

The function **popen** first calls **pipe** to create a pipe, then calls
**fork** to create two copies of itself. The child decides whether it is
supposed to read or write, closes the other end of the pipe, then calls
the shell (via **execl**) to run the desired process. The parent
likewise closes the end of the pipe it does not use. These **close**
operations are necessary to make end-of-file tests work properly. For
example, if a child that intends to read fails to close the write end of
the pipe, it will never encounter the end-of-file on the pipe, just
because there is one writer potentially active. The sequence of
**close** operations in the child is a bit tricky. Suppose that the task
is to create a child process that will read data from the parent. Then
the first **close** closes the write end of the pipe, leaving the read
end open.

To associate a pipe with the standard input of the child, use the
following: 

::

      close(tst(0, 1));
      dup(tst(p[READ], p[WRITE]));

The **close** call closes file-descriptor **0**, the standard input,
then the **dup** call returns a duplicate of the open file-descriptor.
File-descriptors are assigned in increasing order and **dup** returns
the first available one, so the **dup** call effectively copies the
file-descriptor for the pipe (read end) to file-descriptor **0** making
the read end of the pipe the standard input. (Although somewhat tricky,
it's a standard idiom.) Finally, the old read end of the pipe is closed.
A similar sequence of operations takes place when the child process must
write to the parent process instead of reading from it. To finish the
job we need a function **pclose** to close a pipe created by **popen**.

::

   #include <signal.h>

   pclose(fd)   /* close pipe descriptor */
      int fd;
   {
      struct sigaction o_act, h_act, i_act, q_act;
      extern pid_t popen_pid;
      pid_t c_pid;
      int   c_stat;

      close(fd);

      sigaction(SIGINT, SIG_IGN, &i_act);
      sigaction(SIGQUIT, SIG_IGN, &q_act);
      sigaction(SIGHUP, SIG_IGN, &h_act);

      while ((c_pid=wait(&c_stat))!=-1 && c_pid!=popen_pid);
      if (c_pid == -1)
         c_stat = -1;

      sigaction(SIGINT, &i_act, &o_act);
      sigaction(SIGQUIT, &q_act, &o_act);
      sigaction(SIGHUP, &h_act, &o_act);

      return(c_stat);
   }

**pclose**

The main reason for using a separate function rather than **close** is
that it is desirable to wait for the termination of the child process.
First, the return value from **pclose** indicates whether the process
succeeded. Equally important when a process creates several children is
that only a bounded number of unwaited-for children can exist, even if
some of them have terminated; performing the **wait** lays the child to
rest. The calls to **sigaction** make sure that no interrupts, etc.,
interfere with the waiting process (see
`sigaction\ (S) <../man/html.S/sigaction.S.html>`__).

The routine as written has the limitation that only one pipe may be open
at once, because of the single shared variable **popen_pid**; it really
should be an array indexed by file-descriptor. A **popen** function,
with slightly different arguments and return value is available as part
of the Standard I/O Library (see
`Intro\ (S) <../man/html.S/Intro.S.html>`__).

--------------

/STREAMS-based pipes and FIFOs
==============================

A pipe in the UNIX system is a mechanism that provides a communication
path between multiple processes. Before Release 4, UNIX System V had
\``standard'' pipes and named pipes (also called FIFOs). With standard
pipes, one end was opened for reading and the other end for writing,
thus data flow was unidirectional. FIFOs had only one end; typically,
one process opened the file for reading and another process opened the
file for writing. Data written into the FIFO by the writer could then be
read by the reader.

To provide greater support and development flexibility for networked
applications, pipes and FIFOs have become STREAMS-based starting with
UNIX System V Release 4. The basic interface remains the same but the
underlying implementation has changed. Pipes now provide a bidirectional
mechanism for process communication. When a pipe is created by the
**pipe** system call, two Streams are opened and connected together,
thus providing a full-duplex mechanism. Data flow is on a FIFO basis.
Previously, pipes were associated with character devices and the
creation of a pipe was limited to the capacity and configuration of the
device. STREAMS-based pipes and FIFOs are not attached to STREAMS-based
character devices, eliminating configuration constraints and the number
of opened pipes to the number of file descriptors for that process.

--------------

**NOTE:** The remainder of this section uses the terms \``pipe'' and
\``STREAMS-based pipe'' interchangeably.

--------------

--------------


/Creating and opening pipes and FIFOs
=====================================

FIFOs, which are created by `mknod\ (S) <../man/html.S/mknod.S.html>`__
or `mkfifo\ (S) <../man/html.S/mkfifo.S.html>`__ behave like regular
file system nodes but are distinguished from other file system nodes by
the **p** in the first column when the **ls -l** command is executed.
Data written to the FIFO or read from the FIFO flow up and down the
Stream in STREAMS buffers. Data written by one process can be read by
another process.

FIFOs are opened in the same way as other file system nodes using the
**open** system call. Any data written to the FIFO can be read from the
same file descriptor in a FIFO manner. Modules can also be pushed on the
FIFO. See `open\ (S) <../man/html.S/open.S.html>`__ for the restrictions
that apply when opening a FIFO.

A STREAMS-based pipe is created by the **pipe** system call that returns
two file descriptors, **fd[0]** and **fd[1]**. Both file descriptors are
opened for reading and writing. Data written to **fd[0]** becomes data
read from **fd[1]** and vice versa.

Each end of the pipe has knowledge of the other end through internal
data structures. Subsequent reads, writes, and closes are aware of
whether the other end of the pipe is open or closed. When one end of the
pipe is closed, the internal data structures provide a way to access the
Stream for the other end so that an **M_HANGUP** message can be sent to
its Stream head.

After successful creation of a STREAMS-based pipe, **0** is returned. If
**pipe** is unable to create and open a STREAMS-based pipe, it will fail
with **errno** set as follows: 

**ENFILE**
   File table is overflowed.
**EMFILE**
   Cannot allocate more file descriptors for the process.
**ENOSR**
   Could not allocate resources for both Stream heads.
**EINTR**
   Signal was caught while creating the Stream heads.

STREAMS modules can be added to a STREAMS-based pipe with the **ioctl**
**I_PUSH**. A module can be pushed onto one or both ends of the pipe
(see `\``Pushing modules on a STREAMS-based
pipe'' <_Creating_and_Opening_Pipes_and_.html#signals_s6>`__). However,
a pipe maintains the concept of a midpoint so that if a module is pushed
onto one end of the pipe, that module cannot be popped from the other
end.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/pushmod.gif

**Pushing modules on a STREAMS-based pipe**

--------------




/Accessing pipes and FIFOs
==========================

STREAMS-based pipes and FIFOs can be accessed through the operating
system routines `read\ (S) <../man/html.S/read.S.html>`__,
`write\ (S) <../man/html.S/write.S.html>`__,
`ioctl\ (S) <../man/html.S/ioctl.S.html>`__,
`close\ (S) <../man/html.S/close.S.html>`__,
`putmsg\ (S) <../man/html.S/putmsg.S.html>`__,
`getmsg\ (S) <../man/html.S/getmsg.S.html>`__, and
`poll\ (S) <../man/html.S/poll.S.html>`__. If FIFOs, **open** is also
used.

Reading from a pipe or FIFO
---------------------------

The **read** (or **getmsg**) system call is used to read from a pipe or
FIFO. A user reads data from a Stream (not from a data buffer as was
done prior to Release 4). Data can be read from either end of a pipe.

On success, the **read** returns the number of bytes read and placed in
the buffer. When the end of the data is reached, the **read** returns
**0**.

When a user process attempts to read from an empty pipe (or FIFO), the
following will happen: 

-  If one end of the pipe is closed, **0** is returned indicating the
   end of the file.
-  If no process has the FIFO open for writing, **read** returns **0**
   to indicate the end of the file.
-  If some process has the FIFO open for writing, or both ends of the
   pipe are open, and **O_NDELAY** is set, **read** returns **0**.
-  If some process has the FIFO open for writing, or both ends of the
   pipe are open, and **O_NONBLOCK** is set, **read** returns **-1** and
   sets **errno** to **EAGAIN**.
-  If **O_NDELAY** and **O_NONBLOCK** are not set, the **read** call
   blocks until data is written to the pipe, until one end of the pipe
   is closed, or the FIFO is no longer open for writing.

Writing to a pipe or FIFO
-------------------------

When a user process calls the **write** system call, data is sent down
the associated Stream. If the pipe or FIFO is empty (no modules pushed),
data written is placed on the read queue of the other Stream for
STREAMS-based pipes, and on the read queue of the same Stream for FIFOs.
Because the size of a pipe is the number of unread data bytes, the
written data is reflected in the size of the other end of the pipe.

Zero length writes
~~~~~~~~~~~~~~~~~~

If a user process issues **write** with **0** as the number of bytes to
send down a STREAMS-based pipe or FIFO, **0** is returned, and by
default no message is sent down the Stream. However, if a user requires
that a **0**-length message be sent downstream, an **ioctl** call may be
used to change this default behavior. The flag **SNDZERO** supports
this. If **SNDZERO** is set in the Stream head, **write** requests of 0
bytes generate a **0**-length message and send the message down the
Stream. If **SNDZERO** is not set, no message is generated and **0** is
returned to the user.

To toggle the **SNDZERO** bit, the **ioctl** **I_SWROPT** is used. If
**arg** in the **ioctl** call is set to **SNDZERO** and the **SNDZERO**
bit is off, the bit is turned on. If **arg** is set to **0** and the
**SNDZERO** bit is on, the bit is turned off.

The **ioctl** **I_GWROPT** is used to return the current write settings.

Atomic writes
~~~~~~~~~~~~~

If multiple processes simultaneously write to the same pipe, data from
one process can be interleaved with data from another process, if
modules are pushed on the pipe or the write is greater than
**PIPE_BUF**. The sequence of data written is not necessarily the
sequence of data read. To ensure that writes of less than **PIPE_BUF**
bytes are not be interleaved with data written from other processes, any
modules pushed on the pipe should have a maximum packet size of at least
**PIPE_BUF**.

--------------

**NOTE:** **PIPE_BUF** is an implementation-specific constant that
specifies the maximum number of bytes that are atomic in a write to a
pipe. When writing to a pipe, write requests of **PIPE_BUF** or less
bytes are not interleaved with data from other processes doing writes on
the same pipe. However, write requests greater than **PIPE_BUF** bytes
may have data interleaved on arbitrary byte boundaries with writes by
other processes whether the **O_NONBLOCK** or **O_NDELAY** flag is set.

--------------

If the module packet size is at least the size of **PIPE_BUF**, the
Stream head packages the data in such a way that the first message is at
least **PIPE_BUF** bytes. The remaining data may be packaged into
smaller or larger blocks depending on buffer availability. If the first
module on the Stream cannot support a packet of **PIPE_BUF**, atomic
writes on the pipe cannot be guaranteed.

Closing a pipe or FIFO
----------------------

The **close** system call closes a pipe or FIFO and dismantles its
associated Streams. On the last close of one end of a pipe, an
**M_HANGUP** message is sent upstream to the other end of the pipe.
Later **read** or **getmsg** calls on that Stream head return the number
of bytes read and **0** when there is no more data. Later **write** or
**putmsg** requests will fail with **errno** set to **EIO**. If the pipe
has been mounted using **fattach**, the pipe must be unmounted before
calling **close**; otherwise, the Stream will not be dismantled. If the
other end of the pipe is mounted, the last close of the pipe will force
it to be unmounted.

--------------

/Flushing pipes and FIFOs
=========================

When the flush request is initiated from a user **ioctl** or from a
**flushq** routine, the **FLUSHR** and/or **FLUSHW** bits of an
**M_FLUSH** message have to be switched. The point of switching the bits
is the point where the **M_FLUSH** message is passed from a write queue
to a read queue. This point is also known as the midpoint of the pipe.

The midpoint of a pipe is not always easily detectable, especially if
there are numerous modules pushed on either end of the pipe. In that
case, there needs to be a mechanism to intercept all messages passing
through the Stream. If the message is an **M_FLUSH** message and it is
at the Streams midpoint, the flush bits need to switched.

This bit switching is handled by the **pipemod** module. **pipemod**
should be pushed onto a pipe or FIFO where flushing of any kind takes
place. The **pipemod** module can be pushed on either end of the pipe.
The only requirement is that it is pushed onto an end that previously
did not have modules on it. That is, **pipemod** must be the first
module pushed onto a pipe so that it is at the midpoint of the pipe
itself.

The **pipemod** module handles only **M_FLUSH** messages. All other
messages are passed on to the next module by the **putnext** utility
routine. If an **M_FLUSH** message is passed to **pipemod** and the
**FLUSHR** and **FLUSHW** bits are set, the message is not processed but
is passed to the next module by the **putnext** routine. If only the
**FLUSHR** bit is set, the **FLUSHR** bit is turned off and the
**FLUSHW** bit is set. The message is then passed to the next module by
**putnext**. Similarly, if the **FLUSHW** bit is the only bit set in the
**M_FLUSH** message, the **FLUSHW** bit is turned off and the **FLUSHR**
bit is turned on. The message is then passed to the next module on the
Stream.

The **pipemod** module can be pushed on any Stream that desires the bit
switching. It must be pushed onto a pipe or FIFO if any form of flushing
must take place.

--------------


/Named streams
==============

Some applications may want to associate a Stream or STREAMS-based pipe
with an existing node in the file system name space. For example, a
server process may create a pipe, name one end of the pipe, and allow
unrelated processes to communicate with it over that named end.

fattach
-------

A STREAMS file descriptor can be named by attaching that file descriptor
to a node in the file system name space. The routine **fattach** (see
also `fattach\ (S) <../man/html.S/fattach.S.html>`__) is used to name a
STREAMS file descriptor.
`fattach\ (S) <../man/html.S/fattach.S.html>`__. Its format is

::

   int fattach (int fildes, char *path)

where **fildes** is an open file descriptor that refers to either a
STREAMS-based pipe or a STREAMS device driver (or a pseudo device
driver), and **path** is an existing node in the file system name space
(for example, regular file, directory, character special file, and so
forth).

The **path** cannot have a Stream already attached to it. It cannot be a
mount point for a file system nor the root of a file system. A user must
be an owner of the **path** with write permission or a user with the
appropriate privileges to attach the file descriptor.

If the **path** is in use when the routine **fattach** is executed,
those processes accessing the **path** are not interrupted and any data
associated with the **path** before the call to the **fattach** routine
will continue to be accessible by those processes.

After a Stream is named, all subsequent operations (for example,
`open\ (S) <../man/html.S/open.S.html>`__) on the **path** operate on
the named Stream. Thus, it is possible that a user process has one file
descriptor pointing to the data originally associated with the **path**
and another file descriptor pointing to a named Stream.

Once the Stream has been named, the **stat** system call on **path**
shows information for the Stream. If the named Stream is a pipe, the
`stat\ (S) <../man/html.S/stat.S.html>`__ information shows that
**path** is a pipe. If the Stream is a device driver or a pseudo-device
driver, **path** appears as a device. The initial modes, permissions,
and ownership of the named Stream are taken from the attributes of the
**path**. The user can issue the system calls **chmod** and **chown** to
alter the attributes of the named Stream and not affect the original
attributes of the **path**, nor the original attributes of the STREAMS
file.

The size represented in the **stat** information reflects the number of
unread bytes of data currently at the Stream head. This size is not
necessarily the number of bytes written to the Stream.

A STREAMS-based file descriptor can be attached to many different
**path**\ s at the same time (that is, a Stream can have many names
attached to it). The modes, ownership, and permissions of these
**path**\ s may vary, but operations on any of these **path**\ s access
the same Stream.

Named Streams can have modules pushed on them, be polled, be passed as
file descriptors, and be used for any other STREAMS operation.

fdetach
-------

A named Stream can be disassociated from a file with the **fdetach**
routine (see also `fdetach\ (S) <../man/html.S/fdetach.S.html>`__),
which has the following format: 

::

   int fdetach (char *path)

where **path** is the name of the previously named Stream. Only the
owner of **path** or the user with the appropriate privileges may
disassociate the Stream from its name. The Stream may be disassociated
from its name while processes are accessing it. If these processes have
the named Stream open at the time of the **fdetach** call, the processes
do not get an error, and continue to access the Stream. However, after
the disassociation, later operations on **path** access the underlying
file rather than the named Stream.

If only one end of the pipe is named, the last close of the other end
causes the named end to be automatically detached. If the named Stream
is a device and not a pipe, the last close does not cause the Stream to
be detached.

If there is no named Stream or the user does not have access permissions
on **path** or on the named Stream, **fdetach** returns **-1** with
**errno** set to **EINVAL**. Otherwise, **fdetach** returns **0** for
success.

A Stream remains attached with or without an active server process. If a
server aborted, the only way a named Stream is cleaned up is if the
server executed a clean up routine that explicitly detached and closed
down the Stream.

If the named Stream is that of a pipe with only one end attached, clean
up occurs automatically. The named end of the pipe is forced to be
detached when the other end closes down. If there are no other
references after the pipe is detached, the Stream is deallocated and
cleaned up. Thus, a forced detach of a pipe end occurs when the server
is aborted.

If both ends of the pipe are named, the pipe remains attached even after
all processes have exited. In order for the pipe to become detached, a
server process has to explicitly invoke a program that executes the
**fdetach** routine.

To eliminate the need for the server process to invoke the program, the
**fdetach**\ (ADM) command can be used. This command accepts a pathname
that is a path to a named Stream. When the command is invoked, the
Stream is detached from the path. If the name is the only reference to
the Stream, the Stream is also deallocated.

A user invoking the **fdetach**\ (ADM) command must be an owner of the
named Stream or a user with the appropriate permissions.

isastream
---------

The function **isastream** (see also 
`isastream\ (S) <../man/html.S/isastream.S.html>`__) may be used to
determine if a file descriptor is associated with a STREAMS device. Its
format is

::

   int isastream (int fildes)

where **fildes** refers to an open file. **isastream** returns **1** if
**fildes** represents a STREAMS file, and **0** if not. On failure,
**isastream** returns **-1** with **errno** set to **EBADF**.

This function is useful for client processes communicating with a server
process over a named Stream to check whether the file has been overlaid
by a Stream before sending any data over the file.

File descriptor passing
-----------------------

Named Streams are useful for passing file descriptors between unrelated
processes. A user process can send a file descriptor to another process
by invoking the **ioctl** **I_SENDFD** on one end of a named Stream.
This sends a message containing a file pointer to the Stream head at the
other end of the pipe. Another process can retrieve that message
containing the file pointer by invoking the **ioctl** **I_RECVFD** on
the other end of the pipe.

--------------


/Unique connections
===================

With named pipes, client processes may communicate with a server process
by using a module called *connld* that enables a client process to gain
a unique, non-multiplexed connection to a server. The *connld* module
can be pushed onto the named end of the pipe. If *connld* is pushed on
the named end of the pipe and that end is opened by a client, a new pipe
is created. One file descriptor for the new pipe is passed back to a
client (named Stream) as the file descriptor from the **open** call and
the other file descriptor is passed to the server. The server and the
client may now communicate through a new pipe.

`\``Server sets up a pipe'' <_Unique_Connections.html#signals_s7>`__
illustrates a server process that has created a pipe and pushed the
*connld* module on the other end. The server then invokes the
**fattach** routine to name the other end */usr/toserv*.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/servpipe.gif

**Server sets up a pipe**

When process X (**procx**) opens */usr/toserv*, it gains a unique
connection to the server process that was at one end of the original
STREAMS-based pipe. When process Y (**procy**) does the same, it also
gains a unique connection to the server. `\``Processes X and Y open
/usr/toserv'' <_Unique_Connections.html#signals_s8>`__ shows that the
server process has access to three separate STREAMS-based pipes using
three file descriptors.

*connld* is a STREAMS-based module that has an **open**, **close**, and
**put** procedure. *connld* is opened when the module is pushed onto the
pipe for the first time and whenever the named end of the pipe is
opened. The *connld* module distinguishes between these two opens with
the **q_ptr** field of its read queue. On the first **open**, this field
is set to **1** and the routine returns without further processing. On
later **open**\ s, the field is checked for **1** or **0**. If the **1**
is present, the *connld* module creates a pipe and sends the file
descriptor to a client and a server. When the named Stream is opened,
the open routine of *connld* is called. The *connld* open fails if

-  The pipe ends cannot be created.
-  A file pointer and file descriptor cannot be allocated.
-  The Stream head cannot stream the two pipe ends.
-  A failure occurs while sending the file descriptor to the server.

The open is not complete until the server process receives the file
descriptor using the **ioctl** **I_RECVFD**.

The setting of the **O_NDELAY** or **O_NONBLOCK** flag has no affect on
the open.

The *connld* module does not process messages. All messages are passed
to the next object in the Stream. The read and write **put** routines
call **putnext** to send the message up or down the Stream.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/twoopen.gif

**Processes X and Y open /usr/toserv**

--------------


/9. Threads
============

This section introduces the Threads Library, which provides facilities
for concurrent programming. Before describing the routines included in
the Threads Library, this section first discusses concepts and
terminology of concurrent programming in general and of the Threads
Library in particular.

The Threads Library provides two classes of routines: thread management
routines and synchronization routines. The thread management routines
are discussed in `\``Basic threads management'' <PTL_ThdsMgmt.html>`__.
These include routines to create threads, terminate threads, wait for
threads, and adjust threads' scheduling characteristics. In addition,
this section discusses how signals interact with multithreaded programs,
how threads are scheduled, and the relationship between threads and
lightweight processes. The synchronization routines are discussed in
`\``Synchronizing threads'' <PTL_SynchronizThds.html>`__. This includes
an overview of the various types of locks, semaphores, barriers, and
condition variables, used to synchronize threads that are sharing data.

`\``Compilation environment'' <_Compilation_Environment.html>`__ and
`\``Tracing multithreaded programs'' <PTL_TracMulthdProgs.html>`__
discuss the compilation environment and facilities for tracing
multithreaded programs. Finally, `\``Examples'' <PTL_Exs.html>`__ gets
you started with some basic threads programs.

This discussion is not intended to replicate all the information covered
on the reference manual pages for the threads library routines. Please
refer to the manual pages referenced for details such as error returns.
The overview pages, **thread**\ (S) and **synch**\ (S) list all the
available routines.

--------------

/What is concurrent programming?
================================

Historically, most programs are examples of \``sequential programming''.
That is, they consist of a series of operations that are carried out one
at a time. With \``concurrent programming'' the programmer can specify
sets of instructions that *potentially* can be executed in parallel and
still provide correct results.

The advantages of this style of programming are: 

-  A powerful programming paradigm

   Programs are often written to emulate or respond to events in the
   real world. In the real world, concurrency is common and purely
   sequential events are the exception. Modeling such behavior is
   facilitated if the programming environment supports the notion of
   concurrency.

-  Possible performance improvement

   If multiple processors are available, the program might be executed
   in less real time (than sequential execution) if more than one
   processor is working simultaneously. This is called \``true
   concurrency''.

   Even on uniprocessor machines, there may be some performance gain
   from designing greater concurrency into the program. While one
   activity is blocked, others might still be executing.

   Thus, there is an advantage to concurrent programming even if the
   resources (processors) are not available to provide \``true
   concurrency'' and the application is only \``logically concurrent''.

Concurrent programming has been available in the UNIX System since its
inception via the \``process model''. In the UNIX System problems are
solved not just by running programs but by running sets of programs (a
running program is called a \``process'') -- sometimes pre-existing
\``tools'' or \``commands''; sometimes specifically written programs --
that work together (often concurrently) to solve the problem. Processes
can communicate and synchronize with each other by mechanisms that
include: 

-  pipes (named and unnamed)
-  files and file/record locks
-  signals
-  messages
-  shared memory (IPC style shared memory or mapped files)
-  semaphores (IPC style)

--------------

/What are threads?
==================

SCO OpenServer and UNIX System V Release 4.2 MP (SVR4.2 MP) provide
vastly expanded capabilities for concurrent programming via the Threads
Library. These capabilities include: 

-   Facilities to define multiple \``threads of control'' to be run
   concurrently within a single process. Each \``thread'' is a set of
   instructions that is itself sequential but can be executed
   concurrently with other threads.
-  A new, rich set of software mechanisms for coordinating and
   synchronizing the activities of the process' threads. These include: 

   -  mutual exclusion locks (\``mutexes''); both recursive and not;
      both blocking and spinning.
   -  reader-writer locks
   -  counting semaphores (*not* the IPC semaphore system calls)
   -  condition variables
   -  barriers

-  Features to control the level of concurrency and the scheduling of
   threads.
-  Underlying operating system kernel support that enables the library
   to provide true concurrency (on multi-processor architectures), not
   just logical concurrency for threads.

--------------

**NOTE:** The interfaces provided by the Threads Library are a semantic
superset of those specified in the *IEEE POSIX 1003.4a Extensions for
Portable Operating Systems Standard (DRAFT)*, with the exception of
mutex scheduling options.

--------------

General characteristics of threads programming: 

-  Each thread starts executing at a programmer-specified address of a
   function.

   -  A given, common function can be the starting point for several
      unique threads.

-  A thread has many features that are analogous to process features.
   For example,

   -  Each thread is an individually schedulable entity.
   -  Threads can be preempted; consequently, a thread cannot assume
      uninterrupted access to common data unless special synchronizing
      arrangements (for example, locking) are made.
   -  Threads execute logically in parallel, exhibit logical concurrency
      and possibly true concurrency.
   -  A thread will go through many states during its lifetime such as: 

      -  executing
      -  ready to run but not currently executing
      -  waiting for some resource
      -  terminated thread with unreported exit status
      -  stopped from running

   -  Threads can receive signals; consequently, asynchronous
      programming is still possible (see `\``Threads and
      signals'' <PTL_ThdsSigs.html>`__).
   -  In this implementation, most of the features of the Threads
      Library are implemented by user-level library code that is
      dynamically linked with the application program at run time. The
      underlying operating system kernel is not aware of the threads of
      a process.
   -  The operating system kernel supports a scheduling abstraction
      called the \``lightweight process'' (LWP). An LWP is not the same
      as a thread. It is a facility that is used by the Threads Library
      to provide true concurrency for threads (see `\``Managing threads
      concurrency'' <PTL_MngThdsConcurrency.html>`__).

   Each thread of the process has access to all of the resources of the
   process including: 

   -  The entire address space.

      Any thread can access any memory location in the process. By using
      threads for concurrency, the programmer sacrifices the address
      space protection that the operating system maintains (with support
      of hardware features) between processes. A wild pointer in one
      thread can easily corrupt memory used by another thread.

      On the other hand, thread-to-thread data sharing is easy and
      efficient. By default, all data is available to all threads.
      Thread-to-thread communication avoids the system call overhead and
      typical data copying of process-to-process communications.

   -  Resources maintained by the operating system, including: 

      -  Open files, file pointer offsets, file/record locks, and
         current directory.
      -  Access rights (to files, IPC facilities, and so on) and
         Enhanced Security privileges.
      -  Resource limits such as \``ulimit'', \``umask'', and file
         descriptor limit.

   -  Process identity (such as process ID number, parent process ID,
      process group number)

   The features that are unique to each thread include: 

   -  Program context (that is, register values)

   -  Stack

   -  Scheduling information (such as scheduling class, current
      priority)

   -  Timers

   -  Signal handling

      Actually, some signal handling features are maintained per thread
      and some are maintained at the process level. The relationship
      between the two (and how to use them) will be discussed later (see
      `\``Threads and signals'' <PTL_ThdsSigs.html>`__).

   -  Thread ID number and thread-private data.

   On the whole, there is a much more intimate relationship between the
   threads of a process than between processes of an application. This
   gives the programmer much greater flexibility and potentially better
   performance.

   -  With this intimacy there is a greater potential for introducing
      subtle errors and that implies a greater demand on the
      programmer's skill to produce correct code.
   -  Moreover, the proper design of a concurrent program requires
      certain disciplines that do not often arise in sequential
      programming. For example, inappropriate use of the Threads Library
      facilities for synchronizing threads may result in a program that
      is incorrect, inefficient, or both.

The facilities of the Threads Library are well-suited for medium- to
coarse-grained concurrency. It may be inappropriate to use the
facilities of the Threads Library if: 

-  the scale of concurrent tasks cannot be efficiently expressed in
   terms of a function.
-  the task to be performed concurrently is an entire program (perhaps
   an existing program). It is probably more reliable to use
   `fork\ (S) <../man/html.S/fork.S.html>`__ or
   `exec\ (S) <../man/html.S/exec.S.html>`__ (or even the shell).
-  the task to be performed concurrently is extremely small scale (loop
   level). In this case, the Threads Library may entail too much
   overhead. Parallelizing compilers exist for this scale of
   concurrency.

Threads illustrated
-------------------

`\``Overview of threads'' <_What_are_Threads.html#threads_F1>`__
illustrates the relation of threads to LWPs to processes to processors.
The terms `\``multiplexed threads'' <_Multiplexed_Threads.html>`__ and
`\``bound threads'' <_Bound_Threads.html>`__ are discussed elsewhere in
this section.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/threads.gif

**Overview of threads**

--------------

/Basic threads management
=========================

The basic operations on threads are *conceptually* similar to certain
operations on processes.

+-----------------------+-----------------------+-----------------------+
| Operation             | Process method        | Thread method         |
+=======================+=======================+=======================+
| Creation              | `fork\ (S) <../man/h  | **thr_create**\ (S)   |
|                       | tml.S/fork.S.html>`__ |                       |
|                       | `exec\ (S) <../man/h  |                       |
|                       | tml.S/exec.S.html>`__ |                       |
+-----------------------+-----------------------+-----------------------+
| Termination           | `exit\ (S) <../man/h  | **thr_exit**\ (S)     |
|                       | tml.S/exit.S.html>`__ |                       |
+-----------------------+-----------------------+-----------------------+
| Synchronization       | `wait\ (S) <../man/h  | **thr_join**\ (S)     |
|                       | tml.S/wait.S.html>`__ |                       |
+-----------------------+-----------------------+-----------------------+

--------------

/Creating a new thread
======================

In SVR4.2MP and SCO OpenServer processes are single-threaded when they
start running new programs (that is, on entry to **main**, following a
successful call to `exec\ (S) <../man/html.S/exec.S.html>`__). The
thread created to execute **main** is known as the \``initial thread''.
If no additional threads are created, a process can continue to execute
with the same semantics as the traditional UNIX process.

New threads can be created via the **thr_create**\ (S) routine

::

      int thr_create(
       void     *stack_address,
       size_t   stack_size,
       void     *(*start_routine)(void *arg),
       void     *arg,
       long     flags,
       thread_t *new_thread
      );

which takes the following parameters: 

**stack_address** and **stack_size**
   These define the stack space for the new thread. (This space is used
   for function call transactions and for automatic variables in
   functions called by the thread.)

   The stack of the traditional UNIX process has \``autogrow'' support
   by the operating system. That is, if the stack grows beyond its
   initial size the operating system automatically increases its size as
   needed (or until it runs into some other defined segment). However,
   threads (other than the initial thread) use stacks that do not have
   autogrow support; consequently, the stacks should be allocated to
   meet the maximum needs of the thread.

   As a convenience, the Threads Library will implicitly allocate a
   reasonably-sized stack (twice the page size or 16K bytes, whichever
   is greater) if **stack_address** and **stack_size** are set to
   **NULL** and **0**, respectively,

   -  The programmer can specify other sizes if needed. The value must
      not be less than that returned by **thr_minstack**\ (S). Note that
      **stack_address** should point to the base address (lowest) of the
      allocated space.
   -  In this implementation, the Threads Library manages the process
      address space so that stack overflows will result in an addressing
      error (**SIGSEGV**). For most applications, this is a desirable
      behavior. It is better to discover such errors as soon as they
      occur rather than have one stack corrupt another.

**start_routine** and **arg**
   These parameters define the starting condition of the newly created
   thread. **start_routine** is the function address where the new
   thread's execution will begin and **arg** is the argument that
   **start_routine** will receive.

   **start_routine** takes a single parameter of type **(void \*)** and
   returns a value of the same type. These values can be used (with type
   casts) to pass values (or aggregations of values in structures) of
   any type.

   --------------

   **NOTE:** For portability, do *not* cast an **int** to **(void \*)**,
   and then cast it back to **int**. These values should only be used as
   pointers; otherwise, information can be lost.

   --------------

   Of course, a thread need not be entirely defined by a single
   function. That initial function will typically call other functions.

**flags**
   These flags will be discussed as their respective topics arise later
   in this section. These flags are not mutually exclusive; they can be
   combined with a bitwise inclusive OR. For each flag, the relevant
   section is shown: 

   **THR_SUSPENDED**
      `\``Managing thread scheduling'' <PTL_MngThdSchedul.html>`__
   **THR_BOUND**
      `\``Managing threads
      concurrency'' <PTL_MngThdsConcurrency.html>`__
   **THR_DETACHED**
      `\``Waiting for thread termination'' <PTL_WaitThdTerm.html>`__
   **THR_INCR_CONC**
      `\``Managing threads
      concurrency'' <PTL_MngThdsConcurrency.html>`__
   **THR_DAEMON**
      `\``Terminating a thread'' <PTL_TerminatThd.html>`__
**new_thread**
   The \``thread ID'' of the newly created thread is delivered at this
   address.

   -  This value can be used in other functions to influence that
      thread.
   -  The scope of the value is limited to the enclosing process; it is
      not relevant to threads in other processes.
   -   A thread can learn its own thread ID number by the
      **thr_self**\ (S) function.

--------------

**NOTE:** **thr_create**\ (S) and most other functions in the Threads
Library return **0** on success. On failure, instead of setting the
**errno** global variable, they *return* the error code as the
function's value.

--------------

The creation of one thread by another is conceptually similar but not
identical to the creation of a new process by another process via the
`fork\ (S) <../man/html.S/fork.S.html>`__ system call. Some differences
are: 

-   After a `fork\ (S) <../man/html.S/fork.S.html>`__ system call both
   the creator (parent) and created (child) processes resume from the
   same point of computation -- the return from
   `fork\ (S) <../man/html.S/fork.S.html>`__.

   In contrast, a new thread starts execution at the **start_function**
   specified by the creator (in some respects similar to the
   `exec\ (S) <../man/html.S/exec.S.html>`__ system call), while the
   creating thread returns from **thr_create**\ (S).

-  The operating system maintains a parent/child relationship between
   creating and created processes that affects later interactions at
   process termination (for example,
   `wait\ (S) <../man/html.S/wait.S.html>`__ semantics). In contrast,
   there is no innate hierarchy among threads. Each is a \``sibling'' of
   the other. Thus, the creator might wait for the newly created thread
   to terminate or, just as easily, the new thread can wait for its
   creator to terminate. {See discussion of **thr_join**\ (S) below.)

--------------

/Terminating a thread
=====================

A thread can terminate itself by using the **thr_exit**\ (S) function

::

      void thr_exit(
       void *status
      );

where

**status**
   is the address returned to another thread that has called
   **thr_join**\ (S).

The call to **thr_exit**\ (S) initiates automatic clean-up for thread
resources: 

-  Recovery of stack allocated by the Threads Library (see above).

   --------------

   **NOTE:** The stack for a non-detached thread will not be recovered
   until after another thread calls **thr_join** to obtain the
   **status** for the thread, which is stored on the stack. Likewise, an
   explicitly-allocated stack should not be recovered until after
   another thread calls **thr_join**.

   --------------

-   Invocation of the \``destructor'' function for each \``key value''
   that the thread has used (see `\``Thread-specific
   data'' <PTL_Thd-SpecificData.html>`__).

The Threads Library arranges for a simple return from the
**start_routine** to be equivalent to a call to **thr_exit**\ (S)
(except for the initial thread, see `\``Termination of the
process'' <PTL_TerminatThd.html#PTL_TermProc>`__).

The **thr_exit**\ (S) function allows one thread to return a value
called **status** to another; however, this mechanism is more general
than the exit status returned by a child process to its parent. The
argument to `exit\ (S) <../man/html.S/exit.S.html>`__ is limited to a
small range of integers. The **status** returned by **thr_exit**\ (S) is
a general pointer that can be used (with type casts) to direct the
receiver to objects of greater complexity such as structures, arrays,
and linked lists. Of course, both the terminating and receiving threads
should be coded to employ the same convention.

Termination of the process
--------------------------

There are three ways to terminate a threads process.

-  The termination of the last \``non-daemon thread'' of the process
   will terminate the process (with **status** used as
   `exit\ (S) <../man/html.S/exit.S.html>`__ status to the parent
   process). The Threads Library categorizes a thread as either a
   \``daemon thread'' or a \``non-daemon thread''. In practice, daemon
   threads are used to provide services for other threads. Although they
   can terminate themselves or be terminated, there is no need to do so.
   By being distinguished as daemons, they will be implicitly terminated
   when there are no other threads (non-daemons) that might need their
   services.

   A thread is categorized as a daemon thread at the time of its
   creation by use of the **THR_DAEMON** flag to **thr_create**\ (S).

-  There are some special semantics for the initial thread. If the
   initial thread executes a **return** statement or if it implicitly
   returns from **main**, the process will be terminated. However, a
   **thr_exit**\ (S) by the initial thread will terminate only the
   initial thread. The process continues to execute as long as there are
   other non-daemon threads.

-  Finally, any thread can terminate the process by calling the
   `exit\ (S) <../man/html.S/exit.S.html>`__ system call.

--------------

/Waiting for thread termination
===============================

One thread can suspend itself to wait for the termination of another
thread with the **thr_join**\ (S) function

::

      int thr_join(
       thread_t wait_for,
       thread_t *departed,
       void     **status
      );

where the parameters have the following meaning: 

**wait_for**
   The ID of the thread of interest, that is, the non-detached thread
   whose termination the caller will await. A **(thread_t)0** indicates
   interest in the next non-detached thread to terminate (or one that
   has already terminated, but has not been joined), whatever its ID
   happens to be.
**departed**
   **thr_join**\ (S) will deposit the thread ID of the terminated thread
   at this address.
**status**
   **thr_join**\ (S) will deposit at this address the value given as an
   argument by the terminated thread when it called **thr_exit**\ (S).
   That value should be the address at which the terminated thread left
   its return value (exit status).

If the thread of interest has already terminated, **thr_join**\ (S) will
return immediately; otherwise, the calling thread will block.

If there is more than one thread waiting for the termination of some
particular thread: 

-  The thread of interest will be joined to only one of the waiting
   threads. The choice is not predictable.
-  All other waiting threads will return with the **ESRCH** error code.

If a thread receives a catchable signal while blocked in 
**thr_join**\ (S): 

-  The signal is handled.
-   The **thr_join**\ (S) function is transparently restarted.

   --------------

   **NOTE:** This is analogous to the \``autorestart option'' for
   blocking system calls. (See the description of the **SA_RESTART**
   flag for the `sigaction\ (S) <../man/html.S/sigaction.S.html>`__
   system call.)

   --------------

The resources of a non-detached thread (for example, a stack allocated
by the Threads Library) will not be fully recovered by the Threads
Library until some other thread has called **thr_join**\ (S) and
received the terminated thread's exit status.

--------------

**NOTE:** Beware of lingering zombies! Failing to recover the memory and
resources associated with terminated threads can have a negative impact
on performance.

--------------

Detached threads
----------------

If the programmer knows at thread creation time that no other thread
will use **thr_join**\ (S) to wait for the new thread, the
**THR_DETACHED** flag to **thr_create**\ (S) should be used. When a
\``detached thread'' terminates, its resources may be recovered
immediately. In fact, it is not valid to use **thr_join**\ (S) on a
detached thread.

By default, new threads are not detached threads.

--------------

/Thread-specific data
=====================

Historically, programs have used the **static** or **extern** storage
classes to save data that must be preserved between function calls. This
practice is no longer valid when many threads in the same process may
run a given function concurrently and reference one **static** or
**extern** variable by name. Values will not be preserved across
function calls if one thread modifies a value left by another.

--------------

**NOTE:** In contrast, since each thread gets a unique stack, variables
of the **auto** storage class are implicitly unique.

--------------

The facility for \``thread-specific'' data provides a solution to this
problem.

-   Data can be stored and retrieved by a \``key'' value.
-  The same key value can be used to store data by many threads.
-  *Implicit* in the access functions **[**\ (thr_setspecific)S and
   **thr_getspecific**\ (S)] is a disambiguation of the key by the
   thread ID.
-  Thus, the key is a \``virtual variable name'' that will resolve to
   the correct data for the calling thread.

   --------------

   **NOTE:** Analogously, the file name */dev/tty* can be used by any
   process to access its particular controlling terminal.

   --------------

-  The data is specific to each thread but, as with any other part of
   the process address space, the data is not protected from access or
   change by other threads.

The access functions have the following syntax: 

::

      int  thr_setspecific(thread_key_t key, void *data);
      int  thr_getspecific(thread_key_t key; void **value);

A key value must be created by the **thr_keycreate**\ (S) function

::

      int thr_keycreate(
       thread_key_t *key,
       void         (*destructor)(void *data)
      );

where

**key**
   This is the address where the newly valid key value will be
   deposited.
**destructor**
   specifies a function that will be called on the exit of any thread
   that has used the key for data storage. This function should recover
   any space that has been used to store thread-specific data. When
   called, this function receives one argument, the **data** address
   that the thread gave as the second argument to
   **thr_setspecific**\ (S).

--------------

**NOTE:** The key can be created (or later removed) by threads other
than those that use the key for data storage. The using threads need
only have access to the key value by function argument, global variable,
or other means.

--------------

If a particular key value is needed for only a particular phase of a
program (perhaps initialization) it can be deallocated by
**thr_keydelete**\ (S).

For efficiency, it is best to minimize the number of keys used in an
application.

--------------

/Threads and signals
====================

When a process receives a signal of some type (for example, **SIGINT**
type) the process can either take the default response, ignore the
signal (the kernel does not actually deliver the signal), or catch the
signal. When the signal is caught, the system will call a handler
function when the signal is delivered. This response is called the
\``disposition'' for the signal type. In SVR4.2MP and SCO OpenServer,
that disposition is common to all of the threads of a process.

If the disposition for a signal type is

termination
   Such signals will terminate all threads, and the process will
   terminate.
ignore
   Such signals will be ignored by all threads.
catch
   Any thread responding to such signals will enter the same handler
   function.

Moreover, if any thread changes the disposition (say by calling
`sigaction\ (S) <../man/html.S/sigaction.S.html>`__) the new disposition
is in effect for all threads.

--------------

**NOTE:** System signal types **SIGLWP** and **SIGWAITING** are used
internally by the Threads Library. The Threads Library prevents
modification of the disposition or masking of those signal types.

--------------

On the other hand, \``signal masks'' (the set of signal types being
blocked) are maintained per thread. Signal masking for threads behaves
identically to the traditional signal masking for processes. If the
disposition for a particular signal type is not \``ignore'' and the
signal is not masked for a thread targeted to receive that signal, the
signal will be delivered and the appropriate action will be taken by the
thread. If the disposition is not \``ignore'' but the signal is masked
by a thread targeted to receive that signal, the signal will be made
\``pending'' for the thread; this means that the thread will not take
the appropriate action until it unmasks that signal. If the disposition
of the signal is \``ignore,'' the signal is neither made pending nor
delivered, regardless of the thread's signal mask.

A thread inherits the signal mask of its creating thread. A thread can
alter its mask with the **thr_sigsetmask**\ (S) routine.

::

      int thr_sigsetmask(
       int          how,
       const sigset_t *set,
             sigset_t *oset
      );

--------------

**NOTE:** The syntax of **thr_sigsetmask**\ (S) is nearly identical to
that of the `sigprocmask\ (S) <../man/html.S/sigprocmask.S.html>`__
system call.

--------------

Signals can be categorized as being asynchronously generated or
synchronously generated. A \``synchronously-generated signal'' is one
that arises from the action of a particular thread or process. For
example, alarm signals, signals resulting from an illegal memory
reference, and signals resulting from an illegal arithmetic operation
are all synchronously-generated signals. An
\``asynchronously-generated'' signal is one that is sent from outside
the thread (or process); its delivery is unpredictable. Interruptions
and termination signals are usually an asynchronously generated.

Asynchronously-generated signals
--------------------------------

When a signal is delivered to a process, if it is being caught, it will
be handled by one, and only one, of the threads meeting either of the
following conditions: 

#.  A thread blocked in a **sigwait**\ (S) system call whose argument
   *does* include the type of the caught signal.
#. A thread whose signal mask *does not* include the type of the caught
   signal.

Additional considerations: 

-  A thread blocked in **sigwait**\ (S) is given preference over a
   thread not blocking the signal type.
-  If more than one thread meets these requirements (perhaps two threads
   are calling **sigwait**\ (S)), then one of them will be chosen. This
   choice is not predictable by application programs.
-  If no thread is eligible, the signal will remain \``pending'' at the
   process level until some thread becomes eligible.

Asynchronously-generated signals -- paradigm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One useful paradigm for managing signals originating outside of the
process is to have *all* threads include the caught signals in their
signal mask and specifically create one daemon thread to handle the
signals. If that thread uses the **sigwait**\ (S) system call, the
signals can be handled in a synchronous style.

::

      thr_sigsetmask(mask);
      while( (signo = sigwait(mask)) > 0){
       handle signal type signo
      }

Note that it is not only valid to wait for masked signals with
**sigwait**, but it is important to mask out the signal types of
interest before calling **sigwait**. Otherwise, the arrival of one such
signal between calls to **sigwait** will be handled according to the
current process disposition. By default, that will terminate the entire
process. **sigwait** effectively unmasks any masked signals while
blocked, then masks them again before returning.

Even if a handler function is specified, it will not be executed if a
signal is delivered to a thread blocked in **sigwait**; **sigwait**
bypasses any handler.

Since all threads are masking out the same set of signals, one can
predict that the signals in that set will be handled by the single
thread using **sigwait**. This paradigm is advantageous because: 

-  It reduces the complexity of the program.
-  Only one thread need allocate stack space for signal handling. If
   there are several eligible threads, each must have sufficient stack
   for the handler.

   --------------

   **NOTE:** Alternate signal handling stacks (see
   `sigaltstack\ (S) <../man/html.S/sigaltstack.S.html>`__) are not
   supported by the Threads Library.

   --------------

-  Signals are handled in a synchronous style, which is usually easier
   to write and understand than an asynchronous style.

--------------

**NOTE:** The thread that handles the signals should be a \``bound''
thread. Bound threads are introduced in `\``Managing threads
concurrency'' <PTL_MngThdsConcurrency.html>`__.

--------------

Synchronously-generated signals
-------------------------------

A caught, non-masked signal that is caused by a particular thread will
be handled by that thread. Examples include: 

-  Signals arising from an invalid memory reference or illegal
   arithmetic operation. This allows the offending thread to correct its
   error.

-  Alarm or timer signals requested by the thread.

   The Threads Library arranges for such signals to always be delivered
   to the requesting thread even if that (\``multiplexed'') thread is no
   longer held by the same LWP as at the time of the request.

   --------------

   **NOTE:** Multiplexed threads are formally introduced in `\``Managing
   threads concurrency'' <PTL_MngThdsConcurrency.html>`__.

   --------------

Each thread will use the common handler function.

Thread-to-thread signaling
--------------------------

One thread can signal another thread with the **thr_kill**\ (S)
function: 

::

      int thr_kill(
       thread_t tid,
       int      signo
      );

where

**tid**
   The thread ID of the target thread.
**signo**
   The type of signal to send.

A thread catching a signal cannot distinguish between a signal
originating from another thread of the process or from outside of the
process.

The process disposition for the sent signal type (**signo**) is also
applied for thread-to-thread signaling. As usual, the response will be
to ignore the signal, to call the handler function, or to take the
default response (usually, process termination).

This facility allows one thread to influence (perhaps \``reset'' or
terminate) another thread asynchronously.

--------------


/Lightweight processes and threads concurrency level
====================================================

The SVR4.2MP and SCO OpenServer operating system kernel is not aware of
the multithreading of any process using the Threads Library. The kernel
supports an entity known as a \``lightweight process'' (LWP).

-  There may be many LWPs associated with a single process.
-  Each LWP of a process shares the process address space with its
   \``sibling'' LWPs.
-  Each LWP has its own scheduling context.
-  On multiprocessor machines, several LWPs of a process might be
   running on different processors simultaneously (true concurrency).
-  Each LWP has access to all of the resources of the process such as
   open file descriptors, access rights and privileges, and resource
   limits.

Many of these are features of threads as well. This is no coincidence.
Threads have many of these features because a thread only executes once
it has been \``picked up'' by an LWP. However, a process typically has
more threads than LWPs.

Conceptually, an LWP is a dearer resource than a thread. The Threads
Library will typically maintain a pool of LWPs that are shared by the
set of runnable threads in a process.

--------------

**NOTE:** Analogously, the operating system arranges for the sharing of
a relatively small number of (hardware) processors among a much greater
number of processes or LWPs.

--------------

--------------

/Multiplexed threads
====================

The Threads Library \``multiplexes'' threads among the pool of available
LWPs for the process.

-  An LWP can pick up and run only one thread at a time.
-  After a time the LWP will \``put down'' (stop running) its current
   thread and pick up another.
-  Some time later the thread will be picked up again; not necessarily
   by the previous LWP.
-  The algorithm by which a thread is associated with an LWP and later
   preempted is covered in `\``Multiplexed thread
   scheduling'' <PTL_MultxedThdSchedul.html>`__.
-  On multiprocessor systems, a larger number of LWPs implies a greater
   *chance* that different threads of the process will be executed
   simultaneously (that is, true, not logical concurrency).

--------------

/Managing threads concurrency
=============================

The size of the pool of available LWPs (the \``actual concurrency
level'') will vary over time. The Threads Library manages the size of
this pool automatically and dynamically according to rules outlined
below. The programmer can influence the algorithm by changing the
\``requested concurrency level'' (with **thr_setconcurrency**, see
below); at times, the actual concurrency level may be either greater
than or less than the requested level.

The rules governing implicit changes to the actual concurrency level
are: 

-  Initially, for each program, there is a single LWP available for
   execution of threads.
-  The size of the pool is incremented when a thread is created with the
   **THR_INCR_CONC** flag to **thr_create**\ (S).

   --------------

   **NOTE:** The newly created thread is not necessarily picked up by
   that newly created LWP.

   --------------

-  If all of the LWPs of a process are blocked in system calls, then the
   process cannot execute any threads. However, the kernel sends a
   **SIGWAITING** type signal to the process when this condition occurs.
   Additional LWPs are created if there are additional runnable threads.
-  The number of LWPs should not exceed the number of threads -- at
   least not for long -- that would be wasteful. An LWP that remains
   unassigned to a thread for a certain time (5 minutes) is said to have
   \``aged'' and will be terminated [**\_lwp_exit**\ (S)]. Aging will
   terminate LWPs until the size of the pool equals the lesser of

   -  requested level of concurrency
   -  number of active (running or runnable) threads

   Thus, if there are few threads, the actual number of LWPs may be less
   than the requested level.

A thread can use the **thr_setconcurrency**\ (S) function to change the
requested concurrency level mentioned in the algorithm above. The syntax
is: 

::

      int thr_setconcurrency(
       int new_level
      );

This request is serviced asynchronously.

The rules governing the explicit changes in actual concurrency by
**thr_setconcurrency**\ (S) are: 

-  When the level is increased, the number of LWPs is increased.

   One implication is that certain errors (for example, **EAGAIN** --
   system limit on LWPs per user exceeded) may not be reported because
   they occur after **thr_setconcurrency** returns.

-  A request to lower the level of concurrency does not have an
   immediate effect: no LWP is terminated, nor is any thread preempted.
   Instead, the actual level of concurrency becomes lower by the LWP
   aging described above.

-  Setting **new_level** to **0** requests the default level of
   concurrency.

-  The programmer can retrieve the current value of the requested level
   of concurrency with the **thr_getconcurrency**\ (S) function.

-  There is no mechanism to return the current, actual level of
   concurrency.

--------------

/Bound threads
==============

A thread may become runnable at a time when all LWPs of the process are
already executing threads. That thread will be made runnable and
enqueued until an LWP becomes available. This implies some latency (time
lag) between thread awakening and execution. There may be circumstances
where this behavior is not acceptable. (Perhaps the thread must respond
to a signal in a timely manner.)

If a thread is created with the **THR_BOUND** flag to 
**thr_create**\ (S) then

-  Both a thread and a new LWP are created.
-  The new LWP picks up the new thread.
-  That association remains in effect for the life of the thread.
-  Such threads are called \``bound threads''.
-  When the thread terminates, the LWP also terminates.

Bound threads are not counted in the algorithm that manages the level of
concurrency.

--------------

**NOTE:** Bound threads are not guaranteed to gain processor time
whenever they are ready to execute; the LWP on which a bound thread runs
must be scheduled to run on a processor by the system scheduler (see
`\``Bound thread scheduling'' <PTL_BoundThdSchedul.html>`__).

--------------

--------------


/Thread scheduling
==================

Thread scheduling governs the competition among threads for various
system resources.

-  Multiplexed threads vie for a limited number of LWPs.

   -  Bound threads are spared this competition; each maintains its
      association with its LWP for its lifetime.

-  LWPs are, in turn, assigned by the kernel to a limited number of
   (hardware) processors for execution.

-  To coordinate their activities, threads often make use of various
   synchronization mechanisms. At times there may be more than one
   thread waiting for a given event (for example, the unlocking of a
   semaphore). The Threads Library must decide which thread will receive
   the resource.

   This last category of thread scheduling will be covered in
   `\``Synchronizing threads'' <PTL_SynchronizThds.html>`__.

--------------


/Multiplexed thread scheduling
==============================

Multiplexed threads are subjected to two levels of scheduling: 

-  Threads Library Scheduling: The Threads Library scheduler assigns
   multiplexed threads to LWPs for execution and, at times, preempts
   them so the LWP can pick up another thread.
-  System Scheduling: The kernel assigns LWPs to (hardware) processors
   and later preempts them.

The Threads Library maintains a \``priority level'' for each multiplexed
thread. This value plays a role in the selection of a thread for
assignment to an LWP. The priority value of a multiplexed thread can be
modified by any other thread in the process via the **thr_setprio**\ (S)
function.

::

      int thr_setprio(
       thread_t tid,
       int      prio
      );

Runnable, multiplexed threads are scheduled for execution as follows: 

-  A thread with a higher priority value will be scheduled to run before
   a thread with a lower value.
-  Threads with the same priority will be scheduled on a first-come,
   first-serve basis.
-  The valid range of priorities is **0** to **MAXINT-1**; however, the
   Threads Library is optimized for a maximum priority of **126** (or
   less).

The Threads Library must select a thread for assignment to an LWP on the
following occasions: 

-  When an LWP becomes available, the highest priority runnable
   multiplexed thread will be assigned to it.

   For example, an LWP becomes available when a thread exits, or when a
   multiplexed thread blocks on a thread synchronization mechanism
   (discussed later), or when the concurrency level is increased.

-  When a multiplexed thread becomes runnable (perhaps a mutex has been
   released by one thread and acquired by another), it will preempt a
   running multiplexed thread of a lower priority.

-   When an executing thread calls **thr_yield**\ (S), it deliberately
   surrenders its LWP to a runnable thread of equal or higher priority
   (if any).

Threads Library scheduling and system scheduling are independent of each
other.

-  The Threads Library can assign a thread to an LWP but cannot say when
   that LWP will actually execute.
-  The kernel is unaware that the Threads Library is using LWPs to
   implement (user-level) threads. The kernel maintains its own
   scheduling context (for example, current priority, \``nice value'',
   priority class) that is separate from similar features that the
   Threads Library maintains for threads.

The interaction of these two levels of scheduling can produce some
interesting effects: 

-  LWPs of the time-sharing priority class will have their kernel
   priority adjusted dynamically according to processor usage and other
   factors.

   --------------

   **NOTE:** See the **priocntl**\ (S) manual page for further details
   of the time-sharing priority class. Note that using the
   **priocntl**\ (S) system call directly from a multiplexed thread
   should be avoided because it may interfere with thread scheduling by
   the Threads Library.

   --------------

   Consequently, a thread picked up by an LWP may run with a kernel
   priority determined by the activity of the *prior* thread on that
   LWP.

-  It is possible for a thread of high priority from the point of view
   of the Threads Library to be picked up by an LWP of relatively low
   priority to the kernel.

Additional points to consider: 

-  A thread that is blocked in a system call will remain with its LWP
   until that system call returns.
-  Each LWP in the pool used for multiplexed LWPs is of the same kernel
   scheduling class (that is, time-sharing or fixed priority). That
   class is determined by the scheduling class (that is, time-sharing or
   fixed priority) of the LWP running the initial thread of the program.
-  One step in associating a thread with an LWP is to make the signal
   mask of the LWP agree with that of the thread. On each thread context
   switch there is a check for agreement. If the mask of the new thread
   differs from that of the prior thread, there is a system call to
   update the mask of the LWP. One implication of this is that using
   threads with a wide variety of signal masks can add to the cost of
   switching threads.

--------------

/Bound thread scheduling
========================

The semantics of bound thread scheduling differs considerably from that
for multiplexed threads.

-  Bound threads are permanently attached to their LWPs; consequently,
   they are exempt from that level of scheduling by the Threads Library.

-   The Threads Library supports the concept of \``scheduling policy''
   as well as \``priority level'' for bound threads. When the programmer
   specifies these characteristics, the Threads Library applies them to
   the LWP holding the thread. See **priocntl**\ (S) for more
   information.

   These characteristics can be modified with the
   **thr_setscheduler**\ (S) function.

-  The available scheduling policies for bound threads are: 

   **SCHED_TS** or **SCHED_OTHER**
      The two values are synonymous. The bound thread is run by an LWP
      of the kernel time-sharing scheduling class.

      --------------

      **NOTE:** Technically, multiplexed threads are also categorized as
      having the **SCHED_TS** policy even though they are not
      necessarily run by LWPs in the kernel time sharing class. The
      Threads Library algorithm for scheduling multiplexed threads
      (round robin) bears a closer resemblance to the kernel's fixed
      priority class than the kernel's time sharing class.

      --------------
   **SCHED_FIFO** or **SCHED_RR**
      The thread will be run on an LWP of the fixed-priority scheduling
      class. **SCHED_FIFO** means that the LWP will have an infinite
      time quantum (not preempted) whereas **SCHED_RR** (round-robin)
      uses a fixed priority with a finite time slice.

      The **SCHED_FIFO** and **SCHED_RR** policies can be used only by
      bound threads.

      --------------

      **NOTE:** Appropriate privilege is required to set the policy of a
      thread to **SCHED_FIFO** or **SCHED_RR**. See **priocntl**\ (S).

      --------------

-  When an executing bound thread calls **thr_yield**\ (S), it
   deliberately surrenders the processor to another LWP if one is
   available to run on that processor.

A bound thread with real-time constraints can further improve response
time by using **processor_bind**\ (S) to bind its LWP to a processor. It
can use **\_lwp_self**\ (S) to find the ID of the LWP to which it is
bound, and pass that as an argument to **processor_bind**.

--------------

**NOTE:** Multiplexed threads should not use **processor_bind**.

--------------

--------------


/Managing thread scheduling
===========================

The initial thread of a newly executing program (a process returning
from `exec\ (S) <../man/html.S/exec.S.html>`__) is always a multiplexed
thread running under the **SCHED_TS** policy. The scheduling
characteristics of new threads are generally derived from the creator
thread. (There are some interesting variations when a bound thread
creates a multiplexed thread and **vice versa**. See the
**thr_create**\ (S) manual page for details.)

To create a thread with different scheduling characteristics the
programmer can: 

#.  Create a new thread with **thr_create**\ (S) using the
   **THR_SUSPENDED** flag. This will create a new thread but not allow
   it to execute.
#. Use the returned thread ID to change the characteristics of the new
   thread with the **thr_setprio**\ (S) or **thr_setscheduler**\ (S)
   functions.
#.  Use the **thr_continue**\ (S) function to make the new thread
   runnable.

Alternatively, a thread can use **thr_setscheduler**\ (S) or
**thr_setprio**\ (S) to modify its own scheduling class or priority.

--------------

/Synchronizing threads
======================

In general, each thread must take special care in using resources that
might be concurrently used by another thread.

--------------

**NOTE:** The definition of \``resource'' will vary with applications.
Typically, \``resources'' are manifested as some organization of data
relevant to the application in process memory (perhaps a linked list or
other data structure) or in files.

--------------

Unless their actions are synchronized, threads may encounter logically
inconsistent linked lists or partially updated structures in common
process memory. Synchronization may also be needed for concurrent
actions on commonly held external resources such as file descriptors and
message queues.

-  There is no automatic, implicit mechanism to protect each thread from
   the actions of other threads. The correctness of a multithreaded
   program must be incorporated into the design by having each thread
   cooperate with the others.
-  The Threads Library provides a suite of functions with several
   categories of synchronization semantics. The categories are: 

   -  Locks
   -  Semaphores
   -  Barriers
   -  Condition Variables

   Most of these categories contain several variants.
-  The programmer has the responsibility to: 

   -  use the correct number and type of synchronization mechanism(s)
   -  use them where needed
   -  enforce synchronization on *every* thread using the common
      resource
   -   avoid deadlock and starvation conditions

-  Other than programmer discipline, there is nothing to stop any thread
   from using common resources without obeying the synchronization
   protocol being used by the others.
-  The general procedure for using these mechanisms is: 

   1. Allocate a synchronization data structure for the resource to be
      protected (for example, to use a mutual exclusion lock, allocate a
      structure of type **mutex_t**). The address of that structure
      becomes an argument for all subsequent operations on this instance
      of the mechanism.
   2. Initialize the mechanism.
   3. Use the mechanism.
   4. Deallocate the mechanism when it is no longer needed -- perhaps
      when the resource being protected is deallocated.

--------------

/Locks
======

The semantics of a \``lock'' allow the resource to be used by only one
thread at a time. The Threads Library supports several types of locks: 

-  mutual exclusion locks (\``mutexes'')
-  spin locks
-  recursive mutual exclusion locks (\``rmutexes'')
-  reader-writer locks (these allow non-exclusive access for readers)

A thread that successfully locks a resource is said to \``hold the
lock'' or to \``have acquired the lock''. Unlocking is also known as
\``releasing the lock''.

--------------

/Mutual exclusion locks
=======================

A \``mutual exclusion lock'', or \``mutex'', allows only one thread at
any time to access the resource being protected. The lock is acquired by
the **mutex_lock**\ (S) function.

::

      int mutex_lock(
       mutex_t *mutex
      );

If the lock is already held by some other thread, the calling thread
will block in **mutex_lock**\ (S).

When the thread holding the lock calls **mutex_unlock**\ (S), some
waiting thread (if any) will be made runnable.

::

      int mutex_unlock(
       mutex_t *mutex
      );

The Threads Library does not enforce any notion of ownership of a lock
by a thread. The thread unlocking a mutex need not be the same thread
that locked the mutex.

--------------

/Spin locks
===========

A spin lock is also used for mutually exclusive access to some resource.
The **\_spin_lock**\ (S) function differs from **mutex_lock**\ (S) in
implementation. If a spin lock is not available, the calling thread is
not blocked, instead the caller busy waits (or \``spin''s) until the
lock becomes available.

::

      _spin_lock(  spin_t *lock);
      _spin_unlock(spin_t *lock);

Considerations for the use of spin locks: 

-  The busy waiting prevents the LWP from being used by another thread.
-  This facility is intended for use when the delay is expected to be
   smaller than the time to context switch to another thread and back.
-  Use of this facility is not recommended on uniprocessor machines or
   if only one processor of a multiprocessor machine might be available.
   In those circumstances the spinning thread prevents the possible
   execution of the thread that is holding the lock, thereby delaying,
   possibly deadlocking, itself.

--------------

**NOTE:** Extreme care should be exercised in using spin locks. The
minimally safe environment for using spin locks may be bound threads
running on a system with more than one processor. However, deadlocks are
always possible.

--------------

--------------

/Recursive mutual exclusion
===========================

The regular mutex lock (shown earlier) will deadlock the calling thread
on attempts to re-lock a lock that it already holds. A recursive
mutually exclusive lock (recursive mutex or rmutex) allows the holder of
a lock to re-lock without deadlock; other threads will block normally.

::

      int rmutex_lock(  rmutex_t *rmutex);
      int rmutex_unlock(rmutex_t *rmutex);

Considerations for the use of recursive mutex locks: 

-  The holder must unlock the lock for each time it was locked.
-  This facility is useful for

   -  The implementation of recursive algorithms.
   -  Situations where the code locking a resource cannot know which
      locks have already been acquired. This may arise in the
      implementation of library functions where generally the activities
      of the callers are not known.

-  Recursive mutexes only prevent deadlock of a thread with itself for a
   single resource. It is still possible for a thread to become
   deadlocked even with recursive mutexes. Two (or more) threads can
   deadlock by each acquiring multiple locks in an unfortunate order.
-  Recursive mutexes provide exclusivity but they sacrifice
   \``atomicity''. A resource protected by an rmutex will be used by
   only one thread at a time; however, that use must be designed to be
   reentrant because that thread might reacquire the resource in the
   midst of using it.

--------------

/Reader-writer locks
====================

Whereas the locks for mutual exclusion allow only one thread to use a
resource at a time, the reader-writer facility supports a more
complicated model of resource use. This facility allows for mutual
exclusion of a resource for certain operations (typically, write
operations); for other operations (typically, read operations)
simultaneous access to the resource need not be denied to multiple
threads.

Such locks can be held in either \``read mode'' (a read lock) or
\``write mode'' (a write lock).

-  In read mode, there is no limit on the number of threads using the
   resource. By convention, each thread with such a lock assumes that
   the resource is stable while the lock is held. That assumption is
   reasonable provided no thread will modify the resource until it
   acquires a write lock and that is not possible while at least one
   read lock is being held. As usual, these assumptions are not enforced
   by any mechanism other than programming discipline.

-  | In practice, a lock held in read mode should bar only writers while
     a lock held in write mode should bar all readers and all other
     writers. Read and
   | write locks are acquired by the **rw_rdlock**\ (S) and
     **rw_wrlock**\ (S) functions, respectively.

   ::

         int rw_rdlock(rwlock_t *rwlock);
         int rw_wrlock(rwlock_t *rwlock);

   If one or more threads are blocked waiting to acquire the lock in
   write mode, then any threads subsequently attempting to acquire the
   lock in read mode will be blocked to wait for the writer. This
   prevents a sequence of readers from indefinitely blocking a waiting
   writer.

-  The order of access is strictly first-in-first-out (FIFO). This
   ordering is obeyed even if the readers have higher priority than the
   writer. This is an exception to the algorithm used to awaken threads
   by the other thread synchronization mechanisms (see `\``Further
   considerations for synchronization
   mechanisms'' <PTL_SyncMechs.html>`__).

-  It is not possible to promote in place a read lock to a write lock.
   The read lock must be released and a write lock acquired in a
   separate operation.

--------------


/Semaphores
===========

Semaphores are a facility well-suited to managing the allocation and
deallocation of identical resources.

-  The semaphore can be initialized to the number of resources.

-  A thread needing a resource should atomically decrement the
   associated semaphore with the **sema_wait**\ (S) function.

-  If the resource is not available (semaphore count non-positive) the
   caller will block in **sema_wait**\ (S) until one becomes available.

   ::

         int sema_wait(
          sema_t *sema
         );

-  When a resource is no longer in use, the thread releasing the
   resource should increment the associated semaphore with the
   **sema_post**\ (S) function.

   ::

         int sema_post(
          sema_t *sema
         );

-  If any threads are blocked on that semaphore, the call to
   **sema_post** will make one runnable so that it can (implicitly)
   decrement the semaphore and return from **sema_wait**\ (S).

Additional considerations: 

-  This mechanism lacks the following features of the IPC style
   semaphore facility: 

   -  Increment/decrement by values greater than **1**.
   -  Operations on semaphore sets.
   -  The ability to, \``block while count is non-zero'' instead of the
      usual rule, \``block only when count is zero.''
   -  The ability to automatically release semaphores on termination
      (**SEM_UNDO** flag).

-  A semaphore initialized to **1** is almost equivalent to a mutex. In
   such cases, use the mutex facilities; they are more efficient, having
   been optimized for that case.
-  The **sema_post**\ (S) function can validly be used to increase a
   semaphore count above that defined by **sema_init**\ (S).

--------------

/Barriers
=========

In a sense, a barrier is the logical inverse of a lock. Whereas a lock
allows only one thread at a time to proceed (to use a resource), a
barrier allows no thread to proceed until an entire group of them are
ready to proceed.

-  The number of threads expected to gather at a barrier is specified in
   the barrier structure when it is initialized with
   **barrier_init**\ (S). (See `\``Initialization of synchronization
   mechanisms'' <PTL_InitSyncMechs.html>`__.)

-  A thread declares its arrival at the barrier with the
   **barrier_wait**\ (S) function.

   ::

         int barrier_wait(
          barrier_t *barrier
         );

-  The barrier mechanism has no facility to authenticate the threads
   calling **barrier_wait**; it simply counts the arriving threads.

-  If the number of threads at the barrier is less than the initialized
   value, the thread calling **barrier_wait** is suspended.

-  If the arriving thread brings the count to the requisite value, all
   of the waiting threads are made runnable and eventually return from
   **barrier_wait**.

-  When the threads are released, the count of threads at the barrier is
   reset to zero. That same barrier can be reused without
   re-initialization.

-  A barrier should not be re-initialized while there are waiting
   threads.

-   There is also a \``spinning'' variant of barriers called
   **\_barrier_spin**\ (S). The considerations for usage are similar to
   those for spin locks given above.

--------------

/Condition variables
====================

Condition variables are a general mechanism by which one thread can
delay its execution until some \``condition'' is true and another thread
can announce when some condition is true.

The condition variable (of type **cond_t**) is part of the mechanism by
which this synchronization occurs but that variable is not the
\``condition'' itself. This \``condition'' is a somewhat abstract
concept (as is \``resource'') that is represented by other code in the
program. Some hypothetical examples of conditions are: 

-  A message has arrived.
-  Data is available for processing.
-  Space is available to buffer output.

The association between \``condition'' and the condition variable arises
from the programmer's usage of the feature.

One distinguishing feature of the conditional variable mechanism is that
two different types of data structures are employed, not just one. A
mutual exclusion lock (type **mutex_t**) *must* be used in concert with
the condition variable (type **cond_t**) itself. By convention, a thread
that evaluates or modifies or acts on the \``condition'' must acquire
the associated mutex lock beforehand and release that lock afterward.

The following pseudo-code shows the protocol for a thread that is making
some \``condition'' true and announcing the change.

::

      mutex_lock(&mutex);
      make condition true;
      cond_signal(&cond); \(lh awaken thread (if any) waiting for condition
      mutex_unlock(&mutex);

When the thread announces the change of the condition (to being true),
it has a choice of awakening either a single thread waiting for that
condition or all threads waiting for that condition. The syntax is: 

::

      int cond_signal(cond_t *cond);    awaken one thread
      int cond_broadcast(cond_t *cond); awaken all threads

In either case, there is no problem if there happen to be no waiting
threads at the time of announcement.

--------------

**NOTE:** Do not confuse the term \``signal'' in the sense of calling
**cond_signal**\ (S) and \``signal'' in the sense of **thr_kill**\ (S).
They are different mechanisms with different semantics. (The latter
provides asynchronous influence, the former does not.)

--------------

A thread wanting to delay itself until the \``condition'' is true must
first acquire the associated mutex before evaluating the condition. If
the condition is true, there is no need for delay and the thread can
proceed; otherwise, the thread must call **cond_wait**\ (S) to wait for
the condition to become true. The following pseudo-code illustrates the
programming idiom.

::

      mutex_lock(&mutex)
      while(condition is false)
       cond_wait(&cond, &mutex);
      act on the condition; possibly invalidate it
      mutex_unlock(&mutex);

The mutex and condition variable used here must be the same data
structures as those used in the places where the \``condition'' is made
true.

If the \``condition'' is false, **cond_wait** will: 

-  Implicitly unlock the specified mutex.

   If the mutex remained locked (and the stated conventions were obeyed)
   no thread could enter the critical section to make the condition
   true.

-  Block the calling thread until some other thread makes the condition
   true and announces that change with **cond_signal**\ (S) or
   **cond_broadcast**\ (S).

-  Implicitly re-acquire the specified mutex before returning.

   If this were not done, the thread could neither validly re-evaluate
   the condition (part of the **while** loop), nor validly act on the
   condition.

The semantics of condition variables require that a waiting thread
re-test the **condition** on any return from **cond_wait**\ (S) or
**cond_timedwait**\ (S).

-  The waiting thread may have returned prematurely because it received
   a signal or a timeout (in the case of **cond_timedwait**\ (S)).
-  Even though the condition was true when **cond_signal**\ (S) or
   **cond_broadcast**\ (S) was called, another thread may have
   invalidated the condition before the waiting thread was scheduled.

Other features of condition variables are: 

-  Blocked threads can be awakened by signals. The handler will be
   called and **cond_wait**\ (S) returns **EINTR**.
-  There is a time-limited variant of **cond_wait** called
   **cond_timedwait**\ (S).
-  The separateness of the variable (type **cond_t**) used for signaling
   and for mutual exclusion (type **mutex_t**) means that several
   different conditions can be managed within one critical section.

--------------


/Awakening threads for synchronization mechanisms
=================================================

When only one thread is to be awakened for a newly available
synchronization mechanism, the selection is made by the following
general rule.

#. Preference is given to bound threads over multiplexed threads.
#. If there is still more than one candidate for awakening, the thread
   with the highest (Threads Library) \``priority'' is chosen.
#. If there is still more than one candidate for awakening, the thread
   that blocked first is selected.

   -  FIFO ordering of threads of the same priority is generally true
      but not guaranteed. In this implementation, there are race
      conditions in which the ordering is not strictly FIFO.

There are some exceptions to this algorithm: 

-  For a broadcast on a condition variable and for barriers, more than
   one thread is awakened. Conceptually, these are awakened
   simultaneously.
-  For reader-writer locks, the order of awakening is strictly FIFO,
   regardless of priority or other factors.

--------------


/Further considerations for synchronization mechanisms
======================================================

-   There is no protection against \``priority inversion''. When a
   thread holds a lock, it keeps its priority even if a higher priority
   thread is waiting for that lock. Therefore, a low priority thread can
   prevent a thread of higher priority from running.
-  **thr_exit**\ (S) does not release any locks a thread may have
   acquired.
-   There is no automatic protection from deadlock (except for the
   limited protection provided by recursive mutexes).
-  If a caught signal is received by a thread while blocked on a
   synchronization mechanism (other than a condition variable): 

   -  The signal handler is called.
   -  The blocked function call is transparently re-started.
   -  The function does not return with **EINTR**.
   -  Condition variables are the single exception. A call to
      **cond_wait** or **cond_timedwait** will be abnormally terminated
      on receipt of a signal, and **EINTR** will be returned.

-   Each mechanism (except barriers) has a conditional **\_try** variant
   that will not block when the resource is unavailable; error condition
   **EBUSY** is returned instead.

--------------

/Initialization of synchronization mechanisms
=============================================

Some general characteristics of the initialization functions are: 

-  The first argument is a pointer to the locking structure to be
   initialized.
-  The **type** argument can take on the values of either: 

   **USYNC_THREAD**
      thread-to-thread synchronization
   **USYNC_PROCESS**
      interprocess synchronization. For such use, the synchronization
      data structures must reside in memory that is shared between the
      processes, using either IPC shared memory or the mapped file
      feature.

   The **type** argument is not available for the two spinning type
   locks.
-  Two mechanism types (barriers and semaphore) require an initial value
   (**count**).
-  The last argument is of type **(void \*)**, is reserved for future
   use, and should be set to **NULL** for future compatibility.

The syntax of these functions is given below.

::

      int sema_init(      sema_t      *sema,    int count,    int type, void *arg);
      int barrier_init(        barrier_t       *barrier, int count,    int type, void *arg);
      int _barrier_spin_init(  barrier_spin_t  *barrier, int count,        void *arg);
      int _spin_init(      spin_t      *lock,            void *arg);
      int cond_init(       cond_t      *cond,        int type, void *arg);
      int mutex_init(      mutex_t     *mutex,       int type, void *arg);
      int rmutex_init(     rmutex_t        *rmutex,      int type, void *arg);
      int rwlock_init(     rwlock_t        *rwlock,      int type, void *arg);

Alternative initialization
--------------------------

In this implementation, it is valid to use statically initialized
(zero-filled) data structures for the synchronization mechanisms.

For most of the mechanisms, a zero-filled data structure is taken to be
unlocked and of type **USYNC_THREAD**. The mechanisms that take a count
argument have the following additional interpretations: 

-  A zero-filled **sema_t** structure represents zero available
   resources. A **sema_wait**\ (S) on that structure will block.
-  A zero-filled **barrier_t** structure is valid but meaningless.

Filling the data structure with zeroes is *not* recommended for
re-initialization of synchronization structures. In general, it is
incorrect to re-initialize a synchronization structure while in use.
Some of the initialization functions (shown above) return **EBUSY** if
called for an active data structure (one on which threads are blocked).
Zero-filling the data structure bypasses that check.

--------------

/Invalidation of synchronization mechanisms
===========================================

The syntax of the functions that invalidate synchronization structures
is even more regular than that of the initializing functions.

-  The first and only argument is a pointer to the mechanism-specific
   structure to be invalidated.

The syntax is: 

::

      int sema_destroy(         sema_t         *sema);
      int _spin_destroy(        spin_t         *lock);
      int barrier_destroy(      barrier_t      *barrier);
      int _barrier_spin_destroy(barrier_spin_t *barrier);
      int cond_destroy(         cond_t         *cond);
      int mutex_destroy(        mutex_t        *mutex);
      int rmutex_destroy(       rmutex_t       *rmutex);
      int rwlock_destroy(       rwlock_t       *rwlock);

Each function can fail as follows: 

**EINVAL**
   Invalid argument specified.
**EBUSY**
   Mechanism currently in use.

The effect of these functions is: 

-  To mark the structure as being invalid for further use (unless
   re-initialized).
-  To allow the recovery of any Threads Library internal resources that
   may have been allocated when the synchronization mechanism was
   initialized.
-  Though these **\_destroy** functions recover underlying resources,
   the space for the synchronization structure itself remains. If the
   space is to be recovered (say the structure will no longer be used)
   that must be done separately. For example, a space acquired from
   `malloc\ (S) <../man/html.S/malloc.S.html>`__ should be recovered
   with **free** (see `malloc\ (S) <../man/html.S/malloc.S.html>`__).

--------------

/Compilation environment
========================

Source code that uses Threads Library functions should include the
following line: 

::

      #include    <thread.h>

| and should be compiled with the following command line options: 
| **cc** [**options**] **-Kthread** **file**

The **-Kthread** flag is needed for an application to be thread-safe,
and to access reentrant routines in standard libraries (see below).

Source code that uses the synchronization routines in the Threads
Library should include the following line: 

::

      #include    <synch.h>

--------------


/Error returns
==============

None of the thread management or synchronization routines in the Threads
Library set **errno** to indicate an error; most return an error number
if an error is encountered.

-  The error numbers returned correspond to **errno** numbers.
-  This discourages use of **errno**, which is not reentrant and is
   inefficient in a multithreaded environment.
-  The Threads Library does not guarantee preservation of **errno**
   across calls.

--------------

**NOTE:** The asynchronous I/O routines (described on the section S
manual pages), which are included in the Threads Library, do set
**errno**.

--------------

However, threads may call routines that do set **errno**. If all threads
in a process accessed a global **errno**, no thread could be sure that
the global value resulted from a system call it had made, it might have
resulted from another system call made by another thread. Therefore, the
Threads Library maintains a private copy of **errno** for each thread.
When a thread references **errno**, it will get the value of its private
copy, not the global variable.

There is one exception: the initial thread (the thread running **main**)
accesses the global **errno** via its private copy. Therefore, the
initial thread can safely call into non-reentrant code (such as an old
object file compiled before SVR4.2MP and SCO OpenServer), and have
correct **errno** semantics. Threads other than the initial thread
should not make calls into old object files that set **errno**. The
mixing of reentrant and non-reentrant object files is discouraged, and
should only be done as an interim measure until applications are made
reentrant.

--------------


/Thread-safe libraries
======================

In previous releases of SCO OpenServer, libraries freely used global and
static data. In a multithreaded program, different sibling threads
running concurrently could corrupt global or static data. Therefore, in
SVR4.2MP and SCO OpenServer, standard libraries have been made
thread-safe. When an application is compiled with the **-Kthread** flag
to `cc\ (CP) <../man/html.CP/cc.CP.html>`__, standard libraries will
synchronize threads' use of global and static data. (As this
synchronization has a performance cost to single-threaded applications,
it is only enabled when the **-Kthread** flag is used.)

In addition, new, reentrant versions of some library routines have been
added. The names of these routines are suffixed with **\_r**. For
example, the reentrant version of **strtok** (see
`string\ (S) <../man/html.S/string.S.html>`__) is **strtok_r**.
Multithreaded applications should use the reentrant versions of library
routines.

SVR4.2MP and SCO OpenServer supply thread-safe versions of the following
libraries: 

-  libc
-  libm
-  libnsl
-  libsocket
-  libresolv
-  resolv
-  tcpip
-  straddr
-  novell
-  libnwutil

Applications using other libraries that have not been made thread-safe
must synchronize access to global data.

--------------

/System call wrappers
=====================

The Threads Library provides \``wrappers'' for the system calls and
library routines listed below. A wrapper is a routine with the same name
and interface as another routine, in this case a standard system call or
library routine. Wrappers usually do something to modify the behavior of
the standard routine, then call the standard routine, and perhaps do
something further when the standard routine returns. Many of the Threads
Library wrappers cause the system call to affect a single thread instead
of the entire process or LWP.

When you compile with **-Kthread**, references to these routines will
automatically access the Threads Library wrapper versions.

-  `getcontext\ (S) <../man/html.S/getcontext.S.html>`__
-  **setcontext** (see
   `getcontext\ (S) <../man/html.S/getcontext.S.html>`__)
-  `sigaction\ (S) <../man/html.S/sigaction.S.html>`__
-  **sighold** (see `signal\ (S) <../man/html.S/signal.S.html>`__)
-  **sigignore** (see `signal\ (S) <../man/html.S/signal.S.html>`__)
-  `signal\ (S) <../man/html.S/signal.S.html>`__
-  **sigpause** (see `signal\ (S) <../man/html.S/signal.S.html>`__)
-  `sigpending\ (S) <../man/html.S/sigpending.S.html>`__
-  `sigprocmask\ (S) <../man/html.S/sigprocmask.S.html>`__
-  **sigrelse** (see `signal\ (S) <../man/html.S/signal.S.html>`__)
-  **sigset** (see `signal\ (S) <../man/html.S/signal.S.html>`__)
-  `sigsuspend\ (S) <../man/html.S/sigsuspend.S.html>`__
-  **sigwait**\ (S)
-  `alarm\ (S) <../man/html.S/alarm.S.html>`__
-  `getitimer\ (S) <../man/html.S/getitimer.S.html>`__
-  **setitimer** (see
   `getitimer\ (S) <../man/html.S/getitimer.S.html>`__)
-  `sleep\ (S) <../man/html.S/sleep.S.html>`__
-  **forkall** (see `fork\ (S) <../man/html.S/fork.S.html>`__)
-  `fork\ (S) <../man/html.S/fork.S.html>`__

--------------

**NOTE:** The wrappers for the **fork** and **forkall** system calls do
not change the behavior of those system calls for an application linked
with **libthread**. They perform some housekeeping only when tracing is
enabled (that is, when the application is linked with **libthreadT**).
See `\``Tracing multithreaded programs'' <PTL_TracMulthdProgs.html>`__.

--------------

--------------

/Timers
=======

The Threads Library provides facilities that allow multiplexed threads
to use alarms and real interval timers without requiring that the
threads tie up LWPs between the initiation and expiration of the call.
For this purpose, the Threads Library supplies wrappers for
`alarm\ (S) <../man/html.S/alarm.S.html>`__,
`getitimer\ (S) <../man/html.S/getitimer.S.html>`__, **setitimer** and
`sleep\ (S) <../man/html.S/sleep.S.html>`__. When a bound thread calls
one of these routines, it has access to the full functionality as
described on the reference manual page. However, when a multiplexed
thread calls one of these functions, it will use the Threads Library
version of the function, and in some cases the functionality will be
limited. For example, a multiplexed thread can only use real timers, not
virtual or profiling timers.

In addition, the wrapper versions of these functions have per-thread
semantics rather than per-LWP semantics. For example,
`alarm\ (S) <../man/html.S/alarm.S.html>`__ sets an alarm clock. When
the set time expires, the caller receives a **SIGALRM** signal. The
wrapper function ensures that the **SIGALRM** is delivered to the
calling thread (rather than the calling LWP), regardless of whether the
calling thread is running on the same LWP on which it was running when
it issued the call to **alarm**.

--------------


/Debugging multithreaded programs
=================================

The graphical debugger, **debug**\ (CP), can be used to debug
multithreaded programs. See the sections on debugging in `Programming in
standard C and C++ <../SDK_cprog/CONTENTS.html>`__ for guidance on using
**debug**.

--------------


/Tracing multithreaded programs
===============================

The Threads Library provides a mechanism for tracing library events.
Calls to all Threads Library routines can be traced. Significant
information, such as arguments, return values, lock contention, and
duration of execution is recorded. Using tracing facilities, you can
find the latency time for obtaining a lock, for example, or the number
of acquisition attempts on a lock.

| To avoid a performance penalty on the Threads Library, a separate
  library, **libthreadT.so**, contains the tracing routines. To obtain
  trace data, the application must be linked to **libthreadT.so**
  instead of **libthread.so**. Use the following command: 
| **cc** [**options**] **-Kthread** **file** [**-l\ other_libraries**]

Note that the Threads Library must be the last library on the line.

Trace data files
----------------

| Trace data is collected for each LWP and stored in a separate file, by
  default in the current working directory. The files are named: 
| tr.\ **xxxxxxx**.\ **yyy**

where **xxxxxxx** is the seven least significant hexadecimal digits of
the process ID associated with the LWP and **yyy** is the three least
significant hexadecimal digits of the LWP ID.

When a traced application completes execution, one trace file will exist
for each LWP that existed in the life of that application. The logical
way to begin to use this data is to merge all the trace files into one
file with all events sorted chronologically, by thread ID, or by event.
Then you can use tools to summarize the data in useful ways.

Because trace output files have not yet been standardized, no tools are
provided to analyze these files, but you can construct your own using
standard SCO OpenServer tools, such as
`awk\ (C) <../man/html.C/awk.C.html>`__,
`sort\ (C) <../man/html.C/sort.C.html>`__, and
`sed\ (C) <../man/html.C/sed.C.html>`__.

Format of the trace data files
------------------------------

Each line in the files is a trace record in the following format: 

::

      time1:time2:lwpid:pid:tid:event1:event2:which:a1:a2:a3:a4:a5

| The meaning of each field in the record is shown in the following
  table: 
| 

**Meaning of trace record fields**

+-----------------------------------+-----------------------------------+
| Field                             | Meaning                           |
+===================================+===================================+
| *time1*                           | current time in seconds           |
+-----------------------------------+-----------------------------------+
| *time2*                           | current time in nanoseconds       |
+-----------------------------------+-----------------------------------+
| *lwpid*                           | LWP ID of calling thread          |
+-----------------------------------+-----------------------------------+
| *pid*                             | process ID of calling thread      |
+-----------------------------------+-----------------------------------+
| *tid*                             | thread ID of calling thread       |
+-----------------------------------+-----------------------------------+
| *event1*                          | general category of event (type   |
|                                   | of routine called)                |
+-----------------------------------+-----------------------------------+
| *event2*                          | specific event (name of routine   |
|                                   | called)                           |
+-----------------------------------+-----------------------------------+
| *which*                           | **0** for a single record         |
|                                   | associated with this event        |
|                                   | **1** for the first of two        |
|                                   | records                           |
|                                   | **2** for the second of two       |
|                                   | records                           |
+-----------------------------------+-----------------------------------+
| *a1*                              | depends on event                  |
+-----------------------------------+-----------------------------------+
| *a2*                              | depends on event                  |
+-----------------------------------+-----------------------------------+
| *a3*                              | depends on event                  |
+-----------------------------------+-----------------------------------+
| *a4*                              | depends on event                  |
+-----------------------------------+-----------------------------------+
| *a5*                              | depends on event                  |
+-----------------------------------+-----------------------------------+

The first two fields record the time, the next three fields record
information about the caller, the next three fields identify the event
(the routine that was called), and the remaining fields record specific
details about the event, such as the arguments passed to the routine in
question.

Further details about the contents of trace data files are given on the
*thread_trace*\ (F) manual page.

The **thread_trace**\ (F) manual page also describes environment
variables that can be set to change the default trace data collection.
For example, you can specify a subset of events to trace or specify the
directory where trace files should be created.

Merging trace files
-------------------

| The individual trace files for each LWP will already be sorted
  chronologically. The following use of
  `sort\ (C) <../man/html.C/sort.C.html>`__ will efficiently merge the
  trace files in their current format.
| **sort -m -n -o** **mergefilename** **-t: +0 -4** **tracefiles**

where **mergefilename** represents the name of the merge file to be
created and **tracefiles** represents the names of the trace files to be
merged (or a regular expression that identifies them). The resulting
**mergefile** will be sorted chronologically, and further sorted by LWP
ID and process ID.

Using trace file data
---------------------

Once the trace data files are merged, translating the event category and
event number fields into event names is an obvious next step. These are
the sixth and seventh fields of each trace record. The following **awk**
script will read the file specified by the first argument, translate the
event fields into the associated event name, and write the output into
the file specified by the second argument.

::

      MAPPING=/tmp/tracemap.h
      awk '
      BEGIN { FS=":"
       OFS=":"
      }
      FILENAME == ARGV[1] {
       map[$1]=$2
       next
      }
      {    OUT=map[$6+0"_"$7+0]
       print $1" "$2" "$3" "$4" "$5" "OUT" \
             "$8" "$9" "$10" "$11" "$12" "$13
      }' $MAPPING $1 > $2

Note that the code on the line starting with \``print'' and the code on
the line after it should all be on the same line, and that there should
be no backslash in the code.

This script assumes that tracemap.h is located in */tmp* and that it
maps event names to the values in the **event1** and **event2** fields
of the trace record with entries of the form: 

::

      1_1:thr_create
      1_2:thr_exit
      1_3:thr_join
      1_4:thr_self
      1_5:thr_minstack
      1_6:thr_continue
      1_7:thr_suspend
      1_8:thr_setconcurrency
      1_9:thr_getconcurrency
      1_10:thr_kill
      1_11:thr_sigsetmask
      1_12:thr_setscheduler
      1_13:thr_getscheduler
      1_14:thr_setprio
      1_15:thr_getprio
      1_16:thr_yield
      1_17:thr_get_rr_interval
      1_18:thr_keycreate
      1_19:thr_keydelete
      1_20:thr_setspecific
      1_21:thr_getspecific
      
      2_1:mutex_init
      2_2:mutex_lock
      2_3:mutex_trylock
      2_4:mutex_unlock
      2_5:mutex_destroy
      
      3_1:cond_init
      3_2:cond_signal
      3_3:cond_broadcast
      3_4:cond_wait
      3_5:cond_timedwait
      3_6:cond_destroy
      
      4_1:sema_init
      4_2:sema_wait
      4_3:sema_trywait
      4_4:sema_post
      4_5:sema_destroy
      
      5_1:rwlock_init
      5_2:rw_rdlock
      5_3:rw_wrlock
      5_4:rw_unlock
      5_5:rw_tryrdlock
      5_6:rw_trywrlock
      5_7:rwlock_destroy
      
      6_1:rmutex_init
      6_2:rmutex_lock
      6_3:rmutex_trylock
      6_4:rmutex_unlock
      6_5:rmutex_destroy
      
      7_1:barrier_init
      7_2:barrier_wait
      7_3:barrier_destroy
      
      8_1:_barrier_spin_init
      8_2:_barrier_spin
      8_3:_barrier_spin_destroy
      
      9_1:_spin_init
      9_2:_spin_lock
      9_3:_spin_trylock
      9_4:_spin_unlock
      9_5:_spin_destroy

where the number before the underscore on each line is the category
number of the event and the number after the underscore on each line is
the event number of the event listed on that line. See
*thread_trace*\ (4). Note that there should be no whitespace in
*tracemap.h*.

You can write additional **awk** scripts and **sort** commands to
further consolidate your data as needed to analyze the behavior of your
application.

--------------


/Examples
=========

The following sections present several small programs to illustrate use
of the Threads Library.

--------------

/hello, world
=============

::

   #include  <stdio.h>
   #include    <stdlib.h>
   #include    <thread.h>
   static void *print(void*);
   int main()
   {
       int okend = EXIT_SUCCESS;
       (void)thr_create(0,0, print, (void *)"hello, ",  0L,0);
       (void)thr_create(0,0, print, (void *)"world.\n", 0L,0);
       thr_exit(&okend);
       /*NOTREACHED*/
   }
   static void *print(void *s)
   {
       (void)printf(s);
       return NULL;
   }

**hello, world**

`\``hello, world'' <_hello_world.html#threads_e1>`__ shows the
traditional first program written when one enters a new regime of the
UNIX programming environment. In this example, we create one thread to
output \`\`"hello, "'' and a separate thread to output \`\`"world.\\n"''
Despite its brevity, this example illustrates several points about
programming with the Threads Library: 

-  The argument types and the return type of the **printf** (see
   `fprintf\ (S) <../man/html.S/fprintf.S.html>`__) function disqualify
   it as the starting point of a thread. A \``wrapper'' function
   (**print**) had to be devised.
-   There is no need for the initial thread to wait for the completion
   of the two threads running **print**. The process is automatically
   terminated after both of the printing threads complete.

   --------------

   **NOTE:** The use of **thr_exit**\ (S) is important. The use of
   **return** from **main** or allowing **main** to run off the closing
   brace is translated to a call to the
   `exit\ (S) <../man/html.S/exit.S.html>`__ system call. That system
   call generally terminates the process before the printing threads can
   produce their output.

   --------------

-  The order of the output is not guaranteed. In most cases the thread
   that is created first will be able to output \`\`"hello, "'' before
   the following thread outputs \`\`"world.\\n"'' Occasionally, the
   order is reversed.

--------------


/Basic threads management example
=================================

::

   #include <stdio.h>
   #include <stdlib.h>
   #include <unistd.h>
   #include <time.h>
   #include <thread.h>
   #define RANGE   10
   /* ARGSUSED */
   void *sometask(void *dummy)
   {
       thread_t thrID  = thr_self();
       unsigned seed   = getpid() * time(NULL) * (thrID + 1);
       unsigned naptime=
           (unsigned)(1 + RANGE*((double)rand_r(&seed)/(double)RAND_MAX));
       setbuf(stdout,NULL);
       (void)printf("thread %ld entering sometask\n",  thrID);
       (void)printf("thread %ld naptime %d\n",     thrID, naptime);
       (void)sleep(naptime);
       (void)printf("thread %ld leaving  sometask\n",  thrID);
       return NULL;
   }

**sometask**

The following examples on threads management will use (either explicitly
or implicitly) the function **sometask** that appears in
`\`\`\ sometask'' <PTL_ThdsMgmt_example.html#threads_e2>`__. This
function will call `sleep\ (S) <../man/html.S/sleep.S.html>`__ to
represent some arbitrary activity by the thread. Features to note in
this example are: 

-  The simulated action for each thread will be different since each
   sleeps for a different, random period of time. The seed for the
   random number generator depends on current process ID, current time,
   and thread ID.
-  The activity period is at least one second plus a random component
   between zero and nine seconds.
-  The random number is generated with **rand_r**, the thread-safe
   version of `rand\ (S) <../man/html.S/rand.S.html>`__.
-  Calls to `sleep\ (S) <../man/html.S/sleep.S.html>`__ by each thread
   will put only the calling thread to sleep, as arranged by the wrapper
   version of **sleep** provided by the Threads Library.

::

   #include  <stdio.h>
   #include    <stdlib.h>
   #include    <thread.h>
   extern void *sometask(void *);
   main(int argc, char **argv)
   {
        int Nthreads, i; thread_t threadID;
        if(argc != 2){
       (void)fprintf( stderr,"%s: usage: %s Nthreads\nwhere Nthreads > 0\n",
               argv[0], argv[0]);
       return 1;
        }
        if( (Nthreads = atoi(argv[1])) <= 0 ){
       (void)fprintf( stderr,"%s: usage: %s Nthreads\nwhere Nthreads > 0\n",
               argv[0], argv[0]);
       return 1;
        }
        for(i = 0; i < Nthreads; i++)
       (void)thr_create(NULL, 0, sometask, NULL, 0, NULL);
        for(i = 0; i < Nthreads; i++){
       (void)thr_join(0, &threadID, NULL);
       (void)printf("thread %ld is gone\n", threadID);
        }
        return 0;
   }

**Multiple threads**

The program in `\``Multiple 
threads'' <PTL_ThdsMgmt_example.html#threads_e3>`__ creates one or more
threads as follows: 

-  The number of threads to be created is determined by a (validated)
   command line parameter.
-  Each new thread runs **sometask**.
-   The initial thread waits for the termination of each thread that it
   creates.

::

   #include  <stdio.h>
   #include    <stdlib.h>
   #include    <thread.h>
   #include    <synch.h>
   extern void *sometask (void *);
   static void *repeatask(void *);
   static barrier_t    common_wall;
   main(int argc, char **argv)
   {
        int        Nthreads, i;
        if(argc != 2){
       (void)fprintf(  stderr,"%s: usage: %s Nthreads\nwhere Nthreads > 0\n",
               argv[0], argv[0]);
       return 1;
        }
        if((Nthreads = atoi(argv[1]))>0){
       (void)barrier_init(&common_wall, Nthreads, USYNC_THREAD, NULL);
        } else {
       (void)fprintf(  stderr,"%s: usage: %s Nthreads\nwhere Nthreads > 0\n",
               argv[0], argv[0]);
       return 1;
        }
        for(i = 0; i < Nthreads; i++)
       (void)thr_create(NULL, 0, repeatask, NULL, 0, NULL);
        thr_exit(NULL);
        /*NOTREACHED*/
   }
   /* ARGSUSED */
   static void *repeatask(void *dummy)
   {
       for(;;){
           (void)printf("thread %ld at wall\n", thr_self());
           (void)barrier_wait(&common_wall);
           (void)sometask(NULL);
       }
   }

**barrier_wait**

The example in 
`\`\`\ barrier_wait'' <PTL_ThdsMgmt_example.html#threads_e4>`__ is a
variation of that in `\``Multiple
threads'' <PTL_ThdsMgmt_example.html#threads_e3>`__. In this case: 

-  Each thread that is created (running **repeatask**) calls
   **sometask** repeatedly.
-  The created threads coordinate their activity into cycles by the
   barrier facility of the Threads Library.
-  Output of this program shows a flurry of activity as the barrier
   count is reached and the set of threads is unleashed for the next
   cycle.
-  There is no need for the initial thread to persist; consequently, the
   initial thread terminates itself with **thr_exit**\ (S). The process
   continues until the user terminates it manually.

--------------

/Dining philosophers
====================

::

   #include  <stdio.h>
   #include    <thread.h>
   #include    <synch.h>
   #define NPHIL   5
   static sema_t   forks[NPHIL];
   typedef struct {
       int id, left_fork, right_fork;
   } philo_t;
   static philo_t  philo_args[NPHIL];
   static void *philo(void*);
   extern void *sometask(void*);
   main()
   {
       int i;
       for(i = 0; i < NPHIL; i++){
           (void)sema_init(&forks[i], 1, USYNC_THREAD, NULL);
           philo_args[i].id    = i;
           philo_args[i].left_fork = i;
           philo_args[i].rght_fork = (i+1)%NPHIL;
       }
       for(i = 0; i < NPHIL; i++)
           (void)thr_create(NULL, 0, philo, &philo_args[i], 0, NULL);
       thr_exit(NULL);
       /*NOTREACHED*/
   }
   static void *philo(void *philo_arg)
   {
       philo_t *argp   = (philo_t *)philo_arg;
       int id  = argp->id;
       int left    = argp->left_fork;
       int rght    = argp->rght_fork;
       (void)printf("thrID %ld id %d left %d rght %d\n",
               thr_self(), id, left, rght);
       for(;;){
           (void)sema_wait(&forks[left]);
           (void)sema_wait(&forks[rght]);
           (void)printf("philo %d eating w. %d and %d\n", id, left, rght);
           (void)sometask(NULL); /* eating */
           (void)printf("philo %d done   w. %d and %d\n", id, left, rght);
           (void)sema_post(&forks[left]);
           (void)sema_post(&forks[rght]);
           (void)sometask(NULL); /* think */
       } /* NOTREACHED */
   }

**Dining philosophers**

The program in `\``Dining 
philosophers'' <_Dining_Philosophers.html#threads_e5>`__ shows an
implementation of the classic \``dining philosophers'' problem using the
facilities of the Threads Library.

In this problem there are **N** philosophers sitting at a round table
eating and thinking. Each has a plate of spaghetti and there is a single
fork (a total of **N** forks) between each pair. Each philosopher must
use two forks to eat the spaghetti. Each philosopher puts down both
forks to think. This simple problem illustrates many of the issues in
concurrent programming, such as the need for synchronization to prevent
deadlock. The philosophers represent processes that require shared
resources (the forks).

Some features of this program are: 

-  Each philosopher is represented by a thread.
-  Each fork is represented by a semaphore.
-  Each thread runs the same code (**philo**) but needs different
   arguments. That is each philosopher being simulated will follow the
   same rules but is assigned to use a distinct pair of forks. The
   example shows how to assemble several items of information into a
   structure and inform the thread of where to find its arguments.
-  This implementation can deadlock. If each philosopher picks up his or
   her left fork before any picks up his or her right fork, they will
   deadlock, waiting to pick up their right forks. One way to solve this
   deadlock would be to allow no more than **N**-1 philosophers to eat
   at the same time. That way, one of the philosophers will always be
   able to pick up two forks.
-  As in other examples, there is no need for the initial thread to
   persist. The simulation continues until manually terminated.

--------------

/Producer/consumer
==================

::

   #include        <stdio.h>
   #include        <stdlib.h>
   #include        <string.h>
   #include        <thread.h>
   #include        <synch.h>
   #define TRUE    1
   #define FALSE   0
   static  void    *producer(void*);
   static  void    *consumer(void*);
   static  char    Buff[BUFSIZ];
   static  cond_t  Buff_cond;
   static  mutex_t Buff_mutex;
   static  int     DataInBuff = FALSE;
   main()
   {
           (void)mutex_init(&Buff_mutex, USYNC_THREAD,  NULL);
           (void)cond_init (&Buff_cond,  USYNC_THREAD,  NULL);
           (void)thr_create(NULL, 0, producer, NULL, 0, NULL);
           (void)thr_create(NULL, 0, consumer, NULL, 0, NULL);
           thr_exit(NULL);
           /*NOTREACHED*/
   }
   /*ARGSUSED*/
   static void *producer(void *dummy)
   {
       (void)mutex_lock(&Buff_mutex);
           for(;;){
                   while(DataInBuff == TRUE)
                           cond_wait(&Buff_cond, &Buff_mutex);
           /* At this point,
            * the buffer is empty (contents have been output).
            * (Re)fill the buffer.
            */
                   if(fgets(Buff, sizeof(Buff), stdin) == NULL)
                           exit(EXIT_SUCCESS);
                   DataInBuff = TRUE;
                   cond_signal (&Buff_cond);
           }
           /*NOTREACHED*/
   }
   /*ARGSUSED*/
   static void *consumer(void *dummy)
   {
           (void)mutex_lock(&Buff_mutex);
           for(;;){
                   while(DataInBuff == FALSE)
                           cond_wait(&Buff_cond, &Buff_mutex);
           /* At this point,
            * the buffer has data to be output
            */
                   (void)fputs(Buff, stdout);
                   DataInBuff = FALSE;
                   cond_signal(&Buff_cond);
           }
           /*NOTREACHED*/
   }

**Producer/consumer**

The program in 
`\``Producer/consumer'' <_ProducerConsumer.html#threads_e6>`__ shows a
simple producer/consumer example implemented using the condition
variables facilities of the Threads Library.

-  There are two threads, each running different functions. One runs
   **producer**, the other runs **consumer**.
-  The item being produced and consumed is data in a common buffer.

   -  The producer obtains that data with **fgets** (see
      `gets\ (S) <../man/html.S/gets.S.html>`__) and places the data in
      the common buffer.
   -  The consumer reads the data from the buffer. That data is output
      with **fputs** (see `puts\ (S) <../man/html.S/puts.S.html>`__) so
      that its actions can be confirmed.

-  The actions of producer and consumer threads are coordinated by the
   condition variable facility so that they run in strict alternation.

   -  Nothing will be output (consumed) until something is placed in the
      buffer (produced).
   -  Data in the buffer will not be overwritten until it is output.

-  Note that this example differs from the pseudo-code shown earlier.
   The use of the condition variables are *not* bracketed by calls to
   **mutex_lock**\ (S) and **mutex_unlock**\ (S).

   -  This curiosity arises because the actions of each of these threads
      is organized in a loop.
   -  The semantics of **cond_wait**\ (S) guarantee that the named
      \``mutex'' will be released while a thread is waiting and
      reacquired before return from that function.
   -  The condition (**DataInBuff**) is tested (for different values) by
      each thread only when the thread holds the \``mutex'' and the use
      of **cond_wait** by each threads allows the other to acquire the
      \``mutex''.

-  The initial calls to **mutex_lock**\ (S) by each thread and the
   initial state of **DataInBuff** are organized so that: 

   -  Proper conditions are achieved for the initial pass by each
      thread.
   -  The program will work correctly no matter which thread acquires
      the \``mutex'' on the first pass.

-  The producer thread terminates the process with the
   `exit\ (S) <../man/html.S/exit.S.html>`__ system call when it can
   obtain no more data from **fgets** (see
   `gets\ (S) <../man/html.S/gets.S.html>`__).

--------------

/10. Interprocess communication
================================

SCO OpenServer provides several mechanisms that allow processes to
exchange data and synchronize execution. The simpler of these mechanisms
are pipes, named pipes, and signals. These are limited, however, in what
they can do. For instance,

-  Pipes do not allow unrelated processes to communicate.
-  Named pipes allow unrelated processes to communicate, but they cannot
   provide private channels for pairs of communicating processes; that
   is, any process with appropriate permission may read from or write to
   a named pipe.
-  Sending signals, via the **kill** system call, allows arbitrary
   processes to communicate, but the message consists only of the signal
   number.

SCO OpenServer also provides an InterProcess Communication (IPC) package
that supports three, more versatile types of interprocess communication.
For example,

-  Messages allow processes to send formatted data streams to arbitrary
   processes.
-  Semaphores allow processes to synchronize execution.
-  Shared memory allows processes to share parts of their virtual
   address space.

When implemented as a unit, these three mechanisms share common
properties such as

-  each mechanism contains a \``get'' system call to create a new entry
   or retrieve an existing one
-  each mechanism contains a \``control'' system call to query the
   status of an entry, to set status information, or to remove the entry
   from the system
-  each mechanism contains an \``operations'' system call to perform
   various operations on an entry

This section describes the system calls for each of these three forms of
IPC.

This information is for programmers who write multiprocess applications.
These programmers should have a general understanding of what semaphores
are and how they are used.

Information from other sources would also be helpful. See
`ipcs\ (ADM) <../man/html.ADM/ipcs.ADM.html>`__ and
`ipcrm\ (ADM) <../man/html.ADM/ipcrm.ADM.html>`__, as well as the
following manual pages: 

+----------------------+----------------------+----------------------+
| **intro**\ (S)       | **aclipc**\ (S)      |                      |
+----------------------+----------------------+----------------------+
| `msgg                | `msgc                | `ms                  |
| et\ (S) <../man/html | tl\ (S) <../man/html | gop\ (S) <../man/htm |
| .S/msgget.S.html>`__ | .S/msgctl.S.html>`__ | l.S/msgop.S.html>`__ |
+----------------------+----------------------+----------------------+
| `semg                | `semc                | `se                  |
| et\ (S) <../man/html | tl\ (S) <../man/html | mop\ (S) <../man/htm |
| .S/semget.S.html>`__ | .S/semctl.S.html>`__ | l.S/semop.S.html>`__ |
+----------------------+----------------------+----------------------+
| `shmg                | `shmc                | `sh                  |
| et\ (S) <../man/html | tl\ (S) <../man/html | mop\ (S) <../man/htm |
| .S/shmget.S.html>`__ | .S/shmctl.S.html>`__ | l.S/shmop.S.html>`__ |
+----------------------+----------------------+----------------------+

Included in this section are several example programs that show the use
of these IPC system calls. Since there are many ways to accomplish the
same task or requirement, keep in mind that the example programs were
written for clarity and not for program efficiency. Usually, system
calls are embedded within a larger user-written program that makes use
of a particular function provided by the calls.


/Messages
=========

The message type of IPC allows processes (executing programs) to
communicate through the exchange of data stored in buffers. This data is
transmitted between processes in discrete portions called messages.
Processes using this type of IPC can send and receive messages.

Before a process can send or receive a message, it must have the SCO
OpenServer operating system generate the necessary software mechanisms
to handle these operations. A process does this using the **msgget**
system call. In doing this, the process becomes the owner/creator of a
message queue and specifies the initial operation permissions for all
processes, including itself. Subsequently, the owner/creator can
relinquish ownership or change the operation permissions using the
**msgctl** system call. However, the creator remains the creator as long
as the facility exists. Other processes with permission can use
**msgctl** to perform various other control functions.

Processes which have permission and are attempting to send or receive a
message can suspend execution if they are unsuccessful at performing
their operation. That is, a process which is attempting to send a
message can wait until it becomes possible to post the message to the
specified message queue; the receiving process isn't involved (except
indirectly, for example, if the consumer isn't consuming, the queue
space will eventually be exhausted) and vice versa. A process which
specifies that execution is to be suspended is performing a \``blocking
message operation.'' A process which does not allow its execution to be
suspended is performing a \``nonblocking message operation.''

A process performing a blocking message operation can be suspended until
one of three conditions occurs: 

-  It is successful.
-  It receives a signal.
-  The message queue is removed from the system.

System calls make these message capabilities available to processes. The
calling process passes arguments to a system call, and the system call
either successfully or unsuccessfully performs its function. If the
system call is successful, it performs its function and returns
applicable information. Otherwise, an error code (**-1**) is returned to
the process, and an external error number variable, **errno**, is set
accordingly.

--------------

/Using messages
===============

Before a message can be sent or received, a uniquely identified message
queue and data structure must be created. The unique identifier is
called the message queue identifier (**msqid**); it is used to identify
or refer to the associated message queue and data structure. This
identifier is accessible by any process in the system, subject to normal
access restrictions.

The message queue is used to store (header) information about each
message being sent or received. This information, which is for internal
use by the system, includes the following for each message: 

-  pointer to the next message on queue
-  message type
-  message text size
-  message text address

There is one associated data structure for the uniquely identified
message queue. This data structure contains the following information
related to the message queue: 

-  operation permissions data (operation permission structure)
-  pointer to first message on the queue
-  pointer to last message on the queue
-  current number of bytes on the queue
-  number of messages on the queue
-  maximum number of bytes on the queue
-  process identification (PID) of last message sender
-  PID of last message receiver
-  last message send time
-  last message receive time
-  last change time

--------------

**NOTE:** All **include** files discussed in this section are located in
the */usr/include* or */usr/include/sys* directories.

--------------

The definition for the associated message-queue data structure
**msqid_ds** includes the following members: 

::

   struct msqid_ds
   {
          struct ipc_perm  msg_perm;          /* operation permission struct */
          struct msg       *msg_first;        /* ptr to first message on q */
          struct msg       *msg_last;         /* ptr to last message on q */
          ulong            msg_cbytes;        /* current # bytes on q */
          ulong            msg_qnum;          /* # of messages on q */
          ulong            msg_qbytes;        /* max # of bytes on q */
          pid_t            msg_lspid;         /* pid of last msgsnd */
          pid_t            msg_lrpid;         /* pid of last msgrcv */
          time_t           msg_stime;         /* last msgsnd time */
          time_t           msg_rtime;         /* last msgrcv time */
          time_t           msg_ctime;         /* last change time */
   };

The C programming language data structure definition for the
message-queue data structure **msqid_ds** is located in the *sys/msg.h*
header file.

Note that the ``msg_perm`` member of this structure uses **ipc_perm** as
a template. The figure below breaks out the operation permissions data
structure. In SCO OpenServer, the definition of the **ipc_perm** data
structure is as follows: 

::

   struct ipc_perm
   {
       uid_t           uid;    /* owner's user id */
       gid_t           gid;    /* owner's group id */
       uid_t           cuid;   /* creator's user id */
       gid_t           cgid;   /* creator's group id */
       mode_t          mode;   /* access modes */
       ulong           seq;    /* slot usage sequence number */
       key_t           key;    /* key */
       long            pad[4]; /* reserve area */
   };

**ipc_perm data structure**

The C programming language data structure definition for the
interprocess communication permissions data structure **ipc_perm** is
located in the *sys/ipc.h* header file and is common to all IPC
facilities.

The **msgget** system call is used to perform one of two tasks: 

-  to get a new message queue identifier and create an associated
   message queue and data structure for it
-  to return an existing message queue identifier that already has an
   associated message queue and data structure

Both tasks require a **key** argument passed to the **msgget** system
call. For the first task, if the **key** is not already in use for an
existing message queue identifier, a new identifier is returned with an
associated message queue and data structure created for the **key**.

There is also a provision for specifying a **key** of value zero, known
as the private **key** (**IPC_PRIVATE**). When specified, a new
identifier is always returned with an associated message queue and data
structure created for it unless a system-tunable parameter would be
exceeded. The **ipcs** command will show the **key** field for the
**msqid** as all zeros.

For the second task, if a message queue identifier exists for the
**key** specified, the value of the existing identifier is returned. If
you do not want to have an existing message queue identifier returned, a
control command (**IPC_EXCL**) can be specified (set) in the **msgflg**
argument passed to the system call (see `\``Using
msgget'' <_Getting_Message_Queues.html#IC_msgget>`__ for how to use this
system call).

When performing the first task, the process that calls **msgget**
becomes the owner/creator, and the associated data structure is
initialized accordingly. Remember, ownership can be changed but the
creating process always remains the creator. The message queue creator
also determines the initial operation permissions for it.

Once a uniquely identified message queue and data structure are created,
**msgop** (message operations) and **msgctl** (message control) can be
used.

Message operations, as mentioned before, consist of sending and
receiving messages. The **msgsnd** and **msgrcv** system calls are
provided for each of these operations (see `\``Operations for
messages'' <IC_OpsMsgs.html>`__ for details of the **msgsnd** and
**msgrcv** system calls.

The **msgctl** system call permits you to control the message facility
in the following ways: 

-  by retrieving the data structure associated with a message queue
   identifier (**IPC_STAT**)
-  by changing operation permissions for a message queue (**IPC_SET**)
-  by changing the size (**msg_qbytes**) of the message queue for a
   particular message queue identifier (**IPC_SET**)
-  by removing a particular message queue identifier from the SCO
   OpenServer operating system along with its associated message queue
   and data structure (**IPC_RMID**)

See the section `\``Controlling message 
queues'' <IC_CntllMsgQueues.html>`__ for details of the **msgctl**
system call.

--------------

/Getting message queues
=======================

This section describes how to use the **msgget** system call. The
accompanying program illustrates its use.

Using msgget
------------

The synopsis found on the `msgget\ (S) <../man/html.S/msgget.S.html>`__
manual page is as follows: 

::

      #include  <sys/types.h>
      #include  <sys/ipc.h>
      #include  <sys/msg.h>
      
      int  msgget (key_t key, int msgflg);

All of these **include** files are located in the */usr/include/sys*
directory of the SCO OpenServer operating system.

The following line in the synopsis: 

::

   int msgget (key_t key, int msgflg);

informs you that **msgget** is a function that returns an integer-type
value. It also declares the types of the two formal arguments: **key**
is of type **key_t**, and **msgflg** is of type **int**. **key_t** is
defined by a **typedef** in the *sys/types.h* header file to be an
integral type.

The integer returned from this function upon successful completion is
the message queue identifier that was discussed earlier. Upon failure,
the external variable **errno** is set to indicate the reason for
failure, and the value **-1** (which is not a valid **msqid**) is
returned.

As declared, the process calling the **msgget** system call must supply
two arguments to be passed to the formal **key** and **msgflg**
arguments.

A new **msqid** with an associated message queue and data structure is
provided if either

-  **key** is equal to **IPC_PRIVATE**,

or

-  **key** is a unique integer and the control command **IPC_CREAT** is
   specified in the **msgflg** argument.

The value passed to the **msgflg** argument must be an integer-type
value that will specify the following: 

-  operations permissions
-  control fields (commands)

| Operation permissions determine the operations that processes are
  permitted to perform on the associated message queue. \``Read''
  permission is necessary for receiving messages or for determining
  queue status by means of a **msgctl** **IPC_STAT** operation.
  \``Write'' permission is necessary for sending messages.

The following table reflects the numeric values (expressed in octal
notation) for the valid operation permissions codes.

**Operation permissions codes**

  ===================== ===========
  Operation permissions Octal value
  ===================== ===========
  Read by user          00400
  Write by user         00200
  Read by group         00040
  Write by group        00020
  Read by others        00004
  Write by others       00002
  ===================== ===========

A specific value is derived by adding or bitwise ORing the octal values
for the operation permissions wanted. That is, if read by user and
read/write by others is desired, the code value would be 00406 (00400
plus 00006). There are constants located in the *sys/msg.h* header file
which can be used for the user operations permissions. They are as
follows: 

::

   MSG_W  0200    /* write permissions by owner */

   MSG_R   0400    /* read permissions by owner */

Control flags are predefined constants (represented by all upper-case
letters). The flags which apply to the **msgget** system call are
**IPC_CREAT** and **IPC_EXCL** and are defined in the *sys/ipc.h* header
file.

| The value for **msgflg** is therefore a combination of operation
  permissions and control commands. After determining the value for the
  operation permissions as previously described, the desired flag(s) can
  be specified. This is accomplished by adding or bitwise ORing (\|)
  them with the operation permissions; the bit positions and values for
  the control commands in relation to those of the operation permissions
  make this possible.

The **msgflg** value can easily be set by using the flag names in
conjunction with the octal operation permissions value: 

::

   msqid = msgget (key, (IPC_CREAT | 0400));

   msqid = msgget (key, (IPC_CREAT | IPC_EXCL | 0400));

As specified by the `msgget\ (S) <../man/html.S/msgget.S.html>`__ manual
page, success or failure of this system call depends upon the argument
values for **key** and **msgflg** or system-tunable parameters. The
system call will attempt to return a new message queue identifier if one
of the following conditions is true: 

-  **key** is equal to **IPC_PRIVATE**
-  **key** does not already have a message queue identifier associated
   with it and (**msgflg** and **IPC_CREAT**) is \``true'' (not zero).

The **key** argument can be set to **IPC_PRIVATE** like this: 

::

   msqid = msgget (IPC_PRIVATE, msgflg);

The system call will always be attempted. Exceeding the **MSGMNI**
system-tunable parameter always causes a failure. The **MSGMNI**
system-tunable parameter determines the systemwide number of unique
message queues that may be in use at any given time.

**IPC_EXCL** is another control command used in conjunction with
**IPC_CREAT**. It will cause the system call to return an error if a
message queue identifier already exists for the specified **key.** This
is necessary to prevent the process from thinking that it has received a
new identifier when it has not. In other words, when both **IPC_CREAT**
and **IPC_EXCL** are specified, a new message queue identifier is
returned if the system call is successful.

Refer to the `msgget\ (S) <../man/html.S/msgget.S.html>`__ manual page
for specific, associated data structure initialization for successful
completion. The specific failure conditions and their error names are
contained there also.

Example program
---------------

`\`\`\ msgget system call
example'' <_Getting_Message_Queues.html#ipc_i5>`__ is a menu-driven
program. It allows all possible combinations of using the **msgget**
system call to be exercised.

From studying this program, you can observe the method of passing
arguments and receiving return values. The user-written program
requirements are pointed out.

This program begins (lines 4-8) by including the required header files
as specified by `msgget\ (S) <../man/html.S/msgget.S.html>`__. Note that
the *sys/errno.h* header file is included as opposed to declaring
**errno** as an external variable; either method will work.

| Variable names have been chosen to be as close as possible to those in
  the synopsis for the system call. Their declarations are self
  explanatory. These names make the programs more readable are perfectly
  valid since they are local to the program.

The variables declared for this program and what they are used for are
as follows: 

**key**
   used to pass the value for the desired **key**
**opperm**
   used to store the desired operation permissions
**flags**
   used to store the desired control commands (flags)
**opperm_flags**
   used to store the combination from the logical ORing of the
   **opperm** and **flags** variables; it is then used in the system
   call to pass the **msgflg** argument
**msqid**
   used for returning the message queue identification number for a
   successful system call or the error code (**-1**) for an unsuccessful
   one.

The program begins by prompting for a hexadecimal **key**, an octal
operation permissions code, and finally for the control command
combinations (flags) which are selected from a menu (lines 15-32). All
possible combinations are allowed even though they might not be viable.
This allows errors to be observed for invalid combinations.

Next, the menu selection for the flags is combined with the operation
permissions, and the result is stored in the **opperm_flags** variable
(lines 36-51).

The system call is made next, and the result is stored in the **msqid**
variable (line 53).

Since the **msqid** variable now contains a valid message queue
identifier or the error code (**-1**), it is tested to see if an error
occurred (line 55). If **msqid** equals **-1**, a message indicates that
an error resulted, and the external **errno** variable is displayed
(line 57).

If no error occurred, the returned message queue identifier is displayed
(line 61).

The example program for the **msgget** system call follows. We suggest
you name the program file *msgget.c* and the executable file **msgget**.

::

    1    /*This is a program to illustrate
    2     *the message get, msgget(),
    3     *system call capabilities*/

    4    #include    <stdio.h>
    5    #include    <sys/types.h>
    6    #include    <sys/ipc.h>
    7    #include    <sys/msg.h>
    8    #include    <errno.h>

    9    /*Start of main C language program */
   10    main()
   11    {
   12        key_t key;
   13        int opperm, flags;
   14        int msqid, opperm_flags;
   15        /*Enter the desired key*/
   16        printf("Enter the desired key in hex = ");
   17        scanf("%x", &key);

   18        /*Enter the desired octal operation
   19          permissions.*/
   20        printf("\nEnter the operation\n");
   21        printf("permissions in octal = ");
   22        scanf("%o", &opperm);

   23        /*Set the desired flags.*/
   24        printf("\nEnter corresponding number to\n");
   25        printf("set the desired flags:\n");
   26        printf("No flags                  = 0\n");
   27        printf("IPC_CREAT                 = 1\n");
   28        printf("IPC_EXCL                  = 2\n");
   29        printf("IPC_CREAT and IPC_EXCL    = 3\n");
   30        printf("            Flags         = ");

   31        /*Get the flag(s) to be set.*/
   32        scanf("%d", &flags);

   33        /*Check the values.*/
   34        printf ("\nkey =0x%x, opperm = 0%o, flags = 0%o\n",
   35            key, opperm, flags);

   36        /*Incorporate the control fields (flags) with
   37          the operation permissions*/
   38        switch (flags)
   39        {
   40        case 0:    /*No flags are to be set.*/
   41            opperm_flags = (opperm | 0);
   42            break;
   43        case 1:    /*Set the IPC_CREAT flag.*/
   44            opperm_flags = (opperm | IPC_CREAT);
   45            break;
   46        case 2:    /*Set the IPC_EXCL flag.*/
   47            opperm_flags = (opperm | IPC_EXCL);
   48            break;
   49        case 3:    /*Set the IPC_CREAT and IPC_EXCL flags.*/
   50            opperm_flags = (opperm | IPC_CREAT | IPC_EXCL);
   51            break;
   52        default:   /* Invalid Input */
   53            exit(-1);
   54        }

   55        /*Call the msgget system call.*/
   56        msqid = msgget (key, opperm_flags);

   57        /*Perform the following if the call is unsuccessful.*/
   58        if(msqid == -1)
   59        {
   60            printf ("\nThe msgget call failed, error number = %d\n", errno);
   61        }
   62        /*Return the msqid upon successful completion.*/
   63        else
   64            printf ("\nThe msqid = %d\n", msqid);
   65        exit(0);
   66    }

**msgget system call example**

--------------

/Controlling message queues
===========================

This section describes how to use the **msgctl** system call. The
accompanying program illustrates its use.

Using msgctl
------------

The synopsis found on the `msgctl\ (S) <../man/html.S/msgctl.S.html>`__
manual page is as follows: 

::

      #include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/msg.h>
      
      int msgctl (msqid, cmd, buf)
      int msqid, cmd;
      struct msqid_ds *buf;

The **msgctl** system call requires three arguments to be passed to it;
it returns an integer-type value.

When successful, it returns a zero value; when unsuccessful, it returns
a **-1**.

The **msqid** variable must be a valid, non-negative, integer value. In
other words, it must have already been created by using the **msgget**
system call.

The **cmd** argument can be any one of the following values: 

**IPC_STAT**
   return the status information contained in the associated data
   structure for the specified message queue identifier, and place it in
   the data structure pointed to by the **buf** pointer in the user
   memory area.
**IPC_SET**
   for the specified message queue identifier, set the effective user
   and group identification, operation permissions, and the number of
   bytes for the message queue to the values contained in the data
   structure pointed to by the **buf** pointer in the user memory area.
**IPC_RMID**
   remove the specified message queue identifier along with its
   associated message queue and data structure.

To perform an **IPC_SET** or **IPC_RMID** control command, a process
must have: 

-  an effective user id of OWNER/CREATOR, or
-  an effective user id of *root* (if the system is running with the SUM
   privilege module), or
-  the **P_OWNER** privilege.

Read permission is required to perform the **IPC_STAT** control command.

The details of this system call are discussed in the following example
program. If you need more information on the logic manipulations in this
program, read the `msgget\ (S) <../man/html.S/msgget.S.html>`__ manual
page.

Example program
---------------

`\`\`\ msgctl system call example'' <IC_CntllMsgQueues.html#ipc_i6>`__
is a menu-driven program. It allows all possible combinations of using
the **msgctl** system call to be exercised.

From studying this program, you can observe the method of passing
arguments and receiving return values. The user-written program
requirements are pointed out.

This program begins (lines 5-9) by including the required header files
as specified on the `msgctl\ (S) <../man/html.S/msgctl.S.html>`__ manual
page. Note in this program that **errno** is declared as an external
variable, and therefore, the *sys/errno.h* header file does not have to
be included.

Variable and structure names have been chosen to be as close as possible
to those in the synopsis for the system call. Their declarations are
self explanatory. These names make the program more readable and are
perfectly valid since they are local to the program.

The variables declared for this program and what they are used for are
as follows: 

**uid**
   used to store the **IPC_SET** value for the effective user
   identification
**gid**
   used to store the **IPC_SET** value for the effective group
   identification
**mode**
   used to store the **IPC_SET** value for the operation permissions
**bytes**
   used to store the **IPC_SET** value for the number of bytes in the
   message queue (**msg_qbytes**)
**rtrn**
   used to store the return integer value from the system call
**msqid**
   used to store and pass the message queue identifier to the system
   call
**command**
   used to store the code for the desired control command so that
   subsequent processing can be performed on it
**choice**
   used to determine which member is to be changed for the **IPC_SET**
   control command
**msqid_ds**
   used to receive the specified message queue identifier's data
   structure when an **IPC_STAT** control command is performed
*buf*
   a pointer passed to the system call which locates the data structure
   in the user memory area where the **IPC_STAT** control command is to
   place its return values or where the **IPC_SET** command gets the
   values to set

Note that the **msqid_ds** data structure in this program (line 16) uses
the data structure, located in the *sys/msg.h* header file of the same
name, as a template for its declaration.

The next important thing to observe is that although the **buf** pointer
is declared to be a pointer to a data structure of the **msqid_ds**
type, it must also be initialized to contain the address of the user
memory area data structure (line 17). Now that all of the required
declarations have been explained for this program, this is how it works.

First, the program prompts for a valid message queue identifier which is
stored in the **msqid** variable (lines 19, 20). This is required for
every **msgctl** system call.

Then the code for the desired control command must be entered (lines
21-27) and stored in the command variable. The code is tested to
determine the control command for subsequent processing.

If the **IPC_STAT** control command is selected (code 1), the system
call is performed (lines 37, 38) and the status information returned is
printed out (lines 39-46); only the members that can be set are printed
out in this program. Note that if the system call is unsuccessful (line
106), the status information of the last successful call is printed out.
In addition, an error message is displayed and the **errno** variable is
printed out (line 108). If the system call is successful, a message
indicates this along with the message queue identifier used (lines
110-113).

If the **IPC_SET** control command is selected (code 2), the first thing
is to get the current status information for the message queue
identifier specified (lines 50-52). This is necessary because this
example program provides for changing only one member at a time, and the
system call changes all of them. Also, if an invalid value happened to
be stored in the user memory area for one of these members, it would
cause repetitive failures for this control command until corrected. The
next thing the program does is to prompt for a code corresponding to the
member to be changed (lines 53-59). This code is stored in the choice
variable (line 60). Now, depending upon the member picked, the program
prompts for the new value (lines 66-95). The value is placed into the
appropriate member in the user memory area data structure, and the
system call is made (lines 96-98). Depending upon success or failure,
the program returns the same messages as for **IPC_STAT** above.

| If the **IPC_RMID** control command (code 3) is selected, the system
  call is performed (lines 100-103), and the **msqid** along with its
  associated message queue and data structure are removed from the SCO
  OpenServer operating system. Note that the **buf** pointer is ignored
  in performing this control command, and its value can be zero or NULL.
  Depending upon the success or failure, the program returns the same
  messages as for the other control commands.

The example program for the **msgctl** system call follows. We suggest
that you name the source program file *msgctl.c* and the executable file
**msgctl**.

::

     1    /*This is a program to illustrate
     2     *the message control, msgctl(),
     3     *system call capabilities.
     4     */

     5    /*Include necessary header files.*/
     6    #include    <stdio.h>
     7    #include    <sys/types.h>
     8    #include    <sys/ipc.h>
     9    #include    <sys/msg.h>

    10    /*Start of main C language program*/
    11    main()
    12    {
    13        extern int errno;
    14        int mode, bytes;
    15        uid_t uid;
    16        gid_t gid;
    17        int rtrn, msqid, command, choice;
    18        struct msqid_ds msqid_ds, *buf;
    19        buf = & msqid_ds;

    20        /*Get the msqid, and command.*/
    21        printf("Enter the msqid = ");
    22        scanf("%d", &msqid);
    23        printf("\nEnter the number for\n");
    24        printf("the desired command:\n");
    25        printf("IPC_STAT    =  1\n");
    26        printf("IPC_SET     =  2\n");
    27        printf("IPC_RMID    =  3\n");
    28        printf("Entry       =  ");
    29        scanf("%d", &command);

    30        /*Check the values.*/
    31        printf ("\nmsqid =%d, command = %d\n",
    32            msqid, command);

    33        switch (command)
    34        {
    35        case 1:    /*Use msgctl() to duplicate
    36              the data structure for
    37                      msqid in the msqid_ds area pointed
    38                      to by buf and then print it out.*/
    39            rtrn = msgctl(msqid, IPC_STAT,
    40                buf);
    41            printf ("\nThe USER ID = %d\n",
    42                buf->msg_perm.uid);
    43            printf ("The GROUP ID = %d\n",
    44                buf->msg_perm.gid);
    45            printf ("The operation permissions = 0%o\n",
    46                buf->msg_perm.mode);
    47            printf ("The msg_qbytes = %d\n",
    48                buf->msg_qbytes);
    49            break;
    50        case 2:    /*Select and change the desired
    51                      member(s) of the data structure.*/
    52            /*Get the original data for this msqid
    53                  data structure first.*/
    54            rtrn = msgctl(msqid, IPC_STAT, buf);
    55            printf("\nEnter the number for the\n");
    56            printf("member to be changed:\n");
    57            printf("msg_perm.uid   = 1\n");
    58            printf("msg_perm.gid   = 2\n");
    59            printf("msg_perm.mode  = 3\n");
    60            printf("msg_qbytes     = 4\n");
    61            printf("Entry          = ");

    62            scanf("%d", &choice);
    63            /*Only one choice is allowed per
    64              pass as an invalid entry will
    65                  cause repetitive failures until
    66              msqid_ds is updated with
    67                  IPC_STAT.*/

    68            switch(choice){
    69            case 1: 
    70                printf("\nEnter USER ID = ");
    71                scanf ("%ld", &uid);
    72                buf->msg_perm.uid =(uid_t)uid;
    73                printf("\nUSER ID = %d\n",
    74                    buf->msg_perm.uid);
    75                break;
    76            case 2: 
    77                printf("\nEnter GROUP ID = ");
    78                scanf("%d", &gid);
    79                buf->msg_perm.gid = gid;
    80                printf("\nGROUP ID = %d\n",
    81                    buf->msg_perm.gid);
    82                break;
    83            case 3: 
    84                printf("\nEnter MODE = ");
    85                scanf("%o", &mode);
    86                buf->msg_perm.mode = mode;
    87                printf("\nMODE = 0%o\n",
    88                    buf->msg_perm.mode);
    89                break;
    90            case 4: 
    91                printf("\nEnter msq_bytes = ");
    92                scanf("%d", &bytes);
    93                buf->msg_qbytes = bytes;
    94                printf("\nmsg_qbytes = %d\n",
    95                    buf->msg_qbytes);
    96                break;
    97            default: /* Invalid Input */
    98                exit(-1);
    99            }

   100            /*Do the change.*/
   101            rtrn = msgctl(msqid, IPC_SET,
   102                buf);
   103            break;

   104        case 3:    /*Remove the msqid along with its
   105                      associated message queue
   106                      and data structure.*/
   107            rtrn = msgctl(msqid, IPC_RMID, (struct msqid_ds *) NULL);
   108        break;
   109        default: /* Invalid Input */
   110            exit(-1);
   111        }
   112        /*Perform the following if the call is unsuccessful.*/
   113        if(rtrn == -1)
   114        {
   115            printf ("\nThe msgctl call failed, error number = %d\n", errno);
   116        }
   117        /*Return the msqid upon successful completion.*/
   118        else
   119            printf ("\nMsgctl was successful for msqid = %d\n",
   120                msqid);
   121        exit (0);
   122    }

**msgctl system call example**

--------------


/Operations for messages
========================

This section describes how to use the **msgsnd** and **msgrcv** system
calls. The accompanying program illustrates their use.

Using message operations: msgsnd and msgrcv
-------------------------------------------

The synopsis found on the `msgop\ (S) <../man/html.S/msgop.S.html>`__
manual page is as follows: 

::

      #include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/msg.h>
      
      int msgsnd (int msqid, const void *msgp, size_t msgsz, int msgflg)
      
      int msgrcv (int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg)

Sending a message
~~~~~~~~~~~~~~~~~

The **msgsnd** system call requires four arguments to be passed to it.
It returns an integer value.

When successful, it returns a zero value; when unsuccessful, **msgsnd**
returns a **-1**.

The **msqid** argument must be a valid, non-negative, integer value. In
other words, it must have already been created by using the **msgget**
system call.

The **msgp** argument is a pointer to a structure in the user memory
area that contains the type of the message and the message to be sent.

The **msgsz** argument specifies the length of the character array in
the data structure pointed to by the **msgp** argument. This is the
length of the message. The maximum **size** of this array is determined
by the **MSGMAX** system-tunable parameter.

The **msgflg** argument allows the \``blocking message operation'' to be
performed if the **IPC_NOWAIT** flag is not set ((**msgflg** and
**IPC_NOWAIT**)= = 0); the operation would block if the total number of
bytes allowed on the specified message queue are in use (**msg_qbytes**
or **MSGMNB**), or the total system-wide number of messages on all
queues is equal to the system- imposed limit (**MSGTQL**). If the
**IPC_NOWAIT** flag is set, the system call will fail and return a
**-1**.

The value of the ``msg_qbytes`` data structure member can be lowered
from **MSGMNB** by using the **msgctl** **IPC_SET** control command, but
only the *root* (if the SUM privilege module is installed) can raise it
afterwards.

Further details of this system call are discussed in the next example.
If you need more information on the logic manipulations in this program,
read `\``Using msgget'' <_Getting_Message_Queues.html#IC_msgget>`__. It
goes into more detail than would be practical for every system call.

Receiving messages
~~~~~~~~~~~~~~~~~~

The **msgrcv** system call requires five arguments to be passed to it;
it returns an integer value.

When successful, it returns a value equal to the number of bytes
received; when unsuccessful it returns a **-1**.

The **msqid** argument must be a valid, non-negative, integer value. In
other words, it must have already been created by using the **msgget**
system call.

The **msgp** argument is a pointer to a structure in the user memory
area that will receive the message type and the message text.

The **msgsz** argument specifies the length of the message to be
received. If its value is less than the message in the array, an error
can be returned if desired (see the **msgflg** argument below).

The **msgtyp** argument is used to pick the first message on the message
queue of the particular type specified. If it is equal to zero, the
first message on the queue is received; if it is greater than zero, the
first message of the same type is received; if it is less than zero, the
lowest type that is less than or equal to its absolute value is
received.

The **msgflg** argument allows the \``blocking message operation'' to be
performed if the **IPC_NOWAIT** flag is not set ((**msgflg** and
**IPC_NOWAIT**) == 0); the operation would block if there is not a
message on the message queue of the desired type (**msgtyp**) to be
received. If the **IPC_NOWAIT** flag is set, the system call will fail
immediately when there is not a message of the desired type on the
queue. **msgflg** can also specify that the system call fail if the
message is longer than the **size** to be received; this is done by not
setting the **MSG_NOERROR** flag in the **msgflg** argument ((**msgflg**
and **MSG_NOERROR**)) == 0). If the **MSG_NOERROR** flag is set, the
message is truncated to the length specified by the **msgsz** argument
of **msgrcv**.

Further details of this system call are discussed in the following
program. If you need more information on the logic manipulations in this
program, read `\``Using
msgget'' <_Getting_Message_Queues.html#IC_msgget>`__. It goes into more
detail than would be practical for every system call.

--------------

/Example program
================

`\`\`\ msgop system call example'' <_Example_Program3.html#ipc_i7>`__ is
a menu-driven program. It allows all possible combinations of using the
**msgsnd** and **msgrcv** system calls to be exercised.

From studying this program, you can observe the method of passing
arguments and receiving return values. The user-written program
requirements are pointed out.

This program begins (lines 5-9) by including the required header files
as specified on the `msgop\ (S) <../man/html.S/msgop.S.html>`__. Note
that in this program **errno** is declared as an external variable;
therefore, the *sys/errno.h* header file does not have to be included.

| Variable and structure names have been chosen to be as close as
  possible to those in the synopsis. Their declarations are self
  explanatory. These names make the program more readable and are
  perfectly valid since they are local to the program.

The variables declared for this program and what they are used for are
as follows: 

**sndbuf**
   used as a buffer to contain a message to be sent (line 13); it uses
   the **msgbuf1** data structure as a template (lines 10-13). The
   **msgbuf1** structure (lines 10-13) is a duplicate of the **msgbuf**
   structure contained in the *sys/msg.h* header file, except that the
   size of the character array for **mtext** is tailored to fit this
   application. The **msgbuf** structure should not be used directly
   because **mtext** has only one element that would limit the size of
   each message to one character. Instead, declare your own structure.
   It should be identical to **msgbuf** except that the size of the
   **mtext** array should fit your application.
**rcvbuf**
   used as a buffer to receive a message (line 13); it uses the
   **msgbuf1** data structure as a template (lines 10-13)
**msgp**
   used as a pointer (line 13) to both the **sndbuf** and **rcvbuf**
   buffers
**i**
   used as a counter for inputing characters from the keyboard, storing
   them in the array, and keeping track of the message length for the
   **msgsnd** system call; it is also used as a counter to output the
   received message for the **msgrcv** system call
**c**
   used to receive the input character from the **getchar** function
   (line 50)
**flag**
   used to store the code of **IPC_NOWAIT** for the **msgsnd** system
   call (line 61)
**flags**
   used to store the code of the **IPC_NOWAIT** or **MSG_NOERROR** flags
   for the **msgrcv** system call (line 117)
**choice**
   used to store the code for sending or receiving (line 30)
**rtrn**
   used to store the return values from all system calls
**msqid**
   used to store and pass the desired message queue identifier for both
   system calls
**msgsz**
   used to store and pass the **size** of the message to be sent or
   received
**msgflg**
   used to pass the value of flag for sending or the value of flags for
   receiving
**msgtyp**
   used for specifying the message type for sending or for picking a
   message type for receiving.

Note that a **msqid_ds** data structure is set up in the program (line
21) with a pointer initialized to point to it (line 22); this will allow
the data structure members affected by message operations to be
observed. They are observed by using the **msgctl** (**IPC_STAT**)
system call to get them for the program to print them out (lines 80-92
and lines 160-167).

The first thing the program prompts for is whether to send or receive a
message. A corresponding code must be entered for the desired operation;
it is stored in the choice variable (lines 23-30). Depending upon the
code, the program proceeds as in the following **msgsnd** or **msgrcv**
sections.

msgsnd
------

When the code is to send a message, the **msgp** pointer is initialized
(line 33) to the address of the send data structure, **sndbuf**. Next, a
message type must be entered for the message; it is stored in the
variable **msgtyp** (line 42), and then (line 43) it is put into the
**mtype** member of the data structure pointed to by **msgp**.

The program now prompts for a message to be entered from the keyboard
and enters a loop of getting and storing into the **mtext** array of the
data structure (lines 48-51). This will continue until an end-of-file is
recognized which, for the **getchar** function, is a CTRL-d immediately
following a carriage return (<Return>).

The message is immediately echoed from the **mtext** array of the
**sndbuf** data structure to provide feedback (lines 54-56).

The next and final thing that must be decided is whether to set the
**IPC_NOWAIT** flag. The program does this by requesting that a code of
a 1 be entered for yes or anything else for no (lines 57-65). It is
stored in the flag variable. If a 1 is entered, **IPC_NOWAIT** is
logically ORed with **msgflg**; otherwise, **msgflg** is set to zero.

The **msgsnd** system call is performed (line 69). If it is
unsuccessful, a failure message is displayed along with the error number
(lines 70-72). If it is successful, the returned value is printed and
should be zero (lines 73-76).

Every time a message is successfully sent, three members of the
associated data structure are updated. They are: 

**msg_qnum**
   represents the total number of messages on the message queue; it is
   incremented by one.
**msg_lspid**
   contains the process identification (PID) number of the last process
   sending a message; it is set accordingly.
**msg_stime**
   contains the time in seconds since January 1, 1970, Greenwich Mean
   Time (GMT) of the last message sent; it is set accordingly.

These members are displayed after every successful message send
operation (lines 79-92).

msgrcv
------

When the code is to receive a message, the program continues execution
as in the following paragraphs.

The **msgp** pointer is initialized to the **rcvbuf** data structure
(line 99).

Next, the message queue identifier of the message queue from which to
receive the message is requested; it is stored in **msqid** (lines
100-103).

The message type is requested; it is stored in **msgtyp** (lines
104-107).

The code for the desired combination of control flags is requested next;
it is stored in flags (lines 108-117). Depending upon the selected
combination, **msgflg** is set accordingly (lines 118-131).

Finally, the number of bytes to be received is requested; it is stored
in **msgsz** (lines 132-135).

| The **msgrcv** system call is performed (line 142). If it is
  unsuccessful, a message and error number is displayed (lines 143-145).
  If successful, a message indicates so, and the number of bytes
  returned and the **msg** type returned (because the
| value returned may be different from the value requested) is displayed
  followed by the received message (lines 150-156).

When a message is successfully received, three members of the associated
data structure are updated. They are: 

``msg_qnum``
   contains the number of messages on the message queue; it is
   decremented by one.
``msg_lrpid``
   contains the PID of the last process receiving a message; it is set
   accordingly.
``msg_rtime``
   contains the time in seconds since January 1, 1970, Greenwich Mean
   Time (GMT) that the last process received a message; it is set
   accordingly.

`\`\`\ msgop system call example'' <_Example_Program3.html#ipc_i7>`__
shows the **msgop** system calls. We suggest that you put the program
into a source file called *msgop.c* and then compile it into an
executable file called **msgop**.

::

     1    /*This is a program to illustrate
     2     *the message operations, msgop(),
     3     *system call capabilities.
     4     */

     5    /*Include necessary header files.*/
     6    #include    <stdio.h>
     7    #include    <sys/types.h>
     8    #include    <sys/ipc.h>
     9    #include    <sys/msg.h>

    10    struct msgbuf1 {
    11        long    mtype;
    12        char    mtext[8192];
    13    } sndbuf, rcvbuf, *msgp;

    14    /*Start of main C language program*/
    15    main()
    16    {
    17        extern int errno;
    18        int i, c, flag, flags, choice;
    19        int rtrn, msqid, msgsz, msgflg;
    20        long mtype, msgtyp;
    21        struct msqid_ds msqid_ds, *buf;
    22        buf = & msqid_ds;

    23        /*Select the desired operation.*/
    24        printf("Enter the corresponding\n");
    25        printf("code to send or\n");
    26        printf("receive a message:\n");
    27        printf("Send            =  1\n");
    28        printf("Receive         =  2\n");
    29        printf("Entry           =  ");
    30        scanf("%d", &choice);

    31        if(choice == 1) /*Send a message.*/
    32        {
    33            msgp = & sndbuf; /*Point to user send structure.*/

    34            printf("\nEnter the msqid of\n");
    35            printf("the message queue to\n");
    36            printf("handle the message = ");
    37            scanf("%d", &msqid);

    38            /*Set the message type.*/
    39            printf("\nEnter a positive integer\n");
    40            printf("message type (long) for the\n");
    41            printf("message = ");
    42            scanf("%ld", &msgtyp);
    43            msgp->mtype = msgtyp;

    44            /*Enter the message to send.*/
    45            printf("\nEnter a message: \n");

    46            /*A control-d (^d) terminates as
    47              EOF.*/

    48            /*Get each character of the message
    49              and put it in the mtext array.*/
    50            for(i = 0; ((c = getchar()) != EOF); i++)
    51                sndbuf.mtext[i] = c;

    52            /*Determine the message size.*/
    53            msgsz = i;

    54            /*Echo the message to send.*/
    55            for(i = 0; i < msgsz; i++)
    56                putchar(sndbuf.mtext[i]);

    57            /*Set the IPC_NOWAIT flag if
    58              desired.*/
    59            printf("\nEnter a 1 if you want \n");
    60            printf("the IPC_NOWAIT flag set:  ");
    61            scanf("%d", &flag);
    62            if(flag == 1)
    63                msgflg = IPC_NOWAIT;
    64            else
    65                msgflg = 0;

    66            /*Check the msgflg.*/
    67            printf("\nmsgflg = 0%o\n", msgflg);

    68            /*Send the message.*/
    69            rtrn = msgsnd(msqid, (const void*) msgp, msgsz, msgflg);
    70            if(rtrn == -1)
    71            printf("\nMsgsnd failed.  Error = %d\n",
    72                    errno);
    73            else {
    74                /*Print the value of test which
    75                      should be zero for successful.*/
    76                printf("\nValue returned = %d\n", rtrn);

    77                /*Print the size of the message
    78                  sent.*/
    79                printf("\nMsgsz = %d\n", msgsz);

    80                /*Check the data structure update.*/
    81                msgctl(msqid, IPC_STAT, buf);

    82                /*Print out the affected members.*/

    83                /*Print the incremented number of
    84                  messages on the queue.*/
    85                printf("\nThe msg_qnum = %d\n",
    86                    buf->msg_qnum);
    87                /*Print the process id of the last sender.*/
    88                printf("The msg_lspid = %d\n",
    89                    buf->msg_lspid);
    90                /*Print the last send time.*/
    91                printf("The msg_stime = %d\n",
    92                    buf->msg_stime);
    93            }
    94        }

    95        if(choice == 2)  /*Receive a message.*/
    96        {
    97            /*Initialize the message pointer
    98              to the receive buffer.*/
    99            msgp = & rcvbuf;

   100            /*Specify the message queue which contains
   101                   the desired message.*/
   102            printf("\nEnter the msqid = ");
   103            scanf("%d", &msqid);

   104            /*Specify the specific message on the queue
   105                  by using its type.*/
   106            printf("\nEnter the msgtyp = ");
   107            scanf("%ld", &msgtyp);

   108            /*Configure the control flags for the
   109                  desired actions.*/
   110            printf("\nEnter the corresponding code\n");
   111            printf("to select the desired flags: \n");
   112            printf("No flags                    =  0\n");
   113            printf("MSG_NOERROR                 =  1\n");
   114            printf("IPC_NOWAIT                  =  2\n");
   115            printf("MSG_NOERROR and IPC_NOWAIT  =  3\n");
   116            printf("                Flags       =  ");
   117            scanf("%d", &flags);

   118            switch(flags) {
   119            case 0: 
   120                msgflg = 0;
   121                break;
   122            case 1: 
   123                msgflg = MSG_NOERROR;
   124                break;
   125            case 2: 
   126                msgflg = IPC_NOWAIT;
   127                break;
   128            case 3: 
   129                msgflg = MSG_NOERROR | IPC_NOWAIT;
   130                break;
   131            }

   132            /*Specify the number of bytes to receive.*/
   133            printf("\nEnter the number of bytes\n");
   134            printf("to receive (msgsz) = ");
   135            scanf("%d", &msgsz);

   136            /*Check the values for the arguments.*/
   137            printf("\nmsqid =%d\n", msqid);
   138            printf("\nmsgtyp = %ld\n", msgtyp);
   139            printf("\nmsgsz = %d\n", msgsz);
   140            printf("\nmsgflg = 0%o\n", msgflg);

   141            /*Call msgrcv to receive the message.*/
   142            rtrn = msgrcv(msqid, (void*), msgp, msgsz, msgtyp, msgflg);

   143            if(rtrn == -1)  {
   144                printf("\nMsgrcv failed., Error = %d\n", errno);
   145            }
   146            else {
   147                printf ("\nMsgctl was successful\n");
   148                printf("for msqid = %d\n",
   149                    msqid);

   150                /*Print the number of bytes received,
   151                  it is equal to the return
   152                  value.*/
   153                printf("Bytes received = %d\n", rtrn);

   154                /*Print the received message.*/
   155                for(i = 0; i<rtrn; i++)
   156                    putchar(rcvbuf.mtext[i]);
   157            }
   158            /*Check the associated data structure.*/
   159            msgctl(msqid, IPC_STAT, buf);
   160            /*Print the decremented number of messages.*/
   161            printf("\nThe msg_qnum = %d\n", buf->msg_qnum);
   162            /*Print the process id of the last receiver.*/
   163            printf("The msg_lrpid = %d\n", buf->msg_lrpid);
   164            /*Print the last message receive time*/
   165            printf("The msg_rtime = %d\n", buf->msg_rtime);
   166        }
   167    }

**msgop system call example**

--------------

/Semaphores
===========

The semaphore type of IPC allows processes (executing programs) to
communicate through the exchange of semaphore values. Since many
applications require the use of more than one semaphore, the SCO
OpenServer operating system has the ability to create sets or arrays of
semaphores. A semaphore set can contain one or more semaphores up to a
limit set by the system administrator. The tunable parameter,
**SEMMSL**, has a default value of 25. Semaphore sets are created by
using the **semget** (semaphore get) system call.

The process performing the **semget** system call becomes the
owner/creator, determines how many semaphores are in the set, and sets
the initial operation permissions for all processes, including itself.
This process can subsequently relinquish ownership of the set or change
the operation permissions using the **semctl** (semaphore control)
system call. The creating process always remains the creator as long as
the facility exists. Other processes with permission can use **semctl**
to perform other control functions.

Any process can manipulate the semaphore(s) if the owner of the
semaphore grants permission.

Each semaphore within a set can be incremented and decremented with the
`semop\ (S) <../man/html.S/semop.S.html>`__ system call.

To increment a semaphore, an integer value of the desired magnitude is
passed to the **semop** system call. To decrement a semaphore, a minus
(**-**) value of the desired magnitude is passed.

The SCO OpenServer operating system ensures that only one process can
manipulate a semaphore set at any given time. Simultaneous requests are
performed sequentially in an arbitrary manner.

A process can test for a semaphore value to be greater than a certain
value by attempting to decrement the semaphore by one more than that
value. If the process is successful, then the semaphore value is greater
than that certain value. Otherwise, the semaphore value is not. While
doing this, the process can have its execution suspended (**IPC_NOWAIT**
flag not set) until the semaphore value would permit the operation
(other processes increment the semaphore), or the semaphore facility is
removed.

The ability to suspend execution is called a \``blocking semaphore
operation.'' This ability is also available for a process which is
testing for a semaphore equal to zero; only read permission is required
for this test; it is accomplished by passing a value of zero to the
**semop** (semaphore operation) system call.

On the other hand, if the process is not successful and did not request
to have its execution suspended, it is called a \``nonblocking semaphore
operation.'' In this case, the process is returned a known error code
(**-1**), and the external **errno** variable is set accordingly.

The blocking semaphore operation allows processes to communicate based
on the values of semaphores at different points in time. Remember also
that IPC facilities remain in the SCO OpenServer operating system until
removed by a permitted process or until the system is reinitialized.

Operating on a semaphore set is done by using the **semop** system call.

When a set of semaphores is created, the first semaphore in the set is
semaphore number zero. The last semaphore number in the set is numbered
one less than the total in the set.

A single system call can be used to perform a sequence of these
\``blocking/nonblocking operations'' on a set of semaphores. When
performing a sequence of operations, the blocking/nonblocking operations
can be applied to any or all of the semaphores in the set. Also, the
operations can be applied in any order of semaphore number. However, no
operations are done until they can all be done successfully. For
example, if the first three of six operations on a set of ten semaphores
could be completed successfully, but the fourth operation would be
blocked, no changes are made to the set until all six operations can be
performed without blocking. Either the operations are successful and the
semaphores are changed, or one (\``nonblocking'') operation is
unsuccessful and none are changed. In short, the operations are
\``atomically performed.''

Remember, any unsuccessful nonblocking operation for a single semaphore
or a set of semaphores causes immediate return with no operations
performed at all. When this occurs, an error code (**-1**) is returned
to the process, and the external variable **errno** is set accordingly.

System calls make these semaphore capabilities available to processes.
The calling process passes arguments to a system call, and the system
call either successfully or unsuccessfully performs its function. If the
system call is successful, it performs its function and returns the
appropriate information. Otherwise, a known error code (-1) is returned
to the process, and the external variable **errno** is set accordingly.

--------------

/Using semaphores
=================

Before semaphores can be used (operated on or controlled) a uniquely
identified data structure and semaphore set (array) must be created. The
unique identifier is called the semaphore set identifier (**semid**); it
is used to identify or refer to a particular data structure and
semaphore set. This identifier is accessible by any process in the
system, subject to normal access restrictions.

The semaphore set contains a predefined number of structures in an
array, one structure for each semaphore in the set. The number of
semaphores (**nsems**) in a semaphore set is user selectable. The
following members are in each structure within a semaphore set: 

-  semaphore value
-  PID performing last operation
-  number of processes waiting for the semaphore value to become greater
   than its current value
-  number of processes waiting for the semaphore value to equal zero

There is one associated data structure for the uniquely identified
semaphore set. This data structure contains the following information
related to the semaphore set: 

-  operation permissions data (operation permissions structure)
-  pointer to first semaphore in the set (array)
-  number of semaphores in the set
-  last semaphore operation time
-  last semaphore change time

The definition for the semaphore set (array member) **sem** is as
follows: 

::

      struct sem
      {
              ushort  semval;         /* semaphore value */
              pid_t   sempid;         /* pid of last operation */
              ushort  semncnt;        /* # awaiting semval > cval */
              ushort  semzcnt;        /* # awaiting semval = 0 */
      };

Likewise, the definition for the associated semaphore data structure
**semid_ds** contains the following members: 

::

      struct semid_ds
      {
              struct ipc_perm sem_perm;   /* operation permission struct */
              struct sem      *sem_base;  /* ptr to first semaphore in set */
              ushort          sem_nsems;  /* # of semaphores in set */
              time_t          sem_otime;  /* last semop time */
              time_t          sem_ctime;  /* last change time */
      };

The C programming language data structure definition for the semaphore
set (array member) and for the **semid_ds** data structure are located
in the *sys/sem.h* header file.

Note that the **sem_perm** member of this structure uses **ipc_perm** as
a template. `\`\`\ ipc_perm data
structure'' <_Using_Messages.html#ipc_i1>`__ breaks out the operation
permissions data structure.

The **ipc_perm** data structure is the same for all IPC facilities; it
is located in the *sys/ipc.h* header file and is shown in the
`\``Messages'' <IC_Msgs.html>`__.

The **semget** system call is used to perform two tasks: 

-  to get a new semaphore set identifier and create an associated data
   structure and semaphore set for it
-  to return an existing semaphore set identifier that already has an
   associated data structure and semaphore set

The task performed is determined by the value of the **key** argument
passed to the **semget** system call. For the first task, if the **key**
is not already in use for an existing **semid** and the **IPC_CREAT**
flag is set, a new **semid** is returned with an associated data
structure and semaphore set created for it provided no system tunable
parameter would be exceeded.

There is also a provision for specifying a **key** of value zero (0),
which is known as the private **key** (**IPC_PRIVATE**). When this
**key** is specified, a new identifier is always returned with an
associated data structure and semaphore set created for it, unless a
system-tunable parameter would be exceeded. The **ipcs** command will
show the **key** field for the **semid** as all zeros.

When performing the first task, the process which calls **semget**
becomes the owner/creator, and the associated data structure is
initialized accordingly. Remember, ownership can be changed, but the
creating process always remains the creator (see `\``Controlling
semaphores'' <IC_CntllSems.html>`__). The creator of the semaphore set
also determines the initial operation permissions for the facility.

For the second task, if a semaphore set identifier exists for the
**key** specified, the value of the existing identifier is returned. If
you do not want to have an existing semaphore set identifier returned, a
control command (**IPC_EXCL**) can be specified (set) in the **semflg**
argument passed to the system call. The system call will fail if it is
passed a value for the number of semaphores (**nsems**) that is greater
than the number actually in the set; if you do not know how many
semaphores are in the set, use 0 for **nsems** (see `\``Using
semget'' <_Getting_Semaphores.html#IC_semget>`__ for how to use this
system call).

Once a uniquely identified semaphore set and data structure are created,
**semop** (semaphore operations) and **semctl** (semaphore control) can
be used.

Semaphore operations consist of incrementing, decrementing, and testing
for zero. The **semop** system call is used to perform these operations
(see `\``Operations on semaphores'' <IC_OpsSems.html>`__ for details of
the **semop** system call.

The **semctl** system call permits you to control the semaphore facility
in the following ways: 

-  by returning the value of a semaphore (**GETVAL**)
-  by setting the value of a semaphore (**SETVAL**)
-  by returning the PID of the last process performing an operation on a
   semaphore set (**GETPID**)
-  by returning the number of processes waiting for a semaphore value to
   become greater than its current value (**GETNCNT**)
-  by returning the number of processes waiting for a semaphore value to
   equal zero (**GETZCNT**)
-  by getting all semaphore values in a set and placing them in an array
   in user memory (**GETALL**)
-  by setting all semaphore values in a semaphore set from an array of
   values in user memory (**SETALL**)
-  by retrieving the data structure associated with a semaphore set
   (**IPC_STAT**)
-  by changing operation permissions for a semaphore set (**IPC_SET**)
-  by removing a particular semaphore set identifier from the SCO
   OpenServer operating system along with its associated data structure
   and semaphore set (**IPC_RMID**)

See the section `\``Controlling semaphores'' <IC_CntllSems.html>`__ for
details of the **semctl** system call.

--------------

/Getting semaphores
===================

This section describes how to use the **semget** system call. The
accompanying program illustrates its use.

Using semget
------------

The synopsis found on the `semget\ (S) <../man/html.S/semget.S.html>`__
manual page is as follows: 

::

      #include  <sys/types.h>
      #include  <sys/ipc.h>
      #include  <sys/sem.h>
      
      int  semget (key, nsems, semflag)
      key_t  key;
      int nsems, semflag;

The following line in the synopsis: 

::

   int semget (key, nsems, semflg)

informs you that **semget** is a function with three formal arguments
that returns an integer-type value. The next two lines: 

::

   key_t  key;
   int nsems, semflg;

declare the types of the formal arguments. **key_t** is defined by a
**typedef** in the *sys/types.h* header file to be an integer.

The integer returned from this system call upon successful completion is
the semaphore set identifier that was discussed above.

The process calling the **semget** system call must supply three actual
arguments to be passed to the formal **key**, **nsems**, and **semflg**
arguments.

A new **semid** with an associated semaphore set and data structure is
created if either

-  **key** is equal to **IPC_PRIVATE**,

or

-  **key** is a unique integer and **semflg** ANDed with **IPC_CREAT**
   is \``true.''

The value passed to the **semflg** argument must be an integer that will
specify the following: 

-  operation permissions
-  control fields (commands)

`\``Operation permissions codes'' <_Getting_Semaphores.html#ipc_i8>`__
reflects the numeric values (expressed in octal notation) for the valid
operation permissions codes.

**Operation permissions codes**

  ===================== ===========
  Operation permissions Octal value
  ===================== ===========
  Read by user          00400
  Alter by user         00200
  Read by group         00040
  Alter by group        00020
  Read by others        00004
  Alter by others       00002
  ===================== ===========

A specific value is derived by adding or bitwise ORing the values for
the operation permissions wanted. That is, if read by user and
read/alter by others is desired, the code value would be 00406 (00400
plus 00006). There are constants **#define**'d in the *sys/sem.h* header
file which can be used for the user (OWNER). They are as follows: 

::

   SEM_A    0200    /* alter permission by owner */
   SEM_R    0400    /* read permission by owner */

Control flags are predefined constants (represented by all upper-case
letters). The flags that apply to the **semget** system call are
**IPC_CREAT** and **IPC_EXCL** and are defined in the *sys/ipc.h* header
file.

The value for **semflg** is, therefore, a combination of operation
permissions and control commands. After determining the value for the
operation permissions as previously described, the desired flag(s) can
be specified. This specification is accomplished by adding or bitwise
ORing (\|) them with the operation permissions; the bit positions and
values for the control commands in relation to those of the operation
permissions make this possible.

The **semflg** value can easily be set by using the flag names in
conjunction with the octal operation permissions value: 

::

   semid = semget (key, nsems, (IPC_CREAT | 0400));

   semid = semget (key, nsems, (IPC_CREAT | IPC_EXCL | 0400));

As specified on the `semget\ (S) <../man/html.S/semget.S.html>`__ manual
page, success or failure of this system call depends upon the actual
argument values for **key**, **nsems**, and **semflg**, and
system-tunable parameters. The system call will attempt to return a new
semaphore set identifier if one of the following conditions is true: 

-  **key** is equal to **IPC_PRIVATE**
-  **key** does not already have a semaphore set identifier associated
   with it and (**semflg** & **IPC_CREAT**) is \``true'' (not zero).

The **key** argument can be set to **IPC_PRIVATE** like this: 

::

   semid = semget(IPC_PRIVATE, nsems, semflg);

Exceeding the **SEMMNI**, **SEMMNS**, or **SEMMSL** system-tunable
parameters will always cause a failure. The **SEMMNI** system-tunable
parameter determines the maximum number of unique semaphore sets
(**semid**'s) that may be in use at any given time. The **SEMMNS**
system-tunable parameter determines the maximum number of semaphores in
all semaphore sets system wide. The **SEMMSL** system-tunable parameter
determines the maximum number of semaphores in each semaphore set.

**IPC_EXCL** is another control command used in conjunction with
**IPC_CREAT**. It will cause the system call to return an error if a
semaphore set identifier already exists for the specified **key**
provided. This is necessary to prevent the process from thinking that it
has received a new (unique) identifier when it has not. In other words,
when both **IPC_CREAT** and **IPC_EXCL** are specified, a new semaphore
set identifier is returned if the system call is successful. Any value
for **semflg** returns a new identifier if the **key** equals zero
(IPC_PRIVATE) and no system-tunable parameters are exceeded.

Refer to the `semget\ (S) <../man/html.S/semget.S.html>`__ manual page
for specific associated data structure initialization for successful
completion. The specific failure conditions and their error names are
contained there also.

--------------

/Example program
================

`\`\`\ semget system call example'' <_Example_Program4.html#ipc_i9>`__
is a menu-driven program. It allows all possible combinations of using
the **semget** system call to be exercised.

From studying this program, you can observe the method of passing
arguments and receiving return values. The user-written program
requirements are pointed out.

This program begins (lines 4-8) by including the required header files
as specified by the `semget\ (S) <../man/html.S/semget.S.html>`__ manual
page. Note that the *sys/errno.h* header file is included as opposed to
declaring **errno** as an external variable; either method will work.

Variable names have been chosen to be as close as possible to those in
the synopsis. Their declarations are self explanatory. These names make
the program more readable and are perfectly valid since they are local
to the program.

The variables declared for this program and what they are used for are
as follows: 

**key**
   used to pass the value for the desired key
**opperm**
   used to store the desired operation permissions
**flags**
   used to store the desired control commands (flags)
**opperm_flags**
   used to store the combination from the logical ORing of the
   **opperm** and **flags** variables; it is then used in the system
   call to pass the **semflg** argument
**semid**
   used for returning the semaphore set identification number for a
   successful system call or the error code (**-1**) for an unsuccessful
   one.

The program begins by prompting for a hexadecimal **key**, an octal
operation permissions code, and the control command combinations (flags)
which are selected from a menu (lines 15-32). All possible combinations
are allowed even though they might not be viable. This allows observing
the errors for invalid combinations.

Next, the menu selection for the flags is combined with the operation
permissions; the result is stored in **opperm_flags** (lines 36-52).

Then, the number of semaphores for the set is requested (lines 53-57);
its value is stored in **nsems**.

The system call is made next; the result is stored in the **semid**
(lines 60, 61).

Since the **semid** variable now contains a valid semaphore set
identifier or the error code (**-1**), it is tested to see if an error
occurred (line 63). If **semid** equals **-1**, a message indicates that
an error resulted and the external **errno** variable is displayed (line
65). Remember that the external **errno** variable is only set when a
system call fails; it should only be examined immediately following
system calls.

If no error occurred, the returned semaphore set identifier is displayed
(line 69).

The example program for the **semget** system call follows. We suggest
that you name the source program file *semget.c* and the executable file
**semget**.

::

    1    /*This is a program to illustrate
    2     *the semaphore get, semget(),
    3     *system call capabilities.*/

    4    #include    <stdio.h>
    5    #include    <sys/types.h>
    6    #include    <sys/ipc.h>
    7    #include    <sys/sem.h>
    8    #include    <errno.h>

    9    /*Start of main C language program*/
   10    main()
   11    {
   12        key_t key;     /*declare as long integer*/
   13        int opperm, flags, nsems;
   14        int semid, opperm_flags;

   15        /*Enter the desired key*/
   16        printf("\nEnter the desired key in hex = ");
   17        scanf("%x", &key);

   18        /*Enter the desired octal operation
   19              permissions.*/
   20        printf("\nEnter the operation\n");
   21        printf("permissions in octal = ");
   22        scanf("%o", &opperm);

   23        /*Set the desired flags.*/
   24        printf("\nEnter corresponding number to\n");
   25        printf("set the desired flags:\n");
   26        printf("No flags                  = 0\n");
   27        printf("IPC_CREAT                 = 1\n");
   28        printf("IPC_EXCL                  = 2\n");
   29        printf("IPC_CREAT and IPC_EXCL    = 3\n");
   30        printf("            Flags         = ");
   31        /*Get the flags to be set.*/
   32        scanf("%d", &flags);

   33        /*Error checking (debugging)*/
   34        printf ("\nkey =0x%x, opperm = 0%o, flags = %d\n",
   35            key, opperm, flags);
   36        /*Incorporate the control fields (flags) with
   37              the operation permissions.*/
   38        switch (flags)
   39        {
   40        case 0:    /*No flags are to be set.*/
   41            opperm_flags = (opperm | 0);
   42            break;
   43        case 1:    /*Set the IPC_CREAT flag.*/
   44            opperm_flags = (opperm | IPC_CREAT);
   45            break;
   46        case 2:    /*Set the IPC_EXCL flag.*/
   47            opperm_flags = (opperm | IPC_EXCL);
   48            break;
   49        case 3: /*Set the IPC_CREAT and IPC_EXCL
   50                      flags.*/
   51            opperm_flags = (opperm | IPC_CREAT | IPC_EXCL);
   52            break;
   53        default: /* Invalid Input */
   54            exit(-1);
   55        }

   56        /*Get the number of semaphores for this set.*/
   57        printf("\nEnter the number of\n");
   58        printf("desired semaphores for\n");
   59        printf("this set (25 max) = ");
   60        scanf("%d", &nsems);

   61        /*Check the entry.*/
   62        printf("\nNsems = %d\n", nsems);

   63        /*Call the semget system call.*/
   64        semid = semget(key, nsems, opperm_flags);

   65        /*Perform the following if the call is unsuccessful.*/
   66        if(semid == -1)
   67        {
   68            printf("The semget call failed, error number = %d\n", errno);
   69        }
   70        /*Return the semid upon successful completion.*/
   71        else
   72            printf("\nThe semid = %d\n", semid);
   73        exit(0);
   74    }

**semget system call example**

--------------


/Controlling semaphores
=======================

This section describes how to use the **semctl** system call. The
accompanying program illustrates its use.

Using semctl
------------

The synopsis found on the `semctl\ (S) <../man/html.S/semctl.S.html>`__
manual page is as follows: 

::

      #include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/sem.h>
      
      int semctl (semid, semnum, cmd, arg)
      int semid, cmd;
      int semnum;
      union semun
      {
              int val;
              struct semid_ds *buf;
              ushort *array;
      } arg;

The **semctl** system call requires four arguments to be passed to it,
and it returns an integer value.

The **semid** argument must be a valid, non-negative, integer value that
has already been created by using the **semget** system call.

The **semnum** argument is used to select a semaphore by its number.
This relates to sequences of operations (atomically performed) on the
set. When a set of semaphores is created, the first semaphore is number
0, and the last semaphore is numbered one less than the total in the
set.

The **cmd** argument can be replaced by one of the following values: 

**GETVAL**
   return the value of a single semaphore within a semaphore set
**SETVAL**
   set the value of a single semaphore within a semaphore set
**GETPID**
   return the PID of the process that performed the last operation on
   the semaphore within a semaphore set
**GETNCNT**
   return the number of processes waiting for the value of a particular
   semaphore to become greater than its current value
**GETZCNT**
   return the number of processes waiting for the value of a particular
   semaphore to be equal to zero
**GETALL**
   return the value for all semaphores in a semaphore set
**SETALL**
   set all semaphore values in a semaphore set
**IPC_STAT**
   return the status information contained in the associated data
   structure for the specified **semid**, and place it in the data
   structure pointed to by the **buf** pointer in the user memory area;
   **arg.buf** is the union member that contains pointer
**IPC_SET**
   for the specified semaphore set (**semid**), set the effective
   user/group identification and operation permissions
**IPC_RMID**
   remove the specified semaphore set (**semid**) along with its
   associated data structure.

To perform an **IPC_SET** or **IPC_RMID** control command, a process
must have: 

-  an effective user id of OWNER/CREATOR, or
-  an effective user id of *root* (if the system is running with the SUM
   privilege module), or
-  the **P_OWNER** privilege,

The remaining control commands require either read or write permission,
as appropriate.

The **arg** argument is used to pass the system call the appropriate
union member for the control command to be performed. For some of the
control commands, the **arg** argument is not required and is simply
ignored.

-  **arg.val** required: **SETVAL**
-  **arg.buf** required: **IPC_STAT**, **IPC_SET**
-  **arg.array** required: **GETALL**, **SETALL**
-  **arg** ignored: **GETVAL, GETPID, GETNCNT, GETZCNT, IPC_RMID**

The details of this system call are discussed in the following program.
If you need more information on the logic manipulations in this program,
read `\``Using semget'' <_Getting_Semaphores.html#IC_semget>`__. It goes
into more detail than would be practical for every system call.

--------------

/Example program
================

`\`\`\ semctl system call example'' <_Example_Program5.html#ipc_iA>`__
is a menu-driven program. It allows all possible combinations of using
the **semctl** system call to be exercised.

From studying this program, you can observe the method of passing
arguments and receiving return values. The user-written program
requirements are pointed out.

This program begins (lines 5-9) by including the required header files
as specified by the `semctl\ (S) <../man/html.S/semctl.S.html>`__ manual
page. Note that in this program **errno** is declared as an external
variable, and therefore the *sys/errno.h* header file does not have to
be included.

| Variable, structure, and union names have been chosen to be as close
  as possible to those in the synopsis. Their declarations are self
  explanatory. These names make the program more readable and are
  perfectly valid since they are local to the program.

The variables declared for this program and what they are used for are
as follows: 

**semid_ds**
   used to receive the specified semaphore set identifier's data
   structure when an **IPC_STAT** control command is performed
**c**
   used to receive the input values from the **scanf** function (line
   119) when performing a **SETALL** control command
**i**
   used as a counter to increment through the union **arg.array** when
   displaying the semaphore values for a **GETALL** (lines 98-100)
   control command, and when initializing the **arg.array** when
   performing a **SETALL** (lines 117-121) control command
**length**
   used as a variable to test for the number of semaphores in a set
   against the **i** counter variable (lines 98, 117)
**uid**
   used to store the **IPC_SET** value for the user identification
**gid**
   used to store the **IPC_SET** value for the group identification
**mode**
   used to store the **IPC_SET** value for the operation permissions
**retrn**
   used to store the return value from the system call
**semid**
   used to store and pass the semaphore set identifier to the system
   call
**semnum**
   used to store and pass the semaphore number to the system call
**cmd**
   used to store the code for the desired control command so that
   subsequent processing can be performed on it
**choice**
   used to determine which member (**uid**, **gid**, **mode**) for the
   **IPC_SET** control command is to be changed
**semvals[]**
   used to store the set of semaphore values when getting (**GETALL**)
   or initializing (**SETALL**)
**arg.val**
   used to pass the system call a value to set, or to store a value
   returned from the system call, for a single semaphore (union member)
**arg.buf**
   a pointer passed to the system call which locates the data structure
   in the user memory area where the **IPC_STAT** control command is to
   place its return values, or where the **IPC_SET** command gets the
   values to set (union member)
**arg.array**
   a pointer passed to the system call which locates the array in the
   user memory where the **GETALL** control command is to place its
   return values, or when the **SETALL** command gets the values to set
   (union member)

Note that the **semid_ds** data structure in this program (line 14) uses
the data structure located in the *sys/sem.h* header file of the same
name as a template for its declaration.

Note that the **semvals** array is declared to have 25 elements (0
through 24). This number corresponds to the maximum number of semaphores
allowed per set (**SEMMSL**), a system-tunable parameter.

Now that all of the required declarations have been presented for this
program, this is how it works.

First, the program prompts for a valid semaphore set identifier, which
is stored in the **semid** variable (lines 24-26). This is required for
all **semctl** system calls.

Then, the code for the desired control command must be entered (lines
17-42), and the code is stored in the **cmd** variable. The code is
tested to determine the control command for subsequent processing.

If the **GETVAL** control command is selected (code 1), a message
prompting for a semaphore number is displayed (lines 48, 49). When it is
entered, it is stored in the **semnum** variable (line 50). Then, the
system call is performed, and the semaphore value is displayed (lines
51-54). Note that the **arg** argument is not required in this case, and
the system call will simply ignore it. If the system call is successful,
a message indicates this along with the semaphore set identifier used
(lines 197, 198); if the system call is unsuccessful, an error message
is displayed along with the value of the external **errno** variable
(lines 194, 195).

If the **SETVAL** control command is selected (code 2), a message
prompting for a semaphore number is displayed (lines 55, 56). When it is
entered, it is stored in the **semnum** variable (line 57). Next, a
message prompts for the value to which the semaphore is to be set; it is
stored as the **arg.val** member of the union (lines 58, 59). Then, the
system call is performed (lines 60, 62). Depending upon success or
failure, the program returns the same messages as for **GETVAL** above.

If the **GETPID** control command is selected (code 3), the system call
is made immediately since all required arguments are known (lines
63-66), and the PID of the process performing the last operation is
displayed. Note that the **arg** argument is not required in this case,
and the system call will simply ignore it. Depending upon success or
failure, the program returns the same messages as for **GETVAL** above.

If the **GETNCNT** control command is selected (code 4), a message
prompting for a semaphore number is displayed (lines 67-71). When
entered, it is stored in the **semnum** variable (line 73). Then, the
system call is performed and the number of processes waiting for the
semaphore to become greater than its current value is displayed (lines
73-76). Note that the **arg** argument is not required in this case, and
the system call will simply ignore it. Depending upon success or
failure, the program returns the same messages as for **GETVAL** above.

If the **GETZCNT** control command is selected (code 5), a message
prompting for a semaphore number is displayed (lines 77-80). When it is
entered, it is stored in the **semnum** variable (line 81). Then the
system call is performed and the number of processes waiting for the
semaphore value to become equal to zero is displayed (lines 82-85).
Depending upon success or failure, the program returns the same messages
as for **GETVAL** above.

If the **GETALL** control command is selected (code 6), the program
first performs an **IPC_STAT** control command to determine the number
of semaphores in the set (lines 87-93). The length variable is set to
the number of semaphores in the set (line 93). The **arg.array** union
member is set to point to the **semvals** array where the system call is
to store the values of the semaphore set (line 96). Now, a loop is
entered which displays each element of the **arg.array** from zero to
one less than the value of length (lines 98-104). The semaphores in the
set are displayed on a single line, separated by a space. Depending upon
success or failure, the program returns the same messages as for
**GETVAL** above.

If the **SETALL** control command is selected (code 7), the program
first performs an **IPC_STAT** control command to determine the number
of semaphores in the set (lines 107-110). The length variable is set to
the number of semaphores in the set (line 113). Next, the program
prompts for the values to be set and enters a loop which takes values
from the keyboard and initializes the **semvals** array to contain the
desired values of the semaphore set (lines 115-121). The loop puts the
first entry into the array position for semaphore number zero and ends
when the semaphore number that is filled in the array equals one less
than the value of length. The **arg.array** union member is set to point
to the **semvals** array from which the system call is to obtain the
semaphore values. The system call is then made (lines 122-125).
Depending upon success or failure, the program returns the same messages
as for **GETVAL** above.

If the **IPC_STAT** control command is selected (code 8), the system
call is performed (line 129), and the status information returned is
printed out (lines 130-141); only the members that can be set are
printed out in this program. Note that if the system call is
unsuccessful, the status information of the last successful one is
printed out. In addition, an error message is displayed, and the
**errno** variable is printed out (line 194).

If the **IPC_SET** control command is selected (code 9), the program
gets the current status information for the semaphore set identifier
specified (lines 145-149). This is necessary because this example
program provides for changing only one member at a time, and the
**semctl** system call changes all of them. Also, if an invalid value
happened to be stored in the user memory area for one of these members,
it would cause repetitive failures for this control command until
corrected. The next thing the program does is to prompt for a code
corresponding to the member to be changed (lines 150-156). This code is
stored in the **choice** variable (line 157). Now, depending upon the
member picked, the program prompts for the new value (lines 158-181).
The value is placed into the appropriate member in the user memory area
data structure, and the system call is made (line 184). Depending upon
success or failure, the program returns the same messages as for
**GETVAL** above.

If the **IPC_RMID** control command (code 10) is selected, the system
call is performed (lines 186-188). The semaphore set identifier along
with its associated data structure and semaphore set is removed from the
SCO OpenServer operating system. Depending upon success or failure, the
program returns the same messages as for the other control commands.

The example program for the **semctl** system call follows. We suggest
that you name the source program file *semctl.c* and the executable file
**semctl**.

::

     1    /*This is a program to illustrate
     2     *the semaphore control, semctl(),
     3     *system call capabilities.
     4     */

     5    /*Include necessary header files.*/
     6    #include    <stdio.h>
     7    #include    <sys/types.h>
     8    #include    <sys/ipc.h>
     9    #include    <sys/sem.h>

    10    /*Start of main C language program*/
    11    main()
    12    {
    13        extern int errno;
    14        struct semid_ds semid_ds;
    15        int c, i, length;
    16        int uid, gid, mode;
    17        int retrn, semid, semnum, cmd, choice;
    18        ushort semvals[25];
    19        union semun  {
    20            int val;
    21            struct semid_ds *buf;
    22            ushort *array;
    23        } arg;

    24        /*Enter the semaphore ID.*/
    25        printf("Enter the semid = ");
    26        scanf("%d", &semid);

    27        /*Choose the desired command.*/
    28        printf("\nEnter the number for\n");
    29        printf("the desired cmd:\n");
    30        printf("GETVAL      =  1\n");
    31        printf("SETVAL      =  2\n");
    32        printf("GETPID      =  3\n");
    33        printf("GETNCNT     =  4\n");
    34        printf("GETZCNT     =  5\n");
    35        printf("GETALL      =  6\n");
    36        printf("SETALL      =  7\n");
    37        printf("IPC_STAT    =  8\n");
    38        printf("IPC_SET     =  9\n");
    39        printf("IPC_RMID    =  10\n");
    40        printf("Entry       =  ");
    41        scanf("%d", &cmd);

    42        /*Check entries.*/
    43        printf ("\nsemid =%d, cmd = %d\n\n",
    44            semid, cmd);

    45        /*Set the command and do the call.*/
    46        switch (cmd)
    47        {

    48        case 1: /*Get a specified value.*/
    49            printf("\nEnter the semnum = ");
    50            scanf("%d", &semnum);
    51            /*Do the system call.*/
    52            retrn = semctl(semid, semnum, GETVAL, arg);
    53            printf("\nThe semval = %d", retrn);
    54            break;
    55        case 2: /*Set a specified value.*/
    56            printf("\nEnter the semnum = ");
    57            scanf("%d", &semnum);
    58            printf("\nEnter the value = ");
    59            scanf("%d", &arg.val);
    60            /*Do the system call.*/
    61            retrn = semctl(semid, semnum, SETVAL, arg);
    62            break;
    63        case 3: /*Get the process ID.*/
    64            retrn = semctl(semid, 0, GETPID, arg);
    65            printf("\nThe sempid = %d", retrn);
    66            break;
    67        case 4: /*Get the number of processes
    68            waiting for the semaphore to
    69            become greater than its current
    70            value.*/
    71            printf("\nEnter the semnum = ");
    72            scanf("%d", &semnum);
    73            /*Do the system call.*/
    74            retrn = semctl(semid, semnum, GETNCNT, arg);
    75            printf("\nThe semncnt = %d", retrn);
    76            break;

    77        case 5: /*Get the number of processes
    78            waiting for the semaphore
    79            value to become zero.*/
    80            printf("\nEnter the semnum = ");
    81            scanf("%d", &semnum);
    82            /*Do the system call.*/
    83            retrn = semctl(semid, semnum, GETZCNT, arg);
    84            printf("\nThe semzcnt = %d", retrn);
    85            break;

    86        case 6: /*Get all of the semaphores.*/
    87            /*Get the number of semaphores in
    88              the semaphore set.*/
    89            arg.buf = & semid_ds;
    90            retrn = semctl(semid, 0, IPC_STAT, arg);
    91            if(retrn == -1)
    92                goto ERROR;
    93            length = arg.buf->sem_nsems;
    94            /*Get and print all semaphores in the
    95              specified set.*/
    96            arg.array = semvals;
    97            retrn = semctl(semid, 0, GETALL, arg);
    98            for (i = 0; i < length; i++)
    99            {
   100                printf("%d", semvals[i]);
   101                /*Separate each
   102                  semaphore.*/
   103                printf(" ");
   104            }
   105            break;

   106        case 7: /*Set all semaphores in the set.*/
   107            /*Get the number of semaphores in
   108              the set.*/
   109            arg.buf = & semid_ds;
   110            retrn = semctl(semid, 0, IPC_STAT, arg);
   111            if(retrn == -1)
   112                goto ERROR;
   113            length = arg.buf->sem_nsems;
   114            printf("Length = %d\n", length);
   115            /*Set the semaphore set values.*/
   116            printf("\nEnter each value:\n");
   117            for(i = 0; i < length ; i++)
   118            {
   119                scanf("%d", &c);
   120                semvals[i] = c;
   121            }
   122            /*Do the system call.*/
   123            arg.array = semvals;
   124            retrn = semctl(semid, 0, SETALL, arg);
   125            break;

   126        case 8: /*Get the status for the semaphore set.*/
   127            /*Get and print the current status values.*/
   128            arg.buf = & semid_ds;
   129            retrn = semctl(semid, 0, IPC_STAT, arg);
   130            printf ("\nThe USER ID = %d\n",
   131                arg.buf->sem_perm.uid);
   132            printf ("The GROUP ID = %d\n",
   133                arg.buf->sem_perm.gid);
   134            printf ("The operation permissions = 0%o\n",
   135                arg.buf->sem_perm.mode);
   136            printf ("The number of semaphores in set = %d\n",
   137                arg.buf->sem_nsems);
   138            printf ("The last semop time = %d\n",
   139                arg.buf->sem_otime);
   140            printf ("The last change time  = %d\n",
   141                arg.buf->sem_ctime);
   142            break;

   143        case 9:    /*Select and change the desired
   144                      member of the data structure.*/
   145            /*Get the current status values.*/
   146            arg.buf = & semid_ds;
   147            retrn = semctl(semid, 0, IPC_STAT, arg.buf);
   148            if(retrn == -1)
   149                goto ERROR;
   150            /*Select the member to change.*/
   151            printf("\nEnter the number for the\n");
   152            printf("member to be changed:\n");
   153            printf("sem_perm.uid   = 1\n");
   154            printf("sem_perm.gid   = 2\n");
   155            printf("sem_perm.mode  = 3\n");
   156            printf("Entry          = ");
   157            scanf("%d", &choice);
   158            switch(choice){

   159            case 1: /*Change the user ID.*/
   160                printf("\nEnter USER ID = ");
   161                scanf ("%d", &uid);
   162                arg.buf->sem_perm.uid = uid;
   163                printf("\nUSER ID = %d\n",
   164                    arg.buf->sem_perm.uid);
   165                break;

   166            case 2: /*Change the group ID.*/
   167                printf("\nEnter GROUP ID = ");
   168                scanf("%d", &gid);
   169                arg.buf->sem_perm.gid = gid;
   170                printf("\nGROUP ID = %d\n",
   171                    arg.buf->sem_perm.gid);
   172                break;

   173            case 3: /*Change the mode portion of
   174                  the operation
   175                              permissions.*/
   176                printf("\nEnter MODE in octal = ");
   177                scanf("%o", &mode);
   178                arg.buf->sem_perm.mode = mode;
   179                printf("\nMODE = 0%o\n",
   180                    arg.buf->sem_perm.mode);
   181                break;
   182            default: /* Invalid Input */
   183                exit(-1);
   184            }
   185            /*Do the change.*/
   186            retrn = semctl(semid, 0, IPC_SET, arg);
   187            break;
   188        case 10:    /*Remove the semid along with its
   189                      data structure.*/
   190            retrn = semctl(semid, 0, IPC_RMID, arg);
   191            break;
   192        default: /* Invalid Input */
   193            exit(-1);
   194        }
   195        /*Perform the following if the call is unsuccessful.*/
   196        if(retrn == -1)
   197        {
   198    ERROR: 
   199           printf ("\nThe semctl call failed!, error number =  %d\n", errno);
   200            exit(0);
   201        }
   202        printf ("\n\nThe semctl system call was successful\n");
   203        printf ("for semid = %d\n", semid);
   204        exit (0);
   205    }

**semctl system call example**

--------------

/Operations on semaphores
=========================

This section describes how to use the **semop** system call. The
accompanying program illustrates its use.

Using semop
-----------

The synopsis found on the `semop\ (S) <../man/html.S/semop.S.html>`__
manual page is as follows: 

::

      #include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/sem.h>
      
      int semop (int semid, struct sembuf *sops, size_t nsops)

The **semop** system call requires three arguments to be passed to it
and returns an integer value which will be zero for successful
completion or **-1** otherwise.

The **semid** argument must be a valid, non-negative, integer value. In
other words, it must have already been created by using the **semget**
system call.

The **sops** argument points to an array of structures in the user
memory area that contains the following for each semaphore to be
changed: 

-  the semaphore number (**sem_num**)
-  the operation to be performed (**sem_op**)
-  the control flags (**sem_flg**)

The **\*sops** declaration means that either an array name (which is the
address of the first element of the array) or a pointer to the array can
be used. **sembuf** is the \``tag'' name of the data structure used as
the template for the structure members in the array; it is located in
the *sys/sem.h* header file.

The **nsops** argument specifies the length of the array (the number of
structures in the array). The maximum size of this array is determined
by the **SEMOPM** system-tunable parameter. Therefore, a maximum of
**SEMOPM** operations can be performed for each **semop** system call.

The semaphore number (**sem_num**) determines the particular semaphore
within the set on which the operation is to be performed.

The operation to be performed is determined by the following: 

-  if **sem_op** is positive, the semaphore value is incremented by the
   value of **sem_op**
-  if **sem_op** is negative, the semaphore value is decremented by the
   absolute value of **sem_op**
-  if **sem_op** is zero, the semaphore value is tested for equality to
   zero

The following operation commands (flags) can be used: 

-  **IPC_NOWAIT**--this operation command can be set for any operations
   in the array. The system call will return unsuccessfully without
   changing any semaphore values at all if any operation for which
   **IPC_NOWAIT** is set cannot be performed successfully. The system
   call will be unsuccessful when trying to decrement a semaphore more
   than its current value, or when testing for a semaphore to be equal
   to zero when it is not.
-  **SEM_UNDO**--this operation command is used to tell the system to
   undo the process's semaphore changes automatically when the process
   exits; it allows processes to avoid deadlock problems. To implement
   this feature, the system maintains a table with an entry for every
   process in the system. Each entry points to a set of undo structures,
   one for each semaphore used by the process. The system records the
   net change.

--------------

/Example program
================

`\`\`\ semop system call example'' <_Example_Program6.html#ipc_iB>`__ is
a menu-driven program. It allows all possible combinations of using the
**semop** system call to be exercised.

From studying this program, you can observe the method of passing
arguments and receiving return values. The user-written program
requirements are pointed out.

This program begins (lines 5-9) by including the required header files
as specified on the `shmop\ (S) <../man/html.S/shmop.S.html>`__ manual
page. Note that in this program **errno** is declared as an external
variable; therefore, the *sys/errno.h* header file does not have to be
included.

| Variable and structure names have been chosen to be as close as
  possible to those in the synopsis. Their declarations are self
  explanatory. These names make the program more readable and are
  perfectly valid since they are local to the program.

The variables declared for this program and what they are used for are
as follows: 

**sembuf**\ [10]
   used as an array buffer (line 14) to contain a maximum of ten
   **sembuf** type structures; ten is the standard value of the tunable
   parameter **SEMOPM**, the maximum number of operations on a semaphore
   set for each **semop** system call
**sops**
   used as a pointer (line 14) to the **sembuf** array for the system
   call and for accessing the structure members within the array
**string**\ [8]
   used as a character buffer to hold a number entered by the user
**rtrn**
   used to store the return value from the system call
**flags**
   used to store the code of the **IPC_NOWAIT** or **SEM_UNDO** flags
   for the **semop** system call (line 59)
**sem_num**
   used to store the semaphore number entered by the user for each
   semaphore operation in the array
**i**
   used as a counter (line 31) for initializing the structure members in
   the array, and used to print out each structure in the array (line
   78)
**semid**
   used to store the desired semaphore set identifier for the system
   call
**nsops**
   used to specify the number of semaphore operations for the system
   call; must be less than or equal to **SEMOPM**

First, the program prompts for a semaphore set identifier that the
system call is to perform operations on (lines 18-21). **semid** is
stored in the **semid** variable (line 22).

A message is displayed requesting the number of operations to be
performed on this set (lines 24-26). The number of operations is stored
in the **nsops** variable (line 27).

Next, a loop is entered to initialize the array of structures (lines
29-76). The semaphore number, operation, and operation command (flags)
are entered for each structure in the array. The number of structures
equals the number of semaphore operations (**nsops**) to be performed
for the system call, so **nsops** is tested against the **i** counter
for loop control. Note that **sops** is used as a pointer to each
element (structure) in the array, and **sops** is incremented just like
**i**. **sops** is then used to point to each member in the structure
for setting them.

After the array is initialized, all of its elements are printed out for
feedback (lines 77-84).

The **sops** pointer is set to the address of the array (lines 85, 86).
**sembuf** could be used directly, if desired, instead of **sops** in
the system call.

The system call is made (line 88), and depending upon success or
failure, a corresponding message is displayed. The results of the
operation(s) can be viewed by using the **semctl** **GETALL** control
command.

The example program for the **semop** system call follows. We suggest
that you name the source program file *semop.c* and the executable file
**semop**.

::

    1    /*This is a program to illustrate
    2     *the semaphore operations, semop(),
    3     *system call capabilities.
    4     */

    5    /*Include necessary header files.*/
    6    #include    <stdio.h>
    7    #include    <sys/types.h>
    8    #include    <sys/ipc.h>
    9    #include    <sys/sem.h>
   10    /*Start of main C language program*/
   11    main()
   12    {
   13        extern int errno;
   14        struct sembuf sembuf[10], *sops;
   15        char string[8];
   16        int retrn, flags, sem_num, i, semid;
   17        unsigned nsops;

   18        /*Enter the semaphore ID.*/
   19        printf("\nEnter the semid of\n");
   20        printf("the semaphore set to\n");
   21        printf("be operated on = ");
   22        scanf("%d", &semid);
   23        printf("\nsemid = %d", semid);

   24        /*Enter the number of operations.*/
   25        printf("\nEnter the number of semaphore\n");
   26        printf("operations for this set = ");
   27        scanf("%d", &nsops);
   28        printf("\nsops = %d", nsops);

   29        /*Initialize the array for the
   30          number of operations to be performed.*/
   31        for(i = 0, sops = sembuf; i < nsops; i++, sops++)
   32        {

   33            /*This determines the semaphore in
   34              the semaphore set.*/
   35            printf("\nEnter the semaphore\n");
   36            printf("number (sem_num) = ");
   37            scanf("%d", &sem_num);
   38            sops->sem_num = sem_num;
   39            printf("\nThe sem_num = %d", sops->sem_num);

   40            /*Enter a (-)number to decrement,
   41              an unsigned number (no +) to increment,
   42              or zero to test for zero.  These values
   43              are entered into a string and converted
   44              to integer values.*/
   45            printf("\nEnter the operation for\n");
   46            printf("the semaphore (sem_op) = ");
   47            scanf("%s", string);
   48            sops->sem_op = atoi(string);
   49            printf("\nsem_op = %d\n", sops->sem_op);

   50            /*Specify the desired flags.*/
   51            printf("\nEnter the corresponding\n");
   52            printf("number for the desired\n");
   53            printf("flags:\n");
   54            printf("No flags                  = 0\n");
   55            printf("IPC_NOWAIT                = 1\n");
   56            printf("SEM_UNDO                  = 2\n");
   57            printf("IPC_NOWAIT and SEM_UNDO   = 3\n");
   58            printf("            Flags         = ");
   59            scanf("%d", &flags);

   60            switch(flags)
   61            {
   62            case 0: 
   63                sops->sem_flg = 0;
   64                break;
   65            case 1: 
   66                sops->sem_flg = IPC_NOWAIT;
   67                break;
   68            case 2: 
   69                sops->sem_flg = SEM_UNDO;
   70                break;
   71            case 3: 
   72                sops->sem_flg = IPC_NOWAIT | SEM_UNDO;
   73                break;
   74            default: /* Invalid Input */
   75                exit(-1);
   76            }
   77            printf("\nFlags = 0%o\n", sops->sem_flg);
   78        }

   79        /*Print out each structure in the array.*/
   80        for(i = 0; i < nsops; i++)
   81        {
   82            printf("\nsem_num = %d\n", sembuf[i].sem_num);
   83            printf("sem_op = %d\n", sembuf[i].sem_op);
   84            printf("sem_flg = 0%o\n", sembuf[i].sem_flg);
   85            printf(" ");
   86        }

   87        sops = sembuf; /*Reset the pointer to
   88                         sembuf[0].*/

   89        /*Do the semop system call.*/
   90        retrn = semop(semid, sops, nsops);
   91        if(retrn == -1)  {
   92            printf("\nSemop failed, error = %d\n", errno);
   93        }
   94        else {
   95            printf ("\nSemop was successful\n");
   96            printf("for semid = %d\n", semid);

   97            printf("Value returned = %d\n", retrn);
   98        }
   99    }

**semop system call example**

--------------

/Shared memory
==============

The shared memory type of IPC allows two or more processes (executing
programs) to share memory and, consequently, the data contained there.
This is done by allowing processes to set up access to a common virtual
memory address space. This sharing occurs on a segment basis, which is
memory management hardware-dependent.

A process initially creates a shared memory segment facility using the
**shmget** system call. Upon creation, this process sets the overall
operation permissions for the shared memory segment facility, sets its
size in bytes, and can specify that the shared memory segment is for
reference only (read-only) upon attachment.

If the memory segment is not specified to be for reference only, all
other processes with appropriate operation permissions can read from or
write to the memory segment.

**shmat** (shared memory attach) and **shmdt** (shared memory detach)
can be performed on a shared memory segment.

**shmat** allows processes to associate themselves with the shared
memory segment if they have permission. They can then read or write as
allowed.

**shmdt** allows processes to disassociate themselves from a shared
memory segment. Therefore, they lose the ability to read from or write
to the shared memory segment.

| The original owner/creator of a shared memory segment can relinquish
  ownership to another process using the **shmctl** system call.
  However, the creating process remains the creator until the facility
  is removed or the system is reinitialized. Other processes with
  permission can perform other functions on the shared memory segment
  using the **shmctl** system call.

System calls make these shared memory capabilities available to
processes. The calling process passes arguments to a system call, and
the system call either successfully or unsuccessfully performs its
function. If the system call is successful, it performs its function and
returns the appropriate information. Otherwise, a known error code
(**-1**) is returned to the process, and the external variable **errno**
is set accordingly.

--------------

/Using shared memory
====================

Sharing memory between processes occurs on a virtual segment basis.
There is only one copy of each individual shared memory segment existing
in the SCO OpenServer operating system at any time.

Before sharing of memory can be realized, a uniquely identified shared
memory segment and data structure must be created. The unique identifier
created is called the shared memory identifier (**shmid**); it is used
to identify or refer to the associated data structure. This identifier
is accessible by any process in the system, subject to normal access
restrictions.

The data structure includes the following for each shared memory
segment: 

-  operation permissions
-  segment size
-  segment descriptor (for internal system use only)
-  PID performing last operation
-  PID of creator
-  current number of processes attached
-  last attach time
-  last detach time
-  last change time

In SCO OpenServer, the definition for the associated shared-memory
segment data structure **shmid_ds** is as follows: 

::

      /*
       *    There is a shared mem id data structure for each segment in the system.
       */
      struct shmid_ds {
          struct ipc_perm    shm_perm;      /* operation permission struct */
          int                shm_segsz;     /* segment size */
          struct region      *shm_reg;      /* ptr to region structure */
          char               pad[4];        /* for swap compatibility */
          pid_t              shm_lpid;      /* pid of last shmop */
          pid_t              shm_cpid;      /* pid of creator */
          ushort             shm_nattch;    /* used only for shminfo */
          ushort             shm_cnattch;   /* used only for shminfo */
          time_t             shm_atime;     /* last shmat time */
          time_t             shm_dtime;     /* last shmdt time */
          time_t             shm_ctime;     /* last change time */
      };

The C programming language data structure definition for the shared
memory segment data structure **shmid_ds** is located in the *sys/shm.h*
header file.

Note that the ``shm_perm`` member of this structure uses **ipc_perm** as
a template. The **ipc_perm** data structure is the same for all IPC
facilities; it is located in the *sys/ipc.h* header file and shown in
`\`\`\ ipc_perm data structure'' <_Using_Messages.html#ipc_i1>`__.

The **shmget** system call performs two tasks: 

-  it gets a new shared memory identifier and creates an associated
   shared memory segment data structure
-  it returns an existing shared memory identifier that already has an
   associated shared memory segment data structure

The task performed is determined by the value of the **key** argument
passed to the **shmget** system call.

For the first task, if the **key** is not already in use for an existing
shared memory identifier at the security level of the calling process
and the **IPC_CREAT** flag is set in **shmflg**, a new identifier is
returned with an associated shared memory segment data structure created
for it provided no system-tunable parameters would be exceeded.

| There is also a provision for specifying a **key** of value zero which
  is known as the private **key** (**IPC_PRIVATE**); when specified, a
  new **shmid** is always returned with an associated shared memory
  segment data structure created for it unless a system-tunable
  parameter would be exceeded. The **ipcs** command will show the
  **key** field for the **shmid** as all zeros.

For the second task, if a **shmid** exists for the **key** specified,
the value of the existing **shmid** is returned. If it is not desired to
have an existing **shmid** returned, a control command (**IPC_EXCL**)
can be specified (set) in the **shmflg** argument passed to the system
call. `\``Using
shmget'' <_Getting_Shared_Memory_Segments.html#IC_shmget>`__ discusses
how to use this system call.

When performing the first task, the process that calls **shmget**
becomes the owner/creator, and the associated data structure is
initialized accordingly. Remember, ownership can be changed, but the
creating process always remains the creator (see `\``Controlling shared
memory'' <IC_CntllShMem.html>`__). The creator of the shared memory
segment also determines the initial operation permissions for it.

Once a uniquely identified shared memory segment data structure is
created, **shmop** (shared memory segment operations) and **shmctl**
(shared memory control) can be used.

Shared memory segment operations consist of attaching and detaching
shared memory segments. **shmat** and **shmdt** are provided for each of
these operations (see `\``Operations for shared
memory'' <IC_OpsShMem.html>`__ for details of the **shmat** and
**shmdt** system calls).

The **shmctl** system call permits you to control the shared memory
facility in the following ways: 

-  by retrieving the data structure associated with a shared memory
   segment (**IPC_STAT**)
-  by changing operation permissions for a shared memory segment
   (**IPC_SET**)
-  by removing a particular shared memory segment from the SCO
   OpenServer operating system along with its associated shared memory
   segment data structure (**IPC_RMID**)
-  by locking a shared memory segment in memory (**SHM_LOCK**)
-  by unlocking a shared memory segment (**SHM_UNLOCK**)

See the section `\``Controlling shared memory'' <IC_CntllShMem.html>`__
for details of the **shmctl** system call.

--------------


/Getting shared memory segments
===============================

This section describes how to use the **shmget** system call. The
accompanying program illustrates its use.

Using shmget
------------

The synopsis found on the `shmget\ (S) <../man/html.S/shmget.S.html>`__
manual page is as follows: 

::

      #include  <sys/types.h>
      #include  <sys/ipc.h>
      #include  <sys/shm.h>
      
      int  shmget (key, size, shmflg)
      key_t  key;
      int size, shmflg;

All of these include files are located in the **/usr/include/sys**
directory of the SCO OpenServer operating system. The following line in
the synopsis: 

::

   int shmget (key, size, shmflg)

informs you that **shmget** is a function with three formal arguments
that returns an integer-type value. The next two lines: 

::

   key_t  key;
   int size, shmflg;

declare the types of the formal arguments. **key_t** is defined by a
**typedef** in the *sys/types.h* header file to be an integer.

The integer returned from this function (upon successful completion) is
the shared memory identifier (**shmid**) that was discussed earlier.

| As declared, the process calling the **shmget** system call must
  supply three arguments to be passed to the formal **key**, **size**,
  and **shmflg** arguments.

A new **shmid** with an associated shared memory data structure is
provided if either

-  **key** is equal to **IPC_PRIVATE**,

or

-  **key** is a unique integer and **shmflg** ANDed with
   **IPC_CREAT**\ is \``true'' (not zero).

The value passed to the **shmflg** argument must be an integer-type
value and will specify the following: 

-  operations permissions
-  control fields (commands)

Access permissions determine the read/write attributes and modes
determine the user/group/other attributes of the **shmflg** argument.
They are collectively referred to as \``operation permissions.''

`\``Operation permissions
codes'' <_Getting_Shared_Memory_Segments.html#ipc_iC>`__ reflects the
numeric values (expressed in octal notation) for the valid operation
permissions codes.

**Operation permissions codes**

  ===================== ===========
  Operation permissions Octal value
  ===================== ===========
  Read by user          00400
  Write by user         00200
  Read by group         00040
  Write by group        00020
  Read by others        00004
  Write by others       00002
  ===================== ===========

A specific octal value is derived by adding or bitwise ORing the octal
values for the operation permissions desired. That is, if read by user
and read/write by others is desired, the code value would be 00406
(00400 plus 00006). There are constants located in the **sys/shm.h**
header file which can be used for the user (OWNER). They are: 

::

   SHM_R  0400
   SHM_W   0200

Control flags are predefined constants (represented by all upper-case
letters). The flags that apply to the **shmget** system call are
**IPC_CREAT** and **IPC_EXCL** and are defined in the **sys/ipc.h**
header file.

The value for **shmflg** is, therefore, a combination of operation
permissions and control commands. After determining the value for the
operation permissions as previously described, the desired flag(s) can
be specified. This is accomplished by adding or bitwise ORing (\|) them
with the operation permissions; the bit positions and values for the
control commands in relation to those of the operation permissions make
this possible.

The **shmflg** value can easily be set by using the names of the flags
in conjunction with the octal operation permissions value: 

::

   shmid = shmget (key, size, (IPC_CREAT | 0400));

   shmid = shmget (key, size, (IPC_CREAT | IPC_EXCL | 0400));

As specified by the `shmget\ (S) <../man/html.S/shmget.S.html>`__ manual
page, success or failure of this system call depends upon the argument
values for **key**, **size**, and **shmflg,** and system-tunable
parameters. The system call will attempt to return a new **shmid** if
one of the following conditions is true: 

-  **key** is equal to **IPC_PRIVATE** .
-  **key** does not already have a **shmid** associated with it and
   (**shmflg** & **IPC_CREAT**) is \``true'' (not zero).

The **key** argument can be set to **IPC_PRIVATE** like this: 

::

   shmid = shmget(IPC_PRIVATE, size, shmflg);

The **SHMMNI** system-tunable parameter determines the maximum number of
unique shared memory segments (**shmid**\ s) that may be in use at any
given time. If the maximum number of shared memory segments is already
in use, an attempt to create an additional segment will fail.

**IPC_EXCL** is another control command used in conjunction with
**IPC_CREAT**. It will cause the system call to return an error if a
shared memory identifier already exists for the specified **key**
provided. This is necessary to prevent the process from thinking that it
has received a new (unique) **shmid** when it has not. In other words,
when both **PC_CREAT** and **IPC_EXCL** are specified, a unique shared
memory identifier is returned if the system call is successful. Any
value for **shmflg** returns a new identifier if the **key** equals zero
(**IPC_PRIVATE**) and no system-tunable parameters are exceeded.

The system call will fail if the value for the **size** argument is less
than **SHMMIN** or greater than **SHMMAX**. These tunable parameters
specify the minimum and maximum shared memory segment sizes.

Refer to the `shmget\ (S) <../man/html.S/shmget.S.html>`__ manual page
for specific associated data structure initialization for successful
completion. The specific failure conditions and their error names are
contained there also.

--------------

/Example program
================

`\`\`\ shmget system call example'' <_Example_Program7.html#ipc_iD>`__
is a menu-driven program. It allows all possible combinations of using
the **shmget** system call to be exercised.

From studying this program, you can observe the method of passing
arguments and receiving return values. The user-written program
requirements are pointed out.

This program begins (lines 4-7) by including the required header files
as specified by the `shmget\ (S) <../man/html.S/shmget.S.html>`__ manual
page. Note that the **sys/errno.h** header file is included as opposed
to declaring **errno** as an external variable; either method will work.

| Variable names have been chosen to be as close as possible to those in
  the synopsis for the system call. Their declarations are self
  explanatory. These names make the program more readable and are
  perfectly valid since they are local to the program.

The variables declared for this program and what they are used for are
as follows: 

**key**
   used to pass the value for the desired **key**
**opperm**
   used to store the desired operation permissions
**flags**
   used to store the desired control commands (flags)
**shmid**
   used for returning the message queue identification number for a
   successful system call or the error code (**-1**) for an unsuccessful
   one
**size**
   used to specify the shared memory segment size
**opperm_flags**
   used to store the combination from the logical ORing of the
   **opperm** and **flags** variables; it is then used in the system
   call to pass the **shmflg** argument

The program begins by prompting for a hexadecimal **key**, an octal
operation permissions code, and finally for the control command
combinations (flags) which are selected from a menu (lines 14-31). All
possible combinations are allowed even though they might not be viable.
This allows observing the errors for invalid combinations.

Next, the menu selection for the flags is combined with the operation
permissions; the result is stored in the **opperm_flags** variable
(lines 35-50).

A display then prompts for the size of the shared memory segment; it is
stored in the **size** variable (lines 51-54).

The system call is made next; the result is stored in the **shmid**
variable (line 56).

Since the **shmid** variable now contains a valid message queue
identifier or the error code (**-1**), it is tested to see if an error
occurred (line 58). If **shmid** equals **-1**, a message indicates that
an error resulted and the external **errno** variable is displayed (line
60).

If no error occurred, the returned shared memory segment identifier is
displayed (line 64).

The example program for the **shmget** system call follows. We suggest
that you name the source program file **shmget.c** and the executable
file **shmget**.

::

    1    /*This is a program to illustrate
    2     *the shared memory get, shmget(),
    3     *system call capabilities.*/

    4    #include    <sys/types.h>
    5    #include    <sys/ipc.h>
    6    #include    <sys/shm.h>
    7    #include    <errno.h>

    8    /*Start of main C language program*/
    9    main()
   10    {
   11        key_t key;             /*declare as long integer*/
   12        int opperm, flags;
   13        int shmid, size, opperm_flags;
   14        /*Enter the desired key*/
   15        printf("Enter the desired key in hex = ");
   16        scanf("%x", &key);

   17        /*Enter the desired octal operation
   18          permissions.*/
   19        printf("\nEnter the operation\n");
   20        printf("permissions in octal = ");
   21        scanf("%o", &opperm);

   22        /*Set the desired flags.*/
   23        printf("\nEnter corresponding number to\n");
   24        printf("set the desired flags:\n");
   25        printf("No flags                  = 0\n");
   26        printf("IPC_CREAT                 = 1\n");
   27        printf("IPC_EXCL                  = 2\n");
   28        printf("IPC_CREAT and IPC_EXCL    = 3\n");
   29        printf("            Flags         = ");
   30        /*Get the flag(s) to be set.*/
   31        scanf("%d", &flags);

   32        /*Check the values.*/
   33        printf ("\nkey =0x%x, opperm = 0%o, flags = %d\n",
   34            key, opperm, flags);

   35        /*Incorporate the control fields (flags) with
   36          the operation permissions*/
   37        switch (flags)
   38        {
   39        case 0:    /*No flags are to be set.*/
   40            opperm_flags = (opperm | 0);
   41            break;
   42        case 1:    /*Set the IPC_CREAT flag.*/
   43            opperm_flags = (opperm | IPC_CREAT);
   44            break;
   45        case 2:    /*Set the IPC_EXCL flag.*/
   46            opperm_flags = (opperm | IPC_EXCL);
   47            break;
   48        case 3:    /*Set the IPC_CREAT and IPC_EXCL flags.*/
   49            opperm_flags = (opperm | IPC_CREAT | IPC_EXCL);
   50        }

   51        /*Get the size of the segment in bytes.*/
   52        printf ("\nEnter the segment");
   53        printf ("\nsize in bytes = ");
   54        scanf ("%d", &size);

   55        /*Call the shmget system call.*/
   56        shmid = shmget (key, size, opperm_flags);

   57        /*Perform the following if the call is unsuccessful.*/
   58        if(shmid == -1)
   59        {
   60            printf ("\nThe shmget call failed, error number = %d\n", errno);
   61        }
   62        /*Return the shmid upon successful completion.*/
   63        else
   64            printf ("\nThe shmid = %d\n", shmid);
   65        exit(0);
   66    }

**shmget system call example**

| 

--------------


/Controlling shared memory
==========================

This section describes how to use the **shmctl** system call. The
accompanying program illustrates its use.

Using shmctl
------------

The synopsis found on the `shmctl\ (S) <../man/html.S/shmctl.S.html>`__
manual page is as follows: 

::

      #include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/shm.h>
      
      int shmctl (shmid, cmd, buf)
      int shmid, cmd;
      struct shmid_ds *buf;

The **shmctl** system call requires three arguments to be passed to it.
It returns an integer value which will be zero for successful completion
or **-1** otherwise.

The **shmid** variable must be a valid, non-negative, integer value. In
other words, it must have already been created by using the **shmget**
system call.

The **cmd** argument can be replaced by one of following values: 

**IPC_STAT**
   return the status information contained in the associated data
   structure for the specified **shmid** and place it in the data
   structure pointed to by the **buf** pointer in the user memory area
**IPC_SET**
   for the specified **shmid**, set the effective user and group
   identification, and operation permissions
**IPC_RMID**
   remove the specified **shmid** with its associated shared memory
   segment data structure
**SHM_LOCK**
   lock the specified shared memory segment in memory; must have
   **P_SYSOPS** privilege to perform this operation
**SHM_UNLOCK**
   unlock the shared memory segment from memory; must have **P_SYSOPS**
   privilege to perform this operation

To perform an **IPC_SET** or **IPC_RMID** control command, a process
must have: 

-  an effective user id of OWNER/CREATOR, or
-  an effective user id of *root* (if the system is running with the SUM
   privilege module), or
-  the **P_OWNER** privilege.

Only *root* (if the SUM privilege module is installed) can perform a
**SHM_LOCK** or **SHM_UNLOCK** control command.

A process must have read permission to perform the **IPC_STAT** control
command.

The details of this system call are discussed in the example program. If
you need more information on the logic manipulations in this program,
read `\``Using
shmget'' <_Getting_Shared_Memory_Segments.html#IC_shmget>`__. It goes
into more detail than would be practical for every system call.

--------------

/Example program
================

`\`\`\ shmctl system call example'' <_Example_Program8.html#ipc_iE>`__
is a menu-driven program. It allows all possible combinations of using
the **shmctl** system call to be exercised.

From studying this program, you can observe the method of passing
arguments and receiving return values. The user-written program
requirements are pointed out.

This program begins (lines 5-9) by including the required header files
as specified by the `shmctl\ (S) <../man/html.S/shmctl.S.html>`__ manual
page. Note that in this program **errno** is declared as an external
variable, and therefore, the **sys/errno.h** header file does not have
to be included.

| Variable and structure names have been chosen to be as close as
  possible to those in the synopsis for the system call. Their
  declarations are self explanatory. These names make the program more
  readable and are perfectly valid since they are local to the program.

The variables declared for this program and what they are used for are
as follows: 

**uid**
   used to store the **IPC_SET** value for the user identification
**gid**
   used to store the **IPC_SET** value for the group identification
**mode**
   used to store the **IPC_SET** value for the operation permissions
**rtrn**
   used to store the return integer value from the system call
**shmid**
   used to store and pass the shared memory segment identifier to the
   system call
**command**
   used to store the code for the desired control command so that
   subsequent processing can be performed on it
**choice**
   used to determine which member for the **IPC_SET** control command is
   to be changed
**shmid_ds**
   used to receive the specified shared memory segment identifier's data
   structure when an **IPC_STAT** control command is performed
*buf*
   a pointer passed to the system call which locates the data structure
   in the user memory area where the **IPC_STAT** control command is to
   place its return values or where the **IPC_SET** command gets the
   values to set.

Note that the **shmid_ds** data structure in this program (line 16) uses
the data structure of the same name located in the **sys/shm.h** header
file as a template for its declaration.

The next important thing to observe is that although the **buf** pointer
is declared to be a pointer to a data structure of the **shmid_ds**
type, it must also be initialized to contain the address of the user
memory area data structure (line 17).

Now that all of the required declarations have been explained for this
program, this is how it works.

First, the program prompts for a valid shared memory segment identifier
which is stored in the **shmid** variable (lines 18-20). This is
required for every **shmctl** system call.

Then, the code for the desired control command must be entered (lines
21-29); it is stored in the command variable. The code is tested to
determine the control command for subsequent processing.

If the **IPC_STAT** control command is selected (code 1), the system
call is performed (lines 39, 40) and the status information returned is
printed out (lines 41-71). Note that if the system call is unsuccessful
(line 139), the status information of the last successful call is
printed out. In addition, an error message is displayed and the
**errno** variable is printed out (lines 141). If the system call is
successful, a message indicates this along with the shared memory
segment identifier used (lines 143-147).

If the **IPC_SET** control command is selected (code 2), the first thing
done is to get the current status information for the shared memory
identifier specified (lines 88-90). This is necessary because this
example program provides for changing only one member at a time, and the
system call changes all of them. Also, if an invalid value happened to
be stored in the user memory area for one of these members, it would
cause repetitive failures for this control command until corrected. The
next thing the program does is to prompt for a code corresponding to the
member to be changed (lines 91-96). This code is stored in the choice
variable (line 97). Now, depending upon the member picked, the program
prompts for the new value (lines 98-120). The value is placed in the
appropriate member in the user memory area data structure, and the
system call is made (lines 121-128). Depending upon success or failure,
the program returns the same messages as for **IPC_STAT** above.

If the **IPC_RMID** control command (code 3) is selected, the system
call is performed (lines 125-128), and the **shmid** along with its
associated message queue and data structure are removed from the SCO
OpenServer operating system. Note that the **buf** pointer is ignored in
performing this control command and its value can be zero or NULL.
Depending upon the success or failure, the program returns the same
messages as for the other control commands.

If the **SHM_LOCK** control command (code 4) is selected, the system
call is performed (lines 130,131). Depending upon the success or
failure, the program returns the same messages as for the other control
commands.

If the **SHM_UNLOCK** control command (code 5) is selected, the system
call is performed (lines 133-135). Depending upon the success or
failure, the program returns the same messages as for the other control
commands.

The example program for the **shmctl** system call follows. We suggest
that you name the source program file **shmctl.c** and the executable
file **shmctl**.

::

     1    /*This is a program to illustrate
     2     *the shared memory control, shmctl(),
     3     *system call capabilities.
     4     */

     5    /*Include necessary header files.*/
     6    #include    <stdio.h>
     7    #include    <sys/types.h>
     8    #include    <sys/ipc.h>
     9    #include    <sys/shm.h>

    10    /*Start of main C language program*/
    11    main()
    12    {
    13        extern int errno;
    14        int uid, gid, mode;
    15        int rtrn, shmid, command, choice;
    16        struct shmid_ds shmid_ds, *buf;
    17        buf = & shmid_ds;

    18        /*Get the shmid, and command.*/
    19        printf("Enter the shmid = ");
    20        scanf("%d", &shmid);
    21        printf("\nEnter the number for\n");
    22        printf("the desired command:\n");

    23        printf("IPC_STAT    =  1\n");
    24        printf("IPC_SET     =  2\n");
    25        printf("IPC_RMID    =  3\n");
    26        printf("SHM_LOCK    =  4\n");
    27        printf("SHM_UNLOCK  =  5\n");
    28        printf("Entry       =  ");
    29        scanf("%d", &command);

    30        /*Check the values.*/
    31        printf ("\nshmid =%d, command = %d\n",
    32            shmid, command);

    33        switch (command)
    34        {
    35        case 1:    /*Use shmctl() to get
    36                   the data structure for
    37                   shmid in the shmid_ds area pointed
    38                   to by buf and then print it out.*/
    39            rtrn = shmctl(shmid, IPC_STAT,
    40                buf);
    41            printf ("\nThe USER ID = %d\n",
    42                buf->shm_perm.uid);
    43            printf ("The GROUP ID = %d\n",
    44                buf->shm_perm.gid);
    45            printf ("The creator's ID = %d\n",
    46                buf->shm_perm.cuid);
    47            printf ("The creator's group ID = %d\n",
    48                buf->shm_perm.cgid);
    49            printf ("The operation permissions = 0%o\n",
    50                buf->shm_perm.mode);
    51            printf ("The slot usage sequence\n");
    52            printf ("number = 0%x\n",
    53                buf->shm_perm.seq);
    54            printf ("The key= 0%x\n",
    55                buf->shm_perm.key);
    56            printf ("The segment size = %d\n",
    57                buf->shm_segsz);
    58            printf ("The pid of last shmop = %d\n",
    59                buf->shm_lpid);
    60            printf ("The pid of creator = %d\n",
    61                buf->shm_cpid);
    62            printf ("The current # attached = %d\n",
    63                buf->shm_nattch);
    64            printf("The last shmat time = %ld\n",
    65                buf->shm_atime);
    66            printf("The last shmdt time = %ld\n",
    67                buf->shm_dtime);
    68            printf("The last change time = %ld\n",
    69                buf->shm_ctime);
    70            break;

                  /* Lines 71 - 85 deleted */

    86        case 2:    /*Select and change the desired
    87                      member(s) of the data structure.*/

    88            /*Get the original data for this shmid
    89                  data structure first.*/
    90            rtrn = shmctl(shmid, IPC_STAT, buf);

    91            printf("\nEnter the number for the\n");
    92            printf("member to be changed:\n");
    93            printf("shm_perm.uid   = 1\n");
    94            printf("shm_perm.gid   = 2\n");
    95            printf("shm_perm.mode  = 3\n");
    96            printf("Entry          = ");
    97            scanf("%d", &choice);

    98            switch(choice){
    99            case 1: 
   100                printf("\nEnter USER ID = ");
   101                scanf ("%d", &uid);
   102                buf->shm_perm.uid = uid;
   103                printf("\nUSER ID = %d\n",
   104                    buf->shm_perm.uid);
   105                break;

   106            case 2: 
   107                printf("\nEnter GROUP ID = ");
   108                scanf("%d", &gid);
   109                buf->shm_perm.gid = gid;
   110                printf("\nGROUP ID = %d\n",
   111                    buf->shm_perm.gid);
   112                break;

   113            case 3: 
   114                printf("\nEnter MODE in octal = ");
   115                scanf("%o", &mode);
   116                buf->shm_perm.mode = mode;
   117                printf("\nMODE = 0%o\n",
   118                    buf->shm_perm.mode);
   119                break;
   120            }
   121            /*Do the change.*/
   122            rtrn = shmctl(shmid, IPC_SET,
   123                buf);
   124            break;

   125        case 3:    /*Remove the shmid along with its
   126                      associated
   127                      data structure.*/
   128            rtrn = shmctl(shmid, IPC_RMID, (struct shmid_ds *) NULL);
   129            break;

   130        case 4: /*Lock the shared memory segment*/
   131            rtrn = shmctl(shmid, SHM_LOCK, (struct shmid_ds *) NULL);
   132            break;
   133        case 5: /*Unlock the shared memory
   134                      segment.*/
   135            rtrn = shmctl(shmid, SHM_UNLOCK, (struct shmid_ds *) NULL);
   136            break;
   137        }
   138        /*Perform the following if the call is unsuccessful.*/
   139        if(rtrn == -1)
   140        {
   41            printf ("\nThe shmctl call failed, error number = %d\n", errno);
   142        }
   143        /*Return the shmid upon successful completion.*/
   144        else
   145            printf ("\nShmctl was successful for shmid = %d\n",
   146                shmid);
   147        exit (0);
   148    }

**shmctl system call example**

--------------

/Operations for shared memory
=============================

This section describes how to use the **shmat** and **shmdt** system
calls. The accompanying program illustrates their use.

Using shared memory operations: shmat and shmdt
-----------------------------------------------

The synopsis found on the `shmop\ (S) <../man/html.S/shmop.S.html>`__
manual page is as follows: 

::

      #include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/shm.h>
      
      void *shmat (shmid, shmaddr, shmflg)
      int shmid;
      void *shmaddr;
      int shmflg;
      
      int shmdt (shmaddr)
      void *shmaddr;

Attaching a shared memory segment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The **shmat** system call requires three arguments to be passed to it.
It returns a character pointer value. Upon successful completion, this
value will be the address in memory where the process is attached to the
shared memory segment and when unsuccessful the value will be **-1**.

The **shmid** argument must be a valid, non-negative, integer value. In
other words, it must have already been created by using the **shmget**
system call.

| The **shmaddr** argument can be zero or user supplied when passed to
  the **shmat** system call. If it is zero, the SCO OpenServer operating
  system picks the address where the shared memory segment will be
  attached. If it is user supplied, the address must be a valid address
  that the SCO OpenServer operating system could pick.

| The following illustrates some typical address ranges.
| 0xc00c0000
| 0xc00e0000
| 0xc0100000
| 0xc0120000

Note that these addresses are in chunks of 20,000 hexadecimal. It would
be wise to let the operating system pick addresses so as to improve
portability.

The **shmflg** argument is used to pass the **SHM_RND** and
**SHM_RDONLY** flags to the **shmat** system call.

Detaching shared memory segments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The **shmdt** system call requires one argument to be passed to it. It
returns an integer value which will be zero for successful completion or
**-1** otherwise.

Further details on **shmat** and **shmdt** are discussed in the example
program. If you need more information on the logic manipulations in this
program, read `\``Using
shmget'' <_Getting_Shared_Memory_Segments.html#IC_shmget>`__. It goes
into more detail than would be practical for every system call.

--------------

/Example program
================

`\`\`\ shmop system call example'' <_Example_Program9.html#ipc_iF>`__ is
a menu-driven program. It allows all possible combinations of using the
**shmat** and **shmdt** system calls to be exercised.

From studying this program, you can observe the method of passing
arguments and receiving return values. The user-written program
requirements are pointed out.

This program begins (lines 5-9) by including the required header files
as specified by the `shmop\ (S) <../man/html.S/shmop.S.html>`__ manual
page. Note that in this program **errno** is declared as an external
variable; therefore, the **sys/errno.h** header file does not have to be
included.

| Variable and structure names have been chosen to be as close as
  possible to those in the synopsis. Their declarations are self
  explanatory. These names make the program more readable and are
  perfectly valid since they are local to the program.

The variables declared for this program and what they are used for are
as follows: 

**addr**
   used to store the address of the shared memory segment for the
   **shmat** and **shmdt** system calls and to receive the return value
   from the **shmat** system call
**laddr**
   used to store the desired attach/detach address entered by the user
**flags**
   used to store the codes of the **SHM_RND** or **SHM_RDONLY** flags
   for the **shmat** system call
**i**
   used as a loop counter for attaching and detaching
**attach**
   used to store the desired number of attach operations
**shmid**
   used to store and pass the desired shared memory segment identifier
**shmflg**
   used to pass the value of flags to the **shmat** system call
retrn
   used to store the return values from the **shmdt** system call
detach
   used to store the desired number of detach operations

This example program combines both the **shmat** and **shmdt** system
calls. The program prompts for the number of attachments and enters a
loop until they are done for the specified shared memory identifiers.
Then, the program prompts for the number of detachments to be performed
and enters a loop until they are done for the specified shared memory
segment addresses.

shmat
-----

The program prompts for the number of attachments to be performed, and
the value is stored at the address of the attach variable (lines 19-23).

A loop is entered using the attach variable and the **i** counter (lines
23-72) to perform the specified number of attachments.

In this loop, the program prompts for a shared memory segment identifier
(lines 26-29); it is stored in the **shmid** variable (line 30). Next,
the program prompts for the address where the segment is to be attached
(lines 32-36); it is stored in the **laddr** variable (line 37) and
converted to a pointer (line 39). Then, the program prompts for the
desired flags to be used for the attachment (lines 40-47), and the code
representing the flags is stored in the flags variable (line 48). The
flags variable is tested to determine the code to be stored for the
**shmflg** variable used to pass them to the **shmat** system call
(lines 49-60). The system call is executed (line 63). If successful, a
message stating so is displayed along with the attach address (lines
68-70). If unsuccessful, a message stating so is displayed and the error
code is displayed (line 65). The loop then continues until it finishes.

shmdt
-----

After the attach loop completes, the program prompts for the number of
detach operations to be performed (lines 73-77) and the value is stored
in the detach variable (line 76).

A loop is entered using the detach variable and the **i** counter (lines
80-98) to perform the specified number of detachments.

In this loop, the program prompts for the address of the shared memory
segment to be detached (lines 81-85); it is stored in the **laddr**
variable (line 86) and converted to a pointer (line 88). Then, the
**shmdt** system call is performed (line 89). If successful, a message
stating so is displayed along with the address that the segment was
detached from (lines 95, 96). If unsuccessful, the error number is
displayed (line 92). The loop continues until it finishes.

The example program for the **shmop** system calls follows. We suggest
that you name the source program file *shmop.c* and the executable file
**shmop**.

::

    1    /*This is a program to illustrate
    2     *the shared memory operations, shmop(),
    3     *system call capabilities.
    4     */

    5    /*Include necessary header files.*/
    6    #include    <stdio.h>
    7    #include    <sys/types.h>
    8    #include    <sys/ipc.h>
    9    #include    <sys/shm.h>
   10    /*Start of main C language program*/
   11    main()
   12    {
   13        extern int errno;
   14        void *addr;
   15        long laddr;
   16        int flags, i, attach;
   17        int shmid, shmflg, retrn, detach;

   18        /*Loop for attachments by this process.*/
   19        printf("Enter the number of\n");
   20        printf("attachments for this\n");
   21        printf("process (1-4).\n");
   22        printf("       Attachments = ");

   23        scanf("%d", &attach);
   24        printf("Number of attaches = %d\n", attach);

   25        for(i = 1; i <= attach; i++) {
   26            /*Enter the shared memory ID.*/
   27            printf("\nEnter the shmid of\n");
   28            printf("the shared memory segment to\n");
   29            printf("be operated on = ");
   30            scanf("%d", &shmid);
   31            printf("\nshmid = %d\n", shmid);

   32            /*Enter the value for shmaddr.*/
   33            printf("\nEnter the value for\n");
   34            printf("the shared memory address\n");
   35            printf("in hexadecimal:\n");
   36            printf("            Shmaddr = ");
   37            scanf("%lx", &laddr);
   38            addr = (void*) laddr;
   39            printf("The desired address = 0x%lx\n", (long)addr);

   40            /*Specify the desired flags.*/
   41            printf("\nEnter the corresponding\n");
   42            printf("number for the desired\n");
   43            printf("flags:\n");
   44            printf("SHM_RND                = 1\n");
   45            printf("SHM_RDONLY             = 2\n");
   46            printf("SHM_RND and SHM_RDONLY = 3\n");
   47            printf("            Flags      = ");
   48            scanf("%d", &flags);

   49            switch(flags)
   50            {
   51            case 1: 
   52                shmflg = SHM_RND;
   53                break;
   54            case 2: 
   55                shmflg = SHM_RDONLY;
   56                break;
   57            case 3: 
   58                shmflg = SHM_RND | SHM_RDONLY;
   59                break;
   60            }
   61            printf("\nFlags = 0%o\n", shmflg);

   62            /*Do the shmat system call.*/
   63            addr = shmat(shmid, addr, shmflg);
   64            if(addr == (char*) -1) {
   65                printf("\nShmat failed, error = %d\n", errno);
   66            }
   67            else {
   68                printf ("\nShmat was successful\n");
   69                printf("for shmid = %d\n", shmid);
   70                printf("The address = 0x%lx\n", (long)addr);
   71            }
   72        }

   73        /*Loop for detachments by this process.*/
   74        printf("Enter the number of\n");
   75        printf("detachments for this\n");
   76        printf("process (1-4).\n");
   77        printf("       Detachments = ");

   78        scanf("%d", &detach);
   79        printf("Number of attaches = %d\n", detach);
   80        for(i = 1; i <= detach; i++) {

   81            /*Enter the value for shmaddr.*/
   82            printf("\nEnter the value for\n");
   83            printf("the shared memory address\n");
   84            printf("in hexadecimal:\n");
   85            printf("            Shmaddr = ");
   86            scanf("%lx", &laddr);
   87            addr = (void*) laddr;
   88            printf("The desired address = 0x%lx\n", (long)addr);

   89            /*Do the shmdt system call.*/
   90            retrn = shmdt(addr);
   91            if(retrn == -1)  {
   92                printf("Error = %d\n", errno);
   93            }
   94            else {
   95                printf ("\nShmdt was successful\n");
   96                printf("for address  = 0x%lx\n", (long)addr);

   97            }
   98        }
   99    }

**shmop system call example**

--------------


/IPC programming example for liber
==================================

To illustrate the use of SCO OpenServer system programming tools in the
development of an application, we are going to pretend we are engaged in
the development of a computer system for a library. The system is known
as *liber*. The early stages of system development, we assume, have
already been completed; feasibility studies have been done, the
preliminary design is described in the coming paragraphs. We are going
to stop short of producing a complete detailed design and module
specifications for our system. You will have to accept that these exist.
In using portions of the system for examples of the topics covered in
this section, we will work from these virtual specifications.

We make no claim as to the efficacy of this design. It is the way it is
only in order to provide some passably realistic examples of SCO
OpenServer system programming tools in use. It is not an application,
but rather is code fragments only.

*liber* is a system for keeping track of the books in a library. The
hardware consists of a single computer with terminals throughout the
library. One terminal is used for adding new books to the data base.
Others are used for checking out books and as electronic card catalogs.

The design of the system calls for it to be brought up at the beginning
of the day and remain running while the library is in operation.
Associated with each terminal is a program specific to the function of
that terminal, each running as a separate SCO OpenServer process. The
system has one master index that contains the unique identifier of each
title in the library. When the system is running the index is mapped
into the address space of each process. Semaphores are used to
synchronize access to the index. In the pages that follow fragments of
some of the system's programs are shown to illustrate the way they work
together. The startup program performs the system initialization;
opening the semaphores and the index file; mapping the index file into
memory; and kicking off the other programs. The id numbers for the
semaphores (**wrtsem**, and **rdsem**) are written to a file during
initialization, this file is then read by all the subsidiary programs so
that all use the same semaphores.

All the programs share access to the index file. They gain access to it
with the following code: 

::

      /*
       * Gain access to the index file, map it in.
       * After mapping, free the file descriptor so
       * that it will be available for other uses --
       * the mapping will remain until the program
       * exits, or until the mapping is removed either
       * by munmap() or by mapping over top of this one
       * with another call to mmap().  Note the use of
       * the read/write open mode -- all programs but
       * "add-books" should open just for read-only.
       */
      if ((index_fd = open("index.file", O_RDWR)) == -1)
      {
       (void) fprintf(stderr, "index open failed: %d\n", errno);
       exit(1);
      }
      /*
       * Establish the mapping.  As with the call to
       * open(), all programs but "add-books" should
       * map with PROT_READ for read-only access.
       */
      if ((int)(index = (INDEX *)mmap(0, sizeof (INDEX), PROT_READ|PROT_WRITE,
          MAP_SHARED, index_fd, 0) == -1)
      {
       (void) fprintf(stderr, "mmap failed: %d\n", errno);
       exit(1);
      }
      (void) close(index_fd);

The preceding code fragment establishes a mapping to the index file in
the address space of the program. Access to the addresses at which the
file is mapped affect the file directly, no further file operations are
required. For instance, if the access deposits data at the accessed
address, then the file will be modified by operation. If the access
examines data, then the file will be accessed. In either case, the
portion of the file containing the information will be obtained or
restored to secondary storage automatically by the system and
transparently to the application.

Of the programs shown, **add-books** is the only one that alters the
index. The semaphores are used to ensure that no other programs will try
to read the index while **add-books** is altering it. The checkout
program locks the file record for the book, so that each copy being
checked out is recorded separately and the book cannot be checked out at
two different checkout stations at the same time.

The program fragments do not provide any details on the structure of the
index or the book records in the data base.

::

                  /* liber.h - header file for the
                *           library system.
                */
      typedef ... INDEX;       /* data structure for book file index */
      typedef struct {     /* type of records in book file */
       char title[30];
       char author[30];
       .
       .
       .
      } BOOK;  
      int index_fd;
      int wrtsem;
      int rdsem;
      INDEX *index;
      
      int book_file;
      BOOK book_buf;


      
      /*   startup program */
      
      /*
       * 1. Open index file and map it in.
       * 2. Open two semaphores for providing exclusive write access to index.
       * 3. Stash id's for shared memory segment and semaphores in a file
       *    where they can be accessed by the programs.
       * 4. Start programs:  add-books, card-catalog, and checkout running
       *    on the various terminals throughout the library.
       */
      
      #include <stdio.h>
      #include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/shm.h>
      #include <sys/sem.h>
      #include "liber.h"
      
      void exit();
      extern int errno;
      
      key_t key;
      int shmid;
      int wrtsem;
      int rdsem;
      FILE *ipc_file;
      
      main()
      {
       .
       .
       .
       /*
        * Open index file and map it.
        */
      
       /* See previous example */
      
       /*
        * Get the read/write semaphores.
        */
       if ((wrtsem = semget(key, 1, IPC_CREAT | 0666)) == -1)
       {
           (void) fprintf(stderr, "startup: semget failed: errno=%d\n", errno);
           exit(1);
       }
      
       if ((rdsem = semget(key, 1, IPC_CREAT | 0666)) == -1)
       {
           (void) fprintf(stderr, "startup: semget failed: errno=%d\n", errno);
           exit(1);
       }
       (void) fprintf(ipc_file, "%d\n%d\n", wrtsem, rdsem);
      
       /*
        * Start the add-books program running on the terminal in the
        * basement.  Start the checkout and card-catalog programs
        * running on the various other terminals throughout the library.
        */
       .
       .
       .
      }

      /*   card-catalog program    */
      
      /*
       * 1. Read screen for author and title.
       * 2. Use semaphores to prevent reading index while it is being written.
       * 3. Use index to get position of book record in book file.
       * 4. Print book record on screen or indicate book was not found.
       * 5. Go to 1.
       */
      
      #include        <stdio.h>
      #include        <sys/types.h>
      #include        <sys/ipc.h>
      #include        <sys/sem.h>
      #include <fcntl.h>
      #include "liber.h"
      
      void exit();
      extern int errno;
      struct sembuf sop[1];
      
      main() {
       .
       .
       .
      
       while (1)
       {
           /*
            * Read author/title/subject information from screen.
            */
      
           /*
            * Wait for write semaphore to reach 0 (index not being written).
            */
           sop[0].sem_op = 1;
           if (semop(wrtsem, sop, 1) == -1)
           {
               (void) fprintf(stderr, "semop failed: %d\n", errno);
               exit(1);
           }
           /*
            * Increment read semaphore so potential writer will wait
            * for us to finish reading the index.
            */
           sop[0].sem_op = 0;
           if (semop(rdsem, sop, 1) == -1)
           {
               (void) fprintf(stderr, "semop failed: %d\n", errno);
               exit(1);
           }
      
           /* Use index to find file pointer(s) for book(s) */
      
           /* Decrement read semaphore */
           sop[0].sem_op = -1;
           if (semop(rdsem, sop, 1) == -1)
           {
               (void) fprintf(stderr, "semop failed: %d\n", errno);
               exit(1);
           }
      
           /*
            * Now we use the file pointers found in the index to
            * read the book file.  Then we print the information
            * on the book(s) to the screen.
            */
      
           /*
            * Note design alternatives for this portion of the
            * the code: the book file could be accessed by
            * lseek()s to the portion of the file containing
            * the record, and then read() could be used to
            * obtain the file information.  Alternatively, the
            * entire book file could be mapped into memory, and the
            * the record accessed directly without further
            * file operations, or the area of the file containing
            * the book record could just be mapped and then unmapped
            * when the access is complete.
            */
           .
           .
           .
      
       } /* while */
      }
      /*   checkout program    */
      
      /*
       * 1. Read screen for Dewey Decimal number of book to be checked out.
       * 2. Use semaphores to prevent reading index while it is being written.
       * 3. Use index to get position of book record in book file.
       * 4. If book not found print message on screen, otherwise lock
       *    book record and read.
       * 5. If book already checked out print message on screen, otherwise
       *    mark record "checked out" and write back to book file.
       * 6. Unlock book record.
       * 7. Go to 1.
       */
      
      #include        <stdio.h>
      #include        <sys/types.h>
      #include        <sys/ipc.h>
      #include        <sys/sem.h>
      #include <fcntl.h>
      #include "liber.h"
      
      void exit();
      long lseek();
      extern int errno;
      struct flock flk;
      struct sembuf sop[1];
      long bookpos;
      
      main()
      {
       .
       .
       .
       while (1)
       {
           /*
            * Read Dewey Decimal number from screen.
            */
      
           /*
            * Wait for write semaphore to reach 0 (index not being written).
            */
           sop[0].sem_flg = 0;
           sop[0].sem_op = 0;
           if (semop(wrtsem, sop, 1) == -1)
           {
               (void) fprintf(stderr, "semop failed: %d\n", errno);
               exit(1);
           }
           /*
            * Increment read semaphore so potential writer will wait
            * for us to finish reading the index.
            */
           sop[0].sem_op = 1;
           if (semop(rdsem, sop, 1) == -1)
           {
               (void) fprintf(stderr, "semop failed: %d\n", errno);
               exit(1);
           }
      
           /*
            * Now we can use the index to find the book's record position.
            * Assign this value to "bookpos".
            */
      
           /* Decrement read semaphore */
           sop[0].sem_op = -1;
           if (semop(rdsem, sop, 1) == -1)
           {
               (void) fprintf(stderr, "semop failed: %d\n", errno);
               exit(1);
           }
      
           /*
            * Lock the book's record in book file, read the record.
            * Here again we have the design option of deciding to
            * access and update the database through the use of
            * seeks, read()s and write()s; or file mapping can
            * be used to access the file.  File mapping has the
            * disadvantage that it does not interact well with
            * enforcement-mode locking, although semaphores
            * could be used as an alternative synchronization
            * mechanism to file locking.  File mapping would have
            * potential efficiency advantages, eliminating the need
            * for repetitive file access operations and attendant
            * data copying.  For this example, however, we choose
            * not to use mapping to demonstrate the use of other
            * system facilities.
            */
           flk.l_type = F_WRLCK;
           flk.l_whence = 0;
           flk.l_start = bookpos;
           flk.l_len = sizeof(BOOK);
           if (fcntl(book_file, F_SETLKW, &flk) == -1)
      
           {
               (void) fprintf(stderr, "trouble locking: %d\n", errno);
               exit(1);
           }
           if (lseek(book_file, bookpos, 0) == -1)
           {
               (Error processing for lseek);
           }
           if (read(book_file, &book_buf, sizeof(BOOK)) == -1)
           {
               (Error processing for read);
           }
      
           /*
            * If the book is checked out inform the client, otherwise
            * mark the book's record as checked out and write it
            * back into the book file.
            */
      
           /* Unlock the book's record in book file. */
           flk.l_type = F_UNLCK;
           if (fcntl(book_file, F_SETLK, &flk) == -1)
           {
               (void) fprintf(stderr, "trouble unlocking: %d\n", errno);
               exit(1);
           }
       } /* while */
      }

      /*   add-books program   */
      
      /*
       * 1. Read a new book entry from screen.
       * 2. Insert book in book file.
       * 3. Use semaphore "wrtsem" to block new readers.
       * 4. Wait for semaphore "rdsem" to reach 0.
       * 5. Insert book into index.
       * 6. Decrement wrtsem.
       * 7. Go to 1.
       */
      
      #include <stdio.h>
      #include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/sem.h>
      #include "liber.h"

      void exit();
      extern int errno;
      struct sembuf sop[1];
      BOOK bookbuf;
      
      main()
      {
       .
       .
       .
       for (;;)
       {
      
           /*
            * Read information on new book from screen.
            */
      
           addscr(&bookbuf);
      
           /* write new record at the end of the bookfile.
            * Code not shown, but
            * addscr() returns a 1 if title information has
            * been entered, 0 if not.
            */
      
           /*
            * Increment write semaphore, blocking new readers from
            * accessing the index.
            */
           sop[0].sem_flg = 0;
           sop[0].sem_op = 1;
           if (semop(wrtsem, sop, 1) == -1)
           {
               (void) fprintf(stderr, "semop failed: %d\n", errno);
               exit(1);
           }
      
           /*
            * Wait for read semaphore to reach 0 (all readers to finish
            * using the index).
            */
           sop[0].sem_op = 0;
           if (semop(rdsem, sop, 1) == -1)
           {
               (void) fprintf(stderr, "semop failed: %d\n", errno);
               exit(1);
           }
           /*
            * Now that we have exclusive access to the index we
            * insert our new book with its file pointer.
            */
      
           /* Decrement write semaphore, permitting readers to read index. */
           sop[0].sem_op = -1;
           if (semop(wrtsem, sop, 1) == -1)
           {
               (void) fprintf(stderr, "semop failed: %d\n", errno);
               exit(1);
           }
       } /* for */
       .
       .
       .
      }

The example following, **addscr**, illustrates two significant points
about **curses** screens: 

#. Information read in from a **curses** window can be stored in fields
   that are part of a structure defined in the header file for the
   application.
#. The address of the structure can be passed from another function
   where the record is processed.

::

                  /*  addscr is called from add-books.
                *  The user is prompted for title
                *  information.
                */
      #include <curses.h>
      
      WINDOW *cmdwin;
      
      addscr(bb)
      struct BOOK *bb;
      {
       int c;
      
       initscr();
       nonl();
       noecho();
       cbreak();
      
       cmdwin = newwin(6, 40, 3, 20);
       mvprintw(0, 0, "This screen is for adding titles to the data base");
       mvprintw(1, 0, "Enter  a  to add;  q  to quit: ");
       refresh();
       for (;;)
       {
           refresh();
           c = getch();
           switch (c) {
             case 'a': 
               werase(cmdwin);
               box(cmdwin, '|', '-');
               mvwprintw(cmdwin, 1, 1, "Enter title: ");
               wmove(cmdwin, 2, 1);
               echo();
               wrefresh(cmdwin);
               wgetstr(cmdwin, bb->title);
               noecho();
               werase(cmdwin);
               box(cmdwin, '|', '-');
               mvwprintw(cmdwin, 1, 1, "Enter author: ");
               wmove(cmdwin, 2, 1);
               echo();
               wrefresh(cmdwin);
               wgetstr(cmdwin, bb->author);
               noecho();
               werase(cmdwin);
               wrefresh(cmdwin);
               endwin();
               return(1);
             case 'q': 
               erase();
               endwin();
               return(0);
             }
       }
      }

      #
      # Makefile for liber library system
      #
      
      CC = cc
      CFLAGS = -O
      all: startup add-books checkout card-catalog
      
      startup: liber.h startup.c
       $(CC) $(CFLAGS) -o startup startup.c
      
      add-books: add-books.o addscr.o
       $(CC) $(CFLAGS) -o add-books add-books.o addscr.o
      
      add-books.o: liber.h
      
      checkout: liber.h checkout.c
       $(CC) $(CFLAGS) -o checkout checkout.c
      
      card-catalog: liber.h card-catalog.c
       $(CC) $(CFLAGS) -o card-catalog card-catalog.c

--------------

/11. STREAMS polling and multiplexing
======================================

This section describes how STREAMS allows user processes to monitor,
control, and poll Streams to allow an effective utilization of system
resources. The synchronous polling mechanism and asynchronous event
notification within STREAMS is discussed. STREAMS signal handling
between modules and/or drivers and user processes is also discussed.

The remainder of this section is devoted to STREAMS input/output
multiplexing. It defines a STREAMS multiplexor, and describes
multiplexing drivers. A discussion of how STREAMS multiplexing
configurations are created, is included. Code examples are included to
illustrate using both the polling and multiplexing mechanisms.

--------------

/STREAMS input/output polling
=============================

This section describes the synchronous polling mechanism and
asynchronous event notification within STREAMS.

User processes can efficiently monitor and control multiple Streams with
two system calls: **poll** and the **I_SETSIG** **ioctl** command. These
calls allow a user process to detect events that occur at the Stream
head on one or more Streams, including receipt of data or messages on
the read queue and cessation of flow control.

To monitor Streams with **poll**, a user process issues that system call
and specifies the Streams to be monitored, the events to look for, and
the amount of time to wait for an event. The **poll** system call blocks
the process until the time expires or until an event occurs. If an event
occurs, it returns the type of event and the Stream on which the event
occurred.

Instead of waiting for an event to occur, a user process may want to
monitor one or more Streams while processing other data. It can do so by
issuing the **I_SETSIG** **ioctl** command, specifying one or more
Streams and events (as with **poll**). This **ioctl** does not block the
process and force the user process to wait for the event but returns
immediately and issues a signal when an event occurs. The process must
specify a signal handler to catch the resultant \``SIGPOLL'' signal.

If any selected event occurs on any of the selected Streams, STREAMS
causes the \``SIGPOLL'' catching function to be executed in all
associated requesting processes. However, the process(es) will not know
which event occurred, nor on what Stream the event occurred. A process
that issues the **I_SETSIG** can get more detailed information by
issuing a **poll** after it detects the event.

--------------

/Synchronous input/output
=========================

The **poll** system call provides a mechanism to identify those Streams
over which a user can send or receive data. For each Stream of interest,
users can specify one or more events about which they should be
notified. The types of events that can be polled are as follows: 

**POLLIN**
   A message other than an **M_PCPROTO** is at the front of the Stream
   head read queue. This event is maintained for compatibility with the
   previous releases of UNIX System V.
**POLLRDNORM**
   A normal (nonpriority) message is at the front of the Stream head
   read queue.
**POLLRDBAND**
   A priority message (band > 0) is at the front of the Stream head
   queue.
**POLLPRI**
   A high-priority message (**M_PCPROTO**) is at the front of the Stream
   head read queue.
**POLLOUT**
   The normal priority band of the queue is writable (not flow
   controlled).
**POLLWRNORM**
   The same as **POLLOUT**.
**POLLWRBAND**
   A priority band greater than **0** of a queue downstream exists and
   is writable.

Some of the events may not be applicable to all file types. For example,
it is not expected that the **POLLPRI** event will be generated when
polling a regular file. **POLLIN**, **POLLRDNORM**, **POLLRDBAND**, and
**POLLPRI** are set even if the message is of zero length.

The **poll** system call examines each file descriptor for the requested
events and, on return, shows which events have occurred for each file
descriptor. If no event has occurred on any polled file descriptor,
**poll** blocks until a requested event or timeout occurs. **poll**
takes the following arguments: 

-  An array of file descriptors and events to be polled.
-  The number of file descriptors to be polled.
-  The number of milliseconds **poll** should wait for an event if no
   events are pending (-1 specifies wait forever).

The following example shows the use of **poll**. Two separate minor
devices of the communications driver are opened, thereby establishing
two separate Streams to the driver. The **pollfd** entry is initialized
for each device. Each Stream is polled for incoming data. If data
arrives on either Stream, it is read and then written back to the other
Stream.

::

   #include <fcntl.h>
   #include <poll.h>

   #define NPOLL 2     /* number of file descriptors to poll */

   main()
   {
       struct pollfd pollfds[NPOLL];
       char buf[1024];
       int count, i;

       if ((pollfds[0].fd = open("/dev/comm/01", O_RDWR|O_NDELAY)) < 0) {
           perror("open failed for /dev/comm/01");
           exit(1);
       }

       if ((pollfds[1].fd = open("/dev/comm/02", O_RDWR|O_NDELAY)) < 0) {
           perror("open failed for /dev/comm/02");
           exit(2);
       }

The variable **pollfds** is declared as an array of the **pollfd**
structure that is defined in *<poll.h>* and has the following format: 

::

      struct pollfd {
       int     fd;         /* file descriptor */
       short   events;     /* requested events */
       short   revents;    /* returned events */
      }

For each entry in the array, *fd* specifies the file descriptor to be
polled and **events** is a bitmask that contains the bitwise inclusive
**OR** of events to be polled on that file descriptor. On return, the
**revents** bitmask indicates which of the requested events has
occurred.

The example continues to process incoming data as follows: 

::

      pollfds[0].events = POLLIN; /* set events to poll */
       pollfds[1].events = POLLIN; /* for incoming data */
       pollfds[0].revents = 0;
       pollfds[1].revents = 0;
       
       while (1) {
           /* poll and use -1 timeout (infinite) */
           if (poll(pollfds, NPOLL, -1) < 0) {
               perror("poll failed");
               exit(3);
           }
           for (i = 0; i < NPOLL; i++) {
               switch (pollfds[i].revents) {

               case 0:                        /* no events */
                   break;

               case POLLIN: 
                   /* echo incoming data on "other" Stream */
                   while ((count = read(pollfds[i].fd, buf, 1024)) > 0)
                       /*
                        * the write loses data if flow control
                        * prevents the transmit at this time.
                        */
                   if (write(pollfds[(i+1)%2].fd, buf, count) != count)
                           fprintf(stderr,"writer lost data\n");
                   pollfds[i].revents = 0;
                   break;

               default:                       /* default error case */
                   perror("error event");
                   exit(4);
               }
           }
       }
   }

The user specifies the polled events by setting the **events** field of
the **pollfd** structure to **POLLIN**. This requested event directs
**poll** to notify the user of any incoming data on each Stream. The
bulk of the example is an infinite loop, where each iteration polls both
Streams for incoming data.

The second argument to the **poll** system call specifies the number of
entries in the **pollfds** array (2 in this example). The third argument
is a timeout value indicating the number of milliseconds **poll** should
wait for an event if none occurs. On a system where millisecond accuracy
is not available, **timeout** is rounded up to the nearest value
available on that system. If the value of **timeout** is **0**, **poll**
returns immediately. Here, the value of **timeout** is **-1**,
specifying that **poll** should block until a requested event occurs or
until the call is interrupted.

If the **poll** call succeeds, the program looks at each entry in the
**pollfds** array. If **revents** is set to **0**, no event has occurred
on that file descriptor. If **revents** is set to **POLLIN**, incoming
data is available. In this case, all data is read from the polled minor
device and written to the other minor device.

If **revents** is set to a value other than **0** or **POLLIN**, an
error event must have occurred on that Stream, because **POLLIN** was
the only requested event. The following are **poll** error events: 

**POLLERR**
   A fatal error has occurred in some module or driver on the Stream
   associated with the specified file descriptor. Further system calls
   will fail.
**POLLHUP**
   A hangup condition exists on the Stream associated with the specified
   file descriptor. This event and **POLLOUT** are mutually exclusive; a
   Stream cannot be writable if a hangup has occurred.
**POLLNVAL**
   The specified file descriptor is not valid

These events may not be polled by the user, but will be reported in
**revents** whenever they occur. As such, they are only valid in the
**revents** bitmask.

The example attempts to process incoming data as quickly as possible.
However, when writing data to a Stream, the **write** call may block if
the Stream is exerting flow control. To prevent the process from
blocking, the minor devices of the communications driver were opened
with the **O_NDELAY** (or **O_NONBLOCK**, see note) flag set. The
**write** will not be able to send all the data if flow control is
exerted and **O_NDELAY** (**O_NONBLOCK**) is set. This can occur if the
communications driver is unable to keep up with the user's rate of data
transmission. If the Stream becomes full, the number of bytes the
**write** sends will be less than the requested **count**. For
simplicity, the example ignores the data if the Stream becomes full, and
a warning is printed to **stderr**.

--------------

**NOTE:** For conformance with the IEEE operating system interface
standard, POSIX, it is recommended that new applications use the
**O_NONBLOCK** flag, which behaves the same as **O_NDELAY** unless
otherwise noted.

--------------

This program continues until an error occurs on a Stream, or until the
process is interrupted.

--------------

/Asynchronous input/output
==========================

The **poll** system call enables a user to monitor multiple Streams in a
synchronous fashion. The **poll** call normally blocks until an event
occurs on any of the polled file descriptors. In some applications,
however, it is desirable to process incoming data asynchronously. For
example, an application may want to do some local processing and be
interrupted when a pending event occurs. Some time-critical applications
cannot afford to block, but must have immediate indication of success or
failure.

The **I_SETSIG** **ioctl** call (see 
`streamio\ (M) <../man/html.M/streamio.M.html>`__) is used to request
that a \``SIGPOLL'' signal be sent to a user process when a specific
event occurs. Listed below are events for the **ioctl** **I_SETSIG**.
These are similar to those described for **poll**.

**S_INPUT** 
   A message other than an **M_PCPROTO** is at the front of the Stream
   head read queue. This event is maintained for compatibility with the
   previous releases of the UNIX System V.
**S_RDNORM** 
   A normal (nonpriority) message is at the front of the Stream head
   read queue.
**S_RDBAND** 
   A priority message (band > 0) is at the front of the Stream head read
   queue.
**S_HIPRI** 
   A high-priority message (**M_PCPROTO**) is present at the front of
   the Stream head read queue.
**S_OUTPUT** 
   A write queue for normal data (priority band = 0) is no longer full
   (not flow controlled). This notifies a user that there is room on the
   queue for sending or writing normal data downstream.
**S_WRNORM** 
   The same as **S_OUTPUT**.
**S_WRBAND** 
   A priority band greater than **0** of a queue downstream exists and
   is writable. This notifies a user that there is room on the queue for
   sending or writing priority data downstream.
**S_MSG** 
   An **M_SIG** or **M_PCSIG** message containing the \``SIGPOLL'' flag
   has reached the front of Stream head read queue.
**S_ERROR** 
   An **M_ERROR** message reaches the Stream head.
**S_HANGUP** 
   An **M_HANGUP** message reaches the Stream head.
**S_BANDURG** 
   When used with **S_RDBAND**, **SIGURG** is generated instead
   \``SIGPOLL'' when a priority message reaches the front of the Stream
   head read queue.

**S_INPUT**, **S_RDNORM**, **S_RDBAND**, and **S_HIPRI** are set even if
the message is of zero length. A user process may choose to handle only
high-priority messages by setting the **arg** to **S_HIPRI**.

--------------


/Signals
========

STREAMS allows modules and drivers to cause a signal to be sent to user
process(es) through an **M_SIG** or **M_PCSIG** message. The first byte
of the message specifies the signal for the Stream head to generate. If
the signal is not \``SIGPOLL'' (see
`signal\ (S) <../man/html.S/signal.S.html>`__), the signal is sent to
the process group associated with the Stream. If the signal is
\``SIGPOLL'', the signal is only sent to processes that have registered
for the signal by using the **I_SETSIG** **ioctl**.

An **M_SIG** message can be used by modules or drivers that want to
insert an explicit inband signal into a message Stream. For example,
this message can be sent to the user process immediately before a
particular service interface message to gain the immediate attention of
the user process. When the **M_SIG** message reaches the head of the
Stream head read queue, a signal is generated and the **M_SIG** message
is removed. This leaves the service interface message as the next
message to be processed by the user. Use of the **M_SIG** message is
typically defined as part of the service interface of the driver or
module.

--------------


/Extended signals
=================

To enable a process to obtain the band and event associated with
\``SIGPOLL'' more readily, STREAMS supports extended signals. For the
given events, a special code is defined in *<siginfo.h>* that describes
the reason \``SIGPOLL'' was generated. `\`\`\ siginfo_t data available
to the signal handler'' <_Extended_Signals.html#streams_t1>`__ describes
the data available in the **siginfo_t** structure passed to the signal
handler.

**siginfo_t data available to the signal handler**

======== ============ =========== ============= ============
Event    **si_signo** **si_code** **si_band**   **si_errno**
======== ============ =========== ============= ============
S_INPUT  SIGPOLL      POLL_IN     band readable unused
S_OUTPUT SIGPOLL      POLL_OUT    band writable unused
S_MSG    SIGPOLL      POLL_MSG    band signaled unused
S_ERROR  SIGPOLL      POLL_ERR    unused        Stream error
S_HANGUP SIGPOLL      POLL_HUP    unused        unused
S_HIPRI  SIGPOLL      POLL_PRI    unused        unused
======== ============ =========== ============= ============

--------------


/STREAMS input/output multiplexing
==================================

This section describes how STREAMS multiplexing configurations are
created and also discusses multiplexing drivers.

Earlier, Streams were described as linear connections of modules, where
each invocation of a module is connected to at most one upstream module
and one downstream module. While this configuration is suitable for many
applications, others require the ability to multiplex Streams in a
variety of configurations. Typical examples are terminal window
facilities, and internetworking protocols (which might route data over
several subnetworks).

`\``Many-to-one
multiplexor'' <_STREAMS_InputOutput_Multiplexin.html#streams_j1>`__
shows an example of a multiplexor that multiplexes data from several
upper Streams over a single lower Stream. An upper Stream is one that is
upstream from a multiplexor, and a lower Stream is one that is
downstream from a multiplexor. A terminal windowing facility might be
implemented in this fashion, where each upper Stream is associated with
a separate window.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/manyone.gif

**Many-to-one multiplexor**

`\``One-to-many
multiplexor'' <_STREAMS_InputOutput_Multiplexin.html#streams_j2>`__
shows a second type of multiplexor that might route data from a single
upper Stream to one of several lower Streams. An internetworking
protocol could take this form, where each lower Stream links the
protocol to a different physical network.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/onemany.gif

**One-to-many multiplexor**

`\``Many-to-many
multiplexor'' <_STREAMS_InputOutput_Multiplexin.html#streams_j3>`__
shows a third type of multiplexor that might route data from one of many
upper Streams to one of many lower Streams.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/manymany.gif

**Many-to-many multiplexor**

The STREAMS mechanism supports the multiplexing of Streams through
special pseudo-device drivers. Using a linking facility, users can
dynamically build, maintain, and dismantle multiplexed Stream
configurations. Simple configurations like the ones shown in
`\``Many-to-one
multiplexor'' <_STREAMS_InputOutput_Multiplexin.html#streams_j1>`__
through `\``Many-to-many
multiplexor'' <_STREAMS_InputOutput_Multiplexin.html#streams_j3>`__ can
be further combined to form complex, multilevel, multiplexed Stream
configurations.

STREAMS multiplexing configurations are created in the kernel by
interconnecting multiple Streams. Conceptually, there are two kinds of
multiplexors: upper and lower multiplexors. Lower multiplexors have
multiple lower Streams between device drivers and the multiplexor, and
upper multiplexors have multiple upper Streams between user processes
and the multiplexor.

`\``Internet multiplexing
stream'' <_STREAMS_InputOutput_Multiplexin.html#streams_j4>`__ is an
example of the multiplexor configuration that typically occurs where
internetworking functions are included in the system. This configuration
contains three hardware device drivers. The IP (Internet Protocol) is a
multiplexor.

The IP multiplexor switches messages among the lower Streams or sends
them upstream to user processes in the system. In this example, the
multiplexor expects to see the same interface downstream to Module 1,
Module 2, and Driver 3.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/intmux.gif

**Internet multiplexing stream**

`\``Internet multiplexing
stream'' <_STREAMS_InputOutput_Multiplexin.html#streams_j4>`__ depicts
the IP multiplexor as part of a larger configuration. The multiplexor
configuration, shown in the dashed rectangle, generally has an upper
multiplexor and additional modules. Multiplexors can also be cascaded
below the IP multiplexor driver if the device drivers are replaced by
multiplexor drivers.

`\``X.25 multiplexing
stream'' <_STREAMS_InputOutput_Multiplexin.html#streams_j5>`__ shows a
multiplexor configuration where the multiplexor (or multiplexing driver)
routes messages between the lower Stream and one upper Stream. This
Stream performs X.25 multiplexing to multiple independent Switched
Virtual Circuit (SVC) and Permanent Virtual Circuit (PVC) user
processes. Upper multiplexors are a specific application of standard
STREAMS facilities that support multiple minor devices in a device
driver. This figure also shows that more complex configurations can be
built by having one or more multiplexed drivers below and multiple
modules above an upper multiplexor.

Developers can choose either upper or lower multiplexing, or both, when
designing their applications. For example, a window multiplexor would
have a similar configuration to the X.25 configuration of `\``X.25
multiplexing
stream'' <_STREAMS_InputOutput_Multiplexin.html#streams_j5>`__, with a
window driver replacing the Packet Layer, a tty driver replacing the
driver XYZ, and the child processes of the terminal process replacing
the user processes. Although the X.25 and window multiplexing Streams
have similar configurations, their multiplexor drivers would differ
significantly. The IP multiplexor in `\``Internet multiplexing
stream'' <_STREAMS_InputOutput_Multiplexin.html#streams_j4>`__ has a
different configuration than the X.25 multiplexor, and the driver would
implement its own set of processing and routing requirements in each
configuration.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/x25mux.gif

**X.25 multiplexing stream**

In addition to upper and lower multiplexors, you can create more complex
configurations by connecting Streams containing multiplexors to other
multiplexor drivers. With such a diversity of needs for multiplexors, it
is not possible to provide general purpose multiplexor drivers. Rather,
STREAMS provides a general purpose multiplexing facility, which allows
users to set up the intermodule/driver plumbing to create multiplexor
configurations of generally unlimited interconnection.

--------------









/STREAMS multiplexors
=====================

A STREAMS multiplexor is a driver with multiple Streams connected to it.
The primary function of the multiplexing driver is to switch messages
among the connected Streams. Multiplexor configurations are created at
user level by system calls.

STREAMS-related system calls set up the \``plumbing,'' or Stream
interconnections, for multiplexing drivers. The subset of these calls
that allows a user to connect (and disconnect) Streams below a driver is
referred to as the multiplexing facility. This type of connection is
referred to as a 1-to-M, or lower, multiplexor configuration. This
configuration must always contain a multiplexing driver, which is
recognized by STREAMS as having special characteristics.

Multiple Streams can be connected above a driver by **open** calls.
There is no difference between the connections to these drivers, only
the functions performed by the driver are different. In the multiplexing
case, the driver routes data between multiple Streams. In the device
driver case, the driver routes data between user processes and
associated physical ports. Multiplexing with Streams connected above is
referred to as an N-to-1, or upper, multiplexor. STREAMS does not
provide any facilities beyond **open** and **close** to connect or
disconnect upper Streams for multiplexing purposes.

From the driver's perspective, upper and lower configurations differ
only in how they are initially connected to the driver. The
implementation requirements are the same: route the data and handle flow
control. All multiplexor drivers require special developer-provided
software to perform the multiplexing data routing and to handle flow
control. STREAMS does not directly support flow control among
multiplexed Streams.

M-to-N multiplexing configurations are implemented by using both of the
above mechanisms in a driver.

The multiple Streams that represent minor devices are actually distinct
Streams in which the driver keeps track of each Stream attached to it.
The STREAMS subsystem does not recognize any relationship between the
Streams. The same is true for STREAMS multiplexors of any configuration.
The multiplexed Streams are distinct and the driver must be implemented
to do most of the work.

In addition to upper and lower multiplexors, more complex configurations
can be created by connecting Streams containing multiplexors to other
multiplexor drivers. With such a diversity of needs for multiplexors, it
is not possible to provide general-purpose multiplexor drivers. Rather,
STREAMS provides a general purpose multiplexing facility that allows
users to set up the intermodule/driver plumbing to create multiplexor
configurations of generally unlimited interconnection.

--------------


/Building a multiplexor
=======================

This section builds a protocol multiplexor with the multiplexing
configuration shown in `\``Protocol
multiplexor'' <_Building_a_Multiplexor.html#streams_j6>`__. To free
users from the need to know about the underlying protocol structure, a
user-level daemon process is built to maintain the multiplexing
configuration. Users can then access the transport protocol directly by
opening the transport protocol (TP) driver device node.

An internetworking protocol driver (IP) routes data from a single upper
Stream to one of two lower Streams. This driver supports two STREAMS
connections beneath it. These connections are to two distinct networks;
one for the IEEE 802.3 standard with the 802.3 driver, and the other to
the IEEE 802.4 standard with the 802.4 driver. The TP driver multiplexes
upper Streams over a single Stream to the IP driver.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/protmux.gif

**Protocol multiplexor**

The following example shows how this daemon process sets up the protocol
multiplexor. The necessary declarations and initialization for the
daemon program are as follows: 

::

   #include <fcntl.h>
   #include <stropts.h>

   main()
   {
       int fd_802_4,
           fd_802_3,
           fd_ip,
           fd_tp;

       /* daemon-ize this process */
       
       switch (fork()) {
       case 0: 
           break;
       case -1: 
           perror("fork failed");
           exit(2);
       default: 
           exit(0);
       }
       setsid();

This multilevel multiplexed Stream configuration is built from the
bottom up. Therefore, the example begins by first constructing the
Internet Protocol (IP) multiplexor. This multiplexing device driver is
treated like any other software driver. It owns a node in the UNIX file
system and is opened just like any other STREAMS device driver.

The first step is to open the multiplexing driver and the 802.4 driver,
thus creating separate Streams above each driver as shown in `\``Before
link'' <_Building_a_Multiplexor.html#streams_j7>`__. The Stream to the
802.4 driver may now be connected below the multiplexing IP driver using
the **I_LINK** **ioctl** call.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/b4link.gif

**Before link**

The sequence of instructions to this point is

::

      if ((fd_802_4 = open("/dev/802_4", O_RDWR)) < 0) {
           perror("open of /dev/802_4 failed");
           exit(1);
       }

       if ((fd_ip = open("/dev/ip", O_RDWR)) < 0) {
           perror("open of /dev/ip failed");
           exit(2);
       }

       /* now link 802.4 to underside of IP */

       if (ioctl(fd_ip, I_LINK, fd_802_4) < 0) {
           perror("I_LINK ioctl failed");
           exit(3);
       }

**I_LINK** takes two file descriptors as arguments. The first file
descriptor, **fd_ip**, must reference the Stream connected to the
multiplexing driver, and the second file descriptor, **fd_802_4**, must
reference the Stream to be connected below the multiplexor. `\``IP
multiplexor after first
link'' <_Building_a_Multiplexor.html#streams_j8>`__ shows the state of
these Streams following the **I_LINK** call. The complete Stream to the
802.4 driver has been connected below the IP driver. The Stream head's
queues of the 802.4 driver is used by the IP driver to manage the lower
half of the multiplexor.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/aftlink.gif

**IP multiplexor after first link**

**I_LINK** returns an integer value, called **muxid**, which is used by
the multiplexing driver to identify the Stream just connected below it.
This **muxid** is ignored in the example, but is useful for dismantling
a multiplexor or routing data through the multiplexor. Its significance
is discussed later.

The following sequence of system calls is used to continue building the
internetworking protocol multiplexor (IP): 

::

      if ((fd_802_3 = open("/dev/802_3", O_RDWR)) < 0) {
           perror("open of /dev/802_3 failed");
           exit(4);
       }

       if (ioctl(fd_ip, I_LINK, fd_802_3) < 0) {
           perror("I_LINK ioctl failed");
           exit(5);
       }

All links below the IP driver have now been established, giving the
configuration in `\``IP
multiplexor'' <_Building_a_Multiplexor.html#streams_j9>`__.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/ipmux.gif

**IP multiplexor**

The Stream above the multiplexing driver used to establish the lower
connections is the controlling Stream and has special significance when
dismantling the multiplexing configuration. This will be illustrated
later in this section. The Stream referenced by **fd_ip** is the
controlling Stream for the IP multiplexor.

--------------

**NOTE:** The order in which the Streams in the multiplexing
configuration are opened is unimportant. If it is necessary to have
intermediate modules in the Stream between the IP driver and media
drivers, these modules must be added to the Streams associated with the
media drivers (using I_PUSH) before the media drivers are attached below
the multiplexor.

--------------

The number of Streams that can be linked to a multiplexor is restricted
by the design of the particular multiplexor. The manual page describing
each driver (typically found in Section 7) describes such restrictions.
However, only one **I_LINK** operation is allowed for each lower Stream;
a single Stream cannot be linked below two multiplexors simultaneously.

Continuing with the example, the IP driver is now linked below the
transport protocol (TP) multiplexing driver. As seen in `\``Protocol
multiplexor'' <_Building_a_Multiplexor.html#streams_j6>`__, only one
link is supported below the transport driver. This link is formed by the
following sequence of system calls: 

::

      if ((fd_tp = open("/dev/tp", O_RDWR)) < 0) {
           perror("open of /dev/tp failed");
           exit(6);
       }

       if (ioctl(fd_tp, I_LINK, fd_ip) < 0) {
           perror("I_LINK ioctl failed");
           exit(7);
       }

The multilevel multiplexing configuration shown in `\``TP
multiplexor'' <_Building_a_Multiplexor.html#streams_jA>`__ has now been
created.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/tpmux.gif

**TP multiplexor**

Because the controlling Stream of the IP multiplexor has been linked
below the TP multiplexor, the controlling Stream for the new multilevel
multiplexor configuration is the Stream above the TP multiplexor.

At this point, the file descriptors associated with the lower drivers
can be closed without affecting the operation of the multiplexor. If
these file descriptors are not closed, all later **read**, **write**,
**ioctl**, **poll**, **getmsg**, and **putmsg** system calls issued to
them will fail because **I_LINK** associates the Stream head of each
linked Stream with the multiplexor, so the user may not access that
Stream directly for the duration of the link.

The following sequence of system calls completes the daemon example: 

::

      close(fd_802_4);
       close(fd_802_3);
       close(fd_ip);

       /* Hold multiplexor open forever */
       pause();
   }

To summarize, `\``TP 
multiplexor'' <_Building_a_Multiplexor.html#streams_jA>`__ shows the
multilevel protocol multiplexor. The transport driver supports several
simultaneous Streams. These Streams are multiplexed over the single
Stream connected to the IP multiplexor. The mechanism for establishing
multiple Streams above the transport multiplexor is actually a
by-product of the way in which Streams are created between a user
process and a driver. By opening different minor devices of a STREAMS
driver, separate Streams are connected to that driver. Of course, the
driver must be designed with the intelligence to route data from the
single lower Stream to the appropriate upper Stream.

The daemon process maintains the multiplexed Stream configuration
through an open Stream (the controlling Stream) to the transport driver.
Meanwhile, other users can access the services of the transport protocol
by opening new Streams to the transport driver; they are freed from the
need for any unnecessary knowledge of the underlying protocol
configurations and subnetworks that support the transport service.

Multilevel multiplexing configurations should be assembled from the
bottom up because the passing of **ioctl**\ s through the multiplexor is
determined by the multiplexing driver and cannot generally be relied on.

--------------









/Dismantling a multiplexor
==========================

Streams connected to a multiplexing driver from above with **open**, can
be dismantled by closing each Stream with **close**. The mechanism for
dismantling Streams that have been linked below a multiplexing driver is
less obvious, and is described below.

The **I_UNLINK** **ioctl** call disconnects each multiplexor link below
a multiplexing driver individually. This command has the form: 

::

   ioctl(fd, I_UNLINK, muxid);

where **fd** is a file descriptor associated with a Stream connected to
the multiplexing driver from above, and **muxid** is the identifier that
was returned by **I_LINK** when a driver was linked below the
multiplexor. Each lower driver may be disconnected individually in this
way, or a special **muxid** value of **-1** may disconnect all drivers
from the multiplexor simultaneously.

In the multiplexing daemon program presented earlier, the multiplexor is
never explicitly dismantled because all links associated with a
multiplexing driver are automatically dismantled when the controlling
Stream associated with that multiplexor is closed. Because the
controlling Stream is open to a driver, only the final call of **close**
for that Stream closes it. In this case, the daemon is the only process
that opens the controlling Stream, so the multiplexing configuration is
dismantled when the daemon exits.

For the automatic dismantling mechanism to work in the multilevel,
multiplexed Stream configuration, the controlling Stream for each
multiplexor at each level must be linked under the next higher level
multiplexor. In the example, the controlling Stream for the IP driver
was linked under the TP driver, which resulted in a single controlling
Stream for the full, multilevel configuration. Because the multiplexing
program relied on closing the controlling Stream to dismantle the
multiplexed Stream configuration instead of using explicit **I_UNLINK**
calls, the **muxid** values returned by **I_LINK** could be ignored.

An important side-effect of automatic dismantling on the close is that
it is not possible for a process to build a multiplexing configuration
with **I_LINK** and then exit. This is because **exit** closes all files
associated with the process, including the controlling Stream. To keep
the configuration intact, the process must exist for the life of that
multiplexor. That is the motivation for implementing the example as a
daemon process.

However, if the process uses persistent links with the **I_PLINK**
**ioctl** call, the multiplexor configuration remains intact after the
process exits. Persistent links are described later in this section.

--------------


/Routing data through a multiplexor
===================================

As shown, STREAMS provides a mechanism for building multiplexed Stream
configurations. However, the criteria on which a multiplexor routes data
is driver-dependent. For example, the protocol multiplexor shown before
might use address information found in a protocol header to determine
over which subnetwork data should be routed. It is the multiplexing
driver's responsibility to define its routing criteria.

One routing option available to the multiplexor is to use the **muxid**
value to determine to which Stream data should be routed (remember that
each multiplexor link is associated with a **muxid**). **I_LINK** passes
the **muxid** value to the driver and returns this value to the user.
The driver can therefore specify that the **muxid** value must accompany
data routed through it. For example, if a multiplexor routed data from a
single upper Stream to one of several lower Streams (as did the IP
driver), the multiplexor could require the user to insert the **muxid**
of the desired lower Stream into the first four bytes of each message
passed to it. The driver could then match the **muxid** in each message
with the **muxid** of each lower Stream, and route the data accordingly.

--------------


/Persistent links
=================

With **I_LINK** and **I_UNLINK** **ioctl**\ s, the file descriptor
associated with the Stream above the multiplexor used to set up the
lower multiplexor connections must remain open for the duration of the
configuration. Closing the file descriptor associated with the
controlling Stream dismantles the whole multiplexing configuration. Some
applications may not want to keep a process running merely to hold the
multiplexor configuration together. Therefore, \``free-standing'' links
below a multiplexor are needed. A persistent link is such a link. It is
similar to a STREAMS multiplexor link, except that a process is not
needed to hold the links together. After the multiplexor has been set
up, the process may close all file descriptors and exit, and the
multiplexor remains intact.

Two **ioctl**\ s, **I_PLINK** and **I_PUNLINK**, are used to create and
remove persistent links that are associated with the Stream above the
multiplexor. **close** and **I_UNLINK** are not able to disconnect the
persistent links.

The format of **I_PLINK** is 

::

   ioctl(fd0, I_PLINK, fd1)

The first file descriptor, **fd0**, must reference the Stream connected
to the multiplexing driver and the second file descriptor, **fd1**, must
reference the Stream to be connected below the multiplexor. The
persistent link can be created in the following way: 

::

      upper_stream_fd = open("/dev/mux", O_RDWR);
      lower_stream_fd = open("/dev/driver", O_RDWR);
      muxid = ioctl(upper_stream_fd, I_PLINK, lower_stream_fd);
      /*
       * save muxid in a file
       */
      exit(0);

`\``open of MUXdriver and
Driver1'' <_Persistent_Links.html#streams_jB>`__ shows how **open**
establishes a Stream between the device and the Stream head.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/openmux.gif

**open of MUXdriver and Driver1**

The persistent link can still exist even if the file descriptor
associated with the upper Stream to the multiplexing driver is closed.
The **I_PLINK** **ioctl** returns an integer value, **muxid**, that can
be used for dismantling the multiplexing configuration. If the process
that created the persistent link still exists, it may pass the **muxid**
value to some other process to dismantle the link, if the dismantling is
desired, or it can leave the **muxid** value in a file so that other
processes may find it later. `\``Multiplexor after
I_PLINK'' <_Persistent_Links.html#streams_jC>`__ shows a multiplexor
after **I_PLINK**.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/aftplink.gif

**Multiplexor after I_PLINK**

Several users can open the MUXdriver and send data to Driver1 since the
persistent link to Driver1 remains intact. This is shown in `\``Other
users opening a MUXdriver'' <_Persistent_Links.html#streams_jD>`__.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/othermux.gif

**Other users opening a MUXdriver**

The **I_PUNLINK** **ioctl** is used for dismantling the persistent link.
Its format is

::

   ioctl(fd0, I_PUNLINK, muxid)

where the **fd0** is the file descriptor associated with Stream
connected to the multiplexing driver from above. The **muxid** is
returned by the **I_PLINK** **ioctl** for the Stream that was connected
below the multiplexor. The **I_PUNLINK** removes the persistent link
between the multiplexor referenced by the **fd0** and the Stream to the
driver designated by the **muxid**. Each of the bottom persistent links
can be disconnected individually. An **I_PUNLINK** **ioctl** with the
**muxid** value of **MUXID_ALL** removes all persistent links below the
multiplexing driver referenced by **fd0**.

The following dismantles the previously given configuration: 

::

      fd = open("/dev/mux", O_RDWR);
      /*
       * retrieve muxid from the file
       */
      ioctl(fd, I_PUNLINK, muxid);
      exit(0);

The use of the **ioctl**\ s **I_PLINK** and **I_PUNLINK** should not be
intermixed with **I_LINK** and **I_UNLINK**. Any attempt to unlink a
regular link with **I_PUNLINK** or to unlink a persistent link with
**I_UNLINK** **ioctl** causes the **errno** value of **EINVAL** to be
returned.

Because multilevel multiplexing configurations are allowed in STREAMS,
it is possible to have a situation where persistent links exist below a
multiplexor whose Stream is connected to the above multiplexor by
regular links. Closing the file descriptor associated with the
controlling Stream removes the regular link but not the persistent links
below it. On the other hand, regular links are allowed to exist below a
multiplexor whose Stream is connected to the above multiplexor with
persistent links. In this case, the regular links are removed if the
persistent link above is removed and no other references to the lower
Streams exist.

The construction of cycles is not allowed when creating links. A cycle
could be constructed by creating a persistent link of multiplexor 2
below multiplexor 1 and then closing the controlling file descriptor
associated with the multiplexor 2 and reopening it again and then
linking the multiplexor 1 below the multiplexor 2, but this is not
allowed. The operating system prevents a multiplexor configuration from
containing a cycle to ensure that messages cannot be routed infinitely,
thus creating an infinite loop or overflowing the kernel stack.

--------------




/12. Asynchronous I/O
======================

The Asynchronous Input/Output (I/O) feature contains the following POSIX
P1003.4 interface functions: 

**aio_cancel**\ +
   cancel asynchronous read and/or write requests
**aio_error**
   retrieve Asynchronous I/O error status
**aio_fsync**
   asynchronously force I/O completion, and sets **errno** to ENOSYS
**aio_read**
   begin asynchronous read
**aio_return**
   retrieve return status of Asynchronous I/O operation
**aio_suspend**\ +
   suspend until Asynchronous I/O Completes
**aio_write**
   begin asynchronous write
**lio_listio**
   issue list of I/O requests

Together they provide a user application with the ability to overlap CPU
processing with I/O operations. Additionally, Asynchronous I/O supports
the **aio_memlock** function for high performance database applications.

--------------

**NOTE:** The **aio_cancel** and **aio_suspend** functions are supported
only in the thread-based implementation of UNIX System V Release 4.2
Multiprocessor (SVR4.2 MP) and SCO OpenServer. The **lio_listio**
function is supported only for raw slices of hard disks for both SVR4.2
MP, SVR4.2, and SCO OpenServer.

--------------

These routines are more fully described in their respective manual
pages.

Notation conventions
--------------------

| The Asynchronous I/O feature supports UNIX System V Release 4.2
  (SVR4.2), UNIX System V Release 4.2 Multiprocessor (SVR4.2 MP), and
  SCO OpenServer. Functions that can only be used on raw slices of hard
  disks have been indicated in the following manner: 
| **aio_memlock**\ ++

| Functions provided for the SVR4.2 MP and SCO OpenServer threads-based
  implementation only have been indicated in the following manner: 
| **aio_cancel**\ +
| **aio_suspend**\ +

--------------

/Advantages of asynchronous I/O
===============================

The Asynchronous Input/Output (I/O) mechanism provides a user process
with the ability to overlap processing with I/O operations. In real time
and transaction processing environments, applications may need to
overlap their compute and I/O processing to improve the throughput and
determinism on a per process or application basis. You can use
Asynchronous I/O to enable read-ahead and write-behind to be performed
in a controlled fashion. One process can have many I/O operations in
progress while it is executing other code. Conversely, with synchronous
I/O, the process would have been blocked waiting for each I/O operation.

Previously in UNIX System V, a call to the **read** system call was
considered to be logically synchronous because the call could not return
to the user until the requested data was read into the specified buffer
in the calling process' address space. The user process was blocked
until the data had been placed into the user's buffer and could not
execute other instructions while the I/O was taking place. Non-blocking
I/O could only be performed if the **O_NONBLOCK** flag was set on a call
to **open** or **fcntl**. A non-blocking **read** call such as a read
from a pipe, returns immediately with a failure indication if there is
no data available. In contrast, a successful call to begin an
asynchronous read returns to the calling process immediately after
queuing a read request to the open file descriptor so that when data
becomes available, the read request would be satisfied.

A call to the **write** system call is considered to be logically
synchronous because the call does not return to the user until the
requested data is written into the file system cache. After returning
from the call, the user is free to reuse its buffers. However, the data
is actually written to disk asynchronously at a later time. If the
caller has set the **O_SYNC** flag on the call to **open** or **fcntl**,
the call to **write** is truly synchronous and does not return to the
user until the requested data is written out to disk. In contrast, a
successful call to begin an asynchronous write queues a write request
and returns immediately, without waiting for the I/O to be completed.
When returning from the call, the data is not copied from the user
buffers so the caller should not reuse the buffers until the I/O has
completed.

An important part of the Asynchronous I/O application is the ability to
request asynchronous notification of I/O completion. At the time the
Asynchronous I/O request is made, the application may also request later
notification on completion of the I/O.

An asynchronous read enables an application to control the amount of
read-ahead that is performed so that the data can already be available
when the database application needs it. With database and transaction
processing software, often the writing out of data can be done
asynchronously although you may need to know when the I/O has completed.
The notification mechanism provided in UNIX System V fulfills this need.

--------------

**NOTE:** `\``How to use asynchronous I/O with your
application'' <AIO_HowUseAsynchronousIOApp.html>`__ describes how an
application may use the interfaces specified in this document.

--------------

Performance
-----------

The Asynchronous I/O feature enhances performance by allowing
applications to overlap processing with I/O operations. Using
Asynchronous I/O enables an application to have more CPU time available
to perform other processing while the I/O is taking place.

When **read** and **write** system calls return, the data is copied into
or out of the user buffer, respectively. This usually requires copying
data between user and kernel spaces, and may possibly also require real
I/O. If only the copy operation is required, the user process must wait,
and if I/O is necessary, the process will also be blocked. For
applications such as real time and transaction processing, this waiting
and blocking time may be so significant that there may be an application
that supports concurrent execution of I/O and other work in the
application.

With the Asynchronous I/O capability, an application can submit an I/O
request without waiting for its completion, and perform other CPU work
either until it is asynchronously notified of the completion of the I/O
operation, or until it wishes to poll for the completion. For
applications that involve large amounts of I/O data, this CPU and I/O
overlapping can offer significant improvement on throughput.

--------------

/Using asynchronous I/O
=======================

SCO OpenServer offers a thread-based implementation of Asynchronous I/O
that supports all file types, as well as a high performance,
kernel-based implementation of Asynchronous I/O that supports only raw
slices of hard disks.

POSIX interfaces are implemented and included in a single library,
**libthread**, that provides applications with access to this feature.
The Asynchronous I/O routines are included in this library and,
therefore, you must link with **libthread** to use these routines.

Figure 12-1 shows the relationship between the Asynchronous I/O
interface functions and the common threads library, the two versions of
the UNIX Operating System, the interfaces for all the file types, and
the Kernel Implementation used for raw slices of hard disks.

.. image:: http://osr600doc.xinuos.com/en/SDK_sysprog/graphics/aiofuncs.gif

**Asynchronous I/O interface functions**

The following sections detail the various interfaces.

--------------

/Asynchronous I/O control block
===============================

The Asynchronous I/O interfaces use an Asynchronous I/O control block
**aiocb** to provide information when making a request. The data
structure of **aiocb_t** is shown below. See *aiocb*\ (5) for more
details.

::

         int             aio_fildes;      /* file descriptor          */
         volatile void  *aio_buf;         /* buffer location          */
         size_t          aio_nbytes;      /* length of transfer       */
         off_t           aio_offset;      /* file offset              */
         int             aio_reqprio;     /* request priority offset  */
         struct sigevent aio_sigevent;    /* signal number and offset */
         int             aio_lio_opcode;  /* listio operation         */
         int             aio_flags;       /* flags                    */

--------------


/Threads-based Interface
========================

The SVR4.2 MP version of Asynchronous I/O contains the following
caveats: 

-  Uses all POSIX interfaces including **aio_suspend** and
   **aio_cancel**.
-  Can implement Asynchronous I/O over all file types, not just raw disk
   slices and is implemented in the thread-based library **libthread**.
-  Does not need to use **aio_memlock** to lock memory.
-  Does not support **lio_listio**.

Threads-based interface operations
----------------------------------

This section describes how the threads-based version of Asynchronous I/O
operates on the following: 

-  regular files
-  device files
-  STREAMS-based files.

It is not limited to specific file system types. Any device that
supports **read** and **write** will accept asynchronous read and write
requests.

The **aio_read** and **aio_write** interface routines correspond to the
**read** and **write** system calls to support asynchronous read and
write operations. These Asynchronous I/O operations are available with
unbuffered as well as buffered I/O on those file system types that
support unbuffered I/O.

Since unbuffered I/O is not available across all file system types,
asynchronous unbuffered I/O will only be available on those file system
types that support this capability.

--------------

**CAUTION:** It is important that multiple threads performing I/O to the
same file cooperate since the order of operations is non-deterministic.
Even one thread should be careful not to mix synchronous I/O requests
with asynchronous I/O requests (with or without buffering) since the
order of operations is implementation dependent.

--------------

The asynchronous read and write interfaces allow you to specify the file
offset indicating where the I/O should begin. It is possible to specify
absolute file offsets for each I/O request and this type of access is
defined to be random. It is also possible to indicate that the I/O
should begin at the **current** file offset. Sequential access is
defined to be multiple I/O requests from a single thread of control to
the same file descriptor indicating that I/O should begin at the current
file offset. See the section entitled **Asynchronous I/O Control Block**
for more information.

Determining the value of the file pointer when Asynchronous I/O
operations are in progress is difficult. Considering that there may be
multiple outstanding asynchronous I/O operations, each of which may
update the file pointer at any time, things may become complex for an
application. An application should be careful not to mix calls to
**read** and **write** or **lseek**, for example, with Asynchronous I/O
operations. If sequential I/O is not requested, the order of I/O
operations is implementation dependent. In general, until all
asynchronous operations on a file are completed, the position of the
file pointer is considered to be indeterminate.

An application can request cancellation of one or more Asynchronous I/O
requests that the application had previously queued. The **aio_cancel**
interface enables an application to cancel one or more outstanding
Asynchronous I/O operations. Those that have not been started are
canceled but those in progress may or may not be canceled.

An application can wait for Asynchronous I/O completion. If an
application has completed all its **other work**, it may relinquish
control of the CPU until some of its outstanding asynchronous I/O
requests have completed.

An application can obtain completion status information by calling
**aio_error** and **aio_return**.

--------------

**NOTE:** The completion of an asynchronous write on any device has the
same semantics as a synchronous write to that device; for example,
completion of a write to a STREAMS-based device means that the data has
been copied into the stream's queue and does not imply that the data has
been written to a device.

--------------

When an Asynchronous I/O request is made, the application can also
request that it be notified when the I/O completes. This lets the
application know immediately that the I/O has completed rather than
having the application poll for completion status.

Single threaded and multithreaded applications
----------------------------------------------

Asynchronous I/O may be used by single threaded or multithreaded
applications.

In multithreaded applications, multiple threads within a process share
the same address space and therefore have access to the Asynchronous I/O
control blocks of any other thread within that process. For example, one
thread may begin an asynchronous read on an open file and another thread
within that process may use the **aio_suspend** interface to determine
if that read operation has completed. If this occurs, the application
must make sure that the cooperating threads are properly synchronized.

--------------


/Kernel implementation
======================

If you want higher performance for your applications, such as database
applications, use the Kernel Implementation. The Kernel Implementation
contains the following caveats: 

-  It supports Asynchronous I/O only on raw slices of hard disks.
-  It supports the same interface but must be used with two additional
   interfaces, **aio_memlock** and the **AIO_RAW** flag.

   -  The **aio_memlock** function must be called to lock the I/O buffer
      in memory before any other Asynchronous I/O operations can be
      performed.
   -  The **AIO_RAW** flag has to be set in the **aiocb** control block
      so that the Asynchronous I/O operations will be performed by the
      kernel.

-  It can be used on systems that only support raw disk slices such as
   SVR4.2.
-  It supports **lio_listio**, but does not support **aio_suspend** and
   **aio_cancel**.

Accessing raw disk slices
-------------------------

The aio_flags member of the **aiocb** control block must be set to
**AIO_RAW** if you want to access raw disk slices. The following example
shows you how to set this flag: 

::

      aiocb.aio_flags = AIO_RAW;

Using the asynchronous I/O memory lock
--------------------------------------

The Asynchronous I/O interface uses **aio_memlock** to perform memory
lock operations. See **aio_memlock**\ (S). Before starting an
Asynchronous I/O request, the application must lock an area of memory to
be used for the I/O buffer. The size of the locked area is determined by
the number of requests that may be outstanding at any point in time.
Only the I/O buffer area must be locked. Once this buffer has been
locked with **aio_memlock**, it can not be resized or unlocked. When the
application exits, the memory is unlocked automatically.

--------------


/Error handling
===============

The Asynchronous I/O feature handles errors by returning a value of
**-1** and placing an error number in the externally declared variable
**errno**. It is included in *<errno.h>*.

The value of **errno** or the **aio_error** function can be set to one
of the following: 

**EAGAIN**
   The requested Asynchronous I/O operation was not queued because of
   system resource limitations. The first request to encounter a
   resource limitation and all later requests will be marked such that
   **aio_error** returns **EAGAIN**.
**EFAULT**
   **aiocbp** or the **aio_buf** member points outside the allocated
   address space.
**ECANCELED**
   The requested I/O was canceled before the I/O completed because of an
   explicit **aio_cancel** request.
**EINVAL**
   All requests are **NULL** or have their **lio_listio** set to
   **LIO_NOP**. This is used for **lio_listio** only.
**EINVAL**
   **nent** is zero. This is used for **lio_listio** only.
**EINVAL**
   On SVR4.2, the request does not have the **AIO_RAW** flag bit set in
   **aio_flags**.
**EFAULT**
   A memory fault occurred while accessing a **lio_listio** request. In
   this cause, **lio_listio** returns immediately without processing
   later requests in the list. On some implementations, memory faults
   might result in a **SIGSEGV** signal being delivered to the processes
   instead of returning the error code. This is used for **lio_listio**
   only.

Error behavior
--------------

The following describes the detailed error behavior for the
**lio_listio** and **aio_cancel** functions.

**lio_listio**
   If the number of entries indicated by **nent** causes the system-wide
   limit **AIO_MAX** to be exceeded, **lio_listio** returns with **-1**
   and sets **errno** to **EAGAIN** after marking **EAGAIN** in all
   requests.

   If **nent** is greater than **AIO_LISTIO_MAX**, **lio_listio**
   returns immediately with **-1** and sets **errno** to **EINVAL**. No
   requests are processed or touched.

   Requests are processed as follows: 

   #. If there is a memory fault while accessing a request,
      **lio_listio** immediately returns **-1** or **EFAULT**, or causes
      a **SIGSEGV**.
   #. If a resource problem occurs while queuing a request,
      **lio_listio** returns **-1** and sets **errno** to **EAGAIN** for
      all remaining requests.
   #. If any other problem occurs with a request, **lio_listio** returns
      **-1** and sets **errno** to the appropriate error code.
      **lio_listio** continues processing requests and remembers what
      was wrong with the request in order for **lio_listio** to return
      this error code. The callback or signal will not be executed for
      that request. Note that if different errors occur while processing
      requests, it is unspecified which error code gets returned. For
      example, it could be the first error encountered, or the last one.
   #. If all requests from **1** through **nent** have
      **aio_lio_opcode** = **LIO_NOP** or **nent** is zero,
      **lio_listio** returns **-1** or **EINVAL**.

**aio_cancel**
   **aio_cancel** returns **AIO_CANCELED** if all requests were either
   canceled or completed and at least one request was canceled.

   If an attempt was made to cancel a request that is in progress, but
   it is uncertain whether the request will be canceled, **aio_cancel**
   will return **AIO_NOTCANCELED**.

--------------

/Using the interface functions
==============================

This section tells you how to use the four interface functions: 

-  `aio_read <_Using_the_Interface_Functions.html#_aio_read_and_aio_write>`__
-  `aio_write <_Using_the_Interface_Functions.html#_aio_read_and_aio_write>`__
-  `aio_suspend\ + <_Using_the_Interface_Functions.html#_aio_suspend>`__
-  `aio_cancel\ + <_Using_the_Interface_Functions.html#_aio_cancel>`__

aio_read and aio_write
----------------------

**aio_read** and **aio_write** allow an application to request an
asynchronous read or asynchronous write operation. When initiating an
asynchronous read or write, you can request asynchronous notification by
supplying the address of a user-defined handler to be invoked when the
I/O has completed. Since the address of the **aiocb** control block is
passed as an argument to the handler, the I/O request that completed is
easily identified and you need only implement one handler.

aio_suspend
-----------

An application may request asynchronous notification by supplying the
address of a user-defined handler to be called on completion of the
Asynchronous I/O request. This enables the application to perform other
work while the I/O is in progress and guarantees that the application
will be notified at the time the I/O completes so that any processing on
that data may be performed immediately, if so desired.

For threads-based Asynchronous I/O, an application may also use the
**aio_suspend** interface to block until at least one I/O operation
completes or a timeout period expires. This interface is flexible
because it enables any thread within a process to ask about one or more
outstanding Asynchronous I/O operations and can specify how long to
wait.

The **aio_suspend** routine returns **0** if at least one matching I/O
request completed.

A null pointer is returned on failure and **errno** is set to indicate
that the **timeout** expired (**ETIME**) or an interrupt occurred
(**EINTR**).

aio_cancel
----------

Although rarely needed, **aio_cancel** is the only way to cancel an
Asynchronous I/O request that has been blocked for input from a remote
host that just crashed. Requests that have not been started are
canceled, but those in progress may or may not be canceled.

--------------


/Using other system calls with asynchronous I/O
===============================================

This section describes how an Asynchronous I/O application affects and
is affected by the **fork, exec, exit** and **close** system calls.

fork and forkall
----------------

No Asynchronous I/O is inherited for **fork** and **forkall**.
Asynchronous I/O operations that occur after the **fork** or **forkall**
do not affect the copy of the **aiocb** control block in the child's
address space and the child does not receive any notification from the
completion of the parent's I/O. For example, if the parent process does
a **forkall** while an I/O is in progress, the I/O completion will not
be delivered to the child process.

exec and exit
-------------

Before calling **exec** and **exit**, you must attempt to cancel all
outstanding Asynchronous I/O requests. The **exit** function will wait
for all outstanding Asynchronous I/O operations to complete before
returning. It will unlock the area of memory locked by the
**aio_memlock** call.

The **sbrk, brk** and **shmdt** functions will return **EBUSY** if the
areas of locked memory are within the area affected by the call.

The **exec** function will fail if there are any outstanding
Asynchronous I/O operations, so you must ensure that no requests are
outstanding before calling **exec**.

close
-----

When using the **AIO_RAW** flag on raw slices of hard disks, **close**
will block until all outstanding asynchronous I/O operations are
completed. When the call returns, the application is free to reuse the
control block and buffers.

If the **AIO_RAW** flag is not used, the **close**\ (**fd**) has to be
trapped so that all outstanding requests to **fd** can be canceled. This
is done by first calling **aio_cancel** until all have been canceled,
and then **\_close** to close the file.

--------------


/How to use asynchronous I/O with your application
==================================================

Points to remember include: 

-  The **aiocb** control block is the center of all asynchronous I/O
   requests. You must allocate a control block and assign values to its
   members before a call to **aio_read** or **aio_write** is made.
-  Before an application exits or closes its file descriptors, it should
   ensure that all its Asynchronous I/O requests complete.
-  If you want to lock an area of memory using **aio_memlock**, you must
   be sure that you are running the Kernel-based version of Asynchronous
   I/O.

--------------

/13. Guidelines for writing trusted software
=============================================

As a programmer on SCO OpenServer, you need to be aware of the special
care you need to exercise when designing and writing software for any
system. You want to ensure that the software you write and install for
local applications is trusted.

The concept of trusting software is applicable to any system, regardless
of the level of security implemented; the process of trusting software
will lead to a more secure installation.

Trust is the belief that a system element upholds the security policy of
an operating system. If this belief is founded on blind faith, disasters
are likely to happen, so it makes sense to assign trust only when a
system element has been shown to deserve that trust.

For user-level software, this means making sure that a command or
library routine works as advertised, and prevents unauthorized users
from circumventing access controls or mechanisms that protect sensitive
system operations. In this topic, trust refers not to blind faith, but
to confirmed trustworthiness.


/How to use this topic
======================

This topic is divided into sections describing the procedures needed to
produce and install trusted software. For background information, you
may want to read `Administering users and
groups <../UG_admin/CONTENTS.html>`__.

It is a good idea to become familiar with the background material first,
then proceed with reading the sections that explain how to ensure trust
in the kind of software you are writing. Reading all the sections is
useful, but not essential. Many rules for ensuring trust are also good
general programming practices, so they may also benefit any programming
you do.

Finally, be aware that these sections does not contain the definitive
explanation of trust. Writing software is as much an art as it is a
science, and the rules presented here are only guidelines to gain an
understanding of the issues involved. It is by no means a guarantee that
you will produce trusted software if you blindly obey the rules and
dutifully mark the checklists. However, reading the advice here is a
good beginning to learning how to write trusted software.

--------------


/Scope of trust
===============

The first step in assigning trust to a command or library routine is to
determine whether it has enough access to the system to require trust.
Some commands do not require privilege or access to sensitive
information. Such commands need not be trusted, since they pose no
threat.

Other commands either occasionally or routinely obtain access to
sensitive operations, or create that access for themselves through
mechanisms like the **setuid-on-exec** feature. These commands must be
trusted, since they operate in a sensitive environment.

The rules dictating which commands need trust and which commands do not
are straightforward, but matching a command to a rule may not be. The
following command classes must always be trusted: 

-  commands used by administrative personnel
-  commands invoked by other trusted commands
-  commands that use privilege
-  commands that set their user or group identity to an administrative
   one on execution (**set-id**)

Deciding whether a command is \``used by administrative personnel'' or
\``uses privilege'' can be difficult, since this distinction often
varies from site to site and administrator to administrator.

Library routines have similar rules, but these routines are so pervasive
the most reasonable rule is: each library routine must be trusted unless
it can be shown not to be used by trusted code. This principle means
that every element of a trusted command must itself be trusted. This
principle includes the private routines within the command as well as
all library routines used by the command.

--------------


/How trust is achieved
======================

The rules for trust are different for commands and library routines.
These rules are described in detail in the remaining sections.

Trust is achieved by following all rules that pertain to writing a given
piece of software and by documenting the methods used to follow those
rules. This documentation must be supplied with every piece of trusted
software. It describes the circumstances under which it is trusted, the
methods used to make it trusted, and warnings about any practices that
might jeopardize the trust placed in the software.

As with all code that is to be incorporated in a running system, trusted
software needs to be reviewed and tested before it is installed. You can
have reviewers and testers read the sections in this topic so that they
can familiarize themselves with the special requirements for trusted
software.

--------------

/Trust and security
===================

Any discussion of software trust must be based on fundamental
understanding of the security-related system elements. These elements
are: 

-  `Privileges <GWTS_Priv.html>`__
-  `Trusted Facility Management (TFM) <GWTS_TrustedFctyMgmt.html>`__
-  `Discretionary Access Controls (DAC) <_DAC.html>`__
-  `DAC Isolation
   Mechanism <_DAC.html#_Discretionary_Access_Isolation>`__

The next subsections give a general explanation of these elements of
security and trust. There are other descriptions in `Managing system
security <../SEC_admin/CONTENTS.html>`__ to which you may want to refer
for other perspectives and information.

--------------

/Privilege
==========

Privilege means \``the ability to override system restrictions.'' This
ability is vested in three ways: 

-  in any user whose effective identity is *root*
-  by way of the TFM feature
-  through fixed privileges assigned to a command

There is a problem with the first approach to overriding system
restrictions. A user (or command) allowed a reasonably mundane
privileged action (for example, reading a protected file without
explicit permission) also has permission to perform every other
privileged action on the system, including the permission to overwrite
all files on the system, add users, kill processes, start and stop
network services, mount and unmount file systems, and many other
sensitive operations. There is no restriction because there is no way to
give a \``little bit of *root*'' to a user or command. Any process with
an effective user-ID of \``0'' (*root*) is considered omnipotent.

The second and third approaches provide methods of giving a \``little
bit of *root*'' to a user or command, and thus address the problem with
the first approach. These approaches can be thought of as
\``Administrative Least Privilege'' since they introduce the idea of
discrete privileges that are associated with command files and
processes.

The second and third approaches dissolve the bond between user identity
and privilege, making privilege a process and command attribute instead
of a user attribute. This approach makes sense because command behavior
is much easier to describe and regulate than user behavior.

Process privileges are contained in two sets, \``working'' and
\``maximum.'' The working set contains the privileges in effect at any
particular instant. This set controls the restrictions that the process
can override at the moment. The **procpriv**\ (S) system call allows a
command to set or clear privileges in the working set.

The maximum set represents the upper limit of privileges that a process
can have in its working set. These privileges have no effect unless they
are also in the working set, but they are held in reserve for the
command to assert at any time. Using the **procpriv** system call, a
command can clear a privilege in the maximum set but cannot set one.

The privilege set associated with a command's executable file determine
what is put in the working and maximum privilege sets when a process
executes the command. The file privilege set is called \``fixed.'' Fixed
privileges are useful for commands that do privileged things for
ordinary users because they are granted unconditionally upon execution.
The unconditional nature of fixed privileges, however, means that any
program that uses them must strictly enforce all system policies it can
override.

--------------

/Trusted facility management
============================

Historically, the only way a process could acquire privilege was if the
value of the effective user-ID was \``0'', which is traditionally
associated with the *root* login. This acquisition could be accomplished
in one of two ways: 

-  logging in as a user whose real user-ID is \``0'' (i.e. *root*), or
-  executing a command file that is **setuid-on-exec** and is owned by
   *root*. This results in a process effectively executing as *root*.

With this release, another method of acquiring privilege has been
defined. This method is the Trusted Facility Management (TFM) mechanism.
TFM provides an interface between users (not privileged) and commands
(possibly privileged or requiring privilege). The primary elements of
TFM are the **tfadmin**\ (ADM) command, and the TFM database.

| The **tfadmin** command is invoked with the desired command line as
  its arguments as in the following example: 
| tfadmin mount /dev/mydsk /my_mnt_point

The fixed privilege set of the **tfadmin** command file contains all
privileges, so the **exec** system call turns on all privileges in the
resulting process.

But the **tfadmin** command cannot be executed successfully by every
user. To open it to such free access would be a violation of trust. When
**tfadmin** is invoked, the first thing it does is to find out the real
identity (real UID) of the invoking user. It then uses that identity to
find the user's entry in the TFM Database.

A TFM database contains two pieces of information: 

-  the list of privileged commands that define specific roles
-  the list of administrative roles and/or privileged commands to which
   the user is assigned

| A trusted system may define administrative roles for selected system
  administrators. Each role may be filled by a different administrator
  in order that all sensitive administrative functions not be handled by
  a single person. This division of administrative duties into separate
  roles reduces the chances for misuse of administrative power. All
  trusted administrators will be associated with at least one role
  and/or set of privileged commands; a very few administrators may be
| associated with more than one role, especially at small sites. But
  most users are not associated with any role.

When **tfadmin** finds the user's entry, it looks for the requested
command in the list of specific commands, and if it does not find it, in
the list of roles. Once the command is found and the user's entry
verifies that the user is assigned to a role that has the authorization
to use that command, **tfadmin** leaves on the correct privileges (found
in the database entry for the command) in its maximum set, but turns off
all others, and executes the command. These privileges are propagated
across the chain of execution of any child processes.

By providing a single point of privileged access to administrative
commands and by basing that access on the real identity of the
requesting user, **tfadmin** eliminates the need for privileged ID's and
enhances administrative accountability.

--------------

/Discretionary Access Control
=============================

Discretionary Access Control (DAC) on a file defines the permissible
access to it by its owner, the owner's group, and all others. It is
discretionary because the protection on this data object is set at the
discretion of the owner of the object. When the Enhanced Security
Utilities are installed, DAC also includes Access Control Lists (ACLs).

/Discretionary access isolation
===============================

Before discussing how Discretionary Access Control (DAC) provides a fine
granularity of file protection, a review of the limitations and pitfalls
of discretionary protection is in order.

First, the discretion to change permissions on data resides with the
owner. If ownership of a piece of data is obtained by a malicious or
incompetent user, nothing can prevent that user from destroying all
discretionary protections.

Second, discretionary access controls cannot be used to prevent
sensitive software or users from reading bad data, because the owner of
a file can always make its data readable by the world, and the world
includes sensitive people.

Finally, discretionary access is based on effective user and group
identity. Effective identities change whenever a set-id-on-exec command
runs, and they remain changed until the command sets them back to the
real identities or exits.

Thus, sensitive discretionary access (and ownership) can be passed from
a trusted command to an untrusted one by accident, exposing the system
to attack.

SCO OpenServer protects sensitive data files by setting the ownership of
all such files to *root* and supplying **setuid-on-exec** commands to
give users controlled access to these files. This method provides
protection because it makes protected files accessible only to the most
restricted user.

This protection is adequate for most systems, but it is inadequate for
protecting sensitive information on secure systems, because in practice,
this has led to a proliferation of **setuid-on-exec** to *root*
commands, some of which might be less careful than they should about
propagating the *root* user identity to other commands. As a result, not
only did the file protection begin to fail, but what had been the most
restricted user identity suddenly became much easier to obtain.

The next attempt was to set up \``ghost'' user identities other than
*root* to own sensitive files. Ghost user identities are user ID's in
the system that are inaccessible as a valid user account (i.e. no one
can login with this ID. Programmers using this technique managed to
protect *root* somewhat better, but still left open the risk of Trojan
Horse attacks on the files they were trying to protect. Finally, it
became clear that giving away ownership to files made attacks too easy.
Giving away group access was preferable. True, it was still possible to
gain unauthorized access through imperfect system commands, but at least
that access was limited to reading and writing.

The currently recommended DAC isolation method calls for the existence
of a \``ghost'' owner: *sys*. This owner has a locked password entry, to
make logging in as that user impossible. In addition, no commands can
set their user identity to *sys* upon execution. This makes it
impossible for a non-privileged process to obtain this user identity.
Groups are defined to provide protection isolated according to the kinds
of commands and users needing access to protected files. Administrators
are assigned multiple group lists that allow direct access to protected
files while normal users may gain access only through set-gid commands.
All files protected by this mechanism are owned by *sys* and have the
appropriate system group identity.

--------------


/Writing trusted commands
=========================

The following sections describe how to write trusted commands.

--------------

/User documentation
===================

The first line of defense against system damage is accurate and complete
documentation. Before a command can be trusted, its use, behavior,
options, and influence over the system must be fully described. In
addition to a full description of the command, any potentially harmful
behavior should be noted, to allow users to avoid such hazards.

--------------


/Parameter and process attribute checking
=========================================

The parameters given to a command at execution are the primary external
influences over the behavior of the command. All parameters passed into
a command at execution, therefore, must be checked and shown to be
consistent by the command before processing starts. This means that a
command that has, for example, two mutually exclusive modes of operation
based on command line options must ensure that only one of these modes
is requested at a time. This is particularly important when one
operation might negate the other or cause an inconsistency in the
system, or when the interfaces for two operations are similar enough to
interact in a way that might be misinterpreted by the command.

Process attributes are also important, but, with rare exception, should
not be checked explicitly by a command. The reason for this is that most
process attributes are intended to be checked by the operating system
itself and will cause identifiable errors if they are not right. It is
unwise to make assumptions about the way a particular operating system
decision will come out based on potentially flawed knowledge of how the
decision is made. Some exceptions to this rule are the process
**umask**, which should be set as needed by all trusted commands, and
the process **ulimit**, which, if too small, may lead a trusted command
to an error from which it cannot gracefully recover.

--------------


/Privilege and special access
=============================

There are two forms of special access in SCO OpenServer. The first is
the access granted by the set-id feature, and the second is privilege.
In the past these have been bound together through the *root* effective
user identity, and they continue to be bound in superuser-based versions
of SCO OpenServer.

Set-id commands
---------------

Commands that use the set-id feature to obtain access to files not
otherwise available to an invoking user must carefully control not only
their own use of these access permissions, but how these permissions are
granted to other commands. There is always the possibility of a Trojan
Horse when a command executes another command so care must be taken (see
`\``Executing other commands'' <GWTS_ExecutCmds.html>`__) In this
section, the issue is incorrect use of special access rights. In
general, the best protection against either incorrect use or a Trojan
Horse is to reset the effective user and group identity immediately on
entry to a command and only use the special identities where they are
explicitly needed. The code excerpt in `\``Correct regulation of access
in C programs'' <_Priv_Special_Access.html#trusted_sw_tW>`__ illustrates
the procedure.

::

      static  uid_t   eff_uid, real_uid;
      static  uid_t    eff_gid, real_gid;
              .
              .
              .
      main(argc, argv)
      int     argc;
      char    *argv[];
      {
              /*Variable declarations*/
              eff_uid = geteuid();
              eff_gid = getegid();
              real_uid = getuid();
              real_gid = getgid();
              if(seteuid(real_uid) < 0){  /*Set the effective UID to the real*/
                      error("Cannot reset UID."); /*Report error and exit*/
              }
              if(setegid(real_gid) < 0){  /*Set the effective GID to the real*/
                      error("Cannot reset GID."); /*Report error and exit*/
              }
                    .
                    .
                    .
              if(setegid(eff_gid) < 0){            /*Assert the effective GID*/
                      error("Cannot assert GID.");/*Report error and exit*/
              }
              fd = open("/etc/security_file", O_RDWR);
              if(setegid(real_gid) < 0){  /*Set the effective GID to the real*/
                      cleanup();                  /*Restore consistency*/
                      error("Cannot reset GID."); /*Report error and exit*/
              }
              if(fd < 0){
                      error("Cannot open file."); /*Report error and exit*/
              }
              /*Process data*/
                    .
                    .
                    .
              close(fd);
      }

**Correct regulation of access in C programs**

--------------

/Privilege and special access in shared private routines
========================================================

A group of related commands occasionally share routines from a common
object module. Such routines may provide database access, device setup
and release, data conversion, etc. The desire to centralize these
utility functions leads to creation of private \``libraries.'' Although
these are not usually libraries in the archive sense, they are
collections of useful routines stored in a place that makes them
accessible to a controlled group of commands. Since these routines are
private, they are treated as subsections of the commands that use them.
These routines are designed to cooperate closely with their calling
programs, so they are expected to regulate privilege internally.

Exceptions to this rule occur when different commands have different
views of the same routine or when the designer of a routine believes the
routine may be added to a public library. A private database library may
contain a routine to open and position the database. A command that only
needs to query the database might want to assert only read access
override privileges while a command that changes the database might want
to assert both read and write access override privileges. Such a routine
should make no assumptions about what privileges the calling routine
wants to use, but should simply assume that the correct privileges are
in place.

A library routine might also have broad enough usefulness to be a
candidate for public use. The reasons why such a routine might not be
placed in a public library range from a desire to keep the published
interface as small as possible to name conflicts or even lack of staff
to make the change. If a programmer believes that a routine is useful
enough to merit consideration for a public library, the programmer
should follow the rules for writing public library routines, even if the
routine is initially private.

These guidelines apply equally well to special access permissions
obtained through the set-id mechanism as they do to privilege. Wherever
these access permissions are used instead of privilege, they should be
turned on and off as though they were individual privileges, using the
**seteuid** and **setegid** system calls as shown in `\``Correct
regulation of access in C
programs'' <_Priv_Special_Access.html#trusted_sw_tW>`__.

--------------


/Error checking
===============

Almost every system call or library routine can, somehow, encounter an
error during its operation. While many of these occur only because of
programmer error, each such problem indicates a failure of either the
system, the calling program or a transient parameter like access
permission or available memory. If a programmer chooses to ignore a
reported error, the result is a command that, should some basic
assumption of the system fail, could corrupt its environment. For
trusted commands, therefore, every possible error return must be checked
and reported. This rule is not always followed to the letter, since in
some cases it is more efficient to detect the error case downstream from
the actual failure. Ignoring errors is risky and should not be done
without strong justification.

--------------


/Signal handling
================

Signals pose a problem in trusted software because they are not
predictable. There are two main areas of concern when it comes to
handling signals: 

#. maintaining system integrity when a trusted command receives a signal
#. use of privilege and special permission inside signal handling
   functions

If a signal is received by a trusted command, that command must not
simply exit and leave the system in an inconsistent or insecure state.
If a command contains critical sections that cannot be interrupted,
every effort must be made to prevent signals from interrupting those
sections.

On the other hand, a signal usually means either that a system problem
has occurred (like memory exhaustion, an addressing error, or invalid
operation) or that the user has decided to abort the operation.
Regardless, it is not correct for a command to continue processing as
though nothing had happened.

A system-generated signal usually signifies a flaw in the command and
almost certainly means that further processing will be based on corrupt
data. A user-generated signal signifies a change of heart by the
requesting user and should be honored where possible by restoring the
system to the state it was in before the command was invoked. If a
command receives a signal after it is committed to a change, the command
should finish any steps necessary to ensure consistency and exit.

Attempts to write signal-safe commands must take into account the
possibility of unforeseen signals and signals that cannot be caught. On
any given system, the set of possible signals is constant, but in
general, systems are allowed to have their own implementation-specific
signals.

It is better to keep the critical sections of a command as small as
possible than to try to protect large critical sections against
interruption. This principle means, for example, a command that changes
a system database should make all changes on a copy of any sensitive
part of the database (for example an index file) before replacing the
original. This limits opportunity for an unknown signal to interrupt the
sensitive part of the command.

When a trusted command is using privilege or some other extraordinary
access and receives a signal, the command may enter a signal handler.
Because signals are unpredictable, it is not a good idea for a command
to change the privileges or other access attributes of its process
inside a signal handler. When the handler returns to the main stream of
processing, these attributes must be the same as they were before the
signal occurred, or unpredictable processing will result.

Since signal handlers are not allowed to change process attributes, they
should never do anything that might take advantage of privileges or
special access. In general, a signal handler should set a flag and
return or longjump away. Once the flag is set, the command can recognize
the signal and respond to it in an orderly fashion.

--------------


/Handling sensitive data
========================

While it is important that trusted commands always protect the integrity
of the data they manipulate, they must also prevent information
disclosure that might damage system security. If commands are used
exclusively by administrators or never gain access to sensitive
information, then they are mostly exempt from this concern, but some
commands are regularly used by non-administrators and use privilege or
special access to read secret information.

An example is the **passwd** command. The **passwd** command retrieves
information from the system password list (not normally readable by
users) and reports (and sometimes changes) that information. In the
process of obtaining the information, **passwd** must scan through
records that are not intended for the eyes of the invoking user. If a
signal were to cause **passwd** to write a core image with one or more
records buffered, it would be possible for an enterprising programmer to
extract secret information from the core image.

It is best to eliminate this possibility by designing databases and
commands to handle only the sensitive information they are authorized to
disclose. When it is impossible to eliminate the risk, programmers
should limit the vulnerability of the command by clearing the contents
of any sensitive buffers as soon as they cease to be needed.

--------------

/Executing other commands
=========================

Whenever a command executes another command, it must first set its
effective user and group identities to its real user and group
identities unless the executed command needs the special access to do
its job. If the executed command needs the special access, the executing
command must take every possible step to ensure that it executes the
correct command with proper parameters and cannot be misled into
executing a Trojan Horse.

A Trojan Horse is a command that imposes itself on a process by looking
like the needed command. It inherits permissions and other attributes
(like file descriptors, environment, and so on), from the executing
command, and can use these capabilities to disrupt the system. Measures
to prevent Trojan Horse intrusion include the following: 

-  using full pathnames for execution
-  avoiding the **system** and **popen** library routines, which use the
   shell to interpret command lines
-  carefully making sure the *$PATH*, **$IFS**, and other environment
   variables are set to safe values whenever the shell must be used
-  never allowing special-access rights or file descriptors to survive
   across an execution of a user-supplied command name

--------------

/Using library routines
=======================

A trusted command must never use an untrusted library routine. This
restriction means that a trusted command must never use a library
routine that has an untrusted call anywhere in its calling sequence, nor
a library routine that causes an untrusted command to be executed. The
information derived from the untrusted command might influence the
behavior of the trusted command, or the command might give away
extraordinary access to the untrusted command; neither action is
acceptable.

--------------

/Trusting shell scripts
=======================

With the introduction of support for multiple file formats in SCO
OpenServer, it is possible to have set-id and privileged shell scripts.
In addition, there have always been shell scripts that are used by
administrators. If a shell script can get administrative access to the
system it must be trusted, so rules for trusting shell scripts are
needed as well.

The primary rule of trusted shell scripts is: any shell script that uses
privilege or special access rights is subject to spoofing and must not
be available to non-administrators.

User documentation
------------------

The documentation needed for a trusted shell script is the same as that
for any other trusted command (see `\``User
documentation'' <User_Doc1.html>`__).

Privilege and special access
----------------------------

The shell offers no way to control special access rights granted by the
set-id feature and only limited ability to regulate privilege. Without
this control, such a shell script must be extremely simple before it can
be trusted. In general, it is not a good idea to use the set-id
mechanisms for shell scripts. Only trusted commands should be used in
shell scripts.

The shell's limited ability to regulate privileges is provided through
the new built-in **priv** command. This command can be used to
manipulate both working and fixed privileges of the shell. Note, though,
that removing privileges from the shell's working privilege set is
ineffectual in preventing these privileges from being propagated to
executed commands, since it is the maximum privilege set that determines
what privileges an executed command will have. But removing privileges
from the maximum privilege set is permanent -- they cannot be regained
later for propagation to a command that needs privileges. As such,
writing a trusted shell script that propagates its privileges only to
the commands that need it can be rather unwieldy. In general, it is best
not to give the privileges to the shell script itself. Instead, leave
the shell script unprivileged, and whenever the script needs to invoke a
command with privilege, it can invoke that command through **tfadmin**.
In this case, all commands invoked through **tfadmin** must exist in the
TFM database, and all users who are to execute the script must have
access to them.

If a script must be run with privileges, that first line of the script
must be "**#!/sbin/sh -p**".

Error checking
--------------

Most commands report the errors they encounter and exit with a non-zero
return code on failure. Shell scripts, therefore, usually do not need to
bother reporting errors. Nonetheless, shell scripts should check for
errors. A command that fails and reports an error indicates a problem in
the shell script. If that error might cause the system to be left in an
inconsistent state by the script, the error must be caught and handled.
Whether the error is specially reported depends on the particular
circumstances.

For example, if the failing command redirects its standard error output
to a file or to */dev/null*, the shell script must report an error to
avoid failing silently.

If, on the other hand, the command does nothing to redirect messages,
then the command's error message should be enough to tell the user what
happened.

--------------

/Trusting public library routines
=================================

While commands obtain their privilege and special access through kernel
mechanisms, library routines obtain their access rights and privileges
from the commands that call them. Additionally, library routines usually
serve a single purpose instead of offering a spectrum of options. These
differences dictate the rules for library routines described below.

Documentation
-------------

The most important aspect of trusting a library routine is the
documentation used by a programmer to decide how and when that routine
should be used. This description should include basic elements such as
the interface to the routine, what the routine does, and what error
conditions might be encountered by the routine. Additionally, any
privileged routine should have a description of the privileges it can
use and the reason it might use each privilege. Also, any interesting
side effects of the routine should be detailed. These include opening,
closing, deleting or creating files, executing commands, setting global
variables, allocating heap storage, changing process attributes, sending
signals, or any other behavior that is not immediately obvious to the
reader.

Finally, the description should include a section describing any
non-trusted uses of the routine. If, for example, a user can cause the
routine to fill past the end of a buffer by feeding it too much data,
this possibility should be stated in the description. By supplying as
much information as possible to the programmer who will use the routine,
the documenter allows the programmer to choose routines wisely and use
them correctly.

Privilege and special access
----------------------------

Public libraries provide many useful functions, such as file IO
buffering, memory allocation, and mathematical processing. These
routines are intended for use by a wide variety of applications, with a
wide variety of needs and goals.

A library routine, therefore, should not try to guess the intent of the
calling program. It should simply do its job and return. The rule for
public library routines and privilege or special access is: no public
routine should change the privilege or access environment of a process
unless that is its primary purpose. There should be no exceptions to
this rule, since a trusted command must always be in full control of its
privileges and special access rights.

Reporting errors
----------------

The only way a command can detect and recover from an error is to use
the information reported by the system calls and library routines that
encountered the error. A library routine, therefore, must report every
possible error case as informatively as possible to the calling program.
Where several different failure modes are possible, each should be
reported uniquely so that the calling program can take any necessary
corrective action or can restore system integrity before exiting. It is
not correct for a library routine to cause a process to exit as the
result of an error, since the calling program may need to clean up
before exiting. The rule is: library routines must report all errors as
accurately as possible.

Handling sensitive data
-----------------------

Library routines sometimes need to retrieve sensitive data for a trusted
command. The designer of such routines must be aware of the risk that
this data might be accidentally disclosed in a core file or some other
unprotected data object. For a more detailed discussion of this problem
and its solutions, see the section on sensitive data in `\``Writing
trusted commands'' <GWTS_WritTrustedCmds.html>`__.

Executing commands
------------------

Whenever a library routine executes a shell level command it must take
great care to ensure that the command is executed correctly and with the
right parameters. For library routines that handle requests to execute a
command this requirement is limited to making sure the request is
followed exactly as issued. Library routines (like **system** or
**popen**) that execute commands independently of the specific request
must use full pathnames, and be certain that the commands they execute
are themselves trusted.

--------------


/Installing trusted commands and data
=====================================

As much care must be put into defining the privileges and access control
settings appropriate for a command as goes into writing the command and
designing its data. The discretionary access and privilege mechanisms
serve no purpose if these controls are not set appropriately on the
command and data files installed by a software package.

For example, if you simply assign all fixed privileges to a command on
installation, this effectively overrides all system controls for the
command. A malicious user could exploit this fact to gain access to
files and data unintended by the command's designers.

This section establishes principles upon which installation decisions
can be made.

--------------

/Assigning access controls
==========================

All trusted data must be protected from unauthorized changes. This
decision is based on the question \``does any non-administrator need to
use this information?'' not \``is this information too sensitive for
non-administrators to see?''

Discretionary access controls provide a finer access granularity. These
permissions should be assigned based on logical groupings of data
according to the needs of a set of commands and administrators. Since
the discretionary controls are the only protections available to the
base system, they should be assigned as though they were protecting a
system on which all files are public and writable unless restricted by
DAC.

The actual permissions placed on a given file depend entirely on the
needs of the commands that use the file. The group bits, however, should
be used instead of the owner bits to grant controlled access to files.
This methodology allows the designer to use set-uid *root* for
non-access related privilege and still take advantage of DAC controls on
a least privilege system.

--------------

/Assigning privileges and special permissions
=============================================

Privileges are assigned to executable files (commands) based on the
needs of the command and the knowledge that the command will not misuse
the privileges. These two factors are equally important: Even though a
programmer knows that a command will not abuse a particular privilege,
the command must need that privilege or it does not get it. Furthermore,
even though a command needs a privilege, it must be shown to use the
privilege properly or it does not get it.

After determining what privileges a command can have, the next step is
to determine whether the command needs privileges that are propagated
through **tfadmin**, or fixed privileges.

Using fixed privilege calls for extremely careful programming. A command
with fixed privilege must never use untrusted data for security-relevant
decision making. This means that a shell script can never have fixed
privilege, since the environment a shell script inherits is untrusted
and influences the shell's behavior (a command that uses the **system**
or **popen** library routines can never have fixed privilege for the
same reason). Other possible disqualifications are the following: 

-  commands that are controlled by user-supplied script files
-  commands that are controlled by data from standard input

Privileges acquired through **tfadmin** are more carefully controlled,
so they do not require the extensive limitations placed on fixed
privilege. Any privileged command, however, must uphold system policies
when it uses privilege and must obey both the spirit and the letter of
the rules of trust described in these guidelines.

Special access rights should be used in favor of privileges wherever
possible. A program that needs discretionary access to a well-defined
set of files should be **setgid** to the group to which those files
belong. The files should be as accessible as necessary to their group.
If, for example, a command needs to read a file *foo* and read and write
a file *bar* and the group of the files *foo* and *bar* is *sys*, the
command should be **setgid** to *sys*. The file *foo* should be readable
by group while the file *bar* should be both readable and writable by
group. The P_DACREAD and P_DACWRITE privileges should not be used for
this purpose, since they give too much access to the command.

--------------


/Summary
========

Trusting a command or library routine requires a solid understanding of
the risks encountered by the command or library, the policies of the
system, and the principles of trust. These guidelines offer a brief look
at the policies available with SCO OpenServer and a discussion of the
principles of trust. The risks encountered by a particular command or
library must be determined by the programmer attempting to make it
trusted.

While some of the rules presented here may seem overly exacting, or even
clumsy, the strenuousness of the rules is the price paid for a secure
system. Every rule and principle described in these guidelines
originates from some aspect of an observed attack on a computer system.
The programmer who ignores these rules does so, not at his or her own
risk, since the programmer is unlikely to be affected by the attack, but
at the risk of everyone who uses that programmer's software. The
responsibility of writing trusted software, therefore, must not be taken
lightly.

--------------
