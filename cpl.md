
# =ğŸš© The C Programming Language
- The C programming Language https://cs.nju.edu.cn/gchen/teaching/np/kernighan-ritchie/kandr.html
- ä¿æŒç®€å•----çºªå¿µä¸¹å°¼æ–¯â€¢é‡Œå¥‡ï¼ˆDennis Ritchieï¼‰ http://www.ruanyifeng.com/blog/2011/10/dennis_ritchie.html
- Kernighanã€ŠUNIX ä¼ å¥‡ï¼šå†å²ä¸å›å¿†ã€‹æ‚æ„Ÿ https://www.cnblogs.com/Solstice/p/unix_bwk.html
- Unixç‰ˆæƒå² https://www.ruanyifeng.com/blog/2010/03/unix_copyright_history.html
- Unix æ“ä½œç³»ç»Ÿæ¼”è¿›ç®€å² https://www.sohu.com/a/332185684_632967
- The Unix Tree https://www.tuhs.org/cgi-bin/utree.pl
- Dennis' Unix v6 https://minnie.tuhs.org/Archive/Distributions/Research/Dennis_v6/
- Computer Simulation and History http://simh.trailing-edge.com/
- The Evolution of the Unix Time-sharing System https://www.bell-labs.com/usr/dmr/www/hist.html
- MIT 6.828: Operating System Engineering https://pdos.csail.mit.edu/6.828/2018/schedule.html
- COS 333: Advanced Programming Techniques https://www.cs.princeton.edu/courses/archive/spring19/cos333/
- CS 144: Introduction to Computer Networking https://cs144.github.io/
- Life With Unix: A Guide for Everyone https://www.tuhs.org/Archive/Documentation/Books/Life_with_Unix_v2.pdf
- Distributed Systems with Node.js Thomas Hunter Ii https://book4you.org/book/8496883/e8268b
- Distributed systems: concepts and design Coulouris, George F https://book4you.org/book/5902087/d2300a
- é‡è¯» The C Programming Language https://zhuanlan.zhihu.com/p/379408556

C è¯­è¨€å¹¶ä¸æ˜¯ä¸€å¼€å§‹å°±åƒä»Šå¤©è¿™ä¹ˆç¹è£çš„ï¼Œä»ç¡¬ä»¶ç³»ç»Ÿåº•å±‚ï¼Œåˆ°é«˜çº§æ“ä½œç³»ç»Ÿå¼€å‘ï¼Œåˆ°å¤„éƒ½æœ‰å®ƒçš„å½±å­ã€‚

è‡ªä»åˆ›å»º C è¯­è¨€ï¼Œå®ƒçš„å‘å±•å¤§æ¦‚åˆ†ä¸ºäº§ç”Ÿå’Œç¹è£ä¸¤ä¸ªä¸»è¦å†å²æ—¶æœŸï¼š

- 1969-1970 å¹´ï¼ŒTompson åœ¨ BCPL è¯­è¨€ä¸Šåˆ›é€  B è¯­è¨€ã€‚
- 1971-1977 å¹´ï¼ŒRitchie æ”¹é€  B è¯­è¨€å¢åŠ æ•°æ®ç±»å‹åˆ›é€ äº† C è¯­è¨€ï¼Œä¼´éš Unix äº§ç”Ÿè€Œäº§ç”Ÿã€‚
- 1977-1979 å¹´ï¼ŒC è¯­è¨€ä¼´éš Unix ç§»æ¤æ€§éœ€æ±‚è€Œç¹è£å‘å±•ã€‚

Ken Thompson ä¸ Dennis M. Ritchie è¿™å¯¹å¥½åŸºå‹éƒ½æ˜¯å›¾çµå¥–è·å¾—è€…ã€‚

æ—¶é—´å›åˆ° 1970 å¹´ï¼Œæœ€åˆç”± Ken ä¸ªäººåœ¨ PDP-7 å°å‹æœºä¸Šå¼€å‘äº†ä¸€ä¸ªæ“ä½œç³»ç»Ÿå«åš Unicsï¼Œè™½è¯´æ˜¯å°å‹æœºï¼Œä½†ä¹Ÿéœ€è¦ä¸€æ•´ä¸ªæˆ¿é—´æ‰èƒ½æ”¾ä¸‹ã€‚åæ¥ Ken é‚€è¯· DMR åœ¨ PDP-11 æœºå™¨ä¸Šé‡å†™æ•´ä¸ªç³»ç»Ÿï¼Œå¹¶æ”¹åä¸º Unixï¼Œæ—©æœŸçš„ä»£ç è¿˜ä»¥ä»–ä»¬äºŒäººåå­—ä½œä¸ºä»£ç ç›®å½•åˆ†å¼€ç®¡ç†ï¼Œå¯ä»¥åœ¨ The Unix Tree ç«™ç‚¹ä¸ŠæŸ¥çœ‹ã€‚ä½¿ç”¨çš„è¯­è¨€æ˜¯ Dennis åœ¨ Basic Combined Programming Language(BCPL) åŸºç¡€ä¸Šï¼Œæ”¹è¿›çš„ä¸€ç§æ–°çš„é«˜çº§è¯­è¨€ã€‚è¿™ä¸ªè¯­è¨€å°† BCPL è¯­è¨€è¿›è¡Œäº†å‡çº§ï¼Œä¹Ÿå°±æ˜¯ç°åœ¨çš„ C è¯­è¨€ã€‚

Unix å’Œ C è¯ç”Ÿï¼Œå¹¶ä¸”å®Œç¾åœ°ç»“åˆæˆä¸ºä¸€ä¸ªç»Ÿä¸€ä½“ï¼ŒC ä¸ Unix å¾ˆå¿«æˆä¸ºä¸–ç•Œçš„ä¸»å¯¼ï¼Œè®¡ç®—æœºçš„å†å²å¤§å‘å±•æ‰å¼€å§‹ã€‚è€Œå®ƒä»¬ç•™ç»™åäººçš„æ ¸å¿ƒæ€æƒ³å°±æ˜¯ K.I.S.S - Keep It Simple & Stupid!

æ—¶é—´å€’å› Unix è¯ç”Ÿå‰ä¸¤å¹´ï¼Œ1968 å¹´ï¼Œåœ¨è´å°”å®éªŒå®¤è®¡ç®—æœºç ”ç©¶å°ç»„å·¥ä½œçš„ Ken å’Œä»–çš„åŒäº‹ä»¬ä¸º MULTICS (Multiplexed Information and Computing System) é¡¹ç›®åŸ‹å¤´è‹¦å¹²ã€‚MULTICS æ˜¯ä¸€ä¸ªè¶…å‰çš„è®¡ç®—æœºç¯å¢ƒï¼Œæ˜¯ä¸€ä¸ªå…¨é¢çš„ï¼Œé€šç”¨ç¼–ç¨‹ç³»ç»Ÿã€‚ä½œä¸ºä¸€ä¸ªç ”ç©¶é¡¹ç›®ï¼Œå®ƒèµ°é”™äº†è¿›åŒ–çš„å²”è·¯ï¼Œæä¾›çš„åŠŸèƒ½è¿‡äºå¤æ‚ï¼Œéœ€è¦å¤§é‡çš„è®¡ç®—èµ„æºã€‚ç”Ÿäº§ç‰ˆæœ¬å¤ªæ²‰é‡ï¼Œé€Ÿåº¦å¤ªæ…¢ï¼Œæœ€åˆçš„è®¾è®¡åœ¨å®æ–½è¿‡ç¨‹ä¸­ä¸å¾—ä¸ç¼©å‡ï¼Œæœ€ç»ˆè¢«è¿«å«åœï¼Œå¹¶é—´æ¥æˆä¸ºå…¨èº«éƒ½æ¸—é€ç€ç®€æ´ç†å¿µçš„ Unix çš„å‚¬åŒ–å‰‚ã€‚

è´å°”å®éªŒå®¤åœ¨ 1975 å¹´å‘å¸ƒ UNIX V6 ä¹‹åï¼Œäº 1979 å¹´åˆå‘å¸ƒäº† UNIX V7ã€‚åŠ å·å¤§å­¦ä¼¯å…‹åˆ©åˆ†æ ¡äº 1978 å¹´å‘å¸ƒäº†ä»¥ UNIX V6 ä¸ºåŸºç¡€çš„ BSD çš„é¦–ä¸ªç‰ˆæœ¬ã€‚åœ¨æ­¤ä¹‹åï¼ŒUNIX å’Œ BSD ä¸æ–­æœ‰æ–°ç‰ˆæœ¬æˆ–æ´¾ç”Ÿç‰ˆæœ¬å‡ºç°ã€‚ç„¶ååˆå‡ºç°äº†æ ‡å‡†åŒ–çš„åŠ¨å‘ï¼Œåˆ¶å®šäº† POSIX æ ‡å‡†ï¼Œæ„åœ¨ç»Ÿä¸€å„ä¸ªæ“ä½œç³»ç»Ÿæ‰€æä¾›çš„ APIï¼Œå› æ­¤ï¼Œå¤§å¤šæ•°æ–°æ“ä½œç³»ç»Ÿéƒ½å’Œ UNIX V6 æœ‰ç€åƒä¸ä¸‡ç¼•çš„è”ç³»ã€‚è‘—åçš„ Linux ä¹Ÿæ˜¯å°† POSIX æ ‡å‡†ä½œä¸ºå¼€å‘ç›®æ ‡çš„ï¼Œå…¼å®¹ Unix ç³»ç»Ÿï¼Œå¹¶å®ç°äº†æ¥æ›¿ Unix æˆä¸ºå½“ä¸‹ä¸»æµå¼€æºæ“ä½œç³»ç»Ÿã€‚

C è¯­è¨€çš„æˆåŠŸä¼´éš Unix æ“ä½œç³»ç»Ÿçš„ç››è¡Œï¼Œç„¶è€Œåœ¨ 20 ä¸–çºª 70 å¹´ä»£ï¼ŒAT&T å…¬å¸æ³¨æ„åˆ°ä¸‹å±çš„è´å°”å®éªŒå®¤çš„ Unix æ‰€å¸¦æ¥çš„å•†ä¸šä»·å€¼ï¼Œå¹¶ä½¿ç”¨ä¸€äº›æ‰‹æ®µæ¥ä¿æŠ¤ Unixï¼Œä¸ºäº†è§„é¿å„æ–­è€Œè‡ªä¸»ç¦å…¥è®¡ç®—æœºè½¯ä»¶é¢†åŸŸä¹Ÿè¦è¾¾åˆ°å•†ä¸šåŒ– Unix æºä»£ç çš„ç›®çš„ã€‚åœ¨ä¸“åˆ©ä¿æŠ¤çš„å½±å“ä¸‹ï¼ŒåŒ…æ‹¬ä¹‹å‰é€šè¿‡è®¸å¯è¯æ–¹å¼æ•™å­¦ä½¿ç”¨çš„ Unix æºç éƒ½å—åˆ°æå¤§çš„å½±å“ï¼Œä»è€Œé™åˆ¶äº† Unix çš„å‘å±•ã€‚åœ¨ 20 ä¸–çºª 80 å¹´ä»£ï¼ŒUnix å‘å±•å‡ºä¸¤ä¸ªæœ€ä¸»è¦çš„ç‰ˆæœ¬ï¼ŒåŸºäºå¤§å­¦æ•™å­¦ç›®çš„å¼€æº BSD UNIX å’ŒåŸºäºå•†ä¸šç›®çš„é—­æº AT&T Unixã€‚

Sun Microsystems å…¬å¸åŸºäº BSD UNIX å¼€å‘å‡º SunOS å³åæ¥ç°åœ¨çš„ Solaris å·¥ä½œç«™ã€‚AT&T çš„ Unix System V çš„ç¬¬ä¸€ç‰ˆæœ€ç»ˆä¹Ÿé€ å°±äº† IBM çš„ AIX å’Œ HP çš„ HP-UXã€‚

ç°åœ¨å»é’»ç ”ä¸ºå¤ä»£æœºå™¨å®ç°çš„ Unix æºç è¿˜ä¸å¦‚ç ”ç©¶ MIT 6.828 è¯¾ç¨‹ï¼ŒMIT åœ¨ x86 ä¸Šé‡æ–°å®ç°çš„ xv6ï¼Œä»£ç é‡çº¦ä¸€ä¸‡è¡Œï¼Œç®€åŒ–ä»¥çªå‡ºé‡ç‚¹ï¼Œå­¦ä¹ çš„æ€§ä»·æ¯”è¾ƒé«˜ã€‚

è¯¾ç¨‹ä¸­ä½¿ç”¨äº†ä¸¤ä¸ªç”¨äºæ•™å­¦çš„ Unix-like æ“ä½œç³»ç»Ÿï¼ŒXv6 å’Œ JOSï¼Œè€Œ JOS æ˜¯åœ¨ Xv6 çš„åŸºç¡€ä¸Šæ”¹å†™ï¼Œè®©æˆ‘ä»¬èƒ½åœ¨å…¶ä¸Šè¿›è¡Œå®éªŒçš„ OSï¼Œå¯ä»¥å°† JOS çœ‹ä½œ Unix çš„ç²¾ç®€æ•™å­¦ç‰ˆæœ¬ã€‚æ‰€ä»¥ï¼Œå¯ä»¥å°† Xv6 çœ‹ä½œæ˜¯æ›´å®Œæ•´çš„ç‰ˆæœ¬ï¼Œå…¶åå­—æ¥æºäº Lions' Commentary on UNIX' 6th Editionï¼Œä¹Ÿå¯ä»¥åœ¨è¯¾ç¨‹ç½‘ç«™ä¸Šä¸‹è½½ã€Šè±æ˜‚æ°UNIXæºä»£ç åˆ†æã€‹è¿™æœ¬ä¹¦çš„ç”µå­ç‰ˆã€‚

ä¸ºäº†ä½¿ç”¨ç²¾ç®€æŒ‡ä»¤é›†ç”¨äºæ•™å­¦ç›®çš„ï¼Œåœ¨ 2019 å¹´åçš„è¯¾ç¨‹å¼€å§‹ä½¿ç”¨æœ€æ–°çš„ RISC-V æ¶æ„ç‰ˆæœ¬ï¼Œå¦å¤–æ—©å‰çš„ x86 æ¶æ„ç‰ˆæœ¬ä¹Ÿå¯ä»¥åœ¨ mit-pdos ä»“åº“ä¸Šæ‰¾åˆ°ã€‚

ANSI C å’Œ ISO C æ ‡å‡†åŒ–

åœ¨ C è¯­è¨€é«˜é€Ÿå‘å±•æ—¶æœŸï¼Œä»å¤§å‹ä¸»æœºåˆ°å°å‹å¾®æœºï¼Œè¡ç”Ÿäº† C è¯­è¨€çš„å¾ˆå¤šä¸åŒç‰ˆæœ¬ã€‚

ä¸ºç»Ÿä¸€ C è¯­è¨€ç‰ˆæœ¬ï¼Œ1983 å¹´ç¾å›½å›½å®¶æ ‡å‡†å±€ ANSI - American National Standards Institute æˆç«‹äº†ä¸€ä¸ªå§”å‘˜ä¼šï¼Œæ¥åˆ¶å®š C è¯­è¨€æ ‡å‡†ã€‚1989 å¹´ C è¯­è¨€æ ‡å‡†è¢«æ‰¹å‡†ï¼Œè¢«ç§°ä¸º ANSI X3.159-1989 Programming Language Cã€‚ç¬¬ä¸€ä¸ªç‰ˆæœ¬çš„ C è¯­è¨€æ ‡å‡†é€šå¸¸è¢«ç§°ä¸º ANSI Cã€‚åˆç”±äºè¿™ä¸ªç‰ˆæœ¬æ˜¯ 89 å¹´å®Œæˆåˆ¶å®šçš„ï¼Œå› æ­¤ä¹Ÿè¢«ç§°ä¸º C89ã€‚

åæ¥ ANSI æŠŠè¿™ä¸ªæ ‡å‡†æäº¤åˆ° ISO å›½é™…åŒ–æ ‡å‡†ç»„ç»‡ï¼Œ1990 å¹´è¢« ISO é‡‡çº³ä¸ºå›½é™…æ ‡å‡†ï¼Œç§°ä¸º ISO Cã€‚åˆå› ä¸ºè¿™ä¸ªç‰ˆæœ¬æ˜¯ 1990 å¹´å‘å¸ƒçš„ï¼Œå› æ­¤ä¹Ÿè¢«ç§°ä¸º C90ã€‚

ANSI C(C89) ä¸ ISO C(C90)å†…å®¹åŸºæœ¬ç›¸åŒï¼Œä¸»è¦æ˜¯æ ¼å¼ç»„ç»‡ä¸ä¸€æ ·ã€‚çœ‹åˆ° ANSI Cã€ISO Cã€C89ã€C90ï¼Œè¦çŸ¥é“è¿™äº›æ ‡å‡†çš„å†…å®¹éƒ½æ˜¯ä¸€æ ·çš„ã€‚

2011å¹´12æœˆ8æ—¥ï¼ŒISO åˆæ­£å¼å‘å¸ƒäº†æ–°çš„æ ‡å‡†ï¼Œç§°ä¸º ISO/IEC9899: 2011ï¼Œç®€ç§°ä¸º C11ã€‚

ç›®å‰ï¼Œå‡ ä¹æ‰€æœ‰çš„å¼€å‘å·¥å…·éƒ½æ”¯æŒ ANSI/ISO C æ ‡å‡†ï¼Œæ˜¯ C è¯­è¨€ç”¨å¾—æœ€å¹¿æ³›çš„ä¸€ä¸ªæ ‡å‡†ç‰ˆæœ¬ã€‚

åœ¨ ANSI C æ ‡å‡†ç¡®ç«‹ä¹‹åï¼ŒC è¯­è¨€çš„è§„èŒƒåœ¨å¾ˆé•¿ä¸€æ®µæ—¶é—´å†…éƒ½æ²¡æœ‰å¤§çš„å˜åŠ¨ã€‚1995 å¹´ C ç¨‹åºè®¾è®¡è¯­è¨€å·¥ä½œç»„å¯¹ C è¯­è¨€è¿›è¡Œäº†ä¸€äº›ä¿®æ”¹ï¼Œæˆä¸ºåæ¥çš„ 1999 å¹´å‘å¸ƒçš„ ISO/IEC 9899:1999 æ ‡å‡†ï¼Œé€šå¸¸è¢«æˆä¸º C99ã€‚

ä½†æ˜¯å•†ä¸šå…¬å¸å¯¹ C99 çš„æ”¯æŒæ‰€è¡¨ç°å‡ºæ¥çš„å…´è¶£ä¸åŒï¼ŒGCC å’Œå…¶å®ƒä¸€äº›å•†ä¸šç¼–è¯‘å™¨æ”¯æŒ C99 çš„å¤§éƒ¨åˆ†ç‰¹æ€§çš„æ™‚å€™ï¼Œå¾®è½¯å’Œ Borland å´æ²¡æœ‰ä»€ä¹ˆåŠ¨ä½œã€‚

GCC - GNU Compiler Collection ç¼–è¯‘å™¨å¥—ä»¶ä½œä¸º GNU å·¥ç¨‹å¼€å‘çš„æ”¯æŒå¤šç§ç¼–ç¨‹è¯­è¨€çš„ç¼–è¯‘å™¨ï¼Œåœ¨ C è¨€è¯­æ ‡å‡†çš„æ”¯æŒä¸Šä¸€ç›´èµ°åœ¨å‰é¢ã€‚

ä¾‹å¦‚ï¼ŒGCC 9.3.0 æ”¯æŒä»¥ä¸‹æ ‡å‡†ï¼Œä½¿ç”¨ `gcc -v --help` å¯ä»¥æŸ¥è¯¢å½“å‰ç‰ˆæœ¬æ”¯æŒçš„æ ‡å‡†ï¼š

|       Standard      | 9.3 | 8.1 | 5.3 |                     Note                     |
|---------------------|-----|-----|-----|----------------------------------------------|
| -std=c11            | âœ… | âœ…  | âœ… | âœ“ ISO 2011 C                                 |
| -std=c17            | âœ… | âœ…  | âŒ | âœ“ ISO 2017 C (2018)                          |
| -std=c18            | âœ… | âœ…  | âŒ | âœ“ ISO 2017 C (2018)ï¼ŒåŒ `-std=c17`           |
| -std=c1x            | âœ… | âœ…  | âœ… | âœ— å¼ƒç”¨ï¼Œ`-std=c11` æ›¿ä»£ï¼ŒåŒ `-std=c11`       |
| -std=c2x            | âœ… | âŒ  | âŒ | âœ“ ISO 202X C æ ‡å‡†è‰æ¡ˆ [ä½“éªŒ]                 |
| -std=c89            | âœ… | âœ…  | âœ… | âœ“ ISO 1990 C æ ‡å‡†ï¼ŒåŒ `-std=c90`             |
| -std=c90            | âœ… | âœ…  | âœ… | âœ“ ISO 1990 C                                 |
| -std=c99            | âœ… | âœ…  | âœ… | âœ“ ISO 1999 C                                 |
| -std=c9x            | âœ… | âœ…  | âœ… | âœ— å¼ƒç”¨ï¼Œ`-std=c99` æ›¿ä»£ï¼ŒåŒ `-std=c99`       |
| -std=iso9899:1990   | âœ… | âœ…  | âœ… | âœ“ ISO 1990 C æ ‡å‡†ï¼ŒåŒ std=c90                |
| -std=iso9899:199409 | âœ… | âœ…  | âœ… | âœ“ ISO 1990 C as amended in 1994              |
| -std=iso9899:1999   | âœ… | âœ…  | âœ… | âœ“ ISO 1999 C æ ‡å‡†ï¼ŒåŒ std=c99                |
| -std=iso9899:199x   | âœ… | âœ…  | âœ… | âœ— å¼ƒç”¨ï¼Œ`-std=iso9899:1999` æ›¿ä»£ï¼ŒåŒ std=c99 |
| -std=iso9899:2011   | âœ… | âœ…  | âœ… | âœ“ ISO 2011 C æ ‡å‡†ï¼ŒåŒ std=c11                |
| -std=iso9899:2017   | âœ… | âœ…  | âŒ | âœ“ ISO 2017 C (2018)ï¼ŒåŒ `-std=c17`           |
| -std=iso9899:2018   | âœ… | âœ…  | âŒ | âœ“ ISO 2017 C (2018)ï¼ŒåŒ `-std=c17`           |

1983å¹´ï¼Œè´å°”å®éªŒå®¤çš„ Bjarne Stroustrup åœ¨ C è¯­è¨€åŸºç¡€ä¸Šæ¨å‡ºäº† C++ï¼Œè¿›ä¸€æ­¥æ‰©å……å’Œå®Œå–„äº† C è¯­è¨€ï¼Œæ˜¯ä¸€ç§é¢å‘å¯¹è±¡çš„ç¨‹åºè®¾è®¡è¯­è¨€ï¼Œä½†æ˜¯è¿™ç§æ‰©å……ä¹Ÿä½¿å¾— C++ æˆä¸ºå†å²ä¸Šæœ€æœ€æœ€éš¾æçš„è¯­è¨€ã€‚

C++ ç¨‹åºè¿‡äºå¤æ‚å’Œåºå¤§ï¼Œå¹¶ä¸”æ¶ˆè´¹ç”µå­äº§å“æ‰€é‡‡ç”¨çš„åµŒå…¥å¼å¤„ç†å™¨èŠ¯ç‰‡çš„ç§ç±»ç¹æ‚ï¼Œå¦‚ä½•è®©ç¼–å†™çš„ç¨‹åºè·¨å¹³å°è¿è¡Œä¹Ÿæ˜¯ä¸ªéš¾é¢˜ã€‚ä¸ºäº†è§£å†³å›°éš¾ï¼ŒSun å…¬å¸ç ”å‘äººå‘˜å¹¶æ²¡æœ‰å¼€å‘ä¸€ç§å…¨æ–°çš„è¯­è¨€ï¼Œè€Œæ˜¯æ ¹æ®åµŒå…¥å¼è½¯ä»¶çš„è¦æ±‚ï¼Œå¯¹ C++ è¿›è¡Œäº†æ”¹é€ ï¼Œå»é™¤äº†ç•™åœ¨ C++ çš„ä¸€äº›ä¸å¤ªå®ç”¨åŠå½±å“å®‰å…¨çš„æˆåˆ†ï¼Œå¹¶ç»“åˆåµŒå…¥å¼ç³»ç»Ÿçš„å®æ—¶æ€§è¦æ±‚ï¼Œå¼€å‘äº†ä¸€ç§ç§°ä¸º Oak çš„é¢å‘å¯¹è±¡è¯­è¨€ï¼Œåæ¥å‘å±•æˆä¸º Java è¯­è¨€ï¼Œä½œè€…æ˜¯ James Goslingã€‚

ä¸€èˆ¬è€Œè¨€ï¼ŒCï¼ŒC++ï¼ŒJava è¢«è§†ä¸ºåŒä¸€ç³»çš„è¯­è¨€ï¼Œå®ƒä»¬é•¿æœŸå æ®ç€ç¨‹åºä½¿ç”¨æ¦œçš„å‰ä¸‰åã€‚

è®¡ç®—æœºç¨‹åºæ˜¯ä¸ªå¤§ä¸–ç•Œï¼Œå„ç§è¯­è¨€åªæ˜¯ä¸€ä¸ªäº¤æµå·¥å…·ï¼Œæ‰€ä»¥ï¼Œä¸åŒè¯­è¨€å¿…ç„¶å­˜åœ¨æ²Ÿé€šäº¤æµçš„ç°è±¡ã€‚ä¸ç®¡ç†æ˜¯ä»è¯­è¨€èƒ½åŠ›ä¸Šçš„å€Ÿé‰´ã€è¿˜æ˜¯ä»£ç å±‚é¢ä¸Šçš„ç›¸äº’é€šä¿¡éƒ½æ˜¯å¸¸è§ç°è±¡ï¼Œä¾‹å¦‚ï¼Œåœ¨ C è¯­è¨€ä»£ç ä¸­åµŒå…¥æ›´åº•å±‚çš„æ±‡ç¼–æŒ‡ä»¤ï¼Œå°±å¯ä»¥åšä¸€äº›é«˜çº§è¯­è¨€ä¸Šä¸æ–¹ä¾¿æ“ä½œçš„èƒ½åŠ›ï¼Œå¦‚è®¾å¤‡é©±åŠ¨çš„å¼€å‘ã€å…³é”®ä»£ç çš„ä¼˜åŒ–ã€‚å†è€…ï¼Œä¸åŒè¯­è¨€çš„å‘å±•è¿‡ç¨‹ä¸­ï¼Œå‡ºç°æŸäº›ç‰¹åˆ«å¥½ç”¨çš„æ¨¡å—ï¼Œéœ€è¦åœ¨å¦ä¸€ç§è¯­è¨€ä¸Šé¢å€Ÿç”¨ï¼Œå°±éœ€è¦é€šè¿‡ ABI - Application Binary Interface è¿›è¡Œè°ƒç”¨ã€‚æ¯”å¦‚ï¼Œä¸åŒè¯­è¨€ç¼–è¯‘å‡ºæ¥çš„åŠ¨æ€é“¾æ¥åº“ï¼Œç”±å…¶å®ƒè¯­è¨€è¿›è¡Œå…±äº«ä½¿ç”¨ï¼Œè¿™å°±æ˜¯æœ€å¸¸è§çš„ ABI ä½¿ç”¨åœºæ™¯ã€‚è€Œæ¨¡å—åŒ–æ˜¯æ‰€æœ‰ç¼–ç¨‹è¯­è¨€çš„æœ€åŸºæœ¬çš„ä»£ç ç»„ç»‡å½¢å¼ï¼Œè¿™äº›æ¨¡å—æš´éœ²å‡ºæ¥çš„ä¾›ç”¨æˆ·ä½¿ç”¨çš„æ¥å£å°±å« API - Application Programming Interfaceã€‚ABI å’Œ API æ˜¯ä¸¤ä¸ªæœ€åŸºç¡€çš„ç¼–ç¨‹æ¦‚å¿µï¼Œä½†ç¼–ç¨‹è¯­è¨€æ•™ææœªå¿…ä¼šè®²ã€‚

åœ¨è°ˆè®ºæ ‡å‡†æ—¶ï¼Œæ›´å¤šæ˜¯åŸºäºæ“ä½œç³»ç»ŸåŠè®¡ç®—æœºç»“æ„æœ¬èº«æ¥åˆ¶å®šçš„ï¼Œåœ¨æ“ä½œç³»ç»Ÿæœ‰æ ‡å‡†ä¹‹å‰ï¼Œæ€ä¹ˆå®ç°æ˜¯å„ä¸ªç³»ç»Ÿè‡ªå·±çš„äº‹ã€‚å½“æœ‰äº†æ ‡å‡†ä¹‹åï¼Œä¸åŒç³»ç»Ÿéµå¾ªåŒæ ·çš„è§„èŒƒï¼Œåˆ™æ›´èƒ½å½¢æˆä¸€ä¸ªå¤§çš„ç”Ÿæ€ç¯å¢ƒï¼ŒPOSIX - Portable Operating System Interface of UNIX ä½œä¸ºæœ€æˆåŠŸçš„ç§»æ¤æ“ä½œç³»ç»Ÿæ¥å£è§„èŒƒï¼Œä¾èµ–è¿™ä¸ªæ¥å£æ ‡å‡†å¼€å‘å‡ºæ¥çš„ç¨‹åºå°±å…·æœ‰éå¸¸é«˜çš„ç§»æ¤ç‰¹æ€§ï¼Œåœ¨ Unix/Linux ç³»ç»ŸåŸºæœ¬å¯ä»¥é€šè¡Œã€‚

ä»è®¡ç®—æœºç»“æ„ä¸Šè®²ï¼Œç¨‹åºçš„æ ‡å‡†åŒ–åˆ™æ›´å¤šæ˜¯ç¡¬ä»¶ç»“æ„çš„æ ‡å‡†ï¼Œæœ€ç›´æ¥çš„ä½“ç°å°±æ˜¯åœ¨è¾“å…¥è¾“å…¥ä¸Šï¼Œå‡ ä¹æ‰€æœ‰è½¯ä»¶éƒ½éœ€è¦è¾“å…¥ã€è¾“å‡ºï¼Œæ‰€ä»¥ä¸ºç¨‹åºè®¾è®¡åŸºæœ¬çš„ I/O æ¡†æ¶çš„å°±æ˜¯äº‹å®çš„æ ‡å‡†ã€‚è‡³äºï¼Œæ˜¯ä»é¼ æ ‡è¿˜æ˜¯é”®ç›˜è¾“å…¥ï¼Œè¾“å‡ºåˆ°å±å¹•è¿˜æ–‡ä»¶ï¼Œåˆæˆ–è€…è¾“å‡ºåˆ°æ§åˆ¶å°ï¼Œè¿™éƒ½æ˜¯æ ‡å‡†ä¹‹ä¸‹çš„ä¸åŒé€‰æ‹©ã€‚

å¦å¤–ä¸€ä¸ªå¾ˆæœ‰æ„ä¹‰çš„äº‹ï¼Œå°±æ˜¯äº†è§£æ ‡å‡†çš„åº“çš„æ¶æ„æ€æƒ³ï¼Œä»»ä½•ä¸€é—¨è¯­è¨€éƒ½ä¸å¯èƒ½è„±ç¦»åŸºç¡€åº“çš„æ”¯æŒï¼Œä¹Ÿæ²¡æœ‰ä»»ä½•ä¸€ä¸ªäººå¯ä»¥ä»é›¶æ¶æ„èµ·å®Œæ•´çš„ç¼–ç¨‹è¯­è¨€ç”Ÿæ€ã€‚åŸºç¡€åº“æ˜¯é›†ä½“ä¼—äººçš„åŠ›é‡é›†æˆçš„è€Œæˆï¼Œå…·æœ‰æœ€æœ€åŸºç¡€çš„æ”¯æ’‘éƒ¨åˆ†ï¼ŒåŸºäºè¿™äº›åŸºç¡€å¼€å‘åº”ç”¨ç¨‹åºã€‚å¿…éœ€è¦ç†è§£ï¼Œä¸åŒè¯­è¨€ä¸ºä½•ä¼šæä¾›åƒå·®ä¸‡åˆ«çš„åŸºç¡€åº“ï¼Œè¿™å°±éœ€è¦ä»è¯­è¨€å·¥å…·è¿™ä¸ªè§’åº¦æ¥ç†è§£ã€‚æ¯ä¸€é—¨è¯­è¨€éƒ½æœ‰å®ƒçš„ç‰¹é•¿ï¼Œé€‚åˆå¹²ä»€ä¹ˆäº‹é…ç½®ç›¸åº”çš„åˆ©å™¨ï¼Œè¿™æ˜¯å¾ˆåˆç†çš„ã€‚å¦‚ä½•ä¸€é—¨ç”¨äºå¼€å‘ç½‘ç»œåº”ç”¨çš„è¨€è¯­ï¼Œå¦‚ Golangï¼Œå¦‚æœç»™å®ƒé…ç½®ä¸€äº›ç¡¬ä»¶åº•å±‚å¼€å§‹éœ€è¦ç”¨åˆ°çš„åŸºç¡€åº“ï¼Œè¿™æ˜¾ç¤ºä¸æ˜¯é‚£ä¹ˆçš„åˆé€‚ã€‚

æ¯ä¸€é—¨è¯­è¨€æ‰€è¡ç”Ÿå‡ºæ¥çš„åº“ï¼Œå…¶é‡è¦æ€§å¾€å¾€ä¼šè¿œè¿œè¶…è¿‡è¯¥è¯­è¨€æœ¬èº«ï¼Œæ·±å…¥ç†è§£é‚£äº›å¯ä»¥æé«˜ç”Ÿäº§æ•ˆç‡çš„åº“ï¼Œå¾€å¾€ä¹Ÿæ˜¯åˆ¤æ–­æŒæ¡ä¸€é—¨è¯­è¨€çš„é‡è¦ä¾æ®ï¼Œè¿™å¾€å¾€æ¯”å­¦ä¹ è¯­è¨€æœ¬èº«æ›´å…·æœ‰æŒ‘æˆ˜æ€§ã€‚

æ˜¯å¦èƒ½å¯¹ç°æœ‰åº“è¿›è¡ŒäºŒæ¬¡æ”¹é€ å°±æ˜¯å¯¹ä¸€é—¨è¯­è¨€å­¦ä¹ çš„æœ€é«˜è¯„åˆ¤æ ‡å‡†ï¼

C è¯­è¨€çš„æˆåŠŸå’Œæ•™è®­ï¼š

- æˆåŠŸï¼š
    - C åŸºç¡€ä¸Šæ‰©å±•äº§ç”Ÿäº† Objective Cï¼ŒC++
- äº‰è®®ï¼š
    - æ•°ç»„å’ŒæŒ‡é’ˆçš„å…³ç³»ï¼šå°½ç®¡å› ä¸ºå†å²å¶ç„¶æ€§ï¼Œå¯¼è‡´å¾ˆå¤šè¢«åˆå­¦è€…éš¾äºç†è§£
    - å¯¹ç±»å‹é”™è¯¯çš„å®¹å¿ï¼šå°¤å…¶ç±»å‹ä¹‹é—´çš„è½¬æ¢ï¼Œå¦‚æ•´æ•°å’ŒæŒ‡é’ˆç±»å‹ç›¸äº’èµ‹å€¼
    - * è¿ç®—ç¬¦å¯¼è‡´åœ¨å¤æ‚åœºæ™¯ä¸‹ï¼Œéœ€è¦æ‹¬å·æ‰èƒ½è¢«æ­£ç¡®ç†è§£ï¼Œå¦‚ int * fp(), int (* fp)()
    - æŠŠæ•°ç»„å½“æˆæŒ‡é’ˆä¸åˆ©äºç¼–è¯‘å™¨çš„ä¼˜åŒ–ï¼Œå¦‚æœ‰æŒ‡é’ˆå‚æ•°çš„å‡½æ•°ï¼Œæ­¤æŒ‡é’ˆæ¥æºäºæ•°ç»„ï¼Œä½†æ˜¯ç¼–è¯‘å™¨å¾ˆéš¾å¯¹å…¶ä¼˜åŒ–ã€‚
    - éœ€è¦æ‰‹å·¥ç®¡ç†å†…å­˜ï¼Œå¹¶ä¸”å¯¹è‡ªåŠ¨ç®¡ç†å†…å­˜æœºåˆ¶ä¸å‹å¥½ã€‚

The C Programming Language ä¸€ä¹¦ä½œä¸ºæœ€ç»å…¸çš„æ•™æï¼Œä½œè€…ç”¨ç®€æ´çš„è¯­è¨€é˜è¿°äº†ç®€æ´çš„ C è¯­è¨€ï¼Œå¯è°“è¨€ç®€æ„èµ…ã€‚

å¹¶ä¸”ï¼ŒC è¯­è¨€å¼ºå¤§çš„åº•å±‚èƒ½åŠ›è®©å®ƒå¯ä»¥ä¸æ±‡ç¼–æŒ‡ä»¤ä¸€èµ·å·¥ä½œï¼Œä¹Ÿå¯ä»¥ä¸ºå…¶å®ƒé«˜çº§è¯­è¨€æä¾› ABI - Application Binary Interface æ¥å£ï¼Œå³é€šè¿‡ç¼–è¯‘ C è¯­è¨€çš„äºŒè¿›åˆ¶ç¨‹åºä¾›åº”å…¶å®ƒè¯­è¨€ä½¿ç”¨ï¼Œå¦‚ Javaã€Golangã€Rustï¼Œç”šè‡³æ˜¯è„šæœ¬è¯­è¨€å¦‚ PHPï¼Œç°åœ¨è¿ JavaScript ä¹Ÿå¯ä»¥é€šè¿‡ WebAssembly ä½¿ç”¨ C è¯­è¨€ã€‚

ä½†æ˜¯ä½œä¸ºæ²¡æœ‰è®¡ç®—æœºç¼–ç¨‹ç»éªŒçš„äººæ¥è¯´ï¼Œåªé è¿™ä¸€æœ¬ç»å…¸æ•™ææ˜¯ä¸è¶³å®Œå…¨ç²¾é€šè¿™é—¨æ¶‰åŠå„ä¸ªé¢†åŸŸçš„æ ¸å¿ƒæè¯­è¨€çš„ï¼Œå› ä¸ºç¼ºå°‘å¤–æ²¿ï¼Œä½†æ˜¯å¯¹äºä¸€ä¸ªç»éªŒä¸°å¯Œçš„å¼€å‘è€…ï¼Œå¯¹ç¼–ç¨‹ç¯å¢ƒäº†è§£é€å½»ï¼Œé‚£ä¹ˆ The C Programming Language è¿™æœ¬ä¸åˆ° 300 é¡µè¿˜åŒ…å«äº†æ ‡å‡†åº“å‚è€ƒçš„å°å†Œå­å°±æˆä¸ºäº†ç»å…¸ï¼Œå› ä¸ºæ²¡æœ‰ç´¯èµ˜çš„è¨€è¯­ã€‚

å¦å¤–ï¼Œæ•™æä¸­å¤šå¤„ä½¿ç”¨å„ç§ç®—æ³•æ¥è§£æ C è¯­è¨€çš„ä½¿ç”¨ï¼Œè¿™ç›¸å½“äºç”»é¾™ç‚¹ç›ï¼Œé€šå¸¸è¿™äº›å†…å®¹æ˜¯æ•°æ®ç»“æ„ä¸ç®—æ³•è¯¾ç¨‹ä¸Šçš„å†…å®¹ã€‚

å¦‚æœç”¨ä¸€å‰¯æˆ˜ç•¥åœ°å›¾æ¥è¡¨ç¤ºå„ç§è¯­è¨€çš„è”ç³»ï¼Œé‚£ä¹ˆ C è¯­è¨€å°±æ˜¯æœ€æ ¸å¿ƒè¦å¡ï¼Œå››é€šå…«è¾¾ï¼Œæ˜¯å…µå®¶å¿…äº‰ä¹‹åœ°ã€‚

The C Programming Language æ•™æä¸¤ä½ä½œè€…éƒ½æ˜¯è´å°”å®éªŒå®¤çš„ç ”ç©¶å‘˜ã€‚

Brian W. Kernighan

è´å°”å®éªŒå®¤è®¡ç®—ç§‘å­¦ç ”ç©¶ä¸­å¿ƒé«˜çº§ç ”ç©¶äººå‘˜ï¼Œè‘—åçš„è®¡ç®—æœºç§‘å­¦å®¶ã€‚ä»–å‚åŠ äº† UNIX ç³»ç»Ÿã€C è¯­è¨€ã€AWK è¯­è¨€å’Œè®¸å¤šå…¶ä»–ç³»ç»Ÿçš„å¼€å‘ï¼ŒåŒæ—¶å‡ºç‰ˆäº†è®¸å¤šåœ¨è®¡ç®—æœºé¢†åŸŸå…·æœ‰å½±å“çš„è‘—ä½œï¼ŒThe Elements of Programming Style, The Practice of Programming, The UNIX Programming Environment, The AWK Language, Software Toolsã€‚

Dennis M. Ritchie

ä½œä¸º C è¯­è¨€çš„å¼€å‘è€…ï¼ŒDennis M. Ritchie 1967 å¹´åŠ å…¥è´å°”å®éªŒå®¤ï¼Œä»–å’Œ Ken L. Thompson ä¸¤äººå…±åŒè®¾è®¡å¹¶å®ç°çš„ C è¯­è¨€æ”¹å˜äº†ç¨‹åºè®¾è®¡è¯­è¨€å‘å±•çš„è½¨è¿¹ï¼Œæ˜¯ç¨‹åºè®¾è®¡è¯­è¨€å‘å±•è¿‡ç¨‹ä¸­çš„ä¸€ä¸ªé‡è¦é‡Œç¨‹ç¢‘ã€‚ä¸æ­¤åŒæ—¶ï¼Œä»–ä»¬ä¸¤äººè¿˜è®¾è®¡å¹¶å®ç°äº† UNIX æ“ä½œç³»ç»Ÿã€‚æ­£æ˜¯ç”±äºè¿™ä¸¤é¡¹å·¨å¤§è´¡çŒ®ï¼ŒDennis M. Ritchie äº 1983 å¹´è·å¾—äº†è®¡ç®—æœºç•Œçš„æœ€é«˜å¥–â€”â€”å›¾çµå¥–ã€‚æ­¤å¤–ï¼Œä»–è¿˜è·å¾—äº† ACMã€IEEEã€è´å°”å®éªŒå®¤ç­‰æˆäºˆçš„å¤šç§å¥–é¡¹ã€‚

![Dennis M. Ritchie (1941/9/9 - 2011/10/12)](https://pic1.zhimg.com/80/v2-8c9522dfdb51dd5854ab37b538b057e4_1440w.jpg)

C è¯­è¨€ä¹Ÿè´¯å½»äº†"ä¿æŒç®€å•"çš„åŸåˆ™ï¼Œè¯­æ³•éå¸¸ç®€æ´ï¼Œå¯¹ä½¿ç”¨è€…çš„é™åˆ¶å¾ˆå°‘ã€‚ä¸¹å°¼æ–¯â€¢é‡Œå¥‡ç¼–å†™çš„æ•™æã€ŠCç¼–ç¨‹è¯­è¨€ã€‹æ€»å…±åªæœ‰200å¤šé¡µï¼Œè–„å¾—éš¾ä»¥ç½®ä¿¡ã€‚å¾ˆå¤šäººéƒ½è¢«å®ƒçš„ç®€æ´æ€§å¸å¼•ï¼Œå­¦ä¹ å¹¶ä½¿ç”¨Cè¯­è¨€ã€‚ç›´åˆ°ä»Šå¤©ï¼ŒCè¯­è¨€ä¾ç„¶æ˜¯ä¸–ç•Œä¸Šæœ€é‡è¦çš„ç¼–ç¨‹è¯­è¨€ä¹‹ä¸€ï¼Œ"ä¿æŒç®€å•"åŸåˆ™æ˜¾ç¤ºäº†å¼ºå¤§çš„ç”Ÿå‘½åŠ›ã€‚

å‘æ˜ Unix å’Œ C è¯­è¨€ï¼Œç»™ä¸¹å°¼æ–¯â€¢é‡Œå¥‡å¸¦æ¥å·¨å¤§çš„è£èª‰ï¼Œä»–å¾—åˆ°äº†1983å¹´çš„å›¾çµå¥–ã€1990å¹´çš„æ±‰æ˜å¥–ã€1999å¹´çš„ç¾å›½å›½å®¶æŠ€æœ¯å¥–ç« ã€‚å°½ç®¡åŠŸæˆåå°±ï¼Œä½†æ˜¯å°±åƒä»–çš„å·¥ç¨‹è®¾è®¡æ€æƒ³ï¼Œä¸¹å°¼æ–¯â€¢é‡Œå¥‡åœ¨ä¸ªäººç”Ÿæ´»ä¸Šä¹Ÿå°½é‡"ä¿æŒç®€å•"ã€‚ä»–ä¾ç„¶ä½åœ¨æ–°æ³½è¥¿ï¼Œä½è°ƒåœ°ç”Ÿæ´»ï¼Œä¸å¤ªåœ¨åª’ä½“ä¸Šæ›å…‰ï¼Œç»ˆèº«æ²¡æœ‰ç»“å©šã€‚

ä»–ä¸€ç›´åœ¨è´å°”å®éªŒå®¤å·¥ä½œï¼Œ2001å¹´ï¼Œå¤šæ¬¡åˆ†æ‹†åçš„è´å°”å®éªŒå®¤è½¬ç§»åˆ°æœ—è®¯å…¬å¸åä¸‹ï¼Œ2006å¹´12æœˆ1æ—¥ï¼Œè´å°”å®éªŒå®¤è¢«æ•´ä½“å–ç»™äº†æ³•å›½é˜¿å°”å¡ç‰¹å…¬å¸ï¼Œç¬¬äºŒå¹´ä»–å°±é€‰æ‹©é€€ä¼‘äº†ã€‚

é€€ä¼‘ä»¥åï¼Œä»–è¿‡ä¸Šäº†éšå±…ç”Ÿæ´»ï¼Œå¤–ç•Œå‡ ä¹å¿˜äº†ä»–çš„å­˜åœ¨ã€‚2011å¹´10æœˆ12æ—¥ï¼Œå…±äº‹20å¹´çš„åŒäº‹Rob Pikeä»åŠ å·åˆ°æ–°æ³½è¥¿å»æ‹œè®¿ä»–ï¼Œæ‰å‘ç°ä»–å·²ç»å»ä¸–äº†ã€‚ç”±äºæ˜¯ç‹¬å±…ï¼Œæ— æ³•çŸ¥é“å‡†ç¡®çš„æ­»äº¡æ—¶é—´ã€‚æ®ä»–çš„å…„å¼Ÿé€éœ²ï¼Œè¿™å‡ å¹´ä¸¹å°¼æ–¯â€¢é‡Œå¥‡çš„å¥åº·çŠ¶å†µä¸€ç›´ä¸å¥½ï¼Œä»–æ‚£æœ‰å‰åˆ—è…ºç™Œå’Œå¿ƒè„ç—…ã€‚

Rob Pike åœ¨ Google Plus å‘äº†ä¸€æ¡ç®€çŸ­çš„æ¶ˆæ¯ï¼Œ"æ®æˆ‘æ‰€çŸ¥ï¼ŒUnix å’Œ C è¯­è¨€å‘æ˜äººä¸¹å°¼æ–¯â€¢é‡Œå¥‡å·²ç»å»ä¸–"ã€‚


## ==âš¡ ch1 - A Tutorial Introduction
- Code::Blocks The free C/C++ and Fortran IDE. https://www.codeblocks.org
- C99 - ISO/IEC 9899:1999 Programming languages â€” C https://book4you.org/book/931317/08fbbd
- C11 â€“ ISO/IEC 9899:2011 https://book4you.org/book/2646095/b0aa1e
- C++å¼ºå¤§èƒŒå https://www.cnblogs.com/miloyip/archive/2010/09/17/behind_cplusplus.html
- Object-Oriented Programming With ANSI-C https://www.cs.rit.edu/~ats/books/ooc.pdf
- Object Oriented Programming in C http://ldeniau.home.cern.ch/ldeniau/html/oopc/oopc.html


ç¬¬ä¸€ä¸ªç¨‹åº helloworld.c æ§åˆ¶å°ç¨‹åºï¼Œä½¿ç”¨ printf å‡½æ•°è¾“å‡ºå­—ç¬¦ä¸²åˆ°æ§åˆ¶å°ï¼š

è¦ç‚¹ï¼š

- å¼•ç”¨æ ‡å‡†åº“å‡½æ•°ï¼Œä½¿ç”¨å°–æ‹¬å·ï¼Œéæ ‡å‡†å¤´æ–‡ä»¶ä½¿ç”¨åŒå¼•å·ï¼›
- å®šä¹‰ main å…¥å£å‡½æ•°ï¼Œå®Œæ•´ç­¾å`int main(int argc, char* argv[])`ï¼›
- è°ƒç”¨ printf åº“å‡½æ•°æ‰“å°å­—ç¬¦ä¸²ï¼Œä½¿ç”¨æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼›
- ä½¿ç”¨è½¬ä¹‰å­—ç¬¦ï¼Œ\n è¡¨ç¤ºæ¢è¡Œç¬¦ï¼›
- è¯­å¥ä½¿ç”¨åˆ†å·ç»“æŸï¼ŒèŠ±æ‹¬å·åé¢æˆ–å¼•ç”¨å¤´æ–‡ä»¶ä¸éœ€è¦ï¼›

```c
#include <stdio.h>

main()
{
    printf("Hello world\n");
}
```

C è¯­è¨€å…¥å£å‡½æ•°å‚æ•°ä¸ºå‘½ä»¤å‚æ•°ä¸ªæ•° argc å’Œå„ä¸ªå‚æ•°å†…å®¹ argvï¼Œå®ƒæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ã€‚

æŒ‰ç…§è§„èŒƒï¼Œ5.1.2.2.1 Program startup æè¿°ä¸»å‡½æ•°æœ‰ä»¥ä¸‹ä¸¤ç§å½¢å¼ï¼Œåƒä¸Šé¢è¿™ç§ `void main()` å…¶å®æ˜¯ä¸ä¸¥æ ¼çš„ï¼š

```c
int main(void) { /* ... */ }; // void å¯ä»¥çœç•¥
int main(int argc, char *argv[]) { /* ... */ };
```

ä½†æ˜¯ main å‡½æ•°æœ€åçš„ return è¯­å¥æ˜¯å¯ä»¥çœç•¥çš„ï¼Œç¼–è¯‘ä¼šè‡ªåŠ¨æä¾› return 0ï¼Œä½†æ˜¯è®°ä½ï¼Œåªæœ‰ main å‡½æ•°å¯ä»¥çœç•¥ï¼


è¦ç¼–è¯‘ä¸€ä¸ª C è¯­è¨€ç¨‹åºï¼Œç¼–è¯‘å™¨éœ€è¦å¤„ç†æ“ä½œç³»ç»Ÿæä¾›çš„å¤æ‚ç¯å¢ƒï¼Œè§„èŒƒæ–‡æ¡£ 5. Environment å°±æ˜¯è§£æè¿™éƒ¨åˆ†å†…å®¹çš„ã€‚ä¸€ä¸ªç¨‹åºè¿è¡Œæ—¶å…ˆç”±æ“ä½œç³»ç»Ÿçš„ç¨‹åºåŠ è½½å™¨è£…å…¥å†…å­˜ï¼Œç¨‹åºç»“æŸæ—¶è¿”å›ä¸€ä¸ªå€¼ç»™æ“ä½œç³»ç»Ÿï¼Œé€šå¸¸æ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œ0 ä»£è¡¨æ­£å¸¸ç»“æŸã€‚è€Œ main å‡½æ•°è¿”å›çš„å€¼ï¼Œé€šå¸¸æ˜¯é€šè¿‡ EAX å¯„å­˜å™¨è¿”å›ï¼Œå…¶å®æ˜¯ç”± C è¯­è¨€çš„å‡½æ•° `exit(main())` è¿”å›ç»™æ“ä½œç³»ç»Ÿã€‚

C æ ‡å‡† ISO è§„èŒƒå‘½åå‚è€ƒï¼š

- ISO/IEC 9899:1990 â€” C90
- ISO/IEC 9899:1999 â€” C99
- ISO/IEC 9899:2011 â€” C11
- ISO/IEC 9899:2018 â€” C18
- ISO/IEC 9899:202x â€” C2x ä¸‹ä¸€ä¸ªç‰ˆæœ¬çš„ C æ ‡å‡†ï¼Œé¢„è®¡å°†äº 2022 å¹´ 12 æœˆ 1 æ—¥å®Œæˆã€‚

è§„èŒƒè‰æ¡ˆæ–‡æ¡£ PDF æ ¼å¼ä¸‹è½½ï¼šhttps://iso-9899.info/wiki/The_Standard

C2x Not available N3096 [2023-04-02] 
https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3096.pdf
C17 ISO/IEC 9899:2018 N2310 [2018-11-11] (early C2x draft)
https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2310.pdf
C11 ISO/IEC 9899:2011 N1570 [2011-04-04]
https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf
C99 ISO/IEC 9899:1999 N1256 [2007-09-07]
https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf
C89 ISO/IEC 9899:1990 Not available


ä½¿ç”¨ GCC ç¼–è¯‘å·¥å…·ç¼–è¯‘ç”Ÿæˆå¯æ‰§è¡Œç¨‹åºï¼š

    gcc -o hello.exe helloworld.c

å¯ä»¥ä½¿ç”¨å¼€æºçš„å…è´¹å·¥å…·ï¼Œå¦‚ Code::Blocksï¼Œå®ƒæä¾›è‡ªå¸¦ MinGw GCC ç¼–è¯‘å·¥å…·ã€‚ 

CodeBlocks å®‰è£…ç›®å½•ä¸‹ compilers\options_common_warnings.xml æ–‡ä»¶æœ‰ GCC ç¼–è¯‘å™¨çš„é€‰é¡¹è¯´æ˜ï¼š

    -ansi       In C mode, this is equivalent to -std=c90, in C++ mode, it is equivalent to -std=c++98
    -std=c11    Have gcc follow the 2011 ISO C language standard
    -std=c99    Have gcc follow the 1999 ISO C language standard
    -std=c90    Have gcc follow the 1990 ISO C language standard  (certain GNU extensions that conflict with ISO C90 are disabled)
    -std=c++98  Have g++ follow the 1998 ISO C++ language standard

å¯ä»¥ä½¿ç”¨è¿™äº›é€‰é¡¹æ¥ç¼–è¯‘æŒ‡å®šè§„èŒƒçš„ä»£ç ã€‚

C è¯­è¨€ä½œä¸º C++ çš„å‰èº«ï¼Œå®ƒä»¬æ˜¯å‘å‰å…¼å®¹çš„å…³ç³»ï¼ŒC è¯­è¨€æœ‰çš„åŠŸèƒ½ï¼ŒC++ éƒ½æ”¯æŒï¼ŒC++ æœ‰çš„åŠŸèƒ½ï¼ŒC è¯­è¨€ä¸å®šæœ‰ã€‚ç®€æ´ä¸å¤æ‚ä¹‹é—´çš„å¹³è¡¡å°±æ˜¯ C ä¸ C++ ä¹‹é—´çš„å¹³è¡¡ï¼ŒC++ å‡ ä¹æ˜¯ C çš„è¶…é›†ï¼Œåªæœ‰å°‘é‡åŠŸèƒ½ C++ ä¸æ”¯æŒï¼Œä¾‹å¤–ä¹‹ä¸€ï¼ŒC++ æ²¡æœ‰ C99 çš„å˜é•¿æ•°ç»„ VLAã€‚

C/C++ ä½œä¸ºç³»ç»Ÿåº•å±‚è¯­è¨€ï¼ŒåŒæ ·å…·æœ‰å¼ºå¤§çš„åº•å±‚å¼€å‘èƒ½åŠ›ï¼Œç”±äº C++ å¼•å…¥äº† OOPï¼Œç›¸å¯¹äº FPï¼Œå…¶å®ç°ä¸Šæ›´å¤æ‚äº†ï¼Œä¹Ÿæä¾›æ›´ä¸¥æ ¼å…¨é¢çš„å°è£…ã€‚

è€Œ C è¯­è¨€ä½œä¸ºæˆåŠŸçš„ Functional Programmingï¼Œä¸€ç›´ä»¥æ¥ä¿æŒçš„ç®€æ´çš„å®ç°ï¼Œæ‰€ä»¥ä¹Ÿå°±ä¸å…·å¤‡ C++ ä¸­æä¾›çš„ä¸€äº›æ–¹ä¾¿çš„åŠŸèƒ½ï¼Œå¦‚å‡½æ•°é‡è½½ã€æ“ä½œç¬¦é‡è½½ã€ç±»å‹ç³»ç»Ÿã€‚

C è¯­è¨€çš„ä¿æŒç®€æ´çš„è§‚ç‚¹æ˜¯ï¼šæ²¡ä»€ä¹ˆæ˜¯æŒ‡é’ˆå’Œå®ä¸èƒ½è§£å†³çš„ï¼ŒåŠ é‚£ä¹ˆå¤šä¸œè¥¿æ²¡æ„ä¹‰ã€‚

C++ è¯­è¨€åŠŸèƒ½ä¸°å¯Œçš„è§‚ç‚¹æ˜¯ï¼šæ€ä¹ˆå¤æ‚æ€ä¹ˆæï¼Œä¸è¦æœ€å¥½çš„ï¼Œåªè¦æœ€éš¾æçš„ï¼

ç°ä»£ C++ æ˜¯è‡³å°‘å››ç§ç¼–ç¨‹èŒƒå¼çš„é›†åˆä½“ï¼Œé¢å‘è¿‡ç¨‹ï¼Œé¢å‘å¯¹è±¡ï¼Œæ³›å‹ç¼–ç¨‹å’Œå…ƒç¼–ç¨‹ï¼Œå‡½æ•°å¼ç¼–ç¨‹ç­‰ã€‚

ä»¥ä¸‹æ˜¯ Hello World! for C++ï¼š

```cpp
#include <iostream>
#include <cstdio>  // C++ style for stdio.h

using namespace std;

int main(int argv, char **args)
{
    cout << "Hello World!" << endl;
    return 0;
}
```

æé†’ï¼šå­¦ä¹  C è¯­è¨€ä¸åº”è¯¥æºæ‚ C++ çš„ä¸œè¥¿ï¼Œä½œä¸ºåŒä¸€ç³»ä½†åº•å±‚æ€æƒ³ç»ç„¶ä¸åŒçš„ä¸¤ç§è¯­è¨€ï¼ŒC/C++ æœ‰ç€å¤ªå¤§çš„åŒºåˆ«ã€‚


### ===ğŸ‘‰ Fahrenheit-Celsius

ä¸€ä¸ªç»å…¸çš„ç®—æ³•æ•™å­¦æ¡ˆä¾‹ï¼Œåæ°åº¦ä¸æ‘„æ°åº¦ä¸¤ä¸ªæ¸©åº¦æ ‡å‡†çš„è½¬æ¢ï¼Œå®ƒä»¬çš„å…³ç³»å¦‚ä¸‹ï¼š

    â„ƒ=(5/9)(â„‰-32)

åœ¨é‡Œä½¿ç”¨äº† while å¾ªç¯æµç¨‹æ§åˆ¶ç»“æ„ï¼Œå½“åœ†æ‹¬å·é‡Œçš„æ¡ä»¶ä¸º true æ—¶å¾ªç¯å°±ä¼šç»§ç»­ï¼š

```c
#include <stdio.h>

/* 
print Fahrenheit-Celsius table 
fahr from 0 to 300 step by 20
*/
main()
{
    int fahr, celsius;
    int lower, upper, step;

    lower = 0; /* lower limi to f temperature scale */
    upper = 300; // upper limit 
    step  = 20;  // stepsize 

    fahr = lower;
    while (fahr <= upper){
        celsius = 5*(fahr-32)/9;
        printf("%d\t%d\n", fahr, celsius);
        fahr = fahr + step;
    }
}
```

è¿™æ˜¯ä¸€ä¸ªç›¸å¯¹å®Œæ•´çš„ç¨‹åºç»“æ„ï¼Œæœ‰äº† C è¯­è¨€æœ€é‡è¦çš„å‡½æ•°ç»“æ„ï¼Œä¹Ÿæœ‰äº†æ³¨è§£å†…å®¹ï¼Œå•è¡Œæ³¨è§£æˆ–å¤šé€‰æ³¨è§£ï¼ŒåŒæ—¶è¿˜æœ‰æµç¨‹æ§åˆ¶ç»“æ„ï¼Œè¿˜å¯ä»¥ç”¨ for å¾ªç¯ç»“æ„æ¥æ›¿æ¢ whileã€‚

è¿™é‡Œæœ‰ä¸ªé—®é¢˜ï¼Œä½¿ç”¨æ•´æ•°å¯¼è‡´è½¬æ¢è¿‡ç¨‹çš„ç²¾åº¦æŸå¤±ï¼Œå¦‚æœæ¢æˆæµ®ç‚¹è¿ç®—ï¼Œé‚£ä¹ˆç»“æœå°±ä¼šæ›´å‡†ç¡®ï¼Œä¿®æ”¹ä¸¤å¤„ï¼š

```c
float fahr, celsius;
printf("%6.2f\t%6.2f\n", fahr, celsius);
// 100.00   37.78
```

å­—ç¬¦ä¸²æ ¼å¼åŒ–å‚è€ƒåç»­å†…å®¹ã€‚


### ===ğŸ‘‰ Standard I/O

è¿™æ˜¯ä¸¤ä¸ªæœ€åŸºæœ¬çš„è¾“å…¥è¾“å‡ºå‡½æ•°ï¼Œgethar å‡½æ•°è¯»å–ä¸€ä¸ªå­—ç¬¦ï¼Œç„¶å putchar è¾“å‡ºä¸€ä¸ªå­—ç¬¦ã€‚

ä»¥ä¸‹ç¨‹åºæ¼”ç¤ºæ§åˆ¶å°çš„åŸºæœ¬è¾“å…¥è¾“å‡º stdio.cï¼š

```c
#include <stdio.h>
#include <stdlib.h>

int main() 
{ 
    int c;
    do {
        c = getchar();
        if (c=='x') break;
        if (c!='\n') putchar(c);
    } while (c != EOF);
    printf("End of File: %d", c);
    return EXIT_SUCCESS;
}
```

è¿™ä¸ªç¤ºèŒƒç¨‹åºä½¿ç”¨äº† while å¾ªç¯çš„å¦ä¸€ç§å½¢å¼ï¼Œdo-whileï¼Œå°†æ¡ä»¶åˆ¤æ–­ç§»åˆ°å¾ªç¯ä½“åé¢ã€‚

å¾ªç¯ä¸­ä½¿ç”¨ EOF ä½œä¸ºç»“æŸï¼Œåœ¨ Windows ç³»ç»Ÿä¸­ï¼Œè¾“å…¥ ENTER é”®æ–°èµ·ä¸€è¡Œåï¼Œå†è¾“å…¥ Ctrl+Zï¼Œå†è¾“å…¥ ENTER é”®å³å¯ä»¥äº§ç”Ÿ EOFã€‚ 

Linux ç›´æ¥æŒ‰ CTRL+D å¿«æ·é”®ç»“æŸè¾“å…¥ï¼Œå³äº§ç”Ÿ EOFã€‚

åŸºæœ¬è¾“å…¥è¾“å‡ºä¸€èˆ¬æ¶‰åŠé”®ç›˜å’Œæ˜¾ç¤ºå™¨ï¼Œä¹Ÿå°±æ˜¯ç¨‹åºè¿è¡Œä¸­çš„æ§åˆ¶å°ã€‚å¯¹æ§åˆ¶å°æ“ä½œæ—¶ï¼Œé”®ç›˜å’Œé¼ æ ‡ç­‰è¾“å…¥è®¾å¤‡äº§ç”Ÿçš„ä¿¡å·æˆ–æ•°æ®è¢«æŠ½è±¡ä¸ºè¾“å…¥æ–‡ä»¶ stdin æ–‡ä»¶ã€‚è€Œè¾“å‡ºçš„å†…å®¹ä¼šå†™å…¥æ˜¾ç¤ºå™¨çš„ç¼“å­˜ä¸­å¹¶æ˜¾ç¤ºå‡ºæ¥ï¼Œè§†è§‰ä¸Šå°±æ˜¯æ§åˆ¶å°çª—å£çœ‹åˆ°çš„å†…å®¹ï¼ŒåŒæ ·ï¼Œè¾“å‡ºä¹Ÿè¢«æŠ½è±¡ä¸º stdout æ–‡ä»¶ã€‚

å¯¹äºé”®ç›˜è¾“å…¥è®¾å¤‡æŠ½è±¡è€Œæ¥çš„ stdin æ–‡ä»¶ï¼Œæ€ä¹ˆè¡¨ç¤ºå®ƒçš„ç»“æŸæ˜¯ä¸ªæŠ€å·§ï¼Œä¸åƒç¡¬ç›˜å­˜å‚¨çš„æ–‡ä»¶ï¼Œæœ‰æ˜ç¡®çš„æ–‡ä»¶å¤§å°å’Œç»“æŸä½ç½®ã€‚æ ‡å‡†æ§åˆ¶å°çš„è¾“å…¥ç»“æŸä¸€èˆ¬æ„å‘³ç€ç¨‹åºçš„ç»“æŸï¼Œä¸èƒ½å†æ¥æ”¶ç”¨æˆ·çš„è¾“å…¥ã€‚æ¯”å¦‚ï¼Œé€šè¿‡ Ctrl+D å’Œ Ctrl+C ç»“æŸç¨‹åºï¼Œå³ä¼šå¾—åˆ°æ–‡ä»¶ç»“æŸç¬¦ EOFï¼Œå®ƒåœ¨å‡½æ•°åº“é‡Œä¸€èˆ¬å®šä¹‰ä¸º -1ï¼Œä½†è¿™ä¸ªå€¼çš„æ„ä¹‰ä¸åœ¨äºå–ä»€ä¹ˆå€¼ï¼Œå› ä¸ºå®ƒä¸æ˜¯ç”¨æˆ·è¾“å…¥çš„å€¼ï¼Œè€Œæ˜¯ä»»æ„æŒ‡å®šçš„ã€‚

äº‹å®ä¸Šï¼Œè¾“å…¥è¾“å…¥æ–‡ä»¶æ˜¯å¯ä»¥è¢«é‡å®šå‘åˆ°å…¶å®ƒæ–‡ä»¶çš„ï¼Œå¦‚è¿è¡Œç¨‹åºæ—¶ï¼Œå°† stdio ç¨‹åºçš„ stdout é‡å®šå‘åˆ° out.txt æ–‡ä»¶ï¼Œè€Œä¸æ˜¯æ§åˆ¶å°é»˜è®¤çš„æ˜¾ç¤ºå™¨è¾“å‡ºï¼š

```sh
stdio.exe > out.txt
a
b
c
x
```

åªè¦ç¨‹åºæ­£å¸¸ç»“æŸï¼Œè¾“å‡ºçš„å†…å®¹ä¾¿ä¼šæŒ‰ç…§çº¦å®šå†™å…¥ out.txt æ–‡ä»¶ä¸­ï¼ŒåŸæ¥çš„æ–‡ä»¶å†…å®¹å°†è¢«è¦†ç›–ï¼Œå¯ä»¥ä½¿ç”¨ >> æ¥å°†æ–°å†…å®¹é™„åŠ åˆ°æ–‡ä»¶åŸæœ‰å†…å®¹åã€‚

æ­¤å¤–ï¼Œè¿˜æœ‰ stderr æ ‡å‡†é”™è¯¯æ–‡ä»¶ï¼Œå®ƒè¾“å‡ºçš„æ˜¯é”™è¯¯ä¿¡æ¯ï¼Œå’Œ stdout ç›¸å¯¹åº”ã€‚

é¢å¤–è¡¥å……ï¼ŒUnix/Linux æ ‡å‡† I/O æµæ–‡ä»¶ä¸å¯¹åº”çš„ IDï¼š

    | Handle |  Name  |   Description   |
    |--------|--------|-----------------|
    |      0 | stdin  | Standard input  |
    |      1 | stdout | Standard output |
    |      2 | stderr | Standard error  |

åœ¨å‘½ä»¤è¡Œä¸­ï¼Œå¯ä»¥ä½¿ç”¨è¿™äº›æ–‡ä»¶ ID æ¥åšé‡å®šå‘ï¼Œä¾‹å¦‚ ls å‘½ä»¤çš„æ ‡å‡†è¾“å‡ºåˆ°æ–‡ä»¶ï¼š

    # redirect stdout to list.txt
    ls > list.txt
    ls 1> list.txt

    # append stdout to list.txt
    ls -l >> list.txt

ä¾‹å¦‚ï¼Œå°† grep å‘½ä»¤çš„ stderr é‡å®šå‘åˆ°æ–‡ä»¶ï¼š

    grep -R 'MASTER' $HOME 2> err.txt

åŒæ—¶å°† stdout å’Œ stderr é‡å®šå‘åˆ°æ–‡ä»¶ï¼Œæ³¨æ„ï¼Œåé¢çš„`2>&1`è¡¨ç¤ºå°† stderr é‡å®šå‘åˆ° stdoutï¼š

    $ ls > list.txt 2>&1

    ## bash only ##
    $ ls &> list.txt

Windows ç³»ç»Ÿè¿˜æ”¯æŒä»¥ä¸‹è¿™æ ·çš„è¯­æ³•ï¼š

    dir 2>&1 > out.txt
    dir 2> nul
    dir > output.msg 2> output.err
    dir 1> output.msg 2>&1

é‡å®šå‘ stdin ä½¿ç”¨å·¦å°–æ‹¬å·ï¼Œåœ¨ Windows ç³»ç»Ÿåªæ”¯æŒç¬¬ä¸€ç§ç”¨æ³•ï¼š

    cmd < foo         å°† cmd çš„æ ‡å‡†è¾“å…¥é‡å®šå‘åˆ°æ–‡ä»¶ foo å³è¯»å…¥æ–‡ä»¶
    cmd << delimiter  å°† cmd çš„æ ‡å‡†è¾“å…¥é‡å®šå‘åˆ°ä¸‹é¢çš„å‘½ä»¤è¡Œï¼Œç›´åˆ°é‡åˆ° delimiterï¼ˆhere documentï¼‰
    cmd <<- delimiter å°† cmd çš„æ ‡å‡†è¾“å…¥é‡å®šå‘åˆ°ä¸‹é¢çš„å‘½ä»¤è¡Œï¼Œç›´åˆ°é‡åˆ° delimiterï¼ˆhere documentï¼Œå‘½ä»¤è¡Œä¸­å¼€å¤´çš„åˆ¶è¡¨ç¬¦ä¼šè¢«å¿½ç•¥ï¼‰


### ===ğŸ‘‰ Null-terminated String

C è¯­è¨€çš„å­—ç¬¦ä¸²ç§°ä¸º Null-terminated String æˆ–ç§°ä¸º C style stringï¼Œè¿™æ˜¯å› ä¸º C è¯­è¨€æ²¡æœ‰ç±»å¯¹è±¡ï¼Œä¸èƒ½ä¸ºå­—ç¬¦ä¸²æä¾›é¢å¤–çš„å±æ€§æ¥è®°å½•å­—ç¬¦ä¸²é•¿åº¦ï¼Œæ‰€ä»¥ä¸ºäº†æ–¹ä¾¿ï¼Œç›´æ¥ä½¿ç”¨ null å­—ç¬¦ä½œä¸ºå­—ç¬¦ä¸²çš„ç»“æŸæ ‡è®°ã€‚

è¿™é‡Œå¼ºè°ƒä¸€ä¸‹ï¼Œnull å­—ç¬¦æ˜¯æŒ‡ '\0' è¿™ä¸ªå­—ç¬¦ï¼Œè€Œä¸æ˜¯ NULL æŒ‡é’ˆï¼Œé€šå¸¸ä¸åº”è¯¥æ··æ·†å®ƒä»¬ï¼Œå³ä½¿ NULL ç”¨æ¥ç»“æŸå­—ç¬¦ä¸²ä¸ä¼šå¯¼è‡´å‡ºé”™ï¼Œè‡³å°‘å…¶å«ä¹‰ä¸æ˜¯å­—ç¬¦ä¸²ç»“æŸæ ‡è®°ã€‚

æ‰€ä»¥åœ¨ C è¯­è¨€ä¸­å®šä¹‰ä¸€ä¸ªå­—ç¬¦ä¸²çœŸå®çš„æ•°æ®å¦‚ä¸‹ï¼Œä¸‰ä¸ªå®šä¹‰ç­‰ä»·ï¼š

```c
char greeting[6] = {'H', 'e', 'l', 'l', 'o', ''};
char greeting[] = "Hello";
char *greeting = "Hello";
```

ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨å°† null æ·»åŠ åˆ°å­—ç¬¦ä¸²å¸¸é‡çš„æœ«å°¾ï¼Œæ‰€ä»¥ C é£æ ¼å­—ç¬¦ä¸²æ¯”å¯æ˜¾ç¤ºå­—ç¬¦å¤šä¸€ä¸ªå­—èŠ‚ã€‚

è€Œä½¿ç”¨ strlen å‡½æ•°æµ‹è¯•å¾—åˆ°çš„è¿˜æ˜¯å­—ç¬¦ä¸²å†…å®¹é•¿åº¦ï¼Œä½†æ˜¯ä½¿ç”¨å…¶å®ƒå‡½æ•°å¤„ç†å­—ç¬¦ä¸²æ—¶ï¼Œä¸€å®šè¦è®¾ç½®æœ‰è¶³å¤Ÿçš„ç¼“å†²å­—èŠ‚ï¼Œä»¥é¿å…æº¢å‡ºï¼š

```c
#include <stdio.h>
#include <string.h>

int main ()
{
   char str1[] = "Hello";
   char str2[] = "World";
   char str3[11];
   int  len ;
 
   strcpy( str3, str1);
   printf("strcpy( str3, str1) : %s\n", str3);
   // strcpy( str3, str1) : Hello

   strcat( str3, str2);
   printf("strcat( str1, str2): %s\n", str1);
   // strcat( str1, str2): Hello
 
   len = strlen(str3);
   printf("strlen(str1) :%d\n", len);
   // strlen(str1) :10
 
   return 0;
}
```

### ===ğŸ‘‰ escape sequences & <iso646.h>

å­—ç¬¦è½¬ä¹‰ï¼Œç”¨äºåœ¨å­—ç¬¦ä¸²ä¸­æ’å…¥éæ˜¾ç¤ºå­—ç¬¦ï¼Œé€šå¸¸æ˜¯æ§åˆ¶ç¬¦ï¼Œå¦‚å¸¸ç”¨çš„ `\n` æ¢è¡Œç¬¦ã€‚

    | Escape sequence |         Description         |      Representation      |
    |-----------------|-----------------------------|--------------------------|
    | \'              | single quote byte           | 0x27 (in ASCII encoding) |
    | \"              | double quote byte           | 0x22 (in ASCII encoding) |
    | \?              | question mark byte          | 0x3f (in ASCII encoding) |
    | \\              | backslash byte              | 0x5c (in ASCII encoding) |
    | \a              | audible bell byte           | 0x07 (in ASCII encoding) |
    | \b              | backspace byte              | 0x08 (in ASCII encoding) |
    | \f              | form feed - new page byte   | 0x0c (in ASCII encoding) |
    | \n              | line feed - new line byte   | 0x0a (in ASCII encoding) |
    | \r              | carriage return byte        | 0x0d (in ASCII encoding) |
    | \t              | horizontal tab byte         | 0x09 (in ASCII encoding) |
    | \v              | vertical tab byte           | 0x0b (in ASCII encoding) |
    | \nnn            | arbitrary octal value       | byte nnn                 |
    | \xnn            | arbitrary hexadecimal value | byte nn                  |
    | \unnnn          | Unicode character           | code point U+nnnn        |
    | \Unnnnnnnn      | Unicode character           | code point U+nnnnnnnn    |

å…¶ä¸­ `\?` ç”¨æ¥é˜²æ­¢ä¸‰å…ƒç»„ç¬¦å·çš„å‡ºç°ï¼Œå¦‚ "??/" è¿™ä¸ªä¸‰å…ƒç»„åˆè¡¨ç¤º "\"ï¼Œå¦‚æœä½¿ç”¨è½¬ä¹‰ "?\?/" å°±å¾—åˆ° "??/"ï¼Œä¸‰å…ƒç»„æ›¿ä»£ç¬¦å·æ˜¯ä¸ªä¸å¤ªå¸¸ç”¨çš„åŠŸèƒ½ã€‚

å…¨çƒç æ˜¯ç°è¡Œçš„é€šç”¨å­—ç¬¦é›†ï¼Œå¯ä»¥é¿å…å„ç§å­—ç¬¦é›†è½¬æ¢çš„ç—›è‹¦ã€‚

æ ¹æ®ç¼–ç æ–¹æ¡ˆçš„ä¸åŒï¼Œä¸€ä¸ªå…¨çƒç å­—ç¬¦éœ€è¦å¤šä¸ªå­—èŠ‚ï¼Œæˆ–å›ºå®šçš„ 2 ä¸ªå­—èŠ‚æˆ– 4 ä¸ªå­—èŠ‚ã€‚ä¾‹å¦‚ï¼Œ\U0001f34c ç”±å››ä¸ªå­—èŠ‚è¡¨è¾¾çš„å­—ç¬¦å¯¹åº” UTF-8 (\xF0\x9F\x8D\x8C) å’Œ UTF-16 (\uD83C\uDF4C))ã€‚

ä¾‹å¦‚ï¼Œä»¥ä¸‹è¾“å‡ºä¸¤ä¸ªå…¨çƒç å­—ç¬¦ï¼Œä¸€ä¸ªæ˜¯äº”è§’æ˜Ÿï¼Œå¦ä¸€ä¸ªæ˜¯é¦™è•‰ï¼Œå¦‚æœä½¿ç”¨ VSCode ç¼–è¾‘å™¨ä¼šæœ‰æç¤ºå­—ç¬¦ç¼–ç å€¼ï¼š

```c
printf("\u2605");     // â˜…
printf("\U0001f34c"); // ğŸŒ
```

åœ¨æ‰§è¡Œç¨‹åºè¾“å‡ºå…¨çƒç ä¹‹å‰ï¼Œéœ€è¦ä½¿ç”¨ chcp 65001 å°† Windows çš„æ§åˆ¶å°åˆ‡æ¢ä¸º Unicode å­—ç¬¦é›†æ¨¡å‹ã€‚

C ä»£ç å¯ä»¥ä½¿ç”¨é ASCII å­—ç¬¦é›†ç¼–å†™ï¼Œå³ ISO 646:1983 invariant character set ä¹‹å¤–çš„å­—ç¬¦é›†ã€‚ä¸€äº› C è¿ç®—ç¬¦å’Œæ ‡ç‚¹ç¬¦å·éœ€è¦ ISO 646 ä»£ç é›†ä¹‹å¤–çš„å­—ç¬¦ï¼š

    { } [ ] # \ ^ | ~

ä¸ºäº†èƒ½å¤Ÿåœ¨è¿™äº›ç¬¦å·éƒ¨åˆ†æˆ–å…¨éƒ¨ä¸å­˜åœ¨çš„æƒ…å†µä¸‹ä½¿ç”¨å­—ç¬¦ç¼–ç ï¼Œå¦‚å¾·å›½ DIN 66003 å­—ç¬¦é›†ï¼Œæœ‰ä¸¤ç§é€‰æ‹©ï¼šä½¿ç”¨ä¸¤ä¸ªæˆ–ä¸‰ä¸ª ISO 646 å…¼å®¹å­—ç¬¦çš„ç‰¹æ®Šç»„åˆï¼Œæ›¿ä»£æ‹¼å†™è¿™äº›è¿ç®—ç¬¦ï¼Œè¿™äº›å­—ç¬¦è¢«è§£é‡Šä¸ºä¸€ä¸ªé ISO 646 å­—ç¬¦ã€‚


åœ¨ C95 è§„èŒƒå¼•å…¥äº† `<iso646.h>` æä¾›ä»¥ä¸‹è¿ç®—ç¬¦å·çš„å®å®šä¹‰ï¼š

- `&&`  `and` (macro constant) 
- `&=`  `and_eq` (macro constant) 
- `&`   `bitand` (macro constant) 
- `|`   `bitor` (macro constant) 
- `~`   `compl` (macro constant) 
- `!`   `not` (macro constant) 
- `!=`  `not_eq` (macro constant) 
- `||`  `or` (macro constant) 
- `|=`  `or_eq` (macro constant) 
- `^`   `xor` (macro constant) 
- `^=`  `xor_eq` (macro constant) 

è¿˜æœ‰äºŒå…ƒç»„ Digraphs å’Œä¸‰å…ƒç»„ Trigraphs ç¬¦å·æ›¿æ¢ï¼š

- `{`   `<%` 
- `}`   `%>` 
- `[`   `<:` 
- `]`   `:>` 
- `#`   `%:` 
- `##`  `%:%:` 
- `{`   `??<`
- `}`   `??>`
- `[`   `??(`
- `]`   `??)`
- `#`   `??=`
- `\`   `??/`
- `^`   `??'`
- `|`   `??!`
- `~`   `??-`

ç¤ºèŒƒï¼Œä»¥ä¸‹ç¨‹åºä½¿ç”¨æ‹¼å†™æ›¿ä»£ç¬¦å·ï¼Œæ ¹æ®å‘½ä»¤è¡Œå‚æ•°æ‰“å°å†…å®¹ï¼Œåªæ˜¯è§†è§‰ç›¸å½“çš„ç³Ÿç³•ï¼š

```c
%:include <stdlib.h>
%:include <stdio.h>
%:include <iso646.h>
 
int main(int argc, char** argv)
??<
    if (argc > 1 and argv<:1:> not_eq NULL)
    <%
       printf("Hello%s\n", argv<:1:>);
    %>
 
    return EXIT_SUCCESS;
??>
```

### ===ğŸ‘‰ format string
- https://en.cppreference.com/w/c/io/fscanf
- https://en.cppreference.com/w/c/io/fprintf
- https://en.cppreference.com/w/c/types/integer
- https://en.cppreference.com/w/c/header
- https://en.cppreference.com/w/c/string

æ ¼å¼åŒ–è¾“å…¥è¾“å‡ºæ˜¯æœ€å¸¸ç”¨çš„ä¸¤ä¸ªåŸºæœ¬ I/O åŠŸèƒ½ï¼Œscanf å’Œ printf å®šä¹‰åœ¨ `<stdio.h>` å¤´æ–‡ä»¶ä¸­ã€‚

å¸¸ç”¨çš„æ ¼å¼åŒ–è¾“å‡ºï¼š

```c
printf("Strings\n");
const char* s = "Hello";
printf("\t.%10s.\n\t.%-10s.\n\t.%*s.\n", s, s, 10, s);
printf("Characters:\t%c %%\n", 65);

printf("Integers:\n");
printf("Decimal:\t%i %d %.6i %i %.0i %+i %u\n", 1, 2, 3, 0, 0, 4, -1);
printf("Hexadecimal:\t%x %x %X %#x\n", 5, 10, 10, 6);
printf("Octal:\t%o %#o %#o\n", 10, 10, 4);

printf("Floating point\n");
printf("Rounding:\t%f %.0f %.32f\n", 1.5, 1.5, 1.3);
printf("Padding:\t|%05.2f|%.2f|%5.2f|\n", 1.5, 1.5, 1.5);
printf("Scientific:\t%E %e\n", 1.5, 1.5);
printf("Hexadecimal:\t%a %A\n", 1.5, 1.5);
```

ä»¥ä¸Šä»£ç æ ¼å¼åŒ–è¾“å‡ºï¼š

```sh
Strings
    .     Hello.
    .Hello     .
    .     Hello.
Characters:     A %

Integers
Decimal:        1 2 000003 0  +4 4294967295
Hexadecimal:    5 a A 0x6
Octal:          12 012 04

Floating point
Rounding:       1.500000 2 1.30000000000000004440892098500626
Padding:        |01.50|1.50| 1.50|
Scientific:     1.500000E+00 1.500000e+00
Hexadecimal:    0x1.8p+0 0X1.8P+0
```

æ ¼å¼åŒ–åŒ…å«å†…å®¹å¦‚ä¸‹ï¼š

- æ•°æ®ç±»å‹ï¼Œå¦‚ `%s` è¡¨ç¤ºå­—ç¬¦ä¸²ï¼Œ`%d` è¡¨ç¤ºæ•°å€¼ï¼›
- æ ¼å¼è¾“å‡ºå®½åº¦ï¼Œå¦‚ `%10s` è¡¨ç¤º 10 ä¸ªå­—ç¬¦å®½åº¦ï¼Œ`%-10s` è¡¨ç¤ºé å·¦å¯¹é½ï¼Œ`%*s` è¡¨ç¤ºé€šè¿‡å‚æ•°æŒ‡å®šå­—ç¬¦ä¸²å®½åº¦ï¼Œæ˜Ÿå·ä¹Ÿå¯ä»¥ç”¨åœ¨å°æ•°ä¸Šï¼›
- å°æ•°ç‚¹ä½æ•°ï¼Œå¦‚ `%05.2f` è¡¨ç¤º 5 ä¸ªå­—ç¬¦å®½åº¦ï¼Œä¿ç•™ä¸¤ä½å°æ•°ï¼Œæœ‰ç©ºä½™ç©ºé—´å‰é¢æ•´æ•°å‰ç¼€ 0ï¼Œ`%.0f` ä¸ä¿ç•™å°æ•°ä¼šè¿›è¡Œå‘ä¸Šå–èˆï¼›

æ ¼å¼åŒ–æ•°æ®ç±»å‹å ä½ç¬¦å·å¦‚ä¸‹ï¼š

- `%d` åè¿›åˆ¶æœ‰ç¬¦å·æ•´æ•° int
- `%u` åè¿›åˆ¶æ— ç¬¦å·æ•´æ•° unsigned int
- `%lu` åè¿›åˆ¶æ— ç¬¦å·é•¿æ•´æ•° unsigned long
- `%f` æµ®ç‚¹æ•°
- `%s` å­—ç¬¦ä¸²
- `%c` å•ä¸ªå­—ç¬¦
- `%p` æŒ‡é’ˆçš„å€¼
- `%e` æŒ‡æ•°å½¢å¼çš„æµ®ç‚¹æ•°
- `%x`, `%X` æ— ç¬¦å·ä»¥åå…­è¿›åˆ¶è¡¨ç¤ºçš„æ•´æ•°
- `%0` æ— ç¬¦å·ä»¥å…«è¿›åˆ¶è¡¨ç¤ºçš„æ•´æ•°
- `%g` è‡ªåŠ¨é€‰æ‹©åˆé€‚çš„è¡¨ç¤ºæ³•

å¯¹äº long int æˆ– long long int å¯ä»¥ä½¿ç”¨å‰ç¼€ï¼Œå¦‚ `%lld`ã€‚

C++ iostream æä¾› bin, oct, dec, hex æ¥è¡¨ç¤ºå¸¸ç”¨åˆ¶å¼çš„æ ¼å¼åŒ–ã€‚C è¯­è¨€äºŒè¿›åˆ¶æ ¼å¼åŒ–éœ€è¦ä½¿ç”¨ <stdlib.h> å‡½æ•°åº“çš„ `itoa(num, s, radix)`ã€‚

æ–°çš„ç¼–è¯‘å™¨ä¼šå¼•è¿› `__int64 _W64 int64_t` ç­‰ç±»å‹ï¼Œè¦æ‰“å°å®ƒä»¬å°±éœ€è¦å¯¹åº”çš„æ ¼å¼å­—ç¬¦ï¼ŒåŠ å…¥ j å‰ç¼€ï¼Œæˆ–ä½¿ç”¨ <inttypes.h> å®šä¹‰çš„ PRId64 è¿™ç±»æ ¼å¼ç¬¦å·ã€‚size_t æ˜¯æ— ç¬¦å·æ•´å½¢æ•°å€¼ï¼Œä½¿ç”¨ %zu æ ¼å¼å­—ç¬¦ä¸²ã€‚

```c
#include <inttypes.h>
int64_t it;
uint64_t ut;
printf("%" PRId64 "%" PRIu64 "\n", it, ut);
```

The correct conversion specifications for the fixed-width character types (int8_t, etc) are defined in the header <inttypes.h> (although PRIdMAX, PRIuMAX, etc is synonymous with %jd, %ju, etc).


æ ¼å¼åŒ–è¾“å…¥åŸºæœ¬è§„åˆ™ï¼š

- éç©ºç™½å¤šå­—èŠ‚å­—ç¬¦ï¼Œé™¤äº†%ï¼šæ ¼å¼å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªè¿™æ ·çš„å­—ç¬¦åªæ¶ˆè€—è¾“å…¥æµä¸­çš„ä¸€ä¸ªç›¸åŒå­—ç¬¦ï¼Œæˆ–è€…å¦‚æœæµä¸­çš„ä¸‹ä¸€ä¸ªå­—ç¬¦æ¯”è¾ƒä¸ç›¸ç­‰ï¼Œåˆ™å¯¼è‡´å‡½æ•°å¤±è´¥ã€‚
- ç©ºç™½å­—ç¬¦ï¼šæ ¼å¼åŒ–å­—ç¬¦ä¸²çš„ç©ºç™½å­—ç¬¦ "\n", " ", "\t\t" ç­‰ç­‰ï¼Œä¼šæ¶ˆè€—æ‰è¾“å…¥å†…å®¹ä¸­çš„è¿ç»­çš„ç©ºç™½å­—ç¬¦ã€‚

æ ¼å¼è½¬æ¢ç¬¦å·åŸºæœ¬ç»„æˆï¼š

- % æ‰“å¤´è¡¨ç¤ºä¸€ä¸ªè½¬æ¢æŒ‡ç¤ºã€‚
- * è¡¨ç¤ºç¦æ­¢èµ‹å€¼ï¼ŒåŒ¹é…åˆ°çš„å†…å®¹ä¸¢å¼ƒå¤„ç†ã€‚
- width ç”¨å¤§äº 0 çš„æ•´æ•°æŒ‡å®šåŒ¹é…å†…å®¹å®½åº¦ã€‚æ³¨æ„ï¼Œ%s å’Œ %[ è¿™æ ·çš„è½¬æ¢æŒ‡ç¤ºå¦‚æœä¸æŒ‡å®šå®½åº¦ä¼šå¯¼è‡´æº¢å‡ºã€‚
- length æŒ‡å®šæ¥æ”¶å‚æ•°çš„å¤§å°ï¼Œå³å®é™…çš„ç›®æ ‡ç±»å‹ã€‚è¿™ä¼šå½±å“è½¬æ¢ç²¾åº¦å’Œæº¢å‡ºè§„åˆ™ï¼Œæ¯ä¸ªè½¬æ¢ç±»å‹çš„é»˜è®¤ç›®æ ‡ç±»å‹éƒ½ä¸åŒã€‚
- è½¬æ¢æ ¼å¼æŒ‡ç¤º Conversion specifierï¼›

æ ¼å¼åŒ–è¾“å…¥å‡½æ•°æœ‰å¸¦ s åç¼€çš„å®‰å…¨ç‰ˆï¼Œå¦‚ scanf_sï¼Œå’Œæ™®é€šç‰ˆåŒºåˆ«åœ¨äº %c, %s, %[ ç­‰è½¬æ¢å¤„ç†çš„ä¸åŒï¼Œè¿™äº›è½¬æ¢éƒ½è¦æ±‚ä¸¤ä¸ªå‚æ•°ï¼Œä¸€æŒ‡é’ˆå’Œä¸€ä¸ªå¤§å°æ•°å€¼æ¥ç¡®å®šå®‰å…¨è¾¹ç•Œã€‚

Conversion specifier å‚è€ƒï¼š

- `%` matches literal %
- `c` matches a character or a sequence of characters
- `s` matches a sequence of non-whitespace characters (a string)
- `[set]` matches a non-empty sequence of character from set of characters.
- `[^set]` matches a non-empty sequence of character not in the set of characters.
- `d` matches a decimal integer. è¾“å…¥æ ¼å¼è¦æ±‚åŒ strtol() å‡½æ•°ã€‚
- `i` matches an integer. è¾“å…¥æ ¼å¼è¦æ±‚åŒ strtol() å‡½æ•°ã€‚
- `u` matches an unsigned decimal integer. è¾“å…¥æ ¼å¼è¦æ±‚åŒ strtoul() å‡½æ•°ã€‚
- `o` matches an unsigned octal integer. è¾“å…¥æ ¼å¼è¦æ±‚åŒ strtoul() å‡½æ•°ã€‚
- `x`, X matches an unsigned hexadecimal integer. è¾“å…¥æ ¼å¼è¦æ±‚åŒ strtoul() å‡½æ•°ã€‚
- `n` è¿”å›å½“å‰å·²ç»å¤„ç†çš„å­—ç¬¦æ•°ï¼Œä¸æ¶ˆè€—è¾“å…¥æ•°æ®ï¼Œä¸è®°ä½œè¿”å›çš„èµ‹å€¼æ¬¡æ•°ã€‚
- `a`, `A`(C99) `e`, `E`, `f`, `F`, `g`, `G` matches a floating-point number.
- `p` matches implementation defined character sequence defining a pointer.

ä¾‹å¦‚ `%[^\n]` è¡¨ç¤ºåŒ¹é…ä¸€è¡Œè¾“å…¥ï¼Œä½†æ˜¯ä¸åŒ…æ‹¬é ASCII å­—ç¬¦ï¼Œå¦‚è¾“å…¥ "French suits of trÃ¨fles" å°†ä¸¢å¤±åé¢å››ä¸ªå­—ç¬¦ã€‚

ç¤ºèŒƒï¼š

```c
#define __STDC_WANT_LIB_EXT1__ 1
#include <stdio.h>
#include <stddef.h>
#include <locale.h>
 
int main(void)
{
    int i, j;
    float x, y;
    char str1[10], str2[4];
    wchar_t warr[2];
    setlocale(LC_ALL, "en_US.utf8");
 
    char input[] = "25 54.32E-1 Thompson 56789 0123 56ÃŸæ°´";
    /* parse as follows:
       %d: an integer
       %f: a floating-point value
       %9s: a string of at most 9 non-whitespace characters
       %2d: two-digit integer (digits 5 and 6)
       %f:  a floating-point value (digits 7, 8, 9)
       %*d: an integer which isn't stored anywhere
       ' ': all consecutive whitespace
       %3[0-9]: a string of at most 3 decimal digits (digits 5 and 6)
       %2lc: two wide characters, using multibyte to wide conversion  */
    int ret = sscanf(input, "%d%f%9s%2d%f%*d %3[0-9]%2lc",
                     &i, &x, str1, &j, &y, str2, warr);
 
    printf("Converted %d fields:\ni = %d\nx = %f\nstr1 = %s\n"
           "j = %d\ny = %f\nstr2 = %s\n"
           "warr[0] = U+%x warr[1] = U+%x\n",
           ret, i, x, str1, j, y, str2, warr[0], warr[1]);
 
#ifdef __STDC_LIB_EXT1__
    int n = sscanf_s(input, "%d%f%s", &i, &x, str1, (rsize_t)sizeof str1);
    // writes 25 to i, 5.432 to x, the 9 bytes "thompson\0" to str1, and 3 to n.
#endif
}
```

Output:

    Converted 7 fields:
    i = 25
    x = 5.432000
    str1 = Thompson
    j = 56
    y = 789.000000
    str2 = 56
    warr[0] = U+df warr[1] = U+6c34


å¦å¤–ï¼Œä¸å¾—ä¸çš„ä¸€ä¸ªå®¹æ˜“è¢«åˆå­¦è€…å¿½è§†çš„æ˜¯æº¢å‡ºå¯¼è‡´çš„å®‰å…¨é—®é¢˜ï¼Œä¾‹å¦‚ï¼Œä»¥ä¸‹ä»£ç ç‰‡æ–­ä½¿ç”¨æ ¼å¼åŒ–è¾“å…¥å‡½æ•°å¤šæ ‡å‡†è¾“å…¥è®¾ç½®ä¸­è¯»å–ä¸€ä¸ªå­—ç¬¦ä¸²ï¼š

```c
char buf[256];
scanf("%s", buf);
```

ç›®æ ‡ç¼“å†²åŒºåªå®šä¹‰äº† 256 ä¸ªå­—ç¬¦ï¼Œå‡å¦‚æ¶æ„ç”¨æˆ·è¾“å…¥çš„å­—ç¬¦è¶…è¿‡ 256 ä¸ªå­—ç¬¦ä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿ

æ˜¾ç„¶ï¼Œbuf æ‰€æœ‰åœ°å€åé¢ 256 å­—ç¬¦ç´§è·Ÿçš„å†…å­˜åŒºåŸŸå°†ä¼šè¢«ç”¨æˆ·æ¶æ„è¾“å…¥çš„å†…å®¹è¦†ç›–ï¼Œå¦‚æœè¿™äº›å†…å­˜æ˜¯ç²¾å¿ƒæ„é€ çš„ä»£ç ï¼Œé‚£ä¹ˆå°†ææœ‰å¯èƒ½æ¼”å˜ä¸ºæˆåŠŸçš„å †æ ˆæº¢å‡ºæ”»å‡»ã€‚

è§£å†³åŠæ³•æ˜¯æŒ‡å®šè¾“å…¥çš„å­—ç¬¦å®½åº¦ï¼š

```c
#define ScanWidth(width) ScanWidthEx(width)
#define ScanWidthEx(width) ("%" #width "s")

char buf[5];
scanf("%5s", buf);
scanf(ScanWidth(MAXWORD), buf);
// scanf_s for C11
```

scanf ä¸ sscanf å ªç§° C çš„æ€æ‰‹çº§æ ‡å‡†åº“å‡½æ•°ï¼Œå› ä¸ºä½¿ç”¨èµ·æ¥å®åœ¨æ˜¯å¤ªæ–¹ä¾¿äº†ï¼Œä½†æ˜¯å®ƒä»¬çš„å®‰å…¨éšæ‚£åˆæ˜¯å¦‚æ­¤æ˜æ˜¾å’Œå®¹æ˜“è¢«å¿½è§†ã€‚

æ ‡å‡†åº“ <stdlib.h> æ˜¯ä¸€ä¸ªå¤šåŠŸèƒ½å‡½æ•°åº“ï¼Œé™¤äº†åŠ¨æ€å†…å­˜åˆ†é…ï¼Œè¿˜æœ‰ç¨‹åºå·¥å…·ã€ç®—æ³•ï¼ˆqsorts å’Œ bsearchï¼‰ã€å­—ç¬¦ä¸²ç±»å‹è½¬æ¢ï¼Œä»¥åŠä¼ªéšæœºæ•°ã€‚

0. https://en.cppreference.com/w/c/header
1. https://en.cppreference.com/w/c/memory
2. https://en.cppreference.com/w/c/program
3. https://en.cppreference.com/w/c/string
4. https://en.cppreference.com/w/c/numeric/random
5. https://en.cppreference.com/w/c/algorithm
6. https://en.cppreference.com/w/c/io/fprintf

å­—ç¬¦ä¸²è½¬æ¢æ˜¯æœ€åŸºæœ¬çš„ç¼–ç¨‹èƒ½åŠ›ï¼Œæ­¤å‡½æ•°åº“æä¾›ä»¥ä¸‹ä¸‰ç±»å­—ç¬¦ä¸²å¤„ç†å‡½æ•°ï¼š

1. Null-terminated byte string management
2. Null-terminated multibyte string management
3. Null-terminated wide string management

Null-terminated byte string (NTBS) æœ€åŸºæœ¬çš„ C è¯­è¨€å­—ç¬¦ä¸²è¡¨è¾¾å½¢å¼ï¼Œä½¿ç”¨ NULL å³ 0 å€¼ä»€ä¹ˆå­—ç¬¦ä¸²ç»“æŸæ ‡å¿—ï¼Œå¤§å¤šæ•°å­—ç¬¦ä¸²ç›¸å…³å‡½æ•°éƒ½ä¼šæ ¹æ®è¿™ä¸ªæ ‡å¿—å­—èŠ‚æ¥ç»ˆæ­¢å†…å­˜ä¸­çš„å­—ç¬¦ä¸²æ•°æ®è®¿é—®ã€‚æ¯”å¦‚ï¼Œ{'\x63','\x61','\x74','\0'} å››ä¸ªå­—èŠ‚ NTBS ä¿å­˜çš„å­—ç¬¦ä¸²å°±æ˜¯ ASCII å­—ç¬¦é›†ä¸­çš„ "cat"ã€‚

æ ‡å‡†åº“æä¾›äº†å¤šç§å­—ç¬¦ä¸²è½¬æ•°æ®å‡½æ•°ï¼Œæ•°å€¼è½¬å­—ç¬¦ä¸²é€šå¸¸ä½¿ç”¨ stdio æä¾›çš„æ–¹æ³•ï¼š

1. `sprintf()` æˆ– `snprintf()` å‡½æ•°å°†æ•°å€¼è½¬æ¢æˆå­—ç¬¦ä¸²ï¼›
2. `itoa()` å‡½æ•°åœ¨ C è¯­è¨€ä¸­æŠŠæ•´æ•°è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼›

Integer to alphanumeric (itoa)ï¼ŒLong to alphanumeric (ltoa) ç”šè‡³æ˜¯ long long ç±»å‹ä¹‹é—´æˆ–è€…ç›¸åæ–¹å‘çš„è½¬æ¢å‡½æ•°ã€‚`itoa()` è¿™æ ·çš„ç”±æ•°å€¼è½¬å­—ç¬¦ä¸²çš„å‡½æ•°ä¸æ˜¯ ANSI C æ ‡å‡†å‡½æ•°ã€‚æ ¹æ®å®ç°å¹³å°ä¸åŒï¼Œå®ƒå¯èƒ½æ— æ³•åœ¨ C ç¼–è¯‘å™¨ä¸Šå·¥ä½œã€‚`strfromf` è¿™æ ·çš„æ•°å€¼è½¬æ¢å­—ç¬¦ä¸²å‡½æ•°åˆ° C23 è§„åˆ™æ‰æœ‰å®šä¹‰ã€‚

å¦å¤–ï¼Œä¸ºäº†å…¼å®¹æ—§ä»£ç ï¼Œè¿˜æœ‰ä»¥ä¸‹å‡ ä¸ªæµ®ç‚¹æ•°è½¬å­—ç¬¦ä¸²å‡½æ•°ï¼Œè¿”å›å°æ•°ç‚¹ä½ç½®å’Œç¬¦å·ä½ï¼š

```cpp
#include <stdlib.h>
char    ecvt (double value, int ndigit, int * restrict decpt, int * restrict sign)
char    fcvt (double value, int ndigit, int * restrict decpt, int * restrict sign)
char    gcvt (double value, int ndigit, char *buf)
```

Conversions to and from numeric formats

| Defined in header <stdlib.h>                                  |
| atof        | converts a byte string to a floating-point value | (function)
| atoi atol atoll | converts a byte string to an integer value | (function) (C99)
| strtol strtoll | converts a byte string to an integer value | (function) (C99)
| strtoul strtoull | converts a byte string to an unsigned integer value | (function) (C99)
| strtof strtod strtold | converts a byte string to a floating point value | (function) (C99)
| strfromf strfromd strfromld | converts a floating point value to a byte string | (function) (C23)
| Defined in header <inttypes.h>                               |
| strtoimax strtoumax | converts a byte string to intmax_t or uintmax_t | (function) (C99)

```cpp
int       atoi( const char *str );
long      atol( const char *str );
long long atoll( const char *str );  // (since C99)
long      strtol( const char *str, char **str_end, int base );  // (until C99)
long      strtol( const char *restrict str, char **restrict str_end, int base );  // (since C99)
long long strtoll( const char *restrict str, char **restrict str_end, int base );  // (since C99)
unsigned long      strtoul( const char  *str, char **str_end, int base );  // (until C99)
unsigned long      strtoul( const char *restrict str, char **restrict str_end, int base );  // (since C99)
unsigned long long strtoull( const char *restrict str, char **restrict str_end, int base );  // (since C99)
double atof( const char* str );
float       strtof( const char *restrict str, char **restrict str_end ); // (since C99)
double      strtod( const char          *str, char          **str_end ); // (until C99)
double      strtod( const char *restrict str, char **restrict str_end ); // (since C99)
long double strtold( const char *restrict str, char **restrict str_end ); // (since C99)
intmax_t strtoimax( const char *restrict nptr, char **restrict endptr, int base ); // (since C99)
uintmax_t strtoumax( const char *restrict nptr, char **restrict endptr, int base ); // (since C99)
int strfromf( char *restrict s, size_t n, const char *restrict format, float fp ); // (since C23)
int strfromd( char *restrict s, size_t n, const char *restrict format, double fp ); // (since C23)
int strfroml( char *restrict s, size_t n, const char *restrict format, long double fp ); // (since C23)
```


### ===ğŸ‘‰ macro å®åŸºç¡€
1. https://sourceforge.net/p/predef/wiki/Compilers/
2. https://en.cppreference.com/w/cpp/preprocessor
3. https://cplusplus.com/doc/tutorial/preprocessor/

ä½¿ç”¨å® macro å®šä¹‰å¯ä»¥åœ¨ç¼–è¯‘å™¨é¢„å¤„ç†é˜¶æ®µ preprocessor æ›¿æ¢ä»£ç ç”Ÿæˆå®å®šä¹‰çš„åŠŸèƒ½ï¼Œåˆç†åˆ©ç”¨å®èƒ½æé«˜ç¨‹åºçš„è¿è¡Œæ•ˆç‡ã€‚

å®å¤„ç†å™¨å³æ‰§è¡Œå­—ç¬¦ä¸²æ›¿æ¢çš„å¤„ç†ç¨‹åºï¼Œå…¶è¾“å…¥æ˜¯å­—ç¬¦ä¸²ï¼ˆåŒ…å«å®ç¬¦å·å®šä¹‰ï¼‰ï¼Œè¾“å‡ºä¹Ÿæ˜¯å­—ç¬¦ä¸²ã€‚GNU M4 æ˜¯ä¸€ä¸ªé€šç”¨çš„å®å¤„ç†ç¨‹åºï¼ŒC/C++ å®å¤„ç†ç¨‹åºå³æ˜¯ M4 çš„æ¼”åŒ–ç‰ˆæœ¬ã€‚

å¯ä»¥å°†å®å½“ä½œæ˜¯ä¸€æ®µåœ¨ç¼–è¯‘å™¨ä¸­è¿è¡Œçš„è„šæœ¬ï¼Œä¼šåœ¨ç¨‹åºç¼–è¯‘è¿‡ç¨‹ä¸­äº§ç”Ÿä¸€äº›æ–°çš„ä»£ç ã€‚

å®åŸºæœ¬è¯­æ³•å¦‚ä¸‹ï¼š

    #define MacroNameã€€ã€€Contents

Preprocessor directives å‚è€ƒï¼š

```c
// Source file inclusion (#include)
#include <header>
#include "file" 

// macro definitions (#define, #undef)
#define TABLE_SIZE 100
int table1[TABLE_SIZE];
int table2[TABLE_SIZE];
#undef TABLE_SIZE

// Conditional inclusions (#ifdef, #ifndef, #if, #endif, #else and #elif)
#ifdef TABLE_SIZE
int table[TABLE_SIZE];
#endif

#if TABLE_SIZE>200
#  undef TABLE_SIZE
#  define TABLE_SIZE 200
#elif TABLE_SIZE<50
#  undef TABLE_SIZE
#  define TABLE_SIZE 50
#else
#  undef TABLE_SIZE
#  define TABLE_SIZE 100
#endif

// Line control (#line)
#line number "filename"

// Cause an error or warning (since C++23) 
#ifndef __cplusplus
#error A C++ compiler is required!
#warning A C++ compiler is required!
#endif 
// Pragma directive (#pragma)
// Predefined macro names
__LINE__      // Integer value representing the current line in the source code file being compiled.
__FILE__      // A string literal containing the presumed name of the source file being compiled.
__DATE__     // A string literal in the form "Mmm dd yyyy" containing the date in which the compilation process began.
__TIME__     // A string literal in the form "hh:mm:ss" containing the time at which the compilation process began.
__cplusplus    // An integer value. All C++ compilers have this constant defined to some value. 
            // Its value depends on the version of the standard supported by the compiler:
            // 199711L: ISO C++ 1998/2003
            // 201103L: ISO C++ 2011
__STDC_HOSTED__  // 1 if the implementation is a hosted implementation (with all standard headers available)
                // 0 otherwise.
```

å¦‚ä¸‹ï¼Œå®šä¹‰ OGLDEV_FILE_ERROR å®ç”¨æ¥æ‰“å°æ–‡ä»¶æ‰“å¼€çš„é”™è¯¯æ¶ˆæ¯ï¼š

```c
#include <cstring>
#include <iostream>
#include "windows.h"

using namespace std;

#define PI 3.1415926
#define pi "3.1415926"

typedef unsigned int uint;

void OgldevFileError(const char* pFileName, uint line, const char* pFileError);

#define OGLDEV_FILE_ERROR(FileError) OgldevFileError(__FILE__, __LINE__, FileError);

void OgldevFileError(const char* pFileName, uint line, const char* pFileError)
{
#ifdef WIN32
    char msg[1000];
    _snprintf_s(msg, sizeof(msg), "%s:%d: unable to open file? no, just a `%s`", pFileName, line, pFileError);
    MessageBoxA(NULL, msg, NULL, 0);
#else
    fprintf(stderr, "%s:%d: unable to open file? no, just a `%s`\n", pFileName, line, pFileError);
#endif    
}

int main()
{
    OGLDEV_FILE_ERROR("demo from opengl-tutorial.org tutorial02 shader")
}
```

è¿™ä¸ªç¤ºèŒƒç¨‹åºä¼šæ ¹æ®æ˜¯å¦å®šä¹‰äº† WIN32 ç¬¦å·æ¥é€‰æ‹©ä½¿ç”¨å›¾å½¢ç•Œé¢æˆ–è€…æ§åˆ¶å°è¾“å‡ºï¼Œåªéœ€è¦å°† "windows.h" å¤´æ–‡ä»¶æ³¨è§£å°±ä¼šå¤±å»è¿™ä¸ªç¬¦å·å®šä¹‰ï¼Œå³ç¼–è¯‘ç”Ÿæˆæ§åˆ¶å°ç¨‹åºã€‚

ç¨‹åºæ‰“å°ä¸€ä¸ªé”™è¯¯ä¿¡æ¯ï¼ŒåŒ…å«äº†é”™è¯¯å‡ºç°çš„æºä»£ç åŠè¡Œå·ï¼Œè¿™æ˜¯éå¸¸å¥½çš„å¼€å‘ä½“éªŒï¼š

    C:\temp\coding.cpp:29: unable to open file? no, just a `demo from opengl-tutorial.org tutorial02 shader`

ANSI æ ‡å‡†è¯´æ˜äº†äº”ä¸ªé¢„å®šä¹‰çš„å®åï¼Œå®ƒä»¬æ˜¯ï¼š 

```c
__LINE__ /* %d */
__FILE__ /* %s */
__DATE__ /* %s */
__TIME__ /* %s */
__FUNCTION__  or __func__
```

å®å®šä¹‰ä¸­æœ‰ä¸‰ä¸ªç‰¹åˆ«æœ‰ç”¨çš„ç‰¹æ®Šæ‰©å±•ç¬¦å·ï¼š`#`ï¼Œ`##`ï¼Œ`#@`

- `x##y` è¡¨ç¤º x æ‹¼æ¥ yï¼Œæ•°å€¼æˆ–å­—ç¬¦ä¸²ï¼›
- `#@x` ç»™ x åŠ ä¸Šå•å¼•å·ï¼Œç»“æœè¿”å›æ˜¯ä¸€ä¸ª const charã€‚ä¸¾ä¾‹è¯´ï¼š
- `#x` åŸæ„æ˜¯ç»™ x åŠ åŒå¼•å·å˜æˆå­—ç¬¦ä¸²ï¼š

æ³¨æ„ï¼Œæ­£å¦‚å‰é¢æ¼”ç¤ºï¼Œå®å®šä¹‰å¯ä»¥åµŒå¥—å®è°ƒç”¨ï¼Œä½†æ˜¯ä½¿ç”¨'#'æˆ–'##'æ‰©å±•åï¼Œå®å†…å®¹å³ä½¿ç”¨æ˜¯ä¸€ä¸ªå®åï¼Œä¹Ÿä¸ä¼šå†å‘ç”ŸåµŒå¥—çš„å®è°ƒç”¨ã€‚

ç”¨ä»¥ä¸‹ä»£ç æ¼”ç¤ºå…¶åŠŸèƒ½ï¼š

```c
#define Connect(x,y)    x##y
#define ToChar(x)       #@x
#define ToString(x)     #x
#define EXP(a,b)  (int)(a##e##b) 

printf("%d\n", EXP(2,3));  // 2e3 è¾“å‡º:2000 
int n = Connect(123,456);           // n = 123456;
char* str = Connect("asdf", "adf"); // str = "asdfadf";
char a = ToChar(1);           // a = '1';
char* str = ToString(123132); // str="123132";
```

ä»¥ä¸Šå®šä¹‰çš„å®ï¼Œä½¿ç”¨ (int)(value) è¿™æ ·çš„æ˜¾å¼ç±»å‹è½¬æ¢å…¼å®¹æ€§æ›´å¥½ï¼Œå¦‚æœä½¿ç”¨ int(value) è¿™æ ·çš„ç±»å‹è½¬æ¢è¡¨è¾¾å¯åœ¨åœ¨ C++ ä¸­é€šè¿‡ï¼Œä½†åœ¨ä¸€äº› C ç¼–è¯‘å™¨ä¸­ä¸èƒ½é€šè¿‡ã€‚

æ³¨æ„ï¼Œå®æ“ä½œè¿™äº›ç‰¹æ®Šçš„å†…ç½®ç¬¦å·æ—¶ï¼Œä¸èƒ½å°†å®ƒä»¬å½“ä½œæ­£å¸¸çš„å­—ç¬¦ä¸²ã€æ•°å€¼å­—é¢é‡ï¼Œè¿™äº›ç¬¦å·åº”è¯¥åœ¨ä»£ç ä¸­åŸæ ·æ˜¾ç¤ºæ‰å…·æœ‰ç›¸åº”æ•ˆæœï¼š

```cpp
// #define ERROR_MSG(msg) (__FILE__ ": "#msg);
// #define ERROR_MSG(msg) (__FILE__ ": "##msg);
// #define BUILD_MSG(l,f,msg)  ("Error: "msg": "f":"+to_string(l)).c_str()
// #define ERROR_MSG(msg) BUILD_MSG(__LINE__,__FILE__,msg);
#define ERROR_MSG(msg) (("Error: "msg": " __FILE__ ":"+to_string(__LINE__)).c_str());

cout << ERROR_MSG("Some error");
```

å¦å¤–ï¼Œ*__LINE__* æœ€ç»ˆä¼šæ˜¯ä¸€ä¸ªæ•°å€¼ï¼Œä¸èƒ½å’Œå…¶å®ƒå­—ç¬¦ä¸²ç›´æ¥è¿›è¡Œè¿æ¥ï¼Œå¦‚ *__FILE__#__LINE__* å°±ä¼šå‡ºç°åº”è¾“å…¥å®å½¢å‚é—®é¢˜ï¼Œå¦‚æœç›´æ¥ç»™ç­‰å·æ‰“åŒå¼•å·å®ƒå°±ä¼šå˜é‡å­—ä¸²å­—é¢é‡ã€‚éœ€è¦é¢å¤–ä½¿ç”¨å‡½æ•°è¿›è¡Œè½¬å‹æ“ä½œï¼Œä»¥ä¸Šä½¿ç”¨äº† C++11 å¼•å…¥çš„ *std::to_string()* å‡½æ•°ã€‚

å®ä¸æ”¯æŒé‡è½½ï¼Œä¹Ÿä¸æ”¯æŒé»˜è®¤å‚æ•°ï¼Œä½†æ˜¯åˆ©ç”¨è¿æ¥å’ŒäºŒæ¬¡å±•å¼€å¯ä»¥å®ç°ç±»ä¼¼ Boost.PP's facilities æä¾›çš„åŠŸèƒ½ï¼Œä»¥ä¸‹æ˜¯åœ¨ ++11 ä¸­é‡è½½å®çš„æ¨¡æ‹Ÿï¼š

```cpp
// https://stackoverflow.com/questions/27049491/
// Can C/C++ preprocessor macros have default parameter values?
#include <iostream>
#include <string>

using namespace std;

#define VARGSN(a, b, c, N, ...) N
#define VARGSP(...) VARGSN(0, ##__VA_ARGS__, 2, 1, 0,)
#define CONCAT_AB(a, b) a##b
#define CONCAT(a, b) CONCAT_AB(a, b)

#define ERROR_MSG_0(...) "Error: default message."
#define ERROR_MSG_1(msg) ("Error: " msg ": " __FILE__ ":"+to_string(__LINE__)).c_str()
#define ERROR_MSG_2(msg, more) (("Error: " msg +to_string(more)+": " __FILE__ ":"+to_string(__LINE__)).c_str())
#define ERROR_MSG(...) CONCAT(ERROR_MSG_, VARGSP(__VA_ARGS__))(__VA_ARGS__)
// ERROR_MSG("some literal string")
// ERROR_MSG("some literal string", and somethin to be to_string)

int main()
{
    // std::cout << ERROR_MSG() << endl; // ERROR_MSG_1
    std::cout << ERROR_MSG("a") << endl; // ERROR_MSG_1
    std::cout << ERROR_MSG("a", 1) << endl; // ERROR_MSG_2
    std::cout << ERROR_MSG(+string("")+"ABC") << endl; // ERROR_MSG_1
}
```

VARGSN ç›®çš„æ˜¯è·å–ç¬¬ N ä¸ªå³ 11th å·å‚æ•°ï¼Œé…åˆ VARGS å°† *__VA_ARGS__* å°†å…¶å®ƒå¯èƒ½ä¼ å…¥çš„å‚æ•°æ¨åˆ°å‚æ•°åˆ—è¡¨ï¼Œè¿«ä½¿åŸæœ‰çš„å‚æ•°ä»å¤§åˆ°å°æŒ‰ä¼ å…¥å‚æ•°ä¸ªæ•°è¿›å…¥ N å·ä½ï¼Œä»è€Œè·å–å‚æ•°ä¸ªæ•°ã€‚æœ‰äº›ç¼–è¯‘å™¨å¹¶ä¸æ”¯æŒ `##__VA_ARGS__` è¿™ç§è¡¨è¾¾ï¼Œæ‰€ä»¥ä¸Šé¢çš„ä¾‹å­æœ‰ä¸ªç¼ºé™·ï¼Œä¸èƒ½å®Œå…¨æ­£ç¡®çš„åœ°è°ƒç”¨ ERROR_MSG_0ã€‚

ä» C++ 11 å¼€å§‹ï¼Œå®å‡½æ•°æ”¯æŒäº†å˜é•¿å‚æ•° `...`ï¼Œæ¥å—ä»»æ„ä¸ªç”¨é€—å·åˆ†éš”çš„å®å‚æ•°ï¼š

- ä¼ å…¥çš„å˜é•¿å‚æ•°å¯ä»¥ç”¨ `__VA_ARGS__` è·å–ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ `#__VA_ARGS__` è·å–â€œé€—å·+ç©ºæ ¼åˆ†éš”â€çš„å‚æ•°å­—é¢é‡ã€‚
- å¦å¤–ï¼Œå…è®¸ä¼ é€’ç©ºå‚æ•°ï¼Œå³ `##__VA_ARGS__` æ›¿æ¢ä¸ºç©ºå†…å®¹ï¼Œåœ¨æœ‰äº›ç¼–è¯‘å™¨ä¸­å¯ä»¥å°†å…¶å‰å¯¼çš„é€—å·ä¸¢å¼ƒã€‚

```cpp
#define showlist(...) puts(#__VA_ARGS__)
showlist();            // expands to puts("")
showlist(1, "x", int); // expands to puts("1, \"x\", int")
```

å¯¹äºç©ºå‚æ•°ï¼Œå±•å¼€æ—¶éœ€è¦å¤„ç†å¤šä½™é€—å·çš„é—®é¢˜ï¼š

```cpp
#define log(format, ...) printf("LOG: " format, __VA_ARGS__)

log("%d%f", 1, .2);    // -> printf("LOG: %d%f", 1, .2);
log("hello world");    // -> printf("LOG: hello world", );
log("hello world", );  // -> printf("LOG: hello world", );
```

åä¸¤ç§è°ƒç”¨åˆ†åˆ«å¯¹åº”ä¸ä¼ å˜é•¿å‚æ•°ã€å˜é•¿å‚æ•°ä¸ºç©ºçš„æƒ…å†µã€‚å±•å¼€ç»“æœä¼šå¤šå‡ºä¸€ä¸ªé€—å·ï¼Œå¯¼è‡´ C/C++ ç¼–è¯‘é”™è¯¯ï¼ˆä¸æ˜¯å®å±•å¼€é”™è¯¯ï¼‰ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä¸€äº›ç¼–è¯‘å™¨ï¼ˆä¾‹å¦‚ gcc/clangï¼‰æ‰©å±•äº† `## __VA_ARGS__` çš„ç”¨æ³•ï¼Œå¦‚æœä¸ä¼ å˜é•¿å‚æ•°ï¼Œåˆ™çœç•¥å‰é¢çš„é€—å·ï¼š

```cpp
#define log(format, ...) printf("LOG: " format, ## __VA_ARGS__)

log("%d%f", 1, .2);    // -> printf("LOG: %d%f", 1, .2);
log("hello world");    // -> printf("LOG: hello world");
log("hello world", );  // -> printf("LOG: hello world", );
```


ä¸ºäº†è¿›ä¸€æ­¥å¤„ç† å˜é•¿å‚æ•°ä¸ºç©º çš„æƒ…å†µï¼ŒC++ 20 å¼•å…¥äº† `__VA_OPT__` æ ‡è¯†ç¬¦ï¼Œå¦‚æœå˜é•¿å‚æ•°æ˜¯ç©ºå‚æ•°ï¼Œä¸å±•å¼€è¯¥ç¬¦å·ï¼ˆä¸ä»…é™äºé€—å·ï¼‰ï¼š

```cpp
#define log(format, ...) printf("LOG: " format __VA_OPT__(,) __VA_ARGS__)

log("%d%f", 1, .2);    // -> printf("LOG: %d%f", 1, .2);
log("hello world");    // -> printf("LOG: hello world");
log("hello world", );  // -> printf("LOG: hello world");
```


å®å®šä¹‰ä¸­å…è®¸åŒ…å«å¤šè¡Œå†…å®¹ï¼Œæ­¤æ—¶å¿…é¡»åœ¨è¡Œæœ«ï¼Œå³æœ€å³è¾¹åŠ ä¸Š `\` è½¬ä¹‰æ‰æ¢è¡Œç¬¦å³å¯ï¼Œæ³¨æ„åé¢ä¸èƒ½å†æœ‰å…¶å®ƒå†…å®¹ï¼Œå¦åˆ™å°±ä¸æ˜¯è½¬ä¹‰æ¢è¡Œç¬¦ã€‚

    #define MALLOC(n, type) \
        ((type *) malloc((n)* sizeof(type)

    int *ptr;
    ptr = MALLOC( 5, int );

åˆ©ç”¨ç¬¦å·å®šä¹‰é˜²æ­¢ä¸€ä¸ªå¤´æ–‡ä»¶è¢«é‡å¤åŒ…å« 

    #ifndef BODYDEF_H 
    #define BODYDEF_H 

    // ... 

    #endif



### ===ğŸ‘‰ macro å®ç¼–ç¨‹
- C/C++ å®ç¼–ç¨‹çš„è‰ºæœ¯ https://zhuanlan.zhihu.com/p/152354031
- Compiler Explorer https://godbolt.org/z/3a8Txc
- Macros https://gcc.gnu.org/onlinedocs/cpp/Macros.html

å®ç¼–ç¨‹æ— æ³•è°ƒè¯•ï¼Œè€Œç›´æ¥å¯¼è‡´éš¾åº¦å¢åŠ ï¼Œä¸ç»æ„çš„ç¬¦å·æ‹¼å†™é”™è¯¯ã€å‚æ•°ä¸ªæ•°é”™è¯¯ï¼Œå¯¼è‡´æ–‡æœ¬ä¸èƒ½æ­£ç¡®æ›¿æ¢ï¼Œä»è€Œå¸¦æ¥ æ»¡å±çš„ç¼–è¯‘é”™è¯¯ï¼Œéš¾ä»¥å®šä½é—®é¢˜æ‰€åœ¨ã€‚

ç”±äºå®ä»£ç ä¼š åœ¨ç¼–è¯‘å‰å…¨éƒ¨å±•å¼€ï¼Œå¯ä»¥è®©ç¼–è¯‘å™¨ä»…è¾“å‡ºé¢„å¤„ç†ç»“æœï¼š

- gcc -E è®©ç¼–è¯‘å™¨åœ¨é¢„å¤„ç†ç»“æŸååœæ­¢ï¼Œä¸è¿›è¡Œ ç¼–è¯‘ã€é“¾æ¥
- gcc -P å±è”½ç¼–è¯‘å™¨è¾“å‡ºé¢„å¤„ç†ç»“æœçš„è¡Œæ ‡è®° (linemarker)ï¼Œå‡å°‘å¹²æ‰°

å¦å¤–ï¼Œç”±äºè¾“å‡ºç»“æœæ²¡æœ‰æ ¼å¼åŒ–ï¼Œå»ºè®®ä½¿ç”¨ clang-format å·¥å…·æ ¼å¼åŒ–è¾“å‡ºã€‚ä»¥åŠå±è”½æ— å…³çš„å¤´æ–‡ä»¶ï¼Œä¸´æ—¶åˆ æ‰ ä¸å½±å“å®å±•å¼€çš„ #include è¡Œã€‚

å‚è€ƒ PyBind11 åº“çš„å®ç°ï¼Œå®ƒå°±æ˜¯å®ç¼–ç¨‹çš„ä¸€ç§åº”ç”¨ã€‚


#### â¡ ç‰¹æ®Šç¬¦å·

å’Œæ¨¡æ¿å…ƒç¼–ç¨‹ä¸ä¸€æ ·ï¼Œå®ç¼–ç¨‹æ²¡æœ‰ç±»å‹çš„æ¦‚å¿µï¼Œè¾“å…¥å’Œè¾“å‡ºéƒ½æ˜¯ç¬¦å·ï¼Œä¸æ¶‰åŠç¼–è¯‘ C++ çš„è¯­æ³•ï¼Œåªè¿›è¡Œç¼–è¯‘å‰çš„æ–‡æœ¬æ›¿æ¢ï¼š

- ä¸€ä¸ªå®å‚æ•°æ˜¯ä¸€ä¸ªä»»æ„çš„ç¬¦å·åºåˆ— (token sequence)ï¼Œä¸åŒå®å‚æ•°ä¹‹é—´ç”¨é€—å·åˆ†éš”ï¼›
- æ¯ä¸ªå‚æ•°å¯ä»¥æ˜¯ç©ºåºåˆ—ï¼Œä¸”ç©ºç™½å­—ç¬¦ä¼šè¢«å¿½ç•¥ï¼Œä¾‹å¦‚ a + 1 å’Œ a+1 ç›¸åŒï¼›
- åœ¨ä¸€ä¸ªå‚æ•°å†…ï¼Œä¸èƒ½å‡ºç°é€—å· (comma) æˆ–ä¸é…å¯¹çš„æ‹¬å· (parenthesis)ï¼›

ä¾‹å¦‚ FOO(bool, std::pair<int, int>) è¡¨ç¤º FOO() æœ‰ä¸‰ä¸ªå‚æ•°ï¼šbool / std::pair<int / int>

è¦æŠŠ std::pair<int, int> ä½œä¸ºä¸€ä¸ªå‚æ•°ï¼Œä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ C++ çš„ç±»å‹åˆ«å (type alias) é¿å… å‚æ•°ä¸­å‡ºç°é€—å·ã€‚ä¾‹å¦‚å®šä¹‰åˆ«å using IntPair = std::pair<int, int>; å°±å¯ä»¥ä½¿ç”¨ FOO(bool, IntPair)ã€‚

æ›´é€šç”¨çš„æ–¹æ³•æ˜¯ä½¿ç”¨æ‹¬å·å¯¹å°è£…æ¯ä¸ªå‚æ•°ï¼Œç§°ä¸ºå…ƒç»„ï¼Œå¹¶é€šè¿‡å˜é•¿å‚æ•° __VA_ARGS__ åœ¨æœ€ç»ˆå±•å¼€æ—¶ç§»é™¤æ‹¬å·ï¼Œå®Œæˆå…ƒç»„è§£åŒ…ï¼š

```c
#define PP_REMOVE_PARENS(T) PP_REMOVE_PARENS_IMPL T
#define PP_REMOVE_PARENS_IMPL(...) __VA_ARGS__

#define FOO(A, B) int foo(A x, B y)
#define BAR(A, B) FOO(PP_REMOVE_PARENS(A), PP_REMOVE_PARENS(B))

FOO(bool, IntPair)                  // -> int foo(bool x, IntPair y)
BAR((bool), (std::pair<int, int>))  // -> int foo(bool x, std::pair<int, int> y)
```

ä»£æ›¿ç‰¹æ®Šç¬¦å·çš„å¸¸ç”¨å®å‡½æ•°ï¼Œç”¨äºæƒ°æ€§æ±‚å€¼ï¼š

    #define PP_COMMA() ,
    #define PP_LPAREN() (
    #define PP_RPAREN() )
    #define PP_EMPTY()

    #define PP_STRING(A) #A


#### â¡ ç¬¦å·äºŒæ¬¡å±•å¼€

è°ƒç”¨å®å®šä¹‰éœ€è¦åç¼€åœ†æ‹¬å·ï¼Œå®å‚æ•°ä¸­çš„ç¬¦å·ä¸ç°æœ‰å®åŒ¹é…æ—¶å¹¶ä¸å±•å¼€ï¼Œåªæœ‰å®å†…å®¹ä¸­å‡ºç°åŒ¹é…çš„å†…å®¹æ‰ä¼šåµŒå¥—å±•å¼€å®å®šä¹‰ï¼ŒåŒºåˆ†å¤§å°å†™ã€‚

æ‹¼æ¥æ ‡è¯†ç¬¦ (identifier concatenation / token pasting) é€šè¿‡ ## å°†å®å‡½æ•°çš„å‚æ•°æ‹¼æ¥æˆå…¶ä»–ç¬¦å·ï¼Œå†è¿›ä¸€æ­¥ å±•å¼€ä¸ºç›®æ ‡ç»“æœï¼Œæ˜¯å®ç¼–ç¨‹çš„å®ç°åŸºç¡€ï¼Œä½†æ˜¯è¢«æ‹¼æ¥çš„ä¸¤ä¸ªç¬¦å·å¹¶ä¸ä¼šå•ç‹¬å±•å¼€ã€‚

```c
#define FOO(SYMBOL) foo_ ## SYMBOL()
#define BAR() bar
#define foo_bar() fun

FOO(bar())       // -> fun()
FOO(BAR){ abc }  // -> foo_BAR(){ abc }
```

ä¸€ç§é€šç”¨çš„æ–¹æ³•æ˜¯å»¶è¿Ÿæ‹¼æ¥æ“ä½œï¼š

```c
#define BAR() bar
#define PP_CONCAT(A, B) PP_CONCAT_IMPL(A, B)
#define PP_CONCAT_IMPL(A, B) A##B

#define FOO(N) PP_CONCAT(foo_, N)

FOO(bar)    // -> foo_bar
FOO(BAR())  // -> foo_bar
```

è°ƒç”¨å®ï¼Œåœ¨å±•å¼€å®å†…å®¹ä¹‹å‰ï¼Œæ‰€æœ‰å®å‚æ•°ä¼šå…ˆè¿›è¡Œä¸€æ¬¡é¢„æ‰«æï¼Œå®Œå…¨å±•å¼€æœªç”¨äºæ‹¼æ¥çš„æ ‡è¯†ç¬¦æˆ–è·å–å­—é¢é‡çš„æ‰€æœ‰å‚æ•°ï¼Œ*BAR()* ä¼šåœ¨è°ƒç”¨ *PP_CONCAT* å®ä¹‹å‰å±•å¼€ä¸º bar å†è¿›å…¥ä¸‹ä¸€æ­¥ã€‚

é¢„æ‰«æ (Argument Prescan)å³å®å‚æ•°åœ¨è¢«æ›¿æ¢åˆ°å®ä¸»ä½“ä¹‹å‰ä¼šå…ˆè¢«å®Œå…¨æ‰©å±•ï¼Œé™¤éå®ƒä»¬è¢« # å­—ç¬¦ä¸²åŒ–æˆ– ## ä¸å…¶ä»–æ ‡è®°ä¸€èµ·ç²˜è´´ã€‚æ›¿æ¢åï¼Œå°†å†æ¬¡æ‰«ææ•´ä¸ªå®ä½“ï¼ŒåŒ…æ‹¬è¢«æ›¿æ¢çš„å‚æ•°ï¼Œä»¥æŸ¥æ‰¾è¦æ‰©å±•çš„å®ï¼Œç»“æœæ˜¯å‚æ•°è¢«æ‰«æä¸¤æ¬¡ä»¥æ‰©å±•å…¶ä¸­çš„å®è°ƒç”¨ã€‚

å¦å¤–ï¼Œå®å‡½æ•°è¦æ±‚å‚æ•°ä¸ªæ•°å¿…é¡»åŒ¹é…ï¼Œå¹¶ä¸”å®åä¸èƒ½åœ¨å¼•å·å†…ï¼Œå¦åˆ™æ— æ³•å±•å¼€ï¼š

    PP_CONCAT(x PP_COMMA() y)  // too few arguments (before prescan)
    PP_CONCAT(x, PP_COMMA())   // too many arguments (after prescan)



#### â¡ è‡ªå¢è‡ªå‡

å€ŸåŠ©å®çš„åµŒå¥—å±•å¼€å¯ä»¥å®ç°éè´Ÿæ•´æ•°å¢å‡ï¼Œå³ INC(N) = N + 1 æˆ– DEC(N) = N - 1ï¼š

    #define PP_INC(N) PP_CONCAT(PP_INC_, N)
    #define PP_INC_0 1
    #define PP_INC_1 2
    // ...
    #define PP_INC_254 255
    #define PP_INC_255 256

    #define PP_DEC(N) PP_CONCAT(PP_DEC_, N)
    #define PP_DEC_256 255
    #define PP_DEC_255 254
    // ...
    #define PP_DEC_2 1
    #define PP_DEC_1 0

    PP_INC(1)    // -> 2
    PP_DEC(2)    // -> 1
    PP_INC(256)  // -> PP_INC_256 (overflow)
    PP_DEC(0)    // -> PP_DEC_0  (underflow)

å±•å¼€è¿‡ç¨‹ç¤ºæ„ï¼š

- PP_INC(N) -> PP_INC_N -> N + 1
- PP_DEC(N) -> PP_DEC_N -> N - 1

å› ä¸ºéœ€è¦å®šä¹‰å„ä¸ªå€¼ï¼Œä¸Šè¿°æ“ä½œæœ‰ä¸Šé™ï¼Œè‹¥è¶…å‡ºåˆ™æ— æ³•ç»§ç»­å±•å¼€ï¼ŒBOOST_PP æ•°å€¼æ“ä½œçš„ä¸Šé™æ˜¯ 256ã€‚


#### â¡ é€»è¾‘è¿ç®—

å€ŸåŠ© PP_CONCAT() å¯ä»¥å®ç°å¸ƒå°”ç±»å‹ï¼ˆ0 å’Œ 1ï¼‰çš„é€»è¾‘è¿ç®—ï¼ˆä¸/æˆ–/é/å¼‚æˆ–/åŒæˆ–ï¼‰ï¼š

    #define PP_NOT(N) PP_CONCAT(PP_NOT_, N)
    #define PP_NOT_0 1
    #define PP_NOT_1 0

    #define PP_AND(A, B) PP_CONCAT(PP_AND_, PP_CONCAT(A, B))
    #define PP_AND_00 0
    #define PP_AND_01 0
    #define PP_AND_10 0
    #define PP_AND_11 1

    PP_AND(PP_NOT(0), 1)  // -> 1
    PP_AND(PP_NOT(2), 0)  // -> PP_AND_PP_NOT_20

åŸç†æ˜¯ç¬¦å·æ‹¼æ¥ + äºŒæ¬¡å±•å¼€ï¼Œä½†ä¸Šè¿°æ“ä½œä»…æ”¯æŒ 0 å’Œ 1ï¼Œä¸èƒ½æ”¯æŒéè´Ÿæ•´æ•°çš„é€šç”¨é€»è¾‘è¿ç®—ï¼Œå¦‚æœé€šè¿‡å®šä¹‰ PP_NOT_N æ¥æ”¯æŒ PP_NOT(N)ï¼Œå®ä»£ç ä¼šæ€¥å‰§è†¨èƒ€ï¼š

- ä¸€å…ƒè¿ç®— PP_NOT() éœ€è¦è€ƒè™‘ N ç§ç»„åˆ
- äºŒå…ƒè¿ç®— PP_AND() åˆ™è¦è€ƒè™‘ N^2 ç§ç»„åˆ


#### â¡ å…¶å®ƒ

å¾—åˆ°æŒ‡å®šåœ°å€ä¸Šçš„ä¸€ä¸ªå­—èŠ‚æˆ–å­—
 
    #define MEM_B( x ) ( *( (byte *) (x) ) ) 
    #define MEM_W( x ) ( *( (word *) (x) ) )

å¾—åˆ°ä¸€ä¸ªå˜é‡çš„åœ°å€ï¼Œbyte æˆ– word å®½åº¦ 

    #define B_PTR( var ) ( (byte *) (void *) &(var) ) 
    #define W_PTR( var ) ( (word *) (void *) &(var) )

å¾—åˆ°ç»“æ„ä½“ struct ä¸­å­—æ®µçš„åç§»é‡ï¼Œè¿™é‡Œä½¿ç”¨äº† 0 åœ°å€çš„æŒ‡é’ˆï¼š

    #define OFFSETOF( type, field ) ( (size_t) &(( type *) 0)-> field )

å¾—åˆ°ç»“æ„ä½“ä¸­ä¸€ä¸ª field æ‰€å ç”¨çš„å­—èŠ‚æ•° 

    #define FSIZ( type, field ) sizeof( ((type *) 0)->field )

å°†ä¸€ä¸ªå­—æ¯è½¬æ¢ä¸ºå¤§å†™æˆ–å¤§å°å†™åˆ¤æ–­ï¼š

```cpp
#define UPCASE( c ) ( ((c) >= "a" && (c) <= "z") ? ((c) - 0x20) : (c) )
#define IS_UPPER(x) (x >= 'A' && x <= 'Z')
#define IS_LOWER(x) (x >= 'a' && x <= 'z')
```

åˆ¤æ–­å­—ç¬¦æ˜¯ä¸æ˜¯ 10 è¿›å€¼çš„æ•°å­—

    #define DECCHK( c ) ((c) >= "0" && (c) <= "9")

åˆ¤æ–­å­—ç¬¦æ˜¯ä¸æ˜¯ 16 è¿›å€¼çš„æ•°å­— 

    #define HEXCHK( c ) ( ((c) >= "0" && (c) <= "9") ||((c) >= "A" && (c) <= "F") ||((c) >= "a" && (c) <= "f") )

é˜²æ­¢æº¢å‡ºçš„ä¸€ä¸ªæ–¹æ³•

    #define INC_SAT( val ) (val = ((val)+1 > (val)) ? (val)+1 : (val))

è¿”å›æ•°ç»„å…ƒç´ çš„ä¸ªæ•° 

    #define ARR_SIZE( a ) ( sizeof( (a) ) / sizeof( (a[0]) ) )

åˆ¤æ–­æœºå™¨ç¼–ç å¤§å°å°¾æ–¹å¼ Big-endian/Little-endian

    #define LITTLE_ENDIAN ((char)(0x30313233)) == '3'

    #if (('1234' >> 24) == '1')
      #define BIG_ENDIAN 0
    #elif (('4321' >> 24) == '1')
      #define BIG_ENDIAN 1
    #else
      #error "Couldn't determine the endianness!"
    #endif

ä¸¤ç§å­—èŠ‚å­˜å‚¨é¡ºåºä¸ºå¤§ç«¯åºå’Œå°ç«¯åº Big-Endian å’Œ Little-Endianï¼Œå­—èŠ‚åºåªé’ˆå¯¹äºå¤šå­—èŠ‚ç±»å‹çš„æ•°æ®å¤„ç†ã€‚

åœ¨ä¹¦å†™ä¹ æƒ¯ä¸Šï¼Œé«˜ä½çš„å­—èŠ‚å†™åœ¨å·¦ä¾§ï¼Œæ¯”å¦‚ int æ•´æ•° 0x12345678ï¼Œå®ƒå æœ‰ 4 ä¸ªå­—èŠ‚çš„å­˜å‚¨ç©ºé—´ï¼Œæœ€é«˜å­—èŠ‚çš„å€¼ä¸º 0x12ï¼š

- 0x12 0x34 0x56 0x78 Little-Endian é«˜ä½å­˜äºä½åœ°å€ç«¯ï¼Œä½ä½å­—èŠ‚æ’æ”¾åœ¨å†…å­˜çš„é«˜åœ°å€ç«¯ï¼›
- 0x78 0x56 0x34 0x12 Big-Endian ä½ä½å­˜äºä½åœ°å€ç«¯ï¼Œé«˜ä½å­—èŠ‚æ’æ”¾åœ¨å†…å­˜çš„é«˜åœ°å€ç«¯ã€‚

- Big-endian çš„å†…å­˜é¡ºåºå’Œæ•°å­—çš„ä¹¦å†™é¡ºåºæ˜¯ä¸€è‡´çš„ï¼Œæ–¹ä¾¿é˜…è¯»ç†è§£ã€‚
- Little-endian åœ¨å˜é‡æŒ‡é’ˆè½¬æ¢çš„æ—¶å€™åœ°å€ä¿æŒä¸å˜ï¼Œæ¯”å¦‚ int64* è½¬åˆ° int32*

è·å–æœ€å¤§ã€æœ€å°å€¼

```cpp
#define MAX(a, b)    (((a) > (b)) ? (a) : (b))
#define MIN(a, b)    (((a) < (b)) ? (a) : (b))
```

è®¡ç®—æ•°ç»„ä¸­çš„å…ƒç´ ä¸ªæ•°

```cpp
#define ARRAY_SIZE(x)    (sizeof(x) / sizeof((x)[0]))
```

ä½æ“ä½œ

```cpp
#define BIT_MASK(x)         (1 << (x))
#define BIT_GET(x, y)       (((x) >> (y)) & 0x01u)
#define BIT_SET(x, y)       ((x) | (1 << (y)))
#define BIT_CLR(x, y)       ((x) & (~(1 << (y))))
#define BIT_INVERT(x, y)    ((x) ^ (1 << (y)))
```


### ===ğŸ‘‰ Preprocessor C/C++ è¯­è¨€é¢„å¤„ç†å™¨
1. https://en.cppreference.com/w/c/preprocessor
2. https://en.cppreference.com/w/cpp/preprocessor
3. https://en.cppreference.com/w/c/language/translation_phases
3. https://en.cppreference.com/w/cpp/language/translation_phases

é¢„å¤„ç†å™¨ preprocessor ä¼šåœ¨ç¼–è¯‘å™¨ç”Ÿæˆæœºå™¨ç å‰å¯¹æºä»£ç æ–‡ä»¶è¿›è¡Œå¿…è¦çš„æ›¿æ¢ï¼Œæˆ–æ ¹æ®æ¡ä»¶ç¼–è¯‘ä»£ç ï¼Œä¹Ÿå¯ä»¥é€šè¿‡é¢„å¤„ç†æŒ‡ä»¤ä¸ç¼–è¯‘å™¨è¿›è¡Œäº¤äº’ã€‚é¢„ç®—å¤§æ¦‚åˆ†ä¸ºæ¡ä»¶ç¼–è¯‘ï¼Œå­—ç¬¦æ›¿æ¢å³å®å®šä¹‰ï¼Œå¤´æ–‡ä»¶åŒ…å«ï¼Œå…¶å®ƒæ‰©å±•åŠŸèƒ½ã€‚åŒ…å«å¤´æ–‡ä»¶æœ‰ç®­æ‹¬å·å’ŒåŒå¼•å·ä¸¤ç§è¡¨è¾¾ï¼Œç®­æ‹¬å·è¡¨ç¤ºåœ¨æ ‡å‡†åº“ä¸­åŠ è½½ï¼ŒåŒå¼•å·è¡¨ç¤ºå…ˆåœ¨å½“å‰æ–‡ä»¶æ‰€åœ¨ç›®å½•æŸ¥æ‰¾ï¼Œæ²¡æœ‰æ‰¾åˆ°å†ä»æ ‡å‡†åº“ä¸­åŠ è½½ã€‚

    (1) #ifdef identifier is essentially equivalent to #if defined(identifier)
    (2) #ifndef identifier is essentially equivalent to #if !defined(identifier)
    (3) #if expression
    (4) #elif expression
    (5) #else
    (6) #endif

    (1) #define identifier replacement-list(optional)
    (2) #define identifier( parameters ) replacement-list
    (3) #define identifier( parameters, ... ) replacement-list (since C++11)
    (4) #define identifier( ... ) replacement-list (since C++11)
    (5) #undef  identifier

    (1) #include <standar_header>
    (2) #include "non_standar_headr"
    (3) __has_include ( " filename " ) (use with #if, since C++17) 
    (4) __has_include ( < filename > ) (use with #if, since C++17) 

 é™¤äº†ä»¥ä¸Šé¢„å¤„ç†åŠŸèƒ½ï¼Œè¿˜æœ‰ä¸€äº›ç‰¹æ®Šçš„é¢„å¤„ç†æŒ‡ä»¤ï¼Œå¦‚æ–‡ä»¶è¡Œå·ä¿¡æ¯ï¼Œä»¥åŠä¸€äº›é¢„å®šä¹‰å¸¸é‡å¦‚ç¼–è¯‘å™¨ç‰ˆæœ¬ __cplusplusï¼Œæ–‡ä»¶å __LINE__ï¼Œå‡½æ•°å __func__ï¼Œè¡Œå·ç­‰ __LINE__ï¼š

    # åŒå¼•å·åŒ–è½¬æ¢ï¼Œç”¨åœ¨å‡½æ•°å¼å®å®šä¹‰ï¼Œä½¿ç”¨#å·å°†å®å‚æ•°è½¬æ¢æˆåŒå¼•å·åŒ…æ‹¬çš„å­—ç¬¦ä¸²
    ## æ ‡è¯†ç¬¦æ‹¼æ¥ï¼Œåœ¨å‡½æ•°å¼å®å®šä¹‰ä¸­ä½¿ç”¨##å·å°†å®å‚æ•°æ‹¼æ¥åˆ°ä¸€ä¸ªTokenåå½¢æˆå®Œæ•´çš„æ ‡è¯†ç¬¦
    #error é¢„å¤„ç†æŒ‡ä»¤äº§ç”Ÿç¼–è¯‘é”™è¯¯å¹¶ç»ˆæ­¢å½“å‰çš„ç¼–è¯‘ã€‚
    #warning which emits a user-defined message during compilation.
    #pragma pragma_params
    #pragma once éæ ‡å‡† Non-standard pragmas
    _Pragma ( string-literal ) (since C99/C++11) 
    #line lineno  
    #line lineno "filename"

é¢„å¤„ç†åŠŸèƒ½ç¤ºä¾‹

```c
#include <iostream>

using namespace std;

//å®å‘½ä»¤ä¸­ä½¿ç”¨#å¯ä»¥å®ç°æ›¿æ¢å­—ç¬¦ä¸²åŒ–ï¼ŒCè¯­è¨€çš„å­—ç¬¦ä¸²æ˜¯è‡ªåŠ¨æ‹¼æ¥çš„ï¼š"A" "B" = "AB"
#define log(title, var) std::cout << #title << var << std::endl; // # - encloses the result in quotes
#define call(prefix) std::cout << call_##prefix() << std::endl; // ## - Token pasting
char * call_test(){ return (char*)"Macro ## operator demo..."; }
// call(test);  // expands to call_test()

#if __cplusplus < 201103L
    // #error ISO C++ 2011 standard required, so enabled this with the -std=C++11 or -std=gnu++11 compiler options.
    // #pragma message "C++11 standard required ..."
    // #warning C++11 standard required...
#else
    #define __CPP11__
    #define showlist(...) std::cout << " __VA_ARGS__ for " #__VA_ARGS__ << std::endl; // __VA_ARGS__ for C++11 variadic macro
    // showlist();            // expands to puts("")
    // showlist(1, "x", int); // expands to puts("1, \"x\", int")
#endif

// æ–­è¨€(assertion)ä¸»è¦ç”¨äºè°ƒè¯•ä¸­ï¼Œåœ¨ç¨‹åºå‘å¸ƒæ—¶ç¦ç”¨æ–­è¨€ï¼Œé¿å…ç¨‹åºéæ­£å¸¸é€€å‡ºï¼Œåœ¨å¼•å…¥æ–­è¨€å‰é€šè¿‡ #define æˆ– #undef NDEBUG å¼€å…³æ–­è¨€æœºåˆ¶ï¼Œæˆ–æ‰“å¼€ç¼–è¯‘é€‰é¡¹ -DNDEBUGã€‚
// #define NDEBUG
#include <cassert>

// #ifdef NDEBUG
//  #define assert(x)   ((void)0)
// #else
//  #define assert(e)   ((e) ? (void)0 : _assert(#e, __FILE__, __LINE__))
// #endif

int main(int argc, char* argv[])
{
    assert(__cplusplus==1997L);
    // static_assert(1==2, "C++11 static_assert test");

    #ifdef __CPP11__
        log(New Features C++11, "");
        log(__STDC_UTF_16__ (C11):, __STDC_UTF_16__);   //expands to 1 if char16_t use UTF-16 encoding
        log(__STDC_UTF_32__ (C11):, __STDC_UTF_32__);   //expands to 1 if char32_t use UTF-32 encoding
        showlist(C++11, variadic, macro);
    #endif

    log(Standard Macro Constant, "");
    log(__cplusplus:, __cplusplus); // denotes the version of C++, 199711L(until C++11), 201103L(C++11), 201402L(C++14), or 201703L(C++17)

    #line 123 "custome_lineno_and_FILE.c"
    log(__func__:, __func__);
    log(__FILE__:, __FILE__);
    log(__LINE__:, __LINE__);
    log(__DATE__:, __DATE__); // form "Mar 15 2019", The name of the month is as if generated by asctime and the day "dd" is  1-31.
    log(__TIME__:, __TIME__); // form "hh:mm:ss", as in the time generated by asctime()
    return 0;
}
```


## ==âš¡ ch2 - Types, Operators and Expressions
- Type support https://en.cppreference.com/w/c/types
- Fixed width integer types (since C99) https://en.cppreference.com/w/c/types/integer
- Enumerate https://en.cppreference.com/w/c/language/enum

### ===ğŸ‘‰ Basic Types

C è¯­è¨€æä¾›äº†æœ€åŸºæœ¬çš„æ•°æ®ç±»å‹ï¼Œåªæœ‰ 4 ç§ï¼š

- `char`    a single byte, capable of holding one character in the local character set 
- `int`     an integer, typically reflecting the natural size of integers on the host machine 
- `float`   single-precision floating point 
- `double`  double-precision floating point 

```c
printf("char: %ld\n", sizeof (char));          // char: 1
printf("int: %ld\n", sizeof (int));            // int: 4
printf("long int: %ld\n", sizeof (long int));  // long int: 8
printf("float: %ld\n", sizeof (float));        // float: 4
printf("double: %ld\n", sizeof (double));      // double: 8
```

å¦å¤–è¿˜æœ‰ç”¨æˆ·å®šä¹‰çš„ç»„åˆç±»å‹ï¼š

- struct ç»“æ„ä½“ç±»å‹
- union è”åˆä½“ç±»å‹
- enum æšä¸¾ç±»å‹

```c
enum Color { RED=1, GREEN, BLUE } c = RED, *cp = &c;
// introduces the type enum Color
// the integer constants RED, GREEN, BLUE
// the object c of type enum Color
// the object cp of type pointer to enum Color
enum Color green = GREEN; // OK
```

æšä¸¾ç±»å‹çš„ç¬¬ä¸€ä¸ªæˆå‘˜é»˜è®¤å€¼ä¸º 0ï¼Œåé¢çš„ä¾æ¬¡åŠ  1ï¼Œå¯ä»¥æ˜¾å¼æŒ‡å®šä¸€ä¸ªæ•´æ•°å€¼ã€‚

å†æœ‰å°±æ˜¯è¡ç”Ÿå‡ºæ¥çš„ç±»å‹ Derived typesï¼š

- arrays of objects of a given type;
- functions returning objects of a given type;
- pointers to objects of a given type;
- structures containing a sequence of objects of various types;
- unions capable of containing any of one of several objects of various types. 

ä½œä¸ºè¡¥å……ï¼ŒC è¯­è¨€æä¾›äº†ç±»å‹ä¿®é¥°ï¼Œä½¿ç”¨ `signed` `unsigned` ä¿®é¥°å­—ç¬¦æˆ–æ•´å½¢çš„ç¬¦å·ä½ï¼Œæ— ç¬¦å·è¡¨ç¤ºæœ€é«˜ bit ä½œä¸ºæ•°å€¼è€Œä¸æ˜¯ç¬¦å·ä½ä½¿ç”¨ï¼Œä¾‹å¦‚ `char` ä¸€ä¸ªå­—èŠ‚å†…çš„ 256 ä¸ªçŠ¶æ€è¡¨ç¤ºæ•°å€¼èŒƒå›´ -128 ~ 127ï¼Œè€Œä½œä¸ºæ— ç¬¦å·æ•°ï¼Œç¬¦å·ä½ä¹Ÿå‚ä¸è®¡æ•°ï¼Œå°±å¯ä»¥è¡¨ç¤ºå¤§ä¸€å€çš„æ­£æ•´æ•° 0 ~ 256ã€‚

æµ®ç‚¹æ•°ç‰¹æ®Šï¼Œåœ¨ CPU å†…éƒ¨ä½¿ç”¨ä¸“ç”¨çš„ FPU æµ®ç‚¹å¤„ç†å™¨è®¡ç®—ï¼Œå¹¶ä¸”æ€»æ˜¯å¸¦ç¬¦å·çš„æ•°å€¼ã€‚

æ•´å½¢ä¿®é¥°ç¬¦å·æœ‰ `short` `long` ä¸¤ä¸ªï¼Œä½¿ç”¨ä¿®é¥°ç¬¦å·æ—¶ï¼Œå…³é”®å­— `int` å¯ä»¥çœç•¥ä¸å†™ï¼Œä¾‹å¦‚ `long int` è¡¨ç¤º `long`ï¼Œå¦‚æœä¸äº†è§£è¿™çœç•¥çš„å…³é”®å­—å°±ä¼šè§‰å¾—å®ƒä»¬å…³ç³»å¥‡æ€ªã€‚

ä½†æ˜¯ `int` å’Œ `long` çš„å…³ç³»ç¡®å®æœ‰ç‚¹ç‰¹åˆ«ï¼ŒC è¯­è¨€è§„å®š `long` å ç”¨çš„å­—èŠ‚æ•°ä¸å°äº `int`ï¼š

- 16-bit CPU ç³»ç»Ÿä¸Šï¼Œ`long` æ˜¯ 16-bitï¼Œint æ˜¯ 16-bit
- 32-bit CPU ç³»ç»Ÿä¸Šï¼Œ`long` æ˜¯ 32-bitï¼Œint æ˜¯ 32-bit
- 64-bit CPU ç³»ç»Ÿä¸Šï¼Œ`long` æ˜¯ 64-bitï¼Œint æ˜¯ 32-bit

æ­¤å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªç‰¹æ®Šçš„ `void` å…³é”®å­—ï¼Œè¡¨ç¤ºæ²¡æœ‰ä»»ä½•å…·ä½“ç±»å‹ï¼Œé€šå¸¸ç”¨åœ¨å‚æ•°åˆ—è¡¨ã€ä¿®é¥°å‡½æ•°è¿”å›çŠ¶æ€ï¼Œè¡¨ç¤ºæ²¡æœ‰å‚æ•°ï¼Œæ²¡æœ‰è¿”å›å€¼ã€‚

```c
// exit function do not return a value are declared as void.
void exit (int status);

// explicitly discard the value of an expression. For example: 
(void)printf("An example.");

// have no parameters 
int rand(void);

// Pointers to void 
void *memcpy(void *dest, void *source, size_t count);
```

ä½¿ç”¨ `typedef` å…³é”®å­—å¯ä»¥å®šä¹‰ç±»å‹åˆ«åï¼Œå‚è€ƒ C99 è§„èŒƒæä¾›çš„ä¸¤ä¸ªå¤´æ–‡ä»¶ï¼š

- `<inttypes.h>` Format conversion of integer types
- `<stdint.h>` Fixed width integer types

```c
typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;
```

å¦å¤–ï¼Œç°è¡Œçš„ C99 è§„èŒƒçš„ `true` and `false` å®å®šä¹‰ä½¿ç”¨ `int` è€Œé `_Bool` è¡¨ç¤ºï¼Œåœ¨æœªæ¥ C23 è§„èŒƒä¸­å°†è¿›è¡Œæ›´æ–°ã€‚

ç¼–è¯‘æ”¯æŒçš„ `_Bool` ç±»å‹ä¸å…¶å®ƒæ•´å½¢çš„è½¬æ¢è§„åˆ™æœ‰å·®åˆ«ï¼š

- (bool)0.5 -> to 1
- (int)0.5  -> to 0

ç¨‹åºä¸­å¯ä»¥è‡ªè¡Œå®šä¹‰ `bool`, `true` and `false` è¿™äº›å®ï¼Œä½†éƒ½æ˜¯è¿‡æ—¶çš„åšæ³•ã€‚

å…¶å®ƒï¼Œè¡¥å……çš„ç±»å‹ç›¸å…³çš„å®å®šä¹‰ï¼š

```c
///////////////////////////////////
// Defined in header <stddef.h> //
///////////////////////////////////

typedef unsigned int    size_t  // type returned by the sizeof operator
typedef ptrdiff_t       signed int // type returned when subtracting two pointers

#define /*implementation-defined*/ NULL // null pointer constant

// a type with alignment requirement as great as any other scalar type
typedef /*implementation-defined*/ max_align_t; (since C11)

#define offsetof(type, member) /*implementation-defined*/
 // byte offset from the beginning of a struct type to specified member
// (function macro)

///////////////////////////////////
// Defined in header <stdbool.h> //
///////////////////////////////////

#define bool  _Bool // (C99) convenience macro, expands to _Bool
#define false 0 // (keyword macro) (until C23)((_Bool)+0u) (since C23)
#define true  1 // (keyword macro) (until C23)((_Bool)+1u) (since C23)

////////////////////////////////////
// Defined in header <stdalign.h> //
////////////////////////////////////

alignas // (C11) convenience macro, expands to keyword _Alignas (keyword macro)
alignof // (C11) convenience macro, expands to keyword _Alignof (keyword macro)
 
_Alignas ( expression ) (1) (since C11)
_Alignas ( type )   (2) (since C11)
_Alignof( type-name )      (since C11)

#define __alignas_is_defined 1 // (C11)
#define __alignof_is_defined 1 // (C11)

///////////////////////////////////////
// Defined in header <stdnoreturn.h> //
///////////////////////////////////////

noreturn // (C11) convenience macro, expands to _Noreturn (keyword macro)
```

### ===ğŸ‘‰ Variable vs Constants
- https://en.cppreference.com/w/c/language/const
- https://en.cppreference.com/w/cpp/language/implicit_conversion

å˜é‡å’Œå¸¸é‡ä¸¤ä¸ªåŸºæœ¬ç¼–ç¨‹æ¦‚å¿µï¼Œä½†æ˜¯å€¼å¾—ä½œä¸€ç¿»å¯¹æ¯”ï¼Œå…¶ä¸­è¿˜æ¶‰åŠäº†å£°æ˜ä¸åˆå§‹åŒ–çš„ç»†èŠ‚ï¼ŒDeclarations & Initializationsã€‚

é¦–å…ˆï¼Œç»™ä¸€ä¸ªé‡åå­—æ—¶ï¼ŒC è¯­è¨€æœ‰æ ‡è¯†ç¬¦å·çš„è§„åˆ™è¦æ±‚ï¼Œä½¿ç”¨ $ å’Œå­—æ¯è¿˜æœ‰æ•°å­—å’Œä¸‹åˆ’çº¿ï¼Œä½†æ˜¯åªæœ‰ $ ç”Ÿå­—æ¯å¯ä»¥æ‰“å¤´ã€‚

ç„¶åï¼Œå˜é‡å®šä¹‰åï¼Œå¯ä»¥æ”¹å˜å˜é‡ä¿å­˜çš„å€¼ï¼Œè€Œå¸¸é‡æ„å‘³ç€ä¸€æ—¦å®šä¹‰å°±ä¸å¯ä»¥æ”¹å˜å€¼ã€‚

å®šä¹‰å˜é‡å¯ä»¥å°†å¤šä¸ªå˜é‡å†™åœ¨åŒä¸€è¡Œï¼Œä¹Ÿå¯ä»¥ç‹¬ç«‹ä¸€è¡Œï¼Œè¿™é‡Œè¯´çš„å®šä¹‰å°±æ˜¯å£°æ˜ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰å¯¹åˆ†é…ç»™å˜é‡çš„å†…å­˜è¿›è¡Œåˆå§‹åŒ–ï¼š

```c
char c, line[1000];

char c;
char line[1000];
```

æ¯”è¾ƒä¸€ä¸‹ä»¥ä¸‹è¿™ç§è¡¨è¾¾ï¼Œå£°æ˜å˜é‡çš„åŒæ—¶ï¼Œè¿˜èµ‹äº†ä¸€ä¸ªå€¼ç»™å˜é‡ï¼Œå‡†ç¡®åœ°è®²ï¼Œè¿™æ˜¯åˆå§‹åŒ–è€Œä¸æ˜¯ä¸€èˆ¬çš„èµ‹å€¼ï¼š

```c
char c = 'C';
```

è¿™é‡Œè¦åŒºåˆ«åˆå§‹åŒ–ä¸èµ‹å€¼ï¼Œæ˜¯å› ä¸ºåœ¨å®šä¹‰å¸¸é‡é‡Œï¼Œåªèƒ½è€Œä¸”å¿…éœ€è¿›è¡Œåˆå§‹å€¼ï¼Œè€Œä¸å¯ä»¥å¯¹å¸¸é‡é‡æ–°èµ‹å€¼ï¼š

```c
#include <stdio.h>

#define PI  3.141592653589793f
int main(){
    const char msg[] = "warning: ";
    const double e = 2.71828182845905L;
    printf("%s\nPI = %f\ne = %f", msg, PI, e);
}
```

ä»¥ä¸Šä»£ç ä¸­ï¼Œå¸¸é‡è¿™ä¸ªæ¦‚å¿µçš„ä½“ç°æœ‰ 3 å¤„ï¼š

- define é¢„å¤„ç†æŒ‡ä»¤å®šä¹‰çš„ PI ç¬¦å·å¸¸é‡ï¼›
- const å®šä¹‰çš„ msg å’Œ e ä¸¤ä¸ªå¸¸é‡ï¼›
- å­—é¢å¸¸é‡ literal constantsï¼ŒåŒ…æ‹¬å­—ç¬¦ä¸² "warning: " å’Œå…¶å®ƒä¸¤ä¸ªæ•°å€¼å¸¸é‡ï¼Œå½“ç„¶ä¹ŸåŒ…æ‹¬ printf å‡½æ•°ä¸­ä½¿ç”¨çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼›

å…³äº const çš„ä½¿ç”¨ï¼Œåœ¨åé¢ç»“åˆæŒ‡é’ˆæ—¶ä¼šå‡ºç°ä¸¤ç§ç»å¸¸è®©äººæ··æ·†ä¸æ¸…çš„å½¢å¼ï¼Œæ˜¯å…³äº const ä½œç”¨ç‚¹æ˜¯å“ªçš„é—®é¢˜ï¼š

```c
int num = 100; // define a variable
const int PI = 3.14; // define a constant
const int *const cc_pi = &PI; // define a constant pointer point to a constant 
int *const vc_pi = (int*)&PI; // define a const pointer point to a constant
```

å‚è€ƒè¯­æ³•é€Ÿè®°å¦‚ä¸‹ï¼Œè®°ä½æŒ‡é’ˆçš„ä¸¤ä¸ªå±æ€§ï¼Œè¿˜æœ‰å•å…ƒæ“ä½œç¬¦å· * çš„ä¼˜å…ˆçº§å»ç†è§£ï¼Œ( Unary * right to left)ã€‚

é‰´äº Unary * right to left çš„ç»“åˆè§„åˆ™ï¼Œå£°æ˜ const æ—¶ï¼Œå°†å•å…ƒè¿ç®—ç¬¦ * å†™åœ¨å…³é”®å­—æˆ–æ ‡è¯†ç¬¦å·çš„å·¦ä¾§æ˜¯é€»è¾‘æ­£ç¡®çš„ã€‚å®ƒä¿®é¥°çš„å°±æ˜¯é åœ¨å³ä¾§çš„å†…å®¹ï¼Œæ‰€ä»¥ `*const` å°±æ˜¯ä¸€ä¸ªå¸¸æŒ‡é’ˆ Constant Pointerã€‚

```c
int var_int1 = 8;
int var_int2 = 9;
const int * vc_i = &var_int1; // initialization for read-write pointer 
int * const cv_i = &var_int2; // initialization for constant pointer

vc_i = &var_int1; // Ok: point to another
*vc_i = 11;       // Error: read only constant can't be changed

cv_i = &var_int1; // Error: read only const pointer can't be changed
*cv_i = 22;       // Ok: variable can be changed

const char * vc_ch = "Hello"; // pointer to constant
char * const cv_ch = "Hello"; // constant pointer
vc_ch = "Ok";                 // Ok: point to another constant string
vc_ch = cv_ch;                // Ok: point to another pointer's value

// Error: constant can't be change 
*vc_ch = *cv_ch;
*vc_ch = "Error";

// Error: const pointer can't be changed
cv_ch = (char * const)vc_ch;
cv_ch = "Error";
```

å¾ˆæœ‰å¿…è¦å¯¹ä»¥ä¸Šè¿™äº›å¸¸é‡å‡ºç°è¿›è¡Œè¾¨æï¼Œé€šå¸¸æ¦‚å¿µä¸Šå¸¸é‡æ˜¯é€šè¿‡ const æˆ– define å®šä¹‰çš„å€¼ä¸å¯ä¿®æ”¹çš„ç¬¦å·ã€‚åœ¨ç¼–è¯‘å™¨çš„è§’åº¦ä¸Šçœ‹èµ‹å€¼è¿‡ç¨‹ï¼Œå°±æ˜¯å°†ç­‰å·å³ä¾§çš„å€¼èµ‹ç»™å·¦ä¾§çš„å˜é‡ç¬¦å·ï¼Œå³ lvalue = rvalueï¼Œå³å·¦å€¼ä¸å³å€¼çš„åŸºæœ¬æ¦‚å¿µã€‚

å˜é‡å¯ä»¥ä½œä¸ºå¯ä¿®æ”¹çš„å·¦å€¼ï¼Œè€Œå¸¸é‡åˆ™ä¸å¯ä»¥ï¼Œæ¯”å¦‚ `3.14 = 3.14`ï¼Œåœ¨æ•°å­¦é‚»åŸŸä¸Šè®²è¿™æ˜¯ä¸ªç­‰å¼ï¼Œæ˜¯æˆç«‹çš„ã€‚è€Œåœ¨è®¡ç®—æœºçš„é¢†åŸŸä¸­ï¼Œè¿™æ˜¯èµ‹å€¼ï¼Œè€Œå·¦å€¼ 3.14 æ˜¯ä¸ªå­—é¢å¸¸é‡ï¼Œä¸å¯ä¿®æ”¹ä¸å¯èµ‹å€¼ã€‚ä»è¯­æ³•ä¸Šè®²æ˜¯é”™è¯¯çš„ï¼Œä»ç¼–è¯‘å™¨å®ç°ä¸Šè®²ï¼Œè¿™æ˜¯åœ¨ä¸ºéš¾ç¼–è¯‘å™¨ï¼Œè¦å®ç°è¿™æ ·çš„é€»è¾‘å°±è¦æ‰“ç ´ç¼–è¯‘å™¨è§„åˆ™ã€‚

åˆ©ç”¨å·¦å€¼ä¸ºå¸¸é‡ä¸å¯ä¿®æ”¹è¿™ä¸€ç‚¹ï¼Œæœ‰ç»éªŒçš„å¼€å‘è€…ä¼šæŒ‰ä»¥ä¸‹æ–¹å¼ç¼–å†™æ¡ä»¶è¯­å¥ï¼Œè¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼š

```c
if (100 == abc) {
    // ...
}
```

ä»æ±‡ç¼–æŒ‡ä»¤çš„è§’åº¦æ¥çœ‹ï¼Œä½¿ç”¨ const å®šä¹‰çš„å¸¸é‡ç¬¦å·ç»è¿‡ç¼–è¯‘åï¼Œä¹Ÿå’Œå˜é‡ç±»ä¼¼åœ°æŒ‡å‘äº†å†…å­˜çš„æŸä¸€ä½ç½®ï¼Œä½†æ˜¯å¸¸é‡æŒ‡å‘çš„è¿™ä¸ªä½ç½®çš„å†…å®¹æ˜¯ä¸å¯ä»¥æ”¹å˜çš„ã€‚

ç¼–è¯‘å™¨ç¼–è¯‘åï¼Œå­—é¢å¸¸é‡å°†ä¼šä¿å­˜åœ¨äºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶å†…çš„æ•°æ®åŒºï¼Œ.data è¿™æ˜¯ä¸å¯ä¿®æ”¹çš„æ•°æ®ï¼Œè¿è¡Œç¨‹åºæ—¶ï¼Œç”±æ“ä½œç³»ç»Ÿçš„ç¨‹åºåŠ è½½å™¨è£…å…¥å†…å­˜ä¸­ç›´æ¥ä½¿ç”¨ï¼Œ.data å¯¹åº”è£…å…¥çš„å†…å­˜åŒºä¹Ÿä¼šè®¾ç½®ä¸ºåªè¯»å†…å­˜ã€‚

å¼ºåˆ¶æ”¹å˜åªè¯»å†…å­˜çš„æ•°æ®å°†å¯¼è‡´ SIGSEGV å¼‚å¸¸ï¼Œå½“ç„¶ï¼Œè¿›ç¨‹è¶Šç•Œè®¿é—®å…¶å®ƒè¿›ç¨‹çš„å†…å­˜ä¹Ÿä¼šå¯¼è‡´è¿™æ ·çš„å¼‚å¸¸ã€‚åœ¨ CPU å†…éƒ¨ï¼Œæœ‰å†…å­˜åˆ†é¡µæœºåˆ¶ç®¡ç†ç€ç‰©ç†å†…å­˜ï¼Œå¹¶é€šè¿‡ GDT/LDT ç­‰å¯„å­˜å™¨ç®¡ç†ç€æ˜ å°„è¡¨ï¼Œåœ¨å†…å­˜åˆ†é¡µè®°å½•ä¸­ï¼ŒåŒ…å«äº†ç¨‹åºä½¿ç”¨çš„å†…å­˜ç©ºé—´è¯¦ç»†ä¿¡æ¯ï¼ŒåŒ…å«ç¨‹åºè¿è¡Œçš„ä»£ç æ®µ .text ä»¥åŠæ•°æ®æ®µ .data çš„èµ·å§‹åœ°å€ï¼Œä¸€æ—¦ç¨‹åºå‘ç”Ÿäº†è¶Šç•Œè®¿é—®ï¼Œæˆ–ä¿®æ”¹åªè¯»å†…å­˜ï¼ŒCPU å°±ä¼šäº§ç”Ÿç›¸åº”çš„å¼‚å¸¸ä¿æŠ¤ã€‚

å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä»£ç æ¥éªŒè¯ï¼š

```c
int main()
{
    char *fixed = "hello";
    fixed[0] = fixed[1]; // Segmentation fault(SIGSEGV) 
    printf("S:%s", fixed);
    return 0;
}
```

åªèƒ½ä¿®æ”¹å¯è¯»å†™çš„å†…å­˜ä¸­çš„æ•°æ®ï¼Œåˆ—å¦‚ï¼Œä»¥ä¸‹ rw å®šä¹‰çš„å†…å­˜åŒºï¼š

```c
char *fixed = "hello";
// char rw[] = "hello";
char rw[256];
sscanf(fixed, "%s", rw);
```

ç®€å•çš„åšæ³•æ˜¯ç›´æ¥å®šä¹‰å­—ç¬¦æ•°ç»„ï¼Œå®ƒä¸æŒ‡é’ˆæœ€å¤§çš„ä¸åŒåœ¨äºï¼ŒæŒ‡é’ˆåªåˆ†é…äº†æŒ‡é’ˆæœ¬èº«çš„å†…å­˜ç©ºé—´ï¼Œæ²¡æœ‰åˆ†é…æŒ‡é’ˆæŒ‡å‘çš„æ•°æ®æ‰€ä½¿ç”¨çš„å†…å­˜ç©ºé—´ã€‚

ä¸ºäº†è¯´æ˜ç¼–è¯‘ä½¿ç”¨çš„å†…å­˜åˆ†é…è¡Œä¸ºï¼Œç”¨ä»¥ä¸‹ä»£ç ä½œä¸ºä¾‹å­ï¼Œäº‹å®ä¸Šè¿™æ ·çš„ä»£ç æ˜¯ä¸èƒ½é€šè¿‡ç¼–è¯‘çš„ã€‚

```c
int len = 11;
char s[len] = "helloworld";
```

å› ä¸ºï¼Œå­—ç¬¦ä¸²å˜é‡ s ä½œä¸ºä¸€ä¸ªæ•°ç»„ï¼Œæ²¡æœ‰ä½¿ç”¨å¸¸é‡æŒ‡å®šå¤§å°ï¼Œè¿™å°±å¯¼è‡´ç¼–è¯‘å™¨ä¸çŸ¥é“å¦‚ä½•ç»™å®ƒå®‰æ’å†…å­˜ç©ºé—´ã€‚å¦‚æœçœç•¥ len è¿™ä¸ªå˜é‡ï¼Œç›´æ¥ä½¿ç”¨ç©ºçš„æ–¹æ‹¬å· []ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨å°±ä¼šæ ¹æ®å³ä¾§çš„åˆå§‹åŒ–æ•°æ®é•¿åº¦æ¥ç»™å­—ç¬¦ä¸²å˜é‡åˆ†é…å†…å­˜ã€‚åˆå› ä¸º C è¯­è¨€çš„å­—ç¬¦ä¸²æ˜¯ null-terminatedï¼Œåˆ†é…å†…å­˜æ—¶ï¼Œä¼šé¢å¤–å¤šåˆ†é…ä¸€ä¸ªå­—èŠ‚ä½œä¸ºç»“æŸç¬¦å· null çš„ç©ºé—´ã€‚

å¦‚æœï¼Œç¨‹åºå¿…éœ€é€šè¿‡åŠ¨æ€ç¡®å®šå†…å­˜ç”¨é‡ï¼Œé‚£ä¹ˆå°±éœ€è¦ä½¿ç”¨ smalloc å’Œ free å‡½æ•°è¿›è¡ŒåŠ¨æ€å†…å­˜åˆ†é…ç®¡ç†ï¼ŒåŠ¨æ€å†…å­˜ä¹Ÿç§°ä¸º `Head` å †å†…å­˜ï¼Œç”¨äºç¨‹åºè¿è¡Œæ—¶åŠ¨æ€åˆ†é…ã€‚ä¸ä¹‹ç›¸å¯¹çš„æ˜¯ `Stack` æ ˆå†…å­˜ï¼Œä¹Ÿå°±æ˜¯ç¨‹åºçš„è°ƒç”¨æ ˆï¼Œåƒå˜é‡çš„å®šä¹‰ï¼Œå‡½æ•°å‚æ•°çš„ä¼ é€’ï¼ŒåŒ…æ‹¬å¸¸é‡æŒ‡å®šé•¿åº¦çš„æ•°ç»„ï¼Œéƒ½å¯ä»¥åœ¨ç¼–è¯‘æœŸå®‰æ’å¥½æ ˆå†…å­˜ã€‚å †æ ˆå†…å­˜æ¨¡å‹å†…å­˜è¿œä¸æ­¢è¿™æ­¤ï¼Œéœ€è¦é€šè¿‡æ±‡ç¼–çš„è§’åº¦ï¼Œç»“åˆ CPU çš„å†…å­˜ç®¡ç†æ¨¡å‹ï¼Œå’Œæ‰§è¡Œç¨‹åºçš„æµç¨‹å»ç†è§£ï¼Œè¿™äº›éƒ½æ˜¯ç›¸å½“è´´è¿‘ç¡¬ä»¶å±‚é¢çš„å†…å®¹ã€‚

å­—é¢å¸¸é‡æ˜¯ç»å¸¸ä½¿ç”¨çš„å¸¸é‡å®šä¹‰æ–¹å¼ï¼Œå‡ ä¹è¿œå¤„ä¸åœ¨ï¼Œå®ƒä¹Ÿæ˜¯æœ‰ç±»å‹çš„ã€‚å¾ˆç›´è§‚åœ°ï¼Œä½¿ç”¨åŒå¼•å·è¡¨ç¤ºå­—ç¬¦ä¸²ï¼Œå¦‚ "I am a string"ï¼Œä½¿ç”¨å•å¼•å·åŒ…æ‹¬çš„è¡¨ç¤ºå­—ç¬¦ï¼Œå¦‚ 'C'ã€‚

ä¸¤ä¸ªç›¸è¿‘çš„å­—ç¬¦ä¸²ï¼ŒåŒè¡Œæˆ–åˆ†è¡Œï¼Œç¼–è¯‘å™¨ä¼šå°†å®ƒä»¬è¿æ¥åœ¨ä¸€èµ·ï¼Œå¦‚ "war" "ning" ç­‰ä»· "warning"ï¼Œå¦‚è¦æ’å…¥ç‰¹æ®Šå­—ç¬¦ï¼Œå¯ä»¥è¿›è¡Œè½¬ä¹‰ï¼Œå¦‚è½¬ä¹‰åŒå¼•å· "\""ã€‚

æ‰€ä»¥ï¼Œå•å¼•å·å†…ä¸èƒ½æœ‰å¤šä¸ªå­—ç¬¦ï¼Œå³ä½¿ä½¿ç”¨å®½å­—ç¬¦é›†ä¹Ÿä¸å¯ï¼Œä»¥ä¸‹è¿™æ ·çš„ä»£ç å°±ä¸èƒ½é€šè¿‡ç¼–è¯‘ï¼š

```c
#include <wchar.h>

const wchar_t m = 'â˜…';
```

å­—ç¬¦å¸¸é‡ç­‰ä»·ä¸€ä¸ªæ•´æ•°ï¼Œä¹Ÿå°±æ˜¯ ASCII ç è¡¨ä¸­å¯¹åº”çš„ç¼–ç å€¼ï¼Œå¦‚ '0' å¯¹åº”çš„ç å€¼ 48ï¼Œ'A' å¯¹åº”ç å€¼ 65ï¼Œ'a' å¯¹åº”ç å€¼ 97ã€‚

å¦å¤–ï¼ŒC è¯­è¨€ä½¿ç”¨çš„æ˜¯ null-terminated é£æ ¼çš„å­—ç¬¦ä¸²ï¼Œå› ä¸ºæ²¡æœ‰ç±»å‹æ¥ç®¡ç†å­—ç¬¦ä¸²ï¼Œä¸èƒ½ä¿å­˜å­—ç¬¦ä¸²çš„é•¿åº¦ä¿¡æ¯ï¼Œæ‰€ä»¥ä½¿ç”¨ '\0' å³ null ä½œä¸ºå­—ç¬¦ä¸²ç»“æŸæ ‡è®°ã€‚æ‰€ä»¥åœ¨å®šä¹‰å­—ç¬¦ä¸²æ—¶è¦å¤šä¹…ä¸€ä¸ªå­—èŠ‚ï¼Œæ¯”å¦‚ "Hello" å­—é¢å¸¸é‡æœ¬èº«å­—ç¬¦ä¸²é•¿åº¦ä¸º 5 ä½†åœ¨ C è¯­è¨€ä¸­å äº† 6 ä¸ªå­—èŠ‚å†…å­˜ç©ºé—´ã€‚

é™¤äº†æ™®é€šçš„å­—ç¬¦ä¸²å’Œå­—ç¬¦ï¼Œå­—é¢å¸¸é‡è¿˜æœ‰å®½å­—ç¬¦ä¸²ã€å„ç§æ•°å€¼ï¼Œè¿™å°±éœ€è¦ä½¿ç”¨ç±»å‹æ³¨è§£æ¥æç¤ºç¼–è¯‘å™¨å¦‚ä½•å¤„ç†ï¼š

```c
const wchar_t bnn[] = L"ğŸŒwide characters";
int i = 1234;   // 1234   is int
int i = 1234L;  // 1234L  is long int
int i = 1234UL; // 1234UL is unsigned long int
int i = 1234.;  // 1234.  is double
int i = 12e-3;  // 12e-3  is double
int i = 1234.f; // 1234.f is float
```

ä»¥ä¸Šä½¿ç”¨äº† Lã€UL ç­‰åç¼€æ¥ç»™ç¼–è¯‘å™¨æç¤ºç±»å‹ï¼Œä½†æœ€åè¿˜æ˜¯ç»è¿‡ implit conversions éšå¼ç±»å‹è½¬æ¢ä¸º `int`ï¼Œè¿™ç§ä» bit å®½åº¦æ›´å¤§çš„ç±»å‹å‘æ›´ä½çš„ç±»å‹è½¬æ¢ç§°ä¸º narrowing convertions ã€‚

å¦å¤–ï¼Œç±»å‹åç¼€è¿˜å¯ä»¥ä½¿ç”¨å°å†™å½¢å¼ï¼ŒåŒ…æ‹¬ ll, ul, ull ç­‰ã€‚æ•°å€¼å­—é¢å¸¸é‡é»˜è®¤ç±»å‹ä¸º intï¼Œè€Œå¸¦å°æ•°ç‚¹çš„é»˜è®¤ä¸º double æµ®ç‚¹ç±»å‹ï¼Œå¸¦ä¸Š L æˆ– l åç¼€å°±æ˜¯ long double ç±»å‹ï¼Œåªæœ‰æ•´å½¢æ‰å¯ä»¥ä½¿ç”¨ ll æˆ– LL åç¼€ã€‚

é™¤äº†ç±»å‹åç¼€ï¼Œæ•°å€¼å­—é¢å¸¸é‡è¿˜å¯ä»¥ä½¿ç”¨ä¸åŒçš„è¿›åˆ¶è¡¨è¾¾ï¼Œå¦‚ 0x å‰ç¼€è¡¨ç¤º 16 è¿›åˆ¶ï¼Œ0 å‰ç¼€è¡¨ç¤º 8 è¿›åˆ¶ï¼Œï¼š

```c
float i = 0b1111;     // binary literal value is 15 in decimal
float i = 017;        // octal literal value is 15 in decimal
float i = 017UL;      // octal literal value is unsigned long 15 in decimal
float i = 0x100.8p0;  // hexadecimal literal value is 256.5 in decimal
float i = 0x100.8p0L; // hexadecimal literal value is 256.5 in decimal
```

éœ€è¦æ³¨æ„ï¼ŒäºŒè¿›åˆ¶å’Œå…«è¿›åˆ¶å­—é¢å¸¸é‡ä¸æ”¯æŒæµ®ç‚¹ï¼Œå¦å¤–åœ¨ 16 è¿›åˆ¶ä¸­ï¼Œe ä½œä¸ºä¸€ä¸ªåˆæ³•çš„ 16 è¿›åˆ¶ç¬¦å·ï¼Œä½¿ç”¨ p æ¥æ›¿ä»£æŒ‡ç¤ºæŒ‡æ•°éƒ¨åˆ†ã€‚

åå…­è¿›åˆ¶è¡¨è¾¾æµ®ç‚¹æ—¶ï¼Œå°æ•°ç‚¹åé¢çš„å€¼ä¹ŸæŒ‰åå…­è¿›åˆ¶è®¡ç®—ï¼Œåˆ—å¦‚ .1 å°±æ˜¯ 1/6ã€‚

å‰é¢æåˆ°çš„ç±»å‹çª„åŒ– narrowing éšå¼è½¬æ¢ï¼Œé€šå¸¸è¿™ä¼šå¯¼è‡´ç²¾åº¦ä¸¢å¤±ï¼Œé€šå¸¸æ˜¯ä¸å…è®¸çš„ï¼Œè‡³å°‘ç¼–è¯‘å™¨åº”è¯¥æç¤º overflowã€‚

è¿˜æœ‰å…¶å®ƒåˆæ³•çš„éšå¼ç±»å‹çš„è½¬æ¢ï¼Œæ¯”å¦‚ float è½¬æ¢ä¸º doubleï¼Œchar è½¬æ¢ä¸º intï¼Œint è½¬æ¢ä¸º long ç­‰ï¼Œéƒ½ä¸ä¼šå¯¼è‡´æ•°æ®ä¸¢å¤±ï¼Œå®ƒä»¬ç§°ä¸ºç±»å‹æ‹“å®½ widening conversionsã€‚

åœ¨ The C Programming Language é™„å½• A.6 ä¸­æœ‰è¯¦ç»†çš„éšå¼ç±»å‹è½¬æ¢è§„åˆ™æè¿°ï¼Œä»¥ä¸‹æ˜¯ç®€è¦çš„å‚è€ƒï¼š

- If either operand is long double, convert the other to long double. 
- Otherwise, if either operand is double, convert the other to double. 
- Otherwise, if either operand is float, convert the other to float. 
- Otherwise, convert char and short to int. 
- Then, if either operand is long, convert the other to long. 

é€šå¸¸ï¼Œå­—ç¬¦ç±»å‹è¢«ä½œä¸º C è¯­è¨€æä¾›çš„æœ€å°å®½åº¦çš„æ•´å½¢æ•°æ®ï¼Œå¯ä»¥ä¸å…¶å®ƒæ•°å€¼è¿›è¡Œè¿ç®—ã€‚å¦å¤– `<ctype.h>` æä¾›çš„åº“å‡½æ•°ä¹Ÿåªå¯ä»¥å¾ˆæ–¹ä¾¿åœ°åˆ¤æ–­æ˜¯ä»€ä¹ˆç±»å‹çš„å­—ç¬¦ï¼Œå¦‚åˆ¤æ–­æ•°å­— `isdigit(c)`ï¼Œåˆ¤æ–­å­—æ¯ `isalpha(c)`ã€‚

é™¤äº†éƒ¨åˆ†éšå¼ç±»å‹è½¬æ¢ï¼ŒC è¯­è¨€è¿˜æ˜¯ç›¸å½“å®ˆè§„åˆ™çš„ï¼Œåˆ—å¦‚ï¼Œä»¥ä¸‹å®šä¹‰çš„æµ®ç‚¹ç±»å‹ aï¼Œä¼šå°† 1/2 è¿ç®—çš„ç»“æœä½œä¸ºåˆå§‹å€¼ï¼Œä½†æ˜¯ç»“æœå¹¶ä¸æ˜¯ 0.5ã€‚å› ä¸ºï¼Œæ•´æ•°è¿ç®—ç»“æœä¸å®¡æ•´æ•°ï¼Œè¿™å¯¼è‡´æµ®ç‚¹éƒ¨åˆ†è¢«ä¸¢æ‰äº†ã€‚ä½†æ˜¯åªè¦å…¶ä¸­æœ‰ä¸€ä¸ªæµ®ç‚¹æ•°ï¼Œç»“æœå°±ä¼šæ˜¯æ­£ç¡®çš„ã€‚

```c
float a = 1/2;
```

å› æ­¤ï¼Œéœ€è¦ç•™å¿ƒå‘ç”Ÿéšå¼ç±»å‹è½¬æ¢åœºåˆï¼š

- èµ‹å€¼æ“ä½œï¼Œæˆ–åˆå§‹åŒ–ï¼›
- äºŒå…ƒè¿ç®—ï¼›
- å‡½æ•°ä¼ é€’å‚æ•°ï¼›

æ›´å¥½çš„åšæ³•æ˜¯ä½¿ç”¨æ˜¾å¼ç±»å‹è½¬æ¢ï¼Œè¿™æ ·å°±ä¸ä¼šæœ‰æ„å¤–çš„æƒ…å†µå‡ºç°ï¼Œæ˜¾å¼è½¬æ¢è¯­æ³•å¦‚ä¸‹ï¼š

     (type name) expression 

æˆ–è€…ä½¿ç”¨ç±»å‹è½¬æ¢å‡½æ•°ã€‚


### ===ğŸ‘‰ Operators & Expressions
- Bit Twiddling Hacks http://graphics.stanford.edu/~seander/bithacks.html

è¿ç®—ç¬¦å†…å®¹æ¶‰åŠï¼š

- Arithmetic Operators
- Relational and Logical Operators
- Increment and Decrement Operators
- Bitwise Operators
- Assignment Operators 
- Precedence and Order of Evaluation

ä»¥åŠåœ¨ç‰¹å®šåœºåˆä¸‹ä½¿ç”¨ç‰¹å®šçš„è¿ç®—ç¬¦ï¼Œä¾‹å¦‚ï¼Œåœ¨æµç¨‹æ§åˆ¶ç»“æ„ä¸­ï¼Œéœ€è¦æ¡ä»¶åˆ¤æ–­ï¼Œå°±éœ€è¦ä½¿ç”¨å…³ç³»ä¸é€»è¾‘è¿ç®—ï¼Œç›¸åº”çš„è¡¨è¾¾å¼ä¹Ÿç§°ä¸ºæ¡ä»¶è¡¨è¾¾å¼ Conditional Expressionsã€‚

ä¾‹å¦‚ä»¥ä¸‹çš„ä¸‰å…ƒè¿ç®—ç¬¦å’Œ if-else æ¡ä»¶åˆ¤æ–­ä¸­ï¼Œéƒ½æœ‰ (a > b) è¿™ä¸ªæ¡ä»¶è¡¨è¾¾å¼ï¼Œè¿˜æœ‰ for å¾ªç¯ä¸­çš„ i < n ä¹Ÿæ˜¯æ¡ä»¶è¡¨è¾¾å¼ã€‚

```c
/* z = max(a, b) */
z = (a > b) ? a : b;

if (a > b)
   z = a;
else
   z = b;

for (i = 0; i < n; i++) printf("%d", i);
```

æ ¹æ®è¿ç®—ç¬¦éœ€è¦çš„æ•°æ®ä¸ªæ•°ï¼Œå¯ä»¥åˆ†ä¸ºï¼š

- ä¸€å…ƒè¿ç®—ç¬¦å· Unaryï¼Œå¦‚å–åœ°å€ &aï¼Œæˆ–è€…æŒ‰ä½å–å ~aï¼Œè¿˜æœ‰æ­£è´Ÿå· + -ï¼Œå½“ç„¶å®ƒä»¬ä¹Ÿå¯ä»¥å½“ä½œåŠ å‡ç¬¦å·ï¼›
- äºŒå…ƒè¿ç®—ç¬¦å· Binaryï¼Œå¦‚å››åˆ™è¿ç®—ï¼Œa + bï¼Œa - b ç­‰ç­‰ï¼›
- ä¸‰å…ƒè¿ç®—ç¬¦å· Ternaryï¼Œåªæœ‰ ?: ä¸€ä¸ªï¼Œ`c ? x:y;` è¡¨è¾¾å¼è¡¨ç¤ºå½“æ¡ä»¶ c ä¸ºçœŸåˆ™è¿”å› x å¦åˆ™è¿”å› yï¼›

å››åˆ™è¿ç®—ç¬¦å· + - * / æ˜¯æœ€åŸºæœ¬çš„ç®—æœ¯ç¬¦å·ï¼Œæ­¤å¤–è¿˜æœ‰æ¨¡è¿ç®—ï¼Œa % b è¡¨ç¤ºå°† a æ•´æ•°å€äº b çš„éƒ¨åˆ†æˆªå»ï¼Œå–ä½™ä¸‹çš„éƒ¨åˆ†ï¼Œb è¿™ä¸ªæ•°ç§°ä¸ºæ¨¡ï¼Œæ¨¡å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªå›ºå®šçš„é•¿åº¦ã€‚

æ±‚è§£æŸå¹´ä»½æ˜¯ä¸ä¸ºé—°å¹´æ˜¯æ¼”ç¤ºå››åˆ™è¿ç®—å¾ˆå¥½çš„ä¸€ä¸ªä¾‹å­ï¼Œå¦‚æœæŸå¹´å¯ä»¥æ•´é™¤ 4 ä¸”ä¸è¢« 100 æ•´é™¤ï¼Œåˆæˆ–è€…å¹´ä»½å¯ä»¥æ•´é™¤ 400ï¼Œé‚£ä¹ˆå°±æ˜¯é—°å¹´ï¼š

```c
if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
   printf("%d is a leap year\n", year);
else
   printf("%d is not a leap year\n", year);
```

æ³¨æ„ï¼Œæ±‚æ¨¡è¿ç®—ç¬¦å· % ä¸èƒ½ç”¨äºæµ®ç‚¹æ•°ã€‚ 

è´Ÿæ•°è¿›è¡Œ / æˆ– % è¿ç®—ï¼Œç»“æœç¬¦å·ä½æˆªæ–­æ–¹å‘ä¸æœºå™¨æœ‰å…³ï¼Œè®¡ç®—å‡ºç°ä¸Šæº¢æˆ–ä¸‹æº¢æ“ä½œä¹Ÿæ˜¯å¦‚æ­¤ã€‚

    char a = -256/-2; // -128

è‡ªå¢ ++ å’Œè‡ªå‡ -- è¿ç®—ç¬¦å·å¯èƒ½æ˜¯æ€»ä¼šå¼•å‘æ„å¤–çš„ä¸¤ä¸ªç¬¦å·ï¼Œå®ƒä»¬å¯ä»¥æ”¾åœ¨æ“ä½œæ•°æ®çš„å‰é¢ï¼Œè¡¨ç¤ºåœ¨å…ˆè¿›è¡Œè‡ªå¢è¿ç®—å†è¿›è¡Œå…¶å®ƒæ“ä½œï¼Œä¹Ÿå¯ä»¥æ”¾åœ¨æ“ä½œæ•°åé¢ï¼Œè¡¨ç¤ºå…ˆè¿›è¡Œå…¶å®ƒæ“ä½œå†è¿›è¡Œè‡ªå¢è¿ç®—ã€‚

ä¾‹å¦‚ï¼Œä»¥ä¸‹ä»£ç ï¼Œä¸¤ä¸ªè‡ªå¢æ“ä½œæ„ä¹‰å®Œå…¨ä¸åŒï¼Œx ä¸º 2 å› ä¸ºå…ˆèµ‹å€¼å†æ‰§è¡Œ n çš„è‡ªå¢æ“ä½œï¼Œè€Œ y ä¸º 4ï¼Œå› ä¸ºå…ˆæ‰§è¡Œè‡ªå¢å†èµ‹å€¼ï¼š

```c
int n = 2;
int x = n++;
int y = ++n;
```

å¦‚æœä¸€ä¸å°å¿ƒå†™æˆä»¥ä¸‹è¿™æ ·çš„ä»£ç ï¼Œé‚£å°±ç›¸å½“éš¾æäº†ï¼š

```c
x = n+++y;
```

å› ä¸ºï¼Œåç½®çš„è‡ªå¢æˆ–è‡ªå‡è¿ç®—ä¼˜å…ˆçº§å¾ˆä½ï¼Œä¼šä¼˜å…ˆæ‰§è¡Œç®—æœ¯è¿ç®—ï¼Œä½†æ˜¯è¿™é‡Œçš„è§†è§‰æ„Ÿå—åˆ°çš„é€»è¾‘éå¸¸ä»¤äººå›°æƒ‘ï¼Œé™¤éä½ ä¸æƒ³è‡ªå·±ç»æ‰‹çš„é¡¹ç›®è®©åˆ«äººè½»æ¾åœ°ç»´æŠ¤ï¼Œæˆ–è€…ä½ æƒ³ä¸ºéš¾åˆ«äººè¦è¿™æ ·åšã€‚

å¦å¤–ï¼Œä¹Ÿä¸è¦ä½¿ç”¨è¿‡äºå¤æ‚çš„è¡¨è¾¾å¼ï¼Œè¿™ä¼šå¼•å…¥éš¾ä»¥å¯Ÿè§‰çš„é€»è¾‘é—®é¢˜ï¼Œå¦‚ä¸‹ï¼Œç¼–è¯‘å™¨ä»å·¦å‘å³ã€æˆ–ä»å³å‘å·¦è¿›è¡Œæ±‚å€¼æ˜¯ä¸¤ç§ä¸åŒçš„è¡Œä¸ºï¼Œè¿™ä¼šå¯¼è‡´è¾“å‡ºä¸åŒçš„ç»“æœï¼š

```c
int i = 2;
printf("%d %d", i, i*i++);
// 3 6
```

åœ¨ C çš„é€—å·è¿ç®—ç¬¦ä¸­ï¼Œæ˜¯ä»å·¦å‘å³æ±‚å€¼ï¼Œä½†æ˜¯å‡½æ•°å‚æ•°åˆ—è¡¨ä¸å±äºé€—å·è¡¨è¾¾å¼ï¼Œé»˜è®¤ä»å³å¾€å·¦æ±‚å€¼ï¼Œä½†æ˜¯ C è¯­è¨€ç¼–è¯‘å™¨å¯ä»¥é€‰æ‹©å‚æ•°åˆ—è¡¨æ±‚å€¼é¡ºåºï¼Œä»¥ä¼˜åŒ–å¾—åˆ°æ•ˆç‡æ›´é«˜çš„ä»£ç ã€‚


å…³ç³»è¿ç®—ç¬¦å³æ¯”è¾ƒå¤§å°çš„è¿ç®—ç¬¦å·ï¼ŒåŒ…æ‹¬åˆ¤æ–­ç›¸ç­‰ == æˆ–ä¸ç›¸ç­‰ !=ï¼ŒæŒ‰ä¼˜å…ˆçº§ç½—åˆ—å¦‚ä¸‹ï¼š

    >   >=   <   <=

    ==   !=

å…³ç³»è¿ç®—æ¯”ç®—æœ¯è¿ç®—ç¬¦å·ä¼˜å…ˆçº§è¦ä½ï¼Œæ‰€ä»¥ i < lim-1 ç­‰ä»· i < (lim-1)ï¼Œå¹¶ä¸”å»ºè®®ä½¿ç”¨åœ†æ‹¬å·ï¼Œæ„ä¹‰æ›´æ¸…æ™°ã€‚

ä¼—å¤šè¿ç®—ç¬¦å·ä¸­ï¼Œé€»è¾‘è¿ç®—æ˜¯æ¯”è¾ƒæœ‰è¶£çš„ï¼Œé€»è¾‘è¿ç®—åˆ¤æ–­çœŸå‡ï¼ŒåŒ…æ‹¬ `!`ã€`&&` å’Œ `||` åˆ†åˆ«è¡¨ç¤º not, and, orï¼ŒæŒ‰ä¼˜å…ˆçº§æ’åˆ—ã€‚å¦‚æœè¡¨è¾¾å¼ `a || b` ä¸­ a ä¸ºå‡ï¼Œé‚£ä¹ˆ b è¿™éƒ¨åˆ†å°±ä¸ä¼šæ‰§è¡Œï¼ŒåŒç†ï¼Œå¦‚æœ `a || b` ä¸­ a ä¸ºçœŸï¼Œåˆ™ b è¿™éƒ¨åˆ†ä¸ä¼šæ‰§è¡Œï¼Œå› ä¸ºé€»è¾‘æˆ–æ¡ä»¶å·²ç»æˆç«‹ã€‚å¾ˆå¤š C ç¨‹åºéƒ½ä¼šä½¿ç”¨è¿™ä¸ªç‰¹æ€§ï¼Œä¹Ÿå« shortcut çŸ­è·¯è¡Œä¸ºã€‚

ä¾‹å¦‚ï¼Œä»¥ä¸‹ä»£ç ä¸­ï¼Œåªè¦ lim-1 å°äºæˆ–ç­‰äº iï¼Œç¬¬ä¸€ä¸ªé€»è¾‘ä¸ç¬¦å·å·¦ä¾§æ¡ä»¶ä¸º false å°±å¯¼è‡´æ•´ä¸ªé€»è¾‘æ¡ä»¶ä¸º falseï¼Œåé¢çš„æ¡ä»¶å°±ä¸ä¼šè¢«æ‰§è¡Œã€‚æˆ–è€…ï¼Œåªè¦è¯»å–åˆ°æ¢è¡Œç¬¦å·ï¼Œé‚£ä¹ˆç¬¬äºŒä¸ªé€»è¾‘ä¸ç¬¦å·çš„å·¦ä¾§å°±æ˜¯ falseï¼Œæ•´ä¸ªæ¡ä»¶ä¹Ÿå°±æ˜¯ falseï¼Œå°±ä¸ä¼šå†å»åˆ¤æ–­åé¢çš„æ¡ä»¶ï¼š

```c
for (i=0; i < lim-1 && (c=getchar()) != '\n' && c != EOF; ++i)
   s[i] = c;
```

é€»è¾‘éè¿ç®—ç¬¦å·ä¼šå°†é 0 æ“ä½œæ•°è½¬æ¢ä¸º 0ï¼Œè€Œ 0 å€¼ä¼šè¿”è½¬ä¸º 1ï¼Œä½œä¸ºä¸€å…ƒè¿ç®—ç¬¦å·ï¼Œå®ƒçš„ä¼˜å…ˆçº§æ¯”æ‰€æœ‰äºŒå…ƒè¿ç®—ç¬¦å·éƒ½é«˜ã€‚

é€»è¾‘è½¬æ¢çš„ç»„åˆæ˜¯ç›¸å½“çµæ´»çš„ï¼Œä½ å¯ä»¥é€‰æ‹©å–œæ¬¢çš„é€»è¾‘è¿ç®—ç¬¦ï¼Œå®ƒä»¬ä¹‹é—´å¯ä»¥ç›¸äº’è½¬åŒ–ã€‚

```c
if (!valid) ...
if (valid == 0) ...
if (!(valid != 0)) ...
```

æ¯”ç‰¹ä½æ“ä½œ Bitwise Operators ä¹Ÿæ˜¯ç›¸å½“æœ‰è¶£çš„ï¼Œå®ƒç»™äººæ„Ÿè§‰ç›¸å½“è´´è¿‘ CPUï¼Œå¯ä»¥å¯¹ä¸€ä¸ªå­—èŠ‚çš„ 8-bit ä»»ä¸€ä¸ªè¿›è¡Œæ“ä½œã€‚

C æä¾›äº† 6 ä¸ªæ¯”ç‰¹æ“ä½œç¬¦ï¼Œç”¨äºæ•´å‹æ•°æ®çš„è¿ç®—ï¼Œå¦‚ char, short, int, longï¼Œå½“ç„¶ä¹ŸåŒ…æ‹¬ signed or unsigned ä¿®é¥°çš„æ•´å½¢ã€‚

    &   bitwise AND 
    |   bitwise inclusive OR 
    ^   bitwise exclusive OR 
    <<  left shift 
    >>  right shift 
    ~   one's complement (unary) 

æ¯”ç‰¹è¿ç®—çš„ `~ & |` ä¸‰è€…éå¸¸åƒé€»è¾‘è¿ç®—ï¼Œå®ƒä»¬ä¹Ÿæ˜¯åŸºäº `! && ||` çš„é€»è¾‘æ¼”åŒ–è€Œæ¥çš„ã€‚è€Œç§»ä½è¿ç®— << æˆ– >> åˆ™ç›¸å½“ç›´è§‚ï¼Œå°±æ˜¯å°†äºŒè¿›åˆ¶çš„ bit ä½ä¾æ¬¡å¾€å·¦æˆ–å¾€å³ç§»åŠ¨æŒ‡å®šçš„ä½æ•°ã€‚

ä¸ºäº†ç®€åŒ–ï¼Œä¸‹é¢ç”¨ 4-bit çš„æ•°æ®æ¥è§£æ 6 ç§æ¯”ç‰¹è¿ç®—ï¼Œæœ€é«˜ bit ä¹Ÿå½“ä½œç¬¦å·ä½çœ‹å¾…ã€‚

æŒ‰ two's complement è¡¥ç è§„åˆ™ï¼Œè¦å°†ä¸€ä¸ªæ­£æ•°è½¬æ¢ä¸ºè´Ÿæ•°ï¼Œå°±éœ€è¦æŒ‰ä½å–åå†åŠ  1ã€‚é‚£ä¹ˆï¼Œä¸€ä¸ªè´Ÿæ•°è½¬æ¢ä¸ºæ­£æ•°ï¼Œå°±ç›¸åæ“ä½œã€‚äºŒè¿›åˆ¶çš„ 1111 è¡¨ç¤ºä¸€ä¸ªè´Ÿå€¼ï¼Œå‡ 1 å†å–åå°±æ˜¯ 1ï¼Œè¿™ä¸ªè´Ÿæ•°ä¹Ÿå°±æ˜¯ -1ã€‚

    1111 & 1010    1111 | 1010    1111 ^ 1010    1111 << 10     1111 & 10      ~ 1111 
    -----------    -----------    -----------    -----------    -----------    -----------
       1111           1111           1111           1111           1111              
     & 1010         | 1010         ^ 1010        << 0010        >> 0010         ~ 1111
    -------        -------        -------        -------        -------        -------
       1010           1111           0101           1100           1111           1111

è¿ç®—è§„åˆ™ï¼š

- & æ¯”ç‰¹ä¸ï¼Œä¸¤æ–¹åŒä¸º 1 ç»“æœå°±ä¸º 1 å¦åˆ™ä¸º 0ï¼›
- | æ¯”ç‰¹æˆ–ï¼Œæœ‰ä¸€æ–¹ä¸º 1 ç»“æœå°±ä¸º 1 å¦åˆ™ä¸º 0ï¼›
- ^ å¼‚æˆ– XORï¼Œä¸¤æ–¹ç›¸å¼‚ç»“æœå°±ä¸º 1ï¼Œå¦åˆ™ä¸º 0ï¼›
- a >> b å°†æ“ä½œæ•° a å¾€å³ç§»ä½ï¼Œb æŒ‡å®šæ¯”ç‰¹æ•°ï¼Œç¬¦å·ä½è¿›è¡Œå¡«å……ä¿æŒä¸å˜ï¼›
- a << b å°†æ“ä½œæ•° a å¾€å·¦ç§»ä½ï¼Œb æŒ‡å®šæ¯”ç‰¹æ•°ï¼Œè¦†ç›–ç¬¦å·ä½ï¼Œå³ä¾§å¡«å…… 0ï¼›
- ~ æŒ‰ä½å–åï¼Œéœ€è¦ç†è§£è¡¥ç ï¼Œä¾‹å¦‚ï¼Œ`~-1` å¾—åˆ° 0ï¼Œ`~-2` å¾—åˆ° 1ï¼Œå¦‚æœä¸æ¸…æ¥šè¡¥ç è§„åˆ™å°±ç›¸å½“è¿·æƒ‘ã€‚  

åœ¨åµŒå…¥å¼å¼€å‘ä¸­ï¼Œç”±äºèµ„æºæœ‰é™ï¼ŒåŒæ—¶ä¹Ÿæ¥è¿‘ç¡¬ä»¶åº•å±‚ï¼Œæ¯”ç‰¹è¿ç®—è¢«å¤§é‡é‡‡ç”¨ã€‚

æ¯”å¦‚ï¼Œè¦å°†æŸä¸ªæ¯”ç‰¹ç½®ä½ä»¥æ‰“å¼€æŸåŠŸèƒ½ï¼š

    x = x | SET_ON;

é€»è¾‘è¿ç®—ä¸æ¯”ç‰¹è¿ç®—å…·æœ‰åŒæ ·çš„é€»è¾‘æ¦‚å¿µï¼Œä½†å®ƒä»¬è¿˜æ˜¯èµ·ä¸åŒçš„ä½œç”¨çš„ï¼Œæ¯”å¦‚ï¼Œ1 && 2 ä¸ºçœŸï¼Œè€Œ 1 & 2 åˆ™ä¸º 0ã€‚å¹¶ä¸”ï¼Œé€»è¾‘è¿ç®—ç¬¦å·æœ‰çŸ­è·¯ç‰¹æ€§ï¼Œè€Œæ¯”ç‰¹è¿ç®—ç¬¦å·æ²¡æœ‰ã€‚

åˆ©ç”¨ä½è¿ç®—ï¼Œå¯ä»¥å®ç°æŸäº›åŠŸèƒ½ï¼Œå¦‚è½¬æ¢è‹±æ–‡å­—ç¬¦çš„å¤§å°å†™ï¼š

```c
('A' | ' ') == 'a';
('b' & '_') == 'B';
('d' ^ ' ') == 'D';
('D' ^ ' ') == 'd';
```

XOR è¿ç®—è¿˜ä¼šç”¨æ¥åšæ¸…é›¶æ“ä½œï¼Œä»»ä½•ä¸€ä¸ªæ•°æ®å’Œè‡ªèº«è¿›è¡Œ XOR è¿ç®—ç»“æœå°±ä¸º 0ï¼Œæˆ–è€…åšå–åæ“ä½œï¼Œåªè¦å°†ä¸€ä¸ªæ•°æ®å’Œä¸€ä¸ª -1 è¿›è¡Œ XOR å°±ç›¸å½“äº ~ æ“ä½œç¬¦å·åŠŸèƒ½ã€‚

ä½¿ç”¨ XOR è¿˜å¯ä»¥äº¤æ¢ä¸¤ä¸ªå˜é‡å€¼ï¼Œè¿™ä¸ªå¾ˆç¥å¥‡ï¼Œå¯ä»¥ç†è§£ä¸ºåŒä¸€ä¸ªæ“ä½œæ•°å¯¹å¦ä¸€ä¸ªæ“ä½œæ•°è¿›è¡Œä¸¤æ¬¡è¿ç»­ XOR æ“ä½œå€¼ä¸å˜ï¼Œ2 ^ 1 ^ 1 è¿˜æ˜¯ 2ï¼Œç”šè‡³è¿™ä¸ªç‰¹æ€§æ˜¯å–çš„ä¼ é€’æ€§çš„ï¼Œå¦‚ 5 ^ 24 ^ 5 ^ 16 ^ 24 ^ 5 ^ 16 ç»“æœè¿˜æ˜¯ 5ï¼Œåœ¨æ±‡ç¼–è¯­è¨€è¿™ç§åšæ³•å¾ˆå¸¸è§ï¼Œå‚è€ƒ Leetcode 136. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ï¼š

```c
int a = 1, b = 2;
a ^= b; // 0001 ^ 0010 => 0011
b ^= a; // 0010 ^ 0011 => 0001
a ^= b; // 0011 ^ 0001 => 0010
```

åˆ©ç”¨è´Ÿæ•°è¡¥ç å–ååŠ  1 çš„ç‰¹æ€§ï¼Œè¿˜å¯ä»¥å¯¹ä¸€ä¸ªæ•°è¿›è¡ŒåŠ  1 å‡ 1 çš„æ“ä½œï¼Œ`-~2` ç»“æœä¸º 3ï¼Œ`~-3` ç»“æœä¸º 2ã€‚è¿˜æœ‰ `n&(n-1)` ç”¨æ¥æ¶ˆé™¤ bit æœ€å³çš„ 1ï¼Œå¾ªç¯æ“ä½œå°±å¯ä»¥çŸ¥é“ä¸€ä¸ªæ•°æœ‰å‡ ä¸ª bit æ˜¯ 1ï¼Œè¿˜å¯ä»¥åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦ä¸º 2 çš„æ­£å¹‚ï¼Œè´Ÿå¹‚å¦‚ 1/2 å±äºæµ®ç‚¹æ•°åˆ¤æ–­ä¸äº†ï¼Œå‚è€ƒ Leetcode 231 Power of twoã€‚

ç§»ä½æ“ä½œç›¸å½“äºåšä¹˜æ³•è¿ç®—ï¼Œå¾€å·¦ç§» 1 bit å°±æ˜¯ä¹˜ 2ï¼Œå¾€å³å°±æ˜¯é™¤ 2ã€‚å¡«å……ç¬¦å·çš„ >> ä¹Ÿç§°ä¸ºç®—æœ¯ç§»ä½ï¼Œarithmetic shiftï¼Œæœ‰äº›æœºå™¨ä¸å¡«å……ç¬¦å·ä½ï¼Œè€Œå¡«å…… 0 å³é€»è¾‘ç§»ä½ logical shiftã€‚


å„ç§ä¸€å…ƒã€äºŒå…ƒã€ä¸‰å…ƒè¿ç®—ç¬¦ä¼˜å…ˆçº§å‚è€ƒï¼š

    Operators                     | Associativity            |
    ------------------------------|--------------------------|
    () [] -> .                    | left to right            |
    ! ~ ++ -- + - * (type) sizeof | right to left(Unary)     |
    * / %                         | left to right            |
    + -                           | left to right            |
    <<  >>                        | left to right            |
    < <= > >=                     | left to right            |
    == !=                         | left to right            |
    &                             | left to right            |
    ^                             | left to right            |
    |                             | left to right            |
    &&                            | left to right            |
    ||                            | left to right            | 
    ?:                            | right to left(Ternary)   |
    =                             | right to left            |
    ,                             | left to right            |

    Table 2.1: Precedence and Associativity of Operators

éœ€è¦æ³¨æ„ï¼Œä¸€å…ƒè¿ç®—ç¬¦å·ï¼Œå¦‚ & + - * ç­‰é€‰æ‹©ä¼˜å…ˆçº§é«˜äºåœ¨éƒ¨åˆ†äºŒå…ƒè¿ç®—ç¬¦å·ï¼ŒUnary > Binaryï¼Œé™¤åœ†æ‹¬å·ã€ä¸‹æ ‡æ–¹æ‹¬å·å’Œæˆå‘˜è¿ç®—ç¬¦å·ã€‚ 

å¦å¤–ï¼Œæ¯”ç‰¹ä½è¿ç®—ç¬¦ä¼˜å…ˆçº§æ¯”å…³ç³»è¿ç®—ç¬¦ä½ã€‚æŒ‰ä½å–åï¼Œé€»è¾‘ä¸æˆ–é 3 ç§æ“ä½œç¬¦å·ï¼Œä¸‰å…ƒæ“ä½œç¬¦å·ï¼Œè¿˜æœ‰å…³ç³»è¿ç®—ç¬¦å·ä¸èƒ½å’Œèµ‹å€¼ç¬¦å·ç»„åˆã€‚

èµ‹å€¼å·ï¼ŒåŒ…æ‹¬ç»„åˆèµ‹å€¼ç¬¦å·éƒ½æ˜¯ç›¸åŒçš„ä¼˜å…ˆçº§ï¼Œæ˜¯å±äºæœ€ä½çš„è¿ç®—ç¬¦å·ï¼ŒåŒ…æ‹¬ä»¥ä¸‹è¿™äº›ï¼š

    += -= *= /= %= &= ^= |= <<= >>=

å…¶å®ï¼Œæ²¡ä»€ä¹ˆä¼˜å…ˆçº§é—®é¢˜æ˜¯ä¸èƒ½é€šè¿‡ () è§£å†³çš„ï¼Œå¦‚æœæœ‰ï¼Œé‚£å°±å†æ¥ä¸€å¯¹åœ†æ‹¬å·ã€‚

æœ€åï¼Œé€—å·ä¹Ÿæ˜¯ä¸€ä¸ªè¿ç®—ç¬¦å·çš„å­˜åœ¨ï¼Œå®ƒçš„ä½œç”¨ä¸æ˜¯è¿›è¡Œè¿ç®—ï¼Œè€Œåœ¨ç”¨æ¥åˆ†éš”è¡¨è¾¾å¼ï¼Œæˆ–è€…è¯´ç¼–å†™å¤šæ¡è¡¨è¾¾å¼ï¼Œä»å·¦åˆ°å³æ‰§è¡Œã€‚è¿”å›é€—å·åˆ—è¡¨ä¸­æœ€åä¸€ä¸ªæ“ä½œæ•°ï¼Œä¾‹å¦‚ c = (3, 2) ä¼šå°† 2 èµ‹å€¼ç»™ cã€‚åœ¨å®šä¹‰å˜é‡æ—¶ï¼Œæˆ– forã€while ç­‰å¾ªç¯ç»“æ„ä¸­çš„è¯­è¨€ä¸­ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨é€—å·æ¥æ·»åŠ å¤šæ¡è¡¨è¾¾å¼ã€‚ä½†æ˜¯ï¼Œå‡½æ•°å‚æ•°åˆ—è¡¨ä¸­çš„é€—å·å¹¶ä¸æ˜¯é€—å·æ“ä½œç¬¦ã€‚

ä¾‹å¦‚ï¼Œåè½¬ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¿™é‡Œçš„ i++, j-- çš„ç”¨æ³•åœ¨ç®—æ³•ä¸Šæ˜¯ååˆ†é«˜è¶…çš„ï¼š

```c
#include <string.h>

/* reverse:  reverse string s in place */
void reverse(char s[])
{
   int c, i, j;

   for (i = 0, j = strlen(s)-1; i < j; i++, j--) {
       c = s[i];
       s[i] = s[j];
       s[j] = c;
   }
}
```

å¦‚æœä¸æ˜¯è¿™æ ·çš„ç»“æ„å°†ä¼šç´¯èµ˜å¾ˆå¤šï¼Œå˜é‡å¤šäº†ï¼Œç»“æ„ä¹Ÿéº»çƒ¦ï¼š

```c
/* reverse:  reverse string s in place */
void reverse(char s[])
{
   int c, i, j, k = strlen(s)%2;
   for (i = 0, j = strlen(s); i < j/2; i++) {
       c = s[i];
       s[i] = s[j-i-k];
       s[j-i-k] = c;
   }
}
```


## ==âš¡ ch3 - Control Flow

æµç¨‹æ§åˆ¶æ˜¯ç¨‹åºç»“æ„çš„åŸºæœ¬ç»„ç»‡æ–¹å¼ï¼Œæœ‰ forï¼Œwhileï¼Œdo-while å¾ªç¯ç»“æ„ï¼Œè¿˜æœ‰ switch-case åˆ†æ”¯é€‰æ‹©ç»“æ„ï¼Œè¿˜æœ‰ if-else æ¡ä»¶åˆ¤æ–­ç»“æ„ã€‚

æ‰€è°“æµç¨‹æ§åˆ¶ï¼Œå°±æ˜¯æ ¹æ®æ¡ä»¶åˆ¤æ–­ï¼Œé€‰æ‹©ä¸‹ä¸€æ­¥è¦æ‰§è¡Œçš„ä»£ç ï¼Œå¦‚ä¸‹ï¼ŒèŠ±æ‹¬å·çš„ä»£ç åªä¼šåœ¨ a ä¸º true æ—¶ç­‰ç­‰ä»·ä¸º true æ—¶æ‰§è¡Œï¼š

```c
if(a){
    // execute when a is true
}
```

for å’Œ whileï¼Œæˆ–è€… switch-case å’Œ if-else å®ƒä»¬éƒ½å¯ä»¥ç›¸äº’è½¬æ¢ï¼Œç”¨ä¸åŒçš„ç»“æ„å®ç°ç›¸åŒçš„æµç¨‹æ§åˆ¶ã€‚

åœ¨å¾ªç¯ç»“æ„ä¸­ï¼Œä½¿ç”¨ `break` å…³é”®å­—æ¥æ‰“æ–­å¾ªç¯ï¼Œä½¿ç”¨ `continue` æ¥è·³è¿‡æœ¬è½®æ‰§è¡Œã€‚


### ===ğŸ‘‰ if-else & Prime Number

æ¡ä»¶åˆ¤æ–­ç»“æ„æœ‰ä»¥ä¸‹ 3 ä¸ªåŸºæœ¬å½¢å¼ï¼Œelse if å¯ä»¥æ— é™åˆ¶åœ°æ·»åŠ ï¼š

```c
if(condition) { ... }
if(condition) { ... } else { ... }
if(condition) { ... } else if(condition) { ... }
```

å½“è¯­å¥å—ï¼Œå³èŠ±æ‹¬å·ä¸­åªæœ‰ä¸€æ¡è¯­å¥æ—¶ï¼Œå¯ä»¥çœç•¥èŠ±æ‹¬å·ï¼Œä½†é€šå¸¸ä¸å»ºè®®è¿™æ ·åšã€‚


åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦ä¸ºè´¨æ•°æ˜¯ä¸€ä¸ªéå¸¸ä¸é”™çš„ç®—æ³•è®­ç»ƒé¢˜ç›®ï¼Œè´¨æ•°åˆ†å¸ƒæ˜¯ä¸€ä¸ªæœ‰è¶£çš„é—®é¢˜ï¼Œæ¬§æ‹‰å‘ç°è´¨æ•°ä¼—å¤šçš„ä¸€æ¡ç›´çº¿ç©ºé—´ï¼š

    f(n)=n^2-n+41

é‚£ä¹ˆç»™å®šä¸€ä¸ªå€¼ï¼Œå¦‚ä½•åˆ¤æ–­æ˜¯å¦ä¸ºè´¨æ•°å‘¢ï¼Ÿ

å®šä¹‰ï¼šé™¤äº† 1 å’Œå®ƒæœ¬èº«ä»¥å¤–ï¼Œä¸èƒ½è¢«ä»»ä½•æ•´æ•°æ•´é™¤çš„è‡ªç„¶æ•°å°±æ˜¯è´¨æ•°ï¼ŒPrime ä¹Ÿå«ç´ æ•°ï¼Œä¾‹å¦‚ 17 å°±æ˜¯ç´ æ•°ã€‚

é‚£ä¹ˆç»™å®šä¸€ä¸ªæ•° nï¼Œå¯ä»¥ç›´è§‚åœ°æšä¸¾æ‰€æœ‰ 2 - n çš„æ•°ï¼Œçœ‹æ˜¯å¦å¯ä»¥æ•´é™¤ã€‚å½“ç„¶è¿™ç§åšæ³•ç›¸å½“æ²¡æœ‰æ•ˆç‡ï¼Œè¦çŸ¥é“ï¼Œä»»ä½•ä¸€ä¸ªæ•°å¦‚æœå¯ä»¥åˆ†è§£ä¸ºä¸¤ä¸ªæ•´æ•°ç›¸ä¹˜ï¼Œå¿…ç„¶å…¶ä¸­ä¸€ä¸ªæœ€å¤§å€¼ä¸å¤§äº sqrt(n)ã€‚

å†å˜é€šä¸€ä¸‹ï¼Œå‡è®¾è¦æ±‚ 100 ä»¥å†…çš„è´¨æ•°ï¼Œåªéœ€è¦æ‰¾åˆ°ä¸€ä¸ªè´¨æ•°çš„å¹³æ–¹å¤§äº 100 çš„ä½œä¸ºåˆ†ç•Œç‚¹ï¼Œå¹¶ä¸”æ‰¾å‡ºå°äºè¿™ä¸ªå€¼çš„æ‰€æœ‰è´¨æ•°ä½œä¸ºä¸€ä¸ªé™¤æ•°åˆ—è¡¨ï¼Œå¹¶é€šè¿‡è¿™ä¸ªåˆ—è¡¨æ¥æ£€æŸ¥å…¶å®ƒè´¨æ•°ï¼š

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

bool isPrimeIn100(int n){
    int p[] = {2, 3, 5, 7, 11};
    int i, len = sizeof p / sizeof *p;
    if(n<4 && n>0) return true;
    for(i=0; i<len; i++){
        if(n % p[i] == 0 && n != p[i]) return false;
    }
    return true;
}

int main() 
{ 
    int c;

    printf("You would be supposed to type a number: ");
    int succ = scanf("%i", &c);
    if (succ!=1){
        printf("%d may be EOF.\n", succ);
        return EXIT_FAILURE;
    }

    if (0 >= c){
        printf("%d is zero or below.\n", c);
    } else if (isPrimeIn100(c)) {
        printf("%d is a Prime Number.\n", c);
    } else if (100 < c) {
        printf("%d is greater then 100.\n", c);
    } else {
        printf("%d is Composite Number.\n", c);
    }
    
    printf("PrimeQ below 100:\n");
    for(c = 0; c<=100; c++){
        if (isPrimeIn100(c)) printf("%d ", c);
    }
    return EXIT_SUCCESS;
}
```

100 ä»¥å†…çš„è´¨æ•°å¾ˆå®¹æ˜“æ‰¾ï¼Œä½†æ˜¯å¤§è´¨æ•°çš„èŒƒå›´å°±ä¸èƒ½æ‰‹å·¥å»ºè¡¨äº†ï¼Œéœ€è¦é€šè¿‡ç¨‹åºå¤„ç†ã€‚

```c
void primeQ(){
    int lim = 100;
    int can = new Array(lim);
    for (int i = 2; i <= lim; i++){
        can[i] = 1;
    }
    for (int i=2; i <= lim; i++){
        for (int j = 2*i; j <= lim; j+=i){
            can[j] = 0;
        }
    }
    for (int i=2; i <= lim; i++){
        if (1 == can[i]) printf("%d\t", can[i]);
    }
}
```

### ===ğŸ‘‰ for loop
- https://www.programiz.com/dsa/insertion-sort
- https://www.tutorialspoint.com/data_structures_algorithms/shell_sort_algorithm.htm

for å¾ªç¯å’Œ while æ˜¯å¯ä»¥äº’ç›¸æ›¿æ¢ç»“æ„ï¼Œåªæ˜¯è¯­æ³•ç»“æ„ä¸Šçš„å·®åˆ«ã€‚

```c
#include <stdio.h>
#include <stdlib.h>

int main() 
{ 
    int c = 'a';

    // while (c <= 'z'){
    //     printf("%c", c++);
    // }
    
    // for (; ; ){
    //     printf("%c", c++);
    //     if(c > 'z') break;
    // }

    for (; c <= 'z'; ){
        printf("%c", c++);
    }

    return EXIT_SUCCESS;
}
```

for å¾ªç¯çš„åœ†æ‹¬å·ä¸­æœ‰ä¸‰æ¡è¯­å¥ï¼Œä¾æ¬¡åˆ†åˆ«æ˜¯ï¼š

- æ¡ä»¶åˆå§‹åŒ–è¯­å¥ï¼Œåªæ‰§è¡Œä¸€æ¬¡ï¼›
- æ¡ä»¶åˆ¤æ–­è¯­å¥ï¼Œåœ¨æ¯æ¬¡æ‰§è¡Œå¾ªç¯ä½“å‰åˆ¤æ–­æ˜¯è¦ç»§ç»­å¾ªç¯ï¼›
- æ¡ä»¶æ›´æ–°è¯­å¥ï¼Œåœ¨æ¯å›å¾ªç¯åæ‰§è¡Œæ¡ä»¶çš„æ›´æ–°æ“ä½œï¼›

å®ƒä»¬éƒ½æ˜¯å¯é€‰çš„ï¼Œå¯ä»¥ç•™ç©ºï¼Œä½¿ç”¨ if æ¡ä»¶åˆ¤æ–­ç»“åˆ break æ¥ç»“æŸå¾ªç¯ã€‚ 

æ•™æä¸ºäº†è§£æ for å¾ªç¯ï¼Œæ¼”ç¤ºäº† shellsort æ’åºç®—æ³•ï¼š

```c
/* shellsort:  sort v[0]...v[n-1] into increasing order */
void shellsort(int v[], int n)
{
   int gap, i, j, temp;

   for (gap = n/2; gap > 0; gap /= 2)
       for (i = gap; i < n; i++)
           for (j=i-gap; j>=0 && v[j]>v[j+gap]; j-=gap) {
               temp = v[j];
               v[j] = v[j+gap];
               v[j+gap] = temp;
           }
}
```

è¿™æ˜¯ä¸€ä¸ªä¸‰å±‚ for åµŒå¥—çš„å‡½æ•°ç»“æ„ï¼Œå¤–å±‚å®šä¹‰ gap è´Ÿè´£æ§åˆ¶ä¸¤ä¸ªå­é›†æ¯”è¾ƒçš„ç²’åº¦ï¼Œä» n/2 åˆ° 1 çš„ç²’åº¦é€æ¬¡ç¼©å°ã€‚ä¸­é—´å±‚è´Ÿè´£éå†æ‰€æœ‰æ•°æ®ï¼Œè€Œæœ€å†…å±‚è´Ÿè´£æ¯”è¾ƒå¹¶æ›´æ–°é¡ºåºã€‚

åœ¨å¤šä¸ªåµŒå¥—å¾ªç¯ä¿æŒå¾ªç¯æ§åˆ¶é›†ä¸­çš„ä¼˜åŠ¿æ˜æ˜¾ï¼ŒShell sort è¿™ç§æ’åºç®—æ³•çš„åŸºæœ¬æ€æƒ³æ˜¯ D. L. Shell è®¾è®¡çš„ï¼Œåœ¨æ¯”è¾ƒåˆæœŸé˜¶æ®µï¼Œç”¨ç²—ç²’åº¦é—´è·å¯¹å…ƒç´ è¿›è¡Œç²—æ’ï¼Œè€Œä¸æ˜¯ç®€å•çš„äº¤æ¢ç›¸é‚»çš„å…ƒç´ ã€‚è¿™ç§ç²—æ’å¾€å¾€ä¼šå¾ˆå¿«æ¶ˆé™¤å¤§é‡çš„ç´Šä¹±ï¼Œä½¿åæœŸçš„å·¥ä½œæ›´å°‘ã€‚éšç€æ¯”è¾ƒå…ƒç´ ä¹‹é—´çš„é—´éš”é€æ¸å‡å°ä¸º 1ï¼Œæ­¤æ—¶æ’åºæœ‰æ•ˆåœ°æˆä¸ºç›¸é‚»äº¤æ¢æ–¹æ³•ï¼Œæ‰€æœ‰å…ƒç´ æœ€ç»ˆéƒ½ä¼šæ­£ç¡®æ’åºã€‚

æ³¨æ„ for çš„é€šç”¨æ€§ä½¿å¤–å¾ªç¯ä¸å…¶ä»–å¾ªç¯ä»¥ç›¸åŒçš„å½¢å¼æ‹Ÿåˆï¼Œå³ä½¿å®ƒä¸æ˜¯ç®—æœ¯çº§æ•°ï¼Œå³å¯ä»¥æŒ‡å®š step å€¼ã€‚æ­£æ˜¯è¿™ç§é€æ¬¡å‡åŠçš„ç²’åº¦æ§åˆ¶ï¼Œä½¿ç”¨å¾—æ‰€æœ‰æ•°æ®éƒ½å¾—åˆ°æ­£å¸¸çš„æ’åºï¼Œè€Œä¸è¢«é—æ¼ã€‚

åˆ—å¦‚ï¼Œå¯¹ä¸€ä¸ªå•è¯çš„å­—æ¯è¿›è¡Œæ’åºï¼š

    supposed <- gap = 4
    ^   ^
    ouppssed
     ^   ^
    osppsued
      ^   ^
    osepsupd
       ^   ^
    osedsupp <- gap = 2
    ^ ^
    esodsupp
     ^ ^
    edossupp
        ^ ^
    edospusp
         ^ ^
    edosppsu
       ^ ^
    edoppssu
    ^^
    deoppssu

Insertion sort æ˜¯å’Œ Bubbble sort å·®ä¸å¤šéš¾åº¦çš„ç®—æ³•ï¼Œå’Œæ‰“æ‰‘å…‹ç‰Œæ—¶å¯¹æ‰‹ä¸Šçš„å¡ç‰‡è¿›è¡Œæ’åºçš„è¿‡ç¨‹ç±»ä¼¼ï¼Œå…ˆä»¥ç¬¬ä¸€å¼ ä½œä¸ºå‚è€ƒï¼Œæ¯”è¾ƒä¸€ä¸‹ç¬¬äºŒå¼ ï¼Œç„¶åå°†å°çš„æ”¾å‰é¢ï¼Œå³äº¤æ¢ä½ç½®ã€‚å†ç”¨ç¬¬ä¸‰å¼ å’Œå‰é¢çš„æ¯”è¾ƒï¼Œå¦‚æœæ¯”å‰é¢ä¸€å¼ è¦å¤§å°±è¡¨ç¤ºå·²ç»æ˜¯ä»å°åˆ°å¤§æ’åºå¥½äº†ï¼Œé‡å¤è¿™ä¸ªæ“ä½œç›´åˆ°æ‰€æœ‰ç‰Œéƒ½æ’åºå®Œæ¯•ã€‚

è¿™æ ·çš„ç®—æ³•å¯¹å°‘é‡çš„æ•°æ®æ˜¯å¾ˆæœ‰æ•ˆç‡çš„ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n^2)ï¼Œéšç€æ•°æ®æ•°é‡çš„å¢åŠ ï¼Œæ—¶é—´è¦æ±‚æŒ‰ 2 æ¬¡æ–¹å¢åŠ ï¼Œå¦‚æœèƒ½å¯¹å‰é¢å·²æ’åºçš„æ•°æ®è¿›è¡ŒäºŒåˆ†æ³•æŸ¥æ‰¾å°†å¤§é‡èŠ‚çœæ—¶é—´ï¼Œå¯¹æœ‰åºæ•°æ®è¿›è¡Œ Binary search æŠ˜åŠæŸ¥æ‰¾ï¼Œåœ¨å¤§é‡æ•°æ®å¤„ç†ä¸­æ•ˆç‡æ˜¯æ˜æ˜¾çš„ï¼Œå®ƒèƒ½å°† isort ç®—æ³•å†…å±‚çš„ for å¾ªç¯ï¼Œå³æŸ¥æ‰¾éƒ¨åˆ†çš„æ—¶é—´å¤æ‚åº¦é™ä¸º ÎŸ(log n)ï¼Œè€Œä¸æ˜¯ Linear search çš„ O(n^2)ï¼Œå¯¹äºå¤§é‡æ•°æ®çš„æ’åºï¼Œisort çš„ä¸»è¦æ¶ˆè€—å°±åœ¨å†…å±‚å¾ªç¯ã€‚

```c
int isort(unsigned char a[], int n){
   unsigned char k;
   for (size_t i = 1; i < n; i++)
   {
       k = a[i];
       for (size_t j = i; j > 0; j--)
       {
           if (k < a[j-1]) {
               a[j] = a[j-1];
               a[j-1] = k;
           }
       }
   }
   return n;
}

unsigned char s[0xff] = "You would supposed to type some words:";
printf("%s\n", s);
scanf("%[^\n]", s);
isort(s, strlen(s));
printf("isort:%s", s);
```

scanf å¯ä»¥ç”¨æ¥è·å–ä¸€è¡Œå†…å®¹è¾“å…¥ï¼Œä½†æ˜¯ä¸èƒ½å¤„ç†é ASCII å­—ç¬¦ï¼Œå¦‚ "French suits of trÃ¨fles" å°†è·å–ä¸åˆ°åé¢çš„ 4 ä¸ªå­—ç¬¦ã€‚


### ===ğŸ‘‰ while & do-while

å‰é¢çš„ç¤ºèŒƒç¨‹åºå·²ç»æ¼”ç¤ºè¿‡ while å¾ªç¯çš„ä¸¤ç§å½¢å¼ï¼Œè¿™é‡Œå†å°†å®ƒä»¬æ”¾åˆ°ä¸€èµ·å±•ç¤ºï¼š

```c
#include <stdio.h>
#include <stdlib.h>

int main() 
{ 
    int c = 'a';

    while (c <= 'z'){
        printf("%c", c++);
    }

    do {
        c = getchar();
        if (c=='x') break;
        if (c!='\n') putchar(c);
    } while (c != EOF);

    printf("End of File: %d", c);
    return EXIT_SUCCESS;
}
```

åœ¨æ•™æä¸­ï¼Œæä¾›äº†ä¸€ä¸ª itoa å‡½æ•°çš„å®ç°ï¼Œç”¨æ¥å°†ä¸€ä¸ªæ•°å€¼è½¬æ¢æˆå­—ç¬¦ï¼Œä½¿ç”¨åˆ°äº†å‰é¢å·²ç»å®ç°çš„ reverse å‡½æ•°ï¼š

```c
/* itoa:  convert n to characters in s */
void itoa(int n, char s[])
{
   int i, sign;

   if ((sign = n) < 0)  /* record sign */
       n = -n;          /* make n positive */
   i = 0;
   do {      /* generate digits in reverse order */
       s[i++] = n % 10 + '0';  /* get next digit */
   } while ((n /= 10) > 0);    /* delete it */
   if (sign < 0)
       s[i++] = '-';
   s[i] = '\0';
   reverse(s);
}
```

è¿™ä¸ª itoa çš„å®ç°å’Œè®¾æƒ³çš„å·®ä¸å¤šï¼Œå°±æ˜¯é€šè¿‡æ•°å€¼è¾—è½¬é™¤ 10 å–å‡ºä½™æ•°ï¼Œå¹¶ä¸ '0' å­—ç¬¦ç å€¼ç›¸åŠ å¾—åˆ°æ•°å­—ï¼Œæœ€åå¾—åˆ°å­—ç¬¦ä¸²ã€‚

å¦å¤–ï¼Œè¦å¤„ç†å¥½ç¬¦å·ï¼Œè¿˜æœ‰ null-terminated ç»“æŸæ ‡è®°ã€‚


### ===ğŸ‘‰ switch case

switch æ¡ä»¶é€‰æ‹©ç»“æ„å’Œ if-else ç±»ä¼¼ï¼Œå¯ä»¥ç›¸äº’è½¬åŒ–ï¼Œå…¶å®ƒå½¢å¼å¦‚ä¸‹ï¼š

```c
switch (expression) {
   case const-expr: statements
   case const-expr: statements
   default: statements
}
```

case åæ˜¯å¸¸é‡è¡¨è¾¾å¼ï¼Œç”¨æ¥åŒ¹é… switch è¡¨è¾¾å¼äº§ç”Ÿçš„ç»“æœï¼ŒåŒ¹é…ä¸­çš„åˆ†æ”¯å°±æ˜¯æ‰§è¡Œæµç¨‹çš„å…¥å£ï¼Œé‡åˆ° `break` å…³é”®å­—ä¸ºæ­¢ï¼Œå¦‚æœæ²¡åŒ¹é…ä¸­çš„åˆ†æ”¯ï¼Œå°±æ‰§è¡Œ `default` åˆ†æ”¯ï¼š

```cpp
#include <stdio.h>

int main()  /* count digits, white space, others */
{
    int c, i, nwhite, nother, ndigit[10];

    nwhite = nother = 0;
    for (i = 0; i < 10; i++)
        ndigit[i] = 0;
    while ((c = getchar()) != EOF && c != 'x') {
        if (c=='x') break;
        switch (c) {
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
            ndigit[c-'0']++;
            break;
        case ' ':
        case '\n':
        case '\t':
            nwhite++;
            break;
        default:
            nother++;
            break;
        }
    }
    printf("digits =");
    for (i = 0; i < 10; i++)
        printf(" %d", ndigit[i]);
    printf(", white space = %d, other = %d\n",
        nwhite, nother);
    return 0;
}
```

æ¯ä¸ªåˆ†æ”¯å¯ä»¥ç¼ºçœä»£ç å—ï¼Œä¹Ÿå¯ä»¥ä¸éœ€è¦ `break`ï¼Œä½†éœ€è¦å®ƒçš„æ—¶å€™ä¸èƒ½å¿˜è®°å®ƒã€‚

è™½ç„¶ï¼Œswitch å’Œ if-else å¯ä»¥äº’ç›¸è½¬åŒ–ï¼Œä½†æ˜¯ case è¿™ç§åˆ†æ”¯ç»“æ„ä½¿å¾— switch æ›´é€‚åˆç”¨äºé‚£äº›å¯¹å¤šä¸ªæ¡ä»¶è¿›è¡Œå¤„ç†çš„åœºåˆã€‚

### ===ğŸ‘‰ Goto and labels

goto è¿™ç§æ— æ¡ä»¶çš„è·³è½¬æ˜¯æ±‡ç¼–æ—¶ä»£çš„é—äº§ï¼Œåœ¨é«˜çº§è¯­è¨€ä¸­æ˜¯å¾ˆå°‘è§çš„ï¼Œå¹¶ä¸”ä¹Ÿæå°‘ä½¿ç”¨ï¼Œå› ä¸ºå¤§é‡ä½¿ç”¨å®ƒå¸¦çš„è´Ÿä½œç”¨æ›´å¤§ã€‚

åŸºæœ¬ç»“æ„å¦‚ä¸‹ï¼Œgoto è¯­å¥éœ€è¦é…åˆè¡Œæ ‡æ¥å®ç°æµç¨‹è·³è½¬ï¼š

```c
   for ( ... )
       for ( ... ) {
           ...
           if (disaster)
               goto error;
       }
   ...
error:
   /* clean up the mess */
```

å½“ç„¶ï¼Œgoto ç”¨åœ¨å¤šå±‚å¾ªç¯çš„ç»“æŸç¡®å®å¾ˆæ–¹ä¾¿ï¼Œä½†æ˜¯å¯ä»¥ç”¨å‡½æ•° return è¯­å¥æ¥æ›¿ä»£å®ƒã€‚


## ==âš¡ ch4 - Functions and Program Structure

C è¯­è¨€æ˜¯æœ€æˆåŠŸçš„å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ï¼Œæ—©æœŸçš„ç¼–ç¨‹è¯­è¨€å¤šæ•°é¢å‘è¿‡ç¨‹è®¾è®¡çš„ã€‚æ‰©å±• C++ åï¼Œåœ¨å‡½æ•°å¼ç¼–ç¨‹çš„åŸºç¡€ä¸Šï¼Œåˆå®ç°äº†é¢å‘å¯¹è±¡ç¼–ç¨‹ã€‚

åœ¨è°ˆè®ºä¸€é—¨è¯­è¨€ä»¥ä»€ä¹ˆæ–¹å¼ç¼–ç¨‹ï¼Œæˆ–è€…è¯´ç¼–ç¨‹æ€æƒ³ï¼Œé€šå¸¸ä½¿ç”¨ç¼–ç¨‹èŒƒå¼çš„æ¦‚å¿µï¼ŒProgramming Paradigm è¿›è¡Œæè¿°ï¼š

- ç¬¬ä¸€èŒƒå¼ å‘½ä»¤å¼ï¼ŒåŒ…æ‹¬è¿‡ç¨‹å¼ã€ç»“æ„åŒ–è¿‡ç¨‹ç­‰ç­‰ã€‚
- ç¬¬äºŒèŒƒå¼ å£°æ˜å¼ï¼ŒåŒ…æ‹¬å‡½æ•°å¼ã€æ•°æ®æµå¼ç­‰ç­‰ã€‚
- ç¬¬ä¸‰èŒƒå¼ å…ƒç¼–ç¨‹ï¼ŒåŒ…æ‹¬é¢å‘å¯¹è±¡ã€æ³›å‹ã€åå°„åŒ–ç­‰ç­‰ã€‚

å‡½æ•°å¼ä½œä¸ºä¸»æµçš„ç¼–ç¨‹èŒƒå¼ï¼Œä»¥å‡½æ•°ä¸ºç¬¬ä¸€å…¬æ°‘ï¼Œé€šè¿‡å‡½æ•°çš„å¯ä»¥å°†æ•´ä¸ªå·¥ç¨‹åˆ†è§£ä¸ºåŠŸèƒ½ç›¸å¯¹ç‹¬ç«‹çš„ä¸€ä¸ªä¸ªå‡½æ•°ã€‚

å‡½æ•°å¯ä»¥é€’å½’è°ƒç”¨ Recursionï¼Œå³åœ¨å‡½æ•°å†…éƒ¨è°ƒç”¨å‡½æ•°è‡ªèº«ã€‚

æ¯ä¸ªå‡½æ•°å…·æœ‰ä¸€ä¸ªåç§°ï¼Œè¿˜æœ‰è¿”å›å€¼å’Œå‚æ•°åˆ—è¡¨ï¼Œä»¥åŠå‡½æ•°ä½“ã€‚

å‡½æ•°è¯­æ³•ï¼š

    return-type function-name(argument declarations)
    {
        declarations and statements
    }

æ¯”å¦‚ï¼Œåœ¨æ–‡æœ¬ä¸­æœç´¢å«æœ‰ ould çš„è¡Œï¼š

    Ah Love! could you and I with Fate conspire
    To grasp this sorry Scheme of Things entire,
    Would not we shatter it to bits -- and then
    Re-mould it nearer to the Heart's Desire!

é‚£ä¹ˆå®ç°è¿™ä¸ªä¸€ä¸ªç¨‹åºï¼Œå¯ä»¥å°†ä¸åŒçš„åŠŸèƒ½åˆ†è§£ä¸ºä¸€ä¸ªä¸ªå‡½æ•°ï¼Œæœ€åç»„åˆåœ¨ä¸€èµ·å®ç°éœ€è¦çš„ç¨‹åºï¼š

- è¯»å–æ–‡æœ¬çš„å‡½æ•° getlineï¼›
- å­—ç¬¦ä¸²æœç´¢å‡½æ•° strindex;

åœ¨ä¸»å‡½æ•°ä¸­å¾ªç¯å¤„ç†å„è¡Œå³å¯ï¼š

```c
#include <stdio.h>
#define MAXLINE 1000 /* maximum input line length */

int getline(char line[], int max);
int strindex(char source[], char searchfor[]);

char pattern[] = "ould";   /* pattern to search for */

/* find all lines matching pattern */
main()
{
   char line[MAXLINE];
   int found = 0;

   while (getline(line, MAXLINE) > 0)
       if (strindex(line, pattern) >= 0) {
           printf("%s", line);
           found++;
       }
   return found;
}

/* getline:  get line into s, return length */
int getline(char s[], int lim)
{
   int c, i;

   i = 0;
   while (--lim > 0 && (c=getchar()) != EOF && c != '\n')
       s[i++] = c;
   if (c == '\n')
       s[i++] = c;
   s[i] = '\0';
   return i;
}

/* strindex:  return index of t in s, -1 if none */
int strindex(char s[], char t[])
{
   int i, j, k;

   for (i = 0; s[i] != '\0'; i++) {
       for (j=i, k=0; t[k]!='\0' && s[j]==t[k]; j++, k++)
           ;
       if (k > 0 && t[k] == '\0')
           return i;
   }
   return -1;
}
```

å‡½æ•°ä½¿ç”¨å‰éœ€è¦è¿›è¡Œå£°æ˜ï¼Œå³å‘Šè¯‰ç¼–è¯‘å™¨è¿™æ˜¯ä¸€ä¸ªå‡½æ•°ç¬¦å·ï¼Œè€Œä¸æ˜¯å˜é‡æˆ–å…¶ç¬¦å·ï¼š

```c
int getline(char line[], int max);
int strindex(char source[], char searchfor[]);
```

å£°æ˜å‡½æ•°åªéœ€è¦å‡½æ•°å¤´ï¼Œæˆ–è€…å«åšå‡½æ•°ç­¾åï¼Œä¹Ÿå«ä½œ Function Prototypesï¼Œä¸éœ€è¦èŠ±æ‹¬å·éƒ¨åˆ†çš„ä»£ç ï¼Œå³ä¸éœ€è¦å‡½æ•°çš„å®ç°ã€‚æœ‰äº†è¿™ä¸ªåŸå‹ä¿¡æ¯ï¼Œç¼–è¯‘å™¨å°±çŸ¥é“å¦‚ä½•è°ƒç”¨è¿™ä¸ªå‡½æ•°ã€‚

å‡½æ•°å£°æ˜å¯ä»¥å’Œå˜é‡å£°æ˜åœ¨ä¸€èµ·ï¼š

```c
int sum, getline(char [], int lim);
```

ç»˜å‡½æ•°ä¼ é€’å‚æ•°æ—¶ï¼Œä¼šåœ¨ä¸»è°ƒå‡½æ•°ä¸­å°†å‚æ•°ä¼ ä¸‹å‹å…¥æ ˆå†…å­˜ï¼Œåœ¨è¢«è°ƒå‡½æ•°ä¸­é€šè¿‡æ ˆå†…å­˜æ¥è·å–ä¼ å…¥å‚æ•°ã€‚è¿™ä¸ªè¿‡ç¨‹ç›¸åº”äºå°†å˜é‡å¤åˆ¶äº†ä¸€ä¸ªå‰¯æœ¬ï¼Œæ‰€ä»¥ä¿®æ”¹ä¼ å…¥çš„å‚æ•°ä¸ä¼šå½±å“åŸæ¥çš„å˜é‡ï¼Œå¦‚æœéœ€è¦ä¿®æ”¹åŸå˜é‡ï¼Œå°±éœ€è¦ä½¿ç”¨æŒ‡é’ˆæ¥å¼•ç”¨åŸå˜é‡ã€‚

ä¾‹å¦‚ï¼Œå®ç°ä¸€ä¸ª swap å‡½æ•°æ¥äº¤æ¢ä¸¤ä¸ªå˜é‡ï¼š

```c
void swap(int *a, int *b)
{
    int t = *a;
    *a = *b;
    *b = t;
}
```

åœ¨ä¼ å…¥ç»“æ„ä½“å˜é‡æ—¶ï¼Œéœ€è¦è€ƒè™‘æ€§èƒ½ï¼Œé€‰æ‹©åˆé€‚çš„ä¼ å‚æ–¹å¼ï¼Œå¦‚æœå¯èƒ½å°½é‡ä¼ é€’ç»“æ„ä½“æˆ–å…¶æˆå‘˜çš„æŒ‡é’ˆï¼Œä»¥å®ç°é«˜æ•ˆç‡ã€‚

ä½†æ˜¯ï¼Œä¸å¾—ä¸è€ƒè™‘æµ…æ‹·è´é—®é¢˜ï¼ŒShadow copy è¿™æ˜¯ç¼–è¯‘å™¨å¯ä»¥å®ç°çš„æ‹·è´ã€‚å¦‚æœç»“æ„ä½“æˆå‘˜å­˜åœ¨æŒ‡é’ˆå¼•ç”¨å…¶å®ƒæ•°æ®å˜é‡æ—¶ï¼Œåˆ™éœ€è¦è¿›è¡Œæ·±å±‚æ‹·è´ Deep copyã€‚

é€šå¸¸ï¼Œåœ¨å·¥ç¨‹ä¸­ä¼šä»¥å‡½æ•°åº“çš„æ–¹å¼ç»„ç»‡ï¼Œå°†å‡½æ•°çš„å®ç°ä»£ç æ”¾åˆ°ä¸“é—¨çš„æ–‡ä»¶ä¸­ï¼Œå¹¶ä¸”æä¾›ç›¸åº”çš„å¤´æ–‡ä»¶ï¼Œå‚è€ƒå¦‚ä¸‹ï¼š

```c
/* Header for function library.h */
#ifndef _function_library
#define _function_library

// function declarations
int getline(char line[], int max);
int strindex(char source[], char searchfor[]);

#endif
```

å¤´æ–‡ä»¶ä¸­ä½¿ç”¨äº†é¢„å¤„ç†æŒ‡ä»¤ï¼Œé¿å…åœ¨å·¥ç¨‹ä¸­å› å¤šæ¬¡å¼•ç”¨è€Œå¯¼è‡´é“¾æ¥ç¨‹åºæ£€æŸ¥åˆ°ç¬¦å·é‡å¤å®šä¹‰ã€‚

æ¥ä¸‹æ¥åˆ›å»º C ä»£ç æ–‡ä»¶ï¼Œå®ç°å‡½æ•°ï¼Œè¿™é‡Œçœç•¥å®ç°ä»£ç ï¼š

```c
/* library.c */
#include "library.h"
/* getline:  get line into s, return length */
int getline(char s[], int lim)
{
  // ...
}

/* strindex:  return index of t in s, -1 if none */
int strindex(char s[], char t[])
{
  // ...
}
```

ä½¿ç”¨ä¸“ç”¨çš„å‡½æ•°åº“æ–‡ä»¶åï¼Œå‰é¢çš„ç¨‹åºå°±å¯ä»¥ç›´æ¥å¼•ç”¨å¤´æ–‡ä»¶ `#include "library.h"` æ¥ä½¿ç”¨å‡½æ•°ï¼Œå¹¶ä¸”å¯ä»¥çœç•¥å‡½æ•°å£°æ˜å’Œå‡½æ•°å®ç°ã€‚å¦‚æœå·¥ç¨‹ä¸­æœ‰å¤šä¸ªç¨‹åºä¹Ÿéœ€è¦ä½¿ç”¨åº“å‡½æ•°ï¼Œè¿™æ ·å¤„ç†å°±éå¸¸æ–¹ä¾¿ã€‚


### ===ğŸ‘‰ Scope Rules & Variables
- https://en.cppreference.com/w/c/language/storage_duration

å‰é¢å°èŠ‚è®²è¿°äº†å‡½æ•°çš„åŸºæœ¬ç»„ç»‡ç»“æ„ï¼Œæ¥ä¸‹æ¥æ˜¯å…¶å®ƒç›¸å…³çš„é‡è¦æ¦‚å¿µã€‚

é¦–å…ˆï¼Œéœ€è¦äº†è§£ä½œç”¨åŸŸçš„æ¦‚å¿µï¼ŒScope å³èŒƒå›´ï¼Œåœ¨ç¼–ç¨‹è¯­è¨€ä¸­ï¼ŒæŒ‡ç”¨æ¥çº¦æŸå˜é‡èµ·ä½œç”¨çš„ä¸€ä¸ªèŒƒå›´æ¦‚å¿µã€‚
æ¯ä¸ªå‡½æ•°ï¼Œç¬¬ä¸ªè¯­å¥å—ï¼Œå³èŠ±æ‹¬å·å†…éƒ½æ˜¯ä¸€ä¸ªä½œç”¨åŸŸã€‚ä½œç”¨åŸŸå†…éƒ¨å£°æ˜çš„å˜é‡ï¼Œåœ¨ä½œç”¨åŸŸå¤–éƒ¨ä¸èƒ½è®¿é—®ï¼Œ
åŒ…æ‹¬é™æ€å˜é‡ã€‚

å˜é‡æŒ‰å…¶å­˜å‚¨ç»„ç»‡æ–¹å¼çš„ä¸åŒï¼Œå¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ ç§ç±»å‹ï¼š

- `auto` - automatic duration and **no linkage**
- `register` - automatic duration and **no linkage**; address of this variable cannot be taken.
- `static` - static duration and **internal linkage** (unless at block scope)
- `extern` - static duration and **external linkage** (unless already declared internal)

ç¨ä¸ºæ³¨æ„ä¸€ä¸‹å˜é‡çš„é“¾æ¥æ€§ï¼ŒLinkage è¡¨æ˜ä¸€ä¸ªç¬¦å·ï¼Œå¯ä»¥æ˜¯å˜é‡æˆ–å‡½æ•°ï¼Œæ˜¯ä¸å¯ä»¥è¢«å¤–éƒ¨ä½œç”¨åŸŸå¼•ç”¨çš„èƒ½åŠ›ã€‚

01. `no linkage` ç¬¦å·åªå¯åœ¨åŸºå£°æ˜çš„ä½œç”¨åŸŸå†…ä½¿ç”¨ï¼ŒåŒ…æ‹¬å‡½æ•°å‚æ•°ã€æ‰€æœ‰é extern ä»£ç å—ä½œç”¨åŸŸå˜é‡ï¼Œstatic ä¿®é¥°çš„ã€‚
02. `internal linkage` è¡¨ç¤ºç¬¦å·åªå¯ä»¥åœ¨å½“å‰ç¼–è¯‘å•å…ƒå†…å¯ç”¨ï¼Œæ–‡ä»¶èŒƒå›´çš„é™æ€ç¬¦å·ï¼ŒåŒ…æ‹¬å˜é‡æˆ–å‡½æ•°ã€‚
03. `external linkage` è¡¨ç¤ºç¬¦å·å¯ä»¥åœ¨æ•´ä¸ªå·¥ç¨‹ä¸­ä½¿ç”¨ï¼Œå³å¯¹æ‰€æœ‰ç¼–è¯‘å•å…ƒæœ‰æ•ˆï¼ŒåŒ…æ‹¬éé™æ€å‡½æ•°ã€
    æ‰€æœ‰ extern ä¿®é¥°çš„å˜é‡(é™¤éå…ˆå‰å£°æ˜ä¸ºé™æ€)ï¼Œæ‰€æœ‰æ–‡ä»¶ä½œç”¨åŸŸçš„éé™æ€å˜é‡ã€‚

ç‰¹åˆ«è¯´æ˜ä¸€ä¸‹ï¼Œå†…éƒ¨é“¾æ¥ `internal linkage` åªæœ‰ä½œä¸ºä¸€ä¸ªå•ç‹¬ç¼–è¯‘å•ä½æ—¶æ‰ä¼šå‘ç”Ÿä½œç”¨ï¼Œæ¯”å¦‚
åœ¨ alloc.c ä¸­å®šä¹‰å…¨å±€ static å˜é‡ï¼Œç„¶ååœ¨ç¼–è¯‘å‘½ä»¤ä¸­æ·»åŠ ä¸Šè¿™ä¸ªæ–‡ä»¶ï¼Œå’Œä¸»ç¨‹åºä¸€å¹¶ç¼–è¯‘ï¼š

    gcc -o main alloc.c main.c

è¿™æ ·æ‰æ˜¯å†…éƒ¨é“¾æ¥ï¼Œå¦‚æœæ˜¯é€šè¿‡ main.c çš„ `#include` æŒ‡ä»¤å¼•ç”¨ alloc.c åˆ™ä½œä¸ºåŒä¸€ä¸ªç¼–è¯‘å•å…ƒï¼Œ
æ‰€ä»¥ä¸»ç¨‹åºä¸­æ˜¯å¯ä»¥è®¿é—®åˆ° static å…¨å±€å˜é‡çš„ã€‚

åœ¨å‡½æ•°å†…éƒ¨å®šä¹‰çš„å±€éƒ¨å˜é‡é€šå¸¸ä¹Ÿç§°ä¸ºè‡ªåŠ¨å˜é‡ï¼Œé™¤éå‰ç¼€äº† static æˆ– register è¿™æ ·çš„å…³é”®å­—ã€‚
ä¹‹æ‰€ä»¥ç§°ä¸ºè‡ªåŠ¨å˜é‡ï¼Œæ˜¯å› ä¸ºç¼–è¯‘åœ¨ç¼–è¯‘æœŸè‡ªåŠ¨åœ¨æ ˆå†…å­˜ä¸­å¤„ç†å¥½äº†å˜é‡çš„åˆ†é…å’Œå›æ”¶ã€‚

åœ¨ CPU å†…éƒ¨ï¼Œæœ‰ä¸€ä¸ª Stack æ•°æ®ç»“æ„çš„ç¡¬ä»¶å®ç°ï¼ŒåŒ…å« POP å’Œ PUSH è¿™æ ·çš„æ“ä½œæŒ‡ä»¤ï¼Œè¿˜æœ‰ ESP 
å¯„å­˜å™¨ï¼Œå®ƒæŒ‡å‘ç¨‹åºå½“å‰æ ˆé¡¶åœ°å€ã€‚

ç¨‹åºåœ¨ç¼–è¯‘é˜¶æ®µå°±éœ€è¦ç¡®å®šä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶çš„ç»“æ„ï¼Œä¹Ÿç§°ä¸ºç¨‹åºæ˜ åƒæ–‡ä»¶ï¼ŒåŸºæœ¬éœ€è¦åŒ…æ‹¬ä¸€äº›æ®µä¿¡æ¯ï¼š 
`.bss`ã€`.data`ã€`.text`ï¼Œè¿™å‡ ä¸ªæ˜¯æœ€åŸºæœ¬çš„ç¨‹åºæ˜ åƒçš„ç»„æˆï¼Œå…·ä½“å‚æ•° Windows å¹³å°çš„ PE 
ç¨‹åºæ ¼å¼ï¼Œå’Œ Linux å¹³å°çš„ ELF ç¨‹åºæ ¼å¼æ–‡ä»¶ã€‚

- .bss å³ Block Started by Symbolï¼Œé€šå¸¸æ˜¯æŒ‡ç”¨æ¥å­˜æ”¾ç¨‹åºä¸­æœªåˆå§‹åŒ–çš„å…¨å±€å˜é‡çš„ä¸€å—å†…å­˜åŒºåŸŸï¼Œå±äºé™æ€å†…å­˜åˆ†é…ã€‚
- .data å³æ•°æ®æ®µ data segment é€šå¸¸æ˜¯æŒ‡ç”¨æ¥å­˜æ”¾ç¨‹åºä¸­å·²åˆå§‹åŒ–çš„å…¨å±€å˜é‡çš„ä¸€å—å†…å­˜åŒºåŸŸï¼Œå±äºé™æ€å†…å­˜åˆ†é…ã€‚
- .text ä»£ç æ®µ code segment/text segment é€šå¸¸æ˜¯æŒ‡ç”¨æ¥å­˜æ”¾å¯æ‰§è¡Œä»£ç çš„ä¸€å—å†…å­˜åŒºåŸŸã€‚

ä»£ç æ®µåŒºåŸŸçš„å¤§å°åœ¨ç¨‹åºè¿è¡Œå‰å°±å·²ç»ç¡®å®šï¼Œç¼–è¯‘ç”Ÿæˆç¨‹åºæ–‡ä»¶æ—¶å°±å·²ç»ç¡®å®šï¼Œå¹¶ä¸”å†…å­˜åŒºåŸŸé€šå¸¸å±äºåªè¯»å†…å­˜ã€‚å½“ç„¶ï¼Œä»£ç æ®µä¹Ÿæœ‰å¯èƒ½åŒ…å«ä¸€äº›åªè¯»çš„å¸¸æ•°å˜é‡ï¼Œä¾‹å¦‚å­—ç¬¦ä¸²å¸¸é‡ç­‰ã€‚ 

å¦å¤–ï¼Œè¿˜æœ‰å †å†…å­˜åŒº heapï¼Œç”¨äºå­˜æ”¾è¿›ç¨‹è¿è¡Œä¸­è¢«åŠ¨æ€åˆ†é…çš„å†…å­˜æ®µï¼Œå®ƒçš„å¤§å°å¹¶ä¸å›ºå®šï¼Œå¯åŠ¨æ€æ‰©å¼ æˆ–ç¼©å‡ã€‚è°ƒç”¨ malloc ç­‰å‡½æ•°åˆ†é…å†…å­˜ï¼Œæ–°åˆ†é…çš„å†…å­˜å°±è¢«åŠ¨æ€æ·»åŠ åˆ°å †ä¸Šï¼Œå³å †å†…å­˜æ‰©å¼ ã€‚ä½¿ç”¨å®Œå†…å­˜åï¼Œå†é€šè¿‡ free ç­‰å‡½æ•°é‡Šæ”¾å†…å­˜ï¼Œä»å †ä¸­è¢«å‰”é™¤ï¼Œå³å †å†…å­˜è¢«ç¼©å‡ã€‚

è€Œæ ˆ stackï¼Œä¼ ç»Ÿçš„è¯‘æ³•åˆç§°å †æ ˆï¼Œä¸ºäº†ä¸å¼•èµ·æ­§ä¹‰ï¼Œä¸€èˆ¬ç§°ä¸ºæ ˆå†…å­˜æ›´åˆé€‚ï¼Œè¿™æ˜¯æ˜¯ç”¨æˆ·ç¨‹åºå­˜æ”¾ä¸´æ—¶å˜é‡ï¼Œæˆ–è€…å±€éƒ¨å˜é‡ä½¿ç”¨ã€‚ä¸€èˆ¬ç”±ç¼–è¯‘è‡ªåŠ¨ç®¡ç†ï¼Œæ‰€ä»¥è¿™äº›å˜é‡åˆç§°ä¸ºè‡ªåŠ¨å˜é‡ã€‚

è‡ªåŠ¨å˜é‡å†…å­˜åœ¨å£°æ˜æ‰§è¡Œæ—¶åˆ†é…ï¼Œè€Œä¸æ˜¯åœ¨è¿›å…¥ä»£ç å—æ—¶ï¼Œå¹¶ä¸”åœ¨è¶…å‡ºèŒƒå›´æ—¶é‡Šæ”¾ï¼Œè€Œä¸æ˜¯åœ¨å—é€€å‡ºæ—¶é‡Šæ”¾ã€‚

ç†è§£å¯æ‰§è¡Œç¨‹åºçš„æ˜ åƒç»„ç»‡åï¼Œé™æ€å˜é‡æˆ–å¯„å­˜å™¨å˜é‡å°±å¥½ç†è§£å¤šäº†ã€‚

å¯„å­˜å™¨å˜é‡ Register Variables åƒæ™®é€šå˜é‡ä¸€æ ·ï¼Œåªæ˜¯ä½¿ç”¨ CPU çš„å¯„å­˜å™¨æ¥ä¿å­˜æ•°æ®ï¼Œè€Œä¸æ˜¯å†…å­˜ï¼Œè¿™æ ·é€Ÿåº¦ä¸Šä¼šæ›´å¿«ï¼š

```c
f(register unsigned m, register long n)
{
   register int i;
   ...
}
```

C è¯­è¨€ç¨‹åºï¼Œåœ¨ä»£ç æ–‡ä»¶ä¸­å¯ä»¥å¼•ç”¨å…¶å®ƒä»£ç æ–‡ä»¶ä¸­çš„å˜é‡ã€å‡½æ•°æˆ–å¯¹è±¡ External Variablesï¼Œæ ‡å‡†å«æ³• external linkageã€‚ä»è¿™ä¸ªæ„ä¹‰ä¸Šè¯´ï¼Œå¤–éƒ¨å˜é‡ç±»ä¼¼äº Fortran å…¬å…±å—æˆ– Pascal ä¸­æœ€å¤–å±‚å—ä¸­çš„å˜é‡ã€‚

ä½¿ç”¨å…³é”®å­— `extern` ä¿®é¥°å˜é‡ï¼Œæ„æ€å°±æ˜¯è¡¨æ˜è¯¥å˜é‡åœ¨åˆ«çš„åœ°æ–¹å·²ç»å®šä¹‰è¿‡äº†ï¼Œéœ€è¦åœ¨è¿™é‡Œè¦ä½¿ç”¨å®ƒã€‚

å¦‚æœéœ€è¦å…±äº«å¤§é‡çš„å˜é‡ï¼Œä½¿ç”¨å¤–éƒ¨é“¾æ¥æ˜¯ä¸ªæ–¹ä¾¿çš„é€‰æ‹©ï¼Œå¹¶ä¸”ï¼Œå¤–éƒ¨é“¾æ¥çš„å˜é‡å…·æœ‰æ›´å¤šé•¿ä¹…çš„ç”Ÿå‘½å‘¨æœŸå’Œæ›´å¹¿çš„ä½œç”¨åŸŸã€‚

ä»¥ä¸‹æ‘˜æŠ„çš„ä»£ç æ¼”ç¤ºäº†å¦‚ä½•ä½¿ç”¨å¤–éƒ¨å˜é‡ï¼š

```c
// ext.h
extern int global_variable;  /* Declaration of the variable */

// ext.c
#include "ext.h"  /* Declaration made available here */

/* Variable defined here */
int global_variable = 37;    /* Definition checked against declaration */

int increment(void) { return global_variable++; }

// main.c
#include <stdio.h>
#include "ext.h"

void use_it(void)
{
    printf("Global variable: %d\n", global_variable++);
}
```

é™æ€å˜é‡ï¼Œä½¿ç”¨ static å…³é”®å­—è¿›è¡Œå®šä¹‰ï¼Œè¿™æ ·å®šä¹‰é™æ€å˜é‡å°±ä¼šåœ¨å…¨å±€é™æ€å†…å­˜åŒºåˆ†é…å†…å­˜ï¼Œè€Œä¸æ˜¯åœ¨æ ˆå†…å­˜åŒºï¼š

```c
static char buf[BUFSIZE];  /* buffer for ungetch */
static int bufp = 0;       /* next free position in buf */

int getch(void) { ... }

void ungetch(int c) { ... }
```

æ— è®ºæ˜¯åœ¨å…¨å±€è¿˜æ˜¯å±€éƒ¨å®šä¹‰é™æ€å˜é‡ï¼Œå…¶å†…å­˜å§‹ç»ˆåœ¨å…¨å±€æ•°æ®åŒºåˆ†é…å†…å­˜ï¼Œå³é™æ€å˜é‡å§‹ç»ˆé©»ç•™åœ¨å…¨å±€æ•°æ®åŒºï¼Œç›´åˆ°ç¨‹åºè¿è¡Œç»“æŸã€‚åŒºåˆ«æ˜¯ï¼Œå±€éƒ¨é™æ€å˜é‡çš„ä½œç”¨åŸŸé™åˆ¶åœ¨å±€éƒ¨ï¼Œå½“å®šä¹‰å®ƒçš„å‡½æ•°æˆ–å—å®šä¹‰ç»“æŸæ—¶ï¼Œå…¶ä½œç”¨åŸŸéšä¹‹ç»“æŸï¼Œåªæœ‰å†æ¬¡è¿›å…¥æ—¶æ‰å¯ä»¥è®¿é—®ã€‚

ä½¿ç”¨ static ä¿®é¥°å‡½æ•°ä¸ä¿®é¥°å…¨å±€å˜é‡ç±»ä¼¼ï¼Œå°±æ˜¯æ”¹å˜äº†å‡½æ•°çš„ä½œç”¨åŸŸï¼Œä¹Ÿå°±æ˜¯ç”Ÿå­˜æœŸæ›´é•¿äº†ã€‚

ä»¥ä¸Šä»£ç ç‰‡æ–­é€šè¿‡ external static æä¾›äº†ä¸€ç§åœ¨ getch ungetch ç»„åˆä¸­éšè— buf å’Œ bufp ç­‰åç§°çš„æ–¹æ³•ï¼Œè¿™äº›åç§°å¿…é¡»æ˜¯ external ä»¥ä¾¿å¯ä»¥å…±äº«ï¼Œä½†æ˜¯ getch å’Œ ungetch çš„ç”¨æˆ·ä¸åº”è¯¥çœ‹åˆ°è¿™äº›ç¬¦å·ã€‚

é™æ€å£°æ˜å¯ç”¨äºå¤–éƒ¨å˜é‡æˆ–å‡½æ•°ï¼Œè¿™æ ·å£°æ˜çš„å˜é‡å’Œå‡½æ•°çš„ä½œç”¨èŒƒå›´é™åˆ¶ä¸ºæ­£åœ¨ç¼–è¯‘çš„æºæ–‡ä»¶å†…çš„åç»­éƒ¨åˆ†ã€‚å¦‚æœä¸æ˜¯é€šè¿‡ external å¼•å…¥å…¨å±€å˜é‡ï¼Œå°†ä¼šæŒ‰å¼•å…¥çš„ä»£ç æ–‡ä»¶äº§ç”Ÿä¸€ä¸ªå¯¹å°±çš„å˜é‡å‰¯æœ¬ã€‚


å˜é‡å£°æ˜å’Œåˆå§‹åŒ– Initialization å…¶å®æ˜¯ä¸¤ä¸ªç›¸å¯¹ç‹¬ç«‹çš„æ¦‚å¿µï¼Œä½†æ˜¯å®ƒä»¬åˆç»å¸¸æ··åˆä¸€è°ˆï¼Œå› ä¸ºå®ƒä»¬åœ¨è¯­æ³•ä¸Šå°±ä¸å¤ªå®¹æ˜“è¢«æ³¨æ„åˆ°ã€‚

å‚è€ƒä»¥ä¸‹ä»£ç ç‰‡æ–­ï¼Œåœ¨å£°æ˜å˜é‡æ—¶ï¼ŒåŒæ—¶ä½¿ç”¨ = å·è¿›è¡Œèµ‹å€¼ï¼Œè¿™æ—¶çš„èµ‹å€¼æ‰ç§°ä¸ºåˆå§‹åŒ–ï¼Œå…¶å®ƒçš„èµ‹å€¼æ“ä½œä¸èƒ½ç§°ä¸ºåˆå§‹åŒ–ã€‚

```c
char pattern; // declaration of a variable
char pattern[] = "ould"; // declaration & initialization of a variable
char pattern[] = { 'o', 'u', 'l', 'd', '\0' }; // longer but equivalent the above line
```

å€¼å¾—ä¸€è°ˆçš„æ˜¯æŒ‡é’ˆä¸æ•°ç»„çš„åˆå§‹åŒ–å’Œå†…å­˜åˆ†é…ï¼š

```c
char pattern[5]; // declaration of array with 5 bytes memory allocation.
char (*pattern)[5]; // declaration of pointer to array
```

ä»¥ä¸Šä»£ç ç‰‡æ–­ï¼Œå°½ç®¡å£°æ˜æ•°ç»„ä½†æ²¡æœ‰åˆå§‹åŒ–ï¼Œç¼–è¯‘å™¨ä¾ç„¶æ˜¯ä¸ºå…¶åˆ†é…äº† 5 ä¸ªå­—èŠ‚çš„å†…å­˜ç©ºé—´ï¼Œè€ŒæŒ‡é’ˆåˆ™ä¸ä¼šæœ‰è¿™ä¸ªæ•°ç»„çš„ç©ºé—´åˆ†é…ï¼ŒæŒ‡é’ˆåªæ˜¯æŒ‡å‘è¿™æ ·ä¸€ä¸ªæ•°ç»„è€Œå·²ã€‚

å¦‚æœæ›´æ·±å…¥ä¸€ç‚¹ï¼Œè¿™é‡Œè¿˜æ¶‰åŠäº†å˜é‡çš„ç©ºé—´åˆ†é…ï¼Œä½†è¿™ä¸ªä¸æ˜¯é‡ç‚¹ï¼Œå› ä¸ºå˜é‡å£°æ˜åæ€»åˆ†ä¼´éšç©ºé—´çš„åˆ†é…ï¼Œæ ¹æ®å˜é‡ç±»å‹åˆ†é…ï¼Œè€ŒæŒ‡é’ˆåœ¨ 32-bit ç³»ç»Ÿä¸­å›ºå®šåˆ†é… 4 ä¸ªå­—èŠ‚ï¼Œå³ä½¿æŒ‡å‘çš„æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œé€šè¿‡ `sizeof(char *)` å¯ä»¥æŸ¥çœ‹ã€‚


## ==âš¡ ch5 - Pointers and Arrays

è¿™ä¸€ç« å†…å®¹æ¶‰åŠå†…å­˜æ–¹é¢çš„æ“ä½œï¼Œå¦‚æœå¯¹ x86 CPU æ¶æ„çš„å†…å­˜ç®¡ç†æœºåˆ¶æœ‰ä¸€å®šçš„è®¤è¯†å°†ä¼šå¤§å¤§å¸®åŠ©ç†è§£æŒ‡é’ˆä¸ºä½•ç‰©ã€‚

åœ¨é‡Œç®€å•ä»‹ç»ä¸€ä¸‹ CPU å†…å­˜ç®¡ç†å•å…ƒå’Œå‡ ç§å†…å­˜æ¨¡å‹ï¼Œç¨‹åºä½¿ç”¨çš„å†…å­˜è®¿é—®æ¨¡å‹æœ‰ä»¥ä¸‹ä¸‰ä¸ªï¼ŒåŒ…æ‹¬æ­¤å‰ä½¿ç”¨è¿‡çš„ï¼š

    Flat Model
    ================================================
                             Linear Address |      |
    Linear Address ------------------------>|++++++|
                                            |      |
                                            | RAM  |
                                            ========

    Segmented Model
    ================================================
                             Linear Address |      |
                                            |++++++|
                                            |++++++|
                         ===========        |      |
              Offset --->| Segment |------->| RAM  |
    Segment Selector --->|---------|        |++++++|
    ================     |   ...   |        |++++++|
    Logical Address      |---------|        |      |
                         | Segment |------->|      |
                         ===========        ========

    Real-Address Mode Model
    ================================================
                                            | ...  |
                                            |------|
                                            |      |
                             Linear Address |      |
              Offset ---------------------->| RAM  |
    Segment Selector ---------------------->|------|
    ================        Space Divided   |      |
    Logical Address         Into Equal      |      |
                            Sized Segments  |      |
                            Address         ========

    Figure 3-3. Three Memory Management Models

å±•å¹³æ¨¡å‹ Flat memory modelï¼Œå†…å­˜å¯¹äºç¨‹åºå°±æ˜¯ä¸€ä¸ªå®Œæ•´è¿ç»­ç©ºé—´ï¼Œå³çº¿æ€§åœ°å€ç©ºé—´ï¼ŒæŒ‰å­—èŠ‚å¯»å€ï¼Œä»£ç ã€æ•°æ®ã€è°ƒç”¨æ ˆå…¨éƒ½åœ¨è¿™ä¸ªç©ºé—´é‡Œã€‚åœ¨è¿™ä¸ªçº¿æ€§è¿ç»­ç©ºé—´çš„ä»»ä½“ä¸€ä¸ªå­—èŠ‚çš„åœ°å€éƒ½å«çº¿æ€§åœ°å€ï¼Œå¦‚æœä¸æ˜¯ 64-bit æ¶æ„ï¼Œæœ€å¤§å¯å¯»å€ 2^32 å…± 4GBã€‚

åˆ†æ®µæ¨¡å‹ï¼Œåˆ†æ®µçš„å†…å­˜å¯¹ç¨‹åºæ¥è¯´å°±æ˜¯ç‹¬ç«‹çš„åœ°å€ç©ºé—´ï¼Œä»£ç ã€æ•°æ®ã€å †æ ˆé€šå¸¸åœ¨å¦å¤–çš„æ®µä¸­ã€‚ç¨‹åºä½¿ç”¨é€»è¾‘åœ°å€ï¼Œçœ‹ä½œä¸º far pointersã€‚æ®µé€‰æ‹©å™¨æ ‡è¯†è®¿é—®å“ªä¸ªæ®µï¼Œè€Œ ofsset æŒ‡å‘æ®µä¸­çš„å­—èŠ‚åœ°å€ï¼Œæ‰€ä»¥åç§»å€¼åˆç§°ä¸ºæœ‰æ•ˆåœ°å€(effective address)ã€‚åœ¨ IA-32 ä¸Šè¿è¡Œçš„ç¨‹åºå¯ä»¥å¯»å€å¤šè¾¾ 16,383 ä¸ªå¤§å°ä¸ç­‰ä¸åŒç±»å‹çš„çš„åˆ†æ®µï¼Œæ¯æ®µæœ€å¤§ 2^32 å­—èŠ‚ã€‚

å±•å¹³æ¨¡å‹å’Œåˆ†æ®µæ¨¡å‹çš„çº¿æ€§åœ°å€å¯ä»¥ä½¿ç”¨åˆ†é¡µæœºåˆ¶ã€‚

åœ¨ CPU å†…éƒ¨ï¼Œæ‰€æœ‰ç³»ç»Ÿå®šä¹‰çš„æ®µéƒ½æ˜ å°„åˆ°å¤„ç†å™¨çš„çº¿æ€§åœ°å€ç©ºé—´ï¼Œè¦è®¿é—®ä¸€ä¸ªå†…å­˜åœ°å€ï¼ŒCPU å°±è¦å°†é€»è¾‘åœ°å€è½¬æ¢ä¸ºçº¿æ€§åœ°å€ï¼Œè½¬æ¢è¿‡ç¨‹å¯¹ç¨‹åºæ˜¯é€æ˜çš„ã€‚

ä½¿ç”¨åˆ†æ®µæ¨¡å‹çš„ä¸»è¦ç›®çš„æ˜¯æå‡ç³»ç»Ÿçš„å¯é æ€§ï¼Œä¾‹å¦‚ï¼Œå°†ä¸€ä¸ªç¨‹åºçš„è°ƒç”¨æ ˆæ”¾åˆ°å¦å¤–ä¸€ä¸ªåˆ†æ®µä¸Šï¼Œå°±å¾ˆå¥½åœ°é¿å…äº†å †æ ˆæº¢å‡ºå¸¦æ¥çš„é£é™©ï¼Œé¿å…äº†ä»£ç æˆ–æ•°æ®è¢«çº‚æ”¹ã€‚

å®åœ°å€æ¨¡å‹ï¼Œè¿™æ˜¯æœ€æ—©çš„ Intel 8086 å¤„ç†å™¨ä½¿ç”¨çš„æ¨¡å‹ï¼Œå®æ¨¡å¼ä¸‹çš„å¯»å€æ–¹å¼ï¼Œç›´æ¥ä½¿ç”¨ segment:offset çš„æ–¹å¼è¿›è¡ŒçœŸå®å†…å­˜åœ°å€è®¿é—®ï¼Œä½¿ç”¨çš„æ˜¯ä¸“ç”¨çš„åˆ†æ®µå†…å­˜ï¼Œæä¾›ä¸€ç»„æœ€å¤šåªæœ‰ 64KB çš„åˆ†æ®µã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä»»ä½•ç¨‹åºéƒ½èƒ½è®¿é—®æœ€å¤§ï¼Œä¹Ÿæ˜¯å…¨éƒ¨ 1MB çš„ç©ºé—´ï¼Œç›¸å½“äºå†…å­˜æ˜¯å…¬å¼€æ²¡æœ‰ä¿æŠ¤çš„ã€‚

è¿›å…¥ä¿æŠ¤æ¨¡å¼ä½¿ç”¨å†…å­˜ç®¡ç†å•å…ƒåï¼Œå†…å­˜å¯»å€å°±ä¸å†ä½¿ç”¨æ®µåŸºå€åŠ åç§»çš„æ–¹å¼ï¼Œè€Œæ˜¯ä½¿ç”¨é€»è¾‘åœ°å€ï¼Œå³æœºå™¨æ”¯æŒçš„å¯»å€ç©ºé—´ä¸Šçš„åœ°å€ï¼Œè€Œä¸æ˜¯çœŸå®ç‰©ç†å†…å­˜çš„åœ°å€ã€‚

è€Œè¿›å…¥ä¿æŠ¤æ¨¡å¼åï¼Œé€šè¿‡ GDT/LDT åˆ†æ®µæ˜ å°„çš„æ–¹å¼ï¼Œç¨‹åºå¹¶ä¸èƒ½è®¿é—®æ•´ä¸ªç‰©ç†å†…å­˜ç©ºé—´ï¼Œå³å·²ç»è¢«å…¶å®ƒç¨‹åºä½¿ç”¨çš„å†…å­˜å°±ä¸ä¼šå†è¢«ä½¿ç”¨ã€‚

GDT - Global Descriptor Table å…¨å±€æè¿°ç¬¦è¡¨å°±æ˜¯åœ¨ä¿æŠ¤æ¨¡å¼ä¸‹è™šæ‹Ÿå†…å­˜å¯»å€ä¸­çš„é‡è¦ç¯èŠ‚ã€‚

GDT ä¸­æ¯ä¸€é¡¹å«åšæ®µæè¿°ç¬¦ Segment Descriptorï¼Œç”¨æ¥è®°å½•æ¯ä¸ªå†…å­˜åˆ†æ®µçš„ä¸€äº›å±æ€§ä¿¡æ¯ï¼Œæ¯ä¸ªæ®µæè¿°ç¬¦å  8 å­—èŠ‚ã€‚

åœ¨ä¿æŠ¤æ¨¡å¼ä¸‹ï¼Œå†…å­˜ç©ºé—´è¢«åˆ†å‰²ä¸ºäº†ä¸€ä¸ªåˆä¸€ä¸ªå¯ä»¥é‡å çš„æ®µè®°å½•åœ¨ GDTï¼Œä¸åŒçš„ç¨‹åºè®¿é—®å†…å­˜æ—¶ï¼Œé€šè¿‡ GDT æ˜ å°„åˆ°ä¸åŒçš„å†…å­˜ç©ºé—´ï¼Œè¿™æ ·å°±ä¿æŠ¤äº†å†…å­˜å®‰å…¨ã€‚

ä»¥ä¸‹æ˜¯å¯ç”¨åˆ†é¡µæœºåˆ¶ä¸‹çš„é€»è¾‘åœ°å€åˆ°ç‰©ç†åœ°å€çš„æµç¨‹å›¾ï¼š

    Logical Address                         Linear Address                           Physical Address
    ========================                ==========================               ======================
    | 16-bit        32-bit |                | 10-bit  10-bit  12-bit |               | 20-bit      12-bit |
    | Selector      Offset |------> + ----->| Dir     Table   Offset |               | PPN         Offset |
    ===+====================        ^       ===+========+========+====               ===^=============^====
       |                            |          |        |        |                      |             |
       |           +----------------+          |        |        +----------------------|-------------+
       |           |                           |        +----------------+              |
       |         32-bit  20-bit  12-bit        |                         |        20-bit|  12-bit
       |        =======|=======|========       |                         |        ======|=|======
       |        | ---- | ----- | ----- |       |                         |   1023 |-----|-|-----|
       |        | ---- | ----- | ----- |       |       20-bit   12-bit   +------> | PPN + |FLAGS|
       |        | ---- | ----- | ----- |       |       ========|======            | ..... | ... |
       |        | ---- | ----- | ----- |       |  1024 |-------|-----|          0 |-------|-----|
       |     16 | ---- | ----- | ----- |       |       |-------|-----|       +--->========|======
       +----> 8 | Base | Limit | Flags |       |       |.......|.....|   PPN |       Page Table
              0 | ---- | ----- | ----- |       +---->3 | PPN   |FLAGS|-------+
       GDTR --> =======|=======|========             2 |-------|-----|---> Page Table
                        GDT/LDT                      1 |-------|-----|---> Page Table
                                                     0 |-------|-----|---> Page Table
    Volume 3                               CR3 ------> ========|======
    Figure 3-1. Segmentation and Paging                Page Directory

åœ¨æ•´ä¸ªè½¬æ¢è¿‡ç¨‹ä»ç¨‹åºä½¿ç”¨çš„ Logical Address æˆ– Far Pointer å¼€å§‹ï¼š

- å…ˆå°†é€»è¾‘åœ°å€ä¸­çš„é€‰æ‹©å™¨éƒ¨åˆ†é€šè¿‡ GDT/LDT æ˜ å°„åå†ä¸åç§»éƒ¨åˆ†å åŠ å½¢æˆä¸€ä¸ªçº¿æ€§åœ°å€ã€‚
- çº¿æ€§åœ°å€å†åˆ†è§£ä¸º Dir/Table/Offset ä¸‰éƒ¨åˆ†ã€‚
- æ ¹æ® CR3 æ§åˆ¶å¯„å­˜å™¨æŒ‡å®šçš„åˆ†é¡µç›®å½•è¡¨å¹¶æ‰¾åˆ° Dir å¯¹åº”çš„è®°å½•å¹¶å®šä½åˆ° Page Tableã€‚
- æ ¹æ®çº¿æ€§åœ°å€çš„ Table éƒ¨åˆ†å®šä½åˆ° Page Table å¯¹åº”çš„è®°å½•å¹¶è·å¾—æœ€æœ€ç»ˆçš„ PPN - Physical Page Numberã€‚

æ•´ä¸ªè¿‡ç¨‹ç»è¿‡äº†åˆ†æ®µå¤„ç†ï¼Œå†åˆ†é¡µæ˜ å°„å¾—åˆ°æœ€ç»ˆçš„ç‰©ç†å†…å­˜åœ°å€ï¼Œæ³¨æ„åˆ†é¡µç›®å½•è¡¨é‡Œçš„ PPN æ˜¯æŒ‡ Page Table Physical Page Numberï¼Œå®ƒæŒ‡å‘ä¸€ä¸ªå†…å­˜åˆ†é¡µè¡¨ï¼Œè€Œå†…å­˜åˆ†é¡µè¡¨ä¸­çš„ PPN æ˜¯åˆ†é¡µçš„ç‰©ç†å†…å­˜æ‰€åœ¨åœ°å€ï¼ŒAddress of 4KB page frameã€‚æ ¹æ®è¿™ä¸ªæ˜ å°„å…³ç³»ï¼Œä¸€ä¸ªåˆ†é¡µç›®å½•å°±å¯ä»¥æ˜ å°„ 1023 * 1024 * 4KB = 4GB - 4MB ç©ºé—´ï¼Œè€Œæ–° CPU æ¶å…è®¸åˆ†é¡µå¯ä»¥ä¸æ˜¯å›ºå®šçš„ 4KBã€‚


ä»¥ä¸‹æ˜¯ MIPS æ¶æ„å’Œ PC x86 æ¶æ„çš„å†…å­˜æ¨¡å‹å¯¹æ¯”ï¼š

      +----------+ 0x7FFFFFFF               +------------------+  <- 0xFFFFFFFF (4GB)
      | frame... | stack segment            |      32-bit      |
      |          | |                        |  memory mapped   |
      |          | |                        |     devices      |
      |          | V                        /\/\/\/\/\/\/\/\/\/\
      |          |                          /\/\/\/\/\/\/\/\/\/\
      +----------+                          |      Unused      |
      | Dynamic  |                          +------------------+  <- depends on amount of RAM
      | Static   | Data Segment             | Extended Memory  |
      +----------+ 0x10000000               +------------------+  <- 0x00100000 (1MB)
      |          |                          |     BIOS ROM     |
      |          |                          +------------------+  <- 0x000F0000 (960KB)
      |          |                          |  16-bit devices, |
      +----------+   0x400000               |  expansion ROMs  |
      | Reserved |                          +------------------+  <- 0x000C0000 (768KB)
      +----------+ 0x00000000               |   VGA Display    |
                                            +------------------+  <- 0x000A0000 (640KB)
                                            |    Low Memory    |
                                            +------------------+  <- 0x00000000

MIPS å¤„ç†å™¨ç³»ç»Ÿä¸­ï¼Œå°†å†…å­˜åˆ’åˆ†ä¸º 3 ä¸ªéƒ¨åˆ†ï¼š

- ç¬¬ä¸€éƒ¨åˆ†ä»æœ€ä½å†…å­˜åœ°å€å¼€å§‹ï¼Œä»¥ 0x400000 ä¸ºèµ·ç‚¹ï¼Œä½œä¸ºä»£ç æ®µï¼Œä¿å­˜ä»£ç æŒ‡ä»¤ã€‚
- ç¬¬äºŒéƒ¨åˆ†ä»ä»£ç æ®µä¹‹ä¸Šå¼€å§‹ï¼Œç»†åˆ†ä¸º Static data åŒºå’Œï¼Œèµ·å§‹åœ°å€ä¸º 0x10000000ã€‚
- ç¬¬ä¸‰éƒ¨åˆ†ä»æœ€é«˜å†…å­˜åœ°å€å¼€å§‹å¾€ä¸‹ä½œä¸ºè°ƒç”¨æ ˆå†…å­˜ç©ºé—´ stack segmentã€‚

æ³¨æ„ï¼Œå¯ä»¥çœ‹åˆ°æœ€é«˜å†…å­˜åœ°åœ°å€ 0x7FFFFFFF å¹¶ä¸æ˜¯ä»£è¡¨çœŸå®å†…å­˜æœ‰è¿™ä¹ˆå¤šï¼Œå®ƒæ˜¯è™šæ‹Ÿå†…å­˜ç©ºé—´ï¼Œé€šè¿‡ç¡¬ä»¶æ˜ å°„åï¼Œæ‰è®¿é—®åˆ°çœŸå®çš„å†…å­˜åœ°å€ã€‚

åœ¨æ±‡ç¼–ç¨‹åºä¸­ï¼Œé€šè¿‡ `.text` æ±‡ç¼–æŒ‡ä»¤å°±å¯ä»¥æŒ‡ç¤ºç¼–è¯‘å™¨ï¼Œåœ¨ç¼–è¯‘è¿›å°†è¿™éƒ¨åˆ†ç”Ÿæˆçš„æŒ‡ä»¤å­˜åˆ°ä»£ç æ®µå†…å­˜ç©ºé—´ï¼Œå‡†ç¡®åœ°è¯´æ˜¯ç¼–è¯‘å™¨ä¿å­˜äº†ç›¸å…³ä¿¡æ¯ï¼Œåœ¨æ‰§è¡Œç¨‹åºæ—¶ï¼Œç”±ç¨‹åºåŠ è½½å™¨è´Ÿè´£å°†å…¶ä¼ é€åˆ°ä»£ç æ®µå†…å­˜ä¸­ã€‚

é™æ€æ•°æ® Static data è¡¨ç¤ºé‚£äº›åœ¨ç¼–è¯‘é˜¶æ®µå°±å¯ä»¥ç¡®å®šåœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´éƒ½æœ‰æ•ˆçš„æ•°æ®ï¼Œä¹Ÿå°±æ˜¯æ•°æ®ç”Ÿå‘½å‘¨æœŸä¿æŒå’Œç¨‹åºè¿è¡Œå‘¨æœŸä¸€æ ·é•¿ï¼Œæ¯”å¦‚ï¼ŒC/C++ ä¸­çš„å…¨å±€å˜é‡ã€‚

Stack æ˜¯ä¸ªå¾ˆé‡è¦çš„å†…å­˜ç©ºé—´ï¼Œå®ƒæ˜¯åœ¨ç¡¬ä»¶å±‚æ¬¡ä¸Šå®ç°çš„æ•°æ®ç»“æ„ï¼ŒLast-in First-outï¼Œåè¿›å…ˆå‡ºï¼Œå…ˆè¿›åå‡ºï¼ŒCPU é€šå¸¸éƒ½æä¾›å‹æ ˆå’Œå‡ºæ ˆæŒ‡ä»¤ï¼Œ`PUSH` & `POP`ã€‚åœ¨é«˜çº§è¯­è¨€ä¸­æˆ–æ±‡ç¼–è¯­è¨€ä¸­ï¼Œæ˜¯æœ‰å‡½æ•°è°ƒç”¨çš„è¿™ä¸€åŠŸèƒ½çš„ï¼Œprocedure callã€‚ä» A å‡½æ•°è°ƒç”¨ B å‡½æ•°ï¼Œæ‰§è¡Œå®Œåè¿˜è¦å›æ¥ A å‡½æ•°æŒ‰åŸä½ç½®ç»§ç»­æ‰§è¡Œã€‚

é‚£ä¹ˆåœ¨è°ƒç”¨ B å‡½æ•°å‰ï¼Œå°±éœ€è¦å°†å½“å‰æ‰§è¡Œçš„æŒ‡ä»¤æ‰€åœ¨çš„å†…å­˜åœ°å€ï¼Œå³ PC å¯„å­˜å™¨çš„å†…å®¹è®°å½•ä¸‹æ¥ï¼Œç­‰è°ƒç”¨å‡½æ•°åè¿”å›æ—¶å†æ¢å¤ã€‚è¿™å°±å«åšç°åœºä¿æŠ¤ï¼Œè¦ä¿æŠ¤çš„è¿˜åŒ…æ‹¬ä½¿ç”¨åˆ°çš„å…¶å®ƒå¯„å­˜å™¨ã€‚

è€Œå°†æ•°æ®ä¿å­˜åœ¨ä»€ä¹ˆåœ°æ–¹å‘¢ï¼Ÿè¿™å°±éœ€è¦ä½¿ç”¨ Stack çš„å†…å­˜ç©ºé—´äº†ï¼Œå°†éœ€è¦ä¿æŠ¤çš„æ•°æ®æš‚å­˜äºæ ˆå†…å­˜ã€‚æ¯æ¬¡å‡½æ•°è°ƒç”¨äº§ç”Ÿçš„ç°åœºä¿æŠ¤åŠ¨ä½œï¼Œéƒ½ä¼šæœ‰ç›¸åº”çš„ Stack æ•°æ®äº§ç”Ÿï¼Œè¿™ä¸ªåŠ¨ä½œäº§ç”Ÿçš„æ•°æ®ç§°ä¸ºè°ƒç”¨å¸§ frameï¼Œå°±åƒç”µå½±ä¸€å¸§ä¸€å¸§åœ°è®°å½•æ•°æ®ã€‚å¹¶ä¸”ï¼ŒCPU å†…éƒ¨çš„æä¾›äº†ä¸¤ä¸ªä¸“ç”¨å¯„å­˜å™¨ï¼ŒEBPã€ESP åˆ†åˆ«ä¿å­˜è°ƒç”¨æ ˆçš„åŸºå€å’Œå½“å‰æ ˆé¡¶ä½ç½®ï¼Œæ³¨æ„ Stack ç”Ÿé•¿æ–¹å‘å¾€ä½åœ°å€å†…å­˜æ–¹å‘ã€‚

               +------------+   |
               | arg 2      |   \
               +------------+    >- previous function's stack frame
               | arg 1      |   /
               +------------+   |
               | ret %eip   |   /
               +============+   
               | saved %ebp |   \
        %ebp-> +------------+   |
               |            |   |
               |   local    |   \
               | variables, |    >- current function's stack frame
               |    etc.    |   /
               |            |   |
               |            |   |
        %esp-> +------------+   /


### ===ğŸ‘‰ Array

æ•°ç»„ä½œä¸ºä¸€ä¸ªæŠ½è±¡æ•°æ®ç±»å‹æ¦‚å¿µï¼Œæˆ–è€…æ›´å‡†ç¡®åœ°è¯´æ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œåº”è¯¥ä½œä¸ºä¸€ä¸ªç‹¬ç«‹çš„ç« èŠ‚æ¥å»è§£æå®ƒã€‚åœ¨å„ç§åŸºç¡€æ•°æ®ç±»å‹ä¹‹ä¸Šï¼Œç¨‹åºéœ€è¦åŸºäºå®ƒä»¬æ¥æ„å»ºä¸€ä¸ªåº”ç”¨ï¼Œç¦»ä¸å¼€å„ç§æ•°æ®ç»“æ„ä¸ç®—æ³•ï¼Œè€Œæ•°ç»„åˆ™æ˜¯ä½œä¸ºæœ€åŸºç¡€ä¹Ÿæ˜¯æœ€ç®€å•çš„ä¸€ç§æ•°æ®ç»“æ„å­˜åœ¨ã€‚

æ•°ç»„ï¼Œåœ¨å†…å­˜ä¸­å°±æ˜¯ä¸€å—è¿ç»­çš„å†…å­˜ç©ºé—´ï¼Œè¿™ä¸ªå†…å­˜ç©ºé—´æ”¾ä»€ä¹ˆå°±æ˜¯ä»€ä¹ˆç±»å‹çš„æ•°ç»„ï¼Œæ¯”å¦‚ `int a[]` æ•´å½¢æ•°ç»„ï¼Œ`char a[]` å­—ç¬¦æ•°ç»„ï¼Œå³å­—ç¬¦ä¸²ã€‚

C è¯­è¨€ä½¿ç”¨ Null-terminated é£æ ¼å­—ç¬¦ä¸²ï¼Œä¼šè‡ªåŠ¨åœ¨æœ«å°¾åŠ  \0 ä½œä¸ºç»ˆç»“å­—ç¬¦ï¼š

```c
char s[10] = "Hello"; // å¡«å……åç»­ s[5] - s[9] 5 ä¸ª '\0'
char s[10] = "123456789"; // å†…å­˜åˆ†é…é•¿åº¦ä¸º 10 å­—èŠ‚ï¼Œç¼–è¯‘å™¨è‡ªåŠ¨åŠ  '\0'
char s[10] = {'H','e','l','l','o'}; // ç­‰æ•ˆ {'H','e','l','l','o','\0'}
char s[10] = {0} // å…¨éƒ¨åˆå§‹åŒ–ä¸º '\0'
char s[10] = "HelloWorld.\n"; // æœ€åäºŒä¸ªå­—ç¬¦ä¸ºè¶…å‡ºéƒ¨åˆ†ï¼Œä¸¢å¼ƒï¼Œå¹¶ä¸”æ²¡æœ‰å­—ç¬¦ä¸²ç»“å°¾ç¬¦
char s[] = "HelloWorld.\n"; // sizeof = strlen + 1ï¼Œæ³¨æ„ sizeof æ˜¯æ“ä½œç¬¦ï¼Œè€Œå­—ç¬¦é•¿åº¦ç»Ÿè®¡åˆ° '\0' å‰é¢çš„å­—ç¬¦ä¸ºæ­¢
```

å’Œ C++ ä¸­å­—ç¬¦ä¸²æ•°ç»„åˆå§‹åŒ–ä¸€æ ·ï¼ŒC è¯­è¨€ä¸­ä¹Ÿå¯ä»¥å¯¹å­—ç¬¦æŒ‡é’ˆæ•°ç»„è¿›è¡Œåˆå§‹åŒ–ï¼š

```c
// string nums[] = {"one", "two", "three"};
char *nums[] = {"one", "two", "three"};
// int *nums[] = { 1, 2, 3, 4, 5}; // Error
```

ä½†å…¶å®ƒç±»å‹æŒ‡é’ˆæ•°ç»„ä¸å¯ä»¥è¿™æ ·åˆå§‹åŒ–ï¼ŒåŸå› æ˜¯æŒ‡é’ˆçš„åˆå§‹åŒ–æˆ–èµ‹å€¼å¯ä»¥ä½¿ç”¨ 0 å€¼ã€å¸¸é‡è¡¨è¾¾å¼ã€å’Œç±»å‹åŒ¹é…çš„å¯¹è±¡çš„åœ°å€ã€‚

æŒ‡é’ˆéœ€è¦ç”¨åœ°å€åˆå§‹åŒ–ï¼Œç»™æŒ‡é’ˆèµ‹å€¼åº”è¯¥æ˜¯åœ°å€ï¼Œå³ &var è¿™æ ·çš„è¡¨è¾¾ï¼Œç¼–è¯‘å™¨é€šå¸¸ä¼šæç¤ºé”™è¯¯ï¼šä¸å¯å°† int ç±»å‹èµ‹ç»™ int * ç±»å‹ã€‚

å¦‚ä¸Šï¼Œå­—ç¬¦ä¸²å­—é¢å€¼å¸¸é‡ç±»å‹ä¸º `const char *` å³ä¸€ä¸ªå¸¸é‡çš„æŒ‡é’ˆï¼Œä¸æŒ‡é’ˆç±»å‹åŒ¹é…ï¼Œå¯èµ‹å€¼ã€‚

æ•´å½¢å­—é¢å€¼å¸¸é‡å¯ä»¥ä¸º int, long ç­‰ç±»å‹ï¼Œå‚è€ƒ C++ Primer ç¬¬äºŒç«  2.2 èŠ‚å…³äºå˜é‡åˆå§‹åŒ–çš„å†…å®¹ã€‚

åˆ©ç”¨ = è¿ç®—ç¬¦æ¥æ‹·è´å­—ç¬¦ä¸²åˆ°å­—ç¬¦æ•°ç»„ä¸­æ˜¯ä¸å¯èƒ½çš„ï¼ŒC è¯­è¨€æŠŠè¿™äº›è¯­å¥è§£é‡Šä¸ºä¸¤ä¸ªæŒ‡é’ˆä¹‹é—´çš„ï¼ˆéæ³•çš„ï¼‰èµ‹å€¼è¿ç®—ã€‚

å¯æ˜¯ï¼Œå¦‚å‰é¢åœ¨åˆå§‹åŒ–æ—¶ä½¿ç”¨ = ç”¨æ¥åˆå§‹åŒ–å­—ç¬¦æ•°ç»„æ˜¯åˆæ³•çš„ã€‚è¿™æ˜¯ç”±äºåœ¨å£°æ˜ä¸­ä½¿ç”¨ = ä½œä¸ºåˆå§‹åŒ–åŠŸèƒ½è€Œä¸æ˜¯èµ‹å€¼è¿ç®—ç¬¦ã€‚

è¯•å›¾ä½¿ç”¨å…³ç³»è¿ç®—ç¬¦æˆ–åˆ¤ç­‰è¿ç®—ç¬¦æ¥æ¯”è¼ƒå­—ç¬¦ä¸²æ˜¯åˆæ³•çš„ï¼Œä½†ä¸ä¼šäº§ç”Ÿé¢„æœŸçš„ç»“æœã€‚


å¦‚æœï¼Œæ•°ç»„å…ƒç´ æ˜¯æŒ‡é’ˆï¼Œå³ Pointer Arraysï¼ŒPointers to Pointersï¼Œå¦‚ `int *ppi[]`ï¼Œå³æŒ‡é’ˆæ•°ç»„ï¼Œå…ƒç´ ä¸º `int *` æŒ‡é’ˆï¼Œåˆå¦‚ `char *argv[]` æ•°ç»„ï¼Œå…ƒç´ ä¸ºæŒ‡å‘å­—ç¬¦çš„æŒ‡é’ˆã€‚

æ³¨æ„ `char *` å£°æ˜çš„æ˜¯æŒ‡å‘å­—ç¬¦çš„æŒ‡é’ˆï¼Œç«Ÿç„¶å®ƒæ˜¯ä¸æ˜¯å­—ç¬¦ä¸²æ˜¯ä¸ç¡®å®šçš„ã€‚å…¶æ¬¡ï¼Œåƒ `char **` è¿™æ ·çš„åŒé‡æŒ‡é’ˆåœ¨è¯­æ³•ä¸Šæ˜¯å£°æ˜ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å¦ä¸€ä¸ªæŒ‡å‘å­—ç¬¦çš„æŒ‡é’ˆï¼Œå¯ä»¥ä½¿ç”¨ä¸‹æ ‡è¿ç®—ç¬¦ï¼Œä½†å®ƒçš„å«ä¹‰å¹¶ä¸å’Œæ•°ç»„ç­‰ä»·ã€‚


å£°æ˜æ—¶ï¼Œå§‹ç»ˆè¦æ¸…æ¥šä¸¤ä¸ªè¿ç®—ç¬¦çš„ä¼˜å…ˆçº§å„ç»“åˆæ–¹å‘ï¼š

- [] ä¸‹æ ‡è¿ç®—ç¬¦æ˜¯äºŒçº§ä¼˜å…ˆï¼Œleft to right ç»“åˆã€‚
- Unary * right to left ç»“åˆè§„åˆ™ï¼Œä¸‰çº§ä¼˜å…ˆã€‚

å£°æ˜å¸¦æŒ‡é’ˆçš„æ•°ç»„æ—¶ï¼Œå°†å•å…ƒè¿ç®—ç¬¦ * å†™åœ¨å…³é”®å­—æˆ–æ ‡è¯†ç¬¦å·çš„å·¦ä¾§æ˜¯é€»è¾‘æ­£ç¡®çš„ï¼Œå®ƒä¿®é¥°çš„å°±æ˜¯é åœ¨å³ä¾§çš„å†…å®¹ã€‚ç»“åˆä¼˜å…ˆçº§æ›´é«˜ä¸‹æ ‡è¿ç®—ç¬¦æ—¶ï¼Œæ‰€å®šä¹‰çš„ç¬¦å·é¦–å…ˆå°±æ˜¯æ•°ç»„ï¼Œå…¶æ¬¡æ‰æ˜¯æŒ‡é’ˆã€‚

å¦‚æœè¦å®šä¹‰æŒ‡å‘æ•°ç»„çš„æŒ‡é’ˆï¼Œé‚£ä¹ˆå°±å¿…éœ€ä½¿ç”¨åœ†æ‹¬å·æ¥æ”¹å˜è¿ç®—ç¬¦åŸæœ‰çš„ä¼˜å…ˆçº§ï¼Œå…ˆè®© * è¿ç®—ç¬¦ä¸æ ‡è¯†ç¬¦ç»“åˆä»¥ç¡®å®šå®ƒæ˜¯ä¸€ä¸ªæŒ‡é’ˆã€‚ç„¶åå†ä¸ä¸‹æ ‡è¿ç®—ç¬¦ç»“åˆï¼Œæ‰æ˜¯æ•°ç»„éƒ¨åˆ†çš„å®šä¹‰ã€‚

```c
int (*ap)[5];        // pointer to array of 5 ints
int fi[5] = {1, 2, 3, 4, 5};
ap = &fi;
```

è¿™ç§è¿ç®—ç¬¦ä¼˜å…ˆçº§çš„åˆ†ææ€è·¯ä¹Ÿé€‚åˆåé¢æŒ‡é’ˆä¸å‡½æ•°çš„æ··åˆä½¿ç”¨ï¼Œåƒä»¥ä¸‹ fp çš„å®šä¹‰ï¼šé¦–å…ˆ fp æ˜¯æŒ‡é’ˆï¼Œå…¶æ¬¡å®ƒæŒ‡å‘ä¸€ä¸ªå‡½æ•°ï¼Œå†æ¬¡è¿™ä¸ªå‡½æ•°æ¥æ”¶ä¸€ä¸ª char* å‚æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ª int å€¼ã€‚

ä»¥ä¸‹æ˜¯å–è‡ª The C++ Programming Language ä¸€ä¹¦çš„ç¤ºèŒƒä»£ç ï¼š

```c
int* pi;            // pointer to int
char** ppc;         // pointer to pointer to char
int* ap[15] ;       // array of 15 pointers to ints
int (*fp)(char*); // pointer to function taking a char* argument; returns an int
int* f(char*);      // function taking a char* argument; returns a pointer to int
// The C++ Programming Language, Third Edition by Bjarne Stroustrup.
```

è€Œ C è¯­è¨€ä½œä¸ºé™æ€ç±»å‹è¯­è¨€ï¼Œéœ€è¦åœ¨ç¨‹åºç¼–è¯‘æœŸçŸ¥é“è¦ç»™æ•°ç»„åˆ†é…å¤šå°‘ç©ºé—´ï¼Œæ‰€ä»¥æ–¹æ‹¬å·ä¸­é€šå¸¸éœ€è¦æŒ‡å®šä¸€ä¸ªæ•°å€¼å­—é¢å¸¸é‡ï¼Œè¡¨ç¤ºéœ€è¦å­˜æ”¾å¤šå°‘ä¸ªæ•´å½¢ã€å­—ç¬¦ç­‰ã€‚

å¦‚æœï¼Œçœç•¥ï¼Œåˆ™ç¼–è¯‘å™¨ä¼šä»åˆå§‹å€¼ä¸­æ¨æ–­ç©ºé—´å¤§å°ï¼Œå¦‚æœä¸èƒ½æ¨æ–­å°±ç¼–è¯‘å¤±è´¥ï¼ŒæŠ¥é”™ã€‚

å¯¹äºå¤šç»´æ•°ç»„ï¼Œå¿…éœ€æŒ‡å®šå„ä¸ªç»´åº¦çš„å†…å­˜åˆ†é…é‡ï¼Œé™¤ç¬¬ 1 ç»´ï¼š

```c
int im[][3] = {{1,2,3}, {4,5,6}, {7,8,9}};
printf("Test: %p = %d %p = %d", im, **im, im+1, **(im+1));
// Test: 0060FE68 = 1 0060FE74 = 4
```

C99 è§„èŒƒå¼•å…¥äº† VLA - variable-length array ä¹Ÿå°±æ˜¯å˜é•¿æ•°ç»„ï¼Œæ”¯æŒä¸‹é¢è¿™ç§å†™æ³•ï¼Œè¿™æ˜¯ä¸ºæ•°ä¸å¤šçš„ C++ ä¸æ”¯æŒçš„åŠŸèƒ½ï¼š

```c
int n = 10;
int a[n];
```

æ³¨æ„ä¸Šé¢çš„è¯­å¥æ˜¯åœ¨å‡½æ•°å†…éƒ¨å†™çš„ï¼Œä¹Ÿå°±æ˜¯ n å’Œ a éƒ½æ˜¯è‡ªåŠ¨å˜é‡ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœä»£ç ç‰‡æ–­æ”¾åœ¨å‡½æ•°å¤–é¢å°±ä¸èƒ½é€šè¿‡ç¼–è¯‘ï¼Œè¿™æ˜¯å› ä¸ºåœ¨å‡½æ•°å¤–é¢å®šä¹‰çš„æ˜¯å…¨å±€å˜é‡ï¼Œæ­¤å¤–ï¼Œä½¿ç”¨ VLA ä¸èƒ½å¯¹æ•°ç»„è¿›è¡Œåˆå§‹åŒ–ï¼Œå› ä¸ºå®ƒçš„é•¿åº¦åœ¨è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šã€‚

é€šå¸¸ï¼ŒMulti-dimensional Arraysï¼Œå¦‚ä¸¤ç»´æ•°ç»„è¡¨ç¤ºä¸º `[row][col]`ï¼Œä¸‰ç»´æ•°æ®å¯ä»¥è¡¨ç¤ºä¸º `[plane][row][col]`ï¼Œå¦‚æœå¯¹ä¸‰ç»´æ•°ç»„æŒ‡é’ˆè¿›è¡Œè¿ç®—ï¼Œè¿ç®—è¡¨è¾¾å¼ä¸º `*(*(*(im+plane)+row)+col)`ï¼ŒäºŒç»´ä¹Ÿç±»ä¼¼ï¼Œ`*(*(im+row)+col)`å…ˆè®¡ç®—çš„æ°¸è¿œæ˜¯æœ€å·¦ä¾§çš„æ–¹æ‹¬å·ã€‚

å½“ç„¶ï¼Œå¦‚æœä¸æ€•æ··æ·†ï¼Œç›´æ¥ä½¿ç”¨ç¬¬åä¸€ç»´åç§»ä¹Ÿå¯ä»¥è®¿é—®æ‰€æœ‰å…ƒç´ ï¼Œæ¯”å¦‚äºŒç»´æ•°ç»„ï¼Œåªè¦ offset è¶³å¤Ÿå¤§ï¼Œ`*(*im+offset)` è¿™æ ·çš„å°±åªå¯ä»¥è®¿é—®åˆ°æ‰€æœ‰å…ƒç´ ï¼Œä½¿ç”¨ä¸€ä¸ªä¹˜æ•°ä¹Ÿå¯ä»¥å°† offset è½¬æ¢æˆå…¶å®ƒç»´åº¦çš„æŒ‡é’ˆè¿ç®—ï¼Œæ²¡æœ‰æœ¬è´¨åŒºåˆ«ã€‚

å‰é¢çš„ä»£ç ç‰‡æ–­ä¸­ï¼Œè¿˜æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼Œä½œä¸ºåœ°å€ä½¿ç”¨ `im` å¯ä»¥ç›´æ¥é€šè¿‡ printf æ‰“å°å‡ºæ¥ï¼Œä½†æ˜¯å¦‚æœéœ€è¦å–å€¼ï¼Œå°±å¿…éœ€é€šè¿‡ * è§£å¼•ç”¨ï¼Œå¤šå°‘ç»´çš„æ•°æ®å°±æœ‰å¤šå°‘ä¸ª * è¿›è¡Œè§£å¼•ç”¨ï¼Œè¿™æ˜¯ç¼–è¯‘å™¨çº¦å®šçš„è§„åˆ™ï¼Œå¦åˆ™å®ƒå°±æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªåœ°å€ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå€¼ã€‚å¹¶ä¸”ï¼Œæ¯ä¸€æ¬¡è§£å¼•ç”¨åï¼Œå¾—åˆ°çš„åœ°å€çš„ç»´åº¦ä¿¡æ¯éƒ½ä¸ä¸€æ ·ï¼Œæ‰€ä»¥ + - è¿ç®—çš„æ„ä¹‰ä¹Ÿä¸åŒã€‚

å¯ä»¥ç”¨ä»¥ä¸‹å›¾è¡¨ç®€åŒ–ç†è§£ï¼š

      ğŸ”´im                im+1                     *(im+2)+1
       |                   |                         |
       |                   |                         |
       V                   V                         V
    { ğŸ”´1  ğŸ”´2  ğŸ”´3 }, { ğŸ”´4  ğŸ”´5  ğŸ”´6 }, { ğŸ”´7  ğŸ”´8  ğŸ”´9 }  <-- Memory Cell
    row = 0              row = 1             row = 2


åº”è¯¥æ³¨æ„åˆ°ï¼Œé™¤äº† im å˜é‡ï¼Œåƒ `im+1` æˆ– `*(im+2)+1` å¹¶æ²¡æœ‰åŠ åœ†ç‚¹ï¼Œè¡¨ç¤ºç¼–è¯‘å™¨æ²¡æœ‰ä¸ºå®ƒä»¬åˆ†é…ç›¸åº”çš„å†…å­˜ï¼Œå°½ç®¡å®ƒä»¬ä½œä¸ºè¡¨è¾¾å¼ç¡®å®ä¼šäº§ç”Ÿç›¸åº”çš„ä»£ç å¹¶å æ®ä¸€å®šå†…å­˜ã€‚

ä»ä¸Šé¢çš„ç¤ºæ„å›¾ä¸­ï¼Œåº”è¯¥ç†è§£åˆ°ï¼Œå¤šç»´æ•°ç»„æœ¬è´¨å’Œä¸€ç»´æ•°ç»„æ˜¯æ²¡æœ‰åŒºåˆ«çš„ï¼Œå°±æ˜¯è¿ç»­çš„å†…å­˜ç©ºé—´ï¼Œå”¯ä¸€å·®åˆ«å°±æ˜¯è¿›è¡ŒæŒ‡é’ˆè®¡ç®—æ—¶ï¼Œä¸åŒçš„è§£å¼•ç”¨å¯¹åº”äº†ä¸åŒçš„ä¸€ä¸ªä¹˜æ•°ï¼Œå³åç§»é‡çš„ä¹˜æ•°ã€‚

å¯¹äºè®¸å¤š C è¯­è¨€æ•™ææ¥è¯´ï¼Œä»¥ä¸Šè¿™ç‚¹æ˜¯æ²¡æœ‰æ¸…æ™°è§£é‡Šçš„ï¼Œä¹Ÿæ²¡æœ‰ç»™å‡ºä¸€ä¸ªå¾ˆå¥½çš„å…¥é—¨çº§è§£é‡Šã€‚

é¦–å…ˆï¼Œè¦åŒºåˆ†æ™®é€šå˜é‡å’ŒæŒ‡é’ˆï¼Œè™½ç„¶åœ¨ç¼–è¯‘è¯­è¨€ä¸­å®ƒä»¬æ˜¯ä¸¤ç§ä¸åŒçš„ä¸œè¥¿ï¼Œä½†æœ¬è´¨ä¸Šæ²¡æœ‰ä»€ä¹ˆå·®åˆ«ã€‚æŒ‡é’ˆå°±å­˜å‚¨å†…å­˜åœ°å€çš„ï¼Œè€Œå˜é‡æ˜¯å­˜å‚¨ä¸€ä¸ªå€¼ï¼Œå¦‚æœå°†æŒ‡é’ˆå­˜å‚¨çš„å†…å­˜åœ°å€å½“ä½œæ™®é€šçš„æ•´å½¢æ•°å€¼æ¥çœ‹å¾…ï¼Œé‚£ä¹ˆæŒ‡é’ˆå°±ç›¸å½“äºä¸€ä¸ªæ•´å½¢å˜é‡ã€‚å¦‚æœè¯´äº‹å®ä¸ŠæŒ‡é’ˆå’Œæ™®é€šå˜é‡åŒºåˆ«æ˜¯å·¨å¤§çš„ï¼Œé‚£å°±æ˜¯å› ä¸ºæŒ‡é’ˆçš„åŠŸèƒ½æˆ–ä½¿ç”¨åœºåˆã€ä½¿ç”¨æ–¹å¼çš„ä¸åŒå†³å®šçš„ã€‚ç‰¹åˆ«æ˜¯æŒ‡é’ˆåœ¨å†…å­˜ç®¡ç†ä¸­çš„åº”ç”¨ï¼Œè¿™å°±æ˜¯æŒ‡é’ˆå’Œå˜é‡äº§ç”Ÿå·¨å¤§å·®åˆ«çš„åŸå› ã€‚

è€Œæ•°ç»„å’Œå˜é‡çš„åŒºåˆ«å°±åœ¨äºæ•°ç»„æ˜¯è¿ç»­çš„æ•°æ®ï¼Œå¦‚æœæ•°ç»„åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆå®ƒå’Œæ™®é€šå˜é‡æ²¡æœ‰å·®åˆ«ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œæ•°ç»„åå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªå˜é‡åï¼Œå˜é‡åä¹Ÿå¯ä»¥ç†è§£æŒ‡å‘ç¬¬ä¸€ä¸ªå…ƒç´ çš„æ•°ç»„åï¼å¦å¤–ä¸€ä¸ªåŒºåˆ«æ˜¯ï¼Œæ•°ç»„çš„æ“ä½œä¸Šçš„åŒºåˆ«ï¼Œæ¯•ç«Ÿå’Œå˜é‡å­˜å‚¨çš„å†…å®¹åœ¨è¿ç»­æ€§ä¸Šæœ‰å·®åˆ«ã€‚æ‰€ä»¥æ•°ç»„é¢å¤–å¤šäº†ä¸‹æ ‡è¿ç®—ï¼Œå®ƒå­˜åœ¨çš„æ„ä¹‰åœ¨äºï¼Œå¯ä»¥æ ¹æ®æ•°ç»„åå’Œå…ƒç´ å æ®å­—èŠ‚çš„å¤§å°æ¥è¿›è¡Œä¸€ä¸ªåœ°å€åç§»çš„è¿ç®—ï¼Œä»…æ­¤è€Œä»¥ã€‚

ä»¥ä¸‹ç¤ºä¾‹ç»Ÿè®¡ç”¨æˆ·è¾“å…¥çš„æ•°å­—å­—ç¬¦ä¸ªæ•°ï¼š

```c
#include <stdio.h>

/* count digits, white space, others */
main()
{
   int c, i, nwhite, nother;
   int ndigit[10];

   nwhite = nother = 0;
   for (i = 0; i < 10; ++i)
       ndigit[i] = 0;

   while ((c = getchar()) != EOF)
       if (c >= '0' && c <= '9')
           ++ndigit[c-'0'];
       else if (c == ' ' || c == '\n' || c == '\t')
           ++nwhite;
       else
           ++nother;

   printf("digits =");
   for (i = 0; i < 10; ++i)
       printf(" %d", ndigit[i]);
   printf(", white space = %d, other = %d\n",
       nwhite, nother);
}
```

å®šä¹‰å¥½ä¸€ä¸ªæ•°ç»„å˜é‡åï¼Œå…¶å˜é‡ç¬¦å·å°±ä»£è¡¨äº†å†…å­˜ç©ºé—´çš„èµ·å§‹åœ°å€ï¼Œç„¶åé€šè¿‡æ–¹æ‹¬å·æŒ‡å®šä¸‹æ ‡æ¥è®¿é—®æ•°ç»„çš„å„ä¸ªå…ƒç´ ï¼Œå¦‚ `a[0]` `a[1]` åˆ†åˆ«è¡¨ç¤ºç¬¬ 1 ä¸ªå’Œç¬¬ 2 ä¸ªå…ƒç´ ã€‚

å½“ç„¶ï¼Œç›´æ¥å°†æŒ‡é’ˆä½œä¸ºåœ°å€å€¼è¿›è¡Œè¿ç®—ä¹Ÿæ˜¯ä¸€æ ·çš„ï¼Œ`*(a+0)` `*(a+1)`ï¼Œå’Œä½¿ç”¨ä¸‹æ ‡æ–¹å¼æ˜¯ç­‰ä»·çš„ã€‚

å¦å¤–ï¼ŒC è¯­è¨€ä½œä¸ºä¸€é—¨æ•ˆç‡ä½•ç­‰ä¼˜å…ˆçš„è¯­è¨€ï¼Œå¯¹æ•°æ•°ç»„çš„è¶Šç•Œè®¿é—®è¡Œä¸ºæ˜¯ä¸ä½œæ£€æŸ¥çš„ï¼Œæ‰€ä»¥éœ€è¦è‡ªè¡Œå¤„ç†ã€‚


### ===ğŸ‘‰ Pointers

æŒ‡é’ˆå¯ä»¥è¯´æ˜¯ C è¯­è¨€ä¸­æœ€å¼ºå¤§çš„åŠŸèƒ½ï¼Œä½†ä¹Ÿæ˜¯æœ€å®¹æ˜“å¼•å…¥é—®é¢˜çš„åŠŸèƒ½ã€‚

åœ¨æ—§æœ‰è§‚ç‚¹ä¸­ï¼ŒæŒ‡é’ˆä»£è¡¨äº†é«˜æ•ˆç‡ï¼Œä½†æ˜¯åœ¨ç°ä»£ç¼–è¯‘å™¨çš„ä¼˜åŒ–ä¸‹ï¼Œä¸ç”¨æŒ‡é’ˆä¹ŸåŒæ ·å…·æœ‰é«˜æ•ˆç‡ã€‚æŒ‡é’ˆä½œä¸ºä¸€ä¸ªåº•å±‚åŠŸèƒ½ï¼Œæ›´å¤šçš„æ˜¯åœ¨æ•°æ®ç»“æ„ä¸ç®—æ³•ä¸­åº”ç”¨ã€‚

æœ‰äº†å†…å­˜çš„æŒ‡é’ˆï¼Œæ„å‘³ç€æœ‰äº†å¯ä»¥å¯¹æŒ‡å®šå†…å­˜åœ°å€è¿›è¡Œæ“ä½œçš„æƒåŠ›ï¼Œè€Œå†…å­˜é€šå¸¸æ˜¯åœ¨æ“ä½œç³»ç»Ÿç®¡ç†ä¸‹åˆ†é…ä½¿ç”¨ï¼Œæ‰€ä»¥ç›´æ¥æ“ä½œå†…å­˜å¾ˆå®¹æ˜“å’Œæ“ä½œç³»ç»Ÿå†…å­˜ç®¡ç†å†²çªï¼Œæˆ–è€…ç ´åç ´åç¨‹åºé€»è¾‘å®Œæ•´æ€§ã€‚

å¦‚å‰é¢ ğŸ‘‰ Variable vs Constants çš„å†…å®¹ï¼Œå…¸å‹çš„æŒ‡é’ˆé—®é¢˜å°±æ˜¯å¼ºåˆ¶æ”¹å˜åªè¯»å†…å­˜çš„æ•°æ®å°†å¯¼è‡´ Segmentation fault(SIGSEGV) å¼‚å¸¸ï¼Œå½“ç„¶ï¼Œè¿›ç¨‹è¶Šç•Œè®¿é—®å…¶å®ƒè¿›ç¨‹çš„å†…å­˜ä¹Ÿä¼šå¯¼è‡´è¿™æ ·çš„å¼‚å¸¸ã€‚åœ¨ CPU å†…éƒ¨ï¼Œæœ‰å†…å­˜åˆ†é¡µæœºåˆ¶ç®¡ç†ç€ç‰©ç†å†…å­˜ï¼Œå¹¶é€šè¿‡ GDT/LDT ç­‰å¯„å­˜å™¨ç®¡ç†ç€æ˜ å°„è¡¨ï¼Œåœ¨å†…å­˜åˆ†é¡µè®°å½•ä¸­ï¼ŒåŒ…å«äº†ç¨‹åºä½¿ç”¨çš„å†…å­˜ç©ºé—´è¯¦ç»†ä¿¡æ¯ï¼ŒåŒ…å«ç¨‹åºè¿è¡Œçš„ä»£ç æ®µ .text ä»¥åŠæ•°æ®æ®µ .data çš„èµ·å§‹åœ°å€ï¼Œä¸€æ—¦ç¨‹åºå‘ç”Ÿäº†è¶Šç•Œè®¿é—®ï¼Œæˆ–ä¿®æ”¹åªè¯»å†…å­˜ï¼ŒCPU å°±ä¼šäº§ç”Ÿç›¸åº”çš„å¼‚å¸¸ä¿æŠ¤ã€‚

æŒ‡é’ˆä½œä¸º C/C++ è¯­è¨€æœ€å¼ºå¤§çš„åº•å±‚æ“ä½œåŠŸèƒ½ï¼Œå®ƒè¡¨ç°å¤šå°‘æœ‰äº›ç±»ä¼¼äºå˜é‡ã€‚

é¦–å…ˆï¼ŒæŒ‡é’ˆå’Œå˜é‡ä¸€æ ·ï¼Œå…·æœ‰ä¸¤ä¸ªéƒ¨åˆ†çš„å±æ€§ï¼Œä¸€ä¸ªæ˜¯`å…³è”ç±»å‹`å±æ€§ï¼Œå¦ä¸€ä¸ªæ˜¯`åœ°å€å€¼`ã€‚

å…¶æ¬¡ï¼ŒæŒ‡é’ˆæœ¬èº«ä¹Ÿå¯ä»¥å˜é‡ä¸€æ ·å ç”¨å†…å­˜ï¼Œä½†æ˜¯æŒ‡é’ˆå ç”¨çš„å†…å­˜æ˜¯å›ºå®šçš„ï¼Œä¾‹å¦‚ä½¿ç”¨ `sizeof(char *)` è·å–å­—ç¬¦æŒ‡é’ˆçš„å¤§å°ï¼Œåœ¨ 32-bit å¹³å°é‡Œï¼ŒæŒ‡é’ˆæœ¬èº«å æ®äº† 4 ä¸ªå­—èŠ‚ç©ºé—´ã€‚

ä½†æ˜¯ï¼ŒæŒ‡é’ˆå’Œå˜é‡å®Œå…¨æ˜¯ä¸ä¸€æ ·çš„ä¸œè¥¿ï¼Œå˜é‡åªæ˜¯ç”¨æ¥é€šè¿‡å‘½åæ–¹å¼è®¿é—®ä¿å­˜æ•°æ®çš„å†…å­˜ï¼Œè€ŒæŒ‡é’ˆé€šè¿‡åœ°å€ç›´æ¥è®¿é—®å†…å­˜ï¼Œå¹¶ä¸”ä¸å±€é™äºå˜é‡çš„æ•°æ®ï¼Œè¿˜åŒ…æ‹¬å‡½æ•°ç­‰ä¸€åˆ‡å†…å­˜å¯ä»¥è®¿é—®åˆ°çš„ä¸œè¥¿ã€‚

å¦‚å‰é¢çš„æŒ‡é’ˆè¿ç®— `a+1`ï¼Œæ•°ç»„å˜é‡ a å°±æ˜¯ä»£è¡¨æ•°ç»„èµ·å§‹å†…å­˜åœ°å€çš„æŒ‡é’ˆï¼Œå®ƒå¯ä»¥è¿è¡Œæ˜¯åŸºäºæŒ‡é’ˆçš„ä¸¤ä¸ªå±æ€§è¿›è¡Œçš„ã€‚+1 è¡¨ç¤ºæŒ‡é’ˆåœ°å€å‘å‰ç§»åŠ¨ä¸€ä¸ªå…ƒç´ æ‰€å ç”¨çš„å†…å­˜å¤§å°ï¼Œæ¯”å¦‚ `sizeof(int)`ï¼Œ-1 åˆ™è¡¨ç¤ºåå‘ç§»åŠ¨åœ°å€ã€‚å¦‚æœæŒ‡é’ˆæ²¡æœ‰å…³è”ç±»å‹ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨å°±ä¸èƒ½ç†è§£å¦‚ä½•è¿›è¡Œè¿ç®—ï¼ŒC è¯­è¨€ä¸­å¯ä»¥å®šä¹‰æ— ç±»å‹æŒ‡é’ˆ `void *`ï¼Œä½†æ˜¯ä¸èƒ½å®šä¹‰æ— ç±»å‹çš„å˜é‡ã€‚

ä¸¤ä¸ªç›¸å…³çš„è¿ç®—ç¬¦ï¼š

- `&` å–åœ°å€è¿ç®—ç¬¦ï¼Œå®ƒè¿”å›è¿ç®—å¯¹è±¡æˆ–è€…å˜é‡çš„å†…å­˜åœ°å€ã€‚
- `*` è§£æŒ‡é’ˆè¿ç®—ç¬¦ï¼Œå³ indirection/dereferencing operator é—´æ¥æ“ä½œç¬¦ï¼Œå®ƒè¿”å›æŒ‡é’ˆæŒ‡å‘çš„å˜é‡å€¼ã€‚

ä¸¤ä¸ªç‰¹æ®Šçš„æŒ‡é’ˆï¼š

- `void *` æŒ‡é’ˆå¯ä»¥åŒ…å®¹å…·ä½“ç±»å‹çš„æŒ‡é’ˆï¼Œå³å¯ä»¥å°†ä»»æ„æŒ‡é’ˆèµ‹å€¼ç»™æ— ç±»å‹æŒ‡é’ˆï¼Œä½†åè¿‡æ¥ä¸è¡Œã€‚
- `NULL` ç©ºæŒ‡é’ˆï¼Œæ²¡æœ‰å…³è”ç±»å‹ï¼Œä¹Ÿæ²¡æœ‰åœ°å€å€¼ï¼Œä¸æŒ‡å‘ä»»ä½•åœ°å€ï¼Œæˆ–è€…å…·ä½“ç†è§£ä¸ºæŒ‡å‘ 0 åœ°å€çš„æŒ‡é’ˆã€‚

æŒ‰ç…§ ANSI(American National Standards Institute) æ ‡å‡†ï¼Œä¸èƒ½å¯¹ `void *` æŒ‡é’ˆè¿›è¡Œç®—æ³•æ“ä½œï¼ŒåŒ…æ‹¬è§£å¼•ç”¨ã€‚

C è¯­è¨€çš„ * ç¡®å®æ˜¯ä»¤äººå›°æƒ‘çš„ç¬¦å·ï¼Œåœ¨å®šä¹‰æŒ‡é’ˆæ—¶ï¼Œå¦‚ `int *ip` å®ƒå…¶å®ç­‰ä»·ä¸º `int (*ip)`ã€‚ä½†æ˜¯å¯¹äº `char *argv[]` å®ƒåˆç­‰ä»·ä¸º `char *(argv[])`ï¼Œå› ä¸ºä¸‹æ ‡æ–¹æ‹¬å·ä¼˜å…ˆçº§é«˜äº * æ“ä½œç¬¦å·ã€‚ä½†æ˜¯ï¼Œæ— è®ºå¦‚ä½•ç»“åˆï¼Œ* éƒ½ä¸æ˜¯ä¸æ•°æ®ç±»å‹ç»“åˆï¼Œè€Œæ˜¯ä¸å˜é‡ç¬¦å·ç»“åˆã€‚å…·ä½“å«ä¹‰å¾ˆæ˜æ˜¾ï¼Œå°†ç¬¦å·å®šä¹‰ä¸ºæŒ‡é’ˆï¼Œè€Œæ•°æ®ç±»å‹åˆ™ä¸ºæŒ‡é’ˆçš„å…³è”æ•°æ®ç±»å‹ã€‚

ä¸å¾—ä¸æçš„æ˜¯ï¼Œå¯¹æŒ‡é’ˆçš„è¿ç®—å¹¶éæ˜¯ç®—æœ¯è¿ç®—ï¼Œå®ƒæ˜¯ç¼–è¯‘æä¾›çš„åŸºäºå†…å­˜åœ°å€å’Œæ•°æ®ç±»å‹çš„å…³è”è¿ç®—ï¼Œæ‰€ä»¥ä¹Ÿå°±ä¸å­˜åœ¨æŒ‡é’ˆçš„ä¹˜é™¤è¿ç®—ï¼Œä¹Ÿä¸åŒ…å«å‡½æ•°æŒ‡é’ˆçš„è¿ç®—ï¼Œå®ƒä»¬æ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚

æŒ‡é’ˆåªå¯ä»¥è¿›è¡Œ ++ -- + - å››ç§è¿ç®—ï¼Œæ³¨æ„ä¸æ˜¯ç®€å•çš„ç®—æœ¯è¿ç®—ï¼Œå’Œæ•°ç»„è¶Šç•Œä¸æ£€æŸ¥ä¸€æ ·ï¼Œåœ°å€è¿ç®—ä¹ŸåŒæ ·ä¸åšè¶Šç•Œæ£€æŸ¥ã€‚

æŒ‡é’ˆä¹Ÿå¯ä»¥åƒå˜é‡ä¸€æ ·è¿›è¡Œç±»å‹è½¬æ¢ï¼Œå‚è€ƒä»¥ä¸‹åŸºæœ¬ç”¨æ³•ï¼š

```c
int x = 1, y = 2, z[10];
int *ip;          /* ip is a pointer to int */

ip = &x;          /* ip now points to x */
y = *ip;          /* y is now 1 */
*ip = 0;          /* x is now 0 */
ip = &z[0];       /* ip now points to z[0] */

void *vp = ip;
ip = (int *)vp;
```

åœ¨ main å‡½æ•°çš„å‚æ•°åˆ—è¡¨ä¸­ï¼Œå‡ºç°äº†åƒ `char *argv[]` è¿™æ ·çš„æŒ‡é’ˆï¼Œé¦–å…ˆå¿…éœ€ç†è§£ `chat *` å’Œ `char[]` åŸºæœ¬æ˜¯ç­‰ä»·çš„ä¸¤ç§ç±»å‹ï¼Œé™¤äº†åˆå§‹åŒ–å’Œå†…å­˜åˆ†é…çš„å·®åˆ«ï¼Œå®ƒä»¬å®šä¹‰çš„éƒ½æ˜¯ä¸€ä¸ªæŒ‡é’ˆã€‚

ä»è¿ç®—ç¬¦å·ä¼˜å…ˆçº§æ¥çœ‹ï¼Œä¸€å…ƒè¿ç®—ç¬¦å· * ä»…æ¬¡ä¼˜å…ˆäº [] ç¬¦å·ï¼ŒæŒ‰ left to right ç»“åˆé¡ºåºä¸º `char *(argv[])`ã€‚æ‰€ä»¥ï¼Œä»è¯­æ³•ä¸Šæ¥è§£æï¼Œargv å…ˆæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œç„¶åæ‰æ˜¯æŒ‡é’ˆï¼Œè€Œæ•°ç»„å…ƒç´ å³ä¸º `char *` æŒ‡é’ˆï¼Œå³ä¸€ä¸ªåŒ…å«æŒ‡é’ˆçš„æ•°ç»„ Array of Pointersã€‚

å¦‚æœï¼Œå°†æ‹¬å·åŠ äºæ–¹æ‹¬å·å‰ï¼Œ`char (* argv)[]` è¿™æ ·å°±æ˜¯æ•°ç»„æŒ‡é’ˆï¼ŒPointer of Arrayã€‚

æ‰€ä»¥ï¼Œ**ä¸è€ƒè™‘åˆå§‹åŒ–çš„å‰æä¸‹**ï¼Œargv å…¶å®å°±æ˜¯ä¸€ä¸ªåŒé‡æŒ‡é’ˆï¼Œä½†æ˜¯ï¼Œåˆä¸èƒ½å°†å®ƒç­‰ä»·çœ‹ä½œ `char **`ï¼Œè¿™è§£æä¸ºä¸€ä¸ªæŒ‡å‘å­—ç¬¦æŒ‡é’ˆçš„æŒ‡é’ˆï¼Œå®ƒä»¬ä¸¤è€…çš„åŒºåˆ«ä¸»è¦ä½“ç°åœ¨ä»¥ä¸‹ä»£ç ç‰‡æ–­çš„åˆå§‹åŒ–çš„è¿‡ç¨‹ä¸­ã€‚`char *argv[]` éœ€è¦ä¸€ä¸ªåœ°å€åˆ—è¡¨æ¥åˆå§‹åŒ–ï¼Œè€Œ `char **` éœ€è¦ä¸€ä¸ªæŒ‡é’ˆçš„æŒ‡é’ˆæ¥åˆå§‹åŒ–ï¼Œè¿™å¯ä»¥è¯´æ˜¯æ•°ç»„ä¸æŒ‡é’ˆçš„åˆå§‹åŒ–å·®å¼‚ã€‚

åƒä»¥ä¸‹è¿™æ ·çš„åŒé‡æŒ‡é’ˆï¼Œç†è§£èµ·æ¥è¿˜æ˜¯æ¯”è¾ƒå®¹æ˜“çš„ï¼Œè™½ç„¶å­—ç¬¦ä¸²çš„é•¿çŸ­ä¸ä¸€ï¼Œä½†æ˜¯è¿˜è¿˜å¯ä»¥è¿›è¡Œ + - ç­‰æ“ä½œï¼Œç¼–è¯‘å™¨åœ¨ç¼–è¯‘æœŸå¯ä»¥æ¨æ–­å‡ºå“ªä¸ªå­—ç¬¦ä¸²åœ¨å“ªä¸ªåœ°å€ï¼š

```c
// Ok: initialized Pointer Array with (char *) list
char * argv[] = {"abc","xyz", "uv", "uvw"};
char argv[4][256] = {"abc", "xyz", "uv", "uvw"};
// Error: initialized pointer with (char *) list
char ** argv = {"abc", "xyz", "uv", "uvw"}; 
printf("Test: %s %s %s", *argv, argv[2], *(argv+3));
```

ä»¥ä¸Šä»£ç ç‰‡æ–­è¿˜è¯´æ˜äº†æŒ‡é’ˆä¸æ•°ç»„çš„åˆå§‹åŒ–å·®å¼‚ï¼Œåˆå§‹åŒ–è¿‡ç¨‹ä¹Ÿæ˜¯æŒ‡é’ˆä¸æ•°ç»„çš„æœ€å¤§åŒºåˆ«æ‰€åœ¨ã€‚è™½ç„¶ï¼Œå¯ä»¥ä½¿ç”¨ `{"abc","xyz", "uv", "uvw"}` è¿™æ ·ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨å»åˆå§‹åŒ–ç›¸åº”çš„æ•°ç»„ï¼Œä½†æ˜¯ç”¨ä¿å­˜æœ‰åŒæ ·æ•°æ®çš„ä¸€ä¸ªæ•°ç»„å˜é‡å»åˆå§‹åŒ–å°±ä¸è¡Œï¼Œç¼–è¯‘åªä¼šä»å­—é¢é‡åˆ—è¡¨å»æ¨æµ‹å‡ºåˆå§‹çš„æ—¶éœ€è¦çš„åœ°å€åˆ—è¡¨ï¼Œè€Œä¸ä¼šå»æ¨æµ‹ä¸€ä¸ªæ•°ç»„å˜é‡å«æœ‰çš„åœ°å€å…ƒç´ ã€‚æ‰€ä»¥ï¼Œå­—ç¬¦ä¸²æ•°ç»„åˆå§‹åŒ–åˆ—è¡¨ç»è¿‡ç¼–è¯‘å™¨å¤„ç†åï¼Œå®è´¨ä¸Šå°±æ˜¯ [address, address, ...] è¿™æ ·çš„åœ°å€æ•°ç»„ï¼Œè¿™äº›åœ°å€æŒ‡å‘å­—ç¬¦ä¸²å­—é¢å¸¸é‡çš„åœ°å€ã€‚

åŒé‡æŒ‡é’ˆåœ¨å†…å­˜ä¸Šï¼Œå¯ä»¥ç†è§£ä¸ºå…·æœ‰ä¸¤ä¸ªä¸²è”çš„æŒ‡é’ˆï¼Œéœ€è¦ç»è¿‡ä¸¤æ¬¡è§£å¼•ç”¨æ‰èƒ½å¾—åˆ°æ•°æ®ã€‚é¦–å…ˆ argv å˜é‡æœ¬èº«å°±æ˜¯å…¥å£åœ°å€ï¼ŒæŒ‡å‘ä¸€ä¸ªæ•°ç»„æ‰€åœ¨çš„åœ°å€ï¼Œè€Œè¿™ä¸ªæ•°ç»„ä¿å­˜çš„æ˜¯ `char *` å³å­—ç¬¦ä¸²æŒ‡é’ˆï¼Œæ‰€ä»¥éœ€è¦ `*argv` æ¥è·å–å­—ç¬¦ä¸²æ•°ç»„çš„åœ°å€æ‰èƒ½é€šè¿‡ printf æ‰“å°å‡ºå†…å®¹ã€‚

C è¯­è¨€å’Œå…¶å‰èº« B è¯­è¨€ä¸€æ ·ï¼Œå°†åœ°å€å½“ä½œæ•´å‹æ•°æ®çœ‹å¾…ï¼Œä½¿ç”¨ printf è¿™æ ·çš„å‡½æ•°æ‰“å°æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ `%p %d %x` ç­‰æ ¼å¼åŒ–å­—ç¬¦éƒ½å¯ä»¥å¾ˆå¥½åœ°æ˜¾ç¤ºæŒ‡é’ˆæŒ‡å‘çš„åœ°å€ã€‚

åœ¨è¿™é‡Œçš„ä»£ç ç‰‡æ–­ä¸­éœ€è¦æ³¨æ„ï¼Œå£°æ˜çš„æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œä½†åŒæ—¶åˆå°†å­—ç¬¦ä¸²å­—é¢å¸¸é‡åˆ—è¡¨ä½œä¸ºåˆå§‹åŒ–å€¼èµ‹ç»™ argvï¼Œå³å°†å­—é¢é‡çš„åœ°å€èµ‹ç»™å®ƒã€‚

ä½†æ˜¯ï¼Œè¿™æ ·çš„æŒ‡é’ˆåˆå§‹åŒ–æ–¹å¼ä¸å¯ä»¥åœ¨æ•°å€¼å­—é¢å¸¸é‡ä¸­ä½¿ç”¨ï¼Œå¦‚ `int * ie = 123;` å°±ä¸èƒ½é€šè¿‡ç¼–è¯‘ï¼Œå› ä¸ºæŒ‡é’ˆåˆå§‹åŒ–éœ€è¦çš„æ˜¯ä¸€ä¸ªåœ°å€ï¼Œè€Œä¸æ˜¯æ•°å€¼ã€‚å½“ç„¶ï¼ŒC è¯­è¨€ä½œä¸ºåº•å±‚è¯­è¨€ï¼Œå®ƒå®Œå…¨å…è®¸ä½ å°† 123 é€šè¿‡è½¬å‹å˜æˆæŒ‡é’ˆï¼Œ`(int *) 123`ï¼Œä½†æ˜¯è¿™æ ·åšé€šå¸¸ä¼šå¯¼è‡´ç¨‹åºè¿è§„è®¿é—®å†…å­˜ï¼Œä¸€ä¸ªç¨‹åºå¯ä»¥è®¿é—®çš„å†…å­˜ï¼Œæˆ–ä»¥è¯»å–çš„å†…å­˜æ˜¯ç”±ç³»ç»Ÿåˆ†é…çš„ã€‚å³ä½¿æœ‰é™è¯»å–ï¼Œå¦‚æœå°è¯•æ‰§è¡Œå†™å…¥æ“ä½œï¼Œä¹Ÿæ˜¯è¿è§„ä½¿ç”¨å†…å­˜ï¼Œè¿™ä¼šå¯¼è‡´ SIGSEGV å¼‚å¸¸ã€‚


æŒ‡é’ˆä¸å¸¸é‡ç»“åˆä¹Ÿèƒ½äº§ç”Ÿä¸¤ç§ä¸åŒçš„æ•ˆæœï¼š

- æŒ‡å‘å¸¸é‡çš„æŒ‡é’ˆï¼Œå› ä¸ºæŒ‡é’ˆçš„æ˜¯å¸¸é‡ï¼Œå½“ç„¶ä¸èƒ½é€šè¿‡æŒ‡é’ˆæ¥ä¿®æ”¹ï¼Œä½†æŒ‡é’ˆæœ¬èº«å¯ä»¥æŒ‡å‘ä¸åŒçš„åœ°å€ï¼›
- å¸¸é‡æŒ‡é’ˆï¼Œå› ä¸ºæŒ‡é’ˆæ˜¯å¸¸é‡ï¼Œå½“ç„¶æŒ‡é’ˆæœ¬èº«ä¸å¯å˜æ›´åœ°å€ï¼Œå¦‚æœåŒæ—¶åˆæŒ‡å‘ä¸€ä¸ªå¸¸é‡ï¼Œé‚£å°±æ˜¯å®Œå…¨ imutableï¼›

å‚è€ƒè¯­æ³•å¦‚ä¸‹ï¼Œè®°ä½æŒ‡é’ˆçš„ä¸¤ä¸ªå±æ€§ï¼Œè¿˜æœ‰å•å…ƒæ“ä½œç¬¦å· * çš„ä¼˜å…ˆçº§å»ç†è§£ï¼š

```c
int num = 100; // define a variable
const int PI = 3.14; // define a constant
const int *const cc_pi = &PI; // define a constant pointer point to a constant 
int *const vc_pi = (int*)&PI; // define a const pointer point to a constant
```

é‰´äº Unary * right to left çš„ç»“åˆè§„åˆ™ï¼Œå£°æ˜ const æ—¶ï¼Œå°†å•å…ƒè¿ç®—ç¬¦ * å†™åœ¨å…³é”®å­—æˆ–æ ‡è¯†ç¬¦å·çš„å·¦ä¾§æ˜¯é€»è¾‘æ­£ç¡®çš„ï¼Œå®ƒä¿®é¥°çš„å°±æ˜¯é åœ¨å³ä¾§çš„å†…å®¹ã€‚

Command-Line Arguments æ˜¯ç¨‹åºç»å¸¸ä½¿ç”¨åˆ°çš„è¾“å…¥æ•°æ®ï¼Œæ•™æä¸­å®ç°ä¸€ä¸ª find ç¨‹åºæ¥å±•ç¤ºå¦‚ä½•å¤„ç†ä¸»å‡½æ•°çš„å‚æ•°åˆ—è¡¨ã€‚

UNIX ç³»ç»Ÿä¸Šçš„ç¨‹åºçš„ä¸€ä¸ªå¸¸è§çº¦å®šæ˜¯ï¼Œä»¥å‡å·å¼€å¤´çš„å‚æ•°æ¥å‘ç¨‹åºå¼•å…¥å¯é€‰æ ‡å¿—æˆ–é€‰é¡¹ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥ä½¿ç”¨ -x è¡¨ç¤ºæ’é™¤â€œexceptâ€ï¼Œä½¿ç”¨ -n æ¥è¯·æ±‚è¡Œç¼–å·ã€‚

é‚£ä¹ˆå‘½ä»¤å¯ä»¥æŒ‰ä»¥ä¸‹è¾“å…¥ï¼Œå°†ä¸åŒ¹é…çš„å†…å®¹æ‰“å°å‡ºæ¥ï¼š

    find -x -n pattern

é€‰é¡¹è¿˜åº”è¯¥ä¸é™åˆ¶é¡ºåºï¼Œè¿™æ ·ç”¨æˆ·å¯ä»¥éšæ„è¾“å…¥æœ‰æ•ˆé€‰é¡¹è€Œä¸ç”¨ç®¡ä»€ä¹ˆé¡ºåºï¼Œå½“ç„¶ï¼Œå¦‚æœé€‰é¡¹å¯ä»¥åˆå¹¶è¾“å…¥å¦‚ `-nx pattern` è¿™æ ·è¾“å…¥å°±æ›´æ–¹ä¾¿äº†ï¼Œè¿™æ ·ä½¿ç”¨ switch ç»“æ„å¤„ç†èµ·æ¥å°±å¾ˆåˆé€‚ã€‚

```c
#include <stdio.h>
#include <string.h>
#define MAXLINE 1000

int getline(char *line, int max);

/* find: print lines that match pattern from 1st arg */
main(int argc, char *argv[])
{
   char line[MAXLINE];
   long lineno = 0;
   int c, except = 0, number = 0, found = 0;

   while (--argc > 0 && (*++argv)[0] == '-')
       while (c = *++argv[0])
           switch (c) {
           case 'x':
               except = 1;
               break;
           case 'n':
               number = 1;
               break;
           default:
               printf("find: illegal option %c\n", c);
               argc = 0;
               found = -1;
               break;
           }
   if (argc != 1)
       printf("Usage: find -x -n pattern\n");
   else
       while (getline(line, MAXLINE) > 0) {
           lineno++;
           if ((strstr(line, *argv) != NULL) != except) {
               if (number)
                   printf("%ld:", lineno);
               printf("%s", line);
               found++;
           }
       }
   return found;
}
```

### ===ğŸ‘‰ Simple stack

ä¸ºäº†çªå‡ºæŒ‡é’ˆä¸æ•°ç»„åœ¨åˆå§‹åŒ–ä¸Šé¢çš„å·®åˆ«ï¼Œè¿™é‡ŒåŸºäº stack æ•°æ®ç»“æ„å®ç°ä¸€ä¸ªç®€å•çš„å†…å­˜åˆ†é…å™¨ï¼Œæ¼”ç¤ºå†…å­˜åŠ¨æ€åˆ†é…ã€‚

å†…å­˜çš„åˆ†é…ä¸€èˆ¬æœ‰ä¸¤ä¸ªæ­¥éª¤ï¼š

- ç”³è¯·å†…å­˜ç©ºé—´ï¼Œalloc(n) è¿”å›æŒ‡å‘ n ä¸ªè¿ç»­å­—ç¬¦ä½ç½®çš„æŒ‡é’ˆï¼Œè°ƒç”¨è€…å¯ä»¥ç”¨æ¥å­˜å‚¨å­—ç¬¦ã€‚
- é‡Šæ”¾å†…å­˜ç©ºé—´ï¼Œafree(p) é‡Šæ”¾ä¸Šä¸€æ­¥ç”³è¯·åˆ°çš„å†…å®¹ç©ºé—´ï¼Œä»¥ä¾¿ä»¥åå¯ä»¥é‡ç”¨ã€‚

è¿™äº›ä¾‹ç¨‹æ˜¯æœ€åŸºæœ¬çš„ï¼Œafree çš„è°ƒç”¨å¿…é¡»ä¸ alloc çš„è°ƒç”¨é…å¯¹ä½¿ç”¨ï¼Œå…ˆç”³è¯·åé‡Šæ”¾ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œalloc å’Œ afree ç®¡ç†çš„å­˜å‚¨æ˜¯å †æ ˆï¼Œæˆ–è€…è¯´å…ˆå…¥åå‡ºï¼ŒFirst-in last-outã€‚è€Œ C è¯­è¨€æ ‡å‡†åº“å‡½æ•° malloc å’Œ free å°±æ²¡æœ‰è¿™æ ·çš„é™åˆ¶ï¼Œåœ¨ç¬¬æœ€åä¸€ç« å°†å±•ç¤ºå¦‚ä½•å®ç°å®ƒä»¬ã€‚

æœ€ç®€å•çš„å®ç°å°±æ˜¯å»ºç«‹ä¸€ä¸ªå­—ç¬¦ä¸²å¤§æ•°ç»„ allocbufï¼Œå®ƒæä¾›çš„å†…å­˜ç©ºé—´åªä¾› alloc å’Œ afree åˆ†é…å’Œé‡Šæ”¾ï¼Œæ¨¡æ‹Ÿä¸€ä¸ªçœŸå®çš„å†…å­˜åˆ†é…å™¨ã€‚å› ä¸ºï¼Œéœ€è¦ä½¿ç”¨æŒ‡é’ˆæ¥ç®¡ç†è¿™äº›å†…å­˜ç©ºé—´ï¼Œå¹¶ä¸”ä¸å¸Œæœ›å¤–éƒ¨ä»£ç è®¿é—®åˆ°ï¼Œæ‰€ä»¥å°†æ•°ç»„å®šä¹‰ä¸º static é™æ€å˜é‡ã€‚åœ¨å®è·µä¸­ï¼Œè¿™ä¸ªå†…å­˜ç©ºé—´ç”šè‡³å¯ä»¥æ²¡æœ‰åå­—ï¼Œåªèƒ½é€šè¿‡ malloc æˆ–è€…æ“ä½œç³»ç»Ÿ API æ¥ç”³è¯·ï¼Œä¹Ÿåªèƒ½é€šè¿‡ free æ¥é‡Šæ”¾ã€‚

æ¥ç€å°±æ˜¯å®ç°ç®—æ³•ï¼Œåˆç†åœ°ä½¿ç”¨ allocbuf çš„ç©ºé—´ï¼Œå½“ç„¶ä½œä¸ºä¸€ä¸ªå…¥é—¨ä»‹ç»ï¼Œè¿™é‡Œå¹¶æ²¡æœ‰ä»€ä¹ˆç®—æ³•ï¼Œå°±æ˜¯é€šè¿‡ä¸€ä¸ª Stack æ•°æ®ç»“æ„æ¥æ¼”ç¤ºå†…å­˜çš„åˆ†é…ã€‚ä½¿ç”¨ä¸€ä¸ªæŒ‡é’ˆ allocp æ¥æŒ‡å‘ä¸‹ä¸€ä¸ªæœ‰æ•ˆå†…å­˜åœ°å€ï¼Œå³åç»­å†…å­˜ç”³è¯·å°†ä»è¿™ä¸ªä½ç½®å¼€å§‹ã€‚é€šè¿‡ alloc ç”³è¯· n ä¸ªå­—ç¬¦ä¸²ç©ºé—´ï¼Œå…ˆéœ€è¦æ£€æŸ¥ allocbuf å¯ä½¿ç”¨ç©ºé—´æ˜¯å¦è¶³å¤Ÿã€‚è¶³å¤Ÿå°±è¿”å›å½“å‰ allocp çš„æŒ‡å‘çš„åœ°å€ï¼Œç„¶åè®°å½• n ä¸ªå­—èŠ‚çš„åç§»ï¼ŒæŒ‡å‘ä¸‹ä¸€ä¸ªæœ‰æ•ˆåœ°å€ã€‚å¦‚æœï¼Œå¯ç”¨ç©ºé—´ä¸å¤Ÿï¼Œåˆ™å†…å­˜åˆ†é…å¤±è´¥ï¼Œè¿”å› NULLï¼Œå³é›¶å€¼æŒ‡é’ˆã€‚è€Œ afree(p) çš„å®ç°å°±æ˜¾å¾—ç›¸å½“ç®€å•äº†ï¼Œç›´æ¥å°†å‚æ•°æŒ‡å®šçš„ p æŒ‡é’ˆè®¾ç½®ä¸ºå½“å‰çš„æœ‰æ•ˆåœ°å€ï¼Œè¡¨ç¤ºå›æ”¶å·²åˆ†é…çš„å†…å­˜ç©ºé—´ã€‚

å°†ä»¥ä¸‹ä»£ç ä½œä¸º alloc.c å•ç‹¬ä¿å­˜ï¼š

```c
#define ALLOCSIZE 10000 /* size of available space */

static char allocbuf[ALLOCSIZE]; /* storage for alloc */
static char *allocp = allocbuf;  /* next free position */

char *alloc(int n)    /* return pointer to n characters */
{
   if (allocbuf + ALLOCSIZE - allocp >= n) {  /* it fits */
       allocp += n;
       return allocp - n; /* old p */
   } else      /* not enough room */
       return 0;
}

void afree(char *p)  /* free storage pointed to by p */
{
   if (p >= allocbuf && p < allocbuf + ALLOCSIZE)
       allocp = p;
}
```

åœ¨ç¼–è¯‘å‘½ä»¤ä¸­æ·»åŠ ä¸Šè¿™ä¸ªæ–‡ä»¶ï¼Œå’Œä¸»ç¨‹åºä¸€å¹¶ç¼–è¯‘ï¼Œå³å®ƒä»¬æ˜¯ä¸¤ä¸ªå•ç‹¬çš„ç¼–è¯‘å•å…ƒï¼Œå…¨å±€ static å˜é‡æ‰ä¼šæ‰§è¡Œ **internal linkage**ã€‚å¦‚æœåœ¨ä¸»ç¨‹åºä¸­é€šè¿‡ `#include` å¼•ç”¨ alloc.cï¼Œ é‚£ä¹ˆ allocbuf å°±å¯ä»¥è¢«ä¸»ç¨‹åºç›´æ¥è®¿é—®ï¼š

    gcc -o main alloc.c main.c

é€šå¸¸ï¼ŒæŒ‡é’ˆå¯ä»¥åƒå…¶å®ƒå˜é‡ä¸€æ ·åˆå§‹åŒ–ï¼Œåªéœ€è¦ä¸€ä¸ªæœ‰æ•ˆçš„åœ°å€ï¼Œæˆ–è€…ä¸€ä¸ªé›¶å€¼è¡¨ç¤º NULL æŒ‡é’ˆã€‚

å°† allocp å®šä¹‰ä¸ºå­—ç¬¦æŒ‡é’ˆï¼Œå¹¶åˆå§‹åŒ–æŒ‡å‘æ•°ç»„ç©ºé—´çš„å¼€å§‹ä½ç½®ï¼Œä»¥ä¸‹ä¸¤ç§è¯­æ³•æ˜¯ç­‰ä»·çš„è¡¨è¾¾ï¼Œæ•°ç»„åå°±æ˜¯ç¬¬ä¸€ä¸ªå…ƒç´ çš„åœ°å€ï¼š

```c
static char *allocp = allocbuf;
static char *allocp = &allocbuf[0];
```

æ£€æŸ¥ç©ºé—´æ˜¯å¦è¶³å¤Ÿï¼Œåªéœ€è¦æ¯”è¾ƒä¸€ä¸‹æ•°ç»„æœ€å¤§åœ°å€åç§»ä¸å½“å‰ allocp åœ°å€çš„å·®å€¼æ˜¯å¦ä¸å°äºç”³è¯·å€¼ nï¼š

       if (allocbuf + ALLOCSIZE - allocp >= n) {  /* it fits */

å¦‚æœç©ºé—´ä¸è¶³ï¼Œå°±éœ€è¦è¿”å› 0 å€¼ï¼Œå³ NULL æŒ‡é’ˆï¼Œåœ¨ C è¯­è¨€ä¸­è¡¨ç¤ºä¸€ä¸ªæ— æ•ˆåœ°å€ï¼Œå¯ä»¥ç”¨å®ƒä½œä¸ºä¿¡å·è§¦å‘ç»ˆæ­¢äº‹ä»¶ã€‚è™½ç„¶ï¼Œåœ°å€ç”¨ä¸€ä¸ªæ­£æ•´æ•°è¡¨è¾¾ï¼Œä½†æ˜¯å®ƒå’Œæ•´æ•°æ˜¯ä¸å¯ä»¥ç›´æ¥äº’æ¢çš„ã€‚ä¾‹å¤–æ˜¯å¯ä»¥å°† 0 å€¼å¸¸é‡èµ‹ç»™ä¸€ä¸ªæŒ‡é’ˆï¼Œä¹Ÿå¯ä»¥å’Œä¸€ä¸ª 0 å€¼å¸¸é‡è¿›è¡Œæ¯”è¾ƒï¼Œå®šä¹‰åœ¨ `<stdio.h>` çš„ NULL å®å®šä¹‰å°±æ˜¯ç”¨æ¥è¡¨ç¤º 0 å€¼æŒ‡é’ˆçš„ã€‚

åœ¨ alloc å’Œ afree å‡½æ•°ä¸­çš„ä¸¤æ¡æ¯”è¾ƒè¯­å¥ä¸­ï¼Œå……åˆ†å±•ç¤ºäº†æŒ‡é’ˆå¯ä»¥å½“ä½œæ•´æ•°ä¸€æ ·è¿›è¡Œè¿ç®—ï¼Œè¿›è¡Œæ¯”è¾ƒï¼Œ==, !=, <, >= ç­‰ç­‰ï¼Œä½†æ˜¯è¿™éƒ½æ˜¯åœ¨ç‰¹å®šç¯å¢ƒä¸‹ï¼Œä¿è¯æŒ‡é’ˆåœ°å€çš„æœ‰æ•ˆå‰æä¸‹è¿›è¡Œçš„è¿ç®—ã€‚

æŒ‡é’ˆå¯ä»¥å’Œ 0 å€¼è¿›è¡Œæ¯”è¾ƒï¼Œåœ¨æœ‰æ•ˆåœ°å€è®¡ç®—ä¸­æ˜¯æœ‰æ„ä¹‰çš„ã€‚åœ¨è¿™é‡Œï¼Œå¦‚æœæŒ‡é’ˆæŒ‡å‘çš„æ˜¯ä¸åŒæ•°ç»„ï¼Œé‚£ä¹ˆè¿™äº›æ¯”è¾ƒå°±æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼Œä¼šè§¦å‘ä¸å¯çŸ¥çš„è¡Œä¸ºã€‚

å¦å¤–ï¼Œå°±æ˜¯æŒ‡é’ˆçš„åŠ å‡è¿ç®—ï¼Œè¿™ä¸æ˜¯ä¸€èˆ¬çš„åŠ å‡ï¼Œè€Œæ˜¯å’Œå…ƒç´ æ•°æ®ç±»å‹å¤§å°ç›¸å…³çš„åŠ å‡ã€‚åŠ  1 æˆ–å‡ 1 è¡¨ç¤ºåœ°å€åç§»ä¸€ä¸ªå…ƒç´ æ‰€å æ®çš„ç©ºé—´ï¼Œå¯¹äºå­—ç¬¦ç±»å‹ï¼Œå½“ç„¶å¯¹åº”çš„æ˜¯ä¸€ä¸ªå­—èŠ‚åç§»ï¼Œå¦‚æœæ˜¯ int æ•°ç»„ï¼Œé‚£ä¹ˆå°±æ˜¯ 4 ä¸ªå­—èŠ‚çš„åç§»ã€‚

ä»¥ä¸‹æ˜¯åŸºäºæŒ‡é’ˆè¿ç®—çš„ strlen å®ç°ï¼š 

```c
/* strlen:  return length of string s */
int strlen(char *s)
{
   char *p = s;

   while (*p != '\0')
       p++;
   return p - s;
}
```

C è¯­è¨€ä½¿ç”¨ Null-terminated é£æ ¼å­—ç¬¦ä¸²ï¼Œå³ç»“æŸä½ç½®æ°¸è¿œæ˜¯ä¸€ä¸ª '\0' å­—ç¬¦ï¼Œæ‰€ä»¥å­—ç¬¦ä¸²å¤„ç†å‡½æ•°éƒ½åŸºäºè¿™ä¸ªæ ‡å¿—ã€‚è¿™ä¸ªå­—ç¬¦ä¸²é•¿åº¦æµ‹è¯•å‡½æ•°å…ˆæ˜¯æ‰¾åˆ°è¿™ä¸ªç»“æŸæ ‡å¿—çš„åœ°å€ï¼Œå†å’Œå­—ç¬¦ä¸²çš„èµ·å§‹åœ°å€ç›¸å‡ï¼Œå·®å€¼å°±æ˜¯å­—ç¬¦ä¸²é•¿åº¦ã€‚

åœ¨æ ‡å‡†å¤´æ–‡ä»¶ `<stddef.h>` å®šä¹‰äº† ptrdiff_t ç±»å‹ï¼Œå®ƒå¯ä»¥æ­£ç¡®è¡¨ç¤ºä¸¤ä¸ªæŒ‡é’ˆè¿ç®—çš„å¸¦ç¬¦å·å€¼ã€‚ä½œä¸ºå­—ç¬¦ä¸²é•¿åº¦ï¼Œä½¿ç”¨æ— ç¬¦å·æ•´å½¢ size_t æ›´é€‚åˆï¼Œå’Œæ ‡å‡†å‡½æ•°ä½¿ç”¨çš„ç»Ÿä¸€çš„ç±»å‹ã€‚

æŒ‡é’ˆçš„ç®—æœ¯éœ€è¦ä¿æŒä¸€è‡´ï¼Œå¯¹æµ®ç‚¹æŒ‡é’ˆå’Œå­—ç¬¦æŒ‡é’ˆåŒæ ·çš„åŠ  1 è¡¨ç¤ºçš„åœ°å€åç§»æ˜¯ä¸åŒçš„ï¼Œå‰è€…è¡¨ç¤º 4 ä¸ªå­—èŠ‚ï¼Œåè€…åˆ™æ˜¯ 1 ä¸ªå­—èŠ‚ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨å¤„ç†å¥½ä¸€ä¸ªå…ƒç´ çš„åç§»ã€‚

ç›¸åŒç±»å‹çš„æŒ‡é’ˆå¯ä»¥èµ‹å€¼ï¼ŒåŠ å‡ä¸€ä¸ªæ•´æ•°ï¼Œæˆ–è€…æ¯”è¾ƒæ•°ç»„å…ƒç´ çš„åœ°å€ï¼Œè¿™äº›æ“ä½œéƒ½æ˜¯æœ‰æ„ä¹‰çš„ã€‚è€Œå¯¹æŒ‡é’ˆè¿›è¡Œä¹˜é™¤ï¼Œæˆ–è€…ç§»ä½ï¼Œæˆ–è€…åŠ å‡æµ®ç‚¹æ•°éƒ½æ˜¯æ— æ•ˆçš„ã€‚

æœ€åï¼Œå¯ä»¥å°† `void *` å³ NULL æŒ‡é’ˆèµ‹å€¼ç»™ä»»ä½•æŒ‡é’ˆï¼Œè€Œä¸éœ€è¦è¿›è¡Œç±»å‹è½¬æ¢ã€‚


### ===ğŸ‘‰ Pointer of a function

å°†å‡½æ•°åœ°å€èµ‹ç»™æŒ‡é’ˆå°±åƒå°†å˜é‡åœ°å€èµ‹å€¼ç»™æŒ‡é’ˆæ˜¯æ²¡æœ‰æœ¬è´¨å·®åˆ«çš„ï¼Œå°±æ˜¯é€šè¿‡æŒ‡é’ˆæ¥è·å¾—å†…å­˜åœ°å€ï¼Œå¹¶è¿›è¡Œç›¸åº”çš„æ“ä½œã€‚

ä½†æ˜¯ï¼ŒæŒ‡é’ˆå‡½æ•°çš„æŒ‡é’ˆåœ¨å®šä¹‰ä¸Šï¼Œè¯­æ³•ç»“æ„æ˜¾å¾—æ›´å¤æ‚ï¼Œå› ä¸ºå‡½æ•°ç­¾åæ¯”ä¸€ä¸ªå˜é‡åå¤æ‚ï¼š

```c
int *test(int a, int b); /* declaration a function that return a pointer of int */
int  (*fp1)(int a, int b);
int *(*fp2)(int a, int b);
```

ä»¥ä¸Šä»£ç ç‰‡æ–­æœ‰å‡ ç‚¹éœ€è¦è§£æä¸€ä¸‹ï¼š

- test ä½œä¸ºä¸€ä¸ªå‡½æ•°å£°æ˜ï¼Œè¡¨æ˜è¿™æ˜¯ä¸€ä¸ªè¿”å›æ•´å½¢æŒ‡é’ˆçš„å‡½æ•°ï¼Œå£°æ˜æ–¹å¼å¾ˆåƒå£°æ˜æ•´å½¢æŒ‡é’ˆ `int *`ï¼›
- fp1 ä½œä¸ºä¸€ä¸ªå‡½æ•°æŒ‡é’ˆå£°æ˜ï¼Œå¤šäº†ä¸€ä¸ªæ‹¬å·ï¼Œå¦‚æœä¸åœ¨ fp1 è¿™ä¸ªåå­—é‡Œä½¿ç”¨æ‹¬å·ä¼šå¦‚ä½•ï¼Ÿé‚£å°±æ˜¯åœ¨å£°æ˜å‡½æ•°ï¼Œè€Œä¸æ˜¯å‡½æ•°æŒ‡é’ˆäº†ã€‚
- fp2 å£°æ˜äº†ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œç›¸åº”çš„å‡½æ•°è¿”å›æ•´å½¢æŒ‡é’ˆï¼Œè¿™é‡Œå¯ä»¥å¾ˆæ•´ä¸ªå£°æ˜åˆ†æˆ 3 ä¸ªéƒ¨åˆ†ï¼Œé™¤äº†è¿”å›ç±»å‹ï¼Œå…¶å®ƒéƒ½ç”¨è´ºæ‹¬å·ï¼š `return-type (* name)(arguments list)`ã€‚

ä»¥ä¸Šæ˜¯ç®€å•çš„å‡½æ•°æŒ‡é’ˆå£°æ˜è¯­æ³•ï¼Œåœ¨ä½¿ç”¨ä¸­ï¼Œæ¯”å¦‚ï¼Œå£°æ˜ `fp` ä¸ºä¸€ä¸ª fp2 å‡½æ•°æŒ‡é’ˆï¼Œå¦‚æœç›´æ¥ä½¿ç”¨ä»¥ä¸Šçš„è¿™æ ·çš„ç±»å‹å£°æ˜è¯­æ³•è‚¯å®šæ˜¯éº»çƒ¦çš„ï¼Œè¿™æ—¶å¯ä»¥é€šè¿‡ `typedef` å¯ä»¥å°†å‡½æ•°æŒ‡é’ˆçš„å¤æ‚å£°æ˜è¿›è¡Œç®€å•ã€‚

è¯­æ³•å‚è€ƒå¦‚ä¸‹ï¼Œå¯ä»¥çœ‹åˆ°å’Œæ™®é€šç±»å‹åˆ«åçš„å£°æ˜æ ¼å¼æœ‰ç‚¹å·®åˆ«ï¼š

```c
typedef int *IntegerPointer;
typedef int *(*callback)(int, int);
```

å¯ä»¥å°è¯•ä½¿ç”¨ä»¥ä¸‹ç­‰ä»·æ–¹å¼å®šä¹‰å‡½æ•°æŒ‡é’ˆï¼Œç¼–è¯‘å™¨å¦‚æœæ”¯æŒè¿™æ ·çš„è¯­æ³•ï¼š

```c
// typedef int *(*ArithmeticFunP)(int, int);
typedef int *ArithmeticFun(int, int);
typedef ArithmeticFun *ArithmeticFunP;
```

ä»¥ä¸‹ç¤ºèŒƒå‡½æ•°æŒ‡é’ˆçš„ä½¿ç”¨ï¼š

```c
#include <stdio.h>
#include <stdlib.h>

/**
 * declaration of functions
 * - add is a function that return a pointer of int.
 * - call is a function that take a function as parameter.
 */
int *add(int a, int b); 
int call( int *(*func)(int a, int b) );
typedef int *(*ArithmeticFunP)(int, int);

int main()
{
    ArithmeticFunP cb = add;
    printf("add(1,2): %d", call(cb));
}

int call( int *(*func)(int a, int b) ){
    int *ip = func(1, 2);
    int value = *ip;
    free(ip);
    return value;
}
int * add(int a, int b){
    int *c = malloc(sizeof(int));
    *c = a + b;
    return c;
}
```

æ³¨æ„ï¼Œä¸èƒ½å°†å‡½æ•°æœ¬åœ°çš„æŒ‡é’ˆè¿”å›ç»™ä¸Šä¸€å±‚ä½¿ç”¨ï¼Œå› ä¸ºå‡½æ•°è¿”å›åï¼Œä¿å­˜åœ¨æ ˆå†…å­˜çš„æŒ‡é’ˆä¹Ÿä¼šè¢«å›æ”¶ã€‚

æ‰€ä»¥éœ€è¦ä½¿ç”¨åŠ¨æ€å†…å­˜åˆ†é…å‡½æ•° malloc ä» heap è·å–åŠ¨æ€åˆ†é…çš„å †å†…å­˜ï¼Œå¹¶ä¸”åœ¨ä½¿ç”¨å®Œåé€šè¿‡ free å°†å…¶åŠ¨æ€å†…å­˜é‡Šæ”¾ï¼Œä»…ä¸”æ‰§è¡Œä¸€æ¬¡é‡Šæ”¾åŠ¨ä½œã€‚

å†…å­˜é‡Šæ”¾åï¼Œå°±ä¸åº”è¯¥å†ä¾èµ–å®ƒæ¥è·å–æ•°æ®äº†ï¼Œæœ‰å¯ä»¥è·å–åˆ°æ­£ç¡®çš„æ•°æ®ï¼Œä½†è¿™ç»å¯¹æ˜¯å·§åˆï¼Œä¸å¯é çš„ã€‚

æŒ‡é’ˆé€šå¸¸éƒ½å’Œ stdlib.h å‡½æ•°åº“é…åˆä½¿ç”¨ï¼Œæ‰€ä»¥éœ€è¦æ·±å…¥åŠ¨æ€å†…å­˜çš„ç®¡ç†ã€‚


### ===ğŸ‘‰ Complicated Pointers
- https://en.cppreference.com/w/c/program/signal

The C Programming Language æä¾›äº†ä»¥ä¸‹è¿™äº›å¤æ‚çš„æŒ‡é’ˆå£°æ˜å‚è€ƒï¼Œè¿˜ç»™å‡ºç¼–è¯‘å™¨çš„è¯æ³•åˆ†æçš„å‚è€ƒï¼š

```c
char **argv
  // argv:  pointer to char
int (*daytab)[13]
  // daytab:  pointer to array[13] of int
int *daytab[13]
  // daytab:  array[13] of pointer to int
void *comp()
  // comp: function returning pointer to void
void (*comp)()
  // comp: pointer to function returning void
```

å…¶å®ƒç¨ä¸ºå¤æ‚çš„ä¸€äº›æŒ‡é’ˆå®šä¹‰ï¼š

```c
int *(*x)[4]
  // x: Pointer to int *[4]
char (*(*x())[])()
  // x: function returning pointer to array[] of
  // pointer to function returning char
char (*(*x[3])())[5]
  // x: array[3] of pointer to function returning
  // pointer to array[5] of char
```

ä»¥ä¸Šä¸‰ä¸ªæŒ‡é’ˆå®šä¹‰å°±æœ‰ä¸€å®šå¤æ‚åº¦äº†ã€‚

é¦–å…ˆï¼Œç¬¬ä¸€ä¾‹æŒ‰æ‹¬å·ä¼˜å…ˆå¤„ç†ï¼Œå†…æ‹¬å·ä½œä¸ºä¸€ä¸ªæ•´ä½“ `*x` è¡¨ç¤ºä¸€ä¸ªæŒ‡é’ˆï¼Œè€ŒæŒ‡é’ˆæ‰€æŒ‡å‘çš„çš„ç±»å‹æ˜¯ `int*()[4]`ã€‚

ç¬¬äºŒä¾‹ï¼Œä¼˜å…ˆåˆ†è§£ `*x()` è¡¨æ˜ x æ˜¯å‡½æ•°çš„è¿”å›å€¼ï¼Œè¿™ä¸ªå‡½æ•°å‚æ•°åˆ—è¡¨ä¸ºç©ºï¼Œç„¶å `*(*x())[]` è¡¨æ˜è¿”å›çš„ç±»å‹æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘ä¸€ä¸ªæ•°ç»„ã€‚å¹¶ä¸”ï¼Œæ•°ç»„çš„å…ƒç´ ä¹Ÿæ˜¯å‡½æ•°ï¼Œå‡½æ•°è¿”å›å€¼ä¸º charï¼Œå‚æ•°åˆ—è¡¨ä¸ºç©ºï¼Œå³æœ€åä¸€å¯¹åœ†æ‹¬å·ã€‚

ç¬¬ä¸‰ä¾‹ï¼ŒåŒæ ·ä¼˜å…ˆåˆ†è§£åœ†æ‹¬å·å†…çš„éƒ¨åˆ†ï¼Œ`*x[3]` è¡¨æ˜ x æ˜¯ä¸€ä¸ªæ•°ç»„ï¼ŒåŒ…å« 3 ä¸ªå…ƒç´ ä¸ºæŒ‡é’ˆï¼Œ`*(*P)()` è¡¨æ˜æŒ‡é’ˆæŒ‡å‘å‡½æ•°ï¼Œå‚æ•°åˆ—è¡¨ä¸ºç©ºï¼Œç„¶å `char (*F)[5]` è¡¨æ˜å‡½æ•°è¿”å›å€¼æ˜¯å­—æ•°ç»„ `char a[5]`ï¼Œè¿™é‡Œé€æ­¥ä½¿ç”¨ç¬¦å·æ›¿ä»£æ³•ä¹Ÿæ˜¯ä¸é”™çš„ç®€åŒ–æ–¹æ³•ã€‚


ä½¿ç”¨ typedef åŒ–ç®€æ˜¯éå¸¸å¥½çš„æ–¹æ³•ï¼Œå¦å¤–ï¼ŒæŒæ¡æ“ä½œç¬¦ä¼˜å…ˆçº§ä¹Ÿæ˜¯é‡è¦çš„ï¼Œ`() --> [] --> *`ï¼Œä¾‹å¦‚ä»¥ä¸‹è¿™ä¸ªä¾‹å­ï¼š

```c
// int *(*(*fp)(int(*)(int, int), int(*)(int)))(int, int, int(*)(int, int))[10];
typedef int (*A)(int, int);
typedef int (*B)(int);
typedef int *(*(*C)(A, B))(int, int, A)[10];
```

C99 è§„èŒƒå°±æœ‰è®¸å¤šéå¸¸å¥½çš„ä¾‹å­ï¼š

```c
// Standard Library `<stdlib.h>`
int atexit( void (*func)(void) );

// Signal handling <signal.h>
void (*signal(int sig, void (*func)(int)))(int);
```

å…¶ä¸­ atexit è¿˜ä¸é”™å¤ªå¤æ‚ï¼Œå®ƒæœ¬èº«æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œåªéœ€è¦å°†åœ†æ‹¬å·å†…çš„éƒ¨åˆ†ç”¨ X å‚æ•°æ›¿æ¢ï¼Œç»“æ„å°±å¾ˆç®€å•ã€‚ç„¶åæ‹¬å·å†…è¢«æ›¿æ¢çš„è¿™éƒ¨åˆ† `void (*func)(void)` æœ¬èº«å°±æ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œå®ƒæ²¡æœ‰è¿”å›å€¼ï¼Œæ²¡æœ‰å‚æ•°è¾“å…¥ã€‚

çœ‹åˆ°è¿™ä¸ª signal å‡½æ•°æŒ‡é’ˆï¼Œå®ƒå°±éå¸¸å¤æ‚äº†ï¼Œå‚æ•°ä¸­åˆåµŒå¥—äº†å‡½æ•°æŒ‡é’ˆã€‚

åŒæ ·ï¼Œä¹ŸæŒ‰æ‹¬å·ä¼˜å…ˆçº§è¿›è¡Œåˆ†è§£ï¼Œå¯ä»¥å‚è€ƒä½¿ç”¨ typedef ç®€åŒ–å½¢å¼ï¼š

```c
// void (*signal(int, void (*)(int)))(int);
typedef void fv(int), (*pfv)(int);
fv *signal(int, fv *); // style A
pfv signal(int, pfv);  // style B
```

è¿™ä¸ªå‡½æ•°çš„å®šä¹‰çš„éš¾ç‚¹åœ¨äºæ‹¬å·å†…çš„ `*signal(int, void (*)(int))`ï¼Œå¾ˆæ˜æ˜¾ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆ `void (*func)(int)`ã€‚æŒ‰æ“ä½œç¬¦å·ä¼˜å…ˆçº§ï¼Œåœ†æ‹¬å·ä¼˜å…ˆäº * æ“ä½œç¬¦å·ã€‚æ‰€ä»¥ signal æœ¬èº«å°±æ˜¯ä¸€ä¸ªå‡½æ•°çš„è¿”å›å€¼ï¼Œè¿™ä¸ªå‡½æ•°æš‚ä¸”å‘½åä¸º Aï¼Œå®ƒæ¥æ”¶ä¸¤ä¸ªå‚æ•° `int` å’Œå‡½æ•°æŒ‡é’ˆ `void (*func)(int))`ã€‚

æœ€åï¼Œå‡½æ•°è¿”å›çš„ signal è¿™ä¸ªå€¼æœ¬èº«åˆæ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œè¿™æ—¶ï¼Œå°†åœ†æ‹¬å·å†…çš„å‡½æ•°å®šä¹‰å»æ‰å°±å¯ä»¥çœ‹åˆ° `void (*signal)(int)`ï¼Œå®ƒå°±æ˜¯åœ†æ‹¬å·å†…é‚£ä¸ª A å‡½æ•°è¿”å›çš„å‡½æ•°æŒ‡é’ˆå®šä¹‰ã€‚

è¿™ç§ä¼ å…¥å‚æ•°å’Œè¿”å›å€¼éƒ½æ˜¯å‡½æ•°æŒ‡é’ˆçš„è¯­æ³•å·²ç»ç®—æ˜¯åäººç±»äº†ï¼Œå¦‚æœæœ‰æ›´éš¾çš„ï¼Œå»ºè®®è¿˜æ˜¯ä¸è¦å­¦äº†ã€‚

æŒ‡é’ˆå¯ä»¥ä»»æ„å¤šå±‚çº§å¥—ç”¨ï¼Œé€šå¸¸ï¼Œä¸€æ˜Ÿã€äºŒæ˜Ÿç¨‹åºæ˜¯å¸¸è§çš„ï¼Œå¦‚æœç”¨ä¸Š 3 æ˜Ÿå°±å°‘è§äº†ï¼Œç”¨ä¸Š 4 æ˜Ÿé‚£å¯è°“å¥‡è‘©ï¼Œç”¨ä¸Š 5 æ˜Ÿé‚£ç»å¯¹æ˜¯æ¶æã€‚

å¯ä»¥å‚è€ƒï¼š

- å‰æ¡¥å’Œå¼¥ï¼ˆMaebasi Kazuyaï¼‰ã€Šå¾æœCæŒ‡é’ˆã€‹ä¸€ä¹¦ï¼Œ3.5.6 æŒ‘æˆ˜é‚£äº›å¤æ‚çš„å£°æ˜ã€‚
- Pointers in C A Hands on Approach by Naveen Toppo, Hrishikesh Dewan

```c
#include <signal.h>
#include <stdio.h>
 
volatile sig_atomic_t gSignalStatus;
 
void signal_handler(int signal)
{
  gSignalStatus = signal;
}
 
int main(void)
{
  signal(SIGINT, signal_handler);
 
  printf("SignalValue: %d\n", gSignalStatus);
  printf("Sending signal: %d\n", SIGINT);
  raise(SIGINT);
  printf("SignalValue: %d\n", gSignalStatus);
}
```


## ==âš¡ ch6 - Structures

è¿™ç« ä¸»é¢˜ä¸ºç»“æ„ä¼‘ï¼Œä½†æ˜¯åŒ…æ‹¬ Structures, Unions, Bit-Fields ç­‰å†…å®¹ï¼Œå…¶å®è¿™äº›ç±»å‹éƒ½å¯ä»¥ç®—æ˜¯ä¸€ç§ç»“æ„åŒ–æ•°æ®ç±»å‹ï¼Œå°†ä¸åŒçš„ç±»å‹ç»„åˆåˆ°ä¸€èµ·ã€‚

è”åˆä½“ union å…è®¸åœ¨åŒä¸€å†…å­˜åœ°å€ä¸Šå­˜å–ä¸åŒçš„ç±»å‹ï¼Œå°†å„ç§ç±»å‹å®šä¹‰åœ¨è”åˆä½“ä¸­å°±æ˜¯å®ç°è¿™æ ·ä¸€ä¸ªåŠŸèƒ½çš„ã€‚

ä»¥ä¸‹ç¤ºèŒƒä½¿ç”¨ union ç±»å‹ï¼š

```c
// declares an union number type
union number {
    long n; 
    double x;
};

// declares an array nx with ten elements of type union number.
union number  nx[10];

nx[0].x = 1.234;   // Assign a double value to nx[0] 

// declares an union number with initializer list.
union number length = { 100L };
```

å’Œç»“æ„ä½“ä¸€æ ·ï¼Œè”åˆç±»å‹åˆå§‹åŒ–å¯ä»¥æŒ‡å®šä¸€ä¸ªåˆ—è¡¨ï¼Œå¦‚æœæ²¡æœ‰æŒ‡å®šæˆå‘˜åç§°ï¼Œåˆ™åˆå§‹åŒ–ç¬¬ä¸€ä¸ªè”åˆä½“æˆå‘˜ã€‚


ä½åŸŸ Bit-fieldsï¼Œå®šä¹‰å’Œç»“æ„ä½“æˆ–è”åˆä½“ç±»ä¼¼ï¼Œå®ƒä»¬éƒ½å¯ä»¥å®šä¹‰ä¸ºä½åŸŸï¼Œç»™æˆå‘˜è®¾å®š bit å®½åº¦ï¼Œæˆå‘˜å®šä¹‰è¯­æ³•ï¼š

    type    [identifier] : width;

å¯ä»¥æ˜¯ unsigned int æˆ– signed int è¿™æ ·çš„ç±»å‹, æ ‡è¯† identifier æ˜¯å¯é€‰çš„ï¼Œæ¯”ç‰¹å®½åº¦ width å¿…éœ€æŒ‡å®šä¸€ä¸ªä¸è¶…è¿‡ç±»å‹çš„å®½åº¦çš„å€¼ï¼Œå¦‚ char ç±»å‹æœ€å¤§å®½åº¦åªæœ‰ 8-bitã€‚å¹¶ä¸”ï¼Œå®½åº¦ä¸èƒ½è¶…è¿‡ machine wordï¼Œå³æœºå™¨çš„ä¸€æ¬¡å¯å¤„ç†çš„æ¯”ç‰¹ä½å®½åº¦ï¼Œç°ä»£çš„æœºå™¨é€šå¸¸æ˜¯ 32-bit æˆ– 64-bitã€‚

å¦‚æœï¼Œä¸Šä¸€ä¸ªå­—æ®µç•™æœ‰è¶³å¤Ÿçš„æ¯”ç‰¹ä½ï¼Œé‚£ä¹ˆå°±ä¼šå°†ä¸‹ä¸€ä¸ªå­—æ®µä¸ä¸Šä¸€ä¸ªå­—æ®µæ‰“åŒ…åœ¨ä¸€èµ·ã€‚

å¦‚æœï¼Œå®½åº¦ä¸º 0ï¼Œè¿™æ˜¯ç‰¹ä¾‹ï¼Œç”¨æ¥åšåˆ†éš”ï¼Œè¡¨ç¤ºä¸‹ä¸€ä¸ªä½åŸŸå°†æ‰“åŒ…åˆ°æ–°çš„å­˜å‚¨å•å…ƒä¸­ã€‚

ä½åŸŸä½¿ç”¨ç¤ºèŒƒï¼š

```c
struct {
    unsigned int   b0_2 : 3;
    signed   char  b3_7 : 5;
    unsigned char       : 7;
    unsigned char  b15  : 1;
} var;

var.b0_2 = 7;
var.b3_7 = 3;
printf("%d", var.b15);
```

å¯¹æ¯”ç”Ÿæˆçš„æ±‡ç¼–ä»£ç å¯èƒ½ä¼šæ›´æ¸…æ™°ç¼–è¯‘å™¨æ˜¯å¤„ç†å¤„ç†ä½åŸŸçš„ï¼Œé€šå¸¸éœ€è¦ä½¿ç”¨æ¯”ç‰¹ä½è¿ç®—ã€‚

ä½¿ç”¨ IDA ç­‰é€†å‘å·¥å…·æŸ¥çœ‹æ±‡ç¼–ä»£ç ï¼Œæˆ–è€…ç›´æ¥ä½¿ç”¨ç¼–è¯‘å™¨ç”Ÿæˆæ±‡ç¼–ä»£ç  `gcc -c -S demo.c`ã€‚

```sh
.text:0040163E movzx   eax, ds:_var._bf_0                         # movzbl  _var, %eax
.text:00401645 or      eax, 7                                     # orl $7, %eax
.text:00401648 mov     ds:_var._bf_0, al                          # movb    %al, _var
.text:0040164D movzx   eax, byte ptr ds:_var._bf_4                # movzbl  _var+4, %eax
.text:00401654 and     eax, 0FFFFFFE0h                            # andl    $-32, %eax
.text:00401657 or      eax, 3                                     # orl $3, %eax
.text:0040165A mov     byte ptr ds:_var._bf_4, al                 # movb    %al, _var+4
.text:0040165F movzx   eax, byte ptr ds:_var._bf_4+1              # movzbl  _var+5, %eax
.text:00401666 shr     al, 7                                      # shrb    $7, %al
.text:00401669 movzx   eax, al                                    # movzbl  %al, %eax
.text:0040166C mov     [esp+4], eax                               # movl    %eax, 4(%esp)
.text:00401670 mov     dword ptr [esp], offset Format ; "%d"      # movl    $LC0, (%esp)
.text:00401677 call    _printf                                    # call    _printf                                                            
```

ç”±äºç¬¬ 1 ä¸ªå­—æ®µå’Œç¬¬ 2 ä¸ªä½¿ç”¨äº†ä¸åŒçš„æ•°æ®ç±»å‹ï¼Œæ‰€ä»¥åœ¨å†…å­˜ä¸­æŒ‰æ’äº†ä¸åŒçš„å­˜å‚¨å•å…ƒï¼Œä½†æ˜¯è¿ç»­çš„ï¼Œb0_2 åœ¨ä¸€ä¸ª 4 å­—èŠ‚çš„ç©ºé—´ï¼Œè€Œ b3_7 åœ¨ç´§æ¥åé¢çš„ä¸€ä¸ªå­—èŠ‚ç©ºé—´ã€‚

è¿˜å¯ä»¥ä»æ±‡ç¼–ä»£ç çœ‹åˆ°ï¼Œç¬¬ 3 å’Œç¬¬ 4 ä¸ªå­—æ®µåˆšå¥½ 8-bit æ•´åˆåœ¨ä¸€èµ·ï¼Œé€šè¿‡ shr ç®—æœ¯å³ç§»ä½æŒ‡ä»¤å°±å¯ä»¥å–å‡ºæœ€é«˜çš„æ¯”ç‰¹ä½ã€‚

Bit-fields å’Œæ™®é€šæ•´å½¢æ•°æ®çš„å·®å¼‚ï¼š 

- ä¸å¯ä»¥å¯¹ä½åŸŸå–åœ°å€æ“ä½œï¼Œä½† & æ“ä½œç¬¦å·å¯ä»¥å¯¹åŒ…å«ä½åŸŸçš„ç»“æ„ä½“æˆ–å˜é‡æ“ä½œã€‚
- ç”±äºä½åŸŸå’Œæœºå™¨å­—ç›¸å…³ï¼Œæ‰€ä»¥ä¼šé™ä½å¯ç§»æ¤æ€§ï¼Œå› ä¸ºæœºå™¨å­—çš„æ¯”ç‰¹ä½è§£é‡Šåœ¨ä¸åŒçš„æœºå™¨ä¹‹é—´å¯èƒ½ä¸åŒã€‚


### ===ğŸ‘‰ struct & typedef

æœ€å¸¸ç”¨çš„ç»“æ„åŒ–æ•°æ®ç±»å‹è¿˜æ˜¯ç»“æ„ä½“ï¼Œä½¿ç”¨å…³é”®å­— `struct` å®šä¹‰ç»“æ„ä½“ï¼Œå®ƒå¯ä»¥å°†ä¸åŒçš„ç±»å‹æ•´åˆåˆ°ä¸€èµ·ï¼Œä½œä¸ºä¸€ä¸ªæˆå‘˜å®šä¹‰ï¼Œè®¿é—®å®ƒä»¬å°±åƒä½¿ç”¨æ™®é€šå˜é‡ä¸€æ ·ã€‚ç»“æ„ä½“çš„æˆå‘˜å±æ€§åŒ…æ‹¬æ•°æ®ç±»å‹ã€åç§°å’Œå€¼ï¼Œå¦å¤–ï¼Œæˆå‘˜å®šä¹‰çš„å…ˆåé¡ºåºä¹Ÿæ˜¯ä¸€ç§éšå«çš„å±æ€§ã€‚

ä½¿ç”¨ç»“æ„ä½“çš„è¿™ç§æ•°æ®æ•´åˆèƒ½åŠ›ï¼Œå¯ä»¥å¤§å¤§ç®€åŒ–ç¨‹åºç»“æ„ï¼Œç®€æ´çš„ä»£ç å¯ä»¥æ›´æ¸…æ™°åœ°è¡¨è¾¾é€»è¾‘ç»“æ„ã€‚

ç¤ºèŒƒç»“æ„ä½“çš„å®šä¹‰ä¸ä½¿ç”¨ï¼š

```c
struct article {
    char   name[40];
    int    quantity;
    double price;
} anArticle = {"ğŸŒwide", 1, 0};

anArticle.name = "Hello";
```

ä¸Šé¢çš„ä»£ç ç‰‡æ–­æ¼”ç¤ºäº† article ç»“æ„ä½“çš„å®šä¹‰ï¼Œå¹¶ä¸”å£°æ˜äº†ä¸€ä¸ªå˜é‡ anArticleï¼Œä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨å¯¹åº”è®¾ç½®å„æˆå‘˜çš„å€¼ã€‚

ç»“æ„ä½“æˆå‘˜çš„è®¿é—®ä½¿ç”¨å¥ç‚¹ï¼Œå³æˆå‘˜æ“ä½œç¬¦å·å¼•ç”¨ï¼Œå¦‚æœæ˜¯é€šè¿‡ç»“æ„ä½“æŒ‡é’ˆè®¿é—®ï¼Œåˆ™éœ€è¦å…ˆè§£å¼•ç”¨ï¼Œä¾‹å¦‚ `(*p).field`ï¼Œå› ä¸ºæˆå‘˜æ“ä½œç¬¦å·ä¼˜å…ˆäºè§£å¼•ç”¨ç¬¦å·ï¼Œæ‰€ä»¥éœ€è¦ä½¿ç”¨åœ†æ‹¬å·ï¼Œä¸ºäº†é¿å…ä½¿ç”¨ç¹æ‚çš„è¯­æ³•ï¼ŒC è¯­è¨€åˆå®šä¹‰äº†ä¸€ä¸ªç¨ä¸ºç®€å•ä¸€ç‚¹çš„ `->` ç¬¦å·ï¼Œè¿™æ ·å°±å¯ä»¥è¡¨è¾¾ä¸º `p->filed`ã€‚

åœ¨ C è¯­è¨€ä¸­ï¼Œè‡ªå¼•ç”¨ç»“æ„ä½“éœ€è¦é€šè¿‡æŒ‡é’ˆæ¥å®ç°ï¼Œå› ä¸ºæŒ‡é’ˆé•¿åº¦å›ºå®šï¼Œç¼–è¯‘æœŸå°±ç¡®å®šã€‚ä¸é€šè¿‡æŒ‡é’ˆæ— æ³•å®ç°åµŒå¥—ç»“æ„ï¼Œä½†å¯ä»¥åµŒå¥—å…¶å®ƒç»“æ„ä½“ã€‚

åœ¨å®šä¹‰ç»“æ„ä½“æˆ–è”åˆä½“æ—¶ï¼Œå®è·µä¸­é€šå¸¸å’Œ typedef ä¸€èµ·ä½¿ç”¨ï¼Œè¿™æ ·æ–¹ä¾¿å®šä¹‰ç»“æ„ä½“ç±»å‹çš„å˜é‡ã€‚ä½†æ˜¯ï¼Œè‡³ä»Šæˆ‘ä»è®°å¾—ç»“æ„ä½“å®šä¹‰ä¸ typedef å…³é”®å­—ä½¿ç”¨æ—¶å‡ºç°çš„æ··ä¹±çŠ¶æ€ï¼Œè®©æˆ‘æ¯•ç”Ÿéš¾å¿˜ã€‚æ€»å¾—æ¥è¯´ï¼Œå®šä¹‰ä¸€ä¸ªç»“æ„ä½“ç±»å‹å’Œå®ä¾‹åŒ–ç»“æ„ä½“å¯¹è±¡ï¼Œå®ƒä»¬æœ‰éƒ¨åˆ†è¯­æ³•ç»“æ„ä¼šå› ä¸º typedef å…³é”®å­—çš„ä½¿ç”¨è€Œå‡ºç°é‡å ï¼Œè¿™ä¹Ÿæ˜¯æ··ä¹±çš„ä¸»è¦æ¥æºã€‚

å‡è®¾è¦å®šä¹‰ä¸€ä¸ª ByteChunk ç»“æ„ä½“ï¼Œä»¥åŠå…¶å®ä½“å˜é‡ byteChunkï¼Œå„ç§å½¢å¼å¦‚ä¸‹ï¼Œå½“ç„¶è¿˜å¯ä»¥ä½¿ç”¨èŠ±æ‹¬å·å¯¹å®ä¾‹è¿›è¡Œåˆå§‹åŒ–ï¼š

```cpp
// typedef-free style
struct ByteChunk        { /* some filds */};
struct ByteChunk        { /* some filds */} byteChunk;
struct ByteChunk byteChunk;

// typedef style
typedef struct          { /* some filds */} ByteChunk;
typedef struct _ByteChunk { /* some filds */} ByteChunk;
typedef struct _ByteChunk ByteChunk;
ByteChunk byteChunk;
```

åƒä»¥ä¸‹è¿™æ ·ï¼ŒTreenode å°±æ˜¯ä¸€ç§ç»“æ„ä½“ç±»å‹ï¼Œè€Œä¸åƒå‰é¢å£°æ˜ç»“æ„ä½“ç´§æ¥ç€å£°æ˜ç»“æ„ä½“å˜é‡ï¼š

```c
typedef struct tnode *Treeptr;

typedef struct tnode { /* the tree node: */
   char *word;           /* points to the text */
   int count;            /* number of occurrences */
   struct tnode *left;   /* left child */
   struct tnode *right;  /* right child */
} Treenode;

Treenode node;
```

ç¤ºèŒƒï¼Œå¹³é¢åæ ‡ç‚¹ä¸ç‚¹çš„è·ç¦»è®¡ç®—ï¼š

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// use typedef keyword to define a new type
// or else you will use "struct point p" instead of "Point p"
typedef struct point Point;

struct point {
    int x;
    int y;
    Point (*add)(Point, Point);
    Point (*trace)(Point, char *fmt);
    double (*distance)(Point, Point);
} p0 = {9,9}; /* an instance definition for shortcut.*/

/*prototype declaration*/
Point add(Point, Point);
Point trace(Point, char *fmt);
double distance(Point, Point);
Point newPoint(int x, int y);

int main(void)
{
    // Point p1 = {0,0, add, distance};
    Point p1 = newPoint(0, 0);
    Point p2 = newPoint(3, 4);
    p1.trace(p1, "1st point (%d,%d).\n");
    p2.trace(p2, "2nd point (%d,%d).\n");
    printf("distance between them:%d.\n", (int)p1.distance(p1, p2));
    p2 = p2.add(p2, p1);
    printf("add p1 to p2: (%d, %d).\n\n", p2.x, p2.y);
    free(&p1);
    free(&p2);
    return 0;
}

Point newPoint(int x, int y){
    Point * pp = malloc(sizeof(Point));
    pp->x = x;
    pp->y = y;
    pp->add = add;
    pp->trace = trace;
    pp->distance = distance;
    return *pp;
}
Point add(Point a, Point b){
    a.x += b.x;
    a.y += b.y;
    return a;
}
Point trace(Point a, char * fmt){
    printf(fmt, a.x, a.y);
    return a;
}
double distance(Point a, Point b){
    return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));
}
```

ä»¥ä¸Šæ¨¡ä»¿äº† C++ ç±»å‹æˆå‘˜æ–¹æ³•ï¼Œä¸ºç»“æ„ä½“å®šä¹‰äº†å¤šä¸ªå‡½æ•°æŒ‡é’ˆï¼Œå¹¶å¯ä»¥é€šè¿‡ç»“æ„ä½“å®ä¾‹æ¥è°ƒç”¨å®ƒã€‚ä½†æ˜¯ï¼Œåœ¨ C++ ä¸­ï¼Œç±»å¯¹è±¡è°ƒç”¨æ–¹æ³•æ—¶ï¼Œä¼šè‡ªåŠ¨å°†å½“å‰å¯¹è±¡çš„ this æŒ‡é’ˆä¼ å…¥æ–¹æ³•ï¼Œè€Œä¸æ˜¯åƒä»¥ä¸Šä»£ç è¿™æ ·æ‰‹åŠ¨ä¼ å…¥ã€‚

å¦å¤–ï¼Œè™½ç„¶ free é‡Šæ”¾çš„å†…å­˜ç¡®å®æ˜¯ heap å†…å­˜ï¼Œä½†æ˜¯ GCC è¿˜æ˜¯ç»™å‡ºäº†è­¦å‘Šã€‚å› ä¸ºåˆ†é…å†…å­˜åï¼ŒæŒ‡é’ˆç»è¿‡äº†è½¬æ¢ï¼Œå¦‚æœæ˜¯ malloc å‡½æ•°ç›´æ¥è¿”å›çš„æŒ‡é’ˆåˆ™ä¸ä¼šæœ‰è¿™æ ·çš„è­¦å‘Šï¼š

    warning: attempt to free a non-heap object 'p2' [-Wfree-nonheap-object]

æ³¨æ„ï¼šç»“æ„ä½“å˜é‡ä½œä¸ºå‚æ•°ä¼ é€’æ—¶ï¼Œå¦‚æœæŒ‰å€¼ä¼ é€’å°†éœ€è¦å¤åˆ¶å…¨éƒ¨æˆå‘˜ï¼ŒæŒ‡ä»¤ä¼šå°†æˆå‘˜å€¼ä¸€ä¸ªå‹æ ˆä¼ é€’ï¼Œè´¹æ—¶é—´åˆè´¹ç©ºé—´ï¼Œå¼€é”€å¤§ã€‚å¦‚æœç»“æ„ä½“ç±»å‹ä¸­çš„æˆå‘˜å¾ˆå¤šï¼Œæˆ–æœ‰ä¸€äº›æˆå‘˜æ˜¯æ•°ç»„ï¼Œåˆ™ç¨‹åºè¿è¡Œæ•ˆç‡ä¼šå¤§å¤§é™ä½ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç”¨æŒ‡é’ˆåšå‡½æ•°å‚æ•°æ¯”è¾ƒå¥½ï¼Œèƒ½æé«˜è¿è¡Œæ•ˆç‡ã€‚

ä¼ é€’ç»“æ„ä½“å˜é‡æ—¶ï¼Œéœ€è¦è€ƒè™‘æ€§èƒ½ï¼Œé€‰æ‹©åˆé€‚çš„ä¼ å‚æ–¹å¼ï¼Œå¦‚æœå¯èƒ½å°½é‡ä¼ é€’ç»“æ„ä½“æˆ–å…¶æˆå‘˜çš„æŒ‡é’ˆï¼Œä»¥å®ç°é«˜æ•ˆç‡ã€‚

ä½†æ˜¯ï¼Œä¸å¾—ä¸è€ƒè™‘æµ…æ‹·è´é—®é¢˜ï¼ŒShadow copy è¿™æ˜¯ç¼–è¯‘å™¨å¯ä»¥å®ç°çš„æ‹·è´ã€‚å¦‚æœç»“æ„ä½“æˆå‘˜å­˜åœ¨æŒ‡é’ˆå¼•ç”¨å…¶å®ƒæ•°æ®å˜é‡æ—¶ï¼Œåˆ™éœ€è¦è¿›è¡Œæ·±å±‚æ‹·è´ Deep copyã€‚

C è¯­è¨€ä¸­çš„æµ…æ‹·è´æ˜¯æŒ‡åœ¨æ‹·è´è¿‡ç¨‹ä¸­ï¼Œå¯¹äºæŒ‡é’ˆå‹æˆå‘˜å˜é‡åªæ‹·è´æŒ‡é’ˆæœ¬èº«ï¼Œè€Œä¸æ‹·è´æŒ‡é’ˆæ‰€æŒ‡å‘çš„ç›®æ ‡ï¼Œå®ƒæŒ‰å­—èŠ‚å¤åˆ¶çš„ã€‚

ç¼–è¯‘æä¾›çš„æµ…å±‚æ‹·è´ä¼šå°†æŒ‡é’ˆå¤åˆ¶ä¸€ä»½åˆ°å¦å¤–çš„å†…å­˜ç©ºé—´ï¼Œä½†æ˜¯å®ƒè¿˜æ˜¯æŒ‡å‘ç›¸åŒçš„åœ°å€ï¼Œæ‰€ä»¥ç»“æ„ä½“å¤åˆ¶åï¼Œå°†æœ‰å¤šä¸ªæŒ‡é’ˆæŒ‡å‘åŒä¸€ä½ç½®çš„æ•°æ®ã€‚


### ===ğŸ‘‰ struct & binary tree

The C Programming Language å±•ç¤ºäº†é€šè¿‡ä¸€ä¸ªäºŒå‰æ ‘ç»“æ„ç”¨äºå•è¯çš„ç»Ÿè®¡ï¼Œç»“æ„ç¤ºæ„å¦‚ä¸‹ï¼š

            Root
            clay(4)       <-- Level 0
         â”Œâ”€â”€â”€â”´â”€â”€â”€â”      
       app(2)  dog(5)     <-- Level 1
       â”Œâ”€â”´â”€    â”Œâ”€â”´â”€â”€â”    
     ab(1)   cd(1) egg(1) <-- Level 2

ä»£ç å¦‚ä¸‹ï¼Œä¸»è¦æ˜¯ tnode è¿™ä¸ªç»“æ„ä½“ä»¥ä¸‹èŠ‚ç‚¹æ·»åŠ æ–¹æ³• addtreeï¼Œå®ƒéœ€è¦å¯¹äºŒå‰æ ‘ä¸Šçš„èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœèŠ‚ç‚¹ä¸Šçš„å•è¯æ¯”å½“å‰çš„è¾“å…¥çš„å¤§ï¼Œå°±åœ¨å·¦ä¾§æ·»åŠ å­èŠ‚ç‚¹ï¼Œå¦åˆ™åœ¨å³ä¾§æ·»åŠ å­èŠ‚ç‚¹ã€‚

ä¹Ÿå°±æ˜¯è¯´ï¼Œåªå®ç°äº†äºŒå‰æ ‘èŠ‚ç‚¹æ’å…¥ï¼Œæ²¡æœ‰å®ç°èŠ‚ç‚¹åˆ é™¤ã€æ ‘çš„èŠ‚ç‚¹é‡æ–°å¹³è¡¡ç­‰æ–¹æ³•ã€‚

```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

typedef struct tnode *Treeptr;

typedef struct tnode { /* the tree node: */
   char *word;         /* points to the text */
   int count;          /* number of occurrences */
   Treeptr left;       /* left child */
   Treeptr right;      /* right child */
} Treenode;

#define MAXWORD 100
#define ScanWidth(width) ScanWidthEx(width)
#define ScanWidthEx(width) ("%" #width "s")

Treeptr addtree(Treeptr , char *);
void treeprint(Treeptr );
int getword(char *, int);
Treeptr talloc(void);

/* word frequency count */
int main()
{
    Treeptr root;
    char word[MAXWORD] = {};
    root = NULL;
    int len = 0;
    while ((len = getword(word, MAXWORD)) != EOF){
        printf("word %d:%s\n", len, word);
        if (isalpha(word[0]))
            root = addtree(root, word);
    }
    treeprint(root);
    return 0;
}

int getword(char *buf, int n){
    return scanf(ScanWidth(MAXWORD), buf); // scanf_s for C11
}

/* talloc:  make a tnode */
Treeptr talloc(void)
{
    return (Treeptr ) malloc(sizeof(struct tnode));
}

/* addtree:  add a node with w, at or below p */
Treeptr addtree(Treeptr p, char *w)
{
    int cond;

    if (p == NULL) {     /* a new word has arrived */
        p = talloc();    /* make a new node */
        p->word = strdup(w);
        p->count = 1;
        p->left = p->right = NULL;
    } else if ((cond = strcmp(w, p->word)) == 0)
        p->count++;      /* repeated word */
    else if (cond < 0)   /* less than into left subtree */
        p->left = addtree(p->left, w);
    else             /* greater than into right subtree */
        p->right = addtree(p->right, w);
    return p;
}

/* treeprint:  in-order print of tree p */
void treeprint(Treeptr p)
{
    if (p == NULL) return;
    treeprint(p->left);
    printf("%4d %s\n", p->count, p->word);
    treeprint(p->right);
}
```

### ===ğŸ‘‰ Table Lookup

åœ¨æœ¬èŠ‚ä¸­ï¼Œå±•ç¤ºäº†ä¸€ä¸ªè¡¨æŸ¥æ‰¾ç¨‹åºï¼Œä¹Ÿå°±æ˜¯ Hash Table çš„å®ç°ï¼Œå’Œç¼–è¯‘å™¨æˆ–å®å¤„ç†ç¨‹åºçš„ç¬¦å·ç®¡ç†åŠŸèƒ½å®ç°ç±»ä¼¼ï¼Œä¾‹å¦‚ä»£ç ä¸­å®šä¹‰äº†ä¸€ä¸ªç¬¦å·ï¼š

    #define  IN  1

ç„¶åï¼Œåœ¨å…¶å®ƒåœ°æ–¹ä½¿ç”¨è¿™ä¸ªç¬¦å·æ—¶ï¼Œå°±åº”è¯¥å°†ç¬¦å·ç”¨æ‰€å®šä¹‰çš„å€¼æ›¿æ¢ï¼š

    state = IN

æ•´ä¸ªæµç¨‹ä¸»è¦åˆ†ä¸ºä¸¤æ­¥ï¼š

- `install(s,t)` åœ¨è¡¨ä¸­è®°å½•ä¸‹ s ç¬¦å·å’Œå¯¹åº”å€¼ tï¼Œå®ƒä»¬éƒ½æ˜¯å­—ç¬¦ä¸²ï¼›
- `lookup(s)` æŸ¥æ‰¾æ–¹æ³•æ ¹æ®è¾“å…¥çš„ç¬¦å·è¿”å›è¡¨ä¸­è®°å½•çš„ç¬¦å·å¯¹åº”çš„å€¼ï¼Œå¦‚æœæ²¡æ‰¾åˆ°å°±è¿”å› NULLï¼›

è¿™ä¸ªè¡¨çš„å®ç°æ˜¯ä¸€ä¸ª Hash è¡¨ï¼Œç°åœ¨å¯ä»¥å°†å…¶å½“ä½œä¸€ä¸ªäºŒç»´å­—ç¬¦ä¸²æ•°ç»„ï¼ŒæŒ‰è¡Œåˆ—æ˜¾ç¤ºå¦‚ä¸‹ã€‚éœ€è¦è®¾è®¡ä¸€ä¸ª Hash å‡½æ•°ï¼Œå°†è¾“å…¥çš„ s å­—ç¬¦ä¸²è½¬æ¢ä¸ºä¸€ä¸ªæ•´æ•°ï¼Œå¯¹åº”æ•°ç»„çš„å…ƒç´ ã€‚

    Slot -> [0] --> [0] {"IN", 1} [1] ... [2] ...
    Slot -> [1] --> ...
    Slot -> [2] --> ...
    Slot -> [3] --> ...
    Slot -> [4] --> ...
    Slot -> [5] --> ...

ä¸Šé¢å‡è®¾ `hash("IN")` å‡½æ•°è¿ç®—ç»“æ„ä¸º 0ï¼Œé‚£ä¹ˆå°† IN = 1 è®°å½•åˆ°äºŒç»´æ•°ç»„çš„ç¬¬ä¸€ä¸ªå•å…ƒå†…ï¼Œå¦‚æœåç»­åˆæœ‰ç¬¦å·è®°å½•åˆ°è¿™é‡Œï¼Œå°±è·Ÿåœ¨ IN è¿™ä¸ªç¬¦å·çš„ä½ç½®åé¢ã€‚

Hash Table çš„å®ç°ä¸»è¦åœ¨å“ˆå¸Œå‡½æ•°çš„è®¾è®¡ï¼Œç¤ºèŒƒä¸­çš„å“ˆå¸Œå‡½æ•°å¯¹è¾“å…¥çš„å­—ç¬¦ä¸² s å„ä¸ªå­—ç¬¦è¿›è¡Œè¿ç®—ï¼Œå°†å­—ç¬¦å€¼åå¤ä¸ hashval è¿›è¡Œå åŠ ï¼Œå¹¶ä¸” hashval å…ˆä¸ä¸€ä¸ªè´¨æ•° 31 å…ˆè¿›è¡Œä¹˜æ³•è¿ç®—ã€‚

å“ˆå¸Œå‡½æ•°æœ¬è´¨æ˜¯ä¸€ä¸ªå•å‘å‹ç¼©å‡½æ•°ï¼Œå°†æ— é™ä½œç”¨åŸŸç©ºé—´æ˜ å°„åˆ°æœ‰é™çš„å€¼åŸŸç©ºé—´ã€‚

è´¨æ•° Prime æŒ‡é‚£äº›åªèƒ½è¢« 1 å’Œè‡ªèº«æ•´é™¤çš„ä¸”å¤§äº 1 çš„è‡ªç„¶æ•°ï¼Œä¾‹å¦‚ 2ã€3ã€5ã€7ã€11ã€‚å¾ˆæ˜æ˜¾ï¼Œé™¤äº† 2ï¼Œæˆ–è€…è¯´ï¼Œæ‰€æœ‰å¤§äº 2 çš„è´¨æ•°ä¸­ï¼Œä¸ªä½æ•°åªæœ‰ 1, 3, 7, 9ã€‚è€Œä¸”ï¼Œè´¨æ•°æ»¡è¶³å”¯ä¸€åˆ†è§£å®šç†ï¼šä»»ä¸€å¤§äº 1 çš„è‡ªç„¶æ•°ï¼Œè¦ä¹ˆæœ¬èº«æ˜¯è´¨æ•°ï¼Œè¦ä¹ˆå¯ä»¥åˆ†è§£ä¸ºå‡ ä¸ªè´¨æ•°ä¹‹ç§¯ï¼Œä¸”è¿™ç§åˆ†è§£æ˜¯å”¯ä¸€çš„ã€‚

æ ¹æ®è´¨æ•°å”¯ä¸€åˆ†è§£å®šç†ï¼Œä¸€ä¸ªæ•°å¯ä»¥é™¤ä»¥ä¸€ç³»ä¾‹è´¨æ•°è€Œå¾—åˆ°åˆ†è§£ï¼Œè€Œä¸”è¿™äº›è´¨æ•°åºåˆ—å”¯ä¸€ï¼Œæ¯ä¸ªæ•°éƒ½ä¸åŒã€‚

è´¨æ•°åˆ†è¾¨å®šç†ç®€å•çš„è¯´å°±æ˜¯ N ä¸ªè´¨æ•°çš„ä¹˜ç§¯ï¼Œå°±æ˜¯è¿™ N ä¸ªç§¯æ•°å¯ä»¥ç²¾ç¡®åˆ†è¾¨çš„æ•´æ•°æ•°é‡ï¼Œè¿™ N ä¸ªç§¯æ•°ç»„æˆçš„åºåˆ—å…·æœ‰å”¯ä¸€æ€§ï¼Œæ¯ä¸ªæ•°éƒ½æœ‰å”¯ä¸€çš„è´¨æ•°åˆ†è§£åºåˆ—ã€‚

Hash å‡½æ•°çš„è®¾è®¡åŸåˆ™ï¼š

- ä¸€è‡´æ€§ï¼šå¦‚æœ a==b åˆ™ hash(a)==hash(b)ã€‚
- é«˜æ•ˆæ€§ï¼šè®¡ç®—é«˜æ•ˆä¾¿æ·ï¼ŒO(1)ï¼Œç›¸å½“ç›´æ¥ä½¿ç”¨åŠ¨æ€æ•°ç»„ï¼Œåœ¨é€‚å½“çš„æƒ…å†µä¸‹ resizeã€‚
- å‡åŒ€æ€§ï¼šå“ˆå¸Œå€¼çš„åˆ†å¸ƒè¶Šå‡åŒ€è¶Šå¥½ï¼Œè¿™å°±æ˜¯å¯¹å–æ¨¡æ³•ä¸­æ¨¡ä¸ºè´¨æ•°çš„åŸå› ã€‚

å“ˆå¸Œå‡½æ•°çš„é«˜æ•ˆæ€§è¿˜ä½“éªŒç°å°½é‡ä½çš„å“ˆå¸Œå†²çªï¼Œå³å°½å¯èƒ½çš„åˆ†å¸ƒå‡åŒ€ï¼Œå¦‚æœå†²çªæ˜æ˜¾ï¼Œé‚£ä¹ˆå°±ä¼šå‡ºç°å¤§é‡çš„æ•°æ®é›†ä¸­å‡ºç°åœ¨å“ˆå¸Œè¡¨çš„å…¶ä¸­ä¸€ä¸ª Slotï¼Œè¿™æ ·ç›¸å½“äºå°†å“ˆå¸Œè¡¨é€€åŒ–ä¸ºä¸€ä¸ªæ•°ç»„ã€‚

æ•™æä¸­ä½œè€…å®‰æ’äº†ä¸¤ä¸ªç»ƒä¹ ï¼Œè¦æ±‚å®ç° uninstall æ–¹æ³•ä»¥å®Œæˆæ•´ä¸ªç¨‹åºï¼ŒæŒ‰ä»¥ä¸‹å®ç° 3 ä¸ªæ“ä½œäº¤äº’è¾“å…¥ï¼š

- `#` æ‰“å¤´è¡¨ç¤ºæ·»åŠ å¯¹åº”ç¬¦å·ã€‚
- `?` æ‰“å¤´è¡¨ç¤ºæŸ¥è¯¢å¯¹åº”ç¬¦å·ã€‚
- `@` æ‰“å¤´è¡¨ç¤ºåˆ é™¤å¯¹åº”ç¬¦å·ã€‚

ä¾‹å¦‚ï¼š

    #IN 1
    #OUT 2
    #ERR 3
    ?OUT
    OUT = 2
    @IN
    Remove IN

æ³¨æ„äº‹é¡¹ï¼š

- malloc åˆ†é…çš„å†…å­˜æ˜¯æ²¡æœ‰åˆå§‹åŒ–çš„ï¼Œè¿™æ ·é“¾è¡¨ä¸­çš„æŒ‡é’ˆå¯èƒ½æŒ‡å‘é”™è¯¯çš„åœ°å€ï¼Œæ”¹ç”¨ calloc åˆ†é…ç»è¿‡æ¸…é›¶çš„å†…å­˜ï¼›
- æ”¹é€ é“¾è¡¨ï¼Œæ·»åŠ ä¸€ä¸ª prev æŒ‡é’ˆï¼Œæ–¹ä¾¿è¿›è¡Œç§»é™¤æ“ä½œæ—¶æ‰¾åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹ï¼›
- æ‰§è¡ŒèŠ‚ç‚¹ç§»é™¤æ—¶ï¼Œæ³¨æ„ hashtab ä¸­çš„å…ƒç´ æ˜¯å¦æ­£ç¡®è®¾ç½®ä¸ºå¤´èŠ‚ç‚¹ï¼›
- åˆ é™¤èŠ‚ç‚¹æ—¶ï¼Œæ³¨æ„å›æ”¶å†…å­˜ï¼Œå¹¶ä¸”ï¼Œä¸è¦å†è®¿é—®å›æ”¶è¿‡çš„å†…å­˜ï¼›

ä»¥ä¸‹ä¸ºå‚è€ƒä»£ç ï¼š

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct nlist *ListPtr;
struct nlist {      /* table entry: */
    ListPtr next;   /* next entry in chain */
    ListPtr prev;   /* prev entry in chain */
    char *name;     /* defined name */
    char *defn;     /* replacement text */
};

typedef struct cmdtag {
    unsigned char cmd;
    char name[256];
    char value[256];
} CmdTag;

#define HASHSIZE 101
static ListPtr hashtab[HASHSIZE];  /* pointer table */

ListPtr lookup(char *);
ListPtr uninstall(char *name);
ListPtr install(char *name, char *defn);
int gettag(CmdTag *tag);

/* word frequency count */
int main()
{
    CmdTag ct;
    while ((gettag(&ct)) != EOF){
        if (ct.cmd == '#'){
            install(ct.name, ct.value);
        }else if (ct.cmd == '?') {
            ListPtr list = lookup(ct.name);
            if (list == NULL){
                printf("Not Found! %s\n", ct.name);
            }else{
                printf("%s = %s\n", ct.name, list->defn);
            }
        }else if (ct.cmd == '@') {
            ListPtr removed = uninstall(ct.name);
            if (removed == NULL){
                printf("Not Found! %s\n", ct.name);
            }else{
                printf("Remove %s\n", ct.name);
            }
        }
    }
    return 0;
}

int gettag(CmdTag *tag)
{
    char cmd;
    while( (cmd = getc(stdin)) == '\n') {  }
    ungetc(cmd, stdin);
    if (cmd == '?' || cmd == '@'){
        return scanf(" %c%256s", &tag->cmd, &tag->name);
    }
    return scanf(" %c%256s %256s", &tag->cmd, &tag->name, &tag->value);
}

/* hash:  form hash value for string s */
unsigned hash(char *s)
{
    unsigned hashval;

    for (hashval = 0; *s != '\0'; s++)
        hashval = *s + 31 * hashval;
    return hashval % HASHSIZE;
}

ListPtr uninstall(char *name)
{
    ListPtr np;
    if ((np = lookup(name)) != NULL) {
        if (np->prev != NULL) {
            np->prev->next = np->next;
        }else{
            int slot = -1;
            while(hashtab[++slot]!=np) {}
            hashtab[slot] = np->next;
        }
        if (np->next != NULL) np->next->prev = np->prev;
        free((void *)np->defn);
        free((void *)np->name);
        free((void *)np);
        return np;
    }
    return NULL;
}

/* install:  put (name, defn) in hashtab */
ListPtr install(char *name, char *defn)
{
    ListPtr np;
    unsigned slot;

    if ((np = lookup(name)) == NULL) { /* not found */
        // np = (ListPtr ) malloc(sizeof(*np));
        np = (ListPtr ) calloc(HASHSIZE, sizeof(ListPtr));
        if (np == NULL || (np->name = strdup(name)) == NULL)
            return NULL;
        slot = hash(name);
        ListPtr head = hashtab[slot];
        np->next = head;
        if(head != NULL) head->prev = np;
        hashtab[slot] = np;
    } else       /* already there */
        free((void *) np->defn);   /*free previous defn */
    if ((np->defn = strdup(defn)) == NULL)
        return NULL;
    return np;
}

/* lookup:  look for s in hashtab */
ListPtr lookup(char *s)
{
    ListPtr np;

    for (np = hashtab[hash(s)];  np != NULL; np = np->next)
        if (strcmp(s, np->name) == 0)
            return np;     /* found */
    return NULL;           /* not found */
}
```


## ==âš¡ ch7 - Input and Output
- ä¸ºä»€ä¹ˆ char a[1] å¯ä»¥å­˜å…¥ä¸‰ä¸ªæ±‰å­—çš„å­—ç¬¦ä¸²ï¼Ÿ https://www.zhihu.com/question/456630092/answer/1855656826

åœ¨æœ€å¼€å§‹çš„ä¸€ç« è§£é‡Šäº† Standard I/O çš„åŸºæœ¬ä½¿ç”¨ï¼ŒåŒ…æ‹¬å¦‚ä½•é‡å®šå‘ stdin/stdout/stderrã€‚

ä»æ“ä½œç³»ç»Ÿçš„è§’åº¦æ¥çœ‹ï¼Œè¾“å…¥ä¸è¾“å‡ºä¸æ˜¯ C è¯­è¨€çš„ä¸€ä¸ªéƒ¨åˆ†ï¼Œè€Œæ˜¯æ“ä½œç³»ç»Ÿçš„è´£ä»»ã€‚

ä½†æ˜¯æ“ä½œç³»ç»Ÿç»™ç¨‹åºæä¾›å¤æ‚çš„è¿è¡Œç¯å¢ƒï¼Œè¿™å…¶ä¸­åŒ…æ‹¬äº†è¾“å…¥å’Œè¾“å‡ºè®¾å¤‡çš„è¿æ¥ï¼Œæ‰€ä»¥å¼€å‘ç¨‹åºåŒå¿…éœ€æ·±å…¥ç†è§£è¿™äº›é—®é¢˜ã€‚

ä¸ºäº†å¯¹æ¥è¿™äº›å¤æ‚çš„ç¯å¢ƒï¼ŒC è¯­è¨€æä¾›äº† Standard I/O `<stdio.h>` å’Œ Standard Library `<stdlib.h>`å‡½æ•°åº“æ¥è§£å†³åŸºæœ¬è¾“å…¥è¾“å‡ºç­‰é—®é¢˜ï¼ŒåŒ…æ‹¬ä»ç¨‹åºè¿è¡Œå‰çš„åˆå§‹åŒ–ã€è¿è¡Œä¸­çš„å†…å­˜åŠ¨æ€åˆ†é…å’Œæ–‡ä»¶è¯»å†™ï¼Œåˆ°ç¨‹åºç»“æŸçš„å¤„ç†ç­‰ã€‚

Unix/Linux æ ‡å‡† I/O æµæ–‡ä»¶ä¸å¯¹åº”çš„ IDï¼š

    | Handle |  Name  |   Description   |
    |--------|--------|-----------------|
    |      0 | stdin  | Standard input  |
    |      1 | stdout | Standard output |
    |      2 | stderr | Standard error  |

æ ‡å‡† I/O æ–‡ä»¶çš„é‡å®šå‘ï¼š

```sh
# redirect stdout to output.txt  =
ls > output.txt
ls 1> output.txt

# append stdout to output.txt  =
ls -l >> output.txt

# redirect stderr to err.txt  =
grep -R 'MASTER' $HOME 2> err.txt

# redirect stderr to stdout, and stdout to output.txt  =
$ ls > output.txt 2>&1
## bash only ##  ==
$ ls &> output.txt

# on Windows  =
dir 2>&1 > out.txt
dir 2> nul
dir > output.txt 2> err.txt
dir 1> output.txt 2>&1

# redirect a program output to b stdin   =
a | b

# redirect file to stdin  =
# Windows only support < but not <<  =
cmd < file
# redirect fellowing command's output to cmd, until delimiterï¼ˆhere documentï¼‰  =
cmd << delimiter
# delimiter (here document), remove beginning \t  =
cmd <<- delimiter
```

I/O å‡½æ•°åº“æä¾›äº†ä¸¤å¤§ç±»å‡½æ•°ï¼Œæ ¼å¼åŒ–çš„ã€éæ ¼å¼åŒ–çš„ I/O å‡½æ•°ï¼Œæ ¼å¼åŒ–å­—ç¬¦å‚è€ƒå‰é¢çš„ format stringï¼š

- Unformatted input/output 
- Formatted input/output 

æœ€ç®€æ˜“ä½¿ç”¨çš„å°±æ˜¯ä»¥ä¸‹å­—ç¬¦ã€å­—ç¬¦ä¸²çš„è¾“å…¥ä¸è¾“å‡ºï¼š

```c
// reads/writes from stdin/stdout
int getchar(void);
char *gets( char *str );  (until C11) 
char *gets_s( char *str, rsize_t n );  (since C11) (optional) 
int putchar( int ch );
int puts( const char *str );
// puts a character back into a file stream
int ungetc( int ch, FILE *stream );

// reads formatted input from stdin, a file stream or a buffer
int scanf( const char          *format, ... );  (until C99) 
int scanf( const char *restrict format, ... );  (since C99) 
// prints formatted output to stdout, a file stream or a buffer
int printf( const char *format, ... );  (until C99) 
int printf( const char *restrict format, ... );  (since C99)
```

å¦å¤–ï¼Œä¸å¾—ä¸çš„ä¸€ä¸ªå®¹æ˜“è¢«åˆå­¦è€…å¿½è§†çš„æ˜¯æº¢å‡ºå¯¼è‡´çš„å®‰å…¨é—®é¢˜ï¼Œä¾‹å¦‚ï¼Œä»¥ä¸‹ä»£ç ç‰‡æ–­ä½¿ç”¨æ ¼å¼åŒ–è¾“å…¥å‡½æ•°å¤šæ ‡å‡†è¾“å…¥è®¾ç½®ä¸­è¯»å–ä¸€ä¸ªå­—ç¬¦ä¸²ï¼š

```c
char buf[256];
scanf("%s", buf);
```

ç›®æ ‡ç¼“å†²åŒºåªå®šä¹‰äº† 256 ä¸ªå­—ç¬¦ï¼Œå‡å¦‚æ¶æ„ç”¨æˆ·è¾“å…¥çš„å­—ç¬¦è¶…è¿‡ 256 ä¸ªå­—ç¬¦ä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿ

æ˜¾ç„¶ï¼Œbuf æ‰€æœ‰åœ°å€åé¢ 256 å­—ç¬¦ç´§è·Ÿçš„å†…å­˜åŒºåŸŸå°†ä¼šè¢«ç”¨æˆ·æ¶æ„è¾“å…¥çš„å†…å®¹è¦†ç›–ï¼Œå¦‚æœè¿™äº›å†…å­˜æ˜¯ç²¾å¿ƒæ„é€ çš„ä»£ç ï¼Œé‚£ä¹ˆå°†ææœ‰å¯èƒ½æ¼”å˜ä¸ºæˆåŠŸçš„å †æ ˆæº¢å‡ºæ”»å‡»ã€‚

è§£å†³åŠæ³•æ˜¯æŒ‡å®šè¾“å…¥çš„å­—ç¬¦å®½åº¦ï¼š

```c
#define ScanWidth(width) ScanWidthEx(width)
#define ScanWidthEx(width) ("%" #width "s")

char buf[5];
scanf("%5s", buf);
scanf(ScanWidth(MAXWORD), buf);
// scanf_s for C11
```

scanf ä¸ sscanf å ªç§° C çš„æ€æ‰‹çº§æ ‡å‡†åº“å‡½æ•°ï¼Œå› ä¸ºä½¿ç”¨èµ·æ¥å®åœ¨æ˜¯å¤ªæ–¹ä¾¿äº†ï¼Œä½†æ˜¯å®ƒä»¬çš„å®‰å…¨éšæ‚£åˆæ˜¯å¦‚æ­¤æ˜æ˜¾å’Œå®¹æ˜“è¢«å¿½è§†ã€‚

åœ¨ä¸åŒçš„ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œå­—ç¬¦å®šä¹‰æ˜¯ä¸ä¸€æ ·çš„ã€‚

- C/C++ çš„ char æ•°æ®ç±»å‹æ˜¯åŸºæœ¬çš„å€¼ç±»å‹ï¼Œå  8bit å†…å­˜ã€‚
- Rust ä½¿ç”¨ Unicodeï¼Œä¸€ä¸ª char å­—ç¬¦å  4 å­—èŠ‚ï¼Œ`std::mem::size_of::<char>()` å¯ä»¥ç¡®è®¤ã€‚
- JavaScript ä¹Ÿä½¿ç”¨å…¨çƒç ï¼Œä½†æ˜¯æ²¡æœ‰ char è¿™ç§åŸå§‹å€¼ç±»å‹ï¼Œé€šè¿‡ string.charAt è·å–å­—ç¬¦ç¼–ç å€¼ã€‚

åœ¨ç³»ç»Ÿçº§è¯­è¨€ä¸­ï¼ŒC/C++ æˆ– Rustï¼Œå†…å­˜çš„æ§åˆ¶æ˜¯ç›¸å½“è‡ªç”±çš„ï¼Œç‰¹åˆ«æ˜¯ C/C++ï¼ŒRust è¿˜å¥½å…·æœ‰å†…å­˜å®‰å…¨æ€§çš„é™æ€ç¼–è¯‘æ£€æŸ¥æœºåˆ¶ï¼Œå¦‚æœä½ ä¸çŸ¥é“ä»£ç åœ¨ç¡¬ä»¶ä¸Šçš„æŒ‡ä»¤è¡Œä¸ºï¼Œè¿™æ˜¯ä»¶å¾ˆå±é™©çš„äº‹ã€‚

åœ¨ C/C++ å®šä¹‰çš„å­—ç¬¦æ•°ç»„ï¼š

    char a[1];

å®ƒçš„æœ¬æ„å°±æ˜¯å®šä¹‰ä¸€ä¸ªæ•°ç»„å˜é‡ï¼Œå¹¶åˆ†é…ä¸€å—å…·æœ‰ 1 å­—èŠ‚çš„å†…å­˜åŒºåŸŸï¼Œç”¨æ¥å­˜æ”¾å­—ç¬¦æ•°ç»„ï¼Œä½œä¸ºç³»ç»Ÿçº§è¯­è¨€ï¼Œå®ƒæ‰ä¸ç®¡ä½ åœ¨å¹²ä»€ä¹ˆï¼Œå®ƒåªç®¡è‡ªå·±èƒ½åšä»€ä¹ˆã€‚æ‰€ä»¥ï¼Œå®‰å…¨çš„æ“ä½œè¦æ±‚æ•°æ®ä¸è¶…è¿‡ 1 ä¸ªå­—èŠ‚ï¼Œåœ¨ Rust æˆ– JavaScript è¿™æ ·çš„è¯­è¨€ä¸­ï¼Œæ˜¯æ²¡æœ‰æœºä¼šè®©ä½ çŠ¯è¿™ç§é”™è¯¯çš„ã€‚

è€Œ C/C++ ä¸ä¸€æ ·ï¼Œé€šè¿‡ scanf æ‰«æè¾“å…¥äº†è¶…è¿‡ 1 ä¸ªå­—èŠ‚ï¼Œäº‹å®ä¸Šåœ¨ Windows ç³»ç»Ÿä¸Šä½¿ç”¨ GBK ç¼–ç ï¼Œä¸€ä¸ªæ±‰å­— 2 ä¸ªå­—èŠ‚ã€‚æ‰€ä»¥ï¼Œå®ƒä»¬å«ç³»ç»Ÿçº§è¯­è¨€ï¼Œå¹²ä¸€åˆ‡å¯ä»¥å¹²çš„é”™ï¼ŒåŒ…æ‹¬å‡ºè½¨ï¼Œå“¦ï¼Œä¸æ˜¯å‡ºè½¨æ˜¯å‡ºé”™ï¼Œå‡†ç¡®åœ°è¯´æ˜¯å‡ºæ ˆï¼Œæ•°æ®è¶Šè¿‡æ ˆåŒºçš„å†…å­˜ç©ºé—´ Stack overflowï¼

ä¸ºäº†æ›´å½¢è±¡åœ°ç†è§£ï¼Œå‚è€ƒä»¥ä¸‹ ASCIIFlow ç»˜åˆ¶å›¾å½¢ç¤ºæ„ï¼š

    PC Memory address
     0x0001 0x0002 0x0003 0x0004 0x0005 0x0006 ...
    +------+------+------+------+------+------+------+
    |value |      |      |      |      |      |      |
    +--^---+------+------+------+------+------+------+
       |          
       +----------+
     chat a[1];---+

     0x0001 0x0002 0x0003 0x0004 0x0005 0x0006 ...
    +------+------+------+------+------+------+------+
    |  h   |   e  |   l  |  l   |  o   |      |      |
    +--^---+---^--+---^--+--^---+--^---+------+------+
       |       |      |     |      |
       +-------+-^----+-----+------+
                 |
     scanf("%s", a) <--- Enter: Hello


### ===ğŸ‘‰ va_arg Variable-length Argument Lists
- Xv6 - a simple Unix-like teaching operating system https://pdos.csail.mit.edu/6.828/2020/xv6.html

å¯å˜é•¿åº¦å‚æ•° Variable-length Argument Lists æ˜¯ `<stdarg.h>` å‡½æ•°åº“æä¾›çš„åŠŸèƒ½ï¼Œå½“è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œä¼šå…ˆå°†å‚æ•°å‹æ ˆï¼Œè¢«è°ƒç”¨å‡½æ•°åˆ™é€šè¿‡æ ˆå†…å­˜è·å–è¿™äº›ä¼ å…¥çš„å‚æ•°ã€‚

ä¸ºäº†è·å–è¿™äº›ä¸å®šé•¿çš„å‚æ•°ï¼Œåªéœ€è¦ä¸€ä¸ªæŒ‡é’ˆï¼Œå¹¶ç”¨åç§»å»è·å–ç›¸åº”ä½ç½®çš„å‚æ•°ã€‚

æ¯”å¦‚ï¼Œå®šä¹‰ä¸€ä¸ª char æŒ‡é’ˆï¼Œå› ä¸ºå‚æ•°çš„é•¿åº¦æ˜¯å¯å˜çš„ï¼Œæ‰€ä»¥ç”¨ char æŒ‡é’ˆç±»å‹æœ€åˆé€‚ï¼Œå¯å®šä½åˆ°ä»»æ„å­—èŠ‚ä¸Šï¼š

- `va_list`ï¼Œä¸€ä¸ªæŒ‡é’ˆï¼Œå®šä¹‰ä¸º char æŒ‡é’ˆç±»å‹ï¼Œä»¥ä¾¿æ”¯æŒä»»æ„ç±»å‹çš„åœ°å€åç§»ï¼›
- `va_start`ï¼Œæ ¹æ®æœ€åä¸€ä¸ªå‚æ•°æŒ‡å®šçš„ç±»å‹ä¿¡æ¯åˆå§‹åŒ–å‚æ•°åˆ—è¡¨ï¼Œå¹¶å®šä½åˆ°ç¬¬ä¸€ä¸ªå¯å˜å‚æ•°åœ°å€ï¼›
- `va_arg`ï¼Œæ ¹æ®å¯å˜å‚æ•°ä¸ªæ•°ï¼Œé€æ¸å‘é«˜åœ°å€æ–¹å‘å–å‡ºå‚æ•°ï¼›
- `va_end`ï¼Œæ¸…ç†å‚æ•°åˆ—è¡¨ï¼Œå°†æŒ‡é’ˆç½®ç©ºï¼›

å…·ä½“å®ç°å¯ä»¥å‚è€ƒ GCC æºä»£ç ï¼Œå¦‚ expand_builtin_va_startï¼Œä½äº buildins.c æ–‡ä»¶ã€‚

å˜é•¿å‚æ•°çš„å®ç°æ˜¯ä¸ªæœ‰è¶£åˆæœ‰ç”¨çš„æŠ€æœ¯ï¼Œå‚è€ƒ printf å‡½æ•°åŸå‹ï¼š

    int printf(const char *fmt, ...)

è¿™é‡Œä½¿ç”¨äº†å¯å˜å‚æ•°ï¼Œä½¿ç”¨çœç•¥å·è¡¨è¾¾ä»»æ„ä¸ªå‚æ•°ã€‚è¿™ç§è¯­è¨€åœ¨ C è¯­è¨€çš„å¼ºå¤§åº•å±‚èƒ½åŠ›ä¸‹æ˜¯éå¸¸å®¹æ˜“å®ç°çš„ã€‚æ ¹æ®å‡½æ•°è°ƒç”¨è§„åˆ™ï¼Œè°ƒç”¨å‡½æ•°æ—¶ï¼Œå‚æ•°åˆ—è¡¨æœ€å³è¾¹çš„å…ˆ PUSH åˆ°æ ˆå†…ï¼Œå…¶å®ƒå‚æ•°ä¾æ¬¡å¤„ç†ã€‚

å‡½æ•°æ¥æ”¶å‚æ•°æ—¶ï¼Œåªéœ€è¦ä½¿ç”¨ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘è¿™ä¸ªå‚æ•°åˆ—è¡¨ï¼Œå¹¶é€šè¿‡æ¯ä¸ªå‚æ•°æ‰€å çš„å­—èŠ‚æ•°ä½œä¸ºåç§»ç›´æ¥è®¿é—®æ ˆå†…ä¿å­˜çš„å‚æ•°ã€‚C è¯­è¨€æä¾› va_list, va_start, va_arg, va_end ç­‰å‡ ä¸ªå®å®šä¹‰æ¥åšè¿™äº›å·¥ä½œï¼Œåˆå§‹ä½“æ•°æ®ç»“æ„ã€å‡†å¤‡è¯»å–å‚æ•°ã€è·å–å‚æ•°ã€æ¸…ç†æ•°æ®ã€‚

ä»¥ä¸‹ä»£ç æ‘˜å–è‡ª MIT 6.828 æ“ä½œç³»ç»Ÿå·¥ç¨‹çš„ JOS ç³»ç»Ÿçš„ä»£ç ï¼Œcprintf å‡½æ•°å®ç°äº† printf åŒæ ·çš„åŠŸèƒ½ã€‚

```c
int vcprintf(const char *fmt, va_list ap)
{
    int cnt = 0;

    vprintfmt((void *)putch, &cnt, fmt, ap);
    return cnt;
}

int cprintf(const char *fmt, ...)
{
    va_list ap;
    int cnt;

    va_start(ap, fmt);
    cnt = vcprintf(fmt, ap);
    va_end(ap);

    return cnt;
}
```

åœ¨ vprintfmt å‡½æ•°å†…éƒ¨ï¼Œè§£æ fmt ä¼ å…¥çš„æ ¼å¼å­—ç¬¦ä¸²ï¼Œæ ¹æ® % åŒ¹é…æ ¼å¼è¯»å–æŒ‡å®šçš„å‚æ•°ï¼Œæ¯æ¬¡è°ƒç”¨ va_arg å°±ä»å‚æ•°ä¸­ ap å³ argments pointer æŒ‡å®šçš„ä½ç½®è¯»å–æŒ‡å®šç±»å‹çš„å‚æ•°ï¼Œå¹¶ç§»åŠ¨æŒ‡ä»¤æ›´æ–°åˆ°ä¸‹ä¸€ä¸ªå‚æ•°çš„ä½ç½®ã€‚

ä¾‹å¦‚ï¼Œä»å‚æ•°åˆ—è¡¨ä¸­è¯»å–ä¸€ä¸ªæ— ç¬¦å·æ•´å½¢ï¼š

    va_arg(*ap, unsigned int);

å‡½æ•°å¤„ç†å®Œåï¼Œè°ƒç”¨ va_end ç»“æŸæœ¬æ¬¡å¤šå‚æ•°ä¼ é€’çš„å¤„ç†ã€‚

The C Programming Language æä¾›äº†ä¸€ä¸ªç²¾ç®€ç‰ˆæœ¬çš„ printf å‡½æ•°å®ç°ï¼Œç±»ä¼¼ JOS ä¸­çš„ vprintfmt å®ç°ï¼š

```c
#include <stdarg.h>

/* minprintf: minimal printf with variable argument list */
void minprintf(char *fmt, ...)
{
   va_list ap; /* points to each unnamed arg in turn */
   char *p, *sval;
   int ival;
   double dval;

   va_start(ap, fmt); /* make ap point to 1st unnamed arg */
   for (p = fmt; *p; p++) {
       if (*p != '%') {
           putchar(*p);
           continue;
       }
       switch (*++p) {
       case 'd':
           ival = va_arg(ap, int);
           printf("%d", ival);
           break;
       case 'f':
           dval = va_arg(ap, double);
           printf("%f", dval);
           break;
       case 's':
           for (sval = va_arg(ap, char *); *sval; sval++)
               putchar(*sval);
           break;
       default:
           putchar(*p);
           break;
       }
   }
   va_end(ap); /* clean up when done */
}
```

### ===ğŸ‘‰ File Access

ç£ç›˜æ–‡ä»¶çš„è¯»å†™ï¼Œæœ¬è´¨ä¸Šå’Œè¯»å–ç”¨æˆ·é”®ç›˜è¾“å…¥ã€æ˜¾ç¤ºå™¨æ‰“å°è¾“å‡ºæ˜¯æ²¡æœ‰åŒºåˆ«çš„ï¼Œåœ¨ Linux ç³»ç»Ÿå…¨éƒ¨éƒ½æŠ½è±¡ä¸ºæ–‡ä»¶å¯¹è±¡ï¼Œè¿™ä¸æ— é“ç†ã€‚

å½“ç„¶ï¼Œä½¿ç”¨å’Œå®ç°ä¸Šçš„å·®åˆ«è¿˜æ˜¯æœ‰çš„ï¼Œå¦‚ç£ç›˜æ–‡ä»¶çš„äº§ç”Ÿå°±æ˜¯è¯»å–åˆ°æ–‡ä»¶æ•°æ®çš„ç»“æŸä½ç½®ï¼Œè€Œç”¨æˆ·é”®ç›˜è¾“å…¥è¦äº§ç”Ÿ EOF å°±éœ€è¦ç‰¹å®šçš„æŒ‰é”®ç»„åˆï¼ŒLinux ç³»ç»Ÿä¸‹é€šè¿‡ Ctrl+Dï¼ŒWindows ç³»ç»Ÿä¸‹é€šè¿‡è¡Œé¦–ä½ç½®è¾“å…¥çš„ Ctrl+Z æ¥äº§ç”Ÿ EOF æ ‡è®°ã€‚

å¹¶ä¸”ï¼Œç£ç›˜æ–‡ä»¶å…·æœ‰éšæœºè¯»å†™çš„ç‰¹æ€§ï¼Œä¸åƒé”®ç›˜ï¼Œé€šå¸¸åªèƒ½è¯»å–(åœ¨é©±åŠ¨å±‚æ¬¡ä¸Šå¯ä»¥å¾€é”®ç›˜æ§åˆ¶å™¨å†™å…¥æ•°æ®)ï¼Œæˆ–è€…æ˜¾ç¤ºå™¨åªä¾›å†™å…¥ã€‚

æ–‡ä»¶æ“ä½œå‡½æ•°ä¹Ÿæœ‰ç›¸å…³çš„å‚æ•°è®¾ç½®ï¼Œæ–‡ä»¶æ“ä½œçš„ç¬¬ä¸€æ­¥å°±æ˜¯è·å–èµ„æºï¼Œæˆ–è€…å«åšæ‰“å¼€æ–‡ä»¶ï¼Œå¾—åˆ°ä¸€ä¸ªæ–‡ä»¶èµ„æºæŒ‡é’ˆï¼Œç„¶åæ‰ä½¿ç”¨å„ç§åº“å‡½æ•°è¿›è¡Œè¯»å†™æ“ä½œã€‚å®Œæˆæ“ä½œåï¼Œæ‰§è¡Œ `fclose` å…³é—­æ–‡ä»¶ï¼Œé‡Šæ”¾æ–‡ä»¶æŒ‡é’ˆï¼Œç›¸å½“äºå‘Šè¯‰ç³»ç»Ÿæ”¶å›èµ„æºã€‚è¿™æ˜¯å¾ˆé‡è¦çš„æ“ä½œï¼Œå¦åˆ™èµ„æºä¼šä¸€ç›´è¢«å ç”¨ï¼Œå³ä½¿ç”¨ç¨‹åºä¸å†ä½¿ç”¨å®ƒï¼Œæ›´é‡è¦çš„æ˜¯ç³»ç»Ÿçš„èµ„æºæ˜¯æœ‰é™çš„ï¼Œæœ‰äº›ç³»ç»Ÿè¿˜é™åˆ¶äº†æ‰“å¼€æ–‡ä»¶çš„æ•°é‡ã€‚

åŒæ ·ï¼Œåœ¨ä¸éœ€è¦ `stdin` å’Œ `stdout` æ—¶ï¼Œä¹Ÿå¯ä»¥è°ƒç”¨ `fclose` å°†å®ƒä»¬å…³é—­ã€‚

ä»¥ä¸‹æ˜¯æ–‡ä»¶æ‰“å¼€ã€å­—ç¬¦è¯»å†™ã€å­—ç¬¦ä¸²è¯»å–æ“ä½œå‡½æ•°ï¼ŒåŒ…æ‹¬æ ¼å¼åŒ–ã€éæ ¼å¼æ“ä½œä¸¤ç±»åº“å‡½æ•°ï¼š

```c
FILE *fp;
FILE *fopen(char *name, char *mode);
// Allowable modes indelude read ("r"), write ("w"), append ("a"), binary ("b").

// closes a file
int fclose( FILE *stream );
// synchronizes an output stream with the actual file
int fflush( FILE *stream );

// unformatted input or output of files
int getc(FILE *fp)
int putc(int c, FILE *fp)
int fgetc( FILE *stream );
int fputc( int ch, FILE *stream );

char *fgets( char          *str, int count, FILE          *stream );  // (until C99)
char *fgets( char *restrict str, int count, FILE *restrict stream );  // (since C99)
int fputs( const char          *str, FILE          *stream );  // (until C99) 
int fputs( const char *restrict str, FILE *restrict stream );  // (since C99) 

// formatted input or output of files
int fscanf( FILE          *stream, const char          *format, ... );  // (until C99) 
int fscanf( FILE *restrict stream, const char *restrict format, ... );  // (since C99) 

int fprintf( FILE *stream, const char *format, ... );  // (until C99) 
int fprintf( FILE *restrict stream, const char *restrict format, ... );  // (since C99)
```

å…¶å®å¯¹æ ‡å‡†è¾“å…¥è¾“å‡ºæ“ä½œçš„å‡½æ•°ï¼Œå¦‚ getchar å’Œ putchar åªæ˜¯å®åŒ…è£…ï¼Œæ·»åŠ äº† stdin æˆ– stdout æ–‡ä»¶çš„è¯»å†™æ“ä½œï¼š

    #define getchar()    getc(stdin)
    #define putchar(c)   putc((c), stdout)

æ–‡ä»¶è¯»å†™ç¤ºèŒƒç¨‹åºï¼Œå®ç°ä¸€ä¸ª cat å‘½ä»¤ï¼Œå°†æ–‡ä»¶å†…å®¹æ‰“å°åˆ°å±å¹•ï¼š

```c
#include <stdio.h>

/* cat:  concatenate files, version 2 */
main(int argc, char *argv[])
{
   FILE *fp;
   void filecopy(FILE *, FILE *);
   char *prog = argv[0];  /* program name for errors */

   if (argc == 1 ) /* no args; copy standard input */
       filecopy(stdin, stdout);
   else
       while (--argc > 0)
           if ((fp = fopen(*++argv, "r")) == NULL) {
               fprintf(stderr, "%s: can't open %s\n",
                       prog, *argv);
               exit(1);
           } else {
               filecopy(fp, stdout);
               fclose(fp);
           }
   if (ferror(stdout)) {
       fprintf(stderr, "%s: error writing stdout\n", prog);
       exit(2);
   }
   exit(0);
}


/* filecopy:  copy file ifp to file ofp */
void filecopy(FILE *ifp, FILE *ofp)
{
    int c;

    while ((c = getc(ifp)) != EOF)
        putc(c, ofp);
}
```

åœ¨å¤„ç†æ–‡ä»¶çš„è¿‡ç¨‹ä¸­ï¼Œå‡ºé”™å¯èƒ½æ€§æ˜¯æé«˜çš„ï¼Œæ¯”å¦‚æŒ‡å®šçš„æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå› å…±äº«å†²çªæ‰“ä¸å¼€æ–‡ä»¶ç­‰ç­‰ï¼Œæ‰€ä»¥éœ€è¦å¯¹å‡½æ•°çš„è¿”å›å€¼è¿›è¡Œåˆ¤æ–­ã€‚

å¦å¤–ï¼Œå¯ä»¥é€šè¿‡ `stderr` è¿™ä¸ªä¸“ç”¨äºé”™è¯¯ä¿¡æ¯çš„æ ‡å‡†è¾“å‡ºæ–‡ä»¶å‘ä½¿ç”¨è€…å±•ç¤ºé”™è¯¯ä¿¡æ¯ï¼Œå¦‚æœ‰å¿…è¦ï¼Œè¿˜å¯ä»¥ä½¿ç”¨ `exit` åº“å‡½æ•°ä¸»åŠ¨é€€å‡ºç¨‹åºï¼Œå¹¶è®¾ç½®ä¸€ä¸ªè¿”å›ç  Exit Code æˆ– Error Numberï¼Œå½“ç„¶è¿™ä¸æ˜¯å¿…è¦çš„ï¼Œä½†æ˜¯ä¸€ç§è‰¯å¥½çš„ä¹ æƒ¯ï¼Œè¿™æ˜¯ä¸¤ç§å…¸å‹çš„é”™è¯¯ä¿¡æ¯ä¼ é€’æ–¹å¼ã€‚

åœ¨ Windows å¹³å°ï¼Œå¯ä»¥åœ¨æ‰¹å¤„ç†æ–‡ä»¶ä¸­æˆ–å‘½ä»¤è¡Œä½¿ç”¨ %ERRORLEVEL% æ¥è·å– ErrorCodeã€‚

åœ¨ Linux å¹³å°ï¼Œå¯ä»¥ä½¿ç”¨ Shell çš„ä¸€ä¸ªç‰¹æ®Šå˜é‡æ¥è·å–è¿”å›ç ï¼Œå¦‚ `echo $?` ä¼šå°†ä¸Šä¸€ä¸ªå‘½ä»¤çš„è¿”å›å€¼æ‰“å°å‡ºæ¥ã€‚

é€šå¸¸ï¼Œ`stderr` å†…å®¹ä¼šæ‰“å°åœ¨å±å¹•ä¸Šï¼Œå³ç”¨æˆ·å°†ä½¿ç”¨å°† `stdout` é‡å®šå‘åˆ°æ–‡ä»¶ï¼Œå®ƒä»¬ç›¸äº’é—´ä¹Ÿä¸å½±å“ï¼Œé™¤éå¯¹æ ‡å‡†é”™è¯¯æ–‡ä»¶è¿›è¡Œé‡å®šå‘ã€‚


### ===ğŸ‘‰ Line Input and Output

æ•´è¡Œçš„è¾“å…¥è¾“å‡ºæ˜¯æ–‡æœ¬å¤„ç†çš„å¸¸ç”¨åŠŸèƒ½ï¼ŒC è¯­è¨€æä¸ªçš„æ ¼å¼åŒ–è¾“å…¥å‡½æ•°ä¹Ÿæ”¯æŒæ•´è¡Œå†…å®¹çš„è¾“å…¥ã€‚

åœ¨ fscanf æˆ– scanf å‡½æ•°ä¸­ä½¿ç”¨æ ¼å¼åŒ–å­—ç¬¦ `%[^\n]` è¡¨ç¤ºåŒ¹é…ä¸€è¡Œè¾“å…¥ï¼Œä½¿ç”¨æ¢è¡Œç¬¦ '\n' ä½œä¸ºåˆ†éš”ç¬¦å·ã€‚ä½†æ˜¯ï¼Œè¿™ç§è¾“å…¥ä¸åŒ…æ‹¬é ASCII å­—ç¬¦ï¼Œå¦‚è¾“å…¥ "French suits of trÃ¨fles" å°†ä¸¢å¤±åé¢å››ä¸ªå­—ç¬¦ã€‚

åº“å‡½æ•° `gets` `puts` å’Œ `fgets` and `fputs` ç±»ä¼¼ï¼Œå‰è€…åªæ˜¯åŒ…è£…äº† stdin å’Œ stdout çš„å®å®šä¹‰ï¼Œè¿™äº›å­—ç¬¦ä¸²è¾“å…¥ã€è¾“å‡ºå‡½æ•°ä¹Ÿå¯¹ '\n' è¿›è¡Œäº†å¤„ç†ï¼Œ`gets` åˆ™åˆ é™¤äº†ç»“å°¾çš„æ¢è¡Œç¬¦å·ï¼Œè€Œ `puts` åˆ™ç›¸åï¼Œåœ¨è¾“å‡ºå†…å®¹ä¸­é™„åŠ äº†ä¸€ä¸ªæ¢è¡Œç¬¦å·ã€‚

```c
/* fgets:  get at most n chars from iop */
char *fgets(char *s, int n, FILE *iop)
{
   register int c;
   register char *cs;

   cs = s;
   while (--n > 0 && (c = getc(iop)) != EOF)
       if ((*cs++ = c) == '\n')
           break;
   *cs = '\0';
   return (c == EOF && cs == s) ? NULL : s;
}

/* fputs:  put string s on file iop */
int fputs(char *s, FILE *iop)
{
   int c;

   while (c = *s++)
       putc(c, iop);
   return ferror(iop) ? EOF : 0;
}
```

ç±»ä¼¼ scanf å‡½æ•°ä¸€æ ·ä¸å®‰å…¨ï¼Œgets ä¹Ÿå®¹æ˜“äº§ç”Ÿç¼“å†²åŒºæº¢å‡ºé—®é¢˜ï¼ŒC è¯­è¨€ç›´åˆ° C11 è§„èŒƒæ‰å¼•å…¥ gets_s å®‰å…¨ç‰ˆï¼Œä½†è¦å®ç°å®ƒä¸éš¾ï¼Œåªéœ€è¦å°† fets å‡½æ•°çš„å‚æ•°åˆ©ç”¨èµ·æ¥ï¼Œçº¦æŸæœ€å¤§è¾“å…¥é•¿åº¦ï¼š

```c
// reads a character string from stdin
char *gets( char *str ); //  (until C11) 
char *gets_s( char *str, rsize_t n ); // (since C11) (optional) 

/* getline:  read a line, return length */
int getline(char *line, int max)
{
   if (fgets(line, max, stdin) == NULL)
       return 0;
   else
       return strlen(line);
}
```

ç¤ºèŒƒå®½å­—ç¬¦æ•´è¡Œè¾“å…¥è¾“å‡ºï¼š

```c
#include <wchar.h>
#include <stdio.h>

int main(){
    wchar_t buf[256];
    wscanf(L"%[^\n]", buf);
    wprintf(L"IN: %s\n", buf);
}
```

ä»¥ä¸‹ç¤ºèŒƒæ–‡æœ¬è¡Œçš„è¯»å†™ï¼Œä»£ç æ‘˜è‡ª cppreference.comï¼š

```c
#include <stdio.h>
#include <stdlib.h>
 
int main(void)
{
    FILE* tmpf = tmpfile();
    fputs("Alan Turing\n", tmpf);
    fputs("John von Neumann\n", tmpf);
    fputs("Alonzo Church\n", tmpf);
 
    rewind(tmpf);
 
    char buf[8];
    while (fgets(buf, sizeof buf, tmpf) != NULL)
          printf("\"%s\"\n", buf);
 
    if (feof(tmpf))
       puts("End of file reached");
}
```

Output:

    "Alan Tu"
    "ring
    "
    "John vo"
    "n Neuma"
    "nn
    "
    "Alonzo "
    "Church
    "
    End of file reached


### ===ğŸ‘‰ File Differ
- è¯»æ‡‚diff http://ruanyifeng.com/blog/2012/08/how_to_read_diff.html
- Detailed Unified https://www.gnu.org/software/diffutils/manual/html_node/Detailed-Unified.html
- An O(ND) Difference Algorithm and Its Variations http://xmailserver.com/diff2.pdf
- Myers' Diff Algorithm : The linear space refinement http://simplygenius.net/Article/DiffTutorial2
- The Myers diff algorithm https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/
- Diff Strategies https://neil.fraser.name/writing/diff/
- Diffç®—æ³•ä¸å®ç° http://koala.ink/posts/4ee58d50/

æ•™æä¸­å¸ƒç½®äº†å‡ ä¸ªç»ƒä¹ ï¼Œå…¶ä¸­æ–‡ä»¶å†…å®¹æ¯”è¾ƒå€¼å¾—å»å®è·µã€‚

å®ç°ä¸€ä¸ª differ ç¨‹åºæ¯”è¾ƒæœ‰æŒ‘æˆ˜æ€§ï¼Œå¹¶ä¸”å®ƒååˆ†æœ‰ç”¨ï¼ŒUnix/Linux ç³»ç»Ÿå†…ç½® diff å‘½ä»¤ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆé‡è¦çš„å·¥å…·ç¨‹åºã€‚å®ƒç”¨æ¥æ¯”è¾ƒä¸¤ä¸ªæ–‡æœ¬æ–‡ä»¶çš„å·®å¼‚ï¼Œæ˜¯ä»£ç ç‰ˆæœ¬ç®¡ç†çš„åŸºçŸ³ä¹‹ä¸€ã€‚

åœ¨å‘½ä»¤è¡Œä¸‹ï¼Œè¾“å…¥ä»¥ä¸‹å‘½ä»¤ï¼š

    $ diff fileA fileB

å°±ä¼šå¾—åˆ°ä¸¤ä¸ªæ–‡ä»¶çš„å·®å¼‚æŠ¥å‘Šï¼Œå·®å¼‚ä¿¡æ¯æœ‰ä¸‰ç§ diff æŠ¥å‘Šæ ¼å¼æ˜¾ç¤ºï¼š

- æ­£å¸¸æ ¼å¼ï¼ˆnormal diffï¼‰
- ä¸Šä¸‹æ–‡æ ¼å¼ï¼ˆcontext diffï¼‰
- åˆå¹¶æ ¼å¼ï¼ˆunified diffï¼‰

æ­£å¸¸æ ¼å¼ä½¿ç”¨ `NMN` è¿™æ ·çš„æ ¼å¼è¡¨ç¤ºå·®å¼‚çŠ¶æ€ä¿¡æ¯ï¼Œè¿™ 3 ä¸ªå­—æ¯è¡¨ç¤ºä¸‰ä¸ªéƒ¨åˆ†ï¼š

- å‰é¢çš„ N è¡¨ç¤º fileA çš„è¡Œå·ï¼›
- åé¢çš„ N è¡¨ç¤º fileB çš„è¡Œå·ï¼›
- M æ˜¯ä¸€ä¸ªä»£è¡¨æ¨¡å¼çš„å­—ç¬¦ï¼Œc è¡¨ç¤ºå†…å®¹æ”¹å˜æ¨¡å¼ changeï¼Œè¿˜æœ‰ a è¡¨ç¤ºå¢åŠ  additionï¼Œd è¡¨ç¤ºåˆ é™¤ deletionï¼›

ç„¶åæ˜¯ï¼ŒfileA å’Œ fileB ç›¸å…³çš„å†…å®¹ä¸€è¡Œä¸€è¡Œç½—åˆ—ï¼Œå¹¶ä¸”ä½¿ç”¨ `<` æ‰“å¤´è¡¨ç¤ºåˆ é™¤è¡Œå†…å®¹ï¼Œä½¿ç”¨ `>` è¡¨ç¤ºå¢åŠ è¡Œå†…å®¹ã€‚ä¸¤ä¸ªæ–‡ä»¶çš„å†…å®¹ä½¿ç”¨ --- åˆ†éš”ï¼Œå‰é¢æ˜¯ fileA çš„å†…å®¹ï¼Œåé¢æ˜¯ fileB çš„å†…å®¹ã€‚

ä¾‹å¦‚ï¼Œä»¥ä¸‹è¡¨ç¤ºç¬¬ 4 è¡Œå†…å®¹æ”¹åŠ¨ï¼ŒfileA ç¬¬ 4 è¡Œå†…å®¹åˆ é™¤ï¼ŒfileB ç¬¬ 4 è¡Œå†…å®¹ä¸ºæ–°å¢ï¼Œå³ä¿®æ”¹åçš„å†…å®¹ï¼š

    4c4
    < sometext
    ---
    > new text

ç°ä»£å¤§é‡ä½¿ç”¨çš„æ˜¯åˆå¹¶æ ¼å¼ï¼Œè¿™æ˜¯å› ä¸ºå¦‚æœä¸¤ä¸ªæ–‡ä»¶ç›¸ä¼¼åº¦å¾ˆé«˜ï¼Œé‚£ä¹ˆä¸Šä¸‹æ–‡æ ¼å¼çš„ diff ä¼šäº§ç”Ÿå¤§é‡é‡å¤çš„å†…å®¹ï¼Œå¾ˆæµªè´¹ç©ºé—´ã€‚1990 å¹´ï¼ŒGNU diff ç‡å…ˆæ¨å‡ºäº†åˆå¹¶æ ¼å¼çš„ diff æŠ¥å‘Šæ ¼å¼ï¼Œä¸¤ä¸ªæ¯”è¾ƒçš„æ–‡ä»¶ä¸Šä¸‹æ–‡åˆå¹¶åœ¨ä¸€èµ·æ˜¾ç¤ºï¼Œä¸è¿›è¡Œåˆ†éš”ã€‚Git ä»£ç ç®¡ç†å·¥å…·ä¹Ÿä½¿ç”¨è¿™ç§æ ¼å¼ï¼Œå¯ä»¥ä½¿ç”¨ git diff å‘½ä»¤æŸ¥çœ‹å·®å¼‚ã€‚

åœ¨ diff å‘½ä»¤ä¸­åŠ å…¥ -u å‚æ•°å¯ç”¨ unified diff æ ¼å¼ï¼š

    $ diff -u f1 f2

git diff æŠ¥å‘Šæ ¼å¼å‚è€ƒï¼š

    --- a/CTF.md
    +++ b/CTF.md
    @@ -1,9 +1,491 @@

    +# ğŸš© CTF PNG æ–‡ä»¶éšå†™æœ¯
    +- https://github.com/ReFirmLabs/binwalk
    +- http://www.libpng.org/pub/png/libpng-manual.txt
    +- PNG Reference Library: libpng https://libpng.sourceforge.io/index.html
    +- PNG Specification: File Structure http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html
    +- CRC Algorithm http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html#CRC-algorithm
    +- A Painless Guide to CRC Error Detection Algorithms Ross Williams 1993 https://www.zlib.net/crc_v3.txt

è¦ç‚¹ï¼š

- `---` è¡¨ç¤ºå˜åŠ¨å‰çš„æ–‡ä»¶ f1ï¼Œ`+++` è¡¨ç¤ºå˜åŠ¨åçš„æ–‡ä»¶ f2ã€‚
- `@@` ä¹‹é—´çš„ä¸¤ç»„æ•°å­—å¯¹åº”è¡¨ç¤ºä¸¤ä¸ªæ–‡ä»¶å˜åŠ¨å†…å®¹çš„èµ·æ­¢ï¼Œé€—å·å‰é¢çš„æ•°å­—è¡¨ç¤ºèµ·å§‹è¡Œå·ï¼Œåé¢çš„æ•°å­—è¡¨ç¤ºæ€»è¡Œæ•°ã€‚

å‚è€ƒæŠ¥å‘Šä¸­çš„ `-1,9 +1,491` è¡¨ç¤ºåŸæ–‡ä»¶çš„ç¬¬ 1 è¡Œåˆ°åç»­çš„å…± 9 è¡Œå†…å®¹å˜æ›´ä¸ºæ–°æ–‡ä»¶çš„ç¬¬ 1 è¡Œåˆ°åç»­çš„å…± 491 è¡Œå†…å®¹ï¼Œä¹Ÿå°±æ˜¯æ·»åŠ å¤§é‡æ–°å†…å®¹ã€‚è¿™é‡Œçš„è¡Œå·åŒ…æ‹¬äº†çœŸæ­£å˜åŠ¨å†…å®¹çš„å‰ 3 è¡Œå’Œå 3 è¡Œï¼Œæ‰€ä»¥çœŸæ­£ä¿®æ”¹çš„å†…å®¹æ‰€åœ¨è¡Œå·éœ€è¦ +3ï¼Œé™¤éä¿®æ”¹çš„æ˜¯æ–‡ä»¶å¼€å§‹ä»¥çš„å‰é¢ 3 è¡Œã€‚æ­£è´Ÿå·åˆ†åˆ«è¡¨ç¤ºä¸¤ä¸ªæ–‡ä»¶ï¼Œå¯ä»¥æœ‰å¤šç»„å†…å®¹å˜åŠ¨ï¼Œè¿™æ ·å°±æœ‰å¤šä¸ª `@@` æ ‡è®°ã€‚

    @@ from-file-range to-file-range @@ [header]

    from-file-range: -<start line>,<number of lines>
    to-file-range: +<start line>,<number of lines>

ç„¶åæ˜¯ç›¸å…³çš„å†…å®¹ï¼ŒæŒ‰è¡Œç½—åˆ—ï¼Œæ¯ä¸€è¡Œæœ€å‰é¢çš„ä¸€ä¸ªå­—ç¬¦ä¸ºæ ‡å¿—ä½ï¼Œç”¨ç©ºæ ¼è¡¨ç¤ºæ— å˜åŠ¨ï¼Œç”¨ `-` è¡¨ç¤ºåˆ é™¤è¡Œï¼Œ`+` è¡¨ç¤ºå¢åŠ è¡Œï¼Œå¦‚æœå¢åŠ å¤šè¡Œè¿ç»­ï¼Œåªä½¿ç”¨æœ€å‰é¢ä¸€è¡Œçš„ `+` å·è¡¨ç¤ºã€‚é€šå¸¸åœ¨æ§åˆ¶å°ä¸­æ˜¾ç¤ºåˆ é™¤çš„å†…å®¹ä¸ºçº¢è‰²ï¼Œæ–°å¢çš„å†…å®¹ä¸ºç»¿è‰²ï¼Œæ— æ”¹åŠ¨å†…å®¹ä¸ºç™½è‰²ã€‚

Git diff çš„å®ç°æ˜¯é€šè¿‡åŠ¨æ€è§„åˆ’ç®—æ³•å®ç°å·®å¼‚æ¯”è¾ƒçš„ï¼Œé€šè¿‡æ±‚æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆLCSï¼‰ç®—æ³•å®ç°ã€‚å®ƒå¯ä»¥éæ¸…æ™°åœ°æ¯”è¾ƒå‡ºï¼Œä¸¤ä¸ªæ–‡ä»¶ä¸­ï¼Œå“ªäº›å†…å®¹è¢«åˆ é™¤ï¼Œå“ªé‡Œæœ‰æ–°å†…å®¹æ’å…¥ï¼Œå“ªäº›å†…å®¹æœ‰æ”¹åŠ¨ã€‚

è§£å†³æœ€é•¿å…¬å…±å­åºåˆ—é—®é¢˜é€šå¸¸æœ‰ä»¥ä¸‹ä¸¤ç§æ–¹æ³•ï¼š

- Shortest Edit Script ( SES )
- Longest Common Subsequence ( LCS )

åœ¨æ¯”è¾ƒä¸¤ä¸ªæ–‡ä»¶æ—¶ï¼Œé€šå¸¸éœ€è¦æ‰“å‡ºæ›´æ–°åçš„æ–‡ä»¶å¢åŠ ã€åˆ å‡ã€ä¿®æ”¹çš„å†…å®¹ã€‚SES ç®—æ³•åªéœ€è¦æŒ‡å‡ºå“ªäº›å†…å®¹æ˜¯æ–°æ’å…¥çš„ï¼Œå“ªäº›æ˜¯åˆ å‡çš„ã€‚è¿™äº›æ–¹æ³•å¯ä»¥ç”Ÿæˆä¸€ä¸ª diff æ–‡ä»¶ï¼Œç”¨äºæŒ‡å¯¼å¦‚ä½•ä»æ—§æ–‡ä»¶ç”Ÿæˆæ›´æ–°åçš„æ–‡ä»¶ï¼Œè¿™æ ·èƒ½èŠ‚çœå¤§é‡èµ„æºï¼ŒåŒ…æ‹¬ç½‘ç»œå¸¦å®½ã€æ•°æ®åº“å®¹é‡ç­‰ã€‚

ç›¸å…³çš„è®ºæ–‡æ˜¯ Eugene W. Myers äº 1986 åœ¨ Algorithmica æœŸåˆŠä¸Šå‘å¸ƒçš„ An O(ND) Difference Algorithm and Its Variationsã€‚

è®¡ç®—ä¸¤ä¸ªæ–‡æœ¬ç›¸åŒéƒ¨åˆ†çš„é—®é¢˜ï¼Œå³æ±‚ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­åºåˆ— LCS - Longest Common Subsequence é—®é¢˜ã€‚ä½¿ç”¨åŠ¨æ€è§„åˆ’è§£å†³ LCS é—®é¢˜çš„æ—¶é—´å¤æ‚åº¦ä¸º O(mn)ï¼Œæ¯”ç®€å•çš„é€’å½’å®ç°è¦å¿«å¤šäº†ã€‚ç©ºé—´å¤æ‚åº¦æ˜¯ O(mn)ï¼Œå› ä¸ºä½¿ç”¨äº†ä¸€ä¸ªåŠ¨æ€è§„åˆ’è¡¨ã€‚

å­åºåˆ— `Subsequence` å®šä¹‰ï¼Œè®¾åºåˆ— `X=<x1, x2, â€¦, xm>`ï¼Œä» X åºåˆ—ä¸­ä»»æ„å–å‡ºè‹¥å¹²ä¸ªå…ƒç´ ï¼ŒæŒ‰ç…§å…ƒç´ ä¸‹æ ‡ä»å°åˆ°å¤§çš„é¡ºåºæ’åˆ—å¾—åˆ°ä¸€ä¸ªæ–°çš„åºåˆ— `Z=<z1, z2, ..., zk>`ï¼Œåˆ™ Z ä¸º X çš„ä¸€ä¸ªå­åºåˆ—ã€‚å­åºåˆ—åªè¦æ±‚å…ƒç´ çš„å‰åä½ç½®å…³ç³»ä¸åŸåºåˆ—ä¸­ä¿æŒä¸€è‡´å³å¯ï¼Œä¸å¿…ä¿è¯å…ƒç´ å¿…éœ€æ˜¯è¿ç»­çš„ã€‚

å…¬å…±å­åºåˆ— `Common Subsequence` å®šä¹‰ï¼Œç»™å‡ºä¸¤ä¸ªåºåˆ— X ä¸ Yï¼Œæ‰¾åˆ°ä¸€ä¸ªåºåˆ— Zï¼Œæ»¡è¶³ï¼šZ æ˜¯ X çš„å­åºåˆ—åˆæ˜¯ Y çš„å­åºåˆ—ï¼Œåˆ™ Z ä¸º X ä¸ Y çš„ä¸€ä¸ªå…¬å…±å­åºåˆ—ã€‚

æœ€é•¿å…¬å…±å­åºåˆ—å®šä¹‰ï¼Œç»™å‡ºä¸¤ä¸ªåºåˆ— X ä¸ Yï¼Œæ‰¾åˆ°ä¸€ä¸ªå…¬å…±å­åºåˆ— Zï¼Œå…¶é•¿åº¦æ˜¯ X ä¸ Y æ‰€æœ‰å…¬å…±å­åºåˆ—ä¸­é•¿åº¦æœ€é•¿çš„ä¸€ä¸ªã€‚

æ³¨æ„åŒºåˆ«æœ€é•¿å­ä¸²ï¼Œå­ä¸² `Substring` æ˜¯æŒ‡åºåˆ—ä¸­ä»»æ„è¿ç»­çš„éƒ¨åˆ†ï¼Œæ•´ä¸ªåºåˆ—æœ¬èº«å°±æ˜¯æœ€é•¿å­ä¸²ã€‚

å¦‚æœæš´åŠ›æšä¸¾æ‰€æœ‰å­åºåˆ—ï¼Œä¸€ä¸ªé•¿åº¦ä¸º m çš„åºåˆ—ï¼Œå­˜åœ¨ 2^m ä¸ªå­åºåˆ—ï¼Œåœ¨ä¸€ä¸ª n é•¿åº¦çš„åºåˆ—ä¸­åˆ¤æ–­ä¸€ä¸ªå­åºåˆ—çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n)ï¼Œå› æ­¤æš´åŠ›æ±‚è§£ LCS ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º `O(n*2^m)`ï¼Œæ•ˆç‡æä½çš„æŒ‡æ•°çº§æ—¶é—´å¤æ‚åº¦ã€‚




### ===ğŸ‘‰ Miscellaneous Functions
- Pseudo-random number generation https://en.cppreference.com/w/c/numeric/random
- memory management https://en.cppreference.com/w/c/memory
- strings conversions https://en.cppreference.com/w/c/string
- program utilities https://en.cppreference.com/w/c/program

è¿™é‡Œç½—åˆ—äº†ä¸€äº›å¸¸ç”¨çš„æ ‡å‡†åº“å‡½æ•°ï¼Œæ›´å®Œæ•´çš„åˆ—è¡¨åº”è¯¥å‚æ•°å¤´æ–‡ä»¶å®šä¹‰ï¼š

```c
// 7.8.1 String Operations <string.h>
// In the following, s and t are char *'s, and c and n are ints. 
strcat(s,t)     // concatenate t to end of s 
strncat(s,t,n)  // concatenate n characters of t to end of s 
strcmp(s,t)     // return negative, zero, or positive for s < t, s == t, s > t 
strncmp(s,t,n)  // same as strcmp but only in first n characters 
strcpy(s,t)     // copy t to s 
strncpy(s,t,n)  // copy at most n characters of t to s 
strlen(s)       // return length of s 
strchr(s,c)     // return pointer to first c in s, or NULL if not present 
strrchr(s,c)    // return pointer to last c in s, or NULL if not present 

// 7.8.2 Character Class Testing and Conversion <ctype.h>
// In the following, c is an int that can be represented as an unsigned char or EOF. The function returns int. 
isalpha(c)      // non-zero if c is alphabetic, 0 if not 
isupper(c)      // non-zero if c is upper case, 0 if not 
islower(c)      // non-zero if c is lower case, 0 if not 
isdigit(c)      // non-zero if c is digit, 0 if not 
isalnum(c)      // non-zero if isalpha(c) or isdigit(c), 0 if not 
isspace(c)      // non-zero if c is blank, tab, newline, return, formfeed, vertical tab 
toupper(c)      // return c converted to upper case 
tolower(c)      // return c converted to lower case 

// 7.8.3 Ungetc <stdio.h>
// pushes the character c back onto file fp, and returns either c, or EOF for an error.
int ungetc(int c, FILE *fp)

// 7.8.4 Command Execution <stdio.h>
// ex: int exitcode = system("date");
int system( const char *command )

// 7.8.5 Storage Management <stdlib.h>
// The functions malloc and calloc obtain blocks of memory dynamically. 
// malloc returns a pointer to n bytes of uninitialized storage, or NULL if fail. 
void *malloc(size_t n)
// calloc returns a pointer to n * size bytes of storage initialized to zero, or NULL if fail
void *calloc(size_t n, size_t size)
// free deallocates previously allocated memory by malloc or calloc.
void  free( void* ptr )

// 7.8.6 Mathematical Functions <math.h>
// Each takes one or two double arguments and returns a double. 
sin(x)      // sine of x, x in radians 
cos(x)      // cosine of x, x in radians 
atan2(y,x)  // arctangent of y/x, in radians 
exp(x)      // exponential function ex 
log(x)      // natural (base e) logarithm of x (x>0) 
log10(x)    // common (base 10) logarithm of x (x>0) 
pow(x,y)    // xy 
sqrt(x)     // square root of x (x>0) 
fabs(x)     // absolute value of x 

// 7.8.7 Random Number generation <stdlib.h>
int rand()  // computes a sequence of pseudo-random integers in [0, RAND_MAX]
#define frand() ((double) rand() / (RAND_MAX+1.0)) // in [0, 1]
```

å…¶ä¸­ï¼ŒåŠ¨æ€å†…å­˜ç®¡ç†å‡½æ•°æ˜¯ C è¯­è¨€çš„é‡ç‚¹å†…å­˜ï¼Œå…¶é‡è¦æ€§ä¸æ¥äº C è¯­è¨€çš„æŒ‡é’ˆï¼Œå¹¶ä¸”æ˜¯å®¹æ˜“å‡ºé”™çš„éƒ¨åˆ†ï¼Œåˆ—å¦‚å¯¹åŠ¨æ€åˆ†é…çš„å†…å­˜è¿›è¡ŒäºŒæ¬¡é‡Šæ”¾ï¼Œæˆ–è€…é‡Šæ”¾é malloc å’Œ calloc åˆ†é…çš„å†…å­˜ã€‚

é‡Šæ”¾å†…å­˜ï¼Œæ„å‘³ç€åŠ¨æ€åˆ†é…çš„å†…å­˜è¢«å›æ”¶ï¼Œä¸å†å…·æœ‰è®¿é—®æƒé™ï¼Œå¦‚æœè¿›è¡Œè®¿é—®åˆ™è§¦å‘ SegmentFall å¼‚å¸¸ï¼š

```c
int *ip;
ip = (int *) calloc(n, sizeof(int));
free(ip);

// A typical but incorrect piece of code is this loop that frees items from a list: 
for (p = head; p != NULL; p = p->next) /* WRONG */
    free(p);

// The right way is to save whatever is needed before freeing: 
for (p = head; p != NULL; p = q) {
    q = p->next;
    free(p);
}
```

åœ¨åé¢çš„ç« èŠ‚è¿˜ä¼šç»§ç»­æ¢è®¨è¿™åŠ¨æ€å†…å­˜åˆ†é…ï¼Œå®ç°å†…å­˜åˆ†é…å™¨ã€‚


## ==âš¡ ch8 - The UNIX System Interface
- The Unix Programming Environment Brian W. Kernighan, Rob Pike https://book4you.org/book/2753533/762464
- The Practice of Programming Brian W. Kernighan, Rob Pike https://book4you.org/book/735475/780085
- The Art of UNIX Programming Eric S. Raymond https://book4you.org/book/1269633/3c4a32
- Advanced Programming in the UNIXÂ® Environment 3rd https://book4you.org/book/2167553/a59ff8
- UNIX Network Programming, Volume 1: Networking APIs: Sockets and XTI, 2nd https://book4you.org/book/455701/98d00b
- UNIX Network Programming, Volume 1: The Sockets Networking API, 3rd https://book4you.org/book/5337014/e847e9
- UNIX Network Programming, Volume 2: Interprocess Communications https://book4you.org/book/656980/d47b46

æœ€ä¸€ä¸ªç« èŠ‚çš„å£å·å¾ˆæ˜æ˜¾ï¼Œå°±æ˜¯é¢å‘ Unix-like ç¼–ç¨‹ï¼Œé¢å‘ Linux ç¼–ç¨‹ï¼ä½œä¸º Unix ç±»å‹çš„å¼€æºæ“ä½œç³»ç»Ÿï¼ŒLinux å·²ç»æ‰›è¿‡ Unix çš„å¤§æ——ï¼Œå¤§é‡å¼€æ”¾çš„æºä»£ç æ„å‘³ç€å¯ä»¥å­¦ä¹ åˆ°çœŸæ­£çš„æŠ€æœ¯ï¼Œå¦‚æœæ˜¯é¢å‘ Windows ç¼–ç¨‹ï¼Œé‚£ä¹ˆï¼Œå¤šåŠæ˜¯é¢å‘è°ƒåŒ…ç¼–ç¨‹ï¼Œé™¤éä½ å¯ä»¥åŠ å…¥ M$ å†…éƒ¨å›¢é˜Ÿï¼Œå¦åˆ™å°±æ˜¯åœ¨é»‘ç®±æ“ä½œã€‚

ä½†æ˜¯ï¼Œä½¿ç”¨è¿˜æ˜¯ä¹ æƒ¯äº† Windowsï¼ŒåŒ…å«è¿™ä»½æ–‡æ¡£çš„å†™ä½œï¼Œä¹Ÿæ˜¯åœ¨ Windows å¹³å°ä¸Šå®Œæˆçš„ï¼ŒUnix ç¨‹åºå®éªŒæ˜¯åœ¨ Windows WSL å­ç³»ç»Ÿä¸Šå®Œæˆçš„ï¼Œæ‰€ä»¥èŠ‚çœæ—¶é—´æ˜¯é‡è¦çš„å› ç´ ï¼Œä¸ç©é»‘ç®±æ˜¯ä¸€æ¡åº•çº¿ã€‚

C è¯­è¨€æ˜¯å’Œ UNIX ç³»ç»Ÿä¼´ç”Ÿçš„ï¼Œå®ƒä»¬æœ‰ç€ç›¸åŒçš„å‡½æ•°å¼ç¼–ç¨‹é£æ ¼ï¼Œç”šè‡³å¯ä»¥å°† UNIX ä½œä¸ºä¸€ç§å‡½æ•°å¼å…¸èŒƒï¼Œå®ƒæä¾›ä¸€ç³»åˆ—çš„ç³»ç»Ÿ APIï¼Œä¹Ÿå« system cvallsï¼Œä¾›ç”¨æˆ·ç¨‹åºè°ƒç”¨ã€‚

ç³»ç»Ÿè°ƒç”¨æ¶‰åŠå¤šä¸ªæ–¹é¢ï¼Œä¸»è¦æœ‰ï¼š

- æ–‡ä»¶ Files & Directories
- Standard I/O Library & Advanced I/O & Terminal I/O
- ç³»ç»Ÿä¿¡æ¯ System Data Files & Information
- è¿›ç¨‹ç¯å¢ƒ Process Environment
- è¿›ç¨‹æ§åˆ¶ Process Control
- è¿›ç¨‹å…³ç³» Process Relationships
- ä¿¡å· Signals
- çº¿ç¨‹ Threads
- çº¿ç¨‹æ§åˆ¶ Threads Control
- è¿›ç¨‹é—´é€šä¿¡ Interprocess Communication & Network IPC & Advanced IPC

è¿™é‡Œä¸å¯èƒ½å®Œå…¨æ¶‰åŠï¼Œåªèƒ½æŒ‘æœ€åŸºæœ¬çš„æ–‡ä»¶å’Œè¿›ç¨‹ç¯å¢ƒéƒ¨åˆ†å†…å®¹ï¼Œä¸»è¦æ˜¯æ–‡ä»¶ I/O æ“ä½œï¼Œå’Œè¿›ç¨‹çš„å†…å­˜åˆ†é…ï¼Œå…·ä½“å¯ä»¥å‚è€ƒ Advanced Programming in the UNIXÂ® Environment 3rd Editionã€‚

å½“ç„¶ï¼ŒLinux ä½œä¸º Unix-Like ç³»ç»Ÿï¼Œä¹Ÿå¯ä»¥ç”¨ä½œå®éªŒä¹‹ç”¨ï¼Œç°åœ¨é€šè¿‡ Windows WSL å°±å¯ä»¥å®‰è£…ï¼Œå¦‚æœå·¥ä½œç«™å·²ç»å®‰è£… Linux ç³»ç»Ÿæ›´å¥½ã€‚


### ===ğŸ‘‰ File I/O
- https://en.cppreference.com/w/c/io/fread
- https://en.cppreference.com/w/c/io/fwrite

åœ¨ Unix ç³»ç»Ÿä¸­ï¼Œæ‰€æœ‰å¤–è¿è®¾å¤‡éƒ½æŠ½è±¡ä¸ºæ–‡ä»¶ï¼Œå³ä½¿æ˜¯é”®ç›˜æˆ–å±å¹•ï¼Œå®ƒä»¬å¯¹åº”å½“ä½œåªè¯»ã€åªå†™æ–‡ä»¶å¯¹è±¡å¯¹å¾…ã€‚å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œè¯»å†™æ–‡ä»¶éœ€è¦é€šçŸ¥ç³»ç»Ÿï¼Œå³è°ƒç”¨ API æ‰“å¼€æ–‡ä»¶ï¼Œå¯ä»¥é€‰æ‹©ä½¿ç”¨ append æ¨¡å¼ä¿ç•™æ–‡ä»¶å†…å®¹æˆ–ä¸¢å¼ƒå†…å®¹ã€‚ç³»ç»Ÿåœ¨æ‰“å¼€æ–‡ä»¶æ—¶ï¼Œæ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œå½“å‰ç”¨æˆ·ç¨‹åºæ˜¯å¦æœ‰æƒæ‰“å¼€æ–‡ä»¶ã€‚

ç³»ç»Ÿæ‰“å¼€å¯¹åº”çš„æ–‡ä»¶åï¼Œä¼šè¿”å›ä¸€ä¸ªä»£è¡¨æ–‡ä»¶æè¿°ç¬¦çš„éè´Ÿå€¼æ•´æ•°ï¼Œfile descriptorï¼Œå®ƒç”¨æ¥æ¨¡å—æ ‡å‡†åº“ä¸­çš„æ–‡ä»¶æŒ‡é’ˆï¼Œæˆ–è€… MS-DOS ä¸­çš„æ–‡ä»¶å¥æŸ„ã€‚ç³»ç»Ÿé€šè¿‡æ–‡ä»¶æè¿°ç¬¦ç»´æŠ¤æ‰€æœ‰æ–‡ä»¶ç›¸å…³ä¿¡æ¯ï¼Œç”¨æˆ·ç¨‹åºé€šè¿‡æè¿°ç¬¦æ¥å¼•ç”¨æ–‡ä»¶ã€‚

å› ä¸ºç¨‹åºåŸºæœ¬éƒ½ä¼šä½¿ç”¨ä¸€é”®ç›˜è¾“å…¥å’Œå±å¹•è¾“å‡ºï¼Œæ‰€ä»¥å‡ ä¹æ‰€æœ‰ç³»ç»Ÿä¸­ï¼Œå®ƒä»¬éƒ½è¢«å½“ä½œæ ‡å‡†çš„è¾“å…¥è¾“å‡ºæ–‡ä»¶ã€‚

Unix/Linux æ ‡å‡† I/O æµæ–‡ä»¶ä¸å¯¹åº”çš„ IDï¼š

    | Handle |  Name  |   Description   |
    |--------|--------|-----------------|
    |      0 | stdin  | Standard input  |
    |      1 | stdout | Standard output |
    |      2 | stderr | Standard error  |

å…³äºå®ƒäº›æ ‡å‡†æ–‡ä»¶çš„ä½¿ç”¨ï¼Œé‡å®šå‘ã€ç®¡é“æ“ä½œï¼Œå·²ç»åœ¨å‰é¢è§£é‡Šè¿‡ï¼Œå‚è€ƒ ch7 - Input and Outputã€‚

    prog <infile >outfile
    prog | to | another

é€šè¿‡é‡å®šå‘ã€ç®¡é“æ“ä½œï¼Œå¯ä»¥æ”¹å˜ç¨‹åºä¸­å…³è”çš„æ ‡å‡†è¾“å…¥è¾“å‡ºæ–‡ä»¶ï¼ŒåŒ…æ‹¬ stderrã€‚

ç³»ç»Ÿæä¾›åº•å±‚æ–‡ä»¶ I/O å‡½æ•° read å’Œ write æ¥è¯»å†™æ–‡ä»¶ï¼Œæœ‰å¯¹åº” C è¯­è¨€çš„æ ‡å‡† I/O å‡½æ•°ï¼š

```c
int n_read = read(int fd, char *buf, int n);
int n_written = write(int fd, char *buf, int n);
```

å‚æ•°ï¼š

- fd  - æŒ‡å®šä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œé€šè¿‡ open å‡½æ•°è·å–ï¼›
- buf - æŒ‡å®šè¯»å†™çš„å†…å®¹æ‰€åœ¨çš„å†…å­˜ä½ç½®ï¼›
- n   - æŒ‡å®šæœ€å¤§è¯»å†™å­—èŠ‚æ•°ï¼›

ä¸¤ä¸ªå‡½æ•°éƒ½è¿”å›å·²ç»æ“ä½œçš„å­—èŠ‚æ•°ï¼Œå¦‚æœå†™å…¥çš„å­—èŠ‚æ•°ä¸ç­‰äºæŒ‡å®šçš„å­—èŠ‚æ•°ï¼Œå°±è¡¨ç¤ºå†™å…¥å‡ºé”™äº†ã€‚å¦‚æœè¯»å–çš„å­—èŠ‚æ•°ä¸º 0 å°±æš—ç¤ºæ–‡ä»¶ç»“å°¾ï¼Œè¿”å› -1 è¡¨ç¤ºå‡ºé”™ã€‚

å¯ä»¥æŒ‡å®šè¯»å†™ä»»æ„é•¿åº¦çš„å­—èŠ‚ï¼Œä½†å¸¸ç”¨çš„æ˜¯æŒ‡å®š 1 ä¸ªå­—èŠ‚çš„éç¼“å­˜å¼è¯»å†™ï¼Œæˆ–è€… 1024ã€4096 è¿™æ ·çš„è®¾å¤‡ç‰©ç†å—å¤§å°ä¼šæ›´æœ‰æ•ˆç‡ï¼Œç¨å¤§ä¸€ç‚¹çš„ç¼“å†²ä¼šé™ä½ç³»ç»Ÿè°ƒç”¨ï¼ŒåŒæ—¶ä¹Ÿå°±æ˜¯åœ¨é™ä½ä½å±‚æ¶ˆè€—ï¼Œæ¯”å¦‚æœºæ¢°ç£ç›˜çš„ç£å¤´å¯»é“æ“ä½œã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ç¤ºèŒƒï¼Œå°†æ ‡å‡†è¾“å…¥çš„å†…å®¹å†™å…¥æ ‡å‡†è¾“å‡ºæ–‡ä»¶ã€‚åœ¨ Linux ç³»ç»Ÿä¸Šï¼Œæä¾›äº† `<unistd.h>` å¤´æ–‡ä»¶ï¼Œå³ Unix Standard APIï¼Œå®ƒåŒ…è£…äº†å¤§å¤šæ•° Unix ç³»ç»Ÿè°ƒç”¨ï¼Œè™½ç„¶ä¹Ÿæœ‰ `<syscall.h>` ä½†å®ƒæœ¬èº«å¹¶é Unix çš„ç³»ç»Ÿè°ƒç”¨å¤´æ–‡ä»¶ã€‚

```c
// #include "syscalls.h"
// #include <syscall.h>
#include <unistd.h>
#include <stdio.h>

int main()  /* copy input to output */
{
    char buf[BUFSIZ];
    int n;

    while ((n = read(0, buf, BUFSIZ)) > 0)
        write(1, buf, n);
    return 0;
}
```

ä»£ç ä¸­çš„ BUFSIZ å®šä¹‰åœ¨ç³»ç»Ÿå¤´æ–‡ä»¶å†…ï¼Œåœ¨ Linux ç³»ç»Ÿä¸­ï¼Œåˆ™ç”± `<stdio.h>` å¤´æ–‡ä»¶å®šä¹‰ã€‚

é€šè¿‡åº•å±‚ APIï¼Œå¯ä»¥å®ç° C è¯­è¨€å‡½æ–‡ä»¶æ•°åº“ï¼Œå¦‚ getchar putchar ç­‰ç­‰ï¼š

```c
#include "syscalls.h"

/* getchar:  unbuffered single character input */
int getchar(void)
{
   char c;

   return (read(0, &c, 1) == 1) ? (unsigned char) c : EOF;
}
```

å°è£…åï¼Œå½“è¯»å–åˆ°æ–‡ä»¶ç»“æŸï¼Œå‡½æ•°å°±è¿”å›ä¸€ä¸ª EOF - End of File å¸¸é‡æ ‡è®°ï¼Œç”¨æˆ·ç¨‹åºå¯ä»¥é€šè¿‡å®ƒæ¥åˆ¤æ–­æ–‡ä»¶æ˜¯è¿˜æœ‰å†…å®¹ã€‚

å¦ä¸€ä¸ªå®ç°æ˜¯ç¼“å†²ç‰ˆæœ¬ï¼Œä¸€æ¬¡è¯»å–å¤§å—æ•°æ®ä»¥æå‡ç³»ç»Ÿè°ƒç”¨çš„æ•ˆç‡ï¼Œç„¶åå†é€å­—èŠ‚è¿”å›ç»™ç”¨æˆ·ç¨‹åºï¼š

```c
#include "syscalls.h"

/* getchar:  simple buffered version */
int getchar(void)
{
   static char buf[BUFSIZ];
   static char *bufp = buf;
   static int n = 0;

   if (n == 0) {  /* buffer is empty */
       n = read(0, buf, sizeof buf);
       bufp = buf;
   }
   return (--n >= 0) ? (unsigned char) *bufp++ : EOF;
}
```

å¦‚æœéœ€è¦é…åˆ `<stdio.h>` ä½¿ç”¨ä»¥ä¸Šå‡½æ•°ï¼Œå°±éœ€è¦ä½¿ç”¨é¢„å¤„ç†æŒ‡å®š `#undef getchar` æ¥


### ===ğŸ‘‰ Open, Creat, Close, Unlink
- https://www.man7.org/linux/man-pages/man3/error.3.html
- https://www.linux.com/training-tutorials/understanding-linux-file-permissions/

å’Œé»˜è®¤ç”¨é€”çš„æ ‡å‡†è¾“å…¥è¾“å‡ºæ–‡ä»¶ä¸åŒï¼Œå…¶å®ƒæ–‡ä»¶æ“ä½œéœ€è¦åœ¨æ‰“å¼€æ–‡ä»¶å‰æ˜ç¡®è¯»å†™ç›®çš„ï¼Œå¯¹åº”ç³»ç»Ÿè°ƒç”¨ open å’Œ creatã€‚

æ‰“å¼€æ–‡ä»¶å’Œå‰é¢ç« èŠ‚è®¨è®ºçš„ C è¯­è¨€åº“å‡½æ•°ç±»ä¼¼ï¼Œåªä¸è¿‡è¿”å›çš„æ˜¯æ–‡ä»¶æè¿°ç¬¦ï¼Œå³ä¸€ä¸ªéè´Ÿå€¼æ•´æ•°ï¼Œè€Œä¸æ˜¯ä¸€ FILE æŒ‡é’ˆã€‚å¦‚æœè¿”å› -1 å°±è¡¨ç¤ºæ‰“å¼€æ–‡ä»¶é”™è¯¯ï¼Œå¯èƒ½æ˜¯æ–‡ä»¶ä¸å­˜åœ¨ã€‚

```c
#include <fcntl.h>

int fd;
int open(char *name, int flags, int perms);
// fd = open(name, O_RDONLY, 0);

int creat(char *name, int perms);
// fd = creat(name, perms);
```

åœ¨ System V UNIX ä¸­ï¼Œä»¥ä¸Šå¸¸é‡å®šä¹‰åœ¨ `<fcntl.h>` å¤´æ–‡ä»¶ï¼Œæˆ–è€…åœ¨ Berkeley (BSD) ç‰ˆæœ¬å®šä¹‰åœ¨ `<sys/file.h>`ã€‚

æ‰“å¼€æ–‡ä»¶æ—¶ï¼Œperms å³ permissions å‚æ•°æ€»æ˜¯è®¾ç½®ä¸º 0ï¼Œå¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ™äº§ç”Ÿé”™è¯¯ï¼Œè€Œ flags ä¼ å…¥æ–‡ä»¶æ“ä½œç›®çš„ï¼š

- `O_RDONLY` open for reading only 
- `O_WRONLY` open for writing only 
- `O_RDWR`  open for both reading and writing 

å¯¹äºåˆ›å»ºæ–‡ä»¶ï¼Œå¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ™æ–°å»ºæ–‡ä»¶ã€‚å¦‚æœæ–‡ä»¶å­˜åœ¨ï¼Œé‚£ä¹ˆå°±é‡å†™å®ƒçš„å†…å®¹ï¼Œå°†åŸæ–‡ä»¶çš„å†…å®¹æˆªæ–­ã€‚åŒæ ·ï¼Œå¦‚æœè¿”å› -1 è¡¨ç¤ºåˆ›å»ºæ–‡ä»¶å¤±è´¥ï¼Œæ–‡ä»¶å­˜åœ¨å¹¶ä¸ä¼šå¯¼è‡´é”™è¯¯ã€‚

æ–‡ä»¶æƒé™åªåœ¨åˆ›å»ºæ–‡ä»¶æ—¶è®¾ç½®ï¼Œæˆ–è€…ä½¿ç”¨ Shell å‘½ä»¤ chmod è¿›è¡Œä¿®æ”¹ï¼Œè¿™ä¸ªæƒé™å€¼æ˜¯ä¸€ä¸ª 9-bit çš„æ•°æ®ï¼Œæ§åˆ¶æ–‡ä»¶å¦‚ä½•è¢« ownerã€owner's groupã€others ç­‰ç”¨æˆ·æˆ–ç”¨æˆ·ç»„è¿›è¡Œè¯»å–ã€å†™å…¥ã€æ‰§è¡Œã€‚æ¯ 3-bit æ§åˆ¶ä¸€ç±»ç”¨æˆ·æˆ–ç”¨æˆ·ç»„çš„è®¿é—®æƒé™ï¼Œæ€»å…±åˆšå¥½ä½¿ç”¨ 3 ä¸ªå…«è¿›æ•°å­—å°±å¯ä»¥è¡¨ç¤ºï¼Œä¾‹å¦‚ï¼Œ0755 ç»™ owner æŒ‡å®šè¯»å–ã€å†™å…¥ã€æ‰§è¡Œæƒé™ï¼Œè€Œç»™å…¶å®ƒç”¨æˆ·æŒ‡å®šè¯»å–ã€æ‰§è¡Œæƒé™ã€‚å³ 7 å’Œ 5 å¯¹åº”çš„äºŒè¿›åˆ¶ä¸º 111 å’Œ 101ï¼Œä»å·¦åˆ°å³ï¼Œå„ä¸ªæ¯”ç‰¹ä»£è¡¨è¯»å–ã€å†™å…¥ã€æ‰§è¡Œã€‚

æ–‡ä»¶çš„æƒé™ä¿¡æ¯å¯ä»¥ä½¿ç”¨ ls å‘½ä»¤æŸ¥çœ‹ï¼Œä½¿ç”¨ chmod å‘½ä»¤ä¿®æ”¹ï¼š

    $ ls -l
    -rw-r--r-- 1 jeango jeango   31 May  4 07:56 demo.sh
    ---------- - ------ ------ ---- ------------ -------
    ^          ^ ^      ^      ^    ^            ^
    |          | |      |      |    |            ç¬¬ä¸ƒåˆ—ï¼šæ–‡ä»¶å
    |          | |      |      |    ç¬¬å…­åˆ—ï¼šæ–‡ä»¶æœ€åæ›´æ–°ï¼ˆä¿®æ”¹ï¼‰æ—¶é—´
    |          | |      |      ç¬¬äº”åˆ—ï¼šæ–‡ä»¶é•¿åº¦ï¼ˆå¤§å°ï¼‰
    |          | |      ç¬¬å››åˆ—ï¼šæ–‡ä»¶çš„æ‰€å±ç”¨æˆ·ç»„ 
    |          | ç¬¬ä¸‰åˆ—ï¼šæ–‡ä»¶çš„æ‰€æœ‰è€… 
    |          ç¬¬äºŒåˆ—ï¼šä¸€ä¸ªæ•°å­—è¡¨ç¤ºæ–‡ä»¶ inode é“¾æ¥ä¸ªæ•°
    ç¬¬ä¸€åˆ—ï¼šæ–‡ä»¶ç±»å‹ã€å’Œæ–‡ä»¶æƒé™ï¼Œå¯¹åº” owner/group/others 

æ–‡ä»¶ç±»å‹ï¼Œå¤§ä½“åˆ†ä¸ºå¦‚ä¸‹å‡ ç±»ï¼š

- `d` ï¼šç›®å½• 
- `-` ï¼šæ–‡ä»¶ 
- `l` ï¼šé“¾æ¥ 
- `s` ï¼šsocket 
- `p` ï¼šnamed pipe 
- `b` ï¼šblock device 
- `c` ï¼šcharacter device

æ–‡ä»¶æƒé™åˆ†ä¸ºä¸‰æ®µï¼Œå¯¹åº”æ–‡ä»¶æ‰€æœ‰è€…çš„æƒé™ã€æ–‡ä»¶æ‰€å±ç»„çš„æƒé™ã€å’Œå…¶ä»–ç”¨æˆ·å¯¹æ–‡ä»¶çš„æƒé™ï¼Œæ¯ç»„æœ‰ 3 ä¸ªå­—ç¬¦è¡¨ç¤ºä¸åŒçš„æƒé™ï¼š

- `r` : Readable å¯è¯»ï¼Œç”¨æ•°å­— 4 è¡¨ç¤º
- `w` : Writable å¯å†™ï¼Œç”¨æ•°å­— 2 è¡¨ç¤º
- `x` : Executable å¯æ‰§è¡Œï¼Œç”¨æ•°å­— 1 è¡¨ç¤º
- `-` : æ— æƒé™ï¼Œç”¨æ•°å­— 0 è¡¨ç¤º

ä»¥ä¸‹æ˜¯ä¸€ä¸ªæ¼”ç¤ºç¨‹åºï¼Œå®ç°ä¸€ä¸ªç®€å•çš„ cp å‘½ä»¤ï¼Œå°†ä¸€ä¸ªæ–‡ä»¶å¤åˆ¶åˆ°å¦ä¸€ä¸ªæ–‡ä»¶ï¼Œå¹¶ä¸”ä¸å…è®¸ç¬¬äºŒä¸ªå‚æ•°æ˜¯ç›®å½•ï¼Œè®¾ç½®é»˜è®¤çš„è¯»å†™æƒé™ï¼Œè€Œä¸æ˜¯å¤åˆ¶æ–‡ä»¶çš„æƒé™ä¿¡æ¯ï¼š

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h> //"syscalls.h"
#include <error.h>
#include <errno.h>
#define PERMS 0666  /* RW for owner, group, others */

extern int errno;

// void error(char *, ...);

/* cp:  copy f1 to f2 */
int main(int argc, char *argv[])
{
    int f1, f2, n;
    char buf[BUFSIZ];

    if (argc != 3)
        perror("Usage: cp  from to");
    if ((f1 = open(argv[1], O_RDONLY, 0)) == -1)
        error(0, errno, "cp: can't open %s", argv[1]);
    if ((f2 = creat(argv[2], PERMS)) == -1)
        error(0, errno, "cp: can't create %s, mode %03o", argv[2], PERMS);
    while ((n = read(f1, buf, BUFSIZ)) > 0)
        if (write(f2, buf, n) != n)
            error(0, errno, "cp: write error on file %s", argv[2]);
    return 0;
}
```

åœ¨ Windows WSL ç³»ç»Ÿä¸­ï¼Œcreat å‡½æ•°å¯ä»¥æ­£ç¡®è®¾ç½® owner çš„æƒé™ï¼Œä½† group å’Œ all users çš„æƒé™ä¸­ä¸èƒ½è®¾ç½®å†™å…¥æƒé™ã€‚

ä½¿ç”¨ stat ç³»ç»Ÿè°ƒç”¨å¯ä»¥è·å–æ–‡ä»¶çš„ä¿¡æ¯ï¼Œè¿™æ ·å°±å¯ä»¥å¯¹æ–‡ä»¶çš„æƒé™è¿›è¡Œå¤åˆ¶ã€‚

æ³¨æ„ï¼Œerror è¿™ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œåœ¨ Unix ç³»ç»Ÿä¸Šï¼Œå®ƒå¾ˆåƒ printfï¼Œä»¥ä¸‹æ˜¯å‚è€ƒå®ç°ï¼š

```c
#include <stdio.h>
#include <stdarg.h>

/* error:  print an error message and die */
void error(char *fmt, ...)
{
   va_list args;

   va_start(args, fmt);
   fprintf(stderr, "error: ");
   vprintf(stderr, fmt, args);
   fprintf(stderr, "\n");
   va_end(args);
   exit(1);
}
```

åœ¨ Linux ç³»ç»Ÿä¸Šï¼Œerror ç³»åˆ—å‡½æ•°å®šä¹‰åœ¨ `<error.h>` å¤´æ–‡ä»¶ä¸­ï¼Œå¹¶ä¸”å‚æ•°åˆ—è¡¨ä¸åŒï¼Œå¯ä»¥æ‰“å° errnum å¯¹åº”çš„é”™è¯¯è¯´æ˜ä¿¡æ¯ã€‚å¦‚æœåªæ˜¯æ‰“å°ä¸€æ®µå­—ç¬¦ä¸²ï¼Œå¯ä»¥ä½¿ç”¨ `<stdio.h>` çš„å®šä¹‰ perror å‡½æ•°ã€‚åŒæ—¶ï¼Œä¸ºäº†è·å–é”™è¯¯ç ï¼Œéœ€è¦å¼•å…¥ `<errno.h>` æ ‡å‡†å¤´æ–‡ä»¶ï¼Œä½¿ç”¨å…¶å®šä¹‰çš„ errno å˜é‡ï¼Œåœ¨å„ç§æ“ä½œå‡ºç°é”™è¯¯æ—¶ï¼Œåº“å‡½æ•°ä¼šè®¾ç½®è¿™ä¸ªå˜é‡ä¸ºç›¸åº”çš„é”™è¯¯ç ï¼Œé…ç½® error å‡½æ•°å¯ä»¥å°†é”™è¯¯ä¿¡æ¯æ‰“å°å‡ºæ¥ï¼Œå‘ç”¨æˆ·æä¾›å‹å¥½çš„æç¤ºã€‚

```c
#include <stdio.h>
void perror(const char *s);

#include <error.h>
void error(int status, int errnum, const char *format, ...);
// ex: ./cp: cp: can't open test.js: Operation not permitted
```

ç³»ç»Ÿ API çš„å¸®åŠ©ä¿¡æ¯å¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤æ¥æŸ¥è¯¢ Linux Programmer's Manualï¼Œåœ¨æ–°ç‰ˆçš„ Ubuntu ç³»ç»Ÿä¸­é»˜è®¤å·²ç»å®‰è£…äº›æ–‡æ¡£ï¼š

```sh
# POSIX Programmer's Manual  =
apt install manpages-posix-dev
# Linux Programmer's Manual  =
sudo apt-get install manpages-dev

$ apropos "^error$"
$ man 3 error

$ man 3 "^printf$"
printf (1)           - format and print data
printf (1posix)      - write formatted output
printf (3)           - formatted output conversion
printf (3posix)      - print formatted output

$ apropos "^intro$"
intro (1)            - introduction to user commands
intro (2)            - introduction to system calls
intro (3)            - introduction to library functions
intro (4)            - introduction to special files
intro (5)            - introduction to file formats and filesystems
intro (6)            - introduction to games
intro (7)            - introduction to overview and miscellany section
intro (8)            - introduction to administration and privileged commands
```

man å‘½ä»¤çš„æ“ä½œç±»ä¼¼ vimï¼Œå¦‚ q è¡¨ç¤ºé€€å‡ºï¼Œ10G è·³åˆ°ç¬¬ 10 è¡Œï¼Œd å’Œ u åˆ†åˆ«æ˜¯å‘ä¸‹ã€å‘ä¸Šç¿»é¡µã€‚


åœ¨åŒä¸€ä¸ªç¨‹åºä¸­ï¼ŒåŒæ—¶æ‰“å¼€çš„æ–‡ä»¶æ•°é‡é€šå¸¸ä¸º 20 ä¸ªï¼Œéœ€è¦å¤„ç†å¤šæ–‡ä»¶çš„ç¨‹åºå°±éœ€è¦é‡ç”¨æ–‡ä»¶æè¿°ç¬¦ï¼Œä½¿ç”¨ close(int fd) æ¥æ–­å¼€æè¿°ç¬¦ä¸æ‰“å¼€çš„æ–‡ä»¶çš„å…³è”ï¼Œå¹¶é‡Šæ”¾æè¿°ç¬¦ä»¥ä¾›å…¶ä»–æ–‡ä»¶ä½¿ç”¨ã€‚å¯¹åº”çš„ C è¯­è¨€åº“å‡½æ•°æ˜¯ fcloseï¼Œåªæ˜¯æ²¡æœ‰ç¼“å†²åŒºçš„ flush æ“ä½œã€‚æ­£å¸¸çš„é€€å‡ºç¨‹åºï¼Œå¦‚ exit æˆ–ä¸»å‡½æ•°çš„ return éƒ½æœ‰åç»­çš„æ–‡ä»¶æ¸…ç†è¿‡ç¨‹ï¼Œæ‰“å¼€çš„æ–‡ä»¶ä¼šè¢«å…³é—­ã€‚

ç³»ç»Ÿè°ƒç”¨ `unlink(char *name)` ä¼šä»æ–‡ä»¶ç³»ç»Ÿä¸­ç§»é™¤æ–‡ä»¶ï¼Œå³åˆ é™¤ï¼Œå¯¹åº” C è¯­è¨€æ ‡å‡†åº“çš„ remove å‡½æ•°ã€‚ 

Exercise 8-1. Rewrite the program cat from Chapter 7 using read, write, open, and close instead of their standard library equivalents. Perform experiments to determine the relative speeds of the two versions. 


### ===ğŸ‘‰ Random Access - Lseek

é€šå¸¸ï¼Œè¾“å…¥è¾“å‡ºæ˜¯æŒ‰é¡ºåºå¤„ç†çš„ï¼Œå³æ¯æ¬¡è¯»å†™çš„æ•°æ®å°±æ˜¯æ–‡ä»¶å½“å‰ä½ç½®ã€‚åœ¨éœ€è¦çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥åœ¨æ–‡ä»¶çš„ä»»æ„ä½ç½®è¿›è¡Œè¯»å†™ï¼Œè¿™ç§æ“ä½œå«éšæœºè¯»å†™ã€‚

ç³»ç»Ÿè°ƒç”¨ lseek æä¾›äº†æ–¹æ³•ï¼Œå¯ä»¥åœ¨æ–‡ä»¶çš„æ•°æ®ä¸­å®šä½åˆ°ä»»æ„ä½ç½®è¿›è¡Œæ“ä½œï¼Œå‡½æ•°è¿”å›å€¼æ˜¯æ–‡ä»¶ä½ç½®ï¼Œå‡ºé”™æ—¶è¿”å› -1ï¼š

    long lseek(int fd, long offset, int origin);

å‚æ•°ä¸­ï¼ŒæŒ‡å®š offset ç›¸å¯¹ origin æŒ‡å®šä½ç½®çš„åç§»ä½ç½®ï¼ŒæŒ‰å­—èŠ‚æ•°è®¡ç®—ï¼Œåç»­çš„è¯»å†™ä¼šå¯¹æœ€æ–°çš„ä½ç½®æ“ä½œã€‚è®¾ç½® origin ä¸º 0, 1, 2 åˆ†åˆ«ä»£è¡¨ç›¸å¯¹æ–‡ä»¶å¼€å§‹ä½ç½®ã€å½“å‰ä½ç½®ã€ç»“æŸä½ç½®ã€‚

æ¯”å¦‚è¯´ï¼Œä»¥ append æ¨¡å¼æ‰“å¼€çš„æ–‡ä»¶ï¼Œæˆ–è€…ä½¿ç”¨ >> é‡å®šå‘å†™å…¥çš„æ–‡ä»¶ï¼Œå°±ä¼šæœ‰ä¸€ä¸ª seek æ“ä½œï¼Œå°†æ–‡ä»¶çš„ä½ç½®è®¾ç½®åœ¨å…¶ç»“æŸä½ç½®è¿›è¡Œå†™å…¥ï¼š

    lseek(fd, 0L, 2);

å¦‚æœï¼Œéœ€è¦é‡æ–°å›åˆ°æ–‡ä»¶å¼€å¤´ï¼Œä½¿ç”¨ C è¯­è¨€åº“çš„ `rewind` åº“å‡½æ•°ï¼Œæˆ–è€…ä»¥ä¸‹ç³»ç»Ÿè°ƒç”¨ï¼š 

    lseek(fd, 0L, 0);

ä½¿ç”¨ lseekï¼Œå¯ä»¥æˆ–å¤šæˆ–å°‘åœ°å°†æ–‡ä»¶è§†ä¸ºæ•°ç»„è¿›è¡Œæ“ä½œï¼Œä½†ä»£ä»·æ˜¯è®¿é—®é€Ÿåº¦è¾ƒæ…¢ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢çš„å‡½æ•°ä»æ–‡ä»¶ä¸­çš„ä»»æ„ä½ç½®è¯»å–ä»»æ„æ•°é‡çš„å­—èŠ‚ï¼Œå®ƒè¿”å›è¯»å–çš„æ•°å­—ï¼Œå‡ºé”™æ—¶è¿”å› -1ã€‚

```c
#include "syscalls.h"

/*get:  read n bytes from position pos */
int get(int fd, long pos, char *buf, int n)
{
   if (lseek(fd, pos, 0) >= 0) /* get to pos */
       return read(fd, buf, n);
   else
       return -1;
}
```

C è¯­è¨€æ ‡å‡†åº“ä¸­å‡½æ•° fseek å’Œ lseek ç±»ä¼¼ï¼Œåªæ˜¯ç¬¬ä¸€ä¸ªå‚æ•°ä¸º FILE æŒ‡é’ˆï¼Œå¹¶ä¸”è¿”å›éé›¶å€¼è¡¨ç¤ºé”™è¯¯ã€‚


### ===ğŸ‘‰ Example - An implementation of Fopen and Getc

æ•™ææœ€åä¸€ç« æœ‰ä¸‰ä¸ªç¤ºèŒƒï¼Œå®ƒä»¬å æ®å­è¿‡åŠçš„å†…å®¹ï¼Œè¿™å‡ ä¸ªç¤ºèŒƒç¨‹åºä¹Ÿæ˜¯æ¯”è¾ƒé‡è¦çš„åŸºç¡€è®­ç»ƒã€‚

ç¬¬ä¸€ä¸ªä¾‹å­æ˜¯å®ç°åˆ©ç”¨ç³»ç»Ÿè°ƒç”¨æ¥å®ç°æ–‡ä»¶æ‰“å¼€å‡½æ•°ï¼Œå¹¶è¯»å–å†…å®¹ï¼Œåƒ C è¯­è¨€åº“å‡½æ•° fopen å’Œ getc é‚£æ ·ã€‚

å‰é¢å·²ç»ä½¿ç”¨äº†æ ‡å‡†åº“çš„æ–‡ä»¶æŒ‡é’ˆï¼Œå®ƒå’Œç³»ç»Ÿè°ƒç”¨ä¸­çš„æ–‡ä»¶æè¿°ç¬¦å°±æ˜¯æŒ‡é’ˆä¸æ•´æ•°ä¹‹é—´çš„å·®åˆ«ï¼Œè€Œæ–‡ä»¶æŒ‡é’ˆæŒ‡å‘ä¸€ä¸ªåŒ…å«æ–‡ä»¶ä¿¡æ¯çš„ç»“æ„ä½“ï¼š

- ä¸€ä¸ªç¼“å­˜åŒºæŒ‡é’ˆï¼Œç”¨æ¥è¯»å†™å¤§å—çš„æ•°æ®ï¼›
- ä¸€ä¸ªè®°æ•°å˜é‡ï¼ŒæŒ‡ç¤ºç¼“å†²åŒºè¿˜æœ‰å¤šå°‘æ•°æ®ï¼›
- ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘ç¼“å­˜åŒºä¸‹ä¸€ä¸ªå¾…å¤„ç†å­—ç¬¦åœ°å€ï¼›
- ä¸€ä¸ªæ ‡è¯†å˜é‡ï¼Œæè¿°æ–‡ä»¶çš„è¯»å†™æ¨¡å¼ï¼Œé”™è¯¯çŠ¶æ€ç­‰ç­‰ï¼›
- ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼›

ç»“æ„ä½“å®šä¹‰åœ¨ `<stdio.h>`ï¼Œä»¥ä¸‹ä¸ºæ‘˜å½•çš„ä»£ç ç‰‡æ–­ï¼Œåº“å‡½æ•°ä½¿ç”¨çš„åç§°ä»¥ä¸‹åˆ’çº¿å¼€å¤´ï¼Œè¡¨ç¤ºå®ƒä»¬æ˜¯å†…éƒ¨ä½¿ç”¨çš„ï¼Œä½¿ç”¨ä¸‹åˆ’çº¿ä»¥é¿å…å’Œç”¨æˆ·ç¨‹åºä¸­çš„åç§°å‘ç”Ÿå†²çªï¼Œæ‰€æœ‰æ ‡å‡†åº“ä¾‹ç¨‹éƒ½ä½¿ç”¨æ­¤çº¦å®šã€‚

```c
#define NULL      0
#define EOF       (-1)
#define BUFSIZ    1024
#define OPEN_MAX  20    /* max #files open at once */

typedef struct _iobuf {
   int  cnt;       /* characters left */
   char *ptr;      /* next character position */
   char *base;     /* location of buffer */
   int  flag;      /* mode of file access */
   int  fd;        /* file descriptor */
} FILE;
extern FILE _iob[OPEN_MAX];

#define stdin   (&_iob[0])
#define stdout  (&_iob[1])
#define stderr  (&_iob[2])

enum _flags {
   _READ   = 01,   /* file open for reading */
   _WRITE  = 02,   /* file open for writing */
   _UNBUF  = 04,   /* file is unbuffered */
   _EOF    = 010,  /* EOF has occurred on this file */
   _ERR    = 020   /* error occurred on this file */
};

int _fillbuf(FILE *);
int _flushbuf(int, FILE *);

#define feof(p)     ((p)->flag & _EOF) != 0)
#define ferror(p)   ((p)->flag & _ERR) != 0)
#define fileno(p)   ((p)->fd)

#define getc(p)   (--(p)->cnt >= 0 \
              ? (unsigned char) *(p)->ptr++ : _fillbuf(p))
#define putc(x,p) (--(p)->cnt >= 0 \
              ? *(p)->ptr++ = (x) : _flushbuf((x),p))

#define getchar()   getc(stdin)
#define putcher(x)  putc((x), stdout)
```

å®å®šä¹‰ getc æ­£å¸¸åœ°é€’å‡ countï¼Œå°†æŒ‡é’ˆåç§»åˆ°ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶è¿”å›å½“å‰æŒ‡å‘çš„å­—ç¬¦ï¼Œæ— ç¬¦å·å€¼ç±»å‹ã€‚æ³¨æ„ï¼Œåæ–œæ è¡¨ç¤ºç»­è¡Œï¼Œæ•´ä¸ªè¡¨è¾¾å¼å°±æ˜¯ä¸€ä¸ªä¸‰å…ƒè¿ç®—ç¬¦ã€‚å¦‚æœ count ä¸ºè´Ÿå€¼ï¼Œå°±ä¼šè°ƒç”¨ `_fillbuf` è¡¥å……ç¼“å†²åŒºçš„å†…å®¹ï¼Œé‡æ–°åˆå§‹åŒ–ç»“æ„å†…å®¹å¹¶è¿”å›ä¸€ä¸ªå­—ç¬¦ã€‚

ç±»ä¼¼åœ°ï¼Œputc å®šä¹‰çš„å®è¯­å¥çš„æ“ä½œæ–¹å¼ä¸ getc åŸºæœ¬ç›¸åŒï¼Œå³åœ¨ç¼“å†²åŒºå·²æ»¡æ—¶è°ƒç”¨å‡½æ•° `_flushbuf`ã€‚å¦å¤–ï¼Œè¿˜åŒ…æ‹¬ç”¨äºè®¿é—®é”™è¯¯ã€æ–‡ä»¶ç»“æŸçŠ¶æ€ï¼Œä»¥åŠæ–‡ä»¶æè¿°ç¬¦çš„å®ã€‚

ç°åœ¨ï¼Œå¯ä»¥ç¼–å†™ fopen å‡½æ•°äº†ï¼Œå®ƒå¤§éƒ¨åˆ†åŠŸèƒ½æ˜¯å°†æ–‡ä»¶æ‰“å¼€å¹¶å®šä½åˆ°æ­£ç¡®çš„ä½ç½®ï¼Œå¹¶è®¾ç½®æ ‡å¿—ä½ä»¥æŒ‡ç¤ºæ­£ç¡®çš„çŠ¶æ€ã€‚fopen ä¸åˆ†é…ä»»ä½•ç¼“å†²ç©ºé—´ï¼Œè¿™ä¼šåœ¨ç¬¬ä¸€æ¬¡è¯»å–æ–‡ä»¶æ—¶ç”± `_fillbuf` è®¾ç½®ã€‚

```c
#include <fcntl.h>
#include "syscalls.h"
#define PERMS 0666    /* RW for owner, group, others */

FILE *fopen(char *name, char *mode)
{
   int fd;
   FILE *fp;

   if (*mode != 'r' && *mode != 'w' && *mode != 'a')
       return NULL;
   for (fp = _iob; fp < _iob + OPEN_MAX; fp++)
       if ((fp->flag & (_READ | _WRITE)) == 0)
           break;        /* found free slot */
   if (fp >= _iob + OPEN_MAX)   /* no free slots */
       return NULL;

   if (*mode == 'w')
       fd = creat(name, PERMS);
   else if (*mode == 'a') {
       if ((fd = open(name, O_WRONLY, 0)) == -1)
           fd = creat(name, PERMS);
       lseek(fd, 0L, 2);
   } else
       fd = open(name, O_RDONLY, 0);
   if (fd == -1)         /* couldn't access name */
       return NULL;
   fp->fd = fd;
   fp->cnt = 0;
   fp->base = NULL;
   fp->flag = (*mode == 'r') ? _READ : _WRITE;
   return fp;
}
```

è¿™ä¸ªç‰ˆæœ¬çš„ fopen æ²¡æœ‰å¤„ç†æ‰€æœ‰è®¿é—®æ¨¡å¼ï¼Œæ¯”å¦‚ binary æ¨¡å¼ï¼Œè¿™ç§æ¨¡å¼å¯¹ UNIX ç³»ç»Ÿæ˜¯æ²¡æœ‰ç‰¹åˆ«å«æ„çš„ï¼Œä½†ä¹Ÿä¸éœ€å¾ˆå¤šä»£ç æ¥å®ç°ã€‚è¿˜æœ‰ `+` è¡¨ç¤ºè¯»å†™æ¨¡å¼ï¼Œä¹Ÿæ²¡æœ‰æ”¯æŒã€‚

è¯»å–æ–‡ä»¶çš„ç¬¬ä¸€ä¸ª getc è°ƒç”¨é‡åˆ° count ä¸ºé›¶ï¼Œåˆ™å¼ºåˆ¶æ‰§è¡Œ `_fillbuf`ï¼Œå¦‚æœæ–‡ä»¶ä¸æ˜¯è¯»å–æ¨¡å¼åˆ™è¿”å› EOFï¼Œå¦åˆ™å°è¯•åˆ†é…ç¼“å†²åŒºè¯»å–å†…å®¹ã€‚

ä¸€æ—¦ç¼“å†²åŒºå»ºç«‹ï¼Œ`_fillbuf` è°ƒç”¨ read æ–¹æ³•è¯»å–æ•°æ®å¡«å……å®ƒï¼Œå¹¶è®¾ç½® count ä¸ºç›¸åº”çš„å­—èŠ‚æ•°ï¼Œä»¥åŠæŒ‡é’ˆï¼Œå¹¶ä¸”å°†ç¬¬ä¸€ä¸ªå­—èŠ‚è¿”å›ã€‚åç»­çš„ `_fillbuf` è°ƒç”¨ä¼šåœ¨ç¼“å†²åŒºä¸­è·å–å†…å®¹ã€‚

```c
#include "syscalls.h"

/* _fillbuf:  allocate and fill input buffer */
int _fillbuf(FILE *fp)
{
   int bufsize;

   if ((fp->flag&(_READ|_EOF|_ERR)) != _READ)
       return EOF;
   bufsize = (fp->flag & _UNBUF) ? 1 : BUFSIZ;
   if (fp->base == NULL)     /* no buffer yet */
       if ((fp->base = (char *) malloc(bufsize)) == NULL)
           return EOF;       /* can't get buffer */
   fp->ptr = fp->base;
   fp->cnt = read(fp->fd, fp->ptr, bufsize);
   if (--fp->cnt < 0) {
       if (fp->cnt == -1)
           fp->flag |= _EOF;
       else
           fp->flag |= _ERR;
       fp->cnt = 0;
       return EOF;
   }
   return (unsigned char) *fp->ptr++;
}
```

æœ€åå‰©ä¸‹çš„å”¯ä¸€æ‚¬è€Œæœªå†³çš„äº‹æƒ…ï¼Œå°±æ˜¯è®¾ç½®é»˜è®¤çš„æ ‡å‡†è¾“å…¥è¾“å‡ºæ–‡ä»¶ï¼Œå¿…é¡»ä¸º stdinã€stdout å’Œ stderr å®šä¹‰æ•°ç»„ iob å¹¶åˆå§‹åŒ–ï¼Œä»¥ä¾›ç¨‹åºçš„æ­£å¸¸ä½¿ç”¨ï¼š

```c
FILE _iob[OPEN_MAX] = {    /* stdin, stdout, stderr */
   { 0, (char *) 0, (char *) 0, _READ, 0 },
   { 0, (char *) 0, (char *) 0, _WRITE, 1 },
   { 0, (char *) 0, (char *) 0, _WRITE, | _UNBUF, 2 }
};
```

åˆå§‹åŒ–åˆ—è¡¨ä¸­ï¼Œstdin å®šä¹‰ä¸ºåªè¯»ï¼Œstdout å®šä¹‰ä¸ºåªå†™ï¼Œè€Œ stderr å®šä¹‰ä¸ºåªå†™ä¸”ä¸ä½¿ç”¨ç¼“å†²åŒºï¼Œå®ƒä»¬å¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦ä¸º 0ã€1ã€2ã€‚

åˆ°è¿™é‡Œï¼Œä¸€ä¸ªå®Œæ•´çš„ç¨‹åºç»“æ„æ¡†æ¶å·²ç»å®Œå…¨è§£æé€å½»ï¼Œä½†æ˜¯è¿˜æœ‰æ›´å¤šæ›´æœ‰æ·±åº¦çš„æŠ€æœ¯ç­‰ç€ä½ å»æ¢ç´¢ï¼Œè¿™åŒ…æ‹¬ C è¯­è¨€æ ‡å‡†åº“ï¼Œè¿˜æœ‰ï¼Œå¦‚æœè¦åŸºäº Linux å¹³å°å¼€å‘ï¼Œéœ€è¦ç ”ç©¶ Linux ç¼–ç¨‹ç¯å¢ƒã€‚

æœ¬å°èŠ‚è®¾ç½®äº†ä¸‰ä¸ªç»ƒä¹ ï¼š

- 8-2. ä½¿ç”¨å­—æ®µè€Œé bit æ“ä½œé‡å†™ `fopen` å’Œ `_fillbuf`ï¼Œæ¯”è¾ƒä¸¤ç§å®ç°çš„é€Ÿåº¦ä¸ä»£ç å¤§å°ã€‚
- 8-3. è®¾è®¡å®ç° `_flushbuf`, `fflush`, `fclose` ä¸‰ä¸ªåº“å‡½æ•°ã€‚
- 8-4. æ ‡å‡†åº“çš„ fseek å’Œç³»ç»Ÿè°ƒç”¨ lseek å·®åˆ«åœ¨äº FILE æŒ‡é’ˆå’Œæ–‡ä»¶æè¿°ç¬¦ï¼Œå¹¶ä¸”åº“å‡½æ•°è¿”å›çš„æ˜¯çŠ¶æ€å€¼ä¸æ˜¯ä½ç½®ï¼Œé‡å†™å®ç°ä¸€ä¸ª fseekï¼Œç¡®ä¿ä¸å…¶å®ƒåº“å‡½æ•°çš„ç¼“å†²åŒºåè°ƒè‰¯å¥½ã€‚

```c
int fseek(FILE *fp, long offset, int origin)
```

### ===ğŸ‘‰ Example - Listing Directories

è·å–ç›®æ ‡ç»“æ„ä¿¡æ¯æ˜¯å¸¸ç”¨çš„æ–‡ä»¶ç³»ç»Ÿäº¤äº’åŠŸèƒ½ï¼Œè¿™æ—¶å¹¶ä¸éœ€è¦å…³å¿ƒæ–‡ä»¶åŒ…å«ä»€ä¹ˆå†…å®¹ã€‚æ¯”å¦‚ï¼Œls å‘½ä»¤ï¼Œå°±æ˜¯åŸºäºç›®æ ‡ç»“æ„ä¿¡æ¯çš„ä¸€ä¸ªå·¥å…·ï¼Œå®ƒåªéœ€çŸ¥é“ç›®å½•ä¸­æœ‰ä»€ä¹ˆæ–‡ä»¶ï¼Œä»¥åŠæ–‡ä»¶çš„æƒé™ã€å¤§å°ç­‰ä¿¡æ¯ã€‚åœ¨ MS-DOS ç³»ç»Ÿä¸­ï¼Œä¹Ÿæœ‰ç±»ä¼¼çš„ dir å‘½ä»¤ã€‚

ç”±äº UNIX ç³»ç»Ÿå°†ç›®æ ‡ä¹Ÿçœ‹ä½œæ˜¯æ–‡ä»¶ï¼Œls åªæ˜¯è¯»å–æ–‡ä»¶çš„åå­—ã€‚ä½†åœ¨è®¿é—®æœ‰å…³æ–‡ä»¶çš„å…¶ä»–ä¿¡æ¯ï¼Œå¦‚æ–‡ä»¶å¤§å°æ—¶ï¼Œä½¿ç”¨ç³»ç»Ÿè°ƒç”¨æ˜¯å¿…éœ€çš„ã€‚åœ¨å…¶ä»–ç³»ç»Ÿä¸Šï¼Œç”šè‡³è®¿é—®æ–‡ä»¶åä¹Ÿå¯èƒ½éœ€è¦ç³»ç»Ÿè°ƒç”¨ï¼Œä¾‹å¦‚ MS-DOS å°±æ˜¯è¿™æ ·ã€‚æˆ‘ä»¬æƒ³è¦çš„æ˜¯ä»¥ç›¸å¯¹ç‹¬ç«‹äºç³»ç»Ÿçš„æ–¹å¼æä¾›æ–‡ä»¶ä¿¡æ¯çš„è®¿é—®ï¼Œå³ä½¿å®ç°å¯èƒ½é«˜åº¦ä¾èµ–äºç³»ç»Ÿã€‚

é€šè¿‡ç¼–å†™ä¸€ä¸ªåä¸º fsize çš„ç¨‹åºæ¥è¯´æ˜è¿™ä¸€ç‚¹ï¼Œè¿™æ˜¯ ls çš„ä¸€ç§ç‰¹æ®Šå½¢å¼ï¼Œå®ƒæ‰“å°å‘½ä»¤è¡Œå‚æ•°åˆ—è¡¨ä¸­æŒ‡å®šçš„æ‰€æœ‰å‘½åæ–‡ä»¶çš„å¤§å°ã€‚å¦‚æœå…¶ä¸­ä¸€ä¸ªæ–‡ä»¶æ˜¯ç›®å½•ï¼Œåˆ™ fsize å°†è‡ªå·±é€’å½’åœ°åº”ç”¨äºè¯¥ç›®å½•ï¼Œå¦‚æœæ ¹æœ¬æ²¡æœ‰å‚æ•°ï¼Œå®ƒå°†å¤„ç†å½“å‰ç›®å½•ã€‚

å›é¡¾ä¸€ä¸‹ UNIX æ–‡ä»¶ç³»ç»Ÿç»“æ„ï¼Œç›®å½•æ˜¯ä¸€ä¸ªåŒ…å«æ–‡ä»¶ååˆ—è¡¨å’Œå®ƒä»¬æ‰€åœ¨ä½ç½®æŒ‡ç¤ºã€‚location åªæ˜¯ä¸€ä¸ªåä¸º inode list çš„è¡¨çš„ç´¢å¼•å·ã€‚æ–‡ä»¶çš„ inode ä¿å­˜äº†é™¤æ–‡ä»¶åä»¥å¤–çš„æ‰€æœ‰æ–‡ä»¶ä¿¡æ¯ã€‚ä¸€ä¸ªç›®å½•æ¡ç›®é€šå¸¸åªåŒ…å«ä¸¤é¡¹ï¼Œæ–‡ä»¶åå’Œç´¢å¼•èŠ‚ç‚¹å· inode numberã€‚

é—æ†¾çš„æ˜¯ï¼Œåœ¨æ‰€æœ‰ UNIX ç‰ˆæœ¬ç³»ç»Ÿä¸­ï¼Œç›®å½•çš„æ ¼å¼å’Œç²¾ç¡®å†…å®¹å¹¶ä¸ç›¸åŒã€‚å› æ­¤ï¼Œå°†ä»»åŠ¡åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œè¯•å›¾éš”ç¦»ä¸å¯ç§»æ¤çš„éƒ¨åˆ†ã€‚å¤–å±‚å®šä¹‰äº†ä¸€ä¸ªåä¸º Dirent çš„ç»“æ„å’Œä¸‰ä¸ªä¾‹ç¨‹ opendirã€readdirã€closedirï¼Œä»¥æä¾›å¯¹ç›®å½•é¡¹ä¸­çš„åç§°å’ŒèŠ‚ç‚¹ç¼–å·çš„ç‹¬ç«‹äºç³»ç»Ÿçš„è®¿é—®ã€‚æˆ‘ä»¬å°†ç”¨è¿™ä¸ªæ¥å£ç¼–å†™ fsizeï¼Œç„¶åï¼Œå±•ç¤ºå¦‚ä½•åœ¨ Version 7 å’Œ System V UNIX ä½¿ç”¨ç›¸åŒç›®å½•ç»“æ„çš„ç³»ç»Ÿä¸Šå®ç°è¿™äº›åŠŸèƒ½ï¼Œå˜ä½“ä½œä¸ºç»ƒä¹ ç•™ä¸‹ã€‚

Dirent ç»“æ„åŒ…å« inode ç¼–å·å’Œåç§°ã€‚æ–‡ä»¶åç»„ä»¶çš„æœ€å¤§é•¿åº¦æ˜¯ NAME_MAXï¼Œè¿™æ˜¯ä¸€ä¸ªä¾èµ–äºç³»ç»Ÿçš„å€¼ã€‚opendir è¿”å›ä¸€ä¸ªæŒ‡å‘åä¸º DIR çš„ç»“æ„çš„æŒ‡é’ˆï¼Œç±»ä¼¼äº FILEï¼Œreaddir å’Œ closedir ä¸¤ä¸ªå‡½æ•°éœ€è¦ä½¿ç”¨å®ƒã€‚è¿™äº›ä¿¡æ¯è¢«æ”¶é›†åˆ°ä¸€ä¸ªåä¸º dirent.h çš„æ–‡ä»¶ä¸­ã€‚

```c
#define NAME_MAX   14  /* longest filename component; */
                              /* system-dependent */

typedef struct {       /* portable directory entry */
   long ino;                  /* inode number */
   char name[NAME_MAX+1];     /* name + '\0' terminator */
} Dirent;

typedef struct {       /* minimal DIR: no buffering, etc. */
   int fd;               /* file descriptor for the directory */
   Dirent d;             /* the directory entry */
} DIR;

DIR *opendir(char *dirname);
Dirent *readdir(DIR *dfd);
void closedir(DIR *dfd);
```

ç³»ç»Ÿè°ƒç”¨ stat æ¥æ”¶ä¸€ä¸ªæ–‡ä»¶åï¼Œå®ƒé€šè¿‡ç»“æ„ä½“è¿”å›æŒ‡å®šæ–‡ä»¶åœ¨ inode æ•°æ®è¡¨ä¸­çš„æ‰€æœ‰ä¿¡æ¯ï¼Œæˆ–è€…è¿”å› -1 å¦‚æœå‡ºé”™ã€‚ç»“æ„ä½“å®šä¹‰åœ¨ `<sys/stat.h>`ï¼Œå‚è€ƒå¦‚ä¸‹ã€‚

```c
char *name;
struct stat stbuf;
int stat(char *, struct stat *);

stat(name, &stbuf);

struct stat   /* inode information returned by stat */
{
   dev_t     st_dev;      /* device of inode */
   ino_t     st_ino;      /* inode number */
   short     st_mode;     /* mode bits */
   short     st_nlink;    /* number of links to file */
   short     st_uid;      /* owners user id */
   short     st_gid;      /* owners group id */
   dev_t     st_rdev;     /* for special files */
   off_t     st_size;     /* file size in characters */
   time_t    st_atime;    /* time last accessed */
   time_t    st_mtime;    /* time last modified */
   time_t    st_ctime;    /* time originally created */
};
```

ä»¥ä¸Šæ˜¾ç¤ºçš„ stat æ˜¯å¸¸ç”¨çš„å­—æ®µï¼Œå­—æ®µç±»å‹ï¼Œå¦‚ dev_t æˆ– ino_t å®šä¹‰åœ¨ `<sys/types.h>`ã€‚

æ¨¡å¼å­—æ®µ st_mode åŒ…å«ä¸€ç³»ç»Ÿæ ‡å¿—ä½ï¼ŒåŒ…æ‹¬æ–‡ä»¶çš„ç±»å‹å’Œæƒé™ï¼ŒåŒ…æ‹¬è¯»å†™åŠæ‰§è¡Œæƒé™è®¾ç½®ã€‚å„æ ‡å¿—ä½å®šä¹‰åœ¨ `<sys/types.h>`ï¼Œç°åœ¨åªéœ€è¦æ–‡ä»¶ç±»å‹çš„å®šä¹‰ï¼Œå³å…¶ä¸­çš„ 3-bit æ•°æ®ï¼š

```c
/* Encoding of the file mode.  */
#define __S_IFMT    0170000 /* These bits determine file type.  */

/* File types.  */
#define __S_IFDIR   0040000 /* Directory.  */
#define __S_IFSOCK  0140000 /* Socket.  */
#define __S_IFLNK   0120000 /* Symbolic link.  */
#define __S_IFREG   0100000 /* Regular file.  */
#define __S_IFBLK   0060000 /* Block device.  */
#define __S_IFCHR   0020000 /* Character device.  */
#define __S_IFIFO   0010000 /* FIFO(named pipe).  */
/* ... */
```

ç°åœ¨å°±æ¥å®ç° fsize ç¨‹åºï¼Œå¦‚æœæ¥æ”¶åˆ°çš„å‚æ•°æ˜¯ä¸€ä¸ªæ–‡ä»¶è€Œä¸æ˜¯ç›®å½•ï¼Œå°±ç›´æ¥æ‰“å°æ–‡ä»¶çš„å¤§å°ã€‚å¦‚æœï¼Œæ˜¯ä¸€ä¸ªç›®å½•ï¼Œå°±éœ€è¦å¯¹ç›®å½•ä¸‹çš„ä¸€ä¸ªä¸ªæ–‡ä»¶åˆ†åˆ«è¿›è¡Œå¤„ç†ã€‚

ä¸»å‡½æ•°è´Ÿè´£å¯¹å‚æ•°è¿›è¡Œæ£€æŸ¥ï¼Œå¹¶æŒ‰ç›¸åº”çš„å‚æ•°è¿›è¡Œå¤„ç†ã€‚

```c
#include <stdio.h>
#include <string.h>
#include "syscalls.h"
#include <fcntl.h>      /* flags for read and write */
#include <sys/types.h>  /* typedefs */
#include <sys/stat.h>   /* structure returned by stat */
#include "dirent.h"

void fsize(char *)

/* print file name */
main(int argc, char **argv)
{
   if (argc == 1)  /* default: current directory */
       fsize(".");
   else
       while (--argc > 0)
           fsize(*++argv);
   return 0;
}
```

ç„¶åï¼Œåœ¨ fsize å‡½æ•°ä¸­æ‰“å°æ–‡ä»¶å¤§å°ä¿¡æ¯ï¼Œå¦‚æœæ˜¯ä¸€ä¸ªç›®å½•ï¼Œå°±äº¤ç»™ dirwalk å‡½æ•°è¿›è¡Œé€’å½’å¤„ç†ã€‚åˆ¤æ–­æ–‡ä»¶æ˜¯å¦ä¸ºç›®å½•ï¼Œéœ€è¦é€šè¿‡æ ‡å¿—ä½ S_IFMT å’Œ S_IFDIR çš„æ¯”ç‰¹ä½è¿ç®—å¾—åˆ°ã€‚æ³¨æ„ä½¿ç”¨åœ†æ‹¬å·ï¼Œå› ä¸ºæ¯”ç‰¹ä½çš„è¿ç®—ç¬¦å· & ä¼˜å…ˆçº§ä½äº == å…³ç³»è¿ç®—ç¬¦ã€‚ 

```c
int stat(char *, struct stat *);
void dirwalk(char *, void (*fcn)(char *));

/* fsize:  print the name of file "name" */
void fsize(char *name)
{
   struct stat stbuf;

   if (stat(name, &stbuf) == -1) {
       fprintf(stderr, "fsize: can't access %s\n", name);
       return;
   }
   if ((stbuf.st_mode & S_IFMT) == S_IFDIR)
       dirwalk(name, fsize);
   printf("%8ld %s\n", stbuf.st_size, name);
}
```

è°ƒç”¨ dirwalk å‡½æ•°æ—¶ï¼Œä¸€å¹¶ä¼ é€’ fsize å‡½æ•°æŒ‡é’ˆï¼Œåœ¨å…¶å†…éƒ¨è¿›è¡Œè°ƒç”¨ï¼Œå¦‚æœæ˜¯å­ç›®å½•ï¼Œåˆ™ fsize ä¼šå†æ¬¡é€’å½’åœ°è°ƒç”¨ dirwalkï¼Œç›´åˆ°è¿™ä¸¤ä¸ªå‡½æ•°äº¤æ›¿åœ°å¤„ç†å®Œæ‰€æœ‰æ–‡ä»¶ã€‚

```c
#define MAX_PATH 1024

/* dirwalk:  apply fcn to all files in dir */
void dirwalk(char *dir, void (*fcn)(char *))
{
   char name[MAX_PATH];
   Dirent *dp;
   DIR *dfd;

   if ((dfd = opendir(dir)) == NULL) {
       fprintf(stderr, "dirwalk: can't open %s\n", dir);
       return;
   }
   while ((dp = readdir(dfd)) != NULL) {
       if (strcmp(dp->name, ".") == 0 || strcmp(dp->name, ".."))
           continue;    /* skip self and parent */
       if (strlen(dir)+strlen(dp->name)+2 > sizeof(name))
           fprintf(stderr, "dirwalk: name %s %s too long\n", dir, dp->name);
       else {
           sprintf(name, "%s/%s", dir, dp->name);
           (*fcn)(name);
       }
   }
   closedir(dfd);
}
```

æ¯æ¬¡è°ƒç”¨ readdir è¿”å›åŒ…å«æ–‡ä»¶ä¿¡æ¯çš„ DIR ç»“æ„ä½“æŒ‡é’ˆï¼Œæˆ–è€… NULL å¦‚æœæ²¡æœ‰æ›´å¤šçš„æ–‡ä»¶ã€‚

æ¯ä¸ªç›®å½•éƒ¨åˆ†åŒ…å«ä¸¤ä¸ªç‰¹æ®Šçš„ç›®å½•ï¼Œä¸€ä¸ªæ˜¯è‡ªèº«å³ "."ï¼Œå¦ä¸€ä¸ªæ˜¯ä¸Šçº§ç›®å½•å³ ".."ï¼Œå¤„ç†æ—¶åº”è¯¥è·³è¿‡ï¼Œå¦åˆ™ç¨‹åºå°±æ˜¯æ­»å¾ªç¯ã€‚

åˆ°æœ€åä¸€å±‚ï¼Œä»£ç ä¾èµ–äº†ç³»ç»Ÿç»„ç»‡ç›®å½•çš„æ ¼å¼ï¼Œè¿™é‡Œä¸º Version 7 æˆ– System V UNIX ç³»ç»Ÿå®ç°æœ€ç®€å•çš„ opendir, readdir, closedir ç­‰å‡½æ•°ï¼Œopendir è·å–æ–‡ä»¶æè¿°ç¬¦ï¼Œç„¶åç”± readdir è¯»å–ç›®å½•çš„ inode ç´¢å¼•å·å’Œç›®å½•åã€‚ä½¿ç”¨åˆ°äº† `<sys/dir.h>` å®šä¹‰çš„ç›®å½•ç»“æ„ä½“ç±»å‹ï¼Œä¹Ÿå°±æ˜¯å‰é¢å®šä¹‰çš„ Direntï¼š

```c
#ifndef DIRSIZ
#define DIRSIZ  14
#endif
struct direct {   /* directory entry */
   ino_t d_ino;           /* inode number */
   char  d_name[DIRSIZ];  /* long name does not have '\0' */
};
```

è¿™é‡Œçš„ ino_t æ˜¯ç±»å‹åˆ«åï¼Œä¸€äº›ç³»ç»Ÿä¸­å®šä¹‰ä¸º unsigned shortï¼Œä½†åœ¨åµŒå…¥å¼ç³»ç»Ÿä¸­å¯èƒ½æ˜¯ä¸åŒçš„ç±»å‹ï¼Œå®Œæ•´çš„ç³»ç»Ÿç±»å‹å®šä¹‰åœ¨ `<sys/types.h>`ã€‚

å‡½æ•° opendir ä¼šå…ˆç¡®è®¤æ–‡ä»¶æ˜¯ä¸€ä¸ªç›®å½•ï¼Œå†å°†è·å–åˆ°çš„æ–‡ä»¶æè¿°ç¬¦é€šè¿‡ DIR ç»“æ„ä½“è¿”å›ç”¨ç”¨æˆ·ã€‚æ³¨æ„ï¼Œè¿™é‡Œä½¿ç”¨çš„æ˜¯ fstat ç³»ç»Ÿè°ƒç”¨ï¼Œå®ƒé€šè¿‡æ–‡ä»¶æè¿°ç¬¦æ¥è·å–æ–‡ä»¶ä¿¡æ¯ï¼Œå’Œ stat å‡½æ•°æœ‰äº›å·®åˆ«ã€‚

```c
int fstat(int fd, struct stat *);

/* opendir:  open a directory for readdir calls */
DIR *opendir(char *dirname)
{
   int fd;
   struct stat stbuf;
   DIR *dp;

   if ((fd = open(dirname, O_RDONLY, 0)) == -1
    || fstat(fd, &stbuf) == -1
    || (stbuf.st_mode & S_IFMT) != S_IFDIR
    || (dp = (DIR *) malloc(sizeof(DIR))) == NULL)
        return NULL;
   dp->fd = fd;
   return dp;
}

/* closedir:  close directory opened by opendir */
void closedir(DIR *dp)
{
   if (dp) {
       close(dp->fd);
       free(dp);
   }
}
```

æœ€åæ˜¯ readdir å‡½æ•°ï¼Œå®ƒè´Ÿè´£è¯»å–ç›®å½•çš„åç§°ä¿¡æ¯ï¼Œè°ƒç”¨ read è¯»å–ç›®å½•æ–‡ä»¶ã€‚å¦‚å‰é¢æ‰€è§£æçš„ UNIX ç›®å½•æ–‡ä»¶çš„ç»“æ„ï¼Œå®ƒå°±ä¸€ä¸ª inode listï¼Œæ¯ä¸ªå®ä½“å°±æ˜¯åŒ…å«ä¸€ä¸ª inode ç´¢å¼•å·å’Œæ–‡ä»¶åçš„ç»“æ„ã€‚å¦‚æœä¸€ä¸ªå®ä½“æ ‡è®°ä¸ºå·²ç»ä»ç³»ç»Ÿä¸­ç§»é™¤ï¼Œå³å½“å‰çš„ directory slot å¹¶æ²¡ä½¿ç”¨ï¼Œé‚£ä¹ˆ inode ç´¢å¼•å·å°±ä¼šè®¾ç½®ä¸º 0ï¼Œé‚£ä¹ˆå°±åº”è¯¥è·³è¿‡è¿™ä¸ªè®°å½•ã€‚å…¶å®ƒæœ‰æ•ˆçš„å®ä½“éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ inode ç´¢å¼•å·ç å’Œæ–‡ä»¶åå­—ã€‚è¿™äº›ä¿¡æ¯å­˜å‚¨åœ¨ä¸€ä¸ªå±€éƒ¨é™æ€å˜é‡ä¸­ï¼Œæ¯æ¬¡è¯»å–ç›®å½•æ—¶è¢«è¦†ç›–ã€‚

```c
#include <sys/dir.h>   /* local directory structure */

/* readdir:  read directory entries in sequence */
Dirent *readdir(DIR *dp)
{
   struct direct dirbuf;  /* local directory structure */
   static Dirent  d;      /* return: portable structure */

   while (read(dp->fd, (char *) &dirbuf, sizeof(dirbuf))
                   == sizeof(dirbuf)) {
       if (dirbuf.d_ino == 0) /* slot not in use */
           continue;
       d.ino = dirbuf.d_ino;
       strncpy(d.name, dirbuf.d_name, DIRSIZ);
       d.name[DIRSIZ] = '\0';  /* ensure termination */
       return &d;
   }
   return NULL;
}
```

å°½ç®¡è¿™é‡Œå®ç°çš„ fsize ç¨‹åºæ˜¯é’ˆå¯¹ä¸“ç”¨ç³»ç»Ÿçš„ï¼Œä½†æ˜¯å®ƒæ¼”ç¤ºäº†å‡ ä¸ªé‡è¦çš„æ¦‚å¿µã€‚é¦–å…ˆï¼Œå¾ˆå¤šç¨‹åºå¹¶éç³»ç»Ÿç¨‹åºï¼Œå®ƒä»¬åªä½¿ç”¨ç”±æ“ä½œç³»ç»Ÿç»´æŠ¤çš„ä¿¡æ¯ã€‚å¯¹äºè¿™æ ·çš„ç¨‹åºï¼Œåªé€šè¿‡æ ‡å‡†å¤´æ–‡ä»¶æä¾›ä¿¡æ¯æ˜¯è‡³å…³é‡è¦çš„ï¼Œå¹¶ä¸”ç¨‹åºåŒ…æ‹¬é‚£äº›å¤´ï¼Œè€Œä¸æ˜¯å°†å£°æ˜åµŒå…¥å®ƒä»¬è‡ªå·±ã€‚ç¬¬äºŒï¼Œå°å¿ƒåœ°åˆ›å»ºä¸€ä¸ªä¸ç³»ç»Ÿç›¸å…³çš„å¯¹è±¡çš„æ¥å£æ˜¯å¯èƒ½çš„ï¼Œè¯¥å¯¹è±¡æœ¬èº«ç›¸å¯¹ç‹¬ç«‹äºç³»ç»Ÿã€‚

æ ‡å‡†åº“çš„åŠŸèƒ½å°±æ˜¯å¾ˆå¥½çš„ä¾‹å­ã€‚

Exercise 8-5. ä¿®æ”¹ fsize ç¨‹åºï¼Œæ‰“å° inode entry çš„å…¶å®ƒä¿¡æ¯ã€‚ 


### ===ğŸ‘‰ Example - A Storage Allocator
- CS326 - Project 3: Memory Allocator https://www.cs.usfca.edu/~mmalensek/cs326/assignments/project-3.html
- Computer Systems: A Programmer's Perspective 2nd https://book4you.org/book/2190090/f10e21
- Computer Systems: A Programmer's Perspective 3rd Global Edition https://book4you.org/book/3639970/7cae39
- Operating Systems: Three Easy Pieces https://book4you.org/book/5231653/f66f3d
- Extreme C: Taking You To The Limit In Concurrency, OOP, And The Most Advanced Capabilities Of C https://book4you.org/book/5280897/0e0ca6
- Operating Systems: Principles and Practice 2nd, Vol. 1 - 4, Kernels and Processes, Concurrency, Memory Management, Persistent Storage
- ç¨‹åºå‘˜çš„æ•°å­¦ ç»“åŸæµ© https://www.bilibili.com/read/cv7583920/
- What Every Programmer Should Know About Memory Ulrich Drepper https://www.asc.tuwien.ac.at/~schoeberl/wiki/lva/seminar11/cpumemory.pdf
- Memory management: Algorithms and implementation in C/C++ Bill Blunden https://book4you.org/book/459114/5840d1
- A Memory Allocator by Doug Lea http://gee.cs.oswego.edu/dl/html/malloc.html
- mimalloc https://github.com/microsoft/mimalloc

åœ¨å‰é¢çš„ Chapter 5 å®ç°äº†ä¸€ä¸ªåŸºäº Stack çš„ç®€å•å†…å­˜åˆ†é…å™¨ï¼Œåªå®ç°äº†æœ‰æœ€åŸºæœ¬çš„åŠŸèƒ½ï¼Œè€Œä¸”è°ƒç”¨é¡ºåºä¹Ÿæ˜¯åç”³è¯·å…ˆé‡Šæ”¾ï¼Œä¹Ÿæ²¡æœ‰ä½¿ç”¨ä»€ä¹ˆå¤æ‚çš„åˆ†é…ç®—æ³•ã€‚

ç°åœ¨è¦å®ç°ä¸å—è°ƒç”¨é¡ºåºé™åˆ¶çš„ malloc å’Œ free ç‰ˆæœ¬ï¼Œåœ¨å¿…è¦æ—¶é€šè¿‡ malloc å‘æ“ä½œç³»ç»Ÿç”³è¯·è·å–æ›´å¤šå†…å­˜ã€‚ä¾‹ç¨‹è¯´æ˜äº†ä»¥ç›¸å¯¹ç‹¬ç«‹äºæœºå™¨çš„æ–¹å¼ç¼–å†™ä¾èµ–äºæœºå™¨çš„ä»£ç æ—¶æ‰€æ¶‰åŠçš„ä¸€äº›æ³¨æ„äº‹é¡¹ï¼Œè¿˜å±•ç¤ºäº†ç»“æ„ã€è”åˆå’Œ typedef çš„å®é™…åº”ç”¨ã€‚

åŠ¨æ€å†…å­˜åˆ†é…ç®—æ³•ä»‹ç»ï¼š

- é¦–æ¬¡é€‚åº”ç®—æ³• First Fit
    - ä¼˜ç‚¹ï¼šé«˜å€éƒ¨åˆ†çš„å¤§çš„ç©ºé—²åˆ†åŒºå¾—åˆ°ä¿ç•™ï¼Œä¸ºå¤§ä½œä¸šçš„å†…å­˜åˆ†é…åˆ›é€ äº†æ¡ä»¶ï¼›
    - ç¼ºç‚¹ï¼šæ¯æ¬¡éƒ½æ˜¯ä¼˜å…ˆåˆ©ç”¨ä½å€éƒ¨åˆ†çš„ç©ºé—²åŒºï¼Œäº§ç”Ÿå¤§é‡çš„ç¢ç‰‡ã€‚æ¯æ¬¡éƒ½ä»ä½å€éƒ¨åˆ†æŸ¥æ‰¾ï¼Œä½¿å¾—æŸ¥æ‰¾ç©ºé—²åˆ†åŒºçš„å¼€é”€å¢å¤§ã€‚
- å¾ªç¯é¦–æ¬¡é€‚åº”ç®—æ³• Next Fit
    - ä¼˜ç‚¹ï¼šç©ºé—²åˆ†åŒºåˆ†å¸ƒæ›´åŠ å‡åŒ€ï¼ŒæŸ¥æ‰¾å¼€é”€å°ï¼›
    - ç¼ºç‚¹ï¼šé«˜å€éƒ¨åˆ†çš„å¤§ç©ºé—²åˆ†åŒºè¢«åˆ†å°ï¼Œä½¿å¾—å¤§ä½œä¸šè¿›å…¥æ— æ³•åˆ†é…å†…å­˜ï¼›
- æœ€ä½³é€‚åº”ç®—æ³• Best Fit
    - ä¼˜ç‚¹ï¼šæ‰¾åˆ°çš„ç©ºé—²åˆ†åŒºæ˜¯å¤§å°æœ€æ¥è¿‘å¾…åˆ†é…å†…å­˜ä½œä¸šå¤§å°çš„ï¼›
    - ç¼ºç‚¹ï¼šäº§ç”Ÿå¤§é‡éš¾ä»¥åˆ©ç”¨çš„å¤–éƒ¨ç¢ç‰‡ã€‚
- æœ€åé€‚åº”ç®—æ³• Worst Fit
    - ä¼˜ç‚¹ï¼šæ•ˆç‡é«˜ï¼Œåˆ†åŒºæŸ¥æ‰¾æ–¹ä¾¿ï¼›
    - ç¼ºç‚¹ï¼šå½“å°ä½œä¸šæŠŠå¤§ç©ºé—²åˆ†åŒºåˆ†å°äº†ï¼Œé‚£ä¹ˆï¼Œå¤§ä½œä¸šå°±æ‰¾ä¸åˆ°åˆé€‚çš„ç©ºé—²åŒºã€‚

Next Fit ç®—æ³•åˆ†é…å†…å­˜æ—¶ï¼Œä¸æ˜¯ä»é“¾é¦–è¿›è¡ŒæŸ¥æ‰¾ç©ºé—²å†…å­˜ï¼Œè€Œæ˜¯ä»ä¸Šä¸€æ¬¡åˆ†é…å†…å­˜çš„ä¸‹ä¸€ä¸ªä½ç½®å¼€å§‹æŸ¥æ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°åˆé€‚çš„ç©ºé—²å†…å­˜ã€‚

Worst Fit ç®—æ³•ä¸æœ€ä½³é€‚åº”ç®—æ³•åˆšå¥½ç›¸åï¼Œå°†ç©ºé—²åˆ†åŒºé“¾çš„åˆ†åŒºæŒ‰ç…§ä»å¤§åˆ°å°çš„é¡ºåºæ’åºå½¢æˆç©ºé—²åˆ†åŒºé“¾ï¼Œæ¯æ¬¡æŸ¥æ‰¾æ—¶åªè¦çœ‹ç¬¬ä¸€ä¸ªç©ºé—²åˆ†åŒºæ˜¯å¦æ»¡è¶³å³å¯ã€‚

è¿ç»­åˆ†é…æ–¹å¼æ˜¯æœ€æ—©å‡ºç°çš„ä¸€ç§å­˜å‚¨å™¨åˆ†é…æ–¹å¼ï¼Œ æ›¾è¢«å¹¿æ³›åº”ç”¨äºä¸Šä¸–çºª 60 ~ 80 å¹´ä»£ï¼Œè¯¥åˆ†é…ä¸‡å¼ä¸ºä¸ªç”¨æˆ·ç¨‹åºåˆ†é…ä¸€ä¸ªè¿ç»­çš„å†…å­˜ç©ºé—´ï¼Œ å³ç¨‹åºä¸­ä»£ç æˆ–æ•°æ®çš„é€»è¾‘åœ°å€ç›¸é‚»ï¼Œä½“ç°åœ¨å†…å­˜ç©ºé—´åˆ†é…æ—¶ç‰©ç†åœ°å€çš„ç›¸é‚»ã€‚

ä¸åƒä¹‹å‰ä½¿ç”¨é¢„ç¼–è¯‘çš„å›ºå®šå¤§å°çš„æ•°ç»„ï¼Œä½¿ç”¨ malloc ç›´æ¥å‘æ“ä½œç³»ç»Ÿç”³è¯·å†…å­˜ã€‚åŒæ—¶ï¼Œå…¶å®ƒç¨‹åºä¹Ÿä¼šç”³è¯·å†…å­˜ï¼Œæ‰€ä»¥ï¼Œå®ç°è¿™ä¸ªå†…å­˜åˆ†é…å™¨å°±è¦è€ƒè™‘å†…å­˜ä¸å¯èƒ½è¿ç»­çš„é—®é¢˜ï¼Œå¹¶ä¸”éœ€è¦é€šè¿‡é“¾è¡¨æ¥ç®¡ç†å·²åˆ†é…çš„å†…å­˜å—ï¼Œæ¯ä¸ªå—åŒ…æ‹¬å¤§å°ã€åœ°å€ã€å’Œä¸‹ä¸€å—æŒ‡é’ˆã€‚æŒ‰åœ°å€å€¼æ’åˆ—ï¼Œæœ€åä¸€ä¸ªå—æŒ‡å‘å¼€å¤´å—ï¼Œå½¢æˆä¸€ä¸ªç¯å½¢é“¾è¡¨ã€‚

æ¥æ”¶å†…å­˜ç”³è¯·æ—¶ï¼Œmalloc å‡½æ•°æ‰«æç©ºé—²åˆ—è¡¨ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€å—è¶³å¤Ÿå¤§çš„å†…å­˜å—ï¼Œè¿™ç§ç®—æ³•å«åš first fitã€‚ä¸ä¹‹å¯¹åº”çš„æ˜¯æœ€ä½³é€‚ç”¨ç®—æ³• best fitï¼Œå®ƒæŸ¥åˆ°ç¬¦åˆè¦æ±‚çš„æœ€å°å—ã€‚æƒ³åˆ°åŒ¹é…çš„å†…å­˜å—åï¼Œå°±å°†é“¾è¡¨å¯¹åº”çš„èŠ‚ç‚¹è„±ç¦»å‡ºæ¥ï¼Œå¹¶ä¸”å°†åœ°å€è¿”å›ç»™ç”¨æˆ·ã€‚å¦‚æœå†…å­˜å—å¤ªå¤§ï¼Œå°±è¿›è¡Œåˆ†å‰²ï¼Œè¿”å›åˆé€‚çš„å¤§å°ç»™ç”¨æˆ·ï¼Œéƒ¨åˆ†åŠä¿ç•™åœ¨ç©ºé—´åˆ—è¡¨ä¸­ã€‚å¦‚æœæ‰¾ä¸åˆ°è¶³å¤Ÿå¤§çš„å—ï¼Œåˆ™å‘æ“ä½œç³»ç»Ÿç”³è¯·å¦ä¸€ä¸ªå¤§å—å¹¶é“¾æ¥åˆ°ç©ºé—²åˆ—è¡¨ä¸­ã€‚

é‡Šæ”¾è¿‡ç¨‹æœ‰ä¸€ä¸ªæœç´¢ç©ºé—²åˆ—è¡¨çš„åŠ¨ä½œï¼Œä»¥æ‰¾åˆ°æ­£ç¡®ä½ç½®æ’å…¥è¢«é‡Šæ”¾å—ã€‚å¦‚æœè¢«é‡Šæ”¾çš„å—ä¸ä»»ä¸€ä¾§çš„ä¸€ä¸ªç©ºé—²å—ç›¸é‚»ï¼Œå®ƒå°†ä¸ä¹‹åˆå¹¶æˆä¸€ä¸ªæ›´å¤§çš„å—ï¼Œå› æ­¤å­˜å‚¨ä¸ä¼šå˜å¾—å¤ªé›¶ç¢ã€‚ç¡®å®šé‚»æ¥å…³ç³»å¾ˆå®¹æ˜“ï¼Œå› ä¸ºè‡ªç”±åˆ—è¡¨æ˜¯æŒ‰åœ°å€é€’å‡çš„é¡ºåºç»´æŠ¤çš„ã€‚

åœ¨ç¬¬ 5 ç« ä¸­æåˆ°çš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œç¡®ä¿ malloc è¿”å›çš„å­˜å‚¨ä¸å°†å­˜å‚¨åœ¨å…¶ä¸­çš„å¯¹è±¡æ­£ç¡®å¯¹é½ã€‚å°½ç®¡æœºå™¨å„ä¸ç›¸åŒï¼Œä½†æ¯å°æœºå™¨éƒ½æœ‰ä¸€ç§é™åˆ¶æ€§æœ€å¼ºçš„ç±»å‹ï¼šå¦‚æœé™åˆ¶æ€§æœ€å¼ºçš„ç±»å‹å¯ä»¥å­˜å‚¨åœ¨ç‰¹å®šçš„åœ°å€ï¼Œé‚£ä¹ˆæ‰€æœ‰å…¶ä»–ç±»å‹ä¹Ÿå¯ä»¥ã€‚åœ¨æŸäº›æœºå™¨ä¸Šï¼Œæœ€ä¸¥æ ¼çš„ç±»å‹æ˜¯ doubleï¼Œé€šå¸¸å…¶ä»–æƒ…å†µä¸‹ï¼Œint æˆ– long å°±è¶³å¤Ÿäº†ã€‚

ç©ºé—²å—åŒ…å«æŒ‡å‘é“¾è¡¨ä¸‹ä¸€ä¸ªå—çš„æŒ‡é’ˆã€å—å¤§å°çš„è®°å½•ï¼Œç„¶åæ˜¯ç©ºé—²ç©ºé—´åœ°å€ã€‚å¼€å¤´çš„æ§åˆ¶ä¿¡æ¯ç§°ä¸º headerï¼Œä¸ºäº†ç®€åŒ–å¯¹é½ï¼Œæ‰€æœ‰å—éƒ½æ˜¯ header å¤§å°çš„å€æ•°ï¼Œå¹¶ä¸”æ­£ç¡®å¯¹é½ headerã€‚è¿™æ˜¯é€šè¿‡ä¸€ä¸ªè”åˆæ¥å®ç°çš„ï¼Œè¯¥è”åˆåŒ…å«æ‰€éœ€çš„å¤´ç»“æ„å’Œä¸€ä¸ªé™åˆ¶æœ€ä¸¥æ ¼çš„å¯¹é½ç±»å‹çš„å®ä¾‹ã€‚

```c
typedef long Align;    /* for alignment to long boundary */

union header {         /* block header */
   struct {
       union header *ptr; /* next block if on free list */
       unsigned size;     /* size of this block */
   } s;
   Align x;           /* force alignment of blocks */
};

typedef union header Header;
```

ç»“æ„ä½“ä¸­çš„ Align å­—æ®µä»…ä½œä¸ºå¯¹é½ä½¿ç”¨ï¼Œå¼ºåˆ¶æ¯ä¸ª header ç»“æ„ä½“åœ¨æœ€åæƒ…å†µä¸‹çš„è¾¹ç•Œä¸Šå¯¹é½ 4 å­—èŠ‚è¾¹ç•Œã€‚

è€Œå…¶ä¸­ size å­—æ®µåˆ™æ˜¯å¿…éœ€çš„ï¼Œå› ä¸ºå†…å­˜åˆ†é…å¹¶ä¸è¿ç»­ï¼Œåœ¨é‡Šæ”¾å†…å­˜æ—¶ï¼Œéœ€è¦é€šè¿‡å®ƒæ¥è®¡ç®—å†…å­˜ç©ºé—´çš„å¤§å°ã€‚

åœ¨ malloc å‡½æ•°å®ç°ä¸­ï¼Œç”³è¯·çš„å†…å­˜ç©ºé—´ä¼šå‘ä¸Šå– header å¤§å°çš„æ•´æ•°å€ï¼Œè¦åˆ†é…çš„å—åŒ…å«ä¸€ä¸ªä»¥ä¸Šçš„å•å…ƒï¼Œå…¶ä¸­ä¸€ä¸ªå•å…ƒç”¨äºè®°å½• header ç»“æ„æœ¬èº«ï¼ŒåŒ…æ‹¬ size å­—æ®µä¸­è®°å½•çš„å€¼ã€‚malloc è¿”å›çš„æŒ‡é’ˆæŒ‡å‘å¯ç”¨ç©ºé—´ï¼Œè€Œä¸æ˜¯ header æœ¬èº«ã€‚ç”¨æˆ·å¯ä»¥å¯¹è¯·æ±‚çš„ç©ºé—´æ‰§è¡Œä»»ä½•æ“ä½œï¼Œä½†å¦‚æœåœ¨åˆ†é…çš„ç©ºé—´ä¹‹å¤–å†™å…¥ä»»ä½•å†…å®¹ï¼Œåˆ™åˆ—è¡¨å¯èƒ½ä¼šè¢«æ‰“ä¹±ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªå†…å­˜å—çš„ç»“æ„ï¼Œå…¶ä¸­ ptr å’Œ size å°±æ˜¯ header çš„ä¸¤ä¸ªæˆå‘˜ï¼š

    Memory Blockï¼š
    +=========================+
    | ptr | size | free space | 
    +=========================+
    +----Align---+
 
å˜é‡ base ç”¨æ¥è®°å½•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œåœ¨æœªå¼€å§‹åˆ†é…å†…å­˜æ—¶ï¼Œfreep æŒ‡é’ˆä¸º NULLã€‚åœ¨é¦–æ¬¡æ¥æ”¶å†…å­˜ç”³è¯·æ—¶è®¾ç½® freep æŒ‡é’ˆï¼Œå®ƒåŒ…å«ä¸€ä¸ªå¤§å°ä¸ºé›¶çš„å—ï¼Œå’Œä¸€ä¸ªæŒ‡é’ˆå¹¶æŒ‡å‘è‡ªèº«ã€‚

åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œéƒ½ä¼šæœç´¢ç©ºé—²åˆ—è¡¨ï¼Œæœç´¢ä»æ‰¾åˆ°æœ€åä¸€ä¸ªå—çš„æŒ‡é’ˆ freep å¼€å§‹ï¼Œç›´åˆ°æ‰¾åˆ°è¶³å¤Ÿå¤§å°çš„ç©ºé—²å—ã€‚æ³¨æ„ for å¾ªç¯åé¢çš„æ¡ä»¶åˆ¤æ–­ï¼Œå¦‚æœå½“å‰ç©ºé—²åˆ—è¡¨æ²¡æœ‰ç©ºé—²å—ï¼Œåˆ™é€šè¿‡ morecore å‘æ“ä½œç³»ç»Ÿç”³è¯·å†…å­˜ï¼Œå¹¶é€šè¿‡ free æ·»åŠ åˆ°ç©ºé—´åˆ—è¡¨ä¸­ï¼Œåœ¨ä¸‹æ¬¡å¾ªç¯æ—¶è¿›è¡Œå¤„ç†ã€‚è¿™ç§ç­–ç•¥æœ‰åŠ©äºä¿æŒåˆ—è¡¨çš„ä¸€è‡´æ€§ï¼Œå¦‚æœå‘ç°å—å¤ªå¤§ï¼Œåˆ™å°†å°¾éƒ¨è¿”å›ç»™ç”¨æˆ·ï¼Œè¿™æ ·ï¼ŒåŸå—åªéœ€è¦è°ƒæ•´å¤§å°å³å¯ã€‚åœ¨æ‰€æœ‰æƒ…å†µä¸‹ï¼Œè¿”å›ç»™ç”¨æˆ·çš„æŒ‡é’ˆéƒ½æŒ‡å‘å—ä¸­çš„å¯ç”¨ç©ºé—´ï¼Œè¯¥ç©ºé—´ä» header ä»¥å¤–çš„ä¸€ä¸ªå•å…ƒå¼€å§‹ã€‚

```c
static Header base;       /* empty list to get started */
static Header *freep = NULL;     /* start of free list */

/* malloc:  general-purpose storage allocator */
void *malloc(unsigned nbytes)
{
   Header *p, *prevp;
   Header *moreroce(unsigned);
   unsigned nunits;

   nunits = (nbytes+sizeof(Header)-1)/sizeof(header) + 1;
   if ((prevp = freep) == NULL) {   /* no free list yet */ 
       base.s.ptr = freeptr = prevptr = &base;
       base.s.size = 0;
   }
   for (p = prevp->s.ptr; ; prevp = p, p = p->s.ptr) {
       if (p->s.size >= nunits) {  /* big enough */
           if (p->s.size == nunits)  /* exactly */
               prevp->s.ptr = p->s.ptr;
           else {              /* allocate tail end */
               p->s.size -= nunits;
               p += p->s.size;
               p->s.size = nunits;
           }
           freep = prevp;
           return (void *)(p+1);
       }
       if (p == freep)  /* wrapped around free list */
           if ((p = morecore(nunits)) == NULL)
               return NULL;    /* none left */
   }
}
```

å‡½æ•° morecore ç”¨æ¥ä»æ“ä½œç³»ç»Ÿä¸­è·å–å­˜å‚¨ç©ºé—´ï¼Œæ ¹æ®ä¸åŒçš„ç³»ç»Ÿä¼šæœ‰ä¸åŒçš„å®ç°ã€‚ç”±äºç›´æ¥å‘æ“ä½œç³»ç»Ÿç”³è¯·å†…å­˜æ˜¯ä¸€ä¸ªç›¸å¯¹ä½æ•ˆè¿‡ç¨‹ï¼Œå› æ­¤è¦å°½é‡é¿å…ä½¿ç”¨ã€‚

æ‰€ä»¥ morecore è‡³å°‘è¦æ±‚ç”³è¯· NALLOC å•ä½æ‰ä¼šæ‰§è¡Œï¼Œè¿™ä¸ªå¤§å—å¤´ä¼šæ ¹æ®éœ€è¦è¢«åˆ‡ç¢ã€‚è®¾ç½® size å­—æ®µåï¼Œmorecore é€šè¿‡è°ƒç”¨ free å°†é¢å¤–çš„å†…å­˜æ’å…¥ç©ºé—²é“¾è¡¨ä¸­ã€‚

UNIX ç³»ç»Ÿè°ƒç”¨ sbrk(n) è¿”å›æŒ‡å‘ n ä¸ªå­—èŠ‚ä»¥ä¸Šçš„å†…å­˜æŒ‡é’ˆï¼Œè¿”å› -1 è¡¨ç¤ºæ²¡æœ‰ç©ºé—´ï¼Œå³ä½¿ NULL å¯èƒ½æ˜¯æ›´å¥½çš„è®¾è®¡ã€‚å¿…é¡»å°† -1 è½¬æ¢ä¸º char æŒ‡é’ˆï¼Œä»¥ä¾¿ä¸è¿”å›å€¼è¿›è¡Œæ¯”è¾ƒã€‚åŒæ ·ï¼Œå¼ºåˆ¶è½¬æ¢ä½¿å‡½æ•°ç›¸å¯¹ä¸å—ä¸åŒæœºå™¨ä¸ŠæŒ‡é’ˆè¡¨ç¤ºç»†èŠ‚çš„å½±å“ã€‚

```c
#include <unistd.h>
int brk(void *addr);
void *sbrk(intptr_t increment);

#include <sys/time.h>
#include <sys/resource.h>
int getrlimit(int resource, struct rlimit *rlim);
int setrlimit(int resource, const struct rlimit *rlim);
int prlimit(pid_t pid, int resource, const struct rlimit *new_limit, struct rlimit *old_limit);
```

ä½¿ç”¨ä»¥ä¸‹ Linux å‘½ä»¤æŸ¥è¯¢æ–‡æ¡£ï¼š

    $ apropos brk
    brk (2)              - change data segment size
    sbrk (2)             - change data segment size
    strpbrk (3)          - search a string for any of a set of bytes
    strpbrk (3posix)     - scan a string for a byte
    wcspbrk (3)          - search a wide-character string for any of a set of wide characters
    wcspbrk (3posix)     - scan a wide-character string for a wide-character code
    $ man 2 brk

åœ¨ä¸€ä¸ªç¨‹åºåŠ è½½åœ¨å†…å­˜åï¼Œè¿™ä¸ªç¨‹åºåœ¨å†…å­˜é€»è¾‘åœ°å€çš„å½±åƒæŒ‰ä½åœ°å€åˆ°é«˜åœ°å€åˆ†å¸ƒç€ text segmentã€data segmentã€bss segment å’Œ heap ç­‰åˆ†æ®µã€‚ bss å³ Block Started by Symbol è¡¨ç¤ºæœªè¿›è¡Œåˆå§‹çš„æ•°æ®æ®µï¼Œè€Œ program break æ˜¯æŒ‡ç´§æ¥å…¶åçš„ heap å†…å­˜æ®µï¼Œè°ƒç”¨æ“ä½œç³»ç»Ÿæä¾›çš„ brk æˆ– sbrk ä¼šæ”¹å˜ program breakï¼Œéšç€ç”³è¯·å†…å­˜å’Œé‡Šæ”¾å†…å­˜åŠ¨æ€åœ°è°ƒç”¨ã€‚

- `brk()` è®¾ç½®æ•°æ®æ®µä¸ºæŒ‡å®šçš„åœ°å€å€¼ï¼Œåªè¦ä¿è¯ç³»ç»Ÿæœ‰è¶³å¤Ÿçš„å†…å­˜èµ„æºï¼Œå¹¶ä¸”æœ€å¸¸è§çš„æœ‰è¶…è¿‡è¿›ç¨‹èµ„æºé™åˆ¶ï¼Œå‚è€ƒç³»ç»Ÿè°ƒç”¨ setrlimit(2) æˆ– ulimit å‘½ä»¤ã€‚
- `sbrk()` å¢åŠ ç¨‹åºçš„æ•°æ®æ®µç©ºé—´ï¼ŒæŒ‡å®šå­—èŠ‚æ•°ï¼Œé€šè¿‡æŒ‡å®š 0 å­—èŠ‚å¯ä»¥æŸ¥è¯¢åˆ°å½“å‰çš„ program break ä½ç½®ã€‚

æ³¨æ„ï¼Œbss å’Œ heap æ˜¯ä¸ç›¸é‚»çš„ï¼Œå®ƒä»¬æœ‰ä¸€ä¸ªéšæœºçš„é—´éš”ï¼Œå¹¶ä¸”åŒä¸€ä¸ªç¨‹åº bss çš„ç»“æŸåœ°å€ç¼–è¯‘æœŸå°±å›ºå®šï¼Œè€Œ heap çš„èµ·å§‹åœ°å€åœ¨æ¯æ¬¡è¿è¡Œçš„æ—¶å€™éƒ½ä¼šæ”¹å˜ã€‚ç¨‹åºå¼€å§‹è¿è¡Œæ—¶ heap çš„å¤§å°æ˜¯ 0ï¼Œæ‰€ä»¥èµ·å§‹åœ°å€å’Œç»“æŸåœ°å€æ˜¯ä¸€æ ·çš„ã€‚å¯ä»¥é€šè¿‡ brk(n) æ¥è®¾ç½®èµ·ç‚¹ï¼Œè®¾ç½®ä¸ºå½“å‰çš„ heap åœ°å€å‡å»ä¸€ä¸ªåç§»ï¼Œåªè¦è¿™ä¸ªåç§»ä¸è¶…å‡ºéšæœºé—´éš”çš„ç©ºé—´ã€‚

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int bss_end;
#define SIZE 0x2000

void heapLocation(){
    void * tret = sbrk(0);
    if (tret != (void *)-1)
        printf ("heap start: %p ", tret);
    int r = brk((char*)tret-SIZE);
    printf("brk(%p):%d %p\n", (char*)tret-SIZE, r, sbrk(0));
}
int main(void)
{
    printf("bss end: %p\n", (char *)(&bss_end) + 4);
    heapLocation();
    void *m = malloc(SIZE);
    heapLocation();
}
```

ç„¶è€Œï¼Œä»ç„¶æœ‰ä¸€ä¸ªå‡è®¾ï¼Œå³ sbrk è¿”å›çš„æŒ‡å‘ä¸åŒå—çš„æŒ‡é’ˆå¯ä»¥è¿›è¡Œæœ‰æ„ä¹‰çš„æ¯”è¾ƒã€‚è¯­è¨€æ ‡å‡†ä¸èƒ½ä¿è¯è¿™ä¸€ç‚¹ï¼Œå› ä¸ºå®ƒåªå…è®¸åœ¨æ•°ç»„ä¸­è¿›è¡ŒæŒ‡é’ˆæ¯”è¾ƒã€‚å› æ­¤ï¼Œè¿™ä¸ªç‰ˆæœ¬çš„ malloc åªèƒ½åœ¨é€šç”¨æŒ‡é’ˆæ¯”è¾ƒæœ‰æ„ä¹‰çš„æœºå™¨ä¹‹é—´ç§»æ¤ã€‚

```c
#define NALLOC  1024   /* minimum #units to request */

/* morecore:  ask system for more memory */
static Header *morecore(unsigned nu)
{
   char *cp, *sbrk(int);
   Header *up;

   if (nu < NALLOC)
       nu = NALLOC;
   cp = sbrk(nu * sizeof(Header));
   if (cp == (char *) -1)   /* no space at all */
       return NULL;
   up = (Header *) cp;
   up->s.size = nu;
   free((void *)(up+1));
   return freep;
}
```

é‡Šæ”¾å†…å­˜æœ¬èº«æ˜¯æœ€åä¸€ä»¶äº‹ï¼Œä¹Ÿå¯ä»¥å°†å®ƒç†è§£ä¸ºç©ºé—²å†…å­˜å—çš„æ³¨å†Œå‡½æ•°ã€‚å®ƒæ‰«æç©ºé—²é“¾è¡¨ï¼Œä» freep å¼€å§‹ï¼Œå¯»æ‰¾æ’å…¥ç©ºé—²å—çš„ä½ç½®ï¼Œæ³¨æ„å®ƒæ˜¯ä¸€ä¸ªå•å‘å¾ªç¯é“¾è¡¨ç»“æ„ã€‚å®ƒè¦ä¹ˆåœ¨ä¸¤ä¸ªç°æœ‰å—ä¹‹é—´ï¼Œè¦ä¹ˆåœ¨åˆ—è¡¨çš„æœ«å°¾ã€‚åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œå¦‚æœè¢«é‡Šæ”¾çš„å—ä¸ä»»ä¸€ç›¸é‚»å—ç›¸é‚»ï¼Œåˆ™ç›¸é‚»å—è¢«åˆå¹¶ã€‚å”¯ä¸€çš„é—®é¢˜æ˜¯ä¿æŒæŒ‡é’ˆæŒ‡å‘æ­£ç¡®çš„åœ°å€ã€æ­£ç¡®çš„å¤§å°ã€‚

```c
/* free:  put block ap in free list */
void free(void *ap)
{
   Header *bp, *p;

   bp = (Header *)ap - 1;    /* point to  block header */
   for (p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
        if (p >= p->s.ptr && (bp > p || bp < p->s.ptr))
            break;  /* freed block at start or end of arena */

   if (bp + bp->size == p->s.ptr) {    /* join to upper nbr */
       bp->s.size += p->s.ptr->s.size;
       bp->s.ptr = p->s.ptr->s.ptr;
   } else
       bp->s.ptr = p->s.ptr;
   if (p + p->size == bp) {            /* join to lower nbr */
       p->s.size += bp->s.size;
       p->s.ptr = bp->s.ptr;
   } else
       p->s.ptr = bp;
   freep = p;
}
```

å°½ç®¡ï¼Œå­˜å‚¨åˆ†é…æœ¬è´¨ä¸Šä¾èµ–äºæœºå™¨ï¼Œä½†ä¸Šé¢çš„ä»£ç è¯´æ˜äº†å¦‚ä½•æ§åˆ¶æœºå™¨ä¾èµ–æ€§ï¼Œå¹¶å°†å…¶é™åˆ¶åœ¨ç¨‹åºçš„ä¸€å°éƒ¨åˆ†ä¸­ã€‚typedef å’Œ union çš„ç”¨æ¥å¤„ç†å†…å­˜å¯¹é½ï¼Œå‡è®¾ sbrk æä¾›äº†é€‚å½“çš„æŒ‡é’ˆã€‚å¼ºåˆ¶è½¬æ¢ä½¿æŒ‡é’ˆè½¬ç±»å‹æ¢æ˜¾å¼åŒ–ï¼Œç”šè‡³å¯ä»¥å¤„ç†è®¾è®¡ç³Ÿç³•çš„ç³»ç»Ÿæ¥å£ã€‚å°½ç®¡è¿™é‡Œçš„ç»†èŠ‚ä¸å­˜å‚¨åˆ†é…æœ‰å…³ï¼Œä½†ä¸€èˆ¬æ–¹æ³•ä¹Ÿé€‚ç”¨äºå…¶ä»–æƒ…å†µã€‚

æœ¬å°èŠ‚è®¾ç½®äº†ä¸‰ä¸ªç»ƒä¹ ï¼š

- 8-6. æ ‡å‡†åº“å‡½æ•° calloc(n,size) è¿”å› n * size å­—èŠ‚ç©ºé—´ï¼Œå¹¶åˆå§‹åŒ–ä¸º 0 å€¼ã€‚é€šè¿‡è°ƒç”¨ malloc æˆ–ä¿®æ”¹å®ƒå®ç° calloc å‡½æ•°ã€‚
- 8-7. malloc æ¥æ”¶ä¸€ä¸ª size å‚æ•°è€Œä¸æ£€æŸ¥å…¶åˆç†æ€§ï¼Œè€Œ free è®¤ä¸ºè¯·æ±‚é‡Šæ”¾çš„å—åŒ…å«æœ‰æ•ˆçš„å¤§å°å­—æ®µã€‚æ”¹è¿›è¿™äº›å‡½æ•°ï¼Œæä¾›åœ¨é”™è¯¯æ£€æŸ¥æ–¹é¢æ›´åŠ ä¸¥æ ¼ã€‚
- 8-8. ç¼–å†™ bfree(p,n) å®ç°é‡Šæ”¾ä»»æ„å—åˆ° free åˆ—è¡¨ï¼Œp æŒ‡é’ˆä¸º n ä¸ªå­—ç¬¦çš„å—åœ°å€ï¼Œç”¨æˆ·é€šè¿‡å®ƒå¯ä»¥éšæ—¶å°†é™æ€æˆ–å¤–éƒ¨æ•°ç»„æ·»åŠ åˆ°ç©ºé—²åˆ—è¡¨ä¸­ã€‚


# =ğŸš© ASCII Chart
https://en.cppreference.com/w/cpp/language/ascii

The following chart contains all 128 ASCII decimal (dec), octal (oct), hexadecimal (hex) and character (ch) codes.

```cpp
#include <iostream>
 
int main()
{
    std::cout << "Printable ASCII [32..126]:\n";
    for (char c{' '}; c <= '~'; ++c)
        std::cout << c << ((c + 1) % 32 ? ' ' : '\n');
    std::cout << '\n';
}
```

Possible output:

    Printable ASCII [32..126]:
      ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
    @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _
    ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~


| dec | oct | hex |  ch | dec | oct | hex | ch | dec | oct | hex | ch | dec | oct | hex |  ch  |
|-----|-----|-----|-----|-----|-----|-----|----|-----|-----|-----|----|-----|-----|-----|------|
|   0 |   0 | 00  | NUL |  32 |  40 | 20  | SP |  64 | 100 | 40  | @  |  96 | 140 | 60  | BQ    |
|   1 |   1 | 01  | SOH |  33 |  41 | 21  | !  |  65 | 101 | 41  | A  |  97 | 141 | 61  | a    |
|   2 |   2 | 02  | STX |  34 |  42 | 22  | "  |  66 | 102 | 42  | B  |  98 | 142 | 62  | b    |
|   3 |   3 | 03  | ETX |  35 |  43 | 23  | #  |  67 | 103 | 43  | C  |  99 | 143 | 63  | c    |
|   4 |   4 | 04  | EOT |  36 |  44 | 24  | $  |  68 | 104 | 44  | D  | 100 | 144 | 64  | d    |
|   5 |   5 | 05  | ENQ |  37 |  45 | 25  | %  |  69 | 105 | 45  | E  | 101 | 145 | 65  | e    |
|   6 |   6 | 06  | ACK |  38 |  46 | 26  | &  |  70 | 106 | 46  | F  | 102 | 146 | 66  | f    |
|   7 |   7 | 07  | BEL |  39 |  47 | 27  | '  |  71 | 107 | 47  | G  | 103 | 147 | 67  | g    |
|   8 |  10 | 08  | BS  |  40 |  50 | 28  | (  |  72 | 110 | 48  | H  | 104 | 150 | 68  | h    |
|   9 |  11 | 09  | HT  |  41 |  51 | 29  | )  |  73 | 111 | 49  | I  | 105 | 151 | 69  | i    |
|  10 |  12 | 0a  | LF  |  42 |  52 | 2a  | *  |  74 | 112 | 4a  | J  | 106 | 152 | 6a  | j    |
|  11 |  13 | 0b  | VT  |  43 |  53 | 2b  | +  |  75 | 113 | 4b  | K  | 107 | 153 | 6b  | k    |
|  12 |  14 | 0c  | FF  |  44 |  54 | 2c  | ,  |  76 | 114 | 4c  | L  | 108 | 154 | 6c  | l    |
|  13 |  15 | 0d  | CR  |  45 |  55 | 2d  | -  |  77 | 115 | 4d  | M  | 109 | 155 | 6d  | m    |
|  14 |  16 | 0e  | SO  |  46 |  56 | 2e  | .  |  78 | 116 | 4e  | N  | 110 | 156 | 6e  | n    |
|  15 |  17 | 0f  | SI  |  47 |  57 | 2f  | /  |  79 | 117 | 4f  | O  | 111 | 157 | 6f  | o    |
|  16 |  20 | 10  | DLE |  48 |  60 | 30  | 0  |  80 | 120 | 50  | P  | 112 | 160 | 70  | p    |
|  17 |  21 | 11  | DC1 |  49 |  61 | 31  | 1  |  81 | 121 | 51  | Q  | 113 | 161 | 71  | q    |
|  18 |  22 | 12  | DC2 |  50 |  62 | 32  | 2  |  82 | 122 | 52  | R  | 114 | 162 | 72  | r    |
|  19 |  23 | 13  | DC3 |  51 |  63 | 33  | 3  |  83 | 123 | 53  | S  | 115 | 163 | 73  | s    |
|  20 |  24 | 14  | DC4 |  52 |  64 | 34  | 4  |  84 | 124 | 54  | T  | 116 | 164 | 74  | t    |
|  21 |  25 | 15  | NAK |  53 |  65 | 35  | 5  |  85 | 125 | 55  | U  | 117 | 165 | 75  | u    |
|  22 |  26 | 16  | SYN |  54 |  66 | 36  | 6  |  86 | 126 | 56  | V  | 118 | 166 | 76  | v    |
|  23 |  27 | 17  | ETB |  55 |  67 | 37  | 7  |  87 | 127 | 57  | W  | 119 | 167 | 77  | w    |
|  24 |  30 | 18  | CAN |  56 |  70 | 38  | 8  |  88 | 130 | 58  | X  | 120 | 170 | 78  | x    |
|  25 |  31 | 19  | EM  |  57 |  71 | 39  | 9  |  89 | 131 | 59  | Y  | 121 | 171 | 79  | y    |
|  26 |  32 | 1a  | SUB |  58 |  72 | 3a  | :  |  90 | 132 | 5a  | Z  | 122 | 172 | 7a  | z    |
|  27 |  33 | 1b  | ESC |  59 |  73 | 3b  | ;  |  91 | 133 | 5b  | [  | 123 | 173 | 7b  | {    |
|  28 |  34 | 1c  | FS  |  60 |  74 | 3c  | <  |  92 | 134 | 5c  | \  | 124 | 174 | 7c  | PIPE |
|  29 |  35 | 1d  | GS  |  61 |  75 | 3d  | =  |  93 | 135 | 5d  | ]  | 125 | 175 | 7d  | }    |
|  30 |  36 | 1e  | RS  |  62 |  76 | 3e  | >  |  94 | 136 | 5e  | ^  | 126 | 176 | 7e  | ~    |
|  31 |  37 | 1f  | US  |  63 |  77 | 3f  | ?  |  95 | 137 | 5f  | _  | 127 | 177 | 7f  | DEL  |

    NUL (null)                 DLE (data link escape)        PIPE  |
    SOH (start of header)        DC1 (device control 1)        DEL (delete) 
    STX (start of text)         DC2 (device control 2)        SP (space)
    ETX (end of text)          DC3 (device control 3)        BQ (backquote/backtick)
    EOT (end of transmission)     DC4 (device control 4)        
    ENQ (enquiry)              NAK (negative acknowledge)    
    ACK (acknowledge)           SYN (synchronous idle)        
    BEL (bell)                 ETB (end of transmission block) 
    BS (backspace)              CAN (cancel)               
    HT (horizontal tab)           EM (end of medium)         
    LF (line feed - new line)    SUB (substitute)             
    VT (vertical tab)             ESC (escape)                
    FF (form feed - new page)   FS (file separator)           
    CR (carriage return)          GS (group separator)          
    SO (shift out)              RS (record separator)         
    SI (shift in)               US (unit separator)           



# =ğŸš© OOC
- Object-Oriented Programming With ANSI-C https://www.cs.rit.edu/~ats/books/ooc.pdf
- Object Oriented Programming in C http://ldeniau.home.cern.ch/ldeniau/html/oopc/oopc.html


# =ğŸš© Non-Standard C Library

é™¤ C è¯­è¨€æ ‡å‡†æä¾›çš„å¤´æ–‡ä»¶ï¼Œè¿˜æœ‰ä¸€äº›éæ ‡å‡†å¤´æ–‡ä»¶ä¹Ÿä¼šç»å¸¸ç”¨åˆ°ã€‚

æ ‡å‡†å¤´ä¸éæ ‡å‡†å¤´åœ¨å¼•ç”¨æ—¶ï¼Œä½¿ç”¨ä¸åŒçš„è¯­æ³•æœ‰äº›è®¸å·®å¼‚ï¼Œä»¥ conio.h ä¸ºä¾‹ã€‚

å¯¹æ¯”æ ‡å‡†å¹¶å¤´ stdio.h çš„å¼•ç”¨ï¼Œæ ‡å‡†å¤´ä½¿ç”¨å°–æ‹¬å·ï¼Œéæ ‡å‡†å¤´ä½¿ç”¨åŒå¼•å·ï¼š

```c
#include <stdio.h>
#include "conio.h"
```

å› ä¸º C++ éœ€è¦å…¼å®¹ Cï¼Œæ‰€ä»¥åœ¨ C++ ä»£ç ä¸­ï¼Œä½¿ç”¨ C è¯­è¨€æ ‡å‡†å¤´æ–‡ä»¶æ—¶ä½¿ç”¨çš„æ˜¯ C++ ç‰ˆæœ¬çš„ï¼Œå³å»æ‰åç¼€åï¼Œå‰ç¼€ä¸€ä¸ª c å­—ç¬¦ã€‚

```cpp
#include <cstdio>
#include "conio.h"
```

## ==âš¡ conio.h æ§åˆ¶å°å‡½æ•°åº“
- https://docs.oracle.com/cd/E36784_01/html/E36873/termios.h-3head.html
- https://docs.microsoft.com/en-us/cpp/c-runtime-library/console-and-port-i-o
- https://techsupportwhale.com/conio-h-c-plus-plus-library/
- https://code-reference.com/c/conio.h

è¿™æ˜¯ä¸€ä¸ª Console Input/Output å‡½æ•°åº“ï¼Œå…¶ä¸­å®šä¹‰äº†é€šè¿‡æ§åˆ¶å°è¿›è¡Œæ•°æ®è¾“å…¥å’Œæ•°æ®è¾“å‡ºçš„å‡½æ•°ï¼Œä¸»è¦æ˜¯ä¸€äº›ç”¨æˆ·é€šè¿‡æŒ‰é”®ç›˜äº§ç”Ÿçš„å¯¹åº”æ“ä½œï¼Œæ¯”å¦‚ getch() å‡½æ•°ç­‰ç­‰ã€‚

è¿™ä¸ªå¤´æ–‡ä»¶æœ€æ—©åœ¨ MS-DOS ç¼–è¯‘å™¨ä¸Šå¤§é‡ä½¿ç”¨ï¼Œåæ¥å¤§å¤šæ•° UNIX/Linux çš„ C è¯­è¨€ç¼–è¯‘å™¨ä¹Ÿå…¼å®¹å®ƒï¼ŒåŒ…æ‹¬ä¸€äº›åµŒå…¥å¼ç¼–è¯‘å™¨ä¹Ÿæä¾›ï¼Œæ‰€ä»¥å®ƒçš„å‡ ä¹ç›¸å½“æ˜¯ä¸€ä¸ªæ ‡å‡†å¤´æ–‡ä»¶ã€‚

- `cgets`   Reads a string from the console.
- `clrscr`  clears the screen and move the cursor to upper left corner
- `cprintf` prints formatted output to the screen.
- `cputs`   Returns a string to the screen.
- `cscanf`  reads input from the console and reformat it.
- `delline` delete the line containing the cursor and move all lines below it one line up.
- `getch`   prompts the user to press a character
- `getche`  reads a character from the keyboard and display it on the screen
- `gotoxy`  places cursor at a desired location on screen.
- `kbhit`   find ou if a key has been pressed or not
- `putch`   prints characters on the screen.
- `textbackground`  change of current background color in text mode
- `textcolor`   change the color of drawing text
- `ungetch` Pushes a character back into the keyboard buffer
- `wherex`  return current horizontal cursor position
- `wherey`  return current vertival cursor position
- `window`  defines the active text mode window

Console and Port I/O Routines

- `_cgets`, `_cgetws`, `_cgets_s`, `_cgetws_s`    Read string from console
- `_cprintf`, `_cwprintf`, `_cprintf_s`, `_cprintf_s_l`, `_cwprintf_s`, `_cwprintf_s_l`   Write formatted data to console
- `_cputs`  Write string to console
- `_cscanf`, `_cwscanf`, `_cscanf_s`, `_cscanf_s_l`, `_cwscanf_s`, `_cwscanf_s_l` Read formatted data from console
- `_getch`, `_getwch` Read character from console
- `_getche`, `_getwche`   Read character from console and echo it
- `_inp`    Read one byte from specified I/O port
- `_inpd`   Read double word from specified I/O port
- `_inpw`   Read 2-byte word from specified I/O port
- `_kbhit`  Check for keystroke at console; use before attempting to read from console
- `_outp`   Write one byte to specified I/O port
- `_outpd`  Write double word to specified I/O port
- `_outpw`  Write word to specified I/O port
- `_putch`, `_putwch` Write character to console
- `_ungetch`, `_ungetwch` "Unget" last character read from console so it becomes next character read



# =ğŸš© Standard C Library
- https://en.cppreference.com/w/c/header
- the Standard C Library 1992 by P.J. Plauger
- C çš„å†å² https://zh.cppreference.com/w/c/language/history
- The GNU C Library (glibc) https://www.gnu.org/software/libc/sources.html
- [The GNU C Library Reference Manual](https://www.gnu.org/software/libc/manual/html_mono/libc.html)

ç›®å‰ï¼Œå·²å‘å¸ƒè§„èŒƒæ€»å…±åŒ…æ‹¬ 29 ä¸ª C Standard Library header files

- C89/C90 standard (ISO/IEC 9899:1990): 
    01. `<assert.h>` Conditionally compiled macro that compares its argument to zero 
    02. `<ctype.h>` Functions to determine the type contained in character data 
    03. `<errno.h>` Macros reporting error conditions 
    04. `<float.h>` Limits of float types 
    05. `<limits.h>` Sizes of basic types 
    06. `<locale.h>` Localization utilities 
    07. `<math.h>` Common mathematics functions 
    08. `<setjmp.h>` Nonlocal jumps 
    09. `<signal.h>` Signal handling 
    10. `<stdarg.h>` Variable arguments 
    11. `<stddef.h>` Common macro definitions 
    12. `<stdio.h>` Input/output 
    13. `<stdlib.h>` General utilities: memory management, program utilities, string conversions, random numbers, algorithms
    14. `<string.h>` String handling 
    15. `<time.h>` Time/date utilities 
- C95 standard (ISO/IEC 9899:1990/AMD 1:1995)
    01. `<iso646.h>` (`C95`) Alternative operator spellings 
    02. `<wchar.h>` (`C95`) Extended multibyte and wide character utilities 
    03. `<wctype.h>` (`C95`) Wide character classification and mapping utilities 
- C99 standard (ISO/IEC 9899:1999): 
    01. `<complex.h>` (`C99`) Complex number arithmetic 
    02. `<fenv.h>` (`C99`) Floating-point environment 
    03. `<inttypes.h>` (`C99`) Format conversion of integer types 
    04. `<stdbool.h>` (`C99`) Boolean type 
    05. `<stdint.h>` (`C99`) Fixed-width integer types 
    06. `<tgmath.h>` (`C99`) Type-generic math (macros wrapping math.h and complex.h) 
- C11 standard (ISO/IEC 9899:2011): 
    01. `<stdalign.h>` (`C11`) alignas and alignof convenience macros 
    02. `<stdatomic.h>` (`C11`) Atomic types 
    03. `<stdnoreturn.h>` (`C11`) noreturn convenience macros 
    04. `<threads.h>` (`C11`) Thread library 
    05. `<uchar.h>` (`C11`) UTF-16 and UTF-32 character utilities 

æœ‰å…´è¶£äº†è§£æºä»£ç ï¼Œå¯ä»¥ä»ä»¥ä¸‹ä½ç½®è·å– The GNU C Library (glibc)ï¼Œåªå»ºè®®æœ‰éœ€è¦æ‰å»ç¿»ï¼š

```sh
# http://www.gnu.org/software/libc/  =
# https://git.uclibc.org/uClibc  =
git clone git://sourceware.org/git/glibc.git
cd glibc
git checkout --track -b glibc-2_11-branch origin/release/2.11/master
```

MSVC ç¼–è¯‘å™¨ä¹Ÿæä¾›æºä»£ç ï¼Œæ ‡å‡†åº“ä»£ç åœ¨ VC å®‰è£…ç›®å½• \VC\crt\srcã€‚

å¶å°”çœ‹çœ‹æ¶å¿ƒçš„è‚ å­è‚šå­æœ‰åˆ©äºçœ‹é€ç¾å¥³çš„æœ¬è´¨ï¼

ä»å¤´æ–‡ä»¶çš„è§„èŒƒå‘å±•æ¥çœ‹ï¼ŒC95 ä¸»è¦æ˜¯å¯¹å®½å­—ç¬¦è¿›è¡Œäº†æ‰©å±•ã€‚è¿™æ˜¯å¯¹ C89 çš„ä¸€ä¸ªä¿®è®¢å’Œæ‰©å……ï¼Œç§°ä¸ºâ€œC89 with Amendment 1â€æˆ– C95ï¼Œä¸¥æ ¼è¯´æ¥å¹¶ä¸æ˜¯ä¸€ä¸ªçœŸæ­£çš„æ ‡å‡†ã€‚

- C95 standard (ISO/IEC 9899:1990/AMD 1:1995)
    - `<iso646.h>` (`C95`) Alternative operator spellings 
    - `<wchar.h>` (`C95`) Extended multibyte and wide character utilities 
    - `<wctype.h>` (`C95`) Wide character classification and mapping utilities 

C95 çš„ä¸»è¦æ”¹åŠ¨ï¼š

- 3ä¸ªæ–°æ ‡å‡†å¤´æ–‡ä»¶ï¼šiso646.hã€wctype.hã€wchar.hï¼›
- ä¸€äº›æ–°çš„æ ‡è®°ï¼ˆtokenï¼‰å’Œå®ï¼ˆmacroï¼‰ï¼›
- ä¸€äº›æ–°çš„ printf/scanf ç³»åˆ—å‡½æ•°çš„æ ¼å¼ç¬¦ï¼›
- å¢åŠ äº†å¤§é‡çš„å®½å­—ç¬¦å’Œå¤šå­—èŠ‚å­—ç¬¦å‡½æ•°ã€å¸¸æ•°å’Œç±»å‹ã€‚

1999å¹´ï¼Œåœ¨åšäº†ä¸€äº›å¿…è¦çš„ä¿®æ­£å’Œå®Œå–„åï¼ŒISO å‘å¸ƒäº†æ–°çš„ C è¯­è¨€æ ‡å‡†ï¼Œå‘½åä¸º ISO/IEC 9899:1999ï¼Œç®€ç§°â€œC99â€ã€‚

- C99 standard (ISO/IEC 9899:1999): 
    - `<complex.h>` (`C99`) Complex number arithmetic 
    - `<fenv.h>` (`C99`) Floating-point environment 
    - `<inttypes.h>` (`C99`) Format conversion of integer types 
    - `<stdbool.h>` (`C99`) Boolean type 
    - `<stdint.h>` (`C99`) Fixed-width integer types 
    - `<tgmath.h>` (`C99`) Type-generic math (macros wrapping math.h and complex.h) 

C99 çš„ä¸»è¦æ”¹åŠ¨ï¼š

- å¤æ•°ï¼ˆcomplexï¼‰ï¼›
- æ•´æ•°ï¼ˆintegerï¼‰ç±»å‹æ‰©å±•ï¼›
- å˜é•¿æ•°ç»„ï¼›
- Boolean ç±»å‹ï¼›
- éè‹±è¯­å­—ç¬¦é›†çš„æ›´å¥½æ”¯æŒï¼›
- æµ®ç‚¹ç±»å‹çš„æ›´å¥½æ”¯æŒï¼›
- æä¾›å…¨éƒ¨ç±»å‹çš„æ•°å­¦å‡½æ•°ï¼›
- C++ é£æ ¼æ³¨é‡Šï¼ˆ//ï¼‰ã€‚

2007 å¹´ï¼ŒC è¯­è¨€æ ‡å‡†å§”å‘˜ä¼šåˆé‡æ–°å¼€å§‹ä¿®è®¢æ ‡å‡†ï¼Œäº 2011 å¹´æ­£å¼å‘å¸ƒäº† ISO/IEC 9899:2011ï¼Œç®€ç§°ä¸º C11 æ ‡å‡†ã€‚

C11 æ ‡å‡†æ–°å¼•å…¥å°‘é‡çš„ç‰¹å¾å°½ï¼Œæ²¡æœ‰ C90 å¼•å…¥çš„é‚£ä¹ˆå¤šï¼Œä½†æ˜¯è¿™äº›ä¹Ÿéƒ½ååˆ†æœ‰ç”¨ï¼Œæ¯”å¦‚ï¼šå­—èŠ‚å¯¹é½è¯´æ˜ç¬¦ã€æ³›å‹æœºåˆ¶ï¼ˆgeneric selectionï¼‰ã€å¯¹å¤šçº¿ç¨‹çš„æ”¯æŒã€é™æ€æ–­è¨€ã€åŸå­æ“ä½œä»¥åŠå¯¹ Unicode çš„æ”¯æŒã€‚

2018 å¹´ 6 æœˆå‘å¸ƒçš„ ISO/IEC 9899:2018 çš„éæ­£å¼åç§° C17ï¼Œä¹Ÿç§°ä¸ºä¸º C18ï¼Œæ˜¯æˆªæ­¢åˆ° 2020 å¹´ä¸ºæ­¢æœ€æ–°çš„ C è¯­è¨€ç¼–ç¨‹æ ‡å‡†ï¼Œè¢«ç”¨æ¥æ›¿ä»£ C11 æ ‡å‡†ã€‚C17 æ²¡æœ‰å¼•å…¥æ–°çš„è¯­è¨€ç‰¹æ€§ï¼Œåªå¯¹ C11 è¿›è¡Œäº†è¡¥å……å’Œä¿®æ­£ã€‚

ä½œä¸ºä¸‹ä¸€ä¸ªç‰ˆæœ¬çš„ C æ ‡å‡†ï¼ŒC2x é¢„è®¡å°†äº 2022 å¹´ 12 æœˆ 1 æ—¥å®Œæˆã€‚

æœ‰è®¸å¤šäººæå‡ºæƒ³ä¸º C è¯­è¨€æ·»åŠ é¢å‘å¯¹è±¡çš„ç‰¹æ€§ï¼ŒåŒ…æ‹¬å¢åŠ ç±»ã€ç»§æ‰¿ã€å¤šæ€ç­‰å·²è¢« C++ è¯­è¨€æ‰€å¹¿æ³›ä½¿ç”¨çš„è¯­æ³•ç‰¹æ€§ï¼Œä½†æ˜¯æœ€ç»ˆè¢«å§”å‘˜ä¼šé©³å›äº†ã€‚å› ä¸ºè¿™äº›å¤æ‚çš„è¯­æ³•ç‰¹æ€§å¹¶ä¸ç¬¦åˆ C è¯­è¨€çš„è®¾è®¡ç†å¿µä»¥åŠè®¾è®¡å“²å­¦ï¼Œå†µä¸” C++ å·²ç»æœ‰äº†è¿™äº›ç‰¹æ€§ï¼ŒC è¯­è¨€æ— éœ€å†å¯¹å®ƒä»¬è¿›è¡Œæ”¯æŒã€‚


## ==âš¡ `<stdbool.h>` bool in C90 C99

åœ¨ç¼–è¯‘ C è¯­è¨€æ—¶æœ‰æ—¶ä¼šé‡åˆ°è¿™æ ·çš„é”™è¯¯æç¤ºï¼š

    `true' undeclared (first use in this function)
    `false' undeclared (first use in this function)

å°±æ˜¯è¯´ bool, true, false åœ¨æ—©æœŸ C/C++ è¯­è¨€ä¸­æ²¡æœ‰è¿™äº›å…³é”®å­—ï¼Œæ²¡æœ‰å…³é”®å­— boolï¼Œä½¿ç”¨ BOOL å¯ä»¥ï¼Œä½† BOOL ä¸æ˜¯å†…ç½®ç±»å‹ï¼Œéƒ½æ˜¯é€šè¿‡ typedef æˆ–è€…å®æ¥å®šä¹‰çš„ï¼Œé€šå¸¸éƒ½ä¼šè¢«å®šä¹‰æˆ int ç±»å‹ã€‚åæ¥ C++ å†…ç½®ç±»å‹ bool å€¼åªèƒ½ä¸º trueï¼ˆ1ï¼‰å’Œfalseï¼ˆ0ï¼‰ã€‚

è§£å†³æ–¹æ³•ï¼š

+. å°†æ–‡ä»¶å .c æ”¹ä¸ºæ–‡ä»¶å .cpp ç”¨ C++ æ–¹å¼ç¼–è¯‘

+. æˆ–è€…ä½¿ç”¨ C99 æ–‡ä»¶å¤´å®šä¹‰ï¼š

    #include <stdbool.h>

+. è‡ªå·±è¿›è¡Œä¸€ä¸ªå®å®šä¹‰ï¼Œæ¨¡ä»¿å¸ƒå°”å‹ï¼š

    enum bool{false, true}; 

    typedef enum __bool {false = 0,true =1, }bool;

    #define TRUE 1
    #define FALSE 0
    
c90 æ˜¯æ²¡æœ‰ bool çš„ï¼Œå› æ­¤æ”¯æŒ c90 çš„ dev-c++ å½“ç„¶ä¹Ÿæ²¡æœ‰ã€‚

C99 ä¸ºäº†å’Œ C++ å…¼å®¹ï¼Œå¢åŠ å¤´æ–‡ä»¶ stdbool.h å®šä¹‰ boolã€trueã€falseã€‚å…¶ä¸­ bool å°±æ˜¯ `_Bool` ç±»å‹ï¼Œtrue å’Œ false çš„å€¼ä¸º 1 å’Œ 0ã€‚

c99 æ”¯æŒ `_Bool`ï¼Œè€Œä¸æ˜¯ bool æˆ– BOOLï¼Œè¿™çœŸçš„å¤ªå¥‡æ€ªäº†ã€‚

    _Bool a = 1;
    _Bool b = 2;    /* ä½¿ç”¨éé›¶å€¼ï¼Œbçš„å€¼ä¸º1 */ 
    _Bool c = 0;
    _Bool d = -1;   /* ä½¿ç”¨éé›¶å€¼ï¼Œdçš„å€¼ä¸º1 */ 

å¦‚æœ C99 æ–°å¢çš„å¸ƒå°”ç±»å‹å« bool æˆ– BOOLï¼Œåˆ™å¾ˆå¯èƒ½è·Ÿå¤§å®¶å·²æœ‰çš„ä»£ç å‘ç”Ÿå†²çªã€‚ä¸¾ä¸ªä¾‹å­ï¼Œæ­£å¸¸æƒ…å†µä¸‹ï¼Œ`_Bool` æ‰“å°çš„é•¿åº¦åº”è¯¥æ˜¯ 1ï¼Œä½†å¦‚æœæˆ‘å¯¹å®ƒè¿›è¡Œå®å®šä¹‰ `#define _Bool int`ï¼Œåˆ™æ‰“å°å‡ºæ¥çš„é•¿åº¦å°±å˜æˆäº† int çš„é•¿åº¦ã€‚


## ==âš¡ `<stdio.h>` Standard I/O
- https://en.cppreference.com/w/c/io

åŸºæœ¬è¾“å…¥è¾“å‡ºåº“ä¾›åº”çª„å­—ç¬¦å³å•å­—èŠ‚å­—ç¬¦çš„è¾“å…¥è¾“å‡ºèƒ½åŠ›ï¼Œé…åˆ C95 è§„èŒƒå¼•å…¥çš„ `<wchar.h>` `<wctype.h>` å®ç°å®½å­—ç¬¦æ”¯æŒã€‚

I/O æµæ–‡ä»¶å¯¹è±¡ä½¿ç”¨ `FILE*` æŒ‡é’ˆæ“ä½œï¼Œå°½ç®¡å¯ä»¥æ‹·è´è¿™æ ·ä¸€ä¸ªæŒ‡é’ˆï¼Œä½†æ˜¯æ¯ä¸ªæµå…³è”çš„å¤–éƒ¨è®¾å¤‡ä¸åŒï¼Œå¦‚ç£ç›˜å­˜å‚¨çš„æ–‡ä»¶ã€æ ‡å‡†è¾“å…¥æµã€æ‰“å°æœºã€ä¸²å£ç­‰ç­‰ï¼Œæ‰€æœ‰å¹¶ä¸èƒ½ä¿è¯æ‹·è´çš„æ–‡ä»¶æŒ‡é’ˆå¯ä»¥æ­£å¸¸å·¥ä½œã€‚

I/O æµå¯ä»¥ä½¿ç”¨æ ¼å¼åŒ–æˆ–éæ ¼å¼åŒ–çš„è¾“å…¥è¾“å‡ºï¼Œä¹Ÿå¯ä»¥ç»“åˆ `<locale.h>` çš„æœ¬åœ°åŒ–è®¾ç½®ï¼Œæµå¯¹è±¡éƒ½å—å½“å‰çš„æœ¬åœ°åŒ–è®¾ç½®å½±å“ï¼Œå¯ä»¥é€šè¿‡ `setlocale` å‡½æ•°è®¾ç½®å®ƒã€‚

æ ‡å‡† I/O é¢„å®šä¹‰äº† stdin stdout stderr è¿™ä¸‰ä¸ªæœ€å¸¸ç”¨åˆ°çš„æ ‡å‡†æ–‡ï¼š

1. `stdin` expression of type FILE* associated with the input stream
2. `stdout` expression of type FILE* associated with the output stream
3. `stderr` expression of type FILE* associated with the error output stream (macro constant)

åœ¨ä½¿ç”¨å‘½ä»¤è¡Œæ‰§è¡Œç¨‹åºæ—¶ï¼Œå¯ä»¥å¯¹è¿™äº›æ ‡å‡†æ–‡ä»¶è¿›è¡Œé‡å®šå‘æ“ä½œã€‚

æ­¤åº“æä¾›ä»¥ä¸‹åŠŸèƒ½å‡½æ•°ï¼š

1.  File access
2.  Direct input/output
3.  Unformatted input/output
4.  Formatted input/output
5.  File positioning
6.  Error handling
7.  Operations on files

é™¤äº†ç³»ç»Ÿéœ€è¦çš„è®¾å¤‡ä¿¡æ¯ï¼Œæ¯ä¸ªæµå¯¹è±¡è¿˜ä¿å­˜ä»¥ä¸‹ä¿¡æ¯ï¼š

- (C95) Character width: unset, narrow, or wide
- Buffering state: unbuffered, line-buffered, fully buffered.
- The buffer, which may be replaced by an external, user-provided buffer.
- I/O mode: input, output, or update (both input and output).
- Binary/text mode indicator.
- End-of-file status indicator.
- Error status indicator.
- File position indicator (`fpos_t`), which, for wide character streams, includes the parse state (`mbstate_t`(C95)).
- (C11) Reentrant lock used to prevent data races when multiple threads read, write, position, or query the position of a stream.

Narrow and wide orientation
A newly opened stream has no orientation. The first call to *fwide* or to any I/O function establishes the orientation: a wide I/O function makes the stream wide-oriented, a narrow I/O function makes the stream narrow-oriented. Once set, the orientation can only be changed with *freopen*. Narrow I/O functions cannot be called on a wide-oriented stream; wide I/O functions cannot be called on a narrow-oriented stream. Wide I/O functions convert between wide and multibyte characters as if by calling *mbrtowc* and *wcrtomb*. Unlike the multibyte character strings that are valid in a program, multibyte character sequences in the file may contain embedded nulls and do not have to begin or end in the initial shift state.

POSIX requires that the *LC_CTYPE* facet of the currently installed C locale is stored within the stream object the moment its orientation becomes wide, and is used for all future I/O on this stream until the orientation is changed, regardless of any subsequent calls to setlocale.

Binary and text modesA text stream is an ordered sequence of characters composed into lines (zero or more characters plus a terminating '\n'). Whether the last line requires a terminating '\n' is implementation-defined. Characters may have to be added, altered, or deleted on input and output to conform to the conventions for representing text in the OS (in particular, C streams on Windows OS convert \n to \r\n on output, and convert \r\n to \n on input)

Data read in from a text stream is guaranteed to compare equal to the data that were earlier written out to that stream only if all of the following is true:

the data consist only of printing characters and the control characters \t and \n (in particular, on Windows OS, the character '\0x1A' terminates input) no \n is immediately preceded by a space character (space characters that are written out immediately before a \n may disappear when read) the last character is \n A binary stream is an ordered sequence of characters that can transparently record internal data. Data read in from a binary stream always equals to the data that were earlier written out to that stream. Implementations are only allowed to append a number of null characters to the end of the stream. A wide binary stream doesn't need to end in the initial shift state.

POSIX implementations do not distinguish between text and binary streams (there is no special mapping for \n or any other characters)

### ğŸ€1.  File access

```c
/////////////////////////////////
// Defined in header <stdio.h> 
/////////////////////////////////

// opens a file
FILE *fopen( const char *filename, const char *mode ); (until C99)
FILE *fopen( const char *restrict filename, const char *restrict mode ); (since C99)
errno_t fopen_s(FILE *restrict *restrict streamptr,
                const char *restrict filename,
                const char *restrict mode); (since C11)

// open an existing stream with a different name
FILE *freopen( const char *filename, const char *mode,
               FILE *stream ); (until C99)
FILE *freopen( const char *restrict filename, const char *restrict mode,
               FILE *restrict stream ); (since C99)
errno_t freopen_s(FILE *restrict *restrict newstreamptr,
                  const char *restrict filename, const char *restrict mode,
                  FILE *restrict stream);  (since C11)
// closes a file
int fclose( FILE *stream );

// synchronizes an output stream with the actual file
int fflush( FILE *stream );

// sets the buffer for a file stream
void setbuf( FILE          *stream, char          *buffer ); (until C99)
void setbuf( FILE *restrict stream, char *restrict buffer ); (since C99)

// sets the buffer and its size for a file stream
int setvbuf( FILE *         stream, char *         buffer, int mode, size_t size ); (until C99)
int setvbuf( FILE *restrict stream, char *restrict buffer, int mode, size_t size ); (since C99)

/////////////////////////////////
// Defined in header <wchar.h> 
/////////////////////////////////

// switches a file stream between wide character I/O and narrow character I/O
int fwide( FILE *stream, int mode ); (since C95)
```


### ğŸ€2.  Direct input/output

```c
/////////////////////////////////
// Defined in header <stdio.h> //
/////////////////////////////////

// fread reads from a file
size_t fread( void          *buffer, size_t size, size_t count, FILE          *stream ); (until C99)
size_t fread( void *restrict buffer, size_t size, size_t count, FILE *restrict stream ); (since C99)

// fwrite writes to a file
size_t fwrite( const void *buffer, size_t size, size_t count, FILE *stream ); (until C99)
size_t fwrite( const void *restrict buffer, size_t size, size_t count, FILE *restrict stream ); (since C99)
```

### ğŸ€3.  Unformatted input/output

```c
//////////////////////////////////////////////////
// Narrow character Defined in header <stdio.h> //
//////////////////////////////////////////////////

// gets a character from a file stream
int fgetc( FILE *stream );   
int getc( FILE *stream ); 

// gets a character string from a file stream
char *fgets( char          *str, int count, FILE          *stream );  (until C99)
char *fgets( char *restrict str, int count, FILE *restrict stream );  (since C99)

// writes a character to a file stream
int fputc( int ch, FILE *stream );
int putc( int ch, FILE *stream );

// writes a character string to a file stream
int fputs( const char          *str, FILE          *stream );  (until C99) 
int fputs( const char *restrict str, FILE *restrict stream );  (since C99) 
   
// reads a character from stdin
int getchar(void);

// reads a character string from stdin
char *gets( char *str );  (until C11) 
char *gets_s( char *str, rsize_t n );  (since C11) (optional) 

// writes a character to stdout
int putchar( int ch );

// writes a character string to stdout
int puts( const char *str );

// puts a character back into a file stream
int ungetc( int ch, FILE *stream );

////////////////////////////////////////////////
// Wide character Defined in header <wchar.h> //
////////////////////////////////////////////////

// gets a wide character from a file stream
wint_t fgetwc( FILE *stream ); (since C95)
wint_t getwc( FILE *stream ); (since C95)

// gets a wide string from a file stream
wchar_t *fgetws( wchar_t *str, int count, FILE *stream ); (since C95) (until C99)
wchar_t *fgetws( wchar_t * restrict str, int count, FILE * restrict stream ); (since C99)

// writes a wide character to a file stream
wint_t fputwc( wchar_t ch, FILE *stream ); (since C95)
wint_t putwc( wchar_t ch, FILE *stream ); (since C95)

// writes a wide string to a file stream
int fputws( const wchar_t *str, FILE *stream ); (since C95) (until C99)
int fputws( const wchar_t * restrict str, FILE * restrict stream ); (since C99)

// reads a wide character from stdin
wint_t getwchar(void); (since C95)

// writes a wide character to stdout
wint_t putwchar( wchar_t ch ); (since C95)

// puts a wide character back into a file stream
wint_t ungetwc( wint_t ch, FILE *stream ); (since C95)
```

ç¤ºèŒƒï¼Œä½¿ç”¨å®½å­—ç¬¦ï¼š

```c
#include <locale.h>
#include <wchar.h>
 
int main(void)
{
    char narrow_str[] = "z\u00df\u6c34\U0001f34c";
                    // or "zÃŸæ°´ğŸŒ"
                    // or "\x7a\xc3\x9f\xe6\xb0\xb4\xf0\x9f\x8d\x8c";
    wchar_t warr[29]; // the expected string is 28 characters plus 1 null terminator
    setlocale(LC_ALL, "en_US.utf8");
    swprintf(warr, sizeof warr/sizeof *warr,
              L"Converted from UTF-8: '%s'", narrow_str);
    wprintf(L"%ls\n", warr);
}
```


ç¤ºèŒƒï¼Œæ–‡ä»¶è¯»å†™å®½å­—ç¬¦ï¼š

```c
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <errno.h>
#include <locale.h>
 
int main(void)
{
    setlocale(LC_ALL, "en_US.utf8");
    FILE *fp = fopen("fgetwc.dat", "w");
    if(!fp) {
        perror("Can't open file for writing");
        return EXIT_FAILURE;
    }
    fputs("ĞºĞ¾ÑˆĞºĞ°\n", fp);
    fclose(fp);
 
    fp = fopen("fgetwc.dat", "r");
    if(!fp) {
        perror("Can't open file for reading");
        return EXIT_FAILURE;
    }
    wint_t wc;
    errno = 0;
    while ((wc = fgetwc(fp)) != WEOF)
        putwchar(wc);
 
    if (ferror(fp)) {
        if (errno == EILSEQ)
            puts("Character encoding error while reading.");
        else
            puts("I/O error when reading");
    } else if (feof(fp))
        puts("End of file reached successfully");
 
    fclose(fp);
}
```


ç¤ºèŒƒï¼Œè¾“å‡ºå®½å­—ç¬¦åˆ°æ ‡å‡†è¾“å‡ºæµï¼š

```c
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <errno.h>

int main(void)
{
    setlocale(LC_ALL, "en_US.utf8");
 
    errno = 0;
    if (fputwc(L'ğŸŒ', stdout) == WEOF) {
        if (errno == EILSEQ)
            puts("Encoding error in fputwc.");
        else
            puts("I/O error in fputwc.");
        return EXIT_FAILURE;
    }
}
```


### ğŸ€4.  Formatted input/output

```c
//////////////////////////////////////////////////
// Narrow character Defined in header <stdio.h> //
//////////////////////////////////////////////////

// reads formatted input from stdin, a file stream or a buffer
int scanf( const char          *format, ... );  (until C99) 
int scanf( const char *restrict format, ... );  (since C99) 
int fscanf( FILE          *stream, const char          *format, ... );  (until C99) 
int fscanf( FILE *restrict stream, const char *restrict format, ... );  (since C99) 
int sscanf( const char          *buffer, const char          *format, ... );  (until C99) 
int sscanf( const char *restrict buffer, const char *restrict format, ... );  (since C99) 
int scanf_s(const char *restrict format, ...); (4) (since C11) 
int fscanf_s(FILE *restrict stream, const char *restrict format, ...); (5) (since C11) 
int sscanf_s(const char *restrict buffer, const char *restrict format, ...); (6) (since C11) 

// reads formatted input from stdin, a file stream or a buffer using variable argument list
int vscanf( const char *restrict format, va_list vlist ); (since C99) 
int vfscanf( FILE *restrict stream, const char *restrict format, va_list vlist ); (since C99)
int vsscanf( const char *restrict buffer, const char *restrict format, va_list vlist ); (since C99)
int vscanf_s( const char *restrict format, va_list vlist); (since C11) 
int vfscanf_s( FILE *restrict stream, const char *restrict format, va_list vlist); (since C11)
int vsscanf_s( const char *restrict buffer, const char *restrict format, va_list vlist); (since C11)

// prints formatted output to stdout, a file stream or a buffer
int printf( const char *format, ... );  (until C99) 
int printf( const char *restrict format, ... );  (since C99)
int fprintf( FILE *stream, const char *format, ... );  (until C99) 
int fprintf( FILE *restrict stream, const char *restrict format, ... );  (since C99)
int sprintf( char *buffer, const char *format, ... );  (until C99) 
int sprintf( char *restrict buffer, const char *restrict format, ... );  (since C99) 
int snprintf( char *restrict buffer, int bufsz, const char *restrict format, ... ); (since C99)
int printf_s(const char *restrict format, ...); (since C11) 
int fprintf_s(FILE *restrict stream, const char *restrict format, ...); (since C11) 
int sprintf_s(char *restrict buffer, rsize_t bufsz, const char *restrict format, ...); (since C11)
int snprintf_s(char *restrict buffer, rsize_t bufsz, const char *restrict format, ...); (since C11)

// prints formatted output to stdout, a file stream or a buffer using variable argument list
int vprintf( const char *format, va_list vlist );  (until C99) 
int vprintf( const char *restrict format, va_list vlist );  (since C99) 
int vfprintf( FILE *stream, const char *format, va_list vlist );  (until C99) 
int vfprintf( FILE *restrict stream, const char *restrict format, va_list vlist );  (since C99)
int vsprintf( char *buffer, const char *format, va_list vlist );  (until C99) 
int vsprintf( char *restrict buffer, const char *restrict format, va_list vlist );  (since C99)
int vsnprintf( char *restrict buffer, int bufsz, const char *restrict format, va_list vlist ); (since C99)
int vprintf_s( const char *restrict format, va_list arg); (since C11) 
int vfprintf_s( FILE *restrict stream, const char *restrict format, va_list arg); (since C11)
int vsprintf_s( char *restrict buffer, rsize_t bufsz, const char *restrict format, va_list arg); (since C11)
int vsnprintf_s(char *restrict buffer, rsize_t bufsz, const char * restrict format, va_list arg); (since C11)


////////////////////////////////////////////////
// Wide character Defined in header <wchar.h> //
////////////////////////////////////////////////

// reads formatted wide character input from stdin, a file stream or a buffer
int wscanf( const wchar_t *format, ... );  (since C95) (until C99)
int wscanf( const wchar_t *restrict format, ... );  (since C99) 
int fwscanf( FILE *stream, const wchar_t *format, ... );  (since C95) (until C99)
int fwscanf( FILE *restrict stream, 
            const wchar_t *restrict format, ... );  (since C99)
int swscanf( const wchar_t *buffer, 
            const wchar_t *format, ... );  (since C95) (until C99)
int swscanf( const wchar_t *restrict buffer, 
             const wchar_t *restrict format, ... );  (since C99)
int wscanf_s( const wchar_t *restrict format, ...);  (since C11) 
int fwscanf_s( FILE *restrict stream, 
               const wchar_t *restrict format, ...);  (since C11)
int swscanf_s( const wchar_t *restrict s, 
               const wchar_t *restrict format, ...);  (since C11)

// reads formatted wide character input from stdin, a file stream or a buffer using variable argument list
int vwscanf( const wchar_t *restrict format, va_list vlist );  (since C99) 
int vfwscanf( FILE *restrict stream,
              const wchar_t *restrict format, va_list vlist );  (since C99) 
int vswscanf( const wchar_t *restrict buffer,
              const wchar_t *restrict format, va_list vlist );  (since C99) 
int vwscanf_s( const wchar_t *restrict format, va_list vlist );  (since C11) 
int vfwscanf_s( FILE *restrict stream,
                const wchar_t *restrict format, va_list vlist );  (since C11) 
int vswscanf_s( const wchar_t *restrict buffer,
                const wchar_t *restrict format, va_list vlist );  (since C11) 

// prints formatted wide character output to stdout, a file stream or a buffer
int wprintf( const wchar_t *format, ... );  (since C95) (until C99)
int wprintf( const wchar_t *restrict format, ... );  (since C99) 
int fwprintf( FILE *stream, const wchar_t* format, ... );  (since C95) (until C99)
int fwprintf( FILE *restrict stream,
              const wchar_t *restrict format, ... );  (since C99) 
int swprintf( wchar_t *buffer, size_t bufsz,
              const wchar_t* format, ... );  (since C95) (until C99)
int swprintf( wchar_t *restrict buffer, size_t bufsz,
              const wchar_t *restrict format, ... );  (since C99) 
int wprintf_s( const wchar_t *restrict format, ...);  (since C11) 
int fwprintf_s( FILE *restrict stream,
                const wchar_t *restrict format, ...);  (since C11) 
int swprintf_s( wchar_t *restrict buffer, rsize_t bufsz,
                const wchar_t* restrict format, ...);  (since C11) 
int snwprintf_s( wchar_t * restrict s, rsize_t n,
                 const wchar_t * restrict format, ...);  (since C11) 

// prints formatted wide character output to stdout, a file stream or a buffer using variable argument list
int vwprintf( const wchar_t *format, va_list vlist );  (since C95) (until C99) 
int vwprintf( const wchar_t *restrict format, va_list vlist );  (since C99) 
int vfwprintf( FILE* stream, const wchar_t *format, va_list vlist );  (since C95) (until C99) 
int vfwprintf( FILE *restrict stream,
               const wchar_t *restrict format, va_list vlist );  (since C99) 
int vswprintf( wchar_t *buffer, size_t bufsz,
               const wchar_t *format, va_list vlist );  (since C95) (until C99) 
int vswprintf( wchar_t *restrict buffer, size_t bufsz,
               const wchar_t *restrict format, va_list vlist );  (since C99) 
int vwprintf_s( const wchar_t *restrict format, va_list vlist); (4) (since C11) 
int vfwprintf_s( FILE * restrict stream,
                 const wchar_t *restrict format, va_list vlist); (5) (since C11) 
int vswprintf_s( wchar_t *restrict buffer, rsize_t bufsz,
                 const wchar_t * restrict format, va_list vlist); (6) (since C11) 
int vsnwprintf_s( wchar_t *restrict buffer, rsize_t bufsz,
                  const wchar_t *restrict format, va_list vlist); (7) (since C11) 
```

ä½¿ç”¨ scanf æ³¨æ„ä¸€ä¸‹ï¼Œæ¯ä¸ªè½¬æ¢å ä½ç¬¦å·ä¼šæ¶ˆè´¹ç¼“å†²åŒºçš„ç©ºç™½å­—ç¬¦ï¼Œå¦‚ç©ºæ ¼æˆ– TABï¼Œé‚£ä¹ˆåœ¨è½¬æ¢å­—ç¬¦ `%c` æ—¶å°†ä¼šå½±å“åˆ°çœŸæ­£çš„æ•°æ®ï¼Œå³è¯»å–åˆ°çš„æ˜¯ç©ºç™½å­—ç¬¦è€Œä¸æ˜¯åé¢çš„æ•°æ®ã€‚

è§£å†³æ–¹æ³•æ˜¯æ ¼å¼å­—ç¬¦ä¸²ä¸­ä½¿ç”¨å‰ç½®ç©ºæ ¼ï¼Œè¿™æ ·å°±å¯ä»¥æ¶ˆè€—æ‰åˆ†éš”ç”¨çš„ç©ºç™½å­—ç¬¦ã€‚å¦‚ä¸‹ä¼šè¾“å…¥ä¸¤ä¸ªå€¼ï¼Œå¯ä»¥æ˜¯åŒä¸€è¡Œç”¨ç©ºç™½å­—ç¬¦åˆ†éš”ï¼Œä¹Ÿå¯ä»¥åˆ†ä¸¤è¡Œè¾“å…¥ï¼š

```c
scanf("%d", &a);
scanf(" %c", &c); // consume all consecutive whitespace after %d, then read a char
```

### ğŸ€5.  File positioning 

```c
// returns the current file position indicator
long ftell( FILE *stream );

// gets the file position indicator
int fgetpos( FILE          *stream, fpos_t          *pos ); // (until C99)
int fgetpos( FILE *restrict stream, fpos_t *restrict pos ); // (since C99)

// moves the file position indicator to a specific location in a file
int fseek( FILE *stream, long offset, int origin );

// moves the file position indicator to a specific location in a file
int fsetpos( FILE *stream, const fpos_t *pos );

//moves the file position indicator to the beginning in a file
void rewind( FILE *stream );
```

### ğŸ€6.  Error handling

Defined in header <stdio.h>
| clearerr  | clears errors             | (function)
| feof    | checks for the end-of-file | (function)
| ferror  | checks for a file error     | (function)
| perror  | displays a character string corresponding of the current error to stderr | (function)

```c
// clears errors
void clearerr( FILE *stream );

// checks for the end-of-file
int feof( FILE *stream );

// checks for a file error
int ferror( FILE *stream );

// displays a character string corresponding of the current error to stderr
void perror( const char *s );
```


### ğŸ€7.  Operations on files

```c
// remove erases a file
int remove( const char *fname );

// rename renames a file
int rename( const char *old_filename, const char *new_filename );

// (C11) returns a pointer to a temporary file
FILE *tmpfile(void);
errno_t tmpfile_s(FILE * restrict * restrict streamptr);// (since C11)

// (C11) returns a unique filename
char *tmpnam( char *filename );
errno_t tmpnam_s(char *filename_s, rsize_t maxsize); // (since C11)
```


Types Defined in header `<stdio.h>` 

- `FILE` type, capable of holding all information needed to control a C I/O stream 
- `fpos_t` type, capable of uniquely specifying a position and mutibyte parser state in a file 

Macros Defined in header `<stdio.h>` 

```c
// Predefined standard streams
#define stdin  /* implementation-defined */ // (1) FILE* associated with the input stream
#define stdout /* implementation-defined */ // (2) FILE* associated with the output stream
#define stderr /* implementation-defined */ // (3) FILE* associated with the error output stream

EOF         // integer constant expression of type int and negative value
FOPEN_MAX   // number of files that can be open simultaneously
FILENAME_MAX// size needed for an array of char to hold the longest supported file name
BUFSIZ      // size of the buffer used by setbuf()

_IOFBF      // argument to setvbuf() indicating fully buffered I/O
_IOLBF      // argument to setvbuf() indicating line buffered I/O
_IONBF      // argument to setvbuf() indicating unbuffered I/O

SEEK_SET    // argument to fseek() indicating seeking from beginning of the file
SEEK_CUR    // argument to fseek() indicating seeking from the current file position
SEEK_END    // argument to fseek() indicating seeking from end of the file

TMP_MAX     // maximum number of unique filenames that can be generated by tmpnam
TMP_MAX_S   // (C11) maximum number of unique filenames that can be generated by tmpnam_s

L_tmpnam    // size needed for an array of char to hold the result of tmpnam
L_tmpnam_s  // (C11) size needed for an array of char to hold the result of tmpnam_s
```



## ==âš¡ `<stdlib.h>` Standard Library
- https://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html
- memory management https://en.cppreference.com/w/c/memory/calloc
- program utilities https://en.cppreference.com/w/c/program
- string conversions https://en.cppreference.com/w/c/string
- random numbers https://en.cppreference.com/w/c/numeric/random
- algorithms https://en.cppreference.com/w/c/algorithm

C è¯­è¨€æ ‡å‡†åº“é€šå¸¸æŒ‡å„ä¸ªæ ‡å‡†æ–‡ä»¶å¤´æä¾›çš„ç¼–ç¨‹æ¥å£ï¼Œè€Œå…¶ä¸­æœ‰ä¸€ä¸ªåç§°å°±å«æ ‡å‡†åº“ï¼Œ`<stdlib.h>`ï¼Œè¿™ä¹Ÿå¯èƒ½æ˜¯æœ€ä¸ºå¤æ‚çš„ä¸€ä¸ªåº“æ–‡ä»¶ã€‚

æä¾›çš„åŠŸèƒ½å¦‚ä¸‹ï¼š

- C memory management library
    - `void* malloc( size_t size )` ç”³è¯·æœªç»åˆå§‹åŒ–çš„å†…å­˜ã€‚
    - `void* calloc( size_t num, size_t typesize ` ç”³è¯·æ¸…é›¶çŠ¶æ€çš„å†…å­˜ï¼Œå‰ç¼€ c è¡¨ç¤º clearï¼Œå³å¡«å……é›¶å€¼ã€‚
    - `void* realloc( void *ptr, size_t new_size )` é‡æ–°ç”³è¯·ï¼Œæœ‰å¯èƒ½åœ¨æ–°çš„åŒºåŸŸç”³è¯·ï¼Œå¹¶å°†åŸå†…å­˜æ‹·è´è¿‡å»ï¼Œæ‰©å±•çš„åŒºåŸŸä¸åˆå§‹åŒ–ã€‚
    - `void* aligned_alloc( size_t alignment, size_t size )` (`C11`) allocates aligned memory
    - `void  free( void* ptr )` deallocates previously allocated memory
- Program termination
    - `void abort(void)` (until C11) 
    - `_Noreturn void abort(void)` (since C11) éæ­£å¸¸ç»“æŸç¨‹åºï¼Œé™¤éç›‘å¬äº† SIGABRT ä¿¡å·ï¼Œä¸æ‰§è¡Œ atexit æ³¨å†Œçš„å›è°ƒã€‚
    - `void exit( int exit_code )` (until C11) æ­£å¸¸ç»“æŸï¼Œä¼šå®Œå…¨æ‰§è¡Œç†æ¸…å·¥ä½œã€‚
    - `_Noreturn void exit( int exit_code )` (since C11) 
    - `_Noreturn void quick_exit( int exit_code )` (since C11) å¿«é€Ÿç»“æŸç¨‹åºï¼Œä¸ç­‰å¾…æ¸…ç†ï¼Œåªæ‰§è¡Œ at_quick_exit æ³¨å†Œçš„å›è°ƒã€‚
    - `void _Exit( int exit_code )` (since C99) (until C11) æ­£å¸¸ç»“æŸä¸ç­‰å¾…æ¸…ç†ï¼Œæ–‡ä»¶å…³é—­å–å†³äºå®ç°ï¼Œä¸è°ƒç”¨æ³¨å†Œçš„å›è°ƒï¼ŒåŒ…æ‹¬ quick æ–¹å¼ã€‚
    - `_Noreturn void _Exit( int exit_code )` (since C11) 
    - `int at_quick_exit( void (*func)(void) )` (since C11)  æ³¨å†Œç¨‹åºç»“æŸæ—¶çš„å›è°ƒå‡½æ•°ã€‚
    - `int atexit( void (*func)(void) )`  æ³¨å†Œç¨‹åºå¿«é€Ÿç»“æŸæ—¶çš„å›è°ƒå‡½æ•°ã€‚
    - `EXIT_SUCCESS` å’Œ `EXIT_FAILURE` ä¸¤ä¸ªå®å¸¸é‡è¡¨ç¤ºç¨‹åºé€€å‡ºçš„çŠ¶æ€ç ã€‚
- Communicating with the environment
    - `int system( const char *command )` ç³»ç»Ÿè°ƒç”¨ï¼Œæ‰§è¡Œ shell ç¨‹åºã€‚
    - `char *getenv( const char *name )` (C11) access to the list of environment variables
    - `errno_t getenv_s( size_t *restrict len, char *restrict value, rsize_t valuesz, const char *restrict name )` (since C11) 
- random numbers
    - `int rand()` äº§ç”Ÿä¸€ä¸ªä¼ªéšæœºæ•°ï¼ŒèŒƒå›´ [0, RAND_MAX]
    - `void srand( unsigned seed )` éšæœºç§å­ï¼Œåªåº”è¯¥æ‰§è¡Œä¸€æ¬¡ï¼Œå®è·µä¸­ä½¿ç”¨ `time(0)` ä½œä¸ºç§å­ã€‚
    - `RAND_MAX` éšæœºæ•°çš„æœ€å¤§å€¼ã€‚
- algorithms
    - qsort qsort_s (C11) sorts a range of elements with unspecified type
    - bsearch bsearch_s (C11) searches an array for an element of unspecified type

å­—ç¬¦ä¸²è½¬æ¢å¤„ç†å‡½æ•°ä¸å­—ç¬¦æ ¼å¼åŒ–å†…å®¹ç»„ç»‡åœ¨ä¸€èµ·ã€‚

å†…å­˜ç®¡ç†åº“å‡½æ•°å¯ä»¥è¯´æ˜¯æœ€é‡è¦çš„ä¸€éƒ¨åˆ†ï¼Œç”±äº C è¯­è¨€æ²¡æœ‰å¼•å…¥åŠ¨æ€å†…å­˜å›æ”¶æŠ€æœ¯ï¼Œè¿™ä¹Ÿæ˜¯ C è¯­è¨€æ€§èƒ½æå¥½çš„ä¸€ä¸ªåŸå› ã€‚åŒæ—¶è¿™ç»™ä½¿ç”¨è€…å¸¦æ¥äº†é¢å¤–çš„å†…å­˜ç®¡ç†è´£ä»»ï¼Œå¼€å‘è€…å¿…éœ€è‡ªå·±å®ç°å†…å­˜ç®¡ç†ã€‚

å¯¹ç³»ç»Ÿä¸­è¿è¡Œçš„ç¨‹åºæ¥è¯´ï¼Œæ“ä½œç³»ç»Ÿè¿è¡Œç¨‹åºæ—¶ä¼šä¸‹æ”¾å†…å­˜èµ„æºï¼Œè¿™éƒ¨åˆ†å†…å­˜èµ„æºç§°ä¸º User Spaceã€‚

å¯¹äºç¨‹åºæ¥è¯´ï¼Œä¸»è¦çš„å†…å­˜ç¯å¢ƒå¯ä»¥åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼š

- ç³»ç»Ÿå†…å­˜ç©ºé—´ï¼Œæ“ä½œç³»ç»Ÿè¿è¡Œçš„ç¯å¢ƒä¸­æ‰€æŒæ§çš„å†…å­˜èµ„æºï¼Œç³»ç»Ÿè¿è¡Œæ‰€ä½¿ç”¨çš„éƒ¨åˆ†ç§°ä¸º Kernel spaceï¼›
- ç¨‹åºä½¿ç”¨ç©ºé—´ï¼ŒUser Spaceï¼›

è€Œç¼–è¯‘å™¨é“¾æ¥ç¨‹åºç”Ÿæˆçš„å¯æ‰§è¡Œç¨‹æ—¶ä¹Ÿå¯¹å†…å­˜çš„ç”¨é€”è¿›è¡Œåˆ’åˆ†ï¼Œæœ‰ä¸åŒçš„å†…å­˜åˆ†æ®µå®šä¹‰ï¼š

- .text  è¿™æ˜¯æ•´ä¸ªç”¨æˆ·ç©ºé—´çš„æœ€ä½åœ°å€éƒ¨åˆ†ï¼Œå­˜æ”¾æœºå™¨æŒ‡ä»¤çš„ä½ç½®ã€‚
- .data è¿™é‡Œå­˜æ”¾çš„æ˜¯åˆå§‹åŒ–è¿‡çš„å…¨å±€å˜é‡ã€‚
- .BSS è¿™é‡Œå­˜æ”¾çš„æ˜¯æœªåˆå§‹åŒ–çš„å…¨å±€å˜é‡ã€‚
- Heap å †ï¼Œè¿™æ˜¯éœ€è¦é‡ç‚¹å…³æ³¨çš„åœ°æ–¹ï¼Œå †å†…å­˜å¯ä»¥åœ¨ç¨‹åºè¿è¡Œæ—¶è‡ªè¡Œç”³è¯·åˆ†é…ã€‚
- Mapping Area è¿™é‡Œæ˜¯ä¸ mmap ç³»ç»Ÿè°ƒç”¨ç›¸å…³çš„åŒºåŸŸã€‚é€šå¸¸ malloc å®ç°ä¼šè€ƒè™‘é€šè¿‡ mmap åˆ†é…è¾ƒå¤§å—çš„å†…å­˜åŒºåŸŸã€‚
- Stack è¿™æ˜¯æ ˆåŒºåŸŸï¼Œè‡ªé«˜åœ°å€å‘ä½åœ°å€å¢é•¿ã€‚

ç¨‹åºæ‰§è¡Œæ ˆç©ºé—´ Stack æ˜¯ä¸€ä¸ª FILO - First In Last Out æ•°æ®ç»“æ„ï¼Œç¨‹åºæ‰§è¡Œå‰å°±åœ¨ç³»ç»Ÿçš„å®‰æ’ä¸‹é¢„å…ˆè®¾å®šå¥½ï¼ŒCPU å†…æœ‰ ESP å¯„å­˜å™¨æŒ‡å‘æ ˆé¡¶ï¼Œæœ‰å…¶å®ƒé…ç½®æŒ‡ä»¤ç®¡ç†ï¼Œå¦‚ PUSH/POPã€‚å †å†…å­˜ç©ºé—´ Heap ç”±ç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­é€šè¿‡ malloc ç­‰å‡½æ•°åŠ¨æ€ç”³è¯·åˆ†é…ã€‚

ä¸€èˆ¬æ¥è¯´ï¼Œç³»ç»Ÿåº”è¯¥æä¾›è®¾ç½®ï¼Œæ¥æŒ‡å®šç¨‹åºè¿è¡Œæ—¶ç¯å¢ƒé…ç½®ï¼Œå¦‚ Linux å°±å¯ä»¥é€šè¿‡ ulimit -s è®¾å®šç¨‹åºè¿è¡Œæ—¶çš„ Stack å¤§å°ã€‚

å †å†…å­˜çš„å®ç°æœ‰ä¸åŒçš„å½¢å¼ï¼Œæœ‰ä¸€ç§åšæ³•æ˜¯ï¼ŒæŠŠè¿›ç¨‹çš„å†…å­˜ç®¡ç†äº¤ç»™æ“ä½œç³»ç»Ÿå†…æ ¸å»åšï¼Œä½†å®é™…ä¸Šè¿™æ ·åšçš„æ€§èƒ½æ¯”è¾ƒå·®ï¼ŒåŸå› åœ¨äºæ¯æ¬¡ç¨‹åºç”³è¯·æˆ–è€…é‡Šæ”¾å †ç©ºé—´éƒ½éœ€è¦è¿›è¡Œç³»ç»Ÿè°ƒç”¨ã€‚

æ¯”è¾ƒå¥½çš„åšæ³•å°±æ˜¯ï¼šç¨‹åºå‘æ“ä½œç³»ç»Ÿç”³è¯·ä¸€å—é€‚å½“å¤§å°çš„å †ç©ºé—´ï¼Œç„¶åç”±ç¨‹åºè‡ªå·±ç®¡ç†è¿™å—ç©ºé—´ï¼Œè€Œå…·ä½“æ¥è®²ï¼Œç®¡ç†ç€å †ç©ºé—´åˆ†é…çš„å¾€å¾€æ˜¯ç¨‹åºçš„è¿è¡Œåº“ï¼Œå³ malloc è¿™ç±»å‡½æ•°èƒŒåçš„åº“å®ç°ã€‚è¿™ç§æ–¹å¼ç›¸å½“äºå‘æ“ä½œç³»ç»Ÿæ‰¹å‘ä¸€å—è¾ƒå¤§çš„å†…å­˜ï¼Œåˆ°ç¨‹åºè¿™è¾¹é›¶å”®ï¼Œå½“å†…å­˜ç”¨å®Œå†å‘ç³»ç»Ÿè¦ã€‚

Linux ç³»ç»Ÿä¸‹ï¼Œæä¾›ä¸¤ç§å †ç©ºé—´åˆ†é…æ–¹å¼ï¼Œä¸¤ä¸ªç³»ç»Ÿè°ƒç”¨ï¼š

- `brk()` çš„ä½œç”¨å®é™…ä¸Šå°±æ˜¯è®¾ç½®è¿›ç¨‹æ•°æ®æ®µçš„ç»“æŸåœ°å€ï¼Œå³å®ƒå¯ä»¥æ‰©å¤§æˆ–è€…ç¼©å°æ•°æ®æ®µï¼Œ.data æ•°æ®æ®µå’Œ .BBS æ•°æ®æ®µç»Ÿç§°æ•°æ®æ®µã€‚å°†æ•°æ®æ®µçš„ç»“æŸåœ°å€å‘é«˜åœ°å€ç§»åŠ¨ï¼Œé‚£ä¹ˆæ‰©å¤§çš„é‚£éƒ¨åˆ†ç©ºé—´å°±å¯ä»¥è¢«æˆ‘ä»¬ä½¿ç”¨ï¼ŒæŠŠè¿™å—ç©ºé—´æ‹¿è¿‡æ¥ä½¿ç”¨ä½œä¸ºå †ç©ºé—´æ˜¯æœ€å¸¸è§çš„åšæ³•ã€‚

- `mmap()` å‘æ“ä½œç³»ç»Ÿç”³è¯·ä¸€æ®µè™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œç±»ä¼¼ Windows çš„ VirtualAllocï¼Œï¼ˆå †å’Œæ ˆä¸­é—´ï¼Œç§°ä¸ºæ–‡ä»¶æ˜ å°„åŒºåŸŸçš„åœ°æ–¹ï¼‰è¿™å—è™šæ‹Ÿåœ°å€ç©ºé—´å¯ä»¥æ˜ å°„åˆ°æŸä¸ªæ–‡ä»¶ã€‚

glibc çš„ malloc å‡½æ•°æ˜¯è¿™æ ·å¤„ç†ç”¨æˆ·çš„ç©ºé—´è¯·æ±‚çš„ï¼šå¯¹äºå°äº 128KB çš„è¯·æ±‚æ¥è¯´ï¼Œå®ƒä¼šåœ¨ç°æœ‰çš„å †ç©ºé—´é‡Œé¢ï¼ŒæŒ‰ç…§å †åˆ†é…ç®—æ³•ä¸ºå®ƒåˆ†é…ä¸€å—ç©ºé—´å¹¶è¿”å›ï¼›å¯¹äºå¤§äº128KB çš„è¯·æ±‚æ¥è¯´ï¼Œå®ƒä¼šä½¿ç”¨ mmap() å‡½æ•°ä¸ºå®ƒåˆ†é…ä¸€å—åŒ¿åç©ºé—´ï¼Œç„¶ååœ¨è¿™ä¸ªåŒ¿åç©ºé—´ä¸­ä¸ºç”¨æˆ·åˆ†é…ç©ºé—´ã€‚

è¿™ä¸¤ç§æ–¹å¼åˆ†é…çš„éƒ½æ˜¯è™šæ‹Ÿå†…å­˜ï¼Œæ²¡æœ‰åˆ†é…ç‰©ç†å†…å­˜ã€‚åœ¨ç¬¬ä¸€æ¬¡è®¿é—®å·²åˆ†é…çš„è™šæ‹Ÿåœ°å€ç©ºé—´çš„æ—¶å€™ï¼Œå‘ç”Ÿç¼ºé¡µä¸­æ–­ï¼Œæ“ä½œç³»ç»Ÿè´Ÿè´£åˆ†é…ç‰©ç†å†…å­˜ï¼Œç„¶åå»ºç«‹è™šæ‹Ÿå†…å­˜å’Œç‰©ç†å†…å­˜ä¹‹é—´çš„æ˜ å°„å…³ç³»ã€‚

åœ¨æ ‡å‡† C åº“ä¸­çš„ malloc/free å‡½æ•°åˆ†é…é‡Šæ”¾å†…å­˜ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°åº•å±‚ç”± brkï¼Œmmapï¼Œmunmap è¿™äº›ç³»ç»Ÿè°ƒç”¨å®ç°çš„ã€‚


ä»¥ C è¯­è¨€ä½œä¸ºè®¡ç®—æœºå…¥é—¨çš„åŒå­¦ï¼Œå¯èƒ½å¯¹å†…å­˜ç®¡ç†çš„æ¦‚å¿µä¸æ˜¯å¾ˆé€å½»ã€‚è¦çŸ¥é“ï¼Œè®¡ç®—æœºå®‰è£…çš„ç‰©ç†å†…å­˜æ˜¯æœ‰é™çš„ï¼Œå‡å¦‚ï¼Œç¨‹åºåœ¨è¿è¡Œçš„æ—¶å€™ï¼Œä¸æ–­ç”³è¯·ï¼Œè€Œåˆä¸é‡Šæ”¾ã€‚é‚£ä¹ˆï¼Œç»“æœåªæœ‰ä¸€ä¸ªï¼Œå°±æ˜¯æ‰€æœ‰å†…å­˜éƒ½æ¶ˆè€—å®Œï¼Œæ²¡æœ‰ä¸€ç‚¹ç©ºé—´å¯ç”¨ã€‚

æ›´ä¸¥é‡çš„é—®é¢˜è¿˜åœ¨äºå†…å­˜æ³„éœ² Memory Leak æŒ‡çš„æ˜¯é‚£äº›æ„å¤–ä¸å—æ§åˆ¶çš„å†…å­˜ä¸¢å¤±ï¼Œé€šå¸¸æ˜¯æ²¡æœ‰å°†ç›¸åº”çš„å†…å­˜å›æ”¶ä»£ç ç»„ç»‡å¥½ï¼Œå¯¼è‡´å†…å­˜ä¸çŸ¥åœ¨ä½•å¤„æ¶ˆè€—æ‰ï¼Œè¿™ä¸ªé—®é¢˜é€šå¸¸ä¼šæ¶ˆè€—å¤§é‡çš„è°ƒè¯•æ—¶é—´å»æ’æŸ¥ã€‚

å†…å­˜åªè¦ç”³è¯·æˆåŠŸï¼Œå°±å¿…éœ€è¿›è¡Œé‡Šæ”¾ï¼Œå¦åˆ™ä¸€èµ·å ç”¨å†…å­˜ç›´åˆ°ç¨‹åºç»“æŸã€‚å¯¹äºé•¿æ—¶ä¸é—´æ–­è¿è¡Œçš„ç¨‹åºæ¥è¯´ï¼Œä¸€ç›´å æœ‰å†…å­˜èµ„æºä¸ä¸€å®šæ˜¯ä»¶å¥½äº‹ã€‚

å¦‚æœå†…å­˜ç”³è¯·å¤±è´¥ï¼Œå‡½æ•°è¿”å› null æŒ‡é’ˆï¼Œä¸å¿…å¤„ç†ã€‚


C11 å¼•å…¥çš„åœ°å€å¯¹é½æ–¹å¼ç”³è¯·å†…å­˜ï¼Œåœ¨ç‰¹æ®Šåœºåˆéœ€è¦è¿™æ ·çš„åŠŸèƒ½ã€‚

ç¤ºèŒƒï¼ŒåŠ¨æ€å†…å­˜åˆ†é…ï¼Œä¸åœ°å€å¯¹é½æ–¹å¼åˆ†é…ï¼š

```c
#include <stdio.h>
#include <stdlib.h>
 
int main(void)
{
    int *p1 = malloc(10*sizeof *p1);
    printf("default-aligned addr:   %p\n", (void*)p1);
    free(p1);
 
    int *p2 = aligned_alloc(1024, 1024*sizeof *p2);
    printf("1024-byte aligned addr: %p\n", (void*)p2);
    free(p2);
}
// Possible output:
// default-aligned addr:   0x1e40c20
// 1024-byte aligned addr: 0x1e41000
```

ç¨‹åºä¸ shell å‘½ä»¤äº¤äº’ï¼Œsystem å‡½æ•°å¹¶ä¸èƒ½è·å–å‘½ä»¤çš„è¾“å‡ºå†…ç©ºï¼Œåªèƒ½è·å–å‘½ä»¤çš„æ‰§è¡ŒçŠ¶æ€ç ï¼Œä¼ å…¥ null æŒ‡é’ˆå¯ä»¥æµ‹è¯•æ˜¯å¦å­˜åœ¨å‘½ä»¤å¤„ç†ç¨‹åºã€‚

åœ¨ POSIX ç³»ç»Ÿä¸­ï¼Œè¿”å›å€¼å¯ä»¥ä½¿ç”¨ WEXITSTATUS åŠ WSTOPSIG ç­‰ä¿¡å·åˆ†è§£ï¼Œè¿˜å¯ä»¥ä½¿ç”¨ POSIX ç›¸å…³çš„ popen å‡½æ•°æ¥è·å–å‘½ä»¤è¾“å‡ºå†…å®¹ã€‚

ç¯å¢ƒå˜é‡çš„è®¾ç½®å¯ä»¥ä½¿ç”¨ POSIX è§„èŒƒå‡½æ•° setenv(), unsetenv(), putenv() ç­‰ã€‚ 

ç¨‹åºæ­£å¸¸é€€å‡ºæ—¶ï¼Œæ‰§è¡Œä»¥ä¸‹åŠ¨ä½œï¼Œè€Œ quick_exit ä¸ä¼šæ‰§è¡Œè¿™äº›æ¸…ç†åŠ¨ä½œï¼š

- è°ƒç”¨ atexit æ³¨å†Œçš„å›è°ƒå‡½æ•°ï¼ŒæŒ‰æ³¨å†Œé¡ºåºåå‘æ‰§è¡Œã€‚
- æ® C streams å¯¹è±¡ä¼šæ‰§è¡Œ flushed åŠ closed 
- å…³é—­ tmpfile åˆ›å»ºçš„ä¸´æ—¶æ–‡ä»¶ã€‚
- å°†æ§åˆ¶æƒäº¤è¿˜ä¸»æœºç¯å¢ƒã€‚

ç¨‹åºé€€å‡ºæ§åˆ¶è¿˜æ¶‰åŠç³»ç»Ÿä¿¡å·çš„å¤„ç†ã€‚


### ===ğŸ‘‰ `<ctype.h>` Character type
- https://en.cppreference.com/w/c/string/byte
- https://en.cppreference.com/w/c/string/byte

<ctype.h> æ ‡å‡†å¤´æ–‡ä»¶æä¾›å‡½æ•°ä¸ç¡®å®šå­—ç¬¦æ•°æ®å†…å®¹ç›¸å…³ã€‚

Defined in header <ctype.h>

| Character classification                               |
| isalnum | checks if a character is alphanumeric | (function)  |
| isalpha | checks if a character is alphabetic   | (function)     |
| islower | checks if a character is lowercase   | (function)     |
| isupper | checks if a character is an uppercase character | (function)  |
| isdigit | checks if a character is a digit     | (function)  |
| isxdigit | checks if a character is a hexadecimal character | (function)  |
| iscntrl | checks if a character is a control character | (function)  |
| isgraph | checks if a character is a graphical character | (function)  |
| isspace | checks if a character is a space character | (function)  |
| isblank | checks if a character is a blank character | (function) (C99) |
| isprint | checks if a character is a printing character | (function)  |
| ispunct | checks if a character is a punctuation character | (function)  |
| Character manipulation                             |
| tolower | converts a character to lowercase | (function)  |
| toupper | converts a character to uppercase | (function)  |

```c
/////////////////////////////////
// Defined in header <ctype.h> //
/////////////////////////////////

// Character classification
int isalnum(char ch) // checks if a character is alphanumeric
int isalpha(char ch) // checks if a character is alphabetic
int islower(char ch) // checks if a character is lowercase
int isupper(char ch) // checks if a character is an uppercase character
int isdigit(char ch) // checks if a character is a digit
int isxdigit(char ch) // checks if a character is a hexadecimal character
int iscntrl(char ch) // checks if a character is a control character
int isgraph(char ch) // checks if a character is a graphical character
int isspace(char ch) // checks if a character is a space character
int isblank(char ch) // (C99) checks if a character is a blank character
int isprint(char ch) // checks if a character is a printing character
int ispunct(char ch) // checks if a character is a punctuation character 

// Character manipulation
int tolower(char ch) // converts a character to lowercase
int toupper(char ch) // converts a character to uppercase
```

### ===ğŸ‘‰ `<string.h>` String conversions

C è¯­è¨€çš„å­—ç¬¦ä¸²æœ€å¤§ç‰¹è‰²å°±æ˜¯ Null-terminatedï¼Œå³å­—ç¬¦ä¸²ä»¥å­—ç¬¦ '\0' ä¸ºç»“æŸæ ‡å¿—ã€‚

æ ¹æ®å­—ç¬¦ç¼–ç ï¼Œæ—¢æœ‰å•å­—èŠ‚ã€ä¹Ÿæœ‰å¤šå­—èŠ‚ï¼š

- NTBS - Null-terminated byte string management
- NTMBS - Null-terminated multibyte string management
- NTWS - Null-terminated wide string management

ä¾‹å¦‚ï¼š

- {'\x63','\x61','\x74','\0'} è¡¨ç¤ºä¸€ä¸ª NTBS å­—ç¬¦ä¸²ï¼ŒASCII ç¼–ç å†…å®¹ä¸º "cat"ã€‚
- {'\xe4','\xbd','\xa0','\xe5','\xa5','\xbd','\0'} è¡¨ç¤ºä¸€ä¸ª UTF-8 ç¼–ç  NTMBS å­—ç¬¦ä¸² "ä½ å¥½"ã€‚

UTF-8 ç¼–ç å°±æ˜¯å¸¸ç”¨çš„å¤šå­—èŠ‚ç¼–ç ï¼Œè¿˜æœ‰ GB18030, EUC-JP, Shift-JIS ç­‰å›½å®¶å­—ç¬¦ç¼–ç ï¼Œè€Œ UTF-16 åˆ™æ˜¯åŒå­—èŠ‚ç¼–ç ï¼Œä¹Ÿå«å®½å­—ç¬¦ç¼–ç ã€‚

å­—ç¬¦ä¸²å¤„ç†ç›¸å…³å‡½æ•°çš„å®šä¹‰æ¥æºï¼š

- `<string.h>` å•å­—èŠ‚å®½åº¦å­—ç¬¦ä¸²å¤„ç†å‡½æ•°ã€‚
- `<ctype.h>` æä¾›äº†ä¸€ç³»åˆ—å­—ç¬¦ç±»å‹åˆ¤æ–­å‡½æ•°ã€‚
- æ ‡å‡†åº“æä¾›äº†å¤§é‡å­—ç¬¦ä¸²æ“ä½œå‡½æ•°ã€‚

Conversions to numeric formats 

    | Defined in header <stdlib.h>                             |
    | atof      | converts a byte string to a floating-point value    | (function)
    | atoiatolatoll | converts a byte string to an integer value          | (function) (C99)
    | strtolstrtoll | converts a byte string to an integer value          | (function) (C99)
    | strtoul strtoull  | converts a byte string to an unsigned integer value | (function) (C99)
    | strtofstrtodstrtold | converts a byte string to a floating point value   | (function) (C99)
    | Defined in header <inttypes.h>                              |
    | strtoimaxstrtoumax  | converts a byte string to intmax_t or uintmax_t  | (function) (C99)

String manipulation 

    | Defined in header <string.h>                          |
    | strcpystrcpy_s | copies one string to another  | (function)  (C11)
    | strncpystrncpy_s | copies a certain amount of characters from one string to another  | ( function) (C11)
    | strcatstrcat_s | concatenates two strings  | (function)  (C11)
    | strncatstrncat_s | concatenates a certain amount of characters of two strings  | ( function) (C11)
    | strxfrm | transform a string so that strcmp would produce the same result as strcoll  | (function) 

String examination 

    Defined in header <string.h> 
    | strlenstrnlen_s | returns the length of a given string  | (function) (C11)
    | strcmp | compares two strings  | (function)
    | strncmp | compares a certain amount of characters of two strings  | (function)
    | strcoll | compares two strings in accordance to the current locale  | (function)
    | strchr | finds the first occurrence of a character  | (function)
    | strrchr | finds the last occurrence of a character  | (function)
    | strspn | returns the length of the maximum initial segment that consists
    |       | of only the characters found in another byte string  | (function)
    | strcspn | returns the length of the maximum initial segment that consists
    |       | of only the characters not found in another byte string  | (function)
    | strpbrk | finds the first location of any character in one string, in another string  | (function)
    | strstr  | finds the first occurrence of a substring of characters  | (function)
    | strtokstrtok_s | finds the next token in a byte string  | (function) (C11)

Character array manipulation 

    Defined in header <string.h> 
    | memchr | searches an array for the first occurrence of a character | (function) 
    | memcmp | compares two buffers | (function) 
    | memsetmemset_s | fills a buffer with a character | (function) (C11)
    | memcpymemcpy_s | copies one buffer to another | (function) (C11)
    | memmovememmove_s | moves one buffer to another | (function) (C11)

Miscellaneous 

    Defined in header <string.h> 
    | strerrorstrerror_sstrerrorlen_s | returns a text version of a given error code | (function) (C11)


## ==âš¡ `<setjmp.h>` Nonlocal jumps
- https://en.cppreference.com/w/c/program
- https://en.cppreference.com/w/c/language/array

åœ¨ C è¯­è¨€ä¸­ï¼Œgoto è¯­å¥åªèƒ½åœ¨å‡½æ•°ä½“å†…éƒ¨å„ label é—´è·³è½¬ï¼Œä½†ä¸èƒ½è·³è½¬åˆ°å¦ä¸€ä¸ªå‡½æ•°ä¸­ã€‚é€šè¿‡ setjmp å’Œ longjmp å¯ä»¥å®ç°è¿™ç§ç±»å‹çš„åˆ†æ”¯è·³è½¬ï¼Œå¹¶ä¸”å¯ä»¥å®ç°ç±»ä¼¼ try-catch è¿™æ ·çš„åŠŸèƒ½ï¼Œæˆ–è€…åç¨‹çš„å®ç°ã€‚

ä½¿ç”¨æ­¥éª¤ï¼š

- åœ¨ç¨‹åº A å‡½æ•°ä¸­è°ƒç”¨ `setjmp` ä¿å­˜å½“å‰æ‰§è¡Œç¯å¢ƒåˆ° `jmp_buf`ï¼›
- åœ¨å¦ä¸€å‡½æ•° B ä¸­è°ƒç”¨ `longjmp` è·³è½¬åˆ°ä¸Šé¢ä¿å­˜çš„ `jmp_buf`ï¼Œå¹¶ä¼ å…¥ä¸€ä¸ªå€¼;
- ç¨‹åºè¿”å›åˆ° A å‡½æ•°ï¼Œæ­¤æ—¶æ‰§è¡Œç‚¹åˆå›åˆ°è°ƒç”¨ `setjmp` çš„è¿”å›å¤„ï¼Œä¸”è¿”å›å€¼æ˜¯ `longjmp` ä¼ å…¥çš„å€¼ã€‚

æ‰§è¡Œç¯å¢ƒï¼Œç®€å•åœ°è¯´ï¼Œå°±æ˜¯ CPU åœ¨æŸä¸ªæ—¶é—´ä¸­çš„å¯„å­˜å™¨ã€å†…å­˜çŠ¶æ€ï¼Œå¯„å­˜å™¨ä¿å­˜äº†ç¨‹åºæ‰§è¡Œçš„å¿…è¦ä¿¡æ¯ï¼Œä»¥ x86 ä¸ºä¾‹ï¼š

- ESP ä¿å­˜å½“å‰æ ˆé¡¶çš„åœ°å€ã€‚
- EBP ä¿å­˜å½“å‰å‡½æ•°æ ˆå¸§çš„åœ°å€ï¼Œå³ä¸€ä¸ªæŒ‡é’ˆï¼Œå‡½æ•°é€šè¿‡æ ˆæŒ‡é’ˆåŠ åç§»è·å–å‡½æ•°çš„å‚æ•°ã€‚
- EIP ä¿å­˜ä¸‹ä¸€æ¡è¦æ‰§è¡Œçš„æŒ‡ä»¤åœ°å€ã€‚

å‡½æ•°çš„è°ƒç”¨çº¦å®š calling conventions åŒ…å«å‚æ•°çš„å…¥æ ˆé¡ºåºï¼Œå¯¹å¯„å­˜å™¨ä¹Ÿæœ‰å½±å“ï¼Œä»¥ x86 cdeclï¼Œå³ C è¯­è¨€å‡½æ•°çš„è°ƒç”¨çº¦å®šä¸ºä¾‹ï¼š

- å‡½æ•°å‚æ•°é€šè¿‡æ ˆä¼ é€’ï¼Œå‚æ•°åˆ—è¡¨æŒ‰ä»å³åˆ°å·¦é¡ºåºå‹å…¥æ ˆå†…å­˜ï¼Œå¹¶ä¸”ç”±è°ƒç”¨è€…è´Ÿè´£æ¸…ç†æ ˆä¸­çš„å‚æ•°ã€‚
- æ•´å‹å€¼å’Œå†…å­˜åœ°å€é€šè¿‡ EAX è¿”å›ã€‚
- EAX, ECX, EDX ç”±è°ƒç”¨è€…è´Ÿè´£ä¿å­˜ï¼Œå…¶ä½™çš„ç”±è¢«è°ƒå‡½æ•°è´Ÿè´£ä¿å­˜ã€‚

æ‰€ä»¥ï¼Œ`setjmp` ç›¸å½“äºä¸€ä¸ªç°åœºä¿æŠ¤å‡½æ•°ï¼Œè€Œ `longjmp` å°±æ˜¯ä¸€ä¸ªç°åœºæ¢å¤å‡½æ•°ã€‚

è°ƒç”¨ `setjmp` çš„ä¸Šä¸‹æ–‡å¿…éœ€æ˜¯ä»¥ä¸‹ if, switch, while, do-while, for å‡ ç§æµç¨‹æ§åˆ¶ç»“æ„ä¸­ï¼ŒåŒ…æ‹¬å®Œæ•´çš„ `setjmp` è¡¨è¾¾å¼ï¼Œå…¶å®ƒä½ç½®ä½¿ç”¨äº§ç”Ÿä¸ç¡®å®šè¡Œä¸ºï¼š

```c
switch(setjmp(env)) { /*...*/ }
if(setjmp(env) > 10) { /*...*/ }
while(!setjmp(env)) { /*...*/ }

// the entire expression of an expression statement (possibly cast to void).
setjmp(env);
```

ç¤ºèŒƒï¼Œæ¨¡æ‹Ÿä¸€ä¸ªå¾ªç¯ç»“æ„ï¼š

```c
#include <stdio.h>
#include <setjmp.h>
#include <stdnoreturn.h>
 
jmp_buf jump_buffer;
 
noreturn void a(int count) 
{
    printf("a(%d) called\n", count);
    longjmp(jump_buffer, count+1); // will return count+1 out of setjmp
}
 
int main(void)
{
    volatile int count = 0; // local vars must be volatile for setjmp
    if (setjmp(jump_buffer) != 9)
        a(count++);
}
```

Output:

    a(0) called
    a(1) called
    a(2) called
    a(3) called
    a(4) called
    a(5) called
    a(6) called
    a(7) called
    a(8) called

æ¨¡ä»¿é”™è¯¯æ•æ‰ï¼š

```c
static jmp_buf env;

double divide(double to, double by)
{
    if(by == 0)
        longjmp(env, 1);
    return to / by;
}

void f() 
{
    if (setjmp(env) == 0)
        divide(2, 0);
    else
        printf("Cannot / 0");
    printf("done");
}
```

å¤´æ–‡ä»¶æä¾›ä¸¤ä¸ªå‡½æ•°å’Œä¸€ä¸ªç±»å‹å®šä¹‰ï¼š

```c
//////////////////////////////////
// Defined in header <setjmp.h> //
//////////////////////////////////

// Saves the current execution context into a variable env of type jmp_buf. 
#define setjmp(env) /* implementation-defined */

// Loads the execution context env saved by a previous call to setjmp. 
void longjmp( jmp_buf env, int status ); // (until C11)
_Noreturn void longjmp( jmp_buf env, int status ); // (since C11)

// execution context type
typedef /* unspecified */ jmp_buf;
```

The `jmp_buf` type is an array type suitable for storing information to restore a calling environment. The stored information is sufficient to restore execution at the correct block of the program and invocation of that block. The state of floating-point status flags, or open files, or any other data is not stored in an object of type `jmp_buf`.

`setjmp` saves the current execution context into a variable env of type `jmp_buf`. This variable can later be used to restore the current execution context by `longjmp` function. That is, when a call to `longjmp` function is made, the execution continues at the particular call site that constructed the `jmp_buf` variable passed to `longjmp`. In that case setjmp returns the value passed to `longjmp`.

`longjmp` loads the execution context env saved by a previous call to `setjmp`. This function does not return. Control is transferred to the call site of the macro `setjmp` that set up env. That `setjmp` then returns the value, passed as the status.

If the function that called `setjmp` has exited (whether by return or by a different `longjmp` higher up the stack), the behavior is undefined. In other words, only long jumps up the call stack are allowed.

Jumping across threads (if the function that called `setjmp` was executed by another thread) is also undefined behavior.

(since C11)
If when `setjmp` was called, a VLA or another variably-modified type variable was in scope and control left that scope, `longjmp` to that `setjmp` invokes undefined behavior even if control remained within the function.

On the way up the stack, `longjmp` does not deallocate any VLAs, memory leaks may occur if their lifetimes are terminated in this way:

    void g(int n)
    {
        int a[n]; // a may remain allocated
        h(n); // does not return
    }
    void h(int n)
    {
        int b[n]; // b may remain allocated
        longjmp(buf, 2); // might cause a memory leak for h's b and g's a
    }

ä»¥ä¸Šä»£ç ç‰‡æ–­ä¸­çš„æ•°ç»„æ˜¯ VLA - Variable-length arraysï¼Œæ³¨æ„å®ƒæ˜¯é€šè¿‡å˜é‡æ¥æŒ‡é’ˆé•¿åº¦çš„ï¼Œæ‰€ä»¥éœ€è¦åœ¨è¿è¡Œæ—¶æ‰èƒ½ç¡®å®é•¿åº¦ï¼Œä¸èƒ½åœ¨ç¼–è¯‘å™¨è¿›è¡Œåˆå§‹åŒ–è®¾ç½®ã€‚

longjmp å‡½æ•°çš„å‚æ•°è§£æï¼š

- `env` -   variable referring to the execution state of the program saved by `setjmp`
- `status`  -   the value to return from `setjmp`. If it is equal to 0, 1 is used instead



## ==âš¡ `<signal.h>` Signals
- https://en.cppreference.com/w/c/program/signal

ä¿¡å·å¤„ç†å‡½æ•°å’Œ Standard Library `<stdlib.h>` Program termination å‡½æ•°æ˜¯æ­é…ä½¿ç”¨çš„ï¼Œ

```c
//////////////////////////////////
// Defined in header <signal.h> //
//////////////////////////////////

// sets a signal handler for particular signal
void (*signal( int sig, void (*handler) (int))) (int);

// Sends signal sig to the program. The signal handler, specified using signal(), is invoked.
int raise( int sig );

// An integer type which can be accessed as an atomic entity even in the presence of asynchronous interrupts made by signals.
typedef /* unspecified */ sig_atomic_t;

#define SIGTERM /*implementation defined*/
#define SIGSEGV /*implementation defined*/
#define SIGINT /*implementation defined*/
#define SIGILL /*implementation defined*/
#define SIGABRT /*implementation defined*/
#define SIGFPE /*implementation defined*/
```

ä¿¡å·å¤„ç†å›è°ƒå‡½æ•°å¿…éœ€æŒ‡å®šä¸ºä»¥ä¸‹ä¹‹ä¸€ï¼š

- `SIG_DFL` macro. The signal handler is set to default signal handler.
- `SIG_IGN` macro. The signal is ignored.
- pointer to a function. The signature of the function must be equivalent to `void fun(int sig);`

SIG_DFL å’Œ SIG_IGN æ˜¯ä¸¤ç§ä¸åŒçš„ä¿¡å·å¤„ç†ç­–ç•¥ï¼Œå¦å¤– SIG_ERR å®šä¹‰äº†æ³¨å†Œä¿¡å·å¤„ç†å‡½æ•°å¤±è´¥æ—¶è¿”å›çš„ `void (*)(int)` å‡½æ•°æŒ‡é’ˆç±»å‹ã€‚

ä¿¡å·å¸¸é‡ Signal typesï¼š

    | Constant |                           Explanation                           |
    |----------|-----------------------------------------------------------------|
    | SIGTERM  | termination request, sent to the program                        |
    | SIGSEGV  | invalid memory access (segmentation fault)                      |
    | SIGINT   | external interrupt, usually initiated by the user               |
    | SIGILL   | invalid program image, such as invalid instruction              |
    | SIGABRT  | abnormal termination condition, as is e.g. initiated by abort() |
    | SIGFPE   | erroneous arithmetic operation such as divide by zero           |

ç¤ºèŒƒï¼š

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

volatile sig_atomic_t gSignalStatus = 0;

void signal_handler(int signal)
{
    printf("Received signal %d\n", signal);
    gSignalStatus = signal;
}
 
int main(void)
{
    /* Install a signal handler. */
    if (signal(SIGTERM, signal_handler) == SIG_ERR)
    {
        printf("Error while installing a signal handler.\n");
        exit(EXIT_FAILURE);
    }
 
    printf("Sending signal %d\n", SIGTERM);
    if (raise(SIGTERM) != 0)
    {
        printf("Error while raising the SIGTERM signal.\n");
        exit(EXIT_FAILURE);
    }
 
    printf("Exit main()\n");
    return EXIT_SUCCESS;
}
```

Output:

    Sending signal 15
    Received signal 15
    Exit main()



## ==âš¡ `<inttypes.h>` & `<stdint.h>`
- https://en.cppreference.com/w/c/types/integer
- https://en.cppreference.com/w/c/types/limits

C99 æä¾›äº†ä¸¤ä¸ªæ•´å½¢è·¨å¹³å°çš„å¤´æ–‡ä»¶ï¼Œæ—§çš„æ•´å½¢å®šä¹‰ä¸æ–¹ä¾¿åœ¨è·¨å¹³å°ä¸­ä½¿ç”¨ï¼Œä¾‹å¦‚åœ¨åµŒå…¥å¼å¼€å‘ä¸­å¸¸å¸¸éœ€è¦ 16-bit çš„æ•°æ®ç±»å‹ï¼Œå¹¶ä¸”ç”±äºåµŒå…¥å¼å†…å­˜ç´§å‡‘ï¼Œéœ€è¦æ›´ç»†è‡´çš„æ§åˆ¶æ•°æ®èŒƒå›´ã€‚C99 æä¾›çš„å®šå®½æ•´å½¢ int8_tã€int16_tã€int32_t å¯ä»¥å¾ˆæ–¹ä¾¿åœ°æ ¹æ®éœ€è¦ä½¿ç”¨ï¼Œå®½åº¦èŒƒå›´æ˜¾å¼æŒ‡å®šï¼Œæ—¢æ¸…æ™°ä¹Ÿç›´è§‚ã€‚

- `<inttypes.h>` Format conversion of integer types
- `<stdint.h>` Fixed width integer types

```c
typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;
```

é™¤äº†ä»¥ä¸Šè¿™å¥— int å’Œ uint å®šå®½ç±»å‹ï¼Œè¿˜æœ‰ int_fast, int_least, uint_fast, uint_least ç±»å‹ã€‚

- fast è¡¨ç¤º fastest signed integer typeï¼Œæ ¹æ®æœºå™¨é€‰æ‹©å®½åº¦ï¼Œè‡³å°‘ä¸ºç±»å‹åå­—ä¸­æ•°å­—æŒ‡å®šçš„å®½åº¦ã€‚
- least è¡¨ç¤º smallest signed integer typeï¼Œæ ¹æ®æœºå™¨é€‰æ‹©å®½åº¦ï¼Œè‡³å°‘ä¸ºç±»å‹åå­—ä¸­æ•°å­—æŒ‡å®šçš„å®½åº¦ã€‚

å¦å¤–è¿˜å®šä¹‰äº†å„ç§å®å¸¸é‡ï¼Œå¦‚ï¼š

```c
#define INT8_MIN         (-127i8 - 1)
#define INT16_MIN        (-32767i16 - 1)
#define INT32_MIN        (-2147483647i32 - 1)
#define INT64_MIN        (-9223372036854775807i64 - 1)
#define INT8_MAX         127i8
#define INT16_MAX        32767i16
#define INT32_MAX        2147483647i32
#define INT64_MAX        9223372036854775807i64
#define UINT8_MAX        0xffui8
#define UINT16_MAX       0xffffui16
#define UINT32_MAX       0xffffffffui32
#define UINT64_MAX       0xffffffffffffffffui64
```

ä½¿ç”¨æ—¶ï¼Œé€šå¸¸å¼•å…¥ `<inttypes.h>` å³å¯ï¼Œå®ƒåŒ…å«äº†å®šå®½æ•´å½¢çš„æ ¼å¼å®šä¹‰ï¼Œä¹Ÿä¼šå¼•å…¥ `<stdint.h>`ã€‚

```cpp
#include <stdio.h>
#include <inttypes.h>
 
int main(void)
{
    printf("%zu\n", sizeof(int64_t));
    printf("%s\n", PRId64);
    printf("%+"PRId64"\n", INT64_MIN);
    printf("%+"PRId64"\n", INT64_MAX);
 
    int64_t n = 7;
    printf("%+"PRId64"\n", n);
}
// Possible output:

// 8
// lld
// -9223372036854775808
// +9223372036854775807
// +7
```

å¦‚æœä½¿ç”¨ C++11 ç¼–è¯‘ï¼Œä»¥ä¸Š PRId64 å®å®šä¹‰æ ¼å¼åŒ–å­—ç¬¦ä¸²éœ€è¦åŠ ç©ºæ ¼ã€‚


## ==âš¡ `<limits.h>` `<float.h>` `<stdint.h>` Limits of library types
- https://en.cppreference.com/w/c/types/limits
- The IEEE 754 Format http://mathcenter.oxford.emory.edu/site/cs170/ieee754/
- Numerical Computation Guide https://docs.oracle.com/cd/E19957-01/806-3568/ncgTOC.html
- CIS-77 Introduction to Computer Systems - Bits, Numbers Representation http://www.c-jump.com/CIS77/CPU/Numbers/index.html

Implementation-defined Limits: `<limits.h>` and `<float.h>`

ç”±äºæµ®ç‚¹æ•°çš„æœ‰æœ€å°ç²¾åº¦çº¦æŸï¼Œä¸€èˆ¬æ¯”è¾ƒæµ®ç‚¹æ•°æ—¶ï¼Œä¸ç›´æ¥è¿›è¡Œæ¯”è¾ƒï¼Œè€Œæ˜¯æ¯”è¾ƒå·®å€¼æ˜¯å¦è¶…è¿‡æœ€å°ç²¾åº¦å€¼ï¼Œå³ FLT_EPSILON DBL_EPSILON LDBL_EPSILON æŒ‡å®šçš„è¯¯å·®å€¼ã€‚

ANSI/IEEE Std 754-1985 æµ®ç‚¹æ ‡å‡†æ˜¯æœ€åº”ç”¨æœ€å¹¿æ³›çš„äºŒè¿›åˆ¶æµ®ç‚¹æ•°ç®—æœ¯æ ‡å‡†ï¼Œè¢«è®¸å¤š CPU ä¸æµ®ç‚¹è¿ç®—å™¨æ‰€é‡‡ç”¨ã€‚

IEEE æµ®ç‚¹æ•°æ ‡å‡†æ˜¯ä»é€»è¾‘ä¸Šç”¨ä¸‰å…ƒç»„ {Sï¼ŒEï¼ŒM} æ¥è¡¨ç¤ºä¸€ä¸ªæ•° V çš„ï¼Œå³ V=(-1)SÃ—MÃ—2^Eã€‚

ç¬¦å·ä½ S (sign bit) å†³å®šæ•°çš„æ­£è´Ÿï¼Œæ˜¯æ­£æ•° S=0ï¼Œæ˜¯è´Ÿæ•° S=1ï¼Œè€Œå¯¹äºæ•°å€¼ 0 çš„ç¬¦å·ä½è§£é‡Šåˆ™ä½œä¸ºç‰¹æ®Šæƒ…å†µå¤„ç†ã€‚

æœ‰æ•ˆæ•°å­—ä½ M (Significand) æ˜¯äºŒè¿›åˆ¶å°æ•°ï¼Œåœ¨å†…å­˜è®°å½•ä¸­ä½¿ç”¨ç§‘å­¦è®¡æ•°æ³•ï¼ŒäºŒè¿›åˆ¶è¡¨è¾¾çœç•¥å¼€å¤´çš„ 1ï¼Œè¿™æ ·å¯ä»¥å¤šåˆ©ç”¨ä¸€ä¸ª bit æ¥å¢åŠ æœ‰æ•ˆç²¾åº¦ã€‚å®ƒçš„å–å€¼èŒƒå›´ä¸º 1 ~ 2^-Îµï¼Œæˆ–è€…ä¸º 0 ~ 1^-Îµã€‚å®ƒä¹Ÿè¢«ç§°ä¸ºå°¾æ•°ä½ Mantissaã€ç³»æ•°ä½ Coefficientï¼Œç”šè‡³è¿˜è¢«ç§°ä½œâ€œå°æ•°â€ã€‚

æŒ‡æ•°ä½ E (Exponent Bias) æ˜¯ 2 çš„å¹‚ï¼Œå¯èƒ½æ˜¯è´Ÿæ•°ï¼Œå®ƒçš„ä½œç”¨æ˜¯å¯¹æµ®ç‚¹æ•°åŠ æƒã€‚

IEEE 754 è§„å®šäº† 3 ç§è¡¨ç¤ºæµ®ç‚¹æ•°å€¼æ ¼å¼ï¼Œå¯¹åº” C89 è§„èŒƒçš„ä¸‰ç§æµ®ç‚¹ç±»å‹ï¼š

    |     IEEE Precision     |    C/C++    |   bits  | ç¬¦å·ä½ | æŒ‡æ•°ä½ | æœ‰æ•ˆä½  | åè¿›ä½    |   æœ€å°è§„æ ¼æ­£æ•´æ•°   |   æœ€å¤§è§„æ ¼æ­£æ•´æ•°   |
    |------------------------|-------------|---------|--------|--------|---------|---------|-------------------|-------------------|
    | single                 | float       | 32bits  | 1 bit  | 8 bit  | 24 bit  | 6 ~ 9   | 1.175... 10e-38   | 3.402... 10e+38   |
    | double                 | double      | 64bits  | 1 bit  | 11 bit | 53 bit  | 15 ~ 17 | 2.225... 10e-308  | 1.797... 10e+308  |
    | double extended(SPARC) | long double | 128bits | 1 bit  | 15 bit | 113 bit | 33 ~ 36 | 3.362... 10e-4932 | 1.189... 10e+4932 |

åŒç²¾åº¦æ‰©å±•æ ¼å¼åœ¨ x86 å¹³å°ä¸­å®šä¹‰ä¸º 4 ä¸ªéƒ¨åˆ†ï¼Œ1-bit ç¬¦å·ä½ï¼Œ15-bit æŒ‡æ•°ä½ï¼Œ1-bit æ˜¾å¼å‰å¯¼æœ‰æ•ˆä½ï¼Œç§°ä¸º jï¼Œå‰©ä¸‹ 63-bit æœ‰æ•ˆä½(ä¸åŒ…æ‹¬éšå«ä½)ã€‚

æ³¨æ„æœ‰æ•ˆä½ï¼Œå› ä¸ºéšå«çœç•¥çš„å‰ç¼€ 1ï¼Œæ‰€ä»¥å¢åŠ äº† 1 bit æœ‰æ•ˆä½ã€‚

å¦å¤–ï¼Œè§„æ ¼æ•°å’Œæ¬¡è§„æ ¼æ•° Normal å’Œ Subnormal ä¸¤ç§æ•°å€¼å·®åˆ«åœ¨äºï¼Œæ­£è§„æ•°æœ‰æ•ˆæ•°å­—çš„å‰å¯¼ä½ä¸º 1 å³äºŒè¿›åˆ¶æµ®ç‚¹å·¦ä¾§çš„ä¸€ä¸ª bitï¼Œè€Œæ¬¡æ­£è§„æ•°æœ‰æ•ˆæ•°å­—çš„å‰å¯¼ä½ä¸º 0ï¼Œæ¬¡æ­£è§„æ•°ä¹Ÿç§°ä¸ºéæ­£è§„æ•°ã€‚

è¯·æ³¨æ„ï¼Œå•ç²¾åº¦ã€åŒç²¾åº¦ï¼Œå¯¹åº” e < 255 æ—¶ï¼Œe < 2047 æ—¶ï¼Œèµ‹äºˆæµ®ç‚¹æ ¼å¼ä½æ¨¡å¼çš„å€¼ä½¿ç”¨ä»¥ä¸‹æ–¹æ³•æ„æˆï¼šå°†äºŒè¿›åˆ¶åŸºæ•°ç‚¹æ’å…¥åˆ°ç´§é‚»å°æ•°æœ€é«˜æœ‰æ•ˆä½çš„å·¦ä¾§ï¼Œå°†ä¸€ä¸ªéšå«ä½æ’å…¥åˆ°ç´§é‚»äºŒè¿›åˆ¶ç‚¹çš„å·¦ä¾§ã€‚å¦‚æ­¤æ„æˆçš„æ•°å­—ç§°ä¸ºæœ‰æ•ˆæ•°å­—ï¼Œç§°ä¸ºéšå«ä½ï¼ŒåŸå› æ˜¯åœ¨åŒç²¾åº¦æ ¼å¼ä½æ¨¡å¼ä¸­æ²¡æœ‰æ˜¾å¼æŒ‡å®šå…¶å€¼ï¼Œä½†åç½®æŒ‡æ•°å­—æ®µçš„å€¼éšå¼æŒ‡å®šäº†è¯¥å€¼ã€‚å› è€Œä»¥äºŒè¿›åˆ¶ä½ç½®è¡¨ç¤ºæ³•æ¥è¡¨ç¤ºä¸€ä¸ªå¸¦åˆ†æ•°ï¼ˆæ•´æ•°åŠ å°æ•°ï¼Œå…¶ä¸­ 0 â‰¤ å°æ•° < 1ï¼‰ã€‚

The header `<limits.h>` defines constants for the sizes of integral types. The values below are acceptable minimum magnitudes; larger values may be used. 

    | Constants |         Value          |           Description           |
    |-----------|------------------------|---------------------------------|
    | CHAR_BIT  | 8                      | bits in a char                  |
    | CHAR_MAX  | UCHAR_MAX or SCHAR_MAX | maximum value of char           |
    | CHAR_MIN  | 0 or SCHAR_MIN         | maximum value of char           |
    | INT_MAX   | 32767                  | maximum value of int            |
    | INT_MIN   | -32767                 | minimum value of int            |
    | LONG_MAX  | 2147483647             | maximum value of long           |
    | LONG_MIN  | -2147483647            | minimum value of long           |
    | SCHAR_MAX | +127                   | maximum value of signed char    |
    | SCHAR_MIN | -127                   | minimum value of signed char    |
    | SHRT_MAX  | +32767                 | maximum value of short          |
    | SHRT_MIN  | -32767                 | minimum value of short          |
    | UCHAR_MAX | 255                    | maximum value of unsigned char  |
    | UINT_MAX  | 65535                  | maximum value of unsigned int   |
    | ULONG_MAX | 4294967295             | maximum value of unsigned long  |
    | USHRT_MAX | 65535                  | maximum value of unsigned short |

The names in the table below, a subset of `<float.h>`, are constants related to floating-point arithmetic. When a value is given, it represents the minimum magnitude for the corresponding quantity. Each implementation defines appropriate values. 

    |  Constants   | Value |                    Description                    |
    |--------------|-------|---------------------------------------------------|
    | FLT_RADIX    |     2 | radix of exponent, representation, e.g., 2, 16    |
    | FLT_ROUNDS   |       | floating-point rounding mode for addition         |
    | FLT_DIG      |     6 | decimal digits of precision                       |
    | FLT_EPSILON  |  1E-5 | smallest number x such that 1.0+x != 1.0          |
    | FLT_MANT_DIG |       | number of base FLT_RADIX in mantissa              |
    | FLT_MAX      | 1E+37 | maximum floating-point number                     |
    | FLT_MAX_EXP  |       | maximum n such that FLT_RADIXn-1 is representable |
    | FLT_MIN      | 1E-37 | minimum normalized floating-point number          |
    | FLT_MIN_EXP  |       | minimum n such that 10n is a normalized number    |
    | DBL_DIG      |    10 | decimal digits of precision                       |
    | DBL_EPSILON  |  1E-9 | smallest number x such that 1.0+x != 1.0          |
    | DBL_MANT_DIG |       | number of base FLT_RADIX in mantissa              |
    | DBL_MAX      | 1E+37 | maximum double floating-point number              |
    | DBL_MAX_EXP  |       | maximum n such that FLT_RADIXn-1 is representable |
    | DBL_MIN      | 1E-37 | minimum normalized double floating-point number   |
    | DBL_MIN_EXP  |       | minimum n such that 10n is a normalized number    |

ä»¥ä¸‹ä¸º `<stdint.h>` å¤´æ–‡ä»¶ä¸­å®šä¹‰çš„æ•´å½¢é™åˆ¶å¸¸é‡ï¼š

    | PTRDIFF_WIDTH    | (C23) bit width of object of ptrdiff_t type        |
    | PTRDIFF_MIN      | (C99) minimum value of object of ptrdiff_t type    |
    | PTRDIFF_MAX      | (C99) maximum value of object of ptrdiff_t type    |
    | SIZE_WIDTH       | (C23) bit width of object of size_t type           |
    | SIZE_MAX         | (C99) maximum value of object of size_t type       |
    | SIG_ATOMIC_WIDTH | (C23) bit width of object of sig_atomic_t type     |
    | SIG_ATOMIC_MIN   | (C99) minimum value of object of sig_atomic_t type |
    | SIG_ATOMIC_MAX   | (C99) maximum value of object of sig_atomic_t type |
    | WINT_WIDTH       | (C23) bit width of object of wint_t type           |
    | WINT_MIN         | (C99) minimum value of object of wint_t type       |
    | WINT_MAX         | (C99) maximum value of object of wint_t type       |

ä»¥ä¸‹å¸¸é‡å®šä¹‰åœ¨ `<wchar.h>` `<stdint.h>`

    | WCHAR_WIDTH | (C23) bit width of object of wchar_t type     |
    | WCHAR_MIN   | (C99) minimum value of object of wchar_t type |
    | WCHAR_MAX   | (C99) maximum value of object of wchar_t type |


## ==âš¡ `<string.h>` String Functions

There are two groups of string functions defined in the header `<string.h>`. The first have names beginning with str; the second have names beginning with mem. Except for memmove, the behavior is undefined if copying takes place between overlapping objects. Comparison functions treat arguments as unsigned char arrays. 

In the following functions

- variables s and t are of type char * ;
- cs and ct are of type const char * ;
- n is of type size_t;
- and c is an int converted to char. 

- `char *strcpy(s,ct)`    copy string ct to string s, including '\0'; return s. 
- `char *strncpy(s,ct,n)` copy at most n characters of string ct to s; return s. Pad with '\0''s if ct has fewer than n characters. 
- `char *strcat(s,ct)`    concatenate string ct to end of string s; return s. 
- `char *strncat(s,ct,n)` concatenate at most n characters of string ct to string s, terminate s with '\0'; return s. 
- `int strcmp(cs,ct)`     compare string cs to string ct, return < 0 if cs < ct, 0 if cs==ct, or > 0 if cs > ct. 
- `int strncmp(cs,ct,n)`  compare at most n characters of string cs to string ct; return < 0 if cs < ct, 0 if cs==ct, or > 0 if cs > ct. 
- `char *strchr(cs,c)`    return pointer to first occurrence of c in cs or NULL if not present. 
- `char *strrchr(cs,c)`   return pointer to last occurrence of c in cs or NULL if not present. 
- `size_t strspn(cs,ct)`  return length of prefix of cs consisting of characters in ct. 
- `size_t strcspn(cs,ct)` return length of prefix of cs consisting of characters not in ct. 
- `char *strpbrk(cs,ct)`  return pointer to first occurrence in string cs of any character string ct, or NULL if not present. 
- `char *strstr(cs,ct)`   return pointer to first occurrence of string ct in cs, or NULL if not present. 
- `size_t strlen(cs)`     return length of cs. 
- `char *strerror(n)`     return pointer to implementation-defined string corresponding to error n. 
- `char *strtok(s,ct)`    strtok searches s for tokens delimited by characters from ct; see below. 


A sequence of calls of strtok(s,ct) splits s into tokens, each delimited by a character from ct. The first call in a sequence has a non-NULL s, it finds the first token in s consisting of characters not in ct; it terminates that by overwriting the next character of s with '\0' and returns a pointer to the token. Each subsequent call, indicated by a NULL value of s, returns the next such token, searching from just past the end of the previous one. strtok returns NULL when no further token is found. The string ct may be different on each call. 

The mem... functions are meant for manipulating objects as character arrays; the intent is an interface to efficient routines. 

In the following functions

- s and t are of type void * ;
- cs and ct are of type const void * ;
- n is of type size_t;
- and c is an int converted to an unsigned char. 

- `void *memcpy(s,ct,n)`  copy n characters from ct to s, and return s. 
- `void *memmove(s,ct,n)` same as memcpy except that it works even if the objects overlap. 
- `int memcmp(cs,ct,n)`   compare the first n characters of cs with ct; return as with strcmp. 
- `void *memchr(cs,c,n)`  return pointer to first occurrence of character c in cs, or NULL if not present among the first n characters. 
- `void *memset(s,c,n)`   place character c into first n characters of s, return s. 



## ==âš¡ `<stdarg.h>` Variable arguments
- Variadic functions https://en.cppreference.com/w/c/variadic

Variadic functions æ˜¯æŒ‡ç±»ä¼¼ printf è¿™ç§å¯ä»¥æ¥æ”¶å¯å˜é•¿åº¦å‚æ•°çš„å‡½æ•°ï¼Œ`<stdarg.h>` å‡½æ•°åº“æäº† 3 ä¸ªå®å‡½æ•°å’Œä¸€ä¸ªæŒ‡é’ˆç±»å‹ va_listï¼Œå®ƒé€šå¸¸å®šä¹‰ä¸º char ç±»å‹çš„æŒ‡é’ˆï¼Œä»¥æ–¹ä¾¿è¯»å–æ ˆå†…å­˜ä¸­çš„å‚æ•°åˆ—è¡¨ï¼š

```c
///////////////////////////////////
// Defined in header <stdarg.h>  //
///////////////////////////////////

void va_start( va_list ap, parmN );
// enables access to variadic function arguments

void va_copy( va_list dest, va_list src );
// (since C99) makes a copy of the variadic function arguments

T va_arg( va_list ap, T );
// accesses the next variadic function argument

void va_end( va_list ap );
// ends traversal of the variadic function arguments

/* unspecified */ va_list;
// va_list holds the information needed by va_start, va_arg, va_end, and va_copy
```

è¿™äº›å®å®šä¹‰éœ€è¦æŒ‰æ­¥éª¤ä½¿ç”¨ï¼š

- `va_list` å®šä¹‰ä¸€ä¸ªå‚æ•°åˆ—è¡¨å¯¹è±¡ï¼Œå¯ä»¥ç®€å•ç†è§£å®ƒä¸º char æŒ‡é’ˆï¼›
- `va_start` or `va_copy` åˆå§‹åŒ–å‚æ•°åˆ—è¡¨ï¼›
- `va_arg` å®æ‰©å±•åä¼šä» `va_list` æŒ‡å‘çš„å‚æ•°åˆ—è¡¨ä¸­è·å–æŒ‡å®šç±»å‹ T çš„å‚æ•°ï¼Œå¹¶ä¸”ä¼šä¿®æ”¹å‚æ•°åˆ—è¡¨å¯¹è±¡æŒ‡å‘ä¸‹ä¸€ä¸ªå‚æ•°ã€‚
- `va_end` è´Ÿè´£æ¸…ç† `va_start` or `va_copy` åˆå§‹åŒ–è¿‡çš„å‚æ•°åˆ—è¡¨å¯¹è±¡ï¼Œéœ€è¦é…å¯¹ä½¿ç”¨ã€‚

å¦‚æœåˆ›å»ºäº†ä¸€ä¸ª `va_list` å®ä¾‹ï¼Œå¹¶ä¼ é€’ç»™å¦ä¸€ä¸ªå‡½æ•°ï¼Œé€šè¿‡è¯¥å‡½æ•°ä¸­çš„ `va_arg` ä½¿ç”¨è¯¥å®ä¾‹ï¼Œåˆ™è°ƒåº”è¯¥åœ¨è°ƒç”¨ `va_end` ä¹‹å‰è¿›è¡Œã€‚

å°†æŒ‡å‘ `va_list` åˆ—è¡¨å¯¹è±¡çš„æŒ‡é’ˆä¼ é€’ç»™å¦ä¸€ä¸ªå‡½æ•°ï¼Œç„¶ååœ¨å‡½æ•°è¿”å›åä½¿ç”¨è¯¥å¯¹è±¡æ˜¯åˆæ³•çš„ã€‚

`va_arg` å¯ä»¥æ ¹æ®ä¼ å…¥çš„ T ç±»å‹æ¥ç¡®å®šä¸‹ä¸€ä¸ªå‚æ•°çš„åœ°å€åç§»ï¼Œsizeof(T) å°±æ˜¯åç§»å­—èŠ‚æ•°ã€‚

If the type of the next argument in ap (after promotions) is not compatible with T, the behavior is undefined, unless:

- one type is a signed integer type, the other type is the corresponding unsigned integer type, and the value is representable in both types; or
- one type is pointer to void and the other is a pointer to a character type.

If va_arg is called when there are no more arguments in ap, the behavior is undefined.


ç¤ºèŒƒå®ç°ä¸€ä¸ª simple_printfï¼š

```c
#include <stdio.h>
#include <stdarg.h>

void simple_printf(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);

    while (*fmt != '\0') {
        if (*fmt == 'd') {
            int i = va_arg(args, int);
            printf("%d\n", i);
        } else if (*fmt == 'c') {
            // A 'char' variable will be promoted to 'int'
            // A character literal in C is already 'int' by itself
            int c = va_arg(args, int);
            printf("%c\n", c);
        } else if (*fmt == 'f') {
            double d = va_arg(args, double);
            printf("%f\n", d);
        }
        ++fmt;
    }

    va_end(args);
}

int main(void)
{
    simple_printf("dcff", 3, 'a', 1.999, 42.5); 
}
```

Output:

    3
    a
    1.999000
    42.50000


## ==âš¡ `<math.h>` Common mathematics functions
- https://en.cppreference.com/w/c/numeric/math

1. Basic operations
2. Exponential functions
3. Power functions
4. Trigonometric functions
5. Hyperbolic functions
6. Error and gamma functions
7. Nearest integer floating-point operations
8. Floating-point manipulation functions
9. Classification and comparison
10. Types
11. Macro constants

ç»å¯¹å€¼å‡½æ•°å®šä¹‰åœ¨ <stdlib.h> æ–‡ä»¶ä¸­ï¼Œæœ‰ abs, labs, llabs ç­‰å½¢å¼ï¼Œå¯¹åº”ä¸åŒçš„æ•°æ®ç±»å‹ã€‚

åœ¨ <math.h> æ–‡ä»¶ä¸­ä¹Ÿå®šä¹‰äº†å¤šä¸ªå½¢å¼ï¼Œfabs, fabsf, fabslï¼Œéœ€è¦æ ¹æ®æ•°æ®ç±»å‹é€‰æ‹©è¦ä½¿ç”¨çš„ç‰ˆæœ¬ã€‚ 

```c
// <stdlib.h>
int abs (int);
long    labs (long);
long long llabs (long long);

// <math.h>
extern double fabs (double);
extern float fabsf (float);
extern long double fabsl (long double);

// <stdlib.h>
div_t   div (int __numer, int __denom);
ldiv_t  ldiv (long __numer, long __denom);
lldiv_t lldiv (long long __numer, long long __denom);
```



## ==âš¡ `<assert.h>` `<errno.h>` Error handling
- https://www.runoob.com/cprogramming/c-macro-errno.html

æœ‰ä¸¤ä¸ªä¸»è¦ä¸»é”™è¯¯å¤„ç†æä¾›çš„æ–‡ä»¶å¤´ï¼š

- `<assert.h>` Conditionally compiled macro that compares its argument to zero 
- `<errno.h>` Macros reporting error conditions 

æ–­è¨€ assert æ˜¯ä¸€ä¸ªå®å®šä¹‰ï¼Œä½¿ç”¨å®ƒï¼Œå°±å¯ä»¥åœ¨ä»£ç ä¸­æ’å…¥ç”¨äºéªŒè¯çš„ä»£ç ï¼Œå¹¶ä¸”å¯ä»¥é€šè¿‡å®šä¹‰ä¸€ä¸ª NDEBUG ç¬¦å·æ¥æ¸…é™¤è¿™äº›ç”¨äºéªŒè¯çš„ä»£ç ã€‚

æ–­è¨€ä¼šè¯Šæ–­æŒ‡å®šæ¡ä»¶è¡¨è¾¾å¼ï¼Œå¿…éœ€æ˜¯ scalar å€¼ï¼Œå¦‚æœæ¯”è¾ƒç»“æœä¸ä¸º 0ï¼Œé‚£ä¹ˆå°±æ‰“å°è¯Šæ–­ä¿¡æ¯ï¼Œç„¶åè°ƒç”¨æ ‡å‡†åº“çš„ abort() ç»“æŸç¨‹åºã€‚

è¯Šæ–­ä¿¡æ¯åŒ…å«æ¡ä»¶è¡¨è¾¾å¼ã€è¿˜æœ‰æ ‡å‡†çš„å® `__FILE__`, `__LINE__`, `__func__` (since C99)

å¦å¤–ï¼Œé™¤äº†æ–­è¨€ï¼Œè¿˜é™æ€æ–­è¨€ static_assert (C11)ï¼Œå®ƒéœ€è¦åœ¨ç¼–è¯‘æœŸå®Œæˆæ¡ä»¶åˆ¤æ–­æ˜¯å¦ä¸º falseã€‚

    static_assert(2 + 2 == 4, "2+2 isn't 4");      // well-formed
    static_assert(sizeof(int) < sizeof(char),
                "this program requires that int is less than char"); // compile-time error

é€šè¿‡ gcc å‚æ•°å¯ç”¨ C11 æ”¯æŒï¼š

    gcc -g -std=c11 -o file_d file.c


ä»¥ä¸‹åœ¨éè°ƒè¯•æ¨¡å¼ä¸‹ç”Ÿæˆçš„ä»£ç ç›¸å½“äºä»€ä¹ˆä¹Ÿä¸åšçš„ NOP æ±‡ç¼–æŒ‡ä»¤ï¼š

    #define assert(condition) ((void)0)

åœ¨ç¼–è¯‘ç¨‹åºæ—¶ï¼Œå®šä¹‰ NDEBUG ç¬¦å·è¡¨ç¤ºå½“å‰ç¼–è¯‘çš„ç¨‹åºä¸æ˜¯ç”¨äºè°ƒè¯•ï¼Œæ‰€ä»¥ä¸å¿…æ·»åŠ é‚£äº›ç”¨äºè°ƒè¯•ç›®çš„çš„ä»£ç ã€‚

    # Debug
    gcc -g -o file file.c

    # Release
    gcc -D NDEBUG -O2 -o file file.c

é”™è¯¯ç è½¬æ¢ä¿¡æ¯å‡½æ•° strerror ä¼šå°†å¯¹åº”çš„é”™è¯¯ç è½¬æ¢æˆç”¨æˆ·å‹å¥½çš„æ–‡å­—ä¿¡æ¯ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªæ¯«æ— æ„ä¹‰çš„æ•°å­—ã€‚

ç¤ºèŒƒç¨‹åºï¼š

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <assert.h>

extern int errno;

int main() {
  FILE *fp;

  fp = fopen("file.txt", "r");
  if (fp == NULL) {
    fprintf(stderr, "Value of errno: %d\n", errno);
    fprintf(stderr, "Error opening file: %s\n", strerror(errno));
  } else {
    fclose(fp);
  }

  int num;
  printf("Type some number:");
  int succ_count = scanf("%d", &num);
  assert(succ_count==1);
  printf("yes %d! ", num);

  return (0);
}
```

ä¾‹å¦‚ï¼Œä»¥ä¸‹æ–­è¨€å°±å¯ä»¥æ‰“å°å¼‚å¸¸æ‰€åœ¨çš„æ–‡ä»¶ï¼Œè¡Œå·ï¼Œå‡½æ•°åç­‰ä¿¡æ¯ï¼š

```c
#include <stdio.h>
// uncomment to disable assert()
// #define NDEBUG
#include <assert.h>
#include <math.h>
 
int main(void)
{
    double x = -1.0;
    assert(x >= 0.0);
    printf("sqrt(x) = %f\n", sqrt(x));   
 
    return 0;
}
```

æ³¨æ„ï¼Œå¦‚æœæ˜¯æ‰‹åŠ¨ç¼–è¯‘ï¼Œå› ä¸ºä½¿ç”¨ math æ•°å­¦å‡½æ•°åº“ï¼Œå°±éœ€è¦ç»™è¿æ¥ç¨‹åºæ·»åŠ ä¸Š libm.so é“¾æ¥åº“ï¼š

    gcc -g -o file_d file.c -lm

æ³¨æ„ï¼Œå› ä¸ºé“¾æ¥ç¨‹åºåœ¨ç¼–è¯‘ç¨‹åºåé¢è¿è¡Œï¼Œæ‰€ä»¥å‚æ•°ä¹Ÿæ”¾åœ¨åé¢ï¼Œå¦åˆ™é“¾æ¥æ—¶ä¼šæ‰¾ä¸åˆ° sqrt å‡½æ•°å®šä¹‰ã€‚

C++ ä¸­æ²¡æœ‰å•ç‹¬æä¾›æ–­è¨€ï¼Œè¦ä½¿ç”¨ C è¯­è¨€çš„æ–­è¨€è¯·ä½¿ç”¨ä»¥ä¸‹å¯¼å…¥æ–¹å¼ï¼š

```cpp
#include <cassert>
```

