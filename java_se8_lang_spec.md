# The Java¬Æ Language Specification 
          The Java¬Æ Language Specification

                Java SE 8 Edition
                  James Gosling
                  Bill Joy
                  Guy Steele
                  Gilad Bracha
                  Alex Buckley

                  2015-02-13

Java Language and Virtual Machine Specifications ÊñáÊ°£‰∏ªÈ°µÔºö
https://docs.oracle.com/javase/specs/index.html

HTML -> Markdwon ÊñáÊ°£ËΩ¨Êç¢ËÑöÊú¨Ôºö

```js
/// <reference types="node" />
var TurndownService = require('turndown')

var turndownService = new TurndownService()
// var markdown = turndownService.turndown('<h1>Hello world!</h1>')
// process.stdout.write(markdown)

process.stdin.on("data", (it) => {
  // console.log('HTML data:' + it.length + it.toString());
  process.stdout.write(turndownService.turndown(it.toString()));
})
```

```sh
npm install marked turndown
# https://github.com/mixmark-io/turndown
# https://www.npmjs.com/package/marked
cat > list.md << EOF
https://docs.oracle.com/javase/specs/jls/se8/html/jls-0-front.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-0-preface8.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-1.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-1.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-2.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-2.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-7.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-7.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-10.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-10.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-11.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-11.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-16.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-16.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-18.htm
https://docs.oracle.com/javase/specs/jls/se8/html/jls-19.html
https://docs.oracle.com/javase/specs/jls/se8/html/jls-0-index.html
https://docs.oracle.com/javase/specs/jls/se8/html/spec-license.html
EOF
urls=`cat list.md`
# for url in $urls; do echo $url; done
for url in $urls; do 
  curl $url | node index.js >> /c/opendocs/java_se8_lang_spec.md;
done
```

[Legal Notice](jls-0-front.html)

# Table of Contents

[Preface to the Java SE 8 Edition](jls-0-preface8.html)

## üçÄ TOC1. Introduction

[1. Introduction](jls-1.html)
[1.1. Organization of the Specification](jls-1.html#jls-1.1)
[1.2. Example Programs](jls-1.html#jls-1.2)
[1.3. Notation](jls-1.html#jls-1.3)
[1.4. Relationship to Predefined Classes and Interfaces](jls-1.html#jls-1.4)
[1.5. Feedback](jls-1.html#jls-1.5)
[1.6. References](jls-1.html#jls-1.6)

## üçÄ TOC2. Grammars

[2. Grammars](jls-2.html)
[2.1. Context-Free Grammars](jls-2.html#jls-2.1)
[2.2. The Lexical Grammar](jls-2.html#jls-2.2)
[2.3. The Syntactic Grammar](jls-2.html#jls-2.3)
[2.4. Grammar Notation](jls-2.html#jls-2.4)

## üçÄ TOC3. Lexical Structure

[3. Lexical Structure](jls-3.html)
[3.1. Unicode](jls-3.html#jls-3.1)
[3.2. Lexical Translations](jls-3.html#jls-3.2)
[3.3. Unicode Escapes](jls-3.html#jls-3.3)
[3.4. Line Terminators](jls-3.html#jls-3.4)
[3.5. Input Elements and Tokens](jls-3.html#jls-3.5)
[3.6. White Space](jls-3.html#jls-3.6)
[3.7. Comments](jls-3.html#jls-3.7)
[3.8. Identifiers](jls-3.html#jls-3.8)
[3.9. Keywords](jls-3.html#jls-3.9)
[3.10. Literals](jls-3.html#jls-3.10)
[3.10.1. Integer Literals](jls-3.html#jls-3.10.1)
[3.10.2. Floating-Point Literals](jls-3.html#jls-3.10.2)
[3.10.3. Boolean Literals](jls-3.html#jls-3.10.3)
[3.10.4. Character Literals](jls-3.html#jls-3.10.4)
[3.10.5. String Literals](jls-3.html#jls-3.10.5)
[3.10.6. Escape Sequences for Character and String Literals](jls-3.html#jls-3.10.6)
[3.10.7. The Null Literal](jls-3.html#jls-3.10.7)
[3.11. Separators](jls-3.html#jls-3.11)
[3.12. Operators](jls-3.html#jls-3.12)

## üçÄ TOC4. Types, Values, and Variables

[4. Types, Values, and Variables](jls-4.html)
[4.1. The Kinds of Types and Values](jls-4.html#jls-4.1)
[4.2. Primitive Types and Values](jls-4.html#jls-4.2)
[4.2.1. Integral Types and Values](jls-4.html#jls-4.2.1)
[4.2.2. Integer Operations](jls-4.html#jls-4.2.2)
[4.2.3. Floating-Point Types, Formats, and Values](jls-4.html#jls-4.2.3)
[4.2.4. Floating-Point Operations](jls-4.html#jls-4.2.4)
[4.2.5. The `boolean` Type and boolean Values](jls-4.html#jls-4.2.5)
[4.3. Reference Types and Values](jls-4.html#jls-4.3)
[4.3.1. Objects](jls-4.html#jls-4.3.1)
[4.3.2. The Class `Object`](jls-4.html#jls-4.3.2)
[4.3.3. The Class `String`](jls-4.html#jls-4.3.3)
[4.3.4. When Reference Types Are the Same](jls-4.html#jls-4.3.4)
[4.4. Type Variables](jls-4.html#jls-4.4)
[4.5. Parameterized Types](jls-4.html#jls-4.5)
[4.5.1. Type Arguments of Parameterized Types](jls-4.html#jls-4.5.1)
[4.5.2. Members and Constructors of Parameterized Types](jls-4.html#jls-4.5.2)
[4.6. Type Erasure](jls-4.html#jls-4.6)
[4.7. Reifiable Types](jls-4.html#jls-4.7)
[4.8. Raw Types](jls-4.html#jls-4.8)
[4.9. Intersection Types](jls-4.html#jls-4.9)
[4.10. Subtyping](jls-4.html#jls-4.10)
[4.10.1. Subtyping among Primitive Types](jls-4.html#jls-4.10.1)
[4.10.2. Subtyping among Class and Interface Types](jls-4.html#jls-4.10.2)
[4.10.3. Subtyping among Array Types](jls-4.html#jls-4.10.3)
[4.10.4. Least Upper Bound](jls-4.html#jls-4.10.4)
[4.11. Where Types Are Used](jls-4.html#jls-4.11)
[4.12. Variables](jls-4.html#jls-4.12)
[4.12.1. Variables of Primitive Type](jls-4.html#jls-4.12.1)
[4.12.2. Variables of Reference Type](jls-4.html#jls-4.12.2)
[4.12.3. Kinds of Variables](jls-4.html#jls-4.12.3)
[4.12.4. `final` Variables](jls-4.html#jls-4.12.4)
[4.12.5. Initial Values of Variables](jls-4.html#jls-4.12.5)
[4.12.6. Types, Classes, and Interfaces](jls-4.html#jls-4.12.6)

## üçÄ TOC5. Conversions and Contexts

[5. Conversions and Contexts](jls-5.html)
[5.1. Kinds of Conversion](jls-5.html#jls-5.1)
[5.1.1. Identity Conversion](jls-5.html#jls-5.1.1)
[5.1.2. Widening Primitive Conversion](jls-5.html#jls-5.1.2)
[5.1.3. Narrowing Primitive Conversion](jls-5.html#jls-5.1.3)
[5.1.4. Widening and Narrowing Primitive Conversion](jls-5.html#jls-5.1.4)
[5.1.5. Widening Reference Conversion](jls-5.html#jls-5.1.5)
[5.1.6. Narrowing Reference Conversion](jls-5.html#jls-5.1.6)
[5.1.7. Boxing Conversion](jls-5.html#jls-5.1.7)
[5.1.8. Unboxing Conversion](jls-5.html#jls-5.1.8)
[5.1.9. Unchecked Conversion](jls-5.html#jls-5.1.9)
[5.1.10. Capture Conversion](jls-5.html#jls-5.1.10)
[5.1.11. String Conversion](jls-5.html#jls-5.1.11)
[5.1.12. Forbidden Conversions](jls-5.html#jls-5.1.12)
[5.1.13. Value Set Conversion](jls-5.html#jls-5.1.13)
[5.2. Assignment Contexts](jls-5.html#jls-5.2)
[5.3. Invocation Contexts](jls-5.html#jls-5.3)
[5.4. String Contexts](jls-5.html#jls-5.4)
[5.5. Casting Contexts](jls-5.html#jls-5.5)
[5.5.1. Reference Type Casting](jls-5.html#jls-5.5.1)
[5.5.2. Checked Casts and Unchecked Casts](jls-5.html#jls-5.5.2)
[5.5.3. Checked Casts at Run Time](jls-5.html#jls-5.5.3)
[5.6. Numeric Contexts](jls-5.html#jls-5.6)
[5.6.1. Unary Numeric Promotion](jls-5.html#jls-5.6.1)
[5.6.2. Binary Numeric Promotion](jls-5.html#jls-5.6.2)

## üçÄ TOC6. Names

[6. Names](jls-6.html)
[6.1. Declarations](jls-6.html#jls-6.1)
[6.2. Names and Identifiers](jls-6.html#jls-6.2)
[6.3. Scope of a Declaration](jls-6.html#jls-6.3)
[6.4. Shadowing and Obscuring](jls-6.html#jls-6.4)
[6.4.1. Shadowing](jls-6.html#jls-6.4.1)
[6.4.2. Obscuring](jls-6.html#jls-6.4.2)
[6.5. Determining the Meaning of a Name](jls-6.html#jls-6.5)
[6.5.1. Syntactic Classification of a Name According to Context](jls-6.html#jls-6.5.1)
[6.5.2. Reclassification of Contextually Ambiguous Names](jls-6.html#jls-6.5.2)
[6.5.3. Meaning of Package Names](jls-6.html#jls-6.5.3)
[6.5.3.1. Simple Package Names](jls-6.html#jls-6.5.3.1)
[6.5.3.2. Qualified Package Names](jls-6.html#jls-6.5.3.2)
[6.5.4. Meaning of [*PackageOrTypeNames*]](jls-6.html#jls-6.5.4)
[6.5.4.1. Simple [*PackageOrTypeNames*]](jls-6.html#jls-6.5.4.1)
[6.5.4.2. Qualified [*PackageOrTypeNames*]](jls-6.html#jls-6.5.4.2)
[6.5.5. Meaning of Type Names](jls-6.html#jls-6.5.5)
[6.5.5.1. Simple Type Names](jls-6.html#jls-6.5.5.1)
[6.5.5.2. Qualified Type Names](jls-6.html#jls-6.5.5.2)
[6.5.6. Meaning of Expression Names](jls-6.html#jls-6.5.6)
[6.5.6.1. Simple Expression Names](jls-6.html#jls-6.5.6.1)
[6.5.6.2. Qualified Expression Names](jls-6.html#jls-6.5.6.2)
[6.5.7. Meaning of Method Names](jls-6.html#jls-6.5.7)
[6.5.7.1. Simple Method Names](jls-6.html#jls-6.5.7.1)
[6.6. Access Control](jls-6.html#jls-6.6)
[6.6.1. Determining Accessibility](jls-6.html#jls-6.6.1)
[6.6.2. Details on `protected` Access](jls-6.html#jls-6.6.2)
[6.6.2.1. Access to a `protected` Member](jls-6.html#jls-6.6.2.1)
[6.6.2.2. Qualified Access to a `protected` Constructor](jls-6.html#jls-6.6.2.2)
[6.7. Fully Qualified Names and Canonical Names](jls-6.html#jls-6.7)

## üçÄ TOC7. Packages

[7. Packages](jls-7.html)
[7.1. Package Members](jls-7.html#jls-7.1)
[7.2. Host Support for Packages](jls-7.html#jls-7.2)
[7.3. Compilation Units](jls-7.html#jls-7.3)
[7.4. Package Declarations](jls-7.html#jls-7.4)
[7.4.1. Named Packages](jls-7.html#jls-7.4.1)
[7.4.2. Unnamed Packages](jls-7.html#jls-7.4.2)
[7.4.3. Observability of a Package](jls-7.html#jls-7.4.3)
[7.5. Import Declarations](jls-7.html#jls-7.5)
[7.5.1. Single-Type-Import Declarations](jls-7.html#jls-7.5.1)
[7.5.2. Type-Import-on-Demand Declarations](jls-7.html#jls-7.5.2)
[7.5.3. Single-Static-Import Declarations](jls-7.html#jls-7.5.3)
[7.5.4. Static-Import-on-Demand Declarations](jls-7.html#jls-7.5.4)
[7.6. Top Level Type Declarations](jls-7.html#jls-7.6)

## üçÄ TOC8. Classes

[8. Classes](jls-8.html)
[8.1. Class Declarations](jls-8.html#jls-8.1)
[8.1.1. Class Modifiers](jls-8.html#jls-8.1.1)
[8.1.1.1. `abstract` Classes](jls-8.html#jls-8.1.1.1)
[8.1.1.2. `final` Classes](jls-8.html#jls-8.1.1.2)
[8.1.1.3. `strictfp` Classes](jls-8.html#jls-8.1.1.3)
[8.1.2. Generic Classes and Type Parameters](jls-8.html#jls-8.1.2)
[8.1.3. Inner Classes and Enclosing Instances](jls-8.html#jls-8.1.3)
[8.1.4. Superclasses and Subclasses](jls-8.html#jls-8.1.4)
[8.1.5. Superinterfaces](jls-8.html#jls-8.1.5)
[8.1.6. Class Body and Member Declarations](jls-8.html#jls-8.1.6)
[8.2. Class Members](jls-8.html#jls-8.2)
[8.3. Field Declarations](jls-8.html#jls-8.3)
[8.3.1. Field Modifiers](jls-8.html#jls-8.3.1)
[8.3.1.1. `static` Fields](jls-8.html#jls-8.3.1.1)
[8.3.1.2. `final` Fields](jls-8.html#jls-8.3.1.2)
[8.3.1.3. `transient` Fields](jls-8.html#jls-8.3.1.3)
[8.3.1.4. `volatile` Fields](jls-8.html#jls-8.3.1.4)
[8.3.2. Field Initialization](jls-8.html#jls-8.3.2)
[8.3.3. Forward References During Field Initialization](jls-8.html#jls-8.3.3)
[8.4. Method Declarations](jls-8.html#jls-8.4)
[8.4.1. Formal Parameters](jls-8.html#jls-8.4.1)
[8.4.2. Method Signature](jls-8.html#jls-8.4.2)
[8.4.3. Method Modifiers](jls-8.html#jls-8.4.3)
[8.4.3.1. `abstract` Methods](jls-8.html#jls-8.4.3.1)
[8.4.3.2. `static` Methods](jls-8.html#jls-8.4.3.2)
[8.4.3.3. `final` Methods](jls-8.html#jls-8.4.3.3)
[8.4.3.4. `native` Methods](jls-8.html#jls-8.4.3.4)
[8.4.3.5. `strictfp` Methods](jls-8.html#jls-8.4.3.5)
[8.4.3.6. `synchronized` Methods](jls-8.html#jls-8.4.3.6)
[8.4.4. Generic Methods](jls-8.html#jls-8.4.4)
[8.4.5. Method Result](jls-8.html#jls-8.4.5)
[8.4.6. Method Throws](jls-8.html#jls-8.4.6)
[8.4.7. Method Body](jls-8.html#jls-8.4.7)
[8.4.8. Inheritance, Overriding, and Hiding](jls-8.html#jls-8.4.8)
[8.4.8.1. Overriding (by Instance Methods)](jls-8.html#jls-8.4.8.1)
[8.4.8.2. Hiding (by Class Methods)](jls-8.html#jls-8.4.8.2)
[8.4.8.3. Requirements in Overriding and Hiding](jls-8.html#jls-8.4.8.3)
[8.4.8.4. Inheriting Methods with Override-Equivalent Signatures](jls-8.html#jls-8.4.8.4)
[8.4.9. Overloading](jls-8.html#jls-8.4.9)
[8.5. Member Type Declarations](jls-8.html#jls-8.5)
[8.5.1. Static Member Type Declarations](jls-8.html#jls-8.5.1)
[8.6. Instance Initializers](jls-8.html#jls-8.6)
[8.7. Static Initializers](jls-8.html#jls-8.7)
[8.8. Constructor Declarations](jls-8.html#jls-8.8)
[8.8.1. Formal Parameters](jls-8.html#jls-8.8.1)
[8.8.2. Constructor Signature](jls-8.html#jls-8.8.2)
[8.8.3. Constructor Modifiers](jls-8.html#jls-8.8.3)
[8.8.4. Generic Constructors](jls-8.html#jls-8.8.4)
[8.8.5. Constructor Throws](jls-8.html#jls-8.8.5)
[8.8.6. The Type of a Constructor](jls-8.html#jls-8.8.6)
[8.8.7. Constructor Body](jls-8.html#jls-8.8.7)
[8.8.7.1. Explicit Constructor Invocations](jls-8.html#jls-8.8.7.1)
[8.8.8. Constructor Overloading](jls-8.html#jls-8.8.8)
[8.8.9. Default Constructor](jls-8.html#jls-8.8.9)
[8.8.10. Preventing Instantiation of a Class](jls-8.html#jls-8.8.10)
[8.9. Enum Types](jls-8.html#jls-8.9)
[8.9.1. Enum Constants](jls-8.html#jls-8.9.1)
[8.9.2. Enum Body Declarations](jls-8.html#jls-8.9.2)
[8.9.3. Enum Members](jls-8.html#jls-8.9.3)

## üçÄ TOC9. Interfaces

[9. Interfaces](jls-9.html)
[9.1. Interface Declarations](jls-9.html#jls-9.1)
[9.1.1. Interface Modifiers](jls-9.html#jls-9.1.1)
[9.1.1.1. `abstract` Interfaces](jls-9.html#jls-9.1.1.1)
[9.1.1.2. `strictfp` Interfaces](jls-9.html#jls-9.1.1.2)
[9.1.2. Generic Interfaces and Type Parameters](jls-9.html#jls-9.1.2)
[9.1.3. Superinterfaces and Subinterfaces](jls-9.html#jls-9.1.3)
[9.1.4. Interface Body and Member Declarations](jls-9.html#jls-9.1.4)
[9.2. Interface Members](jls-9.html#jls-9.2)
[9.3. Field (Constant) Declarations](jls-9.html#jls-9.3)
[9.3.1. Initialization of Fields in Interfaces](jls-9.html#jls-9.3.1)
[9.4. Method Declarations](jls-9.html#jls-9.4)
[9.4.1. Inheritance and Overriding](jls-9.html#jls-9.4.1)
[9.4.1.1. Overriding (by Instance Methods)](jls-9.html#jls-9.4.1.1)
[9.4.1.2. Requirements in Overriding](jls-9.html#jls-9.4.1.2)
[9.4.1.3. Inheriting Methods with Override-Equivalent Signatures](jls-9.html#jls-9.4.1.3)
[9.4.2. Overloading](jls-9.html#jls-9.4.2)
[9.4.3. Interface Method Body](jls-9.html#jls-9.4.3)
[9.5. Member Type Declarations](jls-9.html#jls-9.5)
[9.6. Annotation Types](jls-9.html#jls-9.6)
[9.6.1. Annotation Type Elements](jls-9.html#jls-9.6.1)
[9.6.2. Defaults for Annotation Type Elements](jls-9.html#jls-9.6.2)
[9.6.3. Repeatable Annotation Types](jls-9.html#jls-9.6.3)
[9.6.4. Predefined Annotation Types](jls-9.html#jls-9.6.4)
[9.6.4.1. `@Target`](jls-9.html#jls-9.6.4.1)
[9.6.4.2. `@Retention`](jls-9.html#jls-9.6.4.2)
[9.6.4.3. `@Inherited`](jls-9.html#jls-9.6.4.3)
[9.6.4.4. `@Override`](jls-9.html#jls-9.6.4.4)
[9.6.4.5. `@SuppressWarnings`](jls-9.html#jls-9.6.4.5)
[9.6.4.6. `@Deprecated`](jls-9.html#jls-9.6.4.6)
[9.6.4.7. `@SafeVarargs`](jls-9.html#jls-9.6.4.7)
[9.6.4.8. `@Repeatable`](jls-9.html#jls-9.6.4.8)
[9.6.4.9. `@FunctionalInterface`](jls-9.html#jls-9.6.4.9)
[9.7. Annotations](jls-9.html#jls-9.7)
[9.7.1. Normal Annotations](jls-9.html#jls-9.7.1)
[9.7.2. Marker Annotations](jls-9.html#jls-9.7.2)
[9.7.3. Single-Element Annotations](jls-9.html#jls-9.7.3)
[9.7.4. Where Annotations May Appear](jls-9.html#jls-9.7.4)
[9.7.5. Multiple Annotations of the Same Type](jls-9.html#jls-9.7.5)
[9.8. Functional Interfaces](jls-9.html#jls-9.8)
[9.9. Function Types](jls-9.html#jls-9.9)

## üçÄ TOC10. Arrays

[10. Arrays](jls-10.html)
[10.1. Array Types](jls-10.html#jls-10.1)
[10.2. Array Variables](jls-10.html#jls-10.2)
[10.3. Array Creation](jls-10.html#jls-10.3)
[10.4. Array Access](jls-10.html#jls-10.4)
[10.5. Array Store Exception](jls-10.html#jls-10.5)
[10.6. Array Initializers](jls-10.html#jls-10.6)
[10.7. Array Members](jls-10.html#jls-10.7)
[10.8. `Class` Objects for Arrays](jls-10.html#jls-10.8)
[10.9. An Array of Characters Is Not a `String`](jls-10.html#jls-10.9)
[11. Exceptions](jls-11.html)
[11.1. The Kinds and Causes of Exceptions](jls-11.html#jls-11.1)
[11.1.1. The Kinds of Exceptions](jls-11.html#jls-11.1.1)
[11.1.2. The Causes of Exceptions](jls-11.html#jls-11.1.2)
[11.1.3. Asynchronous Exceptions](jls-11.html#jls-11.1.3)
[11.2. Compile-Time Checking of Exceptions](jls-11.html#jls-11.2)
[11.2.1. Exception Analysis of Expressions](jls-11.html#jls-11.2.1)
[11.2.2. Exception Analysis of Statements](jls-11.html#jls-11.2.2)
[11.2.3. Exception Checking](jls-11.html#jls-11.2.3)
[11.3. Run-Time Handling of an Exception](jls-11.html#jls-11.3)

## üçÄ TOC12. Execution

[12. Execution](jls-12.html)
[12.1. Java Virtual Machine Startup](jls-12.html#jls-12.1)
[12.1.1. Load the Class `Test`](jls-12.html#jls-12.1.1)
[12.1.2. Link `Test`: Verify, Prepare, (Optionally) Resolve](jls-12.html#jls-12.1.2)
[12.1.3. Initialize Test: Execute Initializers](jls-12.html#jls-12.1.3)
[12.1.4. Invoke `Test.main`](jls-12.html#jls-12.1.4)
[12.2. Loading of Classes and Interfaces](jls-12.html#jls-12.2)
[12.2.1. The Loading Process](jls-12.html#jls-12.2.1)
[12.3. Linking of Classes and Interfaces](jls-12.html#jls-12.3)
[12.3.1. Verification of the Binary Representation](jls-12.html#jls-12.3.1)
[12.3.2. Preparation of a Class or Interface Type](jls-12.html#jls-12.3.2)
[12.3.3. Resolution of Symbolic References](jls-12.html#jls-12.3.3)
[12.4. Initialization of Classes and Interfaces](jls-12.html#jls-12.4)
[12.4.1. When Initialization Occurs](jls-12.html#jls-12.4.1)
[12.4.2. Detailed Initialization Procedure](jls-12.html#jls-12.4.2)
[12.5. Creation of New Class Instances](jls-12.html#jls-12.5)
[12.6. Finalization of Class Instances](jls-12.html#jls-12.6)
[12.6.1. Implementing Finalization](jls-12.html#jls-12.6.1)
[12.6.2. Interaction with the Memory Model](jls-12.html#jls-12.6.2)
[12.7. Unloading of Classes and Interfaces](jls-12.html#jls-12.7)
[12.8. Program Exit](jls-12.html#jls-12.8)

## üçÄ TOC13. Binary Compatibility

[13. Binary Compatibility](jls-13.html)
[13.1. The Form of a Binary](jls-13.html#jls-13.1)
[13.2. What Binary Compatibility Is and Is Not](jls-13.html#jls-13.2)
[13.3. Evolution of Packages](jls-13.html#jls-13.3)
[13.4. Evolution of Classes](jls-13.html#jls-13.4)
[13.4.1. `abstract` Classes](jls-13.html#jls-13.4.1)
[13.4.2. `final` Classes](jls-13.html#jls-13.4.2)
[13.4.3. `public` Classes](jls-13.html#jls-13.4.3)
[13.4.4. Superclasses and Superinterfaces](jls-13.html#jls-13.4.4)
[13.4.5. Class Type Parameters](jls-13.html#jls-13.4.5)
[13.4.6. Class Body and Member Declarations](jls-13.html#jls-13.4.6)
[13.4.7. Access to Members and Constructors](jls-13.html#jls-13.4.7)
[13.4.8. Field Declarations](jls-13.html#jls-13.4.8)
[13.4.9. `final` Fields and `static` Constant Variables](jls-13.html#jls-13.4.9)
[13.4.10. `static` Fields](jls-13.html#jls-13.4.10)
[13.4.11. `transient` Fields](jls-13.html#jls-13.4.11)
[13.4.12. Method and Constructor Declarations](jls-13.html#jls-13.4.12)
[13.4.13. Method and Constructor Type Parameters](jls-13.html#jls-13.4.13)
[13.4.14. Method and Constructor Formal Parameters](jls-13.html#jls-13.4.14)
[13.4.15. Method Result Type](jls-13.html#jls-13.4.15)
[13.4.16. `abstract` Methods](jls-13.html#jls-13.4.16)
[13.4.17. `final` Methods](jls-13.html#jls-13.4.17)
[13.4.18. `native` Methods](jls-13.html#jls-13.4.18)
[13.4.19. `static` Methods](jls-13.html#jls-13.4.19)
[13.4.20. `synchronized` Methods](jls-13.html#jls-13.4.20)
[13.4.21. Method and Constructor Throws](jls-13.html#jls-13.4.21)
[13.4.22. Method and Constructor Body](jls-13.html#jls-13.4.22)
[13.4.23. Method and Constructor Overloading](jls-13.html#jls-13.4.23)
[13.4.24. Method Overriding](jls-13.html#jls-13.4.24)
[13.4.25. Static Initializers](jls-13.html#jls-13.4.25)
[13.4.26. Evolution of Enums](jls-13.html#jls-13.4.26)
[13.5. Evolution of Interfaces](jls-13.html#jls-13.5)
[13.5.1. `public` Interfaces](jls-13.html#jls-13.5.1)
[13.5.2. Superinterfaces](jls-13.html#jls-13.5.2)
[13.5.3. Interface Members](jls-13.html#jls-13.5.3)
[13.5.4. Interface Type Parameters](jls-13.html#jls-13.5.4)
[13.5.5. Field Declarations](jls-13.html#jls-13.5.5)
[13.5.6. Interface Method Declarations](jls-13.html#jls-13.5.6)
[13.5.7. Evolution of Annotation Types](jls-13.html#jls-13.5.7)

## üçÄ TOC14. Blocks and Statements

[14. Blocks and Statements](jls-14.html)
[14.1. Normal and Abrupt Completion of Statements](jls-14.html#jls-14.1)
[14.2. Blocks](jls-14.html#jls-14.2)
[14.3. Local Class Declarations](jls-14.html#jls-14.3)
[14.4. Local Variable Declaration Statements](jls-14.html#jls-14.4)
[14.4.1. Local Variable Declarators and Types](jls-14.html#jls-14.4.1)
[14.4.2. Execution of Local Variable Declarations](jls-14.html#jls-14.4.2)
[14.5. Statements](jls-14.html#jls-14.5)
[14.6. The Empty Statement](jls-14.html#jls-14.6)
[14.7. Labeled Statements](jls-14.html#jls-14.7)
[14.8. Expression Statements](jls-14.html#jls-14.8)
[14.9. The `if` Statement](jls-14.html#jls-14.9)
[14.9.1. The `if`-`then` Statement](jls-14.html#jls-14.9.1)
[14.9.2. The `if`-`then`-`else` Statement](jls-14.html#jls-14.9.2)
[14.10. The `assert` Statement](jls-14.html#jls-14.10)
[14.11. The `switch` Statement](jls-14.html#jls-14.11)
[14.12. The `while` Statement](jls-14.html#jls-14.12)
[14.12.1. Abrupt Completion of `while` Statement](jls-14.html#jls-14.12.1)
[14.13. The `do` Statement](jls-14.html#jls-14.13)
[14.13.1. Abrupt Completion of `do` Statement](jls-14.html#jls-14.13.1)
[14.14. The `for` Statement](jls-14.html#jls-14.14)
[14.14.1. The basic `for` Statement](jls-14.html#jls-14.14.1)
[14.14.1.1. Initialization of `for` Statement](jls-14.html#jls-14.14.1.1)
[14.14.1.2. Iteration of `for` Statement](jls-14.html#jls-14.14.1.2)
[14.14.1.3. Abrupt Completion of `for` Statement](jls-14.html#jls-14.14.1.3)
[14.14.2. The enhanced `for` statement](jls-14.html#jls-14.14.2)
[14.15. The `break` Statement](jls-14.html#jls-14.15)
[14.16. The `continue` Statement](jls-14.html#jls-14.16)
[14.17. The `return` Statement](jls-14.html#jls-14.17)
[14.18. The `throw` Statement](jls-14.html#jls-14.18)
[14.19. The `synchronized` Statement](jls-14.html#jls-14.19)
[14.20. The `try` statement](jls-14.html#jls-14.20)
[14.20.1. Execution of `try`-`catch`](jls-14.html#jls-14.20.1)
[14.20.2. Execution of `try`-`finally` and `try`-`catch`-`finally`](jls-14.html#jls-14.20.2)
[14.20.3. `try`-with-resources](jls-14.html#jls-14.20.3)
[14.20.3.1. Basic `try`-with-resources](jls-14.html#jls-14.20.3.1)
[14.20.3.2. Extended `try`-with-resources](jls-14.html#jls-14.20.3.2)
[14.21. Unreachable Statements](jls-14.html#jls-14.21)

## üçÄ TOC15. Expressions

[15. Expressions](jls-15.html)
[15.1. Evaluation, Denotation, and Result](jls-15.html#jls-15.1)
[15.2. Forms of Expressions](jls-15.html#jls-15.2)
[15.3. Type of an Expression](jls-15.html#jls-15.3)
[15.4. FP-strict Expressions](jls-15.html#jls-15.4)
[15.5. Expressions and Run-Time Checks](jls-15.html#jls-15.5)
[15.6. Normal and Abrupt Completion of Evaluation](jls-15.html#jls-15.6)
[15.7. Evaluation Order](jls-15.html#jls-15.7)
[15.7.1. Evaluate Left-Hand Operand First](jls-15.html#jls-15.7.1)
[15.7.2. Evaluate Operands before Operation](jls-15.html#jls-15.7.2)
[15.7.3. Evaluation Respects Parentheses and Precedence](jls-15.html#jls-15.7.3)
[15.7.4. Argument Lists are Evaluated Left-to-Right](jls-15.html#jls-15.7.4)
[15.7.5. Evaluation Order for Other Expressions](jls-15.html#jls-15.7.5)
[15.8. Primary Expressions](jls-15.html#jls-15.8)
[15.8.1. Lexical Literals](jls-15.html#jls-15.8.1)
[15.8.2. Class Literals](jls-15.html#jls-15.8.2)
[15.8.3. `this`](jls-15.html#jls-15.8.3)
[15.8.4. Qualified `this`](jls-15.html#jls-15.8.4)
[15.8.5. Parenthesized Expressions](jls-15.html#jls-15.8.5)
[15.9. Class Instance Creation Expressions](jls-15.html#jls-15.9)
[15.9.1. Determining the Class being Instantiated](jls-15.html#jls-15.9.1)
[15.9.2. Determining Enclosing Instances](jls-15.html#jls-15.9.2)
[15.9.3. Choosing the Constructor and its Arguments](jls-15.html#jls-15.9.3)
[15.9.4. Run-Time Evaluation of Class Instance Creation Expressions](jls-15.html#jls-15.9.4)
[15.9.5. Anonymous Class Declarations](jls-15.html#jls-15.9.5)
[15.9.5.1. Anonymous Constructors](jls-15.html#jls-15.9.5.1)
[15.10. Array Creation and Access Expressions](jls-15.html#jls-15.10)
[15.10.1. Array Creation Expressions](jls-15.html#jls-15.10.1)
[15.10.2. Run-Time Evaluation of Array Creation Expressions](jls-15.html#jls-15.10.2)
[15.10.3. Array Access Expressions](jls-15.html#jls-15.10.3)
[15.10.4. Run-Time Evaluation of Array Access Expressions](jls-15.html#jls-15.10.4)
[15.11. Field Access Expressions](jls-15.html#jls-15.11)
[15.11.1. Field Access Using a Primary](jls-15.html#jls-15.11.1)
[15.11.2. Accessing Superclass Members using `super`](jls-15.html#jls-15.11.2)
[15.12. Method Invocation Expressions](jls-15.html#jls-15.12)
[15.12.1. Compile-Time Step 1: Determine Class or Interface to Search](jls-15.html#jls-15.12.1)
[15.12.2. Compile-Time Step 2: Determine Method Signature](jls-15.html#jls-15.12.2)
[15.12.2.1. Identify Potentially Applicable Methods](jls-15.html#jls-15.12.2.1)
[15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation](jls-15.html#jls-15.12.2.2)
[15.12.2.3. Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation](jls-15.html#jls-15.12.2.3)
[15.12.2.4. Phase 3: Identify Methods Applicable by Variable Arity Invocation](jls-15.html#jls-15.12.2.4)
[15.12.2.5. Choosing the Most Specific Method](jls-15.html#jls-15.12.2.5)
[15.12.2.6. Method Invocation Type](jls-15.html#jls-15.12.2.6)
[15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?](jls-15.html#jls-15.12.3)
[15.12.4. Run-Time Evaluation of Method Invocation](jls-15.html#jls-15.12.4)
[15.12.4.1. Compute Target Reference (If Necessary)](jls-15.html#jls-15.12.4.1)
[15.12.4.2. Evaluate Arguments](jls-15.html#jls-15.12.4.2)
[15.12.4.3. Check Accessibility of Type and Method](jls-15.html#jls-15.12.4.3)
[15.12.4.4. Locate Method to Invoke](jls-15.html#jls-15.12.4.4)
[15.12.4.5. Create Frame, Synchronize, Transfer Control](jls-15.html#jls-15.12.4.5)
[15.13. Method Reference Expressions](jls-15.html#jls-15.13)
[15.13.1. Compile-Time Declaration of a Method Reference](jls-15.html#jls-15.13.1)
[15.13.2. Type of a Method Reference](jls-15.html#jls-15.13.2)
[15.13.3. Run-Time Evaluation of Method References](jls-15.html#jls-15.13.3)
[15.14. Postfix Expressions](jls-15.html#jls-15.14)
[15.14.1. Expression Names](jls-15.html#jls-15.14.1)
[15.14.2. Postfix Increment Operator `++`](jls-15.html#jls-15.14.2)
[15.14.3. Postfix Decrement Operator `--`](jls-15.html#jls-15.14.3)
[15.15. Unary Operators](jls-15.html#jls-15.15)
[15.15.1. Prefix Increment Operator `++`](jls-15.html#jls-15.15.1)
[15.15.2. Prefix Decrement Operator `--`](jls-15.html#jls-15.15.2)
[15.15.3. Unary Plus Operator `+`](jls-15.html#jls-15.15.3)
[15.15.4. Unary Minus Operator `-`](jls-15.html#jls-15.15.4)
[15.15.5. Bitwise Complement Operator `~`](jls-15.html#jls-15.15.5)
[15.15.6. Logical Complement Operator `!`](jls-15.html#jls-15.15.6)
[15.16. Cast Expressions](jls-15.html#jls-15.16)
[15.17. Multiplicative Operators](jls-15.html#jls-15.17)
[15.17.1. Multiplication Operator `*`](jls-15.html#jls-15.17.1)
[15.17.2. Division Operator `/`](jls-15.html#jls-15.17.2)
[15.17.3. Remainder Operator `%`](jls-15.html#jls-15.17.3)
[15.18. Additive Operators](jls-15.html#jls-15.18)
[15.18.1. String Concatenation Operator `+`](jls-15.html#jls-15.18.1)
[15.18.2. Additive Operators (`+` and `-`) for Numeric Types](jls-15.html#jls-15.18.2)
[15.19. Shift Operators](jls-15.html#jls-15.19)
[15.20. Relational Operators](jls-15.html#jls-15.20)
[15.20.1. Numerical Comparison Operators `<`, `<=`, `>`, and `>=`](jls-15.html#jls-15.20.1)
[15.20.2. Type Comparison Operator `instanceof`](jls-15.html#jls-15.20.2)
[15.21. Equality Operators](jls-15.html#jls-15.21)
[15.21.1. Numerical Equality Operators `==` and `!=`](jls-15.html#jls-15.21.1)
[15.21.2. Boolean Equality Operators `==` and `!=`](jls-15.html#jls-15.21.2)
[15.21.3. Reference Equality Operators `==` and `!=`](jls-15.html#jls-15.21.3)
[15.22. Bitwise and Logical Operators](jls-15.html#jls-15.22)
[15.22.1. Integer Bitwise Operators `&`, `^`, and `|`](jls-15.html#jls-15.22.1)
[15.22.2. Boolean Logical Operators `&`, `^`, and `|`](jls-15.html#jls-15.22.2)
[15.23. Conditional-And Operator `&&`](jls-15.html#jls-15.23)
[15.24. Conditional-Or Operator `||`](jls-15.html#jls-15.24)
[15.25. Conditional Operator `? :`](jls-15.html#jls-15.25)
[15.25.1. Boolean Conditional Expressions](jls-15.html#jls-15.25.1)
[15.25.2. Numeric Conditional Expressions](jls-15.html#jls-15.25.2)
[15.25.3. Reference Conditional Expressions](jls-15.html#jls-15.25.3)
[15.26. Assignment Operators](jls-15.html#jls-15.26)
[15.26.1. Simple Assignment Operator `=`](jls-15.html#jls-15.26.1)
[15.26.2. Compound Assignment Operators](jls-15.html#jls-15.26.2)
[15.27. Lambda Expressions](jls-15.html#jls-15.27)
[15.27.1. Lambda Parameters](jls-15.html#jls-15.27.1)
[15.27.2. Lambda Body](jls-15.html#jls-15.27.2)
[15.27.3. Type of a Lambda Expression](jls-15.html#jls-15.27.3)
[15.27.4. Run-Time Evaluation of Lambda Expressions](jls-15.html#jls-15.27.4)
[15.28. Constant Expressions](jls-15.html#jls-15.28)

## üçÄ TOC16. Definite Assignment

[16. Definite Assignment](jls-16.html)
[16.1. Definite Assignment and Expressions](jls-16.html#jls-16.1)
[16.1.1. Boolean Constant Expressions](jls-16.html#jls-16.1.1)
[16.1.2. Conditional-And Operator `&&`](jls-16.html#jls-16.1.2)
[16.1.3. Conditional-Or Operator `||`](jls-16.html#jls-16.1.3)
[16.1.4. Logical Complement Operator `!`](jls-16.html#jls-16.1.4)
[16.1.5. Conditional Operator `? :`](jls-16.html#jls-16.1.5)
[16.1.6. Conditional Operator `? :`](jls-16.html#jls-16.1.6)
[16.1.7. Other Expressions of Type `boolean`](jls-16.html#jls-16.1.7)
[16.1.8. Assignment Expressions](jls-16.html#jls-16.1.8)
[16.1.9. Operators `++` and `--`](jls-16.html#jls-16.1.9)
[16.1.10. Other Expressions](jls-16.html#jls-16.1.10)
[16.2. Definite Assignment and Statements](jls-16.html#jls-16.2)
[16.2.1. Empty Statements](jls-16.html#jls-16.2.1)
[16.2.2. Blocks](jls-16.html#jls-16.2.2)
[16.2.3. Local Class Declaration Statements](jls-16.html#jls-16.2.3)
[16.2.4. Local Variable Declaration Statements](jls-16.html#jls-16.2.4)
[16.2.5. Labeled Statements](jls-16.html#jls-16.2.5)
[16.2.6. Expression Statements](jls-16.html#jls-16.2.6)
[16.2.7. `if` Statements](jls-16.html#jls-16.2.7)
[16.2.8. `assert` Statements](jls-16.html#jls-16.2.8)
[16.2.9. `switch` Statements](jls-16.html#jls-16.2.9)
[16.2.10. `while` Statements](jls-16.html#jls-16.2.10)
[16.2.11. `do` Statements](jls-16.html#jls-16.2.11)
[16.2.12. `for` Statements](jls-16.html#jls-16.2.12)
[16.2.12.1. Initialization Part of `for` Statement](jls-16.html#jls-16.2.12.1)
[16.2.12.2. Incrementation Part of `for` Statement](jls-16.html#jls-16.2.12.2)
[16.2.13. `break`, `continue`, `return`, and `throw` Statements](jls-16.html#jls-16.2.13)
[16.2.14. `synchronized` Statements](jls-16.html#jls-16.2.14)
[16.2.15. `try` Statements](jls-16.html#jls-16.2.15)
[16.3. Definite Assignment and Parameters](jls-16.html#jls-16.3)
[16.4. Definite Assignment and Array Initializers](jls-16.html#jls-16.4)
[16.5. Definite Assignment and Enum Constants](jls-16.html#jls-16.5)
[16.6. Definite Assignment and Anonymous Classes](jls-16.html#jls-16.6)
[16.7. Definite Assignment and Member Types](jls-16.html#jls-16.7)
[16.8. Definite Assignment and Static Initializers](jls-16.html#jls-16.8)
[16.9. Definite Assignment, Constructors, and Instance Initializers](jls-16.html#jls-16.9)

## üçÄ TOC17. Threads and Locks

[17. Threads and Locks](jls-17.html)
[17.1. Synchronization](jls-17.html#jls-17.1)
[17.2. Wait Sets and Notification](jls-17.html#jls-17.2)
[17.2.1. Wait](jls-17.html#jls-17.2.1)
[17.2.2. Notification](jls-17.html#jls-17.2.2)
[17.2.3. Interruptions](jls-17.html#jls-17.2.3)
[17.2.4. Interactions of Waits, Notification, and Interruption](jls-17.html#jls-17.2.4)
[17.3. Sleep and Yield](jls-17.html#jls-17.3)
[17.4. Memory Model](jls-17.html#jls-17.4)
[17.4.1. Shared Variables](jls-17.html#jls-17.4.1)
[17.4.2. Actions](jls-17.html#jls-17.4.2)
[17.4.3. Programs and Program Order](jls-17.html#jls-17.4.3)
[17.4.4. Synchronization Order](jls-17.html#jls-17.4.4)
[17.4.5. Happens-before Order](jls-17.html#jls-17.4.5)
[17.4.6. Executions](jls-17.html#jls-17.4.6)
[17.4.7. Well-Formed Executions](jls-17.html#jls-17.4.7)
[17.4.8. Executions and Causality Requirements](jls-17.html#jls-17.4.8)
[17.4.9. Observable Behavior and Nonterminating Executions](jls-17.html#jls-17.4.9)
[17.5. `final` Field Semantics](jls-17.html#jls-17.5)
[17.5.1. Semantics of `final` Fields](jls-17.html#jls-17.5.1)
[17.5.2. Reading `final` Fields During Construction](jls-17.html#jls-17.5.2)
[17.5.3. Subsequent Modification of `final` Fields](jls-17.html#jls-17.5.3)
[17.5.4. Write-Protected Fields](jls-17.html#jls-17.5.4)
[17.6. Word Tearing](jls-17.html#jls-17.6)
[17.7. Non-Atomic Treatment of `double` and `long`](jls-17.html#jls-17.7)

## üçÄ TOC18. Type Inference

[18. Type Inference](jls-18.html)
[18.1. Concepts and Notation](jls-18.html#jls-18.1)
[18.1.1. Inference Variables](jls-18.html#jls-18.1.1)
[18.1.2. Constraint Formulas](jls-18.html#jls-18.1.2)
[18.1.3. Bounds](jls-18.html#jls-18.1.3)
[18.2. Reduction](jls-18.html#jls-18.2)
[18.2.1. Expression Compatibility Constraints](jls-18.html#jls-18.2.1)
[18.2.2. Type Compatibility Constraints](jls-18.html#jls-18.2.2)
[18.2.3. Subtyping Constraints](jls-18.html#jls-18.2.3)
[18.2.4. Type Equality Constraints](jls-18.html#jls-18.2.4)
[18.2.5. Checked Exception Constraints](jls-18.html#jls-18.2.5)
[18.3. Incorporation](jls-18.html#jls-18.3)
[18.3.1. Complementary Pairs of Bounds](jls-18.html#jls-18.3.1)
[18.3.2. Bounds Involving Capture Conversion](jls-18.html#jls-18.3.2)
[18.4. Resolution](jls-18.html#jls-18.4)
[18.5. Uses of Inference](jls-18.html#jls-18.5)
[18.5.1. Invocation Applicability Inference](jls-18.html#jls-18.5.1)
[18.5.2. Invocation Type Inference](jls-18.html#jls-18.5.2)
[18.5.3. Functional Interface Parameterization Inference](jls-18.html#jls-18.5.3)
[18.5.4. More Specific Method Inference](jls-18.html#jls-18.5.4)

## üçÄ TOC19. Syntax

[19. Syntax](jls-19.html)
[Index](jls-0-index.html)
[A. Limited License Grant](spec-license.html)

## üçÄ **List of Examples**

3.10.5-1. [String Literals](jls-3.html#d5e1634)
4.2.2-1. [Integer Operations](jls-4.html#d5e2031)
4.2.4-1. [Floating-point Operations](jls-4.html#d5e2344)
4.3.1-1. [Object Creation](jls-4.html#d5e2563)
4.3.1-2. [Primitive and Reference Identity](jls-4.html#d5e2605)
4.4-1. [Members of a Type Variable](jls-4.html#d5e2800)
4.5.1-1. [Unbounded Wildcards](jls-4.html#d5e3157)
4.5.1-2. [Bounded Wildcards](jls-4.html#d5e3166)
4.8-1. [Raw Types](jls-4.html#d5e3534)
4.8-2. [Raw Types and Inheritance](jls-4.html#d5e3537)
4.11-1. [Usage of a Type](jls-4.html#d5e4679)
4.12.3-1. [Different Kinds of Variables](jls-4.html#d5e4969)
4.12.4-1. [Final Variables](jls-4.html#d5e5006)
4.12.5-1. [Initial Values of Variables](jls-4.html#d5e5134)
4.12.6-1. [Type of a Variable versus Class of an Object](jls-4.html#d5e5193)
5.0-1. [Conversions at Compile Time and Run Time](jls-5.html#d5e5264)
5.0-2. [Conversions In Various Contexts](jls-5.html#d5e5343)
5.1.2-1. [Widening Primitive Conversion](jls-5.html#d5e5437)
5.1.3-1. [Narrowing Primitive Conversion](jls-5.html#d5e5582)
5.1.3-2. [Narrowing Primitive Conversions that lose information](jls-5.html#d5e5605)
5.2-1. [Assignment Conversion for Primitive Types](jls-5.html#d5e6421)
5.2-2. [Assignment Conversion for Reference Types](jls-5.html#d5e6433)
5.2-3. [Assignment Conversion for Array Types](jls-5.html#d5e6438)
5.5.1-1. [Casting Conversion for Reference Types](jls-5.html#d5e7526)
5.5.1-2. [Casting Conversion for Array Types](jls-5.html#d5e7542)
5.5.3-1. [Incompatible Types at Run Time](jls-5.html#d5e7759)
5.6.1-1. [Unary Numeric Promotion](jls-5.html#d5e7848)
5.6.2-1. [Binary Numeric Promotion](jls-5.html#d5e7917)
6.1-1. [Unique Package Names](jls-6.html#d5e8195)
6.1-2. [Descriptive Class Names](jls-6.html#d5e8229)
6.1-3. [Conventional Type Variable Names](jls-6.html#d5e8254)
6.3-1. [Scope of Type Declarations](jls-6.html#d5e8619)
6.3-2. [Scope of Local Variable Declarations](jls-6.html#d5e8629)
6.4-1. [Attempted Shadowing Of A Local Variable](jls-6.html#d5e8689)
6.4.1-1. [Shadowing of a Field Declaration by a Local Variable Declaration](jls-6.html#d5e8812)
6.4.1-2. [Shadowing of a Type Declaration by Another Type Declaration](jls-6.html#d5e8874)
6.5.2-1. [Reclassification of Contextually Ambiguous Names](jls-6.html#d5e9356)
6.5.5.2-1. [Qualified Type Names](jls-6.html#d5e9473)
6.5.6.1-1. [Simple Expression Names](jls-6.html#d5e9510)
6.5.6.2-1. [Qualified Expression Names](jls-6.html#d5e9620)
6.5.6.2-2. [Qualifying an Expression with a Type Name](jls-6.html#d5e9628)
6.5.7.1-1. [Simple Method Names and Visibility](jls-6.html#d5e9652)
6.6-1. [Access Control](jls-6.html#d5e9766)
6.6-2. [Access to `public` Fields, Methods, and Constructors](jls-6.html#d5e9805)
6.6-3. [Access to `public` and Non-`public` Classes](jls-6.html#d5e9824)
6.6-4. [Access to Package-Access Fields, Methods, and Constructors](jls-6.html#d5e9845)
6.6-5. [Access to `private` Fields, Methods, and Constructors](jls-6.html#d5e9880)
6.6.2-1. [Access to `protected` Fields, Methods, and Constructors](jls-6.html#d5e9998)
6.7-1. [Fully Qualified Names](jls-6.html#d5e10111)
6.7-2. [Fully Qualified Names v. Canonical Name](jls-6.html#d5e10153)
7.4.2-1. [Unnamed Packages](jls-7.html#d5e10414)
7.5.1-1. [Single-Type-Import](jls-7.html#d5e10521)
7.5.1-2. [Duplicate Type Declarations](jls-7.html#d5e10538)
7.5.1-3. [No Import of a Subpackage](jls-7.html#d5e10548)
7.5.1-4. [Importing a Type Name that is also a Package Name](jls-7.html#d5e10557)
7.5.2-1. [Type-Import-on-Demand](jls-7.html#d5e10602)
7.6-1. [Conflicting Top Level Type Declarations](jls-7.html#d5e10714)
7.6-2. [Scope of Top Level Types](jls-7.html#d5e10730)
7.6-3. [Fully Qualified Names](jls-7.html#d5e10737)
8.1.1.1-1. [Abstract Class Declaration](jls-8.html#d5e10954)
8.1.1.1-2. [Abstract Class Declaration that Prohibits Subclasses](jls-8.html#d5e10986)
8.1.2-1. [Mutually Recursive Type Variable Bounds](jls-8.html#d5e11113)
8.1.2-2. [Nested Generic Classes](jls-8.html#d5e11116)
8.1.3-1. [Inner Class Declarations and Static Members](jls-8.html#d5e11140)
8.1.3-2. [Inner Class Declarations](jls-8.html#d5e11214)
8.1.4-1. [Direct Superclasses and Subclasses](jls-8.html#d5e11367)
8.1.4-2. [Superclasses and Subclasses](jls-8.html#d5e11391)
8.1.4-3. [Class Depends on Itself](jls-8.html#d5e11452)
8.1.5-1. [Illegal Superinterfaces](jls-8.html#d5e11481)
8.1.5-2. [Superinterfaces](jls-8.html#d5e11593)
8.1.5-3. [Illegal Multiple Inheritance of an Interface](jls-8.html#d5e11619)
8.1.5-3. [Implementing Methods of a Superinterface](jls-8.html#d5e11638)
8.2-1. [Use of Class Members](jls-8.html#d5e11749)
8.2-2. [Inheritance of Class Members with Package Access](jls-8.html#d5e11778)
8.2-3. [Inheritance of `public` and `protected` Class Members](jls-8.html#d5e11809)
8.2-4. [Inheritance of `private` Class Members](jls-8.html#d5e11826)
8.2-5. [Accessing Members of Inaccessible Classes](jls-8.html#d5e11836)
8.3-1. [Multiply Inherited Fields](jls-8.html#d5e12029)
8.3-2. [Re-inheritance of Fields](jls-8.html#d5e12062)
8.3.1.1-1. [`static` Fields](jls-8.html#d5e12110)
8.3.1.1-2. [Hiding of Class Variables](jls-8.html#d5e12138)
8.3.1.1-3. [Hiding of Instance Variables](jls-8.html#d5e12172)
8.3.1.3-1. [Persistence of `transient` Fields](jls-8.html#d5e12254)
8.3.1.4-1. [`volatile` Fields](jls-8.html#d5e12277)
8.3.2-1. [Field Initialization](jls-8.html#d5e12379)
8.3.2-2. [Forward Reference to a Class Variable](jls-8.html#d5e12388)
8.3.3-1. [Restrictions on Field Initialization](jls-8.html#d5e12429)
8.4.2-1. [Override-Equivalent Signatures](jls-8.html#d5e12691)
8.4.3.1-1. [Abstract/Abstract Method Overriding](jls-8.html#d5e12771)
8.4.3.1-2. [Abstract/Non-Abstract Overriding](jls-8.html#d5e12780)
8.4.3.6-1. [`synchronized` Monitors](jls-8.html#d5e12889)
8.4.3.6-2. [`synchronized` Methods](jls-8.html#d5e12899)
8.4.6-1. [Type Variables as Thrown Exception Types](jls-8.html#d5e13110)
8.4.8.1-1. [Overriding](jls-8.html#d5e13369)
8.4.8.1-2. [Overriding](jls-8.html#d5e13382)
8.4.8.2-1. [Invocation of Hidden Class Methods](jls-8.html#d5e13455)
8.4.8.3-1. [Covariant Return Types](jls-8.html#d5e13595)
8.4.8.3-2. [Unchecked Warning from Return Type](jls-8.html#d5e13600)
8.4.8.3-3. [Incorrect Overriding because of `throws`](jls-8.html#d5e13616)
8.4.8.3-4. [Erasure Affects Overriding](jls-8.html#d5e13638)
8.4.9-1. [Overloading](jls-8.html#d5e13722)
8.4.9-2. [Overloading, Overriding, and Hiding](jls-8.html#d5e13748)
8.8-1. [Constructor Declarations](jls-8.html#d5e13972)
8.8.7-1. [Constructor Bodies](jls-8.html#d5e14100)
8.8.7.1-1. [Restrictions on Explicit Constructor Invocation Statements](jls-8.html#d5e14270)
8.8.7.1-2. [Qualified Superclass Constructor Invocation](jls-8.html#d5e14278)
8.8.9-1. [Default Constructors](jls-8.html#d5e14342)
8.8.9-2. [Accessibility of Constructors v. Classes](jls-8.html#d5e14352)
8.8.10-1. [Preventing Instantiation via Constructor Accessibility](jls-8.html#d5e14380)
8.9.2-1. [Enum Body Declarations](jls-8.html#d5e14541)
8.9.2-2. [Restriction On Enum Constant Self-Reference](jls-8.html#d5e14546)
8.9.3-1. [Iterating Over Enum Constants With An Enhanced `for` Loop](jls-8.html#d5e14600)
8.9.3-2. [Switching Over Enum Constants](jls-8.html#d5e14606)
8.9.3-3. [Enum Constants with Class Bodies](jls-8.html#d5e14617)
8.9.3-4. [Multiple Enum Types](jls-8.html#d5e14625)
9.3-1. [Ambiguous Inherited Fields](jls-9.html#d5e15059)
9.3-2. [Multiply Inherited Fields](jls-9.html#d5e15074)
9.3.1-1. [Forward Reference to a Field](jls-9.html#d5e15107)
9.4.2-1. [Overloading an `abstract` Method Declaration](jls-9.html#d5e15348)
9.6.1-1. [Annotation Type Declaration](jls-9.html#d5e15527)
9.6.1-2. [Marker Annotation Type Declaration](jls-9.html#d5e15531)
9.6.1-3. [Single-Element Annotation Type Declarations](jls-9.html#d5e15535)
9.6.2-1. [Annotation Type Declaration With Default Values](jls-9.html#d5e15565)
9.6.3-1. [Ill-formed Containing Annotation Type](jls-9.html#d5e15698)
9.6.3-2. [Restricting Where Annotations May Repeat](jls-9.html#d5e15739)
9.6.3-3. [A Repeatable Containing Annotation Type](jls-9.html#d5e15799)
9.7.1-1. [Normal Annotations](jls-9.html#d5e16291)
9.7.2-1. [Marker Annotations](jls-9.html#d5e16315)
9.7.3-1. [Single-Element Annotations](jls-9.html#d5e16342)
9.8-1. [Functional Interfaces](jls-9.html#d5e16668)
9.8-2. [Functional Interfaces and Erasure](jls-9.html#d5e16692)
9.8-3. [Generic Functional Interfaces](jls-9.html#d5e16730)
9.9-1. [Function Types](jls-9.html#d5e17005)
9.9-2. [Generic Function Types](jls-9.html#d5e17052)
10.2-1. [Declarations of Array Variables](jls-10.html#d5e17137)
10.2-2. [Array Variables and Array Types](jls-10.html#d5e17170)
10.4-1. [Array Access](jls-10.html#d5e17224)
10.5-1. [`ArrayStoreException`](jls-10.html#d5e17264)
10.6-1. [Array Initializers](jls-10.html#d5e17339)
10.7-1. [Arrays Are Cloneable](jls-10.html#d5e17384)
10.7-2. [Shared Subarrays After A Clone](jls-10.html#d5e17392)
10.8-1. [`Class` Object Of Array](jls-10.html#d5e17418)
10.8-2. [Array `Class` Objects Are Shared](jls-10.html#d5e17428)
11.2.3-1. [Catching Checked Exceptions](jls-11.html#d5e17851)
11.3-1. [Throwing and Catching Exceptions](jls-11.html#d5e17945)
12.4.1-1. [Superclasses Are Initialized Before Subclasses](jls-12.html#d5e18274)
12.4.1-2. [Only The Class That Declares `static` Field Is Initialized](jls-12.html#d5e18283)
12.4.1-3. [Interface Initialization Does Not Initialize Superinterfaces](jls-12.html#d5e18294)
12.5-1. [Evaluation of Instance Creation](jls-12.html#d5e18505)
12.5-2. [Dynamic Dispatch During Instance Creation](jls-12.html#d5e18546)
13.4.4-1. [Changing A Superclass](jls-13.html#d5e19319)
13.4.6-1. [Changing A Class Body](jls-13.html#d5e19370)
13.4.6-2. [Changing A Superclass](jls-13.html#d5e19394)
13.4.7-1. [Changing Accessibility](jls-13.html#d5e19419)
13.4.8-1. [Adding A Field Declaration](jls-13.html#d5e19471)
13.4.9-1. [Changing A Variable To Be `final`](jls-13.html#d5e19524)
13.4.9-2. [Conditional Compilation](jls-13.html#d5e19555)
13.4.16-1. [Changing A Method To Be `abstract`](jls-13.html#d5e19700)
13.4.17-1. [Changing A Method To Be `final`](jls-13.html#d5e19726)
13.4.23-1. [Adding An Overloaded Method](jls-13.html#d5e19782)
13.5.3-1. [Deleting An Interface Member](jls-13.html#d5e19841)
13.5.6-1. [Adding A Default Method](jls-13.html#d5e19889)
14.3-1. [Local Class Declarations](jls-14.html#d5e20035)
14.7-1. [Labels and Identifiers](jls-14.html#d5e20242)
14.11-1. [Fall-Through in the `switch` Statement](jls-14.html#d5e20694)
14.13-1. [The `do` Statement](jls-14.html#d5e20932)
14.14-1. [Enhanced `for` And Arrays](jls-14.html#d5e21297)
14.14-2. [Enhanced `for` And Unboxing Conversion](jls-14.html#d5e21303)
14.15-1. [The `break` Statement](jls-14.html#d5e21368)
14.16-1. [The `continue` Statement](jls-14.html#d5e21475)
14.19-1. [The `synchronized` Statement](jls-14.html#d5e21754)
14.20.1-1. [Catching An Exception](jls-14.html#d5e22040)
14.20.2-1. [Handling An Uncaught Exception With `finally`](jls-14.html#d5e22168)
15.7.1-1. [Left-Hand Operand Is Evaluated First](jls-15.html#d5e23100)
15.7.1-2. [Implicit Left-Hand Operand In Operator Of Compound Assigment](jls-15.html#d5e23111)
15.7.1-3. [Abrupt Completion of Evaluation of the Left-Hand Operand](jls-15.html#d5e23125)
15.7.2-1. [Evaluation of Operands Before Operation](jls-15.html#d5e23147)
15.7.4-1. [Evaluation Order At Method Invocation](jls-15.html#d5e23193)
15.7.4-2. [Abrupt Completion of Argument Expression](jls-15.html#d5e23202)
15.8.3-1. [The `this` Expression](jls-15.html#d5e23464)
15.9.4-1. [Evaluation Order and Out-Of-Memory Detection](jls-15.html#d5e24079)
15.10.2-1. [Array Creation Evaluation](jls-15.html#d5e24245)
15.10.2-2. [Multi-Dimensional Array Creation](jls-15.html#d5e24262)
15.10.2-3. [`OutOfMemoryError` and Dimension Expression Evaluation](jls-15.html#d5e24307)
15.10.4-1. [Array Reference Is Evaluated First](jls-15.html#d5e24372)
15.10.4-2. [Abrupt Completion of Array Reference Evaluation](jls-15.html#d5e24392)
15.10.4-3. [`null` Array Reference](jls-15.html#d5e24401)
15.11.1-1. [Static Binding for Field Access](jls-15.html#d5e24507)
15.11.1-2. [Receiver Variable Is Irrelevant For `static` Field Access](jls-15.html#d5e24541)
15.11.2-1. [The `super` Expression](jls-15.html#d5e24643)
15.12.2-1. [Method Applicability](jls-15.html#d5e24930)
15.12.2-2. [Return Type Not Considered During Method Selection](jls-15.html#d5e24977)
15.12.2-3. [Choosing The Most Specific Method](jls-15.html#d5e24988)
15.12.4.1-1. [Target References and `static` Methods](jls-15.html#d5e26146)
15.12.4.1-2. [Evaluation Order During Method Invocation](jls-15.html#d5e26159)
15.12.4.4-1. [Overriding and Method Invocation](jls-15.html#d5e26451)
15.12.4.4-2. [Method Invocation Using `super`](jls-15.html#d5e26479)
15.12.4.5-1. [Invoked Method Signature Has Different Erasure Than Compile-Time Method Signature](jls-15.html#d5e26528)
15.17.3-1. [Integer Remainder Operator](jls-15.html#d5e27778)
15.17.3-2. [Floating-Point Remainder Operator](jls-15.html#d5e27821)
15.18.1-1. [String Concatenation](jls-15.html#d5e27870)
15.18.1-2. [String Concatenation and Conditionals](jls-15.html#d5e27889)
15.20.2-1. [The `instanceof` Operator](jls-15.html#d5e28242)
15.26.1-1. [Simple Assignment To An Array Component](jls-15.html#d5e30304)
15.26.2-1. [Compound Assignment To An Array Component](jls-15.html#d5e30393)
15.26.2-2. [Value Of Left-Hand Side Of Compound Assignment Is Saved Before Evaluation Of Right-Hand Side](jls-15.html#d5e30401)
15.28-1. [Constant Expressions](jls-15.html#d5e30892)
16-1. [Definite Assignment Considers Structure of Statements and Expressions](jls-16.html#d5e30931)
16-2. [Definite Assignment Does Not Consider Values of Expressions](jls-16.html#d5e30957)
16-3. [Definite Unassignment](jls-16.html#d5e30976)
17.4-1. [Incorrectly Synchronized Programs May Exhibit Surprising Behavior](jls-17.html#d5e33066)
17.4.5-1. [Happens-before Consistency](jls-17.html#d5e33539)
17.4.8-1. [Happens-before Consistency Is Not Sufficient](jls-17.html#d5e33964)
17.5-1. [`final` Fields In The Java Memory Model](jls-17.html#d5e34106)
17.5-2. [`final` Fields For Security](jls-17.html#d5e34133)
17.5.3-1. [Aggressive Optimization of `final` Fields](jls-17.html#d5e34273)
17.6-1. [Detection of Word Tearing](jls-17.html#d5e34335)

## üçÄ Legal Notice
  
Specification: JSR-337 Java¬Æ SE 8 Release Contents ("Specification")  
Version: 8  
Status: Maintenance Release  
Release: March 2015  
  
Copyright ¬© 1997, 2015, Oracle America, Inc. and/or its affiliates.  
500 Oracle Parkway, Redwood City, California 94065, U.S.A.  
All rights reserved.  

Oracle and Java are registered trademarks of Oracle and/or its affiliates. Other names may be trademarks of their respective owners.

The Specification provided herein is provided to you only under the Limited License Grant included herein as Appendix A. Please see [Appendix A, _Limited License Grant_](spec-license.html "Appendix A. Limited License Grant").

üçÄ Preface to the Java SE 8 Edition
--------------------------------

### Alex Buckley

In 1996, James Gosling, Bill Joy, and Guy Steele wrote for the First Edition of _The Java¬Æ Language Specification_:

_"We believe that the Java programming language is a mature language, ready for widespread use. Nevertheless, we expect some evolution of the language in the years to come. We intend to manage this evolution in a way that is completely compatible with existing applications."_

Java SE 8 represents the single largest evolution of the Java language in its history. A relatively small number of features - lambda expressions, method references, and functional interfaces - combine to offer a programming model that fuses the object-oriented and functional styles. Under the leadership of Brian Goetz, this fusion has been accomplished in a way that encourages best practices - immutability, statelessness, compositionality - while preserving "the feel of Java" - readability, simplicity, universality.

Crucially, the libraries of the Java SE platform have co-evolved with the Java language. This means that using lambda expressions and method references to represent behavior - for example, an operation to be applied to each element in a list - is productive and performant "out of the box". In a similar fashion, the Java Virtual Machine has co-evolved with the Java language to ensure that default methods support library evolution as consistently as possible across compile time and run time, given the constraints of separate compilation.

Initiatives to add first-class functions to the Java language have been around since the 1990s. The _BGGA_ and _CICE_ proposals circa 2007 brought new energy to the topic, while the creation of _Project Lambda_ in OpenJDK circa 2009 attracted unprecedented levels of interest. The addition of method handles to the JVM in Java SE 7 opened the door to new implementation techniques while retaining "write once, run anywhere." In time, language changes were overseen by JSR 335, _Lambda Expressions for the Java Programming Language_, whose Expert Group consisted of Joshua Bloch, Kevin Bourrillion, Andrey Breslav, R√©mi Forax, Dan Heidinga, Doug Lea, Bob Lee, David Lloyd, Sam Pullara, Srikanth Sankaran, and Vladimir Zakharov.

Programming language design typically involves grappling with degrees of complexity utterly hidden from the language's users. (For this reason, it is often compared to an iceberg: 90% of it is invisible.) In JSR 335, the greatest complexity lurked in the interaction of implicitly typed lambda expressions with overload resolution. In this and many other areas, Dan Smith at Oracle did an outstanding job of thoroughly specifying the desired behavior. His words are to be found throughout this specification, including an entirely new chapter on type inference.

Another initiative in Java SE 8 has been to enhance the utility of annotations, one of the most popular features of the Java language. First, the Java grammar has been extended to allow annotations on types in many language constructs, forming the basis for novel static analysis tools such as the _Checker Framework_. This feature was specified by JSR 308, _Annotations on Java Types_, led by Michael Ernst with an Expert Group of myself, Doug Lea, and Srikanth Sankaran. The changes involved in this specification were wide-ranging, and the unstinting efforts of Michael Ernst and Werner Dietl over many years are warmly recognized. Second, annotations may be "repeated" on a language construct, to the great benefit of APIs that model domain-specific configuration with annotation types. Michael Keith and Bill Shannon in Java EE initiated and guided this feature.

Many colleagues in the Java Platform Group at Oracle have provided valuable support to this specification: Leonid Arbouzov, Mandy Chung, Joe Darcy, Robert Field, Joel Borggr√©n-Franck, Sonali Goel, Jon Gibbons, Jeannette Hung, Stuart Marks, Eric McCorkle, Matherey Nunez, Mark Reinhold, Vicente Romero, John Rose, Georges Saab, Steve Sides, Bernard Traversat, and Michel Trudeau.

Perhaps the greatest acknowledgement must go to the compiler engineers who turn the specification into real software. Maurizio Cimadamore at Oracle worked heroically from the earliest days on the design of lambda expressions and their implementation in `javac`. Support for Java SE 8 features in Eclipse was contributed by Jayaprakash Arthanareeswaran, Shankha Banerjee, Anirban Chakraborty, Andrew Clement, Stephan Herrmann, Markus Keller, Jesper M√∏ller, Manoj Palat, Srikanth Sankaran, and Olivier Thomann; and in IntelliJ by Anna Kozlova, Alexey Kudravtsev, and Roman Shevchenko. They deserve the thanks of the entire Java community.

Java SE 8 is a renaissance for the Java language. While some search for the "next great language", we believe that programming in Java is more exciting and productive than ever. We hope that it continues to wear well for you.

üçÄ Chapter 1. Introduction
-----------------------

**Table of Contents**

[1.1. Organization of the Specification](jls-1.html#jls-1.1)
[1.2. Example Programs](jls-1.html#jls-1.2)
[1.3. Notation](jls-1.html#jls-1.3)
[1.4. Relationship to Predefined Classes and Interfaces](jls-1.html#jls-1.4)
[1.5. Feedback](jls-1.html#jls-1.5)
[1.6. References](jls-1.html#jls-1.6)

The Java¬Æ programming language is a general-purpose, concurrent, class-based, object-oriented language. It is designed to be simple enough that many programmers can achieve fluency in the language. The Java programming language is related to C and C++ but is organized rather differently, with a number of aspects of C and C++ omitted and a few ideas from other languages included. It is intended to be a production language, not a research language, and so, as C. A. R. Hoare suggested in his classic paper on language design, the design has avoided including new and untested features.

The Java programming language is strongly and statically typed. This specification clearly distinguishes between the _compile-time errors_ that can and must be detected at compile time, and those that occur at run time. Compile time normally consists of translating programs into a machine-independent byte code representation. Run-time activities include loading and linking of the classes needed to execute a program, optional machine code generation and dynamic optimization of the program, and actual program execution.

The Java programming language is a relatively high-level language, in that details of the machine representation are not available through the language. It includes automatic storage management, typically using a garbage collector, to avoid the safety problems of explicit deallocation (as in C's `free` or C++'s `delete`). High-performance garbage-collected implementations can have bounded pauses to support systems programming and real-time applications. The language does not include any unsafe constructs, such as array accesses without index checking, since such unsafe constructs would cause a program to behave in an unspecified way.

The Java programming language is normally compiled to the bytecode instruction set and binary format defined in _The Java Virtual Machine Specification, Java SE 8 Edition_.

1.1. Organization of the Specification
--------------------------------------

Chapter 2 describes grammars and the notation used to present the lexical and syntactic grammars for the language.

Chapter 3 describes the lexical structure of the Java programming language, which is based on C and C++. The language is written in the Unicode character set. It supports the writing of Unicode characters on systems that support only ASCII.

Chapter 4 describes types, values, and variables. Types are subdivided into primitive types and reference types.

The primitive types are defined to be the same on all machines and in all implementations, and are various sizes of two's-complement integers, single- and double-precision IEEE 754 standard floating-point numbers, a `boolean` type, and a Unicode character `char` type. Values of the primitive types do not share state.

Reference types are the class types, the interface types, and the array types. The reference types are implemented by dynamically created objects that are either instances of classes or arrays. Many references to each object can exist. All objects (including arrays) support the methods of the class `Object`, which is the (single) root of the class hierarchy. A predefined `String` class supports Unicode character strings. Classes exist for wrapping primitive values inside of objects. In many cases, wrapping and unwrapping is performed automatically by the compiler (in which case, wrapping is called boxing, and unwrapping is called unboxing). Class and interface declarations may be generic, that is, they may be parameterized by other reference types. Such declarations may then be invoked with specific type arguments.

Variables are typed storage locations. A variable of a primitive type holds a value of that exact primitive type. A variable of a class type can hold a null reference or a reference to an object whose type is that class type or any subclass of that class type. A variable of an interface type can hold a null reference or a reference to an instance of any class that implements the interface. A variable of an array type can hold a null reference or a reference to an array. A variable of class type `Object` can hold a null reference or a reference to any object, whether class instance or array.

Chapter 5 describes conversions and numeric promotions. Conversions change the compile-time type and, sometimes, the value of an expression. These conversions include the boxing and unboxing conversions between primitive types and reference types. Numeric promotions are used to convert the operands of a numeric operator to a common type where an operation can be performed. There are no loopholes in the language; casts on reference types are checked at run time to ensure type safety.

Chapter 6 describes declarations and names, and how to determine what names mean (denote). The language does not require types or their members to be declared before they are used. Declaration order is significant only for local variables, local classes, and the order of initializers of fields in a class or interface.

The Java programming language provides control over the scope of names and supports limitations on external access to members of packages, classes, and interfaces. This helps in writing large programs by distinguishing the implementation of a type from its users and those who extend it. Recommended naming conventions that make for more readable programs are described here.

Chapter 7 describes the structure of a program, which is organized into packages similar to the modules of Modula. The members of a package are classes, interfaces, and subpackages. Packages are divided into compilation units. Compilation units contain type declarations and can import types from other packages to give them short names. Packages have names in a hierarchical name space, and the Internet domain name system can usually be used to form unique package names.

Chapter 8 describes classes. The members of classes are classes, interfaces, fields (variables) and methods. Class variables exist once per class. Class methods operate without reference to a specific object. Instance variables are dynamically created in objects that are instances of classes. Instance methods are invoked on instances of classes; such instances become the current object `this` during their execution, supporting the object-oriented programming style.

Classes support single implementation inheritance, in which the implementation of each class is derived from that of a single superclass, and ultimately from the class `Object`. Variables of a class type can reference an instance of that class or of any subclass of that class, allowing new types to be used with existing methods, polymorphically.

Classes support concurrent programming with `synchronized` methods. Methods declare the checked exceptions that can arise from their execution, which allows compile-time checking to ensure that exceptional conditions are handled. Objects can declare a `finalize` method that will be invoked before the objects are discarded by the garbage collector, allowing the objects to clean up their state.

For simplicity, the language has neither declaration "headers" separate from the implementation of a class nor separate type and class hierarchies.

A special form of classes, enums, support the definition of small sets of values and their manipulation in a type safe manner. Unlike enumerations in other languages, enums are objects and may have their own methods.

Chapter 9 describes interface types, which declare a set of abstract methods, member types, and constants. Classes that are otherwise unrelated can implement the same interface type. A variable of an interface type can contain a reference to any object that implements the interface. Multiple interface inheritance is supported.

Annotation types are specialized interfaces used to annotate declarations. Such annotations are not permitted to affect the semantics of programs in the Java programming language in any way. However, they provide useful input to various tools.

Chapter 10 describes arrays. Array accesses include bounds checking. Arrays are dynamically created objects and may be assigned to variables of type `Object`. The language supports arrays of arrays, rather than multidimensional arrays.

Chapter 11 describes exceptions, which are nonresuming and fully integrated with the language semantics and concurrency mechanisms. There are three kinds of exceptions: checked exceptions, run-time exceptions, and errors. The compiler ensures that checked exceptions are properly handled by requiring that a method or constructor can result in a checked exception only if the method or constructor declares it. This provides compile-time checking that exception handlers exist, and aids programming in the large. Most user-defined exceptions should be checked exceptions. Invalid operations in the program detected by the Java Virtual Machine result in run-time exceptions, such as `NullPointerException`. Errors result from failures detected by the Java Virtual Machine, such as `OutOfMemoryError`. Most simple programs do not try to handle errors.

Chapter 12 describes activities that occur during execution of a program. A program is normally stored as binary files representing compiled classes and interfaces. These binary files can be loaded into a Java Virtual Machine, linked to other classes and interfaces, and initialized.

After initialization, class methods and class variables may be used. Some classes may be instantiated to create new objects of the class type. Objects that are class instances also contain an instance of each superclass of the class, and object creation involves recursive creation of these superclass instances.

When an object is no longer referenced, it may be reclaimed by the garbage collector. If an object declares a finalizer, the finalizer is executed before the object is reclaimed to give the object a last chance to clean up resources that would not otherwise be released. When a class is no longer needed, it may be unloaded.

Chapter 13 describes binary compatibility, specifying the impact of changes to types on other types that use the changed types but have not been recompiled. These considerations are of interest to developers of types that are to be widely distributed, in a continuing series of versions, often through the Internet. Good program development environments automatically recompile dependent code whenever a type is changed, so most programmers need not be concerned about these details.

Chapter 14 describes blocks and statements, which are based on C and C++. The language has no `goto` statement, but includes labeled `break` and `continue` statements. Unlike C, the Java programming language requires `boolean` (or `Boolean`) expressions in control-flow statements, and does not convert types to `boolean` implicitly (except through unboxing), in the hope of catching more errors at compile time. A `synchronized` statement provides basic object-level monitor locking. A `try` statement can include `catch` and `finally` clauses to protect against non-local control transfers.

Chapter 15 describes expressions. This document fully specifies the (apparent) order of evaluation of expressions, for increased determinism and portability. Overloaded methods and constructors are resolved at compile time by picking the most specific method or constructor from those which are applicable.

Chapter 16 describes the precise way in which the language ensures that local variables are definitely set before use. While all other variables are automatically initialized to a default value, the Java programming language does not automatically initialize local variables in order to avoid masking programming errors.

Chapter 17 describes the semantics of threads and locks, which are based on the monitor-based concurrency originally introduced with the Mesa programming language. The Java programming language specifies a memory model for shared-memory multiprocessors that supports high-performance implementations.

Chapter 18 describes a variety of type inference algorithms used to test applicability of generic methods and to infer types in a generic method invocation.

Chapter 19 presents a syntactic grammar for the language.

1.2. Example Programs
---------------------

Most of the example programs given in the text are ready to be executed and are similar in form to:

class Test {
    public static void main(String\[\] args) {
        for (int i = 0; i < args.length; i++)
            System.out.print(i == 0 ? args\[i\] : " " + args\[i\]);
        System.out.println();
    }
}

On a machine with the Oracle JDK installed, this class, stored in the file `Test.java`, can be compiled and executed by giving the commands:

javac Test.java
java Test Hello, world.

producing the output:

Hello, world.

1.3. Notation
-------------

Throughout this specification we refer to classes and interfaces drawn from the Java SE platform API. Whenever we refer to a class or interface (other than those declared in an example) using a single identifier _N_, the intended reference is to the class or interface named _N_ in the package `java.lang`. We use the canonical name ([¬ß6.7](jls-6.html#jls-6.7 "6.7. Fully Qualified Names and Canonical Names")) for classes or interfaces from packages other than `java.lang`.

Non-normative information, designed to clarify the specification, is given in smaller, indented text.

This is non-normative information. It provides intuition, rationale, advice, examples, etc.

The type system of the Java programming language occasionally relies on the notion of a _substitution_. The notation `[F1:=T1,...,Fn:=Tn]` denotes substitution of Fi by Ti for 1 ‚â§ _i_ ‚â§ _n_.

1.4. Relationship to Predefined Classes and Interfaces
------------------------------------------------------

As noted above, this specification often refers to classes of the Java SE platform API. In particular, some classes have a special relationship with the Java programming language. Examples include classes such as `Object`, `Class`, `ClassLoader`, `String`, `Thread`, and the classes and interfaces in package `java.lang.reflect`, among others. This specification constrains the behavior of such classes and interfaces, but does not provide a complete specification for them. The reader is referred to the Java SE platform API documentation.

Consequently, this specification does not describe reflection in any detail. Many linguistic constructs have analogs in the Core Reflection API (`java.lang.reflect`) and the Language Model API (`javax.lang.model`), but these are generally not discussed here. For example, when we list the ways in which an object can be created, we generally do not include the ways in which the Core Reflection API can accomplish this. Readers should be aware of these additional mechanisms even though they are not mentioned in the text.

1.5. Feedback
-------------

Readers are invited to report technical errors and ambiguities in _The Java¬Æ Language Specification_ to `jls-jvms-spec-comments@openjdk.java.net`.

Questions concerning the behavior of `javac` (the reference compiler for the Java programming language), and in particular its conformance to this specification, may be sent to `compiler-dev@openjdk.java.net`.

1.6. References
---------------

### Bibliography

Apple Computer. _Dylan Reference Manual_. Apple Computer Inc., Cupertino, California. September 29, 1995.

Bobrow, Daniel G., Linda G. DeMichiel, Richard P. Gabriel, Sonya E. Keene, Gregor Kiczales, and David A. Moon. _Common Lisp Object System Specification_, X3J13 Document 88-002R, June 1988; appears as Chapter 28 of Steele, Guy. _Common Lisp: The Language_, 2nd ed. Digital Press, 1990, ISBN 1-55558-041-6, 770-864.

Ellis, Margaret A., and Bjarne Stroustrup. _The Annotated C++ Reference Manual_. Addison-Wesley, Reading, Massachusetts, 1990, reprinted with corrections October 1992, ISBN 0-201-51459-1.

Goldberg, Adele and Robson, David. _Smalltalk-80: The Language_. Addison-Wesley, Reading, Massachusetts, 1989, ISBN 0-201-13688-0.

Harbison, Samuel. _Modula-3_. Prentice Hall, Englewood Cliffs, New Jersey, 1992, ISBN 0-13-596396.

Hoare, C. A. R. _Hints on Programming Language Design_. Stanford University Computer Science Department Technical Report No. CS-73-403, December 1973. Reprinted in SIGACT/SIGPLAN Symposium on Principles of Programming Languages. Association for Computing Machinery, New York, October 1973.

_IEEE Standard for Binary Floating-Point Arithmetic_. ANSI/IEEE Std. 754-1985. Available from Global Engineering Documents, 15 Inverness Way East, Englewood, Colorado 80112-5704 USA; 800-854-7179.

Kernighan, Brian W., and Dennis M. Ritchie. _The C Programming Language_, 2nd ed. Prentice Hall, Englewood Cliffs, New Jersey, 1988, ISBN 0-13-110362-8.

Madsen, Ole Lehrmann, Birger M√∏ller-Pedersen, and Kristen Nygaard. _Object-Oriented Programming in the Beta Programming Language_. Addison-Wesley, Reading, Massachusetts, 1993, ISBN 0-201-62430-3.

Mitchell, James G., William Maybury, and Richard Sweet. _The Mesa Programming Language, Version 5.0_. Xerox PARC, Palo Alto, California, CSL 79-3, April 1979.

Stroustrup, Bjarne. _The C++ Progamming Language_, 2nd ed. Addison-Wesley, Reading, Massachusetts, 1991, reprinted with corrections January 1994, ISBN 0-201-53992-6.

Unicode Consortium, The. _The Unicode Standard, Version 6.2.0_. Mountain View, California, 2012, ISBN 978-1-936213-07-8.

üçÄ Chapter 2. Grammars
-------------------

**Table of Contents**

[2.1. Context-Free Grammars](jls-2.html#jls-2.1)
[2.2. The Lexical Grammar](jls-2.html#jls-2.2)
[2.3. The Syntactic Grammar](jls-2.html#jls-2.3)
[2.4. Grammar Notation](jls-2.html#jls-2.4)

This chapter describes the context-free grammars used in this specification to define the lexical and syntactic structure of a program.

2.1. Context-Free Grammars
--------------------------

A _context-free grammar_ consists of a number of _productions_. Each production has an abstract symbol called a _nonterminal_ as its _left-hand side_, and a sequence of one or more nonterminal and _terminal_ symbols as its _right-hand side_. For each grammar, the terminal symbols are drawn from a specified _alphabet_.

Starting from a sentence consisting of a single distinguished nonterminal, called the _goal symbol_, a given context-free grammar specifies a language, namely, the set of possible sequences of terminal symbols that can result from repeatedly replacing any nonterminal in the sequence with a right-hand side of a production for which the nonterminal is the left-hand side.

2.2. The Lexical Grammar
------------------------

A _lexical grammar_ for the Java programming language is given in [¬ß3 (_Lexical Structure_)](jls-3.html "Chapter 3. Lexical Structure"). This grammar has as its terminal symbols the characters of the Unicode character set. It defines a set of productions, starting from the goal symbol _Input_ ([¬ß3.5](jls-3.html#jls-3.5 "3.5. Input Elements and Tokens")), that describe how sequences of Unicode characters ([¬ß3.1](jls-3.html#jls-3.1 "3.1. Unicode")) are translated into a sequence of input elements ([¬ß3.5](jls-3.html#jls-3.5 "3.5. Input Elements and Tokens")).

These input elements, with white space ([¬ß3.6](jls-3.html#jls-3.6 "3.6. White Space")) and comments ([¬ß3.7](jls-3.html#jls-3.7 "3.7. Comments")) discarded, form the terminal symbols for the syntactic grammar for the Java programming language and are called _tokens_ ([¬ß3.5](jls-3.html#jls-3.5 "3.5. Input Elements and Tokens")). These tokens are the identifiers ([¬ß3.8](jls-3.html#jls-3.8 "3.8. Identifiers")), keywords ([¬ß3.9](jls-3.html#jls-3.9 "3.9. Keywords")), literals ([¬ß3.10](jls-3.html#jls-3.10 "3.10. Literals")), separators ([¬ß3.11](jls-3.html#jls-3.11 "3.11. Separators")), and operators ([¬ß3.12](jls-3.html#jls-3.12 "3.12. Operators")) of the Java programming language.

2.3. The Syntactic Grammar
--------------------------

The _syntactic grammar_ for the Java programming language is given in Chapters 4, 6-10, 14, and 15. This grammar has tokens defined by the lexical grammar as its terminal symbols. It defines a set of productions, starting from the goal symbol _CompilationUnit_ ([¬ß7.3](jls-7.html#jls-7.3 "7.3. Compilation Units")), that describe how sequences of tokens can form syntactically correct programs.

For convenience, the syntactic grammar is presented all together in Chapter 19.

2.4. Grammar Notation
---------------------

Terminal symbols are shown in `fixed width` font in the productions of the lexical and syntactic grammars, and throughout this specification whenever the text is directly referring to such a terminal symbol. These are to appear in a program exactly as written.

Nonterminal symbols are shown in _italic_ type. The definition of a nonterminal is introduced by the name of the nonterminal being defined, followed by a colon. One or more alternative definitions for the nonterminal then follow on succeeding lines.

For example, the syntactic production:

    IfThenStatement:

      `if` `(` Expression `)` Statement

states that the nonterminal _IfThenStatement_ represents the token `if`, followed by a left parenthesis token, followed by an _Expression_, followed by a right parenthesis token, followed by a _Statement_.

The syntax _{x}_ on the right-hand side of a production denotes zero or more occurrences of _x_.

For example, the syntactic production:

    ArgumentList:

      Argument {, Argument}

states that an _ArgumentList_ consists of an _Argument_, followed by zero or more occurrences of a comma and an _Argument_. The result is that an _ArgumentList_ may contain any positive number of arguments.

The syntax _\[x\]_ on the right-hand side of a production denotes zero or one occurrences of _x_. That is, _x_ is an _optional symbol_. The alternative which contains the optional symbol actually defines two alternatives: one that omits the optional symbol and one that includes it.

This means that:

    BreakStatement:

      `break` \[Identifier\] `;`

is a convenient abbreviation for:

    BreakStatement:

      `break` `;`  
      `break` Identifier `;`

As another example, it means that:

    BasicForStatement:

      `for` `(` \[ForInit\] `;` \[Expression\] `;` \[ForUpdate\] `)` Statement

is a convenient abbreviation for:

    BasicForStatement:

      `for` `(` `;` \[Expression\] `;` \[ForUpdate\] `)` Statement  
      `for` `(` ForInit `;` \[Expression\] `;` \[ForUpdate\] `)` Statement

which in turn is an abbreviation for:

    BasicForStatement:

      `for` `(` `;` `;` \[ForUpdate\] `)` Statement  
      `for` `(` `;` Expression `;` \[ForUpdate\] `)` Statement  
      `for` `(` ForInit `;` `;` \[ForUpdate\] `)` Statement  
      `for` `(` ForInit `;` Expression `;` \[ForUpdate\] `)` Statement

which in turn is an abbreviation for:

    BasicForStatement:

      `for` `(` `;` `;` `)` Statement  
      `for` `(` `;` `;` ForUpdate `)` Statement  
      `for` `(` `;` Expression `;` `)` Statement  
      `for` `(` `;` Expression `;` ForUpdate `)` Statement  
      `for` `(` ForInit `;` `;` `)` Statement  
      `for` `(` ForInit `;` `;` ForUpdate `)` Statement  
      `for` `(` ForInit `;` Expression `;` `)` Statement  
      `for` `(` ForInit `;` Expression `;` ForUpdate `)` Statement

so the nonterminal _BasicForStatement_ actually has eight alternative right-hand sides.

A very long right-hand side may be continued on a second line by clearly indenting the second line.

For example, the syntactic grammar contains this production:

    NormalClassDeclaration:

      {[ClassModifier](jls-8.html#jls-ClassModifier "ClassModifier")} `class` [Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeParameters](jls-8.html#jls-TypeParameters "TypeParameters")\] \[[Superclass](jls-8.html#jls-Superclass "Superclass")\] \[[Superinterfaces](jls-8.html#jls-Superinterfaces "Superinterfaces")\] [ClassBody](jls-8.html#jls-ClassBody "ClassBody")

which defines one right-hand side for the nonterminal _NormalClassDeclaration_.

The phrase _(one of)_ on the right-hand side of a production signifies that each of the terminal symbols on the following line or lines is an alternative definition.

For example, the lexical grammar contains the production:

    ZeroToThree:
      (one of)  
      `0 1 2 3`

which is merely a convenient abbreviation for:

    ZeroToThree:

      `0`  
      `1`  
      `2`  
      `3`

When an alternative in a production appears to be a token, it represents the sequence of characters that would make up such a token.

Thus, the production:

    BooleanLiteral:
      (one of)  
      `true` `false`

is shorthand for:

    BooleanLiteral:
      `t r u e`  
      `f a l s e`

The right-hand side of a production may specify that certain expansions are not permitted by using the phrase "but not" and then indicating the expansions to be excluded.

For example:

    Identifier:

      [IdentifierChars](jls-3.html#jls-IdentifierChars "IdentifierChars") but not a [Keyword](jls-3.html#jls-Keyword "Keyword") or [BooleanLiteral](jls-3.html#jls-BooleanLiteral "BooleanLiteral") or [NullLiteral](jls-3.html#jls-NullLiteral "NullLiteral")

Finally, a few nonterminals are defined by a narrative phrase in roman type where it would be impractical to list all the alternatives.

For example:

    RawInputCharacter:

      any Unicode character

üçÄ Chapter 3. Lexical Structure
----------------------------

**Table of Contents**

[3.1. Unicode](jls-3.html#jls-3.1)
[3.2. Lexical Translations](jls-3.html#jls-3.2)
[3.3. Unicode Escapes](jls-3.html#jls-3.3)
[3.4. Line Terminators](jls-3.html#jls-3.4)
[3.5. Input Elements and Tokens](jls-3.html#jls-3.5)
[3.6. White Space](jls-3.html#jls-3.6)
[3.7. Comments](jls-3.html#jls-3.7)
[3.8. Identifiers](jls-3.html#jls-3.8)
[3.9. Keywords](jls-3.html#jls-3.9)
[3.10. Literals](jls-3.html#jls-3.10)
[3.10.1. Integer Literals](jls-3.html#jls-3.10.1)
[3.10.2. Floating-Point Literals](jls-3.html#jls-3.10.2)
[3.10.3. Boolean Literals](jls-3.html#jls-3.10.3)
[3.10.4. Character Literals](jls-3.html#jls-3.10.4)
[3.10.5. String Literals](jls-3.html#jls-3.10.5)
[3.10.6. Escape Sequences for Character and String Literals](jls-3.html#jls-3.10.6)
[3.10.7. The Null Literal](jls-3.html#jls-3.10.7)
[3.11. Separators](jls-3.html#jls-3.11)
[3.12. Operators](jls-3.html#jls-3.12)

This chapter specifies the lexical structure of the Java programming language.

Programs are written in Unicode ([¬ß3.1](jls-3.html#jls-3.1 "3.1. Unicode")), but lexical translations are provided ([¬ß3.2](jls-3.html#jls-3.2 "3.2. Lexical Translations")) so that Unicode escapes ([¬ß3.3](jls-3.html#jls-3.3 "3.3. Unicode Escapes")) can be used to include any Unicode character using only ASCII characters. Line terminators are defined ([¬ß3.4](jls-3.html#jls-3.4 "3.4. Line Terminators")) to support the different conventions of existing host systems while maintaining consistent line numbers.

The Unicode characters resulting from the lexical translations are reduced to a sequence of input elements ([¬ß3.5](jls-3.html#jls-3.5 "3.5. Input Elements and Tokens")), which are white space ([¬ß3.6](jls-3.html#jls-3.6 "3.6. White Space")), comments ([¬ß3.7](jls-3.html#jls-3.7 "3.7. Comments")), and tokens. The tokens are the identifiers ([¬ß3.8](jls-3.html#jls-3.8 "3.8. Identifiers")), keywords ([¬ß3.9](jls-3.html#jls-3.9 "3.9. Keywords")), literals ([¬ß3.10](jls-3.html#jls-3.10 "3.10. Literals")), separators ([¬ß3.11](jls-3.html#jls-3.11 "3.11. Separators")), and operators ([¬ß3.12](jls-3.html#jls-3.12 "3.12. Operators")) of the syntactic grammar.

3.1. Unicode
------------

Programs are written using the Unicode character set. Information about this character set and its associated character encodings may be found at `http://www.unicode.org/`.

The Java SE platform tracks the Unicode Standard as it evolves. The precise version of Unicode used by a given release is specified in the documentation of the class `Character`.

Versions of the Java programming language prior to JDK 1.1 used Unicode 1.1.5. Upgrades to newer versions of the Unicode Standard occurred in JDK 1.1 (to Unicode 2.0), JDK 1.1.7 (to Unicode 2.1), Java SE 1.4 (to Unicode 3.0), Java SE 5.0 (to Unicode 4.0), Java SE 7 (to Unicode 6.0), and Java SE 8 (to Unicode 6.2).

The Unicode standard was originally designed as a fixed-width 16-bit character encoding. It has since been changed to allow for characters whose representation requires more than 16 bits. The range of legal code points is now U+0000 to U+10FFFF, using the hexadecimal _U+n notation_. Characters whose code points are greater than U+FFFF are called supplementary characters. To represent the complete range of characters using only 16-bit units, the Unicode standard defines an encoding called UTF-16. In this encoding, supplementary characters are represented as pairs of 16-bit code units, the first from the high-surrogates range, (U+D800 to U+DBFF), the second from the low-surrogates range (U+DC00 to U+DFFF). For characters in the range U+0000 to U+FFFF, the values of code points and UTF-16 code units are the same.

The Java programming language represents text in sequences of 16-bit code units, using the UTF-16 encoding.

Some APIs of the Java SE platform, primarily in the `Character` class, use 32-bit integers to represent code points as individual entities. The Java SE platform provides methods to convert between 16-bit and 32-bit representations.

This specification uses the terms _code point_ and _UTF-16 code unit_ where the representation is relevant, and the generic term _character_ where the representation is irrelevant to the discussion.

Except for comments ([¬ß3.7](jls-3.html#jls-3.7 "3.7. Comments")), identifiers, and the contents of character and string literals ([¬ß3.10.4](jls-3.html#jls-3.10.4 "3.10.4. Character Literals"), [¬ß3.10.5](jls-3.html#jls-3.10.5 "3.10.5. String Literals")), all input elements ([¬ß3.5](jls-3.html#jls-3.5 "3.5. Input Elements and Tokens")) in a program are formed only from ASCII characters (or Unicode escapes ([¬ß3.3](jls-3.html#jls-3.3 "3.3. Unicode Escapes")) which result in ASCII characters).

ASCII (ANSI X3.4) is the American Standard Code for Information Interchange. The first 128 characters of the Unicode UTF-16 encoding are the ASCII characters.

3.2. Lexical Translations
-------------------------

A raw Unicode character stream is translated into a sequence of tokens, using the following three lexical translation steps, which are applied in turn:

1.  A translation of Unicode escapes ([¬ß3.3](jls-3.html#jls-3.3 "3.3. Unicode Escapes")) in the raw stream of Unicode characters to the corresponding Unicode character. A Unicode escape of the form `\u_xxxx_`, where `_xxxx_` is a hexadecimal value, represents the UTF-16 code unit whose encoding is `_xxxx_`. This translation step allows any program to be expressed using only ASCII characters.
    
2.  A translation of the Unicode stream resulting from step 1 into a stream of input characters and line terminators ([¬ß3.4](jls-3.html#jls-3.4 "3.4. Line Terminators")).
    
3.  A translation of the stream of input characters and line terminators resulting from step 2 into a sequence of input elements ([¬ß3.5](jls-3.html#jls-3.5 "3.5. Input Elements and Tokens")) which, after white space ([¬ß3.6](jls-3.html#jls-3.6 "3.6. White Space")) and comments ([¬ß3.7](jls-3.html#jls-3.7 "3.7. Comments")) are discarded, comprise the tokens ([¬ß3.5](jls-3.html#jls-3.5 "3.5. Input Elements and Tokens")) that are the terminal symbols of the syntactic grammar ([¬ß2.3](jls-2.html#jls-2.3 "2.3. The Syntactic Grammar")).
    

The longest possible translation is used at each step, even if the result does not ultimately make a correct program while another lexical translation would. There is one exception: if lexical translation occurs in a type context ([¬ß4.11](jls-4.html#jls-4.11 "4.11. Where Types Are Used")) and the input stream has two or more consecutive `>` characters that are followed by a non-`>` character, then each `>` character must be translated to the token for the numerical comparison operator `>`.

The input characters `a--b` are tokenized ([¬ß3.5](jls-3.html#jls-3.5 "3.5. Input Elements and Tokens")) as `a`, `--`, `b`, which is not part of any grammatically correct program, even though the tokenization `a`, `-`, `-`, `b` could be part of a grammatically correct program.

Without the rule for `>` characters, two consecutive `>` brackets in a type such as ``` List`<`List`<`String`>``>` ``` would be tokenized as the signed right shift operator `>>`, while three consecutive `>` brackets in a type such as ``` List`<`List`<`List`<`String`>``>``>` ``` would be tokenized as the unsigned right shift operator `>>>`. Worse, the tokenization of four or more consecutive `>` brackets in a type such as ``` List`<`List`<`List`<`List`<`String`>``>``>``>` ``` would be ambiguous, as various combinations of `>`, `>>`, and `>>>` tokens could represent the `>``>``>``>` characters.

3.3. Unicode Escapes
--------------------

A compiler for the Java programming language ("Java compiler") first recognizes Unicode escapes in its input, translating the ASCII characters `\u` followed by four hexadecimal digits to the UTF-16 code unit ([¬ß3.1](jls-3.html#jls-3.1 "3.1. Unicode")) for the indicated hexadecimal value, and passing all other characters unchanged. Representing supplementary characters requires two consecutive Unicode escapes. This translation step results in a sequence of Unicode input characters.

    UnicodeInputCharacter:

    [UnicodeEscape](jls-3.html#jls-UnicodeEscape "UnicodeEscape")  
    [RawInputCharacter](jls-3.html#jls-RawInputCharacter "RawInputCharacter")

    UnicodeEscape:

    `\` [UnicodeMarker](jls-3.html#jls-UnicodeMarker "UnicodeMarker") [HexDigit](jls-3.html#jls-HexDigit "HexDigit") [HexDigit](jls-3.html#jls-HexDigit "HexDigit") [HexDigit](jls-3.html#jls-HexDigit "HexDigit") [HexDigit](jls-3.html#jls-HexDigit "HexDigit")

    UnicodeMarker:

    `u` {`u`}

    HexDigit:

    (one of)  
    `0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F`

    RawInputCharacter:

    any Unicode character

The `\`, `u`, and hexadecimal digits here are all ASCII characters.

In addition to the processing implied by the grammar, for each raw input character that is a backslash `\`, input processing must consider how many other `\` characters contiguously precede it, separating it from a non-`\` character or the start of the input stream. If this number is even, then the `\` is eligible to begin a Unicode escape; if the number is odd, then the `\` is not eligible to begin a Unicode escape.

For example, the raw input `"\\u2122=\u2122"` results in the eleven characters `" \ \ u 2 1 2 2 = ‚Ñ¢ "` (`\u2122` is the Unicode encoding of the character `‚Ñ¢`).

If an eligible `\` is not followed by `u`, then it is treated as a _RawInputCharacter_ and remains part of the escaped Unicode stream.

If an eligible `\` is followed by `u`, or more than one `u`, and the last `u` is not followed by four hexadecimal digits, then a compile-time error occurs.

The character produced by a Unicode escape does not participate in further Unicode escapes.

For example, the raw input `\u005cu005a` results in the six characters `\ u 0 0 5 a`, because `005c` is the Unicode value for `\`. It does not result in the character Z, which is Unicode character `005a`, because the `\` that resulted from the `\u005c` is not interpreted as the start of a further Unicode escape.

The Java programming language specifies a standard way of transforming a program written in Unicode into ASCII that changes a program into a form that can be processed by ASCII-based tools. The transformation involves converting any Unicode escapes in the source text of the program to ASCII by adding an extra `u` - for example, `\u_xxxx_` becomes `\uu_xxxx_` - while simultaneously converting non-ASCII characters in the source text to Unicode escapes containing a single `u` each.

This transformed version is equally acceptable to a Java compiler and represents the exact same program. The exact Unicode source can later be restored from this ASCII form by converting each escape sequence where multiple `u`'s are present to a sequence of Unicode characters with one fewer `u`, while simultaneously converting each escape sequence with a single `u` to the corresponding single Unicode character.

A Java compiler should use the `\u_xxxx_` notation as an output format to display Unicode characters when a suitable font is not available.

3.4. Line Terminators
---------------------

A Java compiler next divides the sequence of Unicode input characters into lines by recognizing _line terminators_.

    LineTerminator:

    the ASCII LF character, also known as "newline"  
    the ASCII CR character, also known as "return"  
    the ASCII CR character followed by the ASCII LF character

    InputCharacter:

    [UnicodeInputCharacter](jls-3.html#jls-UnicodeInputCharacter "UnicodeInputCharacter") but not CR or LF

Lines are terminated by the ASCII characters CR, or LF, or CR LF. The two characters CR immediately followed by LF are counted as one line terminator, not two.

A line terminator specifies the termination of the `//` form of a comment ([¬ß3.7](jls-3.html#jls-3.7 "3.7. Comments")).

The lines defined by line terminators may determine the line numbers produced by a Java compiler.

The result is a sequence of line terminators and input characters, which are the terminal symbols for the third step in the tokenization process.

3.5. Input Elements and Tokens
------------------------------

The input characters and line terminators that result from escape processing ([¬ß3.3](jls-3.html#jls-3.3 "3.3. Unicode Escapes")) and then input line recognition ([¬ß3.4](jls-3.html#jls-3.4 "3.4. Line Terminators")) are reduced to a sequence of _input elements_.

    Input:

    {[InputElement](jls-3.html#jls-InputElement "InputElement")} \[[Sub](jls-3.html#jls-Sub "Sub")\]

    InputElement:

    [WhiteSpace](jls-3.html#jls-WhiteSpace "WhiteSpace")  
    [Comment](jls-3.html#jls-Comment "Comment")  
    [Token](jls-3.html#jls-Token "Token")

    Token:

    [Identifier](jls-3.html#jls-Identifier "Identifier")  
    [Keyword](jls-3.html#jls-Keyword "Keyword")  
    [Literal](jls-3.html#jls-Literal "Literal")  
    [Separator](jls-3.html#jls-Separator "Separator")  
    [Operator](jls-3.html#jls-Operator "Operator")

Sub:

the ASCII SUB character, also known as "control-Z"

Those input elements that are not white space or comments are _tokens_. The tokens are the terminal symbols of the syntactic grammar ([¬ß2.3](jls-2.html#jls-2.3 "2.3. The Syntactic Grammar")).

White space ([¬ß3.6](jls-3.html#jls-3.6 "3.6. White Space")) and comments ([¬ß3.7](jls-3.html#jls-3.7 "3.7. Comments")) can serve to separate tokens that, if adjacent, might be tokenized in another manner. For example, the ASCII characters `-` and `=` in the input can form the operator token `-=` ([¬ß3.12](jls-3.html#jls-3.12 "3.12. Operators")) only if there is no intervening white space or comment.

As a special concession for compatibility with certain operating systems, the ASCII SUB character (`\u001a`, or control-Z) is ignored if it is the last character in the escaped input stream.

Consider two tokens `_x_` and `_y_` in the resulting input stream. If `_x_` precedes `_y_`, then we say that `_x_` is _to the left of_ `_y_` and that `_y_` is _to the right of_ `_x_`.

For example, in this simple piece of code:

    class Empty {
    }

we say that the `}` token is to the right of the `{` token, even though it appears, in this two-dimensional representation, downward and to the left of the `{` token. This convention about the use of the words left and right allows us to speak, for example, of the right-hand operand of a binary operator or of the left-hand side of an assignment.

3.6. White Space
----------------

White space is defined as the ASCII space character, horizontal tab character, form feed character, and line terminator characters ([¬ß3.4](jls-3.html#jls-3.4 "3.4. Line Terminators")).

    WhiteSpace:

    the ASCII SP character, also known as "space"  
    the ASCII HT character, also known as "horizontal tab"  
    the ASCII FF character, also known as "form feed"  
    [LineTerminator](jls-3.html#jls-LineTerminator "LineTerminator")

3.7. Comments
-------------

There are two kinds of comments:

*   `/``*` _text_ `*``/`
    
A _traditional comment_: all the text from the ASCII characters `/``*` to the ASCII characters `*``/` is ignored (as in C and C++).
*   `/``/` _text_
    
An _end-of-line comment_: all the text from the ASCII characters `/``/` to the end of the line is ignored (as in C++).
    

    Comment:

    [TraditionalComment](jls-3.html#jls-TraditionalComment "TraditionalComment")  
    [EndOfLineComment](jls-3.html#jls-EndOfLineComment "EndOfLineComment")

    TraditionalComment:

    `/` `*` [CommentTail](jls-3.html#jls-CommentTail "CommentTail")

    CommentTail:

    `*` [CommentTailStar](jls-3.html#jls-CommentTailStar "CommentTailStar")  
    [NotStar](jls-3.html#jls-NotStar "NotStar") [CommentTail](jls-3.html#jls-CommentTail "CommentTail")

    CommentTailStar:

    `/`  
    `*` [CommentTailStar](jls-3.html#jls-CommentTailStar "CommentTailStar")  
    [NotStarNotSlash](jls-3.html#jls-NotStarNotSlash "NotStarNotSlash") [CommentTail](jls-3.html#jls-CommentTail "CommentTail")

    NotStar:

    [InputCharacter](jls-3.html#jls-InputCharacter "InputCharacter") but not `*`  
    [LineTerminator](jls-3.html#jls-LineTerminator "LineTerminator")

    NotStarNotSlash:

    [InputCharacter](jls-3.html#jls-InputCharacter "InputCharacter") but not `*` or `/`  
    [LineTerminator](jls-3.html#jls-LineTerminator "LineTerminator")

    EndOfLineComment:

    `/` `/` {[InputCharacter](jls-3.html#jls-InputCharacter "InputCharacter")}

These productions imply all of the following properties:

*   Comments do not nest.
*   `/``*` and `*``/` have no special meaning in comments that begin with `/``/`.
*   `/``/` has no special meaning in comments that begin with `/``*` or `/``*``*`.

As a result, the following text is a single complete comment:

/\* this comment /\* // /\*\* ends here: \*/

The lexical grammar implies that comments do not occur within character literals ([¬ß3.10.4](jls-3.html#jls-3.10.4 "3.10.4. Character Literals")) or string literals ([¬ß3.10.5](jls-3.html#jls-3.10.5 "3.10.5. String Literals")).

3.8. Identifiers
----------------

An _identifier_ is an unlimited-length sequence of _Java letters_ and _Java digits_, the first of which must be a _Java letter_.

    Identifier:

    [IdentifierChars](jls-3.html#jls-IdentifierChars "IdentifierChars") but not a [Keyword](jls-3.html#jls-Keyword "Keyword") or [BooleanLiteral](jls-3.html#jls-BooleanLiteral "BooleanLiteral") or [NullLiteral](jls-3.html#jls-NullLiteral "NullLiteral")

    IdentifierChars:

    [JavaLetter](jls-3.html#jls-JavaLetter "JavaLetter") {[JavaLetterOrDigit](jls-3.html#jls-JavaLetterOrDigit "JavaLetterOrDigit")}

    JavaLetter:

    any Unicode character that is a "Java letter"

    JavaLetterOrDigit:

    any Unicode character that is a "Java letter-or-digit"

A "Java letter" is a character for which the method `Character.isJavaIdentifierStart(int)` returns true.

A "Java letter-or-digit" is a character for which the method `Character.isJavaIdentifierPart(int)` returns true.

The "Java letters" include uppercase and lowercase ASCII Latin letters `A-Z` (`\u0041-\u005a`), and `a-z` (`\u0061-\u007a`), and, for historical reasons, the ASCII underscore (`_`, or `\u005f`) and dollar sign (`$`, or `\u0024`). The `$` sign should be used only in mechanically generated source code or, rarely, to access pre-existing names on legacy systems.

The "Java digits" include the ASCII digits `0-9` (`\u0030-\u0039`).

Letters and digits may be drawn from the entire Unicode character set, which supports most writing scripts in use in the world today, including the large sets for Chinese, Japanese, and Korean. This allows programmers to use identifiers in their programs that are written in their native languages.

An identifier cannot have the same spelling (Unicode character sequence) as a keyword ([¬ß3.9](jls-3.html#jls-3.9 "3.9. Keywords")), boolean literal ([¬ß3.10.3](jls-3.html#jls-3.10.3 "3.10.3. Boolean Literals")), or the null literal ([¬ß3.10.7](jls-3.html#jls-3.10.7 "3.10.7. The Null Literal")), or a compile-time error occurs.

Two identifiers are the same only if they are identical, that is, have the same Unicode character for each letter or digit. Identifiers that have the same external appearance may yet be different.

For example, the identifiers consisting of the single letters LATIN CAPITAL LETTER A (`A`, `\u0041`), LATIN SMALL LETTER A (`a`, `\u0061`), GREEK CAPITAL LETTER ALPHA (`A`, `\u0391`), CYRILLIC SMALL LETTER A (`a`, `\u0430`) and MATHEMATICAL BOLD ITALIC SMALL A (`a`, `\ud835\udc82`) are all different.

Unicode composite characters are different from their canonical equivalent decomposed characters. For example, a LATIN CAPITAL LETTER A ACUTE (`√Å`, `\u00c1`) is different from a LATIN CAPITAL LETTER A (`A`, `\u0041`) immediately followed by a NON-SPACING ACUTE (`¬¥`, `\u0301`) in identifiers. See The Unicode Standard, Section 3.11 "Normalization Forms".

Examples of identifiers are:

*   `String`
*   `i3`
*   Œ±œÅŒµœÑŒ∑
*   `MAX_VALUE`
*   `isLetterOrDigit`

3.9. Keywords
-------------

50 character sequences, formed from ASCII letters, are reserved for use as keywords and cannot be used as identifiers ([¬ß3.8](jls-3.html#jls-3.8 "3.8. Identifiers")).

    Keyword:

    (one of)  

        abstract   continue   for          new         switch
        assert     default    if           package     synchronized
        boolean    do         goto         private     this
        break      double     implements   protected   throw
        byte       else       import       public      throws
        case       enum       instanceof   return      transient
        catch      extends    int          short       try
        char       final      interface    static      void
        class      finally    long         strictfp    volatile
        const      float      native       super       while

The keywords `const` and `goto` are reserved, even though they are not currently used. This may allow a Java compiler to produce better error messages if these C++ keywords incorrectly appear in programs.

While `true` and `false` might appear to be keywords, they are technically boolean literals ([¬ß3.10.3](jls-3.html#jls-3.10.3 "3.10.3. Boolean Literals")). Similarly, while `null` might appear to be a keyword, it is technically the null literal ([¬ß3.10.7](jls-3.html#jls-3.10.7 "3.10.7. The Null Literal")).

3.10. Literals
--------------

A _literal_ is the source code representation of a value of a primitive type ([¬ß4.2](jls-4.html#jls-4.2 "4.2. Primitive Types and Values")), the `String` type ([¬ß4.3.3](jls-4.html#jls-4.3.3 "4.3.3. The Class String")), or the null type ([¬ß4.1](jls-4.html#jls-4.1 "4.1. The Kinds of Types and Values")).

    Literal:

    [IntegerLiteral](jls-3.html#jls-IntegerLiteral "IntegerLiteral")  
    [FloatingPointLiteral](jls-3.html#jls-FloatingPointLiteral "FloatingPointLiteral")  
    [BooleanLiteral](jls-3.html#jls-BooleanLiteral "BooleanLiteral")  
    [CharacterLiteral](jls-3.html#jls-CharacterLiteral "CharacterLiteral")  
    [StringLiteral](jls-3.html#jls-StringLiteral "StringLiteral")  
    [NullLiteral](jls-3.html#jls-NullLiteral "NullLiteral")

### 3.10.1. Integer Literals

An _integer literal_ may be expressed in decimal (base 10), hexadecimal (base 16), octal (base 8), or binary (base 2).

    IntegerLiteral:

    [DecimalIntegerLiteral](jls-3.html#jls-DecimalIntegerLiteral "DecimalIntegerLiteral")  
    [HexIntegerLiteral](jls-3.html#jls-HexIntegerLiteral "HexIntegerLiteral")  
    [OctalIntegerLiteral](jls-3.html#jls-OctalIntegerLiteral "OctalIntegerLiteral")  
    [BinaryIntegerLiteral](jls-3.html#jls-BinaryIntegerLiteral "BinaryIntegerLiteral")

    DecimalIntegerLiteral:

    [DecimalNumeral](jls-3.html#jls-DecimalNumeral "DecimalNumeral") \[[IntegerTypeSuffix](jls-3.html#jls-IntegerTypeSuffix "IntegerTypeSuffix")\]

    HexIntegerLiteral:

    [HexNumeral](jls-3.html#jls-HexNumeral "HexNumeral") \[[IntegerTypeSuffix](jls-3.html#jls-IntegerTypeSuffix "IntegerTypeSuffix")\]

    OctalIntegerLiteral:

    [OctalNumeral](jls-3.html#jls-OctalNumeral "OctalNumeral") \[[IntegerTypeSuffix](jls-3.html#jls-IntegerTypeSuffix "IntegerTypeSuffix")\]

    BinaryIntegerLiteral:

    [BinaryNumeral](jls-3.html#jls-BinaryNumeral "BinaryNumeral") \[[IntegerTypeSuffix](jls-3.html#jls-IntegerTypeSuffix "IntegerTypeSuffix")\]

    IntegerTypeSuffix:

    (one of)  
    `l` `L`

An integer literal is of type `long` if it is suffixed with an ASCII letter `L` or `l` (ell); otherwise it is of type `int` ([¬ß4.2.1](jls-4.html#jls-4.2.1 "4.2.1. Integral Types and Values")).

The suffixeral">L is preferred, because the letter `l` (ell) is often hard to distinguish from the digit `1` (one).

Underscores are allowed as separators between digits that denote the integer.

In a hexadecimal or binary literal, the integer is only denoted by the digits after the `0x` or `0b` characters and before any type suffix. Therefore, underscores may not appear immediately after `0x` or `0b`, or after the last digit in the numeral.

In a decimal or octal literal, the integer is denoted by _all_ the digits in the literal before any type suffix. Therefore, underscores may not appear before the first digit or after the last digit in the numeral. Underscores may appear after the initial `0` in an octal numeral (since `0` is a digit that denotes part of the integer) and after the initial non-zero digit in a non-zero decimal literal.

A decimal numeral is either the single ASCII digit `0`, representing the integer zero, or consists of an ASCII digit from `1` to `9` optionally followed by one or more ASCII digits from `0` to `9` interspersed with underscores, representing a positive integer.

    DecimalNumeral:

    `0`  
    [NonZeroDigit](jls-3.html#jls-NonZeroDigit "NonZeroDigit") \[[Digits](jls-3.html#jls-Digits "Digits")\]  
    [NonZeroDigit](jls-3.html#jls-NonZeroDigit "NonZeroDigit") [Underscores](jls-3.html#jls-Underscores "Underscores") [Digits](jls-3.html#jls-Digits "Digits")

    NonZeroDigit:

    (one of)  
    `1 2 3 4 5 6 7 8 9`

    Digits:

    [Digit](jls-3.html#jls-Digit "Digit")  
    [Digit](jls-3.html#jls-Digit "Digit") \[[DigitsAndUnderscores](jls-3.html#jls-DigitsAndUnderscores "DigitsAndUnderscores")\] [Digit](jls-3.html#jls-Digit "Digit")

    Digit:

    `0`  
    [NonZeroDigit](jls-3.html#jls-NonZeroDigit "NonZeroDigit")

    DigitsAndUnderscores:

    [DigitOrUnderscore](jls-3.html#jls-DigitOrUnderscore "DigitOrUnderscore") {[DigitOrUnderscore](jls-3.html#jls-DigitOrUnderscore "DigitOrUnderscore")}

    DigitOrUnderscore:

    [Digit](jls-3.html#jls-Digit "Digit")  
    `_`

    Underscores:

    `_` {`_`}

A hexadecimal numeral consists of the leading ASCII characters `0x` or `0X` followed by one or more ASCII hexadecimal digits interspersed with underscores, and can represent a positive, zero, or negative integer.

Hexadecimal digits with values 10 through 15 are represented by the ASCII letters `a` through `f` or `A` through `F`, respectively; each letter used as a hexadecimal digit may be uppercase or lowercase.

    HexNumeral:

    `0` `x` [HexDigits](jls-3.html#jls-HexDigits "HexDigits")  
    `0` `X` [HexDigits](jls-3.html#jls-HexDigits "HexDigits")

    HexDigits:

    [HexDigit](jls-3.html#jls-HexDigit "HexDigit")  
    [HexDigit](jls-3.html#jls-HexDigit "HexDigit") \[[HexDigitsAndUnderscores](jls-3.html#jls-HexDigitsAndUnderscores "HexDigitsAndUnderscores")\] [HexDigit](jls-3.html#jls-HexDigit "HexDigit")

    HexDigit:

    (one of)  
    `0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F`

    HexDigitsAndUnderscores:

    [HexDigitOrUnderscore](jls-3.html#jls-HexDigitOrUnderscore "HexDigitOrUnderscore") {[HexDigitOrUnderscore](jls-3.html#jls-HexDigitOrUnderscore "HexDigitOrUnderscore")}

    HexDigitOrUnderscore:

    [HexDigit](jls-3.html#jls-HexDigit "HexDigit")  
    `_`

The _HexDigit_ production above comes from [¬ß3.3](jls-3.html#jls-3.3 "3.3. Unicode Escapes").

An octal numeral consists of an ASCII digit `0` followed by one or more of the ASCII digits `0` through `7` interspersed with underscores, and can represent a positive, zero, or negative integer.

    OctalNumeral:

    `0` [OctalDigits](jls-3.html#jls-OctalDigits "OctalDigits")  
    `0` [Underscores](jls-3.html#jls-Underscores "Underscores") [OctalDigits](jls-3.html#jls-OctalDigits "OctalDigits")

    OctalDigits:

    [OctalDigit](jls-3.html#jls-OctalDigit "OctalDigit")  
    [OctalDigit](jls-3.html#jls-OctalDigit "OctalDigit") \[[OctalDigitsAndUnderscores](jls-3.html#jls-OctalDigitsAndUnderscores "OctalDigitsAndUnderscores")\] [OctalDigit](jls-3.html#jls-OctalDigit "OctalDigit")

    OctalDigit:

    (one of)  
    `0 1 2 3 4 5 6 7`

    OctalDigitsAndUnderscores:

    [OctalDigitOrUnderscore](jls-3.html#jls-OctalDigitOrUnderscore "OctalDigitOrUnderscore") {[OctalDigitOrUnderscore](jls-3.html#jls-OctalDigitOrUnderscore "OctalDigitOrUnderscore")}

    OctalDigitOrUnderscore:

    [OctalDigit](jls-3.html#jls-OctalDigit "OctalDigit")  
    `_`

Note that octal numerals always consist of two or more digits, as `0` alone is always considered to be a decimal numeral - not that it matters much in practice, for the numerals `0`, `00`, and `0x0` all represent exactly the same integer value.

A binary numeral consists of the leading ASCII characters `0b` or `0B` followed by one or more of the ASCII digits `0` or `1` interspersed with underscores, and can represent a positive, zero, or negative integer.

    BinaryNumeral:

    `0` `b` [BinaryDigits](jls-3.html#jls-BinaryDigits "BinaryDigits")  
    `0` `B` [BinaryDigits](jls-3.html#jls-BinaryDigits "BinaryDigits")

    BinaryDigits:

    [BinaryDigit](jls-3.html#jls-BinaryDigit "BinaryDigit")  
    [BinaryDigit](jls-3.html#jls-BinaryDigit "BinaryDigit") \[[BinaryDigitsAndUnderscores](jls-3.html#jls-BinaryDigitsAndUnderscores "BinaryDigitsAndUnderscores")\] [BinaryDigit](jls-3.html#jls-BinaryDigit "BinaryDigit")

    BinaryDigit:

    (one of)  
    `0` `1`

    BinaryDigitsAndUnderscores:

    [BinaryDigitOrUnderscore](jls-3.html#jls-BinaryDigitOrUnderscore "BinaryDigitOrUnderscore") {[BinaryDigitOrUnderscore](jls-3.html#jls-BinaryDigitOrUnderscore "BinaryDigitOrUnderscore")}

    BinaryDigitOrUnderscore:

    [BinaryDigit](jls-3.html#jls-BinaryDigit "BinaryDigit")  
    `_`

The largest decimal literal of type `int` is `2147483648` (231).

All decimal literals from `0` to `2147483647` may appear anywhere an `int` literal may appear. The decimal literal `2147483648` may appear only as the operand of the unary minus operator `-` ([¬ß15.15.4](jls-15.html#jls-15.15.4 "15.15.4. Unary Minus Operator -")).

It is a compile-time error if the decimal literal `2147483648` appears anywhere other than as the operand of the unary minus operator; or if a decimal literal of type `int` is larger than `2147483648` (231).

The largest positive hexadecimal, octal, and binary literals of type `int` - each of which represents the decimal value `2147483647` (231\-1) - are respectively:

*   `0x7fff_ffff`,
*   `0177_7777_7777`, and
*   `0b0111_1111_1111_1111_1111_1111_1111_1111`

The most negative hexadecimal, octal, and binary literals of type `int` - each of which represents the decimal value `-2147483648` (-231) - are respectively:

*   `0x8000_0000`,
*   `0200_0000_0000`, and
*   `0b1000_0000_0000_0000_0000_0000_0000_0000`

The following hexadecimal, octal, and binary literals represent the decimal value `-1`:

*   `0xffff_ffff`,
*   `0377_7777_7777`, and
*   `0b1111_1111_1111_1111_1111_1111_1111_1111`

It is a compile-time error if a hexadecimal, octal, or binary `int` literal does not fit in 32 bits.

The largest decimal literal of type `long` is `9223372036854775808L` (263).

All decimal literals from `0L` to `9223372036854775807L` may appear anywhere a `long` literal may appear. The decimal literal `9223372036854775808L` may appear only as the operand of the unary minus operator `-` ([¬ß15.15.4](jls-15.html#jls-15.15.4 "15.15.4. Unary Minus Operator -")).

It is a compile-time error if the decimal literal `9223372036854775808L` appears anywhere other than as the operand of the unary minus operator; or if a decimal literal of type `long` is larger than `9223372036854775808L` (263).

The largest positive hexadecimal, octal, and binary literals of type `long` - each of which represents the decimal value `9223372036854775807L` (263\-1) - are respectively:

*   `0x7fff_ffff_ffff_ffffL`,
*   `07_7777_7777_7777_7777_7777L`, and
*   `0b0111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111L`

The most negative hexadecimal, octal, and binary literals of type `long` - each of which represents the decimal value `-9223372036854775808L` (-263) - are respectively:

*   `0x8000_0000_0000_0000L`, and
*   `010_0000_0000_0000_0000_0000L`, and
*   `0b1000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000L`

The following hexadecimal, octal, and binary literals represent the decimal value `-1L`:

*   `0xffff_ffff_ffff_ffffL`,
*   `017_7777_7777_7777_7777_7777L`, and
*   `0b1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111L`

It is a compile-time error if a hexadecimal, octal, or binary `long` literal does not fit in 64 bits.

Examples of `int` literals:

    0    2    0372    0xDada\_Cafe    1996    0x00\_FF\_\_00\_FF

Examples of `long` literals:

    0l    0777L    0x100000000L    2\_147\_483\_648L    0xC0B0L

### 3.10.2. Floating-Point Literals

A _floating-point literal_ has the following parts: a whole-number part, a decimal or hexadecimal point (represented by an ASCII period character), a fraction part, an exponent, and a type suffix.

A floating-point literal may be expressed in decimal (base 10) or hexadecimal (base 16).

For decimal floating-point literals, at least one digit (in either the whole number or the fraction part) and either a decimal point, an exponent, or a float type suffix are required. All other parts are optional. The exponent, if present, is indicated by the ASCII letter `e` or `E` followed by an optionally signed integer.

For hexadecimal floating-point literals, at least one digit is required (in either the whole number or the fraction part), and the exponent is mandatory, and the float type suffix is optional. The exponent is indicated by the ASCII letter `p` or `P` followed by an optionally signed integer.

Underscores are allowed as separators between digits that denote the whole-number part, and between digits that denote the fraction part, and between digits that denote the exponent.

    FloatingPointLiteral:

    [DecimalFloatingPointLiteral](jls-3.html#jls-DecimalFloatingPointLiteral "DecimalFloatingPointLiteral")  
    [HexadecimalFloatingPointLiteral](jls-3.html#jls-HexadecimalFloatingPointLiteral "HexadecimalFloatingPointLiteral")

    DecimalFloatingPointLiteral:

    [Digits](jls-3.html#jls-Digits "Digits") `.` \[[Digits](jls-3.html#jls-Digits "Digits")\] \[[ExponentPart](jls-3.html#jls-ExponentPart "ExponentPart")\] \[[FloatTypeSuffix](jls-3.html#jls-FloatTypeSuffix "FloatTypeSuffix")\]  
    `.` [Digits](jls-3.html#jls-Digits "Digits") \[[ExponentPart](jls-3.html#jls-ExponentPart "ExponentPart")\] \[[FloatTypeSuffix](jls-3.html#jls-FloatTypeSuffix "FloatTypeSuffix")\]  
    [Digits](jls-3.html#jls-Digits "Digits") [ExponentPart](jls-3.html#jls-ExponentPart "ExponentPart") \[[FloatTypeSuffix](jls-3.html#jls-FloatTypeSuffix "FloatTypeSuffix")\]  
    [Digits](jls-3.html#jls-Digits "Digits") \[[ExponentPart](jls-3.html#jls-ExponentPart "ExponentPart")\] [FloatTypeSuffix](jls-3.html#jls-FloatTypeSuffix "FloatTypeSuffix")

    ExponentPart:

    [ExponentIndicator](jls-3.html#jls-ExponentIndicator "ExponentIndicator") [SignedInteger](jls-3.html#jls-SignedInteger "SignedInteger")

    ExponentIndicator:

    (one of)  
    `e E`

    SignedInteger:

    \[[Sign](jls-3.html#jls-Sign "Sign")\] [Digits](jls-3.html#jls-Digits "Digits")

    Sign:

    (one of)  
    `+ -`

    FloatTypeSuffix:

    (one of)  
    `f F d D`

    HexadecimalFloatingPointLiteral:

    [HexSignificand](jls-3.html#jls-HexSignificand "HexSignificand") [BinaryExponent](jls-3.html#jls-BinaryExponent "BinaryExponent") \[[FloatTypeSuffix](jls-3.html#jls-FloatTypeSuffix "FloatTypeSuffix")\]

    HexSignificand:

    [HexNumeral](jls-3.html#jls-HexNumeral "HexNumeral") \[`.`\]  
    `0` `x` \[[HexDigits](jls-3.html#jls-HexDigits "HexDigits")\] `.` [HexDigits](jls-3.html#jls-HexDigits "HexDigits")  
    `0` `X` \[[HexDigits](jls-3.html#jls-HexDigits "HexDigits")\] `.` [HexDigits](jls-3.html#jls-HexDigits "HexDigits")

    BinaryExponent:

    [BinaryExponentIndicator](jls-3.html#jls-BinaryExponentIndicator "BinaryExponentIndicator") [SignedInteger](jls-3.html#jls-SignedInteger "SignedInteger")

    BinaryExponentIndicator:

    (one of)  
    `p P`

A floating-point literal is of type `float` if it is suffixed with an ASCII letter `F` or `f`; otherwise its type is `double` and it can optionally be suffixed with an ASCII letter `D` or `d` ([¬ß4.2.3](jls-4.html#jls-4.2.3 "4.2.3. Floating-Point Types, Formats, and Values")).

The elements of the types `float` and `double` are those values that can be represented using the IEEE 754 32-bit single-precision and 64-bit double-precision binary floating-point formats, respectively.

The details of proper input conversion from a Unicode string representation of a floating-point number to the internal IEEE 754 binary floating-point representation are described for the methods `valueOf` of class `Float` and class `Double` of the package `java.lang`.

1. The largest positive finite literal of type `float` is `3.4028235e38f`.
2. The smallest positive finite non-zero literal of type `float` is `1.40e-45f`.
3. The largest positive finite literal of type `double` is `1.7976931348623157e308`.
4. The smallest positive finite non-zero literal of type `double` is `4.9e-324`.

It is a compile-time error if a non-zero floating-point literal is too large, so that on rounded conversion to its internal representation, it becomes an IEEE 754 infinity.

A program can represent infinities without producing a compile-time error by using constant expressions such as `1f/0f` or `-1d/0d` or by using the predefined constants `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` of the classes `Float` and `Double`.

It is a compile-time error if a non-zero floating-point literal is too small, so that, on rounded conversion to its internal representation, it becomes a zero.

A compile-time error does not occur if a non-zero floating-point literal has a small value that, on rounded conversion to its internal representation, becomes a non-zero denormalized number.

Predefined constants representing Not-a-Number values are defined in the classes `Float` and `Double` as `Float.NaN` and `Double.NaN`.

Examples of `float` literals:
5.  1e1f    2.f    .3f    0f    3.14f    6.022137e+23f
6. Examples of `double` literals:

    1e1    2.    .3    0.0    3.14    1e-9d    1e137

### 3.10.3. Boolean Literals

The `boolean` type has two values, represented by the _boolean literals_ `true` and `false`, formed from ASCII letters.

    BooleanLiteral:

    (one of)  
    `true` `false`

A boolean literal is always of type `boolean` ([¬ß4.2.5](jls-4.html#jls-4.2.5 "4.2.5. The boolean Type and boolean Values")).

### 3.10.4. Character Literals

A _character literal_ is expressed as a character or an escape sequence ([¬ß3.10.6](jls-3.html#jls-3.10.6 "3.10.6. Escape Sequences for Character and String Literals")), enclosed in ASCII single quotes. (The single-quote, or apostrophe, character is `\u0027`.)

    CharacterLiteral:

    `'` [SingleCharacter](jls-3.html#jls-SingleCharacter "SingleCharacter") `'`  
    `'` [EscapeSequence](jls-3.html#jls-EscapeSequence "EscapeSequence") `'`

    SingleCharacter:

    [InputCharacter](jls-3.html#jls-InputCharacter "InputCharacter") but not `'` or `\`

See [¬ß3.10.6](jls-3.html#jls-3.10.6 "3.10.6. Escape Sequences for Character and String Literals") for the definition of _EscapeSequence_.

Character literals can only represent UTF-16 code units ([¬ß3.1](jls-3.html#jls-3.1 "3.1. Unicode")), i.e., they are limited to values from `\u0000` to `\uffff`. Supplementary characters must be represented either as a surrogate pair within a `char` sequence, or as an integer, depending on the API they are used with.

A character literal is always of type `char` ([¬ß4.2.1](jls-4.html#jls-4.2.1 "4.2.1. Integral Types and Values")).

It is a compile-time error for the character following the _SingleCharacter_ or _EscapeSequence_ to be other than a `'`.

It is a compile-time error for a line terminator ([¬ß3.4](jls-3.html#jls-3.4 "3.4. Line Terminators")) to appear after the opening `'` and before the closing `'`.

As specified in [¬ß3.4](jls-3.html#jls-3.4 "3.4. Line Terminators"), the characters CR and LF are never an _InputCharacter_; each is recognized as constituting a _LineTerminator_.

The following are examples of `char` literals:

*   `'a'`
*   `'%'`
*   `'\t'`
*   `'\\'`
*   `'\''`
*   `'\u03a9'`
*   `'\uFFFF'`
*   `'\177'`
*   `'‚Ñ¢'`

Because Unicode escapes are processed very early, it is not correct to write `'\u000a'` for a character literal whose value is linefeed (LF); the Unicode escape `\u000a` is transformed into an actual linefeed in translation step 1 ([¬ß3.3](jls-3.html#jls-3.3 "3.3. Unicode Escapes")) and the linefeed becomes a _LineTerminator_ in step 2 ([¬ß3.4](jls-3.html#jls-3.4 "3.4. Line Terminators")), and so the character literal is not valid in step 3. Instead, one should use the escape sequence `'\n'` ([¬ß3.10.6](jls-3.html#jls-3.10.6 "3.10.6. Escape Sequences for Character and String Literals")). Similarly, it is not correct to write `'\u000d'` for a character literal whose value is carriage return (CR). Instead, use `'\r'`.

In C and C++, a character literal may contain representations of more than one character, but the value of such a character literal is implementation-defined. In the Java programming language, a character literal always represents exactly one character.

### 3.10.5. String Literals

A _string literal_ consists of zero or more characters enclosed in double quotes. Characters may be represented by escape sequences ([¬ß3.10.6](jls-3.html#jls-3.10.6 "3.10.6. Escape Sequences for Character and String Literals")) - one escape sequence for characters in the range U+0000 to U+FFFF, two escape sequences for the UTF-16 surrogate code units of characters in the range U+010000 to U+10FFFF.

    StringLiteral:

    `"` {[StringCharacter](jls-3.html#jls-StringCharacter "StringCharacter")} `"`

    StringCharacter:

    [InputCharacter](jls-3.html#jls-InputCharacter "InputCharacter") but not `"` or `\`  
    [EscapeSequence](jls-3.html#jls-EscapeSequence "EscapeSequence")

See [¬ß3.10.6](jls-3.html#jls-3.10.6 "3.10.6. Escape Sequences for Character and String Literals") for the definition of _EscapeSequence_.

A string literal is always of type `String` ([¬ß4.3.3](jls-4.html#jls-4.3.3 "4.3.3. The Class String")).

It is a compile-time error for a line terminator to appear after the opening `"` and before the closing matching `"`.

As specified in [¬ß3.4](jls-3.html#jls-3.4 "3.4. Line Terminators"), the characters CR and LF are never an _InputCharacter_; each is recognized as constituting a _LineTerminator_.

A long string literal can always be broken up into shorter pieces and written as a (possibly parenthesized) expression using the string concatenation operator `+` ([¬ß15.18.1](jls-15.html#jls-15.18.1 "15.18.1. String Concatenation Operator +")).

The following are examples of string literals:

    ""                    // the empty string
    "\\""                  // a string containing " alone
    "This is a string"    // a string containing 16 characters
    "This is a " +        // actually a string-valued constant expression,
        "two-line string"    // formed from two string literals

Because Unicode escapes are processed very early, it is not correct to write `"\u000a"` for a string literal containing a single linefeed (LF); the Unicode escape `\u000a` is transformed into an actual linefeed in translation step 1 ([¬ß3.3](jls-3.html#jls-3.3 "3.3. Unicode Escapes")) and the linefeed becomes a _LineTerminator_ in step 2 ([¬ß3.4](jls-3.html#jls-3.4 "3.4. Line Terminators")), and so the string literal is not valid in step 3. Instead, one should write `"\n"` ([¬ß3.10.6](jls-3.html#jls-3.10.6 "3.10.6. Escape Sequences for Character and String Literals")). Similarly, it is not correct to write `"\u000d"` for a string literal containing a single carriage return (CR). Instead, use `"\r"`. Finally, it is not possible to write `"\u0022"` for a string literal containing a double quotation mark (`"`).

A string literal is a reference to an instance of class `String` ([¬ß4.3.1](jls-4.html#jls-4.3.1 "4.3.1. Objects"), [¬ß4.3.3](jls-4.html#jls-4.3.3 "4.3.3. The Class String")).

Moreover, a string literal always refers to the _same_ instance of class `String`. This is because string literals - or, more generally, strings that are the values of constant expressions ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")) - are "interned" so as to share unique instances, using the method `String.intern`.

**Example 3.10.5-1. String Literals**

The program consisting of the compilation unit ([¬ß7.3](jls-7.html#jls-7.3 "7.3. Compilation Units")):

    package testPackage;
    class Test {
        public static void main(String\[\] args) {
            String hello = "Hello", lo = "lo";
            System.out.print((hello == "Hello") + " ");
            System.out.print((Other.hello == hello) + " ");
            System.out.print((other.Other.hello == hello) + " ");
            System.out.print((hello == ("Hel"+"lo")) + " ");
            System.out.print((hello == ("Hel"+lo)) + " ");
            System.out.println(hello == ("Hel"+lo).intern());
        }
    }
    class Other { static String hello = "Hello"; }

and the compilation unit:

    package other;
    public class Other { public static String hello = "Hello"; }

produces the output:

    true true true true false true

This example illustrates six points:

*   Literal strings within the same class ([¬ß8 (_Classes_)](jls-8.html "Chapter 8. Classes")) in the same package ([¬ß7 (_Packages_)](jls-7.html "Chapter 7. Packages")) represent references to the same `String` object ([¬ß4.3.1](jls-4.html#jls-4.3.1 "4.3.1. Objects")).
*   Literal strings within different classes in the same package represent references to the same `String` object.
*   Literal strings within different classes in different packages likewise represent references to the same `String` object.
*   Strings computed by constant expressions ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")) are computed at compile time and then treated as if they were literals.
*   Strings computed by concatenation at run timeare newly created and therefore distinct.

*   The result of explicitly interning a computed string is the same string as any pre-existing literal string with the same contents.
    
  

### 3.10.6. Escape Sequences for Character and String Literals

The character and string _escape sequences_ allow for the representation of some nongraphic characters without using Unicode escapes, as well as the single quote, double quote, and backslash characters, in character literals ([¬ß3.10.4](jls-3.html#jls-3.10.4 "3.10.4. Character Literals")) and string literals ([¬ß3.10.5](jls-3.html#jls-3.10.5 "3.10.5. String Literals")).

    EscapeSequence:

    `\ b` (backspace BS, Unicode `\u0008`)  
    `\ t` (horizontal tab HT, Unicode `\u0009`)  
    `\ n` (linefeed LF, Unicode `\u000a`)  
    `\ f` (form feed FF, Unicode `\u000c`)  
    `\ r` (carriage return CR, Unicode `\u000d`)  
    `\ "` (double quote `"`, Unicode `\u0022`)  
    `\ '` (single quote `'`, Unicode `\u0027`)  
    `\ \` (backslash `\`, Unicode `\u005c`)  
    [OctalEscape](jls-3.html#jls-OctalEscape "OctalEscape") (octal value, Unicode `\u0000` to `\u00ff`)

    OctalEscape:

    `\` [OctalDigit](jls-3.html#jls-OctalDigit "OctalDigit")  
    `\` [OctalDigit](jls-3.html#jls-OctalDigit "OctalDigit") [OctalDigit](jls-3.html#jls-OctalDigit "OctalDigit")  
    `\` [ZeroToThree](jls-3.html#jls-ZeroToThree "ZeroToThree") [OctalDigit](jls-3.html#jls-OctalDigit "OctalDigit") [OctalDigit](jls-3.html#jls-OctalDigit "OctalDigit")  

    OctalDigit:

    (one of)  
    `0 1 2 3 4 5 6 7`

    ZeroToThree:

    (one of)  
    `0 1 2 3`

The _OctalDigit_ production above comes from [¬ß3.10.1](jls-3.html#jls-3.10.1 "3.10.1. Integer Literals").

It is a compile-time error if the character following a backslash in an escape sequence is not an ASCII `b`, `t`, `n`, `f`, `r`, `"`, `'`, `\`, `0`, `1`, `2`, `3`, `4`, `5`, `6`, or `7`. The Unicode escape `\u` is processed earlier ([¬ß3.3](jls-3.html#jls-3.3 "3.3. Unicode Escapes")).

Octal escapes are provided for compatibility with C, but can express only Unicode values `\u0000` through `\u00FF`, so Unicode escapes are usually preferred.

### 3.10.7. The Null Literal

The null type has one value, the null reference, represented by the _null literal_ `null`, which is formed from ASCII characters.

    NullLiteral:

    `null`

A null literal is always of the null type ([¬ß4.1](jls-4.html#jls-4.1 "4.1. The Kinds of Types and Values")).

3.11. Separators
----------------

Twelve tokens, formed from ASCII characters, are the _separators_ (punctuators).

    Separator:

    (one of)  

        (   )   {   }   [   ]   ;   ,   .   ...   @   ::

3.12. Operators
---------------

38 tokens, formed from ASCII characters, are the _operators_.

    Operator:

    (one of)  

        =   >   <   !   ~   ?   :   ->

üçÄ Chapter 4. Types, Values, and Variables
---------------------------------------

**Table of Contents**

[4.1. The Kinds of Types and Values](jls-4.html#jls-4.1)

[4.2. Primitive Types and Values](jls-4.html#jls-4.2)

[4.2.1. Integral Types and Values](jls-4.html#jls-4.2.1)

[4.2.2. Integer Operations](jls-4.html#jls-4.2.2)

[4.2.3. Floating-Point Types, Formats, and Values](jls-4.html#jls-4.2.3)

[4.2.4. Floating-Point Operations](jls-4.html#jls-4.2.4)

[4.2.5. The `boolean` Type and boolean Values](jls-4.html#jls-4.2.5)

[4.3. Reference Types and Values](jls-4.html#jls-4.3)

[4.3.1. Objects](jls-4.html#jls-4.3.1)

[4.3.2. The Class `Object`](jls-4.html#jls-4.3.2)

[4.3.3. The Class `String`](jls-4.html#jls-4.3.3)

[4.3.4. When Reference Types Are the Same](jls-4.html#jls-4.3.4)

[4.4. Type Variables](jls-4.html#jls-4.4)

[4.5. Parameterized Types](jls-4.html#jls-4.5)

[4.5.1. Type Arguments of Parameterized Types](jls-4.html#jls-4.5.1)

[4.5.2. Members and Constructors of Parameterized Types](jls-4.html#jls-4.5.2)

[4.6. Type Erasure](jls-4.html#jls-4.6)

[4.7. Reifiable Types](jls-4.html#jls-4.7)

[4.8. Raw Types](jls-4.html#jls-4.8)

[4.9. Intersection Types](jls-4.html#jls-4.9)

[4.10. Subtyping](jls-4.html#jls-4.10)

[4.10.1. Subtyping among Primitive Types](jls-4.html#jls-4.10.1)

[4.10.2. Subtyping among Class and Interface Types](jls-4.html#jls-4.10.2)

[4.10.3. Subtyping among Array Types](jls-4.html#jls-4.10.3)

[4.10.4. Least Upper Bound](jls-4.html#jls-4.10.4)

[4.11. Where Types Are Used](jls-4.html#jls-4.11)

[4.12. Variables](jls-4.html#jls-4.12)

[4.12.1. Variables of Primitive Type](jls-4.html#jls-4.12.1)

[4.12.2. Variables of Reference Type](jls-4.html#jls-4.12.2)

[4.12.3. Kinds of Variables](jls-4.html#jls-4.12.3)

[4.12.4. `final` Variables](jls-4.html#jls-4.12.4)

[4.12.5. Initial Values of Variables](jls-4.html#jls-4.12.5)

[4.12.6. Types, Classes, and Interfaces](jls-4.html#jls-4.12.6)

The Java programming language is a _statically typed_ language, which means that every variable and every expression has a type that is known at compile time.

The Java programming language is also a _strongly typed_ language, because types limit the values that a variable ([¬ß4.12](jls-4.html#jls-4.12 "4.12. Variables")) can hold or that an expression can produce, limit the operations supported on those values, and determine the meaning of the operations. Strong static typing helps detect errors at compile time.

The types of the Java programming language are divided into two categories: primitive types and reference types. The primitive types ([¬ß4.2](jls-4.html#jls-4.2 "4.2. Primitive Types and Values")) are the `boolean` type and the numeric types. The numeric types are the integral types `byte`, `short`, `int`, `long`, and `char`, and the floating-point types `float` and `double`. The reference types ([¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values")) are class types, interface types, and array types. There is also a special null type. An object ([¬ß4.3.1](jls-4.html#jls-4.3.1 "4.3.1. Objects")) is a dynamically created instance of a class type or a dynamically created array. The values of a reference type are references to objects. All objects, including arrays, support the methods of class `Object` ([¬ß4.3.2](jls-4.html#jls-4.3.2 "4.3.2. The Class Object")). String literals are represented by `String` objects ([¬ß4.3.3](jls-4.html#jls-4.3.3 "4.3.3. The Class String")).

4.1. The Kinds of Types and Values
----------------------------------

There are two kinds of types in the Java programming language: primitive types ([¬ß4.2](jls-4.html#jls-4.2 "4.2. Primitive Types and Values")) and reference types ([¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values")). There are, correspondingly, two kinds of data values that can be stored in variables, passed as arguments, returned by methods, and operated on: primitive values ([¬ß4.2](jls-4.html#jls-4.2 "4.2. Primitive Types and Values")) and reference values ([¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values")).

Type:

[PrimitiveType](jls-4.html#jls-PrimitiveType "PrimitiveType")  
[ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType")

There is also a special _null type_, the type of the expression `null` ([¬ß3.10.7](jls-3.html#jls-3.10.7 "3.10.7. The Null Literal"), [¬ß15.8.1](jls-15.html#jls-15.8.1 "15.8.1. Lexical Literals")), which has no name.

Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type.

The null reference is the only possible value of an expression of null type.

The null reference can always be assigned or cast to any reference type ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts"), [¬ß5.3](jls-5.html#jls-5.3 "5.3. Invocation Contexts"), [¬ß5.5](jls-5.html#jls-5.5 "5.5. Casting Contexts")).

In practice, the programmer can ignore the null type and just pretend that `null` is merely a special literal that can be of any reference type.

4.2. Primitive Types and Values
-------------------------------

A primitive type is predefined by the Java programming language and named by its reserved keyword ([¬ß3.9](jls-3.html#jls-3.9 "3.9. Keywords")):

PrimitiveType:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} [NumericType](jls-4.html#jls-NumericType "NumericType")  
{[Annotation](jls-9.html#jls-Annotation "Annotation")} `boolean`

NumericType:

[IntegralType](jls-4.html#jls-IntegralType "IntegralType")  
[FloatingPointType](jls-4.html#jls-FloatingPointType "FloatingPointType")

IntegralType:

(one of)  
`byte` `short` `int` `long` `char`

FloatingPointType:

(one of)  
`float` `double`

Primitive values do not share state with other primitive values.

The _numeric types_ are the integral types and the floating-point types.

The _integral types_ are `byte`, `short`, `int`, and `long`, whose values are 8-bit, 16-bit, 32-bit and 64-bit signed two's-complement integers, respectively, and `char`, whose values are 16-bit unsigned integers representing UTF-16 code units ([¬ß3.1](jls-3.html#jls-3.1 "3.1. Unicode")).

The _floating-point types_ are `float`, whose values include the 32-bit IEEE 754 floating-point numbers, and `double`, whose values include the 64-bit IEEE 754 floating-point numbers.

The `boolean` type has exactly two values: `true` and `false`.

### 4.2.1. Integral Types and Values

The values of the integral types are integers in the following ranges:

*   For `byte`, from -128 to 127, inclusive
*   For `short`, from -32768 to 32767, inclusive
*   For `int`, from -2147483648 to 2147483647, inclusive
*   For `long`, from -9223372036854775808 to 9223372036854775807, inclusive
*   For `char`, from `'\u0000'` to `'\uffff'` inclusive, that is, from 0 to 65535
    

### 4.2.2. Integer Operations

The Java programming language provides a number of operators that act on integral values:

*   The comparison operators, which result in a value of type `boolean`:
    
    *   The numerical comparison operators `<`, `<=`, `>`, and `>=` ([¬ß15.20.1](jls-15.html#jls-15.20.1 "15.20.1. Numerical Comparison Operators <, <=, >, and >="))
        
    *   The numerical equality operators `==` and `!=` ([¬ß15.21.1](jls-15.html#jls-15.21.1 "15.21.1. Numerical Equality Operators == and !="))
        
*   The numerical operators, which result in a value of type `int` or `long`:
    
    *   The unary plus and minus operators `+` and `-` ([¬ß15.15.3](jls-15.html#jls-15.15.3 "15.15.3. Unary Plus Operator +"), [¬ß15.15.4](jls-15.html#jls-15.15.4 "15.15.4. Unary Minus Operator -"))
        
    *   The multiplicative operators `*`, `/`, and `%` ([¬ß15.17](jls-15.html#jls-15.17 "15.17. Multiplicative Operators"))
        
    *   The additive operators `+` and `-` ([¬ß15.18](jls-15.html#jls-15.18 "15.18. Additive Operators"))
        
    *   The increment operator `++`, both prefix ([¬ß15.15.1](jls-15.html#jls-15.15.1 "15.15.1. Prefix Increment Operator ++")) and postfix ([¬ß15.14.2](jls-15.html#jls-15.14.2 "15.14.2. Postfix Increment Operator ++"))
        
    *   The decrement operator `--`, both prefix ([¬ß15.15.2](jls-15.html#jls-15.15.2 "15.15.2. Prefix Decrement Operator --")) and postfix ([¬ß15.14.3](jls-15.html#jls-15.14.3 "15.14.3. Postfix Decrement Operator --"))
        
    *   The signed and unsigned shift operators `<<`, `>>`, and `>>>` ([¬ß15.19](jls-15.html#jls-15.19 "15.19. Shift Operators"))
        
    *   The bitwise complement operator `~` ([¬ß15.15.5](jls-15.html#jls-15.15.5 "15.15.5. Bitwise Complement Operator ~"))
        
    *   The integer bitwise operators `&`, `^`, and `|` ([¬ß15.22.1](jls-15.html#jls-15.22.1 "15.22.1. Integer Bitwise Operators &, ^, and |"))
        
*   The conditional operator `? :` ([¬ß15.25](jls-15.html#jls-15.25 "15.25. Conditional Operator ? :"))
*   The cast operator ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")), which can convert from an integral value to a value of any specified numeric type
*   The string concatenation operator `+` ([¬ß15.18.1](jls-15.html#jls-15.18.1 "15.18.1. String Concatenation Operator +")), which, when given a `String` operand and an integral operand, will convert the integral operand to a `String` representing its value in decimal form, and then produce a newly created `String` that is the concatenation of the two strings
    

Other useful constructors, methods, and constants are predefined in the classes `Byte`, `Short`, `Integer`, `Long`, and `Character`.

If an integer operator other than a shift operator has at least one operand of type `long`, then the operation is carried out using 64-bit precision, and the result of the numerical operator is of type `long`. If the other operand is not `long`, it is first widened ([¬ß5.1.5](jls-5.html#jls-5.1.5 "5.1.5. Widening Reference Conversion")) to type `long` by numeric promotion ([¬ß5.6](jls-5.html#jls-5.6 "5.6. Numeric Contexts")).

Otherwise, the operation is carried out using 32-bit precision, and the result of the numerical operator is of type `int`. If either operand is not an `int`, it is first widened to type `int` by numeric promotion.

Any value of any integral type may be cast to or from any numeric type. There are no casts between integral types and the type `boolean`.

See [¬ß4.2.5](jls-4.html#jls-4.2.5 "4.2.5. The boolean Type and boolean Values") for an idiom to convert integer expressions to `boolean`.

The integer operators do not indicate overflow or underflow in any way.

An integer operator can throw an exception ([¬ß11 (_Exceptions_)](jls-11.html "Chapter 11. Exceptions")) for the following reasons:

*   Any integer operator can throw a `NullPointerException` if unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) of a null reference is required.
*   The integer divide operator `/` ([¬ß15.17.2](jls-15.html#jls-15.17.2 "15.17.2. Division Operator /")) and the integer remainder operator `%` ([¬ß15.17.3](jls-15.html#jls-15.17.3 "15.17.3. Remainder Operator %")) can throw an `ArithmeticException` if the right-hand operand is zero.
*   The increment and decrement operators `++` ([¬ß15.14.2](jls-15.html#jls-15.14.2 "15.14.2. Postfix Increment Operator ++"), [¬ß15.15.1](jls-15.html#jls-15.15.1 "15.15.1. Prefix Increment Operator ++")) and `--` ([¬ß15.14.3](jls-15.html#jls-15.14.3 "15.14.3. Postfix Decrement Operator --"), [¬ß15.15.2](jls-15.html#jls-15.15.2 "15.15.2. Prefix Decrement Operator --")) can throw an `OutOfMemoryError` if boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")) is required and there is not sufficient memory available to perform the conversion.
    

**Example 4.2.2-1. Integer Operations**

class Test {
    public static void main(String\[\] args) {
        int i = 1000000;
        System.out.println(i \* i);
        long l = i;
        System.out.println(l \* l);
        System.out.println(20296 / (l - i));
    }
}

This program produces the output:

\-727379968
1000000000000

and then encounters an `ArithmeticException` in the division by `l - i`, because `l - i` is zero. The first multiplication is performed in 32-bit precision, whereas the second multiplication is a `long` multiplication. The value `-727379968` is the decimal value of the low 32 bits of the mathematical result, `1000000000000`, which is a value too large for type `int`.

  

### 4.2.3. Floating-Point Types, Formats, and Values

The floating-point types are `float` and `double`, which are conceptually associated with the single-precision 32-bit and double-precision 64-bit format IEEE 754 values and operations as specified in _IEEE Standard for Binary Floating-Point Arithmetic_, ANSI/IEEE Standard 754-1985 (IEEE, New York).

The IEEE 754 standard includes not only positive and negative numbers that consist of a sign and magnitude, but also positive and negative zeros, positive and negative _infinities_, and special _Not-a-Number_ values (hereafter abbreviated NaN). A NaN value is used to represent the result of certain invalid operations such as dividing zero by zero. NaN constants of both `float` and `double` type are predefined as `Float.NaN` and `Double.NaN`.

Every implementation of the Java programming language is required to support two standard sets of floating-point values, called the _float value set_ and the _double value set_. In addition, an implementation of the Java programming language may support either or both of two extended-exponent floating-point value sets, called the _float-extended-exponent value set_ and the _double-extended-exponent value set_. These extended-exponent value sets may, under certain circumstances, be used instead of the standard value sets to represent the values of expressions of type `float` or `double` ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion"), [¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions")).

The finite nonzero values of any floating-point value set can all be expressed in the form _s_ ‚ãÖ _m_ ‚ãÖ 2(_e_ - _N_ + 1), where _s_ is +1 or -1, _m_ is a positive integer less than 2_N_, and _e_ is an integer between _Emin_ = -(2_K_\-1\-2) and _Emax_ = 2_K_\-1\-1, inclusive, and where _N_ and _K_ are parameters that depend on the value set. Some values can be represented in this form in more than one way; for example, supposing that a value _v_ in a value set might be represented in this form using certain values for _s_, _m_, and _e_, then if it happened that _m_ were even and _e_ were less than 2_K_\-1, one could halve _m_ and increase _e_ by 1 to produce a second representation for the same value _v_. A representation in this form is called _normalized_ if _m_ ‚â• 2_N_\-1; otherwise the representation is said to be _denormalized_. If a value in a value set cannot be represented in such a way that _m_ ‚â• 2_N_\-1, then the value is said to be a _denormalized value_, because it has no normalized representation.

The constraints on the parameters _N_ and _K_ (and on the derived parameters _Emin_ and _Emax_) for the two required and two optional floating-point value sets are summarized in [Table 4.2.3-A](jls-4.html#jls-4.2.3-140-A "Table 4.2.3-A. Floating-point value set parameters").

**Table 4.2.3-A. Floating-point value set parameters**

    

Parameter

float

float-extended-exponent

double

double-extended-exponent

_N_

24

24

53

53

_K_

8

‚â• 11

11

‚â• 15

_Emax_

+127

‚â• +1023

+1023

‚â• +16383

_Emin_

\-126

‚â§ -1022

\-1022

‚â§ -16382

  

Where one or both extended-exponent value sets are supported by an implementation, then for each supported extended-exponent value set there is a specific implementation-dependent constant _K_, whose value is constrained by [Table 4.2.3-A](jls-4.html#jls-4.2.3-140-A "Table 4.2.3-A. Floating-point value set parameters"); this value _K_ in turn dictates the values for _Emin_ and _Emax_.

Each of the four value sets includes not only the finite nonzero values that are ascribed to it above, but also NaN values and the four values positive zero, negative zero, positive infinity, and negative infinity.

Note that the constraints in [Table 4.2.3-A](jls-4.html#jls-4.2.3-140-A "Table 4.2.3-A. Floating-point value set parameters") are designed so that every element of the float value set is necessarily also an element of the float-extended-exponent value set, the double value set, and the double-extended-exponent value set. Likewise, each element of the double value set is necessarily also an element of the double-extended-exponent value set. Each extended-exponent value set has a larger range of exponent values than the corresponding standard value set, but does not have more precision.

The elements of the float value set are exactly the values that can be represented using the single floating-point format defined in the IEEE 754 standard. The elements of the double value set are exactly the values that can be represented using the double floating-point format defined in the IEEE 754 standard. Note, however, that the elements of the float-extended-exponent and double-extended-exponent value sets defined here do _not_ correspond to the values that can be represented using IEEE 754 single extended and double extended formats, respectively.

The float, float-extended-exponent, double, and double-extended-exponent value sets are not types. It is always correct for an implementation of the Java programming language to use an element of the float value set to represent a value of type `float`; however, it may be permissible in certain regions of code for an implementation to use an element of the float-extended-exponent value set instead. Similarly, it is always correct for an implementation to use an element of the double value set to represent a value of type `double`; however, it may be permissible in certain regions of code for an implementation to use an element of the double-extended-exponent value set instead.

Except for NaN, floating-point values are _ordered_; arranged from smallest to largest, they are negative infinity, negative finite nonzero values, positive and negative zero, positive finite nonzero values, and positive infinity.

IEEE 754 allows multiple distinct NaN values for each of its single and double floating-point formats. While each hardware architecture returns a particular bit pattern for NaN when a new NaN is generated, a programmer can also create NaNs with different bit patterns to encode, for example, retrospective diagnostic information.

For the most part, the Java SE platform treats NaN values of a given type as though collapsed into a single canonical value, and hence this specification normally refers to an arbitrary NaN as though to a canonical value.

However, version 1.3 of the Java SE platform introduced methods enabling the programmer to distinguish between NaN values: the `Float.floatToRawIntBits` and `Double.doubleToRawLongBits` methods. The interested reader is referred to the specifications for the `Float` and `Double` classes for more information.

Positive zero and negative zero compare equal; thus the result of the expression `0.0==-0.0` is `true` and the result of `0.0>-0.0` is false. But other operations can distinguish positive and negative zero; for example, `1.0/0.0` has the value positive infinity, while the value of `1.0/-0.0` is negative infinity.

NaN is _unordered_, so:

*   The numerical comparison operators `<`, `<=`, `>`, and `>=` return `false` if either or both operands are NaN ([¬ß15.20.1](jls-15.html#jls-15.20.1 "15.20.1. Numerical Comparison Operators <, <=, >, and >=")).
*   The equality operator `==` returns `false` if either operand is NaN.
    
    In particular, `(x<y) == !(x>=y)` will be `false` if `x` or `y` is NaN.
*   The inequality operator `!=` returns `true` if either operand is NaN ([¬ß15.21.1](jls-15.html#jls-15.21.1 "15.21.1. Numerical Equality Operators == and !=")).
    
    In particular, `x!=x` is `true` if and only if `x` is NaN.
    

### 4.2.4. Floating-Point Operations

The Java programming language provides a number of operators that act on floating-point values:

*   The comparison operators, which result in a value of type `boolean`:
    
    *   The numerical comparison operators `<`, `<=`, `>`, and `>=` ([¬ß15.20.1](jls-15.html#jls-15.20.1 "15.20.1. Numerical Comparison Operators <, <=, >, and >="))
        
    *   The numerical equality operators `==` and `!=` ([¬ß15.21.1](jls-15.html#jls-15.21.1 "15.21.1. Numerical Equality Operators == and !="))
        
*   The numerical operators, which result in a value of type `float` or `double`:
    
    *   The unary plus and minus operators `+` and `-` ([¬ß15.15.3](jls-15.html#jls-15.15.3 "15.15.3. Unary Plus Operator +"), [¬ß15.15.4](jls-15.html#jls-15.15.4 "15.15.4. Unary Minus Operator -"))
        
    *   The multiplicative operators `*`, `/`, and `%` ([¬ß15.17](jls-15.html#jls-15.17 "15.17. Multiplicative Operators"))
        
    *   The additive operators `+` and `-` ([¬ß15.18.2](jls-15.html#jls-15.18.2 "15.18.2. Additive Operators (+ and -) for Numeric Types"))
        
    *   The increment operator `++`, both prefix ([¬ß15.15.1](jls-15.html#jls-15.15.1 "15.15.1. Prefix Increment Operator ++")) and postfix ([¬ß15.14.2](jls-15.html#jls-15.14.2 "15.14.2. Postfix Increment Operator ++"))
        
    *   The decrement operator `--`, both prefix ([¬ß15.15.2](jls-15.html#jls-15.15.2 "15.15.2. Prefix Decrement Operator --")) and postfix ([¬ß15.14.3](jls-15.html#jls-15.14.3 "15.14.3. Postfix Decrement Operator --"))
        
*   The conditional operator `? :` ([¬ß15.25](jls-15.html#jls-15.25 "15.25. Conditional Operator ? :"))
*   The cast operator ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")), which can convert from a floating-point value to a value of any specified numeric type
*   The string concatenation operator `+` ([¬ß15.18.1](jls-15.html#jls-15.18.1 "15.18.1. String Concatenation Operator +")), which, when given a `String` operand and a floating-point operand, will convert the floating-point operand to a `String` representing its value in decimal form (without information loss), and then produce a newly created `String` by concatenating the two strings
    

Other useful constructors, methods, and constants are predefined in the classes `Float`, `Double`, and `Math`.

If at least one of the operands to a binary operator is of floating-point type, then the operation is a floating-point operation, even if the other is integral.

If at least one of the operands to a numerical operator is of type `double`, then the operation is carried out using 64-bit floating-point arithmetic, and the result of the numerical operator is a value of type `double`. If the other operand is not a `double`, it is first widened ([¬ß5.1.5](jls-5.html#jls-5.1.5 "5.1.5. Widening Reference Conversion")) to type `double` by numeric promotion ([¬ß5.6](jls-5.html#jls-5.6 "5.6. Numeric Contexts")).

Otherwise, the operation is carried out using 32-bit floating-point arithmetic, and the result of the numerical operator is a value of type `float`. (If the other operand is not a `float`, it is first widened to type `float` by numeric promotion.)

Any value of a floating-point type may be cast to or from any numeric type. There are no casts between floating-point types and the type `boolean`.

See [¬ß4.2.5](jls-4.html#jls-4.2.5 "4.2.5. The boolean Type and boolean Values") for an idiom to convert floating-point expressions to `boolean`.

Operators on floating-point numbers behave as specified by IEEE 754 (with the exception of the remainder operator ([¬ß15.17.3](jls-15.html#jls-15.17.3 "15.17.3. Remainder Operator %"))). In particular, the Java programming language requires support of IEEE 754 _denormalized_ floating-point numbers and _gradual underflow_, which make it easier to prove desirable properties of particular numerical algorithms. Floating-point operations do not "flush to zero" if the calculated result is a denormalized number.

The Java programming language requires that floating-point arithmetic behave as if every floating-point operator rounded its floating-point result to the result precision. _Inexact_ results must be rounded to the representable value nearest to the infinitely preciseresult; if the two nearest representable values are equally near, the one with its least significant bit zero is chosen. This is the IEEE 754 standard's default rounding mode known as _round to nearest_.

The Java programming language uses _round toward zero_ when converting a floating value to an integer ([¬ß5.1.3](jls-5.html#jls-5.1.3 "5.1.3. Narrowing Primitive Conversion")), which acts, in this case, as though the number were truncated, discarding the mantissa bits. Rounding toward zero chooses at its result the format's value closest to and no greater in magnitude than the infinitely precise result.

A floating-point operation that overflows produces a signed infinity.

A floating-point operation that underflows produces a denormalized value or a signed zero.

A floating-point operation that has no mathematically definite result produces NaN.

All numeric operations with NaN as an operand produce NaN as a result.

A floating-point operator can throw an exception ([¬ß11 (_Exceptions_)](jls-11.html "Chapter 11. Exceptions")) for the following reasons:

*   Any floating-point operator can throw a `NullPointerException` if unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) of a null reference is required.
*   The increment and decrement operators `++` ([¬ß15.14.2](jls-15.html#jls-15.14.2 "15.14.2. Postfix Increment Operator ++"), [¬ß15.15.1](jls-15.html#jls-15.15.1 "15.15.1. Prefix Increment Operator ++")) and `--` ([¬ß15.14.3](jls-15.html#jls-15.14.3 "15.14.3. Postfix Decrement Operator --"), [¬ß15.15.2](jls-15.html#jls-15.15.2 "15.15.2. Prefix Decrement Operator --")) can throw an `OutOfMemoryError` if boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")) is required and there is not sufficient memory available to perform the conversion.
    

**Example 4.2.4-1. Floating-point Operations**

class Test {
    public static void main(String\[\] args) {
        // An example of overflow:
        double d = 1e308;
        System.out.print("overflow produces infinity: ");
        System.out.println(d + "\*10==" + d\*10);
        // An example of gradual underflow:
        d = 1e-305 \* Math.PI;
        System.out.print("gradual underflow: " + d + "\\n   ");
        for (int i = 0; i < 4; i++)
            System.out.print(" " + (d /= 100000));
        System.out.println();
        // An example of NaN:
        System.out.print("0.0/0.0 is Not-a-Number: ");
        d = 0.0/0.0;
        System.out.println(d);
        // An example of inexact results and rounding:
        System.out.print("inexact results with float:");
        for (int i = 0; i < 100; i++) {
            float z = 1.0f / i;
            if (z \* i != 1.0f)
                System.out.print(" " + i);
        }
        System.out.println();
        // Another example of inexact results and rounding:
        System.out.print("inexact results with double:");
        for (int i = 0; i < 100; i++) {
            double z = 1.0 / i;
            if (z \* i != 1.0)
                System.out.print(" " + i);
        }
        System.out.println();
        // An example of cast to integer rounding:
        System.out.print("cast to int rounds toward 0: ");
        d = 12345.6;
        System.out.println((int)d + " " + (int)(-d));
    }
}

This program produces the output:

overflow produces infinity: 1.0e+308\*10==Infinity
gradual underflow: 3.141592653589793E-305
3.1415926535898E-310 3.141592653E-315 3.142E-320 0.0
0.0/0.0 is Not-a-Number: NaN
inexact results with float: 0 41 47 55 61 82 83 94 97
inexact results with double: 0 49 98
cast to int rounds toward 0: 12345 -12345

This example demonstrates, among other things, that gradual underflow can result in a gradual loss of precision.

The results when `i` is `0` involve division by zero, so that `z` becomes positive infinity, and `z * 0` is NaN, which is not equal to `1.0`.

  

### 4.2.5. The `boolean` Type and boolean Values

The `boolean` type represents a logical quantity with two possible values, indicated by the literals `true` and `false` ([¬ß3.10.3](jls-3.html#jls-3.10.3 "3.10.3. Boolean Literals")).

The boolean operators are:

*   The relational operators `==` and `!=` ([¬ß15.21.2](jls-15.html#jls-15.21.2 "15.21.2. Boolean Equality Operators == and !="))
*   The logical complement operator `!` ([¬ß15.15.6](jls-15.html#jls-15.15.6 "15.15.6. Logical Complement Operator !"))
*   The logical operators `&`, `^`, and `|` ([¬ß15.22.2](jls-15.html#jls-15.22.2 "15.22.2. Boolean Logical Operators &, ^, and |"))
*   The conditional-and and conditional-or operators `&&` ([¬ß15.23](jls-15.html#jls-15.23 "15.23. Conditional-And Operator &&")) and `||` ([¬ß15.24](jls-15.html#jls-15.24 "15.24. Conditional-Or Operator ||"))
*   The conditional operator `? :` ([¬ß15.25](jls-15.html#jls-15.25 "15.25. Conditional Operator ? :"))
*   The string concatenation operator `+` ([¬ß15.18.1](jls-15.html#jls-15.18.1 "15.18.1. String Concatenation Operator +")), which, when given a `String` operand and a `boolean` operand, will convert the `boolean` operand to a `String` (either `"true"` or `"false"`), and then produce a newly created `String` that is the concatenation of the two strings
    

Boolean expressions determine the control flow in several kinds of statements:

*   The `if` statement ([¬ß14.9](jls-14.html#jls-14.9 "14.9. The if Statement"))
*   The `while` statement ([¬ß14.12](jls-14.html#jls-14.12 "14.12. The while Statement"))
*   The `do` statement ([¬ß14.13](jls-14.html#jls-14.13 "14.13. The do Statement"))
*   The `for` statement ([¬ß14.14](jls-14.html#jls-14.14 "14.14. The for Statement"))
    

A `boolean` expression also determines which subexpression is evaluated in the conditional `? :` operator ([¬ß15.25](jls-15.html#jls-15.25 "15.25. Conditional Operator ? :")).

Only `boolean` and `Boolean` expressions can be used in control flow statements and as the first operand of the conditional operator `? :`.

An integer or floating-point expression `x` can be converted to a `boolean` value, following the C language convention that any nonzero value is `true`, by the expression `x!=0`.

An object reference `obj` can be converted to a `boolean` value, following the C language convention that any reference other than `null` is `true`, by the expression `obj!=null`.

A `boolean` value can be converted to a `String` by string conversion ([¬ß5.4](jls-5.html#jls-5.4 "5.4. String Contexts")).

A `boolean` value may be cast to type `boolean`, `Boolean`, or `Object` ([¬ß5.5](jls-5.html#jls-5.5 "5.5. Casting Contexts")). No other casts on type `boolean` are allowed.

4.3. Reference Types and Values
-------------------------------

There are four kinds of _reference types_: class types ([¬ß8.1](jls-8.html#jls-8.1 "8.1. Class Declarations")), interface types ([¬ß9.1](jls-9.html#jls-9.1 "9.1. Interface Declarations")), type variables ([¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables")), and array types ([¬ß10.1](jls-10.html#jls-10.1 "10.1. Array Types")).

ReferenceType:

[ClassOrInterfaceType](jls-4.html#jls-ClassOrInterfaceType "ClassOrInterfaceType")  
[TypeVariable](jls-4.html#jls-TypeVariable "TypeVariable")  
[ArrayType](jls-4.html#jls-ArrayType "ArrayType")

ClassOrInterfaceType:

[ClassType](jls-4.html#jls-ClassType "ClassType")  
[InterfaceType](jls-4.html#jls-InterfaceType "InterfaceType")

ClassType:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} [Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\]  
[ClassOrInterfaceType](jls-4.html#jls-ClassOrInterfaceType "ClassOrInterfaceType") `.` {[Annotation](jls-9.html#jls-Annotation "Annotation")} [Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\]

InterfaceType:

[ClassType](jls-4.html#jls-ClassType "ClassType")

TypeVariable:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} [Identifier](jls-3.html#jls-Identifier "Identifier")

ArrayType:

[PrimitiveType](jls-4.html#jls-PrimitiveType "PrimitiveType") [Dims](jls-4.html#jls-Dims "Dims")  
[ClassOrInterfaceType](jls-4.html#jls-ClassOrInterfaceType "ClassOrInterfaceType") [Dims](jls-4.html#jls-Dims "Dims")  
[TypeVariable](jls-4.html#jls-TypeVariable "TypeVariable") [Dims](jls-4.html#jls-Dims "Dims")

Dims:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]` {{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]`}

The sample code:

class Point { int\[\] metrics; }
interface Move { void move(int deltax, int deltay); }

declares a class type `Point`, an interface type `Move`, and uses an array type `int``[]` (an array of `int`) to declare the field `metrics` of the class `Point`.

A class or interface type consists of an identifier or a dotted sequence of identifiers, where each identifier is optionally followed by type arguments ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")). If type arguments appear anywhere in a class or interface type, it is a parameterized type ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")).

Each identifier in a class or interface type is classified as a package name or a type name ([¬ß6.5.1](jls-6.html#jls-6.5.1 "6.5.1. Syntactic Classification of a Name According to Context")). Identifiers which are classified as type names may be annotated. If a class or interface type has the form `T.id` (optionally followed by type arguments), then `id` must be the simple name of an accessible member type of `T` ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control"), [¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")), or a compile-time error occurs. The class or interface type denotes that member type.

### 4.3.1. Objects

An _object_ is a _class instance_ or an _array_.

The reference values (often just _references_) are pointers to these objects, and a special null reference, which refers to no object.

A class instance is explicitly created by a class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")).

An array is explicitly created by an array creation expression ([¬ß15.10.1](jls-15.html#jls-15.10.1 "15.10.1. Array Creation Expressions")).

A new class instance is implicitly created when the string concatenation operator `+` ([¬ß15.18.1](jls-15.html#jls-15.18.1 "15.18.1. String Concatenation Operator +")) is used in a non-constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")), resulting in a new object of type `String` ([¬ß4.3.3](jls-4.html#jls-4.3.3 "4.3.3. The Class String")).

A new array object is implicitly created when an array initializer expression ([¬ß10.6](jls-10.html#jls-10.6 "10.6. Array Initializers")) is evaluated; this can occur when a class or interface is initialized ([¬ß12.4](jls-12.html#jls-12.4 "12.4. Initialization of Classes and Interfaces")), when a new instance of a class is created ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")), or when a local variable declaration statement is executed ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements")).

New objects of the types `Boolean`, `Byte`, `Short`, `Character`, `Integer`, `Long`, `Float`, and `Double` may be implicitly created by boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")).

**Example 4.3.1-1. Object Creation**

class Point {
    int x, y;
    Point() { System.out.println("default"); }
    Point(int x, int y) { this.x = x; this.y = y; }

    /\* A Point instance is explicitly created at 
       class initialization time: \*/
    static Point origin = new Point(0,0);

    /\* A String can be implicitly created 
       by a + operator: \*/
    public String toString() { return "(" + x + "," + y + ")"; }
}

class Test {
    public static void main(String\[\] args) {
        /\* A Point is explicitly created
           using newInstance: \*/
        Point p = null;
        try {
            p = (Point)Class.forName("Point").newInstance();
        } catch (Exception e) {
            System.out.println(e);
        }

        /\* An array is implicitly created 
           by an array constructor: \*/
        Point a\[\] = { new Point(0,0), new Point(1,1) };

        /\* Strings are implicitly created 
           by + operators: \*/
        System.out.println("p: " + p);
        System.out.println("a: { " + a\[0\] + ", " + a\[1\] + " }");
    
        /\* An array is explicitly created
           by an array creation expression: \*/
        String sa\[\] = new String\[2\];
        sa\[0\] = "he"; sa\[1\] = "llo";
        System.out.println(sa\[0\] + sa\[1\]);
    }
}

This program produces the output:

default
p: (0,0)
a: { (0,0), (1,1) }
hello

  

The operators on references to objects are:

*   Field access, using either a qualified name ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) or a field access expression ([¬ß15.11](jls-15.html#jls-15.11 "15.11. Field Access Expressions"))
*   Method invocation ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions"))
*   The cast operator ([¬ß5.5](jls-5.html#jls-5.5 "5.5. Casting Contexts"), [¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions"))
*   The string concatenation operator `+` ([¬ß15.18.1](jls-15.html#jls-15.18.1 "15.18.1. String Concatenation Operator +")), which, when given a `String` operand and a reference, will convert the reference to a `String` by invoking the `toString` method of the referenced object (using `"null"` if either the reference or the result of `toString` is a null reference), and then will produce a newly created `String` that is the concatenation of the two strings
*   The `instanceof` operator ([¬ß15.20.2](jls-15.html#jls-15.20.2 "15.20.2. Type Comparison Operator instanceof"))
*   The reference equality operators `==` and `!=` ([¬ß15.21.3](jls-15.html#jls-15.21.3 "15.21.3. Reference Equality Operators == and !="))
*   The conditional operator `? :` ([¬ß15.25](jls-15.html#jls-15.25 "15.25. Conditional Operator ? :")).
    

There may be many references to the same object. Most objects have state, stored in the fields of objects that are instances of classes or in the variables that are the components of an array object. If two variables contain references to the same object, the state of the object can be modified using one variable's reference to the object, and then the altered state can be observed through the reference in the other variable.

**Example 4.3.1-2. Primitive and Reference Identity**

class Value { int val; }

class Test {
    public static void main(String\[\] args) {
        int i1 = 3;
        int i2 = i1;
        i2 = 4;
        System.out.print("i1==" + i1);
        System.out.println(" but i2==" + i2);
        Value v1 = new Value();
        v1.val = 5;
        Value v2 = v1;
        v2.val = 6;
        System.out.print("v1.val==" + v1.val);
        System.out.println(" and v2.val==" + v2.val);
    }
}

This program produces the output:

i1==3 but i2==4
v1.val==6 and v2.val==6

because `v1.val` and `v2.val` reference the same instance variable ([¬ß4.12.3](jls-4.html#jls-4.12.3 "4.12.3. Kinds of Variables")) in the one `Value` object created by the only `new` expression, while `i1` and `i2` are different variables.

  

Each object is associated with a monitor ([¬ß17.1](jls-17.html#jls-17.1 "17.1. Synchronization")), which is used by `synchronized` methods ([¬ß8.4.3](jls-8.html#jls-8.4.3 "8.4.3. Method Modifiers")) and the `synchronized` statement ([¬ß14.19](jls-14.html#jls-14.19 "14.19. The synchronized Statement")) to provide control over concurrent access to state by multiple threads ([¬ß17 (_Threads and Locks_)](jls-17.html "Chapter 17. Threads and Locks")).

### 4.3.2. The Class `Object`

The class `Object` is a superclass ([¬ß8.1.4](jls-8.html#jls-8.1.4 "8.1.4. Superclasses and Subclasses")) of all other classes.

All class and array types inherit ([¬ß8.4.8](jls-8.html#jls-8.4.8 "8.4.8. Inheritance, Overriding, and Hiding")) the methods of class `Object`, which are summarized as follows:

*   The method `clone` is used to make a duplicate of an object.
*   The method `equals` defines a notion of object equality, which is based on value, not reference, comparison.
*   The method `finalize` is run just before an object is destroyed ([¬ß12.6](jls-12.html#jls-12.6 "12.6. Finalization of Class Instances")).
*   The method `getClass` returns the `Class` object that represents the class of the object.
    
    A `Class` object exists for each reference type. It can be used, for example, to discover the fully qualified name of a class, its members, its immediate superclass, and any interfaces that it implements.
    
    The type of a method invocation expression of `getClass` is `Class``<``?` `extends` |T|`>`, where T is the class or interface that was searched for `getClass` ([¬ß15.12.1](jls-15.html#jls-15.12.1 "15.12.1. Compile-Time Step 1: Determine Class or Interface to Search")) and |T| denotes the erasure of T ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")).
    
    A class method that is declared `synchronized` ([¬ß8.4.3.6](jls-8.html#jls-8.4.3.6 "8.4.3.6. synchronized Methods")) synchronizes on the monitor associated with the `Class` object of the class.
*   The method `hashCode` is very useful, together with the method `equals`, in hashtables such as `java.util.HashMap`.
*   The methods `wait`, `notify`, and `notifyAll` are used in concurrent programming using threads ([¬ß17.2](jls-17.html#jls-17.2 "17.2. Wait Sets and Notification")).
*   The method `toString` returns a `String` representation of the object.
    

### 4.3.3. The Class `String`

Instances of class `String` represent sequences of Unicode code points.

A `String` object has a constant (unchanging) value.

String literals ([¬ß3.10.5](jls-3.html#jls-3.10.5 "3.10.5. String Literals")) are references to instances of class `String`.

The string concatenation operator `+` ([¬ß15.18.1](jls-15.html#jls-15.18.1 "15.18.1. String Concatenation Operator +")) implicitly creates a new `String` object when the result is not a constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")).

### 4.3.4. When Reference Types Are the Same

Two reference types are the _same compile-time type_ if they have the same binary name ([¬ß13.1](jls-13.html#jls-13.1 "13.1. The Form of a Binary")) and their type arguments, if any, are the same, applying this definition recursively.

When two reference types are the same, they are sometimes said to be the _same class_ or the _same interface_.

At run time, several reference types with the same binary name may be loaded simultaneously by different class loaders. These types may or may not represent the same type declaration. Even if two such types do represent the same type declaration, they are considered distinct.

Two reference types are the _same run-time type_ if:

*   They are both class or both interface types, are defined by the same class loader, and have the same binary name ([¬ß13.1](jls-13.html#jls-13.1 "13.1. The Form of a Binary")), in which case they are sometimes said to be the _same run-time class_ or the _same run-time interface_.
*   They are both array types, and their component types are the same run-time type ([¬ß10 (_Arrays_)](jls-10.html "Chapter 10. Arrays")).
    

4.4. Type Variables
-------------------

A _type variable_ is an unqualified identifier used as a type in class, interface, method, and constructor bodies.

A type variable is introduced by the declaration of a _type parameter_ of a generic class, interface, method, or constructor ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters"), [¬ß9.1.2](jls-9.html#jls-9.1.2 "9.1.2. Generic Interfaces and Type Parameters"), [¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods"), [¬ß8.8.4](jls-8.html#jls-8.8.4 "8.8.4. Generic Constructors")).

TypeParameter:

{[TypeParameterModifier](jls-4.html#jls-TypeParameterModifier "TypeParameterModifier")} [Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeBound](jls-4.html#jls-TypeBound "TypeBound")\]

TypeParameterModifier:

[Annotation](jls-9.html#jls-Annotation "Annotation")

TypeBound:

`extends` [TypeVariable](jls-4.html#jls-TypeVariable "TypeVariable")  
`extends` [ClassOrInterfaceType](jls-4.html#jls-ClassOrInterfaceType "ClassOrInterfaceType") {[AdditionalBound](jls-4.html#jls-AdditionalBound "AdditionalBound")}

AdditionalBound:

`&` [InterfaceType](jls-4.html#jls-InterfaceType "InterfaceType")

The scope of a type variable declared as a type parameter is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration").

Every type variable declared as a type parameter has a _bound_. If no bound is declared for a type variable, `Object` is assumed. If a bound is declared, it consists of either:

*   a single type variable T, or
*   a class or interface type T possibly followed by interface types I1 `&` ... `&` In.
    

It is a compile-time error if any of the types I1 ... In is a class type or type variable.

The erasures ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of all constituent types of a bound must be pairwise different, or a compile-time error occurs.

A type variable must not at the same time be a subtype of two interface types which are different parameterizations of the same generic interface, or a compile-time error occurs.

The order of types in a bound is only significant in that the erasure of a type variable is determined by the first type in its bound, and that a class type or type variable may only appear in the first position.

The members of a type variable X with bound T `&` I1 `&` ... `&` In are the members of the intersection type ([¬ß4.9](jls-4.html#jls-4.9 "4.9. Intersection Types")) T `&` I1 `&` ... `&` In appearing at the point where the type variable is declared.

**Example 4.4-1. Members of a Type Variable**

package TypeVarMembers;

class C { 
    public    void mCPublic()    {}
    protected void mCProtected() {} 
              void mCPackage()   {}
    private   void mCPrivate()   {} 
} 

interface I {
    void mI();
}

class CT extends C implements I {
    public void mI() {}
}

class Test {
    <T extends C & I> void test(T t) { 	
        t.mI();           // OK
        t.mCPublic();     // OK 
        t.mCProtected();  // OK 
        t.mCPackage();    // OK
        t.mCPrivate();    // Compile-time error
    } 
}

The type variable `T` has the same members as the intersection type `C & I`, which in turn has the same members as the empty class `CT`, defined in the same scope with equivalent supertypes. The members of an interface are always `public`, and therefore always inherited (unless overridden). Hence `mI` is a member of `CT` and of `T`. Among the members of `C`, all but `mCPrivate` are inherited by `CT`, and are therefore members of both `CT` and `T`.

If `C` had been declared in a different package than `T`, then the call to `mCPackage` would give rise to a compile-time error, as that member would not be accessible at the point where `T` is declared.

  

4.5. Parameterized Types
------------------------

A class or interface declaration that is generic ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters"), [¬ß9.1.2](jls-9.html#jls-9.1.2 "9.1.2. Generic Interfaces and Type Parameters")) defines a set of _parameterized types_.

A parameterized type is a class or interface type of the form C`<`T1,...,Tn`>`, where C is the name of a generic type and `<`T1,...,Tn`>` is a list of type arguments that denote a particular _parameterization_ of the generic type.

A generic type has type parameters F1,...,Fn with corresponding bounds B1,...,Bn. Each type argument Ti of a parameterized type ranges over all types that are subtypes of all types listed in the corresponding bound. That is, for each bound type S in Bi, Ti is a subtype of S`[F1:=T1,...,Fn:=Tn]` ([¬ß4.10](jls-4.html#jls-4.10 "4.10. Subtyping")).

A parameterized type C`<`T1,...,Tn`>` is _well-formed_ if all of the following are true:

*   C is the name of a generic type.
*   The number of type arguments is the same as the number of type parameters in the generic declaration of C.
*   When subjected to capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")) resulting in the type C`<`X1,...,Xn`>`, each type argument Xi is a subtype of S`[F1:=X1,...,Fn:=Xn]` for each bound type S in Bi.
    

It is a compile-time error if a parameterized type is not well-formed.

In this specification, whenever we speak of a class or interface type, we include the generic version as well, unless explicitly excluded.

Two parameterized types are _provably distinct_ if either of the following is true:

*   They are parameterizations of distinct generic type declarations.
*   Any of their type arguments are provably distinct.
    

Given the generic types in the examples of [¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters"), here are some well-formed parameterized types:

*   `Seq<String>`
*   `Seq<Seq<String>>`
*   `Seq<String>.Zipper<Integer>`
*   `Pair<String,Integer>`
    

Here are some incorrect parameterizations of those generic types:

*   `Seq<int>` is illegal, as primitive types cannot be type arguments.
*   `Pair<String>` is illegal, as there are not enough type arguments.
*   `Pair<String,String,String>` is illegal, as there are too many type arguments.
    

A parameterized type may be an parameterization of a generic class or interface which is nested. For example, if a non-generic class C has a generic member class D`<`T`>`, then C`.`D`<``Object``>` is a parameterized type. And if a generic class C`<`T`>` has a non-generic member class D, then the member type C`<``String``>``.`ype">D is a parameterized type, even though the class D is not generic.

### 4.5.1. Type Arguments of Parameterized Types

Type arguments may be either reference types or wildcards. Wildcards are useful in situations where only partial knowledge about the type parameter is required.

TypeArguments:

`<` [TypeArgumentList](jls-4.html#jls-TypeArgumentList "TypeArgumentList") `>`

TypeArgumentList:

[TypeArgument](jls-4.html#jls-TypeArgument "TypeArgument") {`,` [TypeArgument](jls-4.html#jls-TypeArgument "TypeArgument")}

TypeArgument:

[ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType")  
[Wildcard](jls-4.html#jls-Wildcard "Wildcard")

Wildcard:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `?` \[[WildcardBounds](jls-4.html#jls-WildcardBounds "WildcardBounds")\]

WildcardBounds:

`extends` [ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType")  
`super` [ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType")

Wildcards may be given explicit bounds, just like regular type variable declarations. An upper bound is signified by the following syntax, where B is the bound:

? extends B

Unlike ordinary type variables declared in a method signature, no type inference is required when using a wildcard. Consequently, it is permissible to declare lower bounds on a wildcard, using the following syntax, where B is a lower bound:

? super B

The wildcard `?` `extends` `Object` is equivalent to the unbounded wildcard `?`.

Two type arguments are _provably distinct_ if one of the following is true:

*   Neither argument is a type variable or wildcard, and the two arguments are not the same type.
*   One type argument is a type variable or wildcard, with an upper bound (from capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")), if necessary) of S; and the other type argument T is not a type variable or wildcard; and neither |S| `<:` |T| nor |T| `<:` |S| ([¬ß4.8](jls-4.html#jls-4.8 "4.8. Raw Types"), [¬ß4.10](jls-4.html#jls-4.10 "4.10. Subtyping")).
*   Each type argument is a type variable or wildcard, with upper bounds (from capture conversion, if necessary) of S and T; and neither |S| `<:` |T| nor |T| `<:` |S|.
    

A type argument T1 is said to _contain_ another type argument T2, written T2 `<=` T1, if the set of types denoted by T2 is provably a subset of the set of types denoted by T1 under the reflexive and transitive closure of the following rules (where `<:` denotes subtyping ([¬ß4.10](jls-4.html#jls-4.10 "4.10. Subtyping"))):

*   `?` `extends` T `<=` `?` `extends` S if T `<:` S
*   `?` `extends` T `<=` `?`
*   `?` `super` T `<=` `?` `super` S if S `<:` T
*   `?` `super` T `<=` `?`
*   `?` `super` T `<=` `?` `extends` `Object`
*   T `<=` T
*   T `<=` `?` `extends` T
*   T `<=` `?` `super` T
    

The relationship of wildcards to established type theory is an interesting one, which we briefly allude to here. Wildcards are a restricted form of existential types. Given a generic type declaration G`<`T `extends` B`>`, G`<``?``>` is roughly analogous to Some X `<:` B. G`<`X`>`.

Historically, wildcards are a direct descendant of the work by Atsushi Igarashi and Mirko Viroli. Readers interested in a more comprehensive discussion should refer to _On Variance-Based Subtyping for Parametric Types_ by Atsushi Igarashi and Mirko Viroli, in the _Proceedings of the 16th European Conference on Object Oriented Programming (ECOOP 2002)_. This work itself builds upon earlier work by Kresten Thorup and Mads Torgersen (_Unifying Genericity_, ECOOP 99), as well as a long tradition of work on declaration based variance that goes back to Pierre America's work on POOL (OOPSLA 89).

Wildcards differ in certain details from the constructs described in the aforementioned paper, in particular in the use of capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")) rather than the `close` operation described by Igarashi and Viroli. For a formal account of wildcards, see _Wild FJ_ by Mads Torgersen, Erik Ernst and Christian Plesner Hansen, in the 12th workshop on Foundations of Object Oriented Programming (FOOL 2005).

**Example 4.5.1-1. Unbounded Wildcards**

import java.util.Collection;
import java.util.ArrayList;

class Test {
    static void printCollection(Collection<?> c) {
                                // a wildcard collection
        for (Object o : c) {
            System.out.println(o);
        }
    }

    public static void main(String\[\] args) {
        Collection<String> cs = new ArrayList<String>();
        cs.add("hello");
        cs.add("world");
        printCollection(cs);
    }
}

Note that using `Collection<Object>` as the type of the incoming parameter, `c`, would not be nearly as useful; the method could only be used with an argument expression that had type `Collection<Object>`, which would be quite rare. In contrast, the use of an unbounded wildcard allows any kind of collection to be passed as an argument.

Here is an example where the element type of an array is parameterized by a wildcard:

public Method getMethod(Class<?>\[\] parameterTypes) { ... }

  

**Example 4.5.1-2. Bounded Wildcards**

boolean addAll(Collection<? extends E> c)

Here, the method is declared within the interface `Collection<E>`, and is designed to add all the elements of its incoming argument to the collection upon which it is invoked. A natural tendency would be to use `Collection<E>` as the type of `c`, but this is unnecessarily restrictive. An alternative would be to declare the method itself to be generic:

<T> boolean addAll(Collection<T> c)

This version is sufficiently flexible, but note that the type parameter is used only once in the signature. This reflects the fact that the type parameter is not being used to express any kind of interdependency between the type(s) of the argument(s), the return type and/or throws type. In the absence of such interdependency, generic methods are considered bad style, and wildcards are preferred.

Reference(T referent, ReferenceQueue<? super T> queue)

Here, the referent can be inserted into any queue whose element type is a supertype of the type `T` of the referent; `T` is the lower bound for the wildcard.

  

### 4.5.2. Members and Constructors of Parameterized Types

Let C be a generic class or interface declaration with type parameters A1,...,An, and let C`<`T1,...,Tn`>` be a parameterization of C where, for 1 ‚â§ _i_ ‚â§ _n_, Ti is a type (rather than a wildcard). Then:

*   Let `m` be a member or constructor declaration in C, whose type as declared is T ([¬ß8.2](jls-8.html#jls-8.2 "8.2. Class Members"), [¬ß8.8.6](jls-8.html#jls-8.8.6 "8.8.6. The Type of a Constructor")).
    
    The type of `m` in C`<`T1,...,Tn`>` is T`[A1:=T1,...,An:=Tn]`.
*   Let `m` be a member or constructor declaration in D, where D is a class extended by C or an interface implemented by C. Let D`<`U1,...,Uk`>` be the supertype of C`<`T1,...,Tn`>` that corresponds to D.
    
    The type of `m` in C`<`T1,...,Tn`>` is the type of `m` in D`<`U1,...,Uk`>`.
    

If any of the type arguments in the parameterization of C are wildcards, then:

*   The types of the fields, methods, and constructors in C`<`T1,...,Tn`>` are the types of the fields, methods, and constructors in the capture conversion of C`<`T1,...,Tn`>` ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")).
*   Let D be a (possibly generic) class or interface declaration in C. Then the type of D in C`<`T1,...,Tn`>` is D where, if D is generic, all type arguments are unbounded wildcards.
    

This is of no consequence, as it is impossible to access a member of a parameterized type without performing capture conversion, and it is impossible to use a wildcard after the keyword `new` in a class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")).

The sole exception to the previous paragraph is when a nested parameterized type is used as the expression in an `instanceof` operator ([¬ß15.20.2](jls-15.html#jls-15.20.2 "15.20.2. Type Comparison Operator instanceof")), where capture conversion is not applied.

A `static` member that is declared in a generic type declaration must be referred to using the non-generic type that corresponds to the generic type ([¬ß6.1](jls-6.html#jls-6.1 "6.1. Declarations"), [¬ß6.5.5.2](jls-6.html#jls-6.5.5.2 "6.5.5.2. Qualified Type Names"), [¬ß6.5.6.2](jls-6.html#jls-6.5.6.2 "6.5.6.2. Qualified Expression Names")), or a compile-time error occurs.

In other words, it is illegal to refer to a `static` member declared in a generic type declaration by using a parameterized type.

4.6. Type Erasure
-----------------

Type erasure is a mapping from types (possibly including parameterized types and type variables) to types (that are never parameterized types or type variables). We write |T| for the erasure of type T. The erasure mapping is defined as follows:

*   The erasure of a parameterized type ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")) G`<`T1,...,Tn`>` is |G|.
*   The erasure of a nested type T`.`C is |T|.C.
*   The erasure of an array type T`[]` is |T|`[]`.
*   The erasure of a type variable ([¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables")) is the erasure of its leftmost bound.
*   The erasure of every other type is the type itself.
    

Type erasure also maps the signature ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")) of a constructor or method to a signature that has no parameterized types or type variables. The erasure of a constructor or method signature s is a signature consisting of the same name as s and the erasures of all the formal parameter types given in s.

The return type of a method ([¬ß8.4.5](jls-8.html#jls-8.4.5 "8.4.5. Method Result")) and the type parameters of a generic method or constructor ([¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods"), [¬ß8.8.4](jls-8.html#jls-8.8.4 "8.8.4. Generic Constructors")) also undergo erasure if the method or constructor's signature is erased.

The erasure of the signature of a generic method has no type parameters.

4.7. Reifiable Types
--------------------

Because some type information is erased during compilation, not all types are available at run time. Types that are completely available at run time are known as _reifiable types_.

A type is _reifiable_ if and only if one of the following holds:

*   It refers to a non-generic class or interface type declaration.
*   It is a parameterized type in which all type arguments are unbounded wildcards ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")).
*   It is a raw type ([¬ß4.8](jls-4.html#jls-4.8 "4.8. Raw Types")).
*   It is a primitive type ([¬ß4.2](jls-4.html#jls-4.2 "4.2. Primitive Types and Values")).
*   It is an array type ([¬ß10.1](jls-10.html#jls-10.1 "10.1. Array Types")) whose element type is reifiable.
*   It is a nested type where, for each type T separated by a "`.`", T itself is reifiable.
    
    For example, if a generic class X`<`T`>` has a generic member class Y`<`U`>`, then the type X`<``?``>``.`Y`<``?``>` is reifiable because X`<``?``>` is reifiable and Y`<``?``>` is reifiable. The type X`<``?``>``.`Y`<``Object``>` is not reifiable because Y`<``Object``>` is not reifiable.
    

An intersection type is not reifiable.

The decision not to make all generic types reifiable is one of the most crucial, and controversial design decisions involving the type system of the Java programming language.

Ultimately, the most important motivation for this decision is compatibility with existing code. In a naive sense, the addition of new constructs such as generics has no implications for pre-existing code. The Java programming language, per se, is compatible with earlier versions as long as every program written in the previous versions retains its meaning in the new version. However, this notion, which may be termed language compatibility, is of purely theoretical interest. Real programs (even trivial ones, such as "Hello World") are composed of several compilation units, some of which are provided by the Java SE platform (such as elements of `java.lang` or `java.util`). In practice, then, the minimum requirement is platform compatibility - that any program written for the prior version of the Java SE platform continues to function unchanged in the new version.

One way to provide platform compatibility is to leave existing platform functionality unchanged, only adding new functionality. For example, rather than modify the existing Collections hierarchy in `java.util`, one might introduce a new library utilizing generics.

The disadvantages of such a scheme is that it is extremely difficult for pre-existing clients of the Collection library to migrate to the new library. Collections are used to exchange data between independently developed modules; if a vendor decides to switch to the new, generic, library, that vendor must also distribute two versions of their code, to be compatible with their clients. Libraries that are dependent on other vendors code cannot be modified to use generics until the supplier's library is updated. If two modules are mutually dependent, the changes must be made simultaneously.

Clearly, platform compatibility, as outlined above, does not provide a realistic path for adoption of a pervasive new feature such as generics. Therefore, the design of the generic type system seeks to support migration compatibility. Migration compatibiliy allows the evolution of existing code to take advantage of generics without imposing dependencies between independently developed software modules.

The price of migration compatibility is that a full and sound reification of the generic type system is not possible, at least while the migration is taking place.

4.8. Raw Types
--------------

To facilitate interfacing with non-generic legacy code, it is possible to use as a type the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of a parameterized type ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")) or the erasure of an array type ([¬ß10.1](jls-10.html#jls-10.1 "10.1. Array Types")) whose element type is a parameterized type. Such a type is called a _raw type_.

More precisely, a raw type is defined to be one of:

*   The reference type that is formed by taking the name of a generic type declaration without an accompanying type argument list.
*   An array type whose element type is a raw type.
*   A non-`static` member type of a raw type R that is not inherited from a superclass or superinterface of R.
    

A non-generic class or interface type is not a raw type.

To see why a non-`static` type member of a raw type is considered raw, consider the following example:

class Outer<T>{
    T t;
    class Inner {
        T setOuterT(T t1) { t = t1; return t; }
    }
}

The type of the member(s) of `Inner` depends on the type parameter of `Outer`. If `Outer` is raw, `Inner` must be treated as raw as well, as there is no valid binding for `T`.

This rule applies only to type members that are not inherited. Inherited type members that depend on type variables will be inherited as raw types as a consequence of the rule that the supertypes of a raw type are erased, described later in this section.

Another implication of the rules above is that a generic inner class of a raw type can itself only be used as a raw type:

class Outer<T>{
    class Inner<S> {
        S s;
    }
}

It is not possible to access `Inner` as a partially raw type (a "rare" type):

Outer.Inner<Double> x = null;  // illegal
Double d = x.s;

because `Outer` itself is raw, hence so are all its inner classes including `Inner`, and so it is not possible to pass any type arguments to Inner.

The superclasses (respectively, superinterfaces) of a raw type are the erasures of the superclasses (superinterfaces) of any of the parameterizations of the generic type.

The type of a constructor ([¬ß8.8](jls-8.html#jls-8.8 "8.8. Constructor Declarations")), instance method ([¬ß8.4](jls-8.html#jls-8.4 "8.4. Method Declarations"), [¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations")), or non-`static` field ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations")) of a raw type C that is not inherited from its superclasses or superinterfaces is the raw type that corresponds to the erasure of its type in the generic declaration corresponding to C.

The type of a `static` method or `static` field of a raw type C is the same as its type in the generic declaration corresponding to C.

It is a compile-time error to pass type arguments to a non-`static` type member of a raw type that is not inherited from its superclasses or superinterfaces.

It is a compile-time error to attempt to use a type member of a parameterized type as a raw type.

This means that the ban on "rare" types extends to the case where the qualifying type is parameterized, but we attempt to use the inner class as a raw type:

Outer<Integer>.Inner x = null; // illegal

This is the opposite of the case discussed above. There is no practical justification for this half-baked type. In legacy code, no type arguments are used. In non-legacy code, we should use the generic types correctly and pass all the required type arguments.

The supertype of a class may be a raw type. Member accesses for the class are treated as normal, and member accesses for the supertype are treated as for raw types. In the constructor of the class, calls to `super` are treated as method calls on a raw type.

The use of raw types is allowed only as a concession to compatibility of legacy code. The use of raw types in code written after the introduction of generics into the Java programming language is strongly discouraged. It is possible that future versions of the Java programming language will disallow the use of raw types.

To make sure that potential violations of the typing rules are always flagged, some accesses to members of a raw type will result in compile-time unchecked warnings. The rules for compile-time unchecked warnings when accessing members or constructors of raw types are as follows:

*   At an assignment to a field: if the type of the _Primary_ in the field access expression ([¬ß15.11](jls-15.html#jls-15.11 "15.11. Field Access Expressions")) is a raw type, then a compile-time unchecked warning occurs if erasure changes the field's type.
*   At an invocation of a method or constructor: if the type of the class or interface to search ([¬ß15.12.1](jls-15.html#jls-15.12.1 "15.12.1. Compile-Time Step 1: Determine Class or Interface to Search")) is a raw type, then a compile-time unchecked warning occurs if erasure changes any of the formal parameter types of the method or constructor.
*   No compile-time unchecked warning occurs for a method call when the formal parameter types do not change under erasure (even if the return type and/or `throws` clause changes), for reading from a field, or for a class instance creation of a raw type.
    

Note that the unchecked warnings above are distinct from the unchecked warnings possible from unchecked conversion ([¬ß5.1.9](jls-5.html#jls-5.1.9 "5.1.9. Unchecked Conversion")), casts ([¬ß5.5.2](jls-5.html#jls-5.5.2 "5.5.2. Checked Casts and Unchecked Casts")), method declarations ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"), [¬ß8.4.8.3](jls-8.html#jls-8.4.8.3 "8.4.8.3. Requirements in Overriding and Hiding"), [¬ß8.4.8.4](jls-8.html#jls-8.4.8.4 "8.4.8.4. Inheriting Methods with Override-Equivalent Signatures"), [¬ß9.4.1.2](jls-9.html#jls-9.4.1.2 "9.4.1.2. Requirements in Overriding")), and variable arity method invocations ([¬ß15.12.4.2](jls-15.html#jls-15.12.4.2 "15.12.4.2. Evaluate Arguments")).

The warnings here cover the case where a legacy consumer uses a generified library. For example, the library declares a generic class `Foo<T extends String>` that has a field `f` of type `Vector<T>`, but the consumer assigns a vector of integers to `e``.``f` where `e` has the raw type `Foo`. The legacy consumer receives a warning because it may have caused heap pollution ([¬ß4.12.2](jls-4.html#jls-4.12.2 "4.12.2. Variables of Reference Type")) for generified consumers of the generified library.

(Note that the legacy consumer can assign a `Vector<String>` from the library to its own `Vector` variable without receiving a warning. That is, the subtyping rules ([¬ß4.10.2](jls-4.html#jls-4.10.2 "4.10.2. Subtyping among Class and Interface Types")) of the Java programming language make it possible for a variable of a raw type to be assigned a value of any of the type's parameterized instances.)

The warnings from unchecked conversion cover the dual case, where a generified consumer uses a legacy library. For example, a method of the library has the raw return type `Vector`, but the consumer assigns the result of the method invocation to a variable of type `Vector<String>`. This is unsafe, since the raw vector might have had a different element type than `String`, but is still permitted using unchecked conversion in order to enable interfacing with legacy code. The warning from unchecked conversion indicates that the generified consumer may experience problems from heap pollution at other points in the program.

**Example 4.8-1. Raw Types**

class Cell<E> {
    E value;

    Cell(E v)     { value = v; }
    E get()       { return value; }
    void set(E v) { value = v; }

    public static void main(String\[\] args) {
        Cell x = new Cell<String>("abc");
        System.out.println(x.value);  // OK, has type Object
        System.out.println(x.get());  // OK, has type Object
        x.set("def");                 // unchecked warning
    }
}

  

**Example 4.8-2. Raw Types and Inheritance**

import java.util.\*;
class NonGeneric {
    Collection<Number> myNumbers() { return null; }
}

abstract class RawMembers<T> extends NonGeneric
                             implements Collection<String> {
    static Collection<NonGeneric> cng =
        new ArrayList<NonGeneric>();

    public static void main(String\[\] args) {
        RawMembers rw = null;
        Collection<Number> cn = rw.myNumbers();
                              // OK
        Iterator<String> is = rw.iterator();
                            // Unchecked warning
        Collection<NonGeneric> cnn = rw.cng;
                                   // OK, static member
    }
}

In this program (which is not meant to be run), `RawMembers<T>` inherits the method:

Iterator<String> iterator()

from the `Collection<String>` superinterface. The raw type `RawMembers` inherits `iterator()` from `Collection`, the erasure of `Collection<String>`, which means that the return type of `iterator()` in `RawMembers` is `Iterator`. As a result, the attempt to assign `rw.iterator()` to `Iterator<String>` requires an unchecked conversion, so a compile-time unchecked warning is issued.

In contrast, `RawMembers` inherits `myNumbers()` from the `NonGeneric` class whose erasure is also `NonGeneric`. Thus, the return type of `myNumbers()` in `RawMembers` is not erased, and the attempt to assign `rw.myNumbers()` to `Collection<Number>` requires no unchecked conversion, so no compile-time unchecked warning is issued.

Similarly, the `static` member `cng` retains its parameterized type even when accessed through a object of raw type. Note that access to a `static` member through an instance is considered bad style and is discouraged.

This example reveals that certain members of a raw type are not erased, namely `static` members whose types are parameterized, and members inherited from a non-generic supertype.

  

Raw types are closely related to wildcards. Both are based on existential types. Raw types can be thought of as wildcards whose type rules are deliberately unsound, to accommodate interaction with legacy code. Historically, raw types preceded wildcards; they were first introduced in GJ, and described in the paper _Making the future safe for the past: Adding Genericity to the Java Programming Language_ by Gilad Bracha, Martin Odersky, David Stoutamire, and Philip Wadler, in _Proceedings of the ACM Conference on Object-Oriented Programming, Systems, Languages and Applications (OOPSLA 98)_, October 1998.

4.9. Intersection Types
-----------------------

An intersection type takes the form T1 `&` ... `&` Tn (_n_ > 0), where Ti (1 ‚â§ _i_ ‚â§ _n_) are types.

Intersection types can be derived from type parameter bounds ([¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables")) and cast expressions ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")); they also arise in the processes of capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")) and least upper bound computation ([¬ß4.10.4](jls-4.html#jls-4.10.4 "4.10.4. Least Upper Bound")).

The values of an intersection type are those objects that are values of all of the types Ti for 1 ‚â§ _i_ ‚â§ _n_.

Every intersection type T1 `&` ... `&` Tn _induces_ a notional class or interface for the purpose of identifying the members of the intersection type, as follows:

*   For each Ti (1 ‚â§ _i_ ‚â§ _n_), let Ci be the most specific class or array type such that Ti `<:` Ci. Then there must be some Ck such that Ck `<:` Ci for any _i_ (1 ‚â§ _i_ ‚â§ _n_), or a compile-time error occurs.
*   For 1 ‚â§ _j_ ‚â§ _n_, if Tj is a type variable, then let Tj' be an interface whose members are the same as the `public` members of Tj; otherwise, if Tj is an interface, then let Tj' be Tj.
*   If Ck is `Object`, a notional interface is induced; otherwise, a notional class is induced with direct superclass Ck. This class or interface has direct superinterfaces T1', ..., Tn' and is declared in the package in which the intersection type appears.
    

The members of an intersection type are the members of the class or interface it induces.

It is worth dwelling upon the distinction between intersection types and the bounds of type variables. Every type variable bound induces an intersection type. This intersection type is often trivial, consisting of a single type. The form of a bound is restricted (only the first element may be a class or type variable, and only one type variable may appear in the bound) to preclude certain awkward situations coming into existence. However, capture conversion can lead to the creation of type variables whose bounds are more general, such as array types).

4.10. Subtyping
---------------

The subtype and supertype relations are binary relations on types.

The _supertypes_ of a type are obtained by reflexive and transitive closure over the direct supertype relation, written S `>1` T, which is defined by rules given later in this section. We write S `:>` T to indicate that the supertype relation holds between S and T.

S is a _proper supertype_</span> of T, written S `>` T, if S `:>` T and S ‚â† T.

The _subtypes_ of a type T are all types U such that T is a supertype of U, and the null type. We write T `<:` S to indicate that that the subtype relation holds between types T and S.

T is a _proper subtype_ of S, written T `<` S, if T `<:` S and S ‚â† T.

T is a _direct subtype_ of S, written T `<1` S, if S `>1` T.

Subtyping does not extend through parameterized types: T `<:` S does not imply that C`<`T`>` `<:` C`<`S`>`.

### 4.10.1. Subtyping among Primitive Types

The following rules define the direct supertype relation among the primitive types:

*   `double` `>1` `float`
*   `float` `>1` `long`
*   `long` `>1` `int`
*   `int` `>1` `char`
*   `int` `>1` `short`
*   `short` `>1` `byte`
    

### 4.10.2. Subtyping among Class and Interface Types

Given a non-generic type declaration C, the _direct supertypes_ of the type C are all of the following:

*   The direct superclass of C ([¬ß8.1.4](jls-8.html#jls-8.1.4 "8.1.4. Superclasses and Subclasses")).
*   The direct superinterfaces of C ([¬ß8.1.5](jls-8.html#jls-8.1.5 "8.1.5. Superinterfaces")).
*   The type `Object`, if C is an interface type with no direct superinterfaces ([¬ß9.1.3](jls-9.html#jls-9.1.3 "9.1.3. Superinterfaces and Subinterfaces")).
    

Given a generic type declaration C`<`F1,...,Fn`>` (_n_ > 0), the _direct supertypes_ of the raw type C ([¬ß4.8](jls-4.html#jls-4.8 "4.8. Raw Types")) are all of the following:

*   The direct superclass of the raw type C.
*   The direct superinterfaces of the raw type C.
*   The type `Object`, if C`<`F1,...,Fn`>` is a generic interface type with no direct superinterfaces ([¬ß9.1.2](jls-9.html#jls-9.1.2 "9.1.2. Generic Interfaces and Type Parameters")).
    

Given a generic type declaration C`<`F1,...,Fn`>` (_n_ > 0), the _direct supertypes_ of the generic type C`<`F1,...,Fn`>` are all of the following:

*   The direct superclass of C`<`F1,...,Fn`>`.
*   The direct superinterfaces of C`<`F1,...,Fn`>`.
*   The type `Object`, if C`<`F1,...,Fn`>` is a generic interface type with no direct superinterfaces.
*   The raw type C.
    

Given a generic type declaration C`<`F1,...,Fn`>` (_n_ > 0), the _direct supertypes_ of the parameterized type C`<`T1,...,Tn`>`, where Ti (1 ‚â§ _i_ ‚â§ _n_) is a type, are all of the following:

*   D`<`U1 Œ∏,...,Uk Œ∏`>`, where D`<`U1,...,Uk`>` is a generic type which is a direct supertype of the generic type C`<`T1,...,Tn`>` and Œ∏ is the substitution `[F1:=T1,...,Fn:=Tn]`.
*   C`<`S1,...,Sn`>`, where Si contains Ti (1 ‚â§ _i_ ‚â§ _n_) ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")).
*   The type `Object`, if C<F1,...,Fn\> is a generic interface type with no direct superinterfaces.
*   The raw type C.
    

Given a generic type declaration C`<`F1,...,Fn`>` (_n_ > 0), the _direct supertypes_ of the parameterized type C`<`R1,...,Rn`>` where at least one of the Ri (1 ‚â§ _i_ ‚â§ _n_) is a wildcard type argument, are the direct supertypes of the parameterized type C`<`X1,...,Xn`>` which is the result of applying capture conversion to C`<`R1,...,Rn`>` ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")).

The direct supertypes of an intersection type T1 `&` ... `&` Tn are Ti (1 ‚â§ _i_ ‚â§ _n_).

The direct supertypes of a type variable are the types listed in its bound.

A type variable is a direct supertype of its lower bound.

The direct supertypes of the null type are all reference types other than the null type itself.

### 4.10.3. Subtyping among Array Types

The following rules define the direct supertype relation among array types:

*   If S and T are both reference types, then S`[]` `>1` T`[]` iff S `>1` T.
*   `Object` `>1` `Object``[]`
*   `Cloneable` `>1` `Object``[]`
*   `java.io.Serializable` `>1` `Object``[]`
*   If P is a primitive type, then:
    
    *   `Object` `>1` P`[]`
        
    *   `Cloneable` `>1` P`[]`
        
    *   `java.io.Serializable` `>1` P`[]`
        
    

### 4.10.4. Least Upper Bound

The _least upper bound_, or "lub", of a set of reference types is a shared supertype that is more specific than any other shared supertype (that is, no other shared supertype is a subtype of the least upper bound). This type, lub(U1, ..., Uk), is determined as follows.

If _k_ = 1, then the lub is the type itself: lub(U) = U.

Otherwise:

*   For each Ui (1 ‚â§ _i_ ‚â§ _k_):
    
    Let ST(Ui) be the set of supertypes of Ui.
    
    Let EST(Ui), the set of erased supertypes of Ui, be:
    
    EST(Ui) = { |W| | W in ST(Ui) } where |W| is the erasure of W.
    
    The reason for computing the set of erased supertypes is to deal with situations where the set of types includes several distinct parameterizations of a generic type.
    
    For example, given `` List`<`String`>` `` and `` List`<`Object`>` ``, simply intersecting the sets ST(`` List`<`String`>` ``) = { `` List`<`String`>` ``, `` Collection`<`String`>` ``, `Object` } and ST(`` List`<`Object`>` ``) = { `` List`<`Object`>` ``, `` Collection`<`Object`>` ``, `Object` } would yield a set { `Object` }, and we would have lost track of the fact that the upper bound can safely be assumed to be a `List`.
    
    In contrast, intersecting EST(`` List`<`String`>` ``) = { `List`, `Collection`, `Object` } and EST(`` List`<`Object`>` ``) = { `List`, `Collection`, `Object` } yields { `List`, `Collection`, `Object` }, which will eventually enable us to produce `` List`<`?`>` ``.
*   Let EC, the erased candidate set for U1 ... Uk, be the intersection of all the sets EST(Ui) (1 ‚â§ _i_ ‚â§ _k_).
*   Let MEC, the minimal erased candidate set for U1 ... Uk, be:
    
    MEC = { V | V in EC, and for all W ‚â† V in EC, it is not the case that W `<:` V }
    
    Because we are seeking to infer more precise types, we wish to filter out any candidates that are supertypes of other candidates. This is what computing MEC accomplishes. In our running example, we had EC = { `List`, `Collection`, `Object` }, so MEC = { `List` }. The next step is to recover type arguments for the erased types in MEC.
*   For any element G of MEC that is a generic type:
    
    Let the "relevant" parameterizations of G, Relevant(G), be:
    
    Relevant(G) = { V | 1 ‚â§ _i_ ‚â§ _k_: V in ST(Ui) and V = G`<`...`>` }
    
    In our running example, the only generic element of MEC is `List`, and Relevant(`List`) = { `` List`<`String`>` ``, `` List`<`Object`>` `` }. We will now seek to find a type argument for `List` that contains ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")) both `String` and `Object`.
    
    This is done by means of the least containing parameterization (lcp) operation defined below. The first line defines lcp() on a set, such as Relevant(`List`), as an operation on a list of the elements of the set. The next line defines the operation on such lists, as a pairwise reduction on the elements of the list. The third line is the definition of lcp() on pairs of parameterized types, which in turn relies on the notion of least containing type argument (lcta). lcta() is defined for all possible cases.
    
    Let the "candidate" parameterization of G, Candidate(G), be the most specific parameterization of the generic type G that contains all the relevant parameterizations of G:
    
    Candidate(G) = lcp(Relevant(G))
    
    where lcp(), the least containing invocation, is:
    
    *   lcp(S) = lcp(`e1`, ..., `en`) where `ei` (1 ‚â§ _i_ ‚â§ _n_) in S
        
    *   lcp(`e1`, ..., `en`) = lcp(lcp(`e1`, `e2`), `e3`, ..., `en`)
        
    *   lcp(G`<`X1, ..., Xn`>`, G`<`Y1, ..., Yn`>`) = G`<`lcta(X1, Y1), ..., lcta(Xn, Yn)`>`
        
    *   lcp(G`<`X1, ..., Xn`>`) = G`<`lcta(X1), ..., lcta(Xn)`>`
        
    
    and where lcta(), the least containing type argument, is: (assuming U and V are types)
    
    *   lcta(U, V) = U if U = V, otherwise `?` `extends` lub(U, V)
        
    *   lcta(U, `?` `extends` V) = `?` `extends` lub(U, V)
        
    *   lcta(U, `?` `super` V) = `?` `super` glb(U, V)
        
    *   lcta(`?` `extends` U, `?` `extends` V) = `?` `extends` lub(U, V)
        
    *   lcta(`?` `extends` U, `?` `super` V) = U if U = V, otherwise `?`
        
    *   lcta(`?` `super` U, `?` `super` V) = `?` `super` glb(U, V)
        
    *   lcta(U) = `?` if U's upper bound is `Object`, otherwise `?` `extends` lub(U,`Object`)
        
    
    and where glb() is as defined in [¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion").
*   Let lub(U1 ... Uk) be:
    
    Best(W1) `&` ... `&` Best(Wr)
    
    where Wi (1 ‚â§ _i_ ‚â§ _r_) are the elements of MEC, the minimal erased candidate set of U1 ... Uk;
    
    and where, if any of these elements are generic, we use the candidate parameterization (so as to recover type arguments):
    
    Best(X) = Candidate(X) if X is generic; X otherwise.
    

Strictly speaking, this lub() function only approximates a least upper bound. Formally, there may exist some other type T such that all of U1 ... Uk are subtypes of T and T is a subtype of lub(U1, ..., Uk). However, a compiler for the Java programming language must implement lub() as specified above.

It is possible that the lub() function yields an infinite type. This is permissible, and a compiler for the Java programming language must recognize such situations and represent them appropriately using cyclic data structures.

The possibility of an infinite type stems from the recursive calls to lub(). Readers familiar with recursive types should note that an infinite type is not the same as a recursive type.

4.11. Where Types Are Used
--------------------------

Types are used in most kinds of declaration and in certain kinds of expression. Specifically, there are 16 _type contexts_ where types are used:

*   In declarations:
    
    1.  A type in the `extends` or `implements` clause of a class declaration ([¬ß8.1.4](jls-8.html#jls-8.1.4 "8.1.4. Superclasses and Subclasses"), [¬ß8.1.5](jls-8.html#jls-8.1.5 "8.1.5. Superinterfaces"), [¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations"))
        
    2.  A type in the `extends` clause of an interface declaration ([¬ß9.1.3](jls-9.html#jls-9.1.3 "9.1.3. Superinterfaces and Subinterfaces"), [¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations"))
        
    3.  The return type of a method (including the type of an element of an annotation type) ([¬ß8.4.5](jls-8.html#jls-8.4.5 "8.4.5. Method Result"), [¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations"), [¬ß9.6.1](jls-9.html#jls-9.6.1 "9.6.1. Annotation Type Elements"))
        
    4.  A type in the `throws` clause of a method or constructor ([¬ß8.4.6](jls-8.html#jls-8.4.6 "8.4.6. Method Throws"), [¬ß8.8.5](jls-8.html#jls-8.8.5 "8.8.5. Constructor Throws"), [¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations"))
        
    5.  A type in the `extends` clause of a type parameter declaration of a generic class, interface, method, or constructor ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters"), [¬ß9.1.2](jls-9.html#jls-9.1.2 "9.1.2. Generic Interfaces and Type Parameters"), [¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods"), [¬ß8.8.4](jls-8.html#jls-8.8.4 "8.8.4. Generic Constructors"))
        
    6.  The type in a field declaration of a class or interface (including an enum constant) ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations"), [¬ß9.3](jls-9.html#jls-9.3 "9.3. Field (Constant) Declarations"), [¬ß8.9.1](jls-8.html#jls-8.9.1 "8.9.1. Enum Constants"))
        
    7.  The type in a formal parameter declaration of a method, constructor, or lambda expression ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"), [¬ß8.8.1](jls-8.html#jls-8.8.1 "8.8.1. Formal Parameters"), [¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations"), [¬ß15.27.1](jls-15.html#jls-15.27.1 "15.27.1. Lambda Parameters"))
        
    8.  The type of the receiver parameter of a method ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"))
        
    9.  The type in a local variable declaration ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements"), [¬ß14.14.1](jls-14.html#jls-14.14.1 "14.14.1. The basic for Statement"), [¬ß14.14.2](jls-14.html#jls-14.14.2 "14.14.2. The enhanced for statement"), [¬ß14.20.3](jls-14.html#jls-14.20.3 "14.20.3. try-with-resources"))
        
    10.  The type in an exception parameter declaration ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement"))
        
*   In expressions:
    
    11.  A type in the explicit type argument list to an explicit constructor invocation statement or class instance creation expression or method invocation expression ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations"), [¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions"), [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions"))
        
    12.  In an unqualified class instance creation expression, as the class type to be instantiated ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")) or as the direct superclass or direct superinterface of an anonymous class to be instantiated ([¬ß15.9.5](jls-15.html#jls-15.9.5 "15.9.5. Anonymous Class Declarations"))
        
    13.  The element type in an array creation expression ([¬ß15.10.1](jls-15.html#jls-15.10.1 "15.10.1. Array Creation Expressions"))
        
    14.  The type in the cast operator of a cast expression ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions"))
        
    15.  The type that follows the `instanceof` relational operator ([¬ß15.20.2](jls-15.html#jls-15.20.2 "15.20.2. Type Comparison Operator instanceof"))
        
    16.  In a method reference expression ([¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions")), as the reference type to search for a member method or as the class type or array type to construct.
        
    

Also, types are used as:

*   The element type of an array type in any of the above contexts; and
*   A non-wildcard type argument, or a bound of a wildcard type argument, of a parameterized type in any of the above contexts.
    

Finally, there are three special terms in the Java programming language which denote the use of a type:

*   An unbounded wildcard ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types"))
*   The `...` in the type of a variable arity parameter ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters")), to indicate an array type
*   The simple name of a type in a constructor declaration ([¬ß8.8](jls-8.html#jls-8.8 "8.8. Constructor Declarations")), to indicate the class of the constructed object
    

The meaning of types in type contexts is given by:

*   [¬ß4.2](jls-4.html#jls-4.2 "4.2. Primitive Types and Values"), for primitive types
*   [¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables"), for type parameters
*   [¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types"), for class and interface types that are parameterized, or appear either as type arguments in a parameterized type or as bounds of wildcard type arguments in a parameterized type
*   [¬ß4.8](jls-4.html#jls-4.8 "4.8. Raw Types"), for class and interface types that are raw
*   [¬ß4.9](jls-4.html#jls-4.9 "4.9. Intersection Types"), for intersection types in the bounds of type parameters
*   [¬ß6.5](jls-6.html#jls-6.5 "6.5. Determining the Meaning of a Name"), for class and interface types in contexts where genericity is unimportant ([¬ß6.1](jls-6.html#jls-6.1 "6.1. Declarations"))
*   [¬ß10.1](jls-10.html#jls-10.1 "10.1. Array Types"), for array types
    

Some type contexts restrict how a reference type may be parameterized:

*   The following type contexts require that if a type is a parameterized reference type, it has no wildcard type arguments:
    
    *   In an `extends` or `implements` clause of a class declaration ([¬ß8.1.4](jls-8.html#jls-8.1.4 "8.1.4. Superclasses and Subclasses"), [¬ß8.1.5](jls-8.html#jls-8.1.5 "8.1.5. Superinterfaces"))
        
    *   In an `extends` clause of an interface declaration ([¬ß9.1.3](jls-9.html#jls-9.1.3 "9.1.3. Superinterfaces and Subinterfaces"))
        
    *   In an unqualified class instance creation expression, as the class type to be instantiated ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")) or as the direct superclass or direct superinterface of an anonymous class to be instantiated ([¬ß15.9.5](jls-15.html#jls-15.9.5 "15.9.5. Anonymous Class Declarations"))In a method reference expression ([¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions")), as the reference type to search for a member method or as the class type or array type to construct.

In addition, no wildcard type arguments are permitted in the explicit type argument list to an explicit constructor invocation statement or class instance creation expression or method invocation expression or method reference expression ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations"), [¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions"), [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions"), [¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions")).

*   The following type contexts require that if a type is a parameterized reference type, it has only unbounded wildcard type arguments (i.e. it is a reifiable type) :
    
    *   As the element type in an array creation expression ([¬ß15.10.1](jls-15.html#jls-15.10.1 "15.10.1. Array Creation Expressions"))
        
    *   As the type that follows the `instanceof` relational operator ([¬ß15.20.2](jls-15.html#jls-15.20.2 "15.20.2. Type Comparison Operator instanceof"))
        
*   The following type contexts disallow a parameterized reference type altogether, because they involve exceptions and the type of an exception is non-generic ([¬ß6.1](jls-6.html#jls-6.1 "6.1. Declarations")):
    
    *   As the type of an exception that can be thrown by a method or constructor ([¬ß8.4.6](jls-8.html#jls-8.4.6 "8.4.6. Method Throws"), [¬ß8.8.5](jls-8.html#jls-8.8.5 "8.8.5. Constructor Throws"), [¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations"))
        
    *   In an exception parameter declaration ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement"))
        
    

In any type context where a type is used, it is possible to annotate the keyword denoting a primitive type or the _Identifier_ denoting the simple name of a reference type. It is also possible to annotate an array type by writing an annotation to the left of the `[` at the desired level of nesting in the array type. Annotations in these locations are called _type annotations_, and are specified in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear"). Here are some examples:

*   `@Foo int[] f;` annotates the primitive type `int`
*   `int @Foo [] f;` annotates the array type `int``[]`
*   `int @Foo [][] f;` annotates the array type `int``[]``[]`
*   `int[] @Foo [] f;` annotates the array type `int``[]` which is the component type of the array type `int``[]``[]`
    

Five of the _type contexts_ which appear in declarations occupy the same syntactic real estate as a number of _declaration contexts_ ([¬ß9.6.4.1](jls-9.html#jls-9.6.4.1 "9.6.4.1. @Target")):

*   The return type of a method (including the type of an element of an annotation type)
*   The type in a field declaration of a class or interface (including an enum constant)
*   The type in a formal parameter declaration of a method, constructor, or lambda expression
*   The type in a local variable declaration
*   The type in an exception parameter declaration
    

The fact that the same syntactic location in a program can be both a type context and a declaration context arises because the modifiers for a declaration immediately precede the type of the declared entity. [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear") explains how an annotation in such a location is deemed to appear in a type context or a declaration context or both.

**Example 4.11-1. Usage of a Type**

import java.util.Random;
import java.util.Collection;
import java.util.ArrayList;

class MiscMath<T extends Number> {
    int divisor;
    MiscMath(int divisor) { this.divisor = divisor; }
    float ratio(long l) {
        try {
            l /= divisor;
        } catch (Exception e) {
            if (e instanceof ArithmeticException)
                l = Long.MAX\_VALUE;
            else
                l = 0;
        }
        return (float)l;
    }
    double gausser() {
        Random r = new Random();
        double\[\] val = new double\[2\];
        val\[0\] = r.nextGaussian();
        val\[1\] = r.nextGaussian();
        return (val\[0\] + val\[1\]) / 2;
    }
    Collection<Number> fromArray(Number\[\] na) {
        Collection<Number> cn = new ArrayList<Number>();
        for (Number n : na) cn.add(n);
        return cn;
    }
    <S> void loop(S s) { this.<S>loop(s); }  
}

In this example, types are used in declarations of the following:

*   Imported types ([¬ß7.5](jls-7.html#jls-7.5 "7.5. Import Declarations")); here the type `Random`, imported from the type `java.util.Random` of the package `java.util`, is declared
*   Fields, which are the class variables and instance variables of classes ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations")), and constants of interfaces ([¬ß9.3](jls-9.html#jls-9.3 "9.3. Field (Constant) Declarations")); here the field `divisor` in the class `MiscMath` is declared to be of type `int`
*   Method parameters ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters")); here the parameter `l` of the method `ratio` is declared to be of type `long`
*   Method results ([¬ß8.4](jls-8.html#jls-8.4 "8.4. Method Declarations")); here the result of the method `ratio` is declared to be of type `float`, and the result of the method `gausser` is declared to be of type `double`
*   Constructor parameters ([¬ß8.8.1](jls-8.html#jls-8.8.1 "8.8.1. Formal Parameters")); here the parameter of the constructor for `MiscMath` is declared to be of type `int`
*   Local variables ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements"), [¬ß14.14](jls-14.html#jls-14.14 "14.14. The for Statement")); the local variables `r` and `val` of the method `gausser` are declared to be of types `Random` and `double``[]` (array of `double`)
*   Exception parameters ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")); here the exception parameter `e` of the `catch` clause is declared to be of type `Exception`
*   Type parameters ([¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables")); here the type parameter of `MiscMath` is a type variable `T` with the type `Number` as its declared bound
*   In any declaration that uses a parameterized type; here the type `Number` is used as a type argument ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")) in the parameterized type `Collection<Number>`.
    

and in expressions of the following kinds:

*   Class instance creations ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")); here a local variable `r` of method `gausser` is initialized by a class instance creation expression that uses the type `Random`
*   Generic class ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters")) instance creations ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")); here `Number` is used as a type argument in the expression `new ArrayList<Number>()`
*   Array creations ([¬ß15.10.1](jls-15.html#jls-15.10.1 "15.10.1. Array Creation Expressions")); here the local variable `val` of method `gausser` is initialized by an array creation expression that creates an array of `double` with size 2
*   Generic method ([¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods")) or constructor ([¬ß8.8.4](jls-8.html#jls-8.8.4 "8.8.4. Generic Constructors")) invocations ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")); here the method `loop` calls itself with an explicit type argument `S`
*   Casts ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")); here the `return` statement of the method `ratio` uses the `float` type in a cast
*   The `instanceof` operator ([¬ß15.20.2](jls-15.html#jls-15.20.2 "15.20.2. Type Comparison Operator instanceof")); here the `instanceof` operator tests whether `e` is assignment-compatible with the type `ArithmeticException`
    

  

4.12. Variables
---------------

A variable is a storage location and has an associated type, sometimes called its _compile-time type_, that is either a primitive type ([¬ß4.2](jls-4.html#jls-4.2 "4.2. Primitive Types and Values")) or a reference type ([¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values")).

A variable's value is changed by an assignment ([¬ß15.26](jls-15.html#jls-15.26 "15.26. Assignment Operators")) or by a prefix or postfix `++` (increment) or `--` (decrement) operator ([¬ß15.14.2](jls-15.html#jls-15.14.2 "15.14.2. Postfix Increment Operator ++"), [¬ß15.14.3](jls-15.html#jls-15.14.3 "15.14.3. Postfix Decrement Operator --"), [¬ß15.15.1](jls-15.html#jls-15.15.1 "15.15.1. Prefix Increment Operator ++"), [¬ß15.15.2](jls-15.html#jls-15.15.2 "15.15.2. Prefix Decrement Operator --")).

Compatibility of the value of a variable with its type is guaranteed by the design of the Java programming language, as long as a program does not give rise to compile-time unchecked warnings ([¬ß4.12.2](jls-4.html#jls-4.12.2 "4.12.2. Variables of Reference Type")). Default values ([¬ß4.12.5](jls-4.html#jls-4.12.5 "4.12.5. Initial Values of Variables")) are compatible and all assignments to a variable are checked for assignment compatibility ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")), usually at compile time, but, in a single case involving arrays, a run-time check is made ([¬ß10.5](jls-10.html#jls-10.5 "10.5. Array Store Exception")).

### 4.12.1. Variables of Primitive Type

A variable of a primitive type always holds a primitive value of that exact primitive type.

### 4.12.2. Variables of Reference Type

A variable of a class type T can hold a null reference or a reference to an instance of class T or of any class that is a subclass of T.

A variable of an interface type can hold a null reference or a reference to any instance of any class that implements the interface.

Note that a variable is not guaranteed to always refer to a subtype of its declared type, but only to subclasses or subinterfaces of the declared type. This is due to the possibility of heap pollution discussed below.

If T is a primitive type, then a variable of type "array of T" can hold a null reference or a reference to any array of type "array of T".

If T is a reference type, then a variable of type "array of T" can hold a null reference or a reference to any array of type "array of S" such that type S is a subclass or subinterface of type T.

A variable of type `Object``[]` can hold a reference to an array of any reference type.

A variable of type `Object` can hold a null reference or a reference to any object, whether it is an instance of a class or an array.

It is possible that a variable of a parameterized type will refer to an object that is not of that parameterized type. This situation is known as _heap pollution_.

Heap pollution can only occur if the program performed some operation involving a raw type that would give rise to a compile-time unchecked warning ([¬ß4.8](jls-4.html#jls-4.8 "4.8. Raw Types"), [¬ß5.1.9](jls-5.html#jls-5.1.9 "5.1.9. Unchecked Conversion"), [¬ß5.5.2](jls-5.html#jls-5.5.2 "5.5.2. Checked Casts and Unchecked Casts"), [¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"), [¬ß8.4.8.3](jls-8.html#jls-8.4.8.3 "8.4.8.3. Requirements in Overriding and Hiding"), [¬ß8.4.8.4](jls-8.html#jls-8.4.8.4 "8.4.8.4. Inheriting Methods with Override-Equivalent Signatures"), [¬ß9.4.1.2](jls-9.html#jls-9.4.1.2 "9.4.1.2. Requirements in Overriding"), [¬ß15.12.4.2](jls-15.html#jls-15.12.4.2 "15.12.4.2. Evaluate Arguments")), or if the program aliases an array variable of non-reifiable element type through an array variable of a supertype which is either raw or non-generic.

For example, the code:

List l = new ArrayList<Number>();
List<String> ls = l;  // Unchecked warning

gives rise to a compile-time unchecked warning, because it is not possible to ascertain, either at compile time (within the limits of the compile-time type checking rules) or at run time, whether the variable `l` does indeed refer to a `List<String>`.

If the code above is executed, heap pollution arises, as the variable `ls`, declared to be a `List<String>`, refers to a value that is not in fact a `List<String>`.

The problem cannot be identified at run time because type variables are not reified, and thus instances do not carry any information at run time regarding the type arguments used to create them.

In a simple example as given above, it may appear that it should be straightforward to identify the situation at compile time and give an error. However, in the general (and typical) case, the value of the variable `l` may be the result of an invocation of a separately compiled method, or its value may depend upon arbitrary control flow. The code above is therefore very atypical, and indeed very bad style.

Furthermore, the fact that `Object``[]` is a supertype of all array types means that unsafe aliasing can occur which leads to heap pollution. For example, the following code compiles because it is statically type-correct:

static void m(List<String>... stringLists) {
    Object\[\] array = stringLists;
    List<Integer> tmpList = Arrays.asList(42);
    array\[0\] = tmpList;                // (1)
    String s = stringLists\[0\].get(0);  // (2)
}

Heap pollution occurs at (1) because a component in the `stringLists` array that should refer to a `List<String>` now refers to a `List<Integer>`. There is no way to detect this pollution in the presence of both a universal supertype (`Object``[]`) and a non-reifiable type (the declared type of the formal parameter, `List<String>``[]`). No unchecked warning is justified at (1); nevertheless, at run time, a `ClassCastException` will occur at (2).

A compile-time unchecked warning will be given at any invocation of the method above because an invocation is considered by the Java programming language's static type system to create an array whose element type, `List<String>`, is non-reifiable ([¬ß15.12.4.2](jls-15.html#jls-15.12.4.2 "15.12.4.2. Evaluate Arguments")). _If and only if_ the body of the method was type-safe with respect to the variable arity parameter, then the programmer could use the `SafeVarargs` annotation to silence warnings at invocations ([¬ß9.6.4.7](jls-9.html#jls-9.6.4.7 "9.6.4.7. @SafeVarargs")). Since the body of the method as written above causes heap pollution, it would be completely inappropriate to use the annotation to disable warnings for callers.

Finally, note that the `stringLists` array could be aliased through variables of types other than `Object``[]`, and heap pollution could still occur. For example, the type of the `array` variable could be `java.util.Collection[]` - a raw element type - and the body of the method above would compile without warnings or errors and still cause heap pollution. And if the Java SE platform defined, say, `Sequence` as a non-generic supertype of `List<T>`, then using `Sequence` as the type of `array` would also cause heap pollution.

The variable will always refer to an object that is an instance of a class that represents the parameterized type.

The value of `ls` in the example above is always an instance of a class that provides a representation of a `List`.

Assignment from an expression of a raw type to a variable of a parameterized type should only be used when combining legacy code which does not make use of parameterized types with more modern code that does.

If no operation that requires a compile-time unchecked warning to be issued takes place, and no unsafe aliasing occurs of array variables with non-reifiable element types, then heap pollution cannot occur. Note that this does not imply that heap pollution only occurs if a compile-time unchecked warning actually occurred. It is possible to run a program where some of the binaries were produced by a compiler for an older version of the Java programming language, or from sources that explicitly suppressed unchecked warnings. This practice is unhealthy at best.

Conversely, it is possible that despite executing code that could (and perhaps did) give rise to a compile-time unchecked warning, no heap pollution takes place. Indeed, good programming practice requires that the programmer satisfy herself that despite any unchecked warning, the code is correct and heap pollution will not occur.

### 4.12.3. Kinds of Variables

There are eight kinds of variables:

1.  A _class variable_ is a field declared using the keyword `static` within a class declaration ([¬ß8.3.1.1](jls-8.html#jls-8.3.1.1 "8.3.1.1. static Fields")), or with or without the keyword `static` within an interface declaration ([¬ß9.3](jls-9.html#jls-9.3 "9.3. Field (Constant) Declarations")).
    
    A class variable is created when its class or interface is prepared ([¬ß12.3.2](jls-12.html#jls-12.3.2 "12.3.2. Preparation of a Class or Interface Type")) and is initialized to a default value ([¬ß4.12.5](jls-4.html#jls-4.12.5 "4.12.5. Initial Values of Variables")). The class variable effectively ceases to exist when its class or interface is unloaded ([¬ß12.7](jls-12.html#jls-12.7 "12.7. Unloading of Classes and Interfaces")).
    
2.  An _instance variable_ is a field declared within a class declaration without using the keyword `static` ([¬ß8.3.1.1](jls-8.html#jls-8.3.1.1 "8.3.1.1. static Fields")).
    
    If a class T has a field `a` that is an instance variable, then a new instance variable `a` is created and initialized to a default value ([¬ß4.12.5](jls-4.html#jls-4.12.5 "4.12.5. Initial Values of Variables")) as part of each newly created object of class T or of any class that is a subclass of T ([¬ß8.1.4](jls-8.html#jls-8.1.4 "8.1.4. Superclasses and Subclasses")). The instance variable effectively ceases to exist when the object of which it is a field is no longer referenced, after any necessary finalization of the object ([¬ß12.6](jls-12.html#jls-12.6 "12.6. Finalization of Class Instances")) has been completed.
    
3.  _Array components_ are unnamed variables that are created and initialized to default values ([¬ß4.12.5](jls-4.html#jls-4.12.5 "4.12.5. Initial Values of Variables")) whenever a new object that is an array is created ([¬ß10 (_Arrays_)](jls-10.html "Chapter 10. Arrays"), [¬ß15.10.2](jls-15.html#jls-15.10.2 "15.10.2. Run-Time Evaluation of Array Creation Expressions")). The array components effectively cease to exist when the array is no longer referenced.
    
4.  _Method parameters_ ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters")) name argument values passed to a method.
    
    For every parameter declared in a method declaration, a new parameter variable is created each time that method is invoked ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")). The new variable is initialized with the corresponding argument value from the method invocation. The method parameter effectively ceases to exist when the execution of the body of the method is complete.
    
5.  _Constructor parameters_ ([¬ß8.8.1](jls-8.html#jls-8.8.1 "8.8.1. Formal Parameters")) name argument values passed to a constructor.
    
    For every parameter declared in a constructor declaration, a new parameter variable is created each time a class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")) or explicit constructor invocation ([¬ß8.8.7](jls-8.html#jls-8.8.7 "8.8.7. Constructor Body")) invokes that constructor. The new variable is initialized with the corresponding argument value from the creation expression or constructor invocation. The constructor parameter effectively ceases to exist when the execution of the body of the constructor is complete.
    
6.  _Lambda parameters_ ([¬ß15.27.1](jls-15.html#jls-15.27.1 "15.27.1. Lambda Parameters")) name argument values passed to a lambda expression body ([¬ß15.27.2](jls-15.html#jls-15.27.2 "15.27.2. Lambda Body")).
    
    For every parameter declared in a lambda expression, a new parameter variable is created each time a method implemented by the lambda body is invoked ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")). The new variable is initialized with the corresponding argument value from the method invocation. The lambda parameter effectively ceases to exist when the execution of the lambda expression body is complete.
    
7.  An _exception parameter_ is created each time an exception is caught by a `catch` clause of a `try` statement ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")).
    
    The new variable is initialized with the actual object associated with the exception ([¬ß11.3](jls-11.html#jls-11.3 "11.3. Run-Time Handling of an Exception"), [¬ß14.18](jls-14.html#jls-14.18 "14.18. The throw Statement")). The exception parameter effectively ceases to exist when execution of the block associated with the `catch` clause is complete.
    
8.  _Local variables_ are declared by local variable declaration statements ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements")).
    
    Whenever the flow of control enters a block ([¬ß14.2](jls-14.html#jls-14.2 "14.2. Blocks")) or `for` statement ([¬ß14.14](jls-14.html#jls-14.14 "14.14. The for Statement")), a new variable is created for each local variable declared in a local variable declaration statement immediately contained within that block or `for` statement.
    
    A local variable declaration statement may contain an expression which initializes the variable. The local variable with an initializing expression is not initialized, however, until the local variable declaration statement that declares it is executed. (The rules of definite assignment ([¬ß16 (_Definite Assignment_)](jls-16.html "Chapter 16. Definite Assignment")) prevent the value of a local variable from being used before it has been initialized or otherwise assigned a value.) The local variable effectively ceases to exist when the execution of the block or for statement is complete.
    
    Were it not for one exceptional situation, a local variable could always be regarded as being created when its local variable declaration statement is executed. The exceptional situation involves the `switch` statement ([¬ß14.11](jls-14.html#jls-14.11 "14.11. The switch Statement")), where it is possible for control to enter a block but bypass execution of a local variable declaration statement. Because of the restrictions imposed by the rules of definite assignment ([¬ß16 (_Definite Assignment_)](jls-16.html "Chapter 16. Definite Assignment")), however, the local variable declared by such a bypassed local variable declaration statement cannot be used before it has been definitely assigned a value by an assignment expression ([¬ß15.26](jls-15.html#jls-15.26 "15.26. Assignment Operators")).
    

**Example 4.12.3-1. Different Kinds of Variables**

class Point {
    static int numPoints;   // numPoints is a class variable
    int x, y;               // x and y are instance variables
    int\[\] w = new int\[10\];  // w\[0\] is an array component
    int setX(int x) {       // x is a method parameter
        int oldx = this.x;  // oldx is a local variable
        this.x = x;
        return oldx;
    }
}

  

### 4.12.4. `final` Variables

A variable can be declared `final`. A `final` variable may only be assigned to once. It is a compile-time error if a `final` variable is assigned to unless it is definitely unassigned immediately prior to the assignment ([¬ß16 (_Definite Assignment_)](jls-16.html "Chapter 16. Definite Assignment")).

Once a `final` variable has been assigned, it always contains the same value. If a `final` variable holds a reference to an object, then the state of the object may be changed by operations on the object, but the variable will always refer to the same object. This applies also to arrays, because arrays are objects; if a `final` variable holds a reference to an array, then the components of the array may be changed by operations on the array, but the variable will always refer to the same array.

A _blank `final`_ is a `final` variable whose declaration lacks an initializer.

A _constant variable_ is a `final` variable of primitive type or type `String` that is initialized with a constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")). Whether a variable is a constant variable or not may have implications with respect to class initialization ([¬ß12.4.1](jls-12.html#jls-12.4.1 "12.4.1. When Initialization Occurs")), binary compatibility ([¬ß13.1](jls-13.html#jls-13.1 "13.1. The Form of a Binary"), [¬ß13.4.9](jls-13.html#jls-13.4.9 "13.4.9. final Fields and static Constant Variables")), and definite assignment ([¬ß16 (_Definite Assignment_)](jls-16.html "Chapter 16. Definite Assignment")).

Three kinds of variable are implicitly declared `final`: a field of an interface ([¬ß9.3](jls-9.html#jls-9.3 "9.3. Field (Constant) Declarations")), a local variable which is a resource of a `try`\-with-resources statement ([¬ß14.20.3](jls-14.html#jls-14.20.3 "14.20.3. try-with-resources")), and an exception parameter of a multi-`catch` clause ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")). An exception parameter of a uni-`catch` clause is never implicitly declared `final`, but may be effectively final.

**Example 4.12.4-1. Final Variables**

Declaring a variable `final` can serve as useful documentation that its value will not change and can help avoid programming errors. In this program:

class Point {
    int x, y;
    int useCount;
    Point(int x, int y) { this.x = x; this.y = y; }
    static final Point origin = new Point(0, 0);
}

the class `Point` declares a `final` class variable `origin`. The `origin` variable holds a reference to an object that is an instance of class `Point` whose coordinates are (0, 0). The value of the variable `Point.origin` can never change, so it always refers to the same `Point` object, the one created by its initializer. However, an operation on this `Point` object might change its state - for example, modifying its `useCount` or even, misleadingly, its `x` or `y` coordinate.

  

Certain variables that are not declared `final` are instead considered _effectively final_:

*   A local variable whose declarator has an initializer ([¬ß14.4.2](jls-14.html#jls-14.4.2 "14.4.2. Execution of Local Variable Declarations")) is _effectively final_ if all of the following are true:
    
    *   It is not declared `final`.
        
    *   It never occurs as the left hand side in an assignment expression ([¬ß15.26](jls-15.html#jls-15.26 "15.26. Assignment Operators")). (Note that the local variable declarator containing the initializer is _not_ an assignment expression.)
        
    *   It never occurs as the operand of a prefix or postfix increment or decrement operator ([¬ß15.14](jls-15.html#jls-15.14 "15.14. Postfix Expressions"), [¬ß15.15](jls-15.html#jls-15.15 "15.15. Unary Operators")).
        
*   A local variable whose declarator lacks an initializer is _effectively final_ if all of the following are true:
    
    *   It is not declared `final`.
        
    *   Whenever it occurs as the left hand side in an assignment expression, it is definitely unassigned and not definitely assigned before the assignment; that is, it is definitely unassigned and not definitely assigned after the right hand side of the assignment expression ([¬ß16 (_Definite Assignment_)](jls-16.html "Chapter 16. Definite Assignment")).
        
    *   It never occurs as the operand of a prefix or postfix increment or decrement operator.
        
*   A method, constructor, lambda, or exception parameter ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"), [¬ß8.8.1](jls-8.html#jls-8.8.1 "8.8.1. Formal Parameters"), [¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations"), [¬ß15.27.1](jls-15.html#jls-15.27.1 "15.27.1. Lambda Parameters"), [¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) is treated, for the purpose of determining whether it is _effectively final_, as a local variable whose declarator has an initializer.
    

If a variable is effectively final, adding the `final` modifier to its declaration will not introduce any compile-time errors. Conversely, a local variable or parameter that is declared `final` in a valid program becomes effectively final if the `final` modifier is removed.

### 4.12.5. Initial Values of Variables

Every variable in a program must have a value before its value is used:

*   Each class variable, instance variable, or array component is initialized with a _default value_ when it is created ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions"), [¬ß15.10.2](jls-15.html#jls-15.10.2 "15.10.2. Run-Time Evaluation of Array Creation Expressions")):
    
    *   For type `byte`, the default value is zero, that is, the value of `(byte)0`.norm-dynamic"> For type `short`, the default value is zero, that is, the value of `(short)0`.

*   For type `int`, the default value is zero, that is, `0`.
*   For type `long`, the default value is zero, that is, `0L`.
*   For type `float`, the default value is positive zero, that is, `0.0f`.
*   For type `double`, the default value is positive zero, that is, `0.0d`.
*   For type `char`, the default value is the null character, that is, `'\u0000'`.
*   For type `boolean`, the default value is `false`.
*   For all reference types ([¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values")), the default value is `null`.
*   Each method parameter ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters")) is initialized to the corresponding argument value provided by the invoker of the method ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")).
*   Each constructor parameter ([¬ß8.8.1](jls-8.html#jls-8.8.1 "8.8.1. Formal Parameters")) is initialized to the corresponding argument value provided by a class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")) or explicit constructor invocation ([¬ß8.8.7](jls-8.html#jls-8.8.7 "8.8.7. Constructor Body")).
*   An exception parameter ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) is initialized to the thrown object representing the exception ([¬ß11.3](jls-11.html#jls-11.3 "11.3. Run-Time Handling of an Exception"), [¬ß14.18](jls-14.html#jls-14.18 "14.18. The throw Statement")).
*   A local variable ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements"), [¬ß14.14](jls-14.html#jls-14.14 "14.14. The for Statement")) must be explicitly given a value before it is used, by either initialization ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements")) or assignment ([¬ß15.26](jls-15.html#jls-15.26 "15.26. Assignment Operators")), in a way that can be verified using the rules for definite assignment ([¬ß16 (_Definite Assignment_)](jls-16.html "Chapter 16. Definite Assignment")).
    

**Example 4.12.5-1. Initial Values of Variables**

class Point {
    static int npoints;
    int x, y;
    Point root;
}

class Test {
    public static void main(String\[\] args) {
        System.out.println("npoints=" + Point.npoints);
        Point p = new Point();
        System.out.println("p.x=" + p.x + ", p.y=" + p.y);
        System.out.println("p.root=" + p.root);
    }
}

This program prints:

npoints=0
p.x=0, p.y=0
p.root=null

illustrating the default initialization of `npoints`, which occurs when the class `Point` is prepared ([¬ß12.3.2](jls-12.html#jls-12.3.2 "12.3.2. Preparation of a Class or Interface Type")), and the default initialization of `x`, `y`, and `root`, which occurs when a new `Point` is instantiated. See [¬ß12 (_Execution_)](jls-12.html "Chapter 12. Execution") for a full description of all aspects of loading, linking, and initialization of classes and interfaces, plus a description of the instantiation of classes to make new class instances.

  

### 4.12.6. Types, Classes, and Interfaces

In the Java programming language, every variable and every expression has a type that can be determined at compile time. The type may be a primitive type or a reference type. Reference types include class types and interface types. Reference types are introduced by _type declarations_, which include class declarations ([¬ß8.1](jls-8.html#jls-8.1 "8.1. Class Declarations")) and interface declarations ([¬ß9.1](jls-9.html#jls-9.1 "9.1. Interface Declarations")). We often use the term _type_ to refer to either a class or an interface.

In the Java Virtual Machine, every object belongs to some particular class: the class that was mentioned in the creation expression that produced the object ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")), or the class whose `Class` object was used to invoke a reflective method to produce the object, or the `String` class for objects implicitly created by the string concatenation operator `+` ([¬ß15.18.1](jls-15.html#jls-15.18.1 "15.18.1. String Concatenation Operator +")). This class is called the _class of the object_. An object is said to be an _instance_ of its class and of all superclasses of its class.

Every array also has a class. The method `getClass`, when invoked for an array object, will return a class object (of class `Class`) that represents the _class of the array_ ([¬ß10.8](jls-10.html#jls-10.8 "10.8. Class Objects for Arrays")).

The compile-time type of a variable is always declared, and the compile-time type of an expression can be deduced at compile time. The compile-time type limits the possible values that the variable can hold at run time or the expression can produce at run time. If a run-time value is a reference that is not `null`, it refers to an object or array that has a class, and that class will necessarily be compatible with the compile-time type.

Even though a variable or expression may have a compile-time type that is an interface type, there are no instances of interfaces. A variable or expression whose type is an interface type can reference any object whose class implements ([¬ß8.1.5](jls-8.html#jls-8.1.5 "8.1.5. Superinterfaces")) that interface.

Sometimes a variable or expression is said to have a "run-time type". This refers to the class of the object referred to by the value of the variable or expression at run time, assuming that the value is not `null`.

The correspondence between compile-time types and run-time types is incomplete for two reasons:

1.  At run time, classes and interfaces are loaded by the Java Virtual Machine using class loaders. Each class loader defines its own set of classes and interfaces. As a result, it is possible for two loaders to load an identical class or interface definition but produce distinct classes or interfaces at run time. Consequently, code that compiled correctly may fail at link time if the class loaders that load it are inconsistent.
    
    See the paper _Dynamic Class Loading in the Java Virtual Machine_, by Sheng Liang and Gilad Bracha, in _Proceedings of OOPSLA '98_, published as _ACM SIGPLAN Notices_, Volume 33, Number 10, October 1998, pages 36-44, and _The Java Virtual Machine Specification, Java SE 8 Edition_ for more details.
    
2.  Type variables ([¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables")) and type arguments ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")) are not reified at run time. As a result, the same class or interface at run time represents multiple parameterized types ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")) from compile time. Specifically, all compile-time parameterizations of a given generic type ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters"), [¬ß9.1.2](jls-9.html#jls-9.1.2 "9.1.2. Generic Interfaces and Type Parameters")) share a single run-time representation.
    
    Under certain conditions, it is possible that a variable of a parameterized type refers to an object that is not of that parameterized type. This situation is known as _heap pollution_ ([¬ß4.12.2](jls-4.html#jls-4.12.2 "4.12.2. Variables of Reference Type")). The variable will always refer to an object that is an instance of a class that represents the parameterized type.
    

**Example 4.12.6-1. Type of a Variable versus Class of an Object**

interface Colorable {
    void setColor(byte r, byte g, byte b);
}

class Point { int x, y; }

class ColoredPoint extends Point implements Colorable {
    byte r, g, b;
    public void setColor(byte rv, byte gv, byte bv) {
        r = rv; g = gv; b = bv;
    }
}

class Test {
    public static void main(String\[\] args) {
        Point p = new Point();
        ColoredPoint cp = new ColoredPoint();
        p = cp;
        Colorable c = cp;
    }
}

In this example:

*   The local variable `p` of the method `main` of class `Test` has type `Point` and is initially assigned a reference to a new instance of class `Point`.
*   The local variable `cp` similarly has as its type `ColoredPoint`, and is initially assigned a reference to a new instance of class `ColoredPoint`.
*   The assignment of the value of `cp` to the variable `p` causes `p` to hold a reference to a `ColoredPoint` object. This is permitted because `ColoredPoint` is a subclass of `Point`, so the class `ColoredPoint` is assignment-compatible ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")) with the type `Point`. A `ColoredPoint` object includes support for all the methods of a `Point`. In addition to its particular fields `r`, `g`, and `b`, it has the fields of class `Point`, namely `x` and `y`.
*   The local variable `c` has as its type the interface type `Colorable`, so it can hold a reference to any object whose class implements `Colorable`; specifically, it can hold a reference to a `ColoredPoint`.
    

Note that an expression such as `new Colorable()` is not valid because it is not possible to create an instance of an interface, only of a class. However, the expression `new Colorable() { public void setColor... }` is valid because it declares an anonymous class ([¬ß15.9.5](jls-15.html#jls-15.9.5 "15.9.5. Anonymous Class Declarations")) that implements the `Colorable` interface.

üçÄ Chapter 5. Conversions and Contexts
-----------------------------------

**Table of Contents**

[5.1. Kinds of Conversion](jls-5.html#jls-5.1)
[5.1.1. Identity Conversion](jls-5.html#jls-5.1.1)
[5.1.2. Widening Primitive Conversion](jls-5.html#jls-5.1.2)
[5.1.3. Narrowing Primitive Conversion](jls-5.html#jls-5.1.3)
[5.1.4. Widening and Narrowing Primitive Conversion](jls-5.html#jls-5.1.4)
[5.1.5. Widening Reference Conversion](jls-5.html#jls-5.1.5)
[5.1.6. Narrowing Reference Conversion](jls-5.html#jls-5.1.6)
[5.1.7. Boxing Conversion](jls-5.html#jls-5.1.7)
[5.1.8. Unboxing Conversion](jls-5.html#jls-5.1.8)
[5.1.9. Unchecked Conversion](jls-5.html#jls-5.1.9)
[5.1.10. Capture Conversion](jls-5.html#jls-5.1.10)
[5.1.11. String Conversion](jls-5.html#jls-5.1.11)
[5.1.12. Forbidden Conversions](jls-5.html#jls-5.1.12)
[5.1.13. Value Set Conversion](jls-5.html#jls-5.1.13)
[5.2. Assignment Contexts](jls-5.html#jls-5.2)
[5.3. Invocation Contexts](jls-5.html#jls-5.3)
[5.4. String Contexts](jls-5.html#jls-5.4)
[5.5. Casting Contexts](jls-5.html#jls-5.5)
[5.5.1. Reference Type Casting](jls-5.html#jls-5.5.1)
[5.5.2. Checked Casts and Unchecked Casts](jls-5.html#jls-5.5.2)
[5.5.3. Checked Casts at Run Time](jls-5.html#jls-5.5.3)
[5.6. Numeric Contexts](jls-5.html#jls-5.6)
[5.6.1. Unary Numeric Promotion](jls-5.html#jls-5.6.1)
[5.6.2. Binary Numeric Promotion](jls-5.html#jls-5.6.2)

Every expression written in the Java programming language either produces no result ([¬ß15.1](jls-15.html#jls-15.1 "15.1. Evaluation, Denotation, and Result")) or has a type that can be deduced at compile time ([¬ß15.3](jls-15.html#jls-15.3 "15.3. Type of an Expression")). When an expression appears in most contexts, it must be _compatible_ with a type expected in that context; this type is called the _target type_. For convenience, compatibility of an expression with its surrounding context is facilitated in two ways:

*   First, for some expressions, termed _poly expressions_ ([¬ß15.2](jls-15.html#jls-15.2 "15.2. Forms of Expressions")), the deduced type can be influenced by the target type. The same expression can have different types in different contexts.
*   Second, after the type of the expression has been deduced, an implicit _conversion_ from the type of the expression to the target type can sometimes be performed.
    

If neither strategy is able to produce the appropriate type, a compile-time error occurs.

The rules determining whether an expression is a poly expression, and if so, its type and compatibility in a particular context, vary depending on the kind of context and the form of the expression. In addition to influencing the type of the expression, the target type may in some cases influence the run time behavior of the expression in order to produce a value of the appropriate type.

Similarly, the rules determining whether a target type allows an implicit conversion vary depending on the kind of context, the type of the expression, and, in one special case, the value of a constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")). A conversion from type S to type T allows an expression of type S to be treated at compile time as if it had type T instead. In some cases this will require a corresponding action at run time to check the validity of the conversion or to translate the run-time value of the expression into a form appropriate for the new type T.

**Example 5.0-1. Conversions at Compile Time and Run Time**

*   A conversion from type `Object` to type `Thread` requires a run-time check to make sure that the run-time value is actually an instance of class `Thread` or one of its subclasses; if it is not, an exception is thrown.
*   A conversion from type `Thread` to type `Object` requires no run-time action; `Thread` is a subclass of `Object`, so any reference produced by an expression of type `Thread` is a valid reference value of type `Object`.
*   A conversion from type `int` to type `long` requires run-time sign-extension of a 32-bit integer value to the 64-bit `long` representation. No information is lost.
*   A conversion from type `double` to type `long` requires a non-trivial translation from a 64-bit floating-point value to the 64-bit integer representation. Depending on the actual run-time value, information may be lost.
    

  

The conversions possible in the Java programming language are grouped into several broad categories:

*   Identity conversions
*   Widening primitive conversions
*   Narrowing primitive conversions
*   Widening reference conversions
*   Narrowing reference conversions
*   Boxing conversions
*   Unboxing conversions
*   Unchecked conversions
*   Capture conversions
*   String conversions
*   Value set conversions
    

There are six kinds of _conversion contexts_ in which poly expressions may be influenced by context or implicit conversions may occur. Each kind of context has different rules for poly expression typing and allows conversions in some of the categories above but not others. The contexts are:

*   Assignment contexts ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts"), [¬ß15.26](jls-15.html#jls-15.26 "15.26. Assignment Operators")), in which an expression's value is bound to a named variable. Primitive and reference types are subject to widening, values may be boxed or unboxed, and some primitive constant expressions may be subject to narrowing. An unchecked conversion may also occur.
*   Strict invocation contexts ([¬ß5.3](jls-5.html#jls-5.3 "5.3. Invocation Contexts"), [¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions"), [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")), in which an argument is bound to a formal parameter of a constructor or method. Widening primitive, widening reference, and unchecked conversions may occur.
*   Loose invocation contexts ([¬ß5.3](jls-5.html#jls-5.3 "5.3. Invocation Contexts"), [¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions"), [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")), in which, like strict invocation contexts, an argument is bound to a formal parameter. Method or constructor invocations may provide this context if no applicable declaration can be found using only strict invocation contexts. In addition to widening and unchecked conversions, this context allows boxing and unboxing conversions to occur.
*   String contexts ([¬ß5.4](jls-5.html#jls-5.4 "5.4. String Contexts"), [¬ß15.18.1](jls-15.html#jls-15.18.1 "15.18.1. String Concatenation Operator +")), in which a value of any type is converted to an object of type `String`.
*   Casting contexts ([¬ß5.5](jls-5.html#jls-5.5 "5.5. Casting Contexts")), in which an expression's value is converted to a type explicitly specified by a cast operator ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")). Casting contexts are more inclusive than assignment or loose invocation contexts, allowing any specific conversion other than a string conversion, but certain casts to a reference type are checked for correctness at run time.
*   Numeric contexts ([¬ß5.6](jls-5.html#jls-5.6 "5.6. Numeric Contexts")), in which the operands of a numeric operator may be widened to a common type so that an operation can be performed.
    

The term "conversion" is also used to describe, without being specific, any conversions allowed in a particular context. For example, we say that an expression that is the initializer of a local variable is subject to "assignment conversion", meaning that a specific conversion will be implicitly chosen for that expression according to the rules for the assignment context.

**Example 5.0-2. Conversions In Various Contexts**

class Test {			
    public static void main(String\[\] args) {
        // Casting conversion (5.4) of a float literal to
        // type int. Without the cast operator, this would
        // be a compile-time error, because this is a
        // narrowing conversion (5.1.3):
        int i = (int)12.5f;

        // String conversion (5.4) of i's int value:
        System.out.println("(int)12.5f==" + i);

        // Assignment conversion (5.2) of i's value to type
        // float. This is a widening conversion (5.1.2):
        float f = i;

        // String conversion of f's float value:
        System.out.println("after float widening: " + f);

        // Numeric promotion (5.6) of i's value to type
        // float. This is a binary numeric promotion.
        // After promotion, the operation is float\*float:
        System.out.print(f);
        f = f \* i;

        // Two string conversions of i and f:
        System.out.println("\*" + i + "==" + f);

        // Invocation conversion (5.3) of f's value
        // to type double, needed because the method Math.sin
        // accepts only a double argument:
        double d = Math.sin(f);

        // Two string conversions of f and d:
        System.out.println("Math.sin(" + f + ")==" + d);
    }
}

This program produces the output:

(int)12.5f==12
after float widening: 12.0
12.0\*12==144.0
Math.sin(144.0)==-0.49102159389846934

  

5.1. Kinds of Conversion
------------------------

Specific type conversions in the Java programming language are divided into 13 categories.

### 5.1.1. Identity Conversion

A conversion from a type to that same type is permitted for any type.

This may seem trivial, but it has two practical consequences. First, it is always permitted for an expression to have the desired type to begin with, thus allowing the simply stated rule that every expression is subject to conversion, if only a trivial identity conversion. Second, it implies that it is permitted for a program to include redundant cast operators for the sake of clarity.

### 5.1.2. Widening Primitive Conversion

19 specific conversions on primitive types are called the _widening primitive conversions_:

*   `byte` to `short`, `int`, `long`, `float`, or `double`
*   `short` to `int`, `long`, `float`, or `double`
*   `char` to `int`, `long`, `float`, or `double`
*   `int` to `long`, `float`, or `double`
*   `long` to `float` or `double`
*   `float` to `double`
    

A widening primitive conversion does not lose information about the overall magnitude of a numeric value in the following cases, where the numeric value is preserved exactly:

*   from an integral type to another integral type
*   from `byte`, `short`, or `char` to a floating point type
*   from `int` to `double`
*   from `float` to `double` in a `strictfp` expression ([¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions"))
    

A widening primitive conversion from `float` to `double` that is not `strictfp` may lose information about the overall magnitude of the converted value.

A widening primitive conversion from `int` to `float`, or from `long` to `float`, or from `long` to `double`, may result in _loss of precision_ - that is, the result may lose some of the least significant bits of the value. In this case, the resulting floating-point value will be a correctly rounded version of the integer value, using IEEE 754 round-to-nearest mode ([¬ß4.2.4](jls-4.html#jls-4.2.4 "4.2.4. Floating-Point Operations")).

A widening conversion of a signed integer value to an integral type T simply sign-extends the two's-complement representation of the integer value to fill the wider format.

A widening conversion of a `char` to an integral type T zero-extends the representation of the `char` value to fill the wider format.

Despite the fact that loss of precision may occur, a widening primitive conversion never results in a run-time exception ([¬ß11.1.1](jls-11.html#jls-11.1.1 "11.1.1. The Kinds of Exceptions")).

**Example 5.1.2-1. Widening Primitive Conversion**

class Test {
    public static void main(String\[\] args) {
        int big = 1234567890;
        float approx = big;
        System.out.println(big - (int)approx);
    }
}

This program prints:

\-46

thus indicating that information was lost during the conversion from type `int` to type `float` because values of type `float` are not precise to nine significant digits.

  

### 5.1.3. Narrowing Primitive Conversion

22 specific conversions on primitive types are called the _narrowing primitive conversions_:

*   `short` to `byte` or `char`
*   `char` to `byte` or `short`
*   `int` to `byte`, `short`, or `char`
*   `long` to `byte`, `short`, `char`, or `int`
*   `float` to `byte`, `short`, `char`, `int`, or `long`
*   `double` to `byte`, `short`, `char`, `int`, `long`, or `float`
    

A narrowing primitive conversion may lose information about the overall magnitude of a numeric value and may also lose precision and range.

A narrowing primitive conversion from `double` to `float` is governed by the IEEE 754 rounding rules ([¬ß4.2.4](jls-4.html#jls-4.2.4 "4.2.4. Floating-Point Operations")). This conversion can lose precision, but also lose range, resulting in a `float` zero from a nonzero `double` and a `float` infinity from a finite `double`. A `double` NaN is converted to a `float` NaN and a `double` infinity is converted to the same-signed `float` infinity.

A narrowing conversion of a signed integer to an integral type T simply discards all but the _n_ lowest order bits, where _n_ is the number of bits used to represent type T. In addition to a possible loss of information about the magnitude of the numeric value, this may cause the sign of the resulting value to differ from the sign of the input value.

A narrowing conversion of a `char` to an integral type T likewise simply discards all but the _n_ lowest order bits, where _n_ is the number of bits used to represent type T. In addition to a possible loss of information about the magnitude of the numeric value, this may cause the resulting value to be a negative number, even though chars represent 16-bit unsigned integer values.

A narrowing conversion of a floating-point number to an integral type T takes two steps:

1.  In the first step, the floating-point number is converted either to a `long`, if T is `long`, or to an `int`, if T is `byte`, `short`, `char`, or `int`, as follows:
    
    *   If the floating-point number is NaN ([¬ß4.2.3](jls-4.html#jls-4.2.3 "4.2.3. Floating-Point Types, Formats, and Values")), the result of the first step of the conversion is an `int` or `long` `0`.
        
    *   Otherwise, if the floating-point number is not an infinity, the floating-point value is rounded to an integer value `V`, rounding toward zero using IEEE 754 round-toward-zero mode ([¬ß4.2.3](jls-4.html#jls-4.2.3 "4.2.3. Floating-Point Types, Formats, and Values")). Then there are two cases:
        
        1.  If T is `long`, and this integer value can be represented as a `long`, then the result of the first step is the `long` value `V`.
            
        2.  Otherwise, if this integer value can be represented as an `int`, then the result of the first step is the `int` value `V`.
            
        
    *   Otherwise, one of the following two cases must be true:
        
        1.  The value must be too small (a negative value of large magnitude or negative infinity), and the result of the first step is the smallest representable value of type `int` or `long`.
            
        2.  The value must be too large (a positive value of large magnitude or positive infinity), and the result of the first step is the largest representable value of type `int` or `long`.
            
        
    
2.  In the second step:
    
    *   If T is `int` or `long`, the result of the conversion is the result of the first step.
        
    *   If T is `byte`, `char`, or `short`, the result of the conversion is the result of a narrowing conversion to type T ([¬ß5.1.3](jls-5.html#jls-5.1.3 "5.1.3. Narrowing Primitive Conversion")) of the result of the first step.
        
    

Despite the fact that overflow, underflow, or other loss of information may occur, a narrowing primitive conversion never results in a run-time exception ([¬ß11.1.1](jls-11.html#jls-11.1.1 "11.1.1. The Kinds of Exceptions")).

**Example 5.1.3-1. Narrowing Primitive Conversion**

class Test {
    public static void main(String\[\] args) {
        float fmin = Float.NEGATIVE\_INFINITY;
        float fmax = Float.POSITIVE\_INFINITY;
        System.out.println("long: " + (long)fmin +
                           ".." + (long)fmax);
        System.out.println("int: " + (int)fmin +
                           ".." + (int)fmax);
        System.out.println("short: " + (short)fmin +
                           ".." + (short)fmax);
        System.out.println("char: " + (int)(char)fmin +
                           ".." + (int)(char)fmax);
        System.out.println("byte: " + (byte)fmin +
                           ".." + (byte)fmax);
    }
}

This program produces the output:

long: -9223372036854775808..9223372036854775807
int: -2147483648..2147483647
short: 0..-1
char: 0..65535
byte: 0..-1

The results for `char`, `int`, and `long` are unsurprising, producing the minimum and maximum representable values of the type.

The results for `byte` and `short` lose information about the sign and magnitude of the numeric values and also lose precision. The results can be understood by examining the low order bits of the minimum and maximum `int`. The minimum `int` is, in hexadecimal, `0x80000000`, and the maximum int is `0x7fffffff`. This explains the `short` results, which are the low 16 bits of these values, namely, `0x0000` and `0xffff`; it explains the char results, which also are the low 16 bits of these values, namely, `'\u0000'` and `'\uffff'`; and it explains the byte results, which are the low 8 bits of these values, namely, `0x00` and `0xff`.

  

**Example 5.1.3-2. Narrowing Primitive Conversions that lose information**

class Test {
    public static void main(String\[\] args) {
        // A narrowing of int to short loses high bits:
        System.out.println("(short)0x12345678==0x" +
                           Integer.toHexString((short)0x12345678));
        // An int value too big for byte changes sign and magnitude:
        System.out.println("(byte)255==" + (byte)255);
        // A float value too big to fit gives largest int value:
        System.out.println("(int)1e20f==" + (int)1e20f);
        // A NaN converted to int yields zero:
        System.out.println("(int)NaN==" + (int)Float.NaN);
        // A double value too large for float yields infinity:
        System.out.println("(float)-1e100==" + (float)-1e100);
        // A double value too small for float underflows to zero:
        System.out.println("(float)1e-50==" + (float)1e-50);
    }
}

This program produces the output:

(short)0x12345678==0x5678
(byte)255==-1
(int)1e20f==2147483647
(int)NaN==0
(float)-1e100==-Infinity
(float)1e-50==0.0

  

### 5.1.4. Widening and Narrowing Primitive Conversion

The following conversion combines both widening and narrowing primitive conversions:

*   `byte` to `char`
    

First, the `byte` is converted to an `int` via widening primitive conversion ([¬ß5.1.2](jls-5.html#jls-5.1.2 "5.1.2. Widening Primitive Conversion")), and then the resulting `int` is converted to a `char` by narrowing primitive conversion ([¬ß5.1.3](jls-5.html#jls-5.1.3 "5.1.3. Narrowing Primitive Conversion")).

### 5.1.5. Widening Reference Conversion

A _widening reference_ conversion exists from any reference type S to any reference type T, provided S is a subtype ([¬ß4.10](jls-4.html#jls-4.10 "4.10. Subtyping")) of T.

Widening reference conversions never require a special action at run time and therefore never throw an exception at run time. They consist simply in regarding a reference as having some other type in a manner that can be proved correct at compile time.

### 5.1.6. Narrowing Reference Conversion

Six kinds of conversions are called the _narrowing reference conversions_:

*   From any reference type S to any reference type T, provided that S is a proper supertype of T ([¬ß4.10](jls-4.html#jls-4.10 "4.10. Subtyping")).
    
    An important special case is that there is a narrowing reference conversion from the class type `Object` to any other reference type ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")).
*   From any class type C to any non-parameterized interface type K, provided that C is not `final` and does not implement K.
*   From any interface type J to any non-parameterized class type C that is not `final`.
*   From any interface type J to any non-parameterized interface type K, provided that J is not a subinterface of K.
*   From the interface types `Cloneable` and `java.io.Serializable` to any array type T`[]`.
*   From any array type SC`[]` to any array type TC`[]`, provided that SC and TC are reference types and there is a narrowing reference conversion from SC to TC.
    

Such conversions require a test at run time to find out whether the actual reference value is a legitimate value of the new type. If not, then a `ClassCastException` is thrown.

### 5.1.7. Boxing Conversion

Boxing conversion converts expressions of primitive type to corresponding expressions of reference type. Specifically, the following nine conversions are called the _boxing conversions_:

*   From type `boolean` to type `Boolean`
*   From type `byte` to type `Byte`
*   From type `short` to type `Short`
*   From type `char` to type `Character`
*   From type `int` to type `Integer`
*   From type `long` to type `Long`
*   From type `float` to type `Float`
*   From type `double` to type `Double`
*   From the null type to the null type
    
    This rule is necessary because the conditional operator ([¬ß15.25](jls-15.html#jls-15.25 "15.25. Conditional Operator ? :")) applies boxing conversion to the types of its operands, and uses the result in further calculations.
    

At run time, boxing conversion proceeds as follows:

*   If `p` is a value of type `boolean`, then boxing conversion converts `p` into a reference `r` of class and type `Boolean`, such that `` `r`.booleanValue() == `p` ``
*   If `p` is a value of type `byte`, then boxing conversion converts `p` into a reference `r` of class and type `Byte`, such that `` `r`.byteValue() == `p` ``
*   If `p` is a value of type `char`, then boxing conversion converts `p` into a reference `r` of class and type `Character`, such that `` `r`.charValue() == `p` ``
*   If `p` is a value of type `short`, then boxing conversion converts `p` into a reference `r` of class and type `Short`, such that `` `r`.shortValue() == `p` ``
*   If `p` is a value of type `int`, then boxing conversion converts `p` into a reference `r` of class and type `Integer`, such that `` `r`.intValue() == `p` ``
*   If `p` is a value of type `long`, then boxing conversion converts `p` into a reference `r` of class and type `Long`, such that `` `r`.longValue() == `p` ``
*   If `p` is a value of type `float` then:
    
    *   If `p` is not NaN, then boxing conversion converts `p` into a reference `r` of class and type `Float`, such that `` `r`.floatValue() `` evaluates to `p`
        
    *   Otherwise, boxing conversion converts `p` into a reference `r` of class and type `Float` such that `` `r`.isNaN() `` evaluates to `true`
        
*   If `p` is a value of type `double`, then:s="listitem">

If `p` is not NaN, boxing conversion converts `p` into a reference `r` of class and type `Double`, such that `` `r`.doubleValue() `` evaluates to `p`

*   Otherwise, boxing conversion converts `p` into a reference `r` of class and type `Double` such that `` `r`.isNaN() `` evaluates to `true`
*   If `p` is a value of any other type, boxing conversion is equivalent to an identity conversion ([¬ß5.1.1](jls-5.html#jls-5.1.1 "5.1.1. Identity Conversion")).
    

If the value `p` being boxed is an integer literal of type `int` between `-128` and `127` inclusive ([¬ß3.10.1](jls-3.html#jls-3.10.1 "3.10.1. Integer Literals")), or the boolean literal `true` or `false` ([¬ß3.10.3](jls-3.html#jls-3.10.3 "3.10.3. Boolean Literals")), or a character literal between `'\u0000'` and `'\u007f'` inclusive ([¬ß3.10.4](jls-3.html#jls-3.10.4 "3.10.4. Character Literals")), then let `a` and `b` be the results of any two boxing conversions of `p`. It is always the case that `a` `==` `b`.

Ideally, boxing a primitive value would always yield an identical reference. In practice, this may not be feasible using existing implementation techniques. The rule above is a pragmatic compromise, requiring that certain common values always be boxed into indistinguishable objects. The implementation may cache these, lazily or eagerly. For other values, the rule disallows any assumptions about the identity of the boxed values on the programmer's part. This allows (but does not require) sharing of some or all of these references. Notice that integer literals of type `long` are allowed, but not required, to be shared.

This ensures that in most common cases, the behavior will be the desired one, without imposing an undue performance penalty, especially on small devices. Less memory-limited implementations might, for example, cache all `char` and `short` values, as well as `int` and `long` values in the range of -32K to +32K.

A boxing conversion may result in an `OutOfMemoryError` if a new instance of one of the wrapper classes (`Boolean`, `Byte`, `Character`, `Short`, `Integer`, `Long`, `Float`, or `Double`) needs to be allocated and insufficient storage is available.

### 5.1.8. Unboxing Conversion

Unboxing conversion converts expressions of reference type to corresponding expressions of primitive type. Specifically, the following eight conversions are called the _unboxing conversions_:

*   From type `Boolean` to type `boolean`
*   From type `Byte` to type `byte`
*   From type `Short` to type `short`
*   From type `Character` to type `char`
*   From type `Integer` to type `int`
*   From type `Long` to type `long`
*   From type `Float` to type `float`
*   From type `Double` to type `double`
    

At run time, unboxing conversion proceeds as follows:

*   If `r` is a reference of type `Boolean`, then unboxing conversion converts `r` into `` `r`.booleanValue() ``
*   If `r` is a reference of type `Byte`, then unboxing conversion converts `r` into `` `r`.byteValue() ``
*   If `r` is a reference of type `Character`, then unboxing conversion converts `r` into `` `r`.charValue() ``
*   If `r` is a reference of type `Short`, then unboxing conversion converts `r` into `` `r`.shortValue() ``
*   If `r` is a reference of type `Integer`, then unboxing conversion converts `r` into `` `r`.intValue() ``
*   If `r` is a reference of type `Long`, then unboxing conversion converts `r` into `` `r`.longValue() ``
*   If `r` is a reference of type `Float`, unboxing conversion converts `r` into `` `r`.floatValue() ``
*   If `r` is a reference of type `Double`, then unboxing conversion converts `r` into `` `r`.doubleValue() ``
*   If `r` is `null`, unboxing conversion throws a `NullPointerException`
    

A type is said to be _convertible to a numeric type_ if it is a numeric type ([¬ß4.2](jls-4.html#jls-4.2 "4.2. Primitive Types and Values")), or it is a reference type that may be converted to a numeric type by unboxing conversion.

A type is said to be _convertible to an integral type_ if it is an integral type, or it is a reference type that may be converted to an integral type by unboxing conversion.

### 5.1.9. Unchecked Conversion

Let G name a generic type declaration with _n_ type parameters.

There is an _unchecked conversion_ from the raw class or interface type ([¬ß4.8](jls-4.html#jls-4.8 "4.8. Raw Types")) G to any parameterized type of the form G`<`T1,...,Tn`>`.

There is an _unchecked conversion_ from the raw array type G`[]`k to any array type of the form G`<`T1,...,Tn`>``[]`k. (The notation `[]`k indicates an array type of _k_ dimensions.)

Use of an unchecked conversion causes a compile-time _unchecked warning_ unless all type arguments Ti (1 ‚â§ _i_ ‚â§ _n_) are unbounded wildcards ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")), or the unchecked warning is suppressed by the `SuppressWarnings` annotation ([¬ß9.6.4.5](jls-9.html#jls-9.6.4.5 "9.6.4.5. @SuppressWarnings")).

Unchecked conversion is used to enable a smooth interoperation of legacy code, written before the introduction of generic types, with libraries that have undergone a conversion to use genericity (a process we call generification). In such circumstances (most notably, clients of the Collections Framework in `java.util`), legacy code uses raw types (e.g. `Collection` instead of `Collection<String>`). Expressions of raw types are passed as arguments to library methods that use parameterized versions of those same types as the types of their corresponding formal parameters.

Such calls cannot be shown to be statically safe under the type system using generics. Rejecting such calls would invalidate large bodies of existing code, and prevent them from using newer versions of the libraries. This in turn, would discourage library vendors from taking advantage of genericity. To prevent such an unwelcome turn of events, a raw type may be converted to an arbitrary invocation of the generic type declaration to which the raw type refers. While the conversion is unsound, it is tolerated as a concession to practicality. An unchecked warning is issued in such cases.

### 5.1.10. Capture Conversion

Let G name a generic type declaration ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters"), [¬ß9.1.2](jls-9.html#jls-9.1.2 "9.1.2. Generic Interfaces and Type Parameters")) with _n_ type parameters A1,...,An with corresponding bounds U1,...,Un.

There exists a _capture conversion_ from a parameterized type G`<`T1,...,Tn`>` ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")) to a parameterized type G`<`S1,...,Sn`>`, where, for 1 ‚â§ _i_ ‚â§ _n_ :

*   If Ti is a wildcard type argument ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")) of the form `?`, then Si is a fresh type variable whose upper bound is Ui`[A1:=S1,...,An:=Sn]` and whose lower bound is the null type ([¬ß4.1](jls-4.html#jls-4.1 "4.1. The Kinds of Types and Values")).
*   If Ti is a wildcard type argument of the form `?` `extends` Bi, then Si is a fresh type variable whose upper bound is glb(Bi, Ui`[A1:=S1,...,An:=Sn]`) and whose lower bound is the null type.
    
    glb(V1,...,Vm) is defined as V1 `&` ... `&` Vm.
    
    It is a compile-time error if, for any two classes (not interfaces) Vi and Vj, Vi is not a subclass of Vj or vice versa.
*   If Ti is a wildcard type argument of the form `?` `super` Bi, then Si is a fresh type variable whose upper bound is Ui`[A1:=S1,...,An:=Sn]` and whose lower bound is Bi.
*   Otherwise, Si = Ti.
    

Capture conversion on any type other than a parameterized type ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")) acts as an identity conversion ([¬ß5.1.1](jls-5.html#jls-5.1.1 "5.1.1. Identity Conversion")).

Capture conversion is not applied recursively.

Capture conversion never requires a special action at run time and therefore never throws an exception at run time.

Capture conversion is designed to make wildcards more useful. To understand the motivation, let's begin by looking at the method `java.util.Collections.reverse()`:

public static void reverse(List<?> list);

The method reverses the list provided as a parameter. It works for any type of list, and so the use of the wildcard type `List<?>` as the type of the formal parameter is entirely appropriate.

Now consider how one would implement `reverse()`:

public static void reverse(List<?> list) { rev(list); }
private static <T> void rev(List<T> list) {
    List<T> tmp = new ArrayList<T>(list);
    for (int i = 0; i < list.size(); i++) {
        list.set(i, tmp.get(list.size() - i - 1));
    }
}

The implementation needs to copy the list, extract elements from the copy, and insert them into the original. To do this in a type-safe manner, we need to give a name, `T`, to the element type of the incoming list. We do this in the private service method `rev()`. This requires us to pass the incoming argument list, of type `List<?>`, as an argument to `rev()`. In general, `List<?>` is a list of unknown type. It is not a subtype of `List<T>`, for any type T. Allowing such a subtype relation would be unsound. Given the method:

public static <T> void fill(List<T> l, T obj)

the following code would undermine the type system:

List<String> ls = new ArrayList<String>();
List<?> l = ls;
Collections.fill(l, new Object());  // not legal - but assume it was!
String s = ls.get(0); // ClassCastException - ls contains
                      // Objects, not Strings.

So, without some special dispensation, we can see that the call from `reverse()` to `rev()` would be disallowed. If this were the case, the author of `reverse()` would be forced to write its signature as:

public static <T> void reverse(List<T> list)

This is undesirable, as it exposes implementation information to the caller. Worse, the designer of an API might reason that the signature using a wildcard is what the callers of the API require, and only later realize that a type safe implementation was precluded.

The call from `reverse()` to `rev()` is in fact harmless, but it cannot be justified on the basis of a general subtyping relation between `List<?>` and `List<T>`. The call is harmless, because the incoming argument is doubtless a list of some type (albeit an unknown one). If we can capture this unknown type in a type variable `X`, we can infer `T` to be `X`. That is the essence of capture conversion. The specification of course must cope with complications, like non-trivial (and possibly recursively defined) upper or lower bounds, the presence of multiple arguments etc.

Mathematically sophisticated readers will want to relate capture conversion to established type theory. Readers unfamiliar with type theory can skip this discussion - or else study a suitable text, such as _Types and Programming Languages_ by Benjamin Pierce, and then revisit this section.

Here then is a brief summary of the relationship of capture conversion to established type theoretical notions. Wildcard types are a restricted form of existential types. Capture conversion corresponds loosely to an opening of a value of existential type. A capture conversion of an expression `e` can be thought of as an `open` of `e` in a scope that comprises the top level expression that encloses `e`.

The classical `open` operation on existentials requires that the captured type variable must not escape the opened expression. The `open` that corresponds to capture conversion is always on a scope sufficiently large that the captured type variable can never be visible outside that scope. The advantage of this scheme is that there is no need for a `close` operation, as defined in the paper _On Variance-Based Subtyping for Parametric Types_ by Atsushi Igarashi and Mirko Viroli, in the proceedings of the 16th European Conference on Object Oriented Programming (ECOOP 2002). For a formal account of wildcards, see _Wild FJ_ by Mads Torgersen, Erik Ernst and Christian Plesner Hansen, in the 12th workshop on Foundations of Object Oriented Programming (FOOL 2005).

### 5.1.11. String Conversion

Any type may be converted to type `String` by _string conversion_.

A value `x` of primitive type T is first converted to a reference value as if by giving it as an argument to an appropriate class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")):

*   If T is `boolean`, then use ``new Boolean(`x`)``.
*   If T is `char`, then use ``new Character(`x`)``.
*   If T is `byte`, `short`, or `int`, then use ``new Integer(`x`)``.
*   If T is `long`, then use ``new Long(`x`)``.
*   If T is `float`, then use ``new Float(`x`)``.
*   If T is `double`, then use ``new Double(`x`)``.
    

This reference value is then converted to type `String` by string conversion.

Now only reference values need to be considered:

*   If the reference is `null`, it is converted to the string "`null`" (four ASCII characters `n`, `u`, `l`, `l`).
*   Otherwise, the conversion is performed as if by an invocation of the `toString` method of the referenced object with no arguments; but if the result of invoking the `toString` method is `null`, then the string "`null`" is used instead.
    
    The `toString` method is defined by the primordial class `Object` ([¬ß4.3.2](jls-4.html#jls-4.3.2 "4.3.2. The Class Object")). Many classes override it, notably `Boolean`, `Character`, `Integer`, `Long`, `Float`, `Double`, and `String`.
    

See [¬ß5.4](jls-5.html#jls-5.4 "5.4. String Contexts") for details of the string context.

### 5.1.12. Forbidden Conversions

Any conversion that is not explicitly allowed is forbidden.

### 5.1.13. Value Set Conversion

_Value set conversion_ is the process of mapping a floating-point value from one value set to another without changing its type.

Within an expression that is not FP-strict ([¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions")), value set conversion provides choices to an implementation of the Java programming language:

*   If the value is an element of the float-extended-exponent value set, then the implementation may, at its option, map the value to the nearest element of the float value set. This conversion may result in overflow (in which case the value is replaced by an infinity of the same sign) or underflow (in which case the value may lose precision because it is replaced by a denormalized number or zero of the same sign).
*   If the value is an element of the double-extended-exponent value set, then the implementation may, at its option, map the value to the nearest element of the double value set. This conversion may result in overflow (in which case the value is replaced by an infinity of the same sign) or underflow (in which case the value may lose precision because it is replaced by a denormalized number or zero of the same sign).
    

Within an FP-strict expression ([¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions")), value set conversion does not provide any choices; every implementation must behave in the same way:

*   If the value is of type `float` and is not an element of the float value set, then the implementation must map the value to the nearest element of the float value set. This conversion may result in overflow or underflow.
*   If the value is of type `double` and is not an element of the double value set, then the implementation must map the value to the nearest element of the double value set. This conversion may result in overflow or underflow.
    

Within an FP-strict expression, mapping values from the float-extended-exponent value set or double-extended-exponent value set is necessary only when a method is invoked whose declaration is not FP-strict and the implementation has chosen to represent the result of the method invocation as an element of an extended-exponent value set.

Whether in FP-strict code or code that is not FP-strict, value set conversion always leaves unchanged any value whose type is neither `float` nor `double`.

5.2. Assignment Contexts
------------------------

_Assignment contexts_ allow the value of an expression to be assigned ([¬ß15.26](jls-15.html#jls-15.26 "15.26. Assignment Operators")) to a variable; the type of the expression must be converted to the type of the variable.

Assignment contexts allow the use of one of the following:

*   an identity conversion ([¬ß5.1.1](jls-5.html#jls-5.1.1 "5.1.1. Identity Conversion"))
*   a widening primitive conversion ([¬ß5.1.2](jls-5.html#jls-5.1.2 "5.1.2. Widening Primitive Conversion"))
*   a widening reference conversion ([¬ß5.1.5](jls-5.html#jls-5.1.5 "5.1.5. Widening Reference Conversion"))
*   a boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")) optionally followed by a widening reference conversion
*   an unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) optionally followed by a widening primitive conversion.
    

If, after the conversions listed above have been applied, the resulting type is a raw type ([¬ß4.8](jls-4.html#jls-4.8 "4.8. Raw Types")), an unchecked conversion ([¬ß5.1.9](jls-5.html#jls-5.1.9 "5.1.9. Unchecked Conversion")) may then be applied.

In addition, if the expression is a constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")) of type `byte`, `short`, `char`, or `int`:

*   A narrowing primitive conversion may be used if the type of the variable is `byte`, `short`, or `char`, and the value of the constant expression is representable in the type of the variable.
*   A narrowing primitive conversion followed by a boxing conversion may be used if the type of the variable is:
    
    *   `Byte` and the value of the constant expression is representable in the type `byte`.
        
    *   `Short` and the value of the constant expression is representable in the type `short`.
        
    *   `Character` and the value of the constant expression is representable in the type `char`.
        
    

The compile-time narrowing of constant expressions means that code such as:

byte theAnswer = 42;

is allowed. Without the narrowing, the fact that the integer literal `42` has type `int` would mean that a cast to `byte` would be required:

byte theAnswer = (byte)42;  // cast is permitted but not required

Finally, a value of the null type (the null reference is the only such value) may be assigned to any reference type, resulting in a null reference of that type.

It is a compile-time error if the chain of conversions contains two parameterized types that are not in the subtype relation ([¬ß4.10](jls-4.html#jls-4.10 "4.10. Subtyping")).

An example of such an illegal chain would be:

Integer, Comparable<Integer>, Comparable, Comparable<String>

The first three elements of the chain are related by widening reference conversion, while the last entry is derived from its predecessor by unchecked conversion. However, this is not a valid assignment conversion, because the chain contains two parameterized types, `Comparable<Integer>` and `Comparable<String>`, that are not subtypes.

If the type of the expression cannot be converted to the type of the variable by a conversion permitted in an assignment context, then a compile-time error occurs.

If the type of an expression can be converted to the type of a variable by assignment conversion, we say the expression (or its value) is _assignable to_ the variable or, equivalently, that the type of the expression is _assignment compatible with_ the type of the variable.

If the type of the variable is `float` or `double`, then value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")) is applied to the value `v` that is the result of the conversion(s):

*   If `v` is of type `float` and is an element of the float-extended-exponent value set, then the implementation must map `v` to the nearest element of the float value set. This conversion may result in overflow or underflow.
*   If `v` is of type `double` and is an element of the double-extended-exponent value set, then the implementation must map `v` to the nearest element of the double value set. This conversion may result in overflow or underflow.
    

The only exceptions that may arise from conversions in an assignment context are:

*   A `ClassCastException` if, after the conversions above have been applied, the resulting value is an object which is not an instance of a subclass or subinterface of the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of the type of the variable.
    
    This circumstance can only arise as a result of heap pollution ([¬ß4.12.2](jls-4.html#jls-4.12.2 "4.12.2. Variables of Reference Type")). In practice, implementations need only perform casts when accessing a field or method of an object of parameterized type when the erased type of the field, or the erased return type of the method, differ from its unerased type.
*   An `OutOfMemoryError` as a result of a boxing conversion.
*   A `NullPointerException` as a result of an unboxing conversion on a null reference.
*   An `ArrayStoreException` in special cases involving array elements or field access ([¬ß10.5](jls-10.html#jls-10.5 "10.5. Array Store Exception"), [¬ß15.26.1](jls-15.html#jls-15.26.1 "15.26.1. Simple Assignment Operator =")).
    

**Example 5.2-1. Assignment Conversion for Primitive Types**

class Test {
    public static void main(String\[\] args) {
        short s = 12;      // narrow 12 to short
        float f = s;       // widen short to float
        System.out.println("f=" + f);
        char c = '\\u0123';
        long l = c;        // widen char to long
        System.out.println("l=0x" + Long.toString(l,16));
        f = 1.23f;
        double d = f;      // widen float to double
        System.out.println("d=" + d);
    }
}

This program produces the output:

f=12.0
l=0x123
d=1.2300000190734863

The following program, however, produces compile-time errors:

class Test {
    public static void main(String\[\] args) {
        short s = 123;
        char c = s;    // error: would require cast
        s = c;         // error: would require cast
    }
}

because not all `short` values are `char` values, and neither are all `char` values `short` values.

  

**Example 5.2-2. Assignment Conversion for Reference Types**

class Point { int x, y; }
class Point3D extends Point { int z; }
interface Colorable { void setColor(int color); }

class ColoredPoint extends Point implements Colorable {
    int color;
    public void setColor(int color) { this.color = color; }
}

class Test {
    public static void main(String\[\] args) {
        // Assignments to variables of class type:
        Point p = new Point();
        p = new Point3D(); 
          // OK because Point3D is a subclass of Point
        Point3D p3d = p; 
          // Error: will require a cast because a Point
          // might not be a Point3D (even though it is,
          // dynamically, in this example.)

        // Assignments to variables of type Object:
        Object o  = p;          // OK: any object to Object
        int\[\] a   = new int\[3\];
        Object o2 = a;          // OK: an array to Object

        // Assignments to variables of interface type:
        ColoredPoint cp = new ColoredPoint();
        Colorable c = cp;
          // OK: ColoredPoint implements Colorable

        // Assignments to variables of array type:
        byte\[\] b = new byte\[4\];
        a = b;
          // Error: these are not arrays of the same primitive type
        Point3D\[\] p3da = new Point3D\[3\];
        Point\[\] pa = p3da; 
          // OK: since we can assign a Point3D to a Point
        p3da = pa;
          // Error: (cast needed) since a Point
          // can't be assigned to a Point3D
    }
}

The following test program illustrates assignment conversions on reference values, but fails to compile, as described in its comments. This example should be compared to the preceding one.

class Point { int x, y; }
interface Colorable { void setColor(int color); }
class ColoredPoint extends Point implements Colorable {
    int color;
    public void setColor(int color) { this.color = color; }
}

class Test {
    public static void main(String\[\] args) {
        Point p = new Point();
        ColoredPoint cp = new ColoredPoint();
        // Okay because ColoredPoint is a subclass of Point:
        p = cp;
        // Okay because ColoredPoint implements Colorable:
        Colorable c = cp;
        // The following cause compile-time errors because
        // we cannot be sure they will succeed, depending on
        // the run-time type of p; a run-time check will be
        // necessary for the needed narrowing conversion and
        // must be indicated by including a cast:
        cp = p;    // p might be neither a ColoredPoint
                   // nor a subclass of ColoredPoint
        c = p;     // p might not implement Colorable
    }
}

  

**Example 5.2-3. Assignment Conversion for Array Types**

class Point { int x, y; }
class ColoredPoint extends Point { int color; }

class Test {
    public static void main(String\[\] args) {
        long\[\] veclong = new long\[100\];
        Object o = veclong;          // okay
        Long l = veclong;            // compile-time error
        short\[\] vecshort = veclong;  // compile-time error
        Point\[\] pvec = new Point\[100\];
        ColoredPoint\[\] cpvec = new ColoredPoint\[100\];
        pvec = cpvec;                // okay
        pvec\[0\] = new Point();       // okay at compile time,
                                     // but would throw an
                                     // exception at run time
        cpvec = pvec;                // compile-time error
    }
}

In this example:

*   The value of `veclong` cannot be assigned to a `Long` variable, because `Long` is a class type other than `Object`. An array can be assigned only to a variable of a compatible array type, or to a variable of type `Object`, `Cloneable` or `java.io.Serializable`.
*   The value of `veclong` cannot be assigned to `vecshort`, because they are arrays of primitive type, and `short` and `long` are not the same primitive type.
*   The value of `cpvec` can be assigned to `pvec`, because any reference that could be the value of an expression of type `ColoredPoint` can be the value of a variable of type `Point`. The subsequent assignment of the new `Point` to a component of `pvec` then would throw an `ArrayStoreException` (if the program were otherwise corrected so that it could be compiled), because a `ColoredPoint` array cannot have an instance of `Point` as the value of a component.The value of `pvec` cannot be assigned to `cpvec`, because not every reference that could be the value of an expression of type `ColoredPoint` can correctly be the value of a variable of type `Point`. If the value of `pvec` at run time were a reference to an instance of `Point[]`, and the assignment to `cpvec` were allowed, a simple reference to a component of `cpvec`, say, `cpvec[0]`, could return a `Point`, and a `Point` is not a `ColoredPoint`. Thus to allow such an assignment would allow a violation of the type system. A cast may be used ([¬ß5.5](jls-5.html#jls-5.5 "5.5. Casting Contexts"), [¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")) to ensure that `pvec` references a `ColoredPoint[]`:

      cpvec = (ColoredPoint\[\])pvec;  // OK, but may throw an 
                               // exception at run time
    

  

5.3. Invocation Contexts
------------------------

_Invocation contexts_ allow an argument value in a method or constructor invocation ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations"), [¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions"), [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")) to be assigned to a corresponding formal parameter.

_Strict_ invocation contexts allow the use of one of the following:

*   an identity conversion ([¬ß5.1.1](jls-5.html#jls-5.1.1 "5.1.1. Identity Conversion"))
*   a widening primitive conversion ([¬ß5.1.2](jls-5.html#jls-5.1.2 "5.1.2. Widening Primitive Conversion"))
*   a widening reference conversion ([¬ß5.1.5](jls-5.html#jls-5.1.5 "5.1.5. Widening Reference Conversion"))
    

_Loose_ invocation contexts allow a more permissive set of conversions, because they are only used for a particular invocation if no applicable declaration can be found using strict invocation contexts. Loose invocation contexts allow the use of one of the following:

*   an identity conversion ([¬ß5.1.1](jls-5.html#jls-5.1.1 "5.1.1. Identity Conversion"))
*   a widening primitive conversion ([¬ß5.1.2](jls-5.html#jls-5.1.2 "5.1.2. Widening Primitive Conversion"))
*   a widening reference conversion ([¬ß5.1.5](jls-5.html#jls-5.1.5 "5.1.5. Widening Reference Conversion"))
*   a boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")) optionally followed by widening reference conversion
*   an unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) optionally followed by a widening primitive conversion
    

If, after the conversions listed for an invocation context have been applied, the resulting type is a raw type ([¬ß4.8](jls-4.html#jls-4.8 "4.8. Raw Types")), an unchecked conversion ([¬ß5.1.9](jls-5.html#jls-5.1.9 "5.1.9. Unchecked Conversion")) may then be applied.

A value of the null type (the null reference is the only such value) may be assigned to any reference type.

It is a compile-time error if the chain of conversions contains two parameterized types that are not in the subtype relation ([¬ß4.10](jls-4.html#jls-4.10 "4.10. Subtyping")).

If the type of the expression cannot be converted to the type of the parameter by a conversion permitted in a loose invocation context, then a compile-time error occurs.

If the type of an argument expression is either `float` or `double`, then value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")) is applied after the conversion(s):

*   If an argument value of type `float` is an element of the float-extended-exponent value set, then the implementation must map the value to the nearest element of the float value set. This conversion may result in overflow or underflow.
*   If an argument value of type `double` is an element of the double-extended-exponent value set, then the implementation must map the value to the nearest element of the double value set. This conversion may result in overflow or underflow.
    

The only exceptions that may arise in an invocation context are:

*   A `ClassCastException` if, after the type conversions above have been applied, the resulting value is an object which is not an instance of a subclass or subinterface of the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of the corresponding formal parameter type.
*   An `OutOfMemoryError` as a result of a boxing conversion.
*   A `NullPointerException` as a result of an unboxing conversion on a null reference.
    

Neither strict nor loose invocation contexts include the implicit narrowing of integer constant expressions which is allowed in assignment contexts. The designers of the Java programming language felt that including these implicit narrowing conversions would add additional complexity to the rules of overload resolution ([¬ß15.12.2](jls-15.html#jls-15.12.2 "15.12.2. Compile-Time Step 2: Determine Method Signature")).

Thus, the program:

class Test {
    static int m(byte a, int b) { return a+b; }
    static int m(short a, short b) { return a-b; }
    public static void main(String\[\] args) {
        System.out.println(m(12, 2));  // compile-time error
    }
}

causes a compile-time error because the integer literals `12` and `2` have type `int`, so neither method `m` matches under the rules of overload resolution. A language that included implicit narrowing of integer constant expressions would need additional rules to resolve cases like this example.

5.4. String Contexts
--------------------

String contexts apply only to an operand of the binary `+` operator which is not a `String` when the other operand is a `String`.

The target type in these contexts is always `String`, and a string conversion ([¬ß5.1.11](jls-5.html#jls-5.1.11 "5.1.11. String Conversion")) of the non-`String` operand always occurs. Evaluation of the `+` operator then proceeds as specified in [¬ß15.18.1](jls-15.html#jls-15.18.1 "15.18.1. String Concatenation Operator +").

5.5. Casting Contexts
---------------------

_Casting contexts_ allow the operand of a cast operator ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")) to be converted to the type explicitly named by the cast operator.

Casting contexts allow the use of one of:

*   an identity conversion ([¬ß5.1.1](jls-5.html#jls-5.1.1 "5.1.1. Identity Conversion"))
*   a widening primitive conversion ([¬ß5.1.2](jls-5.html#jls-5.1.2 "5.1.2. Widening Primitive Conversion"))
*   a narrowing primitive conversion ([¬ß5.1.3](jls-5.html#jls-5.1.3 "5.1.3. Narrowing Primitive Conversion"))
*   a widening and narrowing primitive conversion ([¬ß5.1.4](jls-5.html#jls-5.1.4 "5.1.4. Widening and Narrowing Primitive Conversion"))
*   a widening reference conversion ([¬ß5.1.5](jls-5.html#jls-5.1.5 "5.1.5. Widening Reference Conversion")) optionally followed by either an unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) or an unchecked conversion ([¬ß5.1.9](jls-5.html#jls-5.1.9 "5.1.9. Unchecked Conversion"))
*   a narrowing reference conversion ([¬ß5.1.6](jls-5.html#jls-5.1.6 "5.1.6. Narrowing Reference Conversion")) optionally followed by either an unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) or an unchecked conversion ([¬ß5.1.9](jls-5.html#jls-5.1.9 "5.1.9. Unchecked Conversion"))
*   a boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")) optionally followed by a widening reference conversion ([¬ß5.1.5](jls-5.html#jls-5.1.5 "5.1.5. Widening Reference Conversion"))
*   an unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) optionally followed by a widening primitive conversion ([¬ß5.1.2](jls-5.html#jls-5.1.2 "5.1.2. Widening Primitive Conversion")).
    

Value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")) is applied after the type conversion.

The compile-time legality of a casting conversion is as follows:

*   An expression of a primitive type may undergo casting conversion to another primitive type, by an identity conversion (if the types are the same), or by a widening primitive conversion, or by a narrowing primitive conversion, or by a widening and narrowing primitive conversion.
*   An expression of a primitive type may undergo casting conversion to a reference type without error, by boxing conversion.
*   An expression of a reference type may undergo casting conversion to a primitive type without error, by unboxing conversion.
*   An expression of a reference type may undergo casting conversion to another reference type if no compile-time error occurs given the rules in [¬ß5.5.1](jls-5.html#jls-5.5.1 "5.5.1. Reference Type Casting").
    

The following tables enumerate which conversions are used in certain casting conversions. Each conversion is signified by a symbol:

*   \- signifies no casting conversion allowed
*   ‚âà signifies identity conversion ([¬ß5.1.1](jls-5.html#jls-5.1.1 "5.1.1. Identity Conversion"))
*   œâ signifies widening primitive conversion ([¬ß5.1.2](jls-5.html#jls-5.1.2 "5.1.2. Widening Primitive Conversion"))
*   Œ∑ signifies narrowing primitive conversion ([¬ß5.1.3](jls-5.html#jls-5.1.3 "5.1.3. Narrowing Primitive Conversion"))
*   œâŒ∑ signifies widening and narrowing primitive conversion ([¬ß5.1.4](jls-5.html#jls-5.1.4 "5.1.4. Widening and Narrowing Primitive Conversion"))
*   ‚áë signifies widening reference conversion ([¬ß5.1.5](jls-5.html#jls-5.1.5 "5.1.5. Widening Reference Conversion"))
*   ‚áì signifies narrowing reference conversion ([¬ß5.1.6](jls-5.html#jls-5.1.6 "5.1.6. Narrowing Reference Conversion"))
*   ‚äï signifies boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion"))
*   ‚äó signifies unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion"))
    

In the tables, a comma between symbols indicates that a casting conversion uses one conversion followed by another. The type `Object` means any reference type other than the eight wrapper classes `Boolean`, `Byte`, `Short`, `Character`, `Integer`, `Long`, `Float`, `Double`.

**Table 5.5-A. Casting conversions to primitive types**

        

To ‚Üí

`byte`

`short`

`char`

`int`

`long`

`float`

`double`

`boolean`

From ‚Üì

 

 

 

 

 

 

 

 

`byte`

‚âà

œâ

œâŒ∑

œâ

œâ

œâ

œâ

\-

`short`

Œ∑

‚âà

Œ∑

œâ

œâ

œâ

œâ

\-

`char`

Œ∑

Œ∑

‚âà

œâ

œâ

œâ

œâ

\-

`int`

Œ∑

Œ∑

Œ∑

‚âà

œâ

œâ

œâ

\-

`long`

Œ∑

Œ∑

Œ∑

Œ∑

‚âà

œâ

œâ

\-

`float`

Œ∑

Œ∑

Œ∑

Œ∑

Œ∑

‚âà

œâ

\-

`double`

Œ∑

Œ∑

Œ∑

Œ∑

Œ∑

Œ∑

‚âà

\-

`boolean`

\-

\-

\-

\-

\-

\-

\-

‚âà

`Byte`

‚äó

‚äó,œâ

\-

‚äó,œâ

‚äó,œâ

‚äó,œâ

‚äó,œâ

\-

`Short`

\-

‚äó

\-

‚äó,œâ

‚äó,œâ

‚äó,œâ

‚äó,œâ

\-

`Character`

\-

\-

‚äó

‚äó,œâ

‚äó,œâ

‚äó,œâ

‚äó,œâ

\-

`Integer`

\-

\-

\-

‚äó

‚äó,œâ

‚äó,œâ

‚äó,œâ

\-

`Long`

\-

\-

\-

\-

‚äó

‚äó,œâ

‚äó,œâ

\-

`Float`

\-

\-

\-

\-

\-

‚äó

‚äó,œâ

\-

`Double`

\-

\-

\-

\-

\-

\-

‚äó

\-

`Boolean`

\-

\-

\-

\-

\-

\-

\-

‚äó

`Object`

‚áì,‚äó

‚áì,‚äó

‚áì,‚äó

‚áì,‚äó

‚áì,‚äó

‚áì,‚äó

‚áì,‚äó

‚áì,‚äó

  

**Table 5.5-B. Casting conversions to reference types**

         

To ‚Üí

`Byte`

`Short`

`Character`

`Integer`

`Long`

`Float`

`Double`

`Boolean`

`Object`

From ‚Üì

 

 

 

 

 

 

 

 

 

`byte`

‚äï

\-

\-

\-

\-

\-

\-

\-

‚äï,‚áë

`short`

\-

‚äï

\-

\-

\-

\-

\-

\-

‚äï,‚áë

`char`

\-

\-

‚äï

\-

\-

\-

\-

\-

‚äï,‚áë

`int`

\-

\-

\-

‚äï

\-

\-

\-

\-

‚äï,‚áë

`long`

\-

\-

\-

\-

‚äï

\-

\-

\-

‚äï,‚áë

`float`

\-

\-

\-

\-

\-

‚äï

\-

\-

‚äï,‚áë

`double`

\-

\-

\-

\-

\-

\-

‚äï

\-

‚äï,‚áë

`boolean`

\-

\-

\-

\-

\-

\-

\-

‚äï

‚äï,‚áë

`Byte`

‚âà

\-

\-

\-

\-

\-

\-

\-

‚áë

`Short`

\-

‚âà

\-

\-

\-

\-

\-

\-

‚áë

`Character`

\-

\-

‚âà

\-

\-

\-

\-

\-

‚áë

`Integer`

\-

\-

\-

‚âà

\-

\-

\-

\-

‚áë

`Long`

\-

\-

\-

\-

‚âà

\-

\-

\-

‚áë

`Float`

\-

\-

\-

\-

\-

‚âà

\-

\-

‚áë

`Double`

\-

\-

\-

\-

\-

\-

‚âà

\-

‚áë

`Boolean`

\-

\-

\-

\-

\-

\-

\-

‚âà

‚áë

`Object`

‚áì

‚áì

‚áì

‚áì

‚áì

‚áì

‚áì

‚áì

‚âà

  

### 5.5.1. Reference Type Casting

Given a compile-time reference type S (source) and a compile-time reference type T (target), a casting conversion exists from S to T if no compile-time errors occur due to the following rules.

If S is a class type:

*   If T is a class type, then either |S| `<:` |T|, or |T| `<:` |S|. Otherwise, a compile-time error occurs.
    
    Furthermore, if there exists a supertype X of T, and a supertype Y of S, such that both X and Y are provably distinct parameterized types ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")), and that the erasures of X and Y are the same, a compile-time error occurs.
*   If T is an interface type:
    
    *   If S is not a `final` class ([¬ß8.1.1](jls-8.html#jls-8.1.1 "8.1.1. Class Modifiers")), then, if there exists a supertype X of T, and a supertype Y of S, such that both X and Y are provably distinct parameterized types, and that the erasures of X and Y are the same, a compile-time error occurs.
        
        Otherwise, the cast is always legal at compile time (because even if S does not implement T, a subclass of S might).
        
    *   If S is a `final` class ([¬ß8.1.1](jls-8.html#jls-8.1.1 "8.1.1. Class Modifiers")), then S must implement T, or a compile-time error occurs.
        
*   If T is a type variable, then this algorithm is applied recursively, using the upper bound of T in place of T.
*   If T is an array type, then S must be the class `Object`, or a compile-time error occurs.
*   If T is an intersection type, T1 `&` ... `&` Tn, then it is a compile-time error if there exists a Ti (1 ‚â§ _i_ ‚â§ _n_) such that S cannot be cast to Ti by this algorithm. That is, the success of the cast is determined by the most restrictive component of the intersection type.
    

If S is an interface type:

*   If T is an array type, then S must be the type `java.io.Serializable` or `Cloneable` (the only interfaces implemented by arrays), or a compile-time error occurs.
*   If T is a class or interface type that is not `final` ([¬ß8.1.1](jls-8.html#jls-8.1.1 "8.1.1. Class Modifiers")), then if there exists a supertype X of T, and a supertype Y of S, such that both X and Y are provably distinct parameterized types, and that the erasures of X and Y are the same, a compile-time error occurs.
    
    Otherwise, the cast is always legal at compile time (because even if T does not implement S, a subclass of T might).
*   If T is a class type that is `final`, then:
    
    *If S is not a parameterized type or a raw type, then T must implement S, or a compile-time error occurs.

*   Otherwise, S is either a parameterized type that is an invocation of some generic type declaration G, or a raw type corresponding to a generic type declaration G. Then there must exist a supertype X of T, such that X is an invocation of G, or a compile-time error occurs.
    
    Furthermore, if S and X are provably distinct parameterized types then a compile-time error occurs.
*   If T is a type variable, then this algorithm is applied recursively, using the upper bound of T in place of T.
*   If T is an intersection type, T1 `&` ... `&` Tn, then it is a compile-time error if there exists a Ti (1 ‚â§ _i_ ‚â§ _n_) such that S cannot be cast to Ti by this algorithm.
    

If S is a type variable, then this algorithm is applied recursively, using the upper bound of S in place of S.

If S is an intersection type A1 `&` ... `&` An, then it is a compile-time error if there exists an Ai (1 ‚â§ _i_ ‚â§ _n_) such that Ai cannot be cast to T by this algorithm. That is, the success of the cast is determined by the most restrictive component of the intersection type.

If S is an array type SC`[]`, that is, an array of components of type SC:

*   If T is a class type, then if T is not `Object`, then a compile-time error occurs (because `Object` is the only class type to which arrays can be assigned).
*   If T is an interface type, then a compile-time error occurs unless T is the type `java.io.Serializable` or the type `Cloneable` (the only interfaces implemented by arrays).
*   If T is a type variable, then this algorithm is applied recursively, using the upper bound of T in place of T.
*   If T is an array type TC`[]`, that is, an array of components of type TC, then a compile-time error occurs unless one of the following is true:
    
    *   TC and SC are the same primitive type.
        
    *   TC and SC are reference types and type SC can undergo casting conversion to TC.
        
*   If T is an intersection type, T1 `&` ... `&` Tn, then it is a compile-time error if there exists a Ti (1 ‚â§ _i_ ‚â§ _n_) such that S cannot be cast to Ti by this algorithm.
    

**Example 5.5.1-1. Casting Conversion for Reference Types**

class Point { int x, y; }
interface Colorable { void setColor(int color); }
class ColoredPoint extends Point implements Colorable {
    int color;
    public void setColor(int color) { this.color = color; }
}
final class EndPoint extends Point {}

class Test {
    public static void main(String\[\] args) {
        Point p = new Point();
        ColoredPoint cp = new ColoredPoint();
        Colorable c;
        // The following may cause errors at run time because
        // we cannot be sure they will succeed; this possibility
        // is suggested by the casts:
        cp = (ColoredPoint)p;  // p might not reference an
                               // object which is a ColoredPoint
                               // or a subclass of ColoredPoint
        c = (Colorable)p;      // p might not be Colorable
        // The following are incorrect at compile time because
        // they can never succeed as explained in the text:
        Long l = (Long)p;            // compile-time error #1
        EndPoint e = new EndPoint();
        c = (Colorable)e;            // compile-time error #2
    }
}

Here, the first compile-time error occurs because the class types `Long` and `Point` are unrelated (that is, they are not the same, and neither is a subclass of the other), so a cast between them will always fail.

The second compile-time error occurs because a variable of type `EndPoint` can never reference a value that implements the interface `Colorable`. This is because `EndPoint` is a `final` type, and a variable of a `final` type always holds a value of the same run-time type as its compile-time type. Therefore, the run-time type of variable `e` must be exactly the type `EndPoint`, and type `EndPoint` does not implement `Colorable`.

  

**Example 5.5.1-2. Casting Conversion for Array Types**

class Point {
    int x, y;
    Point(int x, int y) { this.x = x; this.y = y; }
    public String toString() { return "("+x+","+y+")"; }
}
interface Colorable { void setColor(int color); }
class ColoredPoint extends Point implements Colorable {
    int color;
    ColoredPoint(int x, int y, int color) {
        super(x, y); setColor(color);
    }
    public void setColor(int color) { this.color = color; }
    public String toString() {
        return super.toString() + "@" + color;
    }
}

class Test {
    public static void main(String\[\] args) {
        Point\[\] pa = new ColoredPoint\[4\];
        pa\[0\] = new ColoredPoint(2, 2, 12);
        pa\[1\] = new ColoredPoint(4, 5, 24);
        ColoredPoint\[\] cpa = (ColoredPoint\[\])pa;
        System.out.print("cpa: {");
        for (int i = 0; i < cpa.length; i++)
            System.out.print((i == 0 ? " " : ", ") + cpa\[i\]);
        System.out.println(" }");
    }
}

This program compiles without errors and produces the output:

cpa: { (2,2)@12, (4,5)@24, null, null }

  

### 5.5.2. Checked Casts and Unchecked Casts

A cast from a type S to a type T is _statically known to be correct_ if and only if S `<:` T ([¬ß4.10](jls-4.html#jls-4.10 "4.10. Subtyping")).

A cast from a type S to a parameterized type ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")) T is _unchecked_ unless at least one of the following is true:

*   S `<:` T
*   All of the type arguments ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")) of T are unbounded wildcards
*   T `<:` S and S has no subtype X other than T where the type arguments of X are not contained in the type arguments of T.
    

A cast from a type S to a type variable T is unchecked unless S `<:` T.

A cast from a type S to an intersection type T1 `&` ... `&` Tn is unchecked if there exists a Ti (1 ‚â§ _i_ ‚â§ _n_) such that a cast from S to Ti is unchecked.

An unchecked cast from S to a non-intersection type T is _completely unchecked_ if the cast from |S| to |T| is statically known to be correct. Otherwise, it is _partially unchecked_.

An unchecked cast from S to an intersection type T1 `&` ... `&` Tn is _completely unchecked_ if, for all _i_ (1 ‚â§ _i_ ‚â§ _n_), a cast from S to Ti is either statically known to be correct or completely unchecked. Otherwise, it is _partially unchecked_.

An unchecked cast causes a compile-time unchecked warning, unless suppressed by the `SuppressWarnings` annotation ([¬ß9.6.4.5](jls-9.html#jls-9.6.4.5 "9.6.4.5. @SuppressWarnings")).

A cast is _checked_ if it is not statically known to be correct and it is not unchecked.

If a cast to a reference type is not a compile-time error, there are several cases:

*   The cast is statically known to be correct.
    
    No run-time action is performed for such a cast.
*   The cast is a completely unchecked cast.
    
    No run-time action is performed for such a cast.
*   The cast is a partially unchecked or checked cast to an intersection type.
    
    Where the intersection type is T1 `&` ... `&` Tn, then for all _i_ (1 ‚â§ _i_ ‚â§ _n_), any run-time check required for a cast from S to Ti is also required for the cast to the intersection type.
*   The cast is a partially unchecked cast to a non-intersection type.
    
    Such a cast requires a run-time validity check. The check is performed as if the cast had been a checked cast between |S| and |T|, as described below.
*   The cast is a checked cast to a non-intersection type.
    
    Such a cast requires a run-time validity check. If the value at run time is `null`, then the cast is allowed. Otherwise, let R be the class of the object referred to by the run-time reference value, and let T be the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of the type named in the cast operator. A cast conversion must check, at run time, that the class R is assignment compatible with the type T, via the algorithm in [¬ß5.5.3](jls-5.html#jls-5.5.3 "5.5.3. Checked Casts at Run Time").
    
    Note that R cannot be an interface when these rules are first applied for any given cast, but R may be an interface if the rules are applied recursively because the run-time reference value may refer to an array whose element type is an interface type.
    

### 5.5.3. Checked Casts at Run Time

Here is the algorithm to check whether the run-time type R of an object is assignment compatible with the type T which is the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of the type named in the cast operator. If a run-time exception is thrown, it is a `ClassCastException`.

If R is an ordinary class (not an array class):

*   If T is a class type, then R must be either the same class ([¬ß4.3.4](jls-4.html#jls-4.3.4 "4.3.4. When Reference Types Are the Same")) as T or a subclass of T, or a run-time exception is thrown.
*   If T is an interface type, then R must implement ([¬ß8.1.5](jls-8.html#jls-8.1.5 "8.1.5. Superinterfaces")) interface T, or a run-time exception is thrown.
*   If T is an array type, then a run-time exception is thrown.
    

If R is an interface:

*   If T is a class type, then T must be `Object` ([¬ß4.3.2](jls-4.html#jls-4.3.2 "4.3.2. The Class Object")), or a run-time exception is thrown.
*   If T is an interface type, then R must be either the same interface as T or a subinterface of T, or a run-time exception is thrown.
*   If T is an array type, then a run-time exception is thrown.
    

If R is a class representing an array type RC`[]`, that is, an array of components of type RC:

*   If T is a class type, then T must be `Object` ([¬ß4.3.2](jls-4.html#jls-4.3.2 "4.3.2. The Class Object")), or a run-time exception is thrown.
*   If T is an interface type, then a run-time exception is thrown unless T is the type `java.io.Serializable` or the type `Cloneable` (the only interfaces implemented by arrays).
    
    This case could slip past the compile-time checking if, for example, a reference to an array were stored in a variable of type `Object`.
*   If T is an array type TC`[]`, that is, an array of components of type TC, then a run-time exception is thrown unless one of the following is true:
    
    *   TC and RC are the same primitive type.
        
    *   TC and RC are reference types and type RC can be cast to TC by a recursive application of these run-time rules for casting.
        
    

**Example 5.5.3-1. Incompatible Types at Run Time**

class Point { int x, y; }
interface Colorable { void setColor(int color); }
class ColoredPoint extends Point implements Colorable {
    int color;
    public void setColor(int color) { this.color = color; }
}

class Test {
    public static void main(String\[\] args) {
        Point\[\] pa = new Point\[100\];

        // The following line will throw a ClassCastException:
        ColoredPoint\[\] cpa = (ColoredPoint\[\])pa;
        System.out.println(cpa\[0\]);
        int\[\] shortvec = new int\[2\];
        Object o = shortvec;

        // The following line will throw a ClassCastException:
        Colorable c = (Colorable)o;
        c.setColor(0);
    }
}

This program uses casts to compile, but it throws exceptions at run time, because the types are incompatible.

  

5.6. Numeric Contexts
---------------------

_Numeric contexts_ apply to the operands of an arithmetic operator.

Numeric contexts allow the use of:

*   an identity conversion ([¬ß5.1.1](jls-5.html#jls-5.1.1 "5.1.1. Identity Conversion"))
*   a widening primitive conversion ([¬ß5.1.2](jls-5.html#jls-5.1.2 "5.1.2. Widening Primitive Conversion"))
*   an unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) optionally followed by a widening primitive conversion
    

A _numeric promotion_ is a process by which, given an arithmetic operator and its argument expressions, the arguments are converted to an inferred target type T. T is chosen during promotion such that each argument expression can be converted to T and the arithmetic operation is defined for values of type T.

The two kinds of numeric promotion are unary numeric promotion ([¬ß5.6.1](jls-5.html#jls-5.6.1 "5.6.1. Unary Numeric Promotion")) and binary numeric promotion ([¬ß5.6.2](jls-5.html#jls-5.6.2 "5.6.2. Binary Numeric Promotion")).

### 5.6.1. Unary Numeric Promotion

Some operators apply _unary numeric promotion_ to a single operand, which must produce a value of a numeric type:

*   If the operand is of compile-time type `Byte`, `Short`, `Character`, or `Integer`, it is subjected to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")). The result is then promoted to a value of type `int` by a widening primitive conversion ([¬ß5.1.2](jls-5.html#jls-5.1.2 "5.1.2. Widening Primitive Conversion")) or an identity conversion ([¬ß5.1.1](jls-5.html#jls-5.1.1 "5.1.1. Identity Conversion")).
*   Otherwise, if the operand is of compile-time type `Long`, `Float`, or `Double`, it is subjected to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).
*   Otherwise, if the operand is of compile-time type `byte`, `short`, or `char`, it is promoted to a value of type `int` by a widening primitive conversion ([¬ß5.1.2](jls-5.html#jls-5.1.2 "5.1.2. Widening Primitive Conversion")).
*   Otherwise, a unary numeric operand remains as is and is not converted.
    

After the conversion(s), if any, value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")) is then applied.

Unary numeric promotion is performed on expressions in the following situations:

*   Each dimension expression in an array creation expression ([¬ß15.10.1](jls-15.html#jls-15.10.1 "15.10.1. Array Creation Expressions"))
*   The index expression in an array access expression ([¬ß15.10.3](jls-15.html#jls-15.10.3 "15.10.3. Array Access Expressions"))
*   The operand of a unary plus operator `+` ([¬ß15.15.3](jls-15.html#jls-15.15.3 "15.15.3. Unary Plus Operator +"))
*   The operand of a unary minus operator `-` ([¬ß15.15.4](jls-15.html#jls-15.15.4 "15.15.4. Unary Minus Operator -"))
*   The operand of a bitwise complement operator `~` ([¬ß15.15.5](jls-15.html#jls-15.15.5 "15.15.5. Bitwise Complement Operator ~"))
*   Each operand, separately, of a shift operator `<<`, `>>`, or `>>>` ([¬ß15.19](jls-15.html#jls-15.19 "15.19. Shift Operators")).
    
    A `long` shift distance (right operand) does not promote the value being shifted (left operand) to `long`.
    

**Example 5.6.1-1. Unary Numeric Promotion**

class Test {
    public static void main(String\[\] args) {
        byte b = 2;
        int a\[\] = new int\[b\];  // dimension expression promotion
        char c = '\\u0001';
        a\[c\] = 1;              // index expression promotion
        a\[0\] = -c;             // unary - promotion
        System.out.println("a: " + a\[0\] + "," + a\[1\]);
        b = -1;
        int i = ~b;            // bitwise complement promotion
        System.out.println("~0x" + Integer.toHexString(b)
                           + "==0x" + Integer.toHexString(i));
        i = b << 4L;           // shift promotion (left operand)
        System.out.println("0x" + Integer.toHexString(b)
                           + "<<4L==0x" + Integer.toHexString(i));
    }
}

This program produces the output:

a: -1,1
~0xffffffff==0x0
0xffffffff<<4L==0xfffffff0

  

### 5.6.2. Binary Numeric Promotion

When an operator applies _binary numeric promotion_ to a pair of operands, each of which must denote a value that is convertible to a numeric type, the following rules apply, in order:

1.  If any operand is of a reference type, it is subjected to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).
    
2.  Widening primitive conversion ([¬ß5.1.2](jls-5.html#jls-5.1.2 "5.1.2. Widening Primitive Conversion")) is applied to convert either or both operands as specified by the following rules:
    
    *   If either operand is of type `double`, the other is converted to `double`.
        
    *   Otherwise, if either operand is of type `float`, the other is converted to `float`.
        
    *   Otherwise, if either operand is of type `long`, the other is converted to `long`.
        
    *   Otherwise, both operands are converted to type `int`.
        
    

After the conversion(s), if any, value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")) is then applied to each operand.

Binary numeric promotion is performed on the operands of certain operators:

*   The multiplicative operators `*`, `/`, and `%` ([¬ß15.17](jls-15.html#jls-15.17 "15.17. Multiplicative Operators"))
*   The addition and subtraction operators for numeric types `+` and `-` ([¬ß15.18.2](jls-15.html#jls-15.18.2 "15.18.2. Additive Operators (+ and -) for Numeric Types"))
*   The numerical comparison operators `<`, `<=`, `>`, and `>=` ([¬ß15.20.1](jls-15.html#jls-15.20.1 "15.20.1. Numerical Comparison Operators <, <=, >, and >="))
*   The numerical equality operators `==` and `!=` ([¬ß15.21.1](jls-15.html#jls-15.21.1 "15.21.1. Numerical Equality Operators == and !="))
*   The integer bitwise operators `&`, `^`, and `|` ([¬ß15.22.1](jls-15.html#jls-15.22.1 "15.22.1. Integer Bitwise Operators &, ^, and |"))
*   In certain cases, the conditional operator `? :` ([¬ß15.25](jls-15.html#jls-15.25 "15.25. Conditional Operator ? :"))
    

**Example 5.6.2-1. Binary Numeric Promotion**

class Test {
    public static void main(String\[\] args) {
        int i    = 0;
        float f  = 1.0f;
        double d = 2.0;
        // First int\*float is promoted to float\*float, then
        // float==double is promoted to double==double:
        if (i \* f == d) System.out.println("oops");
		
        // A char&byte is promoted to int&int:
        byte b = 0x1f;
        char c = 'G';
        int control = c & b;
        System.out.println(Integer.toHexString(control));
		
        // Here int:float is promoted to float:float:
        f = (b==0) ? i : 4.0f;
        System.out.println(1.0/f);
    }
}

This program produces the output:

7
0.25

The example converts the ASCII character `G` to the ASCII control-G (BEL), by masking off all but the low 5 bits of the character. The `7` is the numeric value of this control character.


üçÄ Chapter 6. Names
----------------

**Table of Contents**

[6.1. Declarations](jls-6.html#jls-6.1)
[6.2. Names and Identifiers](jls-6.html#jls-6.2)
[6.3. Scope of a Declaration](jls-6.html#jls-6.3)
[6.4. Shadowing and Obscuring](jls-6.html#jls-6.4)
[6.4.1. Shadowing](jls-6.html#jls-6.4.1)
[6.4.2. Obscuring](jls-6.html#jls-6.4.2)
[6.5. Determining the Meaning of a Name](jls-6.html#jls-6.5)
[6.5.1. Syntactic Classification of a Name According to Context](jls-6.html#jls-6.5.1)
[6.5.2. Reclassification of Contextually Ambiguous Names](jls-6.html#jls-6.5.2)
[6.5.3. Meaning of Package Names](jls-6.html#jls-6.5.3)
[6.5.3.1. Simple Package Names](jls-6.html#jls-6.5.3.1)
[6.5.3.2. Qualified Package Names](jls-6.html#jls-6.5.3.2)
[6.5.4. Meaning of _PackageOrTypeNames_](jls-6.html#jls-6.5.4)
[6.5.4.1. Simple _PackageOrTypeNames_](jls-6.html#jls-6.5.4.1)
[6.5.4.2. Qualified _PackageOrTypeNames_](jls-6.html#jls-6.5.4.2)
[6.5.5. Meaning of Type Names](jls-6.html#jls-6.5.5)
[6.5.5.1. Simple Type Names](jls-6.html#jls-6.5.5.1)
[6.5.5.2. Qualified Type Names](jls-6.html#jls-6.5.5.2)
[6.5.6. Meaning of Expression Names](jls-6.html#jls-6.5.6)
[6.5.6.1. Simple Expression Names](jls-6.html#jls-6.5.6.1)
[6.5.6.2. Qualified Expression Names](jls-6.html#jls-6.5.6.2)
[6.5.7. Meaning of Method Names](jls-6.html#jls-6.5.7)
[6.5.7.1. Simple Method Names](jls-6.html#jls-6.5.7.1)
[6.6. Access Control](jls-6.html#jls-6.6)
[6.6.1. Determining Accessibility](jls-6.html#jls-6.6.1)
[6.6.2. Details on `protected` Access](jls-6.html#jls-6.6.2)
[6.6.2.1. Access to a `protected` Member](jls-6.html#jls-6.6.2.1)
[6.6.2.2. Qualified Access to a `protected` Constructor](jls-6.html#jls-6.6.2.2)
[6.7. Fully Qualified Names and Canonical Names](jls-6.html#jls-6.7)

Names are used to refer to entities declared in a program.

A declared entity ([¬ß6.1](jls-6.html#jls-6.1 "6.1. Declarations")) is a package, class type (normal or enum), interface type (normal or annotation type), member (class, interface, field, or method) of a reference type, type parameter (of a class, interface, method or constructor), parameter (to a method, constructor, or exception handler), or local variable.

Names in programs are either _simple_, consisting of a single identifier, or _qualified_, consisting of a sequence of identifiers separated by "`.`" tokens ([¬ß6.2](jls-6.html#jls-6.2 "6.2. Names and Identifiers")).

Every declaration that introduces a name has a _scope_ ([¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration")), which is the part of the program text within which the declared entity can be referred to by a simple name.

A qualified name `N.x` may be used to refer to a _member_ of a package or reference type, where `N` is a simple or qualified name and `x` is an identifier. If `N` names a package, then `x` is a member of that package, which is either a class or interface type or a subpackage. If `N` names a reference type or a variable of a reference type, then `x` names a member of that type, which is either a class, an interface, a field, or a method.

In determining the meaning of a name ([¬ß6.5](jls-6.html#jls-6.5 "6.5. Determining the Meaning of a Name")), the context of the occurrence is used to disambiguate among packages, types, variables, and methods with the same name.

Access control ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) can be specified in a class, interface, method, or field declaration to control when _access_ to a member is allowed. Access is a different concept from scope. Access specifies the part of the program text within which the declared entity can be referred to by a qualified name. Access to a declared entity is also relevant in a field access expression ([¬ß15.11](jls-15.html#jls-15.11 "15.11. Field Access Expressions")), a method invocation expression in which the method is not specified by a simple name ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")), a method reference expression ([¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions")), or a qualified class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")). In the absence of an access modifier, most declarations have package access, allowing access anywhere within the package that contains its declaration; other possibilities are `public`, `protected`, and `private`.

Fully qualified and canonical names ([¬ß6.7](jls-6.html#jls-6.7 "6.7. Fully Qualified Names and Canonical Names")) are also discussed in this chapter.

6.1. Declarations
-----------------

A _declaration_ introduces an entity into a program and includes an identifier ([¬ß3.8](jls-3.html#jls-3.8 "3.8. Identifiers")) that can be used in a name to refer to this entity.

A declared entity is one of the following:

*   A package, declared in a `package` declaration ([¬ß7.4](jls-7.html#jls-7.4 "7.4. Package Declarations"))
*   An imported type, declared in a single-type-import declaration or a type-import-on-demand declaration ([¬ß7.5.1](jls-7.html#jls-7.5.1 "7.5.1. Single-Type-Import Declarations"), [¬ß7.5.2](jls-7.html#jls-7.5.2 "7.5.2. Type-Import-on-Demand Declarations"))
*   An imported `static` member, declared in a single-static-import declaration or a static-import-on-demand declaration ([¬ß7.5.3](jls-7.html#jls-7.5.3 "7.5.3. Single-Static-Import Declarations"), [¬ß7.5.4](jls-7.html#jls-7.5.4 "7.5.4. Static-Import-on-Demand Declarations"))
*   A class, declared in a class type declaration ([¬ß8.1](jls-8.html#jls-8.1 "8.1. Class Declarations"))
*   An interface, declared in an interface type declaration ([¬ß9.1](jls-9.html#jls-9.1 "9.1. Interface Declarations"))
*   A type parameter, declared as part of the declaration of a generic class, interface, method, or constructor ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters"), [¬ß9.1.2](jls-9.html#jls-9.1.2 "9.1.2. Generic Interfaces and Type Parameters"), [¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods"), [¬ß8.8.4](jls-8.html#jls-8.8.4 "8.8.4. Generic Constructors"))
*   A member of a reference type ([¬ß8.2](jls-8.html#jls-8.2 "8.2. Class Members"), [¬ß9.2](jls-9.html#jls-9.2 "9.2. Interface Members"), [¬ß8.9.3](jls-8.html#jls-8.9.3 "8.9.3. Enum Members"), [¬ß9.6](jls-9.html#jls-9.6 "9.6. Annotation Types"), [¬ß10.7](jls-10.html#jls-10.7 "10.7. Array Members")), one of the following:
    
    *   A member class ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations"))
        
    *   A member interface ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations"))
        
    *   An enum constant ([¬ß8.9](jls-8.html#jls-8.9 "8.9. Enum Types"))
        
    *   A field, one of the following:
        
        *   A field declared in a class type or enum type ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations"), [¬ß8.9.2](jls-8.html#jls-8.9.2 "8.9.2. Enum Body Declarations"))
            
        *   A field declared in an interface type or annotation type ([¬ß9.3](jls-9.html#jls-9.3 "9.3. Field (Constant) Declarations"), [¬ß9.6.1](jls-9.html#jls-9.6.1 "9.6.1. Annotation Type Elements"))
            
        *   The field `length`, which is implicitly a member of every array type ([¬ß10.7](jls-10.html#jls-10.7 "10.7. Array Members"))
            
        
    *   A method, one of the following:
        
        *   A method (`abstract` or otherwise) declared in a class type or enum type ([¬ß8.4](jls-8.html#jls-8.4 "8.4. Method Declarations"), [¬ß8.9.2](jls-8.html#jls-8.9.2 "8.9.2. Enum Body Declarations"))
            
        *   A method (always `abstract`) declared in an interface type or annotation type ([¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations"), [¬ß9.6.1](jls-9.html#jls-9.6.1 "9.6.1. Annotation Type Elements"))
            
        
*   A parameter, one of the following:
    
    *   A formal parameter of a method or constructor of a class type or enum type ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"), [¬ß8.8.1](jls-8.html#jls-8.8.1 "8.8.1. Formal Parameters"), [¬ß8.9.2](jls-8.html#jls-8.9.2 "8.9.2. Enum Body Declarations")), or of a lambda expression ([¬ß15.27.1](jls-15.html#jls-15.27.1 "15.27.1. Lambda Parameters"))
        
    *   A formal parameter of an `abstract` method of an interface type or annotation type ([¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations"), [¬ß9.6.1](jls-9.html#jls-9.6.1 "9.6.1. Annotation Type Elements"))
        
    *   An exception parameter of an exception handler declared in a `catch` clause of a `try` statement ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement"))
        
*   A local variable, one of the following:
    
    *   A local variable declared in a block ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements"))
        
    *   A local variable declared in a `for` statement ([¬ß14.14](jls-14.html#jls-14.14 "14.14. The for Statement"))
        
    

Constructors ([¬ß8.8](jls-8.html#jls-8.8 "8.8. Constructor Declarations")) are also introduced by declarations, but use the name of the class in which they are declared rather than introducing a new name.

The declaration of a type which is not generic (`class C ...`) declares one entity: a non-generic type (`C`). A non-generic type is not a raw type, despite the syntactic similarity. In contrast, the declaration of a generic type (`class C<T> ...` or `interface C<T> ...`) declares two entities: a generic type (`C<T>`) and a corresponding non-generic type (`C`). In this case, the meaning of the term `C` depends on the context where it appears:

*   If genericity is unimportant, as in the _non-generic contexts_ identified below, the identifier `C` denotes the non-generic type `C`.
*   If genericity is important, as in all contexts from [¬ß6.5](jls-6.html#jls-6.5 "6.5. Determining the Meaning of a Name") except the non-generic contexts, the identifier `C` denotes either:
    
    *   The raw type `C` which is the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of the generic type `C<T>`; or
        
    *   A parameterized type which is a particular parameterization ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")) of the generic type `C<T>`.
        
    

The 13 non-generic contexts are as follows:

1.  In a single-type-import declaration ([¬ß7.5.1](jls-7.html#jls-7.5.1 "7.5.1. Single-Type-Import Declarations"))
    
2.  To the left of the `.` in a single-static-import declaration ([¬ß7.5.3](jls-7.html#jls-7.5.3 "7.5.3. Single-Static-Import Declarations"))
    
3.  To the left of the `.` in a static-import-on-demand declaration ([¬ß7.5.4](jls-7.html#jls-7.5.4 "7.5.4. Static-Import-on-Demand Declarations"))
    
4.  To the left of the `(` in a constructor declaration ([¬ß8.8](jls-8.html#jls-8.8 "8.8. Constructor Declarations"))
    
5.  After the `@` sign in an annotation ([¬ß9.7](jls-9.html#jls-9.7 "9.7. Annotations"))
    
6.  To the left of `.``class` in a class literal ([¬ß15.8.2](jls-15.html#jls-15.8.2 "15.8.2. Class Literals"))
    
7.  To the left of `.``this` in a qualified `this` expression ([¬ß15.8.4](jls-15.html#jls-15.8.4 "15.8.4. Qualified this"))
    
8.  To the left of `.``super` in a qualified superclass field access expression ([¬ß15.11.2](jls-15.html#jls-15.11.2 "15.11.2. Accessing Superclass Members using super"))
    
9.  To the left of `.`_Identifier_ or `.``super``.`_Identifier_ in a qualified method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions"))
    
10.  To the left of `.``super``::` in a method reference expression ([¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions"))
    
11.  In a qualified expression name in a postfix expression ([¬ß15.14.1](jls-15.html#jls-15.14.1 "15.14.1. Expression Names"))
    
12.  In a `throws` clause of a method or constructor ([¬ß8.4.6](jls-8.html#jls-8.4.6 "8.4.6. Method Throws"), [¬ß8.8.5](jls-8.html#jls-8.8.5 "8.8.5. Constructor Throws"), [¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations"))
    
13.  In an exception parameter declaration ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement"))
    

The first ten non-generic contexts correspond to the first ten syntactic contexts for a _TypeName_ in [¬ß6.5.1](jls-6.html#jls-6.5.1 "6.5.1. Syntactic Classification of a Name According to Context"). The eleventh non-generic context is a postfix expression, where a qualified _ExpressionName_ such as `C.x` may include a _TypeName_ `C` to denote static member access. The common use of _TypeName_ is significant: it indicates that these contexts involve a less-than-first-class use of a type. In contrast, the twelfth and thirteenth non-generic contexts employ _ClassType_, indicating that `throws` and `catch` clauses use types in a first-class way, in line with, say, field declarations. The characterization of these two contexts as non-generic is due to the fact that an exception type cannot be parameterized.

Note that the _ClassType_ production allows annotations, so it is possible to annotate the use of a type in a `throws` or `catch` clause, whereas the _TypeName_ production disallows annotations, so it is not possible to annotate the name of a type in, say, a single-type-import declaration.

_Naming Conventions_

The class libraries of the Java SE platform attempt to use, whenever possible, names chosen according to the conventions presented below. These conventions help to make code more readable and avoid certain kinds of name conflicts.

We recommend these conventions for use in all programs written in the Java programming language. However, these conventions should not be followed slavishly if long-held conventional usage dictates otherwise. So, for example, the `sin` and `cos` methods of the class `java.lang.Math` have mathematically conventional names, even though these method names flout the convention suggested here because they are short and are not verbs.

_Package Names_

Developers should take steps to avoid the possibility of two published packages having the same name by choosing _unique package names_ for packages that are widely distributed. This allows packages to be easily and automatically installed and catalogued. This section specifies a suggested convention for generating such unique package names. Implementations of the Java SE platform are encouraged to provide automatic support for converting a set of packages from local and casual package names to the unique name format described here.

If unique package names are not used, then package name conflicts may arise far from the point of creation of either of the conflicting packages. This may create a situation that is difficult or impossible for the user or programmer to resolve. The class `ClassLoader` can be used to isolate packages with the same name from each other in those cases where the packages will have constrained interactions, but not in a way that is transparent to a na√Øve program.

You form a unique package name by first having (or belonging to an organization that has) an Internet domain name, such as `oracle.com`. You then reverse this name, component by component, to obtain, in this example, `com.oracle`, and use this as a prefix for your package names, using a convention developed within your organization to further administer package names. Such a convention might specify that certain package name components be division, department, project, machine, or login names.

**Example 6.1-1. Unique Package Names**

com.nighthacks.java.jag.scrabble
org.openjdk.tools.compiler
net.jcip.annotations
edu.cmu.cs.bovik.cheese
gov.whitehouse.socks.mousefinder

  

The first component of a unique package name is always written in all-lowercase ASCII letters and should be one of the top level domain names, such as `com`, `edu`, `gov`, `mil`, `net`, or `org`, or one of the English two-letter codes identifying countries as specified in _ISO Standard 3166_.

The name of a package is not meant to imply where the package is stored on the Internet. The suggested convention for generating unique package names is merely a way to piggyback a package naming convention on top of an existing, widely known unique name registry instead of having to create a separate registry for package names.

For example, a package named `edu.cmu.cs.bovik.cheese` is not necessarily obtainable from Internet address `cmu.edu` or `cs.cmu.edu` or `bovik.cs.cmu.edu`.

In some cases, the Internet domain name may not be a valid package name. Here are some suggested conventions for dealing with these situations:

*   If the domain name contains a hyphen, or any other special character not allowed in an identifier ([¬ß3.8](jls-3.html#jls-3.8 "3.8. Identifiers")), convert it into an underscore.
*   If any of the resulting package name components are keywords ([¬ß3.9](jls-3.html#jls-3.9 "3.9. Keywords")), append an underscore to them.
*   If any of the resulting package name components start with a digit, or any other character that is not allowed as an initial character of an identifier, have an underscore prefixed to the component.
    

Names of packages intended only for local use should have a first identifier that begins with a lowercase letter, but that first identifier specifically should not be the identifier `java`; package names that start with the identifier `java` are reserved for packages of the Java SE platform.

_Class and Interface Type Names_

Names of class types should be descriptive nouns or noun phrases, not overly long, in mixed case with the first letter of each word capitalized.

**Example 6.1-2. Descriptive Class Names**

    ClassLoader

  

Likewise, names of interface types should be short and descriptive, not overly long, in mixed case with the first letter of each word capitalized. The name may be a descriptive noun or noun phrase, which is appropriate when an interface is used as if it were an abstract superclass, such as interfaces `java.io.DataInput` and `java.io.DataOutput`; or it may be an adjective describing a behavior, as for the interfaces `Runnable` and `Cloneable`.

_Type Variable Names_

Type variable names should be pithy (single character if possible) yet evocative, and should not include lower case letters. This makes it easy to distinguish type parameters from ordinary classes and interfaces.

Container types should use the name `E` for their element type. Maps should use `K` for the type of their keys and `V` for the type of their values. The name `X` should be used for arbitrary exception types. We use `T` for type, whenever there is not anything more specific about the type to distinguish it. (This is often the case in generic methods.)

If there are multiple type parameters that denote arbitrary types, one should use letters that neighbor `T` in the alphabet, such as `S`. Alternately, it is acceptable to use numeric subscripts (e.g., `T1`, `T2`) to distinguish among the different type variables. In such cases, all the variables with the same prefix should be subscripted.

If a generic method appears inside a generic class, it is a good idea to avoid using the same names for the type parameters of the method and class, to avoid confusion. The same applies to nested generic classes.

**Example 6.1-3. Conventional Type Variable Names**

public class HashSet<E> extends AbstractSet<E> { ... }
public class HashMap<K,V> extends AbstractMap<K,V> { ... }
public class ThreadLocal<T> { ... }
public interface Functor<T, X extends Throwable> {
    T eval() throws X;
}

  

When type parameters do not fall conveniently into one of the categories mentioned, names should be chosen to be as meaningful as possible within the confines of a single letter. The names mentioned above (`E`, `K`, `V`, `X`, `T`) should not be used for type parameters that do not fall into the designated categories.

_Method Names_

Method names should be verbs or verb phrases, in mixed case, with the first letter lowercase and the first letter of any subsequent words capitalized. Here are some additional specific conventions for method names:

*   Methods to get and set an attribute that might be thought of as a variable _V_ should be named `get_V_` and `set_V_`. An example is the methods `getPriority` and `setPriority` of class `Thread`.
*   A method that returns the length of something should be named `length`, as in class `String`.
*   A method that tests a boolean condition _V_ about an object should be named `is_V_`. An example is the method `isInterrupted` of class `Thread`.
*   A method that converts its object to a particular format _F_ should be named `to_F_`. Examples are the method `toString` of class `Object` and the methods `toLocaleString` and `toGMTString` of class `java.util.Date`.
    

Whenever possible and appropriate, basing the names of methods in a new class on names in an existing class that is similar, especially a class from the Java SE platform API, will make it easier to use.

_Field Names_

Names of fields that are not `final` should be in mixed case with a lowercase first letter and the first letters of subsequent words capitalized. Note that well-designed classes have very few `public` or `protected` fields, except for fields that are constants (`static` `final` fields).

Fields should have names that are nouns, noun phrases, or abbreviations for nouns.

Examples of this convention are the fields `buf`, `pos`, and `count` of the class `java.io.ByteArrayInputStream` and the field `bytesTransferred` of the class `java.io.InterruptedIOException`.

_Constant Names_

The names of constants in interface types should be, and `final` variables of class types may conventionally be, a sequence of one or more words, acronyms, or abbreviations, all uppercase, with components separated by underscore "`_`" characters. Constant names should be descriptive and not unnecessarily abbreviated. Conventionally they may be any appropriate part of speech.

Examples of names for constants include `MIN_VALUE`, `MAX_VALUE`, `MIN_RADIX`, and `MAX_RADIX` of the class `Character`.

A group of constants that represent alternative values of a set, or, less frequently, masking bits in an integer value, are sometimes usefully specified with a common acronym as a name prefix.

For example:

interface ProcessStates {
    int PS\_RUNNING   = 0;
    int PS\_SUSPENDED = 1;
}

_Local Variable and Parameter Names_

Local variable and parameter names should be short, yet meaningful. They are often short sequences of lowercase letters that are not words, such as:

*   Acronyms, that is the first letter of a series of words, as in `cp` for a variable holding a reference to a `ColoredPoint`
*   Abbreviations, as in `buf` holding a pointer to a buffer of some kind
*   Mnemonic terms, organized in some way to aid memory and understanding, typically by using a set of local variables with conventional names patterned after the names of parameters to widely used classes. For example:
    
    *   `in` and `out`, whenever some kind of input and output are involved, patterned after the fields of `System`
        
    *   `off` and `len`, whenever an offset and length are involved, patterned after the parameters to the `read` and `write` methods of the interfaces `DataInput` and `DataOutput` of `java.io`
        
    

One-character local variable or parameter names should be avoided, except for temporary and looping variables, or where a variable holds an undistinguished value of a type. Conventional one-character names are:

*   `b` for a `byte`
*   `c` for a `char`
*   `d` for a `double`
*   `e` for an `Exception`
*   `f` for a `float`
*   `i`, `j`, and `k` for `int`s
*   `l` for a `long`
*   `o` for an `Object`
*   `s` for a `String`
*   `v` for an arbitrary value of some type
    

Local variable or parameter names that consist of only two or three lowercase letters should not conflict with the initial country codes and domain names that are the first component of unique package names.

6.2. Names and Identifiers
--------------------------

A _name_ is used to refer to an entity declared in a program.

There are two forms of names: simple names and qualified names.

A _simple name_ is a single identifier.

A _qualified name_ consists of a name, a "`.`" token, and an identifier.

In determining the meaning of a name ([¬ß6.5](jls-6.html#jls-6.5 "6.5. Determining the Meaning of a Name")), the context in which the name appears is taken into account. The rules of [¬ß6.5](jls-6.html#jls-6.5 "6.5. Determining the Meaning of a Name") distinguish among contexts where a name must denote (refer to) a package ([¬ß6.5.3](jls-6.html#jls-6.5.3 "6.5.3. Meaning of Package Names")), a type ([¬ß6.5.5](jls-6.html#jls-6.5.5 "6.5.5. Meaning of Type Names")), a variable or value in an expression ([¬ß6.5.6](jls-6.html#jls-6.5.6 "6.5.6. Meaning of Expression Names")), or a method ([¬ß6.5.7](jls-6.html#jls-6.5.7 "6.5.7. Meaning of Method Names")).

Packages and reference types have _members_ which may be accessed by qualified names. As background for the discussion of qualified names and the determination of the meaning of names, see the descriptions of membership in [¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables"), [¬ß4.5.2](jls-4.html#jls-4.5.2 "4.5.2. Members and Constructors of Parameterized Types"), [¬ß4.8](jls-4.html#jls-4.8 "4.8. Raw Types"), [¬ß4.9](jls-4.html#jls-4.9 "4.9. Intersection Types"), [¬ß7.1](jls-7.html#jls-7.1 "7.1. Package Members"), [¬ß8.2](jls-8.html#jls-8.2 "8.2. Class Members"), [¬ß9.2](jls-9.html#jls-9.2 "9.2. Interface Members"), and [¬ß10.7](jls-10.html#jls-10.7 "10.7. Array Members").

Not all identifiers in a program are a part of a name. Identifiers are also used in the following situations:

*   In declarations ([¬ß6.1](jls-6.html#jls-6.1 "6.1. Declarations")), where an identifier may occur to specify the name by which the declared entity will be known.As labels in labeled statements ([¬ß14.7](jls-14.html#jls-14.7 "14.7. Labeled Statements")) and in `break` and `continue` statements ([¬ß14.15](jls-14.html#jls-14.15 "14.15. The break Statement"), [¬ß14.16](jls-14.html#jls-14.16 "14.16. The continue Statement")) that refer to statement labels.

The identifiers used in labeled statements and their associated `break` and `continue` statements are completely separate from those used in declarations.

*   In field access expressions ([¬ß15.11](jls-15.html#jls-15.11 "15.11. Field Access Expressions")), where an identifier occurs after a "`.`" token to indicate a member of the object denoted by the expression before the "`.`" token, or the object denoted by the `super` or _TypeName_`.``super` before the "`.`" token.
*   In some method invocation expressions ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")), wherever an identifier occurs after a "`.`" token and before a "`(`" token to indicate a method to be invoked for the object denoted by the expression before the "`.`" token, or the type denoted by the _TypeName_ before the "`.`" token, or the object denoted by the `super` or _TypeName_`.``super` before the "`.`" token.
*   In some method reference expressions ([¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions")), wherever an identifier occurs after a "`::`" token to indicate a method of the object denoted by the expression before the "`::`" token, or the type denoted by the _TypeName_ before the "`::`" token, or the object denoted by the `super` or _TypeName_`.``super` before the "`::`" token.
*   In qualified class instance creation expressions ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")), where an identifier occurs to the right of the `new` token to indicate a type that is a member of the compile-time type of the expression preceding the `new` token.
*   In element-value pairs of annotations ([¬ß9.7.1](jls-9.html#jls-9.7.1 "9.7.1. Normal Annotations")), to denote an element of the corresponding annotation type.
    

In this program:

class Test {
    public static void main(String\[\] args) {
        Class c = System.out.getClass();
        System.out.println(c.toString().length() +
                           args\[0\].length() + args.length);
    }
}

the identifiers `Test`, `main`, and the first occurrences of `args` and `c` are not names. Rather, they are identifiers used in declarations to specify the names of the declared entities. The names `String`, `Class`, `System.out.getClass`, `System.out.println`, `c.toString`, `args`, and `args.length` appear in the example.

The occurrence of `length` in `args.length` is a name because `args.length` is a qualified name ([¬ß6.5.6.2](jls-6.html#jls-6.5.6.2 "6.5.6.2. Qualified Expression Names")) and not a field access expression ([¬ß15.11](jls-15.html#jls-15.11 "15.11. Field Access Expressions")). A field access expression, as well as a method invocation expression, a method reference expression, and a qualified class instance creation expression, uses an identifier rather than a name to denote the member of interest. Thus, the occurrence of `length` in `args[0].length()` is _not_ a name, but rather an identifier appearing in a method invocation expression.

One might wonder why these kinds of expression use an identifier rather than a simple name, which is after all just an identifier. The reason is that a simple expression name is defined in terms of the lexical environment; that is, a simple expression name must be in the scope of a variable declaration ([¬ß6.5.6.1](jls-6.html#jls-6.5.6.1 "6.5.6.1. Simple Expression Names")). On the other hand, field access, qualified method invocation, method references, and qualified class instance creation all refer to members whose names are not in the lexical environment. By definition, such names are bound only in the context provided by the _Primary_ of the field access expression, method invocation expression, method reference expression, or class instance creation expression; or by the `super` of the field access expression, method invocation expression, or method reference expression; and so on. Thus, we denote such members with identifiers rather than simple names.

To complicate things further, a field access expression is not the only way to denote a field of an object. For parsing reasons, a qualified name is used to denote a field of an in-scope variable. (The variable itself is denoted with a simple name, alluded to above.) It is necessary for access control ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) to apply to both denotations of a field.

6.3. Scope of a Declaration
---------------------------

The _scope_ of a declaration is the region of the program within which the entity declared by the declaration can be referred to using a simple name, provided it is visible ([¬ß6.4.1](jls-6.html#jls-6.4.1 "6.4.1. Shadowing")).

A declaration is said to be _in scope_ at a particular point in a program if and only if the declaration's scope includes that point.

The scope of the declaration of an observable ([¬ß7.4.3](jls-7.html#jls-7.4.3 "7.4.3. Observability of a Package")) top level package is all observable compilation units ([¬ß7.3](jls-7.html#jls-7.3 "7.3. Compilation Units")).

The declaration of a package that is not observable is never in scope.

The declaration of a subpackage is never in scope.

The package `java` is always in scope.

The scope of a type imported by a single-type-import declaration ([¬ß7.5.1](jls-7.html#jls-7.5.1 "7.5.1. Single-Type-Import Declarations")) or a type-import-on-demand declaration ([¬ß7.5.2](jls-7.html#jls-7.5.2 "7.5.2. Type-Import-on-Demand Declarations")) is all the class and interface type declarations ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")) in the compilation unit in which the `import` declaration appears, as well as any annotations on the package declaration (if any) of the compilation unit .

The scope of a member imported by a single-static-import declaration ([¬ß7.5.3](jls-7.html#jls-7.5.3 "7.5.3. Single-Static-Import Declarations")) or a static-import-on-demand declaration ([¬ß7.5.4](jls-7.html#jls-7.5.4 "7.5.4. Static-Import-on-Demand Declarations")) is all the class and interface type declarations ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")) in the compilation unit in which the `import` declaration appears, as well as any annotations on the package declaration (if any) of the compilation unit .

The scope of a top level type ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")) is all type declarations in the package in which the top level type is declared.

The scope of a declaration of a member `m` declared in or inherited by a class type C ([¬ß8.1.6](jls-8.html#jls-8.1.6 "8.1.6. Class Body and Member Declarations")) is the entire body of C, including any nested type declarations.

The scope of a declaration of a member `m` declared in or inherited by an interface type I ([¬ß9.1.4](jls-9.html#jls-9.1.4 "9.1.4. Interface Body and Member Declarations")) is the entire body of I, including any nested type declarations.

The scope of an enum constant C declared in an enum type T is the body of T, and any `case` label of a `switch` statement whose expression is of enum type T ([¬ß14.11](jls-14.html#jls-14.11 "14.11. The switch Statement")).

The scope of a formal parameter of a method ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters")), constructor ([¬ß8.8.1](jls-8.html#jls-8.8.1 "8.8.1. Formal Parameters")), or lambda expression ([¬ß15.27](jls-15.html#jls-15.27 "15.27. Lambda Expressions")) is the entire body of the method, constructor, or lambda expression.

The scope of a class's type parameter ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters")) is the type parameter section of the class declaration, the type parameter section of any superclass or superinterface of the class declaration, and the class body.

The scope of an interface's type parameter ([¬ß9.1.2](jls-9.html#jls-9.1.2 "9.1.2. Generic Interfaces and Type Parameters")) is the type parameter section of the interface declaration, the type parameter section of any superinterface of the interface declaration, and the interface body.

The scope of a method's type parameter ([¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods")) is the entire declaration of the method, including the type parameter section, but excluding the method modifiers.

The scope of a constructor's type parameter ([¬ß8.8.4](jls-8.html#jls-8.8.4 "8.8.4. Generic Constructors")) is the entire declaration of the constructor, including the type parameter section, but excluding the constructor modifiers.

The scope of a local class declaration immediately enclosed by a block ([¬ß14.2](jls-14.html#jls-14.2 "14.2. Blocks")) is the rest of the immediately enclosing block, including its own class declaration.

The scope of a local class declaration immediately enclosed by a switch block statement group ([¬ß14.11](jls-14.html#jls-14.11 "14.11. The switch Statement")) is the rest of the immediately enclosing switch block statement group, including its own class declaration.

The scope of a local variable declaration in a block ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements")) is the rest of the block in which the declaration appears, starting with its own initializer and including any further declarators to the right in the local variable declaration statement.

The scope of a local variable declared in the _ForInit_ part of a basic `for` statement ([¬ß14.14.1](jls-14.html#jls-14.14.1 "14.14.1. The basic for Statement")) includes all of the following:

*   Its own initializer
*   Any further declarators to the right in the _ForInit_ part of the `for` statement
*   The _Expression_ and _ForUpdate_ parts of the `for` statement
*   The contained _Statement_
    

The scope of a local variable declared in the _FormalParameter_ part of an enhanced `for` statement ([¬ß14.14.2](jls-14.html#jls-14.14.2 "14.14.2. The enhanced for statement")) is the contained _Statement_.

The scope of a parameter of an exception handler that is declared in a `catch` clause of a `try` statement ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) is the entire block associated with the `catch`.

The scope of a variable declared in the _ResourceSpecification_ of a `try`\-with-resources statement ([¬ß14.20.3](jls-14.html#jls-14.20.3 "14.20.3. try-with-resources")) is from the declaration rightward over the remainder of the _ResourceSpecification_ and the entire `try` block associated with the `try`\-with-resources statement.

The translation of a `try`\-with-resources statement implies the rule above.

**Example 6.3-1. Scope of Type Declarations**

These rules imply that declarations of class and interface types need not appear before uses of the types. In the following program, the use of `PointList` in class `Point` is valid, because the scope of the class declaration `PointList` includes both class `Point` and class `PointList`, as well as any other type declarations in other compilation units of package `points`.

package points;
class Point {
    int x, y;
    PointList list;
    Point next;
}

class PointList {
    Point first;
}

  

**Example 6.3-2. Scope of Local Variable Declarations**

The following program causes a compile-time error because the initialization of local variable `x` is within the scope of the declaration of local variable `x`, but the local variable `x` does not yet have a value and cannot be used. The field `x` has a value of `0` (assigned when `Test1` was initialized) but is a red herring since it is shadowed ([¬ß6.4.1](jls-6.html#jls-6.4.1 "6.4.1. Shadowing")) by the local variable `x`.

class Test1 {
    static int x;
    public static void main(String\[\] args) {
        int x = x;
    }
}

The following program does compile:

class Test2 {
    static int x;
    public static void main(String\[\] args) {
        int x = (x=2)\*2;
        System.out.println(x);
    }
}

because the local variable `x` is definitely assigned ([¬ß16 (_Definite Assignment_)](jls-16.html "Chapter 16. Definite Assignment")) before it is used. It prints:

4

In the following program, the initializer for `three` can correctly refer to the variable `two` declared in an earlier declarator, and the method invocation in the next line can correctly refer to the variable `three` declared earlier in the block.

class Test3 {
    public static void main(String\[\] args) {
        System.out.print("2+1=");
        int two = 2, three = two + 1;
        System.out.println(three);
    }
}

This program produces the output:

2+1=3

  

6.4. Shadowing and Obscuring
----------------------------

A local variable ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements")), formal parameter ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"), [¬ß15.27.1](jls-15.html#jls-15.27.1 "15.27.1. Lambda Parameters")), exception parameter ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")), and local class ([¬ß14.3](jls-14.html#jls-14.3 "14.3. Local Class Declarations")) can only be referred to using a simple name, not a qualified name ([¬ß6.2](jls-6.html#jls-6.2 "6.2. Names and Identifiers")).

Some declarations are not permitted within the scope of a local variable, formal parameter, exception parameter, or local class declaration because it would be impossible to distinguish between the declared entities using only simple names.

For example, if the name of a formal parameter of a method could be redeclared as the name of a local variable in the method body, then the local variable would shadow the formal parameter and the formal parameter would no longer be visible - an undesirable outcome.

It is a compile-time error if the name of a formal parameter is used to declare a new variable within the body of the method, constructor, or lambda expression, unless the new variable is declared within a class declaration contained by the method, constructor, or lambda expression.

It is a compile-time error if the name of a local variable `v` is used to declare a new variable within the scope of `v`, unless the new variable is declared within a class whose declaration is within the scope of `v`.

It is a compile-time error if the name of an exception parameter is used to declare a new variable within the _Block_ of the `catch` clause, unless the new variable is declared within a class declaration contained by the _Block_ of the `catch` clause.

It is a compile-time error if the name of a local class C is used to declare a new local class within the scope of C, unless the new local class is declared within another class whose declaration is within the scope of C.

These rules allow redeclaration of a variable or local class in nested class declarations (local classes ([¬ß14.3](jls-14.html#jls-14.3 "14.3. Local Class Declarations")) and anonymous classes ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions"))) that occur in the scope of the variable or local class. Thus, the declaration of a formal parameter, local variable, or local class may be shadowed in a class declaration nested within a method, constructor, or lambda expression; and the declaration of an exception parameter may be shadowed inside a class declaration nested within the _Block_ of the `catch` clause.

There are two design alternatives for handling name clashes created by lambda parameters and other variables declared in lambda expressions. One is to mimic class declarations: like local classes, lambda expressions introduce a new "level" for names, and all variable names outside the expression can be redeclared. Another is a "local" strategy: like `catch` clauses, `for` loops, and blocks, lambda expressions operate at the same "level" as the enclosing context, and local variables outside the expression cannot be shadowed. The above rules use the local strategy; there is no special dispensation that allows a variable declared in a lambda expression to shadow a variable declared in an enclosing method.

Note that the rule for local classes does not make an exception for a class of the same name declared within the local class itself. However, this case is prohibited by a separate rule: a class cannot have the same name as a class that encloses it ([¬ß8.1](jls-8.html#jls-8.1 "8.1. Class Declarations")).

**Example 6.4-1. Attempted Shadowing Of A Local Variable**

Because a declaration of an identifier as a local variable of a method, constructor, or initializer block must not appear within the scope of a parameter or local variable of the same name, a compile-time error occurs for the following program:

class Test1 {
    public static void main(String\[\] args) {
        int i;
        for (int i = 0; i < 10; i++)
            System.out.println(i);
    }
}

This restriction helps to detect some otherwise very obscure bugs. A similar restriction on shadowing of members by local variables was judged impractical, because the addition of a member in a superclass could cause subclasses to have to rename local variables. Related considerations make restrictions on shadowing of local variables by members of nested classes, or on shadowing of local variables by local variables declared within nested classes unattractive as well.

Hence, the following program compiles without error:

class Test2 {
    public static void main(String\[\] args) {
        int i;
        class Local {
            {
                for (int i = 0; i < 10; i++)
                    System.out.println(i);
            }
        }
        new Local();
    }
}

On the other hand, local variables with the same name may be declared in two separate blocks or `for` statements, neither of which contains the other:

class Test3 {
    public static void main(String\[\] args) {
        for (int i = 0; i < 10; i++)
            System.out.print(i + " ");
        for (int i = 10; i > 0; i--)
            System.out.print(i + " ");
        System.out.println();
    }
}

This program compiles without error and, when executed, produces the output:

0 1 2 3 4 5 6 7 8 9 10 9 8 7 6 5 4 3 2 1

  

### 6.4.1. Shadowing

Some declarations may be _shadowed_ in part of their scope by another declaration of the same name, in which case a simple name cannot be used to refer to the declared entity.

Shadowing is distinct from hiding ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations"), [¬ß8.4.8.2](jls-8.html#jls-8.4.8.2 "8.4.8.2. Hiding (by Class Methods)"), [¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.3](jls-9.html#jls-9.3 "9.3. Field (Constant) Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")), which applies only to members which would otherwise be inherited but are not because of a declaration in a subclass. Shadowing is also distinct from obscuring ([¬ß6.4.2](jls-6.html#jls-6.4.2 "6.4.2. Obscuring")).

A declaration d is said to be _visible at point `p` in a program_ if the scope of d includes `p`, and d is not shadowed by any other declaration at `p`.

When the program point we are discussing is clear from context, we will often simply say that a declaration is _visible_.

A declaration d of a type named n shadows the declarations of any other types named n that are in scope at the point where d occurs throughout the scope of d.

A declaration d of a field or formal parameter named n shadows, throughout the scope of d, the declarations of any other variables named n that are in scope at the point where d occurs.

A declaration d of a local variable or exception parameter named n shadows, throughout the scope of d, (a) the declarations of any other fields named n that are in scope at the point where d occurs, and (b) the declarations of any other variables named n that are in scope at the point where d occurs but are _not_ declared in the innermost class in which d is declared.

A declaration d of a method named n shadows the declarations of any other methods named n that are in an enclosing scope at the point where d occurs throughout the scope of d.

A package declaration never shadows any other declaration.

A type-import-on-demand declaration never causes any other declaration to be shadowed.

A static-import-on-demand declaration never causes any other declaration to be shadowed.

A single-type-import declaration d in a compilation unit c of package p that imports a type named n shadows, throughout c, the declarations of:

*   any top level type named n declared in another compilation unit of p
*   any type named n imported by a type-import-on-demand declaration in c
*   any type named n imported by a static-import-on-demand declaration in c
    

A single-static-import declaration `d` in a compilation unit `c` of package `p` that imports a field named `n` shadows the declaration of any static field named `n` imported by a static-import-on-demand declaration in `c`, throughout `c`.

A single-static-import declaration `d` in a compilation unit `c` of package `p` that imports a method named `n` with signature s shadows the declaration of any static method named n with signature s imported by a static-import-on-demand declaration in `c`, throughout `c`.

A single-static-import declaration `d` in a compilation unit `c` of package `p` that imports a type named n shadows, throughout `c`, the declarations of:

*   any static type named n imported by a static-import-on-demand declaration in `c`;
*   any top level type ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")) named n declared in another compilation unit ([¬ß7.3](jls-7.html#jls-7.3 "7.3. Compilation Units")) of `p`;
*   any type named n imported by a type-import-on-demand declaration ([¬ß7.5.2](jls-7.html#jls-7.5.2 "7.5.2. Type-Import-on-Demand Declarations")) in `c`.
    

**Example 6.4.1-1. Shadowing of a Field Declaration by a Local Variable Declaration**

class Test {
    static int x = 1;
    public static void main(String\[\] args) {
        int x = 0;
        System.out.print("x=" + x);
        System.out.println(", Test.x=" + Test.x);
    }
}

This program produces the output:

x=0, Test.x=1

This program declares:

*   a class `Test`
*   a class (`static`) variable `x` that is a member of the class `Test`
*   a class method `main` that is a member of the class `Test`
*   a parameter `args` of the `main` method
*   a local variable `x` of the `main` method
    

Since the scope of a class variable includes the entire body of the class ([¬ß8.2](jls-8.html#jls-8.2 "8.2. Class Members")), the class variable `x` would normally be available throughout the entire body of the method `main`. In this example, however, the class variable `x` is shadowed within the body of the method `main` by the declaration of the local variable `x`.

A local variable has as its scope the rest of the block in which it is declared ([¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration")); in this case this is the rest of the body of the `main` method, namely its initializer "`0`" and the invocations of `System.out.print` and `System.out.println`.

This means that:

*   The expression `x` in the invocation of `print` refers to (denotes) the value of the local variable `x`.
*   The invocation of `println` uses a qualified name ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) `Test.x`, which uses the class type name `Test` to access the class variable `x`, because the declaration of `Test.x` is shadowed at this point and cannot be referred to by its simple name.
    

The keyword `this` can also be used to access a shadowed field `x`, using the form `this.x`. Indeed, this idiom typically appears in constructors ([¬ß8.8](jls-8.html#jls-8.8 "8.8. Constructor Declarations")):

class Pair {
    Object first, second;
    public Pair(Object first, Object second) {
        this.first = first;
        this.second = second;
    }
}

Here, the constructor takes parameters having the same names as the fields to be initialized. This is simpler than having to invent different names for the parameters and is not too confusing in this stylized context. In general, however, it is considered poor style to have local variables with the same names as fields.

  

**Example 6.4.1-2. Shadowing of a Type Declaration by Another Type Declaration**

import java.util.\*;
class Vector {
    int val\[\] = { 1 , 2 };
}

class Test {
    public static void main(String\[\] args) {
        Vector v = new Vector();
        System.out.println(v.val\[0\]);
    }
}

The program compiles and prints:

1

using the class `Vector` declared here in preference to the generic class `java.util.Vector` ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters")) that might be imported on demand.

  

### 6.4.2. Obscuring

A simple name may occur in contexts where it may potentially be interpreted as the name of a variable, a type, or a package. In these situations, the rules of [¬ß6.5](jls-6.html#jls-6.5 "6.5. Determining the Meaning of a Name") specify that a variable will be chosen in preference to a type, and that a type will be chosen in preference to a package. Thus, it is may sometimes be impossible to refer to a visible type or package declaration via its simple name. We say that such a declaration is _obscured_.

Obscuring is distinct from shadowing ([¬ß6.4.1](jls-6.html#jls-6.4.1 "6.4.1. Shadowing")) and hiding ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations"), [¬ß8.4.8.2](jls-8.html#jls-8.4.8.2 "8.4.8.2. Hiding (by Class Methods)"), [¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.3](jls-9.html#jls-9.3 "9.3. Field (Constant) Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")).

The naming conventions of [¬ß6.1](jls-6.html#jls-6.1 "6.1. Declarations") help reduce obscuring, but if it does occur, here are some notes about what you can do to avoid it.

When package names occur in expressions:

*   If a package name is obscured by a field declaration, then `import` declarations ([¬ß7.5](jls-7.html#jls-7.5 "7.5. Import Declarations")) can usually be used to make available the type names declared in that package.
*   If a package name is obscured by a declaration of a parameter or local variable, then the name of the parameter or local variable can be changed without affecting other code.
    

The first component of a package name is normally not easily mistaken for a type name, as a type name normally begins with a single uppercase letter. (The Java programming language does not actually rely on case distinctions to determine whether a name is a package name or a type name.)

Obscuring involving class and interface type names is rare. Names of fields, parameters, and local variables normally do not obscure type names because they conventionally begin with a lowercase letter whereas type names conventionally begin with an uppercase letter.

Method names cannot obscure or be obscured by other names ([¬ß6.5.7](jls-6.html#jls-6.5.7 "6.5.7. Meaning of Method Names")).

Obscuring involving field names is rare; however:

*   If a field name obscures a package name, then an `import` declaration ([¬ß7.5](jls-7.html#jls-7.5 "7.5. Import Declarations")) can usually be used to make available the type names declared in that package.
*   If a field name obscures a type name, then a fully qualified name for the type can be used unless the type name denotes a local class ([¬ß14.3](jls-14.html#jls-14.3 "14.3. Local Class Declarations")).
*   Field names cannot obscure method names.
*   If a field name is shadowed by a declaration of a parameter or local variable, then the name of the parameter or local variable can be changed without affecting other code.
    

Obscuring involving constant names is rare:

*   Constant names normally have no lowercase letters, so they will not normally obscure names of packages or types, nor will they normally shadow fields, whose names typically contain at least one lowercase letter.
*   Constant names cannot obscure method names, because they are distinguished syntactically.
    

6.5. Determining the Meaning of a Name
--------------------------------------

The meaning of a name depends on the context in which it is used. The determination of the meaning of a name requires three steps:

*   First, context causes a name syntactically to fall into one of six categories: _PackageName_, _TypeName_, _ExpressionName_, _MethodName_, _PackageOrTypeName_, or _AmbiguousName_.
*   Second, a name that is initially classified by its context as an _AmbiguousName_ or as a _PackageOrTypeName_ is then reclassified to be a _PackageName_, _TypeName_, or _ExpressionName_.
*   Third, the resulting category then dictates the final determination of the meaning of the name (or a compile-time error if the name has no meaning).
    

PackageName:

[Identifier](jls-3.html#jls-Identifier "Identifier")  
[PackageName](jls-6.html#jls-PackageName "PackageName") `.` [Identifier](jls-3.html#jls-Identifier "Identifier")

TypeName:

[Identifier](jls-3.html#jls-Identifier "Identifier")  
[PackageOrTypeName](jls-6.html#jls-PackageOrTypeName "PackageOrTypeName") `.` [Identifier](jls-3.html#jls-Identifier "Identifier")

PackageOrTypeName:

[Identifier](jls-3.html#jls-Identifier "Identifier")  
[PackageOrTypeName](jls-6.html#jls-PackageOrTypeName "PackageOrTypeName") `.` [Identifier](jls-3.html#jls-Identifier "Identifier")

ExpressionName:

[Identifier](jls-3.html#jls-Identifier "Identifier")  
[AmbiguousName](jls-6.html#jls-AmbiguousName "AmbiguousName") `.` [Identifier](jls-3.html#jls-Identifier "Identifier")

MethodName:

[Identifier](jls-3.html#jls-Identifier "Identifier")  

AmbiguousName:

[Identifier](jls-3.html#jls-Identifier "Identifier")  
[AmbiguousName](jls-6.html#jls-AmbiguousName "AmbiguousName") `.` [Id](jls-3.html#jls-Identifier "Identifier")entifier

The use of context helps to minimize name conflicts between entities of different kinds. Such conflicts will be rare if the naming conventions described in [¬ß6.1](jls-6.html#jls-6.1 "6.1. Declarations") are followed. Nevertheless, conflicts may arise unintentionally as types developed by different programmers or different organizations evolve. For example, types, methods, and fields may have the same name. It is always possible to distinguish between a method and a field with the same name, since the context of a use always tells whether a method is intended.

### 6.5.1. Syntactic Classification of a Name According to Context

A name is syntactically classified as a _TypeName_ in these contexts:

*   The first ten non-generic contexts ([¬ß6.1](jls-6.html#jls-6.1 "6.1. Declarations")):
    
    1.  In a single-type-import declaration ([¬ß7.5.1](jls-7.html#jls-7.5.1 "7.5.1. Single-Type-Import Declarations"))
        
    2.  To the left of the `.` in a single-static-import declaration ([¬ß7.5.3](jls-7.html#jls-7.5.3 "7.5.3. Single-Static-Import Declarations"))
        
    3.  To the left of the `.` in a static-import-on-demand declaration ([¬ß7.5.4](jls-7.html#jls-7.5.4 "7.5.4. Static-Import-on-Demand Declarations"))
        
    4.  To the left of the `(` in a constructor declaration ([¬ß8.8](jls-8.html#jls-8.8 "8.8. Constructor Declarations"))
        
    5.  After the `@` sign in an annotation ([¬ß9.7](jls-9.html#jls-9.7 "9.7. Annotations"))
        
    6.  To the left of `.``class` in a class literal ([¬ß15.8.2](jls-15.html#jls-15.8.2 "15.8.2. Class Literals"))
        
    7.  To the left of `.``this` in a qualified `this` expression ([¬ß15.8.4](jls-15.html#jls-15.8.4 "15.8.4. Qualified this"))
        
    8.  To the left of `.``super` in a qualified superclass field access expression ([¬ß15.11.2](jls-15.html#jls-15.11.2 "15.11.2. Accessing Superclass Members using super"))
        
    9.  To the left of `.`_Identifier_ or `.``super``.`_Identifier_ in a qualified method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions"))
        
    10.  To the left of `.``super``::` in a method reference expression ([¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions"))
        
*   As the _Identifier_ or dotted _Identifier_ sequence that constitutes any _ReferenceType_ (including a _ReferenceType_ to the left of the brackets in an array type, or to the left of the < in a parameterized type, or in a non-wildcard type argument of a parameterized type, or in an `extends` or `super` clause of a wildcard type argument of a parameterized type) in the 16 contexts where types are used ([¬ß4.11](jls-4.html#jls-4.11 "4.11. Where Types Are Used")):
    
    1.  In an `extends` or `implements` clause of a class declaration ([¬ß8.1.4](jls-8.html#jls-8.1.4 "8.1.4. Superclasses and Subclasses"), [¬ß8.1.5](jls-8.html#jls-8.1.5 "8.1.5. Superinterfaces"), [¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations"))
        
    2.  In an `extends` clause of an interface declaration ([¬ß9.1.3](jls-9.html#jls-9.1.3 "9.1.3. Superinterfaces and Subinterfaces"))
        
    3.  The return type of a method ([¬ß8.4](jls-8.html#jls-8.4 "8.4. Method Declarations"), [¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations")) (including the type of an element of an annotation type ([¬ß9.6.1](jls-9.html#jls-9.6.1 "9.6.1. Annotation Type Elements")))
        
    4.  In the `throws` clause of a method or constructor ([¬ß8.4.6](jls-8.html#jls-8.4.6 "8.4.6. Method Throws"), [¬ß8.8.5](jls-8.html#jls-8.8.5 "8.8.5. Constructor Throws"), [¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations"))
        
    5.  In an `extends` clause of a type parameter declaration of a generic class, interface, method, or constructor ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters"), [¬ß9.1.2](jls-9.html#jls-9.1.2 "9.1.2. Generic Interfaces and Type Parameters"), [¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods"), [¬ß8.8.4](jls-8.html#jls-8.8.4 "8.8.4. Generic Constructors"))
        
    6.  The type in a field declaration of a class or interface ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations"), [¬ß9.3](jls-9.html#jls-9.3 "9.3. Field (Constant) Declarations"))
        
    7.  The type in a formal parameter declaration of a method, constructor, or lambda expression ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"), [¬ß8.8.1](jls-8.html#jls-8.8.1 "8.8.1. Formal Parameters"), [¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations"), [¬ß15.27.1](jls-15.html#jls-15.27.1 "15.27.1. Lambda Parameters"))
        
    8.  The type of the receiver parameter of a method ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"))
        
    9.  The type in a local variable declaration ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements"), [¬ß14.14.1](jls-14.html#jls-14.14.1 "14.14.1. The basic for Statement"), [¬ß14.14.2](jls-14.html#jls-14.14.2 "14.14.2. The enhanced for statement"), [¬ß14.20.3](jls-14.html#jls-14.20.3 "14.20.3. try-with-resources"))
        
    10.  A type in an exception parameter declaration ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement"))
        
    11.  In an explicit type argument list to an explicit constructor invocation statement or class instance creation expression or method invocation expression ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations"), [¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions"), [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions"))
        
    12.  In an unqualified class instance creation expression, either as the class type to be instantiated ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")) or as the direct superclass or direct superinterface of an anonymous class to be instantiated ([¬ß15.9.5](jls-15.html#jls-15.9.5 "15.9.5. Anonymous Class Declarations"))
        
    13.  The element type in an array creation expression ([¬ß15.10.1](jls-15.html#jls-15.10.1 "15.10.1. Array Creation Expressions"))
        
    14.  The type in the cast operator of a cast expression ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions"))
        
    15.  The type that follows the `instanceof` relational operator ([¬ß15.20.2](jls-15.html#jls-15.20.2 "15.20.2. Type Comparison Operator instanceof"))
        
    16.  In a method reference expression ([¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions")), as the reference type to search for a member method or as the class type or array type to construct.
        
    

The extraction of a _TypeName_ from the identifiers of a _ReferenceType_ in the 16 contexts above is intended to apply recursively to all sub-terms of the _ReferenceType_, such as its element type and any type arguments.

For example, suppose a field declaration uses the type `p.q.Foo[]`. The brackets of the array type are ignored, and the term `p.q.Foo` is extracted as a dotted sequence of _Identifiers_ to the left of the brackets in an array type, and classified as a _TypeName_. A later step determines which of `p`, `q`, and `Foo` is a type name or a package name.

As another example, suppose a cast operator uses the type `p.q.Foo<? extends String>`. The term `p.q.Foo` is again extracted as a dotted sequence of _Identifier_ terms, this time to the left of the `<` in a parameterized type, and classified as a _TypeName_. The term `String` is extracted as an _Identifier_ in an `extends` clause of a wildcard type argument of a parameterized type, and classified as a _TypeName_.

A name is syntactically classified as an _ExpressionName_ in these contexts:

*   As the qualifying expression in a qualified superclass constructor invocation ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations"))
*   As the qualifying expression in a qualified class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions"))
*   As the array reference expression in an array access expression ([¬ß15.10.3](jls-15.html#jls-15.10.3 "15.10.3. Array Access Expressions"))
*   As a _PostfixExpression_ ([¬ß15.14](jls-15.html#jls-15.14 "15.14. Postfix Expressions"))
*   As the left-hand operand of an assignment operator ([¬ß15.26](jls-15.html#jls-15.26 "15.26. Assignment Operators"))
    

A name is syntactically classified as a _MethodName_ in this context:

*   Before the "`(`" in a method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions"))
    

A name is syntactically classified as a _PackageOrTypeName_ in these contexts:

*   To the left of the "`.`" in a qualified _TypeName_
*   In a type-import-on-demand declaration ([¬ß7.5.2](jls-7.html#jls-7.5.2 "7.5.2. Type-Import-on-Demand Declarations"))
    

A name is syntactically classified as an _AmbiguousName_ in these contexts:

*   To the left of the "`.`" in a qualified _ExpressionName_
*   To the left of the rightmost `.` that occurs before the "`(`" in a method invocation expression
*   To the left of the "`.`" in a qualified _AmbiguousName_
*   In the default value clause of an annotation type element declaration ([¬ß9.6.2](jls-9.html#jls-9.6.2 "9.6.2. Defaults for Annotation Type Elements"))
*   To the right of an "`=`" in an an element-value pair ([¬ß9.7.1](jls-9.html#jls-9.7.1 "9.7.1. Normal Annotations"))
*   To the left of `::` in a method reference expression ([¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions"))
    

The effect of syntactic classification is to restrict certain kinds of entities to certain parts of expressions:

*   The name of a field, parameter, or local variable may be used as an expression ([¬ß15.14.1](jls-15.html#jls-15.14.1 "15.14.1. Expression Names")).
*   The name of a method may appear in an expression only as part of a method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")).
*   The name of a class or interface type may appear in an expression only as part of a class literal ([¬ß15.8.2](jls-15.html#jls-15.8.2 "15.8.2. Class Literals")), a qualified `this` expression ([¬ß15.8.4](jls-15.html#jls-15.8.4 "15.8.4. Qualified this")), a class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")), an array creation expression ([¬ß15.10.1](jls-15.html#jls-15.10.1 "15.10.1. Array Creation Expressions")), a cast expression ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")), an `instanceof` expression ([¬ß15.20.2](jls-15.html#jls-15.20.2 "15.20.2. Type Comparison Operator instanceof")), an enum constant ([¬ß8.9](jls-8.html#jls-8.9 "8.9. Enum Types")), or as part of a qualified name for a field or method.
*   The name of a package may appear in an expression only as part of a qualified name for a class or interface type.
    

### 6.5.2. Reclassification of Contextually Ambiguous Names

An _AmbiguousName_ is then reclassified as follows.

If the _AmbiguousName_ is a simple name, consisting of a single _Identifier_:

*   If the _Identifier_ appears within the scope ([¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration")) of a local variable declaration ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements")) or parameter declaration ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"), [¬ß8.8.1](jls-8.html#jls-8.8.1 "8.8.1. Formal Parameters"), [¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) or field declaration ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations")) with that name, then the _AmbiguousName_ is reclassified as an _ExpressionName_.
*   Otherwise, if a field of that name is declared in the compilation unit ([¬ß7.3](jls-7.html#jls-7.3 "7.3. Compilation Units")) containing the _Identifier_ by a single-static-import declaration ([¬ß7.5.3](jls-7.html#jls-7.5.3 "7.5.3. Single-Static-Import Declarations")), or by a static-import-on-demand declaration ([¬ß7.5.4](jls-7.html#jls-7.5.4 "7.5.4. Static-Import-on-Demand Declarations")) then the _AmbiguousName_ is reclassified as an _ExpressionName_.
*   Otherwise, if the _Identifier_ appears within the scope ([¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration")) of a top level class ([¬ß8 (_Classes_)](jls-8.html "Chapter 8. Classes")) or interface type declaration ([¬ß9 (_Interfaces_)](jls-9.html "Chapter 9. Interfaces")), a local class declaration ([¬ß14.3](jls-14.html#jls-14.3 "14.3. Local Class Declarations")) or member type declaration ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")) with that name, then the _AmbiguousName_ is reclassified as a _TypeName_.
*   Otherwise, if a type of that name is declared in the compilation unit ([¬ß7.3](jls-7.html#jls-7.3 "7.3. Compilation Units")) containing the _Identifier_, either by a single-type-import declaration ([¬ß7.5.1](jls-7.html#jls-7.5.1 "7.5.1. Single-Type-Import Declarations")), or by a type-import-on-demand declaration ([¬ß7.5.2](jls-7.html#jls-7.5.2 "7.5.2. Type-Import-on-Demand Declarations")), or by a single-static-import declaration ([¬ß7.5.3](jls-7.html#jls-7.5.3 "7.5.3. Single-Static-Import Declarations")), or by a static-import-on-demand declaration ([¬ß7.5.4](jls-7.html#jls-7.5.4 "7.5.4. Static-Import-on-Demand Declarations")), then the _AmbiguousName_ is reclassified as a _TypeName_.
*   Otherwise, the _AmbiguousName_ is reclassified as a _PackageName_. A later step determines whether or not a package of that name actually exists.
    

If the _AmbiguousName_ is a qualified name, consisting of a name, a "`.`", and an _Identifier_, then the name to the left of the "`.`" is first reclassified, for it is itself an _AmbiguousName_. There is then a choice:

*   If the name to the left of the "`.`" is reclassified as a _PackageName_, then:
    
    *   If there is a package whose name is the name to the left of the "`.`" and that package contains a declaration of a type whose name is the same as the _Identifier_, then this _AmbiguousName_ is reclassified as a _TypeName_.
        
    *   Otherwise, this _AmbiguousName_ is reclassified as a _PackageName_. A later step determines whether or not a package of that name actually exists.
        
*   If the name to the left of the "`.`" is reclassified as a _TypeName_, then:
    
    *   If the _Identifier_ is the name of a method or field of the type denoted by _TypeName_, this _AmbiguousName_ is reclassified as an _ExpressionName_.
        
    *   Otherwise, if the _Identifier_ is the name of a member type of the type denoted by _TypeName_, this _AmbiguousName_ is reclassified as a _TypeName_.
        
    *   Otherwise, a compile-time error occurs.
        
*   If the name to the left of the "`.`" is reclassified as an _ExpressionName_, then let T be the type of the expression denoted by _ExpressionName_.
    
    *   If the _Identifier_ is the name of a method or field of the type denoted by T, this _AmbiguousName_ is reclassified as an _ExpressionName_.
        
    *   Otherwise, if the _Identifier_ is the name of a member type ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")) of the type denoted by T, then this _AmbiguousName_ is reclassified as a _TypeName_.
        
    *   Otherwise, a compile-time error occurs.
        
    

**Example 6.5.2-1. Reclassification of Contextually Ambiguous Names**

Consider the following contrived "library code":

package org.rpgpoet;
import java.util.Random;
public interface Music { Random\[\] wizards = new Random\[4\]; }

and then consider this example code in another package:

package bazola;
class Gabriel {
    static int n = org.rpgpoet.Music.wizards.length;
}

First of all, the name `org.rpgpoet.Music.wizards.length` is classified as an _ExpressionName_ because it functions as a _PostfixExpression_. Therefore, each of the names:

org.rpgpoet.Music.wizards
org.rpgpoet.Music
org.rpgpoet
org

is initially classified as an _AmbiguousName_. These are then reclassified:

*   The simple name `org` is reclassified as a _PackageName_ (since there is no variable or type named org in scope).
*   Next, assuming that there is no class or interface named `rpgpoet` in any compilation unit of package `org` (and we know that there is no such class or interface because package `org` has a subpackage named `rpgpoet`), the qualified name `org.rpgpoet` is reclassified as a _PackageName_.
*   Next, because package `org.rpgpoet` has an accessible ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) interface type named `Music`, the qualified name `org.rpgpoet.Music` is reclassified as a _TypeName_.
*   Finally, because the name `org.rpgpoet.Music` is a _TypeName_, the qualified name `org.rpgpoet.Music.wizards` is reclassified as an _ExpressionName_.
    

  

### 6.5.3. Meaning of Package Names

The meaning of a name classified as a _PackageName_ is determined as follows.

#### 6.5.3.1. Simple Package Names

If a package name consists of a single _Identifier_, then this identifier denotes a top level package named by that identifier.

If no top level package of that name is in scope ([¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration")), then a compile-time error occurs.

#### 6.5.3.2. Qualified Package Names

If a package name is of the form `Q.Id`, then `Q` must also be a package name. The package name `Q.Id` names a package that is the member named `Id` within the package named by `Q`.

If `Q` does not name an observable package ([¬ß7.4.3](jls-7.html#jls-7.4.3 "7.4.3. Observability of a Package")), or `Id` is not the simple name of an observable subpackage of that package, then a compile-time error occurs.

### 6.5.4. Meaning of _PackageOrTypeNames_

#### 6.5.4.1. Simple _PackageOrTypeNames_

If the _PackageOrTypeName_, `Q`, occurs in the scope of a type named `Q`, then the _PackageOrTypeName_ is reclassified as a _TypeName_.

Otherwise, the _PackageOrTypeName_ is reclassified as a _PackageName_. The meaning of the _PackageOrTypeName_ is the meaning of the reclassified name.

#### 6.5.4.2. Qualified _PackageOrTypeNames_

Given a qualified _PackageOrTypeName_ of the form `Q.Id`, if the type or package denoted by `Q` has a member type named `Id`, then the qualified _PackageOrTypeName_ name is reclassified as a _TypeName_.

Otherwise, it is reclassified as a _PackageName_. The meaning of the qualified _PackageOrTypeName_ is the meaning of the reclassified name.

### 6.5.5. Meaning of Type Names

The meaning of a name classified as a _TypeName_ is determined as follows.

#### 6.5.5.1. Simple Type Names

If a type name consists of a single _Identifier_, then the identifier must occur in the scope of exactly one visible declaration of a type with this name, or a compile-time error occurs. The meaning of the type name is that type.

#### 6.5.5.2. Qualified Type Names

If a type name is of the form `Q.Id`, then `Q` must be either a type name or a package name.

If `Id` names exactly one accessible type ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) that is a member of the type or package denoted by `Q`, then the qualified type name denotes that type.

If `Id` does not name a member type within `Q` ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")), or the member type named `Id` within `Q` is not accessible ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")), or `Id` names more than one member type within `Q`, then a compile-time error occurs.

**Example 6.5.5.2-1. Qualified Type Names**

class Test {
    public static void main(String\[\] args) {
        java.util.Date date =
            new java.util.Date(System.currentTimeMillis());
        System.out.println(date.toLocaleString());
    }
}

This program produced the following output the first time it was run:

Sun Jan 21 22:56:29 1996

In this example, the name `java.util.Date` must denote a type, so we first use the procedure recursively to determine if `java.util` is an accessible type or a package, which it is, and then look to see if the type `Date` is accessible in this package.

  

### 6.5.6. Meaning of Expression Names

The meaning of a name classified as an _ExpressionName_ is determined as follows.

#### 6.5.6.1. Simple Expression Names

If an expression name consists of a single _Identifier_, then there must be exactly one declaration denoting either a local variable, parameter, or field visible ([¬ß6.4.1](jls-6.html#jls-6.4.1 "6.4.1. Shadowing")) at the point at which the _Identifier_ occurs. Otherwise, a compile-time error occurs.

If the declaration denotes an instance variable ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations")), the expression name must appear within the declaration of an instance method ([¬ß8.4](jls-8.html#jls-8.4 "8.4. Method Declarations")), constructor ([¬ß8.8](jls-8.html#jls-8.8 "8.8. Constructor Declarations")), instance initializer ([¬ß8.6](jls-8.html#jls-8.6 "8.6. Instance Initializers")), or instance variable initializer ([¬ß8.3.2](jls-8.html#jls-8.3.2 "8.3.2. Field Initialization")). If the expression name appears within a `static` method ([¬ß8.4.3.2](jls-8.html#jls-8.4.3.2 "8.4.3.2. static Methods")), static initializer ([¬ß8.7](jls-8.html#jls-8.7 "8.7. Static Initializers")), or initializer for a `static` variable ([¬ß8.3.2](jls-8.html#jls-8.3.2 "8.3.2. Field Initialization"), [¬ß12.4.2](jls-12.html#jls-12.4.2 "12.4.2. Detailed Initialization Procedure")), then a compile-time error occurs.

If the declaration declares a `final` variable which is definitely assigned before the simple expression, the meaning of the name is the value of that variable. Otherwise, the meaning of the expression name is the variable declared by the declaration.

If the expression name appears in an assignment context, invocation context, or casting context, then the type of the expression name is the declared type of the field, local variable, or parameter after capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")).

Otherwise, the type of the expression name is the declared type of the field, local variable or parameter.

That is, if the expression name appears "on the right hand side", its type is subject to capture conversion. If the expression name is a variable that appears "on the left hand side", its type is not subject to capture conversion.

**Example 6.5.6.1-1. Simple Expression Names**

class Test {
    static int v;
    static final int f = 3;
    public static void main(String\[\] args) {
        int i;
        i = 1;
        v = 2;
        f = 33;  // compile-time error
        System.out.println(i + " " + v + " " + f);
    }
}

In this program, the names used as the left-hand-sides in the assignments to `i`, `v`, and `f` denote the local variable `i`, the field `v`, and the value of `f` (not the variable `f`, because `f` is a `final` variable). The example therefore produces an error at compile time because the last assignment does not have a variable as its left-hand side. If the erroneous assignment is removed, the modified code can be compiled and it will produce the output:

1 2 3

  

#### 6.5.6.2. Qualified Expression Names

If an expression name is of the form `Q.Id`, then `Q` has already been classified as a package name, a type name, or an expression name.

If `Q` is a package name, then a compile-time error occurs.

If `Q` is a type name that names a class type ([¬ß8 (_Classes_)](jls-8.html "Chapter 8. Classes")), then:

*   If there is not exactly one accessible ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) member of the class type that is a field named `Id`, then a compile-time error occurs.
*   Otherwise, if the single accessible member field is not a class variable (that is, it is not declared `static`), then a compile-time error occurs.
*   Otherwise, if the class variable is declared `final`, then `Q.Id` denotes the value of the class variable.
    
    The type of the expression `Q.Id` is the declared type of the class variable after capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")).
    
    If `Q.Id` appears in a context that requires a variable and not a value, then a compile-time error occurs.
*   Otherwise, `Q.Id` denotes the class variable.
    
    The type of the expression `Q.Id` is the declared type of the class variable after capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")).
    
    Note that this clause covers the use of `enum` constants ([¬ß8.9](jls-8.html#jls-8.9 "8.9. Enum Types")), since these always have a corresponding `final` class variable.
    

If `Q` is a type name that names an interface type ([¬ß9 (_Interfaces_)](jls-9.html "Chapter 9. Interfaces")), then:

*   If there is not exactly one accessible ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) member of the interface type that is a field named `Id`, then a compile-time error occurs.
*   Otherwise, `Q.Id` denotes the value of the field.
    
    The type of the expression `Q.Id` is the declared type of the field after capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")).
    
    If `Q.Id` appears in a context that requires a variable and not a value, then a compile-time error occurs.
    

If `Q` is an expression name, let T be the type of the expression `Q`:

*   If T is not a reference type, a compile-time error occurs.
*   If there is not exactly one accessible ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) member of the type T that is a field named `Id`, then a compile-time error occurs.
*   Otherwise, if this field is any of the following:
    
    *   A field of an interface type
        
    *   A `final` field of a class type (which may be either a class variable or an instance variable)
        
    *   The `final` field `length` of an array type ([¬ß10.7](jls-10.html#jls-10.7 "10.7. Array Members"))
        
    
    then `Q.Id` denotes the value of the field, unless it appears in a context that requires a variable and the field is a definitely unassigned blank `final` field, in which case it yields a variable.
    
    The type of the expression `Q.Id` is the declared type of the field after capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")).
    
    If `Q.Id` appears in a context that requires a variable and not a value, and the field denoted by `Q.Id` is definitely assigned, then a compile-time error occurs.
*   Otherwise, `Q.Id` denotes a variable, the field `Id` of class T, which may be either a class variable or an instance variable.
    
    The type of the expression `Q.Id` is the type of the field member after capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")).
    

**Example 6.5.6.2-1. Qualified Expression Names**

class Point {
    int x, y;
    static int nPoints;
}

class Test {
    public static void main(String\[\] args) {
        int i = 0;
        i.x++;        // compile-time error
        Point p = new Point();
        p.nPoints();  // compile-time error
    }
}

This program encounters two compile-time errors, because the `int` variable `i` has no members, and because `nPoints` is not a method of class `Point`.

  

**Example 6.5.6.2-2. Qualifying an Expression with a Type Name**

Note that expression names may be qualified by type names, but not by types in general. A consequence is that it is not possible to access a class variable through a parameterized type. For example, given the code:

class Foo<T> {
    public static int classVar = 42;
}

the following assignment is illegal:

Foo<String>.classVar = 91; // illegal

Instead, one writes:

Foo.classVar = 91;

This does not restrict the Java programming language in any meaningful way. Type parameters may not be used in the types of static variables, and so the type arguments of a parameterized type can never influence the type of a static variable. Therefore, no expressive power is lost. The type name `Foo` appears to be a raw type, but it is not; rather, it is the name of the non-generic type `Foo` whose static member is to be accessed ([¬ß6.1](jls-6.html#jls-6.1 "6.1. Declarations")). Since there is no use of a raw type, there are no unchecked warnings.

  

### 6.5.7. Meaning of Method Names

The meaning of a name classified as a _MethodName_ is determined as follows.

#### 6.5.7.1. Simple Method Names

A simple method name appears in the context of a method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")). The simple method name consists of a single _Identifier_ which specifies the name of the method to be invoked. The rules of method invocation require that the _Identifier_ either denotes a method that is visible at the point of the method invocation, or denotes a method imported by a single-static-import declaration or static-import-on-demand declaration ([¬ß7.5.3](jls-7.html#jls-7.5.3 "7.5.3. Single-Static-Import Declarations"), [¬ß7.5.4](jls-7.html#jls-7.5.4 "7.5.4. Static-Import-on-Demand Declarations")).

**Example 6.5.7.1-1. Simple Method Names and Visibility**

The following program demonstrates the role of method visibility when determining which method to invoke.

class Super {
    void f2(String s)       {}
    void f3(String s)       {}
    void f3(int i1, int i2) {}
}

class Test {
    void f1(int i) {}
    void f2(int i) {}
    void f3(int i) {}

    void m() {
        new Super() {
            {
                f1(0);  // OK, resolves to Test.f1(int)
                f2(0);  // compile-time error
                f3(0);  // compile-time error
            }
        };
    }
}

For the invocation `f1(0)`, only one method named `f1` is visible. It is the method `Test.f1(int)`, whose declaration is in scope throughout the body of `Test` including the anonymous class declaration. [¬ß15.12.1](jls-15.html#jls-15.12.1 "15.12.1. Compile-Time Step 1: Determine Class or Interface to Search") chooses to search in class `Test` since the anonymous class declaration has no member named `f1`. Eventually, `Test.f1(int)` is resolved.

For the invocation `f2(0)`, two methods named `f2` are visible. First, the declaration of the method `Super.f2(String)` is in scope throughout the anonymous class declaration. Second, the declaration of the method `Test.f2(int)` is in scope throughout the body of `Test` including the anonymous class declaration. [¬ß15.12.1](jls-15.html#jls-15.12.1 "15.12.1. Compile-Time Step 1: Determine Class or Interface to Search") chooses to search in class `Super` because it has a member named `f2`. However, `Super.f2(String)` is not applicable to `f2(0)`, so a compile-time error occurs. Note that class `Test` is not searched.

For the invocation `f3(0)`, three methods named `f3` are visible. First and second, the declarations of the methods `Super.f3(String)` and `Super.f3(int,int)` are in scope throughout the anonymous class declaration. Third, the declaration of the method `Test.f3(int)` is in scope throughout the body of `Test` including the anonymous class declaration. [¬ß15.12.1](jls-15.html#jls-15.12.1 "15.12.1. Compile-Time Step 1: Determine Class or Interface to Search") chooses to search in class `Super` because it has a member named `f3`. However, `Super.f3(String)` and `Super.f3(int,int)` are not applicable to `f3(0)`, so a compile-time error occurs. Note that class `Test` is not searched.

Choosing to search a nested class's superclass hierarchy before the lexically enclosing scope is called the "comb rule" ([¬ß15.12.1](jls-15.html#jls-15.12.1 "15.12.1. Compile-Time Step 1: Determine Class or Interface to Search")).

  

6.6. Access Control
-------------------

The Java programming language provides mechanisms for _access control_, to prevent the users of a package or class from depending on unnecessary details of the implementation of that package or class. If access is permitted, then the accessed entity is said to be _accessible_.

Note that accessibility is a static property that can be determined at compile time; it depends only on types and declaration modifiers.

Qualified names are a means of access to members of packages and reference types. When the name of such a member is classified from its context ([¬ß6.5.1](jls-6.html#jls-6.5.1 "6.5.1. Syntactic Classification of a Name According to Context")) as a qualified type name (denoting a member of a package or reference type, [¬ß6.5.5.2](jls-6.html#jls-6.5.5.2 "6.5.5.2. Qualified Type Names")) or a qualified expression name (denoting a member of a reference type, [¬ß6.5.6.2](jls-6.html#jls-6.5.6.2 "6.5.6.2. Qualified Expression Names")), access control is applied.

For example, a single-type-import statement ([¬ß7.5.1](jls-7.html#jls-7.5.1 "7.5.1. Single-Type-Import Declarations")) uses a qualified type name, so the named type must be accessible from the compilation unit containing the import statement. As another example, a class declaration may use a qualified type name for a superclass ([¬ß8.1.5](jls-8.html#jls-8.1.5 "8.1.5. Superinterfaces")), and again the named type must be accessible.

Some obvious expressions are "missing" from context classification in [¬ß6.5.1](jls-6.html#jls-6.5.1 "6.5.1. Syntactic Classification of a Name According to Context"): field access on a _Primary_ ([¬ß15.11.1](jls-15.html#jls-15.11.1 "15.11.1. Field Access Using a Primary")), method invocation on a _Primary_ ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")), method reference via a _Primary_ ([¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions")), and the instantiated class in a qualified class instance creation ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")). Each of these expressions uses identifiers, rather than names, for the reason given in [¬ß6.2](jls-6.html#jls-6.2 "6.2. Names and Identifiers"). Consequently, access control to members (whether fields, methods, or types) is applied _explicitly_ by field access expressions, method invocation expressions, method reference expressions, and qualified class instance creation expressions. (Note that access to a field may also be denoted by a qualified name occuring as a postfix expression.)

In addition, many statements and expressions allow the use of types rather than type names. For example, a class declaration may use a parameterized type ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")) to denote a superclass. Because a parameterized type is not a qualified type name, it is necessary for the class declaration to explicitly perform access control for the denoted superclass. Consequently, most of the statements and expressions that provide contexts in [¬ß6.5.1](jls-6.html#jls-6.5.1 "6.5.1. Syntactic Classification of a Name According to Context") to classify a _TypeName_ also perform their own access control checks.

Beyond access to members of a package or reference type, there is the matter of access to constructors of a reference type. Access control must be checked when a constructor is invoked explicitly or implicitly. Consequently, access control is checked by an explicit constructor invocation statement ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations")) and by a class instance creation expression ([¬ß15.9.3](jls-15.html#jls-15.9.3 "15.9.3. Choosing the Constructor and its Arguments")). Such checks are necessary because [¬ß6.5.1](jls-6.html#jls-6.5.1 "6.5.1. Syntactic Classification of a Name According to Context") has no mention of explicit constructor invocation statements (because they reference constructor names indirectly) and is unaware of the distinction between the class type denoted by an unqualified class instance creation expression and a constructor of that class type. Also, constructors do not have qualified names, so we cannot rely on access control being checked during classification of qualified type names.

Accessibility affects inheritance of class members ([¬ß8.2](jls-8.html#jls-8.2 "8.2. Class Members")), including hiding and method overriding ([¬ß8.4.8.1](jls-8.html#jls-8.4.8.1 "8.4.8.1. Overriding (by Instance Methods)")).

### 6.6.1. Determining Accessibility

*   A package is always accessible.
*   If a class or interface type is declared `public`, then it may be accessed by any code, provided that the compilation unit ([¬ß7.3](jls-7.html#jls-7.3 "7.3. Compilation Units")) in which it is declared is observable.
    
    If a class or interface type is declared with package access, then it may be accessed only from within the package in which it is declared.
    
    A class or interface type declared without an access modifier implicitly has package access.
*   An array type is accessible if and only if its element type is accessible.
*   A member (class, interface, field, or method) of a reference type, or a constructor of a class type, is accessible only if the type is accessible and the member or constructor is declared to permit access:
    
    *   If the member or constructor is declared `public`, then access is permitted.
        
        All members of interfaces lacking access modifiers are implicitly `public`.
        
    *   Otherwise, if the member or constructor is declared `protected`, then access is permitted only when one of the following is true:
        
        *   Access to the member or constructor occurs from within the package containing the class in which the `protected` member or constructor is declared.
            
        *   Access is correct as described in [¬ß6.6.2](jls-6.html#jls-6.6.2 "6.6.2. Details on protected Access").
            
        
    *   Otherwise, if the member or constructor is declared with package access, then access is permitted only when the access occurs from within the package in which the type is declared.
        
        A class member or constructor declared without an access modifier implicitly has package access.
        
    *   Otherwise, the member or constructor is declared `private`, and access is permitted if and only if it occurs within the body of the top level class ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")) that encloses the declaration of the member or constructor.
        
    

**Example 6.6-1. Access Control**

Consider the two compilation units:

package points;
class PointVec { Point\[\] vec; }

and:

package points;
public class Point {
    protected int x, y;
    public void move(int dx, int dy) { x += dx; y += dy; }
    public int getX() { return x; }
    public int getY() { return y; }
}

which declare two class types in the package `points`:

*   The class type `PointVec` is not `public` and not part of the `public` interface of the package `points`, but rather can be used only by other classes in the package.
*   The class type `Point` is declared `public` and is available to other packages. It is part of the `public` interface of the package `points`.
*   The methods `move`, `getX`, and `getY` of the class `Point` are declared `public` and so are available to any code that uses an object of type `Point`.
*   The fields `x` and `y` are declared `protected` and are accessible outside the package `points` only in subclasses of class `Point`, and only when they are fields of objects that are being implemented by the code that is accessing them.
    
    See [¬ß6.6.2](jls-6.html#jls-6.6.2 "6.6.2. Details on protected Access") for an example of how the `protected` access modifier limits access.
    

  

**Example 6.6-2. Access to `public` Fields, Methods, and Constructors**

A `public` class member or constructor is accessible throughout the package where it is declared and from any other package, provided the package in which it is declared is observable ([¬ß7.4.3](jls-7.html#jls-7.4.3 "7.4.3. Observability of a Package")). For example, in the compilation unit:

package points;
public class Point {
    int x, y;
    public void move(int dx, int dy) {
        x += dx; y += dy;
        moves++;
    }
    public static int moves = 0;
}

the `public` class `Point` has as `public` members the `move` method and the `moves` field. These `public` members are accessible to any other package that has access to package `points`. The fields `x` and `y` are not `public` and therefore are accessible only from within the package `points`.

  

**Example 6.6-3. Access to `public` and Non-`public` Classes**

If a class lacks the `public` modifier, access to the class declaration is limited to the package in which it is declared ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")). In the example:

package points;
public class Point {
    public int x, y;
    public void move(int dx, int dy) { x += dx; y += dy; }
}
class PointList {
    Point next, prev;
}

two classes are declared in the compilation unit. The class `Point` is available outside the package `points`, while the class `PointList` is available for access only within the package. Thus a compilation unit in another package can access `points.Point`, either by using its fully qualified name:

package pointsUser;
class Test1 {
    public static void main(String\[\] args) {
        points.Point p = new points.Point();
        System.out.println(p.x + " " + p.y);
    }
}

or by using a single-type-import declaration ([¬ß7.5.1](jls-7.html#jls-7.5.1 "7.5.1. Single-Type-Import Declarations")) that mentions the fully qualified name, so that the simple name may be used thereafter:

package pointsUser;
import points.Point;
class Test2 {
    public static void main(String\[\] args) {
        Point p = new Point();
        System.out.println(p.x + " " + p.y);
    }
}

However, this compilation unit cannot use or import `points.PointList`, which is not declared `public` and is therefore inaccessible outside package `points`.

  

**Example 6.6-4. Access to Package-Access Fields, Methods, and Constructors**

If none of the access modifiers `public`, `protected`, or `private` are specified, a class member or constructor has package access: it is accessible throughout the package that contains the declaration of the class in which the class member is declared, but the class member or constructor is not accessible in any other package.

If a `public` class has a method or constructor with package access, then this method or constructor is not accessible to or inherited by a subclass declared outside this package.

For example, if we have:

package points;
public class Point {
    public int x, y;
    void move(int dx, int dy) { x += dx; y += dy; }
    public void moveAlso(int dx, int dy) { move(dx, dy); }
}

then a subclass in another package may declare an unrelated `move` method, with the same signature ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")) and return type. Because the original `move` method is not accessible from package `morepoints`, `super` may not be used:

package morepoints;
public class PlusPoint extends points.Point {
    public void move(int dx, int dy) {
        super.move(dx, dy);  // compile-time error
        moveAlso(dx, dy);
    }
}

Because `move` of `Point` is not overridden by `move` in `PlusPoint`, the method `moveAlso` in `Point` never calls the method `move` in `PlusPoint`. Thus if you delete the `super.move` call from `PlusPoint` and execute the test program:

import points.Point;
import morepoints.PlusPoint;
class Test {
    public static void main(String\[\] args) {
        PlusPoint pp = new PlusPoint();
        pp.move(1, 1);
    }
}

it terminates normally. If `move` of `Point` were overridden by `move` in `PlusPoint`, then this program would recurse infinitely, until a `StackOverflowError` occurred.

  

**Example 6.6-5. Access to `private` Fields, Methods, and Constructors**

A `private` class member or constructor is accessible only within the body of the top level class ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")) that encloses the declaration of the member or constructor. It is not inherited by subclasses. In the example:

class Point {
    Point() { setMasterID(); }
    int x, y;
    private int ID;
    private static int masterID = 0;
    private void setMasterID() { ID = masterID++; }
}

the private members `ID`, `masterID`, and `setMasterID` may be used only within the body of class `Point`. They may not be accessed by qualified names, field access expressions, or method invocation expressions outside the body of the declaration of `Point`.

See [¬ß8.8.8](jls-8.html#jls-8.8.8 "8.8.8. Constructor Overloading") for an example that uses a `private` constructor.

  

### 6.6.2. Details on `protected` Access

A `protected` member or constructor of an object may be accessed from outside the package in which it is declared only by code that is responsible for the implementation of that object.

#### 6.6.2.1. Access to a `protected` Member

Let C be the class in which a `protected` member is declared. Access is permitted only within the body of a subclass S of C.

In addition, if _Id_ denotes an instance field or instance method, then:

*   If the access is by a qualified name `Q.Id` or a method reference expression ``Q `::` Id`` ([¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions")), where `Q` is an _ExpressionName_, then the access is permitted if and only if the type of the expression `Q` is S or a subclass of S.
*   If the access is by a field access expression `E.Id`, or a method invocation expression `E.Id``(...)`, or a method reference expression ``E `::` Id``, where `E` is a _Primary_ expression ([¬ß15.8](jls-15.html#jls-15.8 "15.8. Primary Expressions")), then the access is permitted if and only if the type of `E` is S or a subclass of S.
*   If the access is by a method reference expression ``T `::` Id``, where T is a _ReferenceType_, then the access is permitted if and only if the type T is S or a subclass of S.
    

More information about access to `protected` members can be found in _Checking Access to Protected Members in the Java Virtual Machine_ by Alessandro Coglio, in the _Journal of Object Technology_, October 2005.

#### 6.6.2.2. Qualified Access to a `protected` Constructor

Let C be the class in which a `protected` constructor is declared and let S be the innermost class in whose declaration the use of the `protected` constructor occurs. Then:

*   If the access is by a superclass constructor invocation `super``(...)`, or a qualified superclass constructor invocation `E``.``super``(...)`, where `E` is a _Primary_ expression, then the access is permitted.
*   If the access is by an anonymous class instance creation expression `new` C`(...){...}`, or a qualified anonymous class instance creation expression E`.``new` C`(...){...}`, where E is a _Primary_ expression, then the access is permitted.
*   If the access is by a simple class instance creation expression `new` C`(...)`, or a qualified class instance creation expression E`.``new` C`(...)`, where E is a _Primary_ expression, or a method reference expression C `::` `new`, where C is a _ClassType_, then the access is not permitted. A `protected` constructor can be accessed by a class instance creation expression (that does not declare an anonymous class) or a method reference expression only from within the package in which it is defined.
    

**Example 6.6.2-1. Access to `protected` Fields, Methods, and Constructors**

Consider this example, where the `points` package declares:

package points;
public class Point {
    protected int x, y;
    void warp(threePoint.Point3d a) {
        if (a.z > 0)  // compile-time error: cannot access a.z
            a.delta(this);
    }
}

and the `threePoint` package declares:

package threePoint;
import points.Point;
public class Point3d extends Point {
    protected int z;
    public void delta(Point p) {
        p.x += this.x;  // compile-time error: cannot access p.x
        p.y += this.y;  // compile-time error: cannot access p.y
    }
    public void delta3d(Point3d q) {
        q.x += this.x;
        q.y += this.y;
        q.z += this.z;
    }
}

A compile-time error occurs in the method `delta` here: it cannot access the `protected` members `x` and `y` of its parameter `p`, because while `Point3d` (the class in which the references to fields `x` and `y` occur) is a subclass of `Point` (the class in which `x` and `y` are declared), it is not involved in the implementation of a `Point` (the type of the parameter `p`). The method `delta3d` can access the `protected` members of its parameter `q`, because the class `Point3d` is a subclass of `Point` and is involved in the implementation of a `Point3d`.

The method `delta` could try to cast ([¬ß5.5](jls-5.html#jls-5.5 "5.5. Casting Contexts"), [¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")) its parameter to be a `Point3d`, but this cast would fail, causing an exception, if the class of `p` at run time were not `Point3d`.

A compile-time error also occurs in the method `warp`: it cannot access the `protected` member `z` of its parameter `a`, because while the class `Point` (the class in which the reference to field `z` occurs) is involved in the implementation of a `Point3d` (the type of the parameter `a`), it is not a subclass of `Point3d` (the class in which `z` is declared).

  

6.7. Fully Qualified Names and Canonical Names
----------------------------------------------

Every primitive type, named package, top level class, and top level interface has a _fully qualified name_:

*   The fully qualified name of a primitive type is the keyword for that primitive type, namely `byte`, `short`, `char`, `int`, `long`, `float`, `double`, or `boolean`.
*   The fully qualified name of a named package that is not a subpackage of a named package is its simple name.
*   The fully qualified name of a named package that is a subpackage of another named package consists of the fully qualified name of the containing package, followed by "`.`", followed by the simple (member) name of the subpackage.
*   The fully qualified name of a top level class or top level interface that is declared in an unnamed package is the simple name of the class or interface.
*   The fully qualified name of a top level class or top level interface that is declared in a named package consists of the fully qualified name of the package, followed by "`.`", followed by the simple name of the class or interface.
    

Each member class, member interface, and array type _may_ have a fully qualified name:

*   A member class or member interface M of another class or interface C has a fully qualified name if and only if C has a fully qualified name.
    
    In that case, the fully qualified name of M consists of the fully qualified name of C, followed by "`.`", followed by the simple name of M.
*   An array type has a fully qualified name if and only if its element type has a fully qualified name.
    
    In that case, the fully qualified name of an array type consists of the fully qualified name of the component type of the array type followed by "`[]`".
    

A local class does not have a fully qualified name.

Every primitive type, named package, top level class, and top level interface has a _canonical name_:

*   For every primitive type, named package, top level class, and top level interface, the canonical name is the same as the fully qualified name.
    

Each member class, member interface, and array type _may_ have a canonical name:

*   A member class or member interface M declared in another class or interface C has a canonical name if and only if C has a canonical name.
    
    In that case, the canonical name of M consists of the canonical name of C, followed by "`.`", followed by the simple name of M.
*   An array type has a canonical name if and only if its component type has a canonical name.
    
    In that case, the canonical name of the array type consists of the canonical name of the component type of the array type followed by "`[]`".
    

A local class does not have a canonical name.

**Example 6.7-1. Fully Qualified Names**

*   The fully qualified name of the type `long` is "`long`".
*   The fully qualified name of the package `java.lang` is "`java.lang`" because it is subpackage `lang` of package `java`.
*   The fully qualified name of the class `Object`, which is defined in the package `java.lang`, is "`java.lang.Object`".
*   The fully qualified name of the interface `Enumeration`, which is defined in the package `java.util`, is "`java.util.Enumeration`".
*   The fully qualified name of the type "array of `double`" is "`double``[]`".
*   The fully qualified name of the type "array of array of array of array of `String`" is "`java.lang.String[][][][]`".
    

In the code:

package points;
class Point    { int x, y; }
class PointVec { Point\[\] vec; }

the fully qualified name of the type `Point` is "`points.Point`"; the fully qualified name of the type `PointVec` is "`points.PointVec`"; and the fully qualified name of the type of the field `vec` of class `PointVec` is "`points.Point[]`".

  

**Example 6.7-2. Fully Qualified Names v. Canonical Name**

The difference between a fully qualified name and a canonical name can be seen in code such as:

package p;
class O1 { class I {} }
class O2 extends O1 {}

Both `p.O1.I` and `p.O2.I` are fully qualified names that denote the member class `I`, but only `p.O1.I` is its canonical name.

üçÄ Chapter 7. Packages
-------------------

**Table of Contents**

[7.1. Package Members](jls-7.html#jls-7.1)
[7.2. Host Support for Packages](jls-7.html#jls-7.2)
[7.3. Compilation Units](jls-7.html#jls-7.3)
[7.4. Package Declarations](jls-7.html#jls-7.4)
[7.4.1. Named Packages](jls-7.html#jls-7.4.1)
[7.4.2. Unnamed Packages](jls-7.html#jls-7.4.2)
[7.4.3. Observability of a Package](jls-7.html#jls-7.4.3)
[7.5. Import Declarations](jls-7.html#jls-7.5)
[7.5.1. Single-Type-Import Declarations](jls-7.html#jls-7.5.1)
[7.5.2. Type-Import-on-Demand Declarations](jls-7.html#jls-7.5.2)
[7.5.3. Single-Static-Import Declarations](jls-7.html#jls-7.5.3)
[7.5.4. Static-Import-on-Demand Declarations](jls-7.html#jls-7.5.4)
[7.6. Top Level Type Declarations](jls-7.html#jls-7.6)

Programs are organized as sets of packages. Each package has its own set of names for types, which helps to prevent name conflicts.

A top level type is accessible ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) outside the package that declares it only if the type is declared `public`.

The naming structure for packages is hierarchical ([¬ß7.1](jls-7.html#jls-7.1 "7.1. Package Members")). The members of a package are class and interface types ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")), which are declared in compilation units of the package, and subpackages, which may contain compilation units and subpackages of their own.

A package can be stored in a file system or in a database ([¬ß7.2](jls-7.html#jls-7.2 "7.2. Host Support for Packages")). Packages that are stored in a file system may have certain constraints on the organization of their compilation units to allow a simple implementation to find classes easily.

A package consists of a number of compilation units ([¬ß7.3](jls-7.html#jls-7.3 "7.3. Compilation Units")). A compilation unit automatically has access to all types declared in its package and also automatically imports all of the `public` types declared in the predefined package `java.lang`.

For small programs and casual development, a package can be unnamed ([¬ß7.4.2](jls-7.html#jls-7.4.2 "7.4.2. Unnamed Packages")) or have a simple name, but if code is to be widely distributed, unique package names should be chosen using qualified names. This can prevent the conflicts that would otherwise occur if two development groups happened to pick the same package name and these packages were later to be used in a single program.

7.1. Package Members
--------------------

The members of a package are its subpackages and all the top level class types ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations"), [¬ß8 (_Classes_)](jls-8.html "Chapter 8. Classes")) and top level interface types ([¬ß9 (_Interfaces_)](jls-9.html "Chapter 9. Interfaces")) declared in all the compilation units ([¬ß7.3](jls-7.html#jls-7.3 "7.3. Compilation Units")) of the package.

For example, in the Java SE platform API:

*   The package `java` has subpackages `awt`, `applet`, `io`, `lang`, `net`, and `util`, but no compilation units.
*   The package `java.awt` has a subpackage named `image`, as well as a number of compilation units containing declarations of class and interface types.
    

If the fully qualified name ([¬ß6.7](jls-6.html#jls-6.7 "6.7. Fully Qualified Names and Canonical Names")) of a package is `P`, and `Q` is a subpackage of `P`, then `P.Q` is the fully qualified name of the subpackage, and furthermore denotes a package.

A package may not contain two members of the same name, or a compile-time error results.

Here are some examples:

*   Because the package `java.awt` has a subpackage `image`, it cannot (and does not) contain a declaration of a class or interface type named `image`.
*   If there is a package named `mouse` and a member type `Button` in that package (which then might be referred to as `mouse.Button`), then there cannot be any package with the fully qualified name `mouse.Button` or `mouse.Button.Click`.
*   If `com.nighthacks.java.jag` is the fully qualified name of a type, then there cannot be any package whose fully qualified name is either `com.nighthacks.java.jag` or `com.nighthacks.java.jag.scrabble`.
    

It is however possible for members of different packages to have the same simple name. For example, it is possible to declare a package:

package vector;
public class Vector { Object\[\] vec; }

that has as a member a `public` class named `Vector`, even though the package `java.util` also declares a class named `Vector`. These two class types are different, reflected by the fact that they have different fully qualified names ([¬ß6.7](jls-6.html#jls-6.7 "6.7. Fully Qualified Names and Canonical Names")). The fully qualified name of this example `Vector` is `vector.Vector`, whereas `java.util.Vector` is the fully qualified name of the `Vector` class included in the Java SE platform. Because the package `vector` contains a class named `Vector`, it cannot also have a subpackage named `Vector`.

The hierarchical naming structure for packages is intended to be convenient for organizing related packages in a conventional manner, but has no significance in itself other than the prohibition against a package having a subpackage with the same simple name as a top level type ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")) declared in that package.

For example, there is no special access relationship between a package named `oliver` and another package named `oliver.twist`, or between packages named `evelyn.wood` and `evelyn.waugh`. That is, the code in a package named `oliver.twist` has no better access to the types declared within package `oliver` than code in any other package.

7.2. Host Support for Packages
------------------------------

Each host system determines how packages and compilation units are created and stored.

Each host system also determines which compilation units are observable ([¬ß7.3](jls-7.html#jls-7.3 "7.3. Compilation Units")) in a particular compilation. The observability of compilation units in turn determines which packages are observable, and which packages are in scope.

In simple implementations of the Java SE platform, packages and compilation units may be stored in a local file system. Other implementations may store them using a distributed file system or some form of database.

If a host system stores packages and compilation units in a database, then the database must not impose the optional restrictions ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")) on compilation units permissible in file-based implementations.

For example, a system that uses a database to store packages may not enforce a maximum of one public class or interface per compilation unit.

Systems that use a database must, however, provide an option to convert a program to a form that obeys the restrictions, for purposes of export to file-based implementations.

As an extremely simple example of storing packages in a file system, all the packages and source and binary code in a project might be stored in a single directory and its subdirectories. Each immediate subdirectory of this directory would represent a top level package, that is, one whose fully qualified name consists of a single simple name. Each further level of subdirectory would represent a subpackage of the package represented by the containing directory, and so on.

The directory might contain the following immediate subdirectories:

com
gls
jag
java
wnj

where directory `java` would contain the Java SE platform packages; the directories `jag`, `gls`, and `wnj` might contain packages that three of the authors of this specification created for their personal use and to share with each other within this small group; and the directory `com` would contain packages procured from companies that used the conventions described in [¬ß6.1](jls-6.html#jls-6.1 "6.1. Declarations") to generate unique names for their packages.

Continuing the example, the directory `java` would contain, among others, the following subdirectories:

applet
awt
io
lang
net
util

corresponding to the packages `java.applet`, `java.awt`, `java.io`, `java.lang`, `java.net`, and `java.util` that are defined as part of the Java SE platform API.

Still continuing the example, if we were to look inside the directory `util`, we might see the following files:

BitSet.java        Observable.java
BitSet.class       Observable.class
Date.java          Observer.java
Date.class         Observer.class
...

where each of the `.java` files contains the source for a compilation unit ([¬ß7.3](jls-7.html#jls-7.3 "7.3. Compilation Units")) that contains the definition of a class or interface whose binary compiled form is contained in the corresponding `.class` file.

Under this simple organization of packages, an implementation of the Java SE platform would transform a package name into a pathname by concatenating the components of the package name, placing a file name separator (directory indicator) between adjacent components.

For example, if this simple organization were used on an operating system where the file name separator is `/`, the package name:

jag.scrabble.board

would be transformed into the directory name:

jag/scrabble/board

A package name component or class name might contain a character that cannot correctly appear in a host file system's ordinary directory name, such as a Unicode character on a system that allows only ASCII characters in file names. As a convention, the character can be escaped by using, say, the `@` character followed by four hexadecimal digits giving the numeric value of the character, as in the `\u_xxxx_` escape ([¬ß3.3](jls-3.html#jls-3.3 "3.3. Unicode Escapes")).

Under this convention, the package name:

children.activities.crafts.papierM\\u00e2ch\\u00e9

which can also be written using full Unicode as:

children.activities.crafts.papierM√¢ch√©

might be mapped to the directory name:

children/activities/crafts/papierM@00e2ch@00e9

If the `@` character is not a valid character in a file name for some given host file system, then some other character that is not valid in a identifier could be used instead.

7.3. Compilation Units
----------------------

_CompilationUnit_ is the goal symbol ([¬ß2.1](jls-2.html#jls-2.1 "2.1. Context-Free Grammars")) for the syntactic grammar ([¬ß2.3](jls-2.html#jls-2.3 "2.3. The Syntactic Grammar")) of Java programs. It is defined by the following productions:

CompilationUnit:

\[[PackageDeclaration](jls-7.html#jls-PackageDeclaration "PackageDeclaration")\] {[ImportDeclaration](jls-7.html#jls-ImportDeclaration "ImportDeclaration")} {[TypeDeclaration](jls-7.html#jls-TypeDeclaration "TypeDeclaration")}

A _compilation unit_ consists of three parts, each of which is optional:

*   A `package` declaration ([¬ß7.4](jls-7.html#jls-7.4 "7.4. Package Declarations")), giving the fully qualified name ([¬ß6.7](jls-6.html#jls-6.7 "6.7. Fully Qualified Names and Canonical Names")) of the package to which the compilation unit belongs.
    
    A compilation unit that has no `package` declaration is part of an unnamed package ([¬ß7.4.2](jls-7.html#jls-7.4.2 "7.4.2. Unnamed Packages")).
*   `import` declarations ([¬ß7.5](jls-7.html#jls-7.5 "7.5. Import Declarations")) that allow types from other packages and `static` members of types to be referred to using their simple names.
*   Top level type declarations ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")) of class and interface types.
    

Every compilation unit implicitly imports every `public` type name declared in the predefined package `java.lang`, as if the declaration `import java.lang.*;` appeared at the beginning of each compilation unit immediately after any `package` statement. As a result, the names of all those types are available as simple names in every compilation unit.

All the compilation units of the predefined package `java` and its subpackages `lang` and `io` are always _observable_.

For all other packages, the host system determines which compilation units are observable.

The observability of a compilation unit influences the observability of its package ([¬ß7.4.3](jls-7.html#jls-7.4.3 "7.4.3. Observability of a Package")).

Types declared in different compilation units can depend on each other, circularly. A Java compiler must arrange to compile all such types at the same time.

7.4. Package Declarations
-------------------------

A `package` declaration appears within a compilation unit to indicate the package to which the compilation unit belongs.

### 7.4.1. Named Packages

A _package declaration_ in a compilation unit specifies the name ([¬ß6.2](jls-6.html#jls-6.2 "6.2. Names and Identifiers")) of the package to which the compilation unit belongs.

PackageDeclaration:

{[PackageModifier](jls-7.html#jls-PackageModifier "PackageModifier")} `package` [Identifier](jls-3.html#jls-Identifier "Identifier") {`.` [Identifier](jls-3.html#jls-Identifier "Identifier")} `;`

PackageModifier:

[Annotation](jls-9.html#jls-Annotation "Annotation")

The package name mentioned in a `package` declaration must be the fully qualified name of the package ([¬ß6.7](jls-6.html#jls-6.7 "6.7. Fully Qualified Names and Canonical Names")).

The scope and shadowing of a package declaration is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

The rules for annotation modifiers on a package declaration are specified in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear") and [¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type").

At most one annotated `package` declaration is permitted for a given package.

The manner in which this restriction is enforced must, of necessity, vary from implementation to implementation. The following scheme is strongly recommended for file-system-based implementations: The sole annotated `package` declaration, if it exists, is placed in a source file called `package-info.java` in the directory containing the source files for the package. This file does not contain the source for a class called `package-info.java`; indeed it would be illegal for it to do so, as `package-info` is not a legal identifier. Typically `package-info.java` contains only a `package` declaration, preceded immediately by the annotations on the package. While the file could technically contain the source code for one or more classes with package access, it would be very bad form.

It is recommended that `package-info.java`, if it is present, take the place of `package.html` for `javadoc` and other similar documentation generation systems. If this file is present, the documentation generation tool should look for the package documentation comment immediately preceding the (possibly annotated) `package` declaration in `package-info.java`. In this way, `package-info.java` becomes the sole repository for package-level annotations and documentation. If, in future, it becomes desirable to add any other package-level information, this file should prove a convenient home for this information.

### 7.4.2. Unnamed Packages

A compilation unit that has no `package` declaration is part of an _unnamed package_.

Unnamed packages are provided by the Java SE platform principally for convenience when developing small or temporary applications or when just beginning development.

An unnamed package cannot have subpackages, since the syntax of a `package` declaration always includes a reference to a named top level package.

An implementation of the Java SE platform must support at least one unnamed package. An implementation may support more than one unnamed package, but is not required to do so. Which compilation units are in each unnamed package is determined by the host system.

**Example 7.4.2-1.** 

The compilation unit:

class FirstCall {
    public static void main(String\[\] args) {
        System.out.println("Mr. Watson, come here. "
                           + "I want you.");
    }
}

defines a very simple compilation unit as part of an unnamed package.

  

In implementations of the Java SE platform that use a hierarchical file system for storing packages, one typical strategy is to associate an unnamed package with each directory; only one unnamed package is observable at a time, namely the one that is associated with the "current working directory". The precise meaning of "current working directory" depends on the host system.

### 7.4.3. Observability of a Package

A package is _observable_ if and only if either:

*   A compilation unit containing a declaration of the package is observable ([¬ß7.3](jls-7.html#jls-7.3 "7.3. Compilation Units")).
*   A subpackage of the package is observable.
    

The packages `java`, `java.lang`, and `java.io` are always observable.

One can conclude this from the rule above and from the rules of observable compilation units, as follows. The predefined package `java.lang` declares the class `Object`, so the compilation unit for `Object` is always observable ([¬ß7.3](jls-7.html#jls-7.3 "7.3. Compilation Units")). Hence, the `java.lang` package is observable ([¬ß7.4.3](jls-7.html#jls-7.4.3 "7.4.3. Observability of a Package")), and the `java` package also. Furthermore, since `Object` is observable, the array type `Object``[]` implicitly exists. Its superinterface `java.io.Serializable` ([¬ß10.1](jls-10.html#jls-10.1 "10.1. Array Types")) also exists, hence the `java.io` package is observable.

7.5. Import Declarations
------------------------

An _import declaration_ allows a named type or a `static` member to be referred to by a simple name ([¬ß6.2](jls-6.html#jls-6.2 "6.2. Names and Identifiers")) that consists of a single identifier.

Without the use of an appropriate import declaration, the only way to refer to a type declared in another package, or a `static` member of another type, is to use a fully qualified name ([¬ß6.7](jls-6.html#jls-6.7 "6.7. Fully Qualified Names and Canonical Names")).

ImportDeclaration:

[SingleTypeImportDeclaration](jls-7.html#jls-SingleTypeImportDeclaration "SingleTypeImportDeclaration")  
[TypeImportOnDemandDeclaration](jls-7.html#jls-TypeImportOnDemandDeclaration "TypeImportOnDemandDeclaration")  
[SingleStaticImportDeclaration](jls-7.html#jls-SingleStaticImportDeclaration "SingleStaticImportDeclaration")  
[StaticImportOnDemandDeclaration](jls-7.html#jls-StaticImportOnDemandDeclaration "StaticImportOnDemandDeclaration")

*   A single-type-import declaration ([¬ß7.5.1](jls-7.html#jls-7.5.1 "7.5.1. Single-Type-Import Declarations")) imports a single named type, by mentioning its canonical name ([¬ß6.7](jls-6.html#jls-6.7 "6.7. Fully Qualified Names and Canonical Names")).
*   A type-import-on-demand declaration ([¬ß7.5.2](jls-7.html#jls-7.5.2 "7.5.2. Type-Import-on-Demand Declarations")) imports all the accessible types ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) of a named type or named package as needed, by mentioning the canonical name of a type or package.
*   A single-static-import declaration ([¬ß7.5.3](jls-7.html#jls-7.5.3 "7.5.3. Single-Static-Import Declarations")) imports all accessible `static` members with a given name from a type, by giving its canonical name.
*   A static-import-on-demand declaration ([¬ß7.5.4](jls-7.html#jls-7.5.4 "7.5.4. Static-Import-on-Demand Declarations")) imports all accessible `static` members of a named type as needed, by mentioning the canonical name of a type.
    

The scope and shadowing of a type or member imported by these declarations is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

An `import` declaration makes types or members available by their simple names only within the compilation unit that actually contains the `import` declaration. The scope of the type(s) or member(s) introduced by an `import` declaration specifically does not include other compilation units in the same package, other `import` declarations in the current compilation unit, or a `package` declaration in the current compilation unit (except for the annotations of a `package` declaration).

### 7.5.1. Single-Type-Import Declarations

A _single-type-import declaration_ imports a single type by giving its canonical name, making it available under a simple name in the class and interface declarations of the compilation unit in which the single-type-import declaration appears.

SingleTypeImportDeclaration:

`import` [TypeName](jls-6.html#jls-TypeName "TypeName") `;`

The _TypeName_ must be the canonical name of a class type, interface type, enum type, or annotation type ([¬ß6.7](jls-6.html#jls-6.7 "6.7. Fully Qualified Names and Canonical Names")).

The name must be qualified ([¬ß6.5.5.2](jls-6.html#jls-6.5.5.2 "6.5.5.2. Qualified Type Names")), or a compile-time error occurs.

It is a compile-time error if the named type is not accessible ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")).

If two single-type-import declarations in the same compilation unit attempt to import types with the same simple name, then a compile-time error occurs, unless the two types are the same type, in which case the duplicate declaration is ignored.

If the type imported by the single-type-import declaration is declared in the compilation unit that contains the `import` declaration, the `import` declaration is ignored.

If a single-type-import declaration imports a type whose simple name is n, and the compilation unit also declares a top level type ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")) whose simple name is n, a compile-time error occurs.

If a compilation unit contains both a single-type-import declaration that imports a type whose simple name is n, and a single-static-import declaration ([¬ß7.5.3](jls-7.html#jls-7.5.3 "7.5.3. Single-Static-Import Declarations")) that imports a type whose simple name is n, a compile-time error occurs.

**Example 7.5.1-1. Single-Type-Import**

import java.util.Vector;

causes the simple name `Vector` to be available within the class and interface declarations in a compilation unit. Thus, the simple name `Vector` refers to the type declaration `Vector` in the package `java.util` in all places where it is not shadowed ([¬ß6.4.1](jls-6.html#jls-6.4.1 "6.4.1. Shadowing")) or obscured ([¬ß6.4.2](jls-6.html#jls-6.4.2 "6.4.2. Obscuring")) by a declaration of a field, parameter, local variable, or nested type declaration with the same name.

Note that the actual declaration of `java.util.Vector` is generic ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters")). Once imported, the name `Vector` can be used without qualification in a parameterized type such as `Vector<String>`, or as the raw type `Vector`. A related limitation of the `import` declaration is that a nested type declared inside a generic type declaration can be imported, but its outer type is always erased.

  

**Example 7.5.1-2. Duplicate Type Declarations**

This program:

import java.util.Vector;
class Vector { Object\[\] vec; }

causes a compile-time error because of the duplicate declaration of `Vector`, as does:

import java.util.Vector;
import myVector.Vector;

where `myVector` is a package containing the compilation unit:

package myVector;
public class Vector { Object\[\] vec; }

  

**Example 7.5.1-3. No Import of a Subpackage**

Note that an `import` statement cannot import a subpackage, only a type.

For example, it does not work to try to import `java.util` and then use the name `util.Random` to refer to the type `java.util.Random`:

import java.util;
class Test { util.Random generator; }
  // incorrect: compile-time error

  

**Example 7.5.1-4. Importing a Type Name that is also a Package Name**

Package names and type names are usually different under the naming conventions described in [¬ß6.1](jls-6.html#jls-6.1 "6.1. Declarations"). Nevertheless, in a contrived example where there is an unconventionally-named package `Vector`, which declares a public class whose name is `Mosquito`:

package Vector;
public class Mosquito { int capacity; }

and then the compilation unit:

package strange;
import java.util.Vector;
import Vector.Mosquito;
class Test {
    public static void main(String\[\] args) {
        System.out.println(new Vector().getClass());
        System.out.println(new Mosquito().getClass());
    }
}

the single-type-import declaration importing class `Vector` from package `java.util` does not prevent the package name `Vector` from appearing and being correctly recognized in subsequent `import` declarations. The example compiles and produces the output:

class java.util.Vector
class Vector.Mosquito

  

### 7.5.2. Type-Import-on-Demand Declarations

A _type-import-on-demand declaration_ allows all accessible types of a named package or type to be imported as needed.

TypeImportOnDemandDeclaration:

`import` [PackageOrTypeName](jls-6.html#jls-PackageOrTypeName "PackageOrTypeName") `.` `*` `;`

The _PackageOrTypeName_ must be the canonical name ([¬ß6.7](jls-6.html#jls-6.7 "6.7. Fully Qualified Names and Canonical Names")) of a package, a class type, an interface type, an enum type, or an annotation type.

If the _PackageOrTypeName_ denotes a type ([¬ß6.5.4](jls-6.html#jls-6.5.4 "6.5.4. Meaning of PackageOrTypeNames")), then the name must be qualified ([¬ß6.5.5.2](jls-6.html#jls-6.5.5.2 "6.5.5.2. Qualified Type Names")), or a compile-time error occurs.

It is a compile-time error if the named package or type is not accessible ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")).

It is not a compile-time error to name either `java.lang` or the named package of the current compilation unit in a type-import-on-demand declaration. The type-import-on-demand declaration is ignored in such cases.

Two or more type-import-on-demand declarations in the same compilation unit may name the same type or package. All but one of these declarations are considered redundant; the effect is as if that type was imported only once.

If a compilation unit contains both a type-import-on-demand declaration and a static-import-on-demand declaration ([¬ß7.5.4](jls-7.html#jls-7.5.4 "7.5.4. Static-Import-on-Demand Declarations")) that name the same type, the effect is as if the `static` member types of that type ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")) were imported only once.

**Example 7.5.2-1. Type-Import-on-Demand**

import java.util.\*;

causes the simple names of all `public` types declared in the package `java.util` to be available within the class and interface declarations of the compilation unit. Thus, the simple name `Vector` refers to the type `Vector` in the package `java.util` in all places in the compilation unit where that type declaration is not shadowed ([¬ß6.4.1](jls-6.html#jls-6.4.1 "6.4.1. Shadowing")) or obscured ([¬ß6.4.2](jls-6.html#jls-6.4.2 "6.4.2. Obscuring")).

The declaration might be shadowed by a single-type-import declaration of a type whose simple name is `Vector`; by a type named `Vector` and declared in the package to which the compilation unit belongs; or any nested classes or interfaces.

The declaration might be obscured by a declaration of a field, parameter, or local variable named `Vector`.

(It would be unusual for any of these conditions to occur.)

  

### 7.5.3. Single-Static-Import Declarations

A _single-static-import declaration_ imports all accessible `static` members with a given simple name from a type. This makes these `static` members available under their simple name in the class and interface declarations of the compilation unit in which the single-static-import declaration appears.

SingleStaticImportDeclaration:

`import` `static` [TypeName](jls-6.html#jls-TypeName "TypeName") `.` [Identifier](jls-3.html#jls-Identifier "Identifier") `;`

The _TypeName_ must be the canonical name ([¬ß6.7](jls-6.html#jls-6.7 "6.7. Fully Qualified Names and Canonical Names")) of a class type, interface type, enum type, or annotation type.

The name must be qualified ([¬ß6.5.5.2](jls-6.html#jls-6.5.5.2 "6.5.5.2. Qualified Type Names")), or a compile-time error occurs.

It is a compile-time error if the named type is not accessible ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")).

The _Identifier_ must name at least one `static` member of the named type. It is a compile-time error if there is no `static` member of that name, or if all of the named members are not accessible.It is permissible for one single-static-import declaration to import several fields or types with the same name, or several methods with the same name and signature.

If a single-static-import declaration imports a type whose simple name is n, and the compilation unit also declares a top level type ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")) whose simple name is n, a compile-time error occurs.

If a compilation unit contains both a single-static-import declaration that imports a type whose simple name is n, and a single-type-import declaration ([¬ß7.5.1](jls-7.html#jls-7.5.1 "7.5.1. Single-Type-Import Declarations")) that imports a type whose simple name is n, a compile-time error occurs.

### 7.5.4. Static-Import-on-Demand Declarations

A _static-import-on-demand declaration_ allows all accessible `static` members of a named type to be imported as needed.

StaticImportOnDemandDeclaration:

`import` `static` [TypeName](jls-6.html#jls-TypeName "TypeName") `.` `*` `;`

The _TypeName_ must be the canonical name ([¬ß6.7](jls-6.html#jls-6.7 "6.7. Fully Qualified Names and Canonical Names")) of a class type, interface type, enum type, or annotation type.

The name must be qualified ([¬ß6.5.5.2](jls-6.html#jls-6.5.5.2 "6.5.5.2. Qualified Type Names")), or a compile-time error occurs.

It is a compile-time error if the named type is not accessible ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")).

Two or more static-import-on-demand declarations in the same compilation unit may name the same type; the effect is as if there was exactly one such declaration.

Two or more static-import-on-demand declarations in the same compilation unit may name the same member; the effect is as if the member was imported exactly once.

It is permissible for one static-import-on-demand declaration to import several fields or types with the same name, or several methods with the same name and signature.

If a compilation unit contains both a static-import-on-demand declaration and a type-import-on-demand declaration ([¬ß7.5.2](jls-7.html#jls-7.5.2 "7.5.2. Type-Import-on-Demand Declarations")) that name the same type, the effect is as if the `static` member types of that type ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")) were imported only once.

7.6. Top Level Type Declarations
--------------------------------

A _top level type declaration_ declares a top level class type ([¬ß8 (_Classes_)](jls-8.html "Chapter 8. Classes")) or a top level interface type ([¬ß9 (_Interfaces_)](jls-9.html "Chapter 9. Interfaces")).

TypeDeclaration:

[ClassDeclaration](jls-8.html#jls-ClassDeclaration "ClassDeclaration")  
[InterfaceDeclaration](jls-9.html#jls-InterfaceDeclaration "InterfaceDeclaration")  
`;`

Extra "`;`" tokens appearing at the level of type declarations in a compilation unit have no effect on the meaning of the compilation unit. Stray semicolons are permitted in the Java programming language solely as a concession to C++ programmers who are used to placing "`;`" after a class declaration. They should not be used in new Java code.

In the absence of an access modifier, a top level type has package access: it is accessible only within compilation units of the package in which it is declared ([¬ß6.6.1](jls-6.html#jls-6.6.1 "6.6.1. Determining Accessibility")). A type may be declared `public` to grant access to the type from code in other packages.

It is a compile-time error if a top level type declaration contains any one of the following access modifiers: `protected`, `private`, or `static`.

It is a compile-time error if the name of a top level type appears as the name of any other top level class or interface type declared in the same package.

The scope and shadowing of a top level type is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

The fully qualified name of a top level type is specified in [¬ß6.7](jls-6.html#jls-6.7 "6.7. Fully Qualified Names and Canonical Names").

**Example 7.6-1. Conflicting Top Level Type Declarations**

package test;
import java.util.Vector;
class Point {
    int x, y;
}
interface Point {  // compile-time error #1
    int getR();
    int getTheta();
}
class Vector { Point\[\] pts; }  // compile-time error #2

Here, the first compile-time error is caused by the duplicate declaration of the name `Point` as both a class and an interface in the same package. A second compile-time error is the attempt to declare the name `Vector` both by a class type declaration and by a single-type-import declaration.

Note, however, that it is not an error for the name of a class to also name a type that otherwise might be imported by a type-import-on-demand declaration ([¬ß7.5.2](jls-7.html#jls-7.5.2 "7.5.2. Type-Import-on-Demand Declarations")) in the compilation unit ([¬ß7.3](jls-7.html#jls-7.3 "7.3. Compilation Units")) containing the class declaration. Thus, in this program:

package test;
import java.util.\*;
class Vector {}  // not a compile-time error

the declaration of the class `Vector` is permitted even though there is also a class `java.util.Vector`. Within this compilation unit, the simple name `Vector` refers to the class `test.Vector`, not to `java.util.Vector` (which can still be referred to by code within the compilation unit, but only by its fully qualified name).

  

**Example 7.6-2. Scope of Top Level Types**

package points;
class Point {
    int x, y;           // coordinates
    PointColor color;   // color of this point
    Point next;         // next point with this color
    static int nPoints;
}
class PointColor {
    Point first;        // first point with this color
    PointColor(int color) { this.color = color; }
    private int color;  // color components
}

This program defines two classes that use each other in the declarations of their class members. Because the class types `Point` and `PointColor` have all the type declarations in package `points`, including all those in the current compilation unit, as their scope, this program compiles correctly. That is, forward reference is not a problem.

  

**Example 7.6-3. Fully Qualified Names**

class Point { int x, y; }

In this code, the class `Point` is declared in a compilation unit with no `package` statement, and thus `Point` is its fully qualified name, whereas in the code:

package vista;
class Point { int x, y; }

the fully qualified name of the class `Point` is `vista.Point`. (The package name `vista` is suitable for local or personal use; if the package were intended to be widely distributed, it would be better to give it a unique package name ([¬ß6.1](jls-6.html#jls-6.1 "6.1. Declarations")).)

  

An implementation of the Java SE platform must keep track of types within packages by their binary names ([¬ß13.1](jls-13.html#jls-13.1 "13.1. The Form of a Binary")). Multiple ways of naming a type must be expanded to binary names to make sure that such names are understood as referring to the same type.

For example, if a compilation unit contains the single-type-import declaration ([¬ß7.5.1](jls-7.html#jls-7.5.1 "7.5.1. Single-Type-Import Declarations")):

import java.util.Vector;

then within that compilation unit, the simple name `Vector` and the fully qualified name `java.util.Vector` refer to the same type.

If and only if packages are stored in a file system ([¬ß7.2](jls-7.html#jls-7.2 "7.2. Host Support for Packages")), the host system may choose to enforce the restriction that it is a compile-time error if a type is not found in a file under a name composed of the type name plus an extension (such as `.java` or `.jav`) if either of the following is true:

*   The type is referred to by code in other compilation units of the package in which the type is declared.
*   The type is declared `public` (and therefore is potentially accessible from code in other packages).
    

This restriction implies that there must be at most one such type per compilation unit. This restriction makes it easy for a Java compiler to find a named class within a package. In practice, many programmers choose to put each class or interface type in its own compilation unit, whether or not it is `public` or is referred to by code in other compilation units.

For example, the source code for a `public` type `wet.sprocket.Toad` would be found in a file `Toad.java` in the directory `wet/sprocket`, and the corresponding object code would be found in the file `Toad.class` in the same directory.

üçÄ Chapter 8. Classes
------------------

**Table of Contents**

[8.1. Class Declarations](jls-8.html#jls-8.1)
[8.1.1. Class Modifiers](jls-8.html#jls-8.1.1)
[8.1.1.1. `abstract` Classes](jls-8.html#jls-8.1.1.1)
[8.1.1.2. `final` Classes](jls-8.html#jls-8.1.1.2)
[8.1.1.3. `strictfp` Classes](jls-8.html#jls-8.1.1.3)
[8.1.2. Generic Classes and Type Parameters](jls-8.html#jls-8.1.2)
[8.1.3. Inner Classes and Enclosing Instances](jls-8.html#jls-8.1.3)
[8.1.4. Superclasses and Subclasses](jls-8.html#jls-8.1.4)
[8.1.5. Superinterfaces](jls-8.html#jls-8.1.5)
[8.1.6. Class Body and Member Declarations](jls-8.html#jls-8.1.6)
[8.2. Class Members](jls-8.html#jls-8.2)
[8.3. Field Declarations](jls-8.html#jls-8.3)
[8.3.1. Field Modifiers](jls-8.html#jls-8.3.1)
[8.3.1.1. `static` Fields](jls-8.html#jls-8.3.1.1)
[8.3.1.2. `final` Fields](jls-8.html#jls-8.3.1.2)
[8.3.1.3. `transient` Fields](jls-8.html#jls-8.3.1.3)
[8.3.1.4. `volatile` Fields](jls-8.html#jls-8.3.1.4)
[8.3.2. Field Initialization](jls-8.html#jls-8.3.2)
[8.3.3. Forward References During Field Initialization](jls-8.html#jls-8.3.3)
[8.4. Method Declarations](jls-8.html#jls-8.4)
[8.4.1. Formal Parameters](jls-8.html#jls-8.4.1)
[8.4.2. Method Signature](jls-8.html#jls-8.4.2)
[8.4.3. Method Modifiers](jls-8.html#jls-8.4.3)
[8.4.3.1. `abstract` Methods](jls-8.html#jls-8.4.3.1)
[8.4.3.2. `static` Methods](jls-8.html#jls-8.4.3.2)
[8.4.3.3. `final` Methods](jls-8.html#jls-8.4.3.3)
[8.4.3.4. `native` Methods](jls-8.html#jls-8.4.3.4)
[8.4.3.5. `strictfp` Methods](jls-8.html#jls-8.4.3.5)
[8.4.3.6. `synchronized` Methods](jls-8.html#jls-8.4.3.6)
[8.4.4. Generic Methods](jls-8.html#jls-8.4.4)
[8.4.5. Method Result](jls-8.html#jls-8.4.5)
[8.4.6. Method Throws](jls-8.html#jls-8.4.6)
[8.4.7. Method Body](jls-8.html#jls-8.4.7)
[8.4.8. Inheritance, Overriding, and Hiding](jls-8.html#jls-8.4.8)
[8.4.8.1. Overriding (by Instance Methods)](jls-8.html#jls-8.4.8.1)
[8.4.8.2. Hiding (by Class Methods)](jls-8.html#jls-8.4.8.2)
[8.4.8.3. Requirements in Overriding and Hiding](jls-8.html#jls-8.4.8.3)
[8.4.8.4. Inheriting Methods with Override-Equivalent Signatures](jls-8.html#jls-8.4.8.4)
[8.4.9. Overloading](jls-8.html#jls-8.4.9)
[8.5. Member Type Declarations](jls-8.html#jls-8.5)
[8.5.1. Static Member Type Declarations](jls-8.html#jls-8.5.1)
[8.6. Instance Initializers](jls-8.html#jls-8.6)
[8.7. Static Initializers](jls-8.html#jls-8.7)
[8.8. Constructor Declarations](jls-8.html#jls-8.8)
[8.8.1. Formal Parameters](jls-8.html#jls-8.8.1)
[8.8.2. Constructor Signature](jls-8.html#jls-8.8.2)
[8.8.3. Constructor Modifiers](jls-8.html#jls-8.8.3)
[8.8.4. Generic Constructors](jls-8.html#jls-8.8.4)
[8.8.5. Constructor Throws](jls-8.html#jls-8.8.5)
[8.8.6. The Type of a Constructor](jls-8.html#jls-8.8.6)
[8.8.7. Constructor Body](jls-8.html#jls-8.8.7)
[8.8.7.1. Explicit Constructor Invocations](jls-8.html#jls-8.8.7.1)
[8.8.8. Constructor Overloading](jls-8.html#jls-8.8.8)
[8.8.9. Default Constructor](jls-8.html#jls-8.8.9)
[8.8.10. Preventing Instantiation of a Class](jls-8.html#jls-8.8.10)
[8.9. Enum Types](jls-8.html#jls-8.9)
[8.9.1. Enum Constants](jls-8.html#jls-8.9.1)
[8.9.2. Enum Body Declarations](jls-8.html#jls-8.9.2)
[8.9.3. Enum Members](jls-8.html#jls-8.9.3)

Class declarations define new reference types and describe how they are implemented ([¬ß8.1](jls-8.html#jls-8.1 "8.1. Class Declarations")).

A _top level class_ is a class that is not a nested class.

A _nested class_ is any class whose declaration occurs within the body of another class or interface.

This chapter discusses the common semantics of all classes - top level ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")) and nested (including member classes ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")), local classes ([¬ß14.3](jls-14.html#jls-14.3 "14.3. Local Class Declarations")) and anonymous classes ([¬ß15.9.5](jls-15.html#jls-15.9.5 "15.9.5. Anonymous Class Declarations"))). Details that are specific to particular kinds of classes are discussed in the sections dedicated to these constructs.

A named class may be declared `abstract` ([¬ß8.1.1.1](jls-8.html#jls-8.1.1.1 "8.1.1.1. abstract Classes")) and must be declared abstract if it is incompletely implemented; such a class cannot be instantiated, but can be extended by subclasses. A class may be declared `final` ([¬ß8.1.1.2](jls-8.html#jls-8.1.1.2 "8.1.1.2. final Classes")), in which case it cannot have subclasses. If a class is declared `public`, then it can be referred to from other packages. Each class except `Object` is an extension of (that is, a subclass of) a single existing class ([¬ß8.1.4](jls-8.html#jls-8.1.4 "8.1.4. Superclasses and Subclasses")) and may implement interfaces ([¬ß8.1.5](jls-8.html#jls-8.1.5 "8.1.5. Superinterfaces")). Classes may be _generic_ ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters")), that is, they may declare type variables whose bindings may differ among different instances of the class.

Classes may be decorated with annotations ([¬ß9.7](jls-9.html#jls-9.7 "9.7. Annotations")) just like any other kind of declaration.

The body of a class declares members (fields and methods and nested classes and interfaces), instance and static initializers, and constructors ([¬ß8.1.6](jls-8.html#jls-8.1.6 "8.1.6. Class Body and Member Declarations")). The scope ([¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration")) of a member ([¬ß8.2](jls-8.html#jls-8.2 "8.2. Class Members")) is the entire body of the declaration of the class to which the member belongs. Field, method, member class, member interface, and constructor declarations may include the access modifiers ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) `public`, `protected`, or `private`. The members of a class include both declared and inherited members ([¬ß8.2](jls-8.html#jls-8.2 "8.2. Class Members")). Newly declared fields can hide fields declared in a superclass or superinterface. Newly declared class members and interface members can hide class or interface members declared in a superclass or superinterface. Newly declared methods can hide, implement, or override methods declared in a superclass or superinterface.

Field declarations ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations")) describe class variables, which are incarnated once, and instance variables, which are freshly incarnated for each instance of the class. A field may be declared `final` ([¬ß8.3.1.2](jls-8.html#jls-8.3.1.2 "8.3.1.2. final Fields")), in which case it can be assigned to only once. Any field declaration may include an initializer.

Member class declarations ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations")) describe nested classes that are members of the surrounding class. Member classes may be `static`, in which case they have no access to the instance variables of the surrounding class; or they may be inner classes ([¬ß8.1.3](jls-8.html#jls-8.1.3 "8.1.3. Inner Classes and Enclosing Instances")).

Member interface declarations ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations")) describe nested interfaces that are members of the surrounding class.

Method declarations ([¬ß8.4](jls-8.html#jls-8.4 "8.4. Method Declarations")) describe code that may be invoked by method invocation expressions ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")). A class method is invoked relative to the class type; an instance method is invoked with respect to some particular object that is an instance of a class type. A method whose declaration does not indicate how it is implemented must be declared `abstract`. A method may be declared `final` ([¬ß8.4.3.3](jls-8.html#jls-8.4.3.3 "8.4.3.3. final Methods")), in which case it cannot be hidden or overridden. A method may be implemented by platform-dependent `native` code ([¬ß8.4.3.4](jls-8.html#jls-8.4.3.4 "8.4.3.4. native Methods")). A `synchronized` method ([¬ß8.4.3.6](jls-8.html#jls-8.4.3.6 "8.4.3.6. synchronized Methods")) automatically locks an object before executing its body and automatically unlocks the object on return, as if by use of a `synchronized` statement ([¬ß14.19](jls-14.html#jls-14.19 "14.19. The synchronized Statement")), thus allowing its activities to be synchronized with those of other threads ([¬ß17 (_Threads and Locks_)](jls-17.html "Chapter 17. Threads and Locks")).

Method names may be overloaded ([¬ß8.4.9](jls-8.html#jls-8.4.9 "8.4.9. Overloading")).

Instance initializers ([¬ß8.6](jls-8.html#jls-8.6 "8.6. Instance Initializers")) are blocks of executable code that may be used to help initialize an instance when it is created ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")).

Static initializers ([¬ß8.7](jls-8.html#jls-8.7 "8.7. Static Initializers")) are blocks of executable code that may be used to help initialize a class.

Constructors ([¬ß8.8](jls-8.html#jls-8.8 "8.8. Constructor Declarations")) are similar to methods, but cannot be invoked directly by a method call; they are used to initialize new class instances. Like methods, they may be overloaded ([¬ß8.8.8](jls-8.html#jls-8.8.8 "8.8.8. Constructor Overloading")).

8.1. Class Declarations
-----------------------

A class declaration specifies a new named reference type.

There are two kinds of class declarations: _normal class declarations_ and _enum declarations_.

ClassDeclaration:

[NormalClassDeclaration](jls-8.html#jls-NormalClassDeclaration "NormalClassDeclaration")  
[EnumDeclaration](jls-8.html#jls-EnumDeclaration "EnumDeclaration")

NormalClassDeclaration:

{[ClassModifier](jls-8.html#jls-ClassModifier "ClassModifier")} `class` [Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeParameters](jls-8.html#jls-TypeParameters "TypeParameters")\] \[[Superclass](jls-8.html#jls-Superclass "Superclass")\] \[[Superinterfaces](jls-8.html#jls-Superinterfaces "Superinterfaces")\] [ClassBody](jls-8.html#jls-ClassBody "ClassBody")

The rules in this section apply to all class declarations, including enum declarations. However, special rules apply to enum declarations with regard to class modifiers, inner classes, and superclasses; these rules are stated in [¬ß8.9](jls-8.html#jls-8.9 "8.9. Enum Types").

The _Identifier_ in a class declaration specifies the name of the class.

It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces.

The scope and shadowing of a class declaration is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

### 8.1.1. Class Modifiers

A class declaration may include _class modifiers_.

ClassModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `public` `protected` `private`  
`abstract` `static` `final` `strictfp`

The rules for annotation modifiers on a class declaration are specified in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear") and [¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type").

The access modifier `public` ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) pertains only to top level classes ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")) and member classes ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations")), not to local classes ([¬ß14.3](jls-14.html#jls-14.3 "14.3. Local Class Declarations")) or anonymous classes ([¬ß15.9.5](jls-15.html#jls-15.9.5 "15.9.5. Anonymous Class Declarations")).

The access modifiers `protected` and `private` pertain only to member classes within a directly enclosing class declaration ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations")).

The modifier `static` pertains only to member classes ([¬ß8.5.1](jls-8.html#jls-8.5.1 "8.5.1. Static Member Type Declarations")), not to top level or local or anonymous classes.

It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration.

If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for _ClassModifier_.

#### 8.1.1.1. `abstract` Classes

An `abstract` class is a class that is incomplete, or to be considered incomplete.

It is a compile-time error if an attempt is made to create an instance of an `abstract` class using a class instance creation expression ([¬ß15.9.1](jls-15.html#jls-15.9.1 "15.9.1. Determining the Class being Instantiated")).

A subclass of an `abstract` class that is not itself `abstract` may be instantiated, resulting in the execution of a constructor for the `abstract` class and, therefore, the execution of the field initializers for instance variables of that class.

A normal class may have `abstract` methods, that is, methods that are declared but not yet implemented ([¬ß8.4.3.1](jls-8.html#jls-8.4.3.1 "8.4.3.1. abstract Methods")), only if it is an `abstract` class. It is a compile-time error if a normal class that is not `abstract` has an `abstract` method.

A class C has `abstract` methods if either of the following is true:

*   Any of the member methods ([¬ß8.2](jls-8.html#jls-8.2 "8.2. Class Members")) of C - either declared or inherited - is `abstract`.
*   Any of C's superclasses has an `abstract` method declared with package access, and there exists no method that overrides the `abstract` method from C or from a superclass of C.
    

It is a compile-time error to declare an `abstract` class type such that it is not possible to create a subclass that implements all of its `abstract` methods. This situation can occur if the class would have as members two `abstract` methods that have the same method signature ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")) but return types for which no type is return-type-substitutable with both ([¬ß8.4.5](jls-8.html#jls-8.4.5 "8.4.5. Method Result")).

**Example 8.1.1.1-1. Abstract Class Declaration**

abstract class Point {
    int x = 1, y = 1;
    void move(int dx, int dy) {
        x += dx;
        y += dy;
        alert();
    }
    abstract void alert();
}
abstract class ColoredPoint extends Point {
    int color;
}
class SimplePoint extends Point {
    void alert() { }
}

Here, a class `Point` is declared that must be declared `abstract`, because it contains a declaration of an `abstract` method named `alert`. The subclass of `Point` named `ColoredPoint` inherits the `abstract` method `alert`, so it must also be declared `abstract`. On the other hand, the subclass of `Point` named `SimplePoint` provides an implementation of `alert`, so it need not be `abstract`.

The statement:

Point p = new Point();

would result in a compile-time error; the class `Point` cannot be instantiated because it is `abstract`. However, a `Point` variable could correctly be initialized with a reference to any subclass of `Point`, and the class `SimplePoint` is not `abstract`, so the statement:

Point p = new SimplePoint();

would be correct. Instantiation of a `SimplePoint` causes the default constructor and field initializers for `x` and `y` of `Point` to be executed.

  

**Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses**

interface Colorable {
    void setColor(int color);
}
abstract class Colored implements Colorable {
    public abstract int setColor(int color);
}

These declarations result in a compile-time error: it would be impossible for any subclass of class `Colored` to provide an implementation of a method named `setColor`, taking one argument of type `int`, that can satisfy both abstract method specifications, because the one in interface `Colorable` requires the same method to return no value, while the one in class `Colored` requires the same method to return a value of type `int` ([¬ß8.4](jls-8.html#jls-8.4 "8.4. Method Declarations")).

  

A class type should be declared `abstract` only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ([¬ß8.8.10](jls-8.html#jls-8.8.10 "8.8.10. Preventing Instantiation of a Class")) of no arguments, make it `private`, never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables.

The class `Math` is an example of a class that cannot be instantiated; its declaration looks like this:

public final class Math {
    private Math() { }  // never instantiate this class
    . . . declarations of class variables and methods . . .
}

#### 8.1.1.2. `final` Classes

A class can be declared `final` if its definition is complete and no subclasses are desired or required.

It is a compile-time error if the name of a `final` class appears in the `extends` clause ([¬ß8.1.4](jls-8.html#jls-8.1.4 "8.1.4. Superclasses and Subclasses")) of another class declaration; this implies that a `final` class cannot have any subclasses.

It is a compile-time error if a class is declared both `final` and `abstract`, because the implementation of such a class could never be completed ([¬ß8.1.1.1](jls-8.html#jls-8.1.1.1 "8.1.1.1. abstract Classes")).

Because a `final` class never has any subclasses, the methods of a `final` class are never overridden ([¬ß8.4.8.1](jls-8.html#jls-8.4.8.1 "8.4.8.1. Overriding (by Instance Methods)")).

#### 8.1.1.3. `strictfp` Classes

The effect of the `strictfp` modifier is to make all `float` or `double` expressions within the class declaration (including within variable initializers, instance initializers, static initializers, and constructors) be explicitly FP-strict ([¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions")).

This implies that all methods declared in the class, and all nested types declared in the class, are implicitly `strictfp`.

### 8.1.2. Generic Classes and Type Parameters

A class is _generic_ if it declares one or more type variables ([¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables")).

These type variables are known as the _type parameters_ of the class. The type parameter section follows the class name and is delimited by angle brackets.

TypeParameters:

`<` [TypeParameterList](jls-8.html#jls-TypeParameterList "TypeParameterList") `>`

TypeParameterList:

[TypeParameter](jls-4.html#jls-TypeParameter "TypeParameter") {`,` [TypeParameter](jls-4.html#jls-TypeParameter "TypeParameter")}

The following productions from [¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables") are shown here for convenience:

TypeParameter:

{[TypeParameterModifier](jls-4.html#jls-TypeParameterModifier "TypeParameterModifier")} [Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeBound](jls-4.html#jls-TypeBound "TypeBound")\]

TypeParameterModifier:

[Annotation](jls-9.html#jls-Annotation "Annotation")

TypeBound:

`extends` [TypeVariable](jls-4.html#jls-TypeVariable "TypeVariable")  
`extends` [ClassOrInterfaceType](jls-4.html#jls-ClassOrInterfaceType "ClassOrInterfaceType") {[AdditionalBound](jls-4.html#jls-AdditionalBound "AdditionalBound")}

AdditionalBound:

`&` [InterfaceType](jls-4.html#jls-InterfaceType "InterfaceType")

The rules for annotation modifiers on a type parameter declaration are specified in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear") and [¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type").

In a class's type parameter section, a type variable T _directly depends_ on a type variable S if S is the bound of T, while T _depends_ on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself.

The scope and shadowing of a class's type parameter is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

A generic class declaration defines a set of parameterized types ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time.

For instance, executing the code:

Vector<String>  x = new Vector<String>();
Vector<Integer> y = new Vector<Integer>();
boolean b = x.getClass() == y.getClass();

will result in the variable `b` holding the value `true`.

It is a compile-time error if a generic class is a direct or indirect subclass of `Throwable` ([¬ß11.1.1](jls-11.html#jls-11.1.1 "11.1.1. The Kinds of Exceptions")).

This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes.

It is a compile-time error to refer to a type parameter of a generic class C in any of the following:

*   the declaration of a `static` member of C ([¬ß8.3.1.1](jls-8.html#jls-8.3.1.1 "8.3.1.1. static Fields"), [¬ß8.4.3.2](jls-8.html#jls-8.4.3.2 "8.4.3.2. static Methods"), [¬ß8.5.1](jls-8.html#jls-8.5.1 "8.5.1. Static Member Type Declarations")).
*   the declaration of a `static` member of any type declaration nested within C.
*   a static initializer of C ([¬ß8.7](jls-8.html#jls-8.7 "8.7. Static Initializers")), or
*   a static initializer of any class declaration nested within C.
    

**Example 8.1.2-1. Mutually Recursive Type Variable Bounds**

interface ConvertibleTo<T> {
    T convert();
}
class ReprChange<T extends ConvertibleTo<S>,
                 S extends ConvertibleTo<T>> { 
    T t; 
    void set(S s) { t = s.convert();    } 
    S get()       { return t.convert(); } 
}

  

**Example 8.1.2-2. Nested Generic Classes**

class Seq<T> { 
    T      head;
    Seq<T> tail;

    Seq() { this(null, null); } 
    Seq(T head, Seq<T> tail) {
        this.head = head;
        this.tail = tail;
    }
    boolean isEmpty() { return tail == null; }

    class Zipper<S> { 
        Seq<Pair<T,S>> zip(Seq<S> that) { 
            if (isEmpty() || that.isEmpty()) {
                return new Seq<Pair<T,S>>(); 
            } else {
                Seq<T>.Zipper<S> tailZipper =
                    tail.new Zipper<S>();
                return new Seq<Pair<T,S>>( 
                    new Pair<T,S>(head, that.head),
                    tailZipper.zip(that.tail));
            }
        }
    }
}
class Pair<T, S> {
    T fst; S snd;
    Pair(T f, S s) { fst = f; snd = s; }
}
class Test {
    public static void main(String\[\] args) {
        Seq<String> strs =
            new Seq<String>(
                "a",
                new Seq<String>("b",
                                new Seq<String>()));
        Seq<Number> nums =
            new Seq<Number>(
                new Integer(1),
                new Seq<Number>(new Double(1.5),
                                new Seq<Number>()));

        Seq<String>.Zipper<Number> zipper =
            strs.new Zipper<Number>();

        Seq<Pair<String,Number>> combined =
            zipper.zip(nums);
    }
}

  

### 8.1.3. Inner Classes and Enclosing Instances

An _inner class_ is a nested class that is not explicitly or implicitly declared `static`.

An inner class may be a non-`static` member class ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations")), a local class ([¬ß14.3](jls-14.html#jls-14.3 "14.3. Local Class Declarations")), or an anonymous class ([¬ß15.9.5](jls-15.html#jls-15.9.5 "15.9.5. Anonymous Class Declarations")). A member class of an interface is implicitly `static` ([¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")) so is never considered to be an inner class.

It is a compile-time error if an inner class declares a static initializer ([¬ß8.7](jls-8.html#jls-8.7 "8.7. Static Initializers")).

It is a compile-time error if an inner class declares a member that is explicitly or implicitly `static`, unless the member is a constant variable ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")).

An inner class may inherit `static` members that are not constant variables even though it cannot declare them.

A nested class that is not an inner class may declare `static` members freely, in accordance with the usual rules of the Java programming language.

**Example 8.1.3-1. Inner Class Declarations and Static Members**

class HasStatic {
    static int j = 100;
}
class Outer {
    class Inner extends HasStatic {
        static final int x = 3;  // OK: constant variable
        static int y = 4;  // Compile-time error: an inner class
    }
    static class NestedButNotInner{
        static int z = 5;    // OK: not an inner class
    }
    interface NeverInner {}  // Interfaces are never inner
}

  

A statement or expression _occurs in a static context_ if and only if the innermost method, constructor, instance initializer, static initializer, field initializer, or explicit constructor invocation statement enclosing the statement or expression is a static method, a static initializer, the variable initializer of a static variable, or an explicit constructor invocation statement ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations")).

An inner class C is a _direct inner class of a class or interface O_ if O is the immediately enclosing type declaration of C and the declaration of C does not occur in a static context.

A class C is an _inner class of class or interface O_ if it is either a direct inner class of O or an inner class of an inner class of O.

It is unusual, but possible, for the immediately enclosing type declaration of an inner class to be an interface. This only occurs if the class is declared in a default method body ([¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations")). Specifically, it occurs if an anonymous or local class is declared in a default method body, or a member class is declared in the body of an anonymous class that is declared in a default method body.

A class or interface O is the _zeroth lexically enclosing type declaration of itself_.

A class O is the _n'th lexically enclosing type declaration of a class C_ if it is the immediately enclosing type declaration of the _n-1_'th lexically enclosing type declaration of C.

An instance `i` of a direct inner class C of a class or interface O is associated with an instance of O, known as the _immediately enclosing instance of `i`_. The immediately enclosing instance of an object, if any, is determined when the object is created ([¬ß15.9.2](jls-15.html#jls-15.9.2 "15.9.2. Determining Enclosing Instances")).

An object `o` is the _zeroth lexically enclosing instance of itself_.

An object `o` is the _n'th lexically enclosing instance of an instance `i`_ if it is the immediately enclosing instance of the _n-1_'th lexically enclosing instance of `i`.

An instance of an inner class I whose declaration occurs in a static context has no lexically enclosing instances. However, if I is immediately declared within a static method or static initializer then I does have an _enclosing block_, which is the innermost block statement lexically enclosing the declaration of I.

For every superclass S of C which is itself a direct inner class of a class or interface SO, there is an instance of SO associated with `i`, known as the _immediately enclosing instance of `i` with respect to S_. The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations")).

When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing type declaration, the variable of the corresponding lexically enclosing instance is used.\-510">Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be declared `final` or be effectively final ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")), or a compile-time error occurs where the use is attempted.

Any local variable used but not declared in an inner class must be definitely assigned ([¬ß16 (_Definite Assignment_)](jls-16.html "Chapter 16. Definite Assignment")) before the body of the inner class, or a compile-time error occurs.

Similar rules on variable use apply in the body of a lambda expression ([¬ß15.27.2](jls-15.html#jls-15.27.2 "15.27.2. Lambda Body")).

A blank `final` field ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")) of a lexically enclosing type declaration may not be assigned within an inner class, or a compile-time error occurs.

**Example 8.1.3-2. Inner Class Declarations**

class Outer {
    int i = 100;
    static void classMethod() {
        final int l = 200;
        class LocalInStaticContext {
            int k = i;  // Compile-time error
            int m = l;  // OK
        }
    }
    void foo() {
        class Local {  // A local class
            int j = i;
        }
    }
}

The declaration of class `LocalInStaticContext` occurs in a static context due to being within the static method `classMethod`. Instance variables of class `Outer` are not available within the body of a static method. In particular, instance variables of `Outer` are not available inside the body of `LocalInStaticContext`. However, local variables from the surrounding method may be referred to without error (provided they are marked `final`).

Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing type declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing type declaration, the instance variable must be defined with respect to an enclosing instance of that declared type. For example, the class `Local` above has an enclosing instance of class `Outer`. As a further example:

class WithDeepNesting {
    boolean toBe;
    WithDeepNesting(boolean b) { toBe = b; }

    class Nested {
        boolean theQuestion;
        class DeeplyNested {
            DeeplyNested(){
                theQuestion = toBe || !toBe;
            }
        }
    }
}

Here, every instance of `WithDeepNesting.Nested.DeeplyNested` has an enclosing instance of class `WithDeepNesting.Nested` (its immediately enclosing instance) and an enclosing instance of class `WithDeepNesting` (its 2nd lexically enclosing instance).

  

### 8.1.4. Superclasses and Subclasses

The optional `extends` clause in a normal class declaration specifies the _direct superclass_ of the current class.

Superclass:

`extends` [ClassType](jls-4.html#jls-ClassType "ClassType")

The `extends` clause must not appear in the definition of the class `Object`, or a compile-time error occurs, because it is the primordial class and has no direct superclass.

The _ClassType_ must name an accessible class type ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")), or a compile-time error occurs.

It is a compile-time error if the _ClassType_ names a class that is `final`, because `final` classes are not allowed to have subclasses ([¬ß8.1.1.2](jls-8.html#jls-8.1.1.2 "8.1.1.2. final Classes")).

It is a compile-time error if the _ClassType_ names the class `Enum` or any invocation of `Enum` ([¬ß8.9](jls-8.html#jls-8.9 "8.9. Enum Types")).

If the _ClassType_ has type arguments, it must denote a well-formed parameterized type ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs.

Given a (possibly generic) class declaration C`<`F1,...,Fn`>` (_n_ ‚â• 0, C ‚â† `Object`), the _direct superclass_ of the class type C`<`F1,...,Fn`>` is the type given in the `extends` clause of the declaration of C if an `extends` clause is present, or `Object` otherwise.

Given a generic class declaration C`<`F1,...,Fn`>` (_n_ > 0), the _direct superclass_ of the parameterized class type C`<`T1,...,Tn`>`, where Ti (1 ‚â§ _i_ ‚â§ _n_) is a type, is D`<`U1 Œ∏,...,Uk Œ∏`>`, where D`<`U1,...,Uk`>` is the direct superclass of C`<`F1,...,Fn`>` and Œ∏ is the substitution `[F1:=T1,...,Fn:=Tn]`.

A class is said to be a _direct subclass_ of its direct superclass. The direct superclass is the class from whose implementation the implementation of the current class is derived.

The _subclass_ relationship is the transitive closure of the direct subclass relationship. A class A is a subclass of class C if either of the following is true:

*   A is the direct subclass of C
*   There exists a class B such that A is a subclass of B, and B is a subclass of C, applying this definition recursively.
    

Class C is said to be a _superclass_ of class A whenever A is a subclass of C.

**Example 8.1.4-1. Direct Superclasses and Subclasses**

class Point { int x, y; }
final class ColoredPoint extends Point { int color; }
class Colored3DPoint extends ColoredPoint { int z; }  // error

Here, the relationships are as follows:

*   The class `Point` is a direct subclass of `Object`.
*   The class `Object` is the direct superclass of the class `Point`.
*   The class `ColoredPoint` is a direct subclass of class `Point`.
*   The class `Point` is the direct superclass of class `ColoredPoint`.
    

The declaration of class `Colored3dPoint` causes a compile-time error because it attempts to extend the final class `ColoredPoint`.

  

**Example 8.1.4-2. Superclasses and Subclasses**

class Point { int x, y; }
class ColoredPoint extends Point { int color; }
final class Colored3dPoint extends ColoredPoint { int z; }

Here, the relationships are as follows:

*   The class `Point` is a superclass of class `ColoredPoint`.
*   The class `Point` is a superclass of class `Colored3dPoint`.
*   The class `ColoredPoint` is a subclass of class `Point`.
*   The class `ColoredPoint` is a superclass of class `Colored3dPoint`.
*   The class `Colored3dPoint` is a subclass of class `ColoredPoint`.
*   The class `Colored3dPoint` is a subclass of class `Point`.
    

  

A class C _directly depends_ on a type T if T is mentioned in the `extends` or `implements` clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name.

A class C _depends_ on a reference type T if any of the following is true:

*   C directly depends on T.
*   C directly depends on an interface I that depends ([¬ß9.1.3](jls-9.html#jls-9.1.3 "9.1.3. Superinterfaces and Subinterfaces")) on T.
*   C directly depends on a class D that depends on T (using this definition recursively).
    

It is a compile-time error if a class depends on itself.

If circularly declared classes are detected at run time, as classes are loaded, then a `ClassCircularityError` is thrown ([¬ß12.2.1](jls-12.html#jls-12.2.1 "12.2.1. The Loading Process")).

**Example 8.1.4-3. Class Depends on Itself**

class Point extends ColoredPoint { int x, y; }
class ColoredPoint extends Point { int color; }

This program causes a compile-time error because class `Point` depends on itself.

  

### 8.1.5. Superinterfaces

The optional `implements` clause in a class declaration lists the names of interfaces that are direct superinterfaces of the class being declared.

Superinterfaces:

`implements` [InterfaceTypeList](jls-8.html#jls-InterfaceTypeList "InterfaceTypeList")

InterfaceTypeList:

[InterfaceType](jls-4.html#jls-InterfaceType "InterfaceType") {`,` [InterfaceType](jls-4.html#jls-InterfaceType "InterfaceType")}

Each _InterfaceType_ must name an accessible interface type ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")), or a compile-time error occurs.

If an _InterfaceType_ has type arguments, it must denote a well-formed parameterized type ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs.

It is a compile-time error if the same interface is mentioned as a direct superinterface more than once in a single `implements` clause. This is true even if the interface is named in different ways.

**Example 8.1.5-1. Illegal Superinterfaces**

class Redundant implements java.lang.Cloneable, Cloneable {
    int x;
}

This program results in a compile-time error because the names `java.lang.Cloneable` and `Cloneable` refer to the same interface.

  

Given a (possibly generic) class declaration C`<`F1,...,Fn`>` (_n_ ‚â• 0, C ‚â† `Object`), the _direct superinterfaces_ of the class type C`<`F1,...,Fn`>` are the types given in the `implements` clause of the declaration of C, if an `implements` clause is present.

Given a generic class declaration C`<`F1,...,Fn`>` (_n_ > 0), the _direct superinterfaces_ of the parameterized class type C`<`T1,...,Tn`>`, where Ti (1 ‚â§ _i_ ‚â§ _n_) is a type, are all types I`<`U1 Œ∏,...,Uk Œ∏`>`, where I`<`U1,...,Uk`>` is a direct superinterface of C`<`F1,...,Fn`>` and Œ∏ is the substitution `[F1:=T1,...,Fn:=Tn]`.

An interface type I is a _superinterface_ of class type C if any of the following is true:

*   I is a direct superinterface of C.
*   C has some direct superinterface J for which I is a superinterface, using the definition of "superinterface of an interface" given in [¬ß9.1.3](jls-9.html#jls-9.1.3 "9.1.3. Superinterfaces and Subinterfaces").
*   I is a superinterface of the direct superclass of C.
    

A class can have a superinterface in more than one way.

A class is said to _implement_ all its superinterfaces.

A class may not at the same time be a subtype of two interface types which are different parameterizations of the same generic interface ([¬ß9.1.2](jls-9.html#jls-9.1.2 "9.1.2. Generic Interfaces and Type Parameters")), or a subtype of a parameterization of a generic interface and a raw type naming that same generic interface, or a compile-time error occurs.

This requirement was introduced in order to support translation by type erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")).

**Example 8.1.5-2. Superinterfaces**

interface Colorable {
    void setColor(int color);
    int getColor();
}
enum Finish { MATTE, GLOSSY }
interface Paintable extends Colorable {
    void setFinish(Finish finish);
    Finish getFinish();
}

class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {
    int color;
    public void setColor(int color) { this.color = color; }
    public int getColor() { return color; }
}
class PaintedPoint extends ColoredPoint implements Paintable {
    Finish finish;
    public void setFinish(Finish finish) {
        this.finish = finish;
    }
    public Finish getFinish() { return finish; }
}

Here, the relationships are as follows:

*   The interface `Paintable` is a superinterface of class `PaintedPoint`.
*   The interface `Colorable` is a superinterface of class `ColoredPoint` and of class `PaintedPoint`.
*   The interface `Paintable` is a subinterface of the interface `Colorable`, and `Colorable` is a superinterface of `Paintable`, as defined in [¬ß9.1.3](jls-9.html#jls-9.1.3 "9.1.3. Superinterfaces and Subinterfaces").
    

The class `PaintedPoint` has `Colorable` as a superinterface both because it is a superinterface of `ColoredPoint` and because it is a superinterface of `Paintable`.

  

**Example 8.1.5-3. Illegal Multiple Inheritance of an Interface**

interface I<T> {}
class B implements I<Integer> {}
class C extends B implements I<String> {}

Class `C` causes a compile-time error because it attempts to be a subtype of both I<`Integer`\> and I<`String`\>.

  

Unless the class being declared is `abstract`, all the `abstract` member methods of each direct superinterface must be implemented ([¬ß8.4.8.1](jls-8.html#jls-8.4.8.1 "8.4.8.1. Overriding (by Instance Methods)")) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not `abstract` is not permitted to have `abstract` methods ([¬ß8.1.1.1](jls-8.html#jls-8.1.1.1 "8.1.1.1. abstract Classes")).

Each default method ([¬ß9.4.3](jls-9.html#jls-9.4.3 "9.4.3. Interface Method Body")) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body.

It is permitted for a single method declaration in a class to implement methods of more than one superinterface.

**Example 8.1.5-3. Implementing Methods of a Superinterface**

interface Colorable {
    void setColor(int color);
    int getColor();
}
class Point { int x, y; };
class ColoredPoint extends Point implements Colorable {
    int color;
}

This program causes a compile-time error, because `ColoredPoint` is not an `abstract` class but fails to provide an implementation of methods `setColor` and `getColor` of the interface `Colorable`.

In the following program:

interface Fish  { int getNumberOfScales(); }
interface Piano { int getNumberOfScales(); }
class Tuna implements Fish, Piano {
    // You can tune a piano, but can you tuna fish?
    public int getNumberOfScales() { return 91; }
}

the method `getNumberOfScales` in class `Tuna` has a name, signature, and return type that matches the method declared in interface `Fish` and also matches the method declared in interface `Piano`; it is considered to implement both.

On the other hand, in a situation such as this:

interface Fish       { int    getNumberOfScales(); }
interface StringBass { double getNumberOfScales(); }
class Bass implements Fish, StringBass {
    // This declaration cannot be correct,
    // no matter what type is used.
    public ?? getNumberOfScales() { return 91; }
}

it is impossible to declare a method named `getNumberOfScales` whose signature and return type are compatible with those of both the methods declared in interface `Fish` and in interface `StringBass`, because a class cannot have multiple methods with the same signature and different primitive return types ([¬ß8.4](jls-8.html#jls-8.4 "8.4. Method Declarations")). Therefore, it is impossible for a single class to implement both interface `Fish` and interface `StringBass` ([¬ß8.4.8](jls-8.html#jls-8.4.8 "8.4.8. Inheritance, Overriding, and Hiding")).

  

### 8.1.6. Class Body and Member Declarations

A _class body_ may contain declarations of members of the class, that is, fields ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations")), methods ([¬ß8.4](jls-8.html#jls-8.4 "8.4. Method Declarations")), classes ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations")), and interfaces ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations")).

A class body may also contain instance initializers ([¬ß8.6](jls-8.html#jls-8.6 "8.6. Instance Initializers")), static initializers ([¬ß8.7](jls-8.html#jls-8.7 "8.7. Static Initializers")), and declarations of constructors ([¬ß8.8](jls-8.html#jls-8.8 "8.8. Constructor Declarations")) for the class.

ClassBody:

`{` {[ClassBodyDeclaration](jls-8.html#jls-ClassBodyDeclaration "ClassBodyDeclaration")} `}`

ClassBodyDeclaration:

[ClassMemberDeclaration](jls-8.html#jls-ClassMemberDeclaration "ClassMemberDeclaration")  
[InstanceInitializer](jls-8.html#jls-InstanceInitializer "InstanceInitializer")  
[StaticInitializer](jls-8.html#jls-StaticInitializer "StaticInitializer")  
[ConstructorDeclaration](jls-8.html#jls-ConstructorDeclaration "ConstructorDeclaration")

ClassMemberDeclaration:

[FieldDeclaration](jls-8.html#jls-FieldDeclaration "FieldDeclaration")  
[MethodDeclaration](jls-8.html#jls-MethodDeclaration "MethodDeclaration")  
[ClassDeclaration](jls-8.html#jls-ClassDeclaration "ClassDeclaration")  
[InterfaceDeclaration](jls-9.html#jls-InterfaceDeclaration "InterfaceDeclaration")  
`;`

The scope and shadowing of a declaration of a member `m` declared in or inherited by a class type C is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

If C itself is a nested class, there may be definitions of the same kind (variable, method, or type) and name as `m` in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member `m` declared in or inherited by C shadows ([¬ß6.4.1](jls-6.html#jls-6.4.1 "6.4.1. Shadowing")) the other definitions of the same kind and name.

8.2. Class Members
------------------

The members of a class type are all of the following:

*   Members inherited from its direct superclass ([¬ß8.1.4](jls-8.html#jls-8.1.4 "8.1.4. Superclasses and Subclasses")), except in class `Object`, which has no direct superclass
*   Members inherited from any direct superinterfaces ([¬ß8.1.5](jls-8.html#jls-8.1.5 "8.1.5. Superinterfaces"))
*   Members declared in the body of the class ([¬ß8.1.6](jls-8.html#jls-8.1.6 "8.1.6. Class Body and Member Declarations"))
    

Members of a class that are declared `private` are not inherited by subclasses of that class.

Only members of a class that are declared `protected` or `public` are inherited by subclasses declared in a package other than the one in which the class is declared.

Constructors, static initializers, and instance initializers are not members and therefore are not inherited.

We use the phrase _the type of a member_ to denote:

*   For a field, its type.
*   For a method, an ordered 4-tuple consisting of:
    
    *   type parameters: the declarations of any type parameters of the method member.
        
    *   argument types: a list of the types of the arguments to the method member.
        
    *   return type: the return type of the method member.
        
    *   `throws` clause: exception types declared in the `throws` clause of the method member.
        
    

Fields, methods, and member types of a class type may have the same name, since they are used in different contexts and are disambiguated by different lookup procedures ([¬ß6.5](jls-6.html#jls-6.5 "6.5. Determining the Meaning of a Name")). However, this is discouraged as a matter of style.

**Example 8.2-1. Use of Class Members**

class Point {
    int x, y;
    private Point() { reset(); }
    Point(int x, int y) { this.x = x; this.y = y; }
    private void reset() { this.x = 0; this.y = 0; }
}
class ColoredPoint extends Point {
    int color;
    void clear() { reset(); }  // error
}
class Test {
    public static void main(String\[\] args) {
        ColoredPoint c = new ColoredPoint(0, 0);  // error
        c.reset();  // error
    }
}

This program causes four compile-time errors.

One error occurs because `ColoredPoint` has no constructor declared with two `int` parameters, as requested by the use in `main`. This illustrates the fact that `ColoredPoint` does not inherit the constructors of its superclass `Point`.

Another error occurs because `ColoredPoint` declares no constructors, and therefore a default constructor for it is implicitly declared ([¬ß8.8.9](jls-8.html#jls-8.8.9 "8.8.9. Default Constructor")), and this default constructor is equivalent to:

ColoredPoint() { super(); }

which invokes the constructor, with no arguments, for the direct superclass of the class `ColoredPoint`. The error is that the constructor for `Point` that takes no arguments is `private`, and therefore is not accessible outside the class `Point`, even through a superclass constructor invocation ([¬ß8.8.7](jls-8.html#jls-8.8.7 "8.8.7. Constructor Body")).

Two more errors occur because the method `reset` of class `Point` is `private`, and therefore is not inherited by class `ColoredPoint`. The method invocations in method `clear` of class `ColoredPoint` and in method `main` of class `Test` are therefore not correct.

  

**Example 8.2-2. Inheritance of Class Members with Package Access**

Consider the example where the `points` package declares two compilation units:

package points;
public class Point {
    int x, y;
    public void move(int dx, int dy) { x += dx; y += dy; }
}

and:

package points;
public class Point3d extends Point {
    int z;
    public void move(int dx, int dy, int dz) {
        x += dx; y += dy; z += dz;
    }
}

and a third compilation unit, in another package, is:

import points.Point3d;
class Point4d extends Point3d {
    int w;
    public void move(int dx, int dy, int dz, int dw) {
        x += dx; y += dy; z += dz; w += dw; // compile-time errors
    }
}

Here both classes in the `points` package compile. The class `Point3d` inherits the fields `x` and `y` of class `Point`, because it is in the same package as `Point`. The class `Point4d`, which is in a different package, does not inherit the fields `x` and `y` of class `Point` or the field `z` of class `Point3d`, and so fails to compile.

A better way to write the third compilation unit would be:

import points.Point3d;
class Point4d extends Point3d {
    int w;
    public void move(int dx, int dy, int dz, int dw) {
        super.move(dx, dy, dz); w += dw;
    }
}

using the `move` method of the superclass `Point3d` to process `dx`, `dy`, and `dz`. If `Point4d` is written in this way, it will compile without errors.

  

**Example 8.2-3. Inheritance of `public` and `protected` Class Members**

Given the class `Point`:

package points;
public class Point {
    public int x, y;
    protected int useCount = 0;
    static protected int totalUseCount = 0;
    public void move(int dx, int dy) {
        x += dx; y += dy; useCount++; totalUseCount++;
    }
}

the `public` and `protected` fields `x`, `y`, `useCount`, and `totalUseCount` are inherited in all subclasses of `Point`.

Therefore, this test program, in another package, can be compiled successfully:

class Test extends points.Point {
    public void moveBack(int dx, int dy) {
        x -= dx; y -= dy; useCount++; totalUseCount++;
    }
}

  

**Example 8.2-4. Inheritance of `private` Class Members**

class Point {
    int x, y;
    void move(int dx, int dy) {
        x += dx; y += dy; totalMoves++;
    }
    private static int totalMoves;
    void printMoves() { System.out.println(totalMoves); }
}
class Point3d extends Point {
    int z;
    void move(int dx, int dy, int dz) {
        super.move(dx, dy); z += dz; totalMoves++; // error
    }
}

Here, the class variable `totalMoves` can be used only within the class `Point`; it is not inherited by the subclass `Point3d`. A compile-time error occurs because method move of class `Point3d` tries to increment `totalMoves`.

  

**Example 8.2-5. Accessing Members of Inaccessible Classes**

Even though a class might not be declared `public`, instances of the class might be available at run time to code outside the package in which it is declared by means of a `public` superclass or superinterface. An instance of the class can be assigned to a variable of such a `public` type. An invocation of a `public` method of the object referred to by such a variable may invoke a method of the class if it implements or overrides a method of the `public` superclass or superinterface. (In this situation, the method is necessarily declared `public`, even though it is declared in a class that is not `public`.)

Consider the compilation unit:

package points;
public class Point {
    public int x, y;
    public void move(int dx, int dy) {
        x += dx; y += dy;
    }
}

and another compilation unit of another package:

package morePoints;
class Point3d extends points.Point {
    public int z;
    public void move(int dx, int dy, int dz) {
        super.move(dx, dy); z += dz;
    }
    public void move(int dx, int dy) {
        move(dx, dy, 0);
    }
}
public class OnePoint {
    public static points.Point getOne() { 
        return new Point3d(); 
    }
}

An invocation `morePoints.OnePoint.getOne()` in yet a third package would return a `Point3d` that can be used as a `Point`, even though the type `Point3d` is not available outside the package `morePoints`. The two-argument version of method `move` could then be invoked for that object, which is permissible because method `move` of `Point3d` is `public` (as it must be, for any method that overrides a `public` method must itself be `public`, precisely so that situations such as this will work out correctly). The fields `x` and `y` of that object could also be accessed from such a third package.

While the field `z` of class `Point3d` is `public`, it is not possible to access this field from code outside the package `morePoints`, given only a reference to an instance of class `Point3d` in a variable `p` of type `Point`. This is because the expression `p.z` is not correct, as `p` has type `Point` and class `Point` has no field named `z`; also, the expression `((Point3d)p).z` is not correct, because the class type `Point3d` cannot be referred to outside package `morePoints`.

The declaration of the field `z` as `public` is not useless, however. If there were to be, in package `morePoints`, a `public` subclass `Point4d` of the class `Point3d`:

package morePoints;
public class Point4d extends Point3d {
    public int w;
    public void move(int dx, int dy, int dz, int dw) {
        super.move(dx, dy, dz); w += dw;
    }
}

then class `Point4d` would inherit the field `z`, which, being `public`, could then be accessed by code in packages other than `morePoints`, through variables and expressions of the `public` type `Point4d`.

  

8.3. Field Declarations
-----------------------

The variables of a class type are introduced by _field declarations_.

FieldDeclaration:

{[FieldModifier](jls-8.html#jls-FieldModifier "FieldModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [VariableDeclaratorList](jls-8.html#jls-VariableDeclaratorList "VariableDeclaratorList") `;`on">

VariableDeclaratorList:

[VariableDeclarator](jls-8.html#jls-VariableDeclarator "VariableDeclarator") {`,` [VariableDeclarator](jls-8.html#jls-VariableDeclarator "VariableDeclarator")}

VariableDeclarator:

[VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId") \[`=` [VariableInitializer](jls-8.html#jls-VariableInitializer "VariableInitializer")\]

VariableDeclaratorId:

[Identifier](jls-3.html#jls-Identifier "Identifier") \[[Dims](jls-4.html#jls-Dims "Dims")\]

VariableInitializer:

[Expression](jls-15.html#jls-Expression "Expression")  
[ArrayInitializer](jls-10.html#jls-ArrayInitializer "ArrayInitializer")

UnannType:

[UnannPrimitiveType](jls-8.html#jls-UnannPrimitiveType "UnannPrimitiveType")  
[UnannReferenceType](jls-8.html#jls-UnannReferenceType "UnannReferenceType")

UnannPrimitiveType:

[NumericType](jls-4.html#jls-NumericType "NumericType")  
`boolean`

UnannReferenceType:

[UnannClassOrInterfaceType](jls-8.html#jls-UnannClassOrInterfaceType "UnannClassOrInterfaceType")  
[UnannTypeVariable](jls-8.html#jls-UnannTypeVariable "UnannTypeVariable")  
[UnannArrayType](jls-8.html#jls-UnannArrayType "UnannArrayType")

UnannClassOrInterfaceType:

[UnannClassType](jls-8.html#jls-UnannClassType "UnannClassType")  
[UnannInterfaceType](jls-8.html#jls-UnannInterfaceType "UnannInterfaceType")

UnannClassType:

[Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\]  
[UnannClassOrInterfaceType](jls-8.html#jls-UnannClassOrInterfaceType "UnannClassOrInterfaceType") `.` {[Annotation](jls-9.html#jls-Annotation "Annotation")} [Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\]

UnannInterfaceType:

[UnannClassType](jls-8.html#jls-UnannClassType "UnannClassType")

UnannTypeVariable:

[Identifier](jls-3.html#jls-Identifier "Identifier")

UnannArrayType:

[UnannPrimitiveType](jls-8.html#jls-UnannPrimitiveType "UnannPrimitiveType") [Dims](jls-4.html#jls-Dims "Dims")  
[UnannClassOrInterfaceType](jls-8.html#jls-UnannClassOrInterfaceType "UnannClassOrInterfaceType") [Dims](jls-4.html#jls-Dims "Dims")  
[UnannTypeVariable](jls-8.html#jls-UnannTypeVariable "UnannTypeVariable") [Dims](jls-4.html#jls-Dims "Dims")

The following production from [¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values") is shown here for convenience:

Dims:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]` {{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]`}

Each declarator in a _FieldDeclaration_ declares one field. The _Identifier_ in a declarator may be used in a name to refer to the field.

More than one field may be declared in a single _FieldDeclaration_ by using more than one declarator; the _FieldModifier_s and _UnannType_ apply to all the declarators in the declaration.

The _FieldModifier_ clause is described in [¬ß8.3.1](jls-8.html#jls-8.3.1 "8.3.1. Field Modifiers").

The declared type of a field is denoted by _UnannType_ if no bracket pairs appear in _UnannType_ and _VariableDeclaratorId_, and is specified by [¬ß10.2](jls-10.html#jls-10.2 "10.2. Array Variables") otherwise.

The scope and shadowing of a field declaration is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

It is a compile-time error for the body of a class declaration to declare two fields with the same name.

If the class declares a field with a certain name, then the declaration of that field is said to _hide_ any and all accessible declarations of fields with the same name in superclasses, and superinterfaces of the class.

In this respect, hiding of fields differs from hiding of methods ([¬ß8.4.8.3](jls-8.html#jls-8.4.8.3 "8.4.8.3. Requirements in Overriding and Hiding")), for there is no distinction drawn between `static` and non-`static` fields in field hiding whereas a distinction is drawn between `static` and non-`static` methods in method hiding.

A hidden field can be accessed by using a qualified name ([¬ß6.5.6.2](jls-6.html#jls-6.5.6.2 "6.5.6.2. Qualified Expression Names")) if it is `static`, or by using a field access expression that contains the keyword `super` ([¬ß15.11.2](jls-15.html#jls-15.11.2 "15.11.2. Accessing Superclass Members using super")) or a cast to a superclass type.

In this respect, hiding of fields is similar to hiding of methods.

If a field declaration hides the declaration of another field, the two fields need not have the same type.

A class inherits from its direct superclass and direct superinterfaces all the non-private fields of the superclass and superinterfaces that are both accessible to code in the class and not hidden by a declaration in the class.

A `private` field of a superclass might be accessible to a subclass - for example, if both classes are members of the same class. Nevertheless, a `private` field is never inherited by a subclass.

It is possible for a class to inherit more than one field with the same name. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the class to refer to any such field by its simple name will result in a compile-time error, because such a reference is ambiguous.

There might be several paths by which the same field declaration might be inherited from an interface. In such a situation, the field is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.

A value stored in a field of type `float` is always an element of the float value set ([¬ß4.2.3](jls-4.html#jls-4.2.3 "4.2.3. Floating-Point Types, Formats, and Values")); similarly, a value stored in a field of type `double` is always an element of the double value set. It is not permitted for a field of type `float` to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a field of type `double` to contain an element of the double-extended-exponent value set that is not also an element of the double value set.

**Example 8.3-1. Multiply Inherited Fields**

A class may inherit two or more fields with the same name, either from two interfaces or from its superclass and an interface. A compile-time error occurs on any attempt to refer to any ambiguously inherited field by its simple name. A qualified name or a field access expression that contains the keyword `super` ([¬ß15.11.2](jls-15.html#jls-15.11.2 "15.11.2. Accessing Superclass Members using super")) may be used to access such fields unambiguously. In the program:

interface Frob  { float v = 2.0f; }
class SuperTest { int   v = 3; }
class Test extends SuperTest implements Frob {
    public static void main(String\[\] args) {
        new Test().printV();
    }
    void printV() { System.out.println(v); }
}

the class `Test` inherits two fields named `v`, one from its superclass `SuperTest` and one from its superinterface `Frob`. This in itself is permitted, but a compile-time error occurs because of the use of the simple name `v` in method `printV`: it cannot be determined which `v` is intended.

The following variation uses the field access expression `super.v` to refer to the field named `v` declared in class `SuperTest` and uses the qualified name `Frob.v` to refer to the field named `v` declared in interface `Frob`:

interface Frob  { float v = 2.0f; }
class SuperTest { int   v = 3; }
class Test extends SuperTest implements Frob {
    public static void main(String\[\] args) {
        new Test().printV();
    }
    void printV() {
        System.out.println((super.v + Frob.v)/2);
    }
}

It compiles and prints:

2.5

Even if two distinct inherited fields have the same type, the same value, and are both `final`, any reference to either field by simple name is considered ambiguous and results in a compile-time error. In the program:

interface Color        { int RED=0, GREEN=1,  BLUE=2;  }
interface TrafficLight { int RED=0, YELLOW=1, GREEN=2; }
class Test implements Color, TrafficLight {
    public static void main(String\[\] args) {
        System.out.println(GREEN);  // compile-time error
        System.out.println(RED);    // compile-time error
    }
}

it is not astonishing that the reference to `GREEN` should be considered ambiguous, because class `Test` inherits two different declarations for `GREEN` with different values. The point of this example is that the reference to `RED` is also considered ambiguous, because two distinct declarations are inherited. The fact that the two fields named `RED` happen to have the same type and the same unchanging value does not affect this judgment.

  

**Example 8.3-2. Re-inheritance of Fields**

If the same field declaration is inherited from an interface by multiple paths, the field is considered to be inherited only once. It may be referred to by its simple name without ambiguity. For example, in the code:

interface Colorable {
    int RED = 0xff0000, GREEN = 0x00ff00, BLUE = 0x0000ff;
}
interface Paintable extends Colorable {
    int MATTE = 0, GLOSSY = 1;
}
class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {}
class PaintedPoint extends ColoredPoint implements Paintable {
    int p = RED;
}

the fields `RED`, `GREEN`, and `BLUE` are inherited by the class `PaintedPoint` both through its direct superclass `ColoredPoint` and through its direct superinterface `Paintable`. The simple names `RED`, `GREEN`, and `BLUE` may nevertheless be used without ambiguity within the class `PaintedPoint` to refer to the fields declared in interface `Colorable`.

  

### 8.3.1. Field Modifiers

FieldModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `public` `protected` `private`  
`static` `final` `transient` `volatile`

The rules for annotation modifiers on a field declaration are specified in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear") and [¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type").

It is a compile-time error if the same keyword appears more than once as a modifier for a field declaration.

If two or more (distinct) field modifiers appear in a field declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for _FieldModifier_.

#### 8.3.1.1. `static` Fields

If a field is declared `static`, there exists exactly one incarnation of the field, no matter how many instances (possibly zero) of the class may eventually be created. A `static` field, sometimes called a class variable, is incarnated when the class is initialized ([¬ß12.4](jls-12.html#jls-12.4 "12.4. Initialization of Classes and Interfaces")).

A field that is not declared `static` (sometimes called a non-`static` field) is called an _instance variable_. Whenever a new instance of a class is created ([¬ß12.5](jls-12.html#jls-12.5 "12.5. Creation of New Class Instances")), a new variable associated with that instance is created for every instance variable declared in that class or any of its superclasses.

**Example 8.3.1.1-1. `static` Fields**

class Point {
    int x, y, useCount;
    Point(int x, int y) { this.x = x; this.y = y; }
    static final Point origin = new Point(0, 0);
}
class Test {
    public static void main(String\[\] args) {
        Point p = new Point(1,1);
        Point q = new Point(2,2);
        p.x = 3;
        p.y = 3;
        p.useCount++;
        p.origin.useCount++;
        System.out.println("(" + q.x + "," + q.y + ")");
        System.out.println(q.useCount);
        System.out.println(q.origin == Point.origin);
        System.out.println(q.origin.useCount);
    }
}

This program prints:

(2,2)
0
true
1

showing that changing the fields `x`, `y`, and `useCount` of `p` does not affect the fields of `q`, because these fields are instance variables in distinct objects. In this example, the class variable `origin` of the class `Point` is referenced both using the class name as a qualifier, in `Point.origin`, and using variables of the class type in field access expressions ([¬ß15.11](jls-15.html#jls-15.11 "15.11. Field Access Expressions")), as in `p.origin` and `q.origin`. These two ways of accessing the `origin` class variable access the same object, evidenced by the fact that the value of the reference equality expression ([¬ß15.21.3](jls-15.html#jls-15.21.3 "15.21.3. Reference Equality Operators == and !=")):

q.origin==Point.origin

is true. Further evidence is that the incrementation:

p.origin.useCount++;

causes the value of `q.origin.useCount` to be `1`; this is so because `p.origin` and `q.origin` refer to the same variable.

  

**Example 8.3.1.1-2. Hiding of Class Variables**

class Point {
    static int x = 2;
}
class Test extends Point {
    static double x = 4.7;
    public static void main(String\[\] args) {
        new Test().printX();
    }
    void printX() {
        System.out.println(x + " " + super.x);
    }
}

This program produces the output:

4.7 2

because the declaration of `x` in class `Test` hides the definition of `x` in class `Point`, so class `Test` does not inherit the field `x` from its superclass `Point`. Within the declaration of class `Test`, the simple name `x` refers to the field declared within class `Test`. Code in class `Test` may refer to the field `x` of class `Point` as `super.x` (or, because `x` is `static`, as `Point.x`). If the declaration of `Test.x` is deleted:

class Point {
    static int x = 2;
}
class Test extends Point {
    public static void main(String\[\] args) {
        new Test().printX();
    }
    void printX() {
        System.out.println(x + " " + super.x);
    }
}

then the field `x` of class `Point` is no longer hidden within class `Test`; instead, the simple name `x` now refers to the field `Point.x`. Code in class `Test` may still refer to that same field as `super.x`. Therefore, the output from this variant program is:

2 2

  

**Example 8.3.1.1-3. Hiding of Instance Variables**

class Point {
    int x = 2;
}
class Test extends Point {
    double x = 4.7;
    void printBoth() {
        System.out.println(x + " " + super.x);
    }
    public static void main(String\[\] args) {
        Test sample = new Test();
        sample.printBoth();
        System.out.println(sample.x + " " + ((Point)sample).x);
    }
}

This program produces the output:

4.7 2
4.7 2

because the declaration of `x` in class `Test` hides the definition of `x` in class `Point`, so class `Test` does not inherit the field `x` from its superclass `Point`. It must be noted, however, that while the field `x` of class `Point` is not inherited by class `Test`, it is nevertheless _implemented_ by instances of class `Test`. In other words, every instance of class `Test` contains two fields, one of type `int` and one of type `double`. Both fields bear the name `x`, but within the declaration of class `Test`, the simple name `x` always refers to the field declared within class `Test`. Code in instance methods of class `Test` may refer to the instance variable `x` of class `Point` as `super.x`.

Code that uses a field access expression to access field `x` will access the field named `x` in the class indicated by the type of reference expression. Thus, the expression `sample.x` accesses a `double` value, the instance variable declared in class `Test`, because the type of the variable `sample` is `Test`, but the expression `((Point)sample).x` accesses an `int` value, the instance variable declared in class `Point`, because of the cast to type `Point`.

If the declaration of `x` is deleted from class `Test`, as in the program:

class Point {
    static int x = 2;
}
class Test extends Point {
    void printBoth() {
        System.out.println(x + " " + super.x);
    }
    public static void main(String\[\] args) {
        Test sample = new Test();
        sample.printBoth();
        System.out.println(sample.x + " " +	((Point)sample).x);
    }
}

then the field `x` of class `Point` is no longer hidden within class `Test`. Within instance methods in the declaration of class `Test`, the simple name `x` now refers to the field declared within class `Point`. Code in class `Test` may still refer to that same field as `super.x`. The expression `sample.x` still refers to the field `x` within type `Test`, but that field is now an inherited field, and so refers to the field `x` declared in class `Point`. The output from this variant program is:

2 2
2 2

  

#### 8.3.1.2. `final` Fields

A field can be declared `final` ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")). Both class and instance variables (`static` and non-`static` fields) may be declared `final`.

A blank `final` class variable must be definitely assigned by a static initializer of the class in which it is declared, or a compile-time error occurs ([¬ß8.7](jls-8.html#jls-8.7 "8.7. Static Initializers"), [¬ß16.8](jls-16.html#jls-16.8 "16.8. Definite Assignment and Static Initializers")).

A blank `final` instance variable must be definitely assigned at the end of every constructor of the class in which it is declared, or a compile-time error occurs ([¬ß8.8](jls-8.html#jls-8.8 "8.8. Constructor Declarations"), [¬ß16.9](jls-16.html#jls-16.9 "16.9. Definite Assignment, Constructors, and Instance Initializers")).

#### 8.3.1.3. `transient` Fields

Variables may be marked `transient` to indicate that they are not part of the persistent state of an object.

**Example 8.3.1.3-1. Persistence of `transient` Fields**

If an instance of the class `Point`:

class Point {
    int x, y;
    transient float rho, theta;
}

were saved to persistent storage by a system service, then only the fields `x` and `y` would be saved. This specification does not specify details of such services; see the specification of `java.io.Serializable` for an example of such a service.

  

#### 8.3.1.4. `volatile` Fields

The Java programming language allows threads to access shared variables ([¬ß17.1](jls-17.html#jls-17.1 "17.1. Synchronization")). As a rule, to ensure that shared variables are consistently and reliably updated, a thread should ensure that it has exclusive use of such variables by obtaining a lock that, conventionally, enforces mutual exclusion for those shared variables.

The Java programming language provides a second mechanism, `volatile` fields, that is more convenient than locking for some purposes.

A field may be declared `volatile`, in which case the Java Memory Model ensures that all threads see a consistent value for the variable ([¬ß17.4](jls-17.html#jls-17.4 "17.4. Memory Model")).

It is a compile-time error if a `final` variable is also declared `volatile`.

**Example 8.3.1.4-1. `volatile` Fields**

If, in the following example, one thread repeatedly calls the method `one` (but no more than `Integer.MAX_VALUE` times in all), and another thread repeatedly calls the method `two`:

class Test {
    static int i = 0, j = 0;
    static void one() { i++; j++; }
    static void two() {
        System.out.println("i=" + i + " j=" + j);
    }
}

then method `two` could occasionally print a value for `j` that is greater than the value of `i`, because the example includes no synchronization and, under the rules explained in [¬ß17.4](jls-17.html#jls-17.4 "17.4. Memory Model"), the shared values of `i` and `j` might be updated out of order.

One way to prevent this out-or-order behavior would be to declare methods `one` and `two` to be `synchronized` ([¬ß8.4.3.6](jls-8.html#jls-8.4.3.6 "8.4.3.6. synchronized Methods")):

class Test {
    static int i = 0, j = 0;
    static synchronized void one() { i++; j++; }
    static synchronized void two() {
        System.out.println("i=" + i + " j=" + j);
    }
}

This prevents method `one` and method `two` from being executed concurrently, and furthermore guarantees that the shared values of `i` and `j` are both updated before method `one` returns. Therefore method `two` never observes a value for `j` greater than that for `i`; indeed, it always observes the same value for `i` and `j`.

Another approach would be to declare `i` and `j` to be `volatile`:

class Test {
    static volatile int i = 0, j = 0;
    static void one() { i++; j++; }
    static void two() {
        System.out.println("i=" + i + " j=" + j);
    }
}

This allows method `one` and method `two` to be executed concurrently, but guarantees that accesses to the shared values for `i` and `j` occur exactly as many times, and in exactly the same order, as they appear to occur during execution of the program text by each thread. Therefore, the shared value for `j` is never greater than that for `i`, because each update to `i` must be reflected in the shared value for `i` before the update to `j` occurs. It is possible, however, that any given invocation of method `two` might observe a value for `j` that is much greater than the value observed for `i`, because method `one` might be executed many times between the moment when method `two` fetches the value of `i` and the moment when method two fetches the value of `j`.

See [¬ß17.4](jls-17.html#jls-17.4 "17.4. Memory Model") for more discussion and examples.

  

### 8.3.2. Field Initialization

If a declarator in a field declaration has a _variable initializer_, then the declarator has the semantics of an assignment ([¬ß15.26](jls-15.html#jls-15.26 "15.26. Assignment Operators")) to the declared variable.

If the declarator is for a class variable (that is, a `static` field), then the following rules apply to its initializer:

*   It is a compile-time error if a reference by simple name to any instance variable occurs in the initializer.
*   It is a compile-time error if the keyword `this` ([¬ß15.8.3](jls-15.html#jls-15.8.3 "15.8.3. this")) or the keyword `super` ([¬ß15.11.2](jls-15.html#jls-15.11.2 "15.11.2. Accessing Superclass Members using super"), [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")) occurs in the initializer.
*   At run time, the initializer is evaluated and the assignment performed exactly once, when the class is initialized ([¬ß12.4.2](jls-12.html#jls-12.4.2 "12.4.2. Detailed Initialization Procedure")).
    
    Note that `static` fields that are constant variables ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")) are initialized before other `static` fields ([¬ß12.4.2](jls-12.html#jls-12.4.2 "12.4.2. Detailed Initialization Procedure")). This also applies in interfaces ([¬ß9.3.1](jls-9.html#jls-9.3.1 "9.3.1. Initialization of Fields in Interfaces")). Such fields will never be observed to have their default initial values ([¬ß4.12.5](jls-4.html#jls-4.12.5 "4.12.5. Initial Values of Variables")), even by devious programs.
    

If the declarator is for an instance variable (that is, a field that is not `static`), then the following rules apply to its initializer:

*   The initializer may use the simple name of any class variable declared in or inherited by the class, even one whose declaration occurs textually after the initializer.
*   The initializer may refer to the current object `this` ([¬ß15.8.3](jls-15.html#jls-15.8.3 "15.8.3. this")) and may use the keyword `super` ([¬ß15.11.2](jls-15.html#jls-15.11.2 "15.11.2. Accessing Superclass Members using super"), [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")).
*   At run time, the initializer is evaluated and the assignment performed each time an instance of the class is created ([¬ß12.5](jls-12.html#jls-12.5 "12.5. Creation of New Class Instances")).
    

Exception checking for a variable initializer in a field declaration is specified in [¬ß11.2.3](jls-11.html#jls-11.2.3 "11.2.3. Exception Checking").

Variable initializers are also used in local variable declaration statements ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements")), where the initializer is evaluated and the assignment performed each time the local variable declaration statement is executed.

**Example 8.3.2-1. Field Initialization**

class Point {
    int x = 1, y = 5;
}
class Test {
    public static void main(String\[\] args) {
        Point p = new Point();
        System.out.println(p.x + ", " + p.y);
    }
}

This program produces the output:

1, 5

because the assignments to `x` and `y` occur whenever a new `Point` is created.

  

**Example 8.3.2-2. Forward Reference to a Class Variable**

class Test {
    float f = j;
    static int j = 1;
}

This program compiles without error; it initializes `j` to `1` when class `Test` is initialized, and initializes `f` to the current value of `j` every time an instance of class `Test` is created.

  

### 8.3.3. Forward References During Field Initialization

Use of class variables whose declarations appear textually after the use is sometimes restricted, even though these class variables are in scope ([¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration")). Specifically, it is a compile-time error if all of the following are true:

*   The declaration of a class variable in a class or interface C appears textually after a use of the class variable;
*   The use is a simple name in either a class variable initializer of C or a static initializer of C;
*   The use is not on the left hand side of an assignment;
*   C is the innermost class or interface enclosing the use.
    

Use of instance variables whose declarations appear textually after the use is sometimes restricted, even though these instance variables are in scope. Specifically, it is a compile-time error if all of the following are true:

*   The declaration of an instance variable in a class or interface C appears textually after a use of the instance variable;
*   The use is a simple name in either an instance variable initializer of C or an instance initializer of C;
*   The use is not on the left hand side of an assignment;
*   C is the innermost class or interface enclosing the use.
    

**Example 8.3.3-1. Restrictions on Field Initialization**

A compile-time error occurs for this program:

class Test1 {
    int i = j;  // compile-time error:
                // incorrect forward reference
    int j = 1;
}

whereas the following program compiles without error:

class Test2 {
    Test2() { k = 2; }
    int j = 1;
    int i = j;
    int k;
}

even though the constructor for `Test2` ([¬ß8.8](jls-8.html#jls-8.8 "8.8. Constructor Declarations")) refers to the field `k` that is declared three lines later.

The restrictions above are designed to catch, at compile time, circular or otherwise malformed initializations. Thus, both:

class Z {
    static int i = j + 2; 
    static int j = 4;
}

and:

class Z {
    static { i = j + 2; }
    static int i, j;
    static { j = 4; }
}

result in compile-time errors. Accesses by methods are not checked in this way, so:

class Z {
    static int peek() { return j; }
    static int i = peek();
    static int j = 1;
}
class Test {
    public static void main(String\[\] args) {
        System.out.println(Z.i);
    }
}

produces the output:

0

because the variable initializer for `i` uses the class method `peek` to access the value of the variable `j` before `j` has been initialized by its variable initializer, at which point it still has its default value ([¬ß4.12.5](jls-4.html#jls-4.12.5 "4.12.5. Initial Values of Variables")).

A more elaborate example is:

class UseBeforeDeclaration {
    static {
        x = 100;
          // ok - assignment
        int y = x + 1;
          // error - read before declaration
        int v = x = 3;
          // ok - x at left hand side of assignment
        int z = UseBeforeDeclaration.x \* 2;
          // ok - not accessed via simple name

        Object o = new Object() { 
            void foo() { x++; }
              // ok - occurs in a different class
            { x++; }
              // ok - occurs in a different class
        };
    }

    {
        j = 200;
          // ok - assignment
        j = j + 1;
          // error - right hand side reads before declaration
        int k = j = j + 1;
          // error - illegal forward reference to j
        int n = j = 300;
          // ok - j at left hand side of assignment
        int h = j++;
          // error - read before declaration
        int l = this.j \* 3;
          // ok - not accessed via simple name

        Object o = new Object() { 
            void foo(){ j++; }
              // ok - occurs in a different class
            { j = j + 1; }
              // ok - occurs in a different class
        };
    }

    int w = x = 3;
      // ok - x at left hand side of assignment
    int p = x;
      // ok - instance initializers may access static fields

    static int u =
        (new Object() { int bar() { return x; } }).bar();
	    // ok - occurs in a different class

    static int x;

    int m = j = 4;
      // ok - j at left hand side of assignment
    int o =
        (new Object() { int bar() { return j; } }).bar(); 
        // ok - occurs in a different class
    int j;
}8.4. Method Declarations
------------------------

A _method_ declares executable code that can be invoked, passing a fixed number of values as arguments.

MethodDeclaration:

{[MethodModifier](jls-8.html#jls-MethodModifier "MethodModifier")} [MethodHeader](jls-8.html#jls-MethodHeader "MethodHeader") [MethodBody](jls-8.html#jls-MethodBody "MethodBody")

MethodHeader:

[Result](jls-8.html#jls-Result "Result") [MethodDeclarator](jls-8.html#jls-MethodDeclarator "MethodDeclarator") \[[Throws](jls-8.html#jls-Throws "Throws")\]  
[TypeParameters](jls-8.html#jls-TypeParameters "TypeParameters") {[Annotation](jls-9.html#jls-Annotation "Annotation")} [Result](jls-8.html#jls-Result "Result") [MethodDeclarator](jls-8.html#jls-MethodDeclarator "MethodDeclarator") \[[Throws](jls-8.html#jls-Throws "Throws")\]

MethodDeclarator:

[Identifier](jls-3.html#jls-Identifier "Identifier") `(` \[[FormalParameterList](jls-8.html#jls-FormalParameterList "FormalParameterList")\] `)` \[[Dims](jls-4.html#jls-Dims "Dims")\]

The following production from [¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values") is shown here for convenience:

Dims:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]` {{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]`}

The _FormalParameterList_ is described in [¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"), the _MethodModifier_ clause in [¬ß8.4.3](jls-8.html#jls-8.4.3 "8.4.3. Method Modifiers"), the _TypeParameters_ clause in [¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods"), the _Result_ clause in [¬ß8.4.5](jls-8.html#jls-8.4.5 "8.4.5. Method Result"), the _Throws_ clause in [¬ß8.4.6](jls-8.html#jls-8.4.6 "8.4.6. Method Throws"), and the _MethodBody_ in [¬ß8.4.7](jls-8.html#jls-8.4.7 "8.4.7. Method Body").

The _Identifier_ in a _MethodDeclarator_ may be used in a name to refer to the method ([¬ß6.5.7.1](jls-6.html#jls-6.5.7.1 "6.5.7.1. Simple Method Names"), [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")).

It is a compile-time error for the body of a class to declare as members two methods with override-equivalent signatures ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")).

The scope and shadowing of a method declaration is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

The declaration of a method that returns an array is allowed to place some or all of the bracket pairs that denote the array type after the formal parameter list. This syntax is supported for compatibility with early versions of the Java programming language. It is very strongly recommended that this syntax is not used in new code.

### 8.4.1. Formal Parameters

The _formal parameters_ of a method or constructor, if any, are specified by a list of comma-separated parameter specifiers. Each parameter specifier consists of a type (optionally preceded by the `final` modifier and/or one or more annotations) and an identifier (optionally followed by brackets) that specifies the name of the parameter.

If a method or constructor has no formal parameters, only an empty pair of parentheses appears in the declaration of the method or constructor.

FormalParameterList:

[ReceiverParameter](jls-8.html#jls-ReceiverParameter "ReceiverParameter")  
[FormalParameters](jls-8.html#jls-FormalParameters "FormalParameters") `,` [LastFormalParameter](jls-8.html#jls-LastFormalParameter "LastFormalParameter")  
[LastFormalParameter](jls-8.html#jls-LastFormalParameter "LastFormalParameter")

FormalParameters:

[FormalParameter](jls-8.html#jls-FormalParameter "FormalParameter") {`,` [FormalParameter](jls-8.html#jls-FormalParameter "FormalParameter")}  
[ReceiverParameter](jls-8.html#jls-ReceiverParameter "ReceiverParameter") {`,` [FormalParameter](jls-8.html#jls-FormalParameter "FormalParameter")}

FormalParameter:

{[VariableModifier](jls-8.html#jls-VariableModifier "VariableModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId")

VariableModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `final`

ReceiverParameter:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} [UnannType](jls-8.html#jls-UnannType "UnannType") \[[Identifier](jls-3.html#jls-Identifier "Identifier") `.`\] `this`

LastFormalParameter:

{[VariableModifier](jls-8.html#jls-VariableModifier "VariableModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") {[Annotation](jls-9.html#jls-Annotation "Annotation")} `...` [VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId")  
[FormalParameter](jls-8.html#jls-FormalParameter "FormalParameter")

The following productions from [¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values") and [¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations") are shown here for convenience:

VariableDeclaratorId:

[Identifier](jls-3.html#jls-Identifier "Identifier") \[[Dims](jls-4.html#jls-Dims "Dims")\]

Dims:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]` {{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]`}

The last formal parameter of a method or constructor is special: it may be a _variable arity parameter_, indicated by an ellipsis following the type.

Note that the ellipsis (`...`) is a token unto itself ([¬ß3.11](jls-3.html#jls-3.11 "3.11. Separators")). It is possible to put whitespace between it and the type, but this is discouraged as a matter of style.

If the last formal parameter is a variable arity parameter, the method is a _variable arity method_. Otherwise, it is a _fixed arity method_.

The _receiver parameter_ is an optional syntactic device for an instance method or an inner class's constructor. For an instance method, the receiver parameter represents the object for which the method is invoked. For an inner class's constructor, the receiver parameter represents the immediately enclosing instance of the newly constructed object. Either way, the receiver parameter exists solely to allow the type of the represented object to be denoted in source code, so that the type may be annotated. The receiver parameter is not a formal parameter; more precisely, it is not a declaration of any kind of variable ([¬ß4.12.3](jls-4.html#jls-4.12.3 "4.12.3. Kinds of Variables")), it is never bound to any value passed as an argument in a method invocation expression or qualified class instance creation expression, and it has no effect whatsoever at run time.

The rules for annotation modifiers on a formal parameter declaration and on a receiver parameter are specified in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear") and [¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type").

It is a compile-time error if `final` appears more than once as a modifier for a formal parameter declaration.

It is a compile-time error to use mixed array notation ([¬ß10.2](jls-10.html#jls-10.2 "10.2. Array Variables")) for a variable arity parameter.

The scope and shadowing of a formal parameter is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

It is a compile-time error for a method or constructor to declare two formal parameters with the same name. (That is, their declarations mention the same _Identifier_.)

It is a compile-time error if a formal parameter that is declared `final` is assigned to within the body of the method or constructor.

A receiver parameter may appear only in the _FormalParameterList_ of an instance method or an inner class's constructor; otherwise, a compile-time error occurs.

Where a receiver parameter is allowed, its type and name are specified as follows:

*   In an instance method, the type of the receiver parameter must be the class or interface in which the method is declared, and the name of the receiver parameter must be `this`; otherwise, a compile-time error occurs.
*   In an inner class's constructor, the type of the receiver parameter must be the class or interface which is the immediately enclosing type declaration of the inner class, and the name of the receiver parameter must be _Identifier_ `.` `this` where _Identifier_ is the simple name of the class or interface which is the immediately enclosing type declaration of the inner class; otherwise, a compile-time error occurs.
    

The declared type of a formal parameter depends on whether it is a variable arity parameter:

*   If the formal parameter is not a variable arity parameter, then the declared type is denoted by _UnannType_ if no bracket pairs appear in _UnannType_ and _VariableDeclaratorId_, and specified by [¬ß10.2](jls-10.html#jls-10.2 "10.2. Array Variables") otherwise.
*   If the formal parameter is a variable arity parameter, then the declared type is specified by [¬ß10.2](jls-10.html#jls-10.2 "10.2. Array Variables"). (Note that "mixed notation" is not permitted for variable arity parameters.)
    

If the declared type of a variable arity parameter has a non-reifiable element type ([¬ß4.7](jls-4.html#jls-4.7 "4.7. Reifiable Types")), then a compile-time unchecked warning occurs for the declaration of the variable arity method, unless the method is annotated with `@SafeVarargs` ([¬ß9.6.4.7](jls-9.html#jls-9.6.4.7 "9.6.4.7. @SafeVarargs")) or the unchecked warning is suppressed by `@SuppressWarnings` ([¬ß9.6.4.5](jls-9.html#jls-9.6.4.5 "9.6.4.5. @SuppressWarnings")).

When the method or constructor is invoked ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")), the values of the actual argument expressions initialize newly created parameter variables, each of the declared type, before execution of the body of the method or constructor. The _Identifier_ that appears in the _DeclaratorId_ may be used as a simple name in the body of the method or constructor to refer to the formal parameter.

Invocations of a variable arity method may contain more actual argument expressions than formal parameters. All the actual argument expressions that do not correspond to the formal parameters preceding the variable arity parameter will be evaluated and the results stored into an array that will be passed to the method invocation ([¬ß15.12.4.2](jls-15.html#jls-15.12.4.2 "15.12.4.2. Evaluate Arguments")).

A method or constructor parameter of type `float` always contains an element of the float value set ([¬ß4.2.3](jls-4.html#jls-4.2.3 "4.2.3. Floating-Point Types, Formats, and Values")); similarly, a method or constructor parameter of type `double` always contains an element of the double value set. It is not permitted for a method or constructor parameter of type `float` to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a method parameter of type `double` to contain an element of the double-extended-exponent value set that is not also an element of the double value set.

Where an actual argument expression corresponding to a parameter variable is not FP-strict ([¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions")), evaluation of that actual argument expression is permitted to use intermediate values drawn from the appropriate extended-exponent value sets. Prior to being stored in the parameter variable, the result of such an expression is mapped to the nearest value in the corresponding standard value set by being subjected to invocation conversion ([¬ß5.3](jls-5.html#jls-5.3 "5.3. Invocation Contexts")).

Here are some examples of receiver parameters in instance methods and inner classes' constructors:

class Test {
    Test(/\* ?? ?? \*/) {}
      // No receiver parameter is permitted in the constructor of
      // a top level class, as there is no conceivable type or name.

    void m(Test this) {}
      // OK: receiver parameter in an instance method

    static void n(Test this) {}
      // Illegal: receiver parameter in a static method                         

    class A {
        A(Test Test.this) {}
          // OK: the receiver parameter represents the instance
          // of Test which immediately encloses the instance
          // of A being constructed.

        void m(A this) {}
          // OK: the receiver parameter represents the instance 
          // of A for which A.m() is invoked.

        class B {
            B(Test.A A.this) {}
              // OK: the receiver parameter represents the instance 
              // of A which immediately encloses the instance of B 
              // being constructed.

            void m(Test.A.B this) {}
              // OK: the receiver parameter represents the instance 
              // of B for which B.m() is invoked.
        }
    }
}

`B`'s constructor and instance method show that the type of the receiver parameter may be denoted with a qualified _TypeName_ like any other type; but that the name of the receiver parameter in an inner class's constructor must use the simple name of the enclosing class.

### 8.4.2. Method Signature

Two methods or constructors, `M` and `N`, have the _same signature_ if they have the same name, the same type parameters (if any) ([¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods")), and, after adapting the formal parameter types of `N` to the the type parameters of `M`, the same formal parameter types.

The signature of a method `m1` is a _subsignature_ of the signature of a method `m2` if either:

*   `m2` has the same signature as `m1`, or
*   the signature of `m1` is the same as the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of the signature of `m2`.
    

Two method signatures `m1` and `m2` are _override-equivalent_ iff either `m1` is a subsignature of `m2` or `m2` is a subsignature of `m1`.

It is a compile-time error to declare two methods with override-equivalent signatures in a class.

**Example 8.4.2-1. Override-Equivalent Signatures**

class Point {
    int x, y;
    abstract void move(int dx, int dy);
    void move(int dx, int dy) { x += dx; y += dy; }
}

This program causes a compile-time error because it declares two `move` methods with the same (and hence, override-equivalent) signature. This is an error even though one of the declarations is `abstract`.

  

The notion of subsignature is designed to express a relationship between two methods whose signatures are not identical, but in which one may override the other. Specifically, it allows a method whose signature does not use generic types to override any generified version of that method. This is important so that library designers may freely generify methods independently of clients that define subclasses or subinterfaces of the library.

Consider the example:

class CollectionConverter {
    List toList(Collection c) {...}
}
class Overrider extends CollectionConverter {
    List toList(Collection c) {...}
}

Now, assume this code was written before the introduction of generics, and now the author of class `CollectionConverter` decides to generify the code, thus:

class CollectionConverter {
    <T> List<T> toList(Collection<T> c) {...}
}

Without special dispensation, `Overrider.toList` would no longer override `CollectionConverter.toList`. Instead, the code would be illegal. This would significantly inhibit the use of generics, since library writers would hesitate to migrate existing code.

### 8.4.3. Method Modifiers

MethodModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `public` `protected` `private`  
`abstract` `static` `final` `synchronized` `native` `strictfp`

The rules for annotation modifiers on a method declaration are specified in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear") and [¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type").

It is a compile-time error if the same keyword appears more than once as a modifier for a method declaration.

It is a compile-time error if a method declaration that contains the keyword `abstract` also contains any one of the keywords `private`, `static`, `final`, `native`, `strictfp`, or `synchronized`.

It is a compile-time error if a method declaration that contains the keyword `native` also contains `strictfp`.

If two or more (distinct) method modifiers appear in a method declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for _MethodModifier_.

#### 8.4.3.1. `abstract` Methods

An `abstract` method declaration introduces the method as a member, providing its signature ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")), result ([¬ß8.4.5](jls-8.html#jls-8.4.5 "8.4.5. Method Result")), and `throws` clause if any ([¬ß8.4.6](jls-8.html#jls-8.4.6 "8.4.6. Method Throws")), but does not provide an implementation ([¬ß8.4.7](jls-8.html#jls-8.4.7 "8.4.7. Method Body")). A method that is not `abstract` may be referred to as a _concrete_ method.

The declaration of an `abstract` method `m` must appear directly within an `abstract` class (call it A) unless it occurs within an enum declaration ([¬ß8.9](jls-8.html#jls-8.9 "8.9. Enum Types")); otherwise a compile-time error occurs.

Every subclass of A that is not `abstract` ([¬ß8.1.1.1](jls-8.html#jls-8.1.1.1 "8.1.1.1. abstract Classes")) must provide an implementation for `m`, or a compile-time error occurs.

An `abstract` class can override an `abstract` method by providing another `abstract` method declaration.

This can provide a place to put a documentation comment, to refine the return type, or to declare that the set of checked exceptions that can be thrown by that method, when it is implemented by its subclasses, is to be more limited.

An instance method that is not `abstract` can be overridden by an `abstract` method.

**Example 8.4.3.1-1. Abstract/Abstract Method Overriding**

class BufferEmpty extends Exception {
    BufferEmpty() { super(); }
    BufferEmpty(String s) { super(s); }
}
class BufferError extends Exception {
    BufferError() { super(); }
    BufferError(String s) { super(s); }
}
interface Buffer {
    char get() throws BufferEmpty, BufferError;
}
abstract class InfiniteBuffer implements Buffer {
    public abstract char get() throws BufferError;
}

The overriding declaration of method `get` in class `InfiniteBuffer` states that method `get` in any subclass of `InfiniteBuffer` never throws a `BufferEmpty` exception, putatively because it generates the data in the buffer, and thus can never run out of data.

  

**Example 8.4.3.1-2. Abstract/Non-Abstract Overriding**

We can declare an `abstract` class `Point` that requires its subclasses to implement `toString` if they are to be complete, instantiable classes:

abstract class Point {
    int x, y;
    public abstract String toString();
}

This `abstract` declaration of `toString` overrides the non-`abstract` `toString` method of class `Object`. (Class `Object` is the implicit direct superclass of class `Point`.) Adding the code:

class ColoredPoint extends Point {
    int color;
    public String toString() {
        return super.toString() + ": color " + color;  // error
    }
}

results in a compile-time error because the invocation `super.toString()` refers to method `toString` in class `Point`, which is `abstract` and therefore cannot be invoked. Method `toString` of class `Object` can be made available to class `ColoredPoint` only if class `Point` explicitly makes it available through some other method, as in:

abstract class Point {
    int x, y;
    public abstract String toString();
    protected String objString() { return super.toString(); }
}
class ColoredPoint extends Point {
    int color;
    public String toString() {
        return objString() + ": color " + color;  // correct
    }
}

  

#### 8.4.3.2. `static` Methods

A method that is declared `static` is called a _class method_.

It is a compile-time error to use the name of a type parameter of any surrounding declaration in the header or body of a class method.

A class method is always invoked without reference to a particular object. It is a compile-time error to attempt to reference the current object using the keyword `this` ([¬ß15.8.3](jls-15.html#jls-15.8.3 "15.8.3. this")) or the keyword `super` ([¬ß15.11.2](jls-15.html#jls-15.11.2 "15.11.2. Accessing Superclass Members using super")).

A method that is not declared `static` is called an _instance method_, and sometimes called a non-`static` method.

An instance method is always invoked with respect to an object, which becomes the current object to which the keywords `this` and `super` refer during execution of the method body.

#### 8.4.3.3. `final` Methods

A method can be declared `final` to prevent subclasses from overriding or hiding it.

It is a compile-time error to attempt to override or hide a `final` method.

A `private` method and all methods declared immediately within a `final` class ([¬ß8.1.1.2](jls-8.html#jls-8.1.1.2 "8.1.1.2. final Classes")) behave as if they are `final`, since it is impossible to override them.

At run time, a machine-code generator or optimizer can "inline" the body of a `final` method, replacing an invocation of the method with the code in its body. The inlining process must preserve the semantics of the method invocation. In particular, if the target of an instance method invocation is `null`, then a `NullPointerException` must be thrown even if the method is inlined. A Java compiler must ensure that the exception will be thrown at the correct point, so that the actual arguments to the method will be seen to have been evaluated in the correct order prior to the method invocation.

Consider the example:

final class Point {
    int x, y;
    void move(int dx, int dy) { x += dx; y += dy; }
}
class Test {
    public static void main(String\[\] args) {
        Point\[\] p = new Point\[100\];
        for (int i = 0; i < p.length; i++) {
            p\[i\] = new Point();
            p\[i\].move(i, p.length-1-i);
        }
    }
}

Inlining the method `move` of class `Point` in method `main` would transform the `for` loop to the form:

    for (int i = 0; i < p.length; i++) {
        p\[i\] = new Point();
        Point pi = p\[i\];
        int j = p.length-1-i;
        pi.x += i;
        pi.y += j;
    }

The loop might then be subject to further optimizations.

Such inlining cannot be done at compile time unless it can be guaranteed that `Test` and `Point` will always be recompiled together, so that whenever `Point` - and specifically its `move` method - changes, the code for `Test.main` will also be updated.

#### 8.4.3.4. `native` Methods

A method that is `native` is implemented in platform-dependent code, typically written in another programming language such as C. The body of a `native` method is given as a semicolon only, indicating that the implementation is omitted, instead of a block ([¬ß8.4.7](jls-8.html#jls-8.4.7 "8.4.7. Method Body")).

For example, the class `RandomAccessFile` of the package `java.io` might declare the following `native` methods:

package java.io;
public class RandomAccessFile
    implements DataOutput, DataInput {
    . . .
    public native void open(String name, boolean writeable)
        throws IOException;
    public native int readBytes(byte\[\] b, int off, int len)
        throws IOException;
    public native void writeBytes(byte\[\] b, int off, int len)
        throws IOException;
    public native long getFilePointer() throws IOException;
    public native void seek(long pos) throws IOException;
    public native long length() throws IOException;
    public native void close() throws IOException;
}

#### 8.4.3.5. `strictfp` Methods

The effect of the `strictfp` modifier is to make all `float` or `double` expressions within the method body be explicitly FP-strict ([¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions")).

#### 8.4.3.6. `synchronized` Methods

A `synchronized` method acquires a monitor ([¬ß17.1](jls-17.html#jls-17.1 "17.1. Synchronization")) before it executes.

For a class (`static`) method, the monitor associated with the `Class` object for the method's class is used.

For an instance method, the monitor associated with `this` (the object for which the method was invoked) is used.

**Example 8.4.3.6-1. `synchronized` Monitors**

These are the same monitors that can be used by the `synchronized` statement ([¬ß14.19](jls-14.html#jls-14.19 "14.19. The synchronized Statement")).

Thus, the code:

class Test {
    int count;
    synchronized void bump() {
        count++;
    }
    static int classCount;
    static synchronized void classBump() {
        classCount++;
    }
}

has exactly the same effect as:

class BumpTest {
    int count;
    void bump() {
        synchronized (this) { count++; }
    }
    static int classCount;
    static void classBump() {
        try {
            synchronized (Class.forName("BumpTest")) {
                classCount++;
            }
        } catch (ClassNotFoundException e) {}
    }
}

  

**Example 8.4.3.6-2. `synchronized` Methods**

public class Box {
    private Object boxContents;
    public synchronized Object get() {
        Object contents = boxContents;
        boxContents = null;
        return contents;
    }
    public synchronized boolean put(Object contents) {
        if (boxContents != null) return false;
        boxContents = contents;
        return true;
    }
}

This program defines a class which is designed for concurrent use. Each instance of the class `Box` has an instance variable `boxContents` that can hold a reference to any object. You can put an object in a `Box` by invoking `put`, which returns `false` if the box is already full. You can get something out of a `Box` by invoking `get`, which returns a null reference if the box is empty.

If `put` and `get` were not `synchronized`, and two threads were executing methods for the same instance of `Box` at the same time, then the code could misbehave. It might, for example, lose track of an object because two invocations to put occurred at the same time.

  

### 8.4.4. Generic Methods

A method is _generic_ if it declares one or more type variables ([¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables")).

These type variables are known as the _type parameters_ of the method. The form of the type parameter section of a generic method is identical to the type parameter section of a generic class ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters")).

A generic method declaration defines a set of methods, one for each possible invocation of the type parameter section by type arguments. Type arguments may not need to be provided explicitly when a generic method is invoked, as they can often be inferred ([¬ß18 (_Type Inference_)](jls-18.html "Chapter 18. Type Inference")).

The scope and shadowing of a method's type parameter is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration").

Two methods or constructors `M` and `N` have the _same type parameters_ if both of the following are true:

*   `M` and `N` have same number of type parameters (possibly zero).
*   Where A1, ..., An are the type parameters of `M` and B1, ..., Bn are the type parameters of `N`, let _Œ∏\=\[B1:=A1, ..., Bn:=An\]_. Then, for all _i_ (1 ‚â§ _i_ ‚â§ _n_), the bound of Ai is the same type as Œ∏ applied to the bound of Bi.
    

Where two methods or constructors `M` and `N` have the same type parameters, a type mentioned in `N` can be _adapted to the type parameters_ of `M` by applying Œ∏, as defined above, to the type.

### 8.4.5. Method Result

The _result_ of a method declaration either declares the type of value that the method returns (the _return type_), or uses the keyword `void` to indicate that the method does not return a value.

Result:

[UnannType](jls-8.html#jls-UnannType "UnannType")  
`void`

If the result is not `void`, then the return type of a method is denoted by _UnannType_ if no bracket pairs appear after the formal parameter list, and is specified byclass="xref" href="jls-10.html#jls-10.2" title="10.2. Array Variables">¬ß10.2 otherwise.

Return types may vary among methods that override each other if the return types are reference types. The notion of return-type-substitutability supports _covariant returns_, that is, the specialization of the return type to a subtype.

A method declaration `d1` with return type R1 is _return-type-substitutable_ for another method `d2` with return type R2 iff any of the following is true:

*   If R1 is `void` then R2 is `void`.
*   If R1 is a primitive type then R2 is identical to R1.
*   If R1 is a reference type then one of the following is true:
    
    *   R1, adapted to the type parameters of `d2` ([¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods")), is a subtype of R2.
        
    *   R1 can be converted to a subtype of R2 by unchecked conversion ([¬ß5.1.9](jls-5.html#jls-5.1.9 "5.1.9. Unchecked Conversion")).
        
    *   `d1` does not have the same signature as `d2` ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")), and R1 = |R2|.
        
    

An unchecked conversion is allowed in the definition, despite being unsound, as a special allowance to allow smooth migration from non-generic to generic code. If an unchecked conversion is used to determine that R1 is return-type-substitutable for R2, then R1 is necessarily not a subtype of R2 and the rules for overriding ([¬ß8.4.8.3](jls-8.html#jls-8.4.8.3 "8.4.8.3. Requirements in Overriding and Hiding"), [¬ß9.4.1](jls-9.html#jls-9.4.1 "9.4.1. Inheritance and Overriding")) will require a compile-time unchecked warning.

### 8.4.6. Method Throws

A `throws` clause is used to declare any checked exception classes ([¬ß11.1.1](jls-11.html#jls-11.1.1 "11.1.1. The Kinds of Exceptions")) that the statements in a method or constructor body can throw ([¬ß11.2.2](jls-11.html#jls-11.2.2 "11.2.2. Exception Analysis of Statements")).

Throws:

`throws` [ExceptionTypeList](jls-8.html#jls-ExceptionTypeList "ExceptionTypeList")

ExceptionTypeList:

[ExceptionType](jls-8.html#jls-ExceptionType "ExceptionType") {`,` [ExceptionType](jls-8.html#jls-ExceptionType "ExceptionType")}

ExceptionType:

[ClassType](jls-4.html#jls-ClassType "ClassType")  
[TypeVariable](jls-4.html#jls-TypeVariable "TypeVariable")

It is a compile-time error if an _ExceptionType_ mentioned in a `throws` clause is not a subtype ([¬ß4.10](jls-4.html#jls-4.10 "4.10. Subtyping")) of `Throwable`.

Type variables are allowed in a `throws` clause even though they are not allowed in a `catch` clause ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")).

It is permitted but not required to mention unchecked exception classes ([¬ß11.1.1](jls-11.html#jls-11.1.1 "11.1.1. The Kinds of Exceptions")) in a `throws` clause.

The relationship between a `throws` clause and the exception checking for a method or constructor body is specified in [¬ß11.2.3](jls-11.html#jls-11.2.3 "11.2.3. Exception Checking").

Essentially, for each checked exception that can result from execution of the body of a method or constructor, a compile-time error occurs unless its exception type or a supertype of its exception type is mentioned in a `throws` clause in the declaration of the method or constructor.

The requirement to declare checked exceptions allows a Java compiler to ensure that code for handling such error conditions has been included. Methods or constructors that fail to handle exceptional conditions thrown as checked exceptions in their bodies will normally cause compile-time errors if they lack proper exception types in their `throws` clauses. The Java programming language thus encourages a programming style where rare and otherwise truly exceptional conditions are documented in this way.

The relationship between the `throws` clause of a method and the `throws` clauses of overridden or hidden methods is specified in [¬ß8.4.8.3](jls-8.html#jls-8.4.8.3 "8.4.8.3. Requirements in Overriding and Hiding").

**Example 8.4.6-1. Type Variables as Thrown Exception Types**

import java.io.FileNotFoundException;
interface PrivilegedExceptionAction<E extends Exception> { 
    void run() throws E;
} 
class AccessController {
    public static <E extends Exception> 
    Object doPrivileged(PrivilegedExceptionAction<E> action) throws E {
        action.run();
        return "success";
    }
}
class Test {
    public static void main(String\[\] args) {
        try {
            AccessController.doPrivileged(
              new PrivilegedExceptionAction<FileNotFoundException>() {
                  public void run() throws FileNotFoundException {
                      // ... delete a file ...
                  } 
              }); 
        } catch (FileNotFoundException f) { /\* Do something \*/ }
    }
}

  

### 8.4.7. Method Body

A _method body_ is either a block of code that implements the method or simply a semicolon, indicating the lack of an implementation.

MethodBody:

[Block](jls-14.html#jls-Block "Block")  
`;`

The body of a method must be a semicolon if the method is `abstract` or `native` ([¬ß8.4.3.1](jls-8.html#jls-8.4.3.1 "8.4.3.1. abstract Methods"), [¬ß8.4.3.4](jls-8.html#jls-8.4.3.4 "8.4.3.4. native Methods")). More precisely:

*   It is a compile-time error if a method declaration is either `abstract` or `native` and has a block for its body.
*   It is a compile-time error if a method declaration is neither `abstract` nor `native` and has a semicolon for its body.
    

If an implementation is to be provided for a method declared `void`, but the implementation requires no executable code, the method body should be written as a block that contains no statements: "`{ }`".

The rules for `return` statements in a method body are specified in [¬ß14.17](jls-14.html#jls-14.17 "14.17. The return Statement").

If a method is declared to have a return type ([¬ß8.4.5](jls-8.html#jls-8.4.5 "8.4.5. Method Result")), then a compile-time error occurs if the body of the method can complete normally ([¬ß14.1](jls-14.html#jls-14.1 "14.1. Normal and Abrupt Completion of Statements")).

In other words, a method with a return type must return only by using a `return` statement that provides a value return; the method is not allowed to "drop off the end of its body". See [¬ß14.17](jls-14.html#jls-14.17 "14.17. The return Statement") for the precise rules about `return` statements in a method body.

It is possible for a method to have a return type and yet contain no `return` statements. Here is one example:

class DizzyDean {
    int pitch() { throw new RuntimeException("90 mph?!"); }
}

### 8.4.8. Inheritance, Overriding, and Hiding

A class C _inherits_ from its direct superclass all concrete methods `m` (both `static` and instance) of the superclass for which all of the following are true:

*   `m` is a member of the direct superclass of C.
*   `m` is `public`, `protected`, or declared with package access in the same package as C.
*   No method declared in C has a signature that is a subsignature ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")) of the signature of `m`.
    

A class C _inherits_ from its direct superclass and direct superinterfaces all `abstract` and default ([¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations")) methods `m` for which all of the following are true:

*   `m` is a member of the direct superclass or a direct superinterface, D, of C.
*   `m` is `public`, `protected`, or declared with package access in the same package as C.
*   No method declared in C has a signature that is a subsignature ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")) of the signature of `m`.
*   No concrete method inherited by C from its direct superclass has a signature that is a subsignature of the signature of `m`.
*   There exists no method `m`' that is a member of the direct superclass or a direct superinterface, D', of C (`m` distinct from `m`', D distinct from D'), such that `m`' from D' overrides the declaration of the method `m`.
    

A class does not inherit `static` methods from its superinterfaces.

Note that it is possible for an inherited concrete method to prevent the inheritance of an `abstract` or default method. (Later we will assert that the concrete method overrides the `abstract` or default method "from C".) Also, it is possible for one supertype method to prevent the inheritance of another supertype method if the former "already" overrides the latter - this is the same as the rule for interfaces ([¬ß9.4.1](jls-9.html#jls-9.4.1 "9.4.1. Inheritance and Overriding")), and prevents conflicts in which multiple default methods are inherited and one implementation is clearly meant to supersede the other.

Note that methods are overridden or hidden on a signature-by-signature basis. If, for example, a class declares two `public` methods with the same name ([¬ß8.4.9](jls-8.html#jls-8.4.9 "8.4.9. Overloading")), and a subclass overrides one of them, the subclass still inherits the other method.

#### 8.4.8.1. Overriding (by Instance Methods)

An instance method `mC` declared in or inherited by class C, _overrides from C_ another method `mA` declared in class A, iff all of the following are true:

*   A is a superclass of C.
*   C does not inherit `mA`.
*   The signature of `mC` is a subsignature ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")) of the signature of `mA`.
*   One of the following is true:
    
    *   `mA` is `public`.
        
    *   `mA` is `protected`.
        
    *   `mA` is declared with package access in the same package as C, and either C declares `mC` or `mA` is a member of the direct superclass of C.
        
    *   `mA` is declared with package access and `mC` overrides `mA` from some superclass of C.
        
    *   `mA` is declared with package access and `mC` overrides a method `m'` from C (`m'` distinct from `mC` and `mA`), such that `m'` overrides `mA` from some superclass of C.
        
    

If a non-`abstract` method `mC` overrides an `abstract` method `mA` from a class C, then `mC` is said to _implement_ `mA` _from C_.

An instance method `mC` declared in or inherited by class C, _overrides from C_ another method `mI` declared in an interface I, iff all of the following are true:

*   I is a superinterface of C.
*   `mI` is an `abstract` or default method.
*   The signature of `mC` is a subsignature ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")) of the signature of `mI`.
    

The signature of an overriding method may differ from the overridden one if a formal parameter in one of the methods has a raw type, while the corresponding parameter in the other has a parameterized type. This accommodates migration of pre-existing code to take advantage of generics.

The notion of overriding includes methods that override another from some subclass of their declaring class. This can happen in two ways:

*   A concrete method in a generic superclass can, under certain parameterizations, have the same signature as an abstract method in that class. In this case, the concrete method is inherited and the `abstract` method is not (as described above). The inherited method should then be considered to override its abstract peer _from C_. (This scenario is complicated by package access: if C is in a different package, then `mA` would not have been inherited anyway, and should not be considered overridden.)
*   A method inherited from a class can override a superinterface method. (Happily, package access is not a concern here.)
    

It is a compile-time error if an instance method overrides a `static` method.

In this respect, overriding of methods differs from hiding of fields ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations")), for it is permissible for an instance variable to hide a `static` variable.

An overridden method can be accessed by using a method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")) that contains the keyword `super`. A qualified name or a cast to a superclass type is not effective in attempting to access an overridden method.

In this respect, overriding of methods differs from hiding of fields.

The presence or absence of the `strictfp` modifier has absolutely no effect on the rules for overriding methods and implementing abstract methods. For example, it is permitted for a method that is not FP-strict to override an FP-strict method and it is permitted for an FP-strict method to override a method that is not FP-strict.

**Example 8.4.8.1-1. Overriding**

class Point {
    int x = 0, y = 0;
    void move(int dx, int dy) { x += dx; y += dy; }
}
class SlowPoint extends Point {
    int xLimit, yLimit;
    void move(int dx, int dy) {
        super.move(limit(dx, xLimit), limit(dy, yLimit));
    }
    static int limit(int d, int limit) {
        return d > limit ? limit : d < -limit ? -limit : d;
    }
}

Here, the class `SlowPoint` overrides the declarations of method `move` of class `Point` with its own `move` method, which limits the distance that the point can move on each invocation of the method. When the `move` method is invoked for an instance of class `SlowPoint`, the overriding definition in class `SlowPoint` will always be called, even if the reference to the `SlowPoint` object is taken from a variable whose type is `Point`.

  

**Example 8.4.8.1-2. Overriding**

Overriding makes it easy for subclasses to extend the behavior of an existing class, as shown in this example:

import java.io.OutputStream;
import java.io.IOException;

class BufferOutput {
    private OutputStream o;
    BufferOutput(OutputStream o) { this.o = o; }
    protected byte\[\] buf = new byte\[512\];
    protected int pos = 0;
    public void putchar(char c) throws IOException {
        if (pos == buf.length) flush();
        buf\[pos++\] = (byte)c;
    }
    public void putstr(String s) throws IOException {
        for (int i = 0; i < s.length(); i++)
            putchar(s.charAt(i));
    }
    public void flush() throws IOException {
        o.write(buf, 0, pos);
        pos = 0;
    }
}
class LineBufferOutput extends BufferOutput {
    LineBufferOutput(OutputStream o) { super(o); }
    public void putchar(char c) throws IOException {
        super.putchar(c);
        if (c == '\\n') flush();
    }
}
class Test {
    public static void main(String\[\] args) throws IOException {
        LineBufferOutput lbo = new LineBufferOutput(System.out);
        lbo.putstr("lbo\\nlbo");
        System.out.print("print\\n");
        lbo.putstr("\\n");
    }
}

This program produces the output:

lbo
print
lbo

The class `BufferOutput` implements a very simple buffered version of an `OutputStream`, flushing the output when the buffer is full or `flush` is invoked. The subclass `LineBufferOutput` declares only a constructor and a single method `putchar`, which overrides the method `putchar` of `BufferOutput`. It inherits the methods `putstr` and `flush` from class `BufferOutput`.

In the `putchar` method of a `LineBufferOutput` object, if the character argument is a newline, then it invokes the `flush` method. The critical point about overriding in this example is that the method `putstr`, which is declared in class `BufferOutput`, invokes the `putchar` method defined by the current object `this`, which is not necessarily the `putchar` method declared in class `BufferOutput`.

Thus, when `putstr` is invoked in `main` using the `LineBufferOutput` object `lbo`, the invocation of `putchar` in the body of the `putstr` method is an invocation of the `putchar` of the object `lbo`, the overriding declaration of `putchar` that checks for a newline. This allows a subclass of `BufferOutput` to change the behavior of the `putstr` method without redefining it.

Documentation for a class such as `BufferOutput`, which is designed to be extended, should clearly indicate what is the contract between the class and its subclasses, and should clearly indicate that subclasses may override the `putchar` method in this way. The implementor of the `BufferOutput` class would not, therefore, want to change the implementation of `putstr` in a future implementation of `BufferOutput` not to use the method `putchar`, because this would break the pre-existing contract with subclasses. See the discussion of binary compatibility in [¬ß13 (_Binary Compatibility_)](jls-13.html "Chapter 13. Binary Compatibility"), especially [¬ß13.2](jls-13.html#jls-13.2 "13.2. What Binary Compatibility Is and Is Not").

  

#### 8.4.8.2. Hiding (by Class Methods)

If a class C declares or inherits a `static` method `m`, then `m` is said to _hide_ any method `m'`, where the signature of `m` is a subsignature ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")) of the signature of `m'`, in the superclasses and superinterfaces of C that would otherwise be accessible to code in C.

It is a compile-time error if a `static` method hides an instance method.

In this respect, hiding of methods differs from hiding of fields ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations")), for it is permissible for a `static` variable to hide an instance variable. Hiding is also distinct from shadowing ([¬ß6.4.1](jls-6.html#jls-6.4.1 "6.4.1. Shadowing")) and obscuring ([¬ß6.4.2](jls-6.html#jls-6.4.2 "6.4.2. Obscuring")).

A hidden method can be accessed by using a qualified name or by using a method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")) that contains the keyword `super` or a cast to a superclass type.

In this respect, hiding of methods is similar to hiding of fields.

**Example 8.4.8.2-1. Invocation of Hidden Class Methods**

A class (`static`) method that is hidden can be invoked by using a reference whose type is the class that actually contains the declaration of the method. In this respect, hiding of `static` methods is different from overriding of instance methods. The example:

class Super {
    static String greeting() { return "Goodnight"; }
    String name() { return "Richard"; }
}
class Sub extends Super {
    static String greeting() { return "Hello"; }
    String name() { return "Dick"; }
}
class Test {
    public static void main(String\[\] args) {
        Super s = new Sub();
        System.out.println(s.greeting() + ", " + s.name());
    }
}

produces the output:

Goodnight, Dick

because the invocation of `greeting` uses the type of `s`, namely `Super`, to figure out, at compile time, which class method to invoke, whereas the invocation of `name` uses the class of `s`, namely `Sub`, to figure out, at run time, which instance method to invoke.

  

#### 8.4.8.3. Requirements in Overriding and Hiding

If a method declaration `d1` with return type R1 overrides or hides the declaration of another method `d2` with return type R2, then `d1` must be return-type-substitutable ([¬ß8.4.5](jls-8.html#jls-8.4.5 "8.4.5. Method Result")) for `d2`, or a compile-time error occurs.

This rule allows for covariant return types - refining the return type of a method when overriding it.

If R1 is not a subtype of R2, a compile-time unchecked warning occurs unless suppressed by the `SuppressWarnings` annotation ([¬ß9.6.4.5](jls-9.html#jls-9.6.4.5 "9.6.4.5. @SuppressWarnings")).

A method that overrides or hides another method, including methods that implement `abstract` methods defined in interfaces, may not be declared to throw more checked exceptions than the overridden or hidden method.

In this respect, overriding of methods differs from hiding of fields ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations")), for it is permissible for a field to hide a field of another type.

More precisely, suppose that B is a class or interface, and A is a superclass or superinterface of B, and a method declaration `m2` in B overrides or hides a method declaration `m1` in A. Then:

*   If `m2` has a `throws` clause that mentions any checked exception types, then `m1` must have a `throws` clause, or a compile-time error occurs.
*   For every checked exception type listed in the `throws` clause of `m2`, that same exception class or one of its supertypes must occur in the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of the `throws` clause of `m1`; otherwise, a compile-time error occurs.
*   If the unerased `throws` clause of `m1` does not contain a supertype of each exception type in the `throws` clause of `m2` (adapted, if necessary, to the type parameters of `m1`), a compile-time unchecked warning occurs.
    

It is a compile-time error if a type declaration T has a member method `m1` and there exists a method `m2` declared in T or a supertype of T such that all of the following are true:

*   `m1` and `m2` have the same name.
*   `m2` is accessible from T.
*   The signature of `m1` is not a subsignature ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")) of the signature of `m2`.
*   The signature of `m1` or some method `m1` overrides (directly or indirectly) has the same erasure as the signature of `m2` or some method `m2` overrides (directly or indirectly).
    

These restrictions are necessary because generics are implemented via erasure. The rule above implies that methods declared in the same class with the same name must have different erasures. It also implies that a type declaration cannot implement or extend two distinct invocations of the same generic interface.

The access modifier ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) of an overriding or hiding method must provide at least as much access as the overridden or hidden method, as follows:

*   If the overridden or hidden method is `public`, then the overriding or hiding method must be `public`; otherwise, a compile-time error occurs.
*   If the overridden or hidden method is `protected`, then the overriding or hiding method must be `protected` or `public`; otherwise, a compile-time error occurs.
*   If the overridden or hidden method has package access, then the overriding or hiding method must _not_ be `private`; otherwise, a compile-time error occurs.
    

Note that a `private` method cannot be hidden or overridden in the technical sense of those terms. This means that a subclass can declare a method with the same signature as a `private` method in one of its superclasses, and there is no requirement that the return type or `throws` clause of such a method bear any relationship to those of the `private` method in the superclass.

**Example 8.4.8.3-1. Covariant Return Types**

The following declarations are legal in the Java programming language from Java SE 5.0 onwards:

class C implements Cloneable { 
    C copy() throws CloneNotSupportedException {
        return (C)clone();
    } 
}
class D extends C implements Cloneable { 
    D copy() throws CloneNotSupportedException {
        return (D)clone();
    } 
}

The relaxed rule for overriding also allows one to relax the conditions on abstract classes implementing interfaces.

  

**Example 8.4.8.3-2. Unchecked Warning from Return Type**

Consider:

class StringSorter {
    // turns a collection of strings into a sorted list
    List toList(Collection c) {...} 
}

and assume that someone subclasses `StringSorter`:

class Overrider extends StringSorter {
    List toList(Collection c) {...}
}

Now, at some point the author of `StringSorter` decides to generify the code:

class StringSorter {
    // turns a collection of strings into a sorted list
    List<String> toList(Collection<String> c) {...}
}

An unchecked warning would be given when compiling `Overrider` against the new definition of `StringSorter` because the return type of `Overrider.toList` is `List`, which is not a subtype of the return type of the overridden method, `List<String>`.

  

**Example 8.4.8.3-3. Incorrect Overriding because of `throws`**

This program uses the usual and conventional form for declaring a new exception type, in its declaration of the class `BadPointException`:

class BadPointException extends Exception {
    BadPointException() { super(); }
    BadPointException(String s) { super(s); }
}
class Point {
    int x, y;
    void move(int dx, int dy) { x += dx; y += dy; }
}
class CheckedPoint extends Point {
    void move(int dx, int dy) throws BadPointException {
        if ((x + dx) < 0 || (y + dy) < 0)
            throw new BadPointException();
        x += dx; y += dy;
    }
}

The program results in a compile-time error, because the override of method `move` in class `CheckedPoint` declares that it will throw a checked exception that the `move` in class `Point` has not declared. If this were not considered an error, an invoker of the method `move` on a reference of type `Point` could find the contract between it and `Point` broken if this exception were thrown.

Removing the `throws` clause does not help:

class CheckedPoint extends Point {
    void move(int dx, int dy) {
        if ((x + dx) < 0 || (y + dy) < 0)
            throw new BadPointException();
        x += dx; y += dy;
    }
}

A different compile-time error now occurs, because the body of the method `move` cannot throw a checked exception, namely `BadPointException`, that does not appear in the `throws` clause for `move`.

  

**Example 8.4.8.3-4. Erasure Affects Overriding**

A class cannot have two member methods with the same name and type erasure:

class C<T> {
    T id (T x) {...}
}
class D extends C<String> {
    Object id(Object x) {...}
}

This is illegal since `D.id(Object)` is a member of `D`, `C<String>.id(String)` is declared in a supertype of `D`, and:

*   The two methods have the same name, `id`\>C<String>.id(String) is accessible to `D`

*   The signature of `D.id(Object)` is not a subsignature of that of `C<String>.id(String)`
*   The two methods have the same erasure
    

Two different methods of a class may not override methods with the same erasure:

class C<T> {
    T id(T x) {...}
}
interface I<T> {
    T id(T x);
}
class D extends C<String> implements I<Integer> {
   public String  id(String x)  {...}
   public Integer id(Integer x) {...}
}

This is also illegal, since `D.id(String)` is a member of `D`, `D.id(Integer)` is declared in `D`, and:

*   The two methods have the same name, `id`
*   `D.id(Integer)` is accessible to `D`
*   The two methods have different signatures (and neither is a subsignature of the other)
*   `D.id(String)` overrides `C<String>.id(String)` and `D.id(Integer)` overrides `I.id(Integer)` yet the two overridden methods have the same erasure
    

  

#### 8.4.8.4. Inheriting Methods with Override-Equivalent Signatures

It is possible for a class to inherit multiple methods with override-equivalent signatures ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")).

It is a compile-time error if a class C inherits a concrete method whose signature is override-equivalent with another method inherited by C.

It is a compile-time error if a class C inherits a default method whose signature is override-equivalent with another method inherited by C, unless there exists an `abstract` method declared in a superclass of C and inherited by C that is override-equivalent with the two methods.

This exception to the strict default-abstract and default-default conflict rules is made when an `abstract` method is declared in a superclass: the assertion of abstract-ness coming from the superclass hierarchy essentially trumps the default method, making the default method act as if it were `abstract`. However, the `abstract` method from a class does not override the default method(s), because interfaces are still allowed to refine the _signature_ of the `abstract` method coming from the class hierarchy.

Note that the exception does not apply if all override-equivalent `abstract` methods inherited by C were declared in interfaces.

Otherwise, the set of override-equivalent methods consists of at least one `abstract` method and zero or more default methods; then the class is necessarily an `abstract` class and is considered to inherit all the methods.

One of the inherited methods must be return-type-substitutable for every other inherited method; otherwise, a compile-time error occurs. (The `throws` clauses do not cause errors in this case.)

There might be several paths by which the same method declaration is inherited from an interface. This fact causes no difficulty and never, of itself, results in a compile-time error.

### 8.4.9. Overloading

If two methods of a class (whether both declared in the same class, or both inherited by a class, or one declared and one inherited) have the same name but signatures that are not override-equivalent, then the method name is said to be _overloaded_.

This fact causes no difficulty and never of itself results in a compile-time error. There is no required relationship between the return types or between the `throws` clauses of two methods with the same name, unless their signatures are override-equivalent.

When a method is invoked ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")), the number of actual arguments (and any explicit type arguments) and the compile-time types of the arguments are used, at compile time, to determine the signature of the method that will be invoked ([¬ß15.12.2](jls-15.html#jls-15.12.2 "15.12.2. Compile-Time Step 2: Determine Method Signature")). If the method that is to be invoked is an instance method, the actual method to be invoked will be determined at run time, using dynamic method lookup ([¬ß15.12.4](jls-15.html#jls-15.12.4 "15.12.4. Run-Time Evaluation of Method Invocation")).

**Example 8.4.9-1. Overloading**

class Point {
    float x, y;
    void move(int dx, int dy) { x += dx; y += dy; }
    void move(float dx, float dy) { x += dx; y += dy; }
    public String toString() { return "("+x+","+y+")"; }
}

Here, the class `Point` has two members that are methods with the same name, `move`. The overloaded `move` method of class `Point` chosen for any particular method invocation is determined at compile time by the overloading resolution procedure given in [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions").

In total, the members of the class `Point` are the `float` instance variables `x` and `y` declared in `Point`, the two declared `move` methods, the declared `toString` method, and the members that `Point` inherits from its implicit direct superclass `Object` ([¬ß4.3.2](jls-4.html#jls-4.3.2 "4.3.2. The Class Object")), such as the method `hashCode`. Note that `Point` does not inherit the `toString` method of class `Object` because that method is overridden by the declaration of the `toString` method in class `Point`.

  

**Example 8.4.9-2. Overloading, Overriding, and Hiding**

class Point {
    int x = 0, y = 0;
    void move(int dx, int dy) { x += dx; y += dy; }
    int color;
}
class RealPoint extends Point {
    float x = 0.0f, y = 0.0f;
    void move(int dx, int dy) { move((float)dx, (float)dy); }
    void move(float dx, float dy) { x += dx; y += dy; }
}

Here, the class `RealPoint` hides the declarations of the `int` instance variables `x` and `y` of class `Point` with its own `float` instance variables `x` and `y`, and overrides the method `move` of class `Point` with its own `move` method. It also overloads the name `move` with another method with a different signature ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")).

In this example, the members of the class `RealPoint` include the instance variable `color` inherited from the class `Point`, the `float` instance variables `x` and `y` declared in `RealPoint`, and the two `move` methods declared in `RealPoint`.

Which of these overloaded `move` methods of class `RealPoint` will be chosen for any particular method invocation will be determined at compile time by the overloading resolution procedure described in [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions").

This following program is an extended variation of the preceding program:

class Point {
    int x = 0, y = 0, color;
    void move(int dx, int dy) { x += dx; y += dy; }
    int getX() { return x; }
    int getY() { return y; }
}
class RealPoint extends Point {
    float x = 0.0f, y = 0.0f;
    void move(int dx, int dy) { move((float)dx, (float)dy); }
    void move(float dx, float dy) { x += dx; y += dy; }
    float getX() { return x; }
    float getY() { return y; }
}

Here, the class `Point` provides methods `getX` and `getY` that return the values of its fields `x` and `y`; the class `RealPoint` then overrides these methods by declaring methods with the same signature. The result is two errors at compile time, one for each method, because the return types do not match; the methods in class `Point` return values of type `int`, but the wanna-be overriding methods in class `RealPoint` return values of type `float`.

This program corrects the errors of the preceding program:

class Point {
    int x = 0, y = 0;
    void move(int dx, int dy) { x += dx; y += dy; }
    int getX() { return x; }
    int getY() { return y; }
    int color;
}
class RealPoint extends Point {
    float x = 0.0f, y = 0.0f;
    void move(int dx, int dy) { move((float)dx, (float)dy); }
    void move(float dx, float dy) { x += dx; y += dy; }
    int getX() { return (int)Math.floor(x); }
    int getY() { return (int)Math.floor(y); }
}

Here, the overriding methods `getX` and `getY` in class `RealPoint` have the same return types as the methods of class `Point` that they override, so this code can be successfully compiled.

Consider, then, this test program:

class Test {
    public static void main(String\[\] args) {
        RealPoint rp = new RealPoint();
        Point p = rp;
        rp.move(1.71828f, 4.14159f);
        p.move(1, -1);
        show(p.x, p.y);
        show(rp.x, rp.y);
        show(p.getX(), p.getY());
        show(rp.getX(), rp.getY());
    }
    static void show(int x, int y) {
        System.out.println("(" + x + ", " + y + ")");
    }
    static void show(float x, float y) {
        System.out.println("(" + x + ", " + y + ")");
    }
}

The output from this program is:

(0, 0)
(2.7182798, 3.14159)
(2, 3)
(2, 3)

The first line of output illustrates the fact that an instance of `RealPoint` actually contains the two integer fields declared in class `Point`; it is just that their names are hidden from code that occurs within the declaration of class `RealPoint` (and those of any subclasses it might have). When a reference to an instance of class `RealPoint` in a variable of type `Point` is used to access the field `x`, the integer field `x` declared in class `Point` is accessed. The fact that its value is zero indicates that the method invocation `p.move(1, -1)` did not invoke the method `move` of class `Point`; instead, it invoked the overriding method `move` of class `RealPoint`.

The second line of output shows that the field access `rp.x` refers to the field `x` declared in class `RealPoint`. This field is of type `float`, and this second line of output accordingly displays floating-point values. Incidentally, this also illustrates the fact that the method name `show` is overloaded; the types of the arguments in the method invocation dictate which of the two definitions will be invoked.

The last two lines of output show that the method invocations `p.getX()` and `rp.getX()` each invoke the `getX` method declared in class `RealPoint`. Indeed, there is no way to invoke the `getX` method of class `Point` for an instance of class `RealPoint` from outside the body of `RealPoint`, no matter what the type of the variable we may use to hold the reference to the object. Thus, we see that fields and methods behave differently: hiding is different from overriding.

  

8.5. Member Type Declarations
-----------------------------

A _member class_ is a class whose declaration is directly enclosed in the body of another class or interface declaration ([¬ß8.1.6](jls-8.html#jls-8.1.6 "8.1.6. Class Body and Member Declarations"), [¬ß9.1.4](jls-9.html#jls-9.1.4 "9.1.4. Interface Body and Member Declarations")).

A _member interface_ is an interface whose declaration is directly enclosed in the body of another class or interface declaration ([¬ß8.1.6](jls-8.html#jls-8.1.6 "8.1.6. Class Body and Member Declarations"), [¬ß9.1.4](jls-9.html#jls-9.1.4 "9.1.4. Interface Body and Member Declarations")).

The accessibility of a member type in a class or interface declaration is specified in [¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control").

It is a compile-time error if the same keyword appears more than once as a modifier for a member type declaration in a class.

The scope and shadowing of a member type is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

If a class declares a member type with a certain name, then the declaration of that type is said to _hide_ any and all accessible declarations of member types with the same name in superclasses and superinterfaces of the class.

In this respect, hiding of member types is similar to hiding of fields ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations")).

A class inherits from its direct superclass and direct superinterfaces all the non-`private` member types of the superclass and superinterfaces that are both accessible to code in the class and not hidden by a declaration in the class.

A class may inherit two or more type declarations with the same name, either from two interfaces or from its superclass and an interface. It is a compile-time error to attempt to refer to any ambiguously inherited class or interface by its simple name.

If the same type declaration is inherited from an interface by multiple paths, the class or interface is considered to be inherited only once. It may be referred to by its simple name without ambiguity.

### 8.5.1. Static Member Type Declarations

The `static` keyword may modify the declaration of a member type C within the body of a non-inner class or interface T. Its effect is to declare that C is not an inner class. Just as a `static` method of T has no current instance of T in its body, C also has no current instance of T, nor does it have any lexically enclosing instances.

It is a compile-time error if a `static` class contains a usage of a non-`static` member of an enclosing class.

A member interface is implicitly `static` ([¬ß9.1.1](jls-9.html#jls-9.1.1 "9.1.1. Interface Modifiers")). It is permitted for the declaration of a member interface to redundantly specify the `static` modifier.

8.6. Instance Initializers
--------------------------

An _instance initializer_ declared in a class is executed when an instance of the class is created ([¬ß12.5](jls-12.html#jls-12.5 "12.5. Creation of New Class Instances"), [¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions"), [¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations")).

InstanceInitializer:

[Block](jls-14.html#jls-Block "Block")

It is a compile-time error if an instance initializer cannot complete normally ([¬ß14.21](jls-14.html#jls-14.21 "14.21. Unreachable Statements")).

It is a compile-time error if a `return` statement ([¬ß14.17](jls-14.html#jls-14.17 "14.17. The return Statement")) appears anywhere within an instance initializer.

Instance initializers are permitted to refer to the current object via the keyword `this` ([¬ß15.8.3](jls-15.html#jls-15.8.3 "15.8.3. this")), to use the keyword `super` ([¬ß15.11.2](jls-15.html#jls-15.11.2 "15.11.2. Accessing Superclass Members using super"), [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")), and to use any type variables in scope.

Use of instance variables whose declarations appear textually after the use is sometimes restricted, even though these instance variables are in scope. See [¬ß8.3.3](jls-8.html#jls-8.3.3 "8.3.3. Forward References During Field Initialization") for the precise rules governing forward reference to instance variables.

Exception checking for an instance initializer is specified in [¬ß11.2.3](jls-11.html#jls-11.2.3 "11.2.3. Exception Checking").

8.7. Static Initializers
------------------------

A _static initializer_ declared in a class is executed when the class is initialized ([¬ß12.4.2](jls-12.html#jls-12.4.2 "12.4.2. Detailed Initialization Procedure")). Together with any field initializers for class variables ([¬ß8.3.2](jls-8.html#jls-8.3.2 "8.3.2. Field Initialization")), static initializers may be used to initialize the class variables of the class.

StaticInitializer:

`static` [Block](jls-14.html#jls-Block "Block")

It is a compile-time error if a static initializer cannot complete normally ([¬ß14.21](jls-14.html#jls-14.21 "14.21. Unreachable Statements")).

It is a compile-time error if a `return` statement ([¬ß14.17](jls-14.html#jls-14.17 "14.17. The return Statement")) appears anywhere within a static initializer.

It is a compile-time error if the keyword `this` ([¬ß15.8.3](jls-15.html#jls-15.8.3 "15.8.3. this")) or the keyword `super` ([¬ß15.11](jls-15.html#jls-15.11 "15.11. Field Access Expressions"), [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")) or any type variable declared outside the static initializer, appears anywhere within a static initializer.

Use of class variables whose declarations appear textually after the use is sometimes restricted, even though these class variables are in scope. See [¬ß8.3.3](jls-8.html#jls-8.3.3 "8.3.3. Forward References During Field Initialization") for the precise rules governing forward reference to class variables.

Exception checking for a static initializer is specified in [¬ß11.2.3](jls-11.html#jls-11.2.3 "11.2.3. Exception Checking").

8.8. Constructor Declarations
-----------------------------

A _constructor_ is used in the creation of an object that is an instance of a class ([¬ß12.5](jls-12.html#jls-12.5 "12.5. Creation of New Class Instances"), [¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")).

ConstructorDeclaration:

{[ConstructorModifier](jls-8.html#jls-ConstructorModifier "ConstructorModifier")} [ConstructorDeclarator](jls-8.html#jls-ConstructorDeclarator "ConstructorDeclarator") \[[Throws](jls-8.html#jls-Throws "Throws")\] [ConstructorBody](jls-8.html#jls-ConstructorBody "ConstructorBody")

ConstructorDeclarator:

\[[TypeParameters](jls-8.html#jls-TypeParameters "TypeParameters")\] [SimpleTypeName](jls-8.html#jls-SimpleTypeName "SimpleTypeName") `(` \[[FormalParameterList](jls-8.html#jls-FormalParameterList "FormalParameterList")\] `)`

SimpleTypeName:

[Identifier](jls-3.html#jls-Identifier "Identifier")

The rules in this section apply to constructors in all class declarations, including enum declarations. However, special rules apply to enum declarations with regard to constructor modifiers, constructor bodies, and default constructors; these rules are stated in [¬ß8.9.2](jls-8.html#jls-8.9.2 "8.9.2. Enum Body Declarations").

The _SimpleTypeName_ in the _ConstructorDeclarator_ must be the simple name of the class that contains the constructor declaration, or a compile-time error occurs.

In all other respects, a constructor declaration looks just like a method declaration that has no result ([¬ß8.4.5](jls-8.html#jls-8.4.5 "8.4.5. Method Result")).

Constructor declarations are not members. They are never inherited and therefore are not subject to hiding or overriding.

Constructors are invoked by class instance creation expressions ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")), by the conversions and concatenations caused by the string concatenation operator `+` ([¬ß15.18.1](jls-15.html#jls-15.18.1 "15.18.1. String Concatenation Operator +")), and by explicit constructor invocations from other constructors ([¬ß8.8.7](jls-8.html#jls-8.8.7 "8.8.7. Constructor Body")). Access to constructors is governed by access modifiers ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")), so it is possible to prevent instantiation by declaring an inaccessible constructor ([¬ß8.8.10](jls-8.html#jls-8.8.10 "8.8.10. Preventing Instantiation of a Class")).

Constructors are never invoked by method invocation expressions ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")).

**Example 8.8-1. Constructor Declarations**

class Point {
    int x, y;
    Point(int x, int y) { this.x = x; this.y = y; }
}

  

### 8.8.1. Formal Parameters

The formal parameters of a constructor are identical in syntax and semantics to those of a method ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters")).

The constructor of a non-`private` inner member class implicitly declares, as the first formal parameter, a variable representing the immediately enclosing instance of the class ([¬ß15.9.2](jls-15.html#jls-15.9.2 "15.9.2. Determining Enclosing Instances"), [¬ß15.9.3](jls-15.html#jls-15.9.3 "15.9.3. Choosing the Constructor and its Arguments")).

The rationale for why only this kind of class has an implicitly declared constructor parameter is subtle. The following explanation may be helpful:

1.  In a class instance creation expression for a non-`private` inner member class, [¬ß15.9.2](jls-15.html#jls-15.9.2 "15.9.2. Determining Enclosing Instances") specifies the immediately enclosing instance of the member class. The member class may have been emitted by a compiler which is different than the compiler of the class instance creation expression. Therefore, there must be a standard way for the compiler of the creation expression to pass a reference (representing the immediately enclosing instance) to the member class's constructor. Consequently, the Java programming language deems in this section that a non-`private` inner member class's constructor implicitly declares an initial parameter for the immediately enclosing instance. [¬ß15.9.3](jls-15.html#jls-15.9.3 "15.9.3. Choosing the Constructor and its Arguments") specifies that the instance is passed to the constructor.
    
2.  In a class instance creation expression for a local class (not in a static context) or anonymous class, [¬ß15.9.2](jls-15.html#jls-15.9.2 "15.9.2. Determining Enclosing Instances") specifies the immediately enclosing instance of the local/anonymous class. The local/anonymous class is necessarily emitted by the same compiler as the class instance creation expression. That compiler can represent the immediately enclosing instance how ever it wishes. There is no need for the Java programming language to implicitly declare a parameter in the local/anonymous class's constructor.
    
3.  In a class instance creation expression for an anonymous class, and where the anonymous class's superclass is either inner or local (not in a static context), [¬ß15.9.2](jls-15.html#jls-15.9.2 "15.9.2. Determining Enclosing Instances") specifies the anonymous class's immediately enclosing instance with respect to the superclass. This instance must be transmitted from the anonymous class to its superclass, where it will serve as the immediately enclosing instance. Since the superclass may have been emitted by a compiler which is different than the compiler of the class instance creation expression, it is necessary to transmit the instance in a standard way, by passing it as the first argument to the superclass's constructor. Note that the anonymous class itself is necessarily emitted by the same compiler as the class instance creation expression, so it would be possible for the compiler to transmit the immediately enclosing instance with respect to the superclass to the anonymous class how ever it wishes, before the anonymous class passes the instance to the superclass's constructor. However, for consistency, the Java programming language deems in [¬ß15.9.5.1](jls-15.html#jls-15.9.5.1 "15.9.5.1. Anonymous Constructors") that, in some circumstances, an anonymous class's constructor implicitly declares an initial parameter for the immediately enclosing instance with respect to the superclass.
    

The fact that a non-`private` inner member class may be accessed by a different compiler than compiled it, whereas a local or anonymous class is always accessed by the same compiler that compiled it, explains why the binary name of a non-`private` inner member class is defined to be predictable but the binary name of a local or anonymous class is not ([¬ß13.1](jls-13.html#jls-13.1 "13.1. The Form of a Binary")).

### 8.8.2. Constructor Signature

It is a compile-time error to declare two constructors with override-equivalent signatures ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")) in a class.

It is a compile-time error to declare two constructors whose signatures have the same erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) in a class.

### 8.8.3. Constructor Modifiers

ConstructorModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `public` `protected` `private`

The rules for annotation modifiers on a constructor declaration are specified in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear") and [¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type").

It is a compile-time error if the same keyword appears more than once as a modifier in a constructor declaration.

In a normal class declaration, a constructor declaration with no access modifiers has package access.

If two or more (distinct) method modifiers appear in a method declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for _MethodModifier_.

Unlike methods, a constructor cannot be `abstract`, `static`, `final`, `native`, `strictfp`, or `synchronized`:

*   A constructor is not inherited, so there is no need to declare it `final`.
*   An `abstract` constructor could never be implemented.
*   A constructor is always invoked with respect to an object, so it makes no sense for a constructor to be `static`.
*   There is no practical need for a constructor to be `synchronized`, because it would lock the object under construction, which is normally not made available to other threads until all constructors for the object have completed their work.
*   The lack of `native` constructors is an arbitrary language design choice that makes it easy for an implementation of the Java Virtual Machine to verify that superclass constructors are always properly invoked during object creation.
*   The inability to declare a constructor as `strictfp` (in contrast to a method ([¬ß8.4.3](jls-8.html#jls-8.4.3 "8.4.3. Method Modifiers"))) is an intentional language design choice; it effectively ensures that a constructor is FP-strict if and only if its class is FP-strict ([¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions")).
    

### 8.8.4. Generic Constructors

A constructor is _generic_ if it declares one or more type variables ([¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables")).

These type variables are known as the _type parameters_ of the constructor. The form of the type parameter section of a generic constructor is identical to the type parameter section of a generic class ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters")).

It is possible for a constructor to be generic independently of whether the class the constructor is declared in is itself generic.

A generic constructor declaration defines a set of constructors, one for each possible invocation of the type parameter section by type arguments. Type arguments may not need to be provided explicitly when a generic constructor is invoked, as they can often by inferred ([¬ß18 (_Type Inference_)](jls-18.html "Chapter 18. Type Inference")).

The scope and shadowing of a constructor's type parameter is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

### 8.8.5. Constructor Throws

The `throws` clause for a constructor is identical in structure and behavior to the `throws` clause for a method ([¬ß8.4.6](jls-8.html#jls-8.4.6 "8.4.6. Method Throws")).

### 8.8.6. The Type of a Constructor

The type of a constructor consists of its signature and the exception types given by its `throws` clause.

### 8.8.7. Constructor Body

The first statement of a constructor body may be an explicit invocation of another constructor of the same class or of the direct superclass ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations")).

ConstructorBody:

`{` \[[ExplicitConstructorInvocation](jls-8.html#jls-ExplicitConstructorInvocation "ExplicitConstructorInvocation")\] \[[BlockStatements](jls-14.html#jls-BlockStatements "BlockStatements")\] `}`

It is a compile-time error for a constructor to directly or indirectly invoke itself through a series of one or more explicit constructor invocations involving `this`.

If a constructor body does not begin with an explicit constructor invocation and the constructor being declared is not part of the primordial class `Object`, then the constructor body implicitly begins with a superclass constructor invocation "`super();`", an invocation of the constructor of its direct superclass that takes no arguments.

Except for the possibility of explicit constructor invocations, and the prohibition on explicitly returning a value ([¬ß14.17](jls-14.html#jls-14.17 "14.17. The return Statement")), the body of a constructor is like the body of a method ([¬ß8.4.7](jls-8.html#jls-8.4.7 "8.4.7. Method Body")).

A `return` statement ([¬ß14.17](jls-14.html#jls-14.17 "14.17. The return Statement")) may be used in the body of a constructor if it does not include an expression.

**Example 8.8.7-1. Constructor Bodies**

class Point {
    int x, y;
    Point(int x, int y) { this.x = x; this.y = y; }
}
class ColoredPoint extends Point {
    static final int WHITE = 0, BLACK = 1;
    int color;
    ColoredPoint(int x, int y) {
        this(x, y, WHITE);
    }
    ColoredPoint(int x, int y, int color) {
        super(x, y);
        this.color = color;
    }
}

Here, the first constructor of `ColoredPoint` invokes the second, providing an additional argument; the second constructor of `ColoredPoint` invokes the constructor of its superclass `Point`, passing along the coordinates.

  

#### 8.8.7.1. Explicit Constructor Invocations

ExplicitConstructorInvocation:

\[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] `this` `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)` `;`  
\[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] `super` `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)` `;`  
[ExpressionName](jls-6.html#jls-ExpressionName "ExpressionName") `.` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] `super` `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)` `;`  
[Primary](jls-15.html#jls-Primary "Primary") `.` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] `super` `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)` `;`The following productions from [¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types") and [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions") are shown here for convenience:

TypeArguments:

`<` [TypeArgumentList](jls-4.html#jls-TypeArgumentList "TypeArgumentList") `>`

ArgumentList:

[Expression](jls-15.html#jls-Expression "Expression") {`,` [Expression](jls-15.html#jls-Expression "Expression")}

Explicit constructor invocation statements are divided into two kinds:

*   _Alternate constructor invocations_ begin with the keyword `this` (possibly prefaced with explicit type arguments). They are used to invoke an alternate constructor of the same class.
*   _Superclass constructor invocations_ begin with either the keyword `super` (possibly prefaced with explicit type arguments) or a _Primary_ expression or an _ExpressionName_. They are used to invoke a constructor of the direct superclass. They are further divided:
    
    *   _Unqualified superclass constructor invocations_ begin with the keyword `super` (possibly prefaced with explicit type arguments).
        
    *   _Qualified superclass constructor invocations_ begin with a _Primary_ expression or an _ExpressionName_. They allow a subclass constructor to explicitly specify the newly created object's immediately enclosing instance with respect to the direct superclass ([¬ß8.1.3](jls-8.html#jls-8.1.3 "8.1.3. Inner Classes and Enclosing Instances")). This may be necessary when the superclass is an inner class.
        
    

An explicit constructor invocation statement in a constructor body may not refer to any instance variables or instance methods or inner classes declared in this class or any superclass, or use `this` or `super` in any expression; otherwise, a compile-time error occurs.

This prohibition on using the current instance explains why an explicit constructor invocation statement is deemed to occur in a static context ([¬ß8.1.3](jls-8.html#jls-8.1.3 "8.1.3. Inner Classes and Enclosing Instances")).

If _TypeArguments_ is present to the left of `this` or `super`, then it is a compile-time error if any of the type arguments are wildcards ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")).

Let C be the class being instantiated, and let S be the direct superclass of C.

If a superclass constructor invocation statement is unqualified, then:

*   If S is an inner member class, but S is not a member of a lexically enclosing type declaration of C, then a compile-time error occurs.
    

If a superclass constructor invocation statement is qualified, then:

*   If S is not an inner class, or if the declaration of S occurs in a static context, then a compile-time error occurs.
*   Otherwise, let `p` be the _Primary_ expression or the _ExpressionName_ immediately preceding "`.``super`", and let O be the immediately enclosing class of S. It is a compile-time error if the type of `p` is not O or a subclass of O, or if the type of `p` is not accessible ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")).
    

The exception types that an explicit constructor invocation statement can throw are specified in [¬ß11.2.2](jls-11.html#jls-11.2.2 "11.2.2. Exception Analysis of Statements").

Evaluation of an alternate constructor invocation statement proceeds by first evaluating the arguments to the constructor, left-to-right, as in an ordinary method invocation; and then invoking the constructor.

Evaluation of a superclass constructor invocation statement proceeds as follows:

1.  Let `i` be the instance being created. The immediately enclosing instance of `i` with respect to S (if any) must be determined:
    
    *   If S is not an inner class, or if the declaration of S occurs in a static context, then no immediately enclosing instance of `i` with respect to S exists.
        
    *   If the superclass constructor invocation is unqualified, then S is necessarily a local class or an inner member class.
        
        Let O be the immediately enclosing class of S, and let _n_ be an integer such that O is the _n_'th lexically enclosing type declaration of C.
        
        The immediately enclosing instance of `i` with respect to S is the _n_'th lexically enclosing instance of `this`.
        
    *   If the superclass constructor invocation is qualified, then the _Primary_ expression or the _ExpressionName_ immediately preceding "`.``super`", `p`, is evaluated.
        
        If `p` evaluates to `null`, a `NullPointerException` is raised, and the superclass constructor invocation completes abruptly.
        
        Otherwise, the result of this evaluation is the immediately enclosing instance of `i` with respect to S.
        
    
2.  After determining the immediately enclosing instance of `i` with respect to S (if any), evaluation of the superclass constructor invocation statement proceeds by evaluating the arguments to the constructor, left-to-right, as in an ordinary method invocation; and then invoking the constructor.
    
3.  Finally, if the superclass constructor invocation statement completes normally, then all instance variable initializers of C and all instance initializers of C are executed. If an instance initializer or instance variable initializer `I` textually precedes another instance initializer or instance variable initializer `J`, then `I` is executed before `J`.
    
    Execution of instance variable initializers and instance initializers is performed regardless of whether the superclass constructor invocation actually appears as an explicit constructor invocation statement or is provided implicitly. (An alternate constructor invocation does not perform this additional implicit execution.)
    

**Example 8.8.7.1-1. Restrictions on Explicit Constructor Invocation Statements**

If the first constructor of `ColoredPoint` in the example from [¬ß8.8.7](jls-8.html#jls-8.8.7 "8.8.7. Constructor Body") were changed as follows:

class Point {
    int x, y;
    Point(int x, int y) { this.x = x; this.y = y; }
}
class ColoredPoint extends Point {
    static final int WHITE = 0, BLACK = 1;
    int color;
    ColoredPoint(int x, int y) {
        this(x, y, color);  // Changed to color from WHITE
    }
    ColoredPoint(int x, int y, int color) {
        super(x, y);
        this.color = color;
    }
}

then a compile-time error would occur, because the instance variable `color` cannot be used by a explicit constructor invocation statement.

  

**Example 8.8.7.1-2. Qualified Superclass Constructor Invocation**

In the code below, `ChildOfInner` has no lexically enclosing type declaration, so an instance of `ChildOfInner` has no enclosing instance. However, the superclass of `ChildOfInner` (`Inner`) has a lexically enclosing type declaration (`Outer`), and an instance of `Inner` must have an enclosing instance of `Outer`. The enclosing instance of `Outer` is set when an instance of `Inner` is created. Therefore, when we create an instance of `ChildOfInner`, which is implicitly an instance of `Inner`, we must provide the enclosing instance of `Outer` via a qualified superclass invocation statement in `ChildOfInner`'s constructor. The instance of `Outer` is called the immediately enclosing instance of `ChildOfInner` with respect to `Inner`.

class Outer {
    class Inner {}
}
class ChildOfInner extends Outer.Inner {
    ChildOfInner() { (new Outer()).super(); }
}

Perhaps surprisingly, the same instance of `Outer` may serve as the immediately enclosing instance of `ChildOfInner` with respect to `Inner` _for multiple instances of `ChildOfInner`_. These instances of `ChildOfInner` are implicitly linked to the same instance of `Outer`. The program below achieves this by passing an instance of `Outer` to the constructor of `ChildOfInner`, which uses the instance in a qualified superclass constructor invocation statement. The rules for an explicit constructor invocation statement do not prohibit using formal parameters of the constructor that contains the statement.

class Outer {
    int secret = 5;
    class Inner {
        int  getSecret()      { return secret; }
        void setSecret(int s) { secret = s; }
    }
}
class ChildOfInner extends Outer.Inner {
    ChildOfInner(Outer x) { x.super(); }
}

public class Test {
    public static void main(String\[\] args) {
        Outer x = new Outer();
        ChildOfInner a = new ChildOfInner(x);
        ChildOfInner b = new ChildOfInner(x);
        System.out.println(b.getSecret());
        a.setSecret(6);
        System.out.println(b.getSecret());
    }
}

This program produces the output:

5
6

The effect is that manipulation of instance variables in the common instance of `Outer` is visible through references to different instances of `ChildOfInner`, even though such references are not aliases in the conventional sense.

  

### 8.8.8. Constructor Overloading

Overloading of constructors is identical in behavior to overloading of methods ([¬ß8.4.9](jls-8.html#jls-8.4.9 "8.4.9. Overloading")). The overloading is resolved at compile time by each class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")).

### 8.8.9. Default Constructor

If a class contains no constructor declarations, then a default constructor is implicitly declared. The form of the default constructor for a top level class, member class, or local class is as follows:

*   The default constructor has the same accessibility as the class ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")).
*   The default constructor has no formal parameters, except in a non-`private` inner member class, where the default constructor implicitly declares one formal parameter representing the immediately enclosing instance of the class ([¬ß8.8.1](jls-8.html#jls-8.8.1 "8.8.1. Formal Parameters"), [¬ß15.9.2](jls-15.html#jls-15.9.2 "15.9.2. Determining Enclosing Instances"), [¬ß15.9.3](jls-15.html#jls-15.9.3 "15.9.3. Choosing the Constructor and its Arguments")).
*   The default constructor has no `throws` clauses.
*   If the class being declared is the primordial class `Object`, then the default constructor has an empty body. Otherwise, the default constructor simply invokes the superclass constructor with no arguments.
    

The form of the default constructor for an anonymous class is specified in [¬ß15.9.5.1](jls-15.html#jls-15.9.5.1 "15.9.5.1. Anonymous Constructors").

It is a compile-time error if a default constructor is implicitly declared but the superclass does not have an accessible constructor that takes no arguments and has no `throws` clause.

**Example 8.8.9-1. Default Constructors**

The declaration:

public class Point {
    int x, y;
}

is equivalent to the declaration:

public class Point {
    int x, y;
    public Point() { super(); }
}

where the default constructor is `public` because the class `Point` is `public`.

  

**Example 8.8.9-2. Accessibility of Constructors v. Classes**

The rule that the default constructor of a class has the same accessibility as the class itself is simple and intuitive. Note, however, that this does not imply that the constructor is accessible whenever the class is accessible. Consider:

package p1;
public class Outer {
    protected class Inner {}
}
package p2;
class SonOfOuter extends p1.Outer {
    void foo() {
        new Inner();  // compile-time access error
    }
}

The default constructor for `Inner` is `protected`. However, the constructor is `protected` relative to `Inner`, while `Inner` is `protected` relative to `Outer`. So, `Inner` is accessible in `SonOfOuter`, since it is a subclass of `Outer`. `Inner`'s constructor is not accessible in `SonOfOuter`, because the class `SonOfOuter` is not a subclass of `Inner`! Hence, even though `Inner` is accessible, its default constructor is not.

  

### 8.8.10. Preventing Instantiation of a Class

A class can be designed to prevent code outside the class declaration from creating instances of the class by declaring at least one constructor, to prevent the creation of a default constructor, and by declaring all constructors to be `private`.

A `public` class can likewise prevent the creation of instances outside its package by declaring at least one constructor, to prevent creation of a default constructor with `public` access, and by declaring no constructor that is `public`.

**Example 8.8.10-1. Preventing Instantiation via Constructor Accessibility**

class ClassOnly {
    private ClassOnly() { }
    static String just = "only the lonely";
}

Here, the class `ClassOnly` cannot be instantiated, while in the following code:

package just;
public class PackageOnly {
    PackageOnly() { }
    String\[\] justDesserts = { "cheesecake", "ice cream" };
}

the class `PackageOnly` can be instantiated only within the package `just`, in which it is declared.

  

8.9. Enum Types
---------------

An _enum declaration_ specifies a new _enum type_, a special kind of class type.

EnumDeclaration:

{[ClassModifier](jls-8.html#jls-ClassModifier "ClassModifier")} `enum` [Identifier](jls-3.html#jls-Identifier "Identifier") \[[Superinterfaces](jls-8.html#jls-Superinterfaces "Superinterfaces")\] [EnumBody](jls-8.html#jls-EnumBody "EnumBody")

It is a compile-time error if an enum declaration has the modifier `abstract` or `final`.

An enum declaration is implicitly `final` unless it contains at least one enum constant that has a class body ([¬ß8.9.1](jls-8.html#jls-8.9.1 "8.9.1. Enum Constants")).

A nested enum type is implicitly `static`. It is permitted for the declaration of a nested enum type to redundantly specify the `static` modifier.

This implies that it is impossible to declare an enum type in the body of an inner class ([¬ß8.1.3](jls-8.html#jls-8.1.3 "8.1.3. Inner Classes and Enclosing Instances")), because an inner class cannot have `static` members except for constant variables.

It is a compile-time error if the same keyword appears more than once as a modifier for an enum declaration.

The direct superclass of an enum type E is `Enum``<`E`>` ([¬ß8.1.4](jls-8.html#jls-8.1.4 "8.1.4. Superclasses and Subclasses")).

An enum type has no instances other than those defined by its enum constants. It is a compile-time error to attempt to explicitly instantiate an enum type ([¬ß15.9.1](jls-15.html#jls-15.9.1 "15.9.1. Determining the Class being Instantiated")).

In addition to the compile-time error, three further mechanisms ensure that no instances of an enum type exist beyond those defined by its enum constants:

*   The `final` `clone` method in `Enum` ensures that enum constants can never be cloned.
*   Reflective instantiation of enum types is prohibited.
*   Special treatment by the serialization mechanism ensures that duplicate instances are never created as a result of deserialization.
    

### 8.9.1. Enum Constants

The body of an enum declaration may contain _enum constants_. An enum constant defines an instance of the enum type.

EnumBody:

`{` \[[EnumConstantList](jls-8.html#jls-EnumConstantList "EnumConstantList")\] \[`,`\] \[[EnumBodyDeclarations](jls-8.html#jls-EnumBodyDeclarations "EnumBodyDeclarations")\] `}`

EnumConstantList:

[EnumConstant](jls-8.html#jls-EnumConstant "EnumConstant") {`,` [EnumConstant](jls-8.html#jls-EnumConstant "EnumConstant")}

EnumConstant:

{[EnumConstantModifier](jls-8.html#jls-EnumConstantModifier "EnumConstantModifier")} [Identifier](jls-3.html#jls-Identifier "Identifier") \[`(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)`\] \[[ClassBody](jls-8.html#jls-ClassBody "ClassBody")\]

EnumConstantModifier:

[Annotation](jls-9.html#jls-Annotation "Annotation")

The following production from [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions") is shown here for convenience:

ArgumentList:

[Expression](jls-15.html#jls-Expression "Expression") {`,` [Expression](jls-15.html#jls-Expression "Expression")}

The rules for annotation modifiers on an enum constant declaration are specified in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear") and [¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type").

The _Identifier_ in a _EnumConstant_ may be used in a name to refer to the enum constant.

The scope and shadowing of an enum constant is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

An enum constant may be followed by arguments, which are passed to the constructor of the enum when the constant is created during class initialization as described later in this section. The constructor to be invoked is chosen using the normal rules of overload resolution ([¬ß15.12.2](jls-15.html#jls-15.12.2 "15.12.2. Compile-Time Step 2: Determine Method Signature")). If the arguments are omitted, an empty argument list is assumed.

The optional class body of an enum constant implicitly defines an anonymous class declaration ([¬ß15.9.5](jls-15.html#jls-15.9.5 "15.9.5. Anonymous Class Declarations")) that extends the immediately enclosing enum type. The class body is governed by the usual rules of anonymous classes; in particular it cannot contain any constructors. Instance methods declared in these class bodies may be invoked outside the enclosing enum type only if they override accessible methods in the enclosing enum type ([¬ß8.4.8](jls-8.html#jls-8.4.8 "8.4.8. Inheritance, Overriding, and Hiding")).

It is a compile-time error for the class body of an enum constant to declare an `abstract` method.

Because there is only one instance of each enum constant, it is permitted to use the `==` operator in place of the `equals` method when comparing two object references if it is known that at least one of them refers to an enum constant.

The `equals` method in `Enum` is a `final` method that merely invokes `super.equals` on its argument and returns the result, thus performing an identity comparison.

### 8.9.2. Enum Body Declarations

In addition to enum constants, the body of an enum declaration may contain constructor and member declarations as well as instance and static initializers.

EnumBodyDeclarations:

`;` {[ClassBodyDeclaration](jls-8.html#jls-ClassBodyDeclaration "ClassBodyDeclaration")}

The following productions from [¬ß8.1.6](jls-8.html#jls-8.1.6 "8.1.6. Class Body and Member Declarations") are shown here for convenience:

ClassBodyDeclaration:

[ClassMemberDeclaration](jls-8.html#jls-ClassMemberDeclaration "ClassMemberDeclaration")  
[InstanceInitializer](jls-8.html#jls-InstanceInitializer "InstanceInitializer")  
[StaticInitializer](jls-8.html#jls-StaticInitializer "StaticInitializer")  
[ConstructorDeclaration](jls-8.html#jls-ConstructorDeclaration "ConstructorDeclaration")

ClassMemberDeclaration:

[FieldDeclaration](jls-8.html#jls-FieldDeclaration "FieldDeclaration")  
[MethodDeclaration](jls-8.html#jls-MethodDeclaration "MethodDeclaration")  
[ClassDeclaration](jls-8.html#jls-ClassDeclaration "ClassDeclaration")  
[InterfaceDeclaration](jls-9.html#jls-InterfaceDeclaration "InterfaceDeclaration")  
`;`

Any constructor or member declarations in the body of an enum declaration apply to the enum type exactly as if they had been present in the body of a normal class declaration, unless explicitly stated otherwise.

It is a compile-time error if a constructor declaration in an enum declaration is `public` or `protected` ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")).

It is a compile-time error if a constructor declaration in an enum declaration contains a superclass constructor invocation statement ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations")).

It is a compile-time error to reference a `static` field of an enum type from constructors, instance initializers, or instance variable initializer expressions of the enum type, unless the field is a constant variable ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")).

In an enum declaration, a constructor declaration with no access modifiers is `private`.

In an enum declaration with no constructor declarations, a default constructor is implicitly declared. The default constructor is `private`, has no formal parameters, and has no `throws` clause.

In practice, a compiler is likely to mirror the `Enum` type by declaring `String` and `int` parameters in the default constructor of an enum type. However, these parameters are not specified as "implicitly declared" because different compilers do not need to agree on the form of the default constructor. Only the compiler of an enum type knows how to instantiate the enum constants; other compilers can simply rely on the implicitly declared `public` `static` fields of the enum type ([¬ß8.9.3](jls-8.html#jls-8.9.3 "8.9.3. Enum Members")) without regard for how those fields were initialized.

It is a compile-time error if an enum declaration E has an `abstract` method `m` as a member, unless E has at least one enum constant and all of E's enum constants have class bodies that provide concrete implementations of `m`.

It is a compile-time error for an enum declaration to declare a finalizer ([¬ß12.6](jls-12.html#jls-12.6 "12.6. Finalization of Class Instances")). An instance of an enum type may never be finalized.

**Example 8.9.2-1. Enum Body Declarations**

enum Coin {
    PENNY(1), NICKEL(5), DIME(10), QUARTER(25);
    Coin(int value) { this.value = value; }

    private final int value;
    public int value() { return value; }
}

Each enum constant arranges for a different value in the field `value`, passed in via a constructor. The field represents the value, in cents, of an American coin. Note that there are no restrictions on the parameters that may be declared by an enum type's constructor.

  

**Example 8.9.2-2. Restriction On Enum Constant Self-Reference**

Without the rule on `static` field access, apparently reasonable code would fail at run time due to the initialization circularity inherent in enum types. (A circularity exists in any class with a "self-typed" `static` field.) Here is an example of the sort of code that would fail:

import java.util.Map;
import java.util.HashMap;

enum Color {
    RED, GREEN, BLUE;
    Color() { colorMap.put(toString(), this); }

    static final Map<String,Color> colorMap =
        new HashMap<String,Color>();
}

Static initialization of this enum would throw a `NullPointerException` because the `static` variable `colorMap` is uninitialized when the constructors for the enum constants run. The restriction above ensures that such code cannot be compiled. However, the code can easily be refactored to work properly:

import java.util.Map;
import java.util.HashMap;

enum Color {
    RED, GREEN, BLUE;

    static final Map<String,Color> colorMap =
        new HashMap<String,Color>();
    static {
        for (Color c : Color.values())
            colorMap.put(c.toString(), c);
    }
}

The refactored version is clearly correct, as static initialization occurs top to bottom.

  

### 8.9.3. Enum Members

The members of an enum type E are all of the following:

*   Members declared in the body of the declaration of E.
*   Members inherited from `Enum``<`E`>`.
*   For each enum constant `c` declared in the body of the declaration of E, E has an implicitly declared `public` `static` `final` field of type E that has the same name as `c`. The field has a variable initializer consisting of `c`, and is annotated by the same annotations as `c`.
    
    These fields are implicitly declared in the same order as the corresponding enum constants, before any `static` fields explicitly declared in the body of the declaration of E.
    
    An enum constant is said to be _created_ when the corresponding implicitly declared field is initialized.
*   The following implicitly declared methods:
    
    /\*\*
    \* Returns an array containing the constants of this enum 
    \* type, in the order they're declared.  This method may be
    \* used to iterate over the constants as follows:
    \*
    \*    for(E c : E.values())
    \*        System.out.println(c);
    \*
    \* @return an array containing the constants of this enum 
    \* type, in the order they're declared
    \*/
    public static E\[\] values();
    
    /\*\*
    \* Returns the enum constant of this type with the specified
    \* name.
    \* The string must match exactly an identifier used to declare
    \* an enum constant in this type.  (Extraneous whitespace 
    \* characters are not permitted.)
    \* 
    \* @return the enum constant with the specified name
    \* @throws IllegalArgumentException if this enum type has no
    \* constant with the specified name
    \*/
    public static E valueOf(String name);
    

It follows that the declaration of enum type E cannot contain fields that conflict with the implicitly declared fields corresponding to E's enum constants, nor contain methods that conflict with implicitly declared methods or override `final` methods of class `Enum``<`E`>`.

**Example 8.9.3-1. Iterating Over Enum Constants With An Enhanced `for` Loop**

public class Test {
    enum Season { WINTER, SPRING, SUMMER, FALL }

    public static void main(String\[\] args) {
        for (Season s : Season.values())
            System.out.println(s);
    }
}

This program produces the output:

WINTER
SPRING
SUMMER
FALL

  

**Example 8.9.3-2. Switching Over Enum Constants**

A `switch` statement ([¬ß14.11](jls-14.html#jls-14.11 "14.11. The switch Statement")) is useful for simulating the addition of a method to an enum type from outside the type. This example "adds" a `color` method to the `Coin` type from [¬ß8.9.2](jls-8.html#jls-8.9.2 "8.9.2. Enum Body Declarations"), and prints a table of coins, their values, and their colors.

class Test {
    enum CoinColor { COPPER, NICKEL, SILVER }

    static CoinColor color(Coin c) {
        switch (c) {
            case PENNY:
                return CoinColor.COPPER;
            case NICKEL:
                return CoinColor.NICKEL;
            case DIME: case QUARTER:
                return CoinColor.SILVER;
            default:
                throw new AssertionError("Unknown coin: " + c);
        }
    }

    public static void main(String\[\] args) {
        for (Coin c : Coin.values())
            System.out.println(c + "\\t\\t" +
                               c.value() + "\\t" + color(c));
    }
}

This program produces the output:

PENNY           1       COPPER
NICKEL          5       NICKEL
DIME            10      SILVER
QUARTER         25      SILVER

  

**Example 8.9.3-3. Enum Constants with Class Bodies**

enum Operation {
    PLUS {
        double eval(double x, double y) { return x + y; }
    },
    MINUS {
        double eval(double x, double y) { return x - y; }
    },
    TIMES {
        double eval(double x, double y) { return x \* y; }
    },
    DIVIDED\_BY {
        double eval(double x, double y) { return x / y; }
    };

    // Each constant supports an arithmetic operation
    abstract double eval(double x, double y);

    public static void main(String args\[\]) {
        double x = Double.parseDouble(args\[0\]);
        double y = Double.parseDouble(args\[1\]);
        for (Operation op : Operation.values())
            System.out.println(x + " " + op + " " + y +
                               " = " + op.eval(x, y));
    }
}

Class bodies attach behaviors to the enum constants. The program produces the output:e class="screen"> java Operation 2.0 4.0 2.0 PLUS 4.0 = 6.0 2.0 MINUS 4.0 = -2.0 2.0 TIMES 4.0 = 8.0 2.0 DIVIDED\_BY 4.0 = 0.5

This pattern is much safer than using a `switch` statement in the base type (`Operation`), as the pattern precludes the possibility of forgetting to add a behavior for a new constant (since the enum declaration would cause a compile-time error).

  

**Example 8.9.3-4. Multiple Enum Types**

In the following program, a playing card class is built atop two simple enums.

import java.util.List;
import java.util.ArrayList;
class Card implements Comparable<Card>,
                      java.io.Serializable {
    public enum Rank { DEUCE, THREE, FOUR, FIVE, SIX, SEVEN,
                       EIGHT, NINE, TEN,JACK, QUEEN, KING, ACE }

    public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES }

    private final Rank rank;
    private final Suit suit;
    public Rank rank() { return rank; }
    public Suit suit() { return suit; }

    private Card(Rank rank, Suit suit) {
        if (rank == null || suit == null)
            throw new NullPointerException(rank + ", " + suit);
        this.rank = rank;
        this.suit = suit;
    }

    public String toString() { return rank + " of " + suit; }

    // Primary sort on suit, secondary sort on rank
    public int compareTo(Card c) {
        int suitCompare = suit.compareTo(c.suit);
        return (suitCompare != 0 ?
                    suitCompare :
                    rank.compareTo(c.rank));
    }

    private static final List<Card> prototypeDeck =
        new ArrayList<Card>(52);

    static {
        for (Suit suit : Suit.values())
            for (Rank rank : Rank.values())
                prototypeDeck.add(new Card(rank, suit));
    }

    // Returns a new deck
    public static List<Card> newDeck() {
        return new ArrayList<Card>(prototypeDeck);
    }
}

The following program exercises the `Card` class. It takes two integer parameters on the command line, representing the number of hands to deal and the number of cards in each hand:

import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
class Deal {
    public static void main(String args\[\]) {
        int numHands     = Integer.parseInt(args\[0\]);
        int cardsPerHand = Integer.parseInt(args\[1\]);
        List<Card> deck  = Card.newDeck();
        Collections.shuffle(deck);
        for (int i=0; i < numHands; i++)
            System.out.println(dealHand(deck, cardsPerHand));
    }

    /\*\*
     \* Returns a new ArrayList consisting of the last n
     \* elements of deck, which are removed from deck.
     \* The returned list is sorted using the elements'
     \* natural ordering.
     \*/
    public static <E extends Comparable<E>>
    ArrayList<E> dealHand(List<E> deck, int n) {
        int deckSize = deck.size();
        List<E> handView = deck.subList(deckSize - n, deckSize);
        ArrayList<E> hand = new ArrayList<E>(handView);
        handView.clear();
        Collections.sort(hand);
        return hand;
    }
}

The program produces the output:

java Deal 4 3
\[DEUCE of CLUBS, SEVEN of CLUBS, QUEEN of DIAMONDS\]
\[NINE of HEARTS, FIVE of SPADES, ACE of SPADES\]
\[THREE of HEARTS, SIX of HEARTS, TEN of SPADES\]
\[TEN of CLUBS, NINE of DIAMONDS, THREE of SPADES\]


üçÄ Chapter 9. Interfaces
---------------------

**Table of Contents**

[9.1. Interface Declarations](jls-9.html#jls-9.1)
[9.1.1. Interface Modifiers](jls-9.html#jls-9.1.1)
[9.1.1.1. `abstract` Interfaces](jls-9.html#jls-9.1.1.1)
[9.1.1.2. `strictfp` Interfaces](jls-9.html#jls-9.1.1.2)
[9.1.2. Generic Interfaces and Type Parameters](jls-9.html#jls-9.1.2)
[9.1.3. Superinterfaces and Subinterfaces](jls-9.html#jls-9.1.3)
[9.1.4. Interface Body and Member Declarations](jls-9.html#jls-9.1.4)
[9.2. Interface Members](jls-9.html#jls-9.2)
[9.3. Field (Constant) Declarations](jls-9.html#jls-9.3)
[9.3.1. Initialization of Fields in Interfaces](jls-9.html#jls-9.3.1)
[9.4. Method Declarations](jls-9.html#jls-9.4)
[9.4.1. Inheritance and Overriding](jls-9.html#jls-9.4.1)
[9.4.1.1. Overriding (by Instance Methods)](jls-9.html#jls-9.4.1.1)
[9.4.1.2. Requirements in Overriding](jls-9.html#jls-9.4.1.2)
[9.4.1.3. Inheriting Methods with Override-Equivalent Signatures](jls-9.html#jls-9.4.1.3)
[9.4.2. Overloading](jls-9.html#jls-9.4.2)
[9.4.3. Interface Method Body](jls-9.html#jls-9.4.3)
[9.5. Member Type Declarations](jls-9.html#jls-9.5)
[9.6. Annotation Types](jls-9.html#jls-9.6)
[9.6.1. Annotation Type Elements](jls-9.html#jls-9.6.1)
[9.6.2. Defaults for Annotation Type Elements](jls-9.html#jls-9.6.2)
[9.6.3. Repeatable Annotation Types](jls-9.html#jls-9.6.3)
[9.6.4. Predefined Annotation Types](jls-9.html#jls-9.6.4)
[9.6.4.1. `@Target`](jls-9.html#jls-9.6.4.1)
[9.6.4.2. `@Retention`](jls-9.html#jls-9.6.4.2)
[9.6.4.3. `@Inherited`](jls-9.html#jls-9.6.4.3)
[9.6.4.4. `@Override`](jls-9.html#jls-9.6.4.4)
[9.6.4.5. `@SuppressWarnings`](jls-9.html#jls-9.6.4.5)
[9.6.4.6. `@Deprecated`](jls-9.html#jls-9.6.4.6)
[9.6.4.7. `@SafeVarargs`](jls-9.html#jls-9.6.4.7)
[9.6.4.8. `@Repeatable`](jls-9.html#jls-9.6.4.8)
[9.6.4.9. `@FunctionalInterface`](jls-9.html#jls-9.6.4.9)
[9.7. Annotations](jls-9.html#jls-9.7)
[9.7.1. Normal Annotations](jls-9.html#jls-9.7.1)
[9.7.2. Marker Annotations](jls-9.html#jls-9.7.2)
[9.7.3. Single-Element Annotations](jls-9.html#jls-9.7.3)
[9.7.4. Where Annotations May Appear](jls-9.html#jls-9.7.4)
[9.7.5. Multiple Annotations of the Same Type](jls-9.html#jls-9.7.5)
[9.8. Functional Interfaces](jls-9.html#jls-9.8)
[9.9. Function Types](jls-9.html#jls-9.9)

An interface declaration introduces a new reference type whose members are classes, interfaces, constants, and methods. This type has no instance variables, and typically declares one or more `abstract` methods; otherwise unrelated classes can implement the interface by providing implementations for its `abstract` methods. Interfaces may not be directly instantiated.

A _nested interface_ is any interface whose declaration occurs within the body of another class or interface.

A _top level interface_ is an interface that is not a nested interface.

We distinguish between two kinds of interfaces - normal interfaces and annotation types.

This chapter discusses the common semantics of all interfaces - normal interfaces, both top level ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")) and nested ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")), and annotation types ([¬ß9.6](jls-9.html#jls-9.6 "9.6. Annotation Types")). Details that are specific to particular kinds of interfaces are discussed in the sections dedicated to these constructs.

Programs can use interfaces to make it unnecessary for related classes to share a common `abstract` superclass or to add methods to `Object`.

An interface may be declared to be a _direct extension_ of one or more other interfaces, meaning that it inherits all the member types, instance methods, and constants of the interfaces it extends, except for any members that it may override or hide.

A class may be declared to _directly implement_ one or more interfaces, meaning that any instance of the class implements all the `abstract` methods specified by the interface or interfaces. A class necessarily implements all the interfaces that its direct superclasses and direct superinterfaces do. This (multiple) interface inheritance allows objects to support (multiple) common behaviors without sharing a superclass.

A variable whose declared type is an interface type may have as its value a reference to any instance of a class which implements the specified interface. It is not sufficient that the class happen to implement all the `abstract` methods of the interface; the class or one of its superclasses must actually be declared to implement the interface, or else the class is not considered to implement the interface.

9.1. Interface Declarations
---------------------------

An _interface declaration_ specifies a new named reference type. There are two kinds of interface declarations - _normal interface declarations_ and _annotation type declarations_ ([¬ß9.6](jls-9.html#jls-9.6 "9.6. Annotation Types")).

InterfaceDeclaration:

[NormalInterfaceDeclaration](jls-9.html#jls-NormalInterfaceDeclaration "NormalInterfaceDeclaration")  
[AnnotationTypeDeclaration](jls-9.html#jls-AnnotationTypeDeclaration "AnnotationTypeDeclaration")

NormalInterfaceDeclaration:

{[InterfaceModifier](jls-9.html#jls-InterfaceModifier "InterfaceModifier")} `interface` [Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeParameters](jls-8.html#jls-TypeParameters "TypeParameters")\] \[[ExtendsInterfaces](jls-9.html#jls-ExtendsInterfaces "ExtendsInterfaces")\] [InterfaceBody](jls-9.html#jls-InterfaceBody "InterfaceBody")

The _Identifier_ in an interface declaration specifies the name of the interface.

It is a compile-time error if an interface has the same simple name as any of its enclosing classes or interfaces.

The scope and shadowing of an interface declaration is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

### 9.1.1. Interface Modifiers

An interface declaration may include _interface modifiers_.

InterfaceModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `public` `protected` `private`  
`abstract` `static` `strictfp`

The rules for annotation modifiers on an interface declaration are specified in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear") and [¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type").

The access modifier `public` ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) pertains to every kind of interface declaration.

The access modifiers `protected` and `private` pertain only to member interfaces whose declarations are directly enclosed by a class declaration ([¬ß8.5.1](jls-8.html#jls-8.5.1 "8.5.1. Static Member Type Declarations")).

The modifier `static` pertains only to member interfaces ([¬ß8.5.1](jls-8.html#jls-8.5.1 "8.5.1. Static Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")), not to top level interfaces ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")).

It is a compile-time error if the same keyword appears more than once as a modifier for an interface declaration.

If two or more (distinct) interface modifiers appear in an interface declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for _InterfaceModifier_.

#### 9.1.1.1. `abstract` Interfaces

Every interface is implicitly `abstract`.

This modifier is obsolete and should not be used in new programs.

#### 9.1.1.2. `strictfp` Interfaces

The effect of the `strictfp` modifier is to make all `float` or `double` expressions within the interface declaration be explicitly FP-strict ([¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions")).

This implies that all methods declared in the interface, and all nested types declared in the interface, are implicitly `strictfp`.

### 9.1.2. Generic Interfaces and Type Parameters

An interface is _generic_ if it declares one or more type variables ([¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables")).

These type variables are known as the _type parameters_ of the interface. The type parameter section follows the interface name and is delimited by angle brackets.

The following productions from [¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters") and [¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables") are shown here for convenience:

TypeParameters:

`<` [TypeParameterList](jls-8.html#jls-TypeParameterList "TypeParameterList") `>`

TypeParameterList:

[TypeParameter](jls-4.html#jls-TypeParameter "TypeParameter") {`,` [TypeParameter](jls-4.html#jls-TypeParameter "TypeParameter")}

TypeParameter:

{[TypeParameterModifier](jls-4.html#jls-TypeParameterModifier "TypeParameterModifier")} [Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeBound](jls-4.html#jls-TypeBound "TypeBound")\]

TypeParameterModifier:

[Annotation](jls-9.html#jls-Annotation "Annotation")

TypeBound:

`extends` [TypeVariable](jls-4.html#jls-TypeVariable "TypeVariable")  
`extends` [ClassOrInterfaceType](jls-4.html#jls-ClassOrInterfaceType "ClassOrInterfaceType") {[AdditionalBound](jls-4.html#jls-AdditionalBound "AdditionalBound")}

AdditionalBound:

`&` [InterfaceType](jls-4.html#jls-InterfaceType "InterfaceType")

The rules for annotation modifiers on a type parameter declaration are specified in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear") and [¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type").

In an interface's type parameter section, a type variable T _directly depends_ on a type variable S if S is the bound of T, while T _depends_ on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a interface's type parameter section depends on itself.

The scope and shadowing of an interface's type parameter is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration").

It is a compile-time error to refer to a type parameter of an interface I anywhere in the declaration of a field or type member of I.

A generic interface declaration defines a set of parameterized types ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same interface at run time.

### 9.1.3. Superinterfaces and Subinterfaces

If an `extends` clause is provided, then the interface being declared extends each of the other named interfaces and therefore inherits the member types, methods, and constants of each of the other named interfaces.

These other named interfaces are the _direct superinterfaces_ of the interface being declared.

Any class that `implements` the declared interface is also considered to implement all the interfaces that this interface `extends`.

ExtendsInterfaces:

`extends` [InterfaceTypeList](jls-8.html#jls-InterfaceTypeList "InterfaceTypeList")

The following production from [¬ß8.1.5](jls-8.html#jls-8.1.5 "8.1.5. Superinterfaces") is shown here for convenience:

InterfaceTypeList:

[InterfaceType](jls-4.html#jls-InterfaceType "InterfaceType") {`,` [InterfaceType](jls-4.html#jls-InterfaceType "InterfaceType")}

Each _InterfaceType_ in the `extends` clause of an interface declaration must name an accessible interface type ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")), or a compile-time error occurs.

If an _InterfaceType_ has type arguments, it must denote a well-formed parameterized type ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs.

Given a (possibly generic) interface declaration I`<`F1,...,Fn`>` (_n_ ‚â• 0), the _direct superinterfaces_ of the interface type I`<`F1,...,Fn`>` are the types given in the `extends` clause of the declaration of I, if an `extends` clause is present.

Given a generic interface declaration I`<`F1,...,Fn`>` (_n_ > 0), the _direct superinterfaces_ of the parameterized interface type I`<`T1,...,Tn`>`, where Ti (1 ‚â§ _i_ ‚â§ _n_) is a type, are all types J`<`U1 Œ∏,...,Uk Œ∏`>`, where J`<`U1,...,Uk`>` is a direct superinterface of I`<`F1,...,Fn`>` and Œ∏ is the substitution `[F1:=T1,...,Fn:=Tn]`.

The _superinterface_ relationship is the transitive closure of the direct superinterface relationship. An interface K is a superinterface of interface I if either of the following is true:

*   K is a direct superinterface of I.
*   There exists an interface J such that K is a superinterface of J, and J is a superinterface of I, applying this definition recursively.
    

Interface I is said to be a _subinterface_ of interface K whenever K is a superinterface of I.

While every class is an extension of class `Object`, there is no single interface of which all interfaces are extensions.

An interface I _directly depends_ on a type T if T is mentioned in the `extends` clause of I either as a superinterface or as a qualifier in the fully qualified form of a superinterface name.

An interface I _depends_ on a reference type T if any of the following is true:

*   I directly depends on T.
*   I directly depends on a class C that depends on T ([¬ß8.1.5](jls-8.html#jls-8.1.5 "8.1.5. Superinterfaces")).
*   I directly depends on an interface J that depends on T (using this definition recursively).
    

It is a compile-time error if an interface depends on itself.

If circularly declared interfaces are detected at run time, as interfaces are loaded, then a `ClassCircularityError` is thrown ([¬ß12.2.1](jls-12.html#jls-12.2.1 "12.2.1. The Loading Process")).

### 9.1.4. Interface Body and Member Declarations

The body of an interface may declare members of the interface, that is, fields ([¬ß9.3](jls-9.html#jls-9.3 "9.3. Field (Constant) Declarations")), methods ([¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations")), classes ([¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")), and interfaces ([¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")).

InterfaceBody:

`{` {[InterfaceMemberDeclaration](jls-9.html#jls-InterfaceMemberDeclaration "InterfaceMemberDeclaration")} `}`

InterfaceMemberDeclaration:

[ConstantDeclaration](jls-9.html#jls-ConstantDeclaration "ConstantDeclaration")  
[InterfaceMethodDeclaration](jls-9.html#jls-InterfaceMethodDeclaration "InterfaceMethodDeclaration")  
[ClassDeclaration](jls-8.html#jls-ClassDeclaration "ClassDeclaration")  
[InterfaceDeclaration](jls-9.html#jls-InterfaceDeclaration "InterfaceDeclaration")  
`;`

The scope of a declaration of a member `m` declared in or inherited by an interface type I is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration").

9.2. Interface Members
----------------------

The members of an interface type are:

*   Members declared in the body of the interface ([¬ß9.1.4](jls-9.html#jls-9.1.4 "9.1.4. Interface Body and Member Declarations")).
*   Members inherited from any direct superinterfaces ([¬ß9.1.3](jls-9.html#jls-9.1.3 "9.1.3. Superinterfaces and Subinterfaces")).
*   If an interface has no direct superinterfaces, then the interface implicitly declares a `public` `abstract` member method `m` with signature s, return type r, and `throws` clause t corresponding to each `public` instance method `m` with signature s, return type r, and `throws` clause t declared in `Object`, unless an `abstract` method with the same signature, same return type, and a compatible `throws` clause is explicitly declared by the interface.
    
    It is a compile-time error if the interface explicitly declares such a method `m` in the case where `m` is declared to be `final` in `Object`.
    
    It is a compile-time error if the interface explicitly declares a method with a signature that is override-equivalent ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")) to a `public` method of `Object`, but which has a different return type, or an incompatible `throws` clause, or is not `abstract`.
    

The interface inherits, from the interfaces it extends, all members of those interfaces, except for fields, classes, and interfaces that it hides; `abstract` or default methods that it overrides ([¬ß9.4.1](jls-9.html#jls-9.4.1 "9.4.1. Inheritance and Overriding")); and `static` methods.

Fields, methods, and member types of an interface type may have the same name, since they are used in different contexts and are disambiguated by different lookup procedures ([¬ß6.5](jls-6.html#jls-6.5 "6.5. Determining the Meaning of a Name")). However, this is discouraged as a matter of style.

9.3. Field (Constant) Declarations
----------------------------------

ConstantDeclaration:

{[ConstantModifier](jls-9.html#jls-ConstantModifier "ConstantModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [VariableDeclaratorList](jls-8.html#jls-VariableDeclaratorList "VariableDeclaratorList") `;`

ConstantModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `public`  
`static` `final`

See [¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations") for _UnannType_. The following productions from [¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values") and [¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations") are shown here for convenience:

VariableDeclaratorList:

[VariableDeclarator](jls-8.html#jls-VariableDeclarator "VariableDeclarator") {`,` [VariableDeclarator](jls-8.html#jls-VariableDeclarator "VariableDeclarator")}

VariableDeclarator:

[VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId") \[`=` [VariableInitializer](jls-8.html#jls-VariableInitializer "VariableInitializer")\]

VariableDeclaratorId:

[Identifier](jls-3.html#jls-Identifier "Identifier") \[[Dims](jls-4.html#jls-Dims "Dims")\]

Dims:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]` {{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]`}

VariableInitializer:

[Expression](jls-15.html#jls-Expression "Expression")  
[ArrayInitializer](jls-10.html#jls-ArrayInitializer "ArrayInitializer")

The rules for annotation modifiers on an interface field declaration are specified in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear") and [¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type").

Every field declaration in the body of an interface is implicitly `public`, `static`, and `final`. It is permitted to redundantly specify any or all of these modifiers for such fields.

It is a compile-time error if the same keyword appears more than once as a modifier for a field declaration.

If two or more (distinct) field modifiers appear in a field declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for _ConstantModifier_.

The declared type of a field is denoted by _UnannType_ if no bracket pairs appear in _UnannType_ and _VariableDeclaratorId_, and is specified by [¬ß10.2](jls-10.html#jls-10.2 "10.2. Array Variables") otherwise.

The scope and shadowing of an interface field declaration is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

It is a compile-time error for the body of an interface declaration to declare two fields with the same name.

If the interface declares a field with a certain name, then the declaration of that field is said to _hide_ any and all accessible declarations of fields with the same name in superinterfaces of the interface.

It is possible for an interface to inherit more than one field with the same name. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the interface to refer to any such field by its simple name will result in a compile-time error, because such a reference is ambiguous.

There might be several paths by which the same field declaration might be inherited from an interface. In such a situation, the field is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.

**Example 9.3-1. Ambiguous Inherited Fields**

If two fields with the same name are inherited by an interface because, for example, two of its direct superinterfaces declare fields with that name, then a single ambiguous member results. Any use of this ambiguous member will result in a compile-time error. In the program:

interface BaseColors {
    int RED = 1, GREEN = 2, BLUE = 4;
}
interface RainbowColors extends BaseColors {
    int YELLOW = 3, ORANGE = 5, INDIGO = 6, VIOLET = 7;
}
interface PrintColors extends BaseColors {
    int YELLOW = 8, CYAN = 16, MAGENTA = 32;
}
interface LotsOfColors extends RainbowColors, PrintColors {
    int FUCHSIA = 17, VERMILION = 43, CHARTREUSE = RED+90;
}

the interface `LotsOfColors` inherits two fields named `YELLOW`. This is all right as long as the interface does not contain any reference by simple name to the field `YELLOW`. (Such a reference could occur within a variable initializer for a field.)

Even if interface `PrintColors` were to give the value `3` to `YELLOW` rather than the value `8`, a reference to field `YELLOW` within interface `LotsOfColors` would still be considered ambiguous.

  

**Example 9.3-2. Multiply Inherited Fields**

If a single field is inherited multiple times from the same interface because, for example, both this interface and one of this interface's direct superinterfaces extend the interface that declares the field, then only a single member results. This situation does not in itself cause a compile-time error.

In the previous example, the fields `RED`, `GREEN`, and `BLUE` are inherited by interface `LotsOfColors` in more than one way, through interface `RainbowColors` and also through interface `PrintColors`, but the reference to field `RED` in interface `LotsOfColors` is not considered ambiguous because only one actual declaration of the field `RED` is involved.

  

### 9.3.1. Initialization of Fields in Interfaces

Every declarator in a field declaration of an interface must have a variable initializer, or a compile-time error occurs.

The initializer need not be a constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")).

It is a compile-time error if the initializer of an interface field uses the simple name of the same field or another field whose declaration occurs textually later in the same interface.

It is a compile-time error if the keyword `this` ([¬ß15.8.3](jls-15.html#jls-15.8.3 "15.8.3. this")) or the keyword `super` ([¬ß15.11.2](jls-15.html#jls-15.11.2 "15.11.2. Accessing Superclass Members using super"), [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")) occurs in the initializer of an interface field, unless the occurrence is within the body of an anonymous class ([¬ß15.9.5](jls-15.html#jls-15.9.5 "15.9.5. Anonymous Class Declarations")).

At run time, the initializer is evaluated and the field assignment performed exactly once, when the interface is initialized ([¬ß12.4.2](jls-12.html#jls-12.4.2 "12.4.2. Detailed Initialization Procedure")).

Note that interface fields that are constant variables ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")) are initialized before other interface fields. This also applies to `static` fields that are constant variables in classes ([¬ß8.3.2](jls-8.html#jls-8.3.2 "8.3.2. Field Initialization")). Such fields will never be observed to have their default initial values ([¬ß4.12.5](jls-4.html#jls-4.12.5 "4.12.5. Initial Values of Variables")), even by devious programs.

**Example 9.3.1-1.&**nbsp;Forward Reference to a Field

interface Test {
    float f = j;
    int   j = 1;
    int   k = k + 1;
}

This program causes two compile-time errors, because `j` is referred to in the initialization of `f` before `j` is declared, and because the initialization of `k` refers to `k` itself.

  

9.4. Method Declarations
------------------------

InterfaceMethodDeclaration:

{[InterfaceMethodModifier](jls-9.html#jls-InterfaceMethodModifier "InterfaceMethodModifier")} [MethodHeader](jls-8.html#jls-MethodHeader "MethodHeader") [MethodBody](jls-8.html#jls-MethodBody "MethodBody")

InterfaceMethodModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `public`  
`abstract` `default` `static` `strictfp`

The following productions from [¬ß8.4](jls-8.html#jls-8.4 "8.4. Method Declarations"), [¬ß8.4.5](jls-8.html#jls-8.4.5 "8.4.5. Method Result"), and [¬ß8.4.7](jls-8.html#jls-8.4.7 "8.4.7. Method Body") are shown here for convenience:

MethodHeader:

[Result](jls-8.html#jls-Result "Result") [MethodDeclarator](jls-8.html#jls-MethodDeclarator "MethodDeclarator") \[[Throws](jls-8.html#jls-Throws "Throws")\]  
[TypeParameters](jls-8.html#jls-TypeParameters "TypeParameters") {[Annotation](jls-9.html#jls-Annotation "Annotation")} [Result](jls-8.html#jls-Result "Result") [MethodDeclarator](jls-8.html#jls-MethodDeclarator "MethodDeclarator") \[[Throws](jls-8.html#jls-Throws "Throws")\]

Result:

[UnannType](jls-8.html#jls-UnannType "UnannType")  
`void`

MethodDeclarator:

[Identifier](jls-3.html#jls-Identifier "Identifier") `(` \[[FormalParameterList](jls-8.html#jls-FormalParameterList "FormalParameterList")\] `)` \[[Dims](jls-4.html#jls-Dims "Dims")\]

MethodBody:

[Block](jls-14.html#jls-Block "Block")  
`;`

The rules for annotation modifiers on an interface method declaration are specified in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear") and [¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type").

Every method declaration in the body of an interface is implicitly `public` ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")). It is permitted, but discouraged as a matter of style, to redundantly specify the `public` modifier for a method declaration in an interface.

A _default method_ is a method that is declared in an interface with the `default` modifier; its body is always represented by a block. It provides a default implementation for any class that implements the interface without overriding the method. Default methods are distinct from concrete methods ([¬ß8.4.3.1](jls-8.html#jls-8.4.3.1 "8.4.3.1. abstract Methods")), which are declared in classes.

An interface can declare `static` methods, which are invoked without reference to a particular object.

It is a compile-time error to use the name of a type parameter of any surrounding declaration in the header or body of a `static` method of an interface.

The effect of the `strictfp` modifier is to make all `float` or `double` expressions within the body of a default or `static` method be explicitly FP-strict ([¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions")).

An interface method lacking a `default` modifier or a `static` modifier is implicitly `abstract`, so its body is represented by a semicolon, not a block. It is permitted, but discouraged as a matter of style, to redundantly specify the `abstract` modifier for such a method declaration.

It is a compile-time error if the same keyword appears more than once as a modifier for a method declaration in an interface.

It is a compile-time error if a method is declared with more than one of the modifiers `abstract`, `default`, or `static`.

It is a compile-time error if an `abstract` method declaration contains the keyword `strictfp`.

It is a compile-time error for the body of an interface to declare, explicitly or implicitly, two methods with override-equivalent signatures ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")). However, an interface may inherit several `abstract` methods with such signatures ([¬ß9.4.1](jls-9.html#jls-9.4.1 "9.4.1. Inheritance and Overriding")).

A method in an interface may be generic. The rules for type parameters of a generic method in an interface are the same as for a generic method in a class ([¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods")).

### 9.4.1. Inheritance and Overriding

An interface I _inherits_ from its direct superinterfaces all `abstract` and default methods `m` for which all of the following are true:

*   `m` is a member of a direct superinterface, J, of I.
*   No method declared in I has a signature that is a subsignature ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")) of the signature of `m`.
*   There exists no method `m`' that is a member of a direct superinterface, J', of I (`m` distinct from `m`', J distinct from J'), such that `m`' overrides from J' the declaration of the method `m`.
    

Note that methods are overridden on a signature-by-signature basis. If, for example, an interface declares two `public` methods with the same name ([¬ß9.4.2](jls-9.html#jls-9.4.2 "9.4.2. Overloading")), and a subinterface overrides one of them, the subinterface still inherits the other method.

The third clause above prevents a subinterface from re-inheriting a method that has already been overridden by another of its superinterfaces. For example, in this program:

interface Top {
    default String name() { return "unnamed"; }
}
interface Left extends Top {
    default String name() { return getClass().getName(); }
}
interface Right extends Top {}

interface Bottom extends Left, Right {}

`Right` inherits `name()` from `Top`, but `Bottom` inherits `name()` from `Left`, not `Right`. This is because `name()` from `Left` overrides the declaration of `name()` in `Top`.

An interface does not inherit `static` methods from its superinterfaces.

If an interface I declares a `static` method `m`, and the signature of `m` is a subsignature of an instance method `m`' in a superinterface of I, and `m`' would otherwise be accessible to code in I, then a compile-time error occurs.

In essence, a `static` method in an interface cannot "hide" an instance method in a superinterface. This is similar to the rule in [¬ß8.4.8.2](jls-8.html#jls-8.4.8.2 "8.4.8.2. Hiding (by Class Methods)") whereby a `static` method in a class cannot hide an instance method in a superclass or superinterface. Note that the rule in [¬ß8.4.8.2](jls-8.html#jls-8.4.8.2 "8.4.8.2. Hiding (by Class Methods)") speaks of a class that "declares or inherits a `static` method", whereas the rule above speaks only of an interface that "declares a `static` method", since an interface cannot inherit a `static` method. Also note that the rule in [¬ß8.4.8.2](jls-8.html#jls-8.4.8.2 "8.4.8.2. Hiding (by Class Methods)") allows hiding of both instance and `static` methods in superclasses/superinterfaces, whereas the rule above considers only instance methods in superinterfaces.

#### 9.4.1.1. Overriding (by Instance Methods)

An instance method `m1`, declared in or inherited by an interface I, _overrides from I_ another instance method, `m2`, declared in interface J, iff both of the following are true:

*   I is a subinterface of J.
*   The signature of `m1` is a subsignature ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")) of the signature of `m2`.
    

The presence or absence of the `strictfp` modifier has absolutely no effect on the rules for overriding methods. For example, it is permitted for a method that is not FP-strict to override an FP-strict method and it is permitted for an FP-strict method to override a method that is not FP-strict.

An overridden default method can be accessed by using a method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")) that contains the keyword `super` qualified by a superinterface name.

#### 9.4.1.2. Requirements in Overriding

The relationship between the return type of an interface method and the return types of any overridden interface methods is specified in [¬ß8.4.8.3](jls-8.html#jls-8.4.8.3 "8.4.8.3. Requirements in Overriding and Hiding").

The relationship between the `throws` clause of an interface method and the `throws` clauses of any overridden interface methods are specified in [¬ß8.4.8.3](jls-8.html#jls-8.4.8.3 "8.4.8.3. Requirements in Overriding and Hiding").

The relationship between the signature of an interface method and the signatures of overridden interface methods are specified in [¬ß8.4.8.3](jls-8.html#jls-8.4.8.3 "8.4.8.3. Requirements in Overriding and Hiding").

It is a compile-time error if a default method is override-equivalent with a non-`private` method of the class `Object`, because any class implementing the interface will inherit its own implementation of the method.

The prohibition against declaring one of the `Object` methods as a default method may be surprising. There are, after all, cases like `java.util.List` in which the behavior of `toString` and `equals` are precisely defined. The motivation becomes clearer, however, when some broader design decisions are understood:

*   First, methods inherited from a superclass are allowed to override methods inherited from superinterfaces ([¬ß8.4.8.1](jls-8.html#jls-8.4.8.1 "8.4.8.1. Overriding (by Instance Methods)")). So, every implementing class would automatically override an interface's `toString` default. This is longstanding behavior in the Java programming language. It is not something we wish to change with the design of default methods, because that would conflict with the goal of allowing interfaces to unobtrusively evolve, only providing default behavior when a class doesn't already have it through the class hierarchy.
*   Second, interfaces do _not_ inherit from `Object`, but rather implicitly declare many of the same methods as `Object` ([¬ß9.2](jls-9.html#jls-9.2 "9.2. Interface Members")). So, there is no common ancestor for the `toString` declared in `Object` and the `toString` declared in an interface. At best, if both were candidates for inheritance by a class, they would conflict. Working around this problem would require awkward commingling of the class and interface inheritance trees.
*   Third, use cases for declaring `Object` methods in interfaces typically assume a linear interface hierarchy; the feature does not generalize very well to multiple inheritance scenarios.
*   Fourth, the `Object` methods are so fundamental that it seems dangerous to allow an arbitrary superinterface to silently add a default method that changes their behavior.
    

An interface is free, however, to define another method that provides behavior useful for classes that override the `Object` methods. For example, the `java.util.List` interface could declare an `elementString` method that produces the string described by the contract of `toString`; implementors of `toString` in classes could then delegate to this method.

#### 9.4.1.3. Inheriting Methods with Override-Equivalent Signatures

It is possible for an interface to inherit several methods with override-equivalent signatures ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")).

If an interface I inherits a default method whose signature is override-equivalent with another method inherited by I, then a compile-time error occurs. (This is the case whether the other method is `abstract` or `default`.)

Otherwise, all the inherited methods are `abstract`, and the interface is considered to inherit all the methods.

One of the inherited methods must be return-type-substitutable for every other inherited method, or else a compile-time error occurs. (The `throws` clauses do not cause errors in this case.)

There might be several paths by which the same method declaration is inherited from an interface. This fact causes no difficulty and never, of itself, results in a compile-time error.

Naturally, when two different default methods with matching signatures are inherited by a subinterface, there is a behavioral conflict. We actively detect this conflict and notify the developer with an error, rather than waiting for the problem to arise when a concrete class is compiled. The error can be avoided by declaring a new method that overrides, and thus prevents the inheritance of, all conflicting methods.

Similarly, when an abstract and a default method with matching signatures are inherited, we produce an error. In this case, it would be possible to give priority to one or the other - perhaps we would assume that the default method provides a reasonable implementation for the abstract method, too. But this is risky, since other than the coincidental name and signature, we have no reason to believe that the default method behaves consistently with the abstract method's contract - the default method may not have even existed when the subinterface was originally developed. It is safer in this situation to ask the user to actively assert that the default implementation is appropriate (via an overriding declaration).

In contrast, the longstanding behavior for inherited concrete methods in classes is that they override abstract methods declared in interfaces (see [¬ß8.4.8](jls-8.html#jls-8.4.8 "8.4.8. Inheritance, Overriding, and Hiding")). The same argument about potential contract violation applies here, but in this case there is an inherent imbalance between classes and interfaces. We prefer, in order to preserve the independent nature of class hierarchies, to minimize class-interface clashes by simply giving priority to concrete methods.

### 9.4.2. Overloading

If two methods of an interface (whether both declared in the same interface, or both inherited by an interface, or one declared and one inherited) have the same name but different signatures that are not override-equivalent ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")), then the method name is said to be _overloaded_.

This fact causes no difficulty and never of itself results in a compile-time error. There is no required relationship between the return types or between the `throws` clauses of two methods with the same name but different signatures that are not override-equivalent.

**Example 9.4.2-1. Overloading an `abstract` Method Declaration**

interface PointInterface {
    void move(int dx, int dy);
}
interface RealPointInterface extends PointInterface {
    void move(float dx, float dy);
    void move(double dx, double dy);
}

Here, the method named `move` is overloaded in interface `RealPointInterface` with three different signatures, two of them declared and one inherited. Any non-`abstract` class that implements interface `RealPointInterface` must provide implementations of all three method signatures.

  

### 9.4.3. Interface Method Body

A default method has a block body. This block of code provides an implementation of the method in the event that a class implements the interface but does not provide its own implementation of the method.

A `static` method also has a block body, which provides the implementation of the method.

It is a compile-time error if an interface method declaration is `abstract` (explicitly or implicitly) and has a block for its body.

It is a compile-time error if an interface method declaration is `default` or `static` and has a semicolon for its body.

It is a compile-time error for the body of a `static` method to attempt to reference the current object using the keyword `this` or the keyword `super`.

The rules for `return` statements in a method body are specified in [¬ß14.17](jls-14.html#jls-14.17 "14.17. The return Statement").

If a method is declared to have a return type ([¬ß8.4.5](jls-8.html#jls-8.4.5 "8.4.5. Method Result")), then a compile-time error occurs if the body of the method can complete normally ([¬ß14.1](jls-14.html#jls-14.1 "14.1. Normal and Abrupt Completion of Statements")).

9.5. Member Type Declarations
-----------------------------

Interfaces may contain member type declarations ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations")).

A member type declaration in an interface is implicitly `public` and `static`. It is permitted to redundantly specify either or both of these modifiers.

It is a compile-time error if a member type declaration in an interface has the modifier `protected` or `private`.

It is a compile-time error if the same keyword appears more than once as a modifier for a member type declaration in an interface.

If an interface declares a member type with a certain name, then the declaration of that type is said to _hide_ any and all accessible declarations of member types with the same name in superinterfaces of the interface.

An interface inherits from its direct superinterfaces all the non-`private` member types of the superinterfaces that are both accessible to code in the interface and not hidden by a declaration in the interface.

An interface may inherit two or more type declarations with the same name. It is a compile-time error to attempt to refer to any ambiguously inherited class or interface by its simple name.

If the same type declaration is inherited from an interface by multiple paths, the class or interface is considered to be inherited only once; it may be referred to by its simple name without ambiguity.

9.6. Annotation Types
---------------------

An _annotation type declaration_ specifies a new _annotation type_, a special kind of interface type. To distinguish an annotation type declaration from a normal interface declaration, the keyword `interface` is preceded by an at-sign (`@`).

AnnotationTypeDeclaration:

{[InterfaceModifier](jls-9.html#jls-InterfaceModifier "InterfaceModifier")} `@` `interface` [Identifier](jls-3.html#jls-Identifier "Identifier") [AnnotationTypeBody](jls-9.html#jls-AnnotationTypeBody "AnnotationTypeBody")

Note that the at-sign (`@`) and the keyword `interface` are distinct tokens. It is possible to separate them with whitespace, but this is discouraged as a matter of style.

The rules for annotation modifiers on an annotation type declaration are specified in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear") and [¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type").

The _Identifier_ in an annotation type declaration specifies the name of the annotation type.

It is a compile-time error if an annotation type has the same simple name as any of its enclosing classes or interfaces.

The direct superinterface of every annotation type is `java.lang.annotation.Annotation`.

By virtue of the _AnnotationTypeDeclaration_ syntax, an annotation type declaration cannot be generic, and no `extends` clause is permitted.

A consequence of the fact that an annotation type cannot explicitly declare a superclass or superinterface is that a subclass or subinterface of an annotation type is never itself an annotation type. Similarly, `java.lang.annotation.Annotation` is not itself an annotation type.

An annotation type inherits several members from `java.lang.annotation.Annotation`, including the implicitly declared methods corresponding to the instance methods of `Object`, yet these methods do not define elements of the annotation type ([¬ß9.6.1](jls-9.html#jls-9.6.1 "9.6.1. Annotation Type Elements")).

Because these methods do not define elements of the annotation type, it is illegal to use them in annotations of that type ([¬ß9.7](jls-9.html#jls-9.7 "9.7. Annotations")). Without this rule, we could not ensure that elements were of the types representable in annotations, or that accessor methods for them would be available.

Unless explicitly modified herein, all of the rules that apply to normal interface declarations apply to annotation type declarations.

For example, annotation types share the same namespace as normal class and interface types; and annotation type declarations are legal wherever interface declarations are legal, and have the same scope and accessibility.

### 9.6.1. Annotation Type Elements

The body of an annotation type may contain method declarations, each of which defines an _element_ of the annotation type. An annotation type has no elements other than those defined by the methods it explicitly declares.

AnnotationTypeBody:

`{` {[AnnotationTypeMemberDeclaration](jls-9.html#jls-AnnotationTypeMemberDeclaration "AnnotationTypeMemberDeclaration")} `}`

AnnotationTypeMemberDeclaration:

[AnnotationTypeElementDeclaration](jls-9.html#jls-AnnotationTypeElementDeclaration "AnnotationTypeElementDeclaration")  
[ConstantDeclaration](jls-9.html#jls-ConstantDeclaration "ConstantDeclaration")  
[ClassDeclaration](jls-8.html#jls-ClassDeclaration "ClassDeclaration")  
[InterfaceDeclaration](jls-9.html#jls-InterfaceDeclaration "InterfaceDeclaration")  
`;`

AnnotationTypeElementDeclaration:

{[AnnotationTypeElementModifier](jls-9.html#jls-AnnotationTypeElementModifier "AnnotationTypeElementModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [Identifier](jls-3.html#jls-Identifier "Identifier") `(` `)` \[[Dims](jls-4.html#jls-Dims "Dims")\] \[[DefaultValue](jls-9.html#jls-DefaultValue "DefaultValue")\] `;`

AnnotationTypeElementModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `public`  
`abstract`

By virtue of the _AnnotationTypeElementDeclaration_ production, a method declaration in an annotation type declaration cannot have formal parameters, type parameters, or a `throws` clause. The following production from [¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values") is shown here for convenience:

Dims:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]` {{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]`}

By virtue of the _AnnotationTypeElementModifier_ production, a method declaration in an annotation type declaration cannot be `default` or `static`. Thus, an annotation type cannot declare the same variety of methods as a normal interface type. Note that it is still possible for an annotation type to inherit a default method from its implicit superinterface, `java.lang.annotation.Annotation`, though no such default method exists as of Java SE 8.

By convention, the only _AnnotationTypeElementModifier_s that should be present on an annotation type element are annotations.

The return type of a method declared in an annotation type must be one of the following, or a compile-time error occurs:

*   A primitive type
*   `String`
*   `Class` or an invocation of `Class` ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types"))
*   An enum type
*   An annotation type
*   An array type whose component type is one of the preceding types ([¬ß10.1](jls-10.html#jls-10.1 "10.1. Array Types")).
    

This rule precludes elements with nested array types, such as:

@interface Verboten {
    String\[\]\[\] value();
}

The declaration of a method that returns an array is allowed to place the bracket pair that denotes the array type after the empty formal parameter list. This syntax is supported for compatibility with early versions of the Java programming language. It is very strongly recommended that this syntax is not used in new code.

It is a compile-time error if any method declared in an annotation type has a signature that is override-equivalent to that of any `public` or `protected` method declared in class `Object` or in the interface `java.lang.annotation.Annotation`.

It is a compile-time error if an annotation type declaration T contains an element of type T, either directly or indirectly.

For example, this is illegal:

@interface SelfRef { SelfRef value(); }

and so is this:

@interface Ping { Pong value(); }
@interface Pong { Ping value(); }

An annotation type with no elements is called a _marker annotation type_.

An annotation type with one element is called a _single-element annotation type_.

By convention, the name of the sole element in a single-element annotation type is `value`. Linguistic support for this convention is provided by single-element annotations ([¬ß9.7.3](jls-9.html#jls-9.7.3 "9.7.3. Single-Element Annotations")).

**Example 9.6.1-1. Annotation Type Declaration**

The following annotation type declaration defines an annotation type with several elements:

/\*\*
 \* Describes the "request-for-enhancement" (RFE)
 \* that led to the presence of the annotated API element.
 \*/
@interface RequestForEnhancement {
    int    id();        // Unique ID number associated with RFE
    String synopsis();  // Synopsis of RFE
    String engineer();  // Name of engineer who implemented RFE
    String date();      // Date RFE was implemented
}

  

**Example 9.6.1-2. Marker Annotation Type Declaration**

The following annotation type declaration defines a marker annotation type:

/\*\*
 \* An annotation with this type indicates that the 
 \* specification of the annotated API element is 
 \* preliminary and subject to change.
 \*/
@interface Preliminary {}

  

**Example 9.6.1-3. Single-Element Annotation Type Declarations**

The convention that a single-element annotation type defines an element called `value` is illustrated in the following annotation type declaration:

/\*\*
 \* Associates a copyright notice with the annotated API element.
 \*/
@interface Copyright {
    String value();
}

The following annotation type declaration defines a single-element annotation type whose sole element has an array type:

/\*\*
 \* Associates a list of endorsers with the annotated class.
 \*/
@interface Endorsers {
    String\[\] value();
}

The following annotation type declaration shows a `Class`\-typed element whose value is constrained by a bounded wildcard:

interface Formatter {}

// Designates a formatter to pretty-print the annotated class
@interface PrettyPrinter {
    Class<? extends Formatter> value();
}

The following annotation type declaration contains an element whose type is also an annotation type:

/\*\*
 \* Indicates the author of the annotated program element.
 \*/
@interface Author {
    Name value();
}
/\*\*
 \* A person's name.  This annotation type is not designed
 \* to be used directly to annotate program elements, but to
 \* define elements of other annotation types.
 \*/
@interface Name {
    String first();
    String last();
}

The grammar for annotation type declarations permits other element declarations besides method declarations. For example, one might choose to declare a nested enum for use in conjunction with an annotation type:

@interface Quality {
    enum Level { BAD, INDIFFERENT, GOOD }
    Level value();
}

  

### 9.6.2. Defaults for Annotation Type Elements

An annotation type element may have a _default value_, specified by following the element's (empty) parameter list with the keyword `default` and an _ElementValue_ ([¬ß9.7.1](jls-9.html#jls-9.7.1 "9.7.1. Normal Annotations")).

DefaultValue:

`default` [ElementValue](jls-9.html#jls-ElementValue "ElementValue")

It is a compile-time error if the type of the element is not commensurate ([¬ß9.7](jls-9.html#jls-9.7 "9.7. Annotations")) with the default value specified.

Default values are not compiled into annotations, but rather applied dynamically at the time annotations are read. Thus, changing a default value affects annotations even in classes that were compiled before the change was made (presuming these annotations lack an explicit value for the defaulted element).

**Example 9.6.2-1. Annotation Type Declaration With Default Values**

Here is a refinement of the `RequestForEnhancement` annotation type from [¬ß9.6.1](jls-9.html#jls-9.6.1 "9.6.1. Annotation Type Elements"):

@interface RequestForEnhancementDefault {
    int    id();       // No default - must be specified in 
                       // each annotation
    String synopsis(); // No default - must be specified in 
                       // each annotation
    String engineer()  default "\[unassigned\]";
    String date()      default "\[unimplemented\]";
}

  

### 9.6.3. Repeatable Annotation Types

An annotation type T is _repeatable_ if its declaration is (meta-)annotated with an `@Repeatable` annotation ([¬ß9.6.4.8](jls-9.html#jls-9.6.4.8 "9.6.4.8. @Repeatable")) whose `value` element indicates a _containing annotation type of T_.

An annotation type TC is a _containing annotation type of T_ if all of the following are true:10-A"> TC declares a `value()` method whose return type is T`[]`.

*   Any methods declared by TC other than `value()` have a default value.
*   TC is retained for at least as long as T, where retention is expressed explicitly or implicitly with the `@Retention` annotation ([¬ß9.6.4.2](jls-9.html#jls-9.6.4.2 "9.6.4.2. @Retention")). Specifically:
    
    *   If the retention of TC is `java.lang.annotation.RetentionPolicy.SOURCE`, then the retention of T is `java.lang.annotation.RetentionPolicy.SOURCE`.
        
    *   If the retention of TC is `java.lang.annotation.RetentionPolicy.CLASS`, then the retention of T is either `java.lang.annotation.RetentionPolicy.CLASS` or `java.lang.annotation.RetentionPolicy.SOURCE`.
        
    *   If the retention of TC is `java.lang.annotation.RetentionPolicy.RUNTIME`, then the retention of T is `java.lang.annotation.RetentionPolicy.SOURCE`, `java.lang.annotation.RetentionPolicy.CLASS`, or `java.lang.annotation.RetentionPolicy.RUNTIME`.
        
*   T is applicable to at least the same kinds of program element as TC ([¬ß9.6.4.1](jls-9.html#jls-9.6.4.1 "9.6.4.1. @Target")). Specifically, if the kinds of program element where T is applicable are denoted by the set `m1`, and the kinds of program element where TC is applicable are denoted by the set `m2`, then each kind in `m2` must occur in `m1`, except that:
    
    *   If the kind in `m2` is `java.lang.annotation.ElementType.ANNOTATION_TYPE`, then at least one of `java.lang.annotation.ElementType.ANNOTATION_TYPE` or `java.lang.annotation.ElementType.TYPE` or `java.lang.annotation.ElementType.TYPE_USE` must occur in `m1`.
        
    *   If the kind in `m2` is `java.lang.annotation.ElementType.TYPE`, then at least one of `java.lang.annotation.ElementType.TYPE` or `java.lang.annotation.ElementType.TYPE_USE` must occur in `m1`.
        
    *   If the kind in `m2` is `java.lang.annotation.ElementType.TYPE_PARAMETER`, then at least one of `java.lang.annotation.ElementType.TYPE_PARAMETER` or `java.lang.annotation.ElementType.TYPE_USE` must occur in `m1`.
        
    
    This clause implements the policy that an annotation type may be _repeatable_ on only some of the kinds of program element where it is _applicable_.
*   If the declaration of T has a (meta-)annotation that corresponds to `java.lang.annotation.Documented`, then the declaration of TC must have a (meta-)annotation that corresponds to `java.lang.annotation.Documented`.
    
    Note that it is permissible for TC to be `@Documented` while T is not `@Documented`.
*   If the declaration of T has a (meta-)annotation that corresponds to `java.lang.annotation.Inherited`, then the declaration of TC must have a (meta)-annotation that corresponds to `java.lang.annotation.Inherited`.
    
    Note that it is permissible for TC to be `@Inherited` while T is not `@Inherited`.
    

It is a compile-time error if an annotation type T is (meta-)annotated with an `@Repeatable` annotation whose `value` element indicates a type which is not a containing annotation type of T.

**Example 9.6.3-1. Ill-formed Containing Annotation Type**

Consider the following declarations:

@Repeatable(FooContainer.class)
@interface Foo {}

@interface FooContainer { Object\[\] value(); }

Compiling the `Foo` declaration produces a compile-time error because `Foo` uses `@Repeatable` to attempt to specify `FooContainer` as its containing annotation type, but `FooContainer` is not in fact a containing annotation type of `Foo`. (The return type of `FooContainer.value()` is not `Foo``[]`.)

  

The `@Repeatable` annotation cannot be repeated, so only one containing annotation type can be specified by a repeatable annotation type.

Allowing more than one containing annotation type to be specified would cause an undesirable choice at compile time, when multiple annotations of the repeatable annotation type are logically replaced with a container annotation ([¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type")).

An annotation type can be the containing annotation type of at most one annotation type.

This is implied by the requirement that if the declaration of an annotation type T specifies a containing annotation type of TC, then the `value()` method of TC has a return type involving T, specifically T`[]`.

An annotation type cannot specify itself as its containing annotation type.

This is implied by the requirement on the `value()` method of the containing annotation type. Specifically, if an annotation type A specified itself (via `@Repeatable`) as its containing annotation type, then the return type of A's `value()` method would have to be A`[]`; but this would cause a compile-time error since an annotation type cannot refer to itself in its elements ([¬ß9.6.1](jls-9.html#jls-9.6.1 "9.6.1. Annotation Type Elements")). More generally, two annotation types cannot specify each other to be their containing annotation types, because cyclic annotation type declarations are illegal.

An annotation type TC may be the containing annotation type of some annotation type T while also having its own containing annotation type TC '. That is, a containing annotation type may itself be a repeatable annotation type.

**Example 9.6.3-2. Restricting Where Annotations May Repeat**

An annotation whose type declaration indicates a target of `java.lang.annotation.ElementType.TYPE` can appear in at least as many locations as an annotation whose type declaration indicates a target of `java.lang.annotation.ElementType.ANNOTATION_TYPE`. For example, given the following declarations of repeatable and containing annotation types:

@Target(ElementType.TYPE)
@Repeatable(FooContainer.class)
@interface Foo {}

@Target(ElementType.ANNOTATION\_TYPE)
@Interface FooContainer {
    Foo\[\] value();
}

`@Foo` can appear on any type declaration while `@FooContainer` can appear on only annotation type declarations. Therefore, the following annotation type declaration is legal:

@Foo @Foo
@interface X {}

while the following interface declaration is illegal:

@Foo @Foo
interface X {}

More broadly, if `Foo` is a repeatable annotation type and `FooContainer` is its containing annotation type, then:

*   If `Foo` has no `@Target` meta-annotation and `FooContainer` has no `@Target` meta-annotation, then `@Foo` may be repeated on any program element which supports annotations.
*   If `Foo` has no `@Target` meta-annotation but `FooContainer` has an `@Target` meta-annotation, then `@Foo` may only be repeated on program elements where `@FooContainer` may appear.
*   If `Foo` has an `@Target` meta-annotation, then in the judgment of the designers of the Java programming language, `FooContainer` must be declared with knowledge of the `Foo`'s applicability. Specifically, the kinds of program element where `FooContainer` may appear must logically be the same as, or a subset of, `Foo`'s kinds.
    
    For example, if `Foo` is applicable to field and method declarations, then `FooContainer` may legitimately serve as `Foo`'s containing annotation type if `FooContainer` is applicable to just field declarations (preventing `@Foo` from being repeated on method declarations). But if `FooContainer` is applicable only to formal parameter declarations, then `FooContainer` was a poor choice of containing annotation type by `Foo` because `@FooContainer` cannot be implicitly declared on some program elements where `@Foo` is repeated.
    
    Similarly, if `Foo` is applicable to field and method declarations, then `FooContainer` cannot legitimately serve as `Foo`'s containing annotation type if `FooContainer` is applicable to field and parameter declarations. While it would be possible to take the intersection of the program elements and make `Foo` repeatable on field declarations only, the presence of additional program elements for `FooContainer` indicates that `FooContainer` was not designed as a containing annotation type for `Foo`. It would therefore be dangerous for `Foo` to rely on it.
    

  

**Example 9.6.3-3. A Repeatable Containing Annotation Type**

The following declarations are legal:

// Foo: Repeatable annotation type
@Repeatable(FooContainer.class)
@interface Foo { int value(); }

// FooContainer: Containing annotation type of Foo
//               Also a repeatable annotation type itself
@Repeatable(FooContainerContainer.class)
@interface FooContainer { Foo\[\] value(); }

// FooContainerContainer: Containing annotation type of FooContainer
@interface FooContainerContainer { FooContainer\[\] value(); }

Thus, an annotation whose type is a containing annotation type may itself be repeated:

@FooContainer({@Foo(1)}) @FooContainer({@Foo(2)})
class A {}

An annotation type which is both repeatable and containing is subject to the rules on mixing annotations of repeatable annotation type with annotations of containing annotation type ([¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type")). For example, it is not possible to write multiple `@Foo` annotations alongside multiple `@FooContainer` annotations, nor is it possible to write multiple `@FooContainer` annotations alongside multiple `@FooContainerContainer` annotations. However, if the `FooContainerContainer` type was itself repeatable, then it would be possible to write multiple `@Foo` annotations alongside multiple `@FooContainerContainer` annotations.

  

### 9.6.4. Predefined Annotation Types

Several annotation types are predefined in the libraries of the Java SE platform. Some of these predefined annotation types have special semantics. These semantics are specified in this section. This section does not provide a complete specification for the predefined annotations contained here in; that is the role of the appropriate API specifications. Only those semantics that require special behavior on the part of a Java compiler or Java Virtual Machine implementation are specified here.

#### 9.6.4.1. `@Target`

An annotation of type `java.lang.annotation.Target` is used on the declaration of an annotation type T to specify the contexts in which T is _applicable_. `java.lang.annotation.Target` has a single element, `value`, of type `java.lang.annotation.ElementType``[]`, to specify contexts.

Annotation types may be applicable in _declaration contexts_, where annotations apply to declarations, or in _type contexts_, where annotations apply to types used in declarations and expressions.

There are eight declaration contexts, each corresponding to an enum constant of `java.lang.annotation.ElementType`:

1.  Package declarations ([¬ß7.4.1](jls-7.html#jls-7.4.1 "7.4.1. Named Packages"))
    
    Corresponds to `java.lang.annotation.ElementType.PACKAGE`
    
2.  Type declarations: class, interface, enum, and annotation type declarations ([¬ß8.1.1](jls-8.html#jls-8.1.1 "8.1.1. Class Modifiers"), [¬ß9.1.1](jls-9.html#jls-9.1.1 "9.1.1. Interface Modifiers"), [¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations"), [¬ß8.9](jls-8.html#jls-8.9 "8.9. Enum Types"), [¬ß9.6](jls-9.html#jls-9.6 "9.6. Annotation Types"))
    
    Corresponds to `java.lang.annotation.ElementType.TYPE`
    
    Additionally, annotation type declarations correspond to `java.lang.annotation.ElementType.ANNOTATION_TYPE`
    
3.  Method declarations (including elements of annotation types) ([¬ß8.4.3](jls-8.html#jls-8.4.3 "8.4.3. Method Modifiers"), [¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations"), [¬ß9.6.1](jls-9.html#jls-9.6.1 "9.6.1. Annotation Type Elements"))
    
    Corresponds to `java.lang.annotation.ElementType.METHOD`
    
4.  Constructor declarations ([¬ß8.8.3](jls-8.html#jls-8.8.3 "8.8.3. Constructor Modifiers"))
    
    Corresponds to `java.lang.annotation.ElementType.CONSTRUCTOR`
    
5.  Type parameter declarations of generic classes, interfaces, methods, and constructors ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters"), [¬ß9.1.2](jls-9.html#jls-9.1.2 "9.1.2. Generic Interfaces and Type Parameters"), [¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods"), [¬ß8.8.4](jls-8.html#jls-8.8.4 "8.8.4. Generic Constructors"))
    
    Corresponds to `java.lang.annotation.ElementType.TYPE_PARAMETER`
    
6.  Field declarations (including enum constants) ([¬ß8.3.1](jls-8.html#jls-8.3.1 "8.3.1. Field Modifiers"), [¬ß9.3](jls-9.html#jls-9.3 "9.3. Field (Constant) Declarations"), [¬ß8.9.1](jls-8.html#jls-8.9.1 "8.9.1. Enum Constants"))
    
    Corresponds to `java.lang.annotation.ElementType.FIELD`
    
7.  Formal and exception parameter declarations ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"), [¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations"), [¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement"))
    
    Corresponds to `java.lang.annotation.ElementType.PARAMETER`
    
8.  Local variable declarations (including loop variables of `for` statements and resource variables of `try`\-with-resources statements) ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements"), [¬ß14.14.1](jls-14.html#jls-14.14.1 "14.14.1. The basic for Statement"), [¬ß14.14.2](jls-14.html#jls-14.14.2 "14.14.2. The enhanced for statement"), [¬ß14.20.3](jls-14.html#jls-14.20.3 "14.20.3. try-with-resources"))
    
    Corresponds to `java.lang.annotation.ElementType.LOCAL_VARIABLE`
    

There are 16 type contexts ([¬ß4.11](jls-4.html#jls-4.11 "4.11. Where Types Are Used")), all represented by the enum constant `TYPE_USE` of `java.lang.annotation.ElementType`.

It is a compile-time error if the same enum constant appears more than once in the `value` element of an annotation of type `java.lang.annotation.Target`.

If an annotation of type `java.lang.annotation.Target` is not present on the declaration of an annotation type T, then T is applicable in all declaration contexts except type parameter declarations, and in no type contexts.

These contexts are the syntactic locations where annotations were allowed in Java SE 7.

#### 9.6.4.2. `@Retention`

Annotations may be present only in source code, or they may be present in the binary form of a class or interface. An annotation that is present in the binary form may or may not be available at run time via the reflection libraries of the Java SE platform. The annotation type `java.lang.annotation.Retention` is used to choose among these possibilities.

If an annotation `a` corresponds to a type T, and T has a (meta-)annotation `m` that corresponds to `java.lang.annotation.Retention`, then:

*   If `m` has an element whose value is `java.lang.annotation.RetentionPolicy.SOURCE`, then a Java compiler must ensure that `a` is not present in the binary representation of the class or interface in which `a` appears.
*   If `m` has an element whose value is `java.lang.annotation.RetentionPolicy.CLASS` or `java.lang.annotation.RetentionPolicy.RUNTIME`, then a Java compiler must ensure that `a` is represented in the binary representation of the class or interface in which `a` appears, unless `m` annotates a local variable declaration.
    
    An annotation on a local variable declaration is never retained in the binary representation.
    
    In addition, if `m` has an element whose value is `java.lang.annotation.RetentionPolicy.RUNTIME`, the reflection libraries of the Java SE platform must make `a` available at run time.
    

If T does not have a (meta-)annotation `m` that corresponds to `java.lang.annotation.Retention`, then a Java compiler must treat T as if it does have such a meta-annotation `m` with an element whose value is `java.lang.annotation.RetentionPolicy.CLASS`.

#### 9.6.4.3. `@Inherited`

The annotation type `java.lang.annotation.Inherited` is used to indicate that annotations on a class C corresponding to a given annotation type are inherited by subclasses of C.

#### 9.6.4.4. `@Override`

Programmers occasionally overload a method declaration when they mean to override it, leading to subtle problems. The annotation type `Override` supports early detection of such problems.

The classic example concerns the `equals` method. Programmers write the following in class `Foo`:

public boolean equals(Foo that) { ... }

when they mean to write:

public boolean equals(Object that) { ... }

This is perfectly legal, but class `Foo` inherits the `equals` implementation from `Object`, which can cause some very subtle bugs.

If a method declaration is annotated with the annotation `@Override`, but the method does not override or implement a method declared in a supertype, or is not override-equivalent to a `public` method of `Object`, a compile-time error occurs.

This behavior differs from Java SE 5.0, where `@Override` only caused a compile-time error if applied to a method that implemented a method from a superinterface that was not also present in a superclass.

The clause about overriding a `public` method is motivated by use of `@Override` in an interface. Consider the following type declarations:

class Foo     { @Override public int hashCode() {..} }
interface Bar { @Override int hashCode(); }

The use of `@Override` in the class declaration is legal by the first clause, because `Foo.hashCode` overrides `Object.hashCode` ([¬ß8.4.8](jls-8.html#jls-8.4.8 "8.4.8. Inheritance, Overriding, and Hiding")).

For the interface declaration, consider that while an interface does not have `Object` as a supertype, an interface does have `public` `abstract` members that correspond to the `public` members of `Object` ([¬ß9.2](jls-9.html#jls-9.2 "9.2. Interface Members")). If an interface chooses to declare them explicitly (i.e. to declare members that are override-equivalent to `public` methods of `Object`), then the interface is deemed to override them ([¬ß8.4.8](jls-8.html#jls-8.4.8 "8.4.8. Inheritance, Overriding, and Hiding")), and use of `@Override` is allowed.

However, consider an interface that attempts to use `@Override` on a `clone` method: (`finalize` could also be used in this example)

interface Quux { @Override Object clone(); }

Because `Object.clone` is not `public`, there is no member called `clone` implicitly declared in `Quux`. Therefore, the explicit declaration of `clone` in `Quux` is not deemed to "implement" any other method, and it is erroneous to use `@Override`. (The fact that `Quux.clone` is `public` is not relevant.)

In contrast, a class declaration that declares `clone` is simply overriding `Object.clone`, so is able to use `@Override`:

class Beep { @Override protected Object clone() {..} }

#### 9.6.4.5. `@SuppressWarnings`

Java compilers are increasingly capable of issuing helpful "lint-like" warnings. To encourage the use of such warnings, there should be some way to disable a warning in a part of the program when the programmer knows that the warning is inappropriate.

The annotation type `SuppressWarnings` supports programmer control over warnings otherwise issued by a Java compiler. It contains a single element that is an array of `String`.

If a program declaration is annotated with the annotation `@SuppressWarnings``(value = {S1, ..., Sk})`, then a Java compiler must not report any warning identified by one of S1 ... Sk if that warning would have been generated as a result of the annotated declaration or any of its parts.

Unchecked warnings are identified by the string "`unchecked`".

Compiler vendors should document the warning names they support in conjunction with this annotation type. Vendors are encouraged to cooperate to ensure that the same names work across multiple compilers.

#### 9.6.4.6. `@Deprecated`

A program element annotated `@Deprecated` is one that programmers are discouraged from using, typically because it is dangerous, or because a better alternative exists.

A Java compiler must produce a deprecation warning when a type, method, field, or constructor whose declaration is annotated with `@Deprecated` is used (overridden, invoked, or referenced by name) in a construct which is explicitly or implicitly declared, unless:

*   The use is within an entity that is itself annotated with the annotation `@Deprecated`; or
*   The use is within an entity that is annotated to suppress the warning with the annotation `@SuppressWarnings``("deprecation")`; or
*   The use and declaration are both within the same outermost class.
    

Use of the `@Deprecated` annotation on a local variable declaration or on a parameter declaration has no effect.

The only implicitly declared construct that can cause a deprecation warning is a container annotation ([¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type")). Namely, if T is a repeatable annotation type and TC is its containing annotation type, and TC is deprecated, then repeating the `@T` annotation will cause a deprecation warning. The warning is due to the implicit `@TC` container annotation. It is strongly discouraged to deprecate a containing annotation type without deprecating the corresponding repeatable annotation type.

#### 9.6.4.7. `@SafeVarargs`

A variable arity parameter with a non-reifiable element type ([¬ß4.7](jls-4.html#jls-4.7 "4.7. Reifiable Types")) can cause heap pollution ([¬ß4.12.2](jls-4.html#jls-4.12.2 "4.12.2. Variables of Reference Type")) and give rise to compile-time unchecked warnings ([¬ß5.1.9](jls-5.html#jls-5.1.9 "5.1.9. Unchecked Conversion")). Such warnings are uninformative if the body of the variable arity method is well-behaved with respect to the variable arity parameter.

The annotation type `SafeVarargs`, when used to annotate a method or constructor declaration, makes a programmer assertion that prevents a Java compiler from reporting unchecked warnings for the declaration or invocation of a variable arity method or constructor where the compiler would otherwise do so due to the variable arity parameter having a non-reifiable element type.

The annotation `@SafeVarargs` has non-local effects because it suppresses unchecked warnings at method invocation expressions in addition to an unchecked warning pertaining to the declaration of the variable arity method itself ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters")). In contrast, the annotation `@SuppressWarnings``("unchecked")` has local effects because it only suppresses unchecked warnings pertaining to the declaration of a method.

The canonical target for `@SafeVarargs` is a method like `java.util.Collections.addAll`, whose declaration starts with:

public static <T> boolean
  addAll(Collection<? super T> c, T... elements)

The variable arity parameter has declared type `T``[]`, which is non-reifiable. However, the method fundamentally just reads from the input array and adds the elements to a collection, both of which are safe operations with respect to the array. Therefore, any compile-time unchecked warnings at method invocation expressions for `java.util.Collections.addAll` are arguably spurious and uninformative. Applying `@SafeVarargs` to the method declaration prevents generation of these unchecked warnings at the method invocation expressions.

It is a compile-time error if a fixed arity method or constructor declaration is annotated with the annotation `@SafeVarargs`.

It is a compile-time error if a variable arity method declaration that is neither `static` nor `final` is annotated with the annotation `@SafeVarargs`.

Since `@SafeVarargs` is only applicable to `static` methods, `final` instance methods, and constructors, the annotation is not usable where method overriding occurs. Annotation inheritance only works on classes (not methods, interfaces, or constructors), so an `@SafeVarargs`\-style annotation cannot be passed through instance methods in classes or through interfaces.

#### 9.6.4.8. `@Repeatable`

The annotation type `java.lang.annotation.Repeatable` is used on the declaration of a _repeatable annotation type_ to indicate its containing annotation type ([¬ß9.6.3](jls-9.html#jls-9.6.3 "9.6.3. Repeatable Annotation Types")).

Note that an `@Repeatable` meta-annotation on the declaration of T, indicating TC, is _not_ sufficient to make TC the containing annotation type of T. There are numerous well-formedness rules for TC to be considered the containing annotation type of T.

#### 9.6.4.9. `@FunctionalInterface`

The annotation type `FunctionalInterface` is used to indicate that an interface is meant to be a functional interface ([¬ß9.8](jls-9.html#jls-9.8 "9.8. Functional Interfaces")). It facilitates early detection of inappropriate method declarations appearing in or inherited by an interface that is meant to be functional.

It is a compile-time error if an interface declaration is annotated with `@FunctionalInterface` but is not, in fact, a functional interface.

Because some interfaces are functional incidentally, it is not necessary or desirable that all declarations of functional interfaces be annotated with `@FunctionalInterface`.

9.7. Annotations
----------------

An _annotation_ is a marker which associates information with a program construct, but has no effect at run time. An annotation denotes a specific invocation of an annotation type ([¬ß9.6](jls-9.html#jls-9.6 "9.6. Annotation Types")) and usually provides values for the elements of that type.

There are three kinds of annotations. The first kind is the most general, while the other kinds are merely shorthands for the first kind.

Annotation:

[NormalAnnotation](jls-9.html#jls-NormalAnnotation "NormalAnnotation")  
[MarkerAnnotation](jls-9.html#jls-MarkerAnnotation "MarkerAnnotation")  
[SingleElementAnnotation](jls-9.html#jls-SingleElementAnnotation "SingleElementAnnotation")

Normal annotations are described in [¬ß9.7.1](jls-9.html#jls-9.7.1 "9.7.1. Normal Annotations"), marker annotations in [¬ß9.7.2](jls-9.html#jls-9.7.2 "9.7.2. Marker Annotations"), and single element annotations in [¬ß9.7.3](jls-9.html#jls-9.7.3 "9.7.3. Single-Element Annotations"). Annotations may appear at various syntactic locations in a program, as described in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear"). The number of annotations of the same type that may appear at a location is determined by their type, as described in [¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type").

### 9.7.1. Normal Annotations

A _normal annotation_ specifies the name of an annotation type and optionally a list of comma-separated _element-value pairs_. Each pair contains an _element value_ that is associated with an element of the annotation type ([¬ß9.6.1](jls-9.html#jls-9.6.1 "9.6.1. Annotation Type Elements")).

NormalAnnotation:`@` [TypeName](jls-6.html#jls-TypeName "TypeName") `(` \[[ElementValuePairList](jls-9.html#jls-ElementValuePairList "ElementValuePairList")\] `)`

ElementValuePairList:

[ElementValuePair](jls-9.html#jls-ElementValuePair "ElementValuePair") {`,` [ElementValuePair](jls-9.html#jls-ElementValuePair "ElementValuePair")}

ElementValuePair:

[Identifier](jls-3.html#jls-Identifier "Identifier") `=` [ElementValue](jls-9.html#jls-ElementValue "ElementValue")

ElementValue:

[ConditionalExpression](jls-15.html#jls-ConditionalExpression "ConditionalExpression")  
[ElementValueArrayInitializer](jls-9.html#jls-ElementValueArrayInitializer "ElementValueArrayInitializer")  
[Annotation](jls-9.html#jls-Annotation "Annotation")

ElementValueArrayInitializer:

`{` \[[ElementValueList](jls-9.html#jls-ElementValueList "ElementValueList")\] \[`,`\] `}`

ElementValueList:

[ElementValue](jls-9.html#jls-ElementValue "ElementValue") {`,` [ElementValue](jls-9.html#jls-ElementValue "ElementValue")}

Note that the at-sign (`@`) is a token unto itself ([¬ß3.11](jls-3.html#jls-3.11 "3.11. Separators")). It is possible to put whitespace between it and the _TypeName_, but this is discouraged as a matter of style.

The _TypeName_ specifies the annotation type corresponding to the annotation. The annotation is said to be "of" that type.

It is a compile-time error if _TypeName_ does not specify an annotation type that is accessible ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) at the point where the annotation appears.

The _Identifier_ in an element-value pair must be the simple name of one of the elements (i.e. methods) of the annotation type, or a compile-time error occurs.

The return type of this method defines the _element type_ of the element-value pair.

If the element type is an array type, then it is not required to use curly braces to specify the element value of the element-value pair. If the element value is not an _ElementValueArrayInitializer_, then an array value whose sole element is the element value is associated with the element. If the element value is an _ElementValueArrayInitializer_, then the array value represented by the _ElementValueArrayInitializer_ is associated with the element.

It is a compile-time error if the element type is not _commensurate_ with the element value. An element type T is commensurate with an element value `V` if and only if one of the following is true:

*   T is an array type E`[]`, and either:
    
    *   If `V` is a _ConditionalExpression_ or an _Annotation_, then `V` is commensurate with E; or
        
    *   If `V` is an _ElementValueArrayInitializer_, then each element value that `V` contains is commensurate with E.
        
        An _ElementValueArrayInitializer_ is similar to a normal array initializer ([¬ß10.6](jls-10.html#jls-10.6 "10.6. Array Initializers")), except that an _ElementValueArrayInitializer_ may syntactically contain annotations as well as expressions and nested initializers. However, nested initializers are not semantically legal in an _ElementValueArrayInitializer_ because they are never commensurate with array-typed elements in annotation type declarations (nested array types not permitted).
        
*   T is not an array type, and the type of `V` is assignment compatible ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")) with T, and:
    
    *   If T is a primitive type or `String`, then `V` is a constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")).
        
    *   If T is `Class` or an invocation of `Class` ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")), then `V` is a class literal ([¬ß15.8.2](jls-15.html#jls-15.8.2 "15.8.2. Class Literals")).
        
    *   If T is an enum type ([¬ß8.9](jls-8.html#jls-8.9 "8.9. Enum Types")), then `V` is an enum constant ([¬ß8.9.1](jls-8.html#jls-8.9.1 "8.9.1. Enum Constants")).
        
    *   `V` is not `null`.
        
    

Note that if T is not an array type or an annotation type, the element value must be a _ConditionalExpression_ ([¬ß15.25](jls-15.html#jls-15.25 "15.25. Conditional Operator ? :")). The use of _ConditionalExpression_ rather than a more general production like _Expression_ is a syntactic trick to prevent assignment expressions as element values. Since an assignment expression is not a constant expression, it cannot be a commensurate element value for a primitive or `String`\-typed element.

Formally, it is invalid to speak of an _ElementValue_ as FP-strict ([¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions")) because it might be an annotation or a class literal. Still, we can speak informally of _ElementValue_ as FP-strict when it is either a constant expression or an array of constant expressions or an annotation whose element values are (recursively) found to be constant expressions; after all, every constant expression is FP-strict.

A normal annotation must contain an element-value pair for every element of the corresponding annotation type, except for those elements with default values, or a compile-time error occurs.

A normal annotation may, but is not required to, contain element-value pairs for elements with default values.

It is customary, though not required, that element-value pairs in an annotation are presented in the same order as the corresponding elements in the annotation type declaration.

An annotation on an annotation type declaration is known as a _meta-annotation_.

An annotation of type T may appear as a meta-annotation on the declaration of type T itself. More generally, circularities in the transitive closure of the "annotates" relation are permitted.

For example, it is legal to annotate the declaration of an annotation type S with a meta-annotation of type T, and to annotate T's own declaration with a meta-annotation of type S. The pre-defined annotation types contain several such circularities.

**Example 9.7.1-1. Normal Annotations**

Here is an example of a normal annotation using the annotation type from [¬ß9.6.1](jls-9.html#jls-9.6.1 "9.6.1. Annotation Type Elements"):

@RequestForEnhancement(
    id       = 2868724,
    synopsis = "Provide time-travel functionality",
    engineer = "Mr. Peabody",
    date     = "4/1/2004"
)
public static void travelThroughTime(Date destination) { ... }

Here is an example of a normal annotation that takes advantage of default values, using the annotation type from [¬ß9.6.2](jls-9.html#jls-9.6.2 "9.6.2. Defaults for Annotation Type Elements"):

@RequestForEnhancement(
    id       = 4561414,
    synopsis = "Balance the federal budget"
)
public static void balanceFederalBudget() {
    throw new UnsupportedOperationException("Not implemented");
}

  

### 9.7.2. Marker Annotations

A _marker annotation_ is a shorthand designed for use with marker annotation types ([¬ß9.6.1](jls-9.html#jls-9.6.1 "9.6.1. Annotation Type Elements")).

MarkerAnnotation:

`@` [TypeName](jls-6.html#jls-TypeName "TypeName")

It is shorthand for the normal annotation:

@_TypeName_()

It is legal to use marker annotations for annotation types with elements, so long as all the elements have default values ([¬ß9.6.2](jls-9.html#jls-9.6.2 "9.6.2. Defaults for Annotation Type Elements")).

**Example 9.7.2-1. Marker Annotations**

Here is an example using the `Preliminary` marker annotation type from [¬ß9.6.1](jls-9.html#jls-9.6.1 "9.6.1. Annotation Type Elements"):

@Preliminary public class TimeTravel { ... }

  

### 9.7.3. Single-Element Annotations

A _single-element annotation_, is a shorthand designed for use with single-element annotation types ([¬ß9.6.1](jls-9.html#jls-9.6.1 "9.6.1. Annotation Type Elements")).

SingleElementAnnotation:

`@` [TypeName](jls-6.html#jls-TypeName "TypeName") `(` [ElementValue](jls-9.html#jls-ElementValue "ElementValue") `)`

It is shorthand for the normal annotation:

@_TypeName_(value = _ElementValue_)

It is legal to use single-element annotations for annotation types with multiple elements, so long as one element is named `value` and all other elements have default values ([¬ß9.6.2](jls-9.html#jls-9.6.2 "9.6.2. Defaults for Annotation Type Elements")).

**Example 9.7.3-1. Single-Element Annotations**

The following annotations all use the single-element annotation types from [¬ß9.6.1](jls-9.html#jls-9.6.1 "9.6.1. Annotation Type Elements").

Here is an example of a single-element annotation:

@Copyright("2002 Yoyodyne Propulsion Systems, Inc.")
public class OscillationOverthruster { ... }

Here is an example of an array-valued single-element annotation:

@Endorsers({"Children", "Unscrupulous dentists"})
public class Lollipop { ... }

Here is an example of a single-element array-valued single-element annotation: (note that the curly braces are omitted)

@Endorsers("Epicurus")
public class Pleasure { ... }

Here is an example of a single-element annotation with a `Class`\-typed element whose value is constrained by a bounded wildcard.

class GorgeousFormatter implements Formatter { ... }

@PrettyPrinter(GorgeousFormatter.class)
public class Petunia { ... }

// Illegal; String is not a subtype of Formatter
@PrettyPrinter(String.class)
public class Begonia { ... }

Here is an example with of a single-element annotation that contains a normal annotation:

@Author(@Name(first = "Joe", last = "Hacker"))
public class BitTwiddle { ... }

Here is an example of a single-element annotation that uses an enum type defined inside the annotation type:

@Quality(Quality.Level.GOOD)
public class Karma { ... }

  

### 9.7.4. Where Annotations May Appear

A _declaration annotation_ is an annotation that applies to a declaration, and whose own type is applicable in the declaration context ([¬ß9.6.4.1](jls-9.html#jls-9.6.4.1 "9.6.4.1. @Target")) represented by that declaration.

A _type annotation_ is an annotation that applies to a type (or any part of a type), and whose own type is applicable in type contexts ([¬ß4.11](jls-4.html#jls-4.11 "4.11. Where Types Are Used")).

For example, given the field declaration:

@Foo int f;

`@Foo` is a declaration annotation on `f` if `Foo` is meta-annotated by `@Target(ElementType.FIELD)`, and a type annotation on `int` if `Foo` is meta-annotated by `@Target(ElementType.TYPE_USE)`. It is possible for `@Foo` to be both a declaration annotation and a type annotation simultaneously.

Type annotations can apply to an array type or any component type thereof ([¬ß10.1](jls-10.html#jls-10.1 "10.1. Array Types")). For example, assuming that `A`, `B`, and `C` are annotation types meta-annotated with `@Target(ElementType.TYPE_USE)`, then given the field declaration:

@C int @A \[\] @B \[\] f;

`@A` applies to the array type `int``[]``[]`, `@B` applies to its component type `int``[]`, and `@C` applies to the element type `int`. For more examples, see [¬ß10.2](jls-10.html#jls-10.2 "10.2. Array Variables").

An important property of this syntax is that, in two declarations that differ only in the number of array levels, the annotations to the left of the type refer to the same type. For example, `@C` applies to the type `int` in all of the following declarations:

@C int f;
@C int\[\] f;
@C int\[\]\[\] f;

It is customary, though not required, to write declaration annotations before all other modifiers, and type annotations immediately before the type to which they apply.

It is possible for an annotation to appear at a syntactic location in a program where it could plausibly apply to a declaration, or a type, or both. This can happen in any of the five declaration contexts where modifiers immediately precede the type of the declared entity:

*   Method declarations (including elements of annotation types)
*   Constructor declarations
*   Field declarations (including enum constants)
*   Formal and exception parameter declarations
*   Local variable declarations (including loop variables of `for` statements and resource variables of `try`\-with-resources statements)
    

The grammar of the Java programming language unambiguously treats annotations at these locations as modifiers for a declaration ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations")), but that is purely a syntactic matter. Whether an annotation applies to a declaration or to the type of the declared entity - and thus, whether the annotation is a _declaration annotation_ or a _type annotation_ - depends on the applicability of the annotation's type:

*   If the annotation's type is applicable in the declaration context corresponding to the declaration, and not in type contexts, then the annotation is deemed to apply only to the declaration.
*   If the annotation's type is applicable in type contexts, and not in the declaration context corresponding to the declaration, then the annotation is deemed to apply only to the type which is closest to the annotation.
*   If the annotation's type is applicable in the declaration context corresponding to the declaration _and_ in type contexts, then the annotation is deemed to apply to both the declaration _and_ the type which is closest to the annotation.
    

In the second and third cases above, the type which is _closest_ to the annotation is the type written in source code for the declared entity; if that type is an array type, then the element type is deemed to be closest to the annotation.

For example, in the field declaration `@Foo public static String f;`, the type which is closest to `@Foo` is `String`. (If the type of the field declaration had been written as `java.lang.String`, then `java.lang.String` would be the type closest to `@Foo`, and later rules would prohibit a type annotation from applying to the package name `java`.) In the generic method declaration `@Foo <T> int[] m() {...}`, the type written for the declared entity is `int``[]`, so `@Foo` applies to the element type `int`.

Local variable declarations are similar to formal parameter declarations of lambda expressions, in that both allow declaration annotations and type annotations in source code, but only the type annotations can be stored in the `class` file.

There are two special cases involving method/constructor declarations:

*   If an annotation appears before a constructor declaration and is deemed to apply to the type which is closest to the annotation, that type is the type of the newly constructed object. The type of the newly constructed object is the fully qualified name of the type immediately enclosing the constructor declaration. Within that fully qualified name, the annotation applies to the simple type name indicated by the constructor declaration.
*   If an annotation appears before a `void` method declaration and is deemed to apply only to the type which is closest to the annotation, a compile-time error occurs.
    

It is a compile-time error if an annotation of type T is syntactically a modifier for:

*   a package declaration, but T is not applicable to package declarations.
*   a class, interface, or enum declaration, but T is not applicable to type declarations or type contexts; or an annotation type declaration, but T is not applicable to annotation type declarations or type declarations or type contexts.
*   a method declaration (including an element of an annotation type), but T is not applicable to method declarations or type contexts.
*   a constructor declaration, but T is not applicable to constructor declarations or type contexts.
*   a type parameter declaration of a generic class, interface, method, or constructor, but T is not applicable to type parameter declarations or type contexts.
*   a field declaration (including an enum constant), but T is not applicable to field declarations or type contexts.
*   a formal or exception parameter declaration, but T is not applicable to either formal and exception parameter declarations or type contexts.
*   a receiver parameter, but T is not applicable to type contexts.
*   a local variable declaration (including a loop variable of a `for` statement or a resource variable of a `try`\-with-resources statement), but T is not applicable to local variable declarations or type contexts.
    

Note that most of the clauses above mention "... or type contexts", because even if an annotation does not apply to the declaration, it may still apply to the type of the declared entity.

A type annotation is _admissible_ if both of the following are true:

*   The simple name to which the annotation is closest is classified as a _TypeName_, not a _PackageName_.
*   If the simple name to which the annotation is closest is followed by "`.`" and another _TypeName_ - that is, the annotation appears as `@Foo T.U` - then `U` denotes an inner class of `T`.
    

The intuition behind the second clause is that if `Outer.this` is legal in a nested class enclosed by `Outer`, then `Outer` may be annotated because it represents the type of some object at run time. On the other hand, if `Outer.this` is not legal - because the class where it appears has no enclosing instance of `Outer` at run time - then `Outer` may not be annotated because it is logically just a name, akin to components of a package name in a fully qualified type name.

For example, in the following program, it is not possible to write `A.this` in the body of `B`, as `B` has no lexically enclosing instances (8.5.1). Therefore, it is not possible to apply `@Foo` to `A` in the type `A.B`, because `A` is logically just a name, not a type.

@Target(ElementType.TYPE\_USE)
@interface Foo {}

class Test {
  class A {
    static class B {}
  }

  @Foo A.B x;  // Illegal 
}

On the other hand, in the following program, it is possible to write `C.this` in the body of `D`. Therefore, it is possible to apply `@Foo` to `C` in the type `C.D`, because `C` represents the type of some object at run time.

@Target(ElementType.TYPE\_USE)
@interface Foo {}

class Test {
  static class C {
    class D {}
  }

  @Foo C.D x;  // Legal 
}

Finally, note that the second clause looks only one level deeper in a qualified type. This is because a `static` class may only be nested in a top level class or another `static` nested class. It is not possible to write a nest like:

@Target(ElementType.TYPE\_USE)
@interface Foo {}

class Test {
  class E {
    class F {
      static class G {}
    }
  }

  @Foo E.F.G x;
}

Assume for a moment that the nest was legal. In the type of field `x`, `E` and `F` would logically be names qualifying `G`, as `E.F.this` would be illegal in the body of `G`. Then, `@Foo` should not be legal next to `E`. Technically, however, `@Foo` would be admissible next to `E` because the next deepest term `F` denotes an inner class; but this is moot as the class nest is illegal in the first place.

It is a compile-time error if an annotation of type T applies to the outermost level of a type in a type context, and T is not applicable in type contexts or the declaration context (if any) which occupies the same syntactic location.

It is a compile-time error if an annotation of type T applies to a part of a type (that is, not the outermost level) in a type context, and T is not applicable in type contexts.

It is a compile-time error if an annotation of type T applies to a type (or any part of a type) in a type context, and T is applicable in type contexts, and the annotation is not admissible.

For example, assume an annotation type `TA` which is meta-annotated with just `@Target(ElementType.TYPE_USE)`. The terms `@TA java.lang.Object` and `java.@TA lang.Object` are illegal because the simple name to which `@TA` is closest is classified as a package name. On the other hand, `java.lang.@TA Object` is legal.

Note that the illegal terms are illegal "everywhere". The ban on annotating package names applies broadly: to locations which are solely type contexts, such as `class ... extends @TA java.lang.Object {...}`, and to locations which are both declaration and type contexts, such as `@TA java.lang.Object f;`. (There are no locations which are solely declaration contexts where a package name could be annotated, as class, package, and type parameter declarations use only simple names.)

If `TA` is additionally meta-annotated with `@Target(ElementType.FIELD)`, then the term `@TA java.lang.Object` is legal in locations which are both declaration and type contexts, such as a field declaration `@TA java.lang.Object f;`. Here, `@TA` is deemed to apply to the declaration of `f` (and not to the type `java.lang.Object`) because `TA` is applicable in the field declaration context.

### 9.7.5. Multiple Annotations of the Same Type

It is a compile-time error if multiple annotations of the same type T appear in a declaration context or type context, unless T is repeatable ([¬ß9.6.3](jls-9.html#jls-9.6.3 "9.6.3. Repeatable Annotation Types")) and both T and the containing annotation type of T are applicable in the declaration context or type context ([¬ß9.6.4.1](jls-9.html#jls-9.6.4.1 "9.6.4.1. @Target")).

It is customary, though not required, for multiple annotations of the same type to appear contiguously.

If a declaration context or type context has multiple annotations of a repeatable annotation type T, then it is as if the context has no explicitly declared annotations of type T and one implicitly declared annotation of the containing annotation type of T.

The implicitly declared annotation is called the _container annotation_, and the multiple annotations of type T which appeared in the context are called the _base annotations_. The elements of the (array-typed) `value` element of the container annotation are all the base annotations in the left-to-right order in which they appeared in the context.

It is a compile-time error if, in a declaration context or type context, there are multiple annotations of a repeatable annotation type T and any annotations of the containing annotation type of T.

In other words, it is not possible to repeat annotations where an annotation of the same type as their container also appears. This prohibits obtuse code like:

@Foo(0) @Foo(1) @FooContainer({@Foo(2)})
class A {}

If this code was legal, then multiple levels of containment would be needed: first the annotations of type `Foo` would be contained by an implicitly declared container annotation of type `FooContainer`, then that annotation and the explicitly declared annotation of type `FooContainer` would be contained in yet another implicitly declared annotation. This complexity is undesirable in the judgment of the designers of the Java programming language. Another approach, treating the annotations of type `Foo` as if they had occurred alongside `@Foo(2)` in the explicit `@FooContainer` annotation, is undesirable because it could change how reflective programs interpret the `@FooContainer` annotation.

It is a compile-time error if, in a declaration context or type context, there is one annotation of a repeatable annotation type T and multiple annotations of the containing annotation type of T.

This rule is designed to allow the following code:

@Foo(1) @FooContainer({@Foo(2)})
class A {}

With only one annotation of the repeatable annotation type `Foo`, no container annotation is implicitly declared, even if `FooContainer` is the containing annotation type of `Foo`. However, repeating the annotation of type `FooContainer`, as in:

@Foo(1) @FooContainer({@Foo(2)}) @FooContainer({@Foo(3)})
class A {}

is prohibited, even if `FooContainer` is repeatable with a containing annotation type of its own. It is obtuse to repeat annotations which are themselves containers when an annotation of the underlying repeatable type is present.

9.8. Functional Interfaces
--------------------------

A _functional interface_ is an interface that has just one abstract method (aside from the methods of `Object`), and thus represents a single function contract. This "single" method may take the form of multiple abstract methods with override-equivalent signatures inherited from superinterfaces; in this case, the inherited methods logically represent a single method.

For an interface I, let `M` be the set of `abstract` methods that are members of I that do not have the same signature as any `public` instance method of the class `Object`. Then, I is a _functional interface_ if there exists a method `m` in `M` for which both of the following are true:

*   The signature of `m` is a subsignature ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")) of every method's signature in `M`.
*   `m` is return-type-substitutable ([¬ß8.4.5](jls-8.html#jls-8.4.5 "8.4.5. Method Result")) for every method in `M`.
    

In addition to the usual process of creating an interface instance by declaring and instantiating a class ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")), instances of functional interfaces can be created with method reference expressions and lambda expressions ([¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions"), [¬ß15.27](jls-15.html#jls-15.27 "15.27. Lambda Expressions")).

The definition of _functional interface_ excludes methods in an interface that are also `public` methods in `Object`. This is to allow functional treatment of an interface like `java.util.Comparator<T>` that declares multiple `abstract` methods of which only one is really "new" - `int compare(T,T)`. The other method - `boolean equals(Object)` - is an explicit declaration of an `abstract` method that would otherwise be implicitly declared, and will be automatically implemented by every class that `implements` the interface.

Note that if non-`public` methods of `Object`, such as `clone()`, are declared in an interface, they are _not_ automatically implemented by every class that `implements` the interface. The implementation inherited from `Object` is `protected` while the interface method is necessarily `public`. The only way to implement such an interface would be for a class to override the non-`public` `Object` method with a `public` method.

**Example 9.8-1. Functional Interfaces**

A simple example of a functional interface is:

interface Runnable {
    void run();
}

The following interface is not functional because it declares nothing which is not already a member of `Object`:

interface NonFunc {
    boolean equals(Object obj);
}

However, its subinterface can be functional by declaring an `abstract` method which is not a member of `Object`:

interface Func extends NonFunc {
    int compare(String o1, String o2);
}

Similarly, the well known interface `java.util.Comparator<T>` is functional because it has one `abstract` non-`Object` method:

interface Comparator<T> {
    boolean equals(Object obj);
    int compare(T o1, T o2);
}

The following interface is not functional because while it only declares one `abstract` method which is not a member of `Object`, it declares _two_ `abstract` methods which are not `public` members of `Object`:

interface Foo {
    int m();
    Object clone();
}

  

**Example 9.8-2. Functional Interfaces and Erasure**

In the following interface hierarchy, `Z` is a functional interface because while it inherits two `abstract` methods which are not members of `Object`, they have the same signature, so the inherited methods logically represent a single method:

interface X { int m(Iterable<String> arg); }
interface Y { int m(Iterable<String> arg); }
interface Z extends X, Y {}

Similarly, `Z` is a functional interface in the following interface hierarchy because `Y.m` is a subsignature of `X.m` and is return-type-substitutable for `X.m`:

interface X { Iterable m(Iterable<String> arg); }
interface Y { Iterable<String> m(Iterable arg); }
interface Z extends X, Y {}

The definition of _functional interface_ respects the fact that an interface cannot have two members which are not subsignatures of each other, yet have the same erasure ([&se](jls-9.html#jls-9.4.1.2 "9.4.1.2. Requirements in Overriding")ct;9.4.1.2). Thus, in the following three interface hierarchies where `Z` causes a compile-time error, `Z` is not a functional interface: (because none of its `abstract` members are subsignatures of all other `abstract` members)

interface X { int m(Iterable<String> arg); }
interface Y { int m(Iterable<Integer> arg); }
interface Z extends X, Y {}

interface X { int m(Iterable<String> arg, Class c); }
interface Y { int m(Iterable arg, Class<?> c); }
interface Z extends X, Y {}

interface X<T> { void m(T arg); }
interface Y<T> { void m(T arg); }
interface Z<A, B> extends X<A>, Y<B> {}

Similarly, the definition of "functional interface" respects the fact that an interface may only have methods with override-equivalent signatures if one is return-type-substitutable for all the others. Thus, in the following interface hierarchy where `Z` causes a compile-time error, `Z` is not a functional interface: (because none of its `abstract` members are return-type-substitutable for all other `abstract` members)

interface X { long m(); }
interface Y { int  m(); }
interface Z extends X, Y {}

In the following example, the declarations of `Foo<T,N>` and `Bar` are legal: in each, the methods called `m` are not subsignatures of each other, but do have different erasures. Still, the fact that the methods in each are not subsignatures means `Foo<T,N>` and `Bar` are not functional interfaces. However, `Baz` is a functional interface because the methods it inherits from `Foo<Integer,Integer>` have the same signature and so logically represent a single method.

interface Foo<T, N extends Number> {
    void m(T arg);
    void m(N arg);
}
interface Bar extends Foo<String, Integer> {}
interface Baz extends Foo<Integer, Integer> {}

Finally, the following examples demonstrate the same rules as above, but with generic methods:

interface Exec { <T> T execute(Action<T> a); }
  // Functional

interface X { <T> T execute(Action<T> a); }
interface Y { <S> S execute(Action<S> a); }
interface Exec extends X, Y {}
  // Functional: signatures are logically "the same"

interface X { <T>   T execute(Action<T> a); }
interface Y { <S,T> S execute(Action<S> a); }
interface Exec extends X, Y {}
  // Error: different signatures, same erasure

  

**Example 9.8-3. Generic Functional Interfaces**

Functional interfaces can be generic, such as `java.util.function.Predicate<T>`. Such a functional interface may be parameterized in a way that produces distinct `abstract` methods - that is, multiple methods that cannot be legally overridden with a single declaration. For example:

interface I    { Object m(Class c); }
interface J<S> { S m(Class<?> c); }
interface K<T> { T m(Class<?> c); }
interface Functional<S,T> extends I, J<S>, K<T> {}

`Functional<S,T>` is a functional interface - `I.m` is return-type-substitutable for `J.m` and `K.m` - but the functional interface type `Functional<String,Integer>` clearly cannot be implemented with a single method. However, other parameterizations of `Functional<S,T>` which are functional interface types are possible.

  

The declaration of a functional interface allows a _functional interface type_ to be used in a program. There are four kinds of functional interface type:

*   The type of a non-generic ([¬ß6.1](jls-6.html#jls-6.1 "6.1. Declarations")) functional interface
*   A parameterized type that is a parameterization ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")) of a generic functional interface
*   The raw type ([¬ß4.8](jls-4.html#jls-4.8 "4.8. Raw Types")) of a generic functional interface
*   An intersection type ([¬ß4.9](jls-4.html#jls-4.9 "4.9. Intersection Types")) that induces a notional functional interface
    

In special circumstances, it is useful to treat an intersection type as a functional interface type. Typically, this will look like an intersection of a functional interface type with one or more marker interface types, such as `` Runnable & `java.io.Serializable` ``. Such an intersection can be used in casts ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")) that force a lambda expression to conform to a certain type. If one of the interface types in the intersection is `java.io.Serializable`, special run-time support for serialization is triggered ([¬ß15.27.4](jls-15.html#jls-15.27.4 "15.27.4. Run-Time Evaluation of Lambda Expressions")).

9.9. Function Types
-------------------

The _function type_ of a functional interface I is a method type ([¬ß8.2](jls-8.html#jls-8.2 "8.2. Class Members")) that can be used to override ([¬ß8.4.8](jls-8.html#jls-8.4.8 "8.4.8. Inheritance, Overriding, and Hiding")) the abstract method(s) of I.

Let `M` be the set of abstract methods defined for I. The function type of I consists of the following:

*   Type parameters, formal parameters, and return type:
    
    Let `m` be a method in `M` with:
    
    1.  a signature that is a subsignature of every method's signature in `M`; and
        
    2.  a return type that is a subtype of every method's return type in `M` (after adapting for any type parameters ([¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods"))).
        
    
    If no such method exists, then let `m` be a method in `M` that:
    
    1.  has a signature that is a subsignature of every method's signature in `M`; and
        
    2.  is return-type-substitutable ([¬ß8.4.5](jls-8.html#jls-8.4.5 "8.4.5. Method Result")) for every method in `M`.
        
    
    The function type's type parameters, formal parameter types, and return type are as given by `m`.
*   `throws` clause:
    
    The function type's `throws` clause is derived from the `throws` clauses of the methods in `M`. If the function type is generic, these clauses are first adapted to the type parameters of the function type ([¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods")). If the function type is not generic but at least one method in `M` is generic, these clauses are first erased. Then, the function type's `throws` clause includes every type, E, which satisfies the following constraints:
    
    *   E is mentioned in one of the `throws` clauses.
        
    *   For each `throws` clause, E is a subtype of some type named in that clause.
        
    

When some return types in `M` are raw and others are not, the definition of a function type tries to choose the most specific type, if possible. For example, if the return types are `LinkedList` and `LinkedList``<``String``>`, then the latter is immediately chosen as the function type's return type. When there is no most specific type, the definition compensates by finding the most substitutable return type. For example, if there is a third return type, `List``<``?``>`, then it is not the case that one of the return types is a subtype of every other (as raw `LinkedList` is not a subtype of `List``<``?``>`); instead, `LinkedList``<``String``>` is chosen as the function type's return type because it is return-type-substitutable for both `LinkedList` and `List``<``?``>`.

The goal driving the definition of a function type's thrown exception types is to support the invariant that a method with the resulting `throws` clause could override each abstract method of the functional interface. Per [¬ß8.4.6](jls-8.html#jls-8.4.6 "8.4.6. Method Throws"), this means the function type cannot throw "more" exceptions than any single method in the set `M`, so we look for as many exception types as possible that are "covered" by every method's `throws` clause.

The function type of a functional interface type is specified as follows:

*   The function type of the type of a non-generic functional interface I is simply the function type of the functional interface I, as defined above.
*   The function type of a parameterized functional interface type I`<`A1...An`>`, where A1...An are types and the corresponding type parameters of I are P1...Pn, is derived by applying the substitution `[`P1:=A1, ..., Pn:=An`]` to the function type of the generic functional interface I`<`P1...Pn`>`.
*   The function type of a parameterized functional interface type I`<`A1...An`>`, where one or more of A1...An is a wildcard, is the function type of the _non-wildcard parameterization_ of I, I`<`T1...Tn`>`. The non-wildcard parameterization is determined as follows.
    
    Let P1...Pn be the type parameters of I with corresponding bounds B1...Bn. For all _i_ (1 ‚â§ _i_ ‚â§ _n_), Ti is derived according to the form of Ai:
    
    *   If Ai is a type, then Ti = Ai.
        
    *   If Ai is a wildcard, and the corresponding type parameter's bound, Bi, mentions one of P1...Pn, then Ti is undefined and there is no function type.
        
    *   Otherwise:
        
        *   If Ai is an unbound wildcard `?`, then Ti = Bi.
            
        *   If Ai is a upper-bounded wildcard `?` `extends` Ui, then Ti = glb(Ui, Bi) ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")).
            
        *   If Ai is a lower-bounded wildcard `?` `super` `Li`, then Ti = `Li`.
            
        
*   The function type of the raw type of a generic functional interface I`<`...`>` is the erasure of the function type of the generic functional interface I`<`...`>`.
*   The function type of an intersection type that induces a notional functional interface is the function type of the notional functional interface.
    

**Example 9.9-1. Function Types**

Given the following interfaces:

interface X { void m() throws IOException; }
interface Y { void m() throws EOFException; }
interface Z { void m() throws ClassNotFoundException; }

the function type of:

interface XY extends X, Y {}

is:

()`->`void throws EOFException

while the function type of:

interface XYZ extends X, Y, Z {}

is:

()`->`void (throws nothing)

Given the following interfaces:

interface A {
    List<String> foo(List<String> arg)
      throws IOException, SQLTransientException;
}
interface B {
    List foo(List<String> arg)
      throws EOFException, SQLException, TimeoutException;
}
interface C {
    List foo(List arg) throws Exception;
}

the function type of:

interface D extends A, B {}

is:

(List<String>)`->`List<String>
  throws EOFException, SQLTransientException

while the function type of:

interface E extends A, B, C {}

is:

(List)`->`List throws EOFException, SQLTransientException

  

The function type of a functional interface is defined nondeterministically: while the signatures in `M` are "the same", they may be syntactically different (`HashMap.Entry` and `Map.Entry`, for example); the return type may be a subtype of every other return type, but there may be other return types that are _also_ subtypes (`List<?>` and `List<? extends Object>`, for example); and the order of thrown types is unspecified. These distinctions are subtle, but they can sometimes be important. However, function types are not used in the Java programming language in such a way that the nondeterminism matters. Note that the return type and `throws` clause of a "most specific method" are also defined nondeterministically when there are multiple abstract methods ([¬ß15.12.2.5](jls-15.html#jls-15.12.2.5 "15.12.2.5. Choosing the Most Specific Method")).

When a generic functional interface is parameterized by wildcards, there are many different instantiations that could satisfy the wildcard and produce different function types. For example, each of `Predicate<Integer>` (function type ``Integer `->` boolean``), `Predicate<Number>` (function type ``Number `->` boolean``), and `Predicate<Object>` (function type ``Object `->` boolean``) is a `Predicate<? super Integer>`. Sometimes, it is possible to known from the context, such as the parameter types of a lambda expression, which function type is intended ([¬ß15.27.3](jls-15.html#jls-15.27.3 "15.27.3. Type of a Lambda Expression")). Other times, it is necessary to pick one; in these circumstances, the bounds are used. (This simple strategy cannot guarantee that the resulting type will satisfy certain complex bounds, so not all complex cases are supported.)

**Example 9.9-2. Generic Function Types**

A function type may be generic, as a functional interface's abstract method may be generic. For example, in the following interface hierarchy:

interface G1 {
    <E extends Exception> Object m() throws E;
}
interface G2 {
    <F extends Exception> String m() throws Exception;
}
interface G extends G1, G2 {}

the function type of `G` is:

<F extends Exception> ()`->`String throws F

A generic function type for a functional interface may be implemented by a method reference expression ([¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions")), but not by a lambda expression ([¬ß15.27](jls-15.html#jls-15.27 "15.27. Lambda Expressions")) as there is no syntax for generic lambda expressions.

  

üçÄ Chapter 10. Arrays
------------------

**Table of Contents**

[10.1. Array Types](jls-10.html#jls-10.1)
[10.2. Array Variables](jls-10.html#jls-10.2)
[10.3. Array Creation](jls-10.html#jls-10.3)
[10.4. Array Access](jls-10.html#jls-10.4)
[10.5. Array Store Exception](jls-10.html#jls-10.5)
[10.6. Array Initializers](jls-10.html#jls-10.6)
[10.7. Array Members](jls-10.html#jls-10.7)
[10.8. `Class` Objects for Arrays](jls-10.html#jls-10.8)
[10.9. An Array of Characters Is Not a `String`](jls-10.html#jls-10.9)

In the Java programming language, _arrays_ are objects ([¬ß4.3.1](jls-4.html#jls-4.3.1 "4.3.1. Objects")), are dynamically created, and may be assigned to variables of type `Object` ([¬ß4.3.2](jls-4.html#jls-4.3.2 "4.3.2. The Class Object")). All methods of class `Object` may be invoked on an array.

An array object contains a number of variables. The number of variables may be zero, in which case the array is said to be _empty_. The variables contained in an array have no names; instead they are referenced by array access expressions that use non-negative integer index values. These variables are called the _components_ of the array. If an array has _n_ components, we say _n_ is the length of the array; the components of the array are referenced using integer indices from 0 to _n_ - 1, inclusive.

All the components of an array have the same type, called the _component type_ of the array. If the component type of an array is T, then the type of the array itself is written T`[]`.

The value of an array component of type `float` is always an element of the float value set ([¬ß4.2.3](jls-4.html#jls-4.2.3 "4.2.3. Floating-Point Types, Formats, and Values")); similarly, the value of an array component of type `double` is always an element of the double value set. It is not permitted for the value of an array component of type `float` to be an element of the float-extended-exponent value set that is not also an element of the float value set, nor for the value of an array component of type `double` to be an element of the double-extended-exponent value set that is not also an element of the double value set.

The component type of an array may itself be an array type. The components of such an array may contain references to subarrays. If, starting from any array type, one considers its component type, and then (if that is also an array type) the component type of that type, and so on, eventually one must reach a component type that is not an array type; this is called the _element type_ of the original array, and the components at this level of the data structure are called the _elements_ of the original array.

There are some situations in which an element of an array can be an array: if the element type is `Object` or `Cloneable` or `java.io.Serializable`, then some or all of the elements may be arrays, because any array object can be assigned to any variable of these types.

10.1. Array Types
-----------------

Array types are used in declarations and in cast expressions ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")).

An array type is written as the name of an element type followed by some number of empty pairs of square brackets `[]`. The number of bracket pairs indicates the depth of array nesting.

Each bracket pair in an array type may be annotated by type annotations ([¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear")). An annotation applies to the bracket pair (or ellipsis, in a variable arity parameter declaration) that follows it.

The element type of an array may be any type, whether primitive or reference. In particular:

*   Arrays with an interface type as the element type are allowed.
    
    An element of such an array may have as its value a null reference or an instance of any type that implements the interface.
*   Arrays with an `abstract` class type as the element type are allowed.
    
    An element of such an array may have as its value a null reference or an instance of any subclass of the `abstract` class that is not itself `abstract`.
    

An array's length is not part of its type.

The supertypes of an array type are specified in [¬ß4.10.3](jls-4.html#jls-4.10.3 "4.10.3. Subtyping among Array Types").

The supertype relation for array types is not the same as the superclass relation. The direct supertype of `Integer``[]` is `Number``[]` according to [¬ß4.10.3](jls-4.html#jls-4.10.3 "4.10.3. Subtyping among Array Types"), but the direct superclass of `Integer``[]` is `Object` according to the `Class` object for `Integer``[]` ([¬ß10.8](jls-10.html#jls-10.8 "10.8. Class Objects for Arrays")). This does not matter in practice, because `Object` is also a supertype of all array types.

10.2. Array Variables
---------------------

A variable of array type holds a reference to an object. Declaring a variable of array type does not create an array object or allocate any space for array components. It creates only the variable itself, which can contain a reference to an array. However, the initializer part of a declarator ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations"), [¬ß9.3](jls-9.html#jls-9.3 "9.3. Field (Constant) Declarations"), [¬ß14.4.1](jls-14.html#jls-14.4.1 "14.4.1. Local Variable Declarators and Types")) may create an array, a reference to which then becomes the initial value of the variable.

**Example 10.2-1. Declarations of Array Variables**

int\[\]     ai;        // array of int
short\[\]\[\] as;        // array of array of short
short     s,         // scalar short
          aas\[\]\[\];   // array of array of short
Object\[\]  ao,        // array of Object
          otherAo;   // array of Object
Collection<?>\[\] ca;  // array of Collection of unknown type

The declarations above do not create array objects. The following are examples of declarations of array variables that do create array objects:

Exception ae\[\]  = new Exception\[3\];
Object aao\[\]\[\]  = new Exception\[2\]\[3\];
int\[\] factorial = { 1, 1, 2, 6, 24, 120, 720, 5040 };
char ac\[\]       = { 'n', 'o', 't', ' ', 'a', ' ',
                    'S', 't', 'r', 'i', 'n', 'g' };
String\[\] aas    = { "array", "of", "String", };

  

The array type of a variable depends on the bracket pairs that may appear as part of the type at the beginning of a variable declaration, or as part of the declarator for the variable, or both. Specifically, in the declaration of a field, formal parameter, or local variable ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations"), [¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"), [¬ß9.3](jls-9.html#jls-9.3 "9.3. Field (Constant) Declarations"), [¬ß9.4](jls-9.html#jls-9.4 "9.4. Method Declarations"), [¬ß14.4.1](jls-14.html#jls-14.4.1 "14.4.1. Local Variable Declarators and Types"), [¬ß14.14.2](jls-14.html#jls-14.14.2 "14.14.2. The enhanced for statement"), [¬ß15.27.1](jls-15.html#jls-15.27.1 "15.27.1. Lambda Parameters")), the array type of the variable is denoted by:

*   the element type that appears at the beginning of the declaration; then,
*   any bracket pairs that follow the variable's _Identifier_ in the declarator (not applicable for a variable arity parameter); then,
*   any bracket pairs that appear in the type at the beginning of the declaration (where the ellipsis of a variable arity parameter is treated as a bracket pair).
    

The return type of a method ([¬ß8.4.5](jls-8.html#jls-8.4.5 "8.4.5. Method Result")) may be an array type. The precise array type depends on the bracket pairs that may appear as part of the type at the beginning of the method declaration, or after the method's formal parameter list, or both. The array type is denoted by:

*   the element type that appears in the _Result_; then,
*   any bracket pairs that follow the formal parameter list; then,
*   any bracket pairs that appear in the _Result_.
    

We do not recommend "mixed notation" in array variable declarations, where bracket pairs appear on both the type and in declarators; nor in method declarations, where bracket pairs appear both before and after the formal parameter list.

**Example 10.2-2. Array Variables and Array Types**

The local variable declaration statement:

byte\[\] rowvector, colvector, matrix\[\];

is equivalent to:

byte rowvector\[\], colvector\[\], matrix\[\]\[\];

because the array type of each local variable is unchanged. Similarly, the local variable declaration statement:

int a, b\[\], c\[\]\[\];

is equivalent to the series of declaration statements:

int a;
int\[\] b;
int\[\]\[\] c;

Brackets are allowed in declarators as a nod to the tradition of C and C++. The general rules for variable declaration, however, permit brackets to appear on both the type and in declarators, so that the local variable declaration statement:

float\[\]\[\] f\[\]\[\], g\[\]\[\]\[\], h\[\];  // Yechh!

is equivalent to the series of declarations:

float\[\]\[\]\[\]\[\] f;
float\[\]\[\]\[\]\[\]\[\] g;
float\[\]\[\]\[\] h;

Because of how array types are formed, the following parameter declarations have the same array type:

void m(int @A \[\] @B \[\]  x) {}
void n(int @A \[\] @B ... y) {}

And perhaps surprisingly, the following field declarations have the same array type:

int @A \[\] f @B \[\];
int @B \[\] @A \[\] g;

  

Once an array object is created, its length never changes. To make an array variable refer to an array of different length, a reference to a different array must be assigned to the variable.

A single variable of array type may contain references to arrays of different lengths, because an array's length is not part of its type.

If an array variable `v` has type A`[]`, where A is a reference type, then `v` can hold a reference to an instance of any array type B`[]`, provided B can be assigned to A ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")). This may result in a run-time exception on a _later_ assignment; see [¬ß10.5](jls-10.html#jls-10.5 "10.5. Array Store Exception") for a discussion.

10.3. Array Creation
--------------------

An array is created by an array creation expression ([¬ß15.10.1](jls-15.html#jls-15.10.1 "15.10.1. Array Creation Expressions")) or an array initializer ([¬ß10.6](jls-10.html#jls-10.6 "10.6. Array Initializers")).

An array creation expression specifies the element type, the number of levels of nested arrays, and the length of the array for at least one of the levels of nesting. The array's length is available as a `final` instance variable `length`.

An array initializer creates an array and provides initial values for all its components.

10.4. Array Access
------------------

A component of an array is accessed by an array access expression ([¬ß15.10.3](jls-15.html#jls-15.10.3 "15.10.3. Array Access Expressions")) that consists of an expression whose value is an array reference followed by an indexing expression enclosed by `[` and `]`, as in `A[i]`.

All arrays are `0`\-origin. An array with length _n_ can be indexed by the integers `0` to _n_\-1.

**Example 10.4-1. Array Access**

class Gauss {
    public static void main(String\[\] args) {
        int\[\] ia = new int\[101\];
        for (int i = 0; i < ia.length; i++) ia\[i\] = i;
        int sum = 0;
        for (int e : ia) sum += e;
        System.out.println(sum);
    }
}

This program produces the output:

5050

The program declares a variable `ia` that has type array of `int`, that is, `int[]`. The variable `ia` is initialized to reference a newly created array object, created by an array creation expression ([¬ß15.10.1](jls-15.html#jls-15.10.1 "15.10.1. Array Creation Expressions")). The array creation expression specifies that the array should have `101` components. The length of the array is available using the field `length`, as shown. The program fills the array with the integers from `0` to `100`, sums these integers, and prints the result.

  

Arrays must be indexed by `int` values; `short`, `byte`, or `char` values may also be used as index values because they are subjected to unary numeric promotion ([¬ß5.6.1](jls-5.html#jls-5.6.1 "5.6.1. Unary Numeric Promotion")) and become `int` values.

An attempt to access an array component with a `long` index value results in a compile-time error.

All array accesses are checked at run time; an attempt to use an index that is less than zero or greater than or equal to the length of the array causes an `ArrayIndexOutOfBoundsException` to be thrown ([¬ß15.10.4](jls-15.html#jls-15.10.4 "15.10.4. Run-Time Evaluation of Array Access Expressions")).

10.5. Array Store Exception
---------------------------

For an array whose type is A`[]`, where A is a reference type, an assignment to a component of the array is checked at run time to ensure that the value being assigned is assignable to the component.

If the type of the value being assigned is not assignment-compatible ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")) with the component type, an `ArrayStoreException` is thrown.

If the component type of an array were not reifiable ([¬ß4.7](jls-4.html#jls-4.7 "4.7. Reifiable Types")), the Java Virtual Machine could not perform the store check described in the preceding paragraph. This is why an array creation expression with a non-reifiable element type is forbidden ([¬ß15.10.1](jls-15.html#jls-15.10.1 "15.10.1. Array Creation Expressions")). One may declare a variable of an array type whose element type is non-reifiable, but assignment of the result of an array creation expression to the variable will necessarily cause an unchecked warning ([¬ß5.1.9](jls-5.html#jls-5.1.9 "5.1.9. Unchecked Conversion")).

**Example 10.5-1. `ArrayStoreException`**

class Point { int x, y; }
class ColoredPoint extends Point { int color; }
class Test {
    public static void main(String\[\] args) {
        ColoredPoint\[\] cpa = new ColoredPoint\[10\];
        Point\[\] pa = cpa;
        System.out.println(pa\[1\] == null);
        try {
            pa\[0\] = new Point();
        } catch (ArrayStoreException e) {
            System.out.println(e);
        }
    }
}

This program produces the output:

true
java.lang.ArrayStoreException: Point

The variable `pa` has type `Point[]` and the variable `cpa` has as its value a reference to an object of type `ColoredPoint[]`. A `ColoredPoint` can be assigned to a `Point`; therefore, the value of `cpa` can be assigned to `pa`.

A reference to this array `pa`, for example, testing whether `pa[1]` is `null`, will not result in a run-time type error. This is because the element of the array of type `ColoredPoint[]` is a `ColoredPoint`, and every `ColoredPoint` can stand in for a `Point`, since `Point` is the superclass of `ColoredPoint`.

On the other hand, an assignment to the array `pa` can result in a run-time error. At compile time, an assignment to an element of `pa` is checked to make sure that the value assigned is a `Point`. But since `pa` holds a reference to an array of `ColoredPoint`, the assignment is valid only if the type of the value assigned at run time is, more specifically, a `ColoredPoint`.

The Java Virtual Machine checks for such a situation at run time to ensure that the assignment is valid; if not, an `ArrayStoreException` is thrown.

  

10.6. Array Initializers
------------------------

An _array initializer_ may be specified in a field declaration ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations"), [¬ß9.3](jls-9.html#jls-9.3 "9.3. Field (Constant) Declarations")) or local variable declaration ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements")), or as part of an array creation expression ([¬ß15.10.1](jls-15.html#jls-15.10.1 "15.10.1. Array Creation Expressions")), to create an array and provide some initial values.

ArrayInitializer:

`{` \[[VariableInitializerList](jls-10.html#jls-VariableInitializerList "VariableInitializerList")\] \[`,`\] `}`

VariableInitializerList:

[VariableInitializer](jls-8.html#jls-VariableInitializer "VariableInitializer") {`,` [VariableInitializer](jls-8.html#jls-VariableInitializer "VariableInitializer")}

The following production from [¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations") is shown here for convenience:

VariableInitializer:

[Expression](jls-15.html#jls-Expression "Expression")  
[ArrayInitializer](jls-10.html#jls-ArrayInitializer "ArrayInitializer")

An array initializer is written as a comma-separated list of expressions, enclosed by braces `{` and `}`.

A trailing comma may appear after the last expression in an array initializer and is ignored.

Each variable initializer must be assignment-compatible ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")) with the array's component type, or a compile-time error occurs.

It is a compile-time error if the component type of the array being initialized is not reifiable ([¬ß4.7](jls-4.html#jls-4.7 "4.7. Reifiable Types")).

The length of the array to be constructed is equal to the number of variable initializers immediately enclosed by the braces of the array initializer. Space is allocated for a new array of that length. If there is insufficient space to allocate the array, evaluation of the array initializer completes abruptly by throwing an `OutOfMemoryError`. Otherwise, a one-dimensional array is created of the specified length, and each component of the array is initialized to its default value ([¬ß4.12.5](jls-4.html#jls-4.12.5 "4.12.5. Initial Values of Variables")).

The variable initializers immediately enclosed by the braces of the array initializer are then executed from left to right in the textual order they occur in the source code. The _n_'th variable initializer specifies the value of the _n_\-1'th array component. If execution of a variable initializer completes abruptly, then execution of the array initializer completes abruptly for the same reason. If all the variable initializer expressions complete normally, the array initializer completes normally, with the value of the newly initialized array.

If the component type is an array type, then the variable initializer specifying a component may itself be an array initializer; that is, array initializers may be nested. In this case, execution of the nested array initializer constructs and initializes an array object by recursive application of the algorithm above, and assigns it to the component.

**Example 10.6-1. Array Initializers**

class Test {
    public static void main(String\[\] args) {
        int ia\[\]\[\] = { {1, 2}, null };
        for (int\[\] ea : ia) {
            for (int e: ea) {
                System.out.println(e);
            }
        }
    }
}

This program produces the output:

1
2

before causing a `NullPointerException` in trying to index the second component of the array `ia`, which is a null reference.

  

10.7. Array Members
-------------------

The members of an array type are all of the following:

*   The `public` `final` field `length`, which contains the number of components of the array. `length` may be positive or zero.
*   The `public` method `clone`, which overrides the method of the same name in class `Object` and throws no checked exceptions. The return type of the `clone` method of an array type T`[]` is T`[]`.
    
    A clone of a multidimensional array is shallow, which is to say that it creates only a single new array. Subarrays are shared.
*   All the members inherited from class `Object`; the only method of `Object` that is not inherited is its `clone` method.
    
    See [¬ß9.6.4.4](jls-9.html#jls-9.6.4.4 "9.6.4.4. @Override") for another situation where the difference between `public` and non-`public` methods of `Object` requires special care.
    

An array thus has the same `public` fields and methods as the following class:

class A<T> implements Cloneable, java.io.Serializable {
    public final int length = X;
    public T\[\] clone() {
        try {
            return (T\[\])super.clone();
        } catch (CloneNotSupportedException e) {
            throw new InternalError(e.getMessage());
        }
    }
}

Note that the cast to `T[]` in the code above would generate an unchecked warning ([¬ß5.1.9](jls-5.html#jls-5.1.9 "5.1.9. Unchecked Conversion")) if arrays were really implemented this way.

**Example 10.7-1. Arrays Are Cloneable**

class Test1 {
    public static void main(String\[\] args) {
        int ia1\[\] = { 1, 2 };
        int ia2\[\] = ia1.clone();
        System.out.print((ia1 == ia2) + " ");
        ia1\[1\]++;
        System.out.println(ia2\[1\]);
    }
}

This program produces the output:

false 2

showing that the components of the arrays referenced by `ia1` and `ia2` are different variables.

  

**Example 10.7-2. Shared Subarrays After A Clone**

The fact that subarrays are shared when a multidimensional array is cloned is shown by this program:

class Test2 {
    public static void main(String\[\] args) throws Throwable {
        int ia\[\]\[\] = { {1,2}, null };
        int ja\[\]\[\] = ia.clone();
        System.out.print((ia == ja) + " ");
        System.out.println(ia\[0\] == ja\[0\] && ia\[1\] == ja\[1\]);
    }
}

This program produces the output:

false true

showing that the `int[]` array that is `ia[0]` and the `int[]` array that is `ja[0]` are the same array.

  

10.8. `Class` Objects for Arrays
--------------------------------

Every array has an associated `Class` object, shared with all other arrays with the same component type.

Although an array type is not a class, the `Class` object of every array acts as if:

*   The direct superclass of every array type is `Object`.
*   Every array type implements the interfaces `Cloneable` and `java.io.Serializable`.
    

**Example 10.8-1. `Class` Object Of Array**

class Test1 {
    public static void main(String\[\] args) {
        int\[\] ia = new int\[3\];
        System.out.println(ia.getClass());
        System.out.println(ia.getClass().getSuperclass());
        for (Class<?> c : ia.getClass().getInterfaces())
            System.out.println("Superinterface: " + c);
    }
}

This program produces the output:

class \[I
class java.lang.Object
Superinterface: interface java.lang.Cloneable
Superinterface: interface java.io.Serializable

where the string "`[I`" is the run-time type signature for the `Class` object "array with component type `int`".

  

**Example 10.8-2. Array `Class` Objects Are Shared**

class Test2 {
    public static void main(String\[\] args) {
        int\[\] ia = new int\[3\];
        int\[\] ib = new int\[6\];
        System.out.println(ia == ib);
        System.out.println(ia.getClass() == ib.getClass());
    }
}

This program produces the output:

false
true

While `ia` and `ib` refer to different arrays, the result of the comparison of the `Class` objects demonstrates that all arrays whose components are of type `int` are instances of the same array type (namely `int``[]`).

  

10.9. An Array of Characters Is Not a `String`
----------------------------------------------

In the Java programming language, unlike C, an array of `char` is not a `String`, and neither a `String` nor an array of `char` is terminated by '`\u0000`' (the NUL character).

A `String` object is immutable, that is, its contents never change, while an array of `char` has mutable elements.

The method `toCharArray` in class `String` returns an array of characters containing the same character sequence as a `String`. The class `StringBuffer` implements useful methods on mutable arrays of characters.

üçÄ Chapter 11. Exceptions
----------------------

**Table of Contents**

[11.1. The Kinds and Causes of Exceptions](jls-11.html#jls-11.1)
[11.1.1. The Kinds of Exceptions](jls-11.html#jls-11.1.1)
[11.1.2. The Causes of Exceptions](jls-11.html#jls-11.1.2)
[11.1.3. Asynchronous Exceptions](jls-11.html#jls-11.1.3)
[11.2. Compile-Time Checking of Exceptions](jls-11.html#jls-11.2)
[11.2.1. Exception Analysis of Expressions](jls-11.html#jls-11.2.1)
[11.2.2. Exception Analysis of Statements](jls-11.html#jls-11.2.2)
[11.2.3. Exception Checking](jls-11.html#jls-11.2.3)
[11.3. Run-Time Handling of an Exception](jls-11.html#jls-11.3)

When a program violates the semantic constraints of the Java programming language, the Java Virtual Machine signals this error to the program as an _exception_.

An example of such a violation is an attempt to index outside the bounds of an array. Some programming languages and their implementations react to such errors by peremptorily terminating the program; other programming languages allow an implementation to react in an arbitrary or unpredictable way. Neither of these approaches is compatible with the design goals of the Java SE platform: to provide portability and robustness.

Instead, the Java programming language specifies that an exception will be thrown when semantic constraints are violated and will cause a non-local transfer of control from the point where the exception occurred to a point that can be specified by the programmer.

An exception is said to be _thrown_ from the point where it occurred and is said to be _caught_ at the point to which control is transferred.

Programs can also throw exceptions explicitly, using `throw` statements ([¬ß14.18](jls-14.html#jls-14.18 "14.18. The throw Statement")).

Explicit use of `throw` statements provides an alternative to the old-fashioned style of handling error conditions by returning funny values, such as the integer value `-1` where a negative value would not normally be expected. Experience shows that too often such funny values are ignored or not checked for by callers, leading to programs that are not robust, exhibit undesirable behavior, or both.

Every exception is represented by an instance of the class `Throwable` or one of its subclasses ([¬ß11.1](jls-11.html#jls-11.1 "11.1. The Kinds and Causes of Exceptions")). Such an object can be used to carry information from the point at which an exception occurs to the handler that catches it. Handlers are established by `catch` clauses of `try` statements ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")).

During the process of throwing an exception, the Java Virtual Machine abruptly completes, one by one, any expressions, statements, method and constructor invocations, initializers, and field initialization expressions that have begun but not completed execution in the current thread. This process continues until a handler is found that indicates that it handles that particular exception by naming the class of the exception or a superclass of the class of the exception ([¬ß11.2](jls-11.html#jls-11.2 "11.2. Compile-Time Checking of Exceptions")). If no such handler is found, then the exception may be handled by one of a hierarchy of uncaught exception handlers ([¬ß11.3](jls-11.html#jls-11.3 "11.3. Run-Time Handling of an Exception")) - thus every effort is made to avoid letting an exception go unhandled.

The exception mechanism of the Java SE platform is integrated with its synchronization model ([¬ß17.1](jls-17.html#jls-17.1 "17.1. Synchronization")), so that monitors are unlocked as `synchronized` statements ([¬ß14.19](jls-14.html#jls-14.19 "14.19. The synchronized Statement")) and invocations of `synchronized` methods ([¬ß8.4.3.6](jls-8.html#jls-8.4.3.6 "8.4.3.6. synchronized Methods"), [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")) complete abruptly.

11.1. The Kinds and Causes of Exceptions
----------------------------------------

### 11.1.1. The Kinds of Exceptions

An exception is represented by an instance of the class `Throwable` (a direct subclass of `Object`) or one of its subclasses.

`Throwable` and all its subclasses are, collectively, the _exception classes_.

The classes `Exception` and `Error` are direct subclasses of `Throwable`:

*   `Exception` is the superclass of all the exceptions from which ordinary programs may wish to recover.
    
    The class `RuntimeException` is a direct subclass of `Exception`. `RuntimeException` is the superclass of all the exceptions which may be thrown for many reasons during expression evaluation, but from which recovery may still be possible.
    
    `RuntimeException` and all its subclasses are, collectively, the _run-time exception classes_.
*   `Error` is the superclass of all the exceptions from which ordinary programs are not ordinarily expected to recover.
    
    `Error` and all its subclasses are, collectively, the _error classes_.
    

The _unchecked exception classes_ are the run-time exception classes and the error classes.

The _checked exception classes_ are all exception classes other than the unchecked exception classes. That is, the checked exception classes are `Throwable` and all its subclasses other than `RuntimeException` and its subclasses and `Error` and its subclasses.

Programs can use the pre-existing exception classes of the Java SE platform API in `throw` statements, or define additional exception classes as subclasses of `Throwable` or of any of its subclasses, as appropriate. To take advantage of compile-time checking for exception handlers ([¬ß11.2](jls-11.html#jls-11.2 "11.2. Compile-Time Checking of Exceptions")), it is typical to define most new exception classes as checked exception classes, that is, as subclasses of `Exception` that are not subclasses of `RuntimeException`.

The class `Error` is a separate subclass of `Throwable`, distinct from `Exception` in the class hierarchy, to allow programs to use the idiom "`} catch (Exception e) {`" ([¬ß11.2.3](jls-11.html#jls-11.2.3 "11.2.3. Exception Checking")) to catch all exceptions from which recovery may be possible without catching errors from which recovery is typically not possible.

Note that a subclass of `Throwable` cannot be generic ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters")).

### 11.1.2. The Causes of Exceptions

An exception is thrown for one of three reasons:

*   A `throw` statement ([¬ß14.18](jls-14.html#jls-14.18 "14.18. The throw Statement")) was executed.
*   An abnormal execution condition was synchronously detected by the Java Virtual Machine, namely:
    
    *   evaluation of an expression violates the normal semantics of the Java programming language ([¬ß15.6](jls-15.html#jls-15.6 "15.6. Normal and Abrupt Completion of Evaluation")), such as an integer divide by zero.
        
    *   an error occurs while loading, linking, or initializing part of the program ([¬ß12.2](jls-12.html#jls-12.2 "12.2. Loading of Classes and Interfaces"), [¬ß12.3](jls-12.html#jls-12.3 "12.3. Linking of Classes and Interfaces"), [¬ß12.4](jls-12.html#jls-12.4 "12.4. Initialization of Classes and Interfaces")); in this case, an instance of a subclass of `LinkageError` is thrown.
        
    *   an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language; in this case, an instance of a subclass of `VirtualMachineError` is thrown.
        
    
    These exceptions are not thrown at an arbitrary point in the program, but rather at a point where they are specified as a possible result of an expression evaluation or statement execution.
*   An asynchronous exception occurred ([¬ß11.1.3](jls-11.html#jls-11.1.3 "11.1.3. Asynchronous Exceptions")).
    

### 11.1.3. Asynchronous Exceptions

Most exceptions occur synchronously as a result of an action by the thread in which they occur, and at a point in the program that is specified to possibly result in such an exception. An _asynchronous exception_ is, by contrast, an exception that can potentially occur at any point in the execution of a program.

Asynchronous exceptions occur only as a result of:

*   An invocation of the (deprecated) `stop` method of class `Thread` or `ThreadGroup`.
    
    The (deprecated) `stop` methods may be invoked by one thread to affect another thread or all the threads in a specified thread group. They are asynchronous because they may occur at any point in the execution of the other thread or threads.
*   An internal error or resource limitation in the Java Virtual Machine that prevents it from implementing the semantics of the Java programming language. In this case, the asynchronous exception that is thrown is an instance of a subclass of `VirtualMachineError`.
    
    Note that `StackOverflowError`, a subclass of `VirtualMachineError`, may be thrown synchronously by method invocation ([¬ß15.12.4.5](jls-15.html#jls-15.12.4.5 "15.12.4.5. Create Frame, Synchronize, Transfer Control")) as well as asynchronously due to `native` method execution or Java Virtual Machine resource limitations. Similarly, `OutOfMemoryError`, another subclass of `VirtualMachineError`, may be thrown synchronously during class instance creation ([¬ß15.9.4](jls-15.html#jls-15.9.4 "15.9.4. Run-Time Evaluation of Class Instance Creation Expressions"), [¬ß12.5](jls-12.html#jls-12.5 "12.5. Creation of New Class Instances")), array creation ([¬ß15.10.2](jls-15.html#jls-15.10.2 "15.10.2. Run-Time Evaluation of Array Creation Expressions"), [¬ß10.6](jls-10.html#jls-10.6 "10.6. Array Initializers")), class initialization ([¬ß12.4.2](jls-12.html#jls-12.4.2 "12.4.2. Detailed Initialization Procedure")), and boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")), as well as asynchronously.
    

The Java SE platform permits a small but bounded amount of execution to occur before an asynchronous exception is thrown.

Asynchronous exceptions are rare, but proper understanding of their semantics is necessary if high-quality machine code is to be generated.

The delay noted above is permitted to allow optimized code to detect and throw these exceptions at points where it is practical to handle them while obeying the semantics of the Java programming language. A simple implementation might poll for asynchronous exceptions at the point of each control transfer instruction. Since a program has a finite size, this provides a bound on the total delay in detecting an asynchronous exception. Since no asynchronous exception will occur between control transfers, the code generator has some flexibility to reorder computation between control transfers for greater performance. The paper _Polling Efficiently on Stock Hardware_ by Marc Feeley, _Proc. 1993 Conference on Functional Programming and Computer Architecture_, Copenhagen, Denmark, pp. 179-187, is recommended as further reading.

11.2. Compile-Time Checking of Exceptions
-----------------------------------------

The Java programming language requires that a program contains handlers for _checked exceptions_ which can result from execution of a method or constructor ([¬ß8.4.6](jls-8.html#jls-8.4.6 "8.4.6. Method Throws"), [¬ß8.8.5](jls-8.html#jls-8.8.5 "8.8.5. Constructor Throws")). This compile-time checking for the presence of exception handlers is designed to reduce the number of exceptions which are not properly handled. For each checked exception which is a possible result, the `throws` clause for the method or constructor must mention the class of that exception or one of the superclasses of the class of that exception ([¬ß11.2.3](jls-11.html#jls-11.2.3 "11.2.3. Exception Checking")).

The checked exception classes ([¬ß11.1.1](jls-11.html#jls-11.1.1 "11.1.1. The Kinds of Exceptions")) named in the `throws` clause are part of the contract between the implementor and user of the method or constructor. The `throws` clause of an overriding method may not specify that this method will result in throwing any checked exception which the overridden method is not permitted, by its `throws` clause, to throw ([¬ß8.4.8.3](jls-8.html#jls-8.4.8.3 "8.4.8.3. Requirements in Overriding and Hiding")). When interfaces are involved, more than one method declaration may be overridden by a single overriding declaration. In this case, the overriding declaration must have a `throws` clause that is compatible with all the overridden declarations ([¬ß9.4.1](jls-9.html#jls-9.4.1 "9.4.1. Inheritance and Overriding")).

The unchecked exception classes ([¬ß11.1.1](jls-11.html#jls-11.1.1 "11.1.1. The Kinds of Exceptions")) are exempted from compile-time checking.

Error classes are exempted because they can occur at many points in the program and recovery from them is difficult or impossible. A program declaring such exceptions would be cluttered, pointlessly. Sophisticated programs may yet wish to catch and attempt to recover from some of these conditions.

Run-time exception classes are exempted because, in the judgment of the designers of the Java programming language, having to declare such exceptions would not aid significantly in establishing the correctness of programs. Many of the operations and constructs of the Java programming language can result in exceptions at run time. The information available to a Java compiler, and the level of analysis a compiler performs, are usually not sufficient to establish that such run-time exceptions cannot occur, even though this may be obvious to the programmer. Requiring such exception classes to be declared would simply be an irritation to programmers.

For example, certain code might implement a circular data structure that, by construction, can never involve null references; the programmer can then be certain that a `NullPointerException` cannot occur, but it would be difficult for a Java compiler to prove it. The theorem-proving technology that is needed to establish such global properties of data structures is beyond the scope of this specification.

We say that a statement or expression _can throw_ an exception class E if, according to the rules in [¬ß11.2.1](jls-11.html#jls-11.2.1 "11.2.1. Exception Analysis of Expressions") and [¬ß11.2.2](jls-11.html#jls-11.2.2 "11.2.2. Exception Analysis of Statements"), the execution of the statement or expression can result in an exception of class E being thrown.

We say that a `catch` clause _can catch_ its catchable exception class(es):

*   The catchable exception class of a uni-`catch` clause is the declared type of its exception parameter ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")).
*   The catchable exception classes of a multi-`catch` clause are the alternatives in the union that denotes the type of its exception parameter.
    

### 11.2.1. Exception Analysis of Expressions

A class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")) can throw an exception class E iff either:

*   The expression is a qualified class instance creation expression and the qualifying expression can throw E; or
*   Some expression of the argument list can throw E; or
*   E is one of the exception types of the invocation type of the chosen constructor ([¬ß15.12.2.6](jls-15.html#jls-15.12.2.6 "15.12.2.6. Method Invocation Type")); or
*   The class instance creation expression includes a _ClassBody_, and some instance initializer or instance variable initializer in the _ClassBody_ can throw E.
    

A method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")) can throw an exception class E iff either:

*   The method invocation expression is of the form _Primary_ `.` _\[TypeArguments\]_ _Identifier_ and the _Primary_ expression can throw E; or
*   Some expression of the argument list can throw E; or
*   E is one of the exception types of the invocation type of the chosen method ([¬ß15.12.2.6](jls-15.html#jls-15.12.2.6 "15.12.2.6. Method Invocation Type")).
    

A lambda expression ([¬ß15.27](jls-15.html#jls-15.27 "15.27. Lambda Expressions")) can throw no exception classes.

For every other kind of expression, the expression can throw an exception class E iff one of its immediate subexpressions can throw E.

Note that a method reference expression ([¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions")) of the form _Primary `::` \[TypeArguments\] Identifier_ can throw an exception class if the _Primary_ subexpression can throw an exception class. In contrast, a lambda expression can throw nothing, and has no immediate subexpressions on which to perform exception analysis. It is the _body_ of a lambda expression, containing expressions and statements, that can throw exception classes.

### 11.2.2. Exception Analysis of Statements

A `throw` statement ([¬ß14.18](jls-14.html#jls-14.18 "14.18. The throw Statement")) whose thrown expression has static type E and is not a final or effectively final exception parameter can throw E or any exception class that the thrown expression can throw.

For example, the statement `throw new java.io.FileNotFoundException();` can throw `java.io.FileNotFoundException` only. Formally, it is not the case that it "can throw" a subclass or superclass of `java.io.FileNotFoundException`.

A `throw` statement whose thrown expression is a final or effectively final exception parameter of a `catch` clause C can throw an exception class E iff:

*   E is an exception class that the `try` block of the `try` statement which declares C can throw; and
*   E is assignment compatible with any of C's catchable exception classes; and
*   E is not assignment compatible with any of the catchable exception classes of the `catch` clauses declared to the left of C in the same `try` statement.
    

A `try` statement ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) can throw an exception class E iff either:

*   The `try` block can throw E, or an expression used to initialize a resource (in a `try`\-with-resources statement) can throw E, or the automatic invocation of the `close()` method of a resource (in a `try`\-with-resources statement) can throw E, and E is not assignment compatible with any catchable exception class of any `catch` clause of the `try` statement, and either no `finally` block is present or the `finally` block can complete normally; or
*   Some `catch` block of the `try` statement can throw E and either no `finally` block is present or the `finally` block can complete normally; or
*   A `finally` block is present and can throw E.
    

An explicit constructor invocation statement ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations")) can throw an exception class E iff either:

*   Some expression of the constructor invocation's parameter list can throw E; or
*   E is determined to be an exception class of the `throws` clause of the constructor that is invoked ([¬ß15.12.2.6](jls-15.html#jls-15.12.2.6 "15.12.2.6. Method Invocation Type")).
    

Any other statement _S_ can throw an exception class E iff an expression or statement immediately contained in _S_ can throw E.

### 11.2.3. Exception Checking

It is a compile-time error if a method or constructor body _can throw_ some exception class E when E is a checked exception class and E is not a subclass of some class declared in the `throws` clause of the method or constructor.

It is a compile-time error if a lambda body _can throw_ some exception class E when E is a checked exception class and E is not a subclass of some class declared in the `throws` clause of the function type targeted by the lambda expression.

It is a compile-time error if a class variable initializer ([¬ß8.3.2](jls-8.html#jls-8.3.2 "8.3.2. Field Initialization")) or static initializer ([¬ß8.7](jls-8.html#jls-8.7 "8.7. Static Initializers")) of a named class or interface _can throw_ a checked exception class.

It is a compile-time error if an instance variable initializer ([¬ß8.3.2](jls-8.html#jls-8.3.2 "8.3.2. Field Initialization")) or instance initializer ([¬ß8.6](jls-8.html#jls-8.6 "8.6. Instance Initializers")) of a named class _can throw_ a checked exception class, unless the named class has at least one explicitly declared constructor and the exception class or one of its superclasses is explicitly declared in the `throws` clause of each constructor.

Note that no compile-time error is due if an instance variable initializer or instance initializer of an anonymous class ([¬ß15.9.5](jls-15.html#jls-15.9.5 "15.9.5. Anonymous Class Declarations")) can throw an exception class. In a named class, it is the responsibility of the programmer to propagate information about which exception classes can be thrown by initializers, by declaring a suitable `throws` clause on any explicit constructor declaration. This relationship between the checked exception classes thrown by a class's initializers and the checked exception classes declared by a class's constructors is assured for an anonymous class declaration, because no explicit constructor declarations are possible and a Java compiler always generates a constructor with a suitable `throws` clause for the anonymous class declaration based on the checked exception classes that its initializers can throw.

It is a compile-time error if a `catch` clause _can catch_ checked exception class E1 and it is not the case that the `try` block corresponding to the `catch` clause _can throw_ a checked exception class that is a subclass or superclass of E1, unless E1 is `Exception` or a superclass of `Exception`.

It is a compile-time error if a `catch` clause _can catch_ an exception class E1 and a preceding `catch` clause of the immediately enclosing `try` statement _can catch_ E1 or a superclass of E1.

A Java compiler is encouraged to issue a warning if a `catch` clause can catch checked exception class E1 and the `try` block corresponding to the `catch` clause can throw checked exception class E2, where E2 `<:` E1, and a preceding `catch` clause of the immediately enclosing `try` statement can catch checked exception class E3, where E2 `<:` E3 `<:` E1.

**Example 11.2.3-1. Catching Checked Exceptions**

import java.io.\*;

class StaticallyThrownExceptionsIncludeSubtypes {
    public static void main(String\[\] args) {
        try {
            throw new FileNotFoundException();
        } catch (IOException ioe) {
            // "catch IOException" catches IOException 
            // and any subtype.
        }

        try {
            throw new FileNotFoundException();
              // Statement "can throw" FileNotFoundException.
              // It is not the case that statement "can throw"
              // a subtype or supertype of FileNotFoundException.
        } catch (FileNotFoundException fnfe) {
            // ... Handle exception ...
        } catch (IOException ioe) {
            // Legal, but compilers are encouraged to give
            // warnings as of Java SE 7, because all subtypes of
            // IOException that the try block "can throw" have 
            // already been caught by the prior catch clause.
        }

        try {
            m();
              // m's declaration says "throws IOException", so
              // m "can throw" IOException. It is not the case
              // that m "can throw" a subtype or supertype of
              // IOException (e.g. Exception).
        } catch (FileNotFoundException fnfe) {
            // Legal, because the dynamic type of the exception 
            // might be FileNotFoundException.
        } catch (IOException ioe) {
            // Legal, because the dynamic type of the exception
            // might be a different subtype of IOException.
        } catch (Throwable t) {
            // Can always catch Throwable.
        }
    }

    static void m() throws IOException {
        throw new FileNotFoundException();
    }
}

  

By the rules above, each alternative in a multi-`catch` clause ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) must be able to catch some exception class thrown by the `try` block and uncaught by previous `catch` clauses. For example, the second `catch` clause below would cause a compile-time error because exception analysis determines that `SubclassOfFoo` is already caught by the first `catch` clause:

try { ... }
catch (Foo f) { ... }
catch (Bar | SubclassOfFoo e) { ... }

11.3. Run-Time Handling of an Exception
---------------------------------------

When an exception is thrown ([¬ß14.18](jls-14.html#jls-14.18 "14.18. The throw Statement")), control is transferred from the code that caused the exception to the nearest dynamically enclosing `catch` clause, if any, of a `try` statement ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) that can handle the exception.

A statement or expression is _dynamically enclosed_ by a `catch` clause if it appears within the `try` block of the `try` statement of which the `catch` clause is a part, or if the caller of the statement or expression is dynamically enclosed by the `catch` clause.

The caller of a statement or expression depends on where it occurs:

*   If within a method, then the caller is the method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")) that was executed to cause the method to be invoked.
*   If within a constructor or an instance initializer or the initializer for an instance variable, then the caller is the class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")) or the method invocation of `newInstance` that was executed to cause an object to be created.
*   If within a static initializer or an initializer for a `static` variable, then the caller is the expression that used the class or interface so as to cause it to be initialized ([¬ß12.4](jls-12.html#jls-12.4 "12.4. Initialization of Classes and Interfaces")).
    

Whether a particular `catch` clause _can handle_ an exception is determined by comparing the class of the object that was thrown to the catchable exception classes of the `catch` clause. The `catch` clause can handle the exception if one of its catchable exception classes is the class of the exception or a superclass of the class of the exception.

Equivalently, a `catch` clause will catch any exception object that is an `instanceof` ([¬ß15.20.2](jls-15.html#jls-15.20.2 "15.20.2. Type Comparison Operator instanceof")) one of its catchable exception classes.

The control transfer that occurs when an exception is thrown causes abrupt completion of expressions ([¬ß15.6](jls-15.html#jls-15.6 "15.6. Normal and Abrupt Completion of Evaluation")) and statements ([¬ß14.1](jls-14.html#jls-14.1 "14.1. Normal and Abrupt Completion of Statements")) until a `catch` clause is encountered that can handle the exception; execution then continues by executing the block of that `catch` clause. The code that caused the exception is never resumed.

All exceptions (synchronous and asynchronous) are _precise_: when the transfer of control takes place, all effects of the statements executed and expressions evaluated before the point from which the exception is thrown must appear to have taken place. No expressions, statements, or parts thereof that occur after the point from which the exception is thrown may appear to have been evaluated.

If optimized code has speculatively executed some of the expressions or statements which follow the point at which the exception occurs, such code must be prepared to hide this speculative execution from the user-visible state of the program.

If no `catch` clause that can handle an exception can be found, then the current thread (the thread that encountered the exception) is terminated. Before termination, all `finally` clauses are executed and the uncaught exception is handled according to the following rules:

*   If the current thread has an uncaught exception handler set, then that handler is executed.
*   Otherwise, the method `uncaughtException` is invoked for the `ThreadGroup` that is the parent of the current thread. If the `ThreadGroup` and its parent `ThreadGroup`s do not override `uncaughtException`, then the default handler's `uncaughtException` method is invoked.
    

In situations where it is desirable to ensure that one block of code is always executed after another, even if that other block of code completes abruptly, a `try` statement with a `finally` clause ([¬ß14.20.2](jls-14.html#jls-14.20.2 "14.20.2. Execution of try-finally and try-catch-finally")) may be used.

If a `try` or `catch` block in a `try`\-`finally` or `try`\-`catch`\-`finally` statement completes abruptly, then the `finally` clause is executed during propagation of the exception, even if no matching `catch` clause is ultimately found.

If a `finally` clause is executed because of abrupt completion of a `try` block and the `finally` clause itself completes abruptly, then the reason for the abrupt completion of the `try` block is discarded and the new reason for abrupt completion is propagated from there.

The exact rules for abrupt completion and for the catching of exceptions are specified in detail with the specification of each statement in [¬ß14 (_Blocks and Statements_)](jls-14.html "Chapter 14. Blocks and Statements") and for expressions in [¬ß15 (_Expressions_)](jls-15.html "Chapter 15. Expressions") (especially [¬ß15.6](jls-15.html#jls-15.6 "15.6. Normal and Abrupt Completion of Evaluation")).

**Example 11.3-1. Throwing and Catching Exceptions**

The following program declares an exception class `TestException`. The `main` method of class `Test` invokes the `thrower` method four times, causing exceptions to be thrown three of the four times. The `try` statement in method `main` catches each exception that the thrower throws. Whether the invocation of `thrower` completes normally or abruptly, a message is printed describing what happened.

class TestException extends Exception {
    TestException()         { super(); }
    TestException(String s) { super(s); }
}

class Test {
    public static void main(String\[\] args) {
        for (String arg : args) {
            try {
                thrower(arg);
                System.out.println("Test \\"" + arg +
                                   "\\" didn't throw an exception");
            } catch (Exception e) {
                System.out.println("Test \\"" + arg +
                                   "\\" threw a " + e.getClass() +
                                   "\\n    with message: " +
                                   e.getMessage());
            }
        }
    }
    static int thrower(String s) throws TestException {
        try {
            if (s.equals("divide")) {
                int i = 0;
                return i/i;
            }
            if (s.equals("null")) {
                s = null;
                return s.length();
            }
            if (s.equals("test")) {
                throw new TestException("Test message");
            }
            return 0;
        } finally {
            System.out.println("\[thrower(\\"" + s + "\\") done\]");
        }
    }
}

If we execute the program, passing it the arguments:

divide null not test

it produces the output:

\[thrower("divide") done\]
Test "divide" threw a class java.lang.ArithmeticException
    with message: / by zero
\[thrower("null") done\]
Test "null" threw a class java.lang.NullPointerException
    with message: null
\[thrower("not") done\]
Test "not" didn't throw an exception
\[thrower("test") done\]
Test "test" threw a class TestException
    with message: Test message

The declaration of the method `thrower` must have a `throws` clause because it can throw instances of `TestException`, which is a checked exception class ([¬ß11.1.1](jls-11.html#jls-11.1.1 "11.1.1. The Kinds of Exceptions")). A compile-time error would occur if the `throws` clause were omitted.

Notice that the `finally` clause is executed on every invocation of `thrower`, whether or not an exception occurs, as shown by the "`[thrower(...) done]`" output that occurs for each invocation.

  

üçÄ Chapter 12. Execution
---------------------

**Table of Contents**

[12.1. Java Virtual Machine Startup](jls-12.html#jls-12.1)
[12.1.1. Load the Class `Test`](jls-12.html#jls-12.1.1)
[12.1.2. Link `Test`: Verify, Prepare, (Optionally) Resolve](jls-12.html#jls-12.1.2)
[12.1.3. Initialize Test: Execute Initializers](jls-12.html#jls-12.1.3)
[12.1.4. Invoke `Test.main`](jls-12.html#jls-12.1.4)
[12.2. Loading of Classes and Interfaces](jls-12.html#jls-12.2)
[12.2.1. The Loading Process](jls-12.html#jls-12.2.1)
[12.3. Linking of Classes and Interfaces](jls-12.html#jls-12.3)
[12.3.1. Verification of the Binary Representation](jls-12.html#jls-12.3.1)
[12.3.2. Preparation of a Class or Interface Type](jls-12.html#jls-12.3.2)
[12.3.3. Resolution of Symbolic References](jls-12.html#jls-12.3.3)
[12.4. Initialization of Classes and Interfaces](jls-12.html#jls-12.4)
[12.4.1. When Initialization Occurs](jls-12.html#jls-12.4.1)
[12.4.2. Detailed Initialization Procedure](jls-12.html#jls-12.4.2)
[12.5. Creation of New Class Instances](jls-12.html#jls-12.5)
[12.6. Finalization of Class Instances](jls-12.html#jls-12.6)
[12.6.1. Implementing Finalization](jls-12.html#jls-12.6.1)
[12.6.2. Interaction with the Memory Model](jls-12.html#jls-12.6.2)
[12.7. Unloading of Classes and Interfaces](jls-12.html#jls-12.7)
[12.8. Program Exit](jls-12.html#jls-12.8)

This chapter specifies activities that occur during execution of a program. It is organized around the life cycle of the Java Virtual Machine and of the classes, interfaces, and objects that form a program.

The Java Virtual Machine starts up by loading a specified class and then invoking the method `main` in this specified class. Section [¬ß12.1](jls-12.html#jls-12.1 "12.1. Java Virtual Machine Startup") outlines the loading, linking, and initialization steps involved in executing `main`, as an introduction to the concepts in this chapter. Further sections specify the details of loading ([¬ß12.2](jls-12.html#jls-12.2 "12.2. Loading of Classes and Interfaces")), linking ([¬ß12.3](jls-12.html#jls-12.3 "12.3. Linking of Classes and Interfaces")), and initialization ([¬ß12.4](jls-12.html#jls-12.4 "12.4. Initialization of Classes and Interfaces")).

The chapter continues with a specification of the procedures for creation of new class instances ([¬ß12.5](jls-12.html#jls-12.5 "12.5. Creation of New Class Instances")); and finalization of class instances ([¬ß12.6](jls-12.html#jls-12.6 "12.6. Finalization of Class Instances")). It concludes by describing the unloading of classes ([¬ß12.7](jls-12.html#jls-12.7 "12.7. Unloading of Classes and Interfaces")) and the procedure followed when a program exits ([¬ß12.8](jls-12.html#jls-12.8 "12.8. Program Exit")).

12.1. Java Virtual Machine Startup
----------------------------------

The Java Virtual Machine starts execution by invoking the method `main` of some specified class, passing it a single argument, which is an array of strings. In the examples in this specification, this first class is typically called `Test`.

The precise semantics of Java Virtual Machine startup are given in Chapter 5 of _The Java Virtual Machine Specification, Java SE 8 Edition_. Here we present an overview of the process from the viewpoint of the Java programming language.

The manner in which the initial class is specified to the Java Virtual Machine is beyond the scope of this specification, but it is typical, in host environments that use command lines, for the fully-qualified name of the class to be specified as a command-line argument and for following command-line arguments to be used as strings to be provided as the argument to the method `main`.

For example, in a UNIX implementation, the command line:

java Test reboot Bob Dot Enzo

will typically start a Java Virtual Machine by invoking method `main` of class `Test` (a class in an unnamed package), passing it an array containing the four strings "`reboot`", "`Bob`", "`Dot`", and "`Enzo`".

We now outline the steps the Java Virtual Machine may take to execute `Test`, as an example of the loading, linking, and initialization processes that are described further in later sections.

### 12.1.1. Load the Class `Test`

The initial attempt to execute the method `main` of class `Test` discovers that the class `Test` is not loaded - that is, that the Java Virtual Machine does not currently contain a binary representation for this class. The Java Virtual Machine then uses a class loader to attempt to find such a binary representation. If this process fails, then an error is thrown. This loading process is described further in [¬ß12.2](jls-12.html#jls-12.2 "12.2. Loading of Classes and Interfaces").

### 12.1.2. Link `Test`: Verify, Prepare, (Optionally) Resolve

After `Test` is loaded, it must be initialized before `main` can be invoked. And `Test`, like all (class or interface) types, must be linked before it is initialized. Linking involves verification, preparation, and (optionally) resolution. Linking is described further in [¬ß12.3](jls-12.html#jls-12.3 "12.3. Linking of Classes and Interfaces").

Verification checks that the loaded representation of `Test` is well-formed, with a proper symbol table. Verification also checks that the code that implements `Test` obeys the semantic requirements of the Java programming language and the Java Virtual Machine. If a problem is detected during verification, then an error is thrown. Verification is described further in [¬ß12.3.1](jls-12.html#jls-12.3.1 "12.3.1. Verification of the Binary Representation").

Preparation involves allocation of static storage and any data structures that are used internally by the implementation of the Java Virtual Machine, such as method tables. Preparation is described further in [¬ß12.3.2](jls-12.html#jls-12.3.2 "12.3.2. Preparation of a Class or Interface Type").

Resolution is the process of checking symbolic references from `Test` to other classes and interfaces, by loading the other classes and interfaces that are mentioned and checking that the references are correct.

The resolution step is optional at the time of initial linkage. An implementation may resolve symbolic references from a class or interface that is being linked very early, even to the point of resolving all symbolic references from the classes and interfaces that are further referenced, recursively. (This resolution may result in errors from these further loading and linking steps.) This implementation choice represents one extreme and is similar to the kind of "static" linkage that has been done for many years in simple implementations of the C language. (In these implementations, a compiled program is typically represented as an "`a.out`" file that contains a fully-linked version of the program, including completely resolved links to library routines used by the program. Copies of these library routines are included in the "`a.out`" file.)

An implementation may instead choose to resolve a symbolic reference only when it is actively used; consistent use of this strategy for all symbolic references would represent the "laziest" form of resolution. In this case, if `Test` had several symbolic references to another class, then the references might be resolved one at a time, as they are used, or perhaps not at all, if these references were never used during execution of the program.

The only requirement on when resolution is performed is that any errors detected during resolution must be thrown at a point in the program where some action is taken by the program that might, directly or indirectly, require linkage to the class or interface involved in the error. Using the "static" example implementation choice described above, loading and linkage errors could occur before the program is executed if they involved a class or interface mentioned in the class `Test` or any of the further, recursively referenced, classes and interfaces. In a system that implemented the "laziest" resolution, these errors would be thrown only when an incorrect symbolic reference is actively used.

The resolution process is described further in [¬ß12.3.3](jls-12.html#jls-12.3.3 "12.3.3. Resolution of Symbolic References").

### 12.1.3. Initialize Test: Execute Initializers

In our continuing example, the Java Virtual Machine is still trying to execute the method `main` of class `Test`. This is permitted only if the class has been initialized ([¬ß12.4.1](jls-12.html#jls-12.4.1 "12.4.1. When Initialization Occurs")).

Initialization consists of execution of any class variable initializers and static initializers of the class `Test`, in textual order. But before `Test` can be initialized, its direct superclass must be initialized, as well as the direct superclass of its direct superclass, and so on, recursively. In the simplest case, `Test` has `Object` as its implicit direct superclass; if class `Object` has not yet been initialized, then it must be initialized before `Test` is initialized. Class `Object` has no superclass, so the recursion terminates here.

If class `Test` has another class `Super` as its superclass, then `Super` must be initialized before `Test`. This requires loading, verifying, and preparing `Super` if this has not already been done and, depending on the implementation, may also involve resolving the symbolic references from `Super` and so on, recursively.

Initialization may thus cause loading, linking, and initialization errors, including such errors involving other types.

The initialization process is described further in [¬ß12.4](jls-12.html#jls-12.4 "12.4. Initialization of Classes and Interfaces").

### 12.1.4. Invoke `Test.main`

Finally, after completion of the initialization for class `Test` (during which other consequential loading, linking, and initializing may have occurred), the method `main` of `Test` is invoked.

The method `main` must be declared `public`, `static`, and `void`. It must specify a formal parameter ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters")) whose declared type is array of `String`. Therefore, either of the following declarations is acceptable:

public static void main(String\[\] args)

public static void main(String... args)

12.2. Loading of Classes and Interfaces
---------------------------------------

_Loading_ refers to the process of finding the binary form of a class or interface type with a particular name, perhaps by computing it on the fly, but more typically by retrieving a binary representation previously computed from source code by a Java compiler, and constructing, from that binary form, a `Class` object to represent the class or interface.

The precise semantics of loading are given in Chapter 5 of _The Java Virtual Machine Specification, Java SE 8 Edition_. Here we present an overview of the process from the viewpoint of the Java programming language.

The binary format of a class or interface is normally the `class` file format described in _The Java Virtual Machine Specification, Java SE 8 Edition_ cited above, but other formats are possible, provided they meet the requirements specified in [¬ß13.1](jls-13.html#jls-13.1 "13.1. The Form of a Binary"). The method `defineClass` of class `ClassLoader` may be used to construct `Class` objects from binary representations in the `class` file format.

Well-behaved class loaders maintain these properties:

*   Given the same name, a good class loader should always return the same class object.
*   If a class loader `L1` delegates loading of a class C to another loader `L2`, then for any type T that occurs as the direct superclass or a direct superinterface of C, or as the type of a field in C, or as the type of a formal parameter of a method or constructor in C, or as a return type of a method in C, `L1` and `L2` should return the same `Class` object.
    

A malicious class loader could violate these properties. However, it could not undermine the security of the type system, because the Java Virtual Machine guards against this.

For further discussion of these issues, see _The Java Virtual Machine Specification, Java SE 8 Edition_ and the paper _Dynamic Class Loading in the Java Virtual Machine_, by Sheng Liang and Gilad Bracha, in _Proceedings of OOPSLA '98_, published as _ACM SIGPLAN Notices_, Volume 33, Number 10, October 1998, pages 36-44. A basic principle of the design of the Java programming language is that the run-time type system cannot be subverted by code written in the Java programming language, not even by implementations of such otherwise sensitive system classes as `ClassLoader` and `SecurityManager`.

### 12.2.1. The Loading Process

The loading process is implemented by the class `ClassLoader` and its subclasses.

Different subclasses of `ClassLoader` may implement different loading policies. In particular, a class loader may cache binary representations of classes and interfaces, prefetch them based on expected usage, or load a group of related classes together. These activities may not be completely transparent to a running application if, for example, a newly compiled version of a class is not found because an older version is cached by a class loader. It is the responsibility of a class loader, however, to reflect loading errors only at points in the program where they could have arisen without prefetching or group loading.

If an error occurs during class loading, then an instance of one of the following subclasses of class `LinkageError` will be thrown at any point in the program that (directly or indirectly) uses the type:

*   `ClassCircularityError`: A class or interface could not be loaded because it would be its own superclass or superinterface ([¬ß8.1.4](jls-8.html#jls-8.1.4 "8.1.4. Superclasses and Subclasses"), [¬ß9.1.3](jls-9.html#jls-9.1.3 "9.1.3. Superinterfaces and Subinterfaces"), [¬ß13.4.4](jls-13.html#jls-13.4.4 "13.4.4. Superclasses and Superinterfaces")).
*   `ClassFormatError`: The binary data that purports to specify a requested compiled class or interface is malformed.
*   `NoClassDefFoundError`: No definition for a requested class or interface could be found by the relevant class loader.
    

Because loading involves the allocation of new data structures, it may fail with an `OutOfMemoryError`.

12.3. Linking of Classes and Interfaces
---------------------------------------

_Linking_ is the process of taking a binary form of a class or interface type and combining it into the run-time state of the Java Virtual Machine, so that it can be executed. A class or interface type is always loaded before it is linked.

Three different activities are involved in linking: verification, preparation, and resolution of symbolic references.

The precise semantics of linking are given in Chapter 5 of _The Java Virtual Machine Specification, Java SE 8 Edition_. Here we present an overview of the process from the viewpoint of the Java programming language.

This specification allows an implementation flexibility as to when linking activities (and, because of recursion, loading) take place, provided that the semantics of the Java programming language are respected, that a class or interface is completely verified and prepared before it is initialized, and that errors detected during linkage are thrown at a point in the program where some action is taken by the program that might require linkage to the class or interface involved in the error.

For example, an implementation may choose to resolve each symbolic reference in a class or interface individually, only when it is used (lazy or late resolution), or to resolve them all at once while the class is being verified (static resolution). This means that the resolution process may continue, in some implementations, after a class or interface has been initialized.

Because linking involves the allocation of new data structures, it may fail with an `OutOfMemoryError`.

### 12.3.1. Verification of the Binary Representation

_Verification_ ensures that the binary representation of a class or interface is structurally correct. For example, it checks that every instruction has a valid operation code; that every branch instruction branches to the start of some other instruction, rather than into the middle of an instruction; that every method is provided with a structurally correct signature; and that every instruction obeys the type discipline of the Java Virtual Machine language.

If an error occurs during verification, then an instance of the following subclass of class `LinkageError` will be thrown at the point in the program that caused the class to be verified:

*   `VerifyError`: The binary definition for a class or interface failed to pass a set of required checks to verify that it obeys the semantics of the Java Virtual Machine language and that it cannot violate the integrity of the Java Virtual Machine. (See [¬ß13.4.2](jls-13.html#jls-13.4.2 "13.4.2. final Classes"), [¬ß13.4.4](jls-13.html#jls-13.4.4 "13.4.4. Superclasses and Superinterfaces"), [¬ß13.4.9](jls-13.html#jls-13.4.9 "13.4.9. final Fields and static Constant Variables"), and [¬ß13.4.17](jls-13.html#jls-13.4.17 "13.4.17. final Methods") for some examples.)
    

### 12.3.2. Preparation of a Class or Interface Type

_Preparation_ involves creating the `static` fields (class variables and constants) for a class or interface and initializing such fields to the default values ([¬ß4.12.5](jls-4.html#jls-4.12.5 "4.12.5. Initial Values of Variables")). This does not require the execution of any source code; explicit initializers for static fields are executed as part of initialization ([¬ß12.4](jls-12.html#jls-12.4 "12.4. Initialization of Classes and Interfaces")), not preparation.

Implementations of the Java Virtual Machine may precompute additional data structures at preparation time in order to make later operations on a class or interface more efficient. One particularly useful data structure is a "method table" or other data structure that allows any method to be invoked on instances of a class without requiring a search of superclasses at invocation time.

### 12.3.3. Resolution of Symbolic References

The binary representation of a class or interface references other classes and interfaces and their fields, methods, and constructors symbolically, using the binary names ([¬ß13.1](jls-13.html#jls-13.1 "13.1. The Form of a Binary")) of the other classes and interfaces ([¬ß13.1](jls-13.html#jls-13.1 "13.1. The Form of a Binary")). For fields and methods, these symbolic references include the name of the class or interface type of which the field or method is a member, as well as the name of the field or method itself, together with appropriate type information.

Before a symbolic reference can be used it must undergo resolution, wherein a symbolic reference is checked to be correct and, typically, replaced with a direct reference that can be more efficiently processed if the reference is used repeatedly.

If an error occurs during resolution, then an error will be thrown. Most typically, this will be an instance of one of the following subclasses of the class `IncompatibleClassChangeError`, but it may also be an instance of some other subclass of `IncompatibleClassChangeError` or even an instance of the class `IncompatibleClassChangeError` itself. This error may be thrown at any point in the program that uses a symbolic reference to the type, directly or indirectly:

*   `IllegalAccessError`: A symbolic reference has been encountered that specifies a use or assignment of a field, or invocation of a method, or creation of an instance of a class, to which the code containing the reference does not have access because the field or method was declared with `private`, `protected`, or package access (not `public`), or because the class was not declared `public`.
    
    This can occur, for example, if a field that is originally declared `public` is changed to be `private` after another class that refers to the field has been compiled ([¬ß13.4.7](jls-13.html#jls-13.4.7 "13.4.7. Access to Members and Constructors")).
*   `InstantiationError`: A symbolic reference has been encountered that is used in class instance creation expression, but an instance cannot be created because the reference turns out to refer to an interface or to an abstract class.
    
    This can occur, for example, if a class that is originally not `abstract` is changed to be `abstract` after another class that refers to the class in question has been compiled ([¬ß13.4.1](jls-13.html#jls-13.4.1 "13.4.1. abstract Classes")).
*   `NoSuchFieldError`: A symbolic reference has been encountered that refers to a specific field of a specific class or interface, but the class or interface does not contain a field of that name.
    
    This can occur, for example, if a field declaration was deleted from a class after another class that refers to the field was compiled ([¬ß13.4.8](jls-13.html#jls-13.4.8 "13.4.8. Field Declarations")).
*   `NoSuchMethodError`: A symbolic reference has been encountered that refers to a specific method of a specific class or interface, but the class or interface does not contain a method of that signature.
    
    This can occur, for example, if a method declaration was deleted from a class after another class that refers to the method was compiled ([¬ß13.4.12](jls-13.html#jls-13.4.12 "13.4.12. Method and Constructor Declarations")).
    

Additionally, an `UnsatisfiedLinkError`, a subclass of `LinkageError`, may be thrown if a class declares a `native` method for which no implementation can be found. The error will occur if the method is used, or earlier, depending on what kind of resolution strategy is being used by an implementation of the Java Virtual Machine ([¬ß12.3](jls-12.html#jls-12.3 "12.3. Linking of Classes and Interfaces")).

12.4. Initialization of Classes and Interfaces
----------------------------------------------

_Initialization_ of a class consists of executing its static initializers and the initializers for `static` fields (class variables) declared in the class.

_Initialization_ of an interface consists of executing the initializers for fields (constants) declared in the interface.

### 12.4.1. When Initialization Occurs

A class or interface type T will be initialized immediately before the first occurrence of any one of the following:

*   T is a class and an instance of T is created.
*   A `static` method declared by T is invoked.
*   A `static` field declared by T is assigned.
*   A `static` field declared by T is used and the field is not a constant variable ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")).
*   T is a top level class ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")) and an `assert` statement ([¬ß14.10](jls-14.html#jls-14.10 "14.10. The assert Statement")) lexically nested within T ([¬ß8.1.3](jls-8.html#jls-8.1.3 "8.1.3. Inner Classes and Enclosing Instances")) is executed.
    

When a class is initialized, its superclasses are initialized (if they have not been previously initialized), as well as any superinterfaces ([¬ß8.1.5](jls-8.html#jls-8.1.5 "8.1.5. Superinterfaces")) that declare any default methods ([¬ß9.4.3](jls-9.html#jls-9.4.3 "9.4.3. Interface Method Body")) (if they have not been previously initialized). Initialization of an interface does not, of itself, cause initialization of any of its superinterfaces.

A reference to a `static` field ([¬ß8.3.1.1](jls-8.html#jls-8.3.1.1 "8.3.1.1. static Fields")) causes initialization of only the class or interface that actually declares it, even though it might be referred to through the name of a subclass, a subinterface, or a class that implements an interface.

Invocation of certain reflective methods in class `Class` and in package `java.lang.reflect` also causes class or interface initialization.

A class or interface will not be initialized under any other circumstance.

Note that a compiler may generate _synthetic_ default methods in an interface, that is, default methods that are neither explicitly nor implicitly declared ([¬ß13.1](jls-13.html#jls-13.1 "13.1. The Form of a Binary")). Such methods will trigger the interface's initialization despite the source code giving no indication that the interface should be initialized.

The intent is that a class or interface type has a set of initializers that put it in a consistent state, and that this state is the first state that is observed by other classes. The static initializers and class variable initializers are executed in textual order, and may not refer to class variables declared in the class whose declarations appear textually after the use, even though these class variables are in scope ([¬ß8.3.3](jls-8.html#jls-8.3.3 "8.3.3. Forward References During Field Initialization")). This restriction is designed to detect, at compile time, most circular or otherwise malformed initializations.

The fact that initialization code is unrestricted allows examples to be constructed where the value of a class variable can be observed when it still has its initial default value, before its initializing expression is evaluated, but such examples are rare in practice. (Such examples can be also constructed for instance variable initialization ([¬ß12.5](jls-12.html#jls-12.5 "12.5. Creation of New Class Instances")).) The full power of the Java programming language is available in these initializers; programmers must exercise some care. This power places an extra burden on code generators, but this burden would arise in any case because the Java programming language is concurrent ([¬ß12.4.2](jls-12.html#jls-12.4.2 "12.4.2. Detailed Initialization Procedure")).

**Example 12.4.1-1. Superclasses Are Initialized Before Subclasses**

class Super {
    static { System.out.print("Super "); }
}
class One {
    static { System.out.print("One "); }
}
class Two extends Super {
    static { System.out.print("Two "); }
}
class Test {
    public static void main(String\[\] args) {
        One o = null;
        Two t = new Two();
        System.out.println((Object)o == (Object)t);
    }
}

This program produces the output:

Super Two false

The class `One` is never initialized, because it not used actively and therefore is never linked to. The class `Two` is initialized only after its superclass `Super` has been initialized.

  

**Example 12.4.1-2. Only The Class That Declares `static` Field Is Initialized**

class Super {
    static int taxi = 1729;
}
class Sub extends Super {
    static { System.out.print("Sub "); }
}
class Test {
    public static void main(String\[\] args) {
        System.out.println(Sub.taxi);
    }
}

This program prints only:

1729

because the class `Sub` is never initialized; the reference to `Sub.taxi` is a reference to a field actually declared in class `Super` and does not trigger initialization of the class `Sub`.

  

**Example 12.4.1-3. Interface Initialization Does Not Initialize Superinterfaces**

interface I {
    int i = 1, ii = Test.out("ii", 2);
}
interface J extends I {
    int j = Test.out("j", 3), jj = Test.out("jj", 4);
}
interface K extends J {
    int k = Test.out("k", 5);
}
class Test {
    public static void main(String\[\] args) {
        System.out.println(J.i);
        System.out.println(K.j);
    }
    static int out(String s, int i) {
        System.out.println(s + "=" + i);
        return i;
    }
}

This program produces the output:

1
j=3
jj=4
3

The reference to `J.i` is to a field that is a constant variable ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")); therefore, it does not cause `I` to be initialized ([¬ß13.4.9](jls-13.html#jls-13.4.9 "13.4.9. final Fields and static Constant Variables")).

The reference to `K.j` is a reference to a field actually declared in interface `J` that is not a constant variable; this causes initialization of the fields of interface `J`, but not those of its superinterface `I`, nor those of interface `K`.

Despite the fact that the name `K` is used to refer to field `j` of interface `J`, interface `K` is not initialized.

  

### 12.4.2. Detailed Initialization Procedure

Because the Java programming language is multithreaded, initialization of a class or interface requires careful synchronization, since some other thread may be trying to initialize the same class or interface at the same time. There is also the possibility that initialization of a class or interface may be requested recursively as part of the initialization of that class or interface; for example, a variable initializer in class A might invoke a method of an unrelated class B, which might in turn invoke a method of class A. The implementation of the Java Virtual Machine is responsible for taking care of synchronization and recursive initialization by using the following procedure.

The procedure assumes that the `Class` object has already been verified and prepared, and that the `Class` object contains state that indicates one of four situations:

*   This `Class` object is verified and prepared but not initialized.
*   This `Class` object is being initialized by some particular thread `T`.
*   This `Class` object is fully initialized and ready for use.
*   This `Class` object is in an erroneous state, perhaps because initialization was attempted and failed.
    

For each class or interface C, there is a unique initialization lock `LC`. The mapping from C to `LC` is left to the discretion of the Java Virtual Machine implementation. The procedure for initializing C is then as follows:

1.  Synchronize on the initialization lock, `LC`, for C. This involves waiting until the current thread can acquire `LC`.
    
2.  If the `Class` object for C indicates that initialization is in progress for C by some other thread, then release `LC` and block the current thread until informed that the in-progress initialization has completed, at which time repeat this step.
    
3.  If the `Class` object for C indicates that initialization is in progress for C by the current thread, then this must be a recursive request for initialization. Release `LC` and complete normally.
    
4.  If the `Class` object for C indicates that C has already been initialized, then no further action is required. Release `LC` and complete normally.
    
5.  If the `Class` object for C is in an erroneous state, then initialization is not possible. Release `L`C and throw a `NoClassDefFoundError`.

*   Otherwise, record the fact that initialization of the `Class` object for C is in progress by the current thread, and release `LC`.
    
    Then, initialize the `static` fields of C which are constant variables ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables"), [¬ß8.3.2](jls-8.html#jls-8.3.2 "8.3.2. Field Initialization"), [¬ß9.3.1](jls-9.html#jls-9.3.1 "9.3.1. Initialization of Fields in Interfaces")).
*   Next, if C is a class rather than an interface, and its superclass has not yet been initialized, then let SC be its superclass and let SI1, ..., SIn be all superinterfaces of C that declare at least one default method. The order of superinterfaces is given by a recursive enumeration over the superinterface hierarchy of each interface directly implemented by C (in the left-to-right order of C's `implements` clause). For each interface I directly implemented by C, the enumeration recurs on I's superinterfaces (in the left-to-right order of I's `extends` clause) before returning I.
    
    For each S in the list \[ SC, SI1, ..., SIn \], recursively perform this entire procedure for S. If necessary, verify and prepare S first.
    
    If the initialization of S completes abruptly because of a thrown exception, then acquire `LC`, label the `Class` object for C as erroneous, notify all waiting threads, release `LC`, and complete abruptly, throwing the same exception that resulted from initializing S.
*   Next, determine whether assertions are enabled ([¬ß14.10](jls-14.html#jls-14.10 "14.10. The assert Statement")) for C by querying its defining class loader.
*   Next, execute either the class variable initializers and static initializers of the class, or the field initializers of the interface, in textual order, as though they were a single block.
*   If the execution of the initializers completes normally, then acquire `LC`, label the `Class` object for C as fully initialized, notify all waiting threads, release `LC`, and complete this procedure normally.
*   Otherwise, the initializers must have completed abruptly by throwing some exception E. If the class of E is not `Error` or one of its subclasses, then create a new instance of the class `ExceptionInInitializerError`, with E as the argument, and use this object in place of E in the following step. If a new instance of `ExceptionInInitializerError` cannot be created because an `OutOfMemoryError` occurs, then instead use an `OutOfMemoryError` object in place of E in the following step.
*   Acquire `LC`, label the `Class` object for C as erroneous, notify all waiting threads, release `LC`, and complete this procedure abruptly with reason E or its replacement as determined in the previous step.
    

An implementation may optimize this procedure by eliding the lock acquisition in step 1 (and release in step 4/5) when it can determine that the initialization of the class has already completed, provided that, in terms of the memory model, all happens-before orderings that would exist if the lock were acquired, still exist when the optimization is performed.

Code generators need to preserve the points of possible initialization of a class or interface, inserting an invocation of the initialization procedure just described. If this initialization procedure completes normally and the `Class` object is fully initialized and ready for use, then the invocation of the initialization procedure is no longer necessary and it may be eliminated from the code - for example, by patching it out or otherwise regenerating the code.

Compile-time analysis may, in some cases, be able to eliminate many of the checks that a type has been initialized from the generated code, if an initialization order for a group of related types can be determined. Such analysis must, however, fully account for concurrency and for the fact that initialization code is unrestricted.

12.5. Creation of New Class Instances
-------------------------------------

A new class instance is explicitly created when evaluation of a class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")) causes a class to be instantiated.

A new class instance may be implicitly created in the following situations:

*   Loading of a class or interface that contains a `String` literal ([¬ß3.10.5](jls-3.html#jls-3.10.5 "3.10.5. String Literals")) may create a new `String` object to represent that literal. (This might not occur if the same `String` has previously been interned ([¬ß3.10.5](jls-3.html#jls-3.10.5 "3.10.5. String Literals")).)
*   Execution of an operation that causes boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")). Boxing conversion may create a new object of a wrapper class associated with one of the primitive types.
*   Execution of a string concatenation operator `+` ([¬ß15.18.1](jls-15.html#jls-15.18.1 "15.18.1. String Concatenation Operator +")) that is not part of a constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")) always creates a new `String` object to represent the result. String concatenation operators may also create temporary wrapper objects for a value of a primitive type.
*   Evaluation of a method reference expression ([¬ß15.13.3](jls-15.html#jls-15.13.3 "15.13.3. Run-Time Evaluation of Method References")) or a lambda expression ([¬ß15.27.4](jls-15.html#jls-15.27.4 "15.27.4. Run-Time Evaluation of Lambda Expressions")) may require that a new instance of a class that implements a functional interface type be created.
    

Each of these situations identifies a particular constructor ([¬ß8.8](jls-8.html#jls-8.8 "8.8. Constructor Declarations")) to be called with specified arguments (possibly none) as part of the class instance creation process.

Whenever a new class instance is created, memory space is allocated for it with room for all the instance variables declared in the class type and all the instance variables declared in each superclass of the class type, including all the instance variables that may be hidden ([¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations")).

If there is not sufficient space available to allocate memory for the object, then creation of the class instance completes abruptly with an `OutOfMemoryError`. Otherwise, all the instance variables in the new object, including those declared in superclasses, are initialized to their default values ([¬ß4.12.5](jls-4.html#jls-4.12.5 "4.12.5. Initial Values of Variables")).

Just before a reference to the newly created object is returned as the result, the indicated constructor is processed to initialize the new object using the following procedure:

1.  Assign the arguments for the constructor to newly created parameter variables for this constructor invocation.
    
2.  If this constructor begins with an explicit constructor invocation ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations")) of another constructor in the same class (using `this`), then evaluate the arguments and process that constructor invocation recursively using these same five steps. If that constructor invocation completes abruptly, then this procedure completes abruptly for the same reason; otherwise, continue with step 5.
    
3.  This constructor does not begin with an explicit constructor invocation of another constructor in the same class (using `this`). If this constructor is for a class other than `Object`, then this constructor will begin with an explicit or implicit invocation of a superclass constructor (using `super`). Evaluate the arguments and process that superclass constructor invocation recursively using these same five steps. If that constructor invocation completes abruptly, then this procedure completes abruptly for the same reason. Otherwise, continue with step 4.
    
4.  Execute the instance initializers and instance variable initializers for this class, assigning the values of instance variable initializers to the corresponding instance variables, in the left-to-right order in which they appear textually in the source code for the class. If execution of any of these initializers results in an exception, then no further initializers are processed and this procedure completes abruptly with that same exception. Otherwise, continue with step 5.
    
5.  Execute the rest of the body of this constructor. If that execution completes abruptly, then this procedure completes abruptly for the same reason. Otherwise, this procedure completes normally.
    

Unlike C++, the Java programming language does not specify altered rules for method dispatch during the creation of a new class instance. If methods are invoked that are overridden in subclasses in the object being initialized, then these overriding methods are used, even before the new object is completely initialized.

**Example 12.5-1. Evaluation of Instance Creation**

class Point {
    int x, y;
    Point() { x = 1; y = 1; }
}
class ColoredPoint extends Point {
    int color = 0xFF00FF;
}
class Test {
    public static void main(String\[\] args) {
        ColoredPoint cp = new ColoredPoint();
        System.out.println(cp.color);
    }
}

Here, a new instance of `ColoredPoint` is created. First, space is allocated for the new `ColoredPoint`, to hold the fields `x`, `y`, and `color`. All these fields are then initialized to their default values (in this case, `0` for each field). Next, the `ColoredPoint` constructor with no arguments is first invoked. Since `ColoredPoint` declares no constructors, a default constructor of the following form is implicitly declared:

ColoredPoint() { super(); }

This constructor then invokes the `Point` constructor with no arguments. The `Point` constructor does not begin with an invocation of a constructor, so the Java compiler provides an implicit invocation of its superclass constructor of no arguments, as though it had been written:

Point() { super(); x = 1; y = 1; }

Therefore, the constructor for `Object` which takes no arguments is invoked.

The class `Object` has no superclass, so the recursion terminates here. Next, any instance initializers and instance variable initializers of `Object` are invoked. Next, the body of the constructor of `Object` that takes no arguments is executed. No such constructor is declared in `Object`, so the Java compiler supplies a default one, which in this special case is:

Object() { }

This constructor executes without effect and returns.

Next, all initializers for the instance variables of class `Point` are executed. As it happens, the declarations of `x` and `y` do not provide any initialization expressions, so no action is required for this step of the example. Then the body of the `Point` constructor is executed, setting `x` to `1` and `y` to `1`.

Next, the initializers for the instance variables of class `ColoredPoint` are executed. This step assigns the value `0xFF00FF` to `color`. Finally, the rest of the body of the `ColoredPoint` constructor is executed (the part after the invocation of `super`); there happen to be no statements in the rest of the body, so no further action is required and initialization is complete.

  

**Example 12.5-2. Dynamic Dispatch During Instance Creation**

class Super {
    Super() { printThree(); }
    void printThree() { System.out.println("three"); }
}
class Test extends Super {
    int three = (int)Math.PI;  // That is, 3
    void printThree() { System.out.println(three); }

    public static void main(String\[\] args) {
        Test t = new Test();
        t.printThree();
    }
}

This program produces the output:

0
3

This shows that the invocation of `printThree` in the constructor for class `Super` does not invoke the definition of `printThree` in class `Super`, but rather invokes the overriding definition of `printThree` in class `Test`. This method therefore runs before the field initializers of `Test` have been executed, which is why the first value output is `0`, the default value to which the field `three` of `Test` is initialized. The later invocation of `printThree` in method `main` invokes the same definition of `printThree`, but by that point the initializer for instance variable `three` has been executed, and so the value `3` is printed.

  

12.6. Finalization of Class Instances
-------------------------------------

The class `Object` has a `protected` method called `finalize`; this method can be overridden by other classes. The particular definition of `finalize` that can be invoked for an object is called the _finalizer_ of that object. Before the storage for an object is reclaimed by the garbage collector, the Java Virtual Machine will invoke the finalizer of that object.

Finalizers provide a chance to free up resources that cannot be freed automatically by an automatic storage manager. In such situations, simply reclaiming the memory used by an object would not guarantee that the resources it held would be reclaimed.

The Java programming language does not specify how soon a finalizer will be invoked, except to say that it will happen before the storage for the object is reused.

The Java programming language does not specify which thread will invoke the finalizer for any given object.

It is important to note that many finalizer threads may be active (this is sometimes needed on large shared memory multiprocessors), and that if a large connected data structure becomes garbage, all of the `finalize` methods for every object in that data structure could be invoked at the same time, each finalizer invocation running in a different thread.

The Java programming language imposes no ordering on `finalize` method calls. Finalizers may be called in any order, or even concurrently.

As an example, if a circularly linked group of unfinalized objects becomes unreachable (or finalizer-reachable), then all the objects may become finalizable together. Eventually, the finalizers for these objects may be invoked, in any order, or even concurrently using multiple threads. If the automatic storage manager later finds that the objects are unreachable, then their storage can be reclaimed.

It is straightforward to implement a class that will cause a set of finalizer-like methods to be invoked in a specified order for a set of objects when all the objects become unreachable. Defining such a class is left as an exercise for the reader.

It is guaranteed that the thread that invokes the finalizer will not be holding any user-visible synchronization locks when the finalizer is invoked.

If an uncaught exception is thrown during the finalization, the exception is ignored and finalization of that object terminates.

The completion of an object's constructor happens-before ([¬ß17.4.5](jls-17.html#jls-17.4.5 "17.4.5. Happens-before Order")) the execution of its `finalize` method (in the formal sense of happens-before).

The `finalize` method declared in class `Object` takes no action. The fact that class `Object` declares a `finalize` method means that the `finalize` method for any class can always invoke the `finalize` method for its superclass. This should always be done, unless it is the programmer's intent to nullify the actions of the finalizer in the superclass. (Unlike constructors, finalizers do not automatically invoke the finalizer for the superclass; such an invocation must be coded explicitly.)

For efficiency, an implementation may keep track of classes that do not override the `finalize` method of class `Object`, or override it in a trivial way.

For example:

protected void finalize() throws Throwable {
    super.finalize();
}

We encourage implementations to treat such objects as having a finalizer that is not overridden, and to finalize them more efficiently, as described in [¬ß12.6.1](jls-12.html#jls-12.6.1 "12.6.1. Implementing Finalization").

A finalizer may be invoked explicitly, just like any other method.

The package `java.lang.ref` describes weak references, which interact with garbage collection and finalization. As with any API that has special interactions with the Java programming language, implementors must be cognizant of any requirements imposed by the `java.lang.ref` API. This specification does not discuss weak references in any way. Readers are referred to the API documentation for details.

### 12.6.1. Implementing Finalization

Every object can be characterized by two attributes: it may be _reachable_, _finalizer-reachable_, or _unreachable_, and it may also be _unfinalized_, _finalizable_, or _finalized_.

A _reachable_ object is any object that can be accessed in any potential continuing computation from any live thread.

A _finalizer-reachable_ object can be reached from some finalizable object through some chain of references, but not from any live thread.

An _unreachable_ object cannot be reached by either means.

An _unfinalized_ object has never had its finalizer automatically invoked.

A _finalized_ object has had its finalizer automatically invoked.

A _finalizable_ object has never had its finalizer automatically invoked, but the Java Virtual Machine may eventually automatically invoke its finalizer.

An object `o` is not finalizable until its constructor has invoked the constructor for `Object` on `o` and that invocation has completed successfully (that is, without throwing an exception). Every pre-finalization write to a field of an object must be visible to the finalization of that object. Furthermore, none of the pre-finalization reads of fields of that object may see writes that occur after finalization of that object is initiated.

Optimizing transformations of a program can be designed that reduce the number of objects that are reachable to be less than those which would naively be considered reachable. For example, a Java compiler or code generator may choose to set a variable or parameter that will no longer be used to `null` to cause the storage for such an object to be potentially reclaimable sooner.

Another example of this occurs if the values in an object's fields are stored in registers. The program may then access the registers instead of the object, and never access the object again. This would imply that the object is garbage. Note that this sort of optimization is only allowed if references are on the stack, not stored in the heap.

For example, consider the _Finalizer Guardian_ pattern:

class Foo {
    private final Object finalizerGuardian = new Object() {
        protected void finalize() throws Throwable {
            /\* finalize outer Foo object \*/
        }
    }
} 

The finalizer guardian forces `super.finalize` to be called if a subclass overrides `finalize` and does not explicitly call `super.finalize`.

If these optimizations are allowed for references that are stored on the heap, then a Java compiler can detect that the `finalizerGuardian` field is never read, null it out, collect the object immediately, and call the finalizer early. This runs counter to the intent: the programmer probably wanted to call the `Foo` finalizer when the `Foo` instance became unreachable. This sort of transformation is therefore not legal: the inner class object should be reachable for as long as the outer class object is reachable.

Transformations of this sort may result in invocations of the `finalize` method occurring earlier than might be otherwise expected. In order to allow the user to prevent this, we enforce the notion that synchronization may keep the object alive. _If an object's finalizer can result in synchronization on that object, then that object must be alive and considered reachable whenever a lock is held on it._

Note that this does not prevent synchronization elimination: synchronization only keeps an object alive if a finalizer might synchronize on it. Since the finalizer occurs in another thread, in many cases the synchronization could not be removed anyway.

### 12.6.2. Interaction with the Memory Model

It must be possible for the memory model ([¬ß17.4](jls-17.html#jls-17.4 "17.4. Memory Model")) to decide when it can commit actions that take place in a finalizer. This section describes the interaction of finalization with the memory model.

Each execution has a number of _reachability decision points_, labeled _di_. Each action either _comes-before di_ or _comes-after di_. Other than as explicitly mentioned, the comes-before ordering described in this section is unrelated to all other orderings in the memory model.

If _r_ is a read that sees a write _w_ and _r_ comes-before _di_, then _w_ must come-before _di_.

If _x_ and _y_ are synchronization actions on the same variable or monitor such that _so(x, y)_ ([¬ß17.4.4](jls-17.html#jls-17.4.4 "17.4.4. Synchronization Order")) and _y_ comes-before _di_, then _x_ must come-before _di_.

At each reachability decision point, some set of objects are marked as unreachable, and some subset of those objects are marked as finalizable. These reachability decision points are also the points at which references are checked, enqueued, and cleared according to the rules provided in the API documentation for the package `java.lang.ref`.

The only objects that are considered definitely reachable at a point _di_ are those that can be shown to be reachable by the application of these rules:

*   An object `B` is definitely reachable at _di_ from `static` fields if there exists a write _w1_ to a `static` field `v` of a class C such that the value written by _w1_ is a reference to `B`, the class C is loaded by a reachable classloader, and there does not exist a write _w2_ to `v` such that _hb(w2, w1)_ is not true and both _w1_ and _w2_ come-before _di_.
*   An object `B` is definitely reachable from `A` at _di_ if there is a write _w1_ to an element `v` of `A` such that the value written by _w1_ is a reference to `B` and there does not exist a write _w2_ to `v` such that _hb(w2, w1)_ is not true and both _w1_ and _w2_ come-before _di_.
*   If an object `C` is definitely reachable from an object `B`, and object `B` is definitely reachable from an object `A`, then `C` is definitely reachable from `A`.
    

If an object `X` is marked as unreachable at _di_, then:

*   `X` must not be definitely reachable at _di_ from `static` fields; and
*   All _active uses_ of `X` in thread `t` that come-after _di_ must occur in the finalizer invocation for `X` or as a result of thread `t` performing a read that comes-after _di_ of a reference to `X`; and
*   All reads that come-after _di_ that see a reference to `X` must see writes to elements of objects that were unreachable at _di_, or see writes that came-after _di_.
    

An action _a_ is an active use of `X` if and only if at least one of the following is true:

*   _a_ reads or writes an element of `X`
*   _a_ locks or unlocks `X` and there is a lock action on `X` that happens-after the invocation of the finalizer for `X`
*   _a_ writes a reference to `X`
*   _a_ is an active use of an object `Y`, and `X` is definitely reachable from `Y`
    

If an object `X` is marked as finalizable at _di_, then:

*   `X` must be marked as unreachable at _di_; and
*   _di_ must be the only place where `X` is marked as finalizable; and
*   actions that happen-after the finalizer invocation must come-after _di_.
    

12.7. Unloading of Classes and Interfaces
-----------------------------------------

An implementation of the Java programming language may _unload_ classes.

A class or interface may be unloaded if and only if its defining class loader may be reclaimed by the garbage collector as discussed in [¬ß12.6](jls-12.html#jls-12.6 "12.6. Finalization of Class Instances").

Classes and interfaces loaded by the bootstrap loader may not be unloaded.

Class unloading is an optimization that helps reduce memory use. Obviously, the semantics of a program should not depend on whether and how a system chooses to implement an optimization such as class unloading. To do otherwise would compromise the portability of programs. Consequently, whether a class or interface has been unloaded or not should be transparent to a program.

However, if a class or interface C was unloaded while its defining loader was potentially reachable, then C might be reloaded. One could never ensure that this would not happen. Even if the class was not referenced by any other currently loaded class, it might be referenced by some class or interface, D, that had not yet been loaded. When D is loaded by C's defining loader, its execution might cause reloading of C.

Reloading may not be transparent if, for example, the class has `static` variables (whose state would be lost), static initializers (which may have side effects), or `native` methods (which may retain static state). Furthermore, the hash value of the `Class` object is dependent on its identity. Therefore it is, in general, impossible to reload a class or interface in a completely transparent manner.

Since we can never guarantee that unloading a class or interface whose loader is potentially reachable will not cause reloading, and reloading is never transparent, but unloading must be transparent, it follows that one must not unload a class or interface while its loader is potentially reachable. A similar line of reasoning can be used to deduce that classes and interfaces loaded by the bootstrap loader can never be unloaded.

One must also argue why it is safe to unload a class C if its defining class loader can be reclaimed. If the defining loader can be reclaimed, then there can never be any live references to it (this includes references that are not live, but might be resurrected by finalizers). This, in turn, can only be true if there are can never be any live references to any of the classes defined by that loader, including C, either from their instances or from code.

Class unloading is an optimization that is only significant for applications that load large numbers of classes and that stop using most of those classes after some time. A prime example of such an application is a web browser, but there are others. A characteristic of such applications is that they manage classes through explicit use of class loaders. As a result, the policy outlined above works well for them.

Strictly speaking, it is not essential that the issue of class unloading be discussed by this specification, as class unloading is merely an optimization. However, the issue is very subtle, and so it is mentioned here by way of clarification.

12.8. Program Exit
------------------

A program terminates all its activity and _exits_ when one of two things happens:

*   All the threads that are not daemon threads terminate.
*   Some thread invokes the `exit` method of class `Runtime` or class `System`, and the `exit` operation is not forbidden by the security manager.
    

üçÄ Chapter 13. Binary Compatibility
--------------------------------

**Table of Contents**

[13.1. The Form of a Binary](jls-13.html#jls-13.1)
[13.2. What Binary Compatibility Is and Is Not](jls-13.html#jls-13.2)
[13.3. Evolution of Packages](jls-13.html#jls-13.3)
[13.4. Evolution of Classes](jls-13.html#jls-13.4)
[13.4.1. `abstract` Classes](jls-13.html#jls-13.4.1)
[13.4.2. `final` Classes](jls-13.html#jls-13.4.2)
[13.4.3. `public` Classes](jls-13.html#jls-13.4.3)
[13.4.4. Superclasses and Superinterfaces](jls-13.html#jls-13.4.4)
[13.4.5. Class Type Parameters](jls-13.html#jls-13.4.5)
[13.4.6. Class Body and Member Declarations](jls-13.html#jls-13.4.6)
[13.4.7. Access to Members and Constructors](jls-13.html#jls-13.4.7)
[13.4.8. Field Declarations](jls-13.html#jls-13.4.8)
[13.4.9. `final` Fields and `static` Constant Variables](jls-13.html#jls-13.4.9)
[13.4.10. `static` Fields](jls-13.html#jls-13.4.10)
[13.4.11. `transient` Fields](jls-13.html#jls-13.4.11)
[13.4.12. Method and Constructor Declarations](jls-13.html#jls-13.4.12)
[13.4.13. Method and Constructor Type Parameters](jls-13.html#jls-13.4.13)
[13.4.14. Method and Constructor Formal Parameters](jls-13.html#jls-13.4.14)
[13.4.15. Method Result Type](jls-13.html#jls-13.4.15)
[13.4.16. `abstract` Methods](jls-13.html#jls-13.4.16)
[13.4.17. `final` Methods](jls-13.html#jls-13.4.17)
[13.4.18. `native` Methods](jls-13.html#jls-13.4.18)
[13.4.19. `static` Methods](jls-13.html#jls-13.4.19)
[13.4.20. `synchronized` Methods](jls-13.html#jls-13.4.20)
[13.4.21. Method and Constructor Throws](jls-13.html#jls-13.4.21)
[13.4.22. Method and Constructor Body](jls-13.html#jls-13.4.22)
[13.4.23. Method and Constructor Overloading](jls-13.html#jls-13.4.23)
[13.4.24. Method Overriding](jls-13.html#jls-13.4.24)
[13.4.25. Static Initializers](jls-13.html#jls-13.4.25)
[13.4.26. Evolution of Enums](jls-13.html#jls-13.4.26)
[13.5. Evolution of Interfaces](jls-13.html#jls-13.5)
[13.5.1. `public` Interfaces](jls-13.html#jls-13.5.1)
[13.5.2. Superinterfaces](jls-13.html#jls-13.5.2)
[13.5.3. Interface Members](jls-13.html#jls-13.5.3)
[13.5.4. Interface Type Parameters](jls-13.html#jls-13.5.4)
[13.5.5. Field Declarations](jls-13.html#jls-13.5.5)
[13.5.6. Interface Method Declarations](jls-13.html#jls-13.5.6)
[13.5.7. Evolution of Annotation Types](jls-13.html#jls-13.5.7)

Development tools for the Java programming language should support automatic recompilation as necessary whenever source code is available. Particular implementations may also store the source and binary of types in a versioning database and implement a `ClassLoader` that uses integrity mechanisms of the database to prevent linkage errors by providing binary-compatible versions of types to clients.

Developers of packages and classes that are to be widely distributed face a different set of problems. In the Internet, which is our favorite example of a widely distributed system, it is often impractical or impossible to automatically recompile the pre-existing binaries that directly or indirectly depend on a type that is to be changed. Instead, this specification defines a set of changes that developers are permitted to make to a package or to a class or interface type while preserving (not breaking) compatibility with pre-existing binaries.

Within the framework of _Release-to-Release Binary Compatibility in SOM_ (Forman, Conner, Danforth, and Raper, _Proceedings of OOPSLA '95_), Java programming language binaries are binary compatible under all relevant transformations that the authors identify (with some caveats with respect to the addition of instance variables). Using their scheme, here is a list of some important binary compatible changes that the Java programming language supports:

*   Reimplementing existing methods, constructors, and initializers to improve performance.
*   Changing methods or constructors to return values on inputs for which they previously either threw exceptions that normally should not occur or failed by going into an infinite loop or causing a deadlock.
*   Adding new fields, methods, or constructors to an existing class or interface.
*   Deleting `private` fields, methods, or constructors of a class.
*   When an entire package is updated, deleting package access fields, methods, or constructors of classes and interfaces in the package.
*   Reordering the fields, methods, or constructors in an existing type declaration.
*   Moving a method upward in the class hierarchy.
*   Reordering the list of direct superinterfaces of a class or interface.
*   Inserting new class or interface types in the type hierarchy.
    

This chapter specifies minimum standards for binary compatibility guaranteed by all implementations. The Java programming language guarantees compatibility when binaries of classes and interfaces are mixed that are not known to be from compatible sources, but whose sources have been modified in the compatible ways described here. Note that we are discussing compatibility between releases of an application. A discussion of compatibility among releases of the Java SE platform is beyond the scope of this chapter.

We encourage development systems to provide facilities that alert developers to the impact of changes on pre-existing binaries that cannot be recompiled.

This chapter first specifies some properties that any binary format for the Java programming language must have ([¬ß13.1](jls-13.html#jls-13.1 "13.1. The Form of a Binary")). It next defines binary compatibility, explaining what it is and what it is not ([¬ß13.2](jls-13.html#jls-13.2 "13.2. What Binary Compatibility Is and Is Not")). It finally enumerates a large set of possible changes to packages ([¬ß13.3](jls-13.html#jls-13.3 "13.3. Evolution of Packages")), classes ([¬ß13.4](jls-13.html#jls-13.4 "13.4. Evolution of Classes")), and interfaces ([¬ß13.5](jls-13.html#jls-13.5 "13.5. Evolution of Interfaces")), specifying which of these changes are guaranteed to preserve binary compatibility and which are not.

Occasionally, references of the form: (JVMS ¬ßx.y) are used to indicate concepts from _The Java Virtual Machine Specification, Java SE 8 Edition_.

13.1. The Form of a Binary
--------------------------

Programs must be compiled either into the `class` file format specified by _The Java Virtual Machine Specification, Java SE 8 Edition_, or into a representation that can be mapped into that format by a class loader written in the Java programming language.

The resulting `class` file must have certain properties. A number of these properties are specifically chosen to support source code transformations that preserve binary compatibility. The required properties are:

1.  The class or interface must be named by its _binary name_, which must meet the following constraints:
    
    *   The binary name of a top level type ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")) is its canonical name ([¬ß6.7](jls-6.html#jls-6.7 "6.7. Fully Qualified Names and Canonical Names")).
        
    *   The binary name of a member type ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")) consists of the binary name of its immediately enclosing type, followed by `$`, followed by the simple name of the member.
        
    *   The binary name of a local class ([¬ß14.3](jls-14.html#jls-14.3 "14.3. Local Class Declarations")) consists of the binary name of its immediately enclosing type, followed by `$`, followed by a non-empty sequence of digits, followed by the simple name of the local class.
        
    *   The binary name of an anonymous class ([¬ß15.9.5](jls-15.html#jls-15.9.5 "15.9.5. Anonymous Class Declarations")) consists of the binary name of its immediately enclosing type, followed by `$`, followed by a non-empty sequence of digits.
        
    *   The binary name of a type variable declared by a generic class or interface ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters"), [¬ß9.1.2](jls-9.html#jls-9.1.2 "9.1.2. Generic Interfaces and Type Parameters")) is the binary name of its immediately enclosing type, followed by `$`, followed by the simple name of the type variable.
        
    *   The binary name of a type variable declared by a generic method ([¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods")) is the binary name of the type declaring the method, followed by `$`, followed by the descriptor of the method (JVMS ¬ß4.3.3), followed by `$`, followed by the simple name of the type variable.
        
    *   The binary name of a type variable declared by a generic constructor ([¬ß8.8.4](jls-8.html#jls-8.8.4 "8.8.4. Generic Constructors")) is the binary name of the type declaring the constructor, followed by `$`, followed by the descriptor of the constructor (JVMS ¬ß4.3.3), followed by `$`, followed by the simple name of the type variable.
        
    
2.  A reference to another class or interface type must be symbolic, using the binary name of the type.
    
3.  A reference to a field that is a constant variable ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")) must be resolved at compile time to the value V denoted by the constant variable's initializer.
    
    If such a field is `static`, then no reference to the field should be present in the code in a binary file, including the class or interface which declared the field. Such a field must always appear to have been initialized ([¬ß12.4.2](jls-12.html#jls-12.4.2 "12.4.2. Detailed Initialization Procedure")); the default initial value for the field (if different than V) must never be observed.
    
    If such a field is non-`static`, then no reference to the field should be present in the code in a binary file, except in the class containing the field. (It will be a class rather than an interface, since an interface has only `static` fields.) The class should have code to set the field's value to V during instance creation ([¬ß12.5](jls-12.html#jls-12.5 "12.5. Creation of New Class Instances")).
    
4.  Given a legal expression denoting a field access in a class C, referencing a field named `f` that is not a constant variable and is declared in a (possibly distinct) class or interface D, we define the _qualifying type of the field reference_ as follows:
    
    *   If the expression is referenced by a simple name, then if `f` is a member of the current class or interface, C, then let T be C. Otherwise, let T be the innermost lexically enclosing type declaration of which `f` is a member. In either case, T is the qualifying type of the reference.
        
    *   If the reference is of the form _TypeName_`.``f`, where _TypeName_ denotes a class or interface, then the class or interface denoted by _TypeName_ is the qualifying type of the reference.
        
    *   If the expression is of the form _ExpressionName_`.``f` or _Primary_`.``f`, then:
        
        *   If the compile-time type of _ExpressionName_ or _Primary_ is an intersection type V1 `&` ... `&` Vn ([¬ß4.9](jls-4.html#jls-4.9 "4.9. Intersection Types")), then the qualifying type of the reference is V1.
            
        *   Otherwise, the compile-time type of _ExpressionName_ or _Primary_ is the qualifying type of the reference.
            
        
    *   If the expression is of the form `super``.``f`, then the superclass of C is the qualifying type of the reference.
        
    *   If the expression is of the form _TypeName_`.``super``.``f`, then the superclass of the class denoted by _TypeName_ is the qualifying type of the reference.
        
    
    The reference to `f` must be compiled into a symbolic reference to the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of the qualifying type of the reference, plus the simple name of the field, `f`. The reference must also include a symbolic reference to the erasure of the declared type of the field so that the verifier can check that the type is as expected.
    
5.  Given a method invocation expression or a method reference expression in a class or interface C, referencing a method named `m` declared (or implicitly declared ([¬ß9.2](jls-9.html#jls-9.2 "9.2. Interface Members"))) in a (possibly distinct) class or interface D, we define the _qualifying type of the method invocation_ as follows:
    
    *   If D is `Object` then the qualifying type of the expression is `Object`.
        
    *   Otherwise:
        
        *   If the method is referenced by a simple name, then if `m` is a member of the current class or interface C, let T be C; otherwise, let T be the innermost lexically enclosing type declaration of which `m` is a member. In either case, T is the qualifying type of the method invocation.
            
        *   If the expression is of the form _TypeName_`.``m` or _ReferenceType_`::``m`, then the type denoted by _TypeName_ or _ReferenceType_ is the qualifying type of the method invocation.
            
        *   If the expression is of the form _ExpressionName_`.``m` or _Primary_`.``m` or _ExpressionName_`::``m` or _Primary_`::``m`, then:
            
            *   If the compile-time type of _ExpressionName_ or _Primary_ is an intersection type V1 `&` ... `&` Vn ([¬ß4.9](jls-4.html#jls-4.9 "4.9. Intersection Types")), then the qualifying type of the method invocation is V1.
                
            *   Otherwise, the compile-time type of _ExpressionName_ or _Primary_ is the qualifying type of the method invocation.
                
            
        *   If the expression is of the form `super``.``m` or `super``::``m`, then the superclass of C is the qualifying type of the method invocation.
            
        *   If the expression is of the form _TypeName_`.``super``.``m` or _TypeName_`.``super``::``m`, then if _TypeName_ denotes a class X, the superclass of X is the qualifying type of the method invocation; if _TypeName_ denotes an interface X, X is the qualifying type of the method invocation.
            
        
    
    A reference to a method must be resolved at compile time to a symbolic reference to the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of the qualifying type of the invocation, plus the erasure of the signature ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")) of the method. The signature of a method must include all of the following as determined by [¬ß15.12.3](jls-15.html#jls-15.12.3 "15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?"):
    
    *   The simple name of the method
        
    *   The number of parameters to the method
        
    *   A symbolic reference to the type of each parameter
        
    
    A reference to a method must also include either a symbolic reference to the erasure of the return type of the denoted method or an indication that the denoted method is declared `void` and does not return a value.
    
6.  Given a class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")) or an explicit constructor invocation statement ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations")) or a method reference expression of the form _ClassType `::` `new`_ ([¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions")) in a class or interface C referencing a constructor `m` declared in a (possibly distinct) class or interface D, we define the qualifying type of the constructor invocation as follows:
    
    *   If the expression is of the form `new` D`(...)` or _ExpressionName_`.``new` D`(...)` or _Primary_`.``new` D`(...)` or D `::` `new`, then the qualifying type of the invocation is D.
        
    *   If the expression is of the form `new` D`(...){...}` or _ExpressionName_`.``new` D`(...){...}` or _Primary_`.``new` D`(...){...}`, then the qualifying type of the expression is the compile-time type of the expression.
        
    *   If the expression is of the form `super``(...)` or _ExpressionName_`.``super``(...)` or _Primary_`.``super``(...)`, then the qualifying type of the expression is the direct superclass of C.
        
    *   If the expression is of the form `this``(...)`, then the qualifying type of the expression is C.
        
    
    A reference to a constructor must be resolved at compile time to a symbolic reference to the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of the qualifying type of the invocation, plus the signature of the constructor ([¬ß8.8.2](jls-8.html#jls-8.8.2 "8.8.2. Constructor Signature")). The signature of a constructor must include both:
    
    *   The number of parameters of the constructor
        
    *   A symbolic reference to the type of each formal parameter
        
    

A binary representation for a class or interface must also contain all of the following:

1.  If it is a class and is not `Object`, then a symbolic reference to the erasure of the direct superclass of this class.
    
2.  A symbolic reference to the erasure of each direct superinterface, if any.
    
3.  A specification of each field declared in the class or interface, given as the simple name of the field and a symbolic reference to the erasure of the type of the field.
    
4.  If it is a class, then the erased signature of each constructor, as described above.
    
5.  For each method declared in the class or interface (excluding, for an interface, its implicitly declared methods ([¬ß9.2](jls-9.html#jls-9.2 "9.2. Interface Members"))), its erased signature and return type, as described above.
    
6.  The code needed to implement the class or interface:
    
    *   For an interface, code for the field initializers and the implementation of each default method.
        
    *   For a class, code for the field initializers, the instance and static initializers, and the implementation of each method or constructor.
        
    
7.  Every type must contain sufficient information to recover its canonical name ([¬ß6.7](jls-6.html#jls-6.7 "6.7. Fully Qualified Names and Canonical Names")).
    
8.  Every member type must have sufficient information to recover its source level access modifier.
    
9.  Every nested class and nested interface must have a symbolic reference to its immediately enclosing class ([¬ß8.1.3](jls-8.html#jls-8.1.3 "8.1.3. Inner Classes and Enclosing Instances")).
    
10.  Every class must contain symbolic references to all of its member types ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations")), and to all local and anonymous classes that appear in its methods, constructors, static initializers, instance initializers, and field initializers.
    
    Every interface must contain symbolic references to all of its member types ([¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")), and to all local and anonymous classes that appear in its default methods and field initializers.
    
11.  A construct emitted by a Java compiler must be marked as _synthetic_ if it does not correspond to a construct declared explicitly or implicitly in source code, unless the emitted construct is a class initialization method (JVMS ¬ß2.9).
    
12.  A construct emitted by a Java compiler must be marked as _mandated_ if it corresponds to a formal parameter declared implicitly in source code ([¬ß8.8.1](jls-8.html#jls-8.8.1 "8.8.1. Formal Parameters"), [¬ß8.8.9](jls-8.html#jls-8.8.9 "8.8.9. Default Constructor"), [¬ß8.9.3](jls-8.html#jls-8.9.3 "8.9.3. Enum Members"), [¬ß15.9.5.1](jls-15.html#jls-15.9.5.1 "15.9.5.1. Anonymous Constructors")).
    

The following formal parameters are declared implicitly in source code:

*   The first formal parameter of a constructor of a non-`private` inner member class ([¬ß8.8.1](jls-8.html#jls-8.8.1 "8.8.1. Formal Parameters"), [¬ß8.8.9](jls-8.html#jls-8.8.9 "8.8.9. Default Constructor")).
*   The first formal parameter of an anonymous constructor of an anonymous class whose superclass is inner or local (not in a static context) ([¬ß15.9.5.1](jls-15.html#jls-15.9.5.1 "15.9.5.1. Anonymous Constructors")).
*   The formal parameter `name` of the `valueOf` method which is implicitly declared in an enum type ([¬ß8.9.3](jls-8.html#jls-8.9.3 "8.9.3. Enum Members")).
    

For reference, the following constructs are declared implicitly in source code, but are not marked as mandated because only formal parameters can be so marked in a `class` file (JVMS ¬ß4.7.22):

*   Default constructors of classes and enum types ([¬ß8.8.9](jls-8.html#jls-8.8.9 "8.8.9. Default Constructor"), [¬ß8.9.2](jls-8.html#jls-8.9.2 "8.9.2. Enum Body Declarations"))
*   Anonymous constructors ([¬ß15.9.5.1](jls-15.html#jls-15.9.5.1 "15.9.5.1. Anonymous Constructors"))
*   The `values` and `valueOf` methods of enum types ([¬ß8.9.3](jls-8.html#jls-8.9.3 "8.9.3. Enum Members"))
*   Certain `public` fields of enum types ([¬ß8.9.3](jls-8.html#jls-8.9.3 "8.9.3. Enum Members"))
*   Certain `public` methods of interfaces ([¬ß9.2](jls-9.html#jls-9.2 "9.2. Interface Members"))
*   Container annotations ([¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type"))
    

The following sections discuss changes that may be made to class and interface type declarations without breaking compatibility with pre-existing binaries. Under the translation requirements given above, the Java Virtual Machine and its `class` file format support these changes. Any other valid binary format, such as a compressed or encrypted representation that is mapped back into `class` files by a class loader under the above requirements, will necessarily support these changes as well.

13.2. What Binary Compatibility Is and Is Not
---------------------------------------------

A change to a type is _binary compatible with_ (equivalently, does not _break binary compatibility_ with) pre-existing binaries if pre-existing binaries that previously linked without error will continue to link without error.

Binaries are compiled to rely on the accessible members and constructors of other classes and interfaces. To preserve binary compatibility, a class or interface should treat its accessible members and constructors, their existence and behavior, as a _contract_ with its users.

The Java programming language is designed to prevent additions to contracts and accidental name collisions from breaking binary compatibility. Specifically, addition of more methods overloading a particular method name does not break compatibility with pre-existing binaries. The method signature that the pre-existing binary will use for method lookup is chosen by the overload resolution algorithm at compile time ([¬ß15.12.2](jls-15.html#jls-15.12.2 "15.12.2. Compile-Time Step 2: Determine Method Signature")).

If the Java programming language had been designed so that the particular method to be executed was chosen at run time, then such an ambiguity might be detected at run time. Such a rule would imply that adding an additional overloaded method so as to make ambiguity possible at a call site could break compatibility with an unknown number of pre-existing binaries. See [¬ß13.4.23](jls-13.html#jls-13.4.23 "13.4.23. Method and Constructor Overloading") for more discussion.

Binary compatibility is not the same as source compatibility. In particular, the example in [¬ß13.4.6](jls-13.html#jls-13.4.6 "13.4.6. Class Body and Member Declarations") shows that a set of compatible binaries can be produced from sources that will not compile all together. This example is typical: a new declaration is added, changing the meaning of a name in an unchanged part of the source code, while the pre-existing binary for that unchanged part of the source code retains the fully-qualified, previous meaning of the name. Producing a consistent set of source code requires providing a qualified name or field access expression corresponding to the previous meaning.

13.3. Evolution of Packages
---------------------------

A new top level class or interface type may be added to a package without breaking compatibility with pre-existing binaries, provided the new type does not reuse a name previously given to an unrelated type.

If a new type reuses a name previously given to an unrelated type, then a conflict may result, since binaries for both types could not be loaded by the same class loader.

Changes in top level class and interface types that are not `public` and that are not a superclass or superinterface, respectively, of a `public` type, affect only types within the package in which they are declared. Such types may be deleted or otherwise changed, even if incompatibilities are otherwise described here, provided that the affected binaries of that package are updated together.13.4. Evolution of Classes
--------------------------

This section describes the effects of changes to the declaration of a class and its members and constructors on pre-existing binaries.

### 13.4.1. `abstract` Classes

If a class that was not declared `abstract` is changed to be declared `abstract`, then pre-existing binaries that attempt to create new instances of that class will throw either an `InstantiationError` at link time, or (if a reflective method is used) an `InstantiationException` at run time; such a change is therefore not recommended for widely distributed classes.

Changing a class that is declared `abstract` to no longer be declared `abstract` does not break compatibility with pre-existing binaries.

### 13.4.2. `final` Classes

If a class that was not declared `final` is changed to be declared `final`, then a `VerifyError` is thrown if a binary of a pre-existing subclass of this class is loaded, because `final` classes can have no subclasses; such a change is not recommended for widely distributed classes.

Changing a class that is declared `final` to no longer be declared `final` does not break compatibility with pre-existing binaries.

### 13.4.3. `public` Classes

Changing a class that is not declared `public` to be declared `public` does not break compatibility with pre-existing binaries.

If a class that was declared `public` is changed to not be declared `public`, then an `IllegalAccessError` is thrown if a pre-existing binary is linked that needs but no longer has access to the class type; such a change is not recommended for widely distributed classes.

### 13.4.4. Superclasses and Superinterfaces

A `ClassCircularityError` is thrown at load time if a class would be a superclass of itself. Changes to the class hierarchy that could result in such a circularity when newly compiled binaries are loaded with pre-existing binaries are not recommended for widely distributed classes.

Changing the direct superclass or the set of direct superinterfaces of a class type will not break compatibility with pre-existing binaries, provided that the total set of superclasses or superinterfaces, respectively, of the class type loses no members.

If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, then linkage errors may result if pre-existing binaries are loaded with the binary of the modified class. Such changes are not recommended for widely distributed classes.

**Example 13.4.4-1. Changing A Superclass**

Suppose that the following test program:

class Hyper { char h = 'h'; } 
class Super extends Hyper { char s = 's'; }
class Test extends Super {
    public static void printH(Hyper h) {
        System.out.println(h.h);
    }
    public static void main(String\[\] args) {
        printH(new Super());
    }
}

is compiled and executed, producing the output:

h

Suppose that a new version of class `Super` is then compiled:

class Super { char s = 's'; }

This version of class `Super` is not a subclass of `Hyper`. If we then run the existing binaries of `Hyper` and `Test` with the new version of `Super`, then a `VerifyError` is thrown at link time. The verifier objects because the result of `new Super()` cannot be passed as an argument in place of a formal parameter of type `Hyper`, because `Super` is not a subclass of `Hyper`.

It is instructive to consider what might happen without the verification step: the program might run and print:

s

This demonstrates that without the verifier, the Java type system could be defeated by linking inconsistent binary files, even though each was produced by a correct Java compiler.

The lesson is that an implementation that lacks a verifier or fails to use it will not maintain type safety and is, therefore, not a valid implementation.

  

The requirement that alternatives in a multi-`catch` clause ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) not be subclasses or superclasses of each other is only a source restriction. Assuming the following client code is legal:

try {
    throwAorB();
} catch(ExceptionA | ExceptionB e) {
    ...
}

where `ExceptionA` and `ExceptionB` do not have a subclass/superclass relationship when the client is compiled, it is binary compatible with respect to the client for `ExceptionA` and `ExceptionB` to have such a relationship when the client is executed.

This is analogous to other situations where a class transformation that is binary compatible for a client might not be source compatible for the same client.

### 13.4.5. Class Type Parameters

Adding or removing a type parameter of a class does not, in itself, have any implications for binary compatibility.

If such a type parameter is used in the type of a field or method, that may have the normal implications of changing the aforementioned type.

Renaming a type parameter of a class has no effect with respect to pre-existing binaries.

Changing the first bound of a type parameter of a class may change the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of any member that uses that type parameter in its own type, and this may affect binary compatibility. The change of such a bound is analogous to the change of the first bound of a type parameter of a method or constructor ([¬ß13.4.13](jls-13.html#jls-13.4.13 "13.4.13. Method and Constructor Type Parameters")).

Changing any other bound has no effect on binary compatibility.

### 13.4.6. Class Body and Member Declarations

No incompatibility with pre-existing binaries is caused by adding an instance (respectively `static`) member that has the same name and accessibility (for fields), or same name and accessibility and signature and return type (for methods), as an instance (respectively `static`) member of a superclass or subclass. No error occurs even if the set of classes being linked would encounter a compile-time error.

Deleting a class member or constructor that is not declared `private` may cause a linkage error if the member or constructor is used by a pre-existing binary.

**Example 13.4.6-1. Changing A Class Body**

class Hyper {
    void hello() { System.out.println("hello from Hyper"); }
}
class Super extends Hyper {
    void hello() { System.out.println("hello from Super"); }
}
class Test {
    public static void main(String\[\] args) {
        new Super().hello();
    }
}

This program produces the output:

hello from Super

Suppose that a new version of class `Super` is produced:

class Super extends Hyper {}

Then, recompiling `Super` and executing this new binary with the original binaries for `Test` and `Hyper` produces the output:

hello from Hyper

as expected.

  

The `super` keyword can be used to access a method declared in a superclass, bypassing any methods declared in the current class. The expression `super``.`_Identifier_ is resolved, at compile time, to a method `m` in the superclass S. If the method `m` is an instance method, then the method which is invoked at run time is the method with the same signature as `m` that is a member of the direct superclass of the class containing the expression involving `super`.

**Example 13.4.6-2. Changing A Superclass**

class Hyper {
    void hello() { System.out.println("hello from Hyper"); }
}
class Super extends Hyper { }
class Test extends Super {
    public static void main(String\[\] args) {
        new Test().hello();
    }
    void hello() {
        super.hello();
    }
}

This program produces the output:

hello from Hyper

Suppose that a new version of class `Super` is produced:

class Super extends Hyper {
    void hello() { System.out.println("hello from Super"); }
}

Then, if `Super` and `Hyper` are recompiled but not `Test`, then running the new binaries with the existing binary of `Test` produces the output:

hello from Super

as you might expect.

  

### 13.4.7. Access to Members and Constructors

Changing the declared access of a member or constructor to permit less access may break compatibility with pre-existing binaries, causing a linkage error to be thrown when these binaries are resolved. Less access is permitted if the access modifier is changed from package access to `private` access; from `protected` access to package or `private` access; or from `public` access to `protected`, package, or `private` access. Changing a member or constructor to permit less access is therefore not recommended for widely distributed classes.

Perhaps surprisingly, the binary format is defined so that changing a member or constructor to be more accessible does not cause a linkage error when a subclass (already) defines a method to have less access.

**Example 13.4.7-1. Changing Accessibility**

If the package `points` defines the class `Point`:

package points;
public class Point {
    public int x, y;
    protected void print() {
        System.out.println("(" + x + "," + y + ")");
    }
}

used by the program:

class Test extends points.Point {
    public static void main(String\[\] args) {
        Test t = new Test();
        t.print();
    }
    protected void print() { 
        System.out.println("Test"); 
    }
}

then these classes compile and `Test` executes to produce the output:

Test

If the method `print` in class `Point` is changed to be `public`, and then only the `Point` class is recompiled, and then executed with the previously existing binary for `Test`, then no linkage error occurs. This happens even though it is improper, at compile time, for a `public` method to be overridden by a `protected` method (as shown by the fact that the class `Test` could not be recompiled using this new `Point` class unless `print` in `Test` were changed to be `public`.)

  

Allowing superclasses to change `protected` methods to be `public` without breaking binaries of pre-existing subclasses helps make binaries less fragile. The alternative, where such a change would cause a linkage error, would create additional binary incompatibilities.

### 13.4.8. Field Declarations

Widely distributed programs should not expose any fields to their clients. Apart from the binary compatibility issues discussed below, this is generally good software engineering practice. Adding a field to a class may break compatibility with pre-existing binaries that are not recompiled.

Assume a reference to a field `f` with qualifying type T. Assume further that `f` is in fact an instance (respectively `static`) field declared in a superclass of T, S, and that the type of `f` is X.

If a new field of type X with the same name as `f` is added to a subclass of S that is a superclass of T or T itself, then a linkage error may occur. Such a linkage error will occur only if, in addition to the above, either one of the following is true:

*   The new field is less accessible than the old one.
*   The new field is a `static` (respectively instance) field.
    

In particular, no linkage error will occur in the case where a class could no longer be recompiled because a field access previously referenced a field of a superclass with an incompatible type. The previously compiled class with such a reference will continue to reference the field declared in a superclass.

**Example 13.4.8-1. Adding A Field Declaration**

class Hyper { String h = "hyper"; }
class Super extends Hyper { String s = "super"; }
class Test {
    public static void main(String\[\] args) {
        System.out.println(new Super().h);
    }
}

This program produces the output:

hyper

Suppose a new version of class `Super` is produced:

class Super extends Hyper {
    String s = "super";
    int h = 0;
}

Then, recompiling `Hyper` and `Super`, and executing the resulting new binaries with the old binary of `Test` produces the output:

hyper

The field `h` of `Hyper` is output by the original binary of `Test`. While this may seem surprising at first, it serves to reduce the number of incompatibilities that occur at run time. (In an ideal world, all source files that needed recompilation would be recompiled whenever any one of them changed, eliminating such surprises. But such a mass recompilation is often impractical or impossible, especially in the Internet. And, as was previously noted, such recompilation would sometimes require further changes to the source code.)

As another example, if the program:

class Hyper { String h = "Hyper"; }
class Super extends Hyper { }
class Test extends Super {
    public static void main(String\[\] args) {
        String s = new Test().h;
        System.out.println(s);
    }
}

is compiled and executed, it produces the output:

Hyper

Suppose that a new version of class `Super` is then compiled:

class Super extends Hyper { char h = 'h'; }

If the resulting binary is used with the existing binaries for `Hyper` and `Test`, then the output is still:

Hyper

even though compiling the source for these binaries:

class Hyper { String h = "Hyper"; }
class Super extends Hyper { char h = 'h'; }
class Test extends Super {
    public static void main(String\[\] args) {
        String s = new Test().h;
        System.out.println(s);
    }
}

would result in a compile-time error, because the `h` in the source code for `main` would now be construed as referring to the `char` field declared in `Super`, and a `char` value can't be assigned to a `String`.

  

Deleting a field from a class will break compatibility with any pre-existing binaries that reference this field, and a `NoSuchFieldError` will be thrown when such a reference from a pre-existing binary is linked. Only `private` fields may be safely deleted from a widely distributed class.

For purposes of binary compatibility, adding or removing a field `f` whose type involves type variables ([¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables")) or parameterized types ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")) is equivalent to the addition (respectively, removal) of a field of the same name whose type is the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of the type of `f`.

### 13.4.9. `final` Fields and `static` Constant Variables

If a field that was not declared `final` is changed to be declared `final`, then it can break compatibility with pre-existing binaries that attempt to assign new values to the field.

**Example 13.4.9-1. Changing A Variable To Be `final`**

class Super { char s; }
class Test extends Super {
    public static void main(String\[\] args) {
        Super x = new Super();
        x.s = 'a';
        System.out.println(x.s);
    }
}

This program produces the output:

a

Suppose that a new version of class `Super` is produced:

class Super { final char s = 'b'; }

If `Super` is recompiled but not `Test`, then running the new binary with the existing binary of `Test` results in a `IllegalAccessError`.

  

Deleting the keyword `final` or changing the value to which a field is initialized does not break compatibility with existing binaries.

If a field is a constant variable ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")), and moreover is `static`, then deleting the keyword `final` or changing its value will not break compatibility with pre-existing binaries by causing them not to run, but they will not see any new value for a usage of the field unless they are recompiled. This result is a side-effect of the decision to support conditional compilation ([¬ß14.21](jls-14.html#jls-14.21 "14.21. Unreachable Statements")). (One might suppose that the new value is not seen if the usage occurs in a constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")) but is seen otherwise. This is not so; pre-existing binaries do not see the new value at all.)

Another reason for requiring inlining of values of `static` constant variables is because of `switch` statements. They are the only kind of statement that relies on constant expressions, namely that each `case` label of a `switch` statement must be a constant expression whose value is different than every other `case` label. `case` labels are often references to `static` constant variables so it may not be immediately obvious that all the labels have different values. If it is proven that there are no duplicate labels at compile time, then inlining the values into the `class` file ensures there are no duplicate labels at run time either - a very desirable property.

**Example 13.4.9-2. Conditional Compilation**

If the example:

class Flags { static final boolean debug = true; }
class Test {
    public static void main(String\[\] args) {
        if (Flags.debug)
            System.out.println("debug is true");
    }
}

is compiled and executed, it produces the output:

debug is true

Suppose that a new version of class `Flags` is produced:

class Flags { static final boolean debug = false; }

If `Flags` is recompiled but not `Test`, then running the new binary with the existing binary of `Test` produces the output:

debug is true

because the value of `debug` was a constant expression, and could have been used in compiling `Test` without making a reference to the class `Flags`.

This behavior would not change if `Flags` were changed to be an interface, as in the modified example:

interface Flags { boolean debug = true; }
class Test {
    public static void main(String\[\] args) {
        if (Flags.debug)
            System.out.println("debug is true");
    }
}

Conditional compilation is discussed further at the end of [¬ß14.21](jls-14.html#jls-14.21 "14.21. Unreachable Statements").

  

The best way to avoid problems with "inconstant constants" in widely-distributed code is to use `static` constant variables only for values which truly are unlikely ever to change. Other than for true mathematical constants, we recommend that source code make very sparing use of `static` constant variables.

If the read-only nature of `final` is required, a better choice is to declare a `private` `static` variable and a suitable accessor method to get its value. Thus we recommend:

private static int N;
public static int getN() { return N; }

rather than:

public static final int N = ...;

There is no problem with:

public static int N = ...;

if `N` need not be read-only.

We recommend, as a general rule, that only constant expressions be assigned to fields of interfaces.

We note, but do not recommend, that if a field of primitive type of an interface may change, its value may be expressed idiomatically as in:

interface Flags {
    boolean debug = new Boolean(true).booleanValue();
}

ensuring that this value is not a constant. Similar idioms exist for the other primitive types.

One other thing to note is that `static` constant variables must never appear to have the default initial value for their type ([¬ß4.12.5](jls-4.html#jls-4.12.5 "4.12.5. Initial Values of Variables")). This means that all such fields appear to be initialized first during class initialization ([¬ß8.3.2](jls-8.html#jls-8.3.2 "8.3.2. Field Initialization"), [¬ß9.3.1](jls-9.html#jls-9.3.1 "9.3.1. Initialization of Fields in Interfaces"), [¬ß12.4.2](jls-12.html#jls-12.4.2 "12.4.2. Detailed Initialization Procedure")).

### 13.4.10. `static` Fields

If a field that is not declared `private` was not declared `static` and is changed to be declared `static`, or vice versa, then a linkage error, specifically an `IncompatibleClassChangeError`, will result if the field is used by a pre-existing binary which expected a field of the other kind. Such changes are not recommended in code that has been widely distributed.

### 13.4.11. `transient` Fields

Adding or deleting a `transient` modifier of a field does not break compatibility with pre-existing binaries.

### 13.4.12. Method and Constructor Declarations

Adding a method or constructor declaration to a class will not break compatibility with any pre-existing binaries, even in the case where a type could no longer be recompiled because an invocation previously referenced a method or constructor of a superclass with an incompatible type. The previously compiled class with such a reference will continue to reference the method or constructor declared in a superclass.

Assume a reference to a method `m` with qualifying type T. Assume further that `m` is in fact an instance (respectively `static`) method declared in a superclass of T, S.

If a new method of type X with the same signature and return type as `m` is added to a subclass of S that is a superclass of T or T itself, then a linkage error may occur. Such a linkage error will occur only if, in addition to the above, either one of the following is true:

*   The new method is less accessible than the old one.
*   The new method is a `static` (respectively instance) method.
    

Deleting a method or constructor from a class may break compatibility with any pre-existing binary that referenced this method or constructor; a `NoSuchMethodError` may be thrown when such a reference from a pre-existing binary is linked. Such an error will occur only if no method with a matching signature and return type is declared in a superclass.

If the source code for a non-inner class contains no declared constructors, then a default constructor with no parameters is implicitly declared ([¬ß8.8.9](jls-8.html#jls-8.8.9 "8.8.9. Default Constructor")). Adding one or more constructor declarations to the source code of such a class will prevent this default constructor from being implicitly declared, effectively deleting a constructor, unless one of the new constructors also has no parameters, thus replacing the default constructor. The default constructor with no parameters is given the same access modifier as the class of its declaration, so any replacement should have as much or more access if compatibility with pre-existing binaries is to be preserved.

### 13.4.13. Method and Constructor Type Parameters

Adding or removing a type parameter of a method or constructor does not, in itself, have any implications for binary compatibility.

If such a type parameter is used in the type of the method or constructor, that may have the normal implications of changing the aforementioned type.

Renaming a type parameter of a method or constructor has no effect with respect to pre-existing binaries.

Changing the first bound of a type parameter of a method or constructor may change the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of any member that uses that type parameter in its own type, and this may affect binary compatibility. Specifically:

*   If the type parameter is used as the type of a field, the effect is as if the field was removed and a field with the same name, whose type is the new erasure of the type variable, was added.
*   If the type parameter is used as the type of any formal parameter of a method, but not as the return type, the effect is as if that method were removed, and replaced with a new method that is identical except for the types of the aforementioned formal parameters, which now have the new erasure of the type parameter as their type.
*   If the type parameter is used as a return type of a method, but not as the type of any formal parameter of the method, the effect is as if that method were removed, and replaced with a new method that is identical except for the return type, which is now the new erasure of the type parameter.
*   If the type parameter is used as a return type of a method and as the type of one or more formal parameters of the method, the effect is as if that method were removed, and replaced with a new method that is identical except for the return type, which is now the new erasure of the type parameter, and except for the types of the aforementioned formal parameters, which now have the new erasure of the type parameter as their types.
    

Changing any other bound has no effect on binary compatibility.

### 13.4.14. Method and Constructor Formal Parameters

Changing the name of a formal parameter of a method or constructor does not impact pre-existing binaries.

Changing the name of a method, or the type of a formal parameter to a method or constructor, or adding a parameter to or deleting a parameter from a method or constructor declaration creates a method or constructor with a new signature, and has the combined effect of deleting the method or constructor with the old signature and adding a method or constructor with the new signature ([¬ß13.4.12](jls-13.html#jls-13.4.12 "13.4.12. Method and Constructor Declarations")).

Changing the type of the last formal parameter of a method from T`[]` to a variable arity parameter ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters")) of type T (i.e. to T`...`), and vice versa, does not impact pre-existing binaries.

For purposes of binary compatibility, adding or removing a method or constructor `m` whose signature involves type variables ([¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables")) or parameterized types ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")) is equivalent to the addition (respectively, removal) of an otherwise equivalent method whose signature is the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of the signature of `m`.

### 13.4.15. Method Result Type

Changing the result type of a method, or replacing a result type with `void`, or replacing `void` with a result type, has the combined effect of deleting the old method and adding a new method with the new result type or newly `void` result (see [¬ß13.4.12](jls-13.html#jls-13.4.12 "13.4.12. Method and Constructor Declarations")).

For purposes of binary compatibility, adding or removing a method or constructor `m` whose return type involves type variables ([¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables")) or parameterized types ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")) is equivalent to the addition (respectively, removal) of the an otherwise equivalent method whose return type is the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of the return type of `m`.

### 13.4.16. `abstract` Methods

Changing a method that is declared `abstract` to no longer be declared `abstract` does not break compatibility with pre-existing binaries.

Changing a method that is not declared `abstract` to be declared `abstract` will break compatibility with pre-existing binaries that previously invoked the method, causing an `AbstractMethodError`.

**Example 13.4.16-1. Changing A Method To Be `abstract`**

class Super { void out() { System.out.println("Out"); } }
class Test extends Super {
    public static void main(String\[\] args) {
        Test t = new Test();
        System.out.println("Way ");
        t.out();
    }
}

This program produces the output:

Way
Out

Suppose that a new version of class `Super` is produced:

abstract class Super {
    abstract void out();
}

If `Super` is recompiled but not `Test`, then running the new binary with the existing binary of `Test` results in an `AbstractMethodError`, because class `Test` has no implementation of the method `out`, and is therefore is (or should be) `abstract`.

  

### 13.4.17. `final` Methods

Changing a method that is declared `final` to no longer be declared `final` does not break compatibility with pre-existing binaries.

Changing an instance method that is not declared `final` to be declared `final` may break compatibility with existing binaries that depend on the ability to override the method.

**Example 13.4.17-1. Changing A Method To Be `final`**

class Super { void out() { System.out.println("out"); } }
class Test extends Super {
    public static void main(String\[\] args) {
        Test t = new Test();
        t.out();
    }
    void out() { super.out(); }
}

This program produces the output:

out

Suppose that a new version of class `Super` is produced:

class Super { final void out() { System.out.println("!"); } }

If `Super` is recompiled but not `Test`, then running the new binary with the existing binary of `Test` results in a `VerifyError` because the class `Test` improperly tries to override the instance method `out`.

  

Changing a class (`static`) method that is not declared `final` to be declared `final` does not break compatibility with existing binaries, because the method could not have been overridden.

### 13.4.18. `native` Methods

Adding or deleting a `native` modifier of a method does not break compatibility with pre-existing binaries.

The impact of changes to types on pre-existing `native` methods that are not recompiled is beyond the scope of this specification and should be provided with the description of an implementation. Implementations are encouraged, but not required, to implement `native` methods in a way that limits such impact.

### 13.4.19. `static` Methods

If a method that is not declared `private` is also declared `static` (that is, a class method) and is changed to not be declared `static` (that is, to an instance method), or vice versa, then compatibility with pre-existing binaries may be broken, resulting in a linkage time error, namely an `IncompatibleClassChangeError`, if these methods are used by the pre-existing binaries. Such changes are not recommended in code that has been widely distributed.

### 13.4.20. `synchronized` Methods

Adding or deleting a `synchronized` modifier of a method does not break compatibility with pre-existing binaries.

### 13.4.21. Method and Constructor Throws

Changes to the `throws` clause of methods or constructors do not break compatibility with pre-existing binaries; these clauses are checked only at compile time.

### 13.4.22. Method and Constructor Body

Changes to the body of a method or constructor do not break compatibility with pre-existing binaries.

The keyword `final` on a method does not mean that the method can be safely inlined; it means only that the method cannot be overridden. It is still possible that a new version of that method will be provided at link-time. Furthermore, the structure of the original program must be preserved for purposes of reflection.

Therefore, we note that a Java compiler cannot expand a method inline at compile time. In general we suggest that implementations use late-bound (run-time) code generation and optimization.ss="titlepage">

### 13.4.23. Method and Constructor Overloading

Adding new methods or constructors that overload existing methods or constructors does not break compatibility with pre-existing binaries. The signature to be used for each invocation was determined when these existing binaries were compiled; therefore newly added methods or constructors will not be used, even if their signatures are both applicable and more specific than the signature originally chosen.

While adding a new overloaded method or constructor may cause a compile-time error the next time a class or interface is compiled because there is no method or constructor that is most specific ([¬ß15.12.2.5](jls-15.html#jls-15.12.2.5 "15.12.2.5. Choosing the Most Specific Method")), no such error occurs when a program is executed, because no overload resolution is done at execution time.

**Example 13.4.23-1. Adding An Overloaded Method**

class Super {
    static void out(float f) {
        System.out.println("float");
    }
}
class Test {
    public static void main(String\[\] args) {
        Super.out(2);
    }
}

This program produces the output:

float

Suppose that a new version of class `Super` is produced:

class Super {
    static void out(float f) { System.out.println("float"); }
    static void out(int i)   { System.out.println("int");   }
}

If `Super` is recompiled but not `Test`, then running the new binary with the existing binary of Test still produces the output:

float

However, if `Test` is then recompiled, using this new `Super`, the output is then:

int

as might have been naively expected in the previous case.

  

### 13.4.24. Method Overriding

If an instance method is added to a subclass and it overrides a method in a superclass, then the subclass method will be found by method invocations in pre-existing binaries, and these binaries are not impacted.

If a class method is added to a class, then this method will not be found unless the qualifying type of the reference is the subclass type.

### 13.4.25. Static Initializers

Adding, deleting, or changing a static initializer ([¬ß8.7](jls-8.html#jls-8.7 "8.7. Static Initializers")) of a class does not impact pre-existing binaries.

### 13.4.26. Evolution of Enums

Adding or reordering constants in an enum will not break compatibility with pre-existing binaries.

If a pre-existing binary attempts to access an enum constant that no longer exists, the client will fail at run time with a `NoSuchFieldError`. Therefore such a change is not recommended for widely distributed enums.

In all other respects, the binary compatibility rules for enums are identical to those for classes.

13.5. Evolution of Interfaces
-----------------------------

This section describes the impact of changes to the declaration of an interface and its members on pre-existing binaries.

### 13.5.1. `public` Interfaces

Changing an interface that is not declared `public` to be declared `public` does not break compatibility with pre-existing binaries.

If an interface that is declared `public` is changed to not be declared `public`, then an `IllegalAccessError` is thrown if a pre-existing binary is linked that needs but no longer has access to the interface type, so such a change is not recommended for widely distributed interfaces.

### 13.5.2. Superinterfaces

Changes to the interface hierarchy cause errors in the same way that changes to the class hierarchy do, as described in [¬ß13.4.4](jls-13.html#jls-13.4.4 "13.4.4. Superclasses and Superinterfaces"). In particular, changes that result in any previous superinterface of a class no longer being a superinterface can break compatibility with pre-existing binaries, resulting in a `VerifyError`.

### 13.5.3. Interface Members

Adding an `abstract` method to an interface does not break compatibility with pre-existing binaries.

A field added to a superinterface of C may hide a field inherited from a superclass of C. If the original reference was to an instance field, an `IncompatibleClassChangeError` will result. If the original reference was an assignment, an `IllegalAccessError` will result.

Deleting a member from an interface may cause linkage errors in pre-existing binaries.

**Example 13.5.3-1. Deleting An Interface Member**

interface I { void hello(); }
class Test implements I {
    public static void main(String\[\] args) {
        I anI = new Test();
        anI.hello();
    }
    public void hello() { System.out.println("hello"); }
}

This program produces the output:

hello

Suppose that a new version of interface `I` is compiled:

interface I {}

If `I` is recompiled but not `Test`, then running the new binary with the existing binary for `Test` will result in a `NoSuchMethodError`.

  

### 13.5.4. Interface Type Parameters

The effects of changes to the type parameters of an interface are the same as those of analogous changes to the type parameters of a class.

### 13.5.5. Field Declarations

The considerations for changing field declarations in interfaces are the same as those for `static final` fields in classes, as described in [¬ß13.4.8](jls-13.html#jls-13.4.8 "13.4.8. Field Declarations") and [¬ß13.4.9](jls-13.html#jls-13.4.9 "13.4.9. final Fields and static Constant Variables").

### 13.5.6. Interface Method Declarations

The considerations for changing `abstract` method declarations in interfaces include those for `abstract` methods in classes, as described in [¬ß13.4.14](jls-13.html#jls-13.4.14 "13.4.14. Method and Constructor Formal Parameters"), [¬ß13.4.15](jls-13.html#jls-13.4.15 "13.4.15. Method Result Type"), [¬ß13.4.19](jls-13.html#jls-13.4.19 "13.4.19. static Methods"), [¬ß13.4.21](jls-13.html#jls-13.4.21 "13.4.21. Method and Constructor Throws"), and [¬ß13.4.23](jls-13.html#jls-13.4.23 "13.4.23. Method and Constructor Overloading").

Adding a `default` method, or changing a method from `abstract` to `default`, does not break compatibility with pre-existing binaries, but may cause an `IncompatibleClassChangeError` if a pre-existing binary attempts to invoke the method. This error occurs if the qualifying type, T, is a subtype of two interfaces, I and J, where both I and J declare a `default` method with the same signature and result, and neither I nor J is a subinterface of the other.

In other words, adding a default method is a binary-compatible change because it does not introduce errors at link time, even if it introduces errors at compile time or invocation time. In practice, the risk of accidental clashes occurring by introducing a default method are similar to those associated with adding a new method to a non-`final` class. In the event of a clash, adding a method to a class is unlikely to trigger a `LinkageError`, but an accidental override of the method in a child can lead to unpredictable method behavior. Both changes can cause errors at compile time.

**Example 13.5.6-1. Adding A Default Method**

interface Painter {
    default void draw() {
        System.out.println("Here's a picture...");
    }
}

interface Cowboy {}

public class CowboyArtist implements Cowboy, Painter {
    public static void main(String... args) {
        new CowboyArtist().draw();
   }
}

This program produces the output:

Here's a picture...

Suppose that a default method is added to `Cowboy`:

interface Cowboy {
    default void draw() {
        System.out.println("Bang!");
    }
}

If `Cowboy` is recompiled but not `CowboyArtist`, then running the new binary with the existing binary for `CowboyArtist` will link without error but cause an `IncompatibleClassChangeError` when `main` attempts to invoke `draw()`.

  

### 13.5.7. Evolution of Annotation Types

Annotation types behave exactly like any other interface. Adding or removing an element from an annotation type is analogous to adding or removing a method. There are important considerations governing other changes to annotation types, such as making an annotation type repeatable ([¬ß9.6.3](jls-9.html#jls-9.6.3 "9.6.3. Repeatable Annotation Types")), but these have no effect on the linkage of binaries by the Java Virtual Machine. Rather, such changes affect the behavior of reflective APIs that manipulate annotations. The documentation of these APIs specifies their behavior when various changes are made to the underlying annotation types.

Adding or removing annotations has no effect on the correct linkage of the binary representations of programs in the Java programming language.

üçÄ Chapter 14. Blocks and Statements
---------------------------------

**Table of Contents**

[14.1. Normal and Abrupt Completion of Statements](jls-14.html#jls-14.1)
[14.2. Blocks](jls-14.html#jls-14.2)
[14.3. Local Class Declarations](jls-14.html#jls-14.3)
[14.4. Local Variable Declaration Statements](jls-14.html#jls-14.4)
[14.4.1. Local Variable Declarators and Types](jls-14.html#jls-14.4.1)
[14.4.2. Execution of Local Variable Declarations](jls-14.html#jls-14.4.2)
[14.5. Statements](jls-14.html#jls-14.5)
[14.6. The Empty Statement](jls-14.html#jls-14.6)
[14.7. Labeled Statements](jls-14.html#jls-14.7)
[14.8. Expression Statements](jls-14.html#jls-14.8)
[14.9. The `if` Statement](jls-14.html#jls-14.9)
[14.9.1. The `if`\-`then` Statement](jls-14.html#jls-14.9.1)
[14.9.2. The `if`\-`then`\-`else` Statement](jls-14.html#jls-14.9.2)
[14.10. The `assert` Statement](jls-14.html#jls-14.10)
[14.11. The `switch` Statement](jls-14.html#jls-14.11)
[14.12. The `while` Statement](jls-14.html#jls-14.12)
[14.12.1. Abrupt Completion of `while` Statement](jls-14.html#jls-14.12.1)
[14.13. The `do` Statement](jls-14.html#jls-14.13)
[14.13.1. Abrupt Completion of `do` Statement](jls-14.html#jls-14.13.1)
[14.14. The `for` Statement](jls-14.html#jls-14.14)
[14.14.1. The basic `for` Statement](jls-14.html#jls-14.14.1)
[14.14.1.1. Initialization of `for` Statement](jls-14.html#jls-14.14.1.1)
[14.14.1.2. Iteration of `for` Statement](jls-14.html#jls-14.14.1.2)
[14.14.1.3. Abrupt Completion of `for` Statement](jls-14.html#jls-14.14.1.3)
[14.14.2. The enhanced `for` statement](jls-14.html#jls-14.14.2)
[14.15. The `break` Statement](jls-14.html#jls-14.15)
[14.16. The `continue` Statement](jls-14.html#jls-14.16)
[14.17. The `return` Statement](jls-14.html#jls-14.17)
[14.18. The `throw` Statement](jls-14.html#jls-14.18)
[14.19. The `synchronized` Statement](jls-14.html#jls-14.19)
[14.20. The `try` statement](jls-14.html#jls-14.20)
[14.20.1. Execution of `try`\-`catch`](jls-14.html#jls-14.20.1)
[14.20.2. Execution of `try`\-`finally` and `try`\-`catch`\-`finally`](jls-14.html#jls-14.20.2)
[14.20.3. `try`\-with-resources](jls-14.html#jls-14.20.3)
[14.20.3.1. Basic `try`\-with-resources](jls-14.html#jls-14.20.3.1)
[14.20.3.2. Extended `try`\-with-resources](jls-14.html#jls-14.20.3.2)
[14.21. Unreachable Statements](jls-14.html#jls-14.21)

The sequence of execution of a program is controlled by _statements_, which are executed for their effect and do not have values.

Some statements _contain_ other statements as part of their structure; such other statements are substatements of the statement. We say that statement `S` _immediately contains_ statement `U` if there is no statement `T` different from `S` and `U` such that `S` contains `T` and `T` contains `U`. In the same manner, some statements contain expressions ([¬ß15 (_Expressions_)](jls-15.html "Chapter 15. Expressions")) as part of their structure.

The first section of this chapter discusses the distinction between normal and abrupt completion of statements ([¬ß14.1](jls-14.html#jls-14.1 "14.1. Normal and Abrupt Completion of Statements")). Most of the remaining sections explain the various kinds of statements, describing in detail both their normal behavior and any special treatment of abrupt completion.

Blocks are explained first ([¬ß14.2](jls-14.html#jls-14.2 "14.2. Blocks")), followed by local class declarations ([¬ß14.3](jls-14.html#jls-14.3 "14.3. Local Class Declarations")) and local variable declaration statements ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements")).

Next a grammatical maneuver that sidesteps the familiar "dangling else" problem ([¬ß14.5](jls-14.html#jls-14.5 "14.5. Statements")) is explained.

The last section ([¬ß14.21](jls-14.html#jls-14.21 "14.21. Unreachable Statements")) of this chapter addresses the requirement that every statement be _reachable_ in a certain technical sense.

14.1. Normal and Abrupt Completion of Statements
------------------------------------------------

Every statement has a normal mode of execution in which certain computational steps are carried out. The following sections describe the normal mode of execution for each kind of statement.

If all the steps are carried out as described, with no indication of abrupt completion, the statement is said to _complete normally_. However, certain events may prevent a statement from completing normally:

*   The `break` ([¬ß14.15](jls-14.html#jls-14.15 "14.15. The break Statement")), `continue` ([¬ß14.16](jls-14.html#jls-14.16 "14.16. The continue Statement")), and `return` ([¬ß14.17](jls-14.html#jls-14.17 "14.17. The return Statement")) statements cause a transfer of control that may prevent normal completion of statements that contain them.
*   Evaluation of certain expressions may throw exceptions from the Java Virtual Machine ([¬ß15.6](jls-15.html#jls-15.6 "15.6. Normal and Abrupt Completion of Evaluation")). An explicit `throw` ([¬ß14.18](jls-14.html#jls-14.18 "14.18. The throw Statement")) statement also results in an exception. An exception causes a transfer of control that may prevent normal completion of statements.
    

If such an event occurs, then execution of one or more statements may be terminated before all steps of their normal mode of execution have completed; such statements are said to _complete abruptly_.

An abrupt completion always has an associated _reason_, which is one of the following:

*   A `break` with no label
*   A `break` with a given label
*   A `continue` with no label
*   A `continue` with a given label
*   A `return` with no value
*   A `return` with a given value
*   A `throw` with a given value, including exceptions thrown by the Java Virtual Machine
    

The terms "complete normally" and "complete abruptly" also apply to the evaluation of expressions ([¬ß15.6](jls-15.html#jls-15.6 "15.6. Normal and Abrupt Completion of Evaluation")). The only reason an expression can complete abruptly is that an exception is thrown, because of either a `throw` with a given value ([¬ß14.18](jls-14.html#jls-14.18 "14.18. The throw Statement")) or a run-time exception or error ([¬ß11 (_Exceptions_)](jls-11.html "Chapter 11. Exceptions"), [¬ß15.6](jls-15.html#jls-15.6 "15.6. Normal and Abrupt Completion of Evaluation")).

If a statement evaluates an expression, abrupt completion of the expression always causes the immediate abrupt completion of the statement, with the same reason. All succeeding steps in the normal mode of execution are not performed.

Unless otherwise specified in this chapter, abrupt completion of a substatement causes the immediate abrupt completion of the statement itself, with the same reason, and all succeeding steps in the normal mode of execution of the statement are not performed.

Unless otherwise specified, a statement completes normally if all expressions it evaluates and all substatements it executes complete normally.

14.2. Blocks
------------

A _block_ is a sequence of statements, local class declarations, and local variable declaration statements within braces.

Block:

`{` \[[BlockStatements](jls-14.html#jls-BlockStatements "BlockStatements")\] `}`

BlockStatements:

[BlockStatement](jls-14.html#jls-BlockStatement "BlockStatement") {[BlockStatement](jls-14.html#jls-BlockStatement "BlockStatement")}

BlockStatement:

[LocalVariableDeclarationStatement](jls-14.html#jls-LocalVariableDeclarationStatement "LocalVariableDeclarationStatement")  
[ClassDeclaration](jls-8.html#jls-ClassDeclaration "ClassDeclaration")  
[Statement](jls-14.html#jls-Statement "Statement")

A block is executed by executing each of the local variable declaration statements and other statements in order from first to last (left to right). If all of these block statements complete normally, then the block completes normally. If any of these block statements complete abruptly for any reason, then the block completes abruptly for the same reason.

14.3. Local Class Declarations
------------------------------

A _local class_ is a nested class ([¬ß8 (_Classes_)](jls-8.html "Chapter 8. Classes")) that is not a member of any class and that has a name ([¬ß6.2](jls-6.html#jls-6.2 "6.2. Names and Identifiers"), [¬ß6.7](jls-6.html#jls-6.7 "6.7. Fully Qualified Names and Canonical Names")).

All local classes are inner classes ([¬ß8.1.3](jls-8.html#jls-8.1.3 "8.1.3. Inner Classes and Enclosing Instances")).

Every local class declaration statement is immediately contained by a block ([¬ß14.2](jls-14.html#jls-14.2 "14.2. Blocks")). Local class declaration statements may be intermixed freely with other kinds of statements in the block.

It is a compile-time error if a local class declaration contains any of the access modifiers `public`, `protected`, or `private` ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")), or the modifier `static` ([¬ß8.1.1](jls-8.html#jls-8.1.1 "8.1.1. Class Modifiers")).

The scope and shadowing of a local class declaration is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

**Example 14.3-1. Local Class Declarations**

Here is an example that illustrates several aspects of the rules given above:

class Global {
    class Cyclic {}

    void foo() {
        new Cyclic(); // create a Global.Cyclic
        class Cyclic extends Cyclic {} // circular definition

        {
            class Local {}
            {
                class Local {} // compile-time error
            }
            class Local {} // compile-time error
            class AnotherLocal {
                void bar() {
                    class Local {} // ok
                }
            }
        }
        class Local {} // ok, not in scope of prior Local
    }
}

The first statement of method `foo` creates an instance of the member class `Global.Cyclic` rather than an instance of the local class `Cyclic`, because the statement appears prior to the scope of the local class declaration.

The fact that the scope of a local class declaration encompasses its whole declaration (not only its body) means that the definition of the local class `Cyclic` is indeed cyclic because it extends itself rather than `Global.Cyclic`. Consequently, the declaration of the local class `Cyclic` is rejected at compile time.

Since local class names cannot be redeclared within the same method (or constructor or initializer, as the case may be), the second and third declarations of `Local` result in compile-time errors. However, `Local` can be redeclared in the context of another, more deeply nested, class such as `AnotherLocal`.

The final declaration of `Local` is legal, since it occurs outside the scope of any prior declaration of `Local`.

  

14.4. Local Variable Declaration Statements
-------------------------------------------

A _local variable declaration statement_ declares one or more local variable names.

LocalVariableDeclarationStatement:

[LocalVariableDeclaration](jls-14.html#jls-LocalVariableDeclaration "LocalVariableDeclaration") `;`

LocalVariableDeclaration:

{[VariableModifier](jls-8.html#jls-VariableModifier "VariableModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [VariableDeclaratorList](jls-8.html#jls-VariableDeclaratorList "VariableDeclaratorList")

See [¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations") for _UnannType_. The following productions from [¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values"), [¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"), and [¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations") are shown here for convenience:

VariableModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `final`

VariableDeclaratorList:

[VariableDeclarator](jls-8.html#jls-VariableDeclarator "VariableDeclarator") {`,` [VariableDeclarator](jls-8.html#jls-VariableDeclarator "VariableDeclarator")}

VariableDeclarator:

[VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId") \[`=` [VariableInitializer](jls-8.html#jls-VariableInitializer "VariableInitializer")\]

VariableDeclaratorId:

[Identifier](jls-3.html#jls-Identifier "Identifier") \[[Dims](jls-4.html#jls-Dims "Dims")\]

Dims:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]` {{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]`}

VariableInitializer:

[Expression](jls-15.html#jls-Expression "Expression")  
[ArrayInitializer](jls-10.html#jls-ArrayInitializer "ArrayInitializer")

Every local variable declaration statement is immediately contained by a block. Local variable declaration statements may be intermixed freely with other kinds of statements in the block.

Apart from local variable declaration statements, a local variable declaration can appear in the header of a `for` statement ([¬ß14.14](jls-14.html#jls-14.14 "14.14. The for Statement")) or `try`\-with-resources statement ([¬ß14.20.3](jls-14.html#jls-14.20.3 "14.20.3. try-with-resources")). In these cases, it is executed in the same manner as if it were part of a local variable declaration statement.

The rules for annotation modifiers on a local variable declaration are specified in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear") and [¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type").

It is a compile-time error if `final` appears more than once as a modifier for a local variable declaration.

### 14.4.1. Local Variable Declarators and Types

Each _declarator_ in a local variable declaration declares one local variable, whose name is the _Identifier_ that appears in the declarator.

If the optional keyword `final` appears at the start of the declaration, the variable being declared is a final variable ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")).

The declared type of a local variable is denoted by _UnannType_ if no bracket pairs appear in _UnannType_ and _VariableDeclaratorId_, and is specified by [¬ß10.2](jls-10.html#jls-10.2 "10.2. Array Variables") otherwise.

A local variable of type `float` always contains a value that is an element of the float value set ([¬ß4.2.3](jls-4.html#jls-4.2.3 "4.2.3. Floating-Point Types, Formats, and Values")); similarly, a local variable of type `double` always contains a value that is an element of the double value set. It is not permitted for a local variable of type `float` to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a local variable of type `double` to contain an element of the double-extended-exponent value set that is not also an element of the double value set.

The scope and shadowing of a local variable declaration is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

### 14.4.2. Execution of Local Variable Declarations

A local variable declaration statement is an executable statement. Every time it is executed, the declarators are processed in order from left to right. If a declarator has an initializer, the initializer is evaluated and its value is assigned to the variable.

If a declarator does not have an initializer, then every reference to the variable must be preceded by execution of an assignment to the variable, or a compile-time error occurs by the rules of [¬ß16 (_Definite Assignment_)](jls-16.html "Chapter 16. Definite Assignment").

Each initializer (except the first) is evaluated only if evaluation of the preceding initializer completes normally.

Execution of the local variable declaration completes normally only if evaluation of the last initializer completes normally.

If the local variable declaration contains no initializers, then executing it always completes normally.

14.5. Statements
----------------

There are many kinds of statements in the Java programming language. Most correspond to statements in the C and C++ languages, but some are unique.

As in C and C++, the `if` statement of the Java programming language suffers from the so-called "dangling `else` problem," illustrated by this misleadingly formatted example:

if (door.isOpen())
    if (resident.isVisible())
        resident.greet("Hello!");
else door.bell.ring();  // A "dangling else"

The problem is that both the outer `if` statement and the inner `if` statement might conceivably own the `else` clause. In this example, one might surmise that the programmer intended the `else` clause to belong to the outer `if` statement.

The Java programming language, like C and C++ and many programming languages before them, arbitrarily decrees that an `else` clause belongs to the innermost `if` to which it might possibly belong. This rule is captured by the following grammar:

Statement:

[StatementWithoutTrailingSubstatement](jls-14.html#jls-StatementWithoutTrailingSubstatement "StatementWithoutTrailingSubstatement")  
[LabeledStatement](jls-14.html#jls-LabeledStatement "LabeledStatement")  
[IfThenStatement](jls-14.html#jls-IfThenStatement "IfThenStatement")  
[IfThenElseStatement](jls-14.html#jls-IfThenElseStatement "IfThenElseStatement")  
[WhileStatement](jls-14.html#jls-WhileStatement "WhileStatement")  
[ForStatement](jls-14.html#jls-ForStatement "ForStatement")

StatementNoShortIf:

[StatementWithoutTrailingSubstatement](jls-14.html#jls-StatementWithoutTrailingSubstatement "StatementWithoutTrailingSubstatement")  
[LabeledStatementNoShortIf](jls-14.html#jls-LabeledStatementNoShortIf "LabeledStatementNoShortIf")  
[IfThenElseStatementNoShortIf](jls-14.html#jls-IfThenElseStatementNoShortIf "IfThenElseStatementNoShortIf")  
[WhileStatementNoShortIf](jls-14.html#jls-WhileStatementNoShortIf "WhileStatementNoShortIf")  
[ForStatementNoShortIf](jls-14.html#jls-ForStatementNoShortIf "ForStatementNoShortIf")

StatementWithoutTrailingSubstatement:

[Block](jls-14.html#jls-Block "Block")  
[EmptyStatement](jls-14.html#jls-EmptyStatement "EmptyStatement")  
[ExpressionStatement](jls-14.html#jls-ExpressionStatement "ExpressionStatement")  
[AssertStatement](jls-14.html#jls-AssertStatement "AssertStatement")  
[SwitchStatement](jls-14.html#jls-SwitchStatement "SwitchStatement")  
[DoStatement](jls-14.html#jls-DoStatement "DoStatement")  
[BreakStatement](jls-14.html#jls-BreakStatement "BreakStatement")  
[ContinueStatement](jls-14.html#jls-ContinueStatement "ContinueStatement")  
[ReturnStatement](jls-14.html#jls-ReturnStatement "ReturnStatement")  
[SynchronizedStatement](jls-14.html#jls-SynchronizedStatement "SynchronizedStatement")  
[ThrowStatement](jls-14.html#jls-ThrowStatement "ThrowStatement")  
[TryStatement](jls-14.html#jls-TryStatement "TryStatement")

The following productions from [¬ß14.9](jls-14.html#jls-14.9 "14.9. The if Statement") are shown here for convenience:

IfThenStatement:

`if` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` [Statement](jls-14.html#jls-Statement "Statement")

IfThenElseStatement:

`if` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf") `else` [Statement](jls-14.html#jls-Statement "Statement")

IfThenElseStatementNoShortIf:

`if` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf") `else` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf")

Statements are thus grammatically divided into two categories: those that might end in an `if` statement that has no `else` clause (a "short `if` statement") and those that definitely do not.

Only statements that definitely do not end in a short `if` statement may appear as an immediate substatement before the keyword `else` in an `if` statement that does have an `else` clause.

This simple rule prevents the "dangling `else`" problem. The execution behavior of a statement with the "no short `if`" restriction is identical to the execution behavior of the same kind of statement without the "no short `if`" restriction; the distinction is drawn purely to resolve the syntactic difficulty.

14.6. The Empty Statement
-------------------------

An empty statement does nothing.

EmptyStatement:

`;`

Execution of an empty statement always completes normally.

14.7. Labeled Statements
------------------------

Statements may have _label_ prefixes.

LabeledStatement:

[Identifier](jls-3.html#jls-Identifier "Identifier") `:` [Statement](jls-14.html#jls-Statement "Statement")

LabeledStatementNoShortIf:

[Identifier](jls-3.html#jls-Identifier "Identifier") `:` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf")

The _Identifier_ is declared to be the label of the immediately contained _Statement_.

Unlike C and C++, the Java programming language has no `goto` statement; identifier statement labels are used with `break` or `continue` statements ([¬ß14.15](jls-14.html#jls-14.15 "14.15. The break Statement"), [¬ß14.16](jls-14.html#jls-14.16 "14.16. The continue Statement")) appearing anywhere within the labeled statement.

The scope of a label of a labeled statement is the immediately contained _Statement_.

It is a compile-time error if the name of a label of a labeled statement is used within the scope of the label as a label of another labeled statement.

There is no restriction against using the same identifier as a label and as the name of a package, class, interface, method, field, parameter, or local variable. Use of an identifier to label a statement does not obscure ([¬ß6.4.2](jls-6.html#jls-6.4.2 "6.4.2. Obscuring")) a package, class, interface, method, field, parameter, or local variable with the same name. Use of an identifier as a class, interface, method, field, local variable or as the parameter of an exception handler ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) does not obscure a statement label with the same name.

A labeled statement is executed by executing the immediately contained _Statement_.

If the statement is labeled by an _Identifier_ and the contained _Statement_ completes abruptly because of a `break` with the same _Identifier_, then the labeled statement completes normally. In all other cases of abrupt completion of the _Statement_, the labeled statement completes abruptly for the same reason.

**Example 14.7-1. Labels and Identifiers**

The following code was taken from a version of the class `String` and its method `indexOf`, where the label was originally called `test`. Changing the label to have the same name as the local variable `i` does not obscure the label in the scope of the declaration of `i`. Thus, the code is valid.

class Test {
    char\[\] value;
    int offset, count;
    int indexOf(TestString str, int fromIndex) {
        char\[\] v1 = value, v2 = str.value;
        int max = offset + (count - str.count);
        int start = offset + ((fromIndex < 0) ? 0 : fromIndex);
    i:
        for (int i = start; i <= max; i++) {
            int n = str.count, j = i, k = str.offset;
            while (n-- != 0) {
                if (v1\[j++\] != v2\[k++\])
                    continue i;
            } 
            return i - offset;
        }
        return -1;
    }
}

The identifier `max` could also have been used as the statement label; the label would not obscure the local variable `max` within the labeled statement.

  

14.8. Expression Statements
---------------------------

Certain kinds of expressions may be used as statements by following them with semicolons.

ExpressionStatement:

[StatementExpression](jls-14.html#jls-StatementExpression "StatementExpression") `;`

StatementExpression:

[Assignment](jls-15.html#jls-Assignment "Assignment")  
[PreIncrementExpression](jls-15.html#jls-PreIncrementExpression "PreIncrementExpression")  
[PreDecrementExpression](jls-15.html#jls-PreDecrementExpression "PreDecrementExpression")  
[PostIncrementExpression](jls-15.html#jls-PostIncrementExpression "PostIncrementExpression")  
[PostDecrementExpression](jls-15.html#jls-PostDecrementExpression "PostDecrementExpression")  
[MethodInvocation](jls-15.html#jls-MethodInvocation "MethodInvocation")  
[ClassInstanceCreationExpression](jls-15.html#jls-ClassInstanceCreationExpression "ClassInstanceCreationExpression")

An _expression statement_ is executed by evaluating the expression; if the expression has a value, the value is discarded.

Execution of the expression statement completes normally if and only if evaluation of the expression completes normally.

Unlike C and C++, the Java programming language allows only certain forms of expressions to be used as expression statements. For example, it is legal to use a method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")):

System.out.println("Hello world");  // OK

but it is not legal to use a parenthesized expression ([¬ß15.8.5](jls-15.html#jls-15.8.5 "15.8.5. Parenthesized Expressions")):

(System.out.println("Hello world"));  // illegal

Note that the Java programming language does not allow a "cast to `void`" - `void` is not a type - so the traditional C trick of writing an expression statement such as:

(void)... ;  // incorrect!

does not work. On the other hand, the Java programming language allows all the most useful kinds of expressions in expression statements, and it does not require a method invocation used as an expression statement to invoke a `void` method, so such a trick is almost never needed. If a trick is needed, either an assignment statement ([¬ß15.26](jls-15.html#jls-15.26 "15.26. Assignment Operators")) or a local variable declaration statement ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements")) can be used instead.

14.9. The `if` Statement
------------------------

The `if` statement allows conditional execution of a statement or a conditional choice of two statements, executing one or the other but not both.

IfThenStatement:

`if` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` [Statement](jls-14.html#jls-Statement "Statement")

IfThenElseStatement:

`if` `(`[](jls-15.html#jls-Expression)e="Expression">Expression `)` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf") `else` [Statement](jls-14.html#jls-Statement "Statement")

IfThenElseStatementNoShortIf:

`if` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf") `else` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf")

The _Expression_ must have type `boolean` or `Boolean`, or a compile-time error occurs.

### 14.9.1. The `if`\-`then` Statement

An `if`\-`then` statement is executed by first evaluating the _Expression_. If the result is of type `Boolean`, it is subject to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).

If evaluation of the _Expression_ or the subsequent unboxing conversion (if any) completes abruptly for some reason, the `if`\-`then` statement completes abruptly for the same reason.

Otherwise, execution continues by making a choice based on the resulting value:

*   If the value is `true`, then the contained _Statement_ is executed; the `if`\-`then` statement completes normally if and only if execution of the _Statement_ completes normally.
*   If the value is `false`, no further action is taken and the `if`\-`then` statement completes normally.
    

### 14.9.2. The `if`\-`then`\-`else` Statement

An `if`\-`then`\-`else` statement is executed by first evaluating the _Expression_. If the result is of type `Boolean`, it is subject to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).

If evaluation of the _Expression_ or the subsequent unboxing conversion (if any) completes abruptly for some reason, then the `if`\-`then`\-`else` statement completes abruptly for the same reason.

Otherwise, execution continues by making a choice based on the resulting value:

*   If the value is `true`, then the first contained _Statement_ (the one before the `else` keyword) is executed; the `if`\-`then`\-`else` statement completes normally if and only if execution of that statement completes normally.
*   If the value is `false`, then the second contained _Statement_ (the one after the `else` keyword) is executed; the `if`\-`then`\-`else` statement completes normally if and only if execution of that statement completes normally.
    

14.10. The `assert` Statement
-----------------------------

An _assertion_ is an `assert` statement containing a boolean expression. An assertion is either _enabled_ or _disabled_. If an assertion is enabled, execution of the assertion causes evaluation of the boolean expression and an error is reported if the expression evaluates to `false`. If the assertion is disabled, execution of the assertion has no effect whatsoever.

AssertStatement:

`assert` [Expression](jls-15.html#jls-Expression "Expression") `;`  
`assert` [Expression](jls-15.html#jls-Expression "Expression") `:` [Expression](jls-15.html#jls-Expression "Expression") `;`

To ease the presentation, the first _Expression_ in both forms of the `assert` statement is referred to as _Expression1_. In the second form of the `assert` statement, the second _Expression_ is referred to as _Expression2_.

It is a compile-time error if _Expression1_ does not have type `boolean` or `Boolean`.

In the second form of the `assert` statement, it is a compile-time error if _Expression2_ is void ([¬ß15.1](jls-15.html#jls-15.1 "15.1. Evaluation, Denotation, and Result")).

An `assert` statement that is executed after its class or interface has completed initialization is enabled if and only if the host system has determined that the top level class or interface that lexically contains the `assert` statement enables assertions.

Whether a top level class or interface enables assertions is determined no later than the earliest of i) the initialization of the top level class or interface, and ii) the initialization of any class or interface nested in the top level class or interface. Whether a top level class or interface enables assertions cannot be changed after it has been determined.

An `assert` statement that is executed before its class or interface has completed initialization is enabled.

This rule is motivated by a case that demands special treatment. Recall that the assertion status of a class is set no later than the time it is initialized. It is possible, though generally not desirable, to execute methods or constructors prior to initialization. This can happen when a class hierarchy contains a circularity in its static initialization, as in the following example:

public class Foo {
    public static void main(String\[\] args) {
        Baz.testAsserts(); 
        // Will execute after Baz is initialized.
    }
}
class Bar {
    static {
        Baz.testAsserts(); 
        // Will execute before Baz is initialized!
    }
}
class Baz extends Bar {
    static void testAsserts() {
        boolean enabled = false;
        assert  enabled = true;
        System.out.println("Asserts " + 
			   (enabled ? "enabled" : "disabled"));
    }
}

Invoking `Baz.testAsserts()` causes `Baz` to be initialized. Before this can happen, `Bar` must be initialized. `Bar`'s static initializer again invokes `Baz.testAsserts()`. Because initialization of `Baz` is already in progress by the current thread, the second invocation executes immediately, though `Baz` is not initialized ([¬ß12.4.2](jls-12.html#jls-12.4.2 "12.4.2. Detailed Initialization Procedure")).

Because of the rule above, if the program above is executed without enabling assertions, it must print:

Asserts enabled
Asserts disabled

A disabled `assert` statement does nothing. In particular, neither _Expression1_ nor _Expression2_ (if it is present) are evaluated. Execution of a disabled `assert` statement always completes normally.

An enabled `assert` statement is executed by first evaluating _Expression1_. If the result is of type `Boolean`, it is subject to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).

If evaluation of _Expression1_ or the subsequent unboxing conversion (if any) completes abruptly for some reason, the `assert` statement completes abruptly for the same reason.

Otherwise, execution continues by making a choice based on the value of _Expression1_:

*   If the value is `true`, no further action is taken and the `assert` statement completes normally.
*   If the value is `false`, the execution behavior depends on whether _Expression2_ is present:
    
    *   If _Expression2_ is present, it is evaluated. Then:
        
        *   If the evaluation completes abruptly for some reason, the `assert` statement completes abruptly for the same reason.
            
        *   If the evaluation completes normally, an `AssertionError` instance whose "detail message" is the resulting value of _Expression2_ is created. Then:
            
            *   If the instance creation completes abruptly for some reason, the `assert` statement completes abruptly for the same reason.
                
            *   If the instance creation completes normally, the `assert` statement completes abruptly by throwing the newly created `AssertionError` object.
                
            
        
    *   If _Expression2_ is not present, an `AssertionError` instance with no "detail message" is created. Then:
        
        *   If the instance creation completes abruptly for some reason, the `assert` statement completes abruptly for the same reason.
            
        *   If the instance creation completes normally, the `assert` statement completes abruptly by throwing the newly created `AssertionError` object.
            
        
    

Typically, assertion checking is enabled during program development and testing, and disabled for deployment, to improve performance.

Because assertions may be disabled, programs must not assume that the expressions contained in assertions will be evaluated. Thus, these boolean expressions should generally be free of side effects. Evaluating such a boolean expression should not affect any state that is visible after the evaluation is complete. It is not illegal for a boolean expression contained in an assertion to have a side effect, but it is generally inappropriate, as it could cause program behavior to vary depending on whether assertions were enabled or disabled.

In light of this, assertions should not be used for argument checking in `public` methods. Argument checking is typically part of the contract of a method, and this contract must be upheld whether assertions are enabled or disabled.

A secondary problem with using assertions for argument checking is that erroneous arguments should result in an appropriate run-time exception (such as `IllegalArgumentException`, `ArrayIndexOutOfBoundsException`, or `NullPointerException`). An assertion failure will not throw an appropriate exception. Again, it is not illegal to use assertions for argument checking on `public` methods, but it is generally inappropriate. It is intended that `AssertionError` never be caught, but it is possible to do so, thus the rules for `try` statements should treat assertions appearing in a `try` block similarly to the current treatment of `throw` statements.

14.11. The `switch` Statement
-----------------------------

The `switch` statement transfers control to one of several statements depending on the value of an expression.

SwitchStatement:

`switch` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` [SwitchBlock](jls-14.html#jls-SwitchBlock "SwitchBlock")

SwitchBlock:

`{` {[SwitchBlockStatementGroup](jls-14.html#jls-SwitchBlockStatementGroup "SwitchBlockStatementGroup")} {[SwitchLabel](jls-14.html#jls-SwitchLabel "SwitchLabel")} `}`

SwitchBlockStatementGroup:

[SwitchLabels](jls-14.html#jls-SwitchLabels "SwitchLabels") [BlockStatements](jls-14.html#jls-BlockStatements "BlockStatements")

SwitchLabels:

[SwitchLabel](jls-14.html#jls-SwitchLabel "SwitchLabel") {[SwitchLabel](jls-14.html#jls-SwitchLabel "SwitchLabel")}

SwitchLabel:

`case` [ConstantExpression](jls-15.html#jls-ConstantExpression "ConstantExpression") `:`  
`case` [EnumConstantName](jls-14.html#jls-EnumConstantName "EnumConstantName") `:`  
`default` `:`

EnumConstantName:

[Identifier](jls-3.html#jls-Identifier "Identifier")

The type of the _Expression_ must be `char`, `byte`, `short`, `int`, `Character`, `Byte`, `Short`, `Integer`, `String`, or an enum type ([¬ß8.9](jls-8.html#jls-8.9 "8.9. Enum Types")), or a compile-time error occurs.

The body of a `switch` statement is known as a _switch block_. Any statement immediately contained by the switch block may be labeled with one or more _switch labels_, which are `case` or `default` labels. Every `case` label has a `case` constant, which is either a constant expression or the name of an enum constant. Switch labels and their `case` constants are said to be _associated_ with the `switch` statement.

Given a `switch` statement, all of the following must be true or a compile-time error occurs:

*   Every `case` constant associated with the `switch` statement must be assignment compatible with the type of the `switch` statement's _Expression_ ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")).
*   If the type of the `switch` statement's _Expression_ is an enum type, then every `case` constant associated with the `switch` statement must be an enum constant of that type.
*   No two of the `case` constants associated with the `switch` statement have the same value.
*   No `case` constant associated with the `switch` statement is `null`.
*   At most one `default` label is associated with the `switch` statement.
    

The prohibition against using `null` as a `case` constant prevents code being written that can never be executed. If the `switch` statement's _Expression_ is of a reference type, that is, `String` or a boxed primitive type or an enum type, then an exception will be thrown will occur if the _Expression_ evaluates to `null` at run time. In the judgment of the designers of the Java programming language, this is a better outcome than silently skipping the entire `switch` statement or choosing to execute the statements (if any) after the `default` label (if any).

A Java compiler is encouraged (but not required) to provide a warning if a `switch` on an enum-valued expression lacks a `default` label and lacks `case` labels for one or more of the enum's constants. Such a `switch` will silently do nothing if the expression evaluates to one of the missing constants.

In C and C++ the body of a `switch` statement can be a statement and statements with `case` labels do not have to be immediately contained by that statement. Consider the simple loop:

for (i = 0; i < n; ++i) foo();

where `n` is known to be positive. A trick known as _Duff's device_ can be used in C or C++ to unroll the loop, but this is not valid code in the Java programming language:

int q = (n+7)/8;
switch (n%8) {
    case 0: do { foo();    // Great C hack, Tom,
    case 7:      foo();    // but it's not valid here.
    case 6:      foo();
    case 5:      foo();
    case 4:      foo();
    case 3:      foo();
    case 2:      foo();
    case 1:      foo();
            } while (--q > 0);
}

Fortunately, this trick does not seem to be widely known or used. Moreover, it is less needed nowadays; this sort of code transformation is properly in the province of state-of-the-art optimizing compilers.

When the `switch` statement is executed, first the _Expression_ is evaluated. If the _Expression_ evaluates to `null`, a `NullPointerException` is thrown and the entire `switch` statement completes abruptly for that reason. Otherwise, if the result is of a reference type, it is subject to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).

If evaluation of the _Expression_ or the subsequent unboxing conversion (if any) completes abruptly for some reason, the `switch` statement completes abruptly for the same reason.

Otherwise, execution continues by comparing the value of the _Expression_ with each `case` constant, and there is a choice:

*   If one of the `case` constants is equal to the value of the expression, then we say that the `case` label _matches_. All statements after the matching `case` label in the `switch` block, if any, are executed in sequence.
    
    If all these statements complete normally, or if there are no statements after the matching `case` label, then the entire `switch` statement completes normally.
*   If no `case` label matches but there is a `default` label, then all statements after the `default` label in the `switch` block, if any, are executed in sequence.
    
    If all these statements complete normally, or if there are no statements after the `default` label, then the entire `switch` statement completes normally.
*   If no `case` label matches and there is no `default` label, then no further action is taken and the `switch` statement completes normally.
    

If any statement immediately contained by the _Block_ body of the `switch` statement completes abruptly, it is handled as follows:

*   If execution of the _Statement_ completes abruptly because of a `break` with no label, no further action is taken and the `switch` statement completes normally.
*   If execution of the _Statement_ completes abruptly for any other reason, the `switch` statement completes abruptly for the same reason.
    
    The case of abrupt completion because of a `break` with a label is handled by the general rule for labeled statements ([¬ß14.7](jls-14.html#jls-14.7 "14.7. Labeled Statements")).
    

**Example 14.11-1. Fall-Through in the `switch` Statement**

As in C and C++, execution of statements in a `switch` block "falls through labels."

For example, the program:

class TooMany {
    static void howMany(int k) {
        switch (k) {
            case 1: System.out.print("one ");
            case 2: System.out.print("too ");
            case 3: System.out.println("many");
        }
    }
    public static void main(String\[\] args) {
        howMany(3);
        howMany(2);
        howMany(1);
    }
}

contains a `switch` block in which the code for each `case` falls through into the code for the next `case`. As a result, the program prints:

many
too many
one too many

If code is not to fall through `case` to `case` in this manner, then `break` statements should be used, as in this example:

class TwoMany {
    static void howMany(int k) {
        switch (k) {
            case 1: System.out.println("one");
                    break;  // exit the switch
            case 2: System.out.println("two");
                    break;  // exit the switch
            case 3: System.out.println("many");
                    break;  // not needed, but good style
        }
    }
    public static void main(String\[\] args) {
        howMany(1);
        howMany(2);
        howMany(3);
    }
}

This program prints:

one
two
many

  

14.12. The `while` Statement
----------------------------

The `while` statement executes an _Expression_ and a _Statement_ repeatedly until the value of the _Expression_ is `false`.

WhileStatement:

`while` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` [Statement](jls-14.html#jls-Statement "Statement")

WhileStatementNoShortIf:

`while` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf")

The _Expression_ must have type `boolean` or `Boolean`, or a compile-time error occurs.

A `while` statement is executed by first evaluating the _Expression_. If the result is of type `Boolean`, it is subject to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).

If evaluation of the _Expression_ or the subsequent unboxing conversion (if any) completes abruptly for some reason, the `while` statement completes abruptly for the same reason.

Otherwise, execution continues by making a choice based on the resulting value:

*   If the value is `true`, then the contained _Statement_ is executed. Then there is a choice:
    
    *   If execution of the _Statement_ completes normally, then the entire `while` statement is executed again, beginning by re-evaluating the _Expression_.
        
    *   If execution of the _Statement_ completes abruptly, see [¬ß14.12.1](jls-14.html#jls-14.12.1 "14.12.1. Abrupt Completion of while Statement").
        
*   If the (possibly unboxed) value of the _Expression_ is `false`, no further action is taken and the `while` statement completes normally.
    
    If the (possibly unboxed) value of the _Expression_ is `false` the first time it is evaluated, then the _Statement_ is not executed.
    

### 14.12.1. Abrupt Completion of `while` Statement

Abrupt completion of the contained _Statement_ is handled in the following manner:

*   If execution of the _Statement_ completes abruptly because of a `break` with no label, no further action is taken and the `while` statement completes normally.
*   If execution of the _Statement_ completes abruptly because of a `continue` with no label, then the entire `while` statement is executed again.
*   If execution of the _Statement_ completes abruptly because of a `continue` with label `L`, then there is a choice:
    
    *   If the `while` statement has label `L`, then the entire `while` statement is executed again.
        
    *   If the `while` statement does not have label `L`, the `while` statement completes abruptly because of a `continue` with label `L`.
        
*   If execution of the _Statement_ completes abruptly for any other reason, the `while` statement completes abruptly for the same reason.
    
    The case of abrupt completion because of a `break` with a label is handled by the general rule for labeled statements ([¬ß14.7](jls-14.html#jls-14.7 "14.7. Labeled Statements")).
    

14.13. The `do` Statement
-------------------------

The `do` statement executes a _Statement_ and an _Expression_ repeatedly until the value of the _Expression_ is `false`.

DoStatement:

`do` [Statement](jls-14.html#jls-Statement "Statement") `while` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` `;`

The _Expression_ must have type `boolean` or `Boolean`, or a compile-time error occurs.

A `do` statement is executed by first executing the _Statement_. Then there is a choice:

*   If execution of the _Statement_ completes normally, then the _Expression_ is evaluated. If the result is of type `Boolean`, it is subject to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).
    
    If evaluation of the _Expression_ or the subsequent unboxing conversion (if any) completes abruptly for some reason, the `do` statement completes abruptly for the same reason.
    
    Otherwise, there is a choice based on the resulting value:
    
    *   If the value is `true`, then the entire `do` statement is executed again.
        
    *   If the value is `false`, no further action is taken and the `do` statement completes normally.
        
*   If execution of the _Statement_ completes abruptly, see [¬ß14.13.1](jls-14.html#jls-14.13.1 "14.13.1. Abrupt Completion of do Statement").
    

Executing a `do` statement always executes the contained _Statement_ at least once.

### 14.13.1. Abrupt Completion of `do` Statement

Abrupt completion of the contained _Statement_ is handled in the following manner:

*   If execution of the _Statement_ completes abruptly because of a `break` with no label, then no further action is taken and the `do` statement completes normally.
*   If execution of the _Statement_ completes abruptly because of a `continue` with no label, then the _Expression_ is evaluated. Then there is a choice based on the resulting value:
    
    *   If the value is `true`, then the entire `do` statement is executed again.
        
    *   If the value is `false`, no further action is taken and the `do` statement completes normally.
        
*   If execution of the _Statement_ completes abruptly because of a `continue` with label `L`, then there is a choice:
    
    *   If the `do` statement has label `L`, then the _Expression_ is evaluated. Then there is a choice:
        
        *   If the value of the _Expression_ is `true`, then the entire `do` statement is executed again.
            
        *   If the value of the _Expression_ is `false`, no further action is taken and the `do` statement completes normally.
            
        
    *   If the `do` statement does not have label `L`, the `do` statement completes abruptly because of a `continue` with label `L`.
        
*   If execution of the _Statement_ completes abruptly for any other reason, the `do` statement completes abruptly for the samereason.

The case of abrupt completion because of a `break` with a label is handled by the general rule for labeled statements ([¬ß14.7](jls-14.html#jls-14.7 "14.7. Labeled Statements")).

**Example 14.13-1. The `do` Statement**

The following code is one possible implementation of the `toHexString` method of class `Integer`:

public static String toHexString(int i) {
    StringBuffer buf = new StringBuffer(8);
    do {
        buf.append(Character.forDigit(i & 0xF, 16));
        i >>>= 4;
    } while (i != 0);
    return buf.reverse().toString();
}

Because at least one digit must be generated, the `do` statement is an appropriate control structure.

  

14.14. The `for` Statement
--------------------------

The `for` statement has two forms:

*   The basic `for` statement.
*   The enhanced `for` statement
    

ForStatement:

[BasicForStatement](jls-14.html#jls-BasicForStatement "BasicForStatement")  
[EnhancedForStatement](jls-14.html#jls-EnhancedForStatement "EnhancedForStatement")

ForStatementNoShortIf:

[BasicForStatementNoShortIf](jls-14.html#jls-BasicForStatementNoShortIf "BasicForStatementNoShortIf")  
[EnhancedForStatementNoShortIf](jls-14.html#jls-EnhancedForStatementNoShortIf "EnhancedForStatementNoShortIf")

### 14.14.1. The basic `for` Statement

The basic `for` statement executes some initialization code, then executes an _Expression_, a _Statement_, and some update code repeatedly until the value of the _Expression_ is `false`.

BasicForStatement:

`for` `(` \[[ForInit](jls-14.html#jls-ForInit "ForInit")\] `;` \[[Expression](jls-15.html#jls-Expression "Expression")\] `;` \[[ForUpdate](jls-14.html#jls-ForUpdate "ForUpdate")\] `)` [Statement](jls-14.html#jls-Statement "Statement")

BasicForStatementNoShortIf:

`for` `(` \[[ForInit](jls-14.html#jls-ForInit "ForInit")\] `;` \[[Expression](jls-15.html#jls-Expression "Expression")\] `;` \[[ForUpdate](jls-14.html#jls-ForUpdate "ForUpdate")\] `)` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf")

ForInit:

[StatementExpressionList](jls-14.html#jls-StatementExpressionList "StatementExpressionList")  
[LocalVariableDeclaration](jls-14.html#jls-LocalVariableDeclaration "LocalVariableDeclaration")

ForUpdate:

[StatementExpressionList](jls-14.html#jls-StatementExpressionList "StatementExpressionList")

StatementExpressionList:

[StatementExpression](jls-14.html#jls-StatementExpression "StatementExpression") {`,` [StatementExpression](jls-14.html#jls-StatementExpression "StatementExpression")}

The _Expression_ must have type `boolean` or `Boolean`, or a compile-time error occurs.

The scope and shadowing of a local variable declared in the _ForInit_ part of a basic `for` statement is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

#### 14.14.1.1. Initialization of `for` Statement

A `for` statement is executed by first executing the _ForInit_ code:

*   If the _ForInit_ code is a list of statement expressions ([¬ß14.8](jls-14.html#jls-14.8 "14.8. Expression Statements")), the expressions are evaluated in sequence from left to right; their values, if any, are discarded.
    
    If evaluation of any expression completes abruptly for some reason, the `for` statement completes abruptly for the same reason; any _ForInit_ statement expressions to the right of the one that completed abruptly are not evaluated.
*   If the _ForInit_ code is a local variable declaration ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements")), it is executed as if it were a local variable declaration statement appearing in a block.
    
    If execution of the local variable declaration completes abruptly for any reason, the `for` statement completes abruptly for the same reason.
*   If the _ForInit_ part is not present, no action is taken.
    

#### 14.14.1.2. Iteration of `for` Statement

Next, a `for` iteration step is performed, as follows:

*   If the _Expression_ is present, it is evaluated. If the result is of type `Boolean`, it is subject to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).
    
    If evaluation of the _Expression_ or the subsequent unboxing conversion (if any) completes abruptly, the `for` statement completes abruptly for the same reason.
    
    Otherwise, there is then a choice based on the presence or absence of the _Expression_ and the resulting value if the _Expression_ is present; see next bullet.
*   If the _Expression_ is not present, or it is present and the value resulting from its evaluation (including any possible unboxing) is `true`, then the contained _Statement_ is executed. Then there is a choice:
    
    *   If execution of the _Statement_ completes normally, then the following two steps are performed in sequence:
        
        1.  First, if the _ForUpdate_ part is present, the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If evaluation of any expression completes abruptly for some reason, the `for` statement completes abruptly for the same reason; any _ForUpdate_ statement expressions to the right of the one that completed abruptly are not evaluated.
            
            If the _ForUpdate_ part is not present, no action is taken.
            
        2.  Second, another `for` iteration step is performed.
            
        
    *   If execution of the _Statement_ completes abruptly, see [¬ß14.14.1.3](jls-14.html#jls-14.14.1.3 "14.14.1.3. Abrupt Completion of for Statement").
        
*   If the _Expression_ is present and the value resulting from its evaluation (including any possible unboxing) is `false`, no further action is taken and the `for` statement completes normally.
    
    If the (possibly unboxed) value of the _Expression_ is `false` the first time it is evaluated, then the _Statement_ is not executed.
    

If the _Expression_ is not present, then the only way a `for` statement can complete normally is by use of a `break` statement.

#### 14.14.1.3. Abrupt Completion of `for` Statement

Abrupt completion of the contained _Statement_ is handled in the following manner:

*   If execution of the _Statement_ completes abruptly because of a `break` with no label, no further action is taken and the `for` statement completes normally.
*   If execution of the _Statement_ completes abruptly because of a `continue` with no label, then the following two steps are performed in sequence:
    
    1.  First, if the _ForUpdate_ part is present, the expressions are evaluated in sequence from left to right; their values, if any, are discarded.
        
        If the _ForUpdate_ part is not present, no action is taken.
        
    2.  Second, another `for` iteration step is performed.
        
*   If execution of the _Statement_ completes abruptly because of a `continue` with label `L`, then there is a choice:
    
    *   If the `for` statement has label `L`, then the following two steps are performed in sequence:
        
        1.  First, if the _ForUpdate_ part is present, the expressions are evaluated in sequence from left to right; their values, if any, are discarded.
            
            If the _ForUpdate_ is not present, no action is taken.
            
        2.  Second, another `for` iteration step is performed.
            
        
    *   If the `for` statement does not have label `L`, the `for` statement completes abruptly because of a `continue` with label `L`.
        
*   If execution of the _Statement_ completes abruptly for any other reason, the `for` statement completes abruptly for the same reason.
    
    Note that the case of abrupt completion because of a `break` with a label is handled by the general rule for labeled statements ([¬ß14.7](jls-14.html#jls-14.7 "14.7. Labeled Statements")).
    

### 14.14.2. The enhanced `for` statement

The enhanced `for` statement has the form:

EnhancedForStatement:

`for` `(` {[VariableModifier](jls-8.html#jls-VariableModifier "VariableModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId") `:` [Expression](jls-15.html#jls-Expression "Expression") `)` [Statement](jls-14.html#jls-Statement "Statement")

EnhancedForStatementNoShortIf:

`for` `(` {[VariableModifier](jls-8.html#jls-VariableModifier "VariableModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId") `:` [Expression](jls-15.html#jls-Expression "Expression") `)` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf")

See [¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations") for _UnannType_. The following productions from [¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values"), [¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"), and [¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations") are shown here for convenience:

VariableModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `final`

VariableDeclaratorId:

[Identifier](jls-3.html#jls-Identifier "Identifier") \[[Dims](jls-4.html#jls-Dims "Dims")\]

Dims:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]` {{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]`}

The type of the _Expression_ must be `Iterable` or an array type ([¬ß10.1](jls-10.html#jls-10.1 "10.1. Array Types")), or a compile-time error occurs.

The declared type of the local variable in the header of the enhanced `for` statement is denoted by _UnannType_ if no bracket pairs appear in _UnannType_ and _VariableDeclaratorId_, and is specified by [¬ß10.2](jls-10.html#jls-10.2 "10.2. Array Variables") otherwise.

The scope and shadowing of the local variable declared in the header of an enhanced `for` statement is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

The meaning of the enhanced `for` statement is given by translation into a basic `for` statement, as follows:

*   If the type of _Expression_ is a subtype of `Iterable`, then the translation is as follows.
    
    If the type of _Expression_ is a subtype of `Iterable``<`X`>` for some type argument X, then let I be the type `java.util.Iterator``<`X`>`; otherwise, let I be the raw type `java.util.Iterator`.
    
    The enhanced `for` statement is equivalent to a basic `for` statement of the form:
    
    for (I #i = _Expression_.iterator(); #i.hasNext(); ) {
        _{VariableModifier} TargetType Identifier_ =
            (TargetType) #i.next();
        _Statement_
    }
        
    
    `#i` is an automatically generated identifier that is distinct from any other identifiers (automatically generated or otherwise) that are in scope ([¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration")) at the point where the enhanced `for` statement occurs.
    
    If the declared type of the local variable in the header of the enhanced `for` statement is a reference type, then _TargetType_ is that declared type; otherwise, _TargetType_ is the upper bound of the capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")) of the type argument of I, or `Object` if I is raw.
    
    For example, this code:
    
    List<? extends Integer> l = ...
    for (float i : l) ...
          
    
    will be translated to:
    
    for (Iterator<Integer> #i = l.iterator(); #i.hasNext(); ) {
        float #i0 = (Integer)#i.next();
        ...
          
*   Otherwise, the _Expression_ necessarily has an array type, T`[]`.
    
    Let `L1` ... `Lm` be the (possibly empty) sequence of labels immediately preceding the enhanced `for` statement.
    
    The enhanced `for` statement is equivalent to a basic `for` statement of the form:
    
    T`[]` #a = _Expression_;
    `L1`: `L2`: ... `Lm`:
    for (int #i = 0; #i < #a.length; #i++) {
        _{VariableModifier} TargetType Identifier_ = #a\[#i\];
        _Statement_
    }
        
    
    `#a` and `#i` are automatically generated identifiers that are distinct from any other identifiers (automatically generated or otherwise) that are in scope at the point where the enhanced `for` statement occurs.
    
    _TargetType_ is the declared type of the local variable in the header of the enhanced `for` statement.
    

**Example 14.14-1. Enhanced `for` And Arrays**

The following program, which calculates the sum of an integer array, shows how enhanced `for` works for arrays:

int sum(int\[\] a) {
    int sum = 0;
    for (int i : a) sum += i;
    return sum;
}

  

**Example 14.14-2. Enhanced `for` And Unboxing Conversion**

The following program combines the enhanced `for` statement with auto-unboxing to translate a histogram into a frequency table:

Map<String, Integer> histogram = ...;
double total = 0;
for (int i : histogram.values())
    total += i;
for (Map.Entry<String, Integer> e : histogram.entrySet())
    System.out.println(e.getKey() + " " + e.getValue() / total);
}

  

14.15. The `break` Statement
----------------------------

A `break` statement transfers control out of an enclosing statement.

BreakStatement:

`break` \[[Identifier](jls-3.html#jls-Identifier "Identifier")\] `;`

A `break` statement with no label attempts to transfer control to the innermost enclosing `switch`, `while`, `do`, or `for` statement of the immediately enclosing method or initializer; this statement, which is called the _break target_, then immediately completes normally.

To be precise, a `break` statement with no label always completes abruptly, the reason being a `break` with no label.

If no `switch`, `while`, `do`, or `for` statement in the immediately enclosing method, constructor, or initializer contains the `break` statement, a compile-time error occurs.

A `break` statement with label _Identifier_ attempts to transfer control to the enclosing labeled statement ([¬ß14.7](jls-14.html#jls-14.7 "14.7. Labeled Statements")) that has the same _Identifier_ as its label; this statement, which is called the _break target_, then immediately completes normally. In this case, the break target need not be a `switch`, `while`, `do`, or `for` statement.

To be precise, a `break` statement with label _Identifier_ always completes abruptly, the reason being a `break` with label _Identifier_.

A `break` statement must refer to a label within the immediately enclosing method, constructor, initializer, or lambda body. There are no non-local jumps. If no labeled statement with _Identifier_ as its label in the immediately enclosing method, constructor, initializer, or lambda body contains the `break` statement, a compile-time error occurs.

It can be seen, then, that a `break` statement always completes abruptly.

The preceding descriptions say "attempts to transfer control" rather than just "transfers control" because if there are any `try` statements ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) within the break target whose `try` blocks or `catch` clauses contain the `break` statement, then any `finally` clauses of those `try` statements are executed, in order, innermost to outermost, before control is transferred to the break target. Abrupt completion of a `finally` clause can disrupt the transfer of control initiated by a `break` statement.

**Example 14.15-1. The `break` Statement**

In the following example, a mathematical graph is represented by an array of arrays. A graph consists of a set of nodes and a set of edges; each edge is an arrow that points from some node to some other node, or from a node to itself. In this example it is assumed that there are no redundant edges; that is, for any two nodes `P` and `Q`, where `Q` may be the same as `P`, there is at most one edge from `P` to `Q`.

Nodes are represented by integers, and there is an edge from node `i` to node ``edges[`i`][`j`]`` for every `i` and `j` for which the array reference ``edges[`i`][`j`]`` does not throw an `ArrayIndexOutOfBoundsException`.

The task of the method `loseEdges`, given integers `i` and `j`, is to construct a new graph by copying a given graph but omitting the edge from node `i` to node `j`, if any, and the edge from node `j` to node `i`, if any:

class Graph {
    int edges\[\]\[\];
    public Graph(int\[\]\[\] edges) { this.edges = edges; }

    public Graph loseEdges(int i, int j) {
        int n = edges.length;
        int\[\]\[\] newedges = new int\[n\]\[\];
        for (int k = 0; k < n; ++k) {
edgelist:
{
            int z;
search:
{
            if (k == i) {
                for (z = 0; z < edges\[k\].length; ++z) {
                    if (edges\[k\]\[z\] == j) break search;
                }
            } else if (k == j) {
                for (z = 0; z < edges\[k\].length; ++z) {
                    if (edges\[k\]\[z\] == i) break search;
                }
            }

            // No edge to be deleted; share this list.
            newedges\[k\] = edges\[k\];
            break edgelist;
} //search

            // Copy the list, omitting the edge at position z.
            int m = edges\[k\].length - 1;
            int ne\[\] = new int\[m\];
            System.arraycopy(edges\[k\], 0, ne, 0, z);
            System.arraycopy(edges\[k\], z+1, ne, z, m-z);
            newedges\[k\] = ne;
} //edgelist
        }
        return new Graph(newedges);
    }
}

Note the use of two statement labels, `edgelist` and `search`, and the use of `break` statements. This allows the code that copies a list, omitting one edge, to be shared between two separate tests, the test for an edge from node `i` to node `j`, and the test for an edge from node `j` to node `i`.

  

14.16. The `continue` Statement
-------------------------------

A `continue` statement may occur only in a `while`, `do`, or `for` statement; statements of these three kinds are called _iteration statements_. Control passes to the loop-continuation point of an iteration statement.

ContinueStatement:

`continue` \[[Identifier](jls-3.html#jls-Identifier "Identifier")\] `;`

A `continue` statement with no label attempts to transfer control to the innermost enclosing `while`, `do`, or `for` statement of the immediately enclosing method, constructor, or initializer; this statement, which is called the _continue target_, then immediately ends the current iteration and begins a new one.

To be precise, such a `continue` statement always completes abruptly, the reason being a `continue` with no label.

If no `while`, `do`, or `for` statement of the immediately enclosing method, constructor, or initializer contains the `continue` statement, a compile-time error occurs.

A `continue` statement with label _Identifier_ attempts to transfer control to the enclosing labeled statement ([¬ß14.7](jls-14.html#jls-14.7 "14.7. Labeled Statements")) that has the same _Identifier_ as its label; that statement, which is called the _continue target_, then immediately ends the current iteration and begins a new one.

To be precise, a `continue` statement with label _Identifier_ always completes abruptly, the reason being a `continue` with label _Identifier_.

The continue target must be a `while`, `do`, or `for` statement, or a compile-time error occurs.

A `continue` statement must refer to a label within the immediately enclosing method, constructor, initializer, or lambda body. There are no non-local jumps. If no labeled statement with _Identifier_ as its label in the immediately enclosing method, constructor, initializer, or lambda body contains the `continue` statement, a compile-time error occurs.

It can be seen, then, that a `continue` statement always completes abruptly.

See the descriptions of the `while` statement ([¬ß14.12](jls-14.html#jls-14.12 "14.12. The while Statement")), `do` statement ([¬ß14.13](jls-14.html#jls-14.13 "14.13. The do Statement")), and `for` statement ([¬ß14.14](jls-14.html#jls-14.14 "14.14. The for Statement")) for a discussion of the handling of abrupt termination because of `continue`.

The preceding descriptions say "attempts to transfer control" rather than just "transfers control" because if there are any `try` statements ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) within the continue target whose `try` blocks or `catch` clauses contain the `continue` statement, then any `finally` clauses of those `try` statements are executed, in order, innermost to outermost, before control is transferred to the continue target. Abrupt completion of a `finally` clause can disrupt the transfer of control initiated by a `continue` statement.

**Example 14.16-1. The `continue` Statement**

In the `Graph` class in [¬ß14.15](jls-14.html#jls-14.15 "14.15. The break Statement"), one of the `break` statements is used to finish execution of the entire body of the outermost `for` loop. This break can be replaced by a `continue` if the `for` loop itself is labeled:

class Graph {
    int edges\[\]\[\];
    public Graph(int\[\]\[\] edges) { this.edges = edges; }

    public Graph loseEdges(int i, int j) {
        int n = edges.length;
        int\[\]\[\] newedges = new int\[n\]\[\];
edgelists:
        for (int k = 0; k < n; ++k) {
            int z;
search:
{
            if (k == i) {
                for (z = 0; z < edges\[k\].length; ++z) {
                    if (edges\[k\]\[z\] == j) break search;
                }
            } else if (k == j) {
                for (z = 0; z < edges\[k\].length; ++z) {
                    if (edges\[k\]\[z\] == i) break search;
                }
            }

            // No edge to be deleted; share this list.
            newedges\[k\] = edges\[k\];
            continue edgelists;
} //search

            // Copy the list, omitting the edge at position z.
            int m = edges\[k\].length - 1;
            int ne\[\] = new int\[m\];
            System.arraycopy(edges\[k\], 0, ne, 0, z);
            System.arraycopy(edges\[k\], z+1, ne, z, m-z);
            newedges\[k\] = ne;
        } //edgelists
        return new Graph(newedges);
    }
}

Which to use, if either, is largely a matter of programming style.

  

14.17. The `return` Statement
-----------------------------

A `return` statement returns control to the invoker of a method ([¬ß8.4](jls-8.html#jls-8.4 "8.4. Method Declarations"), [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")) or constructor ([¬ß8.8](jls-8.html#jls-8.8 "8.8. Constructor Declarations"), [¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")).

ReturnStatement:

`return` \[[Expression](jls-15.html#jls-Expression "Expression")\] `;`

A `return` statement is _contained_ in the innermost constructor, method, initializer, or lambda expression whose body encloses the `return` statement.

It is a compile-time error if a `return` statement is contained in an instance initializer or a static initializer ([¬ß8.6](jls-8.html#jls-8.6 "8.6. Instance Initializers"), [¬ß8.7](jls-8.html#jls-8.7 "8.7. Static Initializers")).

A `return` statement with no _Expression_ must be contained in one of the following, or a compile-time error occurs:

*   A method that is declared, using the keyword `void`, not to return a value ([¬ß8.4.5](jls-8.html#jls-8.4.5 "8.4.5. Method Result"))7-300-B"> A constructor ([¬ß8.8.7](jls-8.html#jls-8.8.7 "8.8.7. Constructor Body"))

*   A lambda expression ([¬ß15.27](jls-15.html#jls-15.27 "15.27. Lambda Expressions"))
    

A `return` statement with no _Expression_ attempts to transfer control to the invoker of the method, constructor, or lambda body that contains it. To be precise, a `return` statement with no _Expression_ always completes abruptly, the reason being a return with no value.

A `return` statement with an _Expression_ must be contained in one of the following, or a compile-time error occurs:

*   A method that is declared to return a value
*   A lambda expression
    

The _Expression_ must denote a variable or a value, or a compile-time error occurs.

When a `return` statement with an _Expression_ appears in a method declaration, the _Expression_ must be assignable ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")) to the declared return type of the method, or a compile-time error occurs.

A `return` statement with an _Expression_ attempts to transfer control to the invoker of the method or lambda body that contains it; the value of the _Expression_ becomes the value of the method invocation. More precisely, execution of such a `return` statement first evaluates the _Expression_. If the evaluation of the _Expression_ completes abruptly for some reason, then the `return` statement completes abruptly for that reason. If evaluation of the _Expression_ completes normally, producing a value `V`, then the `return` statement completes abruptly, the reason being a return with value `V`.

If the expression is of type `float` and is not FP-strict ([¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions")), then the value may be an element of either the float value set or the float-extended-exponent value set ([¬ß4.2.3](jls-4.html#jls-4.2.3 "4.2.3. Floating-Point Types, Formats, and Values")). If the expression is of type `double` and is not FP-strict, then the value may be an element of either the double value set or the double-extended-exponent value set.

It can be seen, then, that a `return` statement always completes abruptly.

The preceding descriptions say "attempts to transfer control" rather than just "transfers control" because if there are any `try` statements ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) within the method or constructor whose `try` blocks or `catch` clauses contain the `return` statement, then any `finally` clauses of those `try` statements will be executed, in order, innermost to outermost, before control is transferred to the invoker of the method or constructor. Abrupt completion of a `finally` clause can disrupt the transfer of control initiated by a `return` statement.

14.18. The `throw` Statement
----------------------------

A `throw` statement causes an exception ([¬ß11 (_Exceptions_)](jls-11.html "Chapter 11. Exceptions")) to be thrown. The result is an immediate transfer of control ([¬ß11.3](jls-11.html#jls-11.3 "11.3. Run-Time Handling of an Exception")) that may exit multiple statements and multiple constructor, instance initializer, static initializer and field initializer evaluations, and method invocations until a `try` statement ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) is found that catches the thrown value. If no such `try` statement is found, then execution of the thread ([¬ß17 (_Threads and Locks_)](jls-17.html "Chapter 17. Threads and Locks")) that executed the `throw` is terminated ([¬ß11.3](jls-11.html#jls-11.3 "11.3. Run-Time Handling of an Exception")) after invocation of the `uncaughtException` method for the thread group to which the thread belongs.

ThrowStatement:

`throw` [Expression](jls-15.html#jls-Expression "Expression") `;`

The _Expression_ in a `throw` statement must either denote a variable or value of a reference type which is assignable ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")) to the type `Throwable`, or denote the null reference, or a compile-time error occurs.

The reference type of the _Expression_ will always be a class type (since no interface types are assignable to `Throwable`) which is not parameterized (since a subclass of `Throwable` cannot be generic ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters"))).

At least one of the following three conditions must be true, or a compile-time error occurs:

*   The type of the _Expression_ is an unchecked exception class ([¬ß11.1.1](jls-11.html#jls-11.1.1 "11.1.1. The Kinds of Exceptions")) or the null type ([¬ß4.1](jls-4.html#jls-4.1 "4.1. The Kinds of Types and Values")).
*   The `throw` statement is contained in the `try` block of a `try` statement ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) and it is not the case that the `try` statement can throw an exception of the type of the _Expression_. (In this case we say the thrown value is _caught_ by the `try` statement.)
*   The `throw` statement is contained in a method or constructor declaration and the type of the _Expression_ is assignable ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")) to at least one type listed in the `throws` clause ([¬ß8.4.6](jls-8.html#jls-8.4.6 "8.4.6. Method Throws"), [¬ß8.8.5](jls-8.html#jls-8.8.5 "8.8.5. Constructor Throws")) of the declaration.
    

The exception types that a `throw` statement can throw are specified in [¬ß11.2.2](jls-11.html#jls-11.2.2 "11.2.2. Exception Analysis of Statements").

A `throw` statement first evaluates the _Expression_. Then:

*   If evaluation of the _Expression_ completes abruptly for some reason, then the `throw` completes abruptly for that reason.
*   If evaluation of the _Expression_ completes normally, producing a non-`null` value `V`, then the `throw` statement completes abruptly, the reason being a `throw` with value `V`.
*   If evaluation of the _Expression_ completes normally, producing a `null` value, then an instance `V'` of class `NullPointerException` is created and thrown instead of `null`. The `throw` statement then completes abruptly, the reason being a `throw` with value `V'`.
    

It can be seen, then, that a `throw` statement always completes abruptly.

If there are any enclosing `try` statements ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) whose `try` blocks contain the `throw` statement, then any `finally` clauses of those `try` statements are executed as control is transferred outward, until the thrown value is caught. Note that abrupt completion of a `finally` clause can disrupt the transfer of control initiated by a `throw` statement.

If a `throw` statement is contained in a method declaration or a lambda expression, but its value is not caught by some `try` statement that contains it, then the invocation of the method completes abruptly because of the `throw`.

If a `throw` statement is contained in a constructor declaration, but its value is not caught by some `try` statement that contains it, then the class instance creation expression that invoked the constructor will complete abruptly because of the `throw` ([¬ß15.9.4](jls-15.html#jls-15.9.4 "15.9.4. Run-Time Evaluation of Class Instance Creation Expressions")).

If a `throw` statement is contained in a static initializer ([¬ß8.7](jls-8.html#jls-8.7 "8.7. Static Initializers")), then a compile-time check ([¬ß11.2.3](jls-11.html#jls-11.2.3 "11.2.3. Exception Checking")) ensures that either its value is always an unchecked exception or its value is always caught by some `try` statement that contains it. If at run time, despite this check, the value is not caught by some `try` statement that contains the `throw` statement, then the value is rethrown if it is an instance of class `Error` or one of its subclasses; otherwise, it is wrapped in an `ExceptionInInitializerError` object, which is then thrown ([¬ß12.4.2](jls-12.html#jls-12.4.2 "12.4.2. Detailed Initialization Procedure")).

If a `throw` statement is contained in an instance initializer ([¬ß8.6](jls-8.html#jls-8.6 "8.6. Instance Initializers")), then a compile-time check ([¬ß11.2.3](jls-11.html#jls-11.2.3 "11.2.3. Exception Checking")) ensures that either its value is always an unchecked exception or its value is always caught by some `try` statement that contains it, or the type of the thrown exception (or one of its superclasses) occurs in the `throws` clause of every constructor of the class.

By convention, user-declared throwable types should usually be declared to be subclasses of class `Exception`, which is a subclass of class `Throwable` ([¬ß11.1.1](jls-11.html#jls-11.1.1 "11.1.1. The Kinds of Exceptions")).

14.19. The `synchronized` Statement
-----------------------------------

A `synchronized` statement acquires a mutual-exclusion lock ([¬ß17.1](jls-17.html#jls-17.1 "17.1. Synchronization")) on behalf of the executing thread, executes a block, then releases the lock. While the executing thread owns the lock, no other thread may acquire the lock.

SynchronizedStatement:

`synchronized` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` [Block](jls-14.html#jls-Block "Block")

The type of _Expression_ must be a reference type, or a compile-time error occurs.

A `synchronized` statement is executed by first evaluating the _Expression_. Then:

*   If evaluation of the _Expression_ completes abruptly for some reason, then the `synchronized` statement completes abruptly for the same reason.
*   Otherwise, if the value of the _Expression_ is `null`, a `NullPointerException` is thrown.
*   Otherwise, let the non-`null` value of the _Expression_ be `V`. The executing thread locks the monitor associated with `V`. Then the _Block_ is executed, and then there is a choice:
    
    *   If execution of the _Block_ completes normally, then the monitor is unlocked and the `synchronized` statement completes normally.
        
    *   If execution of the _Block_ completes abruptly for any reason, then the monitor is unlocked and the `synchronized` statement completes abruptly for the same reason.
        
    

The locks acquired by `synchronized` statements are the same as the locks that are acquired implicitly by `synchronized` methods ([¬ß8.4.3.6](jls-8.html#jls-8.4.3.6 "8.4.3.6. synchronized Methods")). A single thread may acquire a lock more than once.

Acquiring the lock associated with an object does not in itself prevent other threads from accessing fields of the object or invoking un-`synchronized` methods on the object. Other threads can also use `synchronized` methods or the `synchronized` statement in a conventional manner to achieve mutual exclusion.

**Example 14.19-1. The `synchronized` Statement**

class Test {
    public static void main(String\[\] args) {
        Test t = new Test();
        synchronized(t) {
            synchronized(t) {
                System.out.println("made it!");
            }
        }
    }
}

This program produces the output:

made it!

Note that this program would deadlock if a single thread were not permitted to lock a monitor more than once.

  

14.20. The `try` statement
--------------------------

A `try` statement executes a block. If a value is thrown and the `try` statement has one or more `catch` clauses that can catch it, then control will be transferred to the first such `catch` clause. If the `try` statement has a `finally` clause, then another block of code is executed, no matter whether the `try` block completes normally or abruptly, and no matter whether a `catch` clause is first given control.

TryStatement:

`try` [Block](jls-14.html#jls-Block "Block") [Catches](jls-14.html#jls-Catches "Catches")  
`try` [Block](jls-14.html#jls-Block "Block") \[[Catches](jls-14.html#jls-Catches "Catches")\] [Finally](jls-14.html#jls-Finally "Finally")  
[TryWithResourcesStatement](jls-14.html#jls-TryWithResourcesStatement "TryWithResourcesStatement")

Catches:

[CatchClause](jls-14.html#jls-CatchClause "CatchClause") {[CatchClause](jls-14.html#jls-CatchClause "CatchClause")}

CatchClause:

`catch` `(` [CatchFormalParameter](jls-14.html#jls-CatchFormalParameter "CatchFormalParameter") `)` [Block](jls-14.html#jls-Block "Block")

CatchFormalParameter:

{[VariableModifier](jls-8.html#jls-VariableModifier "VariableModifier")} [CatchType](jls-14.html#jls-CatchType "CatchType") [VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId")

CatchType:

[UnannClassType](jls-8.html#jls-UnannClassType "UnannClassType") {`|` [ClassType](jls-4.html#jls-ClassType "ClassType")}

Finally:

`finally` [Block](jls-14.html#jls-Block "Block")

See [¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations") for _UnannClassType_. The following productions from [¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values"), [¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations"), and [¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters") are shown here for convenience:

VariableModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `final`

VariableDeclaratorId:

[Identifier](jls-3.html#jls-Identifier "Identifier") \[[Dims](jls-4.html#jls-Dims "Dims")\]

Dims:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]` {{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]`}

The _Block_ immediately after the keyword `try` is called the _`try` block_ of the `try` statement.

The _Block_ immediately after the keyword `finally` is called the _`finally` block_ of the `try` statement.

A `try` statement may have `catch` clauses, also called _exception handlers_.

A `catch` clause declares exactly one parameter, which is called an _exception parameter_.

It is a compile-time error if `final` appears more than once as a modifier for an exception parameter declaration.

The scope and shadowing of an exception parameter is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

An exception parameter may denote its type as either a single class type or a union of two or more class types (called _alternatives_). The alternatives of a union are syntactically separated by `|`.

A `catch` clause whose exception parameter is denoted as a single class type is called a _uni-`catch` clause_.

A `catch` clause whose exception parameter is denoted as a union of types is called a _multi-`catch` clause_.

Each class type used in the denotation of the type of an exception parameter must be the class `Throwable` or a subclass of `Throwable`, or a compile-time error occurs.

It is a compile-time error if a type variable is used in the denotation of the type of an exception parameter.

It is a compile-time error if a union of types contains two alternatives Di and Dj (_i_ ‚â† _j_) where Di is a subtype of Dj ([¬ß4.10.2](jls-4.html#jls-4.10.2 "4.10.2. Subtyping among Class and Interface Types")).

The declared type of an exception parameter that denotes its type with a single class type is that class type.

The declared type of an exception parameter that denotes its type as a union with alternatives D1 `|` D2 `|` ... `|` Dn is lub(D1, D2, ..., Dn).

An exception parameter of a multi-`catch` clause is implicitly declared `final` if it is not explicitly declared `final`.

It is a compile-time error if an exception parameter that is implicitly or explicitly declared `final` is assigned to within the body of the `catch` clause.

An exception parameter of a uni-`catch` clause is never implicitly declared `final`, but it may be explicitly declared `final` or be effectively final ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")).

An implicitly `final` exception parameter is final by virtue of its declaration, while an effectively final exception parameter is (as it were) final by virtue of how it is used. An exception parameter of a multi-`catch` clause is implicitly declared `final`, so will never occur as the left-hand operand of an assignment operator, but it is _not_ considered effectively final.

If an exception parameter is effectively final (in a uni-`catch` clause) or implicitly final (in a multi-`catch` clause), then adding an explicit `final` modifier to its declaration will not introduce any compile-time errors. On the other hand, if the exception parameter of a uni-`catch` clause is explicitly declared `final`, then removing the `final` modifier may introduce compile-time errors because the exception parameter, now considered to be effectively final, can no longer longer be referenced by anonymous and local class declarations in the body of the `catch` clause. If there are no compile-time errors, it is possible to further change the program so that the exception parameter is re-assigned in the body of the `catch` clause and thus will no longer be considered effectively final.

The exception types that a `try` statement can throw are specified in [¬ß11.2.2](jls-11.html#jls-11.2.2 "11.2.2. Exception Analysis of Statements").

The relationship of the exceptions thrown by the `try` block of a `try` statement and caught by the `catch` clauses (if any) of the `try` statement is specified in [¬ß11.2.3](jls-11.html#jls-11.2.3 "11.2.3. Exception Checking").

Exception handlers are considered in left-to-right order: the earliest possible `catch` clause accepts the exception, receiving as its argument the thrown exception object, as specified in [¬ß11.3](jls-11.html#jls-11.3 "11.3. Run-Time Handling of an Exception").

A multi-`catch` clause can be thought of as a sequence of uni-`catch` clauses. That is, a `catch` clause where the type of the exception parameter is denoted as a union D1`|`D2`|`...`|`Dn is equivalent to a sequence of _n_ `catch` clauses where the types of the exception parameters are class types D1, D2, ..., Dn respectively. In the _Block_ of each of the _n_ `catch` clauses, the declared type of the exception parameter is lub(D1, D2, ..., Dn). For example, the following code:

try {
    ... throws ReflectiveOperationException ...
}
catch (ClassNotFoundException | IllegalAccessException ex) {
    ... body ...
}

is semantically equivalent to the following code:

try {
    ... throws ReflectiveOperationException ...
}
catch (final ClassNotFoundException ex1) {
    final ReflectiveOperationException ex = ex1;
    ... body ...
}
catch (final IllegalAccessException ex2) {
    final ReflectiveOperationException ex = ex2;
    ... body ...
}

where the multi-`catch` clause with two alternatives has been translated into two uni-`catch` clauses, one for each alternative. A Java compiler is neither required nor recommended to compile a multi-`catch` clause by duplicating code in this manner, since it is possible to represent the multi-`catch` clause in a `class` file without duplication.

A `finally` clause ensures that the `finally` block is executed after the `try` block and any `catch` block that might be executed, no matter how control leaves the `try` block or `catch` block. Handling of the `finally` block is rather complex, so the two cases of a `try` statement with and without a `finally` block are described separately ([¬ß14.20.1](jls-14.html#jls-14.20.1 "14.20.1. Execution of try-catch"), [¬ß14.20.2](jls-14.html#jls-14.20.2 "14.20.2. Execution of try-finally and try-catch-finally")).

A `try` statement is permitted to omit `catch` clauses and a `finally` clause if it is a _`try`\-with-resources_ statement ([¬ß14.20.3](jls-14.html#jls-14.20.3 "14.20.3. try-with-resources")).

### 14.20.1. Execution of `try`\-`catch`

A `try` statement without a `finally` block is executed by first executing the `try` block. Then there is a choice:

*   If execution of the `try` block completes normally, then no further action is taken and the `try` statement completes normally.
*   If execution of the `try` block completes abruptly because of a `throw` of a value `V`, then there is a choice:
    
    *   If the run-time type of `V` is assignment compatible with ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")) a catchable exception class of any `catch` clause of the `try` statement, then the first (leftmost) such `catch` clause is selected. The value `V` is assigned to the parameter of the selected `catch` clause, and the _Block_ of that `catch` clause is executed, and then there is a choice:
        
        *   If that block completes normally, then the `try` statement completes normally.
            
        *   If that block completes abruptly for any reason, then the `try` statement completes abruptly for the same reason.
            
        
    *   If the run-time type of `V` is not assignment compatible with a catchable exception class of any `catch` clause of the `try` statement, then the `try` statement completes abruptly because of a `throw` of the value `V`.
        
*   If execution of the `try` block completes abruptly for any other reason, then the `try` statement completes abruptly for the same reason.
    

**Example 14.20.1-1. Catching An Exception**

class BlewIt extends Exception {
    BlewIt() { }
    BlewIt(String s) { super(s); }
}
class Test {
    static void blowUp() throws BlewIt { throw new BlewIt(); }

    public static void main(String\[\] args) {
        try {
            blowUp();
        } catch (RuntimeException r) {
            System.out.println("Caught RuntimeException");
        } catch (BlewIt b) {
            System.out.println("Caught BlewIt");
        }
    }
}

Here, the exception `BlewIt` is thrown by the method `blowUp`. The `try`\-`catch` statement in the body of `main` has two `catch` clauses. The run-time type of the exception is `BlewIt` which is not assignable to a variable of type `RuntimeException`, but is assignable to a variable of type `BlewIt`, so the output of the example is:

Caught BlewIt

  

### 14.20.2. Execution of `try`\-`finally` and `try`\-`catch`\-`finally`

A `try` statement with a `finally` block is executed by first executing the `try` block. Then there is a choice:

*   If execution of the `try` block completes normally, then the `finally` block is executed, and then there is a choice:
    
    *   If the `finally` block completes normally, then the `try` statement completes normally.
        
    *   If the `finally` block completes abruptly for reason `S`, then the `try` statement completes abruptly for reason `S`.
        
*   If execution of the `try` block completes abruptly because of a `throw` of a value `V`, then there is a choice:
    
    *   If the run-time type of `V` is assignment compatible with a catchable exception class of any `catch` clause of the `try` statement, then the first (leftmost) such `catch` clause is selected. The value `V` is assigned to the parameter of the selected `catch` clause, and the _Block_ of that `catch` clause is executed. Then there is a choice:
        
        *   If the `catch` block completes normally, then the `finally` block is executed. Then there is a choice:
            
            *   If the `finally` block completes normally, then the `try` statement completes normally.
                
            *   If the `finally` block completes abruptly for any reason, then the `try` statement completes abruptly for the same reason.
                
            
        *   If the `catch` block completes abruptly for reason `R`, then the `finally` block is executed. Then there is a choice:
            
            *   If the `finally` block completes normally, then the `try` statement completes abruptly for reason `R`.
                
            *   If the `finally` block completes abruptly for reason `S`, then the `try` statement completes abruptly for reason `S` (and reason `R` is discarded).
                
            
        
    *   If the run-time type of `V` is not assignment compatible with a catchable exception class of any `catch` clause of the `try` statement, then the `finally` block is executed. Then there is a choice:
        
        *   If the `finally` block completes normally, then the `try` statement completes abruptly because of a `throw` of the value `V`.
            
        *   If the `finally` block completes abruptly for reason `S`, then the `try` statement completes abruptly for reason `S` (and the `throw` of value `V` is discarded and forgotten).
            
        
*   If execution of theclass="literal">try block completes abruptly for any other reason `R`, then the `finally` block is executed, and then there is a choice:

*   If the `finally` block completes normally, then the `try` statement completes abruptly for reason `R`.
*   If the `finally` block completes abruptly for reason `S`, then the `try` statement completes abruptly for reason `S` (and reason `R` is discarded).
    

**Example 14.20.2-1. Handling An Uncaught Exception With `finally`**

class BlewIt extends Exception {
    BlewIt() { }
    BlewIt(String s) { super(s); }
}
class Test {
    static void blowUp() throws BlewIt {
        throw new NullPointerException();
    }
    public static void main(String\[\] args) {
        try {
            blowUp();
        } catch (BlewIt b) {
            System.out.println("Caught BlewIt");
        } finally {
            System.out.println("Uncaught Exception");
        }
    }
}

This program produces the output:

Uncaught Exception
Exception in thread "main" java.lang.NullPointerException
        at Test.blowUp(Test.java:7)
        at Test.main(Test.java:11)

The `NullPointerException` (which is a kind of `RuntimeException`) that is thrown by method `blowUp` is not caught by the `try` statement in `main`, because a `NullPointerException` is not assignable to a variable of type `BlewIt`. This causes the `finally` clause to execute, after which the thread executing `main`, which is the only thread of the test program, terminates because of an uncaught exception, which typically results in printing the exception name and a simple backtrace. However, a backtrace is not required by this specification.

The problem with mandating a backtrace is that an exception can be created at one point in the program and thrown at a later one. It is prohibitively expensive to store a stack trace in an exception unless it is actually thrown (in which case the trace may be generated while unwinding the stack). Hence we do not mandate a back trace in every exception.

  

### 14.20.3. `try`\-with-resources

A `try`\-with-resources statement is parameterized with variables (known as _resources_) that are initialized before execution of the `try` block and closed automatically, in the reverse order from which they were initialized, after execution of the `try` block. `catch` clauses and a `finally` clause are often unnecessary when resources are closed automatically.

TryWithResourcesStatement:

`try` [ResourceSpecification](jls-14.html#jls-ResourceSpecification "ResourceSpecification") [Block](jls-14.html#jls-Block "Block") \[[Catches](jls-14.html#jls-Catches "Catches")\] \[[Finally](jls-14.html#jls-Finally "Finally")\]

ResourceSpecification:

`(` [ResourceList](jls-14.html#jls-ResourceList "ResourceList") \[`;`\] `)`

ResourceList:

[Resource](jls-14.html#jls-Resource "Resource") {`;` [Resource](jls-14.html#jls-Resource "Resource")}

Resource:

{[VariableModifier](jls-8.html#jls-VariableModifier "VariableModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId") `=` [Expression](jls-15.html#jls-Expression "Expression")

See [¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations") for _UnannType_. The following productions from [¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values"), [¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations"), and [¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters") are shown here for convenience:

VariableModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `final`

VariableDeclaratorId:

[Identifier](jls-3.html#jls-Identifier "Identifier") \[[Dims](jls-4.html#jls-Dims "Dims")\]

Dims:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]` {{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]`}

A _resource specification_ declares one or more local variables with initializer expressions to act as _resources_ for the `try` statement.

It is a compile-time error for a resource specification to declare two variables with the same name.

It is a compile-time error if `final` appears more than once as a modifier for each variable declared in a resource specification.

A variable declared in a resource specification is implicitly declared `final` ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")) if it is not explicitly declared `final`.

The type of a variable declared in a resource specification must be a subtype of `AutoCloseable`, or a compile-time error occurs.

The scope and shadowing of a variable declared in a resource specification is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

Resources are initialized in left-to-right order. If a resource fails to initialize (that is, its initializer expression throws an exception), then all resources initialized so far by the `try`\-with-resources statement are closed. If all resources initialize successfully, the `try` block executes as normal and then all non-null resources of the `try`\-with-resources statement are closed.

Resources are closed in the reverse order from that in which they were initialized. A resource is closed only if it initialized to a non-null value. An exception from the closing of one resource does not prevent the closing of other resources. Such an exception is _suppressed_ if an exception was thrown previously by an initializer, the `try` block, or the closing of a resource.

A `try`\-with-resources statement whose resource specification declares multiple resources is treated as if it were multiple `try`\-with-resources statements, each of which has a resource specification that declares a single resource. When a `try`\-with-resources statement with _n_ resources (_n_ > 1) is translated, the result is a `try`\-with-resources statement with _n_\-1 resources. After _n_ such translations, there are _n_ nested `try`\-`catch`\-`finally` statements, and the overall translation is complete.

#### 14.20.3.1. Basic `try`\-with-resources

A `try`\-with-resources statement with no `catch` clauses or `finally` clause is called a _basic_ `try`\-with-resources statement.

The meaning of a basic `try`\-with-resources statement:

try (_{VariableModifier} R Identifier_ = _Expression_ ...)
    _Block_

is given by the following translation to a local variable declaration and a `try`\-`catch`\-`finally` statement:

{
    final _{VariableModifierNoFinal} R Identifier_ = _Expression_;
    Throwable #primaryExc = null;

    try _ResourceSpecification\_tail_
        _Block_
    catch (Throwable #t) {
        #primaryExc = #t;
        throw #t;
    } finally {
        if (_Identifier_ != null) {
            if (#primaryExc != null) {
                try {
                    _Identifier_.close();
                } catch (Throwable #suppressedExc) {
                    #primaryExc.addSuppressed(#suppressedExc);
                }
            } else {
                _Identifier_.close();
            }
        }
    }
}

_{VariableModifierNoFinal}_ is defined as _{VariableModifier}_ without `final`, if present.

`#t`, `#primaryExc`, and `#suppressedExc` are automatically generated identifiers that are distinct from any other identifiers (automatically generated or otherwise) that are in scope at the point where the `try`\-with-resources statement occurs.

If the resource specification declares one resource, then _ResourceSpecification\_tail_ is empty (and the `try`\-`catch`\-`finally` statement is not itself a `try`\-with-resources statement).

If the resource specification declares _n_ > 1 resources, then _ResourceSpecification\_tail_ consists of the 2nd, 3rd, ..., _n_'th resources declared in resource specification, in the same order (and the `try`\-`catch`\-`finally` statement is itself a `try`\-with-resources statement).

Reachability and definite assignment rules for the basic `try`\-with-resources statement are implicitly specified by the translation above.

In a basic `try`\-with-resources statement that manages a single resource:

*   If the initialization of the resource completes abruptly because of a `throw` of a value `V`, then the `try`\-with-resources statement completes abruptly because of a `throw` of the value `V`.
*   If the initialization of the resource completes normally, and the `try` block completes abruptly because of a `throw` of a value `V`, then:
    
    *   If the automatic closing of the resource completes normally, then the `try`\-with-resources statement completes abruptly because of a `throw` of the value `V`.
        
    *   If the automatic closing of the resource completes abruptly because of a `throw` of a value `V2`, then the `try`\-with-resources statement completes abruptly because of a `throw` of value `V` with `V2` added to the suppressed exception list of `V`.
        
*   If the initialization of the resource completes normally, and the `try` block completes normally, and the automatic closing of the resource completes abruptly because of a `throw` of a value `V`, then the `try`\-with-resources statement completes abruptly because of a `throw` of the value `V`.
    

In a basic `try`\-with-resources statement that manages multiple resources:

*   If the initialization of a resource completes abruptly because of a `throw` of a value `V`, then:
    
    *   If the automatic closings of all successfully initialized resources (possibly zero) complete normally, then the `try`\-with-resources statement completes abruptly because of a `throw` of the value `V`.
        
    *   If the automatic closings of all successfully initialized resources (possibly zero) complete abruptly because of `throw`s of values `V1`...`Vn`, then the `try`\-with-resources statement completes abruptly because of a `throw` of the value `V` with any remaining values `V1`...`Vn` added to the suppressed exception list of `V`.
        
*   If the initialization of all resources completes normally, and the `try` block completes abruptly because of a `throw` of a value `V`, then:
    
    *   If the automatic closings of all initialized resources complete normally, then the `try`\-with-resources statement completes abruptly because of a `throw` of the value `V`.
        
    *   If the automatic closings of one or more initialized resources complete abruptly because of `throw`s of values `V1`...`Vn`, then the `try`\-with-resources statement completes abruptly because of a `throw` of the value `V` with any remaining values `V1`...`Vn` added to the suppressed exception list of `V`.
        
*   If the initialization of every resource completes normally, and the `try` block completes normally, then:
    
    *   If one automatic closing of an initialized resource completes abruptly because of a `throw` of value `V`, and all other automatic closings of initialized resources complete normally, then the `try`\-with-resources statement completes abruptly because of a `throw` of the value `V`.
        
    *   If more than one automatic closing of an initialized resource completes abruptly because of `throw`s of values `V1`...`Vn`, then the `try`\-with-resources statement completes abruptly because of a `throw` of the value `V1` with any remaining values `V2`...`Vn` added to the suppressed exception list of `V1` (where `V1` is the exception from the rightmost resource failing to close and `Vn` is the exception from the leftmost resource failing to close).
        
    

#### 14.20.3.2. Extended `try`\-with-resources

A `try`\-with-resources statement with at least one `catch` clause and/or a `finally` clause is called an _extended_ `try`\-with-resources statement.

The meaning of an extended `try`\-with-resources statement:

try _ResourceSpecification_
    _Block_
_\[Catches\]_
_\[Finally\]_

is given by the following translation to a basic `try`\-with-resources statement nested inside a `try`\-`catch` or `try`\-`finally` or `try`\-`catch`\-`finally` statement:

try {
    try _ResourceSpecification_
        Block
}
_\[Catches\]_
_\[Finally\]_

The effect of the translation is to put the resource specification "inside" the `try` statement. This allows a `catch` clause of an extended `try`\-with-resources statement to catch an exception due to the automatic initialization or closing of any resource.

Furthermore, all resources will have been closed (or attempted to be closed) by the time the `finally` block is executed, in keeping with the intent of the `finally` keyword.

14.21. Unreachable Statements
-----------------------------

It is a compile-time error if a statement cannot be executed because it is _unreachable_.

This section is devoted to a precise explanation of the word "reachable." The idea is that there must be some possible execution path from the beginning of the constructor, method, instance initializer, or static initializer that contains the statement to the statement itself. The analysis takes into account the structure of statements. Except for the special treatment of `while`, `do`, and `for` statements whose condition expression has the constant value `true`, the values of expressions are not taken into account in the flow analysis.

For example, a Java compiler will accept the code:

{
    int n = 5;
    while (n > 7) k = 2;
}

even though the value of `n` is known at compile time and in principle it can be known at compile time that the assignment to `k` can never be executed.

The rules in this section define two technical terms:

*   whether a statement is _reachable_
*   whether a statement _can complete normally_
    

The definitions here allow a statement to complete normally only if it is reachable.

To shorten the description of the rules, the customary abbreviation "iff" is used to mean "if and only if."

A reachable `break` statement _exits a statement_ if, within the break target, either there are no `try` statements whose `try` blocks contain the `break` statement, or there are `try` statements whose `try` blocks contain the `break` statement and all `finally` clauses of those `try` statements can complete normally.

This definition is based on the logic around "attempts to transfer control" in [¬ß14.15](jls-14.html#jls-14.15 "14.15. The break Statement").

A `continue` statement _continues a `do` statement_ if, within the `do` statement, either there are no `try` statements whose `try` blocks contain the `continue` statement, or there are `try` statements whose `try` blocks contain the `continue` statement and all `finally` clauses of those `try` statements can complete normally.

The rules are as follows:

*   The block that is the body of a constructor, method, instance initializer, or static initializer is reachable.
*   An empty block that is not a switch block can complete normally iff it is reachable.
    
    A non-empty block that is not a switch block can complete normally iff the last statement in it can complete normally.
    
    The first statement in a non-empty block that is not a switch block is reachable iff the block is reachable.
    
    Every other statement `S` in a non-empty block that is not a switch block is reachable iff the statement preceding `S` can complete normally.
*   A local class declaration statement can complete normally iff it is reachable.
*   A local variable declaration statement can complete normally iff it is reachable.
*   An empty statement can complete normally iff it is reachable.
*   A labeled statement can complete normally if at least one of the following is true:
    
    *   The contained statement can complete normally.
        
    *   There is a reachable `break` statement that exits the labeled statement.
        
    
    The contained statement is reachable iff the labeled statement is reachable.
*   An expression statement can complete normally iff it is reachable.
*   An `if`\-`then` statement can complete normally iff it is reachable.
    
    The `then`\-statement is reachable iff the `if`\-`then` statement is reachable.
    
    An `if`\-`then`\-`else` statement can complete normally iff the `then`\-statement can complete normally or the `else`\-statement can complete normally.
    
    The `then`\-statement is reachable iff the `if`\-`then`\-`else` statement is reachable.
    
    The `else`\-statement is reachable iff the `if`\-`then`\-`else` statement is reachable.
    
    This handling of an `if` statement, whether or not it has an `else` part, is rather unusual. The rationale is given at the end of this section.
*   An `assert` statement can complete normally iff it is reachable.
*   A `switch` statement can complete normally iff at least one of the following is true:
    
    *   The switch block is empty or contains only switch labels.
        
    *   The last statement in the switch block can complete normally.
        
    *   There is at least one switch label after the last switch block statement group.
        
    *   The switch block does not contain a `default` label.
        
    *   There is a reachable `break` statement that exits the `switch` statement.
        
*   A switch block is reachable iff its `switch` statement is reachable.
*   A statement in a switch block is reachable iff its `switch` statement is reachable and at least one of the following is true:
    
    *   It bears a `case` or `default` label.
        
    *   There is a statement preceding it in the switch block and that preceding statement can complete normally.
        
*   A `while` statement can complete normally iff at least one of the following is true:
    
    *   The `while` statement is reachable and the condition expression is not a constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")) with value `true`.
        
    *   There is a reachable `break` statement that exits the `while` statement.
        
    
    The contained statement is reachable iff the `while` statement is reachable and the condition expression is not a constant expression whose value is `false`.
*   A `do` statement can complete normally iff at least one of the following is true:
    
    *   The contained statement can complete normally and the condition expression is not a constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")) with value `true`.
        
    *   The `do` statement contains a reachable `continue` statement with no label, and the `do` statement is the innermost `while`, `do`, or `for` statement that contains that `continue` statement, and the `continue` statement continues that `do` statement, and the condition expression is not a constant expression with value `true`.
        
    *   The `do` statement contains a reachable `continue` statement with a label `L`, and the `do` statement has label `L`, and the `continue` statement continues that `do` statement, and the condition expression is not a constant expression with value `true`.
        
    *   There is a reachable `break` statement that exits the `do` statement.
        
    
    The contained statement is reachable iff the `do` statement is reachable.
*   A basic `for` statement can complete normally iff at least one of the following is true:
    
    *   The `for` statement is reachable, there is a condition expression, and the condition expression is not a constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")) with value `true`.
        
    *   There is a reachable `break` statement that exits the `for` statement.
        
    
    The contained statement is reachable iff the `for` statement is reachable and the condition expression is not a constant expression whose value is `false`.
*   An enhanced `for` statement can complete normally iff it is reachable.
*   A `break`, `continue`, `return`, or `throw` statement cannot complete normally.
*   A `synchronized` statement can complete normally iff the contained statement can complete normally.
    
    The contained statement is reachable iff the `synchronized` statement is reachable.
*   A `try` statement can complete normally iff both of the following are true:
    
    *   The `try` block can complete normally or any `catch` block can complete normally.
        
    *   If the `try` statement has a `finally` block, then the `finally` block can complete normally.
        
*   The `try` block is reachable iff the `try` statement is reachable.
*   A `catch` block `C` is reachable iff both of the following are true:
    
    *   Either the type of `C`'s parameter is an unchecked exception type or `Exception` or a superclass of `Exception`, or some expression or `throw` statement in the `try` block is reachable and can throw a checked exception whose type is assignable to the type of `C`'s parameter. (An expression is reachable iff the innermost statement containing it is reachable.)
        
        See [¬ß15.6](jls-15.html#jls-15.6 "15.6. Normal and Abrupt Completion of Evaluation") for normal and abrupt completion of expressions.
        
    *   There is no earlier `catch` block `A` in the `try` statement such that the type of `C`'s parameter is the same as or a subclass of the type of `A`'s parameter.
        
*   The _Block_ of a `catch` block is reachable iff the `catch` block is reachable.
*   If a `finally` block is present, it is reachable iff the `try` statement is reachable.
    

One _might expect_ the `if` statement to be handled in the following manner:

*   An `if`\-`then` statement can complete normally iff at least one of the following is true:
    
    *   The `if`\-`then` statement is reachable and the condition expression is not a constant expression whose value is `true`.
        
    *   Thee class="literal">then-statement can complete normally.

The `then`\-statement is reachable iff the `if`\-`then` statement is reachable and the condition expression is not a constant expression whose value is `false`.

*   An `if`\-`then`\-`else` statement can complete normally iff the `then`\-statement can complete normally or the `else`\-statement can complete normally.
    
    The `then`\-statement is reachable iff the `if`\-`then`\-`else` statement is reachable and the condition expression is not a constant expression whose value is `false`.
    
    The `else`\-statement is reachable iff the `if`\-`then`\-`else` statement is reachable and the condition expression is not a constant expression whose value is `true`.
    

This approach would be consistent with the treatment of other control structures. However, in order to allow the if statement to be used conveniently for "conditional compilation" purposes, the actual rules differ.

As an example, the following statement results in a compile-time error:

while (false) { x=3; }

because the statement `x=3;` is not reachable; but the superficially similar case:

if (false) { x=3; }

does not result in a compile-time error. An optimizing compiler may realize that the statement `x=3;` will never be executed and may choose to omit the code for that statement from the generated `class` file, but the statement `x=3;` is not regarded as "unreachable" in the technical sense specified here.

The rationale for this differing treatment is to allow programmers to define "flag variables" such as:

static final boolean DEBUG = false;

and then write code such as:

if (DEBUG) { x=3; }

The idea is that it should be possible to change the value of `DEBUG` from `false` to `true` or from `true` to `false` and then compile the code correctly with no other changes to the program text.

This ability to "conditionally compile" has no relationship to binary compatibility ([¬ß13 (_Binary Compatibility_)](jls-13.html "Chapter 13. Binary Compatibility")). If a set of classes that use such a "flag" variable are compiled and conditional code is omitted, it does not suffice later to distribute just a new version of the class or interface that contains the definition of the flag. The classes that use the flag will not see its new value, so their behavior may be surprising, but no `LinkageError` will occur. A change to the value of a flag is, therefore, binary compatible with pre-existing binaries, but not behaviorally compatible.

üçÄ Chapter 15. Expressions
-----------------------

**Table of Contents**

[15.1. Evaluation, Denotation, and Result](jls-15.html#jls-15.1)
[15.2. Forms of Expressions](jls-15.html#jls-15.2)
[15.3. Type of an Expression](jls-15.html#jls-15.3)
[15.4. FP-strict Expressions](jls-15.html#jls-15.4)
[15.5. Expressions and Run-Time Checks](jls-15.html#jls-15.5)
[15.6. Normal and Abrupt Completion of Evaluation](jls-15.html#jls-15.6)
[15.7. Evaluation Order](jls-15.html#jls-15.7)
[15.7.1. Evaluate Left-Hand Operand First](jls-15.html#jls-15.7.1)
[15.7.2. Evaluate Operands before Operation](jls-15.html#jls-15.7.2)
[15.7.3. Evaluation Respects Parentheses and Precedence](jls-15.html#jls-15.7.3)
[15.7.4. Argument Lists are Evaluated Left-to-Right](jls-15.html#jls-15.7.4)
[15.7.5. Evaluation Order for Other Expressions](jls-15.html#jls-15.7.5)
[15.8. Primary Expressions](jls-15.html#jls-15.8)
[15.8.1. Lexical Literals](jls-15.html#jls-15.8.1)
[15.8.2. Class Literals](jls-15.html#jls-15.8.2)
[15.8.3. `this`](jls-15.html#jls-15.8.3)
[15.8.4. Qualified `this`](jls-15.html#jls-15.8.4)
[15.8.5. Parenthesized Expressions](jls-15.html#jls-15.8.5)
[15.9. Class Instance Creation Expressions](jls-15.html#jls-15.9)
[15.9.1. Determining the Class being Instantiated](jls-15.html#jls-15.9.1)
[15.9.2. Determining Enclosing Instances](jls-15.html#jls-15.9.2)
[15.9.3. Choosing the Constructor and its Arguments](jls-15.html#jls-15.9.3)
[15.9.4. Run-Time Evaluation of Class Instance Creation Expressions](jls-15.html#jls-15.9.4)
[15.9.5. Anonymous Class Declarations](jls-15.html#jls-15.9.5)
[15.9.5.1. Anonymous Constructors](jls-15.html#jls-15.9.5.1)
[15.10. Array Creation and Access Expressions](jls-15.html#jls-15.10)
[15.10.1. Array Creation Expressions](jls-15.html#jls-15.10.1)
[15.10.2. Run-Time Evaluation of Array Creation Expressions](jls-15.html#jls-15.10.2)
[15.10.3. Array Access Expressions](jls-15.html#jls-15.10.3)
[15.10.4. Run-Time Evaluation of Array Access Expressions](jls-15.html#jls-15.10.4)
[15.11. Field Access Expressions](jls-15.html#jls-15.11)
[15.11.1. Field Access Using a Primary](jls-15.html#jls-15.11.1)
[15.11.2. Accessing Superclass Members using `super`](jls-15.html#jls-15.11.2)
[15.12. Method Invocation Expressions](jls-15.html#jls-15.12)
[15.12.1. Compile-Time Step 1: Determine Class or Interface to Search](jls-15.html#jls-15.12.1)
[15.12.2. Compile-Time Step 2: Determine Method Signature](jls-15.html#jls-15.12.2)
[15.12.2.1. Identify Potentially Applicable Methods](jls-15.html#jls-15.12.2.1)
[15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation](jls-15.html#jls-15.12.2.2)
[15.12.2.3. Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation](jls-15.html#jls-15.12.2.3)
[15.12.2.4. Phase 3: Identify Methods Applicable by Variable Arity Invocation](jls-15.html#jls-15.12.2.4)
[15.12.2.5. Choosing the Most Specific Method](jls-15.html#jls-15.12.2.5)
[15.12.2.6. Method Invocation Type](jls-15.html#jls-15.12.2.6)
[15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?](jls-15.html#jls-15.12.3)
[15.12.4. Run-Time Evaluation of Method Invocation](jls-15.html#jls-15.12.4)
[15.12.4.1. Compute Target Reference (If Necessary)](jls-15.html#jls-15.12.4.1)
[15.12.4.2. Evaluate Arguments](jls-15.html#jls-15.12.4.2)
[15.12.4.3. Check Accessibility of Type and Method](jls-15.html#jls-15.12.4.3)
[15.12.4.4. Locate Method to Invoke](jls-15.html#jls-15.12.4.4)
[15.12.4.5. Create Frame, Synchronize, Transfer Control](jls-15.html#jls-15.12.4.5)
[15.13. Method Reference Expressions](jls-15.html#jls-15.13)
[15.13.1. Compile-Time Declaration of a Method Reference](jls-15.html#jls-15.13.1)
[15.13.2. Type of a Method Reference](jls-15.html#jls-15.13.2)
[15.13.3. Run-Time Evaluation of Method References](jls-15.html#jls-15.13.3)
[15.14. Postfix Expressions](jls-15.html#jls-15.14)
[15.14.1. Expression Names](jls-15.html#jls-15.14.1)
[15.14.2. Postfix Increment Operator `++`](jls-15.html#jls-15.14.2)
[15.14.3. Postfix Decrement Operator `--`](jls-15.html#jls-15.14.3)
[15.15. Unary Operators](jls-15.html#jls-15.15)
[15.15.1. Prefix Increment Operator `++`](jls-15.html#jls-15.15.1)
[15.15.2. Prefix Decrement Operator `--`](jls-15.html#jls-15.15.2)
[15.15.3. Unary Plus Operator `+`](jls-15.html#jls-15.15.3)
[15.15.4. Unary Minus Operator `-`](jls-15.html#jls-15.15.4)
[15.15.5. Bitwise Complement Operator `~`](jls-15.html#jls-15.15.5)
[15.15.6. Logical Complement Operator `!`](jls-15.html#jls-15.15.6)
[15.16. Cast Expressions](jls-15.html#jls-15.16)
[15.17. Multiplicative Operators](jls-15.html#jls-15.17)
[15.17.1. Multiplication Operator `*`](jls-15.html#jls-15.17.1)
[15.17.2. Division Operator `/`](jls-15.html#jls-15.17.2)
[15.17.3. Remainder Operator `%`](jls-15.html#jls-15.17.3)
[15.18. Additive Operators](jls-15.html#jls-15.18)
[15.18.1. String Concatenation Operator `+`](jls-15.html#jls-15.18.1)
[15.18.2. Additive Operators (`+` and `-`) for Numeric Types](jls-15.html#jls-15.18.2)
[15.19. Shift Operators](jls-15.html#jls-15.19)
[15.20. Relational Operators](jls-15.html#jls-15.20)
[15.20.1. Numerical Comparison Operators `<`, `<=`, `>`, and `>=`](jls-15.html#jls-15.20.1)
[15.20.2. Type Comparison Operator `instanceof`](jls-15.html#jls-15.20.2)
[15.21. Equality Operators](jls-15.html#jls-15.21)
[15.21.1. Numerical Equality Operators `==` and `!=`](jls-15.html#jls-15.21.1)
[15.21.2. Boolean Equality Operators `==` and `!=`](jls-15.html#jls-15.21.2)
[15.21.3. Reference Equality Operators `==` and `!=`](jls-15.html#jls-15.21.3)
[15.22. Bitwise and Logical Operators](jls-15.html#jls-15.22)
[15.22.1. Integer Bitwise Operators `&`, `^`, and `|`](jls-15.html#jls-15.22.1)
[15.22.2. Boolean Logical Operators `&`, `^`, and `|`](jls-15.html#jls-15.22.2)
[15.23. Conditional-And Operator `&&`](jls-15.html#jls-15.23)
[15.24. Conditional-Or Operator `||`](jls-15.html#jls-15.24)
[15.25. Conditional Operator `? :`](jls-15.html#jls-15.25)
[15.25.1. Boolean Conditional Expressions](jls-15.html#jls-15.25.1)
[15.25.2. Numeric Conditional Expressions](jls-15.html#jls-15.25.2)
[15.25.3. Reference Conditional Expressions](jls-15.html#jls-15.25.3)
[15.26. Assignment Operators](jls-15.html#jls-15.26)
[15.26.1. Simple Assignment Operator `=`](jls-15.html#jls-15.26.1)
[15.26.2. Compound Assignment Operators](jls-15.html#jls-15.26.2)
[15.27. Lambda Expressions](jls-15.html#jls-15.27)
[15.27.1. Lambda Parameters](jls-15.html#jls-15.27.1)
[15.27.2. Lambda Body](jls-15.html#jls-15.27.2)
[15.27.3. Type of a Lambda Expression](jls-15.html#jls-15.27.3)
[15.27.4. Run-Time Evaluation of Lambda Expressions](jls-15.html#jls-15.27.4)
[15.28. Constant Expressions](jls-15.html#jls-15.28)

Much of the work in a program is done by evaluating _expressions_, either for their side effects, such as assignments to variables, or for their values, which can be used as arguments or operands in larger expressions, or to affect the execution sequence in statements, or both.

This chapter specifies the meanings of expressions and the rules for their evaluation.

15.1. Evaluation, Denotation, and Result
----------------------------------------

When an expression in a program is _evaluated_ (_executed_), the result denotes one of three things:

*   A variable ([¬ß4.12](jls-4.html#jls-4.12 "4.12. Variables")) (in C, this would be called an _lvalue_)
*   A value ([¬ß4.2](jls-4.html#jls-4.2 "4.2. Primitive Types and Values"), [¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values"))
*   Nothing (the expression is said to be void)
    

If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the _value_ of the expression.

Value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")) is applied to the result of every expression that produces a value, including when the value of a variable of type `float` or `double` is used.

An expression denotes nothing if and only if it is a method invocation ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")) that invokes a method that does not return a value, that is, a method declared `void` ([¬ß8.4](jls-8.html#jls-8.4 "8.4. Method Declarations")). Such an expression can be used only as an expression statement ([¬ß14.8](jls-14.html#jls-14.8 "14.8. Expression Statements")) or as the single expression of a lambda body ([¬ß15.27.2](jls-15.html#jls-15.27.2 "15.27.2. Lambda Body")), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded.

Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, and method invocations.

An expression occurs in either:

*   The declaration of some (class or interface) type that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation.
*   An annotation on a package declaration or on a top level type declaration.
    

15.2. Forms of Expressions
--------------------------

Expressions can be broadly categorized into one of the following syntactic forms:

*   Expression names ([¬ß6.5.6](jls-6.html#jls-6.5.6 "6.5.6. Meaning of Expression Names"))
*   Primary expressions ([¬ß15.8](jls-15.html#jls-15.8 "15.8. Primary Expressions") - [¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions"))
*   Unary operator expressions ([¬ß15.14](jls-15.html#jls-15.14 "15.14. Postfix Expressions") - [¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions"))
*   Binary operator expressions ([¬ß15.17](jls-15.html#jls-15.17 "15.17. Multiplicative Operators") - [¬ß15.24](jls-15.html#jls-15.24 "15.24. Conditional-Or Operator ||"), and [¬ß15.26](jls-15.html#jls-15.26 "15.26. Assignment Operators"))
*   Ternary operator expressions ([¬ß15.25](jls-15.html#jls-15.25 "15.25. Conditional Operator ? :"))
*   Lambda expressions ([¬ß15.27](jls-15.html#jls-15.27 "15.27. Lambda Expressions"))
    

Precedence among operators is managed by a hierarchy of grammar productions. The lowest precedence operator is the arrow of a lambda expression (`->`), followed by the assignment operators. Thus, all expressions are syntactically included in the _LambdaExpression_ and _AssignmentExpression_ nonterminals:

Expression:

[LambdaExpression](jls-15.html#jls-LambdaExpression "LambdaExpression")  
[AssignmentExpression](jls-15.html#jls-AssignmentExpression "AssignmentExpression")

When some expressions appear in certain contexts, they are considered _poly expressions_. The following forms of expressions may be poly expressions:

*   Parenthesized expressions ([¬ß15.8.5](jls-15.html#jls-15.8.5 "15.8.5. Parenthesized Expressions"))
*   Class instance creation expressions ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions"))
*   Method invocation expressions ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions"))
*   Method reference expressions ([¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions"))
*   Conditional expressions ([¬ß15.25](jls-15.html#jls-15.25 "15.25. Conditional Operator ? :"))
*   Lambda expressions ([¬ß15.27](jls-15.html#jls-15.27 "15.27. Lambda Expressions"))
    

The rules determining whether an expression of one of these forms is a poly expression are given in the individual sections that specify these forms of expressions.

Expressions that are not poly expressions are _standalone expressions_. Standalone expressions are expressions of the forms above when determined not to be poly expressions, as well as all expressions of all other forms. Expressions of all other forms are said to have a _standalone form_.

Some expressions have a value that can be determined at compile time. These are _constant expressions_ ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")).

15.3. Type of an Expression
---------------------------

If an expression denotes a variable or a value, then the expression has a type known at compile time. The type of a standalone expression can be determined entirely from the contents of the expression; in contrast, the type of a poly expression may be influenced by the expression's target type ([¬ß5 (_Conversions and Contexts_)](jls-5.html "Chapter 5. Conversions and Contexts")). The rules for determining the type of an expression are explained separately below for each kind of expression.

The value of an expression is assignment compatible ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")) with the type of the expression, unless heap pollution occurs ([¬ß4.12.2](jls-4.html#jls-4.12.2 "4.12.2. Variables of Reference Type")).

Likewise, the value stored in a variable is always compatible with the type of the variable, unless heap pollution occurs.

In other words, the value of an expression whose type is T is always suitable for assignment to a variable of type T.

Note that an expression whose type is a class type F that is declared `final` is guaranteed to have a value that is either a null reference or an object whose class is F itself, because `final` types have no subclasses.

15.4. FP-strict Expressions
---------------------------

If the type of an expression is `float` or `double`, then there is a question as to what value set ([¬ß4.2.3](jls-4.html#jls-4.2.3 "4.2.3. Floating-Point Types, Formats, and Values")) the value of the expression is drawn from. This is governed by the rules of value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")); these rules in turn depend on whether or not the expression is _FP-strict_.

Every constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")) is FP-strict.

If an expression is not a constant expression, then consider all the class declarations, interface declarations, and method declarations that contain the expression. If _any_ such declaration bears the `strictfp` modifier ([¬ß8.1.1.3](jls-8.html#jls-8.1.1.3 "8.1.1.3. strictfp Classes"), [¬ß8.4.3.5](jls-8.html#jls-8.4.3.5 "8.4.3.5. strictfp Methods"), [¬ß9.1.1.2](jls-9.html#jls-9.1.1.2 "9.1.1.2. strictfp Interfaces")), then the expression is FP-strict.

If a class, interface, or method, X, is declared `strictfp`, then X and any class, interface, method, constructor, instance initializer, static initializer, or variable initializer within X is said to be _FP-strict_.

Note that an annotation's element value ([¬ß9.7](jls-9.html#jls-9.7 "9.7. Annotations")) is always FP-strict, because it is always a constant expression.

It follows that an expression is not FP-strict if and only if it is not a constant expression _and_ it does not appear within any declaration that has the `strictfp` modifier.

Within an FP-strict expression, all intermediate values must be elements of the float value set or the double value set, implying that the results of all FP-strict expressions must be those predicted by IEEE 754 arithmetic on operands represented using single and double formats.

Within an expression that is not FP-strict, some leeway is granted for an implementation to use an extended exponent range to represent intermediate results; the net effect, roughly speaking, is that a calculation might produce "the correct answer" in situations where exclusive use of the float value set or double value set might result in overflow or underflow.

15.5. Expressions and Run-Time Checks
-------------------------------------

If the type of an expression is a primitive type, then the value of the expression is of that same primitive type.

If the type of an expression is a reference type, then the class of the referenced object, or even whether the value is a reference to an object rather than `null`, is not necessarily known at compile time. There are a few places in the Java programming language where the actual class of a referenced object affects program execution in a manner that cannot be deduced from the type of the expression. They are as follows:

*   Method invocation ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")). The particular method used for an invocation `o.m(...)` is chosen based on the methods that are part of the class or interface that is the type of `o`. For instance methods, the class of the object referenced by the run-time value of `o` participates because a subclass may override a specific method already declared in a parent class so that this overriding method is invoked. (The overriding method may or may not choose to further invoke the original overridden `m` method.)
*   The `instanceof` operator ([¬ß15.20.2](jls-15.html#jls-15.20.2 "15.20.2. Type Comparison Operator instanceof")). An expression whose type is a reference type may be tested using `instanceof` to find out whether the class of the object referenced by the run-time value of the expression is assignment compatible ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")) with some other reference type.
*   Casting ([¬ß5.5](jls-5.html#jls-5.5 "5.5. Casting Contexts"), [¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")). The class of the object referenced by the run-time value of the operand expression might not be compatible with the type specified by the cast. For reference types, this may require a run-time check that throws an exception if the class of the referenced object, as determined at run time, is not assignment compatible ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")) with the target type.
*   Assignment to an array component of reference type ([¬ß10.5](jls-10.html#jls-10.5 "10.5. Array Store Exception"), [¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions"), [¬ß15.26.1](jls-15.html#jls-15.26.1 "15.26.1. Simple Assignment Operator =")). The type-checking rules allow the array type S`[]` to be treated as a subtype of T`[]` if S is a subtype of T, but this requires a run-time check for assignment to an array component, similar to the check performed for a cast.
*   Exception handling ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")). An exception is caught by a `catch` clause only if the class of the thrown exception object is an `instanceof` the type of the formal parameter of the `catch` clause.
    

Situations where the class of an object is not statically known may lead to run-time type errors.

In addition, there are situations where the statically known type may not be accurate at run time. Such situations can arise in a program that gives rise to compile-time unchecked warnings. Such warnings are given in response to operations that cannot be statically guaranteed to be safe, and cannot immediately be subjected to dynamic checking because they involve non-reifiable types ([¬ß4.7](jls-4.html#jls-4.7 "4.7. Reifiable Types")). As a result, dynamic checks later in the course of program execution may detect inconsistencies and result in run-time type errors.

A run-time type error can occur only in these situations:

*   In a cast, when the actual class of the object referenced by the value of the operand expression is not compatible with the target type specified by the cast operator ([¬ß5.5](jls-5.html#jls-5.5 "5.5. Casting Contexts"), [¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")); in this case a `ClassCastException` is thrown.
*   In an automatically generated cast introduced to ensure the validity of an operation on a non-reifiable type ([¬ß4.7](jls-4.html#jls-4.7 "4.7. Reifiable Types")).
*   In an assignment to an array component of reference type, when the actual class of the object referenced by the value to be assigned is not compatible with the actual run-time component type of the array ([¬ß10.5](jls-10.html#jls-10.5 "10.5. Array Store Exception"), [¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions"), [¬ß15.26.1](jls-15.html#jls-15.26.1 "15.26.1. Simple Assignment Operator =")); in this case an `ArrayStoreException` is thrown.
*   When an exception is not caught by any `catch` clause of a `try` statement ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")); in this case the thread of control that encountered the exception first attempts to invoke an uncaught exception handler ([¬ß11.3](jls-11.html#jls-11.3 "11.3. Run-Time Handling of an Exception")) and then terminates.
    

15.6. Normal and Abrupt Completion of Evaluation
------------------------------------------------

Every expression has a normal mode of evaluation in which certain computational steps are carried out. The following sections describe the normal mode of evaluation for each kind of expression.

If all the steps are carried out without an exception being thrown, the expression is said to _complete normally_.

If, however, evaluation of an expression throws an exception, then the expression is said to _complete abruptly_. An abrupt completion always has an associated reason, which is always a `throw` with a given value.

Run-time exceptions are thrown by the predefined operators as follows:

*   A class instance creation expression ([¬ß15.9.4](jls-15.html#jls-15.9.4 "15.9.4. Run-Time Evaluation of Class Instance Creation Expressions")), array creation expression ([¬ß15.10.2](jls-15.html#jls-15.10.2 "15.10.2. Run-Time Evaluation of Array Creation Expressions")), method reference expression ([¬ß15.13.3](jls-15.html#jls-15.13.3 "15.13.3. Run-Time Evaluation of Method References")), array initializer expression ([¬ß10.6](jls-10.html#jls-10.6 "10.6. Array Initializers")), string concatenation operator expression ([¬ß15.18.1](jls-15.html#jls-15.18.1 "15.18.1. String Concatenation Operator +")), or lambda expression ([¬ß15.27.4](jls-15.html#jls-15.27.4 "15.27.4. Run-Time Evaluation of Lambda Expressions")) throws an `OutOfMemoryError` if there is insufficient memory available.
*   An array creation expression ([¬ß15.10.2](jls-15.html#jls-15.10.2 "15.10.2. Run-Time Evaluation of Array Creation Expressions")) throws a `NegativeArraySizeException` if the value of any dimension expression is less than zero.
*   An array access expression ([¬ß15.10.4](jls-15.html#jls-15.10.4 "15.10.4. Run-Time Evaluation of Array Access Expressions")) throws a `NullPointerException` if the value of the array reference expression is `null`.
*   An array access expression ([¬ß15.10.4](jls-15.html#jls-15.10.4 "15.10.4. Run-Time Evaluation of Array Access Expressions")) throws an `ArrayIndexOutOfBoundsException` if the value of the array index expression is negative or greater than or equal to the `length` of the array.
*   A field access expression ([¬ß15.11](jls-15.html#jls-15.11 "15.11. Field Access Expressions")) throws a `NullPointerException` if the value of the object reference expression is `null`.
*   A method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")) that invokes an instance method throws a `NullPointerException` if the target reference is `null`.
*   A cast expression ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")) throws a `ClassCastException` if a cast is found to be impermissible at run time.
*   An integer division ([¬ß15.17.2](jls-15.html#jls-15.17.2 "15.17.2. Division Operator /")) or integer remainder ([¬ß15.17.3](jls-15.html#jls-15.17.3 "15.17.3. Remainder Operator %")) operator throws an `ArithmeticException` if the value of the right-hand operand expression is zero.
*   An assignment to an array component of reference type ([¬ß15.26.1](jls-15.html#jls-15.26.1 "15.26.1. Simple Assignment Operator =")), a method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")), or a prefix or postfix increment ([¬ß15.14.2](jls-15.html#jls-15.14.2 "15.14.2. Postfix Increment Operator ++"), [¬ß15.15.1](jls-15.html#jls-15.15.1 "15.15.1. Prefix Increment Operator ++")) or decrement operator ([¬ß15.14.3](jls-15.html#jls-15.14.3 "15.14.3. Postfix Decrement Operator --"), [¬ß15.15.2](jls-15.html#jls-15.15.2 "15.15.2. Prefix Decrement Operator --")) may all throw an `OutOfMemoryError` as a result of boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")).
*   An assignment to an array component of reference type ([¬ß15.26.1](jls-15.html#jls-15.26.1 "15.26.1. Simple Assignment Operator =")) throws an `ArrayStoreException` when the value to be assigned is not compatible with the component type of the array ([¬ß10.5](jls-10.html#jls-10.5 "10.5. Array Store Exception")).
    

A method invocation expression can also result in an exception being thrown if an exception occurs that causes execution of the method body to complete abruptly.

A class instance creation expression can also result in an exception being thrown if an exception occurs that causes execution of the constructor to complete abruptly.

Various linkage and virtual machine errors may also occur during the evaluation of an expression. By their nature, such errors are difficult to predict and difficult to handle.

If an exception occurs, then evaluation of one or more expressions may be terminated before all steps of their normal mode of evaluation are complete; such expressions are said to complete abruptly.

If evaluation of an expression requires evaluation of a subexpression, then abrupt completion of the subexpression always causes the immediate abrupt completion of the expression itself, with the same reason, and all succeeding steps in the normal mode of evaluation are not performed.

The terms "complete normally" and "complete abruptly" are also applied to the execution of statements ([¬ß14.1](jls-14.html#jls-14.1 "14.1. Normal and Abrupt Completion of Statements")). A statement may complete abruptly for a variety of reasons, not just because an exception is thrown.

15.7. Evaluation Order
----------------------

The Java programming language guarantees that the operands of operators appear to be evaluated in a specific _evaluation order_, namely, from left to right.

It is recommended that code not rely crucially on this specification. Code is usually clearer when each expression contains at most one side effect, as its outermost operation, and when code does not depend on exactly which exception arises as a consequence of the left-to-right evaluation of expressions.

### 15.7.1. Evaluate Left-Hand Operand First

The left-hand operand of a binary operator appears to be fully evaluated before any part of the right-hand operand is evaluated.

If the operator is a compound-assignment operator ([¬ß15.26.2](jls-15.html#jls-15.26.2 "15.26.2. Compound Assignment Operators")), then evaluation of the left-hand operand includes both remembering the variable that the left-hand operand denotes and fetching and saving that variable's value for use in the implied binary operation.

If evaluation of the left-hand operand of a binary operator completes abruptly, no part of the right-hand operand appears to have been evaluated.

**Example 15.7.1-1. Left-Hand Operand Is Evaluated First**

In the following program, the `*` operator has a left-hand operand that contains an assignment to a variable and a right-hand operand that contains a reference to the same variable. The value produced by the reference will reflect the fact that the assignment occurred first.

class Test1 {
    public static void main(String\[\] args) {
        int i = 2;
        int j = (i=3) \* i;
        System.out.println(j);
    }
}

This program produces the output:

9

It is not permitted for evaluation of the `*` operator to produce `6` instead of `9`.

  

**Example 15.7.1-2. Implicit Left-Hand Operand In Operator Of Compound Assigment**

In the following program, the two assignment statements both fetch and remember the value of the left-hand operand, which is `9`, before the right-hand operand of the addition operator is evaluated, at which point the variable is set to `3`.

class Test2 {
    public static void main(String\[\] args) {
        int a = 9;
        a += (a = 3);  // first example
        System.out.println(a);
        int b = 9;
        b = b + (b = 3);  // second example
        System.out.println(b);
    }
}

This program produces the output:

12
12

It is not permitted for either assignment (compound for `a`, simple for `b`) to produce the result `6`.

See also the example in [¬ß15.26.2](jls-15.html#jls-15.26.2 "15.26.2. Compound Assignment Operators").

  

**Example 15.7.1-3. Abrupt Completion of Evaluation of the Left-Hand Operand**

class Test3 {
    public static void main(String\[\] args) {
        int j = 1;
        try {
            int i = forgetIt() / (j = 2);
        } catch (Exception e) {
            System.out.println(e);
            System.out.println("Now j = " + j);
        }
    }
    static int forgetIt() throws Exception {
        throw new Exception("I'm outta here!");
    }
}

This program produces the output:

java.lang.Exception: I'm outta here!
Now j = 1

That is, the left-hand operand `forgetIt()` of the operator `/` throws an exception before the right-hand operand is evaluated and its embedded assignment of `2` to `j` occurs.

  

### 15.7.2. Evaluate Operands before Operation

The Java programming language guarantees that every operand of an operator (except the conditional operators `&&`, `||`, and `? :`) appears to be fully evaluated before any part of the operation itself is performed.

If the binary operator is an integer division `/` ([¬ß15.17.2](jls-15.html#jls-15.17.2 "15.17.2. Division Operator /")) or integer remainder `%` ([¬ß15.17.3](jls-15.html#jls-15.17.3 "15.17.3. Remainder Operator %")), then its execution may raise an `ArithmeticException`, but this exception is thrown only after both operands of the binary operator have been evaluated and only if these evaluations completed normally.

**Example 15.7.2-1. Evaluation of Operands Before Operation**

class Test {
    public static void main(String\[\] args) {
        int divisor = 0;
        try {
            int i = 1 / (divisor \* loseBig());
        } catch (Exception e) {
            System.out.println(e);
        }
    }
    static int loseBig() throws Exception {
        throw new Exception("Shuffle off to Buffalo!");
    }
}

This program produces the output:

java.lang.Exception: Shuffle off to Buffalo!

and not:

java.lang.ArithmeticException: / by zero

since no part of the division operation, including signaling of a divide-by-zero exception, may appear to occur before the invocation of `loseBig` completes, even though the implementation may be able to detect or infer that the division operation would certainly result in a divide-by-zero exception.

  

### 15.7.3. Evaluation Respects Parentheses and Precedence

The Java programming language respects the order of evaluation indicated explicitly by parentheses and implicitly by operator precedence.

An implementation of the Java programming language may not take advantage of algebraic identities such as the associative law to rewrite expressions into a more convenient computational order unless it can be proven that the replacement expression is equivalent in value and in its observable side effects, even in the presence of multiple threads of execution (using the thread execution model in [¬ß17 (_Threads and Locks_)](jls-17.html "Chapter 17. Threads and Locks")), for all possible computational values that might be involved.

In the case of floating-point calculations, this rule applies also for infinity and not-a-number (NaN) values.

For example, `!(x<y)` may not be rewritten as `x>=y`, because these expressions have different values if either `x` or `y` is NaN or both are NaN.

Specifically, floating-point calculations that appear to be mathematically associative are unlikely to be computationally associative. Such computations must not be naively reordered.

For example, it is not correct for a Java compiler to rewrite `4.0*x*0.5` as `2.0*x`; while roundoff happens not to be an issue here, there are large values of `x` for which the first expression produces infinity (because of overflow) but the second expression produces a finite result.

So, for example, the test program:

strictfp class Test {
    public static void main(String\[\] args) {
        double d = 8e+307;
        System.out.println(4.0 \* d \* 0.5);
        System.out.println(2.0 \* d);
    }
}

prints:

Infinity
1.6e+308

because the first expression overflows and the second does not.

In contrast, integer addition and multiplication _are_ provably associative in the Java programming language.

For example `a+b+c`, where `a`, `b`, and `c` are local variables (this simplifying assumption avoids issues involving multiple threads and `volatile` variables), will always produce the same answer whether evaluated as `(a+b)+c` or `a+(b+c)`; if the expression `b+c` occurs nearby in the code, a smart Java compiler may be able to use this common subexpression.

### 15.7.4. Argument Lists are Evaluated Left-to-Right

In a method or constructor invocation or class instance creation expression, argument expressions may appear within the parentheses, separated by commas. Each argument expression appears to be fully evaluated before any part of any argument expression to its right.

If evaluation of an argument expression completes abruptly, no part of any argument expression to its right appears to have been evaluated.

**Example 15.7.4-1. Evaluation Order At Method Invocation**

class Test1 {
    public static void main(String\[\] args) {
        String s = "going, ";
        print3(s, s, s = "gone");
    }
    static void print3(String a, String b, String c) {
        System.out.println(a + b + c);
    }
}

This program produces the output:

going, going, gone

because the assignment of the string "`gone`" to `s` occurs after the first two arguments to `print3` have been evaluated.

  

**Example 15.7.4-2. Abrupt Completion of Argument Expression**

class Test2 {
    static int id;
    public static void main(String\[\] args) {
        try {
            test(id = 1, oops(), id = 3);
        } catch (Exception e) {
            System.out.println(e + ", id=" + id);
        }
    }
    static int test(int a, int b, int c) {
        return a + b + c;
    }
    static int oops() throws Exception {
        throw new Exception("oops");
    }
}

This program produces the output:

java.lang.Exception: oops, id=1

because the assignment of `3` to `id` is not executed.

  

### 15.7.5. Evaluation Order for Other Expressions

The order of evaluation for some expressions is not completely covered by these general rules, because these expressions may raise exceptional conditions at times that must be specified. See the detailed explanations of evaluation order for the following kinds of expressions:

*   class instance creation expressions ([¬ß15.9.4](jls-15.html#jls-15.9.4 "15.9.4. Run-Time Evaluation of Class Instance Creation Expressions"))
*   array creation expressions ([¬ß15.10.2](jls-15.html#jls-15.10.2 "15.10.2. Run-Time Evaluation of Array Creation Expressions"))
*   array access expressions ([¬ß15.10.4](jls-15.html#jls-15.10.4 "15.10.4. Run-Time Evaluation of Array Access Expressions"))
*   method invocation expressions ([¬ß15.12.4](jls-15.html#jls-15.12.4 "15.12.4. Run-Time Evaluation of Method Invocation"))
*   method reference expressions ([¬ß15.13.3](jls-15.html#jls-15.13.3 "15.13.3. Run-Time Evaluation of Method References"))
*   assignments involving array components ([¬ß15.26](jls-15.html#jls-15.26 "15.26. Assignment Operators"))
*   lambda expressions ([¬ß15.27.4](jls-15.html#jls-15.27.4 "15.27.4. Run-Time Evaluation of Lambda Expressions"))
    

15.8. Primary Expressions
-------------------------

Primary expressions include most of the simplest kinds of expressions, from which all others are constructed: literals, object creations, field accesses, method invocations, method references, and array accesses. A parenthesized expression is also treated syntactically as a primary expression.

Primary:

[PrimaryNoNewArray](jls-15.html#jls-PrimaryNoNewArray "PrimaryNoNewArray")  
[ArrayCreationExpression](jls-15.html#jls-ArrayCreationExpression "ArrayCreationExpression")

PrimaryNoNewArray:

[Literal](jls-3.html#jls-Literal "Literal")  
[ClassLiteral](jls-15.html#jls-ClassLiteral "ClassLiteral")  
`this`  
[TypeName](jls-6.html#jls-TypeName "TypeName") `.` `this`  
`(` [Expression](jls-15.html#jls-Expression "Expression") `)`  
[ClassInstanceCreationExpression](jls-15.html#jls-ClassInstanceCreationExpression "ClassInstanceCreationExpression")  
[FieldAccess](jls-15.html#jls-FieldAccess "FieldAccess")  
[ArrayAccess](jls-15.html#jls-ArrayAccess "ArrayAccess")  
[MethodInvocation](jls-15.html#jls-MethodInvocation "MethodInvocation")  
[MethodReference](jls-15.html#jls-MethodReference "MethodReference")

This part of the grammar of the Java programming language is unusual, in two ways. First, one might expect simple names, such as names of local variables and method parameters, to be primary expressions. For technical reasons, names are grouped together with primary expressions a little later when postfix expressions are introduced ([¬ß15.14](jls-15.html#jls-15.14 "15.14. Postfix Expressions")).

The technical reasons have to do with allowing left-to-right parsing of Java programs with only one-token lookahead. Consider the expressions `(z[3])` and `(z[])`. The first is a parenthesized array access ([¬ß15.10.3](jls-15.html#jls-15.10.3 "15.10.3. Array Access Expressions")) and the second is the start of a cast ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")). At the point that the look-ahead symbol is `[`, a left-to-right parse will have reduced the `z` to the nonterminal _Name_. In the context of a cast we prefer not to have to reduce the name to a _Primary_, but if _Name_ were one of the alternatives for _Primary_, then we could not tell whether to do the reduction (that is, we could not determine whether the current situation would turn out to be a parenthesized array access or a cast) without looking ahead two tokens, to the token following the `[`. The grammar presented here avoids the problem by keeping _Name_ and _Primary_ separate and allowing either in certain other syntax rules (those for _ClassInstanceCreationExpression_, _MethodInvocation_, _ArrayAccess_, and _PostfixExpression_, but not for _FieldAccess_ because this uses an identifier directly). This strategy effectively defers the question of whether a _Name_ should be treated as a _Primary_ until more context can be examined.

The second unusual feature avoids a potential grammatical ambiguity in the expression "`new int[3][3]`" which in Java always means a single creation of a multidimensional array, but which, without appropriate grammatical finesse, might also be interpreted as meaning the same as "`(new int[3])[3]`".

This ambiguity is eliminated by splitting the expected definition of _Primary_ into _Primary_ and _PrimaryNoNewArray_. (This may be compared to the splitting of _Statement_ into _Statement_ and _StatementNoShortIf_ ([¬ß14.5](jls-14.html#jls-14.5 "14.5. Statements")) to avoid the "dangling else" problem.)

### 15.8.1. Lexical Literals

A literal ([¬ß3.10](jls-3.html#jls-3.10 "3.10. Literals")) denotes a fixed, unchanging value.

The following production from [¬ß3.10](jls-3.html#jls-3.10 "3.10. Literals") is shown here for convenience:

Literal:

[IntegerLiteral](jls-3.html#jls-IntegerLiteral "IntegerLiteral")  
[FloatingPointLiteral](jls-3.html#jls-FloatingPointLiteral "FloatingPointLiteral")  
[BooleanLiteral](jls-3.html#jls-BooleanLiteral "BooleanLiteral")  
[CharacterLiteral](jls-3.html#jls-CharacterLiteral "CharacterLiteral")  
[StringLiteral](jls-3.html#jls-StringLiteral "StringLiteral")  
[NullLiteral](jls-3.html#jls-NullLiteral "NullLiteral")

The type of a literal is determined as follows:

*   The type of an integer literal ([¬ß3.10.1](jls-3.html#jls-3.10.1 "3.10.1. Integer Literals")) that ends with `L` or `l` is `long` ([¬ß4.2.1](jls-4.html#jls-4.2.1 "4.2.1. Integral Types and Values")).
    
    The type of any other integer literal is `int` ([¬ß4.2.1](jls-4.html#jls-4.2.1 "4.2.1. Integral Types and Values")).
*   The type of a floating-point literal ([¬ß3.10.2](jls-3.html#jls-3.10.2 "3.10.2. Floating-Point Literals")) that ends with `F` or `f` is `float` and its value must be an element of the float value set ([¬ß4.2.3](jls-4.html#jls-4.2.3 "4.2.3. Floating-Point Types, Formats, and Values")).
    
    The type of any other floating-point literal is `double` and its value must be an element of the double value set ([¬ß4.2.3](jls-4.html#jls-4.2.3 "4.2.3. Floating-Point Types, Formats, and Values")).
*   The type of a boolean literal ([¬ß3.10.3](jls-3.html#jls-3.10.3 "3.10.3. Boolean Literals")) is `boolean` ([¬ß4.2.5](jls-4.html#jls-4.2.5 "4.2.5. The boolean Type and boolean Values")).
*   The type of a character literal ([¬ß3.10.4](jls-3.html#jls-3.10.4 "3.10.4. Character Literals")) is `char` ([¬ß4.2.1](jls-4.html#jls-4.2.1 "4.2.1. Integral Types and Values")).
*   The type of a string literal ([¬ß3.10.5](jls-3.html#jls-3.10.5 "3.10.5. String Literals")) is `String` ([¬ß4.3.3](jls-4.html#jls-4.3.3 "4.3.3. The Class String")).
*   The type of the null literal `null` ([¬ß3.10.7](jls-3.html#jls-3.10.7 "3.10.7. The Null Literal")) is the null type ([¬ß4.1](jls-4.html#jls-4.1 "4.1. The Kinds of Types and Values")); its value is the null reference.
    

Evaluation of a lexical literal always completes normally.

### 15.8.2. Class Literals

A _class literal_ is an expression consisting of the name of a class, interface, array, or primitive type, or the pseudo-type `void`, followed by a '`.`' and the token `class`.

ClassLiteral:

[TypeName](jls-6.html#jls-TypeName "TypeName") {`[` `]`} `.` `class`  
[NumericType](jls-4.html#jls-NumericType "NumericType") {`[` `]`} `.` `class`  
`boolean` {`[` `]`} `.` `class`  
`void` `.` `class`

The type of C`.``class`, where C is the name of a class, interface, or array type ([¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values")), is `Class``<`C`>`.

The type of p`.``class`, where p is the name of a primitive type ([¬ß4.2](jls-4.html#jls-4.2 "4.2. Primitive Types and Values")), is `Class``<`B`>`, where B is the type of an expression of type p after boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")).

The type of `void``.``class` ([¬ß8.4.5](jls-8.html#jls-8.4.5 "8.4.5. Method Result")) is `Class``<``Void``>`.

It is a compile-time error if the named type is a type variable ([¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables")) or a parameterized type ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")) or an array whose element type is a type variable or parameterized type.

It is a compile-time error if the named type does not denote a type that is accessible ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) and in scope ([¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration")) at the point where the class literal appears.

A class literal evaluates to the `Class` object for the named type (or for `void`) as defined by the defining class loader ([¬ß12.2](jls-12.html#jls-12.2 "12.2. Loading of Classes and Interfaces")) of the class of the current instance.

### 15.8.3. `this`

The keyword `this` may be used only in the following contexts:

*   in the body of an instance method or default method ([¬ß8.4.7](jls-8.html#jls-8.4.7 "8.4.7. Method Body"), [¬ß9.4.3](jls-9.html#jls-9.4.3 "9.4.3. Interface Method Body"))
*   in the body of a constructor of a class ([¬ß8.8.7](jls-8.html#jls-8.8.7 "8.8.7. Constructor Body"))
*   in an instance initializer of a class ([¬ß8.6](jls-8.html#jls-8.6 "8.6. Instance Initializers"))
*   in the initializer of an instance variable of a class ([¬ß8.3.2](jls-8.html#jls-8.3.2 "8.3.2. Field Initialization"))
*   to denote a receiver parameter ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"))
    

If it appears anywhere else, a compile-time error occurs.

The keyword `this` may be used in a lambda expression only if it is allowed in the context in which the lambda expression appears. Otherwise, a compile-time error occurs.

When used as a primary expression, the keyword `this` denotes a value that is a reference to the object for which the instance method or default method was invoked ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")), or to the object being constructed. The value denoted by `this` in a lambda body is the same as the value denoted by `this` in the surrounding context.

The keyword `this` is also used in explicit constructor invocation statements ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations")).

The type of `this` is the class or interface type T within which the keyword `this` occurs.

Default methods provide the unique ability to access `this` inside an interface. (All other interface methods are either `abstract` or `static`, so provide no access to `this`.) As a result, it is possible for `this` to have an interface type.

At run time, the class of the actual object referred to may be T, if T is a class type, or a class that is a subtype of T.

**Example 15.8.3-1. The `this` Expression**

class IntVector {
    int\[\] v;
    boolean equals(IntVector other) {
        if (this == other)
            return true;
        if (v.length != other.v.length)
            return false;
        for (int i = 0; i < v.length; i++) {
            if (v\[i\] != other.v\[i\]) return false;
        }
        return true;
    }
}

Here, the class `IntVector` implements a method `equals`, which compares two vectors. If the other vector is the same vector object as the one for which the `equals` method was invoked, then the check can skip the length and value comparisons. The `equals` method implements this check by comparing the reference to the other object to `this`.

  

### 15.8.4. Qualified `this`

Any lexically enclosing instance ([¬ß8.1.3](jls-8.html#jls-8.1.3 "8.1.3. Inner Classes and Enclosing Instances")) can be referred to by explicitly qualifying the keyword `this`.

Let T be the type denoted by _TypeName_. Let _n_ be an integer such that T is the _n_'th lexically enclosing type declaration of the class or interface in which the qualified `this` expression appears.

The value of an expression of the form _TypeName_`.``this` is the _n_'th lexically enclosing instance of `this`.

The type of the expression is T.

It is a compile-time error if the expression occurs in a class or interface which is not an inner class of class T or T itself.

### 15.8.5. Parenthesized Expressions

A parenthesized expression is a primary expression whose type is the type of the contained expression and whose value at run time is the value of the contained expression. If the contained expression denotes a variable then the parenthesized expression also denotes that variable.

The use of parentheses affects only the _order_ of evaluation, except for a corner case whereby `(-2147483648)` and `(-9223372036854775808L)` are legal but `-(2147483648)` and `-(9223372036854775808L)` are illegal.

This is because the decimal literals `2147483648` and `9223372036854775808L` are allowed only as an operand of the unary minus operator ([¬ß3.10.1](jls-3.html#jls-3.10.1 "3.10.1. Integer Literals")).

In particular, the presence or absence of parentheses around an expression does not (except for the case noted above) affect in any way:

*   the choice of value set ([¬ß4.2.3](jls-4.html#jls-4.2.3 "4.2.3. Floating-Point Types, Formats, and Values")) for the value of an expression of type `float` or `double`.
*   whether a variable is definitely assigned, definitely assigned when `true`, definitely assigned when `false`, definitely unassigned, definitely unassigned when `true`, or definitely unassigned when `false` ([¬ß16 (_Definite Assignment_)](jls-16.html "Chapter 16. Definite Assignment")).
    

If a parenthesized expression appears in a context of a particular kind with target type T ([¬ß5 (_Conversions and Contexts_)](jls-5.html "Chapter 5. Conversions and Contexts")), its contained expression similarly appears in a context of the same kind with target type T.

If the contained expression is a poly expression ([¬ß15.2](jls-15.html#jls-15.2 "15.2. Forms of Expressions")), the parenthesized expression is also a poly expression. Otherwise, it is a standalone expression.

15.9. Class Instance Creation Expressions
-----------------------------------------

A class instance creation expression is used to create new objects that are instances of classes.

ClassInstanceCreationExpression:

[UnqualifiedClassInstanceCreationExpression](jls-15.html#jls-UnqualifiedClassInstanceCreationExpression "UnqualifiedClassInstanceCreationExpression")  
[ExpressionName](jls-6.html#jls-ExpressionName "ExpressionName") `.` [UnqualifiedClassInstanceCreationExpression](jls-15.html#jls-UnqualifiedClassInstanceCreationExpression "UnqualifiedClassInstanceCreationExpression")  
[Primary](jls-15.html#jls-Primary "Primary") `.` [UnqualifiedClassInstanceCreationExpression](jls-15.html#jls-UnqualifiedClassInstanceCreationExpression "UnqualifiedClassInstanceCreationExpression")

UnqualifiedClassInstanceCreationExpression:

`new` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [ClassOrInterfaceTypeToInstantiate](jls-15.html#jls-ClassOrInterfaceTypeToInstantiate "ClassOrInterfaceTypeToInstantiate") `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)` \[[ClassBody](jls-8.html#jls-ClassBody "ClassBody")\]

ClassOrInterfaceTypeToInstantiate:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} [Identifier](jls-3.html#jls-Identifier "Identifier") {`.` {[Annotation](jls-9.html#jls-Annotation "Annotation")} [Identifier](jls-3.html#jls-Identifier "Identifier")} \[[TypeArgumentsOrDiamond](jls-15.html#jls-TypeArgumentsOrDiamond "TypeArgumentsOrDiamond")\]

TypeArgumentsOrDiamond:

[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")  
`<>`

The following production from [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions") is shown here for convenience:

ArgumentList:

[Expression](jls-15.html#jls-Expression "Expression") {`,` [Expression](jls-15.html#jls-Expression "Expression")}

A class instance creation expression specifies a class to be instantiated, possibly followed by type arguments ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")) or a _diamond_ (`<>`) if the class being instantiated is generic ([¬ß8.1.2](jls-8.html#jls-8.1.2 "8.1.2. Generic Classes and Type Parameters")), followed by (a possibly empty) list of actual value arguments to the constructor.

If the type argument list to the class is empty ‚Äî the diamond form `<>` ‚Äî the type arguments of the class are inferred. It is legal, though strongly discouraged as a matter of style, to have white space between the "`<`" and "`>`" of a diamond.

If the constructor is generic ([¬ß8.8.4](jls-8.html#jls-8.8.4 "8.8.4. Generic Constructors")), the type arguments to the constructor may similarly either be inferred or passed explicitly. If passed explicitly, the type arguments to the constructor immediately follow the keyword `new`.

It is a compile-time error if a class instance creation expression provides type arguments to a constructor but uses the diamond form for type arguments to the class.

This rule is introduced because inference of a generic class's type arguments may influence the constraints on a generic constructor's type arguments.

If _TypeArguments_ is present immediately after `new`, or immediately before `(`, then it is a compile-time error if any of the type arguments are wildcards ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")).

The exception types that a class instance creation expression can throw are specified in [¬ß11.2.1](jls-11.html#jls-11.2.1 "11.2.1. Exception Analysis of Expressions").

Class instance creation expressions have two forms:

*   _Unqualified class instance creation expressions_ begin with the keyword `new`.
    
    An unqualified class instance creation expression may be used to create an instance of a class, regardless of whether the class is a top level ([¬ß7.6](jls-7.html#jls-7.6 "7.6. Top Level Type Declarations")), member ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")), local ([¬ß14.3](jls-14.html#jls-14.3 "14.3. Local Class Declarations")), or anonymous class ([¬ß15.9.5](jls-15.html#jls-15.9.5 "15.9.5. Anonymous Class Declarations")).
*   _Qualified class instance creation expressions_ begin with a _Primary_ expression or an _ExpressionName_.
    
    A qualified class instance creation expression enables the creation of instances of inner member classes and their anonymous subclasses.
    

Both unqualified and qualified class instance creation expressions may optionally end with a class body. Such a class instance creation expression declares an _anonymous class_ ([¬ß15.9.5](jls-15.html#jls-15.9.5 "15.9.5. Anonymous Class Declarations")) and creates an instance of it.

A class instance creation expression is a poly expression ([¬ß15.2](jls-15.html#jls-15.2 "15.2. Forms of Expressions")) if it uses the diamond form for type arguments to the class, and it appears in an assignment context or an invocation context ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts"), [¬ß5.3](jls-5.html#jls-5.3 "5.3. Invocation Contexts")). Otherwise, it is a standalone expression.

We say that a class is _instantiated_ when an instance of the class is created by a class instance creation expression. Class instantiation involves determining the class to be instantiated ([¬ß15.9.1](jls-15.html#jls-15.9.1 "15.9.1. Determining the Class being Instantiated")), the enclosing instances (if any) of the newly created instance ([¬ß15.9.2](jls-15.html#jls-15.9.2 "15.9.2. Determining Enclosing Instances")), and the constructor to be invoked to create the new instance ([¬ß15.9.3](jls-15.html#jls-15.9.3 "15.9.3. Choosing the Constructor and its Arguments")).

### 15.9.1. Determining the Class being Instantiated

If the class instance creation expression ends in a class body, then the class being instantiated is an anonymous class. Then:

*   If the class instance creation expression is unqualified:
    
    The _ClassOrInterfaceTypeToInstantiate_ must denote a class that is accessible, non-`final`, and not an enum type; or denote an interface that is accessible. Otherwise a compile-time error occurs.
    
    If _ClassOrInterfaceTypeToInstantiate_ ends with `<>`, then a compile-time error occurs.
    
    If _ClassOrInterfaceTypeToInstantiate_ ends with _TypeArguments_, then _ClassOrInterfaceTypeToInstantiate_ must denote a well-formed parameterized type ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")), or a compile-time error occurs.
    
    Let T be the type denoted by _ClassOrInterfaceTypeToInstantiate_. If T denotes a class, then an anonymous direct subclass of T is declared. If T denotes an interface, then an anonymous direct subclass of `Object` that implements T is declared. In either case, the body of the subclass is the _ClassBody_ given in the class instance creation expression.
    
    The class being instantiated is the anonymous subclass.
*   If the class instance creation expression is qualified:The _ClassOrInterfaceTypeToInstantiate_ must unambiguously denote an inner class that is accessible, non-`final`, not an enum type, and a member of the compile-time type of the _Primary_ expression or the _ExpressionName_. Otherwise, a compile-time error occurs.

If _ClassOrInterfaceTypeToInstantiate_ ends with `<>`, then a compile-time error occurs.

If _ClassOrInterfaceTypeToInstantiate_ ends with _TypeArguments_, then _ClassOrInterfaceTypeToInstantiate_ must denote a well-formed parameterized type, or a compile-time error occurs.

Let T be the type denoted by _ClassOrInterfaceTypeToInstantiate_. An anonymous direct subclass of T is declared. The body of the subclass is the _ClassBody_ given in the class instance creation expression.

The class being instantiated is the anonymous subclass.

If a class instance creation expression does not declare an anonymous class, then:

*   If the class instance creation expression is unqualified:
    
    The _ClassOrInterfaceTypeToInstantiate_ must denote a class that is accessible, non-`abstract`, and not an enum type. Otherwise, a compile-time error occurs.
    
    If _ClassOrInterfaceTypeToInstantiate_ ends with `<>`, but the class denoted by _ClassOrInterfaceTypeToInstantiate_ is not generic, then a compile-time error occurs.
    
    If _ClassOrInterfaceTypeToInstantiate_ ends with _TypeArguments_, then _ClassOrInterfaceTypeToInstantiate_ must denote a well-formed parameterized class, or a compile-time error occurs.
    
    The class being instantiated is the class denoted by _ClassOrInterfaceTypeToInstantiate_.
*   If the class instance creation expression is qualified:
    
    The _ClassOrInterfaceTypeToInstantiate_ must unambiguously denote an inner class that is accessible, non-`abstract`, not an enum type, and a member of the compile-time type of the _Primary_ expression or the _ExpressionName_.
    
    If _ClassOrInterfaceTypeToInstantiate_ ends with `<>`, and the class denoted by _ClassOrInterfaceTypeToInstantiate_ is not generic, then a compile-time error occurs.
    
    If _ClassOrInterfaceTypeToInstantiate_ ends with _TypeArguments_, then _ClassOrInterfaceTypeToInstantiate_ must denote a well-formed parameterized class, or a compile-time error occurs.
    
    The class being instantiated is the class denoted by _ClassOrInterfaceTypeToInstantiate_.
    

### 15.9.2. Determining Enclosing Instances

Let C be the class being instantiated, and let `i` be the instance being created. If C is an inner class, then `i` may have an _immediately enclosing instance_ ([¬ß8.1.3](jls-8.html#jls-8.1.3 "8.1.3. Inner Classes and Enclosing Instances")), determined as follows:

*   If C is an anonymous class, then:
    
    *   If the class instance creation expression occurs in a static context, then `i` has no immediately enclosing instance.
        
    *   Otherwise, the immediately enclosing instance of `i` is `this`.
        
*   If C is a local class, then:
    
    *   If C occurs in a static context, then `i` has no immediately enclosing instance.
        
    *   Otherwise, if the class instance creation expression occurs in a static context, then a compile-time error occurs.
        
    *   Otherwise, let O be the immediately enclosing class of C. Let _n_ be an integer such that O is the _n_'th lexically enclosing type declaration of the class in which the class instance creation expression appears.
        
        The immediately enclosing instance of `i` is the _n_'th lexically enclosing instance of `this`.
        
*   If C is an inner member class, then:
    
    *   If the class instance creation expression is unqualified, then:
        
        *   If the class instance creation expression occurs in a static context, then a compile-time error occurs.
            
        *   Otherwise, if C is a member of a class enclosing the class in which the class instance creation expression appears, then let O be the immediately enclosing class of which C is a member. Let _n_ be an integer such that O is the _n_'th lexically enclosing type declaration of the class in which the class instance creation expression appears.
            
            The immediately enclosing instance of `i` is the _n_'th lexically enclosing instance of `this`.
            
        *   Otherwise, a compile-time error occurs.
            
        
    *   If the class instance creation expression is qualified, then the immediately enclosing instance of `i` is the object that is the value of the _Primary_ expression or the _ExpressionName_.
        
    

If C is an anonymous class, and its direct superclass S is an inner class, then `i` may have an _immediately enclosing instance with respect to S_, determined as follows:

*   If S is a local class, then:
    
    *   If S occurs in a static context, then `i` has no immediately enclosing instance with respect to S.
        
    *   Otherwise, if the class instance creation expression occurs in a static context, then a compile-time error occurs.
        
    *   Otherwise, let O be the immediately enclosing class of S. Let _n_ be an integer such that O is the _n_'th lexically enclosing type declaration of the class in which the class instance creation expression appears.
        
        The immediately enclosing instance of `i` with respect to S is the _n_'th lexically enclosing instance of `this`.
        
*   If S is an inner member class, then:
    
    *   If the class instance creation expression is unqualified, then:
        
        *   If the class instance creation expression occurs in a static context, then a compile-time error occurs.
            
        *   Otherwise, if S is a member of a class enclosing the class in which the class instance creation expression appears, then let O be the immediately enclosing class of which S is a member. Let _n_ be an integer such that O is the _n_'th lexically enclosing type declaration of the class in which the class instance creation expression appears.
            
            The immediately enclosing instance of `i` with respect to S is the _n_'th lexically enclosing instance of `this`.
            
        *   Otherwise, a compile-time error occurs.
            
        
    *   If the class instance creation expression is qualified, then the immediately enclosing instance of `i` with respect to S is the object that is the value of the _Primary_ expression or the _ExpressionName_.
        
    

### 15.9.3. Choosing the Constructor and its Arguments

Let C be the class being instantiated. To create an instance of C, `i`, a constructor of C is chosen at compile time by the following rules:

First, the actual arguments to the constructor invocation are determined:

*   If C is an anonymous class with direct superclass S, then:
    
    *   If S is not an inner class, or if S is a local class that occurs in a static context, then the arguments to the constructor are the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the expression.
        
    *   Otherwise, the first argument to the constructor is the immediately enclosing instance of `i` with respect to S ([¬ß15.9.2](jls-15.html#jls-15.9.2 "15.9.2. Determining Enclosing Instances")), and the subsequent arguments to the constructor are the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the class instance creation expression.
        
*   If C is a local class or a `private` inner member class, then the arguments to the constructor are the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the class instance creation expression.
*   If C is a non-`private` inner member class, then the first argument to the constructor is the immediately enclosing instance of `i` ([¬ß8.8.1](jls-8.html#jls-8.8.1 "8.8.1. Formal Parameters"), [¬ß15.9.2](jls-15.html#jls-15.9.2 "15.9.2. Determining Enclosing Instances")), and the subsequent arguments to its constructor are the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the class instance creation expression.
*   Otherwise, the arguments to the constructor are the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the expression.
    

Second, a constructor of C and corresponding return type and `throws` clause are determined:

*   If the class instance creation expression uses `<>` to elide class type arguments, a list of methods `m1`...`mn` is defined for the purpose of overload resolution and type argument inference.
    
    Let `c1`...`cn` be the constructors of class C. Let `#m` be an automatically generated name that is distinct from all constructor and method names in C. For all _j_ (1 ‚â§ _j_ ‚â§ _n_), `mj` is defined in terms of `cj` as follows:
    
    *   A substitution Œ∏`j` is first defined to instantiate the types in `cj`.
        
        Let F1...Fp be the type parameters of C, and let G1...Gq be the type parameters (if any) of `cj`. Let X1...Xp and Y1...Yq be type variables with distinct names that are not in scope in the body of C.
        
        Œ∏`j` is `[F1:=X1, ..., Fp:=Xp, G1:=Y1, ..., Gq:=Yq]`.
        
    *   The modifiers of `mj` are those of `cj`.
        
    *   The type parameters of `mj` are X1...Xp,Y1...Yq. The bound of each parameter, if any, is Œ∏`j` applied to the corresponding parameter bound in C or `cj`.
        
    *   The return type of `mj` is Œ∏`j` applied to C`<`F1,...,Fp`>`.
        
    *   The name of `mj` is `#m`.
        
    *   The (possibly empty) list of argument types of `mj` is Œ∏`j` applied to the argument types of `cj`.
        
    *   The (possibly empty) list of thrown types of `mj` is Œ∏`j` applied to the thrown types of `cj`.
        
    *   The body of `mj` is irrelevant.
        
    
    To choose a constructor, we temporarily consider `m1`...`mn` to be members of C. Then one of `m1`...`mn` is selected, as determined by the class instance creation's argument expressions, using the process specified in [¬ß15.12.2](jls-15.html#jls-15.12.2 "15.12.2. Compile-Time Step 2: Determine Method Signature").
    
    If there is no unique most specific method that is both applicable and accessible, then a compile-time error occurs.
    
    Otherwise, where `mj` is the selected method, `cj` is the chosen constructor. The return type and `throws` clause of `cj` are the same as the return type and `throws` clause determined for `mj` ([¬ß15.12.2.6](jls-15.html#jls-15.12.2.6 "15.12.2.6. Method Invocation Type")).
*   Otherwise, the class instance creation expression does not use `<>` to elide class type arguments.
    
    Let T be the type denoted by C followed by any class type arguments in the expression. The process specified in [¬ß15.12.2](jls-15.html#jls-15.12.2 "15.12.2. Compile-Time Step 2: Determine Method Signature"), modified to handle constructors, is used to select one of the constructors of T and determine its `throws` clause.
    
    If there is no unique most-specific constructor that is both applicable and accessible, then a compile-time error occurs (as in method invocations).
    
    Otherwise, the return type is T.
    

It is a compile-time error if an argument to a class instance creation expression is not compatible with its target type, as derived from the invocation type ([¬ß15.12.2.6](jls-15.html#jls-15.12.2.6 "15.12.2.6. Method Invocation Type")).

If the compile-time declaration is applicable by variable arity invocation ([¬ß15.12.2.4](jls-15.html#jls-15.12.2.4 "15.12.2.4. Phase 3: Identify Methods Applicable by Variable Arity Invocation")), then where the last formal parameter type of the invocation type of the constructor is Fn`[]`, it is a compile-time error if the type which is the erasure of Fn is not accessible at the point of invocation.

The type of the class instance creation expression is the return type of the chosen constructor, as defined above.

Note that the type of the class instance creation expression may be an anonymous class type, in which case the constructor being invoked is an anonymous constructor ([¬ß15.9.5.1](jls-15.html#jls-15.9.5.1 "15.9.5.1. Anonymous Constructors")).

### 15.9.4. Run-Time Evaluation of Class Instance Creation Expressions

At run time, evaluation of a class instance creation expression is as follows.

First, if the class instance creation expression is a qualified class instance creation expression, the qualifying primary expression is evaluated. If the qualifying expression evaluates to `null`, a `NullPointerException` is raised, and the class instance creation expression completes abruptly. If the qualifying expression completes abruptly, the class instance creation expression completes abruptly for the same reason.

Next, space is allocated for the new class instance. If there is insufficient space to allocate the object, evaluation of the class instance creation expression completes abruptly by throwing an `OutOfMemoryError`.

The new object contains new instances of all the fields declared in the specified class type and all its superclasses. As each new field instance is created, it is initialized to its default value ([¬ß4.12.5](jls-4.html#jls-4.12.5 "4.12.5. Initial Values of Variables")).

Next, the actual arguments to the constructor are evaluated, left-to-right. If any of the argument evaluations completes abruptly, any argument expressions to its right are not evaluated, and the class instance creation expression completes abruptly for the same reason.

Next, the selected constructor of the specified class type is invoked. This results in invoking at least one constructor for each superclass of the class type. This process can be directed by explicit constructor invocation statements ([¬ß8.8](jls-8.html#jls-8.8 "8.8. Constructor Declarations")) and is specified in detail in [¬ß12.5](jls-12.html#jls-12.5 "12.5. Creation of New Class Instances").

The value of a class instance creation expression is a reference to the newly created object of the specified class. Every time the expression is evaluated, a fresh object is created.

**Example 15.9.4-1. Evaluation Order and Out-Of-Memory Detection**

If evaluation of a class instance creation expression finds there is insufficient memory to perform the creation operation, then an `OutOfMemoryError` is thrown. This check occurs before any argument expressions are evaluated.

So, for example, the test program:

class List {
    int value;
    List next;
    static List head = new List(0);
    List(int n) { value = n; next = head; head = this; }
}
class Test {
    public static void main(String\[\] args) {
        int id = 0, oldid = 0;
        try {
            for (;;) {
                ++id;
                new List(oldid = id);
            }
        } catch (Error e) {
            List.head = null;
            System.out.println(e.getClass() + ", " + (oldid==id));
        }
    }
}

prints:

class java.lang.OutOfMemoryError, false

because the out-of-memory condition is detected before the argument expression `oldid = id` is evaluated.

Compare this to the treatment of array creation expressions, for which the out-of-memory condition is detected after evaluation of the dimension expressions ([¬ß15.10.2](jls-15.html#jls-15.10.2 "15.10.2. Run-Time Evaluation of Array Creation Expressions")).

  

### 15.9.5. Anonymous Class Declarations

An anonymous class declaration is automatically derived from a class instance creation expression by the Java compiler.

An anonymous class is never `abstract` ([¬ß8.1.1.1](jls-8.html#jls-8.1.1.1 "8.1.1.1. abstract Classes")).

An anonymous class is always implicitly `final` ([¬ß8.1.1.2](jls-8.html#jls-8.1.1.2 "8.1.1.2. final Classes")).

An anonymous class is always an inner class ([¬ß8.1.3](jls-8.html#jls-8.1.3 "8.1.3. Inner Classes and Enclosing Instances")); it is never `static` ([¬ß8.1.1](jls-8.html#jls-8.1.1 "8.1.1. Class Modifiers"), [¬ß8.5.1](jls-8.html#jls-8.5.1 "8.5.1. Static Member Type Declarations")).

#### 15.9.5.1. Anonymous Constructors

An anonymous class cannot have an explicitly declared constructor. Instead, an anonymous constructor is implicitly declared for an anonymous class. The form of the anonymous constructor for an anonymous class C with direct superclass S is as follows:

*   If S is not an inner class, or if S is a local class that occurs in a static context, then the anonymous constructor has one formal parameter for each actual argument to the class instance creation expression in which C is declared.
    
    The actual arguments to the class instance creation expression are used to determine a constructor `cs` of S, using the same rules as for method invocations ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")). The type of each formal parameter of the anonymous constructor must be identical to the corresponding formal parameter of `cs`.
    
    The constructor body consists of an explicit constructor invocation ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations")) of the form `super(...)`, where the actual arguments are the formal parameters of the constructor, in the order they were declared.
*   Otherwise, the first formal parameter of the constructor of C represents the value of the immediately enclosing instance of `i` with respect to S ([¬ß15.9.2](jls-15.html#jls-15.9.2 "15.9.2. Determining Enclosing Instances"), [¬ß15.9.3](jls-15.html#jls-15.9.3 "15.9.3. Choosing the Constructor and its Arguments")). The type of this parameter is the class type that immediately encloses the declaration of S.
    
    The constructor has an additional formal parameter for each actual argument to the class instance creation expression that declared the anonymous class. The _n_'th formal parameter `e` corresponds to the _n-1_'th actual argument.
    
    The actual arguments to the class instance creation expression are used to determine a constructor `cs` of S, using the same rules as for method invocations ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")). The type of each formal parameter of the anonymous constructor must be identical to the corresponding formal parameter of `cs`.
    
    The constructor body consists of an explicit constructor invocation ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations")) of the form `o.super(...)`, where `o` is the first formal parameter of the constructor, and the actual arguments are the subsequent formal parameters of the constructor, in the order they were declared.
    

In all cases, the `throws` clause of an anonymous constructor must list all the checked exceptions thrown by the explicit superclass constructor invocation statement contained within the anonymous constructor, and all checked exceptions thrown by any instance initializers or instance variable initializers of the anonymous class.

Note that it is possible for the signature of the anonymous constructor to refer to an inaccessible type (for example, if such a type occurred in the signature of the superclass constructor `cs`). This does not, in itself, cause any errors at either compile-time or run-time.

15.10. Array Creation and Access Expressions
--------------------------------------------

### 15.10.1. Array Creation Expressions

An array creation expression is used to create new arrays ([¬ß10 (_Arrays_)](jls-10.html "Chapter 10. Arrays")).

ArrayCreationExpression:

`new` [PrimitiveType](jls-4.html#jls-PrimitiveType "PrimitiveType") [DimExprs](jls-15.html#jls-DimExprs "DimExprs") \[[Dims](jls-4.html#jls-Dims "Dims")\]  
`new` [ClassOrInterfaceType](jls-4.html#jls-ClassOrInterfaceType "ClassOrInterfaceType") [DimExprs](jls-15.html#jls-DimExprs "DimExprs") \[[Dims](jls-4.html#jls-Dims "Dims")\]  
`new` [PrimitiveType](jls-4.html#jls-PrimitiveType "PrimitiveType") [Dims](jls-4.html#jls-Dims "Dims") [ArrayInitializer](jls-10.html#jls-ArrayInitializer "ArrayInitializer")  
`new` [ClassOrInterfaceType](jls-4.html#jls-ClassOrInterfaceType "ClassOrInterfaceType") [Dims](jls-4.html#jls-Dims "Dims") [ArrayInitializer](jls-10.html#jls-ArrayInitializer "ArrayInitializer")

DimExprs:

[DimExpr](jls-15.html#jls-DimExpr "DimExpr") {[DimExpr](jls-15.html#jls-DimExpr "DimExpr")}

DimExpr:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` [Expression](jls-15.html#jls-Expression "Expression") `]`

The following production from [¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values") is shown here for convenience:

Dims:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]` {{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]`}

An array creation expression creates an object that is a new array whose elements are of the type specified by the _PrimitiveType_ or _ClassOrInterfaceType_.

It is a compile-time error if the _ClassOrInterfaceType_ does not denote a reifiable type ([¬ß4.7](jls-4.html#jls-4.7 "4.7. Reifiable Types")). Otherwise, the _ClassOrInterfaceType_ may name any named reference type, even an `abstract` class type ([¬ß8.1.1.1](jls-8.html#jls-8.1.1.1 "8.1.1.1. abstract Classes")) or an interface type.

The rules above imply that the element type in an array creation expression cannot be a parameterized type, unless all type arguments to the parameterized type are unbounded wildcards.

The type of each dimension expression within a _DimExpr_ must be a type that is convertible ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) to an integral type, or a compile-time error occurs.

Each dimension expression undergoes unary numeric promotion ([¬ß5.6.1](jls-5.html#jls-5.6.1 "5.6.1. Unary Numeric Promotion")). The promoted type must be `int`, or a compile-time error occurs.

The type of the array creation expression is an array type that can denoted by a copy of the array creation expression from which the `new` keyword and every _DimExpr_ expression and array initializer have been deleted.

For example, the type of the creation expression:

new double\[3\]\[3\]\[\]

is:

double\[\]\[\]\[\]

### 15.10.2. Run-Time Evaluation of Array Creation Expressions

At run time, evaluation of an array creation expression behaves as follows:*   If there are no dimension expressions, then there must be an array initializer. A newly allocated array will be initialized with the values provided by the array initializer as described in [¬ß10.6](jls-10.html#jls-10.6 "10.6. Array Initializers"). The value of the array initializer becomes the value of the array creation expression.
*   Otherwise, there is no array initializer, and:
    
    *   First, the dimension expressions are evaluated, left-to-right. If any of the expression evaluations completes abruptly, the expressions to the right of it are not evaluated.
        
    *   Next, the values of the dimension expressions are checked. If the value of any _DimExpr_ expression is less than zero, then a `NegativeArraySizeException` is thrown.
        
    *   Next, space is allocated for the new array. If there is insufficient space to allocate the array, evaluation of the array creation expression completes abruptly by throwing an `OutOfMemoryError`.
        
    *   Then, if a single _DimExpr_ appears, a one-dimensional array is created of the specified length, and each component of the array is initialized to its default value ([¬ß4.12.5](jls-4.html#jls-4.12.5 "4.12.5. Initial Values of Variables")).
        
    *   Otherwise, if _n_ _DimExpr_ expressions appear, then array creation effectively executes a set of nested loops of depth _n_`-1` to create the implied arrays of arrays.
        
        A multidimensional array need not have arrays of the same length at each level.
        
    

**Example 15.10.2-1. Array Creation Evaluation**

In an array creation expression with one or more dimension expressions, each dimension expression is fully evaluated before any part of any dimension expression to its right. Thus:

class Test1 {
    public static void main(String\[\] args) {
        int i = 4;
        int ia\[\]\[\] = new int\[i\]\[i=3\];
        System.out.println(
            "\[" + ia.length + "," + ia\[0\].length + "\]");
    }
}

prints:

\[4,3\]

because the first dimension is calculated as `4` before the second dimension expression sets `i` to `3`.

If evaluation of a dimension expression completes abruptly, no part of any dimension expression to its right will appear to have been evaluated. Thus:

class Test2 {
    public static void main(String\[\] args) {
        int\[\]\[\] a = { { 00, 01 }, { 10, 11 } };
        int i = 99;
        try {
            a\[val()\]\[i = 1\]++;
        } catch (Exception e) {
            System.out.println(e + ", i=" + i);
        }
    }
    static int val() throws Exception {
        throw new Exception("unimplemented");
    }
}

prints:

java.lang.Exception: unimplemented, i=99

because the embedded assignment that sets `i` to `1` is never executed.

  

**Example 15.10.2-2. Multi-Dimensional Array Creation**

The declaration:

float\[\]\[\] matrix = new float\[3\]\[3\];

is equivalent in behavior to:

float\[\]\[\] matrix = new float\[3\]\[\];
for (int `d` = 0; `d` < matrix.length; `d`++)
    matrix\[`d`\] = new float\[3\];

and:

Age\[\]\[\]\[\]\[\]\[\] Aquarius = new Age\[6\]\[10\]\[8\]\[12\]\[\];

is equivalent to:

Age\[\]\[\]\[\]\[\]\[\] Aquarius = new Age\[6\]\[\]\[\]\[\]\[\];
for (int `d1` = 0; `d1` < Aquarius.length; `d1`++) {
    Aquarius\[`d1`\] = new Age\[10\]\[\]\[\]\[\];
    for (int `d2` = 0; `d2` < Aquarius\[`d1`\].length; `d2`++) {
        Aquarius\[`d1`\]\[`d2`\] = new Age\[8\]\[\]\[\];
        for (int `d3` = 0; `d3` < Aquarius\[`d1`\]\[`d2`\].length; `d3`++) {
            Aquarius\[`d1`\]\[`d2`\]\[`d3`\] = new Age\[12\]\[\];
        }
    }
}

with `d`, `d1`, `d2`, and `d3` replaced by names that are not already locally declared. Thus, a single `new` expression actually creates one array of length 6, 6 arrays of length 10, 6x10 = 60 arrays of length 8, and 6x10x8 = 480 arrays of length 12. This example leaves the fifth dimension, which would be arrays containing the actual array elements (references to `Age` objects), initialized only to null references. These arrays can be filled in later by other code, such as:

Age\[\] Hair = { new Age("quartz"), new Age("topaz") };
Aquarius\[1\]\[9\]\[6\]\[9\] = Hair;

A triangular matrix may be created by:

float triang\[\]\[\] = new float\[100\]\[\];
for (int i = 0; i < triang.length; i++)
    triang\[i\] = new float\[i+1\];

  

If evaluation of an array creation expression finds there is insufficient memory to perform the creation operation, then an `OutOfMemoryError` is thrown. If the array creation expression does not have an array initializer, then this check occurs only after evaluation of all dimension expressions has completed normally. If the array creation expression does have an array initializer, then an `OutOfMemoryError` can occur when an object of reference type is allocated during evaluation of a variable initializer expression, or when space is allocated for an array to hold the values of a (possibly nested) array initializer.

**Example 15.10.2-3. `OutOfMemoryError` and Dimension Expression Evaluation**

class Test3 {
    public static void main(String\[\] args) {
        int len = 0, oldlen = 0;
        Object\[\] a = new Object\[0\];
        try {
            for (;;) {
                ++len;
                Object\[\] temp = new Object\[oldlen = len\];
                temp\[0\] = a;
                a = temp;
            }
        } catch (Error e) {
            System.out.println(e + ", " + (oldlen==len));
        }
    }
}

This program produces the output:

java.lang.OutOfMemoryError, true

because the out-of-memory condition is detected after the dimension expression `oldlen = len` is evaluated.

Compare this to class instance creation expressions ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")), which detect the out-of-memory condition before evaluating argument expressions ([¬ß15.9.4](jls-15.html#jls-15.9.4 "15.9.4. Run-Time Evaluation of Class Instance Creation Expressions")).

  

### 15.10.3. Array Access Expressions

An array access expression refers to a variable that is a component of an array.

ArrayAccess:

[ExpressionName](jls-6.html#jls-ExpressionName "ExpressionName") `[` [Expression](jls-15.html#jls-Expression "Expression") `]`  
[PrimaryNoNewArray](jls-15.html#jls-PrimaryNoNewArray "PrimaryNoNewArray") `[` [Expression](jls-15.html#jls-Expression "Expression") `]`

An array access expression contains two subexpressions, the _array reference expression_ (before the left bracket) and the _index expression_ (within the brackets).

Note that the array reference expression may be a name or any primary expression that is not an array creation expression ([¬ß15.10](jls-15.html#jls-15.10 "15.10. Array Creation and Access Expressions")).

The type of the array reference expression must be an array type (call it T`[]`, an array whose components are of type T), or a compile-time error occurs.

The index expression undergoes unary numeric promotion ([¬ß5.6.1](jls-5.html#jls-5.6.1 "5.6.1. Unary Numeric Promotion")). The promoted type must be `int`, or a compile-time error occurs.

The type of the array access expression is the result of applying capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")) to T.

The result of an array access expression is a variable of type T, namely the variable within the array selected by the value of the index expression.

This resulting variable, which is a component of the array, is never considered `final`, even if the array reference expression denoted a `final` variable.

### 15.10.4. Run-Time Evaluation of Array Access Expressions

At run time, evaluation of an array access expression behaves as follows:

*   First, the array reference expression is evaluated. If this evaluation completes abruptly, then the array access completes abruptly for the same reason and the index expression is not evaluated.
*   Otherwise, the index expression is evaluated. If this evaluation completes abruptly, then the array access completes abruptly for the same reason.
*   Otherwise, if the value of the array reference expression is `null`, then a `NullPointerException` is thrown.
*   Otherwise, the value of the array reference expression indeed refers to an array. If the value of the index expression is less than zero, or greater than or equal to the array's `length`, then an `ArrayIndexOutOfBoundsException` is thrown.
*   Otherwise, the result of the array access is the variable of type T, within the array, selected by the value of the index expression.
    

**Example 15.10.4-1. Array Reference Is Evaluated First**

In an array access, the expression to the left of the brackets appears to be fully evaluated before any part of the expression within the brackets is evaluated. For example, in the (admittedly monstrous) expression `a[(a=b)[3]]`, the expression `a` is fully evaluated before the expression `(a=b)[3]`; this means that the original value of `a` is fetched and remembered while the expression `(a=b)[3]` is evaluated. This array referenced by the original value of `a` is then subscripted by a value that is element `3` of another array (possibly the same array) that was referenced by `b` and is now also referenced by `a`.

Thus, the program:

class Test1 {
    public static void main(String\[\] args) {
        int\[\] a = { 11, 12, 13, 14 };
        int\[\] b = { 0, 1, 2, 3 };
        System.out.println(a\[(a=b)\[3\]\]);
    }
}

prints:

14

because the monstrous expression's value is equivalent to `a[b[3]]` or `a[3]` or `14`.

  

**Example 15.10.4-2. Abrupt Completion of Array Reference Evaluation**

If evaluation of the expression to the left of the brackets completes abruptly, no part of the expression within the brackets will appear to have been evaluated. Thus, the program:

class Test2 {
    public static void main(String\[\] args) {
        int index = 1;
        try {
            skedaddle()\[index=2\]++;
        } catch (Exception e) {
            System.out.println(e + ", index=" + index);
        }
    }
    static int\[\] skedaddle() throws Exception {
        throw new Exception("Ciao");
    }
}

prints:

java.lang.Exception: Ciao, index=1

because the embedded assignment of `2` to `index` never occurs.

  

**Example 15.10.4-3. `null` Array Reference**

If the array reference expression produces `null` instead of a reference to an array, then a `NullPointerException` is thrown at run time, but only after all parts of the array access expression have been evaluated and only if these evaluations completed normally. Thus, the program:

class Test3 {
    public static void main(String\[\] args) {
        int index = 1;
        try {
            nada()\[index=2\]++;
        } catch (Exception e) {
            System.out.println(e + ", index=" + index);
        }
    }
    static int\[\] nada() { return null; }
}

prints:

java.lang.NullPointerException, index=2

because the embedded assignment of `2` to `index` occurs before the check for a `null` array reference expression. As a related example, the program:

class Test4 {
    public static void main(String\[\] args) {
        int\[\] a = null;
        try {
            int i = a\[vamoose()\];
            System.out.println(i);
        } catch (Exception e) {
            System.out.println(e);
        }
    }
    static int vamoose() throws Exception {
        throw new Exception("Twenty-three skidoo!");
    }
}

always prints:

java.lang.Exception: Twenty-three skidoo!

A `NullPointerException` never occurs, because the index expression must be completely evaluated before any further part of the array access occurs, and that includes the check as to whether the value of the array reference expression is `null`.

  

15.11. Field Access Expressions
-------------------------------

A field access expression may access a field of an object or array, a reference to which is the value of either an expression or the special keyword `super`.

FieldAccess:

[Primary](jls-15.html#jls-Primary "Primary") `.` [Identifier](jls-3.html#jls-Identifier "Identifier")  
`super` `.` [Identifier](jls-3.html#jls-Identifier "Identifier")  
[TypeName](jls-6.html#jls-TypeName "TypeName") `.` `super` `.` [Identifier](jls-3.html#jls-Identifier "Identifier")

The meaning of a field access expression is determined using the same rules as for qualified names ([¬ß6.5.6.2](jls-6.html#jls-6.5.6.2 "6.5.6.2. Qualified Expression Names")), but limited by the fact that an expression cannot denote a package, class type, or interface type.

It is also possible to refer to a field of the current instance or current class by using a simple name ([¬ß6.5.6.1](jls-6.html#jls-6.5.6.1 "6.5.6.1. Simple Expression Names")).

### 15.11.1. Field Access Using a Primary

The type of the _Primary_ must be a reference type T, or a compile-time error occurs.

The meaning of the field access expression is determined as follows:

*   If the identifier names several accessible ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) member fields in type T, then the field access is ambiguous and a compile-time error occurs.
*   If the identifier does not name an accessible member field in type T, then the field access is undefined and a compile-time error occurs.
*   Otherwise, the identifier names a single accessible member field in type T, and the type of the field access expression is the type of the member field after capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")).
    

At run time, the result of the field access expression is computed as follows: (assuming that the program is correct with respect to definite assignment analysis, i.e. every blank `final` variable is definitely assigned before access)

*   If the field is `static`:
    
    *   The _Primary_ expression is evaluated, and the result is discarded. If evaluation of the _Primary_ expression completes abruptly, the field access expression completes abruptly for the same reason.
        
    *   If the field is a non-blank `final` field, then the result is the value of the specified class variable in the class or interface that is the type of the _Primary_ expression.
        
    *   If the field is not `final`, or is a blank `final` and the field access occurs in a static initializer or class variable initializer, then the result is a variable, namely, the specified class variable in the class that is the type of the _Primary_ expression.
        
*   If the field is not `static`:
    
    *   The _Primary_ expression is evaluated. If evaluation of the _Primary_ expression completes abruptly, the field access expression completes abruptly for the same reason.
        
    *   If the value of the _Primary_ is `null`, then a `NullPointerException` is thrown.
        
    *   If the field is a non-blank `final`, then the result is the value of the named member field in type T found in the object referenced by the value of the _Primary_.
        
    *   If the field is not `final`, or is a blank `final` and the field access occurs in a constructor or instance variable initializer, then the result is a variable, namely the named member field in type T found in the object referenced by the value of the _Primary_.
        
    

Note that only the type of the _Primary_ expression, not the class of the actual object referred to at run time, is used in determining which field to use.

**Example 15.11.1-1. Static Binding for Field Access**

class S           { int x = 0; }
class T extends S { int x = 1; }
class Test1 {
    public static void main(String\[\] args) {
        T t = new T();
        System.out.println("t.x=" + t.x + when("t", t));
        S s = new S();
        System.out.println("s.x=" + s.x + when("s", s));
        s = t;
        System.out.println("s.x=" + s.x + when("s", s));
    }
    static String when(String name, Object t) {
        return " when " + name + " holds a "
                        + t.getClass() + " at run time.";
    }
}

This program produces the output:

t.x=1 when t holds a class T at run time.
s.x=0 when s holds a class S at run time.
s.x=0 when s holds a class T at run time.

The last line shows that, indeed, the field that is accessed does not depend on the run-time class of the referenced object; even if `s` holds a reference to an object of class `T`, the expression `s.x` refers to the `x` field of class `S`, because the type of the expression `s` is `S`. Objects of class `T` contain two fields named `x`, one for class `T` and one for its superclass `S`.

This lack of dynamic lookup for field accesses allows programs to be run efficiently with straightforward implementations. The power of late binding and overriding is available, but only when instance methods are used. Consider the same example using instance methods to access the fields:

class S           { int x = 0; int z() { return x; } }
class T extends S { int x = 1; int z() { return x; } }
class Test2 {
    public static void main(String\[\] args) {
        T t = new T();
        System.out.println("t.z()=" + t.z() + when("t", t));
        S s = new S();
        System.out.println("s.z()=" + s.z() + when("s", s));
        s = t;
        System.out.println("s.z()=" + s.z() + when("s", s));
    }
    static String when(String name, Object t) {
        return " when " + name + " holds a "
                        + t.getClass() + " at run time.";
    }
}

Now the output is:

t.z()=1 when t holds a class T at run time.
s.z()=0 when s holds a class S at run time.
s.z()=1 when s holds a class T at run time.

The last line shows that, indeed, the method that is accessed _does_ depend on the run-time class of the referenced object; when `s` holds a reference to an object of class `T`, the expression `s.z()` refers to the `z` method of class `T`, despite the fact that the type of the expression `s` is `S`. Method `z` of class `T` overrides method `z` of class `S`.

  

**Example 15.11.1-2. Receiver Variable Is Irrelevant For `static` Field Access**

The following program demonstrates that a null reference may be used to access a class (`static`) variable without causing an exception:

class Test3 {
    static String mountain = "Chocorua";
    static Test3 favorite(){
        System.out.print("Mount ");
        return null;
    }
    public static void main(String\[\] args) {
        System.out.println(favorite().mountain);
    }
}

It compiles, executes, and prints:

Mount Chocorua

Even though the result of `favorite()` is `null`, a `NullPointerException` is not thrown. That "`Mount` " is printed demonstrates that the _Primary_ expression is indeed fully evaluated at run time, despite the fact that only its type, not its value, is used to determine which field to access (because the field `mountain` is `static`).

  

### 15.11.2. Accessing Superclass Members using `super`

The form `super``.`_Identifier_ refers to the field named _Identifier_ of the current object, but with the current object viewed as an instance of the superclass of the current class.

The form T`.``super``.`_Identifier_ refers to the field named _Identifier_ of the lexically enclosing instance corresponding to T, but with that instance viewed as an instance of the superclass of T.

The forms using the keyword `super` are valid only in an instance method, instance initializer, or constructor of a class, or in the initializer of an instance variable of a class. If they appear anywhere else, a compile-time error occurs.

These are exactly the same situations in which the keyword `this` may be used in a class declaration ([¬ß15.8.3](jls-15.html#jls-15.8.3 "15.8.3. this")).

It is a compile-time error if the forms using the keyword `super` appear in the declaration of class `Object`, since `Object` has no superclass.

Suppose that a field access expression `super``.``f` appears within class C, and the immediate superclass of C is class S. If `f` in S is accessible from class C ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")), then `super``.``f` is treated as if it had been the expression `this``.``f` in the body of class S. Otherwise, a compile-time error occurs.

Thus, `super``.``f` can access the field `f` that is accessible in class S, even if that field is hidden by a declaration of a field `f` in class C.

Suppose that a field access expression T`.``super``.``f` appears within class C, and the immediate superclass of the class denoted by T is a class whose fully qualified name is S. If `f` in S is accessible from C, then T`.``super``.``f` is treated as if it had been the expression `this``.``f` in the body of class S. Otherwise, a compile-time error occurs.

Thus, T`.``super``.``f` can access the field `f` that is accessible in class S, even if that field is hidden by a declaration of a field `f` in class T.

It is a compile-time error if the current class is not an inner class of class T or T itself.

**Example 15.11.2-1. The `super` Expression**

interface I           { int x = 0; }
class T1 implements I { int x = 1; }
class T2 extends T1   { int x = 2; }
class T3 extends T2 {
    int x = 3;
    void test() {
        System.out.println("x=\\t\\t"          + x);
        System.out.println("super.x=\\t\\t"    + super.x);
        System.out.println("((T2)this).x=\\t" + ((T2)this).x);
        System.out.println("((T1)this).x=\\t" + ((T1)this).x);
        System.out.println("((I)this).x=\\t"  + ((I)this).x);
    }
}
class Test {
    public static void main(String\[\] args) {
        new T3().test();
    }
}

This program produces the output:

x=              3
super.x=        2
((T2)this).x=   2
((T1)this).x=   1
((I)this).x=    0

Within class `T3`, the expression `super.x` has the same effect as `((T2)this).x` when `x` has package access. Note that `super.x` is not specified in terms of a cast, due to difficulties around access to `protected` members of the superclass.

  

15.12. Method Invocation Expressions
------------------------------------

A method invocation expression is used to invoke a class or instance method.

MethodInvocation:

[MethodName](jls-6.html#jls-MethodName "MethodName") `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)`  
[TypeName](jls-6.html#jls-TypeName "TypeName") `.` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier") `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)`  
[ExpressionName](jls-6.html#jls-ExpressionName "ExpressionName") `.` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier") `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)`  
[Primary](jls-15.html#jls-Primary "Primary") `.` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier") `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)`  
`super` `.` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier") `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)`  
[TypeName](jls-6.html#jls-TypeName "TypeName") `.` `super` `.` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier") `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)`

ArgumentList:

[Expression](jls-15.html#jls-Expression "Expression") {`,` [Expression](jls-15.html#jls-Expression "Expression")}

Resolving a method name at compile time is more complicated than resolving a field name because of the possibility of method overloading. Invoking a method at run time is also more complicated than accessing a field because of the possibility of instance method overriding.

Determining the method that will be invoked by a method invocation expression involves several steps. The following three sections describe the compile-time processing of a method invocation. The determination of the type of the method invocation expression is specified in [¬ß15.12.3](jls-15.html#jls-15.12.3 "15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?").

The exception types that a method invocation expression can throw are specified in [¬ß11.2.1](jls-11.html#jls-11.2.1 "11.2.1. Exception Analysis of Expressions").

It is a compile-time error if the name to the left of the rightmost "`.`" that occurs before the `(` in a _MethodInvocation_ cannot be classified as a _TypeName_ or an _ExpressionName_ ([¬ß6.5.2](jls-6.html#jls-6.5.2 "6.5.2. Reclassification of Contextually Ambiguous Names")).

If _TypeArguments_ is present to the left of _Identifier_, then it is a compile-time error if any of the type arguments are wildcards ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")).

A method invocation expression is a poly expression if all of the following are true:

*   The invocation appears in an assignment context or an invocation context ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts"), [¬ß5.3](jls-5.html#jls-5.3 "5.3. Invocation Contexts")).
*   If the invocation is qualified (that is, any form of _MethodInvocation_ except for the first), then the invocation elides _TypeArguments_ to the left of the _Identifier_.
*   The method to be invoked, as determined by the following subsections, is generic ([¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods")) and has a return type that mentions at least one of the method's type parameters.
    

Otherwise, the method invocation expression is a standalone expression.

### 15.12.1. Compile-Time Step 1: Determine Class or Interface to Search

The first step in processing a method invocation at compile time is to figure out the name of the method to be invoked and which class or interface to search for definitions of methods of that name.

The name of the method is specified by the _MethodName_ or _Identifier_ which immediately precedes the left parenthesis of the _MethodInvocation_.

For the class or interface to search, there are six cases to consider, depending on the form that precedes the left parenthesis of the _MethodInvocation_:

*   If the form is _MethodName_, that is, just an _Identifier_, then:
    
    If the _Identifier_ appears in the scope of a visible method declaration with that name ([¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration"), [¬ß6.4.1](jls-6.html#jls-6.4.1 "6.4.1. Shadowing")), then:
    
    *   If there is an enclosing type declaration of which that method is a member, let T be the innermost such type declaration. The class or interface to search is T.
        
        This search policy is called the "comb rule". It effectively looks for methods in a nested class's superclass hierarchy before looking for methods in an enclosing class and its superclass hierarchy. See [¬ß6.5.7.1](jls-6.html#jls-6.5.7.1 "6.5.7.1. Simple Method Names") for an example.
        
    *   Otherwise, the visible method declaration may be in scope due to one or more single-static-import or static-import-on-demand declarations. There is no class or interface to search, as the method to be invoked is determined later ([¬ß15.12.2.1](jls-15.html#jls-15.12.2.1 "15.12.2.1. Identify Potentially Applicable Methods")).
        
*   If the form is _TypeName_ `.` _\[TypeArguments\]_ _Identifier_, then the type to search is the type denoted by _TypeName_.
*   If the form is _ExpressionName_ `.` _\[TypeArguments\]_ _Identifier_, then the class or interface to search is the declared type T of the variable denoted by _ExpressionName_ if T is a class or interface type, or the upper bound of T if T is a type variable.
*   If the form is _Primary_ `.` _\[TypeArguments\]_ _Identifier_, then let T be the type of the _Primary_ expression. The class or interface to search is T if T is a class or interface type, or the upper bound of T if T is a type variable.

It is a compile-time error if T is not a reference type.

*   If the form is `super` `.` _\[TypeArguments\]_ _Identifier_, then the class to search is the superclass of the class whose declaration contains the method invocation.
    
    Let T be the type declaration immediately enclosing the method invocation. It is a compile-time error if T is the class `Object` or T is an interface.
*   If the form is _TypeName_ `.` `super` `.` _\[TypeArguments\]_ _Identifier_, then:
    
    *   It is a compile-time error if _TypeName_ denotes neither a class nor an interface.
        
    *   If _TypeName_ denote a class, C, then the class to search is the superclass of C.
        
        It is a compile-time error if C is not a lexically enclosing type declaration of the current class, or if C is the class `Object`.
        
        Let T be the type declaration immediately enclosing the method invocation. It is a compile-time error if T is the class `Object`.
        
    *   Otherwise, _TypeName_ denotes the interface to be searched, I.
        
        Let T be the type declaration immediately enclosing the method invocation. It is a compile-time error if I is not a direct superinterface of T, or if there exists some other direct superclass or direct superinterface of T, J, such that J is a subtype of I.
        
    

The _TypeName_ `.` `super` syntax is overloaded: traditionally, the _TypeName_ refers to a lexically enclosing type declaration which is a class, and the target is the superclass of this class, as if the invocation were an unqualified `super` in the lexically enclosing type declaration.

class Superclass {
    void foo() { System.out.println("Hi"); }
}

class Subclass1 extends Superclass {
    void foo() { throw new UnsupportedOperationException(); }

    Runnable tweak = new Runnable() {
        void run() {
            Subclass1.super.foo();  // Gets the 'println' behavior
        }
    };
}

To support invocation of default methods in superinterfaces, the _TypeName_ may also refer to a direct superinterface of the current class or interface, and the target is that superinterface.

interface Superinterface {
    default void foo() { System.out.println("Hi"); }
}

class Subclass2 implements Superinterface {
    void foo() { throw new UnsupportedOperationException(); }

    void tweak() {
        Superinterface.super.foo();  // Gets the 'println' behavior
    }
}

No syntax supports a combination of these forms, that is, invoking a superinterface method of a lexically enclosing type declaration which is a class, as if the invocation were of the form _InterfaceName_ `.` `super` in the lexically enclosing type declaration.

class Subclass3 implements Superinterface {
    void foo() { throw new UnsupportedOperationException(); }

    Runnable tweak = new Runnable() {
        void run() {
            Subclass3.Superinterface.super.foo();  // Illegal
        }
    };
}

A workaround is to introduce a `private` method in the lexically enclosing type declaration, that performs the interface `super` call.

### 15.12.2. Compile-Time Step 2: Determine Method Signature

The second step searches the type determined in the previous step for member methods. This step uses the name of the method and the argument expressions to locate methods that are both _accessible_ and _applicable_, that is, declarations that can be correctly invoked on the given arguments.

There may be more than one such method, in which case the _most specific_ one is chosen. The descriptor (signature plus return type) of the most specific method is the one used at run time to perform the method dispatch.

A method is _applicable_ if it is applicable by one of strict invocation ([¬ß15.12.2.2](jls-15.html#jls-15.12.2.2 "15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation")), loose invocation ([¬ß15.12.2.3](jls-15.html#jls-15.12.2.3 "15.12.2.3. Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation")), or variable arity invocation ([¬ß15.12.2.4](jls-15.html#jls-15.12.2.4 "15.12.2.4. Phase 3: Identify Methods Applicable by Variable Arity Invocation")).

Certain argument expressions that contain implicitly typed lambda expressions ([¬ß15.27.1](jls-15.html#jls-15.27.1 "15.27.1. Lambda Parameters")) or inexact method references ([¬ß15.13.1](jls-15.html#jls-15.13.1 "15.13.1. Compile-Time Declaration of a Method Reference")) are ignored by the applicability tests, because their meaning cannot be determined until a target type is selected.

Although the method invocation may be a poly expression, only its argument expressions - _not_ the invocation's target type - influence the selection of applicable methods.

The process of determining applicability begins by determining the potentially applicable methods ([¬ß15.12.2.1](jls-15.html#jls-15.12.2.1 "15.12.2.1. Identify Potentially Applicable Methods")).

The remainder of the process is split into three phases, to ensure compatibility with versions of the Java programming language prior to Java SE 5.0. The phases are:

1.  The first phase ([¬ß15.12.2.2](jls-15.html#jls-15.12.2.2 "15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation")) performs overload resolution without permitting boxing or unboxing conversion, or the use of variable arity method invocation. If no applicable method is found during this phase then processing continues to the second phase.
    
    This guarantees that any calls that were valid in the Java programming language before Java SE 5.0 are not considered ambiguous as the result of the introduction of variable arity methods, implicit boxing and/or unboxing. However, the declaration of a variable arity method ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters")) can change the method chosen for a given method method invocation expression, because a variable arity method is treated as a fixed arity method in the first phase. For example, declaring `m(Object...)` in a class which already declares `m(Object)` causes `m(Object)` to no longer be chosen for some invocation expressions (such as `m(null)`), as `m(Object[])` is more specific.
    
2.  The second phase ([¬ß15.12.2.3](jls-15.html#jls-15.12.2.3 "15.12.2.3. Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation")) performs overload resolution while allowing boxing and unboxing, but still precludes the use of variable arity method invocation. If no applicable method is found during this phase then processing continues to the third phase.
    
    This ensures that a method is never chosen through variable arity method invocation if it is applicable through fixed arity method invocation.
    
3.  The third phase ([¬ß15.12.2.4](jls-15.html#jls-15.12.2.4 "15.12.2.4. Phase 3: Identify Methods Applicable by Variable Arity Invocation")) allows overloading to be combined with variable arity methods, boxing, and unboxing.
    

Deciding whether a method is applicable will, in the case of generic methods ([¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods")), require an analysis of the type arguments. Type arguments may be passed explicitly or implicitly. If they are passed implicitly, bounds of the type arguments must be inferred ([¬ß18 (_Type Inference_)](jls-18.html "Chapter 18. Type Inference")) from the argument expressions.

If several applicable methods have been identified during one of the three phases of applicability testing, then the most specific one is chosen, as specified in section [¬ß15.12.2.5](jls-15.html#jls-15.12.2.5 "15.12.2.5. Choosing the Most Specific Method").

To check for applicability, the types of an invocation's arguments cannot, in general, be inputs to the analysis. This is because:

*   The arguments to a method invocation may be poly expressions
*   Poly expressions cannot be typed in the absence of a target type
*   Overload resolution has to be completed before the arguments' target types will be known
    

Instead, the input to the applicability check is a list of argument expressions, which _can_ be checked for compatibility with potential target types, even if the ultimate types of the expressions are unknown.

Note that overload resolution is independent of a target type. This is for two reasons:

*   First, it makes the user model more accessible and less error-prone. The meaning of a method name (i.e., the declaration corresponding to the name) is too fundamental to the meaning of a program to depend on subtle contextual hints. (In contrast, other poly expressions may have different behavior depending on a target type; but the variation in behavior is always limited and essentially equivalent, while no such guarantees can be made about the behavior of an arbitrary set of methods that share a name and arity.)
*   Second, it allows other properties - such as whether or not the method is a poly expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")) or how to categorize a conditional expression ([¬ß15.25](jls-15.html#jls-15.25 "15.25. Conditional Operator ? :")) - to depend on the meaning of the method name, even before a target type is known.
    

**Example 15.12.2-1. Method Applicability**

class Doubler {
            static int two()      { return two(1); }
    private static int two(int i) { return 2\*i;    }
}
class Test extends Doubler {	
    static long two(long j) { return j+j; }

    public static void main(String\[\] args) {
        System.out.println(two(3));
        System.out.println(Doubler.two(3)); // compile-time error
    }
}

For the method invocation `two(1)` within class `Doubler`, there are two accessible methods named `two`, but only the second one is applicable, and so that is the one invoked at run time.

For the method invocation `two(3)` within class `Test`, there are two applicable methods, but only the one in class `Test` is accessible, and so that is the one to be invoked at run time (the argument `3` is converted to type `long`).

For the method invocation `Doubler.two(3)`, the class `Doubler`, not class `Test`, is searched for methods named `two`; the only applicable method is not accessible, and so this method invocation causes a compile-time error.

Another example is:

class ColoredPoint {
    int x, y;
    byte color;
    void setColor(byte color) { this.color = color; }
}
class Test {
    public static void main(String\[\] args) {
        ColoredPoint cp = new ColoredPoint();
        byte color = 37;
        cp.setColor(color);
        cp.setColor(37);  // compile-time error
    }
}

Here, a compile-time error occurs for the second invocation of `setColor`, because no applicable method can be found at compile time. The type of the literal `37` is `int`, and `int` cannot be converted to `byte` by invocation conversion. Assignment conversion, which is used in the initialization of the variable `color`, performs an implicit conversion of the constant from type `int` to `byte`, which is permitted because the value `37` is small enough to be represented in type `byte`; but such a conversion is not allowed for invocation conversion.

If the method `setColor` had, however, been declared to take an `int` instead of a `byte`, then both method invocations would be correct; the first invocation would be allowed because invocation conversion does permit a widening conversion from `byte` to `int`. However, a narrowing cast would then be required in the body of `setColor`:

void setColor(int color) { this.color = (byte)color; }

Here is an example of overloading ambiguity. Consider the program:

class Point { int x, y; }
class ColoredPoint extends Point { int color; }
class Test {
    static void test(ColoredPoint p, Point q) {
        System.out.println("(ColoredPoint, Point)");
    }
    static void test(Point p, ColoredPoint q) {
        System.out.println("(Point, ColoredPoint)");
    }
    public static void main(String\[\] args) {
        ColoredPoint cp = new ColoredPoint();
        test(cp, cp);  // compile-time error
    }
}

This example produces an error at compile time. The problem is that there are two declarations of `test` that are applicable and accessible, and neither is more specific than the other. Therefore, the method invocation is ambiguous.

If a third definition of `test` were added:

static void test(ColoredPoint p, ColoredPoint q) {
    System.out.println("(ColoredPoint, ColoredPoint)");
}

then it would be more specific than the other two, and the method invocation would no longer be ambiguous.

  

**Example 15.12.2-2. Return Type Not Considered During Method Selection**

class Point { int x, y; }
class ColoredPoint extends Point { int color; }
class Test {
    static int test(ColoredPoint p) {
        return p.color;
    }
    static String test(Point p) {
        return "Point";
    }
    public static void main(String\[\] args) {
        ColoredPoint cp = new ColoredPoint();
        String s = test(cp);  // compile-time error
    }
}

Here, the most specific declaration of method `test` is the one taking a parameter of type `ColoredPoint`. Because the result type of the method is `int`, a compile-time error occurs because an `int` cannot be converted to a `String` by assignment conversion. This example shows that the result types of methods do not participate in resolving overloaded methods, so that the second `test` method, which returns a `String`, is not chosen, even though it has a result type that would allow the example program to compile without error.

  

**Example 15.12.2-3. Choosing The Most Specific Method**

The most specific method is chosen at compile time; its descriptor determines what method is actually executed at run time. If a new method is added to a class, then source code that was compiled with the old definition of the class might not use the new method, even if a recompilation would cause this method to be chosen.

So, for example, consider two compilation units, one for class `Point`:

package points;
public class Point {
    public int x, y;
    public Point(int x, int y) { this.x = x; this.y = y; }
    public String toString() { return toString(""); }
    public String toString(String s) {
        return "(" + x + "," + y + s + ")";
    }
}

and one for class `ColoredPoint`:

package points;
public class ColoredPoint extends Point {
    public static final int
        RED = 0, GREEN = 1, BLUE = 2;
    public static String\[\] COLORS =
        { "red", "green", "blue" };

    public byte color;
    public ColoredPoint(int x, int y, int color) {
        super(x, y);
        this.color = (byte)color;
    }

    /\*\* Copy all relevant fields of the argument into
        this ColoredPoint object. \*/
    public void adopt(Point p) { x = p.x; y = p.y; }

    public String toString() {
        String s = "," + COLORS\[color\];
        return super.toString(s);
    }
}

Now consider a third compilation unit that uses `ColoredPoint`:

import points.\*;
class Test {
    public static void main(String\[\] args) {
        ColoredPoint cp =
            new ColoredPoint(6, 6, ColoredPoint.RED);
        ColoredPoint cp2 =
            new ColoredPoint(3, 3, ColoredPoint.GREEN);
        cp.adopt(cp2);
        System.out.println("cp: " + cp);
    }
}

The output is:

cp: (3,3,red)

The programmer who coded class `Test` has expected to see the word `green`, because the actual argument, a `ColoredPoint`, has a `color` field, and `color` would seem to be a "relevant field". (Of course, the documentation for the package `points` ought to have been much more precise!)

Notice, by the way, that the most specific method (indeed, the only applicable method) for the method invocation of `adopt` has a signature that indicates a method of one parameter, and the parameter is of type `Point`. This signature becomes part of the binary representation of class `Test` produced by the Java compiler and is used by the method invocation at run time.

Suppose the programmer reported this software error and the maintainer of the `points` package decided, after due deliberation, to correct it by adding a method to class `ColoredPoint`:

public void adopt(ColoredPoint p) {
    adopt((Point)p);
    color = p.color;
}

If the programmer then runs the old binary file for `Test` with the new binary file for `ColoredPoint`, the output is still:

cp: (3,3,red)

because the old binary file for `Test` still has the descriptor "one parameter, whose type is `Point`; `void`" associated with the method call `cp.adopt(cp2)`. If the source code for `Test` is recompiled, the Java compiler will then discover that there are now two applicable `adopt` methods, and that the signature for the more specific one is "one parameter, whose type is `ColoredPoint`; `void`"; running the program will then produce the desired output:

cp: (3,3,green)

With forethought about such problems, the maintainer of the `points` package could fix the `ColoredPoint` class to work with both newly compiled and old code, by adding defensive code to the old `adopt` method for the sake of old code that still invokes it on `ColoredPoint` arguments:

public void adopt(Point p) {
    if (p instanceof ColoredPoint)
        color = ((ColoredPoint)p).color;
    x = p.x; y = p.y;
}

Ideally, source code should be recompiled whenever code that it depends on is changed. However, in an environment where different classes are maintained by different organizations, this is not always feasible. Defensive programming with careful attention to the problems of class evolution can make upgraded code much more robust. See [¬ß13 (_Binary Compatibility_)](jls-13.html "Chapter 13. Binary Compatibility") for a detailed discussion of binary compatibility and type evolution.

  

#### 15.12.2.1. Identify Potentially Applicable Methods

The class or interface determined by compile-time step 1 ([¬ß15.12.1](jls-15.html#jls-15.12.1 "15.12.1. Compile-Time Step 1: Determine Class or Interface to Search")) is searched for all member methods that are potentially applicable to this method invocation; members inherited from superclasses and superinterfaces are included in this search.

In addition, if the form of the method invocation expression is _MethodName_ - that is, a single _Identifier_ - then the search for potentially applicable methods also examines all member methods that are imported by single-static-import declarations and static-import-on-demand declarations of the compilation unit where the method invocation occurs ([¬ß7.5.3](jls-7.html#jls-7.5.3 "7.5.3. Single-Static-Import Declarations"), [¬ß7.5.4](jls-7.html#jls-7.5.4 "7.5.4. Static-Import-on-Demand Declarations")) and that are not shadowed at the point where the method invocation appears.

A member method is _potentially applicable_ to a method invocation if and only if all of the following are true:

*   The name of the member is identical to the name of the method in the method invocation.
*   The member is accessible ([¬ß6.6](jls-6.html#jls-6.6 "6.6. Access Control")) to the class or interface in which the method invocation appears.
    
    Whether a member method is accessible at a method invocation depends on the access modifier (`public`, `protected`, no modifier (package access), or `private`) in the member's declaration and on where the method invocation appears.
*   If the member is a fixed arity method with arity _n_, the arity of the method invocation is equal to _n_, and for all _i_ (1 ‚â§ _i_ ‚â§ _n_), the _i_'th argument of the method invocation is _potentially compatible_, as defined below, with the type of the _i_'th parameter of the method.
*   If the member is a variable arity method with arity _n_, then for all _i_ (1 ‚â§ _i_ ‚â§ _n_\-1), the _i_'th argument of the method invocation is _potentially compatible_ with the type of the _i_'th parameter of the method; and, where the _n_th parameter of the method has type T`[]`, one of the following is true:
    
    *   The arity of the method invocation is equal to _n_\-1.
        
    *   The arity of the method invocation is equal to _n_, and the _n_th argument of the method invocation is potentially compatible with either T or T`[]`.
        
    *   The arity of the method invocation is _m_, where _m_ > _n_, and for all _i_ (_n_ ‚â§ _i_ ‚â§ _m_), the _i_'th argument of the method invocation is potentially compatible with T.
        
*   If the method invocation includes explicit type arguments, and the member is a generic method, then the number of type arguments is equal to the number of type parameters of the method.
    
    This clause implies that a non-generic method may be potentially applicable to an invocation that supplies explicit type arguments. Indeed, it may turn out to be applicable. In such a case, the type arguments will simply be ignored.
    
    This rule stems from issues of compatibility and principles of substitutability. Since interfaces or superclasses may be generified independently of their subtypes, we may override a generic method with a non-generic one. However, the overriding (non-generic) method must be applicable to calls to the generic method, including calls that explicitly pass type arguments. Otherwise the subtype would not be substitutable for its generified supertype.
    

If the search does not yield at least one method that is potentially applicable, then a compile-time error occurs.

An expression is _potentially compatible_ with a target type according to the following rules:

*   A lambda expression ([¬ß15.27](jls-15.html#jls-15.27 "15.27. Lambda Expressions")) is potentially compatible with a functional interface type ([¬ß9.8](jls-9.html#jls-9.8 "9.8. Functional Interfaces")) if all of the following are true:
    
    *   The arity of the target type's function type is the same as the arity of the lambda expression.
        
    *   If the target type's function type has a `void` return, then the lambda body is either a statement expression ([¬ß14.8](jls-14.html#jls-14.8 "14.8. Expression Statements")) or a void-compatible block ([¬ß15.27.2](jls-15.html#jls-15.27.2 "15.27.2. Lambda Body")).
        
    *   If the target type's function type has a (non-`void`) return type, then the lambda body is either an expression or a value-compatible block ([¬ß15.27.2](jls-15.html#jls-15.27.2 "15.27.2. Lambda Body")).
        
*   A method reference expression ([¬ß15.13](jls-15.html#jls-15.13 "15.13. Method Reference Expressions")) is potentially compatible with a functional interface type if, where the type's function type arity is _n_, there exists at least one potentially applicable method for the method reference expression with arity _n_ ([¬ß15.13.1](jls-15.html#jls-15.13.1 "15.13.1. Compile-Time Declaration of a Method Reference")), and one of the following is true:
    
    *   The method reference expression has the form _ReferenceType_ `::` _\[TypeArguments\]_ _Identifier_ and at least one potentially applicable method is i) `static` and supports arity _n_, or ii) not `static` and supports arity _n_\-1.
        
    *   The method reference expression has some other form and at least one potentially applicable method is not `static`.
        
*   A lambda expression or a method reference expression is potentially compatible with a type variable if the type variable is a type parameter of the candidate method.
*   A parenthesized expression ([¬ß15.8.5](jls-15.html#jls-15.8.5 "15.8.5. Parenthesized Expressions")) is potentially compatible with a type if its contained expression is potentially compatible with that type.
*   A conditional expression ([¬ß15.25](jls-15.html#jls-15.25 "15.25. Conditional Operator ? :")) is potentially compatible with a type if each of its second and third operand expressions are potentially compatible with that type.
*   A class instance creation expression, a method invocation expression, or an expression of a standalone form ([¬ß15.2](jls-15.html#jls-15.2 "15.2. Forms of Expressions")) is potentially compatible with any type.
    

The definition of potential applicability goes beyond a basic arity check to also take into account the presence and "shape" of functional interface target types. In some cases involving type argument inference, a lambda expression appearing as a method invocation argument cannot be properly typed until after overload resolution. These rules allow the form of the lambda expression to still be taken into account, discarding obviously incorrect target types that might otherwise cause ambiguity errors.

#### 15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation

An argument expression is considered _pertinent to applicability_ for a potentially applicable method `m` unless it has one of the following forms:

*   An implicitly typed lambda expression ([¬ß15.27.1](jls-15.html#jls-15.27.1 "15.27.1. Lambda Parameters")).
*   An inexact method reference expression ([¬ß15.13.1](jls-15.html#jls-15.13.1 "15.13.1. Compile-Time Declaration of a Method Reference")).
*   If `m` is a generic method and the method invocation does not provide explicit type arguments, an explicitly typed lambda expression or an exact method reference expression for which the corresponding target type (as derived from the signature of `m`) is a type parameter of `m`.
*   An explicitly typed lambda expression whose body is an expression that is not pertinent to applicability.
*   An explicitly typed lambda expression whose body is a block, where at least one result expression is not pertinent to applicability.
*   A parenthesized expression ([¬ß15.8.5](jls-15.html#jls-15.8.5 "15.8.5. Parenthesized Expressions")) whose contained expression is not pertinent to applicability.
*   A conditional expression ([¬ß15.25](jls-15.html#jls-15.25 "15.25. Conditional Operator ? :")) whose second or third operand is not pertinent to applicability.
    

Let `m` be a potentially applicable method ([¬ß15.12.2.1](jls-15.html#jls-15.12.2.1 "15.12.2.1. Identify Potentially Applicable Methods")) with arity _n_ and formal parameter types F1 ... Fn, and let `e1`, ..., `en` be the actual argument expressions of the method invocation. Then:

*   If `m` is a generic method and the method invocation does not provide explicit type arguments, then the applicability of the method is inferred as specified in [¬ß18.5.1](jls-18.html#jls-18.5.1 "18.5.1. Invocation Applicability Inference").
*   If `m` is a generic method and the method invocation provides explicit type arguments, then let R1 ... Rp (_p_ ‚â• 1) be the type parameters of `m`, let Bl be the declared bound of Rl (1 ‚â§ _l_ ‚â§ _p_), and let U1, ..., Up be the explicit type arguments given in the method invocation. Then `m` is _applicable by strict invocation_ if both of the following are true:
    
    *   For 1 ‚â§ _i_ ‚â§ _n_, if `ei` is pertinent to applicability then `ei` is compatible in a strict invocation context with Fi`[`R1:=U1, ..., Rp:=Up`]`.
        
    *   For 1 ‚â§ _l_ ‚â§ _p_, Ul `<:` Bl`[`R1:=U1, ..., Rp:=Up`]`.
        
*   If `m` is not a generic method, then `m` is _applicable by strict invocation_ if, for 1 ‚â§ _i_ ‚â§ _n_, either `ei` is compatible in a strict invocation context with Fi or `ei` is not pertinent to applicability.
    

If no method applicable by strict invocation is found, the search for applicable methods continues with phase 2 ([¬ß15.12.2.3](jls-15.html#jls-15.12.2.3 "15.12.2.3. Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation")).

Otherwise, the most specific method ([¬ß15.12.2.5](jls-15.html#jls-15.12.2.5 "15.12.2.5. Choosing the Most Specific Method")) is chosen among the methods that are applicable by strict invocation.

The meaning of an implicitly typed lambda expression or an inexact method reference expression is sufficiently vague prior to resolving a target type that arguments containing these expressions are not considered _pertinent to applicability_; they are simply ignored (except for their expected arity) until overload resolution is finished.

#### 15.12.2.3. Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation

Let `m` be a potentially applicable method ([¬ß15.12.2.1](jls-15.html#jls-15.12.2.1 "15.12.2.1. Identify Potentially Applicable Methods")) with arity _n_ and formal parameter types F1, ..., Fn, and let `e1`, ..., `en` be the actual argument expressions of the method invocation. Then:

*   If `m` is a generic method and the method invocation does not provide explicit type arguments, then the applicability of the method is inferred as specified in [¬ß18.5.1](jls-18.html#jls-18.5.1 "18.5.1. Invocation Applicability Inference").
*   If `m` is a generic method and the method invocation provides explicit type arguments, then let R1 ... Rp (_p_ ‚â• 1) be the type parameters of `m`, let Bl be the declared bound of Rl (1 ‚â§ _l_ ‚â§ _p_), and let U1 ... Up be the explicit type arguments given in the method invocation. Then `m` is _applicable by loose invocation_ if both of the following are true:
    
    *   For 1 ‚â§ _i_ ‚â§ _n_, if `ei` is pertinent to applicability ([¬ß15.12.2.2](jls-15.html#jls-15.12.2.2 "15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation")) then `ei` is compatible in a loose invocation context with Fi`[`R1:=U1, ..., Rp:=Up`]`.
        
    *   For 1 ‚â§ _l_ ‚â§ _p_, Ul `<:` Bl`[`R1:=U1, ..., Rp:=Up`]`.
        
*   If `m` is not a generic method, then `m` is _applicable by loose invocation_ if, for 1 ‚â§ _i_ ‚â§ _n_, either `ei` is compatible in a loose invocation context with Fi or `ei` is not pertinent to applicability.
    

If no method applicable by loose invocation is found, the search for applicable methods continues with phase 3 ([¬ß15.12.2.4](jls-15.html#jls-15.12.2.4 "15.12.2.4. Phase 3: Identify Methods Applicable by Variable Arity Invocation")).

Otherwise, the most specific method ([¬ß15.12.2.5](jls-15.html#jls-15.12.2.5 "15.12.2.5. Choosing the Most Specific Method")) is chosen among the methods that are applicable by loose invocation.

#### 15.12.2.4. Phase 3: Identify Methods Applicable by Variable Arity Invocation

Where a variable arity method has formal parameter types F1, ..., Fn-1, Fn`[]`, let the _i_'th _variable arity parameter type_ of the method be defined as follows:

*   For _i_ ‚â§ _n_\-1, the _i_'th variable arity parameter type is Fi.
*   For _i_ ‚â• _n_, the _i_'th variable arity parameter type is Fn.
    

Let `m` be a potentially applicable method ([¬ß15.12.2.1](jls-15.html#jls-15.12.2.1 "15.12.2.1. Identify Potentially Applicable Methods")) with variable arity, let T1, ..., Tk be the first _k_ variable arity parameter types of `m`, and let `e1`, ..., `ek` be the actual argument expressions of the method invocation. Then:

*   If `m` is a generic method and the method invocation does not provide explicit type arguments, then the applicability of the method is inferred as specified in [¬ß18.5.1](jls-18.html#jls-18.5.1 "18.5.1. Invocation Applicability Inference").
*   If `m` is a generic method and the method invocation provides explicit type arguments, then let R1 ... Rp (_p_ ‚â• 1) be the type parameters of `m`, let Bl be the declared bound of Rl (1 ‚â§ _l_ ‚â§ _p_), and let U1 ... Up be the explicit type arguments given in the method invocation. Then `m` is _applicable by variable arity invocation_ if:
    
    *   For 1 ‚â§ _i_ ‚â§ _k_, if `ei` is pertinent to applicability ([¬ß15.12.2.2](jls-15.html#jls-15.12.2.2 "15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation")) then `ei` is compatible in a loose invocation context with Ti`[`R1:=U1, ..., Rp:=Up`]`.
        
    *   For 1 ‚â§ _l_ ‚â§ _p_, Ul `<:` Bl`[`R1:=U1, ..., Rp:=Up`]`.
        
*   If `m` is not a generic method, then `m` is _applicable by variable arity invocation_ if, for 1 ‚â§ _i_ ‚â§ _k_, either `ei` is compatible in a loose invocation context with Ti or `ei` is not pertinent to applicability.
    

If no method applicable by variable arity invocation is found, then a compile-time error occurs.

Otherwise, the most specific method ([¬ß15.12.2.5](jls-15.html#jls-15.12.2.5 "15.12.2.5. Choosing the Most Specific Method")) is chosen among the methods applicable by variable arity invocation.

#### 15.12.2.5. Choosing the Most Specific Method

If more than one member method is both accessible and applicable to a method invocation, it is necessary to choose one to provide the descriptor for the run-time method dispatch. The Java programming language uses the rule that the _most specific_ method is chosen.

The informal intuition is that one method is more specific than another if any invocation handled by the first method could be passed on to the other one without a compile-time error. In cases such as an explicitly typed lambda expression argument ([¬ß15.27.1](jls-15.html#jls-15.27.1 "15.27.1. Lambda Parameters")) or a variable arity invocation ([¬ß15.12.2.4](jls-15.html#jls-15.12.2.4 "15.12.2.4. Phase 3: Identify Methods Applicable by Variable Arity Invocation")), some flexibility is allowed to adapt one signature to the other.

One applicable method `m1` is _more specific_ than another applicable method `m2`, for an invocation with argument expressions `e1`, ..., `ek`, if any of the following are true:

*   `m2` is generic, and `m1` is inferred to be more specific than `m2` for argument expressions `e1`, ..., `ek` by [¬ß18.5.4](jls-18.html#jls-18.5.4 "18.5.4. More Specific Method Inference").
*   `m2` is not generic, and `m1` and `m2` are applicable by strict or loose invocation, and where `m1` has formal parameter types S1, ..., Sn and `m2` has formal parameter types T1, ..., Tn, the type Si is _more specific_ than Ti for argument `ei` for all _i_ (1 ‚â§ _i_ ‚â§ _n_, _n_ = _k_).
*   `m2` is not generic, and `m1` and `m2` are applicable by variable arity invocation, and where the first _k_ variable arity parameter types of `m1` are S1, ..., Sk and the first _k_ variable arity parameter types of `m2` are T1, ..., Tk, the type Si is _more specific_ than Ti for argument `ei` for all _i_ (1 ‚â§ _i_ ‚â§ _k_). Additionally, if `m2` has _k_+1 parameters, then the _k__+1_'th variable arity parameter type of `m1` is a subtype of the _k__+1_'th variable arity parameter type of `m2`.
    

The above conditions are the only circumstances under which one method may be more specific than another.

A type S is _more specific_ than a type T for _any_ expression if S `<:` T ([¬ß4.10](jls-4.html#jls-4.10 "4.10. Subtyping")).

A functional interface type S is _more specific_ than a functional interface type T for an expression `e` if T is not a subtype of S and one of the following is true (where U1 ... Uk and R1 are the parameter types and return type of the function type of the capture of S, and V1 ... Vk and R2 are the parameter types and return type of the function type of T):

*   If `e` is an explicitly typed lambda expression ([¬ß15.27.1](jls-15.html#jls-15.27.1 "15.27.1. Lambda Parameters")), then one of the following is true:
    
    *   R2 is `void`.
        
    *   R1 `<:` R2.
        
    *   R1 and R2 are functional interface types, and there is at least one result expression, and R1 is more specific than R2 for each result expression of `e`.
        
        (The result expression of a lambda expression with a block body is defined in [¬ß15.27.2](jls-15.html#jls-15.27.2 "15.27.2. Lambda Body"); the result expression of a lambda expression with an expression body is simply the body itself.)
        
    *   R1 is a primitive type, and R2 is a reference type, and there is at least one result expression, and each result expression of `e` is a standalone expression ([¬ß15.2](jls-15.html#jls-15.2 "15.2. Forms of Expressions")) of a primitive type.
        
    *   R1 is a reference type, and R2 is a primitive type, and there is at least one result expression, and each result expression of `e` is either a standalone expression of a reference type or a poly expression.
        
*   If `e` is an exact method reference expression ([¬ß15.13.1](jls-15.html#jls-15.13.1 "15.13.1. Compile-Time Declaration of a Method Reference")), then i) for all _i_ (1 ‚â§ _i_ ‚â§ _k_), Ui is the same as Vi, and ii) one of the following is true:
    
    *   R2 is `void`.
        
    *   R1 `<:` R2.
        
    *   R1 is a primitive type, R2 is a reference type, and the compile-time declaration for the method reference has a return type which is a primitive type.
        
    *   R1 is a reference type, R2 is a primitive type, and the compile-time declaration for the method reference has a return type which is a reference type.
        
*   If `e` is a parenthesized expression, then one of these conditions applies recursively to the contained expression.
*   If `e` is a conditional expression, then for each of the second and third operands, one of these conditions applies recursively.
    

A method `m1` is _strictly more specific_ than another method `m2` if and only if `m1` is more specific than `m2` and `m2` is not more specific than `m1`.

A method is said to be _maximally specific_ for a method invocation if it is accessible and applicable and there is no other method that is applicable and accessible that is strictly more specific.

If there is exactly one maximally specific method, then that method is in fact the _most specific method_; it is necessarily more specific than any other accessible method that is applicable. It is then subjected to some further compile-time checks as specified in [¬ß15.12.3](jls-15.html#jls-15.12.3 "15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?").

It is possible that no method is the most specific, because there are two or more methods that are maximally specific. In this case:

*   If all the maximally specific methods have override-equivalent signatures ([¬ß8.4.2](jls-8.html#jls-8.4.2 "8.4.2. Method Signature")), then:
    
    *   If exactly one of the maximally specific methods is concrete (that is, non-`abstract` or default), it is the most specific method.
        
    *   Otherwise, if all the maximally specific methods are `abstract` or default, and the signatures of all of the maximally specific methods have the same erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")), then the most specific method is chosen arbitrarily among the subset of the maximally specific methods that have the most specific return type.
        
        In this case, the most specific method is considered to be `abstract`. Also, the most specific method is considered to throw a checked exception if and only if that exception or its erasure is declared in the `throws` clauses of each of the maximally specific methods.
        
*   Otherwise, the method invocation is _ambiguous_, and a compile-time error occurs.
    

#### 15.12.2.6. Method Invocation Type

The _invocation type_ of a most specific accessible and applicable method is a method type ([¬ß8.2](jls-8.html#jls-8.2 "8.2. Class Members")) expressing the target types of the invocation arguments, the result (return type or `void`) of the invocation, and the exception types of the invocation. It is determined as follows:

*   If the chosen method is generic and the method invocation does not provide explicit type arguments, the invocation type is inferred as specified in [¬ß18.5.2](jls-18.html#jls-18.5.2 "18.5.2. Invocation Type Inference").
*   If the chosen method is generic and the method invocation provides explicit type arguments, let Pi be the type parameters of the method and let Ti be the explicit type arguments provided for the method invocation (1 ‚â§ _i_ ‚â§ _p_). Then:
    
    *   If unchecked conversion was necessary for the method to be applicable, then the invocation type's parameter types are obtained by applying the substitution `[`P1:=T1, ..., Pp:=Tp`]` to the parameter types of the method's type, and the invocation type's return type and thrown types are given by the erasure of the return type and thrown types of the method's type.
        
    *   If unchecked conversion was not necessary for the method to be applicable, then the invocation type is obtained by applying the substitution `[`P1:=T1, ..., Pp:=Tp`]` to the method's type.
        
*   If the chosen method is not generic, then:
    
    *   If unchecked conversion was necessary for the method to be applicable, the parameter types of the invocation type are the parameter types of the method's type, and the return type and thrown types are given by the erasures of the return type and thrown types of the method's type.
        
    *   Otherwise, if the chosen method is the `getClass` method of the class `Object` ([¬ß4.3.2](jls-4.html#jls-4.3.2 "4.3.2. The Class Object")), the invocation type is the same as the method's type, except that the return type is `Class``<``?` `extends` |T|`>`, where T is the type that was searched, as determined by [¬ß15.12.1](jls-15.html#jls-15.12.1 "15.12.1. Compile-Time Step 1: Determine Class or Interface to Search"), and |T| denotes the erasure of T ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")).
        
    *   Otherwise, the invocation type is the same as the method's type.
        
    

### 15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?

If there is a most specific method declaration for a method invocation, it is called the _compile-time declaration_ for the method invocation.

It is a compile-time error if an argument to a method invocation is not compatible with its target type, as derived from the invocation type of the compile-time declaration.

If the compile-time declaration is applicable by variable arity invocation, then where the last formal parameter type of the invocation type of the method is Fn`[]`, it is a compile-time error if the type which is the erasure of Fn is not accessible at the point of invocation.

If the compile-time declaration is `void`, then the method invocation must be a top level expression (that is, the _Expression_ in an expression statement or in the _ForInit_ or _ForUpdate_ part of a `for` statement), or a compile-time error occurs. Such a method invocation produces no value and so must be used only in a situation where a value is not needed.

In addition, whether the compile-time declaration is appropriate may depend on the form of the method invocation expression before the left parenthesis, as follows:

*   If the form is _MethodName_ - that is, just an _Identifier_ - and the compile-time declaration is an instance method, then:
    
    *   It is a compile-time error if the method invocation occurs in a static context ([¬ß8.1.3](jls-8.html#jls-8.1.3 "8.1.3. Inner Classes and Enclosing Instances")).
        
    *   Otherwise, let C be the immediately enclosing class of which the compile-time declaration is a member. If the method invocation is not directly enclosed by C or an inner class of C, then a compile-time error occurs.
        
*   If the form is _TypeName_ `.` _\[TypeArguments\]_ _Identifier_, then the compile-time declaration must be `static`, or a compile-time error occurs.
*   If the form is _ExpressionName_ `.` _\[TypeArguments\]_ _Identifier_ or _Primary_ `.` _\[TypeArguments\]_ _Identifier_, then the compile-time declaration must not be a `static` method declared in an interface, or a compile-time error occurs.
*   If the form is `super` `.` _\[TypeArguments\]_ _Identifier_, then:
    
    *   It is a compile-time error if the compile-time declaration is `abstract`.
        
    *   It is a compile-time error if the method invocation occurs in a static context.
        
*   If the form is _TypeName_ `.` `super` `.` _\[TypeArguments\]_ _Identifier_, then:
    
    *   It is a compile-time error if the compile-time declaration is `abstract`.
        
    *   It is a compile-time error if the method invocation occurs in a static context.
        
    *   If _TypeName_ denotes a class C, then if the method invocation is not directly enclosed by C or an inner class of C, a compile-time error occurs.
        
    *   If _TypeName_ denotes an interface, let T be the type declaration immediately enclosing the method invocation. A compile-time error occurs if there exists a method, distinct from the compile-time declaration, that overrides ([¬ß9.4.1](jls-9.html#jls-9.4.1 "9.4.1. Inheritance and Overriding")) the compile-time declaration from a direct superclass or direct superinterface of T.
        
        In the case that a superinterface overrides a method declared in a grandparent interface, this rule prevents the child interface from "skipping" the override by simply adding the grandparent to its list of direct superinterfaces. The appropriate way to access functionality of a grandparent is through the direct superinterface, and only if that interface chooses to expose the desired behavior. (Alternately, the developer is free to define his own additional superinterface that exposes the desired behavior with a `super` method invocation.)
        
    

The _compile-time parameter types_ and _compile-time result_ are determined as follows:

*   If the compile-time declaration for the method invocation is _not_ a signature polymorphic method, then the compile-time parameter types are the types of the formal parameters of the compile-time declaration, and the compile-time result is the result chosen for the compile-time declaration ([¬ß15.12.2.6](jls-15.html#jls-15.12.2.6 "15.12.2.6. Method Invocation Type")).
*   If the compile-time declaration for the method invocation is a signature polymorphic method, then:
    
    *   The compile-time parameter types are the static types of the actual argument expressions. An argument expression which is the null literal `null` ([¬ß3.10.7](jls-3.html#jls-3.10.7 "3.10.7. The Null Literal")) is treated as having the static type `Void`.
        
    *   The compile-time result is determined as follows:
        
        *   If the method invocation expression is an expression statement, the compile-time result is `void`.
            
        *   Otherwise, if the method invocation expression is the operand of a cast expression ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")), the compile-time result is the erasure of the type of the cast expression ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")).
            
        *   Otherwise, the compile-time result is the signature polymorphic method's declared return type, `Object`.
            
        
    

A method is _signature polymorphic_ if all of the following are true:

*   It is declared in the `java.lang.invoke.MethodHandle` class.
*   It takes a single variable arity parameter ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters")) whose declared type is `Object``[]`.
*   It has a return type of `Object`.
*   It is `native`.
    

In Java SE 8, the only signature polymorphic methods are the `invoke` and `invokeExact` methods of the class `java.lang.invoke.MethodHandle`.

The following compile-time information is then associated with the method invocation for use at run time:

*   The name of the method.
*   The qualifying type of the method invocation ([¬ß13.1](jls-13.html#jls-13.1 "13.1. The Form of a Binary")).
*   The number of parameters and the compile-time parameter types, in order.
*   The compile-time result, or `void`.

*   The invocation mode, computed as follows:
    
    *   If the qualifying type of the method declaration is a class, then:
        
        *   If the compile-time declaration has the `static` modifier, then the invocation mode is `static`.
            
        *   Otherwise, if the compile-time declaration has the `private` modifier, then the invocation mode is `nonvirtual`.
            
        *   Otherwise, if the part of the method invocation before the left parenthesis is of the form `super` `.` _Identifier_ or of the form _TypeName_ `.` `super` `.` _Identifier_, then the invocation mode is `super`.
            
        *   Otherwise, the invocation mode is `virtual`.
            
        
    *   If the qualifying type of the method invocation is an interface, then the invocation mode is `interface`.
        
    

If the result of the invocation type of the compile-time declaration is not `void`, then the type of the method invocation expression is obtained by applying capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")) to the return type of the invocation type of the compile-time declaration.

### 15.12.4. Run-Time Evaluation of Method Invocation

At run time, method invocation requires five steps. First, a _target reference_ may be computed. Second, the argument expressions are evaluated. Third, the accessibility of the method to be invoked is checked. Fourth, the actual code for the method to be executed is located. Fifth, a new activation frame is created, synchronization is performed if necessary, and control is transferred to the method code.

#### 15.12.4.1. Compute Target Reference (If Necessary)

There are six cases to consider, depending on the form of the method invocation:

*   If the form is _MethodName_ - that is, just an _Identifier_ - then:
    
    *   If the invocation mode is `static`, then there is no target reference.
        
    *   Otherwise, let T be the enclosing type declaration of which the method is a member, and let _n_ be an integer such that T is the _n_'th lexically enclosing type declaration of the class whose declaration immediately contains the method invocation. The target reference is the _n_'th lexically enclosing instance of `this`.
        
        It is a compile-time error if the _n_'th lexically enclosing instance of `this` does not exist.
        
*   If the form is _TypeName_ `.` _\[TypeArguments\]_ _Identifier_, then there is no target reference.
*   If form is _ExpressionName_ `.` _\[TypeArguments\]_ _Identifier_, then:
    
    *   If the invocation mode is `static`, then there is no target reference. The _ExpressionName_ is evaluated, but the result is then discarded.
        
    *   Otherwise, the target reference is the value denoted by _ExpressionName_.
        
*   If the form is _Primary_ `.` _\[TypeArguments\]_ _Identifier_ involved, then:
    
    *   If the invocation mode is `static`, then there is no target reference. The _Primary_ expression is evaluated, but the result is then discarded.
        
    *   Otherwise, the _Primary_ expression is evaluated and the result is used as the target reference.
        
    
    In either case, if the evaluation of the _Primary_ expression completes abruptly, then no part of any argument expression appears to have been evaluated, and the method invocation completes abruptly for the same reason.
*   If the form is `super` `.` _\[TypeArguments\]_ _Identifier_, then the target reference is the value of `this`.
*   If the form is _TypeName_ `.` `super` `.` _\[TypeArguments\]_ _Identifier_, then if _TypeName_ denotes a class, the target reference is the value of _TypeName_`.``this`; otherwise, the target reference is the value of `this`.
    

**Example 15.12.4.1-1. Target References and `static` Methods**

When a target reference is computed and then discarded because the invocation mode is `static`, the reference is not examined to see whether it is `null`:

class Test1 {
    static void mountain() {
        System.out.println("Monadnock");
    }
    static Test1 favorite(){
        System.out.print("Mount ");
        return null;
    }
    public static void main(String\[\] args) {
        favorite().mountain();
    }
}

which prints:

Mount Monadnock

Here `favorite()` returns `null`, yet no `NullPointerException` is thrown.

  

**Example 15.12.4.1-2. Evaluation Order During Method Invocation**

As part of an instance method invocation ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")), there is an expression that denotes the object to be invoked. This expression appears to be fully evaluated before any part of any argument expression to the method invocation is evaluated.

So, for example, in:

class Test2 {
    public static void main(String\[\] args) {
        String s = "one";
        if (s.startsWith(s = "two"))
            System.out.println("oops");
    }
}

the occurrence of `s` before "`.startsWith`" is evaluated first, before the argument expression `s = "two"`. Therefore, a reference to the string `"one"` is remembered as the target reference before the local variable `s` is changed to refer to the string `"two"`. As a result, the `startsWith` method is invoked for target object `"one"` with argument `"two"`, so the result of the invocation is `false`, as the string `"one"` does not start with `"two"`. It follows that the test program does not print "`oops`".

  

#### 15.12.4.2. Evaluate Arguments

The process of evaluating the argument list differs, depending on whether the method being invoked is a fixed arity method or a variable arity method ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters")).

If the method being invoked is a variable arity method `m`, it necessarily has _n_ > 0 formal parameters. The final formal parameter of `m` necessarily has type T`[]` for some T, and `m` is necessarily being invoked with _k_ ‚â• 0 actual argument expressions.

If `m` is being invoked with _k_ ‚â† _n_ actual argument expressions, or, if `m` is being invoked with _k_ = _n_ actual argument expressions and the type of the _k_'th argument expression is not assignment compatible with T`[]`, then the argument list (`e1`, ..., `en-1`, `en`, ..., `ek`) is evaluated as if it were written as (`e1`, ..., `en-1`, `new` |T`[]`| `{` `en`, ..., `ek` `}`), where |T`[]`| denotes the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of T`[]`.

The preceding paragraph is crafted to handle the interaction of parameterized types and array types that occurs in a Java Virtual Machine with erased generics. Namely, if the element type T of the variable array parameter is non-reifiable, e.g. `` List`<`String`>` ``, then special care must be taken with the array creation expression ([¬ß15.10](jls-15.html#jls-15.10 "15.10. Array Creation and Access Expressions")) because the created array's element type must be reifiable. By erasing the array type of the final expression in the argument list, we are guaranteed to obtain a reifiable element type. Then, since the array creation expression appears in an invocation context ([¬ß5.3](jls-5.html#jls-5.3 "5.3. Invocation Contexts")), an unchecked conversion is possible from the array type with reifiable element type to an array type with non-reifiable element type, specifically that of the variable arity parameter. A Java compiler is required to give a compile-time unchecked warning at this conversion. Oracle's reference implementation of a Java compiler identifies the unchecked warning here as a more informative _unchecked generic array creation_.

The argument expressions (possibly rewritten as described above) are now evaluated to yield _argument values_. Each argument value corresponds to exactly one of the method's _n_ formal parameters.

The argument expressions, if any, are evaluated in order, from left to right. If the evaluation of any argument expression completes abruptly, then no part of any argument expression to its right appears to have been evaluated, and the method invocation completes abruptly for the same reason. The result of evaluating the _j_'th argument expression is the _j_'th argument value, for 1 ‚â§ _j_ ‚â§ _n_. Evaluation then continues, using the argument values, as described below.

#### 15.12.4.3. Check Accessibility of Type and Method

Let C be the class containing the method invocation, and let T be the qualifying type of the method invocation ([¬ß13.1](jls-13.html#jls-13.1 "13.1. The Form of a Binary")), and let `m` be the name of the method as determined at compile time ([¬ß15.12.3](jls-15.html#jls-15.12.3 "15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?")).

An implementation of the Java programming language must ensure, as part of linkage, that the method `m` still exists in the type T. If this is not true, then a `NoSuchMethodError` (which is a subclass of `IncompatibleClassChangeError`) occurs.

If the invocation mode is `interface`, then the implementation must also check that the target reference type still implements the specified interface. If the target reference type does not still implement the interface, then an `IncompatibleClassChangeError` occurs.

The implementation must also ensure, during linkage, that the type T and the method `m` are accessible:

*   For the type T:
    
    *   If T is in the same package as C, then T is accessible.
        
    *   If T is in a different package than C, and T is `public`, then T is accessible.
        
    *   If T is in a different package than C, and T is `protected`, then T is accessible if and only if C is a subclass of T.
        
*   For the method `m`:
    
    *   If `m` is `public`, then `m` is accessible. (All members of interfaces are `public` ([¬ß9.2](jls-9.html#jls-9.2 "9.2. Interface Members")).)
        
    *   If `m` is `protected`, then `m` is accessible if and only if either T is in the same package as C, or C is T or a subclass of T.
        
    *   If `m` has package access, then `m` is accessible if and only if T is in the same package as C.
        
    *   If `m` is `private`, then `m` is accessible if and only if C is T, or C encloses T, or T encloses C, or T and C are both enclosed by a third class.
        
    

If either T or `m` is not accessible, then an `IllegalAccessError` occurs ([¬ß12.3](jls-12.html#jls-12.3 "12.3. Linking of Classes and Interfaces")).

#### 15.12.4.4. Locate Method to Invoke

The strategy for method lookup depends on the invocation mode.

If the invocation mode is `static`, no target reference is needed and overriding is not allowed. Method `m` of class T is the one to be invoked.

Otherwise, an instance method is to be invoked and there is a target reference. If the target reference is `null`, a `NullPointerException` is thrown at this point. Otherwise, the target reference is said to refer to a _target object_ and will be used as the value of the keyword `this` in the invoked method. The other four possibilities for the invocation mode are then considered.

If the invocation mode is `nonvirtual`, overriding is not allowed. Method `m` of class T is the one to be invoked.

Otherwise, if the invocation mode is `virtual`, and T and `m` jointly indicate a signature polymorphic method ([¬ß15.12.3](jls-15.html#jls-15.12.3 "15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?")), then the target object is an instance of `java.lang.invoke.MethodHandle`. The method handle encapsulates a _type_ which is matched against the information associated with the method invocation at compile time ([¬ß15.12.3](jls-15.html#jls-15.12.3 "15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?")). Details of this matching are given in _The Java Virtual Machine Specification, Java SE 8 Edition_ and the Java SE platform API. If matching succeeds, the _target method_ encapsulated by the method handle is directly and immediately invoked, _and the procedure in [¬ß15.12.4.5](jls-15.html#jls-15.12.4.5 "15.12.4.5. Create Frame, Synchronize, Transfer Control") is not executed_.

Otherwise, the invocation mode is `interface`, `virtual`, or `super`, and overriding may occur. A _dynamic method lookup_ is used. The dynamic lookup process starts from a class S, determined as follows:

*   If the invocation mode is `interface` or `virtual`, then S is initially the actual run-time class R of the target object.
    
    This is true even if the target object is an array instance. (Note that for invocation mode `interface`, R necessarily implements T; for invocation mode `virtual`, R is necessarily either T or a subclass of T.)
*   If the invocation mode is `super`, then S is initially the qualifying type ([¬ß13.1](jls-13.html#jls-13.1 "13.1. The Form of a Binary")) of the method invocation.
    

The dynamic method lookup uses the following procedure to search class S, and then the superclasses and superinterfaces of class S, as necessary, for method `m`.

Let X be the compile-time type of the target reference of the method invocation. Then:

1.  If class S contains a declaration for a method named `m` with the same descriptor (same number of parameters, the same parameter types, and the same return type) required by the method invocation as determined at compile time ([¬ß15.12.3](jls-15.html#jls-15.12.3 "15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?")), then:
    
    *   If the invocation mode is `super` or `interface`, then this is the method to be invoked, and the procedure terminates.
        
    *   If the invocation mode is `virtual`, and the declaration in S overrides X`.``m` ([¬ß8.4.8.1](jls-8.html#jls-8.4.8.1 "8.4.8.1. Overriding (by Instance Methods)")), then the method declared in S is the method to be invoked, and the procedure terminates.
        
    
2.  Otherwise, if S has a superclass, the lookup procedure of steps 1 and 2 is performed recursively using the direct superclass of S in place of S; the method to be invoked, if any, is the result of the recursive invocation of this lookup procedure.
    
3.  If no method is found by the previous two steps, the superinterfaces of S are searched for a suitable method.
    
    A set of candidate methods is considered with the following properties: i) each method is declared in a (direct or indirect) superinterface of S; ii) each method has the name and descriptor required by the method invocation; iii) each method is non-`static`; iv) for each method, where the method's declaring interface is I, there is no other method satisfying (i) through (iii) that is declared in a subinterface of I.
    
    If this set contains a default method, one such method is the method to be invoked. Otherwise, an `abstract` method in the set is selected as the method to be invoked.
    

Dynamic method lookup may cause the following errors to occur:

*   If the method to be invoked is `abstract`, an `AbstractMethodError` is thrown.
*   If the method to be invoked is default, and more than one default method appears in the set of candidates in step 3 above, an `IncompatibleClassChangeError` is thrown.
*   If the invocation mode is `interface` and the selected method is not `public`, an `IllegalAccessError` is thrown.
    

The above procedure (if it terminates without error) will find a non-`abstract`, accessible method to invoke, provided that all classes and interfaces in the program have been consistently compiled. However, if this is not the case, then various errors may occur, as specified above; additional details about the behavior of the Java Virtual Machine under these circumstances are given by _The Java Virtual Machine Specification, Java SE 8 Edition_.

The dynamic lookup process, while described here explicitly, will often be implemented implicitly, for example as a side-effect of the construction and use of per-class method dispatch tables, or the construction of other per-class structures used for efficient dispatch.

**Example 15.12.4.4-1. Overriding and Method Invocation**

class Point {
    final int EDGE = 20;
    int x, y;
    void move(int dx, int dy) {
        x += dx; y += dy;
        if (Math.abs(x) >= EDGE || Math.abs(y) >= EDGE)
            clear();
    }
    void clear() {
        System.out.println("\\tPoint clear");
        x = 0; y = 0;
    }
}
class ColoredPoint extends Point {
    int color;
    void clear() {
        System.out.println("\\tColoredPoint clear");
        super.clear();
        color = 0;
    }
}

Here, the subclass `ColoredPoint` extends the `clear` abstraction defined by its superclass `Point`. It does so by overriding the `clear` method with its own method, which invokes the `clear` method of its superclass, using the form `super.clear()`.

This method is then invoked whenever the target object for an invocation of `clear` is a `ColoredPoint`. Even the method `move` in `Point` invokes the `clear` method of class `ColoredPoint` when the class of `this` is `ColoredPoint`, as shown by the output of this test program:

class Test1 {
    public static void main(String\[\] args) {
        Point p = new Point();
        System.out.println("p.move(20,20):");
        p.move(20, 20);

        ColoredPoint cp = new ColoredPoint();
        System.out.println("cp.move(20,20):");
        cp.move(20, 20);

        p = new ColoredPoint();
        System.out.println("p.move(20,20), p colored:");
        p.move(20, 20);
    }
}

which is:

p.move(20,20):
        Point clear
cp.move(20,20):
        ColoredPoint clear
        Point clear
p.move(20,20), p colored:
        ColoredPoint clear
        Point clear

Overriding is sometimes called "late-bound self-reference"; in this example it means that the reference to `clear` in the body of `Point.move` (which is really syntactic shorthand for `this.clear`) invokes a method chosen "late" (at run time, based on the run-time class of the object referenced by `this`) rather than a method chosen "early" (at compile time, based only on the type of `this`). This provides the programmer a powerful way of extending abstractions and is a key idea in object-oriented programming.

  

**Example 15.12.4.4-2. Method Invocation Using `super`**

An overridden instance method of a superclass may be accessed by using the keyword `super` to access the members of the immediate superclass, bypassing any overriding declaration in the class that contains the method invocation.

When accessing an instance variable, `super` means the same as a cast of `this` ([¬ß15.11.2](jls-15.html#jls-15.11.2 "15.11.2. Accessing Superclass Members using super")), but this equivalence does not hold true for method invocation. This is demonstrated by the example:

class T1 {
    String s() { return "1"; }
}
class T2 extends T1 {
    String s() { return "2"; }
}
class T3 extends T2 {
    String s() { return "3"; }
    void test() {
        System.out.println("s()=\\t\\t"          + s());
        System.out.println("super.s()=\\t"      + super.s());
        System.out.println("((T2)this).s()=\\t" + ((T2)this).s());
        System.out.println("((T1)this).s()=\\t" + ((T1)this).s());
    }
}
class Test2 {
    public static void main(String\[\] args) {
        T3 t3 = new T3();
        t3.test();
    }
}

which produces the output:

s()=            3
super.s()=      2
((T2)this).s()= 3
((T1)this).s()= 3

The casts to types `T1` and `T2` do not change the method that is invoked, because the instance method to be invoked is chosen according to the run-time class of the object referred to by `this`. A cast does not change the class of an object; it only checks that the class is compatible with the specified type.

  

#### 15.12.4.5. Create Frame, Synchronize, Transfer Control

A method `m` in some class S has been identified as the one to be invoked.

Now a new _activation frame_ is created, containing the target reference (if any) and the argument values (if any), as well as enough space for the local variables and stack for the method to be invoked and any other bookkeeping information that may be required by the implementation (stack pointer, program counter, reference to previous activation frame, and the like). If there is not sufficient memory available to create such an activation frame, a `StackOverflowError` is thrown.

The newly created activation frame becomes the current activation frame. The effect of this is to assign the argument values to corresponding freshly created parameter variables of the method, and to make the target reference available as `this`, if there is a target reference. Before each argument value is assigned to its corresponding parameter variable, it is subjected to invocation conversion ([¬ß5.3](jls-5.html#jls-5.3 "5.3. Invocation Contexts")), which includes any required value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")).

If the erasure ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of the type of the method being invoked differs in its signature from the erasure of the type of the compile-time declaration for the method invocation ([¬ß15.12.3](jls-15.html#jls-15.12.3 "15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?")), then if any of the argument values is an object which is not an instance of a subclass or subinterface of the erasure of the corresponding formal parameter type in the compile-time declaration for the method invocation, then a `ClassCastException` is thrown.

If the method `m` is a `native` method but the necessary native, implementation-dependent binary code has not been loaded or otherwise cannot be dynamically linked, then an `UnsatisfiedLinkError` is thrown.

If the method `m` is not `synchronized`, control is transferred to the body of the method `m` to be invoked.

If the method `m` is `synchronized`, then an object must be locked before the transfer of control. No further progress can be made until the current thread can obtain the lock. If there is a target reference, then the target object must be locked; otherwise the `Class` object for class S, the class of the method `m`, must be locked. Control is then transferred to the body of the method `m` to be invoked. The object is automatically unlocked when execution of the body of the method has completed, whether normally or abruptly. The locking and unlocking behavior is exactly as if the body of the method were embedded in a `synchronized` statement ([¬ß14.19](jls-14.html#jls-14.19 "14.19. The synchronized Statement")).

**Example 15.12.4.5-1. Invoked Method Signature Has Different Erasure Than Compile-Time Method Signature**

Consider the declarations:

abstract class C<T> {
    abstract T id(T x);
}
class D extends C<String> {
    String id(String x) { return x; }
}

Now, given an invocation:

C c = new D();
c.id(new Object());  // fails with a ClassCastException

The erasure of the actual method being invoked, `D.id()`, differs in its signature from that of the compile-time method declaration, `C.id()`. The former takes an argument of type `String` while the latter takes an argument of type `Object`. The invocation fails with a `ClassCastException` before the body of the method is executed.

Such situations can only arise if the program gives rise to a compile-time unchecked warning ([¬ß4.8](jls-4.html#jls-4.8 "4.8. Raw Types"), [¬ß5.1.9](jls-5.html#jls-5.1.9 "5.1.9. Unchecked Conversion"), [¬ß5.5.2](jls-5.html#jls-5.5.2 "5.5.2. Checked Casts and Unchecked Casts"), [¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"), [¬ß8.4.8.3](jls-8.html#jls-8.4.8.3 "8.4.8.3. Requirements in Overriding and Hiding"), [¬ß8.4.8.4](jls-8.html#jls-8.4.8.4 "8.4.8.4. Inheriting Methods with Override-Equivalent Signatures"), [¬ß9.4.1.2](jls-9.html#jls-9.4.1.2 "9.4.1.2. Requirements in Overriding"), [¬ß15.12.4.2](jls-15.html#jls-15.12.4.2 "15.12.4.2. Evaluate Arguments")).

Implementations can enforce these semantics by creating _bridge methods_. In the above example, the following bridge method would be created in class `D`:

Object id(Object x) { return id((String) x); }

This is the method that would actually be invoked by the Java Virtual Machine in response to the call `c.id(new Object())` shown above, and it will execute the cast and fail, as required.

  

15.13. Method Reference Expressions
-----------------------------------

A method reference expression is used to refer to the invocation of a method without actually performing the invocation. Certain forms of method reference expression also allow class instance creation ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")) or array creation ([¬ß15.10](jls-15.html#jls-15.10 "15.10. Array Creation and Access Expressions")) to be treated as if it were a method invocation.

MethodReference:

[ExpressionName](jls-6.html#jls-ExpressionName "ExpressionName") `::` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier")  
[ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType") `::` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier")  
[Primary](jls-15.html#jls-Primary "Primary") `::` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier")  
`super` `::` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier")  
[TypeName](jls-6.html#jls-TypeName "TypeName") `.` `super` `::` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier")  
[ClassType](jls-4.html#jls-ClassType "ClassType") `::`\[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] `new`  
[ArrayType](jls-4.html#jls-ArrayType "ArrayType") `::` `new`

If _TypeArguments_ is present to the right of `::`, then it is a compile-time error if any of the type arguments are wildcards ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")).

If a method reference expression has the form _ExpressionName_ `::` _\[TypeArguments\]_ _Identifier_ or _Primary_ `::` _\[TypeArguments\]_ _Identifier_, it is a compile-time error if the type of the _ExpressionName_ or _Primary_ is not a reference type.

If a method reference expression has the form `super` `::` _\[TypeArguments\]_ _Identifier_, let T be the type declaration immediately enclosing the method reference expression. It is a compile-time error if T is the class `Object` or T is an interface.

If a method reference expression has the form _TypeName_ `.` `super` `::` _\[TypeArguments\]_ _Identifier_, then:

*   If _TypeName_ denotes a class, C, then it is a compile-time error if C is not a lexically enclosing class of the current class, or if C is the class `Object`.
*   If _TypeName_ denotes an interface, I, then let T be the type declaration immediately enclosing the method reference expression. It is a compile-time error if I is not a direct superinterface of T, or if there exists some other direct superclass or direct superinterface of T, J, such that J is a subtype of I.
*   If _TypeName_ denotes a type variable, then a compile-time error occurs.
    

If a method reference expression has the form `super` `::` _\[TypeArguments\]_ _Identifier_ or _TypeName_ `.` `super` `::` _\[TypeArguments\]_ _Identifier_, it is a compile-time error if the expression occurs in a static context.

If a method reference expression has the form _ClassType_ `::` _\[TypeArguments\]_ `new`, then:

*   _ClassType_ must denote a class that is accessible, non-`abstract`, and not an enum type, or a compile-time error occurs.
*   If _ClassType_ denotes a parameterized type ([¬ß4.5](jls-4.html#jls-4.5 "4.5. Parameterized Types")), then it is a compile-time error if any of its type arguments are wildcards.
*   If _ClassType_ denotes a raw type ([¬ß4.8](jls-4.html#jls-4.8 "4.8. Raw Types")), then it is a compile-time error if _TypeArguments_ is present after the `::`.
    

If a method reference expression has the form _ArrayType_ `::` `new`, then _ArrayType_ must denote a type that is reifiable ([¬ß4.7](jls-4.html#jls-4.7 "4.7. Reifiable Types")), or a compile-time error occurs.

The target reference of an instance method ([¬ß15.12.4.1](jls-15.html#jls-15.12.4.1 "15.12.4.1. Compute Target Reference (If Necessary)")) may be provided by the method reference expression using an _ExpressionName_, a _Primary_, or `super`, or it may be provided later when the method is invoked. The immediately enclosing instance of a new inner class instance ([¬ß15.9.2](jls-15.html#jls-15.9.2 "15.9.2. Determining Enclosing Instances")) is provided by a lexically enclosing instance of `this` ([¬ß8.1.3](jls-8.html#jls-8.1.3 "8.1.3. Inner Classes and Enclosing Instances")).

When more than one member method of a type has the same name, or when a class has more than one constructor, the appropriate method or constructor is selected based on the functional interface type targeted by the expression, as specified in [¬ß15.13.1](jls-15.html#jls-15.13.1 "15.13.1. Compile-Time Declaration of a Method Reference").

If a method or constructor is generic, the appropriate type arguments may either be inferred or provided explicitly. Similarly, the type arguments of a generic type mentioned by the method reference expression may be provided explicitly or inferred.

Method reference expressions are always poly expressions ([¬ß15.2](jls-15.html#jls-15.2 "15.2. Forms of Expressions")).

It is a compile-time error if a method reference expression occurs in a program in someplace other than an assignment context ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")), an invocation context ([¬ß5.3](jls-5.html#jls-5.3 "5.3. Invocation Contexts")), or a casting context ([¬ß5.5](jls-5.html#jls-5.5 "5.5. Casting Contexts")).

Evaluation of a method reference expression produces an instance of a functional interface type ([¬ß9.8](jls-9.html#jls-9.8 "9.8. Functional Interfaces")). Method reference evaluation does _not_ cause the execution of the corresponding method; instead, this may occur at a later time when an appropriate method of the functional interface is invoked.

Here are some method reference expressions, first with no target reference and then with a target reference:

String::length             // instance method
System::currentTimeMillis  // static method
List<String>::size  // explicit type arguments for generic type
List::size          // inferred type arguments for generic type
int\[\]::clone
T::tvarMember

System.out::println
"abc"::length
foo\[x\]::bar
(test ? list.replaceAll(String::trim) : list) :: iterator
super::toString

Here are some more method reference expressions:

String::valueOf       // overload resolution needed     
Arrays::sort          // type arguments inferred from context
Arrays::<String>sort  // explicit type arguments

Here are some method reference expressions that represent a deferred creation of an object or an array:

ArrayList<String>::new     // constructor for parameterized type
ArrayList::new             // inferred type arguments
                           // for generic class
Foo::<Integer>new          // explicit type arguments
                           // for generic constructor
Bar<String>::<Integer>new  // generic class, generic constructor
Outer.Inner::new           // inner class constructor
int\[\]::new                 // array creation

It is not possible to specify a particular signature to be matched, for example, `Arrays::sort(int[])`. Instead, the functional interface provides argument types that are used as input to the overload resolution algorithm ([¬ß15.12.2](jls-15.html#jls-15.12.2 "15.12.2. Compile-Time Step 2: Determine Method Signature")). This should satisfy the vast majority of use cases; when the rare need arises for more precise control, a lambda expression can be used.

The use of type argument syntax in the class name before a delimiter (`List<String>::size`) raises the parsing problem of distinguishing between `<` as a type argument bracket and `<` as a less-than operator. In theory, this is no worse than allowing type arguments in cast expressions; however, the difference is that the cast case only comes up when a `(` token is encountered; with the addition of method reference expressions, the start of _every_ expression is potentially a parameterized type.

### 15.13.1. Compile-Time Declaration of a Method Reference

The _compile-time declaration_ of a method reference is the method to which the expression refers. In special cases, the compile-time declaration does not actually exist, but is a notional method that represents a class instance creation or an array creation. The choice of compile-time declaration depends on a function type targeted by the expression, just as the compile-time declaration of a method invocation depends on the invocation's arguments ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")).

The search for a compile-time declaration mirrors the process for method invocations in [¬ß15.12.1](jls-15.html#jls-15.12.1 "15.12.1. Compile-Time Step 1: Determine Class or Interface to Search") and [¬ß15.12.2](jls-15.html#jls-15.12.2 "15.12.2. Compile-Time Step 2: Determine Method Signature"), as follows:

*   First, a type to search is determined:
    
    *   If the method reference expression has the form _ExpressionName_ `::` _\[TypeArguments\]_ _Identifier_ or _Primary_ `::` _\[TypeArguments\]_ _Identifier_, the type to search is the type of the expression preceding the `::` token.
        
    *   If the method reference expression has the form _ReferenceType_ `::` _\[TypeArguments\]_ _Identifier_, the type to search is the result of capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")) applied to _ReferenceType_.
        
    *   If the method reference expression has the form `super` `::` _\[TypeArguments\]_ _Identifier_, the type to search is the superclass type of the class whose declaration contains the method reference.
        
    *   If the method reference expression has the form _TypeName_ `.` `super` `::` _\[TypeArguments\]_ _Identifier_, then if _TypeName_ denotes a class, the type to search is the superclass type of the named class; otherwise, _TypeName_ denotes an interface, and the corresponding superinterface type of the class or interface whose declaration contains the method reference is the type to search.
        
    *   For the two other forms (involving `::` `new`), the referenced method is notional and there is no type to search.
        
*   Second, given a targeted function type with _n_ parameters, a set of potentially applicable methods is identified:
    
    *   If the method reference expression has the form _ReferenceType_ `::` _\[TypeArguments\]_ _Identifier_, the potentially applicable methods are the member methods of the type to search that have an appropriate name (given by _Identifier_), accessibility, arity (_n_ or _n-1_), and type argument arity (derived from _\[TypeArguments\]_), as specified in [¬ß15.12.2.1](jls-15.html#jls-15.12.2.1 "15.12.2.1. Identify Potentially Applicable Methods").
        
        Two different arities, _n_ and _n-1_, are considered, to account for the possibility that this form refers to either a `static` method or an instance method.
        
    *   If the method reference expression has the form _ClassType_ `::` _\[TypeArguments\]_ `new`, the potentially applicable methods are a set of notional methods corresponding to the constructors of _ClassType_.
        
        If _ClassType_ is a raw type, but is not a non-`static` member type of a raw type, the candidate notional member methods are those specified in [¬ß15.9.3](jls-15.html#jls-15.9.3 "15.9.3. Choosing the Constructor and its Arguments") for a class instance creation expression that uses `<>` to elide the type arguments to a class.
        
        Otherwise, the candidate notional member methods are the constructors of _ClassType_, treated as if they were methods with return type _ClassType_. Among these candidates, the methods with appropriate accessibility, arity (_n_), and type argument arity (derived from _\[TypeArguments\]_) are selected, as specified in [¬ß15.12.2.1](jls-15.html#jls-15.12.2.1 "15.12.2.1. Identify Potentially Applicable Methods").
        
    *   If the method reference expression has the form _ArrayType_ `::` `new`, a single notional method is considered. The method has a single parameter of type `int`, returns the _ArrayType_, and has no `throws` clause. If _n = 1_, this is the only potentially applicable method; otherwise, there are no potentially applicable methods.
        
    *   For all other forms, the potentially applicable methods are the member methods of the type to search that have an appropriate name (given by _Identifier_), accessibility, arity (_n_), and type argument arity (derived from _\[TypeArguments\]_), as specified in [¬ß15.12.2.1](jls-15.html#jls-15.12.2.1 "15.12.2.1. Identify Potentially Applicable Methods").
        
*   Finally, if there are no potentially applicable methods, then there is no compile-time declaration.
    
    Otherwise, given a targeted function type with parameter types P1, ..., Pn and a set of potentially applicable methods, the compile-time declaration is selected as follows:
    
    *   If the method reference expression has the form _ReferenceType_ `::` _\[TypeArguments\]_ _Identifier_, then two searches for a most specific applicable method are performed. Each search is as specified in [¬ß15.12.2.2](jls-15.html#jls-15.12.2.2 "15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation") through [¬ß15.12.2.5](jls-15.html#jls-15.12.2.5 "15.12.2.5. Choosing the Most Specific Method"), with the clarifications below. Each search may produce a method or, in the case of an error as specified in [¬ß15.12.2.2](jls-15.html#jls-15.12.2.2 "15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation") through [¬ß15.12.2.5](jls-15.html#jls-15.12.2.5 "15.12.2.5. Choosing the Most Specific Method"), no result.
        
        In the first search, the method reference is treated as if it were an invocation with argument expressions of types P1, ..., Pn; the type arguments, if any, are given by the method reference expression.
        
        In the second search, if P1, ..., Pn is not empty and P1 is a subtype of _ReferenceType_, then the method reference expression is treated as if it were a method invocation expression with argument expressions of types P2, ..., Pn. If _ReferenceType_ is a raw type, and there exists a parameterization of this type, G`<`...`>`, that is a supertype of P1, the type to search is the result of capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")) applied to G`<`...`>`; otherwise, the type to search is the same as the type of the first search. Again, the type arguments, if any, are given by the method reference expression.
        
        If the first search produces a `static` method, and no non-`static` method is applicable by [¬ß15.12.2.2](jls-15.html#jls-15.12.2.2 "15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation"), [¬ß15.12.2.3](jls-15.html#jls-15.12.2.3 "15.12.2.3. Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation"), or [¬ß15.12.2.4](jls-15.html#jls-15.12.2.4 "15.12.2.4. Phase 3: Identify Methods Applicable by Variable Arity Invocation") during the second search, then the compile-time declaration is the result of the first search.
        
        Otherwise, if no `static` method is applicable by [¬ß15.12.2.2](jls-15.html#jls-15.12.2.2 "15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation"), [¬ß15.12.2.3](jls-15.html#jls-15.12.2.3 "15.12.2.3. Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation"), or [¬ß15.12.2.4](jls-15.html#jls-15.12.2.4 "15.12.2.4. Phase 3: Identify Methods Applicable by Variable Arity Invocation") during the first search, and the second search produces a non-`static` method, then the compile-time declaration is the result of the second search.
        
        Otherwise, there is no compile-time declaration.
        
    *   For all other forms of method reference expression, one search for a most specific applicable method is performed. The search is as specified in [¬ß15.12.2.2](jls-15.html#jls-15.12.2.2 "15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation") through [¬ß15.12.2.5](jls-15.html#jls-15.12.2.5 "15.12.2.5. Choosing the Most Specific Method"), with the clarifications below.
        
        The method reference is treated as if it were an invocation with argument expressions of types P1, ..., Pn; the type arguments, if any, are given by the method reference expression.
        
        If the search results in an error as specified in [¬ß15.12.2.2](jls-15.html#jls-15.12.2.2 "15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation") through [¬ß15.12.2.5](jls-15.html#jls-15.12.2.5 "15.12.2.5. Choosing the Most Specific Method"), or if the most specific applicable method is `static`, there is no compile-time declaration.
        
        Otherwise, the compile-time declaration is the most specific applicable method.
        
    

It is a compile-time error if a method reference expression has the form _ReferenceType_ `::` _\[TypeArguments\]_ _Identifier_, and the compile-time declaration is `static`, and _ReferenceType_ is not a simple or qualified name ([¬ß6.2](jls-6.html#jls-6.2 "6.2. Names and Identifiers")).

It is a compile-time error if the method reference expression has the form `super` `::` _\[TypeArguments\]_ _Identifier_ or _TypeName_ `.` `super` `::` _\[TypeArguments\]_ _Identifier_, and the compile-time declaration is `abstract`.

It is a compile-time error if the method reference expression has the form _TypeName_ `.` `super` `::` _\[TypeArguments\]_ _Identifier_, and _TypeName_ denotes an interface, and there exists a method, distinct from the compile-time declaration, that overrides ([¬ß8.4.8](jls-8.html#jls-8.4.8 "8.4.8. Inheritance, Overriding, and Hiding"), [¬ß9.4.1](jls-9.html#jls-9.4.1 "9.4.1. Inheritance and Overriding")) the compile-time declaration from a direct superclass or direct superinterface of the type whose declaration immediately encloses the method reference expression.

It is a compile-time error if the method reference expression is of the form _ClassType_ `::` _\[TypeArguments\]_ `new` and a compile-time error would occur when determining an enclosing instance for _ClassType_ as specified in [¬ß15.9.2](jls-15.html#jls-15.9.2 "15.9.2. Determining Enclosing Instances") (treating the method reference expression as if it were an unqualified class instance creation expression).

A method reference expression of the form _ReferenceType_ `::` _\[TypeArguments\]_ _Identifier_ can be interpreted in different ways. If _Identifier_ refers to an instance method, then the implicit lambda expression has an extra parameter compared to if _Identifier_ refers to a `static` method. It is possible for _ReferenceType_ to have both kinds of applicable methods, so the search algorithm described above identifies them separately, since there are different parameter types for each case.

An example of ambiguity is:

interface Fun<T,R> { R apply(T arg); }

class C {
    int size() { return 0; }
    static int size(Object arg) { return 0; }

    void test() {
        Fun<C, Integer> f1 = C::size;
          // Error: instance method size()
          // or static method size(Object)?
    }
}

This ambiguity cannot be resolved by providing an applicable instance method which is more specific than an applicable `static` method:

interface Fun<T,R> { R apply(T arg); }

class C {
    int size() { return 0; }
    static int size(Object arg) { return 0; }
    int size(C arg) { return 0; }

    void test() {
        Fun<C, Integer> f1 = C::size;
          // Error: instance method size()
          // or static method size(Object)?
    }
}

The search is smart enough to ignore ambiguities in which all the applicable methods (from both searches) are instance methods:

interface Fun<T,R> { R apply(T arg); }

class C {
    int size() { return 0; }
    int size(Object arg) { return 0; }
    int size(C arg) { return 0; }

    void test() {
        Fun<C, Integer> f1 = C::size;
          // OK: reference is to instance method size()
    }
}

For convenience, when the name of a generic type is used to refer to an instance method (where the receiver becomes the first parameter), the target type is used to determine the type arguments. This facilitates usage like `Pair::first` in place of `Pair<String,Integer>::first`. Similarly, a method reference like `Pair::new` is treated like a "diamond" instance creation (`new Pair<>()`). Because the "diamond" is implicit, this form does _not_ instantiate a raw type; in fact, there is no way to express a reference to the constructor of a raw type.

For some method reference expressions, there is only one possible compile-time declaration with only one possible invocation type ([¬ß15.12.2.6](jls-15.html#jls-15.12.2.6 "15.12.2.6. Method Invocation Type")), regardless of the targeted function type. Such method reference expressions are said to be _exact_. A method reference expression that is not exact is said to be _inexact_.

A method reference expression ending with _Identifier_ is exact if it satisfies all of the following:

*   If the method reference expression has the form _ReferenceType_ `::` _\[TypeArguments\]_ _Identifier_, then _ReferenceType_ does not denote a raw type.
*   The type to search has exactly one member method with the name _Identifier_ that is accessible to the class or interface in which the method reference expression appears.
*   This method is not variable arity ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters")).
*   If this method is generic ([¬ß8.4.4](jls-8.html#jls-8.4.4 "8.4.4. Generic Methods")), then the method reference expression provides _TypeArguments_.
    

A method reference expression of the form _ClassType_ `::` _\[TypeArguments\]_ `new` is exact if it satisfies all of the following:

*   The type denoted by _ClassType_ is not raw, or is a non-`static` member type of a raw type.
*   The type denoted by _ClassType_ has exactly one constructor that is accessible to the class or interface in which the method reference expression appears.
*   This constructor is not variable arity.
*   If this constructor is generic, then the method reference expression provides _TypeArguments_.
    

A method reference expression of the form _ArrayType_ `::` `new` is always exact.

### 15.13.2. Type of a Method Reference

A method reference expression is compatible in an assignment context, invocation context, or casting context with a target type T if T is a functional interface type ([¬ß9.8](jls-9.html#jls-9.8 "9.8. Functional Interfaces")) and the expression is _congruent_ with the function type of the _ground target type_ derived from T.

The _ground target type_ is derived from T as follows:

*   If T is a wildcard-parameterized functional interface type, then the ground target type is the non-wildcard parameterization ([¬ß9.9](jls-9.html#jls-9.9 "9.9. Function Types")) of T.
*   Otherwise, the ground target type is T.
    

A method reference expression is _congruent_ with a function type if both of the following are true:

*   The function type identifies a single compile-time declaration corresponding to the reference.
*   One of the following is true:
    
    *   The result of the function type is `void`.
        
    *   The result of the function type is R, and the result of applying capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")) to the return type of the invocation type ([¬ß15.12.2.6](jls-15.html#jls-15.12.2.6 "15.12.2.6. Method Invocation Type")) of the chosen compile-time declaration is R' (where R is the target type that may be used to infer R'), and neither R nor R' is `void`, and R' is compatible with R in an assignment context.
        
    

A compile-time unchecked warning occurs if unchecked conversion was necessary for the compile-time declaration to be applicable, and this conversion would cause an unchecked warning in an invocation context.

A compile-time unchecked warning occurs if unchecked conversion was necessary for the return type R', described above, to be compatible with the function type's return type, R, and this conversion would cause an unchecked warning in an assignment context.

If a method reference expression is compatible with a target type T, then the type of the expression, U, is the ground target type derived from T.

It is a compile-time error if any class or interface mentioned by either U or the function type of U is not accessible from the class or interface in which the method reference expression appears.

For each non-`static` member method `m` of U, if the function type of U has a subsignature of the signature of `m`, then a notional method whose method type is the function type of U is said to override `m`, and any compile-time error or unchecked warning specified in [¬ß8.4.8.3](jls-8.html#jls-8.4.8.3 "8.4.8.3. Requirements in Overriding and Hiding") may occur.

For each checked exception type X listed in the `throws` clause of the invocation type of the compile-time declaration, X or a superclass of X must be mentioned in the `throws` clause of the function type of U, or a compile-time error occurs.

The key idea driving the compatibility definition is that a method reference is compatible if and only if the equivalent lambda expression ``(x, y, z) `->` exp.<T1, T2>method(x, y, z)`` is compatible. (This is informal, and there are issues that make it difficult or impossible to formally define the semantics in terms of such a rewrite.)

These compatibility rules provide a convenient facility for converting from one functional interface to another:

Task t = () `->` System.out.println("hi");
Runnable r = t::invoke;

The implementation may be optimized so that when a lambda-derived object is passed around and converted to various types, this does not result in many levels of adaptation logic around the core lambda body.

Unlike a lambda expression, a method reference can be congruent with a generic function type (that is, a function type that has type parameters). This is because the lambda expression would need to be able to declare type parameters, and no syntax supports this; while for a method reference, no such declaration is necessary. For example, the following program is legal:

interface ListFactory {
    <T> List<T> make();
}

ListFactory lf  = ArrayList::new;
List<String> ls = lf.make();
List<Number> ln = lf.make();

### 15.13.3. Run-Time Evaluation of Method References

At run time, evaluation of a method reference expression is similar to evaluation of a class instance creation expression, insofar as normal completion produces a reference to an object. Evaluation of a method reference expression is distinct from invocation of the method itself.

First, if the method reference expression begins with an _ExpressionName_ or a _Primary_, this subexpression is evaluated. If the subexpression evaluates to `null`, a `NullPointerException` is raised, and the method reference expression completes abruptly. If the subexpression completes abruptly, the method reference expression completes abruptly for the same reason.

Next, either a new instance of a class with the properties below is allocated and initialized, or an existing instance of a class with the properties below is referenced. If a new instance is to be created, but there is insufficient space to allocate the object, evaluation of the method reference expression completes abruptly by throwing an `OutOfMemoryError`.

The value of a method reference expression is a reference to an instance of a class with the following properties:

*   The class implements the targeted functional interface type and, if the target type is an intersection type, every other interface type mentioned in the intersection.
*   Where the method reference expression has type U, for each non-`static` member method `m` of U:
    
    If the function type of U has a subsignature of the signature of `m`, then the class declares an _invocation method_ that overrides `m`. The invocation method's body invokes the referenced method, creates a class instance, or creates an array, as described below. If the invocation method's result is not `void`, then the body returns the result of the method invocation or object creation, after any necessary assignment conversions ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")).
    
    If the erasure of the type of a method being overridden differs in its signature from the erasure of the function type of U, then before the method invocation or object creation, an invocation method's body checks that each argument value is an instance of a subclass or subinterface of the erasure of the corresponding parameter type in the function type of U; if not, a `ClassCastException` is thrown.
*   The class overrides no other methods of the functional interface type or other interface types mentioned above, although it may override methods of the `Object` class.
    

The body of an invocation method depends on the form of the method reference expression, as follows:

*   If the form is _ExpressionName_ `::` _\[TypeArguments\]_ _Identifier_ or _Primary_ `::` _\[TypeArguments\]_ _Identifier_, then the body of the invocation method has the effect of a method invocation expression for a compile-time declaration which is the compile-time declaration of the method reference expression. Run-time evaluation of the method invocation expression is as specified in [¬ß15.12.4.3](jls-15.html#jls-15.12.4.3 "15.12.4.3. Check Accessibility of Type and Method"), [¬ß15.12.4.4](jls-15.html#jls-15.12.4.4 "15.12.4.4. Locate Method to Invoke"), and [¬ß15.12.4.5](jls-15.html#jls-15.12.4.5 "15.12.4.5. Create Frame, Synchronize, Transfer Control"), where:
    
    *   The invocation mode is derived from the compile-time declaration as specified in [¬ß15.12.3](jls-15.html#jls-15.12.3 "15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?").
        
    *   The target reference is the value of _ExpressionName_ or _Primary_, as determined when the method reference expression was evaluated.
        
    *   The arguments to the method invocation expression are the formal parameters of the invocation method.
        
*   If the form is _ReferenceType_ `::` _\[TypeArguments\]_ _Identifier_, the body of the invocation method similarly has the effect of a method invocation expression for a compile-time declaration which is the compile-time declaration of the method reference expression. Run-time evaluation of the method invocation expression is as specified in [¬ß15.12.4.3](jls-15.html#jls-15.12.4.3 "15.12.4.3. Check Accessibility of Type and Method"), [¬ß15.12.4.4](jls-15.html#jls-15.12.4.4 "15.12.4.4. Locate Method to Invoke"), and [¬ß15.12.4.5](jls-15.html#jls-15.12.4.5 "15.12.4.5. Create Frame, Synchronize, Transfer Control"), where:
    
    *   The invocation mode is derived from the compile-time declaration as specified in [¬ß15.12.3](jls-15.html#jls-15.12.3 "15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?").
        
    *   If the compile-time declaration is an instance method, then the target reference is the first formal parameter of the invocation method. Otherwise, there is no target reference.
        
    *   If the compile-time declaration is an instance method, then the arguments to the method invocation expression (if any) are the second and subsequent formal parameters of the invocation method. Otherwise, the arguments to the method invocation expression are the formal parameters of the invocation method.
        
*   If the form is `super` `::` _\[TypeArguments\]_ _Identifier_ or _TypeName_ `.` `super` `::` _\[TypeArguments\]_ _Identifier_, the body of the invocation method has the effect of a method invocation expression for a compile-time declaration which is the compile-time declaration of the method reference expression. Run-time evaluation of the method invocation expression is as specified in [¬ß15.12.4.3](jls-15.html#jls-15.12.4.3 "15.12.4.3. Check Accessibility of Type and Method"), [¬ß15.12.4.4](jls-15.html#jls-15.12.4.4 "15.12.4.4. Locate Method to Invoke"), and [¬ß15.12.4.5](jls-15.html#jls-15.12.4.5 "15.12.4.5. Create Frame, Synchronize, Transfer Control"), where:
    
    *   The invocation mode is `super`.
        
    *   If the method reference expression begins with a _TypeName_ that names a class, the target reference is the value of _TypeName_ `.` `this` at the point at which the method reference is evaluated. Otherwise, the target reference is the value of `this` at the point at which the method reference is evaluated.
        
    *   The arguments to the method invocation expression are the formal parameters of the invocation method.
        
*   If the form is _ClassType_ `::` _\[TypeArguments\]_ `new`, the body of the invocation method has the effect of a class instance creation expression of the form `new` _\[TypeArguments\]_ _ClassType_(A1, ..., An), where the arguments A1, ..., An are the formal parameters of the invocation method, and where:
    
    *   The enclosing instance for the new object, if any, is derived from the site of the method reference expression, as specified in [¬ß15.9.2](jls-15.html#jls-15.9.2 "15.9.2. Determining Enclosing Instances").
        
    *   The constructor to invoke is the constructor that corresponds to the compile-time declaration of the method reference ([¬ß15.13.1](jls-15.html#jls-15.13.1 "15.13.1. Compile-Time Declaration of a Method Reference")).
        
*   If the form is _Type`[]`k_ `::` `new` (_k_ ‚â• 1), then the body of the invocation method has the same effect as an array creation expression of the form `new` _Type `[` size `]` `[]`k-1_, where _size_ is the invocation method's single parameter. (The notation _`[]`k_ indicates a sequence of _k_ bracket pairs.)
    

If the body of the invocation method has the effect of a method invocation expression, then the compile-time parameter types and the compile-time result of the method invocation are determined as specified in [¬ß15.12.3](jls-15.html#jls-15.12.3 "15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?"). For the purpose of determining the compile-time result, the method invocation expression is an expression statement if the invocation method's result is `void`, and the _Expression_ of a `return` statement if the invocation method's result is non-`void`.

The effect of this determination when the compile-time declaration of the method reference is signature polymorphic is that:

*   The types of the parameters for the method invocation are the types of the corresponding arguments.
*   The method invocation is either `void` or has a return type of `Object`, depending on whether the invocation method which encloses the method invocation is `void` or has a return type.
    

The timing of method reference expression evaluation is more complex than that of lambda expressions ([¬ß15.27.4](jls-15.html#jls-15.27.4 "15.27.4. Run-Time Evaluation of Lambda Expressions")). When a method reference expression has an expression (rather than a type) preceding the `::` separator, that subexpression is evaluated immediately. The result of evaluation is stored until the method of the corresponding functional interface type is invoked; at that point, the result is used as the target reference for the invocation. This means the expression preceding the `::` separator is evaluated only when the program encounters the method reference expression, and is not re-evaluated on subsequent invocations on the functional interface type.

It is interesting to contrast the treatment of `null` here with its treatment during method invocation. When a method invocation expression is evaluated, it is possible for the _Primary_ that qualifies the invocation to evaluate to `null` but for no `NullPointerException` to be raised. This occurs when the invoked method is `static` (despite the syntax of the invocation suggesting an instance method). Since the applicable method for a method reference expression qualified by a _Primary_ is prohibited from being `static` ([¬ß15.13.1](jls-15.html#jls-15.13.1 "15.13.1. Compile-Time Declaration of a Method Reference")), the evaluation of the method reference expression is simpler - a `null` _Primary_ always raises a `NullPointerException`.

15.14. Postfix Expressions
--------------------------

Postfix expressions include uses of the postfix `++` and `--` operators. Names are not considered to be primary expressions ([¬ß15.8](jls-15.html#jls-15.8 "15.8. Primary Expressions")), but are handled separately in the grammar to avoid certain ambiguities. They become interchangeable only here, at the level of precedence of postfix expressions.

PostfixExpression:

[Primary](jls-15.html#jls-Primary "Primary")  
[ExpressionName](jls-6.html#jls-ExpressionName "ExpressionName")  
[PostIncrementExpression](jls-15.html#jls-PostIncrementExpression "PostIncrementExpression")  
[PostDecrementExpression](jls-15.html#jls-PostDecrementExpression "PostDecrementExpression")

### 15.14.1. Expression Names

The rules for evaluating expression names are given in [¬ß6.5.6](jls-6.html#jls-6.5.6 "6.5.6. Meaning of Expression Names").

### 15.14.2. Postfix Increment Operator `++`

A postfix expression followed by a `++` operator is a postfix increment expression.

PostIncrementExpression:

[PostfixExpression](jls-15.html#jls-PostfixExpression "PostfixExpression") `++`

The result of the postfix expression must be a variable of a type that is convertible ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) to a numeric type, or a compile-time error occurs.

The type of the postfix increment expression is the type of the variable. The result of the postfix increment expression is not a variable, but a value.

At run time, if evaluation of the operand expression completes abruptly, then the postfix increment expression completes abruptly for the same reason and no incrementation occurs. Otherwise, the value `1` is added to the value of the variable and the sum is stored back into the variable. Before the addition, binary numeric promotion ([¬ß5.6.2](jls-5.html#jls-5.6.2 "5.6.2. Binary Numeric Promotion")) is performed on the value `1` and the value of the variable. If necessary, the sum is narrowed by a narrowing primitive conversion ([¬ß5.1.3](jls-5.html#jls-5.1.3 "5.1.3. Narrowing Primitive Conversion")) and/or subjected to boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")) to the type of the variable before it is stored. The value of the postfix increment expression is the value of the variable _before_ the new value is stored.

Note that the binary numeric promotion mentioned above may include unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) and value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")). If necessary, value set conversion is applied to the sum prior to its being stored in the variable.

A variable that is declared `final` cannot be incremented because when an access of such a `final` variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a postfix increment operator.

### 15.14.3. Postfix Decrement Operator `--`

A postfix expression followed by a `--` operator is a postfix decrement expression.

PostDecrementExpression:

[PostfixExpression](jls-15.html#jls-PostfixExpression "PostfixExpression") `--`

The result of the postfix expression must be a variable of a type that is convertible ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) to a numeric type, or a compile-time error occurs.

The type of the postfix decrement expression is the type of the variable. The result of the postfix decrement expression is not a variable, but a value.

At run time, if evaluation of the operand expression completes abruptly, then the postfix decrement expression completes abruptly for the same reason and no decrementation occurs. Otherwise, the value `1` is subtracted from the value of the variable and the difference is stored back into the variable. Before the subtraction, binary numeric promotion ([¬ß5.6.2](jls-5.html#jls-5.6.2 "5.6.2. Binary Numeric Promotion")) is performed on the value `1` and the value of the variable. If necessary, the difference is narrowed by a narrowing primitive conversion ([¬ß5.1.3](jls-5.html#jls-5.1.3 "5.1.3. Narrowing Primitive Conversion")) and/or subjected to boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")) to the type of the variable before it is stored. The value of the postfix decrement expression is the value of the variable _before_ the new value is stored.

Note that the binary numeric promotion mentioned above may include unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) and value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")). If necessary, value set conversion is applied to the difference prior to its being stored in the variable.

A variable that is declared `final` cannot be decremented because when an access of such a `final` variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a postfix decrement operator.

15.15. Unary Operators
----------------------

The operators `+`, `-`, `++`, `--`, `~`, `!`, and the cast operator ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")) are called the _unary operators_.

UnaryExpression:

[PreIncrementExpression](jls-15.html#jls-PreIncrementExpression "PreIncrementExpression")  
[PreDecrementExpression](jls-15.html#jls-PreDecrementExpression "PreDecrementExpression")  
`+` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
`-` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
[UnaryExpressionNotPlusMinus](jls-15.html#jls-UnaryExpressionNotPlusMinus "UnaryExpressionNotPlusMinus")

PreIncrementExpression:

`++` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")

PreDecrementExpression:

`--` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")

UnaryExpressionNotPlusMinus:

[PostfixExpression](jls-15.html#jls-PostfixExpression "PostfixExpression")  
`~` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
`!` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
[CastExpression](jls-15.html#jls-CastExpression "CastExpression")

The following production from [¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions") is shown here for convenience:

CastExpression:

`(` [PrimitiveType](jls-4.html#jls-PrimitiveType "PrimitiveType") `)` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
`(` [ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType") {[AdditionalBound](jls-4.html#jls-AdditionalBound "AdditionalBound")} `)` [UnaryExpressionNotPlusMinus](jls-15.html#jls-UnaryExpressionNotPlusMinus "UnaryExpressionNotPlusMinus")  
`(` [ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType") {[AdditionalBound](jls-4.html#jls-AdditionalBound "AdditionalBound")} `)` [LambdaExpression](jls-15.html#jls-LambdaExpression "LambdaExpression")  

Expressions with unary operators group right-to-left, so that `-~x` means the same as `-(~x)`.

This portion of the grammar contains some tricks to avoid two potential syntactic ambiguities.

The first potential ambiguity would arise in expressions such as `(p)+q`, which looks, to a C or C++ programmer, as though it could be either a cast to type `p` of a unary `+` operating on `q`, or a binary addition of two quantities `p` and `q`. In C and C++, the parser handles this problem by performing a limited amount of semantic analysis as it parses, so that it knows whether `p` is the name of a type or the name of a variable.

Java takes a different approach. The result of the `+` operator must be numeric, and all type names involved in casts on numeric values are known keywords. Thus, if `p` is a keyword naming a primitive type, then `(p)+q` can make sense only as a cast of a unary expression. However, if `p` is not a keyword naming a primitive type, then `(p)+q` can make sense only as a binary arithmetic operation. Similar remarks apply to the `-` operator. The grammar shown above splits _CastExpression_ into two cases to make this distinction. The nonterminal _UnaryExpression_ includes all unary operators, but the nonterminal _UnaryExpressionNotPlusMinus_ excludes uses of all unary operators that could also be binary operators, which in Java are `+` and `-`.

The second potential ambiguity is that the expression `(p)++` could, to a C or C++ programmer, appear to be either a postfix increment of a parenthesized expression or the beginning of a cast, for example, in `(p)++q`. As before, parsers for C and C++ know whether `p` is the name of a type or the name of a variable. But a parser using only one-token lookahead and no semantic analysis during the parse would not be able to tell, when `++` is the lookahead token, whether `(p)` should be considered a _Primary_ expression or left alone for later consideration as part of a _CastExpression_.

In Java, the result of the `++` operator must be numeric, and all type names involved in casts on numeric values are known keywords. Thus, if `p` is a keyword naming a primitive type, then `(p)++` can make sense only as a cast of a prefix increment expression, and there had better be an operand such as `q` following the `++`. However, if `p` is not a keyword naming a primitive type, then `(p)++` can make sense only as a postfix increment of `p`. Similar remarks apply to the `--` operator. The nonterminal _UnaryExpressionNotPlusMinus_ therefore also excludes uses of the prefix operators `++` and `--`.

### 15.15.1. Prefix Increment Operator `++`

A unary expression preceded by a `++` operator is a prefix increment expression.

The result of the unary expression must be a variable of a type that is convertible ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) to a numeric type, or a compile-time error occurs.

The type of the prefix increment expression is the type of the variable. The result of the prefix increment expression is not a variable, but a value.

At run time, if evaluation of the operand expression completes abruptly, then the prefix increment expression completes abruptly for the same reason and no incrementation occurs. Otherwise, the value `1` is added to the value of the variable and the sum is stored back into the variable. Before the addition, binary numeric promotion ([¬ß5.6.2](jls-5.html#jls-5.6.2 "5.6.2. Binary Numeric Promotion")) is performed on the value `1` and the value of the variable. If necessary, the sum is narrowed by a narrowing primitive conversion ([¬ß5.1.3](jls-5.html#jls-5.1.3 "5.1.3. Narrowing Primitive Conversion")) and/or subjected to boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")) to the type of the variable before it is stored. The value of the prefix increment expression is the value of the variable _after_ the new value is stored.

Note that the binary numeric promotion mentioned above may include unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) and value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")). If necessary, value set conversion is applied to the sum prior to its being stored in the variable.

A variable that is declared `final` cannot be incremented because when an access of such a `final` variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a prefix increment operator.

### 15.15.2. Prefix Decrement Operator `--`

A unary expression preceded by a `--` operator is a prefix decrement expression.

The result of the unary expression must be a variable of a type that is convertible ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) to a numeric type, or a compile-time error occurs.

The type of the prefix decrement expression is the type of the variable. The result of the prefix decrement expression is not a variable, but a value.

At run time, if evaluation of the operand expression completes abruptly, then the prefix decrement expression completes abruptly for the same reason and no decrementation occurs. Otherwise, the value `1` is subtracted from the value of the variable and the difference is stored back into the variable. Before the subtraction, binary numeric promotion ([¬ß5.6.2](jls-5.html#jls-5.6.2 "5.6.2. Binary Numeric Promotion")) is performed on the value `1` and the value of the variable. If necessary, the difference is narrowed by a narrowing primitive conversion ([¬ß5.1.3](jls-5.html#jls-5.1.3 "5.1.3. Narrowing Primitive Conversion")) and/or subjected to boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")) to the type of the variable before it is stored. The value of the prefix decrement expression is the value of the variable _after_ the new value is stored.

Note that the binary numeric promotion mentioned above may include unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) and value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")). If necessary, format conversion is applied to the difference prior to its being stored in the variable.

A variable that is declared `final` cannot be decremented because when an access of such a `final` variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a prefix decrement operator.

### 15.15.3. Unary Plus Operator `+`

The type of the operand expression of the unary `+` operator must be a type that is convertible ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) to a primitive numeric type, or a compile-time error occurs.

Unary numeric promotion ([¬ß5.6.1](jls-5.html#jls-5.6.1 "5.6.1. Unary Numeric Promotion")) is performed on the operand. The type of the unary plus expression is the promoted type of the operand. The result of the unary plus expression is not a variable, but a value, even if the result of the operand expression is a variable.

At run time, the value of the unary plus expression is the promoted value of the operand.

### 15.15.4. Unary Minus Operator `-`

The type of the operand expression of the unary `-` operator must be a type that is convertible ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) to a primitive numeric type, or a compile-time error occurs.

Unary numeric promotion ([¬ß5.6.1](jls-5.html#jls-5.6.1 "5.6.1. Unary Numeric Promotion")) is performed on the operand.

The type of the unary minus expression is the promoted type of the operand.

Note that unary numeric promotion performs value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")). Whatever value set the promoted operand value is drawn from, the unary negation operation is carried out and the result is drawn from that same value set. That result is then subject to further value set conversion.

At run time, the value of the unary minus expression is the arithmetic negation of the promoted value of the operand.

For integer values, negation is the same as subtraction from zero. The Java programming language uses two's-complement representation for integers, and the range of two's-complement values is not symmetric, so negation of the maximum negative `int` or `long` results in that same maximum negative number. Overflow occurs in this case, but no exception is thrown. For all integer values `x`, `-x` equals `(~x)+1`.

For floating-point values, negation is _not_ the same as subtraction from zero, because if `x` is `+0.0`, then `0.0-x` is `+0.0`, but `-x` is `-0.0`. Unary minus merely inverts the sign of a floating-point number. Special cases of interest:

*   If the operand is NaN, the result is NaN. (Recall that NaN has no sign ([¬ß4.2.3](jls-4.html#jls-4.2.3 "4.2.3. Floating-Point Types, Formats, and Values")).)
*   If the operand is an infinity, the result is the infinity of opposite sign.
*   If the operand is a zero, the result is the zero of opposite sign.
    

### 15.15.5. Bitwise Complement Operator `~`

The type of the operand expression of the unary `~` operator must be a type that is convertible ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) to a primitive integral type, or a compile-time error occurs.

Unary numeric promotion ([¬ß5.6.1](jls-5.html#jls-5.6.1 "5.6.1. Unary Numeric Promotion")) is performed on the operand. The type of the unary bitwise complement expression is the promoted type of the operand.

At run time, the value of the unary bitwise complement expression is the bitwise complement of the promoted value of the operand. In all cases, `~x` equals `(-x)-1`.

### 15.15.6. Logical Complement Operator `!`

The type of the operand expression of the unary `!` operator must be `boolean` or `Boolean`, or a compile-time error occurs.

The type of the unary logical complement expression is `boolean`.

At run time, the operand is subject to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) if necessary. The value of the unary logical complement expression is `true` if the (possibly converted) operand value is `false`, and `false` if the (possibly converted) operand value is `true`.

15.16. Cast Expressions
-----------------------

A cast expression converts, at run time, a value of one numeric type to a similar value of another numeric type; or confirms, at compile time, that the type of an expression is `boolean`; or checks, at run time, that a reference value refers to an object whose class is compatible with a specified reference type or list of reference types.

The parentheses and the type or list of types they contain are sometimes called the _cast operator_.

CastExpression:

`(` [PrimitiveType](jls-4.html#jls-PrimitiveType "PrimitiveType") `)` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
`(` [ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType") {[AdditionalBound](jls-4.html#jls-AdditionalBound "AdditionalBound")} `)` [UnaryExpressionNotPlusMinus](jls-15.html#jls-UnaryExpressionNotPlusMinus "UnaryExpressionNotPlusMinus")  
`(` [ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType") {[AdditionalBound](jls-4.html#jls-AdditionalBound "AdditionalBound")} `)` [LambdaExpression](jls-15.html#jls-LambdaExpression "LambdaExpression")  

The following production from [¬ß4.4](jls-4.html#jls-4.4 "4.4. Type Variables") is shown here for convenience:

AdditionalBound:

`&` [InterfaceType](jls-4.html#jls-InterfaceType "InterfaceType")

If the cast operator contains a list of types - that is, a _ReferenceType_ followed by one or more _AdditionalBound_ terms - then all of the following must be true, or a compile-time error occurs:

*   _ReferenceType_ must denote a class or interface type.
*   The erasures ([¬ß4.6](jls-4.html#jls-4.6 "4.6. Type Erasure")) of all the listed types must be pairwise different.
*   No two listed types may be subtypes of different parameterizations of the same generic interface.
    

The target type for the casting context ([¬ß5.5](jls-5.html#jls-5.5 "5.5. Casting Contexts")) introduced by the cast expression is either the _PrimitiveType_ or the _ReferenceType_ (if not followed by _AdditionalBound_ terms) appearing in the cast operator, or the intersection type denoted by the _ReferenceType_ and _AdditionalBound_ terms appearing in the cast operator.

The type of a cast expression is the result of applying capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")) to this target type.

Casts can be used to explicitly "tag" a lambda expression or a method reference expression with a particular target type. To provide an appropriate degree of flexibility, the target type may be a list of types denoting an intersection type, provided the intersection induces a functional interface ([¬ß9.8](jls-9.html#jls-9.8 "9.8. Functional Interfaces")).

The result of a cast expression is not a variable, but a value, even if the result of the operand expression is a variable.

A cast operator has no effect on the choice of value set ([¬ß4.2.3](jls-4.html#jls-4.2.3 "4.2.3. Floating-Point Types, Formats, and Values")) for a value of type `float` or type `double`. Consequently, a cast to type `float` within an expression that is not FP-strict ([¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions")) does not necessarily cause its value to be converted to an element of the float value set, and a cast to type `double` within an expression that is not FP-strict does not necessarily cause its value to be converted to an element of the double value set.

It is a compile-time error if the compile-time type of the operand may never be cast to the type specified by the cast operator according to the rules of casting conversion ([¬ß5.5](jls-5.html#jls-5.5 "5.5. Casting Contexts")).

Otherwise, at run time, the operand value is converted (if necessary) by casting conversion to the type specified by the cast operator.

A `ClassCastException` is thrown if a cast is found at run time to be impermissible.

Some casts result in an error at compile time. Some casts can be proven, at compile time, always to be correct at run time. For example, it is always correct to convert a value of a class type to the type of its superclass; such a cast should require no special action at run time. Finally, some casts cannot be proven to be either always correct or always incorrect at compile time. Such casts require a test at run time. See [¬ß5.5](jls-5.html#jls-5.5 "5.5. Casting Contexts") for details.

15.17. Multiplicative Operators
-------------------------------

The operators `*`, `/`, and `%` are called the _multiplicative operators_.

MultiplicativeExpression:

[UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
[MultiplicativeExpression](jls-15.html#jls-MultiplicativeExpression "MultiplicativeExpression") `*` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
[MultiplicativeExpression](jls-15.html#jls-MultiplicativeExpression "MultiplicativeExpression") `/` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
[MultiplicativeExpression](jls-15.html#jls-MultiplicativeExpression "MultiplicativeExpression") `%` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")

The multiplicative operators have the same precedence and are syntactically left-associative (they group left-to-right).

The type of each of the operands of a multiplicative operator must be a type that is convertible ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) to a primitive numeric type, or a compile-time error occurs.

Binary numeric promotion is performed on the operands ([¬ß5.6.2](jls-5.html#jls-5.6.2 "5.6.2. Binary Numeric Promotion")).

Note that binary numeric promotion performs value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")) and may perform unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).

The type of a multiplicative expression is the promoted type of its operands.

If the promoted type is `int` or `long`, then integer arithmetic is performed.

If the promoted type is `float` or `double`, then floating-point arithmetic is performed.

### 15.17.1. Multiplication Operator `*`

The binary `*` operator performs multiplication, producing the product of its operands.

Multiplication is a commutative operation if the operand expressions have no side effects.

Integer multiplication is associative when the operands are all of the same type.

Floating-point multiplication is not associative.

If an integer multiplication overflows, then the result is the low-order bits of the mathematical product as represented in some sufficiently large two's-complement format. As a result, if overflow occurs, then the sign of the result may not be the same as the sign of the mathematical product of the two operand values.

The result of a floating-point multiplication is determined by the rules of IEEE 754 arithmetic:

*   If either operand is NaN, the result is NaN.
*   If the result is not NaN, the sign of the result is positive if both operands have the same sign, and negative if the operands have different signs.
*   Multiplication of an infinity by a zero results in NaN.
*   Multiplication of an infinity by a finite value results in a signed infinity. The sign is determined by the rule stated above.
*   In the remaining cases, where neither an infinity nor NaN is involved, the exact mathematical product is computed. A floating-point value set is then chosen:
    
    *   If the multiplication expression is FP-strict ([¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions")):
        
        *   If the type of the multiplication expression is `float`, then the float value set must be chosen.
            
        *   If the type of the multiplication expression is `double`, then the double value set must be chosen.
            
        
    *   If the multiplication expression is not FP-strict:
        
        *   If the type of the multiplication expression is `float`, then either the float value set or the float-extended-exponent value set may be chosen, at the whim of the implementation.
            
        *   If the type of the multiplication expression is `double`, then either the double value set or the double-extended-exponent value set may be chosen, at the whim of the implementation.
            
        
    
    Next, a value must be chosen from the chosen value set to represent the product.
    
    If the magnitude of the product is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign.
    
    Otherwise, the product is rounded to the nearest value in the chosen value set using IEEE 754 round-to-nearest mode. The Java programming language requires support of gradual underflow as defined by IEEE 754 ([¬ß4.2.4](jls-4.html#jls-4.2.4 "4.2.4. Floating-Point Operations")).
    

Despite the fact that overflow, underflow, or loss of information may occur, evaluation of a multiplication operator `*` never throws a run-time exception.

### 15.17.2. Division Operator `/`

The binary `/` operator performs division, producing the quotient of its operands. The left-hand operand is the _dividend_ and the right-hand operand is the _divisor_.

Integer division rounds toward `0`. That is, the quotient produced for operands _n_ and _d_ that are integers after binary numeric promotion ([¬ß5.6.2](jls-5.html#jls-5.6.2 "5.6.2. Binary Numeric Promotion")) is an integer value _q_ whose magnitude is as large as possible while satisfying |_d_ ‚ãÖ _q_| ‚â§ |_n_|. Moreover, _q_ is positive when |_n_| ‚â• |_d_| and _n_ and _d_ have the same sign, but _q_ is negative when |_n_| ‚â• |_d_| and _n_ and _d_ have opposite signs.

There is one special case that does not satisfy this rule: if the dividend is the negative integer of largest possible magnitude for its type, and the divisor is `-1`, then integer overflow occurs and the result is equal to the dividend. Despite the overflow, no exception is thrown in this case. On the other hand, if the value of the divisor in an integer division is `0`, then an `ArithmeticException` is thrown.

The result of a floating-point division is determined by the rules of IEEE 754 arithmetic:

*   If either operand is NaN, the result is NaN.
*   If the result is not NaN, the sign of the result is positive if both operands have the same sign, and negative if the operands have different signs.
*   Division of an infinity by an infinity results in NaN.
*   Division of an infinity by a finite value results in a signed infinity. The sign is determined by the rule stated above.
*   Division of a finite value by an infinity results in a signed zero. The sign is determined by the rule stated above.
*   Division of a zero by a zero results in NaN; division of zero by any other finite value results in a signed zero. The sign is determined by the rule stated above.
*   Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule stated above.
*   In the remaining cases, where neither an infinity nor NaN is involved, the exact mathematical quotient is computed. A floating-point value set is then chosen:
    
    *   If the division expression is FP-strict ([¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions")):
        
        *   If the type of the division expression is `float`, then the float value set must be chosen.
            
        *   If the type of the division expression is `double`, then the double value set must be chosen.
            
        
    *   If the division expression is not FP-strict:
        
        *   If the type of the division expression is `float`, then either the float value set or the float-extended-exponent value set may be chosen, at the whim of the implementation.
            
        *   If the type of the division expression is `double`, then either the double value set or the double-extended-exponent value set may be chosen, at the whim of the implementation.
            
        
    
    Next, a value must be chosen from the chosen value set to represent the quotient.
    
    If the magnitude of the quotient is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign.
    
    Otherwise, the quotient is rounded to the nearest value in the chosen value set using IEEE 754 round-to-nearest mode. The Java programming language requires support of gradual underflow as defined by IEEE 754 ([¬ß4.2.4](jls-4.html#jls-4.2.4 "4.2.4. Floating-Point Operations")).
    

Despite the fact that overflow, underflow, division by zero, or loss of information may occur, evaluation of a floating-point division operator `/` never throws a run-time exception.

### 15.17.3. Remainder Operator `%`

The binary `%` operator is said to yield the remainder of its operands from an implied division; the left-hand operand is the _dividend_ and the right-hand operand is the _divisor_.

In C and C++, the remainder operator accepts only integral operands, but in the Java programming language, it also accepts floating-point operands.

The remainder operation for operands that are integers after binary numeric promotion ([¬ß5.6.2](jls-5.html#jls-5.6.2 "5.6.2. Binary Numeric Promotion")) produces a result value such that `(a/b)*b+(a%b)` is equal to `a`.

This identity holds even in the special case that the dividend is the negative integer of largest possible magnitude for its type and the divisor is `-1` (the remainder is `0`).

It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative, and can be positive only if the dividend is positive. Moreover, the magnitude of the result is always less than the magnitude of the divisor.

If the value of the divisor for an integer remainder operator is `0`, then an `ArithmeticException` is thrown.

**Example 15.17.3-1. Integer Remainder Operator**

class Test1 {
    public static void main(String\[\] args) {
        int a = 5%3;  // 2
        int b = 5/3;  // 1
        System.out.println("5%3 produces " + a +
                           " (note that 5/3 produces " + b + ")");

        int c = 5%(-3);  // 2
        int d = 5/(-3);  // -1
        System.out.println("5%(-3) produces " + c +
                           " (note that 5/(-3) produces " + d + ")");

        int e = (-5)%3;  // -2
        int f = (-5)/3;  // -1
        System.out.println("(-5)%3 produces " + e +
                           " (note that (-5)/3 produces " + f + ")");

        int g = (-5)%(-3);  // -2
        int h = (-5)/(-3);  // 1
        System.out.println("(-5)%(-3) produces " + g +
                           " (note that (-5)/(-3) produces " + h + ")");
    }
}

This program produces the output:

5%3 produces 2 (note that 5/3 produces 1)
5%(-3) produces 2 (note that 5/(-3) produces -1)
(-5)%3 produces -2 (note that (-5)/3 produces -1)
(-5)%(-3) produces -2 (note that (-5)/(-3) produces 1)

  

The result of a floating-point remainder operation as computed by the `%` operator is _not_ the same as that produced by the remainder operation defined by IEEE 754. The IEEE 754 remainder operation computes the remainder from a rounding division, not a truncating division, and so its behavior is _not_ analogous to that of the usual integer remainder operator. Instead, the Java programming language defines `%` on floating-point operations to behave in a manner analogous to that of the integer remainder operator; this may be compared with the C library function `fmod`. The IEEE 754 remainder operation may be computed by the library routine `Math.IEEEremainder`.

The result of a floating-point remainder operation is determined by the rules of IEEE 754 arithmetic:

*   If either operand is NaN, the result is NaN.
*   If the result is not NaN, the sign of the result equals the sign of the dividend.
*   If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.
*   If the dividend is finite and the divisor is an infinity, the result equals the dividend.
*   If the dividend is a zero and the divisor is finite, the result equals the dividend.
*   In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the floating-point remainder _r_ from the division of a dividend _n_ by a divisor _d_ is defined by the mathematical relation _r_ = _n_ - (_d_ ‚ãÖ _q_) where _q_ is an integer that is negative only if _n_/_d_ is negative and positive only if _n_/_d_ is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of _n_ and _d_.
    

Evaluation of a floating-point remainder operator `%` never throws a run-time exception, even if the right-hand operand is zero. Overflow, underflow, or loss of precision cannot occur.

**Example 15.17.3-2. Floating-Point Remainder Operator**

class Test2 {
    public static void main(String\[\] args) {
        double a = 5.0%3.0;  // 2.0
        System.out.println("5.0%3.0 produces " + a);

        double b = 5.0%(-3.0);  // 2.0
        System.out.println("5.0%(-3.0) produces " + b);

        double c = (-5.0)%3.0;  // -2.0
        System.out.println("(-5.0)%3.0 produces " + c);

        double d = (-5.0)%(-3.0);  // -2.0
        System.out.println("(-5.0)%(-3.0) produces " + d);
    }
}

This program produces the output:

5.0%3.0 produces 2.0
5.0%(-3.0) produces 2.0
(-5.0)%3.0 produces -2.0
(-5.0)%(-3.0) produces -2.0

  

15.18. Additive Operators
-------------------------

The operators `+` and `-` are called the _additive operators_.

AdditiveExpression:

[MultiplicativeExpression](jls-15.html#jls-MultiplicativeExpression "MultiplicativeExpression")  
[AdditiveExpression](jls-15.html#jls-AdditiveExpression "AdditiveExpression") `+` [MultiplicativeExpression](jls-15.html#jls-MultiplicativeExpression "MultiplicativeExpression")  
[AdditiveExpression](jls-15.html#jls-AdditiveExpression "AdditiveExpression") `-` [MultiplicativeExpression](jls-15.html#jls-MultiplicativeExpression "MultiplicativeExpression")

The additive operators have the same precedence and are syntactically left-associative (they group left-to-right).

If the type of either operand of a `+` operator is `String`, then the operation is string concatenation.

Otherwise, the type of each of the operands of the `+` operator must be a type that is convertible ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) to a primitive numeric type, or a compile-time error occurs.

In every case, the type of each of the operands of the binary `-` operator must be a type that is convertible ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) to a primitive numeric type, or a compile-time error occurs.

### 15.18.1. String Concatenation Operator `+`

If only one operand expression is of type `String`, then string conversion ([¬ß5.1.11](jls-5.html#jls-5.1.11 "5.1.11. String Conversion")) is performed on the other operand to produce a string at run time.

The result of string concatenation is a reference to a `String` object that is the concatenation of the two operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in the newly created string.

The `String` object is newly created ([¬ß12.5](jls-12.html#jls-12.5 "12.5. Creation of New Class Instances")) unless the expression is a constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")).

An implementation may choose to perform conversion and concatenation in one step to avoid creating and then discarding an intermediate `String` object. To increase the performance of repeated string concatenation, a Java compiler may use the `StringBuffer` class or a similar technique to reduce the number of intermediate `String` objects that are created by evaluation of an expression.

For primitive types, an implementation may also optimize away the creation of a wrapper object by converting directly from a primitive type to a string.

**Example 15.18.1-1. String Concatenation**

The example expression:

"The square root of 2 is " + Math.sqrt(2)

produces the result:

"The square root of 2 is 1.4142135623730952"

The `+` operator is syntactically left-associative, no matter whether it is determined by type analysis to represent string concatenation or numeric addition. In some cases care is required to get the desired result. For example, the expression:

a + b + c

is always regarded as meaning:

(a + b) + c

Therefore the result of the expression:

1 + 2 + " fiddlers"

is:

"3 fiddlers"

but the result of:

"fiddlers " + 1 + 2

is:

"fiddlers 12"

  

**Example 15.18.1-2. String Concatenation and Conditionals**

In this jocular little example:

class Bottles {
    static void printSong(Object stuff, int n) {
        String plural = (n == 1) ? "" : "s";
  loop: while (true) {
            System.out.println(n + " bottle" + plural
                    + " of " + stuff + " on the wall,");
            System.out.println(n + " bottle" + plural
                    + " of " + stuff + ";");
            System.out.println("You take one down "
                    + "and pass it around:");
            --n;
            plural = (n == 1) ? "" : "s";
            if (n == 0)
                break loop;
            System.out.println(n + " bottle" + plural
                    + " of " + stuff + " on the wall!");
            System.out.println();
        }
        System.out.println("No bottles of " +
                    stuff + " on the wall!");
    }

    public static void main(String\[\] args) {
        printSong("slime", 3);
    }
}

the method `printSong` will print a version of a children's song. Popular values for `stuff` include "`pop`" and "`beer`"; the most popular value for `n` is `100`. Here is the output that results from running the program:

3 bottles of slime on the wall,
3 bottles of slime;
You take one down and pass it around:
2 bottles of slime on the wall!

2 bottles of slime on the wall,
2 bottles of slime;
You take one down and pass it around:
1 bottle of slime on the wall!

1 bottle of slime on the wall,
1 bottle of slime;
You take one down and pass it around:
No bottles of slime on the wall!

In the code, note the careful conditional generation of the singular "`bottle`" when appropriate rather than the plural "`bottles`"; note also how the string concatenation operator was used to break the long constant string:

"You take one down and pass it around:"

into two pieces to avoid an inconveniently long line in the source code.

  

### 15.18.2. Additive Operators (`+` and `-`) for Numeric Types

The binary `+` operator performs addition when applied to two operands of numeric type, producing the sum of the operands.

The binary `-` operator performs subtraction, producing the difference of two numeric operands.

Binary numeric promotion is performed on the operands ([¬ß5.6.2](jls-5.html#jls-5.6.2 "5.6.2. Binary Numeric Promotion")).

Note that binary numeric promotion performs value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")) and may perform unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).

The type of an additive expression on numeric operands is the promoted type of its operands.

If this promoted type is `int` or `long`, then integer arithmetic is performed.

If this promoted type is `float` or `double`, then floating-point arithmetic is performed.

Addition is a commutative operation if the operand expressions have no side effects.

Integer addition is associative when the operands are all of the same type.

Floating-point addition is not associative.

If an integer addition overflows, then the result is the low-order bits of the mathematical sum as represented in some sufficiently large two's-complement format. If overflow occurs, then the sign of the result is not the same as the sign of the mathematical sum of the two operand values.

The result of a floating-point addition is determined using the following rules of IEEE 754 arithmetic:

*   If either operand is NaN, the result is NaN.
*   The sum of two infinities of opposite sign is NaN.
*   The sum of two infinities of the same sign is the infinity of that sign.
*   The sum of an infinity and a finite value is equal to the infinite operand.
*   The sum of two zeros of opposite sign is positive zero.
*   The sum of two zeros of the same sign is the zero of that sign.
*   The sum of a zero and a nonzero finite value is equal to the nonzero operand.
*   The sum of two nonzero finite values of the same magnitude and opposite sign is positive zero.
*   In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, and the operands have the same sign or have different magnitudes, the exact mathematical sum is computed. A floating-point value set is then chosen:
    
    *   If the addition expression is FP-strict ([¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions")):
        
        *   If the type of the addition expression is `float`, then the float value set must be chosen.
            
        *   If the type of the addition expression is `double`, then the double value set must be chosen.
            
        
    *   If the addition expression is not FP-strict:
        
        *   If the type of the addition expression is `float`, then either the float value set or the float-extended-exponent value set may be chosen, at the whim of the implementation.
            
        *   If the type of the addition expression is `double`, then either the double value set or the double-extended-exponent value set may be chosen, at the whim of the implementation.
            
        
    
    Next, a value must be chosen from the chosen value set to represent the sum.
    
    If the magnitude of the sum is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign.
    
    Otherwise, the sum is rounded to the nearest value in the chosen value set using IEEE 754 round-to-nearest mode. The Java programming language requires support of gradual underflow as defined by IEEE 754 ([¬ß4.2.4](jls-4.html#jls-4.2.4 "4.2.4. Floating-Point Operations")).
    

The binary `-` operator performs subtraction when applied to two operands of numeric type, producing the difference of its operands; the left-hand operand is the _minuend_ and the right-hand operand is the _subtrahend_.

For both integer and floating-point subtraction, it is always the case that `a-b` produces the same result as `a+(-b)`.

Note that, for integer values, subtraction from zero is the same as negation. However, for floating-point operands, subtraction from zero is _not_ the same as negation, because if x is `+0.0`, then `0.0-x` is `+0.0`, but `-x` is `-0.0`.

Despite the fact that overflow, underflow, or loss of information may occur, evaluation of a numeric additive operator never throws a run-time exception.

15.19. Shift Operators
----------------------

The operators `<<` (left shift), `>>` (signed right shift), and `>>>` (unsigned right shift) are called the _shift operators_. The left-hand operand of a shift operator is the value to be shifted; the right-hand operand specifies the shift distance.

ShiftExpression:

[AdditiveExpression](jls-15.html#jls-AdditiveExpression "AdditiveExpression")  
[ShiftExpression](jls-15.html#jls-ShiftExpression "ShiftExpression") `<<` [AdditiveExpression](jls-15.html#jls-AdditiveExpression "AdditiveExpression")  
[ShiftExpression](jls-15.html#jls-ShiftExpression "ShiftExpression") `>>` [AdditiveExpression](jls-15.html#jls-AdditiveExpression "AdditiveExpression")  
[ShiftExpression](jls-15.html#jls-ShiftExpression "ShiftExpression") `>>>` [AdditiveExpression](jls-15.html#jls-AdditiveExpression "AdditiveExpression")

The shift operators are syntactically left-associative (they group left-to-right).

Unary numeric promotion ([¬ß5.6.1](jls-5.html#jls-5.6.1 "5.6.1. Unary Numeric Promotion")) is performed on each operand separately. (Binary numeric promotion ([¬ß5.6.2](jls-5.html#jls-5.6.2 "5.6.2. Binary Numeric Promotion")) is _not_ performed on the operands.)

It is a compile-time error if the type of each of the operands of a shift operator, after unary numeric promotion, is not a primitive integral type.

The type of the shift expression is the promoted type of the left-hand operand.

If the promoted type of the left-hand operand is `int`, then only the five lowest-order bits of the right-hand operand are used as the shift distance. It is as if the right-hand operand were subjected to a bitwise logical AND operator `&` ([¬ß15.22.1](jls-15.html#jls-15.22.1 "15.22.1. Integer Bitwise Operators &, ^, and |")) with the mask value `0x1f` (`0b11111`). The shift distance actually used is therefore always in the range `0` to `31`, inclusive.

If the promoted type of the left-hand operand is `long`, then only the six lowest-order bits of the right-hand operand are used as the shift distance. It is as if the right-hand operand were subjected to a bitwise logical AND operator `&` ([¬ß15.22.1](jls-15.html#jls-15.22.1 "15.22.1. Integer Bitwise Operators &, ^, and |")) with the mask value `0x3f` (`0b111111`). The shift distance actually used is therefore always in the range `0` to `63`, inclusive.

At run time, shift operations are performed on the two's-complement integer representation of the value of the left operand.

The value of _n_ `<<` _s_ is _n_ left-shifted _s_ bit positions; this is equivalent (even if overflow occurs) to multiplication by two to the power _s_.

The value of _n_ `>>` _s_ is _n_ right-shifted _s_ bit positions with sign-extension. The resulting value is _floor_(_n_ `/` 2_s_). For non-negative values of _n_, this is equivalent to truncating integer division, as computed by the integer division operator `/`, by two to the power _s_.

The value of _n_ `>>>` _s_ is _n_ right-shifted _s_ bit positions with zero-extension, where:

*   If _n_ is positive, then the result is the same as that of _n_ `>>` _s_.
*   If _n_ is negative and the type of the left-hand operand is `int`, then the result is equal to that of the expression `(`_n_ `>>` _s_`)` `+` `(``2` `<<` `~`code>_s_`)`.

*   If _n_ is negative and the type of the left-hand operand is `long`, then the result is equal to that of the expression `(`_n_ `>>` _s_`)` `+` `(``2L` `<<` `~`_s_`)`.
    

The added term `(``2` `<<` `~`_s_`)` or `(``2L` `<<` `~`_s_`)` cancels out the propagated sign bit.

Note that, because of the implicit masking of the right-hand operand of a shift operator, `~`_s_ as a shift distance is equivalent to `31-`_s_ when shifting an `int` value and to `63-`_s_ when shifting a `long` value.

15.20. Relational Operators
---------------------------

The numerical comparison operators `<`, `>`, `<=`, and `>=`, and the `instanceof` operator, are called the _relational operators_.

RelationalExpression:

[ShiftExpression](jls-15.html#jls-ShiftExpression "ShiftExpression")  
[RelationalExpression](jls-15.html#jls-RelationalExpression "RelationalExpression") `<` [ShiftExpression](jls-15.html#jls-ShiftExpression "ShiftExpression")  
[RelationalExpression](jls-15.html#jls-RelationalExpression "RelationalExpression") `>` [ShiftExpression](jls-15.html#jls-ShiftExpression "ShiftExpression")  
[RelationalExpression](jls-15.html#jls-RelationalExpression "RelationalExpression") `<=` [ShiftExpression](jls-15.html#jls-ShiftExpression "ShiftExpression")  
[RelationalExpression](jls-15.html#jls-RelationalExpression "RelationalExpression") `>=` [ShiftExpression](jls-15.html#jls-ShiftExpression "ShiftExpression")  
[RelationalExpression](jls-15.html#jls-RelationalExpression "RelationalExpression") `instanceof` [ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType")

The relational operators are syntactically left-associative (they group left-to-right).

However, this fact is not useful. For example, `a<b<c` parses as `(a<b)<c`, which is always a compile-time error, because the type of `a<b` is always `boolean` and < is not an operator on `boolean` values.

The type of a relational expression is always `boolean`.

### 15.20.1. Numerical Comparison Operators `<`, `<=`, `>`, and `>=`

The type of each of the operands of a numerical comparison operator must be a type that is convertible ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) to a primitive numeric type, or a compile-time error occurs.

Binary numeric promotion is performed on the operands ([¬ß5.6.2](jls-5.html#jls-5.6.2 "5.6.2. Binary Numeric Promotion")).

Note that binary numeric promotion performs value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")) and may perform unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).

If the promoted type of the operands is `int` or `long`, then signed integer comparison is performed.

If the promoted type is `float` or `double`, then floating-point comparison is performed.

Comparison is carried out accurately on floating-point values, no matter what value sets their representing values were drawn from.

The result of a floating-point comparison, as determined by the specification of the IEEE 754 standard, is:

*   If either operand is NaN, then the result is false.
*   All values other than NaN are ordered, with negative infinity less than all finite values, and positive infinity greater than all finite values.
*   Positive zero and negative zero are considered equal.
    
    For example, `-0.0<0.0` is `false`, but `-0.0<=0.0` is `true`.
    
    Note, however, that the methods `Math.min` and `Math.max` treat negative zero as being strictly smaller than positive zero.
    

Subject to these considerations for floating-point numbers, the following rules then hold for integer operands or for floating-point operands other than NaN:

*   The value produced by the `<` operator is `true` if the value of the left-hand operand is less than the value of the right-hand operand, and otherwise is `false`.
*   The value produced by the `<=` operator is `true` if the value of the left-hand operand is less than or equal to the value of the right-hand operand, and otherwise is `false`.
*   The value produced by the `>` operator is `true` if the value of the left-hand operand is greater than the value of the right-hand operand, and otherwise is `false`.
*   The value produced by the `>=` operator is `true` if the value of the left-hand operand is greater than or equal to the value of the right-hand operand, and otherwise is `false`.
    

### 15.20.2. Type Comparison Operator `instanceof`

The type of the _RelationalExpression_ operand of the `instanceof` operator must be a reference type or the null type; otherwise, a compile-time error occurs.

It is a compile-time error if the _ReferenceType_ mentioned after the `instanceof` operator does not denote a reference type that is reifiable ([¬ß4.7](jls-4.html#jls-4.7 "4.7. Reifiable Types")).

If a cast ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")) of the _RelationalExpression_ to the _ReferenceType_ would be rejected as a compile-time error, then the `instanceof` relational expression likewise produces a compile-time error. In such a situation, the result of the `instanceof` expression could never be true.

At run time, the result of the `instanceof` operator is `true` if the value of the _RelationalExpression_ is not `null` and the reference could be cast to the _ReferenceType_ without raising a `ClassCastException`. Otherwise the result is `false`.

**Example 15.20.2-1. The `instanceof` Operator**

class Point   { int x, y; }
class Element { int atomicNumber; }
class Test {
    public static void main(String\[\] args) {
        Point   p = new Point();
        Element e = new Element();
        if (e instanceof Point) {  // compile-time error
            System.out.println("I get your point!");
            p = (Point)e;  // compile-time error
        }
    }
}

This program results in two compile-time errors. The cast `(Point)e` is incorrect because no instance of `Element` or any of its possible subclasses (none are shown here) could possibly be an instance of any subclass of `Point`. The `instanceof` expression is incorrect for exactly the same reason. If, on the other hand, the class `Point` were a subclass of `Element` (an admittedly strange notion in this example):

class Point extends Element { int x, y; }

then the cast would be possible, though it would require a run-time check, and the `instanceof` expression would then be sensible and valid. The cast `(Point)e` would never raise an exception because it would not be executed if the value of `e` could not correctly be cast to type `Point`.

  

15.21. Equality Operators
-------------------------

The operators `==` (equal to) and `!=` (not equal to) are called the _equality operators_.

EqualityExpression:

[RelationalExpression](jls-15.html#jls-RelationalExpression "RelationalExpression")  
[EqualityExpression](jls-15.html#jls-EqualityExpression "EqualityExpression") `==` [RelationalExpression](jls-15.html#jls-RelationalExpression "RelationalExpression")  
[EqualityExpression](jls-15.html#jls-EqualityExpression "EqualityExpression") `!=` [RelationalExpression](jls-15.html#jls-RelationalExpression "RelationalExpression")

The equality operators are syntactically left-associative (they group left-to-right).

However, this fact is essentially never useful. For example, `a==b==c` parses as `(a==b)==c`. The result type of `a==b` is always `boolean`, and `c` must therefore be of type `boolean` or a compile-time error occurs. Thus, `a==b==c` does not test to see whether `a`, `b`, and `c` are all equal.

The equality operators are commutative if the operand expressions have no side effects.

The equality operators are analogous to the relational operators except for their lower precedence. Thus, `a<b==c<d` is `true` whenever `a<b` and `c<d` have the same truth value.

The equality operators may be used to compare two operands that are convertible ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) to numeric type, or two operands of type `boolean` or `Boolean`, or two operands that are each of either reference type or the null type. All other cases result in a compile-time error.

The type of an equality expression is always `boolean`.

In all cases, `a!=b` produces the same result as `!(a==b)`.

### 15.21.1. Numerical Equality Operators `==` and `!=`

If the operands of an equality operator are both of numeric type, or one is of numeric type and the other is convertible ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) to numeric type, binary numeric promotion is performed on the operands ([¬ß5.6.2](jls-5.html#jls-5.6.2 "5.6.2. Binary Numeric Promotion")).

Note that binary numeric promotion performs value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")) and may perform unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).

If the promoted type of the operands is `int` or `long`, then an integer equality test is performed.

If the promoted type is `float` or `double`, then a floating-point equality test is performed.

Comparison is carried out accurately on floating-point values, no matter what value sets their representing values were drawn from.

Floating-point equality testing is performed in accordance with the rules of the IEEE 754 standard:

*   If either operand is NaN, then the result of `==` is `false` but the result of `!=` is `true`.
    
    Indeed, the test `x!=x` is `true` if and only if the value of `x` is NaN.
    
    The methods `Float.isNaN` and `Double.isNaN` may also be used to test whether a value is NaN.
*   Positive zero and negative zero are considered equal.
    
    For example, `-0.0==0.0` is `true`.
*   Otherwise, two distinct floating-point values are considered unequal by the equality operators.
    
    In particular, there is one value representing positive infinity and one value representing negative infinity; each compares equal only to itself, and each compares unequal to all other values.
    

Subject to these considerations for floating-point numbers, the following rules then hold for integer operands or for floating-point operands other than NaN:

*   The value produced by the `==` operator is `true` if the value of the left-hand operand is equal to the value of the right-hand operand; otherwise, the result is `false`.
*   The value produced by the `!=` operator is `true` if the value of the left-hand operand is not equal to the value of the right-hand operand; otherwise, the result is `false`.
    

### 15.21.2. Boolean Equality Operators `==` and `!=`

If the operands of an equality operator are both of type `boolean`, or if one operand is of type `boolean` and the other is of type `Boolean`, then the operation is boolean equality.

The boolean equality operators are associative.

If one of the operands is of type `Boolean`, it is subjected to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).

The result of `==` is `true` if the operands (after any required unboxing conversion) are both `true` or both `false`; otherwise, the result is `false`.

The result of `!=` is `false` if the operands are both `true` or both `false`; otherwise, the result is `true`.

Thus `!=` behaves the same as `^` ([¬ß15.22.2](jls-15.html#jls-15.22.2 "15.22.2. Boolean Logical Operators &, ^, and |")) when applied to `boolean` operands.

### 15.21.3. Reference Equality Operators `==` and `!=`

If the operands of an equality operator are both of either reference type or the null type, then the operation is object equality.

It is a compile-time error if it is impossible to convert the type of either operand to the type of the other by a casting conversion ([¬ß5.5](jls-5.html#jls-5.5 "5.5. Casting Contexts")). The run-time values of the two operands would necessarily be unequal (ignoring the case where both values are `null`).

At run time, the result of `==` is `true` if the operand values are both `null` or both refer to the same object or array; otherwise, the result is `false`.

The result of `!=` is `false` if the operand values are both `null` or both refer to the same object or array; otherwise, the result is `true`.

While `==` may be used to compare references of type `String`, such an equality test determines whether or not the two operands refer to the same `String` object. The result is `false` if the operands are distinct `String` objects, even if they contain the same sequence of characters ([¬ß3.10.5](jls-3.html#jls-3.10.5 "3.10.5. String Literals")). The contents of two strings `s` and `t` can be tested for equality by the method invocation `s.equals(t)`.

15.22. Bitwise and Logical Operators
------------------------------------

The _bitwise operators_ and _logical operators_ include the AND operator `&`, exclusive OR operator `^`, and inclusive OR operator `|`.

AndExpression:

[EqualityExpression](jls-15.html#jls-EqualityExpression "EqualityExpression")  
[AndExpression](jls-15.html#jls-AndExpression "AndExpression") `&` [EqualityExpression](jls-15.html#jls-EqualityExpression "EqualityExpression")

ExclusiveOrExpression:

[AndExpression](jls-15.html#jls-AndExpression "AndExpression")  
[ExclusiveOrExpression](jls-15.html#jls-ExclusiveOrExpression "ExclusiveOrExpression") `^` [AndExpression](jls-15.html#jls-AndExpression "AndExpression")

InclusiveOrExpression:

[ExclusiveOrExpression](jls-15.html#jls-ExclusiveOrExpression "ExclusiveOrExpression")  
[InclusiveOrExpression](jls-15.html#jls-InclusiveOrExpression "InclusiveOrExpression") `|` [ExclusiveOrExpression](jls-15.html#jls-ExclusiveOrExpression "ExclusiveOrExpression")

These operators have different precedence, with `&` having the highest precedence and `|` the lowest precedence.

Each of these operators is syntactically left-associative (each groups left-to-right).

Each operator is commutative if the operand expressions have no side effects.

Each operator is associative.

The bitwise and logical operators may be used to compare two operands of numeric type or two operands of type `boolean`. All other cases result in a compile-time error.

### 15.22.1. Integer Bitwise Operators `&`, `^`, and `|`

When both operands of an operator `&`, `^`, or `|` are of a type that is convertible ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) to a primitive integral type, binary numeric promotion is first performed on the operands ([¬ß5.6.2](jls-5.html#jls-5.6.2 "5.6.2. Binary Numeric Promotion")).

The type of the bitwise operator expression is the promoted type of the operands.

For `&`, the result value is the bitwise AND of the operand values.

For `^`, the result value is the bitwise exclusive OR of the operand values.

For `|`, the result value is the bitwise inclusive OR of the operand values.

For example, the result of the expression:

0xff00 & 0xf0f0

is:

0xf000

The result of the expression:

0xff00 ^ 0xf0f0

is:

0x0ff0

The result of the expression:

0xff00 | 0xf0f0

is:

0xfff0

### 15.22.2. Boolean Logical Operators `&`, `^`, and `|`

When both operands of a `&`, `^`, or `|` operator are of type `boolean` or `Boolean`, then the type of the bitwise operator expression is `boolean`. In all cases, the operands are subject to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")) as necessary.

For `&`, the result value is `true` if both operand values are `true`; otherwise, the result is `false`.

For `^`, the result value is `true` if the operand values are different; otherwise, the result is `false`.

For `|`, the result value is `false` if both operand values are `false`; otherwise, the result is `true`.

15.23. Conditional-And Operator `&&`
------------------------------------

The conditional-and operator `&&` is like `&` ([¬ß15.22.2](jls-15.html#jls-15.22.2 "15.22.2. Boolean Logical Operators &, ^, and |")), but evaluates its right-hand operand only if the value of its left-hand operand is `true`.

ConditionalAndExpression:

[InclusiveOrExpression](jls-15.html#jls-InclusiveOrExpression "InclusiveOrExpression")  
[ConditionalAndExpression](jls-15.html#jls-ConditionalAndExpression "ConditionalAndExpression") `&&` [InclusiveOrExpression](jls-15.html#jls-InclusiveOrExpression "InclusiveOrExpression")

The conditional-and operator is syntactically left-associative (it groups left-to-right).

The conditional-and operator is fully associative with respect to both side effects and result value. That is, for any expressions `a`, `b`, and `c`, evaluation of the expression ``((`a`) `&&` (`b`)) `&&` (`c`)`` produces the same result, with the same side effects occurring in the same order, as evaluation of the expression ``(`a`) `&&` ((`b`) `&&` (`c`))``.

Each operand of the conditional-and operator must be of type `boolean` or `Boolean`, or a compile-time error occurs.

The type of a conditional-and expression is always `boolean`.

At run time, the left-hand operand expression is evaluated first; if the result has type `Boolean`, it is subjected to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).

If the resulting value is `false`, the value of the conditional-and expression is `false` and the right-hand operand expression is not evaluated.

If the value of the left-hand operand is `true`, then the right-hand expression is evaluated; if the result has type `Boolean`, it is subjected to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")). The resulting value becomes the value of the conditional-and expression.

Thus, `&&` computes the same result as `&` on `boolean` operands. It differs only in that the right-hand operand expression is evaluated conditionally rather than always.

15.24. Conditional-Or Operator `||`
-----------------------------------

The conditional-or operator `||` operator is like `|` ([¬ß15.22.2](jls-15.html#jls-15.22.2 "15.22.2. Boolean Logical Operators &, ^, and |")), but evaluates its right-hand operand only if the value of its left-hand operand is `false`.

ConditionalOrExpression:

[ConditionalAndExpression](jls-15.html#jls-ConditionalAndExpression "ConditionalAndExpression")  
[ConditionalOrExpression](jls-15.html#jls-ConditionalOrExpression "ConditionalOrExpression") `||` ConditionalAndExpression

The conditional-or operator is syntactically left-associative (it groups left-to-right).

The conditional-or operator is fully associative with respect to both side effects and result value. That is, for any expressions `a`, `b`, and `c`, evaluation of the expression ``((`a`) `||` (`b`)) `||` (`c`)`` produces the same result, with the same side effects occurring in the same order, as evaluation of the expression ``(`a`) `||` ((`b`) `||` (`c`))``.

Each operand of the conditional-or operator must be of type `boolean` or `Boolean`, or a compile-time error occurs.

The type of a conditional-or expression is always `boolean`.

At run time, the left-hand operand expression is evaluated first; if the result has type `Boolean`, it is subjected to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).

If the resulting value is `true`, the value of the conditional-or expression is `true` and the right-hand operand expression is not evaluated.

If the value of the left-hand operand is `false`, then the right-hand expression is evaluated; if the result has type `Boolean`, it is subjected to unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")). The resulting value becomes the value of the conditional-or expression.

Thus, `||` computes the same result as `|` on `boolean` or `Boolean` operands. It differs only in that the right-hand operand expression is evaluated conditionally rather than always.

15.25. Conditional Operator `? :`
---------------------------------

The conditional operator `? :` uses the boolean value of one expression to decide which of two other expressions should be evaluated.

ConditionalExpression:

[ConditionalOrExpression](jls-15.html#jls-ConditionalOrExpression "ConditionalOrExpression")  
[ConditionalOrExpression](jls-15.html#jls-ConditionalOrExpression "ConditionalOrExpression") `?` [Expression](jls-15.html#jls-Expression "Expression") `:` [ConditionalExpression](jls-15.html#jls-ConditionalExpression "ConditionalExpression")  
[ConditionalOrExpression](jls-15.html#jls-ConditionalOrExpression "ConditionalOrExpression") `?` [Expression](jls-15.html#jls-Expression "Expression") `:` [LambdaExpression](jls-15.html#jls-LambdaExpression "LambdaExpression")  

The conditional operator is syntactically right-associative (it groups right-to-left). Thus, `a?b:c?d:e?f:g` means the same as `a?b:(c?d:(e?f:g))`.

The conditional operator has three operand expressions. `?` appears between the first and second expressions, and `:` appears between the second and third expressions.

The first expression must be of type `boolean` or `Boolean`, or a compile-time error occurs.

It is a compile-time error for either the second or the third operand expression to be an invocation of a `void` method.

In fact, by the grammar of expression statements ([¬ß14.8](jls-14.html#jls-14.8 "14.8. Expression Statements")), it is not permitted for a conditional expression to appear in any context where an invocation of a `void` method could appear.

There are three kinds of conditional expressions, classified according to the second and third operand expressions: _boolean conditional expressions_, _numeric conditional expressions_, and _reference conditional expressions_. The classification rules are as follows:

*   If both the second and the third operand expressions are _boolean expressions_, the conditional expression is a boolean conditional expression.
    
    For the purpose of classifying a conditional, the following expressions are boolean expressions:
    
    *   An expression of a standalone form ([¬ß15.2](jls-15.html#jls-15.2 "15.2. Forms of Expressions")) that has type `boolean` or `Boolean`.
        
    *   A parenthesized `boolean` expression ([¬ß15.8.5](jls-15.html#jls-15.8.5 "15.8.5. Parenthesized Expressions")).
        
    *   A class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")) for class `Boolean`.
        
    *   A method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")) for which the chosen most specific method ([¬ß15.12.2.5](jls-15.html#jls-15.12.2.5 "15.12.2.5. Choosing the Most Specific Method")) has return type `boolean` or `Boolean`.
        
        Note that, for a generic method, this is the type _before_ instantiating the method's type arguments.
        
    *   A `boolean` conditional expression.
        
*   If both the second and the third operand expressions are _numeric expressions_, the conditional expression is a numeric conditional expression.
    
    For the purpose of classifying a conditional, the following expressions are numeric expressions:
    
    *   An expression of a standalone form ([¬ß15.2](jls-15.html#jls-15.2 "15.2. Forms of Expressions")) with a type that is convertible to a numeric type ([¬ß4.2](jls-4.html#jls-4.2 "4.2. Primitive Types and Values"), [¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).
        
    *   A parenthesized numeric expression ([¬ß15.8.5](jls-15.html#jls-15.8.5 "15.8.5. Parenthesized Expressions")).
        
    *   A class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")) for a class that is convertible to a numeric type.
        
    *   A method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")) for which the chosen most specific method ([¬ß15.12.2.5](jls-15.html#jls-15.12.2.5 "15.12.2.5. Choosing the Most Specific Method")) has a return type that is convertible to a numeric type.
        
    *   A numeric conditional expression.
        
*   Otherwise, the conditional expression is a reference conditional expression.
    

The process for determining the type of a conditional expression depends on the kind of conditional expression, as outlined in the following sections.

The following tables summarize the rules above by giving the type of a conditional expression for all possible types of its second and third operands. bnp(..) means to apply binary numeric promotion. The form "T | bnp(..)" is used where one operand is a constant expression of type `int` and may be representable in type T, where binary numeric promotion is used if the operand is not representable in type T. The operand type `Object` means any reference type other than the `null` type andthe eight wrapper classes `Boolean`, `Byte`, `Short`, `Character`, `Integer`, `Long`, `Float`, `Double`.

**Table 15.25-A. Conditional expression type (Primitive 3rd operand, Part I)**

    

3rd ‚Üí

`byte`

`short`

`char`

`int`

2nd ‚Üì

 

 

 

 

`byte`

`byte`

`short`

bnp(`byte`,`char`)

`byte` | bnp(`byte`,`int`)

`Byte`

`byte`

`short`

bnp(`Byte`,`char`)

`byte` | bnp(`Byte`,`int`)

`short`

`short`

`short`

bnp(`short`,`char`)

`short` | bnp(`short`,`int`)

`Short`

`short`

`short`

bnp(`Short`,`char`)

`short` | bnp(`Short`,`int`)

`char`

bnp(`char`,`byte`)

bnp(`char`,`short`)

`char`

`char` | bnp(`char`,`int`)

`Character`

bnp(`Character`,`byte`)

bnp(`Character`,`short`)

`char`

`char` | bnp(`Character`,`int`)

`int`

`byte` | bnp(`int`,`byte`)

`short` | bnp(`int`,`short`)

`char` | bnp(`int`,`char`)

`int`

`Integer`

bnp(`Integer`,`byte`)

bnp(`Integer`,`short`)

bnp(`Integer`,`char`)

`int`

`long`

bnp(`long`,`byte`)

bnp(`long`,`short`)

bnp(`long`,`char`)

bnp(`long`,`int`)

`Long`

bnp(`Long`,`byte`)

bnp(`Long`,`short`)

bnp(`Long`,`char`)

bnp(`Long`,`int`)

`float`

bnp(`float`,`byte`)

bnp(`float`,`short`)

bnp(`float`,`char`)

bnp(`float`,`int`)

`Float`

bnp(`Float`,`byte`)

bnp(`Float`,`short`)

bnp(`Float`,`char`)

bnp(`Float`,`int`)

`double`

bnp(`double`,`byte`)

bnp(`double`,`short`)

bnp(`double`,`char`)

bnp(`double`,`int`)

`Double`

bnp(`Double`,`byte`)

bnp(`Double`,`short`)

bnp(`Double`,`char`)

bnp(`Double`,`int`)

`boolean`

lub(`Boolean`,`Byte`)

lub(`Boolean`,`Short`)

lub(`Boolean`,`Character`)

lub(`Boolean`,`Integer`)

`Boolean`

lub(`Boolean`,`Byte`)

lub(`Boolean`,`Short`)

lub(`Boolean`,`Character`)

lub(`Boolean`,`Integer`)

`null`

lub(`null`,`Byte`)

lub(`null`,`Short`)

lub(`null`,`Character`)

lub(`null`,`Integer`)

`Object`

lub(`Object`,`Byte`)

lub(`Object`,`Short`)

lub(`Object`,`Character`)

lub(`Object`,`Integer`)

  

**Table 15.25-B. Conditional expression type (Primitive 3rd operand, Part II)**

    

3rd ‚Üí

`long`

`float`

`double`

`boolean`

2nd ‚Üì

 

 

 

 

`byte`

bnp(`byte`,`long`)

bnp(`byte`,`float`)

bnp(`byte`,`double`)

lub(`Byte`,`Boolean`)

`Byte`

bnp(`Byte`,`long`)

bnp(`Byte`,`float`)

bnp(`Byte`,`double`)

lub(`Byte`,`Boolean`)

`short`

bnp(`short`,`long`)

bnp(`short`,`float`)

bnp(`short`,`double`)

lub(`Short`,`Boolean`)

`Short`

bnp(`Short`,`long`)

bnp(`Short`,`float`)

bnp(`Short`,`double`)

lub(`Short`,`Boolean`)

`char`

bnp(`char`,`long`)

bnp(`char`,`float`)

bnp(`char`,`double`)

lub(`Character`,`Boolean`)

`Character`

bnp(`Character`,`long`)

bnp(`Character`,`float`)

bnp(`Character`,`double`)

lub(`Character`,`Boolean`)

`int`

bnp(`int`,`long`)

bnp(`int`,`float`)

bnp(`int`,`double`)

lub(`Integer`,`Boolean`)

`Integer`

bnp(`Integer`,`long`)

bnp(`Integer`,`float`)

bnp(`Integer`,`double`)

lub(`Integer`,`Boolean`)

`long`

`long`

bnp(`long`,`float`)

bnp(`long`,`double`)

lub(`Long`,`Boolean`)

`Long`

`long`

bnp(`Long`,`float`)

bnp(`Long`,`double`)

lub(`Long`,`Boolean`)

`float`

bnp(`float`,`long`)

`float`

bnp(`float`,`double`)

lub(`Float`,`Boolean`)

`Float`

bnp(`Float`,`long`)

`float`

bnp(`Float`,`double`)

lub(`Float`,`Boolean`)

`double`

bnp(`double`,`long`)

bnp(`double`,`float`)

`double`

lub(`Double`,`Boolean`)

`Double`

bnp(`Double`,`long`)

bnp(`Double`,`float`)

`double`

lub(`Double`,`Boolean`)

`boolean`

lub(`Boolean`,`Long`)

lub(`Boolean`,`Float`)

lub(`Boolean`,`Double`)

`boolean`

`Boolean`

lub(`Boolean`,`Long`)

lub(`Boolean`,`Float`)

lub(`Boolean`,`Double`)

`boolean`

`null`

lub(`null`,`Long`)

lub(`null`,`Float`)

lub(`null`,`Double`)

lub(`null`,`Boolean`)

`Object`

lub(`Object`,`Long`)

lub(`Object`,`Float`)

lub(`Object`,`Double`)

lub(`Object`,`Boolean`)

  

**Table 15.25-C. Conditional expression type (Reference 3rd operand, Part I)**

    

3rd ‚Üí

`Byte`

`Short`

`Character`

`Integer`

2nd ‚Üì

 

 

 

 

`byte`

`byte`

`short`

bnp(`byte`,`Character`)

bnp(`byte`,`Integer`)

`Byte`

`Byte`

`short`

bnp(`Byte`,`Character`)

bnp(`Byte`,`Integer`)

`short`

`short`

`short`

bnp(`short`,`Character`)

bnp(`short`,`Integer`)

`Short`

`short`

`Short`

bnp(`Short`,`Character`)

bnp(`Short`,`Integer`)

`char`

bnp(`char`,`Byte`)

bnp(`char`,`Short`)

`char`

bnp(`char`,`Integer`)

`Character`

bnp(`Character`,`Byte`)

bnp(`Character`,`Short`)

`Character`

bnp(`Character`,`Integer`)

`int`

`byte` | bnp(`int`,`Byte`)

`short` | bnp(`int`,`Short`)

`char` | bnp(`int`,`Character`)

`int`

`Integer`

bnp(`Integer`,`Byte`)

bnp(`Integer`,`Short`)

bnp(`Integer`,`Character`)

`Integer`

`long`

bnp(`long`,`Byte`)

bnp(`long`,`Short`)

bnp(`long`,`Character`)

bnp(`long`,`Integer`)

`Long`

bnp(`Long`,`Byte`)

bnp(`Long`,`Short`)

bnp(`Long`,`Character`)

bnp(`Long`,`Integer`)

`float`

bnp(`float`,`Byte`)

bnp(`float`,`Short`)

bnp(`float`,`Character`)

bnp(`float`,`Integer`)

`Float`

bnp(`Float`,`Byte`)

bnp(`Float`,`Short`)

bnp(`Float`,`Character`)

bnp(`Float`,`Integer`)

`double`

bnp(`double`,`Byte`)

bnp(`double`,`Short`)

bnp(`double`,`Character`)

bnp(`double`,`Integer`)

`Double`

bnp(`Double`,`Byte`)

bnp(`Double`,`Short`)

bnp(`Double`,`Character`)

bnp(`Double`,`Integer`)

`boolean`

lub(`Boolean`,`Byte`)

lub(`Boolean`,`Short`)

lub(`Boolean`,`Character`)

lub(`Boolean`,`Integer`)

`Boolean`

lub(`Boolean`,`Byte`)

lub(`Boolean`,`Short`)

lub(`Boolean`,`Character`)

lub(`Boolean`,`Integer`)

`null`

`Byte`

`Short`

`Character`

`Integer`

`Object`

lub(`Object`,`Byte`)

lub(`Object`,`Short`)

lub(`Object`,`Character`)

lub(`Object`,`Integer`)

  

**Table 15.25-D. Conditional expression type (Reference 3rd operand, Part II)**

    

3rd ‚Üí

`Long`

`Float`

`Double`

`Boolean`

2nd ‚Üì

 

 

 

 

`byte`

bnp(`byte`,`Long`)

bnp(`byte`,`Float`)

bnp(`byte`,`Double`)

lub(`Byte`,`Boolean`)

`Byte`

bnp(`Byte`,`Long`)

bnp(`Byte`,`Float`)

bnp(`Byte`,`Double`)

lub(`Byte`,`Boolean`)

`short`

bnp(`short`,`Long`)

bnp(`short`,`Float`)

bnp(`short`,`Double`)

lub(`Short`,`Boolean`)

`Short`

bnp(`Short`,`Long`)

bnp(`Short`,`Float`)

bnp(`Short`,`Double`)

lub(`Short`,`Boolean`)

`char`

bnp(`char`,`Long`)

bnp(`char`,`Float`)

bnp(`char`,`Double`)

lub(`Character`,`Boolean`)

`Character`

bnp(`Character`,`Long`)

bnp(`Character`,`Float`)

bnp(`Character`,`Double`)

lub(`Character`,`Boolean`)

`int`

bnp(`int`,`Long`)

bnp(`int`,`Float`)

bnp(`int`,`Double`)

lub(`Integer`,`Boolean`)

`Integer`

bnp(`Integer`,`Long`)

bnp(`Integer`,`Float`)

bnp(`Integer`,`Double`)

lub(`Integer`,`Boolean`)

`long`

`long`

bnp(`long`,`Float`)

bnp(`long`,`Double`)

lub(`Long`,`Boolean`)

`Long`

`Long`

bnp(`Long`,`Float`)

bnp(`Long`,`Double`)

lub(`Long`,`Boolean`)

`float`

bnp(`float`,`Long`)

`float`

bnp(`float`,`Double`)

lub(`Float`,`Boolean`)

`Float`

bnp(`Float`,`Long`)

`Float`

bnp(`Float`,`Double`)

lub(`Float`,`Boolean`)

`double`

bnp(`double`,`Long`)

bnp(`double`,`Float`)

`double`

lub(`Double`,`Boolean`)

`Double`

bnp(`Double`,`Long`)

bnp(`Double`,`Float`)

`Double`

lub(`Double`,`Boolean`)

`boolean`

lub(`Boolean`,`Long`)

lub(`Boolean`,`Float`)

lub(`Boolean`,`Double`)

`boolean`

`Boolean`

lub(`Boolean`,`Long`)

lub(`Boolean`,`Float`)

lub(`Boolean`,`Double`)

`Boolean`

`null`

`Long`

`Float`

`Double`

`Boolean`

`Object`

lub(`Object`,`Long`)

lub(`Object`,`Float`)

lub(`Object`,`Double`)

lub(`Object`,`Boolean`)

  

**Table 15.25-E. Conditional expression type (Reference 3rd operand, Part III)**

  

3rd ‚Üí

`null`

`Object`

2nd ‚Üì

 

 

`byte`

lub(`Byte`,`null`)

lub(`Byte`,`Object`)

`Byte`

`Byte`

lub(`Byte`,`Object`)

`short`

lub(`Short`,`null`)

lub(`Short`,`Object`)

`Short`

`Short`

lub(`Short`,`Object`)

`char`

lub(`Character`,`null`)

lub(`Character`,`Object`)

`Character`

`Character`

lub(`Character`,`Object`)

`int`

lub(`Integer`,`null`)

lub(`Integer`,`Object`)

`Integer`

`Integer`

lub(`Integer`,`Object`)

`long`

lub(`Long`,`null`)

lub(`Long`,`Object`)

`Long`

`Long`

lub(`Long`,`Object`)

`float`

lub(`Float`,`null`)

lub(`Float`,`Object`)

`Float`

`Float`

lub(`Float`,`Object`)

`double`

lub(`Double`,`null<`/code>) lub(`Double`,`Object`) `Double` `Double` lub(`Double`,`Object`) `boolean` lub(`Boolean`,`null`) lub(`Boolean`,`Object`) `Boolean` `Boolean` lub(`Boolean`,`Object`) `null` `null` lub(`null`,`Object`) `Object` `Object` `Object`  

At run time, the first operand expression of the conditional expression is evaluated first. If necessary, unboxing conversion is performed on the result.

The resulting `boolean` value is then used to choose either the second or the third operand expression:

*   If the value of the first operand is `true`, then the second operand expression is chosen.
*   If the value of the first operand is `false`, then the third operand expression is chosen.
    

The chosen operand expression is then evaluated and the resulting value is converted to the type of the conditional expression as determined by the rules stated below.

This conversion may include boxing or unboxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion"), [¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).

The operand expression not chosen is not evaluated for that particular evaluation of the conditional expression.

### 15.25.1. Boolean Conditional Expressions

Boolean conditional expressions are standalone expressions ([¬ß15.2](jls-15.html#jls-15.2 "15.2. Forms of Expressions")).

The type of a boolean conditional expression is determined as follows:

*   If the second and third operands are both of type `Boolean`, the conditional expression has type `Boolean`.
*   Otherwise, the conditional expression has type `boolean`.
    

### 15.25.2. Numeric Conditional Expressions

Numeric conditional expressions are standalone expressions ([¬ß15.2](jls-15.html#jls-15.2 "15.2. Forms of Expressions")).

The type of a numeric conditional expression is determined as follows:

*   If the second and third operands have the same type, then that is the type of the conditional expression.
*   If one of the second and third operands is of primitive type T, and the type of the other is the result of applying boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")) to T, then the type of the conditional expression is T.
*   If one of the operands is of type `byte` or `Byte` and the other is of type `short` or `Short`, then the type of the conditional expression is `short`.
*   If one of the operands is of type T where T is `byte`, `short`, or `char`, and the other operand is a constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")) of type `int` whose value is representable in type T, then the type of the conditional expression is T.
*   If one of the operands is of type T, where T is `Byte`, `Short`, or `Character`, and the other operand is a constant expression of type `int` whose value is representable in the type U which is the result of applying unboxing conversion to T, then the type of the conditional expression is U.
*   Otherwise, binary numeric promotion ([¬ß5.6.2](jls-5.html#jls-5.6.2 "5.6.2. Binary Numeric Promotion")) is applied to the operand types, and the type of the conditional expression is the promoted type of the second and third operands.
    
    Note that binary numeric promotion performs value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")) and may perform unboxing conversion ([¬ß5.1.8](jls-5.html#jls-5.1.8 "5.1.8. Unboxing Conversion")).
    

### 15.25.3. Reference Conditional Expressions

A reference conditional expression is a poly expression if it appears in an assignment context or an invocation context ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts"). [¬ß5.3](jls-5.html#jls-5.3 "5.3. Invocation Contexts")). Otherwise, it is a standalone expression.

Where a poly reference conditional expression appears in a context of a particular kind with target type T, its second and third operand expressions similarly appear in a context of the same kind with target type T.

The type of a poly reference conditional expression is the same as its target type.

The type of a standalone reference conditional expression is determined as follows:

*   If the second and third operands have the same type (which may be the null type), then that is the type of the conditional expression.
*   If the type of one of the second and third operands is the null type, and the type of the other operand is a reference type, then the type of the conditional expression is that reference type.
*   Otherwise, the second and third operands are of types S1 and S2 respectively. Let T1 be the type that results from applying boxing conversion to S1, and let T2 be the type that results from applying boxing conversion to S2. The type of the conditional expression is the result of applying capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")) to lub(T1, T2).
    

Because reference conditional expressions can be poly expressions, they can "pass down" context to their operands. This allows lambda expressions and method reference expressions to appear as operands:

return ... ? (x `->` x) : (x `->` -x);

It also allows use of extra information to improve type checking of generic method invocations. Prior to Java SE 8, this assignment was well-typed:

List<String> ls = Arrays.asList();

but this was not:

List<String> ls = ... ? Arrays.asList() : Arrays.asList("a","b");

The rules above allow both assignments to be considered well-typed.

Note that a reference conditional expression does not have to _contain_ a poly expression as an operand in order to _be_ a poly expression. It is a poly expression simply by virtue of the context in which it appears. For example, in the following code, the conditional expression is a poly expression, and each operand is considered to be in an assignment context targeting `` Class`<`? super Integer`>` ``:

Class<? super Integer> choose(boolean b,
                              Class<Integer> c1,
                              Class<Number> c2) {
    return b ? c1 : c2;
}

If the conditional expression was not a poly expression, then a compile-time error would occur, as its type would be lub(`` Class`<`Integer`>` ``, `` Class`<`Number`>` ``) = `` Class`<`? extends Number`>` `` which is incompatible with the return type of `choose`.

15.26. Assignment Operators
---------------------------

There are 12 _assignment operators_; all are syntactically right-associative (they group right-to-left). Thus, `a=b=c` means `a=(b=c)`, which assigns the value of `c` to `b` and then assigns the value of `b` to `a`.

AssignmentExpression:

[ConditionalExpression](jls-15.html#jls-ConditionalExpression "ConditionalExpression")  
[Assignment](jls-15.html#jls-Assignment "Assignment")

Assignment:

[LeftHandSide](jls-15.html#jls-LeftHandSide "LeftHandSide") [AssignmentOperator](jls-15.html#jls-AssignmentOperator "AssignmentOperator") [Expression](jls-15.html#jls-Expression "Expression")

LeftHandSide:

[ExpressionName](jls-6.html#jls-ExpressionName "ExpressionName")  
[FieldAccess](jls-15.html#jls-FieldAccess "FieldAccess")  
[ArrayAccess](jls-15.html#jls-ArrayAccess "ArrayAccess")

AssignmentOperator:

(one of)  

    =

The result of the first operand of an assignment operator must be a variable, or a compile-time error occurs.

This operand may be a named variable, such as a local variable or a field of the current object or class, or it may be a computed variable, as can result from a field access ([¬ß15.11](jls-15.html#jls-15.11 "15.11. Field Access Expressions")) or an array access ([¬ß15.10.3](jls-15.html#jls-15.10.3 "15.10.3. Array Access Expressions")).

The type of the assignment expression is the type of the variable after capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")).

At run time, the result of the assignment expression is the value of the variable after the assignment has occurred. The result of an assignment expression is not itself a variable.

A variable that is declared `final` cannot be assigned to (unless it is definitely unassigned ([¬ß16 (_Definite Assignment_)](jls-16.html "Chapter 16. Definite Assignment"))), because when an access of such a `final` variable is used as an expression, the result is a value, not a variable, and so it cannot be used as the first operand of an assignment operator.

### 15.26.1. Simple Assignment Operator `=`

A compile-time error occurs if the type of the right-hand operand cannot be converted to the type of the variable by assignment conversion ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")).

At run time, the expression is evaluated in one of three ways.

If the left-hand operand expression is a field access expression `e``.``f` ([¬ß15.11](jls-15.html#jls-15.11 "15.11. Field Access Expressions")), possibly enclosed in one or more pairs of parentheses, then:

*   First, the expression `e` is evaluated. If evaluation of `e` completes abruptly, the assignment expression completes abruptly for the same reason.
*   Next, the right hand operand is evaluated. If evaluation of the right hand expression completes abruptly, the assignment expression completes abruptly for the same reason.
*   Then, if the field denoted by `e``.``f` is not `static` and the result of the evaluation of `e` above is `null`, then a `NullPointerException` is thrown.
*   Otherwise, the variable denoted by `e``.``f` is assigned the value of the right hand operand as computed above.
    

If the left-hand operand is an array access expression ([¬ß15.10.3](jls-15.html#jls-15.10.3 "15.10.3. Array Access Expressions")), possibly enclosed in one or more pairs of parentheses, then:

*   First, the array reference subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the index subexpression (of the left-hand operand array access expression) and the right-hand operand are not evaluated and no assignment occurs.
*   Otherwise, the index subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-hand operand is not evaluated and no assignment occurs.
*   Otherwise, the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
*   Otherwise, if the value of the array reference subexpression is `null`, then no assignment occurs and a `NullPointerException` is thrown.
*   Otherwise, the value of the array reference subexpression indeed refers to an array. If the value of the index subexpression is less than zero, or greater than or equal to the `length` of the array, then no assignment occurs and an `ArrayIndexOutOfBoundsException` is thrown.
*   Otherwise, the value of the index subexpression is used to select a component of the array referred to by the value of the array reference subexpression.
    
    This component is a variable; call its type SC. Also, let TC be the type of the left-hand operand of the assignment operator as determined at compile time. Then there are two possibilities:
    
    *   If TC is a primitive type, then SC is necessarily the same as TC.
        
        The value of the right-hand operand is converted to the type of the selected array component, is subjected to value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")) to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the array component.
        
    *   If TC is a reference type, then SC may not be the same as TC, but rather a type that extends or implements TC.
        
        Let RC be the class of the object referred to by the value of the right-hand operand at run time.
        
        A Java compiler may be able to prove at compile time that the array component will be of type TC exactly (for example, TC might be `final`). But if a Java compiler cannot prove at compile time that the array component will be of type TC exactly, then a check must be performed at run time to ensure that the class RC is assignment compatible ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")) with the actual type SC of the array component.
        
        This check is similar to a narrowing cast ([¬ß5.5](jls-5.html#jls-5.5 "5.5. Casting Contexts"), [¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")), except that if the check fails, an `ArrayStoreException` is thrown rather than a `ClassCastException`.
        
        If class RC is not assignable to type SC, then no assignment occurs and an `ArrayStoreException` is thrown.
        
        Otherwise, the reference value of the right-hand operand is stored into the selected array component.
        
    

Otherwise, three steps are required:

*   First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs.
*   Otherwise, the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
*   Otherwise, the value of the right-hand operand is converted to the type of the left-hand variable, is subjected to value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")) to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the variable.
    

**Example 15.26.1-1. Simple Assignment To An Array Component**

class ArrayReferenceThrow extends RuntimeException { }
class IndexThrow          extends RuntimeException { }
class RightHandSideThrow  extends RuntimeException { }

class IllustrateSimpleArrayAssignment {
    static Object\[\] objects = { new Object(), new Object() };
    static Thread\[\] threads = { new Thread(), new Thread() };

    static Object\[\] arrayThrow() {
        throw new ArrayReferenceThrow();
    }
    static int indexThrow() {
        throw new IndexThrow();
    }
    static Thread rightThrow() {
        throw new RightHandSideThrow();
    }
    static String name(Object q) {
        String sq = q.getClass().getName();
        int k = sq.lastIndexOf('.');
        return (k < 0) ? sq : sq.substring(k+1);
    }

    static void testFour(Object\[\] x, int j, Object y) {
        String sx = x == null ? "null" : name(x\[0\]) + "s";
        String sy = name(y);
        System.out.println();
        try {
            System.out.print(sx + "\[throw\]=throw => ");
            x\[indexThrow()\] = rightThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "\[throw\]=" + sy + " => ");
            x\[indexThrow()\] = y;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "\[" + j + "\]=throw => ");
            x\[j\] = rightThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "\[" + j + "\]=" + sy + " => ");
            x\[j\] = y;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
    }

    public static void main(String\[\] args) {
        try {
            System.out.print("throw\[throw\]=throw => ");
            arrayThrow()\[indexThrow()\] = rightThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw\[throw\]=Thread => ");
            arrayThrow()\[indexThrow()\] = new Thread();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw\[1\]=throw => ");
            arrayThrow()\[1\] = rightThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw\[1\]=Thread => ");
            arrayThrow()\[1\] = new Thread();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }

        testFour(null, 1, new StringBuffer());
        testFour(null, 9, new Thread());
        testFour(objects, 1, new StringBuffer());
        testFour(objects, 1, new Thread());
        testFour(objects, 9, new StringBuffer());
        testFour(objects, 9, new Thread());
        testFour(threads, 1, new StringBuffer());
        testFour(threads, 1, new Thread());
        testFour(threads, 9, new StringBuffer());
        testFour(threads, 9, new Thread());
    }
}

This program produces the output:

throw\[throw\]=throw => ArrayReferenceThrow
throw\[throw\]=Thread => ArrayReferenceThrow
throw\[1\]=throw => ArrayReferenceThrow
throw\[1\]=Thread => ArrayReferenceThrow

null\[throw\]=throw => IndexThrow
null\[throw\]=StringBuffer => IndexThrow
null\[1\]=throw => RightHandSideThrow
null\[1\]=StringBuffer => NullPointerException

null\[throw\]=throw => IndexThrow
null\[throw\]=Thread => IndexThrow
null\[9\]=throw => RightHandSideThrow
null\[9\]=Thread => NullPointerException

Objects\[throw\]=throw => IndexThrow
Objects\[throw\]=StringBuffer => IndexThrow
Objects\[1\]=throw => RightHandSideThrow
Objects\[1\]=StringBuffer => Okay!

Objects\[throw\]=throw => IndexThrow
Objects\[throw\]=Thread => IndexThrow
Objects\[1\]=throw => RightHandSideThrow
Objects\[1\]=Thread => Okay!

Objects\[throw\]=throw => IndexThrow
Objects\[throw\]=StringBuffer => IndexThrow
Objects\[9\]=throw => RightHandSideThrow
Objects\[9\]=StringBuffer => ArrayIndexOutOfBoundsException

Objects\[throw\]=throw => IndexThrow
Objects\[throw\]=Thread => IndexThrow
Objects\[9\]=throw => RightHandSideThrow
Objects\[9\]=Thread => ArrayIndexOutOfBoundsException

Threads\[throw\]=throw => IndexThrow
Threads\[throw\]=StringBuffer => IndexThrow
Threads\[1\]=throw => RightHandSideThrow
Threads\[1\]=StringBuffer => ArrayStoreException

Threads\[throw\]=throw => IndexThrow
Threads\[throw\]=Thread => IndexThrow
Threads\[1\]=throw => RightHandSideThrow
Threads\[1\]=Thread => Okay!

Threads\[throw\]=throw => IndexThrow
Threads\[throw\]=StringBuffer => IndexThrow
Threads\[9\]=throw => RightHandSideThrow
Threads\[9\]=StringBuffer => ArrayIndexOutOfBoundsException

Threads\[throw\]=throw => IndexThrow
Threads\[throw\]=Thread => IndexThrow
Threads\[9\]=throw => RightHandSideThrow
Threads\[9\]=Thread => ArrayIndexOutOfBoundsException

The most interesting case of the lot is thirteenth from the end:

Threads\[1\]=StringBuffer => ArrayStoreException

which indicates that the attempt to store a reference to a `StringBuffer` into an array whose components are of type `Thread` throws an `ArrayStoreException`. The code is type-correct at compile time: the assignment has a left-hand side of type `Object[]` and a right-hand side of type `Object`. At run time, the first actual argument to method `testFour` is a reference to an instance of "array of `Thread`" and the third actual argument is a reference to an instance of class `StringBuffer`.

  

### 15.26.2. Compound Assignment Operators

A compound assignment expression of the form `E1 op= E2` is equivalent to `E1 = (T) ((E1) op (E2))`, where T is the type of `E1`, except that `E1` is evaluated only once.

For example, the following code is correct:

short x = 3;
x += 4.6;

and results in `x` having the value `7` because it is equivalent to:

short x = 3;
x = (short)(x + 4.6);

At run time, the expression is evaluated in one of two ways.

If the left-hand operand expression is not an array access expression, then:

*   First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs.
*   Otherwise, the value of the left-hand operand is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
*   Otherwise, the saved value of the left-hand variable and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
*   Otherwise, the result of the binary operation is converted to the type of the left-hand variable, subjected to value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")) to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the variable.
    

If the left-hand operand expression is an array access expression ([¬ß15.10.3](jls-15.html#jls-15.10.3 "15.10.3. Array Access Expressions")), then:

*   First, the array reference subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the index subexpression (of the left-hand operand array access expression) and the right-hand operand are not evaluated and no assignment occurs.
*   Otherwise, the index subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-hand operand is not evaluated and no assignment occurs.
*   Otherwise, if the value of the array reference subexpression is `null`, then no assignment occurs and a `NullPointerException` is thrown.
*   Otherwise, the value of the array reference subexpression indeed refers to an array. If the value of the index subexpression is less than zero, or greater than or equal to the `length` of the array, then no assignment occurs and an `ArrayIndexOutOfBoundsException` is thrown.
*   Otherwise, the value of the index subexpression is used to select a component of the array referred to by the value of the array reference subexpression. The value of this component is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
    
    For a simple assignment operator, the evaluation of the right-hand operand occurs before the checks of the array reference subexpression and the index subexpression, but for a compound assignment operator, the evaluation of the right-hand operand occurs after these checks.
*   Otherwise, consider the array component selected in the previous step, whose value was saved. This component is a variable; call its type S. Also, let T be the type of the left-hand operand of the assignment operator as determined at compile time.
    
    *   If T is a primitive type, then S is necessarily the same as T.
        
        The saved value of the array component and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator.
        
        If this operation completes abruptly (the only possibility is an integer division by zero - see [¬ß15.17.2](jls-15.html#jls-15.17.2 "15.17.2. Division Operator /")), then the assignment expression completes abruptly for the same reason and no assignment occurs.
        
        Otherwise, the result of the binary operation is converted to the type of the selected array component, subjected to value set conversion ([¬ß5.1.13](jls-5.html#jls-5.1.13 "5.1.13. Value Set Conversion")) to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the array component.
        
    *   If T is a reference type, then it must be `String`. Because class `String` is a `final` class, S must also be `String`.
        
        Therefore the run-time check that is sometimes required for the simple assignment operator is never required for a compound assignment operator.
        
        The saved value of the array component and the value of the right-hand operand are used to perform the binary operation (string concatenation) indicated by the compound assignment operator (which is necessarily `+=`). If this operation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
        
        Otherwise, the `String` result of the binary operation is stored into the array component.
        
    

**Example 15.26.2-1. Compound Assignment To An Array Component**

class ArrayReferenceThrow extends RuntimeException { }
class IndexThrow          extends RuntimeException { }
class RightHandSideThrow  extends RuntimeException { }

class IllustrateCompoundArrayAssignment {
    static String\[\] strings = { "Simon", "Garfunkel" };
    static double\[\] doubles = { Math.E, Math.PI };

    static String\[\] stringsThrow() {
        throw new ArrayReferenceThrow();
    }
    static double\[\] doublesThrow() {
        throw new ArrayReferenceThrow();
    }
    static int indexThrow() {
        throw new IndexThrow();
    }
    static String stringThrow() {
        throw new RightHandSideThrow();
    }
    static double doubleThrow() {
        throw new RightHandSideThrow();
    }
    static String name(Object q) {
        String sq = q.getClass().getName();
        int k = sq.lastIndexOf('.');
        return (k < 0) ? sq : sq.substring(k+1);
    }

    static void testEight(String\[\] x, double\[\] z, int j) {
        String sx = (x == null) ? "null" : "Strings";
        String sz = (z == null) ? "null" : "doubles";
        System.out.println();
        try {
            System.out.print(sx + "\[throw\]+=throw => ");
            x\[indexThrow()\] += stringThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sz + "\[throw\]+=throw => ");
            z\[indexThrow()\] += doubleThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "\[throw\]+=\\"heh\\" => ");
            x\[indexThrow()\] += "heh";
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sz + "\[throw\]+=12345 => ");
            z\[indexThrow()\] += 12345;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "\[" + j + "\]+=throw => ");
            x\[j\] += stringThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sz + "\[" + j + "\]+=throw => ");
            z\[j\] += doubleThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "\[" + j + "\]+=\\"heh\\" => ");
            x\[j\] += "heh";
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sz + "\[" + j + "\]+=12345 => ");
            z\[j\] += 12345;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
    }

    public static void main(String\[\] args) {
        try {
            System.out.print("throw\[throw\]+=throw => ");
            stringsThrow()\[indexThrow()\] += stringThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw\[throw\]+=throw => ");
            doublesThrow()\[indexThrow()\] += doubleThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw\[throw\]+=\\"heh\\" => ");
            stringsThrow()\[indexThrow()\] += "heh";
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw\[throw\]+=12345 => ");
            doublesThrow()\[indexThrow()\] += 12345;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw\[1\]+=throw => ");
            stringsThrow()\[1\] += stringThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw\[1\]+=throw => ");
            doublesThrow()\[1\] += doubleThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw\[1\]+=\\"heh\\" => ");
            stringsThrow()\[1\] += "heh";
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw\[1\]+=12345 => ");
            doublesThrow()\[1\] += 12345;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        testEight(null, null, 1);
        testEight(null, null, 9);
        testEight(strings, doubles, 1);
        testEight(strings, doubles, 9);
    }
}

This program produces the output:

throw\[throw\]+=throw => ArrayReferenceThrow
throw\[throw\]+=throw => ArrayReferenceThrow
throw\[throw\]+="heh" => ArrayReferenceThrow
throw\[throw\]+=12345 => ArrayReferenceThrow
throw\[1\]+=throw => ArrayReferenceThrow
throw\[1\]+=throw => ArrayReferenceThrow
throw\[1\]+="heh" => ArrayReferenceThrow
throw\[1\]+=12345 => ArrayReferenceThrow

null\[throw\]+=throw => IndexThrow
null\[throw\]+=throw => IndexThrow
null\[throw\]+="heh" => IndexThrow
null\[throw\]+=12345 => IndexThrow
null\[1\]+=throw => NullPointerException
null\[1\]+=throw => NullPointerException
null\[1\]+="heh" => NullPointerException
null\[1\]+=12345 => NullPointerException

null\[throw\]+=throw => IndexThrow
null\[throw\]+=throw => IndexThrow
null\[throw\]+="heh" => IndexThrow
null\[throw\]+=12345 => IndexThrow
null\[9\]+=throw => NullPointerException
null\[9\]+=throw => NullPointerException
null\[9\]+="heh" => NullPointerException
null\[9\]+=12345 => NullPointerException

Strings\[throw\]+=throw => IndexThrow
doubles\[throw\]+=throw => IndexThrow
Strings\[throw\]+="heh" => IndexThrow
doubles\[throw\]+=12345 => IndexThrow
Strings\[1\]+=throw => RightHandSideThrow
doubles\[1\]+=throw => RightHandSideThrow
Strings\[1\]+="heh" => Okay!
doubles\[1\]+=12345 => Okay!

Strings\[throw\]+=throw => IndexThrow
doubles\[throw\]+=throw => IndexThrow
Strings\[throw\]+="heh" => IndexThrow
doubles\[throw\]+=12345 => IndexThrow
Strings\[9\]+=throw => ArrayIndexOutOfBoundsException
doubles\[9\]+=throw => ArrayIndexOutOfBoundsException
Strings\[9\]+="heh" => ArrayIndexOutOfBoundsException
doubles\[9\]+=12345 => ArrayIndexOutOfBoundsException

The most interesting cases of the lot are eleventh and twelfth from the end:

Strings\[1\]+=throw => RightHandSideThrow
doubles\[1\]+=throw => RightHandSideThrow

They are the cases where a right-hand side that throws an exception actually gets to throw the exception; moreover, they are the only such cases in the lot. This demonstrates that the evaluation of the right-hand operand indeed occurs after the checks for a null array reference value and an out-of-bounds index value.

  

**Example 15.26.2-2. Value Of Left-Hand Side Of Compound Assignment Is Saved Before Evaluation Of Right-Hand Side**

class Test {
    public static void main(String\[\] args) {
        int k = 1;
        int\[\] a = { 1 };
        k += (k = 4) \* (k + 2);
        a\[0\] += (a\[0\] = 4) \* (a\[0\] + 2);
        System.out.println("k==" + k + " and a\[0\]==" + a\[0\]);
    }
}

This program produces the output:

k==25 and a\[0\]==25

The value `1` of `k` is saved by the compound assignment operator `+=` before its right-hand operand `(k = 4) * (k + 2)` is evaluated. Evaluation of this right-hand operand then assigns `4` to `k`, calculates the value `6` for `k + 2`, and then multiplies `4` by `6` to get `24`. This is added to the saved value `1` to get `25`, which is then stored into `k` by the `+=` operator. An identical analysis applies to the case that uses `a[0]`.

In short, the statements:

k += (k = 4) \* (k + 2);
a\[0\] += (a\[0\] = 4) \* (a\[0\] + 2);

behave in exactly the same manner as the statements:

k = k + (k = 4) \* (k + 2);
a\[0\] = a\[0\] + (a\[0\] = 4) \* (a\[0\] + 2);

  

15.27. Lambda Expressions
-------------------------

A lambda expression is like a method: it provides a list of formal parameters and a body - an expression or block - expressed in terms of those parameters.

LambdaExpression:

[LambdaParameters](jls-15.html#jls-LambdaParameters "LambdaParameters") `->` [LambdaBody](jls-15.html#jls-LambdaBody "LambdaBody")

Lambda expressions are always poly expressions ([¬ß15.2](jls-15.html#jls-15.2 "15.2. Forms of Expressions")).

It is a compile-time error if a lambda expression occurs in a program in someplace other than an assignment context ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")), an invocation context ([¬ß5.3](jls-5.html#jls-5.3 "5.3. Invocation Contexts")), or a casting context ([¬ß5.5](jls-5.html#jls-5.5 "5.5. Casting Contexts")).

Evaluation of a lambda expression produces an instance of a functional interface ([¬ß9.8](jls-9.html#jls-9.8 "9.8. Functional Interfaces")). Lambda expression evaluation does _not_ cause the execution of the expression's body; instead, this may occur at a later time when an appropriate method of the functional interface is invoked.

Here are some examples of lambda expressions:

() -> {}                // No parameters; result is void
() -> 42                // No parameters, expression body
() -> null              // No parameters, expression body
() -> { return 42; }    // No parameters, block body with return
() -> { System.gc(); }  // No parameters, void block body

() -> {                 // Complex block body with returns
  if (true) return 12;
  else {
    int result = 15;
    for (int i = 1; i < 10; i++)
      result \*= i;
    return result;
  }
}                          

(int x) -> x+1              // Single declared-type parameter
(int x) -> { return x+1; }  // Single declared-type parameter
(x) -> x+1                  // Single inferred-type parameter
x -> x+1                    // Parentheses optional for
                            // single inferred-type parameter

(String s) -> s.length()      // Single declared-type parameter
(Thread t) -> { t.start(); }  // Single declared-type parameter
s -> s.length()               // Single inferred-type parameter
t -> { t.start(); }           // Single inferred-type parameter

(int x, int y) -> x+y  // Multiple declared-type parameters
(x, y) -> x+y          // Multiple inferred-type parameters
(x, int y) -> x+y    // Illegal: can't mix inferred and declared types
(x, final y) -> x+y  // Illegal: no modifiers with inferred types

This syntax has the advantage of minimizing bracket noise around simple lambda expressions, which is especially beneficial when a lambda expression is an argument to a method, or when the body is another lambda expression. It also clearly distinguishes between its expression and statement forms, which avoids ambiguities or over-reliance on '`;`' tokens. When some extra bracketing is needed to visually distinguish either the full lambda expression or its body expression, parentheses are naturally supported (just as in other cases in which operator precedence is unclear).

The syntax has some parsing challenges. The Java programming language has always required arbitrary lookahead to distinguish between types and expressions after a '`(`' token: what follows may be a cast or a parenthesized expression. This was made worse when generics reused the binary operators '`<`' and '`>`' in types. Lambda expressions introduce a new possibility: the tokens following '`(`' may describe a type, an expression, or a lambda parameter list. Some tokens immediately indicate a parameter list (annotations, `final`); in other cases there are certain patterns that must be interpreted as parameter lists (two names in a row, a '`,`' not nested inside of '`<`' and '`>`'); and sometimes, the decision cannot be made until a '`->`' is encountered after a '`)`'. The simplest way to think of how this might be efficiently parsed is with a state machine: each state represents a subset of possible interpretations (type, expression, or parameters), and when the machine transitions to a state in which the set is a singleton, the parser knows which case it is. This does not map very elegantly to a fixed-lookahead grammar, however.

There is no special nullary form: a lambda expression with zero arguments is expressed as ``() `->` ...``. The obvious special-case syntax, `` `->` ... ``, does not work because it introduces an ambiguity between argument lists and casts: ``(x) `->` ...``.

Lambda expressions cannot declare type parameters. While it would make sense semantically to do so, the natural syntax (preceding the parameter list with a type parameter list) introduces messy ambiguities. For example, consider:

foo( (x) < y , z > (w) `->` v )

This could be an invocation of `foo` with one argument (a generic lambda cast to type `x`), or it could be an invocation of `foo` with two arguments, both the results of comparisons, the second comparing `z` with a lambda expression. (Strictly speaking, a lambda expression is meaningless as an operand to the relational operator `>`, but that is a tenuous assumption on which to build the grammar.)

There is a precedent for ambiguity resolution involving casts, which essentially prohibits the use of `-` and `+` following a non-primitive cast ([¬ß15.15](jls-15.html#jls-15.15 "15.15. Unary Operators")), but to extend that approach to generic lambdas would involve invasive changes to the grammar.

### 15.27.1. Lambda Parameters

The formal parameters of a lambda expression may have either declared types or inferred types. These styles cannot be mixed: it is not possible for a lambda expression to declare the types of some of its parameters but leave others to be inferred. Only parameters with declared types can have modifiers.

LambdaParameters:

[Identifier](jls-3.html#jls-Identifier "Identifier")  
`(` \[[FormalParameterList](jls-8.html#jls-FormalParameterList "FormalParameterList")\] `)`  
`(` [InferredFormalParameterList](jls-15.html#jls-InferredFormalParameterList "InferredFormalParameterList") `)`

InferredFormalParameterList:

[Identifier](jls-3.html#jls-Identifier "Identifier") {`,` [Identifier](jls-3.html#jls-Identifier "Identifier")}

The following productions from [¬ß4.3](jls-4.html#jls-4.3 "4.3. Reference Types and Values"), [¬ß8.3](jls-8.html#jls-8.3 "8.3. Field Declarations"), and [¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters") are shown here for convenience:

FormalParameterList:

[ReceiverParameter](jls-8.html#jls-ReceiverParameter "ReceiverParameter")  
[FormalParameters](jls-8.html#jls-FormalParameters "FormalParameters") `,` [LastFormalParameter](jls-8.html#jls-LastFormalParameter "LastFormalParameter")  
[LastFormalParameter](jls-8.html#jls-LastFormalParameter "LastFormalParameter")

FormalParameters:

[FormalParameter](jls-8.html#jls-FormalParameter "FormalParameter") {`,` [FormalParameter](jls-8.html#jls-FormalParameter "FormalParameter")}  
[ReceiverParameter](jls-8.html#jls-ReceiverParameter "ReceiverParameter") {`,` [FormalParameter](jls-8.html#jls-FormalParameter "FormalParameter")}

FormalParameter:

{[VariableModifier](jls-8.html#jls-VariableModifier "VariableModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId")

LastFormalParameter:

{[VariableModifier](jls-8.html#jls-VariableModifier "VariableModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") {[Annotation](jls-9.html#jls-Annotation "Annotation")} `...` [VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId")  
[FormalParameter](jls-8.html#jls-FormalParameter "FormalParameter")

VariableModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `final`

VariableDeclaratorId:

[Identifier](jls-3.html#jls-Identifier "Identifier") \[[Dims](jls-4.html#jls-Dims "Dims")\]

Dims:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]` {{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]`}

Receiver parameters are not permitted in the _FormalParameters_ of a lambda expression, as specified in [¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters").

A lambda expression whose formal parameters have declared types is said to be _explicitly typed_, while a lambda expression whose formal parameters have inferred types is said to be _implicitly typed_. A lambda expression with zero parameters is explicitly typed.

If the formal parameters have inferred types, then these types are derived ([¬ß15.27.3](jls-15.html#jls-15.27.3 "15.27.3. Type of a Lambda Expression")) from the functional interface type targeted by the lambda expression.

The syntax for formal parameters with declared types is the same as the syntax for the parameters of a method declaration ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters")).

The declared type of a formal parameter depends on whether it is a variable arity parameter:

*   If the formal parameter is not a variable arity parameter, then the declared type is denoted by _UnannType_ if no bracket pairs appear in _UnannType_ and _VariableDeclaratorId_, and specified by [¬ß10.2](jls-10.html#jls-10.2 "10.2. Array Variables") otherwise.
*   If the formal parameter is a variable arity parameter, then the declared type is specified by [¬ß10.2](jls-10.html#jls-10.2 "10.2. Array Variables"). (Note that "mixed notation" is not permitted for variable arity parameters.)
    

No distinction is made between the following lambda parameter lists:

(int... x) `->` ..
(int\[\] x) `->` ..

Consistent with the rules for overriding, either can be used, whether the functional interface's abstract method is fixed arity or variable arity. Since lambda expressions are never directly invoked, introducing `int...` where the functional interface uses `int[]` can have no impact on the surrounding program. In a lambda body, a variable arity parameter is treated just like an array-typed parameter.

The rules for annotation modifiers on a formal parameter declaration are specified in [¬ß9.7.4](jls-9.html#jls-9.7.4 "9.7.4. Where Annotations May Appear") and [¬ß9.7.5](jls-9.html#jls-9.7.5 "9.7.5. Multiple Annotations of the Same Type").

It is a compile-time error if `final` appears more than once as a modifier for a formal parameter declaration.

It is a compile-time error to use mixed array notation ([¬ß10.2](jls-10.html#jls-10.2 "10.2. Array Variables")) for a variable arity parameter.

The scope and shadowing of a formal parameter declaration is specified in [¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration") and [¬ß6.4](jls-6.html#jls-6.4 "6.4. Shadowing and Obscuring").

It is a compile-time error for a lambda expression to declare two formal parameters with the same name. (That is, their declarations mention the same _Identifier_.)

It is a compile-time error if a lambda parameter has the name `_` (that is, a single underscore character).

The use of the variable name `_` in any context is discouraged. Future versions of the Java programming language may reserve this name as a keyword and/or give it special semantics.

It is a compile-time error if a receiver parameter ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters")) appears in the _FormalParameters_ of a lambda expression.

It is a compile-time error if a formal parameter that is declared `final` is assigned to within the body of the lambda expression.

When the lambda expression is invoked (via a method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions"))), the values of the actual argument expressions initialize newly created parameter variables, each of the declared or inferred type, before execution of the lambda body. The _Identifier_ that appears in the _VariableDeclaratorId_ or the _InferredFormalParameterList_ may be used as a simple name in the lambda body to refer to the formal parameter.

A lambda parameter of type `float` always contains an element of the float value set ([¬ß4.2.3](jls-4.html#jls-4.2.3 "4.2.3. Floating-Point Types, Formats, and Values")); similarly, a lambda parameter of type `double` always contains an element of the double value set. It is not permitted for a lambda parameter of type `float` to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a lambda parameter of type `double` to contain an element of the double-extended-exponent value set that is not also an element of the double value set.

When the parameter types of a lambda expression are inferred, the same lambda body can be interpreted in different ways, depending on the context in which it appears. Specifically, the types of expressions in the body, the checked exceptions thrown by the body, and the type correctness of code in the body all depend on the parameters' inferred types. This implies that inference of parameter types must occur "before" attempting to type-check the body of the lambda expression.

### 15.27.2. Lambda Body

A lambda body is either a single expression or a block ([¬ß14.2](jls-14.html#jls-14.2 "14.2. Blocks")). Like a method body, a lambda body describes code that will be executed whenever an invocation occurs.

LambdaBody:

[Expression](jls-15.html#jls-Expression "Expression")  
[Block](jls-14.html#jls-Block "Block")

Unlike code appearing in anonymous class declarations, the meaning of names and the `this` and `super` keywords appearing in a lambda body, along with the accessibility of referenced declarations, are the same as in the surrounding context (except that lambda parameters introduce new names).

The transparency of `this` (both explicit and implicit) in the body of a lambda expression - that is, treating it the same as in the surrounding context - allows more flexibility for implementations, and prevents the meaning of unqualified names in the body from being dependent on overload resolution.

Practically speaking, it is unusual for a lambda expression to need to talk about itself (either to call itself recursively or to invoke its other methods), while it is more common to want to use names to refer to things in the enclosing class that would otherwise be shadowed (`this`, `toString()`). If it is necessary for a lambda expression to refer to itself (as if via `this`), a method reference or an anonymous inner class should be used instead.

A block lambda body is _void-compatible_ if every return statement in the block has the form `return``;`.

A block lambda body is _value-compatible_ if it cannot complete normally ([¬ß14.21](jls-14.html#jls-14.21 "14.21. Unreachable Statements")) and every return statement in the block has the form `return` _Expression_`;`.

It is a compile-time error if a block lambda body is neither void-compatible nor value-compatible.

In a value-compatible block lambda body, the _result expressions_ are any expressions that may produce an invocation's value. Specifically, for each statement of the form `return` _Expression_ `;` contained by the body, the _Expression_ is a result expression.

The following lambda bodies are void-compatible:

() `->` {}
() `->` { System.out.println("done"); }

These are value-compatible:

() `->` { return "done"; }
() `->` { if (...) return 1; else return 0; }

These are both:

() `->` { throw new RuntimeException(); }
() `->` { while (true); }

This is neither:

() `->` { if (...) return "done"; System.out.println("done"); }

The handling of void/value-compatible and the meaning of names in the body jointly serve to minimize the dependency on a particular target type in the given context, which is useful both for implementations and for programmer comprehension. While expressions can be assigned different types during overload resolution depending on the target type, the meaning of unqualified names and the basic structure of the lambda body do not change.

Note that the void/value-compatible definition is not a strictly structural property: "can complete normally" depends on the values of constant expressions, and these may include names that reference constant variables.

Any local variable, formal parameter, or exception parameter used but not declared in a lambda expression must either be declared `final` or be effectively final ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")), or a compile-time error occurs where the use is attempted.

Any local variable used but not declared in a lambda body must be definitely assigned ([¬ß16 (_Definite Assignment_)](jls-16.html "Chapter 16. Definite Assignment")) before the lambda body, or a compile-time error occurs.

Similar rules on variable use apply in the body of an inner class ([¬ß8.1.3](jls-8.html#jls-8.1.3 "8.1.3. Inner Classes and Enclosing Instances")). The restriction to effectively final variables prohibits access to dynamically-changing local variables, whose capture would likely introduce concurrency problems. Compared to the `final` restriction, it reduces the clerical burden on programmers.

The restriction to effectively final variables includes standard loop variables, but not enhanced-`for` loop variables, which are treated as distinct for each iteration of the loop ([¬ß14.14.2](jls-14.html#jls-14.14.2 "14.14.2. The enhanced for statement")).

The following lambda bodies demonstrate use of effectively final variables.

void m1(int x) {
    int y = 1;
    foo(() -> x+y);
    // Legal: x and y are both effectively final.
}

void m2(int x) {
    int y;
    y = 1;
    foo(() -> x+y);
    // Legal: x and y are both effectively final.
}

void m3(int x) {
    int y;
    if (...) y = 1;
    foo(() -> x+y);
    // Illegal: y is effectively final, but not definitely assigned.
}

void m4(int x) {
    int y;
    if (...) y = 1; else y = 2;
    foo(() -> x+y);
    // Legal: x and y are both effectively final.
}

void m5(int x) {
    int y;
    if (...) y = 1;
    y = 2;
    foo(() -> x+y);
    // Illegal: y is not effectively final.
}

void m6(int x) {
    foo(() -> x+1);
    x++;
    // Illegal: x is not effectively final.
}

void m7(int x) {
    foo(() -> x=1);
    // Illegal: x is not effectively final.
}

void m8() {
    int y;
    foo(() -> y=1);
    // Illegal: y is not definitely assigned before the lambda.
}

void m9(String\[\] arr) {
    for (String s : arr) {
        foo(() -> s);
        // Legal: s is effectively final
        // (it is a new variable on each iteration)
    }
}

void m10(String\[\] arr) {
    for (int i = 0; i < arr.length; i++) {
        foo(() -> arr\[i\]);
        // Illegal: i is not effectively final
        // (it is not final, and is incremented)
    }
}

### 15.27.3. Type of a Lambda Expression

A lambda expression is compatible in an assignment context, invocation context, or casting context with a target type T if T is a functional interface type ([¬ß9.8](jls-9.html#jls-9.8 "9.8. Functional Interfaces")) and the expression is _congruent_ with the function type of the _ground target type_ derived from T.

The _ground target type_ is derived from T as follows:

*   If T is a wildcard-parameterized functional interface type and the lambda expression is explicitly typed, then the ground target type is inferred as described in [¬ß18.5.3](jls-18.html#jls-18.5.3 "18.5.3. Functional Interface Parameterization Inference").
*   If T is a wildcard-parameterized functional interface type and the lambda expression is implicitly typed, then the ground target type is the non-wildcard parameterization ([¬ß9.9](jls-9.html#jls-9.9 "9.9. Function Types")) of T.
*   Otherwise, the ground target type is T.
    

A lambda expression is _congruent_ with a function type if all of the following are true:

*   The function type has no type parameters.
*   The number of lambda parameters is the same as the number of parameter types of the function type.
*   If the lambda expression is explicitly typed, its formal parameter types are the same as the parameter types of the function type.
*   If the lambda parameters are assumed to have the same types as the function type's parameter types, then:
    
    *   If the function type's result is `void`, the lambda body is either a statement expression ([¬ß14.8](jls-14.html#jls-14.8 "14.8. Expression Statements")) or a `void`\-compatible block.
        
    *   If the function type's result is a (non-`void`) type R, then either i) the lambda body is an expression that is compatible with R in an assignment context, or ii) the lambda body is a value-compatible block, and each result expression ([¬ß15.27.2](jls-15.html#jls-15.27.2 "15.27.2. Lambda Body")) is compatible with R in an assignment context.
        
    

If a lambda expression is compatible with a target type T, then the type of the expression, U, is the ground target type derived from T.

It is a compile-time error if any class or interface mentioned by either U or the function type of U is not accessible from the class or interface in which the lambda expression appears.

For each non-`static` member method `m` of U, if the function type of U has a subsignature of the signature of `m`, then a notional method whose method type is the function type of U is deemed to override `m`, and any compile-time error or unchecked warning specified in [¬ß8.4.8.3](jls-8.html#jls-8.4.8.3 "8.4.8.3. Requirements in Overriding and Hiding") may occur.

A checked exception that can be thrown in the body of the lambda expression may cause a compile-time error, as specified in [¬ß11.2.3](jls-11.html#jls-11.2.3 "11.2.3. Exception Checking").

The parameter types of explicitly typed lambdas are required to exactly match those of the function type. While it would be possible to be more flexible - allow boxing or contravariance, for example - this kind of generality seems unnecessary, and is inconsistent with the way overriding works in class declarations. A programmer ought to know exactly what function type is being targeted when writing a lambda expression, so he should thus know exactly what signature must be overridden. (In contrast, this is not the case for method references, and so more flexibility is allowed when they are used.) In addition, more flexibility with parameter types would add to the complexity of type inference and overload resolution.

Note that while boxing is not allowed in a strict invocation context, boxing of lambda result expressions is _always_ allowed - that is, the result expression appears in an assignment context, regardless of the context enclosing the lambda expression. However, if an explicitly typed lambda expression is an argument to an overloaded method, a method signature that avoids boxing or unboxing the lambda result is preferred by the most specific check ([¬ß15.12.2.5](jls-15.html#jls-15.12.2.5 "15.12.2.5. Choosing the Most Specific Method")).

If the body of a lambda is a statement expression (that is, an expression that would be allowed to stand alone as a statement), it is compatible with a `void`\-producing function type; any result is simply discarded. So, for example, both of the following are legal:

// Predicate has a `boolean` result
java.util.function.Predicate<String> p = s `->` list.add(s);
// Consumer has a `void` result
java.util.function.Consumer<String> c = s `->` list.add(s);

Generally speaking, a lambda of the form `(``)` `->` _expr_, where _expr_ is a statement expression, is interpreted as either `(``)` `->` `{` `return` _expr_`;` `}` or `(``)` `->` `{` _expr_`;` `}`, depending on the target type.

### 15.27.4. Run-Time Evaluation of Lambda Expressions

At run time, evaluation of a lambda expression is similar to evaluation of a class instance creation expression, insofar as normal completion produces a reference to an object. Evaluation of a lambda expression is distinct from execution of the lambda body.

Either a new instance of a class with the properties below is allocated and initialized, or an existing instance of a class with the properties below is referenced. If a new instance is to be created, but there is insufficient space to allocate the object, evaluation of the lambda expression completes abruptly by throwing an `OutOfMemoryError`.

The value of a lambda expression is a reference to an instance of a class with the following properties:

*   The class implements the targeted functional interface type and, if the target type is an intersection type, every other interface type mentioned in the intersection.
*   Where the lambda expression has type U, for each non-`static` member method `m` of U:
    
    If the function type of U has a subsignature of the signature of `m`, then the class declares a method that overrides `m`. The method's body has the effect of evaluating the lambda body, if it is an expression, or of executing the lambda body, if it is a block; if a result is expected, it is returned from the method.
    
    If the erasure of the type of a method being overridden differs in its signature from the erasure of the function type of U, then before evaluating or executing the lambda body, the method's body checks that each argument value is an instance of a subclass or subinterface of the erasure of the corresponding parameter type in the function type of U; if not, a `ClassCastException` is thrown.
*   The class overrides no other methods of the targeted functional interface type or other interface types mentioned above, although it may override methods of the `Object` class.
    

These rules are meant to offer flexibility to implementations of the Java programming language, in that:

*   A new object need not be allocated on every evaluation.
*   Objects produced by different lambda expressions need not belong to different classes (if the bodies are identical, for example).
*   Every object produced by evaluation need not belong to the same class (captured local variables might be inlined, for example).
*   If an "existing instance" is available, it need not have been created at a previous lambda evaluation (it might have been allocated during the enclosing class's initialization, for example).
    

If the targeted functional interface type is a subtype of `java.io.Serializable`, the resulting object will automatically be an instance of a serializable class. Making an object derived from a lambda expression serializable can have extra run time overhead and security implications, so lambda-derived objects are not required to be serializable "by default".

15.28. Constant Expressions
---------------------------

ConstantExpression:

[Expression](jls-15.html#jls-Expression "Expression")

A _constant expression_ is an expression denoting a value of primitive type or a `String` that does not complete abruptly and is composed using only the following:

*   Literals of primitive type and literals of type `String` ([¬ß3.10.1](jls-3.html#jls-3.10.1 "3.10.1. Integer Literals"), [¬ß3.10.2](jls-3.html#jls-3.10.2 "3.10.2. Floating-Point Literals"), [¬ß3.10.3](jls-3.html#jls-3.10.3 "3.10.3. Boolean Literals"), [¬ß3.10.4](jls-3.html#jls-3.10.4 "3.10.4. Character Literals"), [¬ß3.10.5](jls-3.html#jls-3.10.5 "3.10.5. String Literals"))
*   Casts to primitive types and casts to type `String` ([¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions"))
*   The unary operators `+`, `-`, `~`, and `!` (but not `++` or `--`) ([¬ß15.15.3](jls-15.html#jls-15.15.3 "15.15.3. Unary Plus Operator +"), [¬ß15.15.4](jls-15.html#jls-15.15.4 "15.15.4. Unary Minus Operator -"), [¬ß15.15.5](jls-15.html#jls-15.15.5 "15.15.5. Bitwise Complement Operator ~"), [¬ß15.15.6](jls-15.html#jls-15.15.6 "15.15.6. Logical Complement Operator !"))
*   The multiplicative operators `*`, `/`, and `%` ([¬ß15.17](jls-15.html#jls-15.17 "15.17. Multiplicative Operators"))
*   The additive operators `+` and `-` ([¬ß15.18](jls-15.html#jls-15.18 "15.18. Additive Operators"))
*   The shift operators `<<`, `>>`, and `>>>` ([¬ß15.19](jls-15.html#jls-15.19 "15.19. Shift Operators"))
*   The relational operators `<`, `<=`, `>`, and `>=` (but not `instanceof`) ([¬ß15.20](jls-15.html#jls-15.20 "15.20. Relational Operators"))
*   The equality operators `==` and `!=` ([¬ß15.21](jls-15.html#jls-15.21 "15.21. Equality Operators"))
*   The bitwise and logical operators `&`, `^`, and `|` ([¬ß15.22](jls-15.html#jls-15.22 "15.22. Bitwise and Logical Operators"))The conditional-and operator `&&` and the conditional-or operator `||` ([¬ß15.23](jls-15.html#jls-15.23 "15.23. Conditional-And Operator &&"), [¬ß15.24](jls-15.html#jls-15.24 "15.24. Conditional-Or Operator ||"))

*   The ternary conditional operator `? :` ([¬ß15.25](jls-15.html#jls-15.25 "15.25. Conditional Operator ? :"))
*   Parenthesized expressions ([¬ß15.8.5](jls-15.html#jls-15.8.5 "15.8.5. Parenthesized Expressions")) whose contained expression is a constant expression.
*   Simple names ([¬ß6.5.6.1](jls-6.html#jls-6.5.6.1 "6.5.6.1. Simple Expression Names")) that refer to constant variables ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")).
*   Qualified names ([¬ß6.5.6.2](jls-6.html#jls-6.5.6.2 "6.5.6.2. Qualified Expression Names")) of the form _TypeName_ `.` _Identifier_ that refer to constant variables ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables")).
    

Constant expressions of type `String` are always "interned" so as to share unique instances, using the method `String.intern`.

A constant expression is always treated as FP-strict ([¬ß15.4](jls-15.html#jls-15.4 "15.4. FP-strict Expressions")), even if it occurs in a context where a non-constant expression would not be considered to be FP-strict.

Constant expressions are used as `case` labels in `switch` statements ([¬ß14.11](jls-14.html#jls-14.11 "14.11. The switch Statement")) and have a special significance for assignment conversion ([¬ß5.2](jls-5.html#jls-5.2 "5.2. Assignment Contexts")) and initialization of a class or interface ([¬ß12.4.2](jls-12.html#jls-12.4.2 "12.4.2. Detailed Initialization Procedure")). They may also govern the ability of a `while`, `do`, or `for` statement to complete normally ([¬ß14.21](jls-14.html#jls-14.21 "14.21. Unreachable Statements")), and the type of a conditional operator `? :` with numeric operands.

**Example 15.28-1. Constant Expressions**

true
(short)(1\*2\*3\*4\*5\*6)
Integer.MAX\_VALUE / 2
2.0 \* Math.PI
"The integer " + Long.MAX\_VALUE + " is mighty big."

  

üçÄ Chapter 16. Definite Assignment
-------------------------------

**Table of Contents**

[16.1. Definite Assignment and Expressions](jls-16.html#jls-16.1)
[16.1.1. Boolean Constant Expressions](jls-16.html#jls-16.1.1)
[16.1.2. Conditional-And Operator `&&`](jls-16.html#jls-16.1.2)
[16.1.3. Conditional-Or Operator `||`](jls-16.html#jls-16.1.3)
[16.1.4. Logical Complement Operator `!`](jls-16.html#jls-16.1.4)
[16.1.5. Conditional Operator `? :`](jls-16.html#jls-16.1.5)
[16.1.6. Conditional Operator `? :`](jls-16.html#jls-16.1.6)
[16.1.7. Other Expressions of Type `boolean`](jls-16.html#jls-16.1.7)
[16.1.8. Assignment Expressions](jls-16.html#jls-16.1.8)
[16.1.9. Operators `++` and `--`](jls-16.html#jls-16.1.9)
[16.1.10. Other Expressions](jls-16.html#jls-16.1.10)
[16.2. Definite Assignment and Statements](jls-16.html#jls-16.2)
[16.2.1. Empty Statements](jls-16.html#jls-16.2.1)
[16.2.2. Blocks](jls-16.html#jls-16.2.2)
[16.2.3. Local Class Declaration Statements](jls-16.html#jls-16.2.3)
[16.2.4. Local Variable Declaration Statements](jls-16.html#jls-16.2.4)
[16.2.5. Labeled Statements](jls-16.html#jls-16.2.5)
[16.2.6. Expression Statements](jls-16.html#jls-16.2.6)
[16.2.7. `if` Statements](jls-16.html#jls-16.2.7)
[16.2.8. `assert` Statements](jls-16.html#jls-16.2.8)
[16.2.9. `switch` Statements](jls-16.html#jls-16.2.9)
[16.2.10. `while` Statements](jls-16.html#jls-16.2.10)
[16.2.11. `do` Statements](jls-16.html#jls-16.2.11)
[16.2.12. `for` Statements](jls-16.html#jls-16.2.12)
[16.2.12.1. Initialization Part of `for` Statement](jls-16.html#jls-16.2.12.1)
[16.2.12.2. Incrementation Part of `for` Statement](jls-16.html#jls-16.2.12.2)
[16.2.13. `break`, `continue`, `return`, and `throw` Statements](jls-16.html#jls-16.2.13)
[16.2.14. `synchronized` Statements](jls-16.html#jls-16.2.14)
[16.2.15. `try` Statements](jls-16.html#jls-16.2.15)
[16.3. Definite Assignment and Parameters](jls-16.html#jls-16.3)
[16.4. Definite Assignment and Array Initializers](jls-16.html#jls-16.4)
[16.5. Definite Assignment and Enum Constants](jls-16.html#jls-16.5)
[16.6. Definite Assignment and Anonymous Classes](jls-16.html#jls-16.6)
[16.7. Definite Assignment and Member Types](jls-16.html#jls-16.7)
[16.8. Definite Assignment and Static Initializers](jls-16.html#jls-16.8)
[16.9. Definite Assignment, Constructors, and Instance Initializers](jls-16.html#jls-16.9)

Each local variable ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements")) and every blank `final` field ([¬ß4.12.4](jls-4.html#jls-4.12.4 "4.12.4. final Variables"), [¬ß8.3.1.2](jls-8.html#jls-8.3.1.2 "8.3.1.2. final Fields")) must have a _definitely assigned_ value when any access of its value occurs.

An access to its value consists of the simple name of the variable (or, for a field, the simple name of the field qualified by `this`) occurring anywhere in an expression except as the left-hand operand of the simple assignment operator `=` ([¬ß15.26.1](jls-15.html#jls-15.26.1 "15.26.1. Simple Assignment Operator =")).

For every access of a local variable or blank `final` field `x`, `x` must be definitely assigned before the access, or a compile-time error occurs.

Similarly, every blank `final` variable must be assigned at most once; it must be _definitely unassigned_ when an assignment to it occurs.

Such an assignment is defined to occur if and only if either the simple name of the variable (or, for a field, its simple name qualified by `this`) occurs on the left hand side of an assignment operator.

For every assignment to a blank `final` variable, the variable must be definitely unassigned before the assignment, or a compile-time error occurs.

The remainder of this chapter is devoted to a precise explanation of the words "definitely assigned before" and "definitely unassigned before".

The idea behind definite assignment is that an assignment to the local variable or blank `final` field must occur on every possible execution path to the access. Similarly, the idea behind definite unassignment is that no other assignment to the blank `final` variable is permitted to occur on any possible execution path to an assignment.

The analysis takes into account the structure of statements and expressions; it also provides a special treatment of the expression operators `!`, `&&`, `||`, and `? :`, and of boolean-valued constant expressions.

Except for the special treatment of the conditional boolean operators `&&`, `||`, and `? :` and of boolean-valued constant expressions, the values of expressions are not taken into account in the flow analysis.

**Example 16-1. Definite Assignment Considers Structure of Statements and Expressions**

A Java compiler recognizes that `k` is definitely assigned before its access (as an argument of a method invocation) in the code:

{
    int k;
    if (v > 0 && (k = System.in.read()) >= 0)
        System.out.println(k);
}

because the access occurs only if the value of the expression:

v > 0 && (k = System.in.read()) >= 0

is `true`, and the value can be `true` only if the assignment to `k` is executed (more properly, evaluated).

Similarly, a Java compiler will recognize that in the code:

{
    int k;
    while (true) {
        k = n;
        if (k >= 5) break;
        n = 6;
    }
    System.out.println(k);
}

the variable `k` is definitely assigned by the `while` statement because the condition expression `true` never has the value `false`, so only the `break` statement can cause the `while` statement to complete normally, and `k` is definitely assigned before the `break` statement.

On the other hand, the code:

{
    int k;
    while (n < 4) {
        k = n;
        if (k >= 5) break;
        n = 6;
    }
    System.out.println(k);  /\* k is not "definitely assigned"
                               before this statement \*/
}

must be rejected by a Java compiler, because in this case the `while` statement is not guaranteed to execute its body as far as the rules of definite assignment are concerned.

  

**Example 16-2. Definite Assignment Does Not Consider Values of Expressions**

A Java compiler must produce a compile-time error for the code:

{
    int k;
    int n = 5;
    if (n > 2)
        k = 3;
    System.out.println(k);  /\* k is not "definitely assigned"
                               before this statement \*/
}

even though the value of `n` is known at compile time, and in principle it can be known at compile time that the assignment to `k` will always be executed (more properly, evaluated). A Java compiler must operate according to the rules laid out in this section. The rules recognize only constant expressions; in this example, the expression `n > 2` is not a constant expression as defined in [¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions").

As another example, a Java compiler will accept the code:

void flow(boolean flag) {
    int k;
    if (flag)
        k = 3;
    else
        k = 4;
    System.out.println(k);
}

as far as definite assignment of `k` is concerned, because the rules outlined in this section allow it to tell that `k` is assigned no matter whether the `flag` is `true` or `false`. But the rules do not accept the variation:

void flow(boolean flag) {
    int k;
    if (flag)
        k = 3;
    if (!flag)
        k = 4;
    System.out.println(k);  /\* k is not "definitely assigned"
                               before this statement \*/
}

and so compiling this program must cause a compile-time error to occur.

  

**Example 16-3. Definite Unassignment**

A Java compiler will accept the code:

void unflow(boolean flag) {
    final int k;
    if (flag) {
        k = 3;
        System.out.println(k);
    }
    else {
        k = 4;
        System.out.println(k);
    }
}

as far as definite unassignment of `k` is concerned, because the rules outlined in this section allow it to tell that `k` is assigned at most once (indeed, exactly once) no matter whether the `flag` is `true` or `false`. But the rules do not accept the variation:

void unflow(boolean flag) {
    final int k;
    if (flag) {
        k = 3;
        System.out.println(k);
    }
    if (!flag) {
        k = 4;
        System.out.println(k);  /\* k is not "definitely unassigned"
                                   before this statement \*/
    }
}

and so compiling this program must cause a compile-time error to occur.

  

In order to precisely specify all the cases of definite assignment, the rules in this section define several technical terms:

*   whether a variable is _definitely assigned before_ a statement or expression;
*   whether a variable is _definitely unassigned before_ a statement or expression;
*   whether a variable is _definitely assigned after_ a statement or expression; and
*   whether a variable is _definitely unassigned after_ a statement or expression.
    

For boolean-valued expressions, the last two are refined into four cases:

*   whether a variable is _definitely assigned after_ the expression _when true_;
*   whether a variable is _definitely unassigned after_ the expression _when true_;
*   whether a variable is _definitely assigned after_ the expression _when false_; and
*   whether a variable is _definitely unassigned_ after the expression _when false_.
    

Here, _when true_ and _when false_ refer to the value of the expression.

For example, the local variable `k` is definitely assigned a value after evaluation of the expression:

a && ((k=m) > 5)

when the expression is `true` but not when the expression is `false` (because if `a` is false, then the assignment to `k` is not necessarily executed (more properly, evaluated)).

The phrase "V is definitely assigned after X" (where V is a local variable and X is a statement or expression) means "V is definitely assigned after X if X completes normally". If X completes abruptly, the assignment need not have occurred, and the rules stated here take this into account.

A peculiar consequence of this definition is that "V is definitely assigned after `break;`" is always true! Because a `break` statement never completes normally, it is vacuously true that V has been assigned a value if the `break` statement completes normally.

The statement "V is definitely unassigned after X" (where V is a variable and X is a statement or expression) means "V is definitely unassigned after X if X completes normally".

An even more peculiar consequence of this definition is that "V is definitely unassigned after `break;`" is always true! Because a `break` statement never completes normally, it is vacuously true that V has not been assigned a value if the `break` statement completes normally. (For that matter, it is also vacuously true that the moon is made of green cheese if the `break` statement completes normally.)

In all, there are four possibilities for a variable V after a statement or expression has been executed:

*   V is definitely assigned and is not definitely unassigned.
    
    (The flow analysis rules prove that an assignment to V has occurred.)
*   V is definitely unassigned and is not definitely assigned.
    
    (The flow analysis rules prove that an assignment to V has not occurred.)
*   V is not definitely assigned and is not definitely unassigned.
    
    (The rules cannot prove whether or not an assignment to V has occurred.)
*   V is definitely assigned and is definitely unassigned.
    
    (It is impossible for the statement or expression to complete normally.)
    

To shorten the rules, the customary abbreviation "iff" is used to mean "if and only if". We also use an abbreviation convention: if a rule contains one or more occurrences of "\[un\]assigned" then it stands for two rules, one with every occurrence of "\[un\]assigned" replaced by "definitely assigned" and one with every occurrence of "\[un\]assigned" replaced by "definitely unassigned".

For example:

*   V is \[un\]assigned after an empty statement iff it is \[un\]assigned before the empty statement.
    

should be understood to stand for two rules:

*   V is definitely assigned after an empty statement iff it is definitely assigned before the empty statement.
*   V is definitely unassigned after an empty statement iff it is definitely unassigned before the empty statement.
    

Throughout the rest of this chapter, we will, unless explicitly stated otherwise, write V to represent a local variable or blank `final` field which is in scope ([¬ß6.3](jls-6.html#jls-6.3 "6.3. Scope of a Declaration")). Likewise, we will use `a`, `b`, `c`, and `e` to represent expressions, and S and T to represent statements. We will use the phrase "`a` is V" to mean that `a` is either the simple name of the variable V, or V's simple name qualified by `this` (ignoring parentheses). We will use the phrase "`a` is not V" to mean the negation of "`a` is V".

The definite unassignment analysis of loop statements raises a special problem. Consider the statement ``while (`e`) S``. In order to determine whether V is definitely unassigned within some subexpression of `e`, we need to determine whether V is definitely unassigned before `e`. One might argue, by analogy with the rule for definite assignment ([¬ß16.2.10](jls-16.html#jls-16.2.10 "16.2.10. while Statements")), that V is definitely unassigned before `e` iff it is definitely unassigned before the `while` statement. However, such a rule is inadequate for our purposes. If `e` evaluates to `true`, the statement S will be executed. Later, if V is assigned by S, then in the following iteration(s) V will have already been assigned when `e` is evaluated. Under the rule suggested above, it would be possible to assign V multiple times, which is exactly what we have sought to avoid by introducing these rules.

A revised rule would be: "V is definitely unassigned before `e` iff it is definitely unassigned before the `while` statement and definitely unassigned after S". However, when we formulate the rule for S, we find: "V is definitely unassigned before S iff it is definitely unassigned after `e` when true". This leads to a circularity. In effect, V is definitely unassigned _before_ the loop condition `e` only if it is unassigned _after_ the loop as a whole!

We break this vicious circle using a hypothetical analysis of the loop condition and body. For example, if we assume that V is definitely unassigned before `e` (regardless of whether V really is definitely unassigned before `e`), and can then prove that V was definitely unassigned after `e` then we know that `e` does not assign V. This is stated more formally as:

Assuming V is definitely unassigned before `e`, V is definitely unassigned after `e`.

Variations on the above analysis are used to define well founded definite unassignment rules for all loop statements in the Java programming language.

16.1. Definite Assignment and Expressions
-----------------------------------------

### 16.1.1. Boolean Constant Expressions

*   V is \[un\]assigned after any constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")) whose value is `true` when false.
*   V is \[un\]assigned after any constant expression whose value is `false` when true.
*   V is \[un\]assigned after any constant expression whose value is `true` when true iff V is \[un\]assigned before the constant expression.
*   V is \[un\]assigned after any constant expression whose value is `false` when false iff V is \[un\]assigned before the constant expression.
*   V is \[un\]assigned after a boolean-valued constant expression `e` iff V is \[un\]assigned after `e` when true and V is \[un\]assigned after `e` when false.
    
    This is equivalent to saying that V is \[un\]assigned after `e` iff V is \[un\]assigned before `e`.
    

Because a constant expression whose value is `true` never has the value `false`, and a constant expression whose value is `false` never has the value `true`, the first two rules are vacuously satisfied. They are helpful in analyzing expressions involving the operators `&&` ([¬ß16.1.2](jls-16.html#jls-16.1.2 "16.1.2. Conditional-And Operator &&")), `||` ([¬ß16.1.3](jls-16.html#jls-16.1.3 "16.1.3. Conditional-Or Operator ||")), `!` ([¬ß16.1.4](jls-16.html#jls-16.1.4 "16.1.4. Logical Complement Operator !")), and `? :` ([¬ß16.1.5](jls-16.html#jls-16.1.5 "16.1.5. Conditional Operator ? :")).

### 16.1.2. Conditional-And Operator `&&`

*   V is \[un\]assigned after `a` `&&` `b` ([¬ß15.23](jls-15.html#jls-15.23 "15.23. Conditional-And Operator &&")) when true iff V is \[un\]assigned after `b` when true.
*   V is \[un\]assigned after `a` `&&` `b` when false iff V is \[un\]assigned after `a` when false and V is \[un\]assigned after `b` when false.
*   V is \[un\]assigned before `a` iff V is \[un\]assigned before `a` `&&` `b`.
*   V is \[un\]assigned before `b` iff V is \[un\]assigned after `a` when true.
*   V is \[un\]assigned after `a` `&&` `b` iff V is \[un\]assigned after `a` `&&` `b` when true and V is \[un\]assigned after `a` `&&` `b` when false.
    

### 16.1.3. Conditional-Or Operator `||`

*   V is \[un\]assigned after `a` `||` `b` ([¬ß15.24](jls-15.html#jls-15.24 "15.24. Conditional-Or Operator ||")) when true iff V is \[un\]assigned after `a` when true and V is \[un\]assigned after `b` when true.
*   V is \[un\]assigned after `a` `||` `b` when false iff V is \[un\]assigned after `b` when false.
*   V is \[un\]assigned before `a` iff V is \[un\]assigned before `a` `||` `b`.
*   V is \[un\]assigned before `b` iff V is \[un\]assigned after `a` when false.
*   V is \[un\]assigned after `a` `||` `b` iff V is \[un\]assigned after `a` `||` `b` when true and V is \[un\]assigned after `a` `||` `b` when false.
    

### 16.1.4. Logical Complement Operator `!`

*   V is \[un\]assigned after `!``a` ([¬ß15.15.6](jls-15.html#jls-15.15.6 "15.15.6. Logical Complement Operator !")) when true iff V is \[un\]assigned after `a` when false.
*   V is \[un\]assigned after `!``a` when false iff V is \[un\]assigned after `a` when true.
*   V is \[un\]assigned before `a` iff V is \[un\]assigned before `!``a`.
*   V is \[un\]assigned after `!``a` iff V is \[un\]assigned after `!``a` when true and V is \[un\]assigned after `!``a` when false.
    
    This is equivalent to saying that V is \[un\]assigned after `!``a` iff V is \[un\]assigned after `a`.
    

### 16.1.5. Conditional Operator `? :`

Suppose that `b` and `c` are boolean-valued expressions.

*   V is \[un\]assigned after `a` `?` `b` `:` `c` ([¬ß15.25](jls-15.html#jls-15.25 "15.25. Conditional Operator ? :")) when true iff V is \[un\]assigned after `b` when true and V is \[un\]assigned after `c` when true.
*   V is \[un\]assigned after `a` `?` `b` `:` `c` when false iff V is \[un\]assigned after `b` when false and V is \[un\]assigned after `c` when false.
*   V is \[un\]assigned before `a` iff V is \[un\]assigned before `a` `?` `b` `:` `c`.
*   V is \[un\]assigned before `b` iff V is \[un\]assigned after `a` when true.
*   V is \[un\]assigned before `c` iff V is \[un\]assigned after `a` when false.
*   V is \[un\]assigned after `a` `?` `b` `:` `c` iff V is \[un\]assigned after `a` `?` `b` `:` `c` when true and V is \[un\]assigned after `a` `?` `b` `:` `c` when false.
    

### 16.1.6. Conditional Operator `? :`

Suppose that `b` and `c` are expressions that are not boolean-valued.

*   V is \[un\]assigned after `a` `?` `b` `:` `c` ([¬ß15.25](jls-15.html#jls-15.25 "15.25. Conditional Operator ? :")) iff V is \[un\]assigned after `b` and V is \[un\]assigned after `c`.
*   V is \[un\]assigned before `a` iff V is \[un\]assigned before `a` `?` `b` `:` `c`.
*   V is \[un\]assigned before `b` iff V is \[un\]assigned after `a` when true.
*   V is \[un\]assigned before `c` iff V is \[un\]assigned after `a` when false.
    

### 16.1.7. Other Expressions of Type `boolean`

Suppose that `e` is an expression of type `boolean` and is not a boolean constant expression, logical complement expression `!``a`, conditional-and expression `a` `&&` `b`, conditional-or expression `a` `||` `b`, or conditional expression `a` `?` `b` `:` `c`.

*   V is \[un\]assigned after `e` when true iff V is \[un\]assigned after `e`.
*   V is \[un\]assigned after `e` when false iff V is \[un\]assigned after `e`.
    

### 16.1.8. Assignment Expressions

Consider an assignment expression `a` `=` `b`, `a` `+=` `b`, `a` `-=` `b`, `a` `*=` `b`, `a` `/=` `b`, `a` `%=` `b`, `a` `<<=` `b`, `a` `>>=` `b`, `a` `>>>=` `b`, `a` `&=` `b`, `a` `|=` `b`, or `a` `^=` `b` ([¬ß15.26](jls-15.html#jls-15.26 "15.26. Assignment Operators")).

*   V is definitely assigned after the assignment expression iff either:
    
    *   `a` is V, or
        
    *   V is definitely assigned after `b`.
        
*   V is definitely unassigned after the assignment expression iff `a` is not V and V is definitely unassigned after `b`.
*   V is \[un\]assigned before `a` iff V is \[un\]assigned before the assignment expression.
*   V is \[un\]assigned before `b` iff V is \[un\]assigned after `a`.
    

Note that if `a` is V and V is not definitely assigned before a compound assignment such as `a` `&=` `b`, then a compile-time error will necessarily occur. The first rule for definite assignment stated above includes the disjunct "`a` is V" even for compound assignment expressions, not just simple assignments, so that V will be considered to have been definitely assigned at later points in the code. Including the disjunct "`a` is V" does not affect the binary decision as to whether a program is acceptable or will result in a compile-time error, but it affects how many different points in the code may be regarded as erroneous, and so in practice it can improve the quality of error reporting. A similar remark applies to the inclusion of the conjunct "`a` is not V" in the first rule for definite unassignment stated above.

### 16.1.9. Operators `++` and `--`

*   V is definitely assigned after `++``a` ([¬ß15.15.1](jls-15.html#jls-15.15.1 "15.15.1. Prefix Increment Operator ++")), `--``a` ([¬ß15.15.2](jls-15.html#jls-15.15.2 "15.15.2. Prefix Decrement Operator --")), `a``++` (x Increment Operator ++">¬ß15.14.2), or `a``--` ([¬ß15.14.3](jls-15.html#jls-15.14.3 "15.14.3. Postfix Decrement Operator --")) iff either `a` is V or V is definitely assigned after the operand expression.

*   V is definitely unassigned after `++``a`, `--``a`, `a``++`, or `a``--` iff `a` is not V and V is definitely unassigned after the operand expression.
*   V is \[un\]assigned before `a` iff V is \[un\]assigned before `++``a`, `--``a`, `a``++`, or `a``--`.
    

### 16.1.10. Other Expressions

If an expression is not a boolean constant expression, and is not a preincrement expression `++``a`, predecrement expression `--``a`, postincrement expression `a``++`, postdecrement expression `a``--`, logical complement expression `!``a`, conditional-and expression `a` `&&` `b`, conditional-or expression `a` `||` `b`, conditional expression `a` `?` `b` `:` `c`, or assignment expression, then the following rules apply:

*   If the expression has no subexpressions, V is \[un\]assigned after the expression iff V is \[un\]assigned before the expression.
    
    This case applies to literals, names, `this` (both qualified and unqualified), unqualified class instance creation expressions with no arguments, initialized array creation expressions whose initializers contain no expressions, unqualified superclass field access expressions, named method invocations with no arguments, and unqualified superclass method invocations with no arguments.
*   If the expression has subexpressions, V is \[un\]assigned after the expression iff V is \[un\]assigned after its rightmost immediate subexpression.
    

There is a piece of subtle reasoning behind the assertion that a variable V can be known to be definitely unassigned after a method invocation. Taken by itself, at face value and without qualification, such an assertion is not always true, because an invoked method can perform assignments. But it must be remembered that, for the purposes of the Java programming language, the concept of definite unassignment is applied only to blank `final` variables. If V is a blank `final` local variable, then only the method to which its declaration belongs can perform assignments to V. If V is a blank `final` field, then only a constructor or an initializer for the class containing the declaration for V can perform assignments to V; no method can perform assignments to V. Finally, explicit constructor invocations ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations")) are handled specially ([¬ß16.9](jls-16.html#jls-16.9 "16.9. Definite Assignment, Constructors, and Instance Initializers")); although they are syntactically similar to expression statements containing method invocations, they are not expression statements and therefore the rules of this section do not apply to explicit constructor invocations.

For any immediate subexpression `y` of an expression `x`, V is \[un\]assigned before `y` iff one of the following is true:

*   `y` is the leftmost immediate subexpression of `x` and V is \[un\]assigned before `x`.
*   `y` is the right-hand operand of a binary operator and V is \[un\]assigned after the left-hand operand.
*   `x` is an array access, `y` is the subexpression within the brackets, and V is \[un\]assigned after the subexpression before the brackets.
*   `x` is a primary method invocation expression, `y` is the first argument expression in the method invocation expression, and V is \[un\]assigned after the primary expression that computes the target object.
*   `x` is a method invocation expression or a class instance creation expression; `y` is an argument expression, but not the first; and V is \[un\]assigned after the argument expression to the left of `y`.
*   `x` is a qualified class instance creation expression, `y` is the first argument expression in the class instance creation expression, and V is \[un\]assigned after the primary expression that computes the qualifying object.
*   `x` is an array instance creation expression; `y` is a dimension expression, but not the first; and V is \[un\]assigned after the dimension expression to the left of `y`.
*   `x` is an array instance creation expression initialized via an array initializer; `y` is the array initializer in `x`; and V is \[un\]assigned after the dimension expression to the left of `y`.
    

16.2. Definite Assignment and Statements
----------------------------------------

### 16.2.1. Empty Statements

*   V is \[un\]assigned after an empty statement ([¬ß14.6](jls-14.html#jls-14.6 "14.6. The Empty Statement")) iff it is \[un\]assigned before the empty statement.
    

### 16.2.2. Blocks

*   A blank `final` member field V is definitely assigned (and moreover is not definitely unassigned) before the block ([¬ß14.2](jls-14.html#jls-14.2 "14.2. Blocks")) that is the body of any method in the scope of V and before the declaration of any class declared within the scope of V.
*   A local variable V is definitely unassigned (and moreover is not definitely assigned) before the block that is the body of the constructor, method, instance initializer or static initializer that declares V.
*   Let C be a class declared within the scope of V. Then V is definitely assigned before the block that is the body of any constructor, method, instance initializer, or static initializer declared in C iff V is definitely assigned before the declaration of C.
    
    Note that there are no rules that would allow us to conclude that V is definitely unassigned before the block that is the body of any constructor, method, instance initializer, or static initializer declared in C. We can informally conclude that V is not definitely unassigned before the block that is the body of any constructor, method, instance initializer, or static initializer declared in C, but there is no need for such a rule to be stated explicitly.
*   V is \[un\]assigned after an empty block iff V is \[un\]assigned before the empty block.
*   V is \[un\]assigned after a non-empty block iff V is \[un\]assigned after the last statement in the block.
*   V is \[un\]assigned before the first statement of the block iff V is \[un\]assigned before the block.
*   V is \[un\]assigned before any other statement S of the block iff V is \[un\]assigned after the statement immediately preceding S in the block.
    

We say that V is definitely unassigned everywhere in a block B iff:

*   V is definitely unassigned before B.
*   V is definitely assigned after `e` in every assignment expression V `=` `e`, V `+=` `e`, V `-=` `e`, V `*=` `e`, V `/=` `e`, V `%=` `e`, V `<<=` `e`, V `>>=` `e`, V `>>>=` `e`, V `&=` `e`, V `|=` `e`, or V `^=` `e` that occurs in B.
*   V is definitely assigned before every expression `++`V, `--`V, V`++`, or V`--` that occurs in B.
    

These conditions are counterintuitive and require some explanation. Consider a simple assignment V `=` `e`. If V is definitely assigned after `e`, then either:

*   The assignment occurs in dead code, and V is vacuously definitely assigned. In this case, the assignment will not actually take place, and we can assume that V is not being assigned by the assignment expression. Or:
*   V was already assigned by an earlier expression prior to `e`. In this case the current assignment will cause a compile-time error.
    

So, we can conclude that if the conditions are met by a program that causes no compile time error, then any assignments to V in B will not actually take place at run time.

### 16.2.3. Local Class Declaration Statements

*   V is \[un\]assigned after a local class declaration statement ([¬ß14.3](jls-14.html#jls-14.3 "14.3. Local Class Declarations")) iff V is \[un\]assigned before the local class declaration statement.
    

### 16.2.4. Local Variable Declaration Statements

*   V is \[un\]assigned after a local variable declaration statement ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements")) that contains no variable initializers iff V is \[un\]assigned before the local variable declaration statement.
*   V is definitely assigned after a local variable declaration statement that contains at least one variable initializer iff either V is definitely assigned after the last variable initializer in the local variable declaration statement or the last variable initializer in the declaration is in the declarator that declares V.
*   V is definitely unassigned after a local variable declaration statement that contains at least one variable initializer iff V is definitely unassigned after the last variable initializer in the local variable declaration statement and the last variable initializer in the declaration is not in the declarator that declares V.
*   V is \[un\]assigned before the first variable initializer in a local variable declaration statement iff V is \[un\]assigned before the local variable declaration statement.
*   V is definitely assigned before any variable initializer `e` other than the first one in the local variable declaration statement iff either V is definitely assigned after the variable initializer to the left of `e` or the initializer expression to the left of `e` is in the declarator that declares V.
*   V is definitely unassigned before any variable initializer `e` other than the first one in the local variable declaration statement iff V is definitely unassigned after the variable initializer to the left of `e` and the initializer expression to the left of `e` is not in the declarator that declares V.
    

### 16.2.5. Labeled Statements

*   V is \[un\]assigned after a labeled statement `L` `:` S (where `L` is a label) ([¬ß14.7](jls-14.html#jls-14.7 "14.7. Labeled Statements")) iff V is \[un\]assigned after S and V is \[un\]assigned before every `break` statement that may exit the labeled statement `L` `:` S.
*   V is \[un\]assigned before S iff V is \[un\]assigned before `L` `:` S.
    

### 16.2.6. Expression Statements

*   V is \[un\]assigned after an expression statement `e``;` ([¬ß14.8](jls-14.html#jls-14.8 "14.8. Expression Statements")) iff it is \[un\]assigned after `e`.
*   V is \[un\]assigned before `e` iff it is \[un\]assigned before `e``;`.
    

### 16.2.7. `if` Statements

The following rules apply to a statement ``if (`e`) S`` ([¬ß14.9.1](jls-14.html#jls-14.9.1 "14.9.1. The if-then Statement")):

*   V is \[un\]assigned after ``if (`e`) S`` iff V is \[un\]assigned after S and V is \[un\]assigned after `e` when false.
*   V is \[un\]assigned before `e` iff V is \[un\]assigned before ``if (`e`) S``.
*   V is \[un\]assigned before S iff V is \[un\]assigned after `e` when true.
    

The following rules apply to a statement `if (e) S else T` ([¬ß14.9.2](jls-14.html#jls-14.9.2 "14.9.2. The if-then-else Statement")):

*   V is \[un\]assigned after ``if (`e`) S else T`` iff V is \[un\]assigned after S and V is \[un\]assigned after T.
*   V is \[un\]assigned before `e` iff V is \[un\]assigned before ``if (`e`) S else T``.
*   V is \[un\]assigned before S iff V is \[un\]assigned after `e` when true.
*   V is \[un\]assigned before T iff V is \[un\]assigned after `e` when false.
    

### 16.2.8. `assert` Statements

The following rules apply both to a statement `` assert `e1` `` and to a statement `` assert `e1` : `e2` `` ([¬ß14.10](jls-14.html#jls-14.10 "14.10. The assert Statement")):

*   V is \[un\]assigned before `e1` iff V is \[un\]assigned before the `assert` statement.
*   V is definitely assigned after the `assert` statement iff V is definitely assigned before the `assert` statement.
*   V is definitely unassigned after the `assert` statement iff V is definitely unassigned before the `assert` statement and V is definitely unassigned after `e1` when true.
    

The following rule applies to a statement `` assert `e1` : `e2` `` :

*   V is \[un\]assigned before `e2` iff V is \[un\]assigned after `e1` when false.
    

### 16.2.9. `switch` Statements

*   V is \[un\]assigned after a `switch` statement ([¬ß14.11](jls-14.html#jls-14.11 "14.11. The switch Statement")) iff all of the following are true:
    
    *   Either there is a `default` label in the switch block or V is \[un\]assigned after the switch expression.
        
    *   Either there are no switch labels in the switch block that do not begin a block-statement-group (that is, there are no switch labels immediately before the "`}`" that ends the switch block) or V is \[un\]assigned after the switch expression.
        
    *   Either the switch block contains no block-statement-groups or V is \[un\]assigned after the last block-statement of the last block-statement-group.
        
    *   V is \[un\]assigned before every `break` statement that may exit the `switch` statement.
        
*   V is \[un\]assigned before the switch expression iff V is \[un\]assigned before the `switch` statement.
    

If a switch block contains at least one block-statement-group, then the following rules also apply:

*   V is \[un\]assigned before the first block-statement of the first block-statement-group in the switch block iff V is \[un\]assigned after the switch expression.
*   V is \[un\]assigned before the first block-statement of any block-statement-group other than the first iff V is \[un\]assigned after the switch expression and V is \[un\]assigned after the preceding block-statement.
    

### 16.2.10. `while` Statements

*   V is \[un\]assigned after ``while (`e`) S`` ([¬ß14.12](jls-14.html#jls-14.12 "14.12. The while Statement")) iff V is \[un\]assigned after `e` when false and V is \[un\]assigned before every `break` statement for which the `while` statement is the break target.
*   V is definitely assigned before `e` iff V is definitely assigned before the `while` statement.
*   V is definitely unassigned before `e` iff all of the following are true:
    
    *   V is definitely unassigned before the `while` statement.
        
    *   Assuming V is definitely unassigned before `e`, V is definitely unassigned after S.
        
    *   Assuming V is definitely unassigned before `e`, V is definitely unassigned before every `continue` statement for which the `while` statement is the continue target.
        
*   V is \[un\]assigned before S iff V is \[un\]assigned after `e` when true.
    

### 16.2.11. `do` Statements

*   V is \[un\]assigned after ``do S while (`e`);`` ([¬ß14.13](jls-14.html#jls-14.13 "14.13. The do Statement")) iff V is \[un\]assigned after `e` when false and V is \[un\]assigned before every `break` statement for which the `do` statement is the break target.
*   V is definitely assigned before S iff V is definitely assigned before the `do` statement.
*   V is definitely unassigned before S iff all of the following are true:
    
    *   V is definitely unassigned before the `do` statement.
        
    *   Assuming V is definitely unassigned before S, V is definitely unassigned after `e` when true.
        
*   V is \[un\]assigned before `e` iff V is \[un\]assigned after S and V is \[un\]assigned before every `continue` statement for which the `do` statement is the continue target.
    

### 16.2.12. `for` Statements

The rules herein cover the basic `for` statement ([¬ß14.14.1](jls-14.html#jls-14.14.1 "14.14.1. The basic for Statement")). Since the enhanced `for` statement ([¬ß14.14.2](jls-14.html#jls-14.14.2 "14.14.2. The enhanced for statement")) is defined by translation to a basic `for` statement, no special rules need to be provided for it.

*   V is \[un\]assigned after a `for` statement iff both of the following are true:
    
    *   Either a condition expression is not present or V is \[un\]assigned after the condition expression when false.
        
    *   V is \[un\]assigned before every `break` statement for which the `for` statement is the break target.
        
*   V is \[un\]assigned before the initialization part of the `for` statement iff V is \[un\]assigned before the `for` statement.
*   V is definitely assigned before the condition part of the `for` statement iff V is definitely assigned after the initialization part of the `for` statement.
*   V is definitely unassigned before the condition part of the `for` statement iff all of the following are true:
    
    *   V is definitely unassigned after the initialization part of the `for` statement.
        
    *   Assuming V is definitely unassigned before the condition part of the `for` statement, V is definitely unassigned after the contained statement.
        
    *   Assuming V is definitely unassigned before the contained statement, V is definitely unassigned before every `continue` statement for which the `for` statement is the continue target.
        
*   V is \[un\]assigned before the contained statement iff either of the following is true:
    
    *   A condition expression is present and V is \[un\]assigned after the condition expression when true.
        
    *   No condition expression is present and V is \[un\]assigned after the initialization part of the `for` statement.
        
*   V is \[un\]assigned before the incrementation part of the `for` statement iff V is \[un\]assigned after the contained statement and V is \[un\]assigned before every `continue` statement for which the `for` statement is the continue target.
    

#### 16.2.12.1. Initialization Part of `for` Statement

*   If the initialization part of the `for` statement is a local variable declaration statement, the rules of [¬ß16.2.4](jls-16.html#jls-16.2.4 "16.2.4. Local Variable Declaration Statements") apply.
*   Otherwise, if the initialization part is empty, then V is \[un\]assigned after the initialization part iff V is \[un\]assigned before the initialization part.
*   Otherwise, three rules apply:
    
    *   V is \[un\]assigned after the initialization part iff V is \[un\]assigned after the last expression statement in the initialization part.
        
    *   V is \[un\]assigned before the first expression statement in the initialization part iff V is \[un\]assigned before the initialization part.
        
    *   V is \[un\]assigned before an expression statement S other than the first in the initialization part iff V is \[un\]assigned after the expression statement immediately preceding S.
        
    

#### 16.2.12.2. Incrementation Part of `for` Statement

*   If the incrementation part of the `for` statement is empty, then V is \[un\]assigned after the incrementation part iff V is \[un\]assigned before the incrementation part.
*   Otherwise, three rules apply:
    
    *   V is \[un\]assigned after the incrementation part iff V is \[un\]assigned after the last expression statement in the incrementation part.
        
    *   V is \[un\]assigned before the first expression statement in the incrementation part iff V is \[un\]assigned before the incrementation part.
        
    *   V is \[un\]assigned before an expression statement S other than the first in the incrementation part iff V is \[un\]assigned after the expression statement immediately preceding S.
        
    

### 16.2.13. `break`, `continue`, `return`, and `throw` Statements

*   By convention, we say that V is \[un\]assigned after any `break`, `continue`, `return`, or `throw` statement ([¬ß14.15](jls-14.html#jls-14.15 "14.15. The break Statement"), [¬ß14.16](jls-14.html#jls-14.16 "14.16. The continue Statement"), [¬ß14.17](jls-14.html#jls-14.17 "14.17. The return Statement"), [¬ß14.18](jls-14.html#jls-14.18 "14.18. The throw Statement")).
    
    The notion that a variable is "\[un\]assigned after" a statement or expression really means "is \[un\]assigned after the statement or expression completes normally". Because a `break`, `continue`, `return`, or `throw` statement never completes normally, it vacuously satisfies this notion.
*   In a `return` statement with an expression `e` or a `throw` statement with an expression `e`, V is \[un\]assigned before `e` iff V is \[un\]assigned before the `return` or `throw` statement.
    

### 16.2.14. `synchronized` Statements

*   V is \[un\]assigned after ``synchronized (`e`) S`` ([¬ß14.19](jls-14.html#jls-14.19 "14.19. The synchronized Statement")) iff V is \[un\]assigned after S.
*   V is \[un\]assigned before `e` iff V is \[un\]assigned before the statement ``synchronized (`e`) S``.
*   V is \[un\]assigned before S iff V is \[un\]assigned after `e`.
    

### 16.2.15. `try` Statements

These rules apply to every `try` statement ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")), whether or not it has a `finally` block:

*   V is \[un\]assigned before the `try` block iff V is \[un\]assigned before the `try` statement.
*   V is definitely assigned before a `catch` block iff V is definitely assigned before the `try` block.
*   V is definitely unassigned before a `catch` block iff all of the following are true:
    
    *   V is definitely unassigned after the `try` block.
        
    *   V is definitely unassigned before every `return` statement that belongs to the `try` block.
        
    *   V is definitely unassigned after `e` in every statement of the form `throw` `e` that belongs to the `try` block.
        
    *   V is definitely unassigned after every `assert` statement that occurs in the `try` block.
        
    *   V is definitely unassigned before every `break` statement that belongs to the `try` block and whose break target contains (or is) the `try` statement.
        
    *   V is definitely unassigned before every `continue` statement that belongs to the `try` block and whose continue target contains the `try` statement.
        
    

If a `try` statement does not have a `finally` block, then this rule also applies:

*   V is \[un\]assigned after the `try` statement iff V is \[un\]assigned after the `try` block and V is \[un\]assigned after every `catch` block in the `try` statement.
    

If a `try` statement does have a `finally` block, then these rules also apply:

*   V is definitely assigned after the `try` statement iff at least one of the following is true:
    
    *   V is definitely assigned after the `try` block and V is definitely assigned after every `catch` block in the `try` statement.
        
    *   V is definitely assigned after the `finally` block.
        
    *   V is definitely unassigned after a `try` statement iff V is definitely unassigned after the `finally` block.
        
*   V is definitely assigned before the `finally` block iff V is definitely assigned before the `try` statement.
*   V is definitely unassigned before the `finally` block iff all of the following are true:
    
    *   V is definitely unassigned after the `try` block.
        
    *   V is definitely unassigned before every `return` statement that belongs to the `try` block.
        
    *   V is definitely unassigned after `e` in every statement of the form `throw` `e` that belongs to the `try` block.
        
    *   V is definitely unassigned after every `assert` statement that occurs in the `try` block.
        
    *   V is definitely unassigned before every `break` statement that belongs to the `try` block and whose break target contains (or is) the `try` statement.
        
    *   V is definitely unassigned before every `continue` statement that belongs to the `try` block and whose continue target contains the `try` statement.
        
    *   V is definitely unassigned after every `catch` block of the `try` statement.
        
    

16.3. Definite Assignment and Parameters
----------------------------------------

*   A formal parameter V of a method or constructor ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters"), [¬ß8.8.1](jls-8.html#jls-8.8.1 "8.8.1. Formal Parameters")) is definitely assigned (and moreover is not definitely unassigned) before the body of the method or constructor.
*   An exception parameter V of a `catch` clause ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) is definitely assigned (and moreover is not definitely unassigned) before the body of the `catch` clause.
    

16.4. Definite Assignment and Array Initializers
------------------------------------------------

*   V is \[un\]assigned after an empty array initializer ([¬ß10.6](jls-10.html#jls-10.6 "10.6. Array Initializers")) iff V is \[un\]assigned before the empty array initializer.
*   V is \[un\]assigned after a non-empty array initializer iff V is \[un\]assigned after the last variable initializer in the array initializer.
*   V is \[un\]assigned before the first variable initializer of the array initializer iff V is \[un\]assigned before the array initializer.
*   V is \[un\]assigned before any other variable initializer `e` of the array initializer iff V is \[un\]assigned after the variable initializer to the left of `e` in the array initializer.
    

16.5. Definite Assignment and Enum Constants
--------------------------------------------

The rules determining when a variable is definitely assigned or definitely unassigned before an enum constant ([¬ß8.9.1](jls-8.html#jls-8.9.1 "8.9.1. Enum Constants")) are given in [¬ß16.8](jls-16.html#jls-16.8 "16.8. Definite Assignment and Static Initializers").

This is because an enum constant is essentially a `static` `final` field ([¬ß8.3.1.1](jls-8.html#jls-8.3.1.1 "8.3.1.1. static Fields"), [¬ß8.3.1.2](jls-8.html#jls-8.3.1.2 "8.3.1.2. final Fields")) that is initialized with a class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")).

*   V is definitely assigned before the declaration of a class body of an enum constant with no arguments that is declared within the scope of V iff V is definitely assigned before the enum constant.
*   V is definitely assigned before the declaration of a class body of an enum constant with arguments that is declared within the scope of V iff V is definitely assigned after the last argument expression of the enum constant
    

The definite assignment/unassignment status of any construct within the class body of an enum constant is governed by the usual rules for classes.

*   V is \[un\]assigned before the first argument to an enum constant iff it is \[un\]assigned before the enum constant.
*   V is \[un\]assigned before `y` (an argument of an enum constant, but not the first) iff V is \[un\]assigned after the argument to the left of `y`.
    

16.6. Definite Assignment and Anonymous Classes
-----------------------------------------------

*   V is definitely assigned before an anonymous class declaration ([¬ß15.9.5](jls-15.html#jls-15.9.5 "15.9.5. Anonymous Class Declarations")) that is declared within the scope of V iff V is definitely assigned after the class instance creation expression that declares the anonymous class.
    

It should be clear that if an anonymous class is implicitly defined by an enum constant, the rules of [¬ß16.5](jls-16.html#jls-16.5 "16.5. Definite Assignment and Enum Constants") apply.

16.7. Definite Assignment and Member Types
------------------------------------------

Let C be a class, and let V be a blank `final` member field of C. Then:

*   V is definitely assigned (and moreover, not definitely unassigned) before the declaration of any member type ([¬ß8.5](jls-8.html#jls-8.5 "8.5. Member Type Declarations"), [¬ß9.5](jls-9.html#jls-9.5 "9.5. Member Type Declarations")) of C.
    

Let C be a class declared within the scope of V. Then:

*   V is definitely assigned before a member type declaration of C iff V is definitely assigned before the declaration of C.
    

16.8. Definite Assignment and Static Initializers
-------------------------------------------------

Let C be a class declared within the scope of V. Then:

*   V is definitely assigned before an enum constant ([¬ß8.9.1](jls-8.html#jls-8.9.1 "8.9.1. Enum Constants")) or static variable initializer ([¬ß8.3.2](jls-8.html#jls-8.3.2 "8.3.2. Field Initialization")) of C iff V is definitely assigned before the declaration of C.
    
    Note that there are no rules that would allow us to conclude that V is definitely unassigned before a static variable initializer or enum constant. We can informally conclude that V is not definitely unassigned before any static variable initializer of C, but there is no need for such a rule to be stated explicitly.
    

Let C be a class, and let V be a blank `static` `final` member field of C, declared in C. Then:

*   V is definitely unassigned (and moreover is not definitely assigned) before the leftmost enum constant, static initializer ([¬ß8.7](jls-8.html#jls-8.7 "8.7. Static Initializers")), or static variable initializer of C.
*   V is \[un\]assigned before an enum constant, static initializer, or static variable initializer of C other than the leftmost iff V is \[un\]assigned after the preceding enum constant, static initializer, or static variable initializer of C.
    

Let C be a class, and let V be a blank `static` `final` member field of C, declared in a superclass of C. Then:

*   V is definitely assigned (and moreover is not definitely unassigned) before every enum constant of C.
*   V is definitely assigned (and moreover is not definitely unassigned) before the block that is the body of a static initializer of C.
*   V is definitely assigned (and moreover is not definitely unassigned) before every static variable initializer of C.
    

16.9. Definite Assignment, Constructors, and Instance Initializers
------------------------------------------------------------------

Let C be a class declared within the scope of V. Then:

*   V is definitely assigned before an instance variable initializer ([¬ß8.3.2](jls-8.html#jls-8.3.2 "8.3.2. Field Initialization")) of C iff V is definitely assigned before the declaration of C.
    
    Note that there are no rules that would allow us to conclude that V is definitely unassigned before an instance variable initializer. We can informally conclude that V is not definitely unassigned before any instance variable initializer of C, but there is no need for such a rule to be stated explicitly.
    

Let C be a class, and let V be a blank `final` non-`static` member field of C, declared in C. Then:

*   V is definitely unassigned (and moreover is not definitely assigned) before the leftmost instance initializer ([¬ß8.6](jls-8.html#jls-8.6 "8.6. Instance Initializers")) or instance variable initializer of C.
*   V is \[un\]assigned before an instance initializer or instance variable initializer of C other than the leftmost iff V is \[un\]assigned after the preceding instance initializer or instance variable initializer of C.
    

The following rules hold within the constructors ([¬ß8.8.7](jls-8.html#jls-8.8.7 "8.8.7. Constructor Body")) of class C:

*   V is definitely assigned (and moreover is not definitely unassigned) after an alternate constructor invocation ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations")).
*   V is definitely unassigned (and moreover is not definitely assigned) before an explicit or implicit superclass constructor invocation ([¬ß8.8.7.1](jls-8.html#jls-8.8.7.1 "8.8.7.1. Explicit Constructor Invocations")).
*   If C has no instance initializers or instance variable initializers, then V is not definitely assigned (and moreover is definitely unassigned) after an explicit or implicit superclass constructor invocation.
*   If C has at least one instance initializer or instance variable initializer then V is \[un\]assigned after an explicit or implicit superclass constructor invocation iff V is \[un\]assigned after the rightmost instance initializer or instance variable initializer of C.
    

Let C be a class, and let V be a blank `final` member field of C, declared in a superclass of C. Then:

*   V is definitely assigned (and moreover is not definitely unassigned) before the block that is the body of a constructor or instance initializer of C.
*   V is definitely assigned (and moreover is not definitely unassigned) before every instance variable initializer of C.
    

üçÄ Chapter 17. Threads and Locks
-----------------------------

**Table of Contents**

[17.1. Synchronization](jls-17.html#jls-17.1)
[17.2. Wait Sets and Notification](jls-17.html#jls-17.2)
[17.2.1. Wait](jls-17.html#jls-17.2.1)
[17.2.2. Notification](jls-17.html#jls-17.2.2)
[17.2.3. Interruptions](jls-17.html#jls-17.2.3)
[17.2.4. Interactions of Waits, Notification, and Interruption](jls-17.html#jls-17.2.4)
[17.3. Sleep and Yield](jls-17.html#jls-17.3)
[17.4. Memory Model](jls-17.html#jls-17.4)
[17.4.1. Shared Variables](jls-17.html#jls-17.4.1)
[17.4.2. Actions](jls-17.html#jls-17.4.2)
[17.4.3. Programs and Program Order](jls-17.html#jls-17.4.3)
[17.4.4. Synchronization Order](jls-17.html#jls-17.4.4)
[17.4.5. Happens-before Order](jls-17.html#jls-17.4.5)
[17.4.6. Executions](jls-17.html#jls-17.4.6)
[17.4.7. Well-Formed Executions](jls-17.html#jls-17.4.7)
[17.4.8. Executions and Causality Requirements](jls-17.html#jls-17.4.8)
[17.4.9. Observable Behavior and Nonterminating Executions](jls-17.html#jls-17.4.9)
[17.5. `final` Field Semantics](jls-17.html#jls-17.5)
[17.5.1. Semantics of `final` Fields](jls-17.html#jls-17.5.1)
[17.5.2. Reading `final` Fields During Construction](jls-17.html#jls-17.5.2)
[17.5.3. Subsequent Modification of `final` Fields](jls-17.html#jls-17.5.3)
[17.5.4. Write-Protected Fields](jls-17.html#jls-17.5.4)
[17.6. Word Tearing](jls-17.html#jls-17.6)
[17.7. Non-Atomic Treatment of `double` and `long`](jls-17.html#jls-17.7)

While most of the discussion in the preceding chapters is concerned only with the behavior of code as executed a single statement or expression at a time, that is, by a single _thread_, the Java Virtual Machine can support many threads of execution at once. These threads independently execute code that operates on values and objects residing in a shared main memory. Threads may be supported by having many hardware processors, by time-slicing a single hardware processor, or by time-slicing many hardware processors.

Threads are represented by the `Thread` class. The only way for a user to create a thread is to create an object of this class; each thread is associated with such an object. A thread will start when the `start()` method is invoked on the corresponding `Thread` object.

The behavior of threads, particularly when not correctly synchronized, can be confusing and counterintuitive. This chapter describes the semantics of multithreaded programs; it includes rules for which values may be seen by a read of shared memory that is updated by multiple threads. As the specification is similar to the _memory models_ for different hardware architectures, these semantics are known as the _Java programming language memory model_. When no confusion can arise, we will simply refer to these rules as "the memory model".

These semantics do not prescribe how a multithreaded program should be executed. Rather, they describe the behaviors that multithreaded programs are allowed to exhibit. Any execution strategy that generates only allowed behaviors is an acceptable execution strategy.

17.1. Synchronization
---------------------

The Java programming language provides multiple mechanisms for communicating between threads. The most basic of these methods is _synchronization_, which is implemented using _monitors_. Each object in Java is associated with a monitor, which a thread can _lock_ or _unlock_. Only one thread at a time may hold a lock on a monitor. Any other threads attempting to lock that monitor are blocked until they can obtain a lock on that monitor. A thread _t_ may lock a particular monitor multiple times; each unlock reverses the effect of one lock operation.

The `synchronized` statement ([¬ß14.19](jls-14.html#jls-14.19 "14.19. The synchronized Statement")) computes a reference to an object; it then attempts to perform a lock action on that object's monitor and does not proceed further until the lock action has successfully completed. After the lock action has been performed, the body of the `synchronized` statement is executed. If execution of the body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor.

A `synchronized` method ([¬ß8.4.3.6](jls-8.html#jls-8.4.3.6 "8.4.3.6. synchronized Methods")) automatically performs a lock action when it is invoked; its body is not executed until the lock action has successfully completed. If the method is an instance method, it locks the monitor associated with the instance for which it was invoked (that is, the object that will be known as `this` during execution of the body of the method). If the method is `static`, it locks the monitor associated with the `Class` object that represents the class in which the method is defined. If execution of the method's body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor.

The Java programming language neither prevents nor requires detection of deadlock conditions. Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that do not deadlock, if necessary.

Other mechanisms, such as reads and writes of `volatile` variables and the use of classes in the `java.util.concurrent` package, provide alternative ways of synchronization.

17.2. Wait Sets and Notification
--------------------------------

Every object, in addition to having an associated monitor, has an associated _wait set_. A wait set is a set of threads.

When an object is first created, its wait set is empty. Elementary actions that add threads to and remove threads from wait sets are atomic. Wait sets are manipulated solely through the methods `Object``.``wait`, `Object``.``notify`, and `Object``.``notifyAll`.

Wait set manipulations can also be affected by the interruption status of a thread, and by the `Thread` class's methods dealing with interruption. Additionally, the `Thread` class's methods for sleeping and joining other threads have properties derived from those of wait and notification actions.

### 17.2.1. Wait

_Wait actions_ occur upon invocation of `wait()`, or the timed forms `wait(long millisecs)` and `wait(long millisecs, int nanosecs)`.

A call of `wait(long millisecs)` with a parameter of zero, or a call of `wait(long millisecs, int nanosecs)` with two zero parameters, is equivalent to an invocation of `wait()`.

A thread _returns normally_ from a wait if it returns without throwing an `InterruptedException`.

Let thread _t_ be the thread executing the `wait` method on object _m_, and let _n_ be the number of lock actions by _t_ on _m_ that have not been matched by unlock actions. One of the following actions occurs:

*   If _n_ is zero (i.e., thread _t_ does not already possess the lock for target _m_), then an `IllegalMonitorStateException` is thrown.
*   If this is a timed wait and the `nanosecs` argument is not in the range of `0-999999` or the `millisecs` argument is negative, then an `IllegalArgumentException` is thrown.
*   If thread _t_ is interrupted, then an `InterruptedException` is thrown and _t_'s interruption status is set to false.
*   Otherwise, the following sequence occurs:
    
    1.  Thread _t_ is added to the wait set of object _m_, and performs _n_ unlock actions on _m_.
        
    2.  Thread _t_ does not execute any further instructions until it has been removed from _m_'s wait set. The thread may be removed from the wait set due to any one of the following actions, and will resume sometime afterward:
        
        *   A `notify` action being performed on _m_ in which _t_ is selected for removal from the wait set.
            
        *   A `notifyAll` action being performed on _m_.
            
        *   An `interrupt` action being performed on _t_.
            
        *   If this is a timed wait, an internal action removing _t_ from _m_'s wait set that occurs after at least `millisecs` milliseconds plus `nanosecs` nanoseconds elapse since the beginning of this wait action.
            
        *   An internal action by the implementation. Implementations are permitted, although not encouraged, to perform "spurious wake-ups", that is, to remove threads from wait sets and thus enable resumption without explicit instructions to do so.
            
            Notice that this provision necessitates the Java coding practice of using `wait` only within loops that terminate only when some logical condition that the thread is waiting for holds.
            
        
        Each thread must determine an order over the events that could cause it to be removed from a wait set. That order does not have to be consistent with other orderings, but the thread must behave as though those events occurred in that order.
        
        For example, if a thread _t_ is in the wait set for _m_, and then both an interrupt of _t_ and a notification of _m_ occur, there must be an order over these events. If the interrupt is deemed to have occurred first, then _t_ will eventually return from `wait` by throwing `InterruptedException`, and some other thread in the wait set for _m_ (if any exist at the time of the notification) must receive the notification. If the notification is deemed to have occurred first, then _t_ will eventually return normally from `wait` with an interrupt still pending.
        
    3.  Thread _t_ performs _n_ lock actions on _m_.
        
    4.  If thread _t_ was removed from _m_'s wait set in step 2 due to an interrupt, then _t_'s interruption status is set to false and the `wait` method throws `InterruptedException`.
        
    

### 17.2.2. Notification

Notification actions occur upon invocation of methods `notify` and `notifyAll`.

Let thread _t_ be the thread executing either of these methods on object _m_, and let _n_ be the number of lock actions by _t_ on _m_ that have not been matched by unlock actions. One of the following actions occurs:

*   If _n_ is zero, then an `IllegalMonitorStateException` is thrown.
    
    This is the case where thread _t_ does not already possess the lock for target _m_.
*   If _n_ is greater than zero and this is a `notify` action, then if _m_'s wait set is not empty, a thread _u_ that is a member of _m_'s current wait set is selected and removed from the wait set.
    
    There is no guarantee about which thread in the wait set is selected. This removal from the wait set enables _u_'s resumption in a wait action. Notice, however, that _u_'s lock actions upon resumption cannot succeed until some time after _t_ fully unlocks the monitor for _m_.
*   If _n_ is greater than zero and this is a `notifyAll` action, then all threads are removed from _m_'s wait set, and thus resume.
    
    Notice, however, that only one of them at a time will lock the monitor required during the resumption of wait.
    

### 17.2.3. Interruptions

Interruption actions occur upon invocation of `Thread.interrupt`, as well as methods defined to invoke it in turn, such as `ThreadGroup.interrupt`.

Let _t_ be the thread invoking _u_`.interrupt`, for some thread _u_, where _t_ and _u_ may be the same. This action causes _u_'s interruption status to be set to true.

Additionally, if there exists some object _m_ whose wait set contains _u_, then _u_ is removed from _m_'s wait set. This enables _u_ to resume in a wait action, in which case this wait will, after re-locking _m_'s monitor, throw `InterruptedException`.

Invocations of `Thread.isInterrupted` can determine a thread's interruption status. The `static` method `Thread.interrupted` may be invoked by a thread to observe and clear its own interruption status.

### 17.2.4. Interactions of Waits, Notification, and Interruption

The above specifications allow us to determine several properties having to do with the interaction of waits, notification, and interruption.

If a thread is both notified and interrupted while waiting, it may either:

*   return normally from `wait`, while still having a pending interrupt (in other words, a call to `Thread.interrupted` would return true)
*   return from `wait` by throwing an `InterruptedException`
    

The thread may not reset its interrupt status and return normally from the call to `wait`.

Similarly, notifications cannot be lost due to interrupts. Assume that a set _s_ of threads is in the wait set of an object _m_, and another thread performs a `notify` on _m_. Then either:

*   at least one thread in _s_ must return normally from `wait`, or
*   all of the threads in _s_ must exit `wait` by throwing `InterruptedException`
    

Note that if a thread is both interrupted and woken via `notify`, and that thread returns from `wait` by throwing an `InterruptedException`, then some other thread in the wait set must be notified.

17.3. Sleep and Yield
---------------------

`Thread.sleep` causes the currently executing thread to sleep (temporarily cease execution) for the specified duration, subject to the precision and accuracy of system timers and schedulers. The thread does not lose ownership of any monitors, and resumption of execution will depend on scheduling and the availability of processors on which to execute the thread.

It is important to note that neither `Thread.sleep` nor `Thread.yield` have any synchronization semantics. In particular, the compiler does not have to flush writes cached in registers out to shared memory before a call to `Thread.sleep` or `Thread.yield`, nor does the compiler have to reload values cached in registers after a call to `Thread.sleep` or `Thread.yield`.

For example, in the following (broken) code fragment, assume that `this.done` is a non-`volatile boolean` field:

while (!this.done)
    Thread.sleep(1000);

The compiler is free to read the field `this.done` just once, and reuse the cached value in each execution of the loop. This would mean that the loop would never terminate, even if another thread changed the value of `this.done`.

17.4. Memory Model
------------------

A _memory model_ describes, given a program and an execution trace of that program, whether the execution trace is a legal execution of the program. The Java programming language memory model works by examining each read in an execution trace and checking that the write observed by that read is valid according to certain rules.

The memory model describes possible behaviors of a program. An implementation is free to produce any code it likes, as long as all resulting executions of a program produce a result that can be predicted by the memory model.

This provides a great deal of freedom for the implementor to perform a myriad of code transformations, including the reordering of actions and removal of unnecessary synchronization.

**Example 17.4-1. Incorrectly Synchronized Programs May Exhibit Surprising Behavior**

The semantics of the Java programming language allow compilers and microprocessors to perform optimizations that can interact with incorrectly synchronized code in ways that can produce behaviors that seem paradoxical. Here are some examples of how incorrectly synchronized programs may exhibit surprising behaviors.

Consider, for example, the example program traces shown in [Table 17.4-A](jls-17.html#jls-17.4-A "Table 17.4-A. Surprising results caused by statement reordering - original code"). This program uses local variables `r1` and `r2` and shared variables `A` and `B`. Initially, `A == B == 0`.

**Table 17.4-A. Surprising results caused by statement reordering - original code**

 

Thread 1

Thread 2

1: `r2 = A;`

3: `r1 = B;`

2: `B = 1;`

4: `A = 2;`

  

It may appear that the result `r2 == 2` and `r1 == 1` is impossible. Intuitively, either instruction 1 or instruction 3 should come first in an execution. If instruction 1 comes first, it should not be able to see the write at instruction 4. If instruction 3 comes first, it should not be able to see the write at instruction 2.

If some execution exhibited this behavior, then we would know that instruction 4 came before instruction 1, which came before instruction 2, which came before instruction 3, which came before instruction 4. This is, on the face of it, absurd.

However, compilers are allowed to reorder the instructions in either thread, when this does not affect the execution of that thread in isolation. If instruction 1 is reordered with instruction 2, as shown in the trace in [Table 17.4-B](jls-17.html#jls-17.4-B "Table 17.4-B. Surprising results caused by statement reordering - valid compiler transformation"), then it is easy to see how the result `r2 == 2` and `r1 == 1` might occur.

**Table 17.4-B. Surprising results caused by statement reordering - valid compiler transformation**

 

Thread 1

Thread 2

`B = 1;`

`r1 = B;`

`r2 = A;`

`A = 2;`

  

To some programmers, this behavior may seem "broken". However, it should be noted that this code is improperly synchronized:

*   there is a write in one thread,
*   a read of the same variable by another thread,
*   and the write and read are not ordered by synchronization.
    

This situation is an example of a _data race_ ([¬ß17.4.5](jls-17.html#jls-17.4.5 "17.4.5. Happens-before Order")). When code contains a data race, counterintuitive results are often possible.

Several mechanisms can produce the reordering in [Table 17.4-B](jls-17.html#jls-17.4-B "Table 17.4-B. Surprising results caused by statement reordering - valid compiler transformation"). A Just-In-Time compiler in a Java Virtual Machine implementation may rearrange code, or the processor. In addition, the memory hierarchy of the architecture on which a Java Virtual Machine implementation is run may make it appear as if code is being reordered. In this chapter, we shall refer to anything that can reorder code as a _compiler_.

Another example of surprising results can be seen in [Table 17.4-C](jls-17.html#jls-17.4-C "Table 17.4-C. Surprising results caused by forward substitution"). Initially, `p == q` and `p.x == 0`. This program is also incorrectly synchronized; it writes to shared memory without enforcing any ordering between those writes.

**Table 17.4-C. Surprising results caused by forward substitution**

 

Thread 1

Thread 2

`r1 = p;`

`r6 = p;`

`r2 = r1.x;`

`r6.x = 3;`

`r3 = q;`

 

`r4 = r3.x;`

 

`r5 = r1.x;`

 

  

One common compiler optimization involves having the value read for `r2` reused for `r5`: they are both reads of `r1.x` with no intervening write. This situation is shown in [Table 17.4-D](jls-17.html#jls-17.4-D "Table 17.4-D. Surprising results caused by forward substitution").

**Table 17.4-D. Surprising results caused by forward substitution**

 

Thread 1

Thread 2

`r1 = p;`

`r6 = p;`

`r2 = r1.x;`

`r6.x = 3;`

`r3 = q;`

 

`r4 = r3.x;`

 

`r5 = r2;`

 

  

Now consider the case where the assignment to `r6.x` in Thread 2 happens between the first read of `r1.x` and the read of `r3.x` in Thread 1. If the compiler decides to reuse the value of `r2` for the `r5`, then `r2` and `r5` will have the value `0`, and `r4` will have the value `3`. From the perspective of the programmer, the value stored at `p.x` has changed from `0` to `3` and then changed back.

  

The memory model determines what values can be read at every point in the program. The actions of each thread in isolation must behave as governed by the semantics of that thread, with the exception that the values seen by each read are determined by the memory model. When we refer to this, we say that the program obeys _intra-thread semantics_. Intra-thread semantics are the semantics for single-threaded programs, and allow the complete prediction of the behavior of a thread based on the values seen by read actions within the thread. To determine if the actions of thread _t_ in an execution are legal, we simply evaluate the implementation of thread _t_ as it would be performed in a single-threaded context, as defined in the rest of this specification.

Each time the evaluation of thread _t_ generates an inter-thread action, it must match the inter-thread action _a_ of _t_ that comes next in program order. If _a_ is a read, then further evaluation of _t_ uses the value seen by _a_ as determined by the memory model.

This section provides the specification of the Java programming language memory model except for issues dealing with `final` fields, which are described in [¬ß17.5](jls-17.html#jls-17.5 "17.5. final Field Semantics").

The memory model specified herein is not fundamentally based in the object-oriented nature of the Java programming language. For conciseness and simplicity in our examples, we often exhibit code fragments without class or method definitions, or explicit dereferencing. Most examples consist of two or more threads containing statements with access to local variables, shared global variables, or instance fields of an object. We typically use variables names such as `r1` or `r2` to indicate variables local to a method or thread. Such variables are not accessible by other threads.

### 17.4.1. Shared Variables

Memory that can be shared between threads is called _shared memory_ or _heap memory_.

All instance fields, `static` fields, and array elements are stored in heap memory. In this chapter, we use the term _variable_ to refer to both fields and array elements.

Local variables ([¬ß14.4](jls-14.html#jls-14.4 "14.4. Local Variable Declaration Statements")), formal method parameters ([¬ß8.4.1](jls-8.html#jls-8.4.1 "8.4.1. Formal Parameters")), and exception handler parameters ([¬ß14.20](jls-14.html#jls-14.20 "14.20. The try statement")) are never shared between threads and are unaffected by the memory model.

Two accesses to (reads of or writes to) the same variable are said to be _conflicting_ if at least one of the accesses is a write.

### 17.4.2. Actions

An _inter-thread action_ is an action performed by one thread that can be detected or directly influenced by another thread. There are several kinds of inter-thread action that a program may perform:

*   _Read_ (normal, or non-volatile). Reading a variable.
*   _Write_ (normal, or non-volatile). Writing a variable.
*   _Synchronization actions_, which are:
    
    *   _Volatile read_. A volatile read of a variable.
        
    *   _Volatile write_. A volatile write of a variable.
        
    *   _Lock_. Locking a monitor
        
    *   _Unlock_. Unlocking a monitor.
        
    *   The (synthetic) first and last action of a thread.
        
    *   Actions that start a thread or detect that a thread has terminated ([¬ß17.4.4](jls-17.html#jls-17.4.4 "17.4.4. Synchronization Order")).
        
*   _External Actions_. An external action is an action that may be observable outside of an execution, and has a result based on an environment external to the execution.
*   _Thread divergence actions_ ([¬ß17.4.9](jls-17.html#jls-17.4.9 "17.4.9. Observable Behavior and Nonterminating Executions")). A thread divergence action is only performed by a thread that is in an infinite loop in which no memory, synchronization, or external actions are performed. If a thread performs a thread divergence action, it will be followed by an infinite number of thread divergence actions.
    
    Thread divergence actions are introduced to model how a thread may cause all other threads to stall and fail to make progress.
    

This specification is only concerned with inter-thread actions. We do not need to concern ourselves with intra-thread actions (e.g., adding two local variables and storing the result in a third local variable). As previously mentioned, all threads need to obey the correct intra-thread semantics for Java programs. We will usually refer to inter-thread actions more succinctly as simply _actions_.

An action _a_ is described by a tuple < _t_, _k_, _v_, _u_ >, comprising:

*   _t_ - the threadperforming the action

*   _k_ - the kind of action
*   _v_ - the variable or monitor involved in the action.
    
    For lock actions, _v_ is the monitor being locked; for unlock actions, _v_ is the monitor being unlocked.
    
    If the action is a (volatile or non-volatile) read, _v_ is the variable being read.
    
    If the action is a (volatile or non-volatile) write, _v_ is the variable being written.
*   _u_ - an arbitrary unique identifier for the action
    

An external action tuple contains an additional component, which contains the results of the external action as perceived by the thread performing the action. This may be information as to the success or failure of the action, and any values read by the action.

Parameters to the external action (e.g., which bytes are written to which socket) are not part of the external action tuple. These parameters are set up by other actions within the thread and can be determined by examining the intra-thread semantics. They are not explicitly discussed in the memory model.

In non-terminating executions, not all external actions are observable. Non-terminating executions and observable actions are discussed in [¬ß17.4.9](jls-17.html#jls-17.4.9 "17.4.9. Observable Behavior and Nonterminating Executions").

### 17.4.3. Programs and Program Order

Among all the inter-thread actions performed by each thread _t_, the _program order_ of _t_ is a total order that reflects the order in which these actions would be performed according to the intra-thread semantics of _t_.

A set of actions is _sequentially consistent_ if all actions occur in a total order (the execution order) that is consistent with program order, and furthermore, each read _r_ of a variable _v_ sees the value written by the write _w_ to _v_ such that:

*   _w_ comes before _r_ in the execution order, and
*   there is no other write _w_' such that _w_ comes before _w_' and _w_' comes before _r_ in the execution order.
    

Sequential consistency is a very strong guarantee that is made about visibility and ordering in an execution of a program. Within a sequentially consistent execution, there is a total order over all individual actions (such as reads and writes) which is consistent with the order of the program, and each individual action is atomic and is immediately visible to every thread.

If a program has no data races, then all executions of the program will appear to be sequentially consistent.

Sequential consistency and/or freedom from data races still allows errors arising from groups of operations that need to be perceived atomically and are not.

If we were to use sequential consistency as our memory model, many of the compiler and processor optimizations that we have discussed would be illegal. For example, in the trace in [Table 17.4-C](jls-17.html#jls-17.4-C "Table 17.4-C. Surprising results caused by forward substitution"), as soon as the write of `3` to `p.x` occurred, subsequent reads of that location would be required to see that value.

### 17.4.4. Synchronization Order

Every execution has a _synchronization order_. A synchronization order is a total order over all of the synchronization actions of an execution. For each thread _t_, the synchronization order of the synchronization actions ([¬ß17.4.2](jls-17.html#jls-17.4.2 "17.4.2. Actions")) in _t_ is consistent with the program order ([¬ß17.4.3](jls-17.html#jls-17.4.3 "17.4.3. Programs and Program Order")) of _t_.

Synchronization actions induce the _synchronized-with_ relation on actions, defined as follows:

*   An unlock action on monitor _m_ _synchronizes-with_ all subsequent lock actions on _m_ (where "subsequent" is defined according to the synchronization order).
*   A write to a volatile variable _v_ ([¬ß8.3.1.4](jls-8.html#jls-8.3.1.4 "8.3.1.4. volatile Fields")) _synchronizes-with_ all subsequent reads of _v_ by any thread (where "subsequent" is defined according to the synchronization order).
*   An action that starts a thread _synchronizes-with_ the first action in the thread it starts.
*   The write of the default value (zero, `false`, or `null`) to each variable _synchronizes-with_ the first action in every thread.
    
    Although it may seem a little strange to write a default value to a variable before the object containing the variable is allocated, conceptually every object is created at the start of the program with its default initialized values.
*   The final action in a thread `T1` _synchronizes-with_ any action in another thread `T2` that detects that `T1` has terminated.
    
    `T2` may accomplish this by calling `T1``.isAlive()` or `T1``.join()`.
*   If thread `T1` interrupts thread `T2`, the interrupt by `T1` _synchronizes-with_ any point where any other thread (including `T2`) determines that `T2` has been interrupted (by having an `InterruptedException` thrown or by invoking `Thread.interrupted` or `Thread.isInterrupted`).
    

The source of a _synchronizes-with_ edge is called a _release_, and the destination is called an _acquire_.

### 17.4.5. Happens-before Order

Two actions can be ordered by a _happens-before_ relationship. If one action _happens-before_ another, then the first is visible to and ordered before the second.

If we have two actions _x_ and _y_, we write _hb(x, y)_ to indicate that _x happens-before y_.

*   If _x_ and _y_ are actions of the same thread and _x_ comes before _y_ in program order, then _hb(x, y)_.
*   There is a _happens-before_ edge from the end of a constructor of an object to the start of a finalizer ([¬ß12.6](jls-12.html#jls-12.6 "12.6. Finalization of Class Instances")) for that object.
*   If an action _x_ _synchronizes-with_ a following action _y_, then we also have _hb(x, y)_.
*   If _hb(x, y)_ and _hb(y, z)_, then _hb(x, z)_.
    

The `wait` methods of class `Object` ([¬ß17.2.1](jls-17.html#jls-17.2.1 "17.2.1. Wait")) have lock and unlock actions associated with them; their _happens-before_ relationships are defined by these associated actions.

It should be noted that the presence of a _happens-before_ relationship between two actions does not necessarily imply that they have to take place in that order in an implementation. If the reordering produces results consistent with a legal execution, it is not illegal.

For example, the write of a default value to every field of an object constructed by a thread need not happen before the beginning of that thread, as long as no read ever observes that fact.

More specifically, if two actions share a _happens-before_ relationship, they do not necessarily have to appear to have happened in that order to any code with which they do not share a _happens-before_ relationship. Writes in one thread that are in a data race with reads in another thread may, for example, appear to occur out of order to those reads.

The _happens-before_ relation defines when data races take place.

A set of synchronization edges, _S_, is _sufficient_ if it is the minimal set such that the transitive closure of _S_ with the program order determines all of the _happens-before_ edges in the execution. This set is unique.

It follows from the above definitions that:

*   An unlock on a monitor _happens-before_ every subsequent lock on that monitor.
*   A write to a `volatile` field ([¬ß8.3.1.4](jls-8.html#jls-8.3.1.4 "8.3.1.4. volatile Fields")) _happens-before_ every subsequent read of that field.
*   A call to `start()` on a thread _happens-before_ any actions in the started thread.
*   All actions in a thread _happen-before_ any other thread successfully returns from a `join()` on that thread.
*   The default initialization of any object _happens-before_ any other actions (other than default-writes) of a program.
    

When a program contains two conflicting accesses ([¬ß17.4.1](jls-17.html#jls-17.4.1 "17.4.1. Shared Variables")) that are not ordered by a happens-before relationship, it is said to contain a _data race_.

The semantics of operations other than inter-thread actions, such as reads of array lengths ([¬ß10.7](jls-10.html#jls-10.7 "10.7. Array Members")), executions of checked casts ([¬ß5.5](jls-5.html#jls-5.5 "5.5. Casting Contexts"), [¬ß15.16](jls-15.html#jls-15.16 "15.16. Cast Expressions")), and invocations of virtual methods ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")), are not directly affected by data races.

Therefore, a data race cannot cause incorrect behavior such as returning the wrong length for an array.

A program is _correctly synchronized_ if and only if all sequentially consistent executions are free of data races.

If a program is correctly synchronized, then all executions of the program will appear to be sequentially consistent ([¬ß17.4.3](jls-17.html#jls-17.4.3 "17.4.3. Programs and Program Order")).

This is an extremely strong guarantee for programmers. Programmers do not need to reason about reorderings to determine that their code contains data races. Therefore they do not need to reason about reorderings when determining whether their code is correctly synchronized. Once the determination that the code is correctly synchronized is made, the programmer does not need to worry that reorderings will affect his or her code.

A program must be correctly synchronized to avoid the kinds of counterintuitive behaviors that can be observed when code is reordered. The use of correct synchronization does not ensure that the overall behavior of a program is correct. However, its use does allow a programmer to reason about the possible behaviors of a program in a simple way; the behavior of a correctly synchronized program is much less dependent on possible reorderings. Without correct synchronization, very strange, confusing and counterintuitive behaviors are possible.

We say that a read _r_ of a variable _v_ is allowed to observe a write _w_ to _v_ if, in the _happens-before_ partial order of the execution trace:

*   _r_ is not ordered before _w_ (i.e., it is not the case that _hb(r, w)_), and
*   there is no intervening write _w_' to _v_ (i.e. no write _w_' to _v_ such that _hb(w, w')_ and _hb(w', r)_).
    

Informally, a read _r_ is allowed to see the result of a write _w_ if there is no _happens-before_ ordering to prevent that read.

A set of actions _A_ is _happens-before consistent_ if for all reads _r_ in _A_, where _W(r)_ is the write action seen by _r_, it is not the case that either _hb(r, W(r))_ or that there exists a write _w_ in _A_ such that _w.v_ = _r.v_ and _hb(W(r), w)_ and _hb(w, r)_.

In a _happens-before consistent_ set of actions, each read sees a write that it is allowed to see by the _happens-before_ ordering.

**Example 17.4.5-1. Happens-before Consistency**

For the trace in [Table 17.4.5-A](jls-17.html#jls-17.4.5-A "Table 17.4.5-A. Behavior allowed by happens-before consistency, but not sequential consistency."), initially `A == B == 0`. The trace can observe `r2 == 0` and `r1 == 0` and still be _happens-before consistent_, since there are execution orders that allow each read to see the appropriate write.

**Table 17.4.5-A. Behavior allowed by happens-before consistency, but not sequential consistency.**

 

Thread 1

Thread 2

`B = 1;`

`A = 2;`

`r2 = A;`

`r1 = B;`

  

Since there is no synchronization, each read can see either the write of the initial value or the write by the other thread. An execution order that displays this behavior is:

1: B = 1;
3: A = 2;
2: r2 = A;  // sees initial write of 0
4: r1 = B;  // sees initial write of 0

Another execution order that is happens-before consistent is:

1: r2 = A;  // sees write of A = 2
3: r1 = B;  // sees write of B = 1
2: B = 1;
4: A = 2;

In this execution, the reads see writes that occur later in the execution order. This may seem counterintuitive, but is allowed by _happens-before_ consistency. Allowing reads to see later writes can sometimes produce unacceptable behaviors.

  

### 17.4.6. Executions

An execution _E_ is described by a tuple < _P, A, po, so, W, V, sw, hb_ >, comprising:

*   _P_ - a program
*   _A_ - a set of actions
*   _po_ - program order, which for each thread _t_, is a total order over all actions performed by _t_ in _A_
*   _so_ - synchronization order, which is a total order over all synchronization actions in _A_
*   _W_ - a write-seen function, which for each read _r_ in _A_, gives _W(r)_, the write action seen by _r_ in _E_.
*   _V_ - a value-written function, which for each write _w_ in _A_, gives _V(w)_, the value written by _w_ in _E_.
*   _sw_ - synchronizes-with, a partial order over synchronization actions
*   _hb_ - happens-before, a partial order over actions
    

Note that the synchronizes-with and happens-before elements are uniquely determined by the other components of an execution and the rules for well-formed executions ([¬ß17.4.7](jls-17.html#jls-17.4.7 "17.4.7. Well-Formed Executions")).

An execution is _happens-before consistent_ if its set of actions is _happens-before consistent_ ([¬ß17.4.5](jls-17.html#jls-17.4.5 "17.4.5. Happens-before Order")).

### 17.4.7. Well-Formed Executions

We only consider well-formed executions. An execution _E_ = < _P, A, po, so, W, V, sw, hb_ > is well formed if the following are true:

1.  Each read sees a write to the same variable in the execution.
    
    All reads and writes of volatile variables are volatile actions. For all reads _r_ in _A_, we have _W(r)_ in _A_ and _W(r).v_ = _r.v_. The variable _r.v_ is volatile if and only if _r_ is a volatile read, and the variable _w.v_ is volatile if and only if _w_ is a volatile write.
    
2.  The happens-before order is a partial order.
    
    The happens-before order is given by the transitive closure of synchronizes-with edges and program order. It must be a valid partial order: reflexive, transitive and antisymmetric.
    
3.  The execution obeys intra-thread consistency.
    
    For each thread _t_, the actions performed by _t_ in _A_ are the same as would be generated by that thread in program-order in isolation, with each write _w_ writing the value _V(w)_, given that each read _r_ sees the value _V(W(r))_. Values seen by each read are determined by the memory model. The program order given must reflect the program order in which the actions would be performed according to the intra-thread semantics of _P_.
    
4.  The execution is _happens-before consistent_ ([¬ß17.4.6](jls-17.html#jls-17.4.6 "17.4.6. Executions")).
    
5.  The execution obeys synchronization-order consistency.
    
    For all volatile reads _r_ in _A_, it is not the case that either _so(r, W(r))_ or that there exists a write _w_ in _A_ such that _w.v_ = _r.v_ and _so(W(r), w)_ and _so(w, r)_.
    

### 17.4.8. Executions and Causality Requirements

We use _f_|_d_ to denote the function given by restricting the domain of _f_ to _d_. For all _x_ in _d_, _f_|_d_(_x_) = _f_(_x_), and for all _x_ not in _d_, _f_|_d_(_x_) is undefined.

We use _p_|_d_ to represent the restriction of the partial order _p_ to the elements in _d_. For all _x_,_y_ in _d_, _p_(_x_,_y_) if and only if _p_|_d_(_x_,_y_). If either _x_ or _y_ are not in _d_, then it is not the case that _p_|_d_(_x_,_y_).

A well-formed execution _E_ = < _P, A, po, so, W, V, sw, hb_ > is validated by _committing_ actions from _A_. If all of the actions in _A_ can be committed, then the execution satisfies the causality requirements of the Java programming language memory model.

Starting with the empty set as _C0_, we perform a sequence of steps where we take actions from the set of actions _A_ and add them to a set of committed actions _Ci_ to get a new set of committed actions _Ci+1_. To demonstrate that this is reasonable, for each _Ci_ we need to demonstrate an execution _E_ containing _Ci_ that meets certain conditions.

Formally, an execution _E satisfies the causality requirements of the Java programming language memory model_ if and only if there exist:

*   Sets of actions _C0_, _C1_, ... such that:
    
    *   _C0_ is the empty set
        
    *   _Ci_ is a proper subset of _Ci+1_
        
    *   _A_ = ‚à™ (_C0_, _C1_, ...)
        
    
    If _A_ is finite, then the sequence _C0_, _C1_, ... will be finite, ending in a set _Cn_ = _A_.
    
    If _A_ is infinite, then the sequence _C0_, _C1_, ... may be infinite, and it must be the case that the union of all elements of this infinite sequence is equal to _A_.
*   Well-formed executions _E1_, ..., where _Ei_ = < _P, Ai, poi, soi, Wi, Vi, swi, hbi_ >.
    

Given these sets of actions _C0_, ... and executions _E1_, ... , every action in _Ci_ must be one of the actions in _Ei_. All actions in _Ci_ must share the same relative happens-before order and synchronization order in both _Ei_ and _E_. Formally:

1.  _Ci_ is a subset of _Ai_
    
2.  _hbi_|_Ci_ = _hb_|_Ci_
    
3.  _soi_|_Ci_ = _so_|_Ci_
    

The values written by the writes in _Ci_ must be the same in both _Ei_ and _E_. Only the reads in _Ci-1_ need to see the same writes in _Ei_ as in _E_. Formally:

4.  _Vi_|_Ci_ = _V_|_Ci_
    
5.  _Wi_|_Ci-1_ = _W_|_Ci-1_
    

All reads in _Ei_ that are not in _Ci-1_ must see writes that happen-before them. Each read _r_ in _Ci_ - _Ci-1_ must see writes in _Ci-1_ in both _Ei_ and _E_, but may see a different write in _Ei_ from the one it sees in _E_. Formally:

6.  For any read _r_ in _Ai_ - _Ci-1_, we have _hbi(Wi(r), r)_
    
7.  For any read _r_ in (_Ci_ - _Ci-1_), we have _Wi(r)_ in _Ci-1_ and _W(r)_ in _Ci-1_
    

Given a set of sufficient synchronizes-with edges for _Ei_, if there is a release-acquire pair that happens-before ([¬ß17.4.5](jls-17.html#jls-17.4.5 "17.4.5. Happens-before Order")) an action you are committing, then that pair must be present in all _Ej_, where _j_ ‚â• _i_. Formally:

8.  Let _sswi_ be the _swi_ edges that are also in the transitive reduction of _hbi_ but not in _po_. We call _sswi_ the _sufficient synchronizes-with edges for _Ei__. If _sswi(x, y)_ and _hbi(y, z)_ and _z_ in _Ci_, then _swj(x, y)_ for all _j_ ‚â• _i_.
    
    If an action _y_ is committed, all external actions that happen-before _y_ are also committed.
    
9.  If _y_ is in _Ci_, _x_ is an external action and _hbi(x, y)_, then _x_ in _Ci_.
    

**Example 17.4.8-1. Happens-before Consistency Is Not Sufficient**

Happens-before consistency is a necessary, but not sufficient, set of constraints. Merely enforcing happens-before consistency would allow for unacceptable behaviors - those that violate the requirements we have established for programs. For example, happens-before consistency allows values to appear "out of thin air". This can be seen by a detailed examination of the trace in [Table 17.4.8-A](jls-17.html#jls-17.4.8-A "Table 17.4.8-A. Happens-before consistency is not sufficient").

**Table 17.4.8-A. Happens-before consistency is not sufficient**

 

Thread 1

Thread 2

`r1 = x;`

`r2 = y;`

`if (r1 != 0) y = 1;`

`if (r2 != 0) x = 1;`

  

The code shown in [Table 17.4.8-A](jls-17.html#jls-17.4.8-A "Table 17.4.8-A. Happens-before consistency is not sufficient") is correctly synchronized. This may seem surprising, since it does not perform any synchronization actions. Remember, however, that a program is correctly synchronized if, when it is executed in a sequentially consistent manner, there are no data races. If this code is executed in a sequentially consistent way, each action will occur in program order, and neither of the writes will occur. Since no writes occur, there can be no data races: the program is correctly synchronized.

Since this program is correctly synchronized, the only behaviors we can allow are sequentially consistent behaviors. However, there is an execution of this program that is happens-before consistent, but not sequentially consistent:

r1 = x;  // sees write of x = 1
y = 1;
r2 = y;  // sees write of y = 1
x = 1; 

This result is happens-before consistent: there is no happens-before relationship that prevents it from occurring. However, it is clearly not acceptable: there is no sequentially consistent execution that would result in this behavior. The fact that we allow a read to see a write that comes later in the execution order can sometimes thus result in unacceptable behaviors.

Although allowing reads to see writes that come later in the execution order is sometimes undesirable, it is also sometimes necessary. As we saw above, the trace in [Table 17.4.5-A](jls-17.html#jls-17.4.5-A "Table 17.4.5-A. Behavior allowed by happens-before consistency, but not sequential consistency.") requires some reads to see writes that occur later in the execution order. Since the reads come first in each thread, the very first action in the execution order must be a read. If that read cannot see a write that occurs later, then it cannot see any value other than the initial value for the variable it reads. This is clearly not reflective of all behaviors.

We refer to the issue of when reads can see future writes as _causality_, because of issues that arise in cases like the one found in [Table 17.4.8-A](jls-17.html#jls-17.4.8-A "Table 17.4.8-A. Happens-before consistency is not sufficient"). In that case, the reads cause the writes to occur, and the writes cause the reads to occur. There is no "first cause" for the actions. Our memory model therefore needs a consistent way of determining which reads can see writes early.

Examples such as the one found in [Table 17.4.8-A](jls-17.html#jls-17.4.8-A "Table 17.4.8-A. Happens-before consistency is not sufficient") demonstrate that the specification must be careful when stating whether a read can see a write that occurs later in the execution (bearing in mind that if a read sees a write that occurs later in the execution, it represents the fact that the write is actually performed early).The memory model takes as input a given execution, and a program, and determines whether that execution is a legal execution of the program. It does this by gradually building a set of "committed" actions that reflect which actions were executed by the program. Usually, the next action to be committed will reflect the next action that can be performed by a sequentially consistent execution. However, to reflect reads that need to see later writes, we allow some actions to be committed earlier than other actions that happen-before them.

Obviously, some actions may be committed early and some may not. If, for example, one of the writes in [Table 17.4.8-A](jls-17.html#jls-17.4.8-A "Table 17.4.8-A. Happens-before consistency is not sufficient") were committed before the read of that variable, the read could see the write, and the "out-of-thin-air" result could occur. Informally, we allow an action to be committed early if we know that the action can occur without assuming some data race occurs. In [Table 17.4.8-A](jls-17.html#jls-17.4.8-A "Table 17.4.8-A. Happens-before consistency is not sufficient"), we cannot perform either write early, because the writes cannot occur unless the reads see the result of a data race.

  

### 17.4.9. Observable Behavior and Nonterminating Executions

For programs that always terminate in some bounded finite period of time, their behavior can be understood (informally) simply in terms of their allowable executions. For programs that can fail to terminate in a bounded amount of time, more subtle issues arise.

The observable behavior of a program is defined by the finite sets of external actions that the program may perform. A program that, for example, simply prints "Hello" forever is described by a set of behaviors that for any non-negative integer _i_, includes the behavior of printing "Hello" _i_ times.

Termination is not explicitly modeled as a behavior, but a program can easily be extended to generate an additional external action _executionTermination_ that occurs when all threads have terminated.

We also define a special _hang_ action. If behavior is described by a set of external actions including a _hang_ action, it indicates a behavior where after the external actions are observed, the program can run for an unbounded amount of time without performing any additional external actions or terminating. Programs can hang if all threads are blocked or if the program can perform an unbounded number of actions without performing any external actions.

A thread can be blocked in a variety of circumstances, such as when it is attempting to acquire a lock or perform an external action (such as a read) that depends on external data.

An execution may result in a thread being blocked indefinitely and the execution's not terminating. In such cases, the actions generated by the blocked thread must consist of all actions generated by that thread up to and including the action that caused the thread to be blocked, and no actions that would be generated by the thread after that action.

To reason about observable behaviors, we need to talk about sets of observable actions.

If _O_ is a set of observable actions for an execution _E_, then set _O_ must be a subset of _E_'s actions, _A_, and must contain only a finite number of actions, even if _A_ contains an infinite number of actions. Furthermore, if an action _y_ is in _O_, and either _hb(x, y)_ or _so(x, y)_, then _x_ is in _O_.

Note that a set of observable actions are not restricted to external actions. Rather, only external actions that are in a set of observable actions are deemed to be observable external actions.

A behavior _B_ is an allowable behavior of a program _P_ if and only if _B_ is a finite set of external actions and either:

*   There exists an execution _E_ of _P_, and a set _O_ of observable actions for _E_, and _B_ is the set of external actions in _O_ (If any threads in _E_ end in a blocked state and _O_ contains all actions in _E_, then _B_ may also contain a _hang_ action); or
*   There exists a set _O_ of actions such that _B_ consists of a _hang_ action plus all the external actions in _O_ and for all _k_ ‚â• | _O_ |, there exists an execution _E_ of _P_ with actions _A_, and there exists a set of actions _O_' such that:
    
    *   Both _O_ and _O_' are subsets of _A_ that fulfill the requirements for sets of observable actions.
        
    *   _O_ ‚äÜ _O_' ‚äÜ _A_
        
    *   | _O_' | ‚â• _k_
        
    *   _O_' - _O_ contains no external actions
        
    

Note that a behavior _B_ does not describe the order in which the external actions in _B_ are observed, but other (internal) constraints on how the external actions are generated and performed may impose such constraints.

17.5. `final` Field Semantics
-----------------------------

Fields declared final are initialized once, but never changed under normal circumstances. The detailed semantics of `final` fields are somewhat different from those of normal fields. In particular, compilers have a great deal of freedom to move reads of `final` fields across synchronization barriers and calls to arbitrary or unknown methods. Correspondingly, compilers are allowed to keep the value of a `final` field cached in a register and not reload it from memory in situations where a non-`final` field would have to be reloaded.

`final` fields also allow programmers to implement thread-safe immutable objects without synchronization. A thread-safe immutable object is seen as immutable by all threads, even if a data race is used to pass references to the immutable object between threads. This can provide safety guarantees against misuse of an immutable class by incorrect or malicious code. `final` fields must be used correctly to provide a guarantee of immutability.

An object is considered to be _completely initialized_ when its constructor finishes. A thread that can only see a reference to an object after that object has been completely initialized is guaranteed to see the correctly initialized values for that object's `final` fields.

The usage model for `final` fields is a simple one: Set the `final` fields for an object in that object's constructor; and do not write a reference to the object being constructed in a place where another thread can see it before the object's constructor is finished. If this is followed, then when the object is seen by another thread, that thread will always see the correctly constructed version of that object's `final` fields. It will also see versions of any object or array referenced by those `final` fields that are at least as up-to-date as the `final` fields are.

**Example 17.5-1. `final` Fields In The Java Memory Model**

The program below illustrates how `final` fields compare to normal fields.

class FinalFieldExample { 
    final int x;
    int y; 
    static FinalFieldExample f;

    public FinalFieldExample() {
        x = 3; 
        y = 4; 
    } 

    static void writer() {
        f = new FinalFieldExample();
    } 

    static void reader() {
        if (f != null) {
            int i = f.x;  // guaranteed to see 3  
            int j = f.y;  // could see 0
        } 
    } 
}

The class `FinalFieldExample` has a `final` `int` field `x` and a non-`final` `int` field `y`. One thread might execute the method `writer` and another might execute the method `reader`.

Because the `writer` method writes `f` _after_ the object's constructor finishes, the `reader` method will be guaranteed to see the properly initialized value for `f.x`: it will read the value `3`. However, `f.y` is not `final`; the `reader` method is therefore not guaranteed to see the value `4` for it.

  

**Example 17.5-2. `final` Fields For Security**

`final` fields are designed to allow for necessary security guarantees. Consider the following program. One thread (which we shall refer to as thread 1) executes:

Global.s = "/tmp/usr".substring(4);

while another thread (thread 2) executes

String myS = Global.s; 
if (myS.equals("/tmp"))System.out.println(myS);

`String` objects are intended to be immutable and string operations do not perform synchronization. While the `String` implementation does not have any data races, other code could have data races involving the use of `String` objects, and the memory model makes weak guarantees for programs that have data races. In particular, if the fields of the `String` class were not `final`, then it would be possible (although unlikely) that thread 2 could initially see the default value of `0` for the offset of the string object, allowing it to compare as equal to "`/tmp`". A later operation on the `String` object might see the correct offset of `4`, so that the `String` object is perceived as being "`/usr`". Many security features of the Java programming language depend upon `String` objects being perceived as truly immutable, even if malicious code is using data races to pass `String` references between threads.

  

### 17.5.1. Semantics of `final` Fields

Let _o_ be an object, and _c_ be a constructor for _o_ in which a `final` field _f_ is written. A _freeze_ action on `final` field _f_ of _o_ takes place when _c_ exits, either normally or abruptly.

Note that if one constructor invokes another constructor, and the invoked constructor sets a `final` field, the freeze for the `final` field takes place at the end of the invoked constructor.

For each execution, the behavior of reads is influenced by two additional partial orders, the dereference chain _dereferences()_ and the memory chain _mc()_, which are considered to be part of the execution (and thus, fixed for any particular execution). These partial orders must satisfy the following constraints (which need not have a unique solution):

*   Dereference Chain: If an action _a_ is a read or write of a field or element of an object _o_ by a thread _t_ that did not initialize _o_, then there must exist some read _r_ by thread _t_ that sees the address of _o_ such that _r_ _dereferences(r, a)_.
*   Memory Chain: There are several constraints on the memory chain ordering:
    
    *   If _r_ is a read that sees a write _w_, then it must be the case that _mc(w, r)_.
        
    *   If _r_ and _a_ are actions such that _dereferences(r, a)_, then it must be the case that _mc(r, a)_.
        
    *   If _w_ is a write of the address of an object _o_ by a thread _t_ that did not initialize _o_, then there must exist some read _r_ by thread _t_ that sees the address of _o_ such that _mc(r, w)_.
        
    

Given a write _w_, a freeze _f_, an action _a_ (that is not a read of a `final` field), a read _r1_ of the `final` field frozen by _f_, and a read _r2_ such that _hb(w, f)_, _hb(f, a)_, _mc(a, r1)_, and _dereferences(r1, r2)_, then when determining which values can be seen by _r2_, we consider _hb(w, r2)_. (This _happens-before_ ordering does not transitively close with other _happens-before_ orderings.)

Note that the _dereferences_ order is reflexive, and _r1_ can be the same as _r2_.

For reads of `final` fields, the only writes that are deemed to come before the read of the `final` field are the ones derived through the `final` field semantics.

### 17.5.2. Reading `final` Fields During Construction

A read of a `final` field of an object within the thread that constructs that object is ordered with respect to the initialization of that field within the constructor by the usual _happens-before_ rules. If the read occurs after the field is set in the constructor, it sees the value the `final` field is assigned, otherwise it sees the default value.

### 17.5.3. Subsequent Modification of `final` Fields

In some cases, such as deserialization, the system will need to change the `final` fields of an object after construction. `final` fields can be changed via reflection and other implementation-dependent means. The only pattern in which this has reasonable semantics is one in which an object is constructed and then the `final` fields of the object are updated. The object should not be made visible to other threads, nor should the `final` fields be read, until all updates to the `final` fields of the object are complete. Freezes of a `final` field occur both at the end of the constructor in which the `final` field is set, and immediately after each modification of a `final` field via reflection or other special mechanism.

Even then, there are a number of complications. If a `final` field is initialized to a constant expression ([¬ß15.28](jls-15.html#jls-15.28 "15.28. Constant Expressions")) in the field declaration, changes to the `final` field may not be observed, since uses of that `final` field are replaced at compile time with the value of the constant expression.

Another problem is that the specification allows aggressive optimization of `final` fields. Within a thread, it is permissible to reorder reads of a `final` field with those modifications of a `final` field that do not take place in the constructor.

**Example 17.5.3-1. Aggressive Optimization of `final` Fields**

class A {
    final int x;
    A() { 
        x = 1; 
    } 

    int f() { 
        return d(this,this); 
    } 

    int d(A a1, A a2) { 
        int i = a1.x; 
        g(a1); 
        int j = a2.x; 
        return j - i; 
    }

    static void g(A a) { 
        // uses reflection to change a.x to 2 
    } 
}

In the `d` method, the compiler is allowed to reorder the reads of `x` and the call to `g` freely. Thus, `new A().f()` could return `-1`, `0`, or `1`.

  

An implementation may provide a way to execute a block of code in a _`final`\-field-safe context_. If an object is constructed within a `final`\-field-safe context, the reads of a `final` field of that object will not be reordered with modifications of that `final` field that occur within that `final`\-field-safe context.

A `final`\-field-safe context has additional protections. If a thread has seen an incorrectly published reference to an object that allows the thread to see the default value of a `final` field, and then, within a `final`\-field-safe context, reads a properly published reference to the object, it will be guaranteed to see the correct value of the `final` field. In the formalism, code executed within a `final`\-field-safe context is treated as a separate thread (for the purposes of `final` field semantics only).

In an implementation, a compiler should not move an access to a `final` field into or out of a `final`\-field-safe context (although it can be moved around the execution of such a context, so long as the object is not constructed within that context).

One place where use of a `final`\-field-safe context would be appropriate is in an executor or thread pool. By executing each `Runnable` in a separate `final`\-field-safe context, the executor could guarantee that incorrect access by one `Runnable` to a object _o_ will not remove `final` field guarantees for other `Runnable`s handled by the same executor.

### 17.5.4. Write-Protected Fields

Normally, a field that is `final` and `static` may not be modified. However, `System.in`, `System.out`, and `System.err` are `static` `final` fields that, for legacy reasons, must be allowed to be changed by the methods `System.setIn`, `System.setOut`, and `System.setErr`. We refer to these fields as being _write-protected_ to distinguish them from ordinary `final` fields.

The compiler needs to treat these fields differently from other `final` fields. For example, a read of an ordinary `final` field is "immune" to synchronization: the barrier involved in a lock or volatile read does not have to affect what value is read from a `final` field. Since the value of write-protected fields may be seen to change, synchronization events should have an effect on them. Therefore, the semantics dictate that these fields be treated as normal fields that cannot be changed by user code, unless that user code is in the `System` class.

17.6. Word Tearing
------------------

One consideration for implementations of the Java Virtual Machine is that every field and array element is considered distinct; updates to one field or element must not interact with reads or updates of any other field or element. In particular, two threads that update adjacent elements of a byte array separately must not interfere or interact and do not need synchronization to ensure sequential consistency.

Some processors do not provide the ability to write to a single byte. It would be illegal to implement byte array updates on such a processor by simply reading an entire word, updating the appropriate byte, and then writing the entire word back to memory. This problem is sometimes known as _word tearing_, and on processors that cannot easily update a single byte in isolation some other approach will be required.

**Example 17.6-1. Detection of Word Tearing**

The following program is a test case to detect word tearing:

public class WordTearing extends Thread { 
    static final int LENGTH = 8;
    static final int ITERS  = 1000000; 
    static byte\[\] counts    = new byte\[LENGTH\]; 
    static Thread\[\] threads = new Thread\[LENGTH\]; 

    final int id; 
    WordTearing(int i) { 
        id = i; 
    }

    public void run() { 
        byte v = 0; 
        for (int i = 0; i < ITERS; i++) { 
            byte v2 = counts\[id\]; 
            if (v != v2) { 
                System.err.println("Word-Tearing found: " + 
                              "counts\[" + id + "\] = "+ v2 +
                              ", should be " + v); 
                return; 
            } 
            v++; 
            counts\[id\] = v; 
        } 
    }

    public static void main(String\[\] args) { 
        for (int i = 0; i < LENGTH; ++i) 
            (threads\[i\] = new WordTearing(i)).start(); 
    } 
}

This makes the point that bytes must not be overwritten by writes to adjacent bytes.

  

17.7. Non-Atomic Treatment of `double` and `long`
-------------------------------------------------

For the purposes of the Java programming language memory model, a single write to a non-volatile `long` or `double` value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.

Writes and reads of volatile `long` and `double` values are always atomic.

Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.

Some implementations may find it convenient to divide a single write action on a 64-bit `long` or `double` value into two write actions on adjacent 32-bit values. For efficiency's sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to `long` and `double` values atomically or in two parts.

Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as `volatile` or synchronize their programs correctly to avoid possible complications.

üçÄ Chapter 18. Type Inference
--------------------------

**Table of Contents**

[18.1. Concepts and Notation](jls-18.html#jls-18.1)
[18.1.1. Inference Variables](jls-18.html#jls-18.1.1)
[18.1.2. Constraint Formulas](jls-18.html#jls-18.1.2)
[18.1.3. Bounds](jls-18.html#jls-18.1.3)
[18.2. Reduction](jls-18.html#jls-18.2)
[18.2.1. Expression Compatibility Constraints](jls-18.html#jls-18.2.1)
[18.2.2. Type Compatibility Constraints](jls-18.html#jls-18.2.2)
[18.2.3. Subtyping Constraints](jls-18.html#jls-18.2.3)
[18.2.4. Type Equality Constraints](jls-18.html#jls-18.2.4)
[18.2.5. Checked Exception Constraints](jls-18.html#jls-18.2.5)
[18.3. Incorporation](jls-18.html#jls-18.3)
[18.3.1. Complementary Pairs of Bounds](jls-18.html#jls-18.3.1)
[18.3.2. Bounds Involving Capture Conversion](jls-18.html#jls-18.3.2)
[18.4. Resolution](jls-18.html#jls-18.4)
[18.5. Uses of Inference](jls-18.html#jls-18.5)
[18.5.1. Invocation Applicability Inference](jls-18.html#jls-18.5.1)
[18.5.2. Invocation Type Inference](jls-18.html#jls-18.5.2)
[18.5.3. Functional Interface Parameterization Inference](jls-18.html#jls-18.5.3)
[18.5.4. More Specific Method Inference](jls-18.html#jls-18.5.4)

A variety of compile-time analyses require reasoning about types that are not yet known. Principal among these are generic method applicability testing ([¬ß18.5.1](jls-18.html#jls-18.5.1 "18.5.1. Invocation Applicability Inference")) and generic method invocation type inference ([¬ß18.5.2](jls-18.html#jls-18.5.2 "18.5.2. Invocation Type Inference")). In general, we refer to the process of reasoning about unknown types as _type inference_.

At a high level, type inference can be decomposed into three processes:

*   _Reduction_ takes a compatibility assertion about an expression or type, called a _constraint formula_, and reduces it to a set of _bounds_ on _inference variables_. Often, a constraint formula reduces to _other_ constraint formulas, which must be recursively reduced. A procedure is followed to identify these additional constraint formulas and, ultimately, to express via a bound set the conditions under which the choices for inferred types would render each constraint formula true.
*   _Incorporation_ maintains a set of inference variable bounds, ensuring that these are consistent as new bounds are added. Because the bounds on one variable can sometimes impact the possible choices for another variable, this process propagates bounds between such interdependent variables.
*   _Resolution_ examines the bounds on an inference variable and determines an _instantiation_ that is compatible with those bounds. It also decides the order in which interdependent inference variables are to be resolved.
    

These processes interact closely: reduction can trigger incorporation; incorporation may lead to further reduction; and resolution may cause further incorporation.

*   [¬ß18.1](jls-18.html#jls-18.1 "18.1. Concepts and Notation") more precisely defines the concepts used as intermediate results and the notation used to express them.
*   [¬ß18.2](jls-18.html#jls-18.2 "18.2. Reduction") describes reduction in detail.
*   [¬ß18.3](jls-18.html#jls-18.3 "18.3. Incorporation") describes incorporation in detail.
*   [¬ß18.4](jls-18.html#jls-18.4 "18.4. Resolution") describes resolution in detail.
*   [¬ß18.5](jls-18.html#jls-18.5 "18.5. Uses of Inference") defines how these inference tools are used to solve certain compile-time analysis problems.
    

In comparison to the Java SE 7 Edition of _The Java¬Æ Language Specification_, important changes to inference include:

*   Adding support for lambda expressions and method references as method invocation arguments.
*   Generalizing to define inference in terms of poly expressions, which may not have well-defined types until _after_ inference is complete. This has the notable effect of improving inference for nested generic method and diamond constructor invocations.
*   Describing how inference is used to handle wildcard-parameterized functional interface target types and most specific method analysis.
*   Clarifying the distinction between invocation applicability testing (which involves only the invocation arguments) and invocation type inference (which incorporates a target type).
*   Delaying resolution of all inference variables, even those with lower bounds, until invocation type inference, in order to get better results.
*   Improving inference behavior for interdependent (or self-dependent) variables.
*   Eliminating bugs and potential sources of confusion. This revision more carefully and precisely handles the distinction between specific conversion contexts and subtyping, and describes reduction by paralleling the corresponding non-inference relations. Where there are intentional departures from the non-inference relations, these are explicitly identified as such.
*   Laying a foundation for future evolution: enhancements to or new applications of inference will be easier to integrate into the specification.
    

18.1. Concepts and Notation
---------------------------

This section defines _inference variables_, _constraint formulas_, and _bounds_, as the terms will be used throughout this chapter. It also presents notation.

### 18.1.1. Inference Variables

_Inference variables_ are _meta-variables_ for types - that is, they are special names that allow abstract reasoning about types. To distinguish them from _type variables_, inference variables are represented with Greek letters, principally Œ±.

The term "type" is used loosely in this chapter to include type-like syntax that contains inference variables. The term _proper type_ excludes such "types" that mention inference variables. Assertions that involve inference variables are assertions about every proper type that can be produced by replacing each inference variable with a proper type.

### 18.1.2. Constraint Formulas

_Constraint formulas_ are assertions of compatibility or subtyping that may involve inference variables. The formulas may take one of the following forms:

*   ‚Äπ_Expression_ ‚Üí T‚Ä∫: An expression is compatible in a loose invocation context with type T ([¬ß5.3](jls-5.html#jls-5.3 "5.3. Invocation Contexts")).
*   ‚ÄπS ‚Üí T‚Ä∫: A type S is compatible in a loose invocation context with type T ([¬ß5.3](jls-5.html#jls-5.3 "5.3. Invocation Contexts")).
*   ‚ÄπS `<:` T‚Ä∫: A reference type S is a subtype of a reference type T ([¬ß4.10](jls-4.html#jls-4.10 "4.10. Subtyping")).
*   ‚ÄπS `<=` T‚Ä∫: A type argument S is contained by a type argument T ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")).
*   ‚ÄπS = T‚Ä∫: A type S is the same as a type T ([¬ß4.3.4](jls-4.html#jls-4.3.4 "4.3.4. When Reference Types Are the Same")), or a type argument S is the same as type argument T.
*   ‚Äπ_LambdaExpression_ ‚Üí_throws_ T‚Ä∫: The checked exceptions thrown by the body of the _LambdaExpression_ are declared by the `throws` clause of the function type derived from T.
*   ‚Äπ_MethodReference_ ‚Üí_throws_ T‚Ä∫: The checked exceptions thrown by the referenced method are declared by the `throws` clause of the function type derived from T.
    

Examples of constraint formulas:

*   From `Collections.singleton("hi")`, we have the constraint formula ‚Äπ`"hi"` ‚Üí Œ±‚Ä∫. Through reduction, this will become the constraint formula: ‚Äπ`String` `<:` Œ±‚Ä∫.
*   From `Arrays.asList(1, 2.0)`, we have the constraint formulas ‚Äπ`1` ‚Üí Œ±‚Ä∫ and ‚Äπ`2.0` ‚Üí Œ±‚Ä∫. Through reduction, these will become the constraint formulas ‚Äπ`int` ‚Üí Œ±‚Ä∫ and ‚Äπ`double` ‚Üí Œ±‚Ä∫, and then ‚Äπ`Integer` `<:` Œ±‚Ä∫ and ‚Äπ`Double` `<:` Œ±‚Ä∫.
*   From the target type of the constructor invocation ``List<Thread> lt = new ArrayList`<>`()``, we have the constraint formula ‚Äπ`ArrayList``<`Œ±`>` ‚Üí `List``<``Thread``>`‚Ä∫. Through reduction, this will become the constraint formula ‚ÄπŒ± `<=` `Thread`‚Ä∫, and then ‚ÄπŒ± = `Thread`‚Ä∫.
    

### 18.1.3. Bounds

During the inference process, a set of _bounds_ on inference variables is maintained. A bound has one of the following forms:

*   S = T, where at least one of S or T is an inference variable: S is the same as T.
*   S `<:` T, where at least one of S or T is an inference variable: S is a subtype of T.
*   _false_: No valid choice of inference variables exists.
*   G`<`Œ±1, ..., Œ±n`>` = capture(G`<`A1, ..., An`>`): The variables Œ±1, ..., Œ±n represent the result of capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")) applied to G`<`A1, ..., An`>` (where A1, ..., An may be types or wildcards and may mention inference variables).
*   `throws` Œ±: The inference variable Œ± appears in a `throws` clause.
    

A bound is _satisfied_ by an inference variable substitution if, after applying the substitution, the assertion is true. The bound _false_ can never be satisfied.

Some bounds relate an inference variable to a proper type. Let T be a proper type. Given a bound of the form Œ± = T or T = Œ±, we say T is an _instantiation_ of Œ±. Similarly, given a bound of the form Œ± `<:` T, we say T is a _proper upper bound_ of Œ±, and given a bound of the form T `<:` Œ±, we say T is a _proper lower bound_ of Œ±.

Other bounds relate two inference variables, or an inference variable to a type that contains inference variables. Such bounds, of the form S = T or S `<:` T, are called _dependencies_.

A bound of the form G`<`Œ±1, ..., Œ±n`>` = capture(G`<`A1, ..., An`>`) indicates that Œ±1, ..., Œ±n are placeholders for the results of capture conversion. This is necessary because capture conversion can only be performed on a proper type, and the inference variables in A1, ..., An may not yet be resolved.

A bound of the form `throws` Œ± is purely informational: it directs resolution to optimize the instantiation of Œ± so that, if possible, it is not a checked exception type.

An important intermediate result of inference is a _bound set_. It is sometimes convenient to refer to an _empty_ bound set with the symbol _true_; this is merely out of convenience, and the two are interchangeable.

Examples of bound sets:

*   { Œ± = `String` } contains a single bound, instantiating Œ± as `String`.
*   { `Integer` `<:` Œ±, `Double` `<:` Œ±, Œ± `<:` `Object` } describes two proper lower bounds and one proper upper bound for Œ±.
*   { Œ± `<:` `Iterable<?>`, Œ≤ `<:` `Object`, Œ± `<:` `List``<`Œ≤`>` } describes a proper upper bound for each of Œ± and Œ≤, along with a dependency between them.
*   { } contains no bounds nor dependencies, and can be referred to as _true_.
*   { _false_ } expresses the fact that no satisfactory instantiation exists.
    

When inference begins, a bound set is typically generated from a list of type parameter declarations P1, ..., Pp and associated inference variables Œ±1, ..., Œ±p. Such a bound set is constructed as follows. For each _l_ (1 ‚â§ _l_ ‚â§ _p_):

*   If Pl has no _TypeBound_, the bound _Œ±l `<:` `Object`_ appears in the set.
*   Otherwise, for each type T delimited by `&` in the _TypeBound_, the bound Œ±l `<:` T`[`P1:=Œ±1, ..., Pp:=Œ±p`]` appears in the set; if this results in no proper upper bounds for Œ±l (only dependencies), then the bound Œ±l `<:` `Object` also appears in the set.
    

18.2. Reduction
---------------

_Reduction_ is the process by which a set of constraint formulas ([¬ß18.1.2](jls-18.html#jls-18.1.2 "18.1.2. Constraint Formulas")) is simplified to produce a bound set ([¬ß18.1.3](jls-18.html#jls-18.1.3 "18.1.3. Bounds")).

Each constraint formula is considered in turn. The rules in this section specify how the formula is reduced to one or both of:

*   A bound or bound set, which is to be incorporated with the "current" bound set. Initially, the current bound set is empty.
*   Further constraint formulas, which are to be reduced recursively.
    

Reduction completes when no further constraint formulas remain to be reduced.

The results of a reduction step are always _soundness-preserving_: if an inference variable instantiation satisfies the reduced constraints and bounds, it will also satisfy the original constraint. On the other hand, reduction is not _completeness-preserving_: there may exist inference variable instantiations that satisfy the original constraint but _do not_ satisfy a reduced constraint or bound. This is due to inherent limitations of the algorithm, along with a desire to avoid undue complexity. One effect is that there are expressions for which type argument inference fails to find a solution, but that can be well-typed if the programmer explicitly inserts appropriate types.

### 18.2.1. Expression Compatibility Constraints

A constraint formula of the form ‚Äπ_Expression_ ‚Üí T‚Ä∫ is reduced as follows:

*   If T is a proper type, the constraint reduces to _true_ if the expression is compatible in a loose invocation context with T ([¬ß5.3](jls-5.html#jls-5.3 "5.3. Invocation Contexts")), and _false_ otherwise.
*   Otherwise, if the expression is a standalone expression ([¬ß15.2](jls-15.html#jls-15.2 "15.2. Forms of Expressions")) of type S, the constraint reduces to ‚ÄπS ‚Üí T‚Ä∫.
*   Otherwise, the expression is a poly expression ([¬ß15.2](jls-15.html#jls-15.2 "15.2. Forms of Expressions")). The result depends on the form of the expression:
    
    *   If the expression is a parenthesized expression of the form `(` _Expression_' `)`, the constraint reduces to ‚Äπ_Expression_' ‚Üí T‚Ä∫.
        
    *   If the expression is a class instance creation expression or a method invocation expression, the constraint reduces to the bound set B3 which would be used to determine the expression's invocation type when targeting T, as defined in [¬ß18.5.2](jls-18.html#jls-18.5.2 "18.5.2. Invocation Type Inference"). (For a class instance creation expression, the corresponding "method" used for inference is defined in [¬ß15.9.3](jls-15.html#jls-15.9.3 "15.9.3. Choosing the Constructor and its Arguments")).
        
        This bound set may contain new inference variables, as well as dependencies between these new variables and the inference variables in T.
        
    *   If the expression is a conditional expression of the form `e1` `?` `e2` `:` `e3`, the constraint reduces to two constraint formulas, ‚Äπ`e2` ‚Üí T‚Ä∫ and ‚Äπ`e3` ‚Üí T‚Ä∫.
        
    *   If the expression is a lambda expression or a method reference expression, the result is specified below.
        
    

By treating nested generic method invocations as poly expressions, we improve the behavior of inference for nested invocations. For example, the following is illegal in Java SE 7 but legal in Java SE 8:

ProcessBuilder b = new ProcessBuilder(Collections.emptyList());
  // ProcessBuilder's constructor expects a List<String>

When _both_ the outer and the nested invocation require inference, the problem is more difficult. For example:

List<String> ls = new ArrayList<>(Collections.emptyList());

Our approach is to "lift" the bounds inferred for the nested invocation (simply { Œ± `<:` `Object` } in the case of `emptyList`) into the outer inference process (in this case, trying to infer Œ≤ where the constructor is for type `ArrayList``<`Œ≤`>`). We also infer dependencies between the nested inference variables and the outer inference variables (the constraint ‚Äπ`List``<`Œ±`>` ‚Üí `Collection``<`Œ≤`>`‚Ä∫ would reduce to the dependency Œ± = Œ≤). In this way, resolution of the inference variables in the nested invocation can wait until additional information can be inferred from the outer invocation (based on the assignment target, Œ≤ = `String`).

A constraint formula of the form ‚Äπ_LambdaExpression_ ‚Üí T‚Ä∫, where T mentions at least one inference variable, is reduced as follows:

*   If T is not a functional interface type ([¬ß9.8](jls-9.html#jls-9.8 "9.8. Functional Interfaces")), the constraint reduces to _false_.
*   Otherwise, let T' be the ground target type derived from T, as specified in [¬ß15.27.3](jls-15.html#jls-15.27.3 "15.27.3. Type of a Lambda Expression"). If [¬ß18.5.3](jls-18.html#jls-18.5.3 "18.5.3. Functional Interface Parameterization Inference") is used to derive a functional interface type which is parameterized, then the test that F`<`A'1, ..., A'm`>` is a subtype of F`<`A1, ..., Am`>` is not performed (instead, it is asserted with a constraint formula below). Let the target function type for the lambda expression be the function type of T'. Then:
    
    *   If no valid function type can be found, the constraint reduces to _false_.
        
    *   Otherwise, the congruence of _LambdaExpression_ with the target function type is asserted as follows:
        
        *   If the number of lambda parameters differs from the number of parameter types of the function type, the constraint reduces to _false_.
            
        *   If the lambda expression is implicitly typed and one or more of the function type's parameter types is not a proper type, the constraint reduces to _false_.
            
            This condition never arises in practice, due to the handling of implicitly typed lambda expressions in [¬ß18.5.1](jls-18.html#jls-18.5.1 "18.5.1. Invocation Applicability Inference") and the substitution applied to the target type in [¬ß18.5.2](jls-18.html#jls-18.5.2 "18.5.2. Invocation Type Inference").
            
        *   If the function type's result is `void` and the lambda body is neither a statement expression nor a void-compatible block, the constraint reduces to _false_.
            
        *   If the function type's result is not `void` and the lambda body is a block that is not value-compatible, the constraint reduces to _false_.
            
        *   Otherwise, the constraint reduces to all of the following constraint formulas:
            
            *   If the lambda parameters have explicitly declared types F1, ..., Fn and the function type has parameter types G1, ..., Gn, then i) for all _i_ (1 ‚â§ _i_ ‚â§ _n_), ‚ÄπFi = Gi‚Ä∫, and ii) ‚ÄπT' `<:` T‚Ä∫.
                
            *   If the function type's return type is a (non-`void`) type R, assume the lambda's parameter types are the same as the function type's parameter types. Then:
                
                *   If R is a proper type, and if the lambda body or some result expression in the lambda body is not compatible in an assignment context with R, then _false_.
                    
                *   Otherwise, if R is not a proper type, then where the lambda body has the form _Expression_, the constraint ‚Äπ_Expression_ ‚Üí R‚Ä∫; or where the lambda body is a block with result expressions `e1`, ..., `em`, for all _i_ (1 ‚â§ _i_ ‚â§ _m_), ‚Äπ`ei` ‚Üí R‚Ä∫.
                    
                
            
        
    

The key piece of information to derive from a compatibility constraint involving a lambda expression is the set of bounds on inference variables appearing in the target function type's return type. This is crucial, because functional interfaces are often generic, and many methods operating on these types are generic, too.

In the simplest case, a lambda expression may simply provide a lower bound for an inference variable:

<T> List<T> makeThree(Factory<T> factory) { ... }
String s = makeThree(() `->` "abc").get(2);

In more complex cases, a result expression may be a poly expression - perhaps even another lambda expression - and so the inference variable might be passed through multiple constraint formulas with different target types before a bound is produced.

Most of the work described in this section precedes assertions about the result expressions; its purpose is to derive the lambda expression's function type, and to check for expressions that are clearly disqualified from compatibility.

We do _not_ attempt to produce bounds on inference variables that appear in the target function type's `throws` clause. This is because exception containment is not part of compatibility ([¬ß15.27.3](jls-15.html#jls-15.27.3 "15.27.3. Type of a Lambda Expression")) - in particular, it must not influence method applicability ([¬ß18.5.1](jls-18.html#jls-18.5.1 "18.5.1. Invocation Applicability Inference")). However, we _do_ get bounds on these variables later, because invocation type inference ([¬ß18.5.2](jls-18.html#jls-18.5.2 "18.5.2. Invocation Type Inference")) produces exception containment constraint formulas ([¬ß18.2.5](jls-18.html#jls-18.2.5 "18.2.5. Checked Exception Constraints")).

Note that if the target type is an inference variable, or if the target type's parameter types contain inference variables, we produce _false_. During invocation type inference (ype Inference">¬ß18.5.2), extra substitutions are performed in order to instantiate these inference variables, thus avoiding this scenario. (In other words, reduction will, in practice, never be "invoked" with a target type of one of these forms.)

Finally, note that the result expressions of a lambda expression are required by [¬ß15.27.3](jls-15.html#jls-15.27.3 "15.27.3. Type of a Lambda Expression") to be compatible in an assignment context with the target type's return type, R. If R is a proper type, such as `Byte` derived from ``` Function`<`Œ±,`Byte``>` ```, then assignability is easy enough to test, and reduction does so above. If R is not a proper type, such as Œ± derived from `` Function`<`String,Œ±`>` ``, then we make the simplifying assumption above that loose invocation compatibility will be sufficient. The difference between assignment compatibility and loose invocation compatibility is that only assignment allows narrowing of constant expressions, such as `Byte b = 100;`. Consequently, our simplifying assumption is not completeness-preserving: given target return type Œ± and an integer literal result expression `100`, it is conceivable that Œ± could be instantiated to `Byte`, but reduction will not in fact produce such a bound.

A constraint formula of the form ‚Äπ_MethodReference_ ‚Üí T‚Ä∫, where T mentions at least one inference variable, is reduced as follows:

*   If T is not a functional interface type, or if T is a functional interface type that does not have a function type ([¬ß9.9](jls-9.html#jls-9.9 "9.9. Function Types")), the constraint reduces to _false_.
*   Otherwise, if there does not exist a potentially applicable method for the method reference when targeting T, the constraint reduces to _false_.
*   Otherwise, if the method reference is exact ([¬ß15.13.1](jls-15.html#jls-15.13.1 "15.13.1. Compile-Time Declaration of a Method Reference")), then let P1, ..., Pn be the parameter types of the function type of T, and let F1, ..., Fk be the parameter types of the potentially applicable method. The constraint reduces to a new set of constraints, as follows:
    
    *   In the special case where _n_ = _k_+1, the parameter of type P1 is to act as the target reference of the invocation. The method reference expression necessarily has the form _ReferenceType `::` \[TypeArguments\] Identifier_. The constraint reduces to ‚ÄπP1 `<:` _ReferenceType_‚Ä∫ and, for all _i_ (2 ‚â§ _i_ ‚â§ _n_), ‚ÄπPi ‚Üí Fi-1‚Ä∫.
        
        In all other cases, _n_ = _k_, and the constraint reduces to, for all _i_ (1 ‚â§ _i_ ‚â§ _n_), ‚ÄπPi ‚Üí Fi‚Ä∫.
        
    *   If the function type's result is not `void`, let R be its return type. Then, if the result of the potentially applicable compile-time declaration is `void`, the constraint reduces to _false_. Otherwise, the constraint reduces to ‚ÄπR' ‚Üí R‚Ä∫, where R' is the result of applying capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")) to the return type of the potentially applicable compile-time declaration.
        
*   Otherwise, the method reference is inexact, and:
    
    *   If one or more of the function type's parameter types is not a proper type, the constraint reduces to _false_.
        
        This condition never arises in practice, due to the handling of inexact method references in [¬ß18.5.1](jls-18.html#jls-18.5.1 "18.5.1. Invocation Applicability Inference") and the substitution applied to the target type in [¬ß18.5.2](jls-18.html#jls-18.5.2 "18.5.2. Invocation Type Inference").
        
    *   Otherwise, a search for a compile-time declaration is performed, as specified in [¬ß15.13.1](jls-15.html#jls-15.13.1 "15.13.1. Compile-Time Declaration of a Method Reference"). If there is no compile-time declaration for the method reference, the constraint reduces to _false_. Otherwise, there is a compile-time declaration, and:
        
        *   If the result of the function type is `void`, the constraint reduces to _true_.
            
        *   Otherwise, if the method reference expression elides _TypeArguments_, and the compile-time declaration is a generic method, and the return type of the compile-time declaration mentions at least one of the method's type parameters, then the constraint reduces to the bound set B3 which would be used to determine the method reference's invocation type when targeting the return type of the function type, as defined in [¬ß18.5.2](jls-18.html#jls-18.5.2 "18.5.2. Invocation Type Inference"). B3 may contain new inference variables, as well as dependencies between these new variables and the inference variables in T.
            
        *   Otherwise, let R be the return type of the function type, and let R' be the result of applying capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")) to the return type of the invocation type ([¬ß15.12.2.6](jls-15.html#jls-15.12.2.6 "15.12.2.6. Method Invocation Type")) of the compile-time declaration. If R' is `void`, the constraint reduces to _false_; otherwise, the constraint reduces to ‚ÄπR' ‚Üí R‚Ä∫.
            
        
    

The strategy used to determine a return type for a generic referenced method follows the same pattern as for generic method invocations ([¬ß18.2.1](jls-18.html#jls-18.2.1 "18.2.1. Expression Compatibility Constraints")). This may involve "lifting" bounds into the outer context and inferring dependencies between the two sets of inference variables.

### 18.2.2. Type Compatibility Constraints

A constraint formula of the form ‚ÄπS ‚Üí T‚Ä∫ is reduced as follows:

*   If S and T are proper types, the constraint reduces to _true_ if S is compatible in a loose invocation context with T ([¬ß5.3](jls-5.html#jls-5.3 "5.3. Invocation Contexts")), and _false_ otherwise.
*   Otherwise, if S is a primitive type, let S' be the result of applying boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")) to S. Then the constraint reduces to ‚ÄπS' ‚Üí T‚Ä∫.
*   Otherwise, if T is a primitive type, let T' be the result of applying boxing conversion ([¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion")) to T. Then the constraint reduces to ‚ÄπS = T'‚Ä∫.
*   Otherwise, if T is a parameterized type of the form G`<`T1, ..., Tn`>`, and there exists no type of the form G`<`...`>` that is a supertype of S, but the raw type G is a supertype of S, then the constraint reduces to _true_.
*   Otherwise, if T is an array type of the form G`<`T1, ..., Tn`>``[]`k, and there exists no type of the form G`<`...`>``[]`k that is a supertype of S, but the raw type G`[]`k is a supertype of S, then the constraint reduces to _true_. (The notation `[]`k indicates an array type of _k_ dimensions.)
*   Otherwise, the constraint reduces to ‚ÄπS `<:` T‚Ä∫.
    

The fourth and fifth cases are implicit uses of unchecked conversion ([¬ß5.1.9](jls-5.html#jls-5.1.9 "5.1.9. Unchecked Conversion")). These, along with any use of unchecked conversion in the first case, may result in compile-time unchecked warnings, and may influence a method's invocation type ([¬ß15.12.2.6](jls-15.html#jls-15.12.2.6 "15.12.2.6. Method Invocation Type")).

Boxing T to T' is not completeness-preserving; for example, if T were `long`, S might be instantiated to `Integer`, which is not a subtype of `Long` but could be unboxed and then widened to `long`. We avoid this problem in most cases by giving special treatment to inference-variable return types that we know are already constrained to be certain boxed primitive types. See [¬ß18.5.2](jls-18.html#jls-18.5.2 "18.5.2. Invocation Type Inference").

Similarly, the treatment of unchecked conversion sacrifices completeness in cases in which T is not a parameterized type (for example, if T is an inference variable). It is not usually clear in such situations whether the unchecked conversion is necessary or not. Since unchecked conversions introduce unchecked warnings, inference prefers to avoid them unless it is clearly necessary.

### 18.2.3. Subtyping Constraints

A constraint formula of the form ‚ÄπS `<:` T‚Ä∫ is reduced as follows:

*   If S and T are proper types, the constraint reduces to _true_ if S is a subtype of T ([¬ß4.10](jls-4.html#jls-4.10 "4.10. Subtyping")), and _false_ otherwise.
*   Otherwise, if S is the null type, the constraint reduces to _true_.
*   Otherwise, if T is the null type, the constraint reduces to _false_.
*   Otherwise, if S is an inference variable, Œ±, the constraint reduces to the bound Œ± `<:` T.
*   Otherwise, if T is an inference variable, Œ±, the constraint reduces to the bound S `<:` Œ±.
*   Otherwise, the constraint is reduced according to the form of T:
    
    *   If T is a parameterized class or interface type, or an inner class type of a parameterized class or interface type (directly or indirectly), let A1, ..., An be the type arguments of T. Among the supertypes of S, a corresponding class or interface type is identified, with type arguments B1, ..., Bn. If no such type exists, the constraint reduces to _false_. Otherwise, the constraint reduces to the following new constraints: for all _i_ (1 ‚â§ _i_ ‚â§ _n_), ‚ÄπBi `<=` Ai‚Ä∫.
        
    *   If T is any other class or interface type, then the constraint reduces to _true_ if T is among the supertypes of S, and _false_ otherwise.
        
    *   If T is an array type, T'`[]`, then among the supertypes of S that are array types, a most specific type is identified, S'`[]` (this may be S itself). If no such array type exists, the constraint reduces to _false_. Otherwise:
        
        *   If neither S' nor T' is a primitive type, the constraint reduces to ‚ÄπS' `<:` T'‚Ä∫.
            
        *   Otherwise, the constraint reduces to _true_ if S' and T' are the same primitive type, and _false_ otherwise.
            
        
    *   If T is a type variable, there are three cases:
        
        *   If S is an intersection type of which T is an element, the constraint reduces to _true_.
            
        *   Otherwise, if T has a lower bound, B, the constraint reduces to ‚ÄπS `<:` B‚Ä∫.
            
        *   Otherwise, the constraint reduces to _false_.
            
        
    *   If T is an intersection type, I1 `&` ... `&` In, the constraint reduces to the following new constraints: for all _i_ (1 ‚â§ _i_ ‚â§ _n_), ‚ÄπS `<:` Ii‚Ä∫.
        
    

A constraint formula of the form ‚ÄπS `<=` T‚Ä∫, where S and T are type arguments ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")), is reduced as follows:

*   If T is a type:
    
    *   If S is a type, the constraint reduces to ‚ÄπS = T‚Ä∫.
        
    *   If S is a wildcard, the constraint reduces to _false_.
        
*   If T is a wildcard of the form `?`, the constraint reduces to _true_.
*   If T is a wildcard of the form `?` `extends` T':
    
    *   If S is a type, the constraint reduces to ‚ÄπS `<:` T'‚Ä∫.
        
    *   If S is a wildcard of the form `?`, the constraint reduces to ‚Äπ`Object` `<:` T'‚Ä∫.
        
    *   If S is a wildcard of the form `?` `extends` S', the constraint reduces to ‚ÄπS' `<:` T'‚Ä∫.
        
    *   If S is a wildcard of the form `?` `super` S', the constraint reduces to ‚Äπ`Object` = T'‚Ä∫.
        
*   If T is a wildcard of the form `?` `super` T':
    
    *   If S is a type, the constraint reduces to ‚ÄπT' `<:` S‚Ä∫.
        
    *   If S is a wildcard of the form `?` `super` S', the constraint reduces to ‚ÄπT' `<:` S'‚Ä∫.
        
    *   Otherwise, the constraint reduces to _false_.
        
    

### 18.2.4. Type Equality Constraints

A constraint formula of the form ‚ÄπS = T‚Ä∫, where S and T are types, is reduced as follows:

*   If S and T are proper types, the constraint reduces to _true_ if S is the same as T ([¬ß4.3.4](jls-4.html#jls-4.3.4 "4.3.4. When Reference Types Are the Same")), and _false_ otherwise.
*   Otherwise, if S or T is the null type, the constraint reduces to _false_.
*   Otherwise, if S is an inference variable, Œ±, and T is not a primitive type, the constraint reduces to the bound Œ± = T.
*   Otherwise, if T is an inference variable, Œ±, and S is not a primitive type, the constraint reduces to the bound S = Œ±.
*   Otherwise, if S and T are class or interface types with the same erasure, where S has type arguments B1, ..., Bn and T has type arguments A1, ..., An, the constraint reduces to the following new constraints: for all _i_ (1 ‚â§ _i_ ‚â§ _n_), ‚ÄπBi = Ai‚Ä∫.
*   Otherwise, if S and T are array types, S'`[]` and T'`[]`, the constraint reduces to ‚ÄπS' = T'‚Ä∫.
*   Otherwise, the constraint reduces to _false_.
    

Note that we do not address intersection types above, because it is impossible for reduction to encounter an intersection type that is not a proper type.

A constraint formula of the form ‚ÄπS = T‚Ä∫, where S and T are type arguments ([¬ß4.5.1](jls-4.html#jls-4.5.1 "4.5.1. Type Arguments of Parameterized Types")), is reduced as follows:

*   If S and T are types, the constraint is reduced as described above.
*   If S has the form `?` and T has the form `?`, the constraint reduces to _true_.
*   If S has the form `?` and T has the form `?` `extends` T', the constraint reduces to ‚Äπ`Object` = T'‚Ä∫.
*   If S has the form `?` `extends` S' and T has the form `?`, the constraint reduces to ‚ÄπS' = `Object`‚Ä∫.
*   If S has the form `?` `extends` S' and T has the form `?` `extends` T', the constraint reduces to ‚ÄπS' = T'‚Ä∫.
*   If S has the form `?` `super` S' and T has the form `?` `super` T', the constraint reduces to ‚ÄπS' = T'‚Ä∫.
*   Otherwise, the constraint reduces to _false_.
    

### 18.2.5. Checked Exception Constraints

A constraint formula of the form ‚Äπ_LambdaExpression_ ‚Üí_throws_ T‚Ä∫ is reduced as follows:

*   If T is not a functional interface type ([¬ß9.8](jls-9.html#jls-9.8 "9.8. Functional Interfaces")), the constraint reduces to _false_.
*   Otherwise, let the target function type for the lambda expression be determined as specified in [¬ß15.27.3](jls-15.html#jls-15.27.3 "15.27.3. Type of a Lambda Expression"). If no valid function type can be found, the constraint reduces to _false_.
*   Otherwise, if the lambda expression is implicitly typed, and one or more of the function type's parameter types is not a proper type, the constraint reduces to _false_.
    
    This condition never arises in practice, due to the substitution applied to the target type in [¬ß18.5.2](jls-18.html#jls-18.5.2 "18.5.2. Invocation Type Inference").
*   Otherwise, if the function type's return type is neither `void` nor a proper type, the constraint reduces to _false_.
    
    This condition never arises in practice, due to the substitution applied to the target type in [¬ß18.5.2](jls-18.html#jls-18.5.2 "18.5.2. Invocation Type Inference").
*   Otherwise, let E1, ..., En be the types in the function type's `throws` clause that are _not_ proper types. If the lambda expression is implicitly typed, let its parameter types be the function type's parameter types. If the lambda body is a poly expression or a block containing a poly result expression, let the targeted return type be the function type's return type. Let X1, ..., Xm be the checked exception types that the lambda body can throw ([¬ß11.2](jls-11.html#jls-11.2 "11.2. Compile-Time Checking of Exceptions")). Then there are two cases:
    
    *   If _n_ = `0` (the function type's `throws` clause consists only of proper types), then if there exists some _i_ (1 ‚â§ _i_ ‚â§ _m_) such that Xi is not a subtype of any proper type in the `throws` clause, the constraint reduces to _false_; otherwise, the constraint reduces to _true_.
        
    *   If _n_ > `0`, the constraint reduces to a set of subtyping constraints: for all _i_ (1 ‚â§ _i_ ‚â§ _m_), if Xi is not a subtype of any proper type in the `throws` clause, then the constraints include, for all _j_ (1 ‚â§ _j_ ‚â§ _n_), ‚ÄπXi `<:` Ej‚Ä∫. In addition, for all _j_ (1 ‚â§ _j_ ‚â§ _n_), the constraint reduces to the bound `throws` Ej.
        
    

A constraint formula of the form ‚Äπ_MethodReference_ ‚Üí_throws_ T‚Ä∫ is reduced as follows:

*   If T is not a functional interface type, or if T is a functional interface type but does not have a function type ([¬ß9.9](jls-9.html#jls-9.9 "9.9. Function Types")), the constraint reduces to _false_.
*   Otherwise, let the target function type for the method reference expression be the function type of T. If the method reference is inexact ([¬ß15.13.1](jls-15.html#jls-15.13.1 "15.13.1. Compile-Time Declaration of a Method Reference")) and one or more of the function type's parameter types is not a proper type, the constraint reduces to _false_.
*   Otherwise, if the method reference is inexact and the function type's result is neither `void` nor a proper type, the constraint reduces to _false_.
*   Otherwise, let E1, ..., En be the types in the function type's `throws` clause that are _not_ proper types. Let X1, ..., Xm be the checked exceptions in the `throws` clause of the invocation type of the method reference's compile-time declaration ([¬ß15.13.2](jls-15.html#jls-15.13.2 "15.13.2. Type of a Method Reference")) (as derived from the function type's parameter types and return type). Then there are two cases:
    
    *   If _n_ = `0` (the function type's `throws` clause consists only of proper types), then if there exists some _i_ (1 ‚â§ _i_ ‚â§ _m_) such that Xi is not a subtype of any proper type in the `throws` clause, the constraint reduces to _false_; otherwise, the constraint reduces to _true_.
        
    *   If _n_ > `0`, the constraint reduces to a set of subtyping constraints: for all _i_ (1 ‚â§ _i_ ‚â§ _m_), if Xi is not a subtype of any proper type in the `throws` clause, then the constraints include, for all _j_ (1 ‚â§ _j_ ‚â§ _n_), ‚ÄπXi `<:` Ej‚Ä∫. In addition, for all _j_ (1 ‚â§ _j_ ‚â§ _n_), the constraint reduces to the bound `throws` Ej.
        
    

Constraints on checked exceptions are handled separately from constraints on return types, because return type compatibility influences applicability of methods ([¬ß18.5.1](jls-18.html#jls-18.5.1 "18.5.1. Invocation Applicability Inference")), while exceptions only influence the invocation type after overload resolution is complete ([¬ß](jls-18.html#jls-18.5.2 "18.5.2. Invocation Type Inference")18.5.2). This could be simplified by including exception compatibility in the definition of lambda expression compatibility ([¬ß15.27.3](jls-15.html#jls-15.27.3 "15.27.3. Type of a Lambda Expression")), but this would lead to possibly surprising cases in which exceptions that can be thrown by an explicitly typed lambda body change overload resolution.

The exceptions thrown by a lambda body cannot be determined until i) the parameter types of the lambda are known, and ii) the target type of result expressions in the body is known. (The second requirement is to account for generic method invocations in which, for example, the same type parameter appears in the return type and the `throws` clause.) Hence, we require both of these, as derived from the target type T, to be proper types.

One consequence is that lambda expressions returned from _other_ lambda expressions cannot generate constraints from their thrown exceptions. These constraints can only be generated from top-level lambda expressions.

Note that the handling of the case in which more than one inference variable appears in a function type's `throws` clause is not completeness-preserving. Either variable may, on its own, satisfy the constraint that each checked exception be declared, but we cannot be sure which one is intended. So, for predictability, we constrain them both.

18.3. Incorporation
-------------------

As bound sets are constructed and grown during inference, it is possible that new bounds can be inferred based on the assertions of the original bounds. The process of _incorporation_ identifies these new bounds and adds them to the bound set.

Incorporation can happen in two scenarios. One scenario is that the bound set contains complementary pairs of bounds; this implies new constraint formulas, as specified in [¬ß18.3.1](jls-18.html#jls-18.3.1 "18.3.1. Complementary Pairs of Bounds"). The other scenario is that the bound set contains a bound involving capture conversion; this implies new bounds and may imply new constraint formulas, as specified in [¬ß18.3.2](jls-18.html#jls-18.3.2 "18.3.2. Bounds Involving Capture Conversion"). In both scenarios, any new constraint formulas are reduced, and any new bounds are added to the bound set. This may trigger further incorporation; ultimately, the set will reach a fixed point and no further bounds can be inferred.

If incorporation of a bound set has reached a fixed point, and the set does not contain the bound _false_, then the bound set has the following properties:

*   For each combination of a proper lower bound `L` and a proper upper bound U of an inference variable, `L` `<:` U.
*   If every inference variable mentioned by a bound has an instantiation, the bound is satisfied by the corresponding substitution.
*   Given a dependency Œ± = Œ≤, every bound of Œ± matches a bound of Œ≤, and vice versa.
*   Given a dependency Œ± `<:` Œ≤, every lower bound of Œ± is a lower bound of Œ≤, and every upper bound of Œ≤ is an upper bound of Œ±.
    

The assertion that incorporation reaches a fixed point oversimplifies the matter slightly. Building on the work of Kennedy and Pierce, _[On Decidability of Nominal Subtyping with Variance](http://research.microsoft.com/apps/pubs/default.aspx?id=64041)_, this property can be proven by making the argument that the set of types that may appear in the bound set is finite. The argument relies on two assumptions:

*   New capture variables are not generated when reducing subtyping constraints ([¬ß18.2.3](jls-18.html#jls-18.2.3 "18.2.3. Subtyping Constraints")).
*   Expansive inheritance paths are not pursued.
    

This specification does not currently guarantee these properties (it is imprecise about the handling of wildcards when reducing subtyping constraints, and does not detect expansive inheritance paths), but may do so in a future version. (This is not a new problem: the Java subtyping algorithm is also at risk of non-termination.)

### 18.3.1. Complementary Pairs of Bounds

(In this section, S and T are inference variables or types, and U is a proper type. For conciseness, a bound of the form Œ± = T may also match a bound of the form T = Œ±.)

When a bound set contains a pair of bounds that match one of the following rules, a new constraint formula is implied:

*   Œ± = S and Œ± = T imply ‚ÄπS = T‚Ä∫
*   Œ± = S and Œ± `<:` T imply ‚ÄπS `<:` T‚Ä∫
*   Œ± = S and T `<:` Œ± imply ‚ÄπT `<:` S‚Ä∫
*   S `<:` Œ± and Œ± `<:` T imply ‚ÄπS `<:` T‚Ä∫
*   Œ± = U and S = T imply ‚ÄπS`[`Œ±:=U`]` = T`[`Œ±:=U`]`‚Ä∫
*   Œ± = U and S `<:` T imply ‚ÄπS`[`Œ±:=U`]` `<:` T`[`Œ±:=U`]`‚Ä∫
    

When a bound set contains a pair of bounds Œ± `<:` S and Œ± `<:` T, and there exists a supertype of S of the form G`<`S1, ..., Sn`>` and a supertype of T of the form G`<`T1, ..., Tn`>` (for some generic class or interface, G), then for all _i_ (1 ‚â§ _i_ ‚â§ _n_), if Si and Ti are types (not wildcards), the constraint formula ‚ÄπSi = Ti‚Ä∫ is implied.

### 18.3.2. Bounds Involving Capture Conversion

When a bound set contains a bound of the form G`<`Œ±1, ..., Œ±n`>` = capture(G`<`A1, ..., An`>`), new bounds are implied and new constraint formulas may be implied, as follows.

Let P1, ..., Pn represent the type parameters of G and let B1, ..., Bn represent the bounds of these type parameters. Let Œ∏ represent the substitution `[`P1:=Œ±1, ..., Pn:=Œ±n`]`. Let R be a type that is _not_ an inference variable (but is not necessarily a proper type).

A set of bounds on Œ±1, ..., Œ±n is implied, constructed from the declared bounds of P1, ..., Pn as specified in [¬ß18.1.3](jls-18.html#jls-18.1.3 "18.1.3. Bounds").

In addition, for all _i_ (1 ‚â§ _i_ ‚â§ _n_):

*   If Ai is not a wildcard, then the bound Œ±i = Ai is implied.
*   If Ai is a wildcard of the form `?`:
    
    *   Œ±i = R implies the bound _false_
        
    *   Œ±i `<:` R implies the constraint formula ‚ÄπBi Œ∏ `<:` R‚Ä∫
        
    *   R `<:` Œ±i implies the bound _false_
        
*   If Ai is a wildcard of the form `?` `extends` T:
    
    *   Œ±i = R implies the bound _false_
        
    *   If Bi is `Object`, then Œ±i `<:` R implies the constraint formula ‚ÄπT `<:` R‚Ä∫
        
    *   If T is `Object`, then Œ±i `<:` R implies the constraint formula ‚ÄπBi Œ∏ `<:` R‚Ä∫
        
    *   R `<:` Œ±i implies the bound _false_
        
*   If Ai is a wildcard of the form `?` `super` T:
    
    *   Œ±i = R implies the bound _false_
        
    *   Œ±i `<:` R implies the constraint formula ‚ÄπBi Œ∏ `<:` R‚Ä∫
        
    *   R `<:` Œ±i implies the constraint formula ‚ÄπR `<:` T‚Ä∫
        
    

18.4. Resolution
----------------

Given a bound set that does not contain the bound _false_, a subset of the inference variables mentioned by the bound set may be _resolved_. This means that a satisfactory instantiation may be added to the set for each inference variable, until all the requested variables have instantiations.

Dependencies in the bound set may require that the variables be resolved in a particular order, or that additional variables be resolved. Dependencies are specified as follows:

*   Given a bound of one of the following forms, where T is either an inference variable Œ≤ or a type that mentions Œ≤:
    
    *   Œ± = T
        
    *   Œ± `<:` T
        
    *   T = Œ±
        
    *   T `<:` Œ±
        
    
    If Œ± appears on the left-hand side of another bound of the form G`<`..., Œ±, ...`>` = capture(G`<`...`>`), then Œ≤ depends on the resolution of Œ±. Otherwise, Œ± depends on the resolution of Œ≤.
*   An inference variable Œ± appearing on the left-hand side of a bound of the form G`<`..., Œ±, ...`>` = capture(G`<`...`>`) depends on the resolution of every other inference variable mentioned in this bound (on both sides of the = sign).
*   An inference variable Œ± depends on the resolution of an inference variable Œ≤ if there exists an inference variable Œ≥ such that Œ± depends on the resolution of Œ≥ and Œ≥ depends on the resolution of Œ≤.
*   An inference variable Œ± depends on the resolution of itself.
    

Given a set of inference variables to resolve, let V be the union of this set and all variables upon which the resolution of at least one variable in this set depends.

If every variable in V has an instantiation, then resolution succeeds and this procedure terminates.

Otherwise, let { Œ±1, ..., Œ±n } be a non-empty subset of uninstantiated variables in V such that i) for all _i_ (1 ‚â§ _i_ ‚â§ _n_), if Œ±i depends on the resolution of a variable Œ≤, then either Œ≤ has an instantiation or there is some _j_ such that Œ≤ = Œ±j; and ii) there exists no non-empty proper subset of { Œ±1, ..., Œ±n } with this property. Resolution proceeds by generating an instantiation for each of Œ±1, ..., Œ±n based on the bounds in the bound set:

*   If the bound set does not contain a bound of the form G`<`..., Œ±i, ...`>` = capture(G`<`...`>`) for all _i_ (1 ‚â§ _i_ ‚â§ _n_), then a candidate instantiation Ti is defined for each Œ±i:
    
    *   If Œ±i has one or more _proper_ lower bounds, `L1`, ..., `Lk`, then Ti = lub(`L1`, ..., `Lk`) ([¬ß4.10.4](jls-4.html#jls-4.10.4 "4.10.4. Least Upper Bound")).
        
    *   Otherwise, if the bound set contains `throws` Œ±i, and the proper upper bounds of Œ±i are, at most, `Exception`, `Throwable`, and `Object`, then Ti = `RuntimeException`.
        
    *   Otherwise, where Œ±i has _proper_ upper bounds U1, ..., Uk, Ti = glb(U1, ..., Uk) ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")).
        
    
    The bounds Œ±1 = T1, ..., Œ±n = Tn are incorporated with the current bound set.
    
    If the result does not contain the bound _false_, then the result becomes the new bound set, and resolution proceeds by selecting a new set of variables to instantiate (if necessary), as described above.
    
    Otherwise, the result contains the bound _false_, so a second attempt is made to instantiate { Œ±1, ..., Œ±n } by performing the step below.
*   If the bound set contains a bound of the form G`<`..., Œ±i, ...`>` = capture(G`<`...`>`) for some _i_ (1 ‚â§ _i_ ‚â§ _n_), or;
    
    If the bound set produced in the step above contains the bound _false_;
    
    then let Y1, ..., Yn be fresh type variables whose bounds are as follows:
    
    *   For all _i_ (1 ‚â§ _i_ ‚â§ _n_), if Œ±i has one or more _proper_ lower bounds `L1`, ..., `Lk`, then let the lower bound of Yi be lub(`L1`, ..., `Lk`); if not, then Yi has no lower bound.
        
    *   For all _i_ (1 ‚â§ _i_ ‚â§ _n_), where Œ±i has upper bounds U1, ..., Uk, let the upper bound of Yi be glb(U1 Œ∏, ..., Uk Œ∏), where Œ∏ is the substitution `[`Œ±1:=Y1, ..., Œ±n:=Yn`]`.
        
    
    If the type variables Y1, ..., Yn do not have well-formed bounds (that is, a lower bound is not a subtype of an upper bound, or an intersection type is inconsistent), then resolution fails.
    
    Otherwise, for all _i_ (1 ‚â§ _i_ ‚â§ _n_), all bounds of the form G`<`..., Œ±i, ...`>` = capture(G`<`...`>`) are removed from the current bound set, and the bounds Œ±1 = Y1, ..., Œ±n = Yn are incorporated.
    
    If the result does not contain the bound _false_, then the result becomes the new bound set, and resolution proceeds by selecting a new set of variables to instantiate (if necessary), as described above.
    
    Otherwise, the result contains the bound _false_, and resolution fails.
    

The first method of instantiating an inference variable derives the instantiation from that variable's bounds. Sometimes, however, complex dependencies mean that the result is not within the variable's bounds. In that case, a different method of instantiation is performed, analogous to capture conversion ([¬ß5.1.10](jls-5.html#jls-5.1.10 "5.1.10. Capture Conversion")): fresh type variables are introduced, with bounds derived from the bounds of the inference variables. Note that the lower bounds of these "capture" variables are computed using only proper types: this is important in order to avoid attempts to perform typing computations on uninstantiated type variables.

18.5. Uses of Inference
-----------------------

Using the inference processes defined above, the following analyses are performed at compile time.

### 18.5.1. Invocation Applicability Inference

Given a method invocation that provides no explicit type arguments, the process to determine whether a potentially applicable generic method `m` is applicable is as follows:

*   Where P1, ..., Pp (_p_ ‚â• 1) are the type parameters of `m`, let Œ±1, ..., Œ±p be inference variables, and let Œ∏ be the substitution `[`P1:=Œ±1, ..., Pp:=Œ±p`]`.
*   An initial bound set, B0, is constructed from the declared bounds of P1, ..., Pp, as described in [¬ß18.1.3](jls-18.html#jls-18.1.3 "18.1.3. Bounds").
*   For all _i_ (1 ‚â§ _i_ ‚â§ _p_), if Pi appears in the `throws` clause of `m`, then the bound `throws` Œ±i is implied. These bounds, if any, are incorporated with B0 to produce a new bound set, B1.
*   A set of constraint formulas, C, is constructed as follows.
    
    Let F1, ..., Fn be the formal parameter types of `m`, and let `e1`, ..., `ek` be the actual argument expressions of the invocation. Then:
    
    *   To test for _applicability by strict invocation_:
        
        If _k_ ‚â† _n_, or if there exists an _i_ (1 ‚â§ _i_ ‚â§ _n_) such that `ei` is pertinent to applicability ([¬ß15.12.2.2](jls-15.html#jls-15.12.2.2 "15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation")) and either i) `ei` is a standalone expression of a primitive type but Fi is a reference type, or ii) Fi is a primitive type but `ei` is not a standalone expression of a primitive type; then the method is not applicable and there is no need to proceed with inference.
        
        Otherwise, C includes, for all _i_ (1 ‚â§ _i_ ‚â§ _k_) where `ei` is pertinent to applicability, ‚Äπ`ei` ‚Üí Fi Œ∏‚Ä∫.
        
    *   To test for _applicability by loose invocation_:
        
        If _k_ ‚â† _n_, the method is not applicable and there is no need to proceed with inference.
        
        Otherwise, C includes, for all _i_ (1 ‚â§ _i_ ‚â§ _k_) where `ei` is pertinent to applicability, ‚Äπ`ei` ‚Üí Fi Œ∏‚Ä∫.
        
    *   To test for _applicability by variable arity invocation_:
        
        Let F'1, ..., F'k be the first _k_ variable arity parameter types of `m` ([¬ß15.12.2.4](jls-15.html#jls-15.12.2.4 "15.12.2.4. Phase 3: Identify Methods Applicable by Variable Arity Invocation")). C includes, for all _i_ (1 ‚â§ _i_ ‚â§ _k_) where `ei` is pertinent to applicability, ‚Äπ`ei` ‚Üí F'i Œ∏‚Ä∫.
        
*   C is reduced ([¬ß18.2](jls-18.html#jls-18.2 "18.2. Reduction")) and the resulting bounds are incorporated with B1 to produce a new bound set, B2.
*   Finally, the method `m` is applicable if B2 does not contain the bound _false_ and resolution of all the inference variables in B2 succeeds ([¬ß18.4](jls-18.html#jls-18.4 "18.4. Resolution")).
    

Consider the following method invocation and assignment:

List<Number> ln = Arrays.asList(1, 2.0);

A most specific applicable method for the invocation must be identified as described in [¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions"). The only potentially applicable method ([¬ß15.12.2.1](jls-15.html#jls-15.12.2.1 "15.12.2.1. Identify Potentially Applicable Methods")) is declared as follows:

public static <T> List<T> asList(T... a)

Trivially (because of its arity), this method is neither applicable by strict invocation ([¬ß15.12.2.2](jls-15.html#jls-15.12.2.2 "15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation")) nor applicable by loose invocation ([¬ß15.12.2.3](jls-15.html#jls-15.12.2.3 "15.12.2.3. Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation")). But since there are no other candidates, in a third phase the method is checked for applicability by variable arity invocation.

The initial bound set, B, is a trivial upper bound for a single inference variable, Œ±:

{ Œ± `<:` `Object` }

The initial constraint formula set is as follows:

{ ‚Äπ`1` ‚Üí Œ±‚Ä∫, ‚Äπ`2.0` ‚Üí Œ±‚Ä∫ }

These are reduced to a new bound set, B1:

{ Œ± `<:` `Object`, `Integer` `<:` Œ±, `Double` `<:` Œ± }

Then, to test whether the method is applicable, we attempt to resolve these bounds. We succeed, producing the rather complex instantiation

Œ± = `Number & Comparable<? extends Number & Comparable<?>>`

We have thus demonstrated that the method is applicable; since no other candidates exist, it is the most specific applicable method. Still, the type of the method invocation, and its compatibility with the target type in the assignment, is not determined until further inference can occur, as described in the next section.

### 18.5.2. Invocation Type Inference

Given a method invocation that provides no explicit type arguments, and a corresponding most specific applicable generic method `m`, the process to infer the invocation type ([¬ß15.12.2.6](jls-15.html#jls-15.12.2.6 "15.12.2.6. Method Invocation Type")) of the chosen method is as follows:

*   Let Œ∏ be the substitution `[`P1:=Œ±1, ..., Pp:=Œ±p`]` defined in [¬ß18.5.1](jls-18.html#jls-18.5.1 "18.5.1. Invocation Applicability Inference") to replace the type parameters of `m` with inference variables.
*   Let B2 be the bound set produced by reduction in order to demonstrate that `m` is applicable in [¬ß18.5.1](jls-18.html#jls-18.5.1 "18.5.1. Invocation Applicability Inference"). (While it was necessary in [¬ß18.5.1](jls-18.html#jls-18.5.1 "18.5.1. Invocation Applicability Inference") to demonstrate that the inference variables in B2 could be resolved, in order to establish applicability, the instantiations produced by this resolution step are _not_ considered part of B2.)
*   If the invocation is not a poly expression, let the bound set B3 be the same as B2.
    
    If the invocation is a poly expression, let the bound set B3 be derived from B2 as follows. Let R be the return type of `m`, let T be the invocation's target type, and then:
    
    *   If unchecked conversion was necessary for the method to be applicable during constraint set reduction in [¬ß18.5.1](jls-18.html#jls-18.5.1 "18.5.1. Invocation Applicability Inference"), the constraint formula ‚Äπ|R| ‚Üí T‚Ä∫ is reduced and incorporated with B2.
        
    *   Otherwise, if R Œ∏ is a parameterized type, G`<`A1, ..., An`>`, and one of A1, ..., An is a wildcard, then, for fresh inference variables Œ≤1, ..., Œ≤n, the constraint formula ‚ÄπG`<`Œ≤1, ..., Œ≤n`>` ‚Üí T‚Ä∫ is reduced and incorporated, along with the bound G`<`Œ≤1, ..., Œ≤n`>` = capture(G`<`A1, ..., An`>`), with B2.
        
    *   Otherwise, if R Œ∏ is an inference variable Œ±, and one of the following is true:
        
        *   T is a reference type, but is not a wildcard-parameterized type, and either i) B2 contains a bound of one of the forms Œ± = S or S `<:` Œ±, where S is a wildcard-parameterized type, or ii) B2 contains two bounds of the forms S1 `<:` Œ± and S2 `<:` Œ±, where S1 and S2 have supertypes that are two different parameterizations of the same generic class or interface.
            
        *   T is a parameterization of a generic class or interface, G, and B2 contains a bound of one of the forms Œ± = S or S `<:` Œ±, where there exists no type of the form G`<`...`>` that is a supertype of S, but the raw type |G`<`...`>`| is a supertype of S.
            
        *   T is a primitive type, and one of the primitive wrapper classes mentioned in [¬ß5.1.7](jls-5.html#jls-5.1.7 "5.1.7. Boxing Conversion") is an instantiation, upper bound, or lower bound for Œ± in B2.
            
        
        then Œ± is resolved in B2, and where the capture of the resulting instantiation of Œ± is U, the constraint formula ‚ÄπU ‚Üí T‚Ä∫ is reduced and incorporated with B2.
        
    *   Otherwise, the constraint formula ‚ÄπR Œ∏ ‚Üí T‚Ä∫ is reduced and incorporated with B2.
        
*   A set of constraint formulas, C, is constructed as follows.
    
    Let `e1`, ..., `ek` be the actual argument expressions of the invocation. If `m` is applicable by strict or loose invocation, let F1, ..., Fk be the formal parameter types of `m`; if `m` is applicable by variable arity invocation, let F1, ..., Fk the first _k_ variable arity parameter types of `m` ([¬ß15.12.2.4](jls-15.html#jls-15.12.2.4 "15.12.2.4. Phase 3: Identify Methods Applicable by Variable Arity Invocation")). Then:
    
    *   For all _i_ (1 ‚â§ _i_ ‚â§ _k_), if `ei` is not pertinent to applicability, C contains ‚Äπ`ei` ‚Üí Fi Œ∏‚Ä∫.
        
    *   For all _i_ (1 ‚â§ _i_ ‚â§ _k_), additional constraints may be included, depending on the form of `ei`:
        
        *   If `ei` is a _LambdaExpression_, C contains ‚Äπ_LambdaExpression_ ‚Üí_throws_ Fi Œ∏‚Ä∫.
            
            In addition, the lambda body is searched for additional constraints:
            
            *   For a block lambda body, the search is applied recursively to each result expression.
                
            *   For a poly class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")) or a poly method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")), C contains all the constraint formulas that would appear in the set C generated by [¬ß18.5.2](jls-18.html#jls-18.5.2 "18.5.2. Invocation Type Inference") when inferring the poly expression's invocation type.
                
            *   For a parenthesized expression, the search is applied recursively to the contained expression.
                
            *   For a conditional expression, the search is applied recursively to the second and third operands.
                
            *   For a lambda expression, the search is applied recursively to the lambda body.
                
            
        *   If `ei` is a _MethodReference_, C contains ‚Äπ_MethodReference_ ‚Üí_throws_ Fi Œ∏‚Ä∫.
            
        *   If `ei` is a poly class instance creation expression ([¬ß15.9](jls-15.html#jls-15.9 "15.9. Class Instance Creation Expressions")) or a poly method invocation expression ([¬ß15.12](jls-15.html#jls-15.12 "15.12. Method Invocation Expressions")), C contains all the constraint formulas that would appear in the set C generated by [¬ß18.5.2](jls-18.html#jls-18.5.2 "18.5.2. Invocation Type Inference") when inferring the poly expression's invocation type.
            
        *   If `ei` is a parenthesized expression, these rules are applied recursively to the contained expression.
            
        *   If `ei` is a conditional expression, these rules are applied recursively to the second and third operands.
            
        
*   While C is not empty, the following process is repeated, starting with the bound set B3 and accumulating new bounds into a "current" bound set, ultimately producing a new bound set, B4:
    
    1.  A subset of constraints is selected in C, satisfying the property that, for each constraint, no input variable can influence an output variable of another constraint in C. The terms _input variable_ and _output variable_ are defined below. An inference variable Œ± _can influence_ an inference variable Œ≤ if Œ± depends on the resolution of Œ≤ ([¬ß18.4](jls-18.html#jls-18.4 "18.4. Resolution")), or vice versa; or if there exists a third inference variable Œ≥ such that Œ± can influence Œ≥ and Œ≥ can influence Œ≤.
        
        If this subset is empty, then there is a cycle (or cycles) in the graph of dependencies between constraints. In this case, all constraints are considered that participate in a dependency cycle (or cycles) and do not depend on any constraints outside of the cycle (or cycles). A single constraint is selected from the considered constraints, as follows:
        
        *   If any of the considered constraints have the form ‚Äπ_Expression_ ‚Üí T‚Ä∫, then the selected constraint is the considered constraint of this form that contains the expression to the left ([¬ß3.5](jls-3.html#jls-3.5 "3.5. Input Elements and Tokens")) of the expression of every other considered constraint of this form.
            
        *   If no considered constraint has the form ‚Äπ_Expression_ ‚Üí T‚Ä∫, then the selected constraint is the considered constraint that contains the expression to the left of the expression of every other considered constraint.
            
        
    2.  The selected constraint(s) are removed from C.
        
    3.  The input variables Œ±1, ..., Œ±m of all the selected constraint(s) are resolved.
        
    4.  Where T1, ..., Tm are the instantiations of Œ±1, ..., Œ±m, the substitution `[`Œ±1:=T1, ..., Œ±m:=Tm`]` is applied to every constraint.
        
    5.  The constraint(s) resulting from substitution are reduced and incorporated with the current bound set.
        
*   Finally, if B4 does not contain the bound _false_, the inference variables in B4 are resolved.
    
    If resolution succeeds with instantiations T1, ..., Tp for inference variables Œ±1, ..., Œ±p, let Œ∏' be the substitution `[`P1:=T1, ..., Pp:=Tp`]`. Then:
    
    *   If unchecked conversion was necessary for the method to be applicable during constraint set reduction in [¬ß18.5.1](jls-18.html#jls-18.5.1 "18.5.1. Invocation Applicability Inference"), then the parameter types of the invocation type of `m` are obtained by applying Œ∏' to the parameter types of `m`'s type, and the return type and thrown types of the invocation type of `m` are given by the erasure of the return type and thrown types of `m`'s type.
        
    *   If unchecked conversion was not necessary for the method to be applicable, then the invocation type of `m` is obtained by applying Œ∏' to the type of `m`.
        
    
    If B4 contains the bound _false_, or if resolution fails, then a compile-time error occurs.
    

Invocation type inference may require carefully sequencing the reduction of constraint formulas of the forms ‚Äπ_Expression_ ‚Üí T‚Ä∫, ‚Äπ_LambdaExpression_ ‚Üí_throws_ T‚Ä∫, and ‚Äπ_MethodReference_ ‚Üí_throws_ T‚Ä∫. To facilitate this sequencing, the _input variables_ of these constraints are defined as follows:

*   For ‚Äπ_LambdaExpression_ ‚Üí T‚Ä∫:
    
    *   If T is an inference variable, it is the (only) input variable.
        
    *   If T is a functional interface type, and a function type can be derived from T ([¬ß15.27.3](jls-15.html#jls-15.27.3 "15.27.3. Type of a Lambda Expression")), then the input variables include i) if the lambda expression is implicitly typed, the inference variables mentioned by the function type's parameter types; and ii) if the function type's return type, R, is not `void`, then for each result expression `e` in the lambda body (or for the body itself if it is an expression), the input variables of ‚Äπ`e` ‚Üí R‚Ä∫.
        
    *   Otherwise, there are no input variables.
        
*   For ‚Äπ_LambdaExpression_ ‚Üí_throws_ T‚Ä∫:
    
    *   If T is an inference variable, it is the (only) input variable.
        
    *   If T is a functional interface type, and a function type can be derived, as described in [¬ß15.27.3](jls-15.html#jls-15.27.3 "15.27.3. Type of a Lambda Expression"), the input variables include i) if the lambda expression is implicitly typed, the inference variables mentioned by the function type's parameter types; and ii) the inference variables mentioned by the function type's return type.
        
    *   Otherwise, there are no input variables.
        
*   For ‚Äπ_MethodReference_ ‚Üí T‚Ä∫:
    
    *   If T is an inference variable, it is the (only) input variable.
        
    *   If T is a functional interface type with a function type, and if the method reference is inexact ([¬ß15.13.1](jls-15.html#jls-15.13.1 "15.13.1. Compile-Time Declaration of a Method Reference")), the input variables are the inference variables mentioned by the function type's parameter types.
        
    *   Otherwise, there are no input variables.
        
*   For ‚Äπ_MethodReference_ ‚Üí_throws_ T‚Ä∫:
    
    *   If T is an inference variable, it is the (only) input variable.
        
    *   If T is a functional interface type with a function type, and if the method reference is inexact ([¬ß15.13.1](jls-15.html#jls-15.13.1 "15.13.1. Compile-Time Declaration of a Method Reference")), the input variables are the inference variables mentioned by the function type's parameter types and the function type's return type.
        
    *   Otherwise, there are no input variables.
        
*   For ‚Äπ_Expression_ ‚Üí T‚Ä∫, if _Expression_ is a parenthesized expression:
    
    Where the contained expression of _Expression_ is _Expression_', the input variables are the input variables of ‚Äπ_Expression_' ‚Üí T‚Ä∫.
*   For ‚Äπ_ConditionalExpression_ ‚Üí T‚Ä∫:
    
    Where the conditional expression has the form `e1` `?` `e2` `:` `e3`, the input variables are the input variables of ‚Äπ`e2` ‚Üí T‚Ä∫ and ‚Äπ`e3` ‚Üí T‚Ä∫.
*   For all other constraint formulas, there are no input variables.
    

The _output variables_ of these constraints are all inference variables mentioned by the type on the right-hand side of the constraint, T, that are not input variables.

It is important to note that two "rounds" of inference are involved in finding the type of a method invocation. This is necessary to allow a target type to influence the type of the invocation without allowing it to influence the choice of an applicable method. The first round produces a bound set and tests that a resolution exists, but does not commit to that resolution. The second round reduces additional constraints and then performs a second resolution, this time "for real".

Consider the example from the previous section:

List`<`Number`>` ln = Arrays.asList(1, 2.0);

The most specific applicable method was identified as:

public static `<`T`>` List`<`T`>` asList(T... a)

In order to complete type-checking of the method invocation, we must determine whether it is compatible with its target type, `` List`<`Number`>` ``.

The bound set used to demonstrate applicability in the previous section, B2, was:

{ Œ± `<:` `Object`, `Integer` `<:` Œ±, `Double` `<:` Œ± }

The new constraint formula set is as follows:

{ ‚Äπ`` List`<`Œ±`>` `` ‚Üí `` List`<`Number`>` ``‚Ä∫ }

This compatibility constraint produces an equality bound for Œ±, which is included in the new bound set, B3:

{ Œ± `<:` `Object`, `Integer` `<:` Œ±, `Double` `<:` Œ±, Œ± = `Number` }

These bounds are trivially resolved:

Œ± = `Number`

Finally, we perform a substitution on the declared return type of `asList` to determine that the method invocation has type `` List`<`Number`>` ``; clearly, this is compatible with the target type.

This inference strategy is different than the Java SE 7 Edition of _The Java¬Æ Language Specification_, which would have instantiated Œ± based on its lower bounds (before even considering the invocation's target type), as we did in the previous section. This would result in a type error, since the resulting type is not a subtype of `` List`<`Number`>` ``.

Under various special circumstances, based on the bounds appearing in B2, we eagerly resolve an inference variable that appears as the return type of the invocation. This is to avoid unfortunate situations in which the usual constraint, ‚ÄπR Œ∏ ‚Üí T‚Ä∫, is not completeness-preserving. It is, unfortunately, possible that by eagerly resolving the variable, we are unable to make use of bounds that would be inferred later. It is also possible that, in some cases, bounds that will later be inferred from the invocation arguments (such as implicitly typed lambda expressions) would have caused a different outcome if they had been present in B2. Despite these limitations, the strategy allows for reasonable outcomes in typical use cases, and is backwards compatible with the algorithm in the Java SE 7 Edition of _The Java¬Æ Language Specification_.

### 18.5.3. Functional Interface Parameterization Inference

Where a lambda expression with explicit parameter types P1, ..., Pn targets a functional interface type F`<`A1, ..., Am`>` with at least one wildcard type argument, then a parameterization of F may be derived as the ground target type of the lambda expression as follows.

Let Q1, ..., Qk be the parameter types of the function type of the type F`<`Œ±1, ..., Œ±m`>`, where Œ±1, ..., Œ±m are fresh inference variables.

If _n_ ‚â† _k_, no valid parameterization exists. Otherwise, a set of constraint formulas is formed with, for all _i_ (1 ‚â§ _i_ ‚â§ _n_), ‚ÄπPi = Qi‚Ä∫. This constraint formula set is reduced to form the bound set B.

If B contains the bound _false_, no valid parameterization exists. Otherwise, a new parameterization of the functional interface type, F`<`A'1, ..., A'm`>`, is constructed as follows, for 1 ‚â§ _i_ ‚â§ _m_:

*   If B contains an instantiation ([¬ß18.1.3](jls-18.html#jls-18.1.3 "18.1.3. Bounds")) for Œ±i, T, then A'i = T.
*   Otherwise, A'i = Ai.
    

If F`<`A'1, ..., A'm`>` is not a well-formed type (that is, the type arguments are not within their bounds), or if F`<`A'1, ..., A'm`>` is not a subtype of F`<`A1, ..., Am`>`, no valid parameterization exists. Otherwise, the inferred parameterization is either F`<`A'1, ..., A'm`>`, if all the type arguments are types, or the non-wildcard parameterization ([¬ß9.9](jls-9.html#jls-9.9 "9.9. Function Types")) of F`<`A'1, ..., A'm`>`, if one or more type arguments are still wildcards.

In order to determine the function type of a wildcard-parameterized functional interface, we have to "instantiate" the wildcard type arguments with specific types. The "default" approach is to simply replace the wildcards with their bounds, as described in [¬ß9.8](jls-9.html#jls-9.8 "9.8. Functional Interfaces"), but this produces spurious errors in cases where a lambda expression has explicit parameter types that do _not_ correspond to the wildcard bounds. For example:

Predicate<? super Integer> p = (Number n) `->` n.equals(23);

The lambda expression is a `Predicate<Number>`, which is a subtype of `Predicate<? super Integer>` but not `Predicate<Integer>`. The analysis in this section is used to infer that `Number` is an appropriate choice for the type argument to `Predicate`.

That said, the analysis here, while described in terms of general type inference, is intentionally quite simple. The only constraints are equality constraints, which means that reduction amounts to simple pattern matching. A more powerful strategy might also infer constraints from the body of the lambda expression. But, given possible interactions with inference for surrounding and/or nested generic method invocations, this would introduce a lot of extra complexity.

### 18.5.4. More Specific Method Inference

When testing that one applicable method is _more specific_ than another ([¬ß15.12.2.5](jls-15.html#jls-15.12.2.5 "15.12.2.5. Choosing the Most Specific Method")), where the second method is generic, it is necessary to test whether some instantiation of the second method's type parameters can be inferred to make the first method more specific than the second.

Let `m1` be the first method and `m2` be the second method. Where `m2` has type parameters P1, ..., Pp, let Œ±1, ..., Œ±p be inference variables, and let Œ∏ be the substitution `[`P1:=Œ±1, ..., Pp:=Œ±p`]`.

Let `e1`, ..., `ek` be the argument expressions of the corresponding invocation. Then:

*   If `m1` and `m2` are applicable by strict or loose invocation ([¬ß15.12.2.2](jls-15.html#jls-15.12.2.2 "15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation"), [¬ß15.12.2.3](jls-15.html#jls-15.12.2.3 "15.12.2.3. Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation")), then let S1, ..., Sk be the formal parameter types of `m1`, and let T1, ..., Tk be the result of Œ∏ applied to the formal parameter types of `m2`.
*   If `m1` and `m2` are applicable by variable arity invocation ([¬ß15.12.2.4](jls-15.html#jls-15.12.2.4 "15.12.2.4. Phase 3: Identify Methods Applicable by Variable Arity Invocation")), then let S1, ..., Sk be the first _k_ variable arity parameter types of `m1`, and let T1, ..., Tk be the result of Œ∏ applied to the first _k_ variable arity parameter types of `m2`.
    

Note that no substitution is applied to S1, ..., Sk; even if `m1` is generic, the type parameters of `m1` are treated as type variables, not inference variables.

The process to determine if `m1` is more specific than `m2` is as follows:

*   First, an initial bound set, B, is constructed from the declared bounds of P1, ..., Pp, as specified in [¬ß18.1.3](jls-18.html#jls-18.1.3 "18.1.3. Bounds").
*   Second, for all _i_ (1 ‚â§ _i_ ‚â§ _k_), a set of constraint formulas or bounds is generated.
    
    If Ti is a proper type, the result is _true_ if Si is more specific than Ti for `ei` ([¬ß15.12.2.5](jls-15.html#jls-15.12.2.5 "15.12.2.5. Choosing the Most Specific Method")), and _false_ otherwise. (Note that Si is always a proper type.)
    
    Otherwise, if Ti is not a functional interface type, the constraint formula ‚ÄπSi `<:` Ti‚Ä∫ is generated.
    
    Otherwise, Ti is a parameterization of a functional interface, I. It must be determined whether Si satisfies the following five conditions:
    
    *   Si is a functional interface type.
        
    *   Si is not a superinterface of I, nor a parameterization of a superinterface of I.
        
    *   Si is not a subinterface of I, nor a parameterization of a subinterface of I.
        
    *   If Si is an intersection type, at least one element of the intersection is not a superinterface of I, nor a parameterization of a superinterface of I.If Si is an intersection type, no element of the intersection is a subinterface of I, nor a parameterization of a subinterface of I.

If all five conditions are true, then the following constraint formulas or bounds are generated (where U1 ... Uk and R1 are the parameter types and return type of the function type of the capture of Si, and V1 ... Vk and R2 are the parameter types and return type of the function type of Ti):

*   If `ei` is an explicitly typed lambda expression:
    
    *   For all _j_ (1 ‚â§ _j_ ‚â§ _k_), ‚ÄπUj = Vj‚Ä∫.
        
    *   If R2 is `void`, _true_.
        
    *   Otherwise, if R1 and R2 are functional interface types, and neither interface is a subinterface of the other, and `ei` has at least one result expression, then these rules are applied recursively to R1 and R2, for each result expression in `ei`.
        
    *   Otherwise, if R1 is a primitive type and R2 is not, and `ei` has at least one result expression, and each result expression of `ei` is a standalone expression ([¬ß15.2](jls-15.html#jls-15.2 "15.2. Forms of Expressions")) of a primitive type, _true_.
        
    *   Otherwise, if R2 is a primitive type and R1 is not, and `ei` has at least one result expression, and each result expression of `ei` is either a standalone expression of a reference type or a poly expression, _true_.
        
    *   Otherwise, ‚ÄπR1 `<:` R2‚Ä∫.
        
*   If `ei` is an exact method reference:
    
    *   For all _j_ (1 ‚â§ _j_ ‚â§ _k_), ‚ÄπUj = Vj‚Ä∫.
        
    *   If R2 is `void`, _true_.
        
    *   Otherwise, if R1 is a primitive type and R2 is not, and the compile-time declaration for `ei` has a primitive return type, _true_.
        
    *   Otherwise if R2 is a primitive type and R1 is not, and the compile-time declaration for `ei` has a reference return type, _true_.
        
    *   Otherwise, ‚ÄπR1 `<:` R2‚Ä∫.
        
*   If `ei` is a parenthesized expression, these rules are applied recursively to the contained expression.
*   If `ei` is a conditional expression, these rules are applied recursively to each of the second and third operands.
*   Otherwise, _false_.
    

If the five constraints on Si are not satisfied, the constraint formula ‚ÄπSi `<:` Ti‚Ä∫ is generated instead.

*   Third, if `m2` is applicable by variable arity invocation and has _k_+1 parameters, then where Sk+1 is the _k_+1'th variable arity parameter type of `m1` and Tk+1 is the result of Œ∏ applied to the _k_+1'th variable arity parameter type of `m2`, the constraint ‚ÄπSk+1 `<:` Tk+1‚Ä∫ is generated.
*   Fourth, the generated bounds and constraint formulas are reduced and incorporated with B to produce a bound set B'.
    
    If B' does not contain the bound _false_, and resolution of all the inference variables in B' succeeds, then `m1` is more specific than `m2`.
    
    Otherwise, `m1` is not more specific than `m2`.
    

üçÄ Chapter 19. Syntax
------------------

This chapter repeats the syntactic grammar given in Chapters 4, 6-10, 14, and 15, as well as key parts of the lexical grammar from Chapter 3, using the notation from [¬ß2.4](jls-2.html#jls-2.4 "2.4. Grammar Notation").

**Productions from [¬ß3 (_Lexical Structure_)](jls-3.html "Chapter 3. Lexical Structure")**

Identifier:

[IdentifierChars](jls-3.html#jls-IdentifierChars "IdentifierChars") but not a [Keyword](jls-3.html#jls-Keyword "Keyword") or [BooleanLiteral](jls-3.html#jls-BooleanLiteral "BooleanLiteral") or [NullLiteral](jls-3.html#jls-NullLiteral "NullLiteral")

IdentifierChars:

[JavaLetter](jls-3.html#jls-JavaLetter "JavaLetter") {[JavaLetterOrDigit](jls-3.html#jls-JavaLetterOrDigit "JavaLetterOrDigit")}

JavaLetter:

any Unicode character that is a "Java letter"

JavaLetterOrDigit:

any Unicode character that is a "Java letter-or-digit"

Literal:

[IntegerLiteral](jls-3.html#jls-IntegerLiteral "IntegerLiteral")  
[FloatingPointLiteral](jls-3.html#jls-FloatingPointLiteral "FloatingPointLiteral")  
[BooleanLiteral](jls-3.html#jls-BooleanLiteral "BooleanLiteral")  
[CharacterLiteral](jls-3.html#jls-CharacterLiteral "CharacterLiteral")  
[StringLiteral](jls-3.html#jls-StringLiteral "StringLiteral")  
[NullLiteral](jls-3.html#jls-NullLiteral "NullLiteral")

**Productions from [¬ß4 (_Types, Values, and Variables_)](jls-4.html "Chapter 4. Types, Values, and Variables")**

Type:

[PrimitiveType](jls-4.html#jls-PrimitiveType "PrimitiveType")  
[ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType")

PrimitiveType:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} [NumericType](jls-4.html#jls-NumericType "NumericType")  
{[Annotation](jls-9.html#jls-Annotation "Annotation")} `boolean`

NumericType:

[IntegralType](jls-4.html#jls-IntegralType "IntegralType")  
[FloatingPointType](jls-4.html#jls-FloatingPointType "FloatingPointType")

IntegralType:

(one of)  
`byte` `short` `int` `long` `char`

FloatingPointType:

(one of)  
`float` `double`

ReferenceType:

[ClassOrInterfaceType](jls-4.html#jls-ClassOrInterfaceType "ClassOrInterfaceType")  
[TypeVariable](jls-4.html#jls-TypeVariable "TypeVariable")  
[ArrayType](jls-4.html#jls-ArrayType "ArrayType")

ClassOrInterfaceType:

[ClassType](jls-4.html#jls-ClassType "ClassType")  
[InterfaceType](jls-4.html#jls-InterfaceType "InterfaceType")

ClassType:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} [Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\]  
[ClassOrInterfaceType](jls-4.html#jls-ClassOrInterfaceType "ClassOrInterfaceType") `.` {[Annotation](jls-9.html#jls-Annotation "Annotation")} [Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\]

InterfaceType:

[ClassType](jls-4.html#jls-ClassType "ClassType")

TypeVariable:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} [Identifier](jls-3.html#jls-Identifier "Identifier")

ArrayType:

[PrimitiveType](jls-4.html#jls-PrimitiveType "PrimitiveType") [Dims](jls-4.html#jls-Dims "Dims")  
[ClassOrInterfaceType](jls-4.html#jls-ClassOrInterfaceType "ClassOrInterfaceType") [Dims](jls-4.html#jls-Dims "Dims")  
[TypeVariable](jls-4.html#jls-TypeVariable "TypeVariable") [Dims](jls-4.html#jls-Dims "Dims")

Dims:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]` {{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` `]`}

TypeParameter:

{[TypeParameterModifier](jls-4.html#jls-TypeParameterModifier "TypeParameterModifier")} [Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeBound](jls-4.html#jls-TypeBound "TypeBound")\]

TypeParameterModifier:

[Annotation](jls-9.html#jls-Annotation "Annotation")

TypeBound:

`extends` [TypeVariable](jls-4.html#jls-TypeVariable "TypeVariable")  
`extends` [ClassOrInterfaceType](jls-4.html#jls-ClassOrInterfaceType "ClassOrInterfaceType") {[AdditionalBound](jls-4.html#jls-AdditionalBound "AdditionalBound")}

AdditionalBound:

`&` [InterfaceType](jls-4.html#jls-InterfaceType "InterfaceType")

TypeArguments:

`<` [TypeArgumentList](jls-4.html#jls-TypeArgumentList "TypeArgumentList") `>`

TypeArgumentList:

[TypeArgument](jls-4.html#jls-TypeArgument "TypeArgument") {`,` [TypeArgument](jls-4.html#jls-TypeArgument "TypeArgument")}

TypeArgument:

[ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType")  
[Wildcard](jls-4.html#jls-Wildcard "Wildcard")

Wildcard:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `?` \[[WildcardBounds](jls-4.html#jls-WildcardBounds "WildcardBounds")\]

WildcardBounds:

`extends` [ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType")  
`super` [ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType")

**Productions from [¬ß6 (_Names_)](jls-6.html "Chapter 6. Names")**

TypeName:

[Identifier](jls-3.html#jls-Identifier "Identifier")  
[PackageOrTypeName](jls-6.html#jls-PackageOrTypeName "PackageOrTypeName") `.` [Identifier](jls-3.html#jls-Identifier "Identifier")

PackageOrTypeName:

[Identifier](jls-3.html#jls-Identifier "Identifier")  
[PackageOrTypeName](jls-6.html#jls-PackageOrTypeName "PackageOrTypeName") `.` [Identifier](jls-3.html#jls-Identifier "Identifier")

ExpressionName:

[Identifier](jls-3.html#jls-Identifier "Identifier")  
[AmbiguousName](jls-6.html#jls-AmbiguousName "AmbiguousName") `.` [Identifier](jls-3.html#jls-Identifier "Identifier")

MethodName:

[Identifier](jls-3.html#jls-Identifier "Identifier")  

PackageName:

[Identifier](jls-3.html#jls-Identifier "Identifier")  
[PackageName](jls-6.html#jls-PackageName "PackageName") `.` [Identifier](jls-3.html#jls-Identifier "Identifier")

AmbiguousName:

[Identifier](jls-3.html#jls-Identifier "Identifier")  
[AmbiguousName](jls-6.html#jls-AmbiguousName "AmbiguousName") `.` [Identifier](jls-3.html#jls-Identifier "Identifier")

**Productions from [¬ß7 (_Packages_)](jls-7.html "Chapter 7. Packages")**

CompilationUnit:

\[[PackageDeclaration](jls-7.html#jls-PackageDeclaration "PackageDeclaration")\] {[ImportDeclaration](jls-7.html#jls-ImportDeclaration "ImportDeclaration")} {[TypeDeclaration](jls-7.html#jls-TypeDeclaration "TypeDeclaration")}

PackageDeclaration:

{[PackageModifier](jls-7.html#jls-PackageModifier "PackageModifier")} `package` [Identifier](jls-3.html#jls-Identifier "Identifier") {`.` [Identifier](jls-3.html#jls-Identifier "Identifier")} `;`

PackageModifier:

[Annotation](jls-9.html#jls-Annotation "Annotation")

ImportDeclaration:

[SingleTypeImportDeclaration](jls-7.html#jls-SingleTypeImportDeclaration "SingleTypeImportDeclaration")  
[TypeImportOnDemandDeclaration](jls-7.html#jls-TypeImportOnDemandDeclaration "TypeImportOnDemandDeclaration")  
[SingleStaticImportDeclaration](jls-7.html#jls-SingleStaticImportDeclaration "SingleStaticImportDeclaration")  
[StaticImportOnDemandDeclaration](jls-7.html#jls-StaticImportOnDemandDeclaration "StaticImportOnDemandDeclaration")

SingleTypeImportDeclaration:

`import` [TypeName](jls-6.html#jls-TypeName "TypeName") `;`

TypeImportOnDemandDeclaration:

`import` [PackageOrTypeName](jls-6.html#jls-PackageOrTypeName "PackageOrTypeName") `.` `*` `;`

SingleStaticImportDeclaration:

`import` `static` [TypeName](jls-6.html#jls-TypeName "TypeName") `.` [Identifier](jls-3.html#jls-Identifier "Identifier") `;`

StaticImportOnDemandDeclaration:

`import` `static` [TypeName](jls-6.html#jls-TypeName "TypeName") `.` `*` `;`

TypeDeclaration:

[ClassDeclaration](jls-8.html#jls-ClassDeclaration "ClassDeclaration")  
[InterfaceDeclaration](jls-9.html#jls-InterfaceDeclaration "InterfaceDeclaration")  
`;`

**Productions from [¬ß8 (_Classes_)](jls-8.html "Chapter 8. Classes")**

ClassDeclaration:

[NormalClassDeclaration](jls-8.html#jls-NormalClassDeclaration "NormalClassDeclaration")  
[EnumDeclaration](jls-8.html#jls-EnumDeclaration "EnumDeclaration")

NormalClassDeclaration:

{[ClassModifier](jls-8.html#jls-ClassModifier "ClassModifier")} `class` [Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeParameters](jls-8.html#jls-TypeParameters "TypeParameters")\] \[[Superclass](jls-8.html#jls-Superclass "Superclass")\] \[[Superinterfaces](jls-8.html#jls-Superinterfaces "Superinterfaces")\] [ClassBody](jls-8.html#jls-ClassBody "ClassBody")

ClassModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `public` `protected` `private`  
`abstract` `static` `final` `strictfp`

TypeParameters:

`<` [TypeParameterList](jls-8.html#jls-TypeParameterList "TypeParameterList") `>`

TypeParameterList:

[TypeParameter](jls-4.html#jls-TypeParameter "TypeParameter") {`,` [TypeParameter](jls-4.html#jls-TypeParameter "TypeParameter")}

Superclass:

`extends` [ClassType](jls-4.html#jls-ClassType "ClassType")

Superinterfaces:

`implements` [InterfaceTypeList](jls-8.html#jls-InterfaceTypeList "InterfaceTypeList")

InterfaceTypeList:

[InterfaceType](jls-4.html#jls-InterfaceType "InterfaceType") {`,` [InterfaceType](jls-4.html#jls-InterfaceType "InterfaceType")}

ClassBody:

`{` {[ClassBodyDeclaration](jls-8.html#jls-ClassBodyDeclaration "ClassBodyDeclaration")} `}`

ClassBodyDeclaration:

[ClassMemberDeclaration](jls-8.html#jls-ClassMemberDeclaration "ClassMemberDeclaration")  
[InstanceInitializer](jls-8.html#jls-InstanceInitializer "InstanceInitializer")  
[StaticInitializer](jls-8.html#jls-StaticInitializer "StaticInitializer")  
[ConstructorDeclaration](jls-8.html#jls-ConstructorDeclaration "ConstructorDeclaration")

ClassMemberDeclaration:

[FieldDeclaration](jls-8.html#jls-FieldDeclaration "FieldDeclaration")  
[MethodDeclaration](jls-8.html#jls-MethodDeclaration "MethodDeclaration")  
[ClassDeclaration](jls-8.html#jls-ClassDeclaration "ClassDeclaration")  
[InterfaceDeclaration](jls-9.html#jls-InterfaceDeclaration "InterfaceDeclaration")  
`;`

FieldDeclaration:

{[FieldModifier](jls-8.html#jls-FieldModifier "FieldModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [VariableDeclaratorList](jls-8.html#jls-VariableDeclaratorList "VariableDeclaratorList") `;`

FieldModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `public` `protected` `private`  
`static` `final` `transient` `volatile`

VariableDeclaratorList:

[VariableDeclarator](jls-8.html#jls-VariableDeclarator "VariableDeclarator") {`,` [VariableDeclarator](jls-8.html#jls-VariableDeclarator "VariableDeclarator")}

VariableDeclarator:

[VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId") \[`=` [VariableInitializer](jls-8.html#jls-VariableInitializer "VariableInitializer")\]

VariableDeclaratorId:

[Identifier](jls-3.html#jls-Identifier "Identifier") \[[Dims](jls-4.html#jls-Dims "Dims")\]

VariableInitializer:

[Expression](jls-15.html#jls-Expression "Expression")  
[ArrayInitializer](jls-10.html#jls-ArrayInitializer "ArrayInitializer")

UnannType:

[UnannPrimitiveType](jls-8.html#jls-UnannPrimitiveType "UnannPrimitiveType")  
[UnannReferenceType](jls-8.html#jls-UnannReferenceType "UnannReferenceType")

UnannPrimitiveType:

[NumericType](jls-4.html#jls-NumericType "NumericType")  
`boolean`

UnannReferenceType:

[UnannClassOrInterfaceType](jls-8.html#jls-UnannClassOrInterfaceType "UnannClassOrInterfaceType")  
[UnannTypeVariable](jls-8.html#jls-UnannTypeVariable "UnannTypeVariable")  
[UnannArrayType](jls-8.html#jls-UnannArrayType "UnannArrayType")

UnannClassOrInterfaceType:

[UnannClassType](jls-8.html#jls-UnannClassType "UnannClassType")  
[UnannInterfaceType](jls-8.html#jls-UnannInterfaceType "UnannInterfaceType")

UnannClassType:

[Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\]  
[UnannClassOrInterfaceType](jls-8.html#jls-UnannClassOrInterfaceType "UnannClassOrInterfaceType") `.` {[Annotation](jls-9.html#jls-Annotation "Annotation")} [Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\]

UnannInterfaceType:

[UnannClassType](jls-8.html#jls-UnannClassType "UnannClassType")

UnannTypeVariable:

[Identifier](jls-3.html#jls-Identifier "Identifier")

UnannArrayType:

[UnannPrimitiveType](jls-8.html#jls-UnannPrimitiveType "UnannPrimitiveType") [Dims](jls-4.html#jls-Dims "Dims")  
[UnannClassOrInterfaceType](jls-8.html#jls-UnannClassOrInterfaceType "UnannClassOrInterfaceType") [Dims](jls-4.html#jls-Dims "Dims")  
[UnannTypeVariable](jls-8.html#jls-UnannTypeVariable "UnannTypeVariable") [Dims](jls-4.html#jls-Dims "Dims")

MethodDeclaration:

{[MethodModifier](jls-8.html#jls-MethodModifier "MethodModifier")} [MethodHeader](jls-8.html#jls-MethodHeader "MethodHeader") [MethodBody](jls-8.html#jls-MethodBody "MethodBody")

MethodModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `public` `protected` `private`  
`abstract` `static` `final` `synchronized` `native` `strictfp`

MethodHeader:

[Result](jls-8.html#jls-Result "Result") [MethodDeclarator](jls-8.html#jls-MethodDeclarator "MethodDeclarator") \[[Throws](jls-8.html#jls-Throws "Throws")\]  
[TypeParameters](jls-8.html#jls-TypeParameters "TypeParameters") {[Annotation](jls-9.html#jls-Annotation "Annotation")} [Result](jls-8.html#jls-Result "Result") [MethodDeclarator](jls-8.html#jls-MethodDeclarator "MethodDeclarator") \[[Throws](jls-8.html#jls-Throws "Throws")\]

Result:

[UnannType](jls-8.html#jls-UnannType "UnannType")  
`void`

MethodDeclarator:

[Identifier](jls-3.html#jls-Identifier "Identifier") `(` \[[FormalParameterList](jls-8.html#jls-FormalParameterList "FormalParameterList")\] `)` \[[Dims](jls-4.html#jls-Dims "Dims")\]

FormalParameterList:

[ReceiverParameter](jls-8.html#jls-ReceiverParameter "ReceiverParameter")  
[FormalParameters](jls-8.html#jls-FormalParameters "FormalParameters") `,` [LastFormalParameter](jls-8.html#jls-LastFormalParameter "LastFormalParameter")  
[LastFormalParameter](jls-8.html#jls-LastFormalParameter "LastFormalParameter")

FormalParameters:

[FormalParameter](jls-8.html#jls-FormalParameter "FormalParameter") {`,` [FormalParameter](jls-8.html#jls-FormalParameter "FormalParameter")}  
[ReceiverParameter](jls-8.html#jls-ReceiverParameter "ReceiverParameter") {`,` [FormalParameter](jls-8.html#jls-FormalParameter "FormalParameter")}

FormalParameter:

{[VariableModifier](jls-8.html#jls-VariableModifier "VariableModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId")

VariableModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `final`

LastFormalParameter:

{[VariableModifier](jls-8.html#jls-VariableModifier "VariableModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") {[Annotation](jls-9.html#jls-Annotation "Annotation")} `...` [VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId")  
[FormalParameter](jls-8.html#jls-FormalParameter "FormalParameter")

ReceiverParameter:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} [UnannType](jls-8.html#jls-UnannType "UnannType") \[[Identifier](jls-3.html#jls-Identifier "Identifier") `.`\] `this`

Throws:

`throws` [ExceptionTypeList](jls-8.html#jls-ExceptionTypeList "ExceptionTypeList")

ExceptionTypeList:

[ExceptionType](jls-8.html#jls-ExceptionType "ExceptionType") {`,` [ExceptionType](jls-8.html#jls-ExceptionType "ExceptionType")}

ExceptionType:

[ClassType](jls-4.html#jls-ClassType "ClassType")  
[TypeVariable](jls-4.html#jls-TypeVariable "TypeVariable")

MethodBody:

[Block](jls-14.html#jls-Block "Block")  
`;`

InstanceInitializer:

[Block](jls-14.html#jls-Block "Block")

StaticInitializer:

`static` [Block](jls-14.html#jls-Block "Block")

ConstructorDeclaration:

{[ConstructorModifier](jls-8.html#jls-ConstructorModifier "ConstructorModifier")} [ConstructorDeclarator](jls-8.html#jls-ConstructorDeclarator "ConstructorDeclarator") \[[Throws](jls-8.html#jls-Throws "Throws")\] [ConstructorBody](jls-8.html#jls-ConstructorBody "ConstructorBody")

ConstructorModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `public` `protected` `private`

ConstructorDeclarator:

\[[TypeParameters](jls-8.html#jls-TypeParameters "TypeParameters")\] [SimpleTypeName](jls-8.html#jls-SimpleTypeName "SimpleTypeName") `(` \[[FormalParameterList](jls-8.html#jls-FormalParameterList "FormalParameterList")\] `)`

SimpleTypeName:

[Identifier](jls-3.html#jls-Identifier "Identifier")

ConstructorBody:

`{` \[[ExplicitConstructorInvocation](jls-8.html#jls-ExplicitConstructorInvocation "ExplicitConstructorInvocation")\] \[[BlockStatements](jls-14.html#jls-BlockStatements "BlockStatements")\] `}`

ExplicitConstructorInvocation:

\[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] `this` `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)` `;`  
\[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] `super` `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)` `;`  
[ExpressionName](jls-6.html#jls-ExpressionName "ExpressionName") `.` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] `super` `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)` `;`  
[Primary](jls-15.html#jls-Primary "Primary") `.` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] `super` `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)` `;`

EnumDeclaration:

{[ClassModifier](jls-8.html#jls-ClassModifier "ClassModifier")} `enum` [Identifier](jls-3.html#jls-Identifier "Identifier") \[[Superinterfaces](jls-8.html#jls-Superinterfaces "Superinterfaces")\] [EnumBody](jls-8.html#jls-EnumBody "EnumBody")

EnumBody:

`{` \[[EnumConstantList](jls-8.html#jls-EnumConstantList "EnumConstantList")\] \[`,`\] \[[EnumBodyDeclarations](jls-8.html#jls-EnumBodyDeclarations "EnumBodyDeclarations")\] `}`

EnumConstantList:href="jls-8.html#jls-EnumConstant" title="EnumConstant">EnumConstant {`,` [EnumConstant](jls-8.html#jls-EnumConstant "EnumConstant")}

EnumConstant:

{[EnumConstantModifier](jls-8.html#jls-EnumConstantModifier "EnumConstantModifier")} [Identifier](jls-3.html#jls-Identifier "Identifier") \[`(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)`\] \[[ClassBody](jls-8.html#jls-ClassBody "ClassBody")\]

EnumConstantModifier:

[Annotation](jls-9.html#jls-Annotation "Annotation")

EnumBodyDeclarations:

`;` {[ClassBodyDeclaration](jls-8.html#jls-ClassBodyDeclaration "ClassBodyDeclaration")}

**Productions from [¬ß9 (_Interfaces_)](jls-9.html "Chapter 9. Interfaces")**

InterfaceDeclaration:

[NormalInterfaceDeclaration](jls-9.html#jls-NormalInterfaceDeclaration "NormalInterfaceDeclaration")  
[AnnotationTypeDeclaration](jls-9.html#jls-AnnotationTypeDeclaration "AnnotationTypeDeclaration")

NormalInterfaceDeclaration:

{[InterfaceModifier](jls-9.html#jls-InterfaceModifier "InterfaceModifier")} `interface` [Identifier](jls-3.html#jls-Identifier "Identifier") \[[TypeParameters](jls-8.html#jls-TypeParameters "TypeParameters")\] \[[ExtendsInterfaces](jls-9.html#jls-ExtendsInterfaces "ExtendsInterfaces")\] [InterfaceBody](jls-9.html#jls-InterfaceBody "InterfaceBody")

InterfaceModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `public` `protected` `private`  
`abstract` `static` `strictfp`

ExtendsInterfaces:

`extends` [InterfaceTypeList](jls-8.html#jls-InterfaceTypeList "InterfaceTypeList")

InterfaceBody:

`{` {[InterfaceMemberDeclaration](jls-9.html#jls-InterfaceMemberDeclaration "InterfaceMemberDeclaration")} `}`

InterfaceMemberDeclaration:

[ConstantDeclaration](jls-9.html#jls-ConstantDeclaration "ConstantDeclaration")  
[InterfaceMethodDeclaration](jls-9.html#jls-InterfaceMethodDeclaration "InterfaceMethodDeclaration")  
[ClassDeclaration](jls-8.html#jls-ClassDeclaration "ClassDeclaration")  
[InterfaceDeclaration](jls-9.html#jls-InterfaceDeclaration "InterfaceDeclaration")  
`;`

ConstantDeclaration:

{[ConstantModifier](jls-9.html#jls-ConstantModifier "ConstantModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [VariableDeclaratorList](jls-8.html#jls-VariableDeclaratorList "VariableDeclaratorList") `;`

ConstantModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `public`  
`static` `final`

InterfaceMethodDeclaration:

{[InterfaceMethodModifier](jls-9.html#jls-InterfaceMethodModifier "InterfaceMethodModifier")} [MethodHeader](jls-8.html#jls-MethodHeader "MethodHeader") [MethodBody](jls-8.html#jls-MethodBody "MethodBody")

InterfaceMethodModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `public`  
`abstract` `default` `static` `strictfp`

AnnotationTypeDeclaration:

{[InterfaceModifier](jls-9.html#jls-InterfaceModifier "InterfaceModifier")} `@` `interface` [Identifier](jls-3.html#jls-Identifier "Identifier") [AnnotationTypeBody](jls-9.html#jls-AnnotationTypeBody "AnnotationTypeBody")

AnnotationTypeBody:

`{` {[AnnotationTypeMemberDeclaration](jls-9.html#jls-AnnotationTypeMemberDeclaration "AnnotationTypeMemberDeclaration")} `}`

AnnotationTypeMemberDeclaration:

[AnnotationTypeElementDeclaration](jls-9.html#jls-AnnotationTypeElementDeclaration "AnnotationTypeElementDeclaration")  
[ConstantDeclaration](jls-9.html#jls-ConstantDeclaration "ConstantDeclaration")  
[ClassDeclaration](jls-8.html#jls-ClassDeclaration "ClassDeclaration")  
[InterfaceDeclaration](jls-9.html#jls-InterfaceDeclaration "InterfaceDeclaration")  
`;`

AnnotationTypeElementDeclaration:

{[AnnotationTypeElementModifier](jls-9.html#jls-AnnotationTypeElementModifier "AnnotationTypeElementModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [Identifier](jls-3.html#jls-Identifier "Identifier") `(` `)` \[[Dims](jls-4.html#jls-Dims "Dims")\] \[[DefaultValue](jls-9.html#jls-DefaultValue "DefaultValue")\] `;`

AnnotationTypeElementModifier:

(one of)  
[Annotation](jls-9.html#jls-Annotation "Annotation") `public`  
`abstract`

DefaultValue:

`default` [ElementValue](jls-9.html#jls-ElementValue "ElementValue")

Annotation:

[NormalAnnotation](jls-9.html#jls-NormalAnnotation "NormalAnnotation")  
[MarkerAnnotation](jls-9.html#jls-MarkerAnnotation "MarkerAnnotation")  
[SingleElementAnnotation](jls-9.html#jls-SingleElementAnnotation "SingleElementAnnotation")

NormalAnnotation:

`@` [TypeName](jls-6.html#jls-TypeName "TypeName") `(` \[[ElementValuePairList](jls-9.html#jls-ElementValuePairList "ElementValuePairList")\] `)`

ElementValuePairList:

[ElementValuePair](jls-9.html#jls-ElementValuePair "ElementValuePair") {`,` [ElementValuePair](jls-9.html#jls-ElementValuePair "ElementValuePair")}

ElementValuePair:

[Identifier](jls-3.html#jls-Identifier "Identifier") `=` [ElementValue](jls-9.html#jls-ElementValue "ElementValue")

ElementValue:

[ConditionalExpression](jls-15.html#jls-ConditionalExpression "ConditionalExpression")  
[ElementValueArrayInitializer](jls-9.html#jls-ElementValueArrayInitializer "ElementValueArrayInitializer")  
[Annotation](jls-9.html#jls-Annotation "Annotation")

ElementValueArrayInitializer:

`{` \[[ElementValueList](jls-9.html#jls-ElementValueList "ElementValueList")\] \[`,`\] `}`

ElementValueList:

[ElementValue](jls-9.html#jls-ElementValue "ElementValue") {`,` [ElementValue](jls-9.html#jls-ElementValue "ElementValue")}

MarkerAnnotation:

`@` [TypeName](jls-6.html#jls-TypeName "TypeName")

SingleElementAnnotation:

`@` [TypeName](jls-6.html#jls-TypeName "TypeName") `(` [ElementValue](jls-9.html#jls-ElementValue "ElementValue") `)`

**Productions from [¬ß10 (_Arrays_)](jls-10.html "Chapter 10. Arrays")**

ArrayInitializer:

`{` \[[VariableInitializerList](jls-10.html#jls-VariableInitializerList "VariableInitializerList")\] \[`,`\] `}`

VariableInitializerList:

[VariableInitializer](jls-8.html#jls-VariableInitializer "VariableInitializer") {`,` [VariableInitializer](jls-8.html#jls-VariableInitializer "VariableInitializer")}

**Productions from [¬ß14 (_Blocks and Statements_)](jls-14.html "Chapter 14. Blocks and Statements")**

Block:

`{` \[[BlockStatements](jls-14.html#jls-BlockStatements "BlockStatements")\] `}`

BlockStatements:

[BlockStatement](jls-14.html#jls-BlockStatement "BlockStatement") {[BlockStatement](jls-14.html#jls-BlockStatement "BlockStatement")}

BlockStatement:

[LocalVariableDeclarationStatement](jls-14.html#jls-LocalVariableDeclarationStatement "LocalVariableDeclarationStatement")  
[ClassDeclaration](jls-8.html#jls-ClassDeclaration "ClassDeclaration")  
[Statement](jls-14.html#jls-Statement "Statement")

LocalVariableDeclarationStatement:

[LocalVariableDeclaration](jls-14.html#jls-LocalVariableDeclaration "LocalVariableDeclaration") `;`

LocalVariableDeclaration:

{[VariableModifier](jls-8.html#jls-VariableModifier "VariableModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [VariableDeclaratorList](jls-8.html#jls-VariableDeclaratorList "VariableDeclaratorList")

Statement:

[StatementWithoutTrailingSubstatement](jls-14.html#jls-StatementWithoutTrailingSubstatement "StatementWithoutTrailingSubstatement")  
[LabeledStatement](jls-14.html#jls-LabeledStatement "LabeledStatement")  
[IfThenStatement](jls-14.html#jls-IfThenStatement "IfThenStatement")  
[IfThenElseStatement](jls-14.html#jls-IfThenElseStatement "IfThenElseStatement")  
[WhileStatement](jls-14.html#jls-WhileStatement "WhileStatement")  
[ForStatement](jls-14.html#jls-ForStatement "ForStatement")

StatementNoShortIf:

[StatementWithoutTrailingSubstatement](jls-14.html#jls-StatementWithoutTrailingSubstatement "StatementWithoutTrailingSubstatement")  
[LabeledStatementNoShortIf](jls-14.html#jls-LabeledStatementNoShortIf "LabeledStatementNoShortIf")  
[IfThenElseStatementNoShortIf](jls-14.html#jls-IfThenElseStatementNoShortIf "IfThenElseStatementNoShortIf")  
[WhileStatementNoShortIf](jls-14.html#jls-WhileStatementNoShortIf "WhileStatementNoShortIf")  
[ForStatementNoShortIf](jls-14.html#jls-ForStatementNoShortIf "ForStatementNoShortIf")

StatementWithoutTrailingSubstatement:

[Block](jls-14.html#jls-Block "Block")  
[EmptyStatement](jls-14.html#jls-EmptyStatement "EmptyStatement")  
[ExpressionStatement](jls-14.html#jls-ExpressionStatement "ExpressionStatement")  
[AssertStatement](jls-14.html#jls-AssertStatement "AssertStatement")  
[SwitchStatement](jls-14.html#jls-SwitchStatement "SwitchStatement")  
[DoStatement](jls-14.html#jls-DoStatement "DoStatement")  
[BreakStatement](jls-14.html#jls-BreakStatement "BreakStatement")  
[ContinueStatement](jls-14.html#jls-ContinueStatement "ContinueStatement")  
[ReturnStatement](jls-14.html#jls-ReturnStatement "ReturnStatement")  
[SynchronizedStatement](jls-14.html#jls-SynchronizedStatement "SynchronizedStatement")  
[ThrowStatement](jls-14.html#jls-ThrowStatement "ThrowStatement")  
[TryStatement](jls-14.html#jls-TryStatement "TryStatement")

EmptyStatement:

`;`

LabeledStatement:

[Identifier](jls-3.html#jls-Identifier "Identifier") `:` [Statement](jls-14.html#jls-Statement "Statement")

LabeledStatementNoShortIf:

[Identifier](jls-3.html#jls-Identifier "Identifier") `:` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf")

ExpressionStatement:

[StatementExpression](jls-14.html#jls-StatementExpression "StatementExpression") `;`

StatementExpression:

[Assignment](jls-15.html#jls-Assignment "Assignment")  
[PreIncrementExpression](jls-15.html#jls-PreIncrementExpression "PreIncrementExpression")  
[PreDecrementExpression](jls-15.html#jls-PreDecrementExpression "PreDecrementExpression")  
[PostIncrementExpression](jls-15.html#jls-PostIncrementExpression "PostIncrementExpression")  
[PostDecrementExpression](jls-15.html#jls-PostDecrementExpression "PostDecrementExpression")  
[MethodInvocation](jls-15.html#jls-MethodInvocation "MethodInvocation")  
[ClassInstanceCreationExpression](jls-15.html#jls-ClassInstanceCreationExpression "ClassInstanceCreationExpression")

IfThenStatement:

`if` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` [Statement](jls-14.html#jls-Statement "Statement")

IfThenElseStatement:

`if` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf") `else` [Statement](jls-14.html#jls-Statement "Statement")

IfThenElseStatementNoShortIf:

`if` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf") `else` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf")

AssertStatement:

`assert` [Expression](jls-15.html#jls-Expression "Expression") `;`  
`assert` [Expression](jls-15.html#jls-Expression "Expression") `:` [Expression](jls-15.html#jls-Expression "Expression") `;`

SwitchStatement:

`switch` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` [SwitchBlock](jls-14.html#jls-SwitchBlock "SwitchBlock")

SwitchBlock:

`{` {[SwitchBlockStatementGroup](jls-14.html#jls-SwitchBlockStatementGroup "SwitchBlockStatementGroup")} {[SwitchLabel](jls-14.html#jls-SwitchLabel "SwitchLabel")} `}`

SwitchBlockStatementGroup:

[SwitchLabels](jls-14.html#jls-SwitchLabels "SwitchLabels") [BlockStatements](jls-14.html#jls-BlockStatements "BlockStatements")

SwitchLabels:

[SwitchLabel](jls-14.html#jls-SwitchLabel "SwitchLabel") {[SwitchLabel](jls-14.html#jls-SwitchLabel "SwitchLabel")}

SwitchLabel:

`case` [ConstantExpression](jls-15.html#jls-ConstantExpression "ConstantExpression") `:`  
`case` [EnumConstantName](jls-14.html#jls-EnumConstantName "EnumConstantName") `:`  
`default` `:`

EnumConstantName:

[Identifier](jls-3.html#jls-Identifier "Identifier")

WhileStatement:

`while` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` [Statement](jls-14.html#jls-Statement "Statement")

WhileStatementNoShortIf:

`while` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf")

DoStatement:

`do` [Statement](jls-14.html#jls-Statement "Statement") `while` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` `;`

ForStatement:

[BasicForStatement](jls-14.html#jls-BasicForStatement "BasicForStatement")  
[EnhancedForStatement](jls-14.html#jls-EnhancedForStatement "EnhancedForStatement")

ForStatementNoShortIf:

[BasicForStatementNoShortIf](jls-14.html#jls-BasicForStatementNoShortIf "BasicForStatementNoShortIf")  
[EnhancedForStatementNoShortIf](jls-14.html#jls-EnhancedForStatementNoShortIf "EnhancedForStatementNoShortIf")

BasicForStatement:

`for` `(` \[[ForInit](jls-14.html#jls-ForInit "ForInit")\] `;` \[[Expression](jls-15.html#jls-Expression "Expression")\] `;` \[[ForUpdate](jls-14.html#jls-ForUpdate "ForUpdate")\] `)` [Statement](jls-14.html#jls-Statement "Statement")

BasicForStatementNoShortIf:

`for` `(` \[[ForInit](jls-14.html#jls-ForInit "ForInit")\] `;` \[[Expression](jls-15.html#jls-Expression "Expression")\] `;` \[[ForUpdate](jls-14.html#jls-ForUpdate "ForUpdate")\] `)` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf")

ForInit:

[StatementExpressionList](jls-14.html#jls-StatementExpressionList "StatementExpressionList")  
[LocalVariableDeclaration](jls-14.html#jls-LocalVariableDeclaration "LocalVariableDeclaration")

ForUpdate:

[StatementExpressionList](jls-14.html#jls-StatementExpressionList "StatementExpressionList")

StatementExpressionList:

[StatementExpression](jls-14.html#jls-StatementExpression "StatementExpression") {`,` [StatementExpression](jls-14.html#jls-StatementExpression "StatementExpression")}

EnhancedForStatement:

`for` `(` {[VariableModifier](jls-8.html#jls-VariableModifier "VariableModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId") `:` [Expression](jls-15.html#jls-Expression "Expression") `)` [Statement](jls-14.html#jls-Statement "Statement")

EnhancedForStatementNoShortIf:

`for` `(` {[VariableModifier](jls-8.html#jls-VariableModifier "VariableModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId") `:` [Expression](jls-15.html#jls-Expression "Expression") `)` [StatementNoShortIf](jls-14.html#jls-StatementNoShortIf "StatementNoShortIf")

BreakStatement:

`break` \[[Identifier](jls-3.html#jls-Identifier "Identifier")\] `;`

ContinueStatement:

`continue` \[[Identifier](jls-3.html#jls-Identifier "Identifier")\] `;`

ReturnStatement:

`return` \[[Expression](jls-15.html#jls-Expression "Expression")\] `;`

ThrowStatement:

`throw` [Expression](jls-15.html#jls-Expression "Expression") `;`

SynchronizedStatement:

`synchronized` `(` [Expression](jls-15.html#jls-Expression "Expression") `)` [Block](jls-14.html#jls-Block "Block")

TryStatement:

`try` [Block](jls-14.html#jls-Block "Block") [Catches](jls-14.html#jls-Catches "Catches")  
`try` [Block](jls-14.html#jls-Block "Block") \[[Catches](jls-14.html#jls-Catches "Catches")\] [Finally](jls-14.html#jls-Finally "Finally")  
[TryWithResourcesStatement](jls-14.html#jls-TryWithResourcesStatement "TryWithResourcesStatement")

Catches:

[CatchClause](jls-14.html#jls-CatchClause "CatchClause") {[CatchClause](jls-14.html#jls-CatchClause "CatchClause")}

CatchClause:

`catch` `(` [CatchFormalParameter](jls-14.html#jls-CatchFormalParameter "CatchFormalParameter") `)` [Block](jls-14.html#jls-Block "Block")

CatchFormalParameter:

{[VariableModifier](jls-8.html#jls-VariableModifier "VariableModifier")} [CatchType](jls-14.html#jls-CatchType "CatchType") [VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId")

CatchType:

[UnannClassType](jls-8.html#jls-UnannClassType "UnannClassType") {`|` [ClassType](jls-4.html#jls-ClassType "ClassType")}

Finally:

`finally` [Block](jls-14.html#jls-Block "Block")

TryWithResourcesStatement:

`try` [ResourceSpecification](jls-14.html#jls-ResourceSpecification "ResourceSpecification") [Block](jls-14.html#jls-Block "Block") \[[Catches](jls-14.html#jls-Catches "Catches")\] \[[Finally](jls-14.html#jls-Finally "Finally")\]

ResourceSpecification:

`(` [ResourceList](jls-14.html#jls-ResourceList "ResourceList") \[`;`\] `)`

ResourceList:

[Resource](jls-14.html#jls-Resource "Resource") {`;` [Resource](jls-14.html#jls-Resource "Resource")}

Resource:

{[VariableModifier](jls-8.html#jls-VariableModifier "VariableModifier")} [UnannType](jls-8.html#jls-UnannType "UnannType") [VariableDeclaratorId](jls-8.html#jls-VariableDeclaratorId "VariableDeclaratorId") `=` [Expression](jls-15.html#jls-Expression "Expression")

**Productions from [¬ß15 (_Expressions_)](jls-15.html "Chapter 15. Expressions")**

Primary:

[PrimaryNoNewArray](jls-15.html#jls-PrimaryNoNewArray "PrimaryNoNewArray")  
[ArrayCreationExpression](jls-15.html#jls-ArrayCreationExpression "ArrayCreationExpression")

PrimaryNoNewArray:

[Literal](jls-3.html#jls-Literal "Literal")  
[ClassLiteral](jls-15.html#jls-ClassLiteral "ClassLiteral")  
`this`  
[TypeName](jls-6.html#jls-TypeName "TypeName") `.` `this`  
`(` [Expression](jls-15.html#jls-Expression "Expression") `)`  
[ClassInstanceCreationExpression](jls-15.html#jls-ClassInstanceCreationExpression "ClassInstanceCreationExpression")  
[FieldAccess](jls-15.html#jls-FieldAccess "FieldAccess")  
[ArrayAccess](jls-15.html#jls-ArrayAccess "ArrayAccess")  
[MethodInvocation](jls-15.html#jls-MethodInvocation "MethodInvocation")  
[MethodReference](jls-15.html#jls-MethodReference "MethodReference")

ClassLiteral:

[TypeName](jls-6.html#jls-TypeName "TypeName") {`[` `]`} `.` `class`  
[NumericType](jls-4.html#jls-NumericType "NumericType") {`[` `]`} `.` `class`  
`boolean` {`[` `]`} `.` `class`  
`void` `.` `class`

ClassInstanceCreationExpression:

[UnqualifiedClassInstanceCreationExpression](jls-15.html#jls-UnqualifiedClassInstanceCreationExpression "UnqualifiedClassInstanceCreationExpression")  
[ExpressionName](jls-6.html#jls-ExpressionName "ExpressionName") `.` [UnqualifiedClassInstanceCreationExpression](jls-15.html#jls-UnqualifiedClassInstanceCreationExpression "UnqualifiedClassInstanceCreationExpression")  
[Primary](jls-15.html#jls-Primary "Primary") `.` [UnqualifiedClassInstanceCreationExpression](jls-15.html#jls-UnqualifiedClassInstanceCreationExpression "UnqualifiedClassInstanceCreationExpression")

UnqualifiedClassInstanceCreationExpression:

`new` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [ClassOrInterfaceTypeToInstantiate](jls-15.html#jls-ClassOrInterfaceTypeToInstantiate "ClassOrInterfaceTypeToInstantiate") `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)` \[[ClassBody](jls-8.html#jls-ClassBody "ClassBody")\]

ClassOrInterfaceTypeToInstantiate:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} [Identifier](jls-3.html#jls-Identifier "Identifier") {`.` {[Annotation](jls-9.html#jls-Annotation "Annotation")} [Identifier](jls-3.html#jls-Identifier "Identifier")} \[[TypeArgumentsOrDiamond](jls-15.html#jls-TypeArgumentsOrDiamond "TypeArgumentsOrDiamond")\]

TypeArgumentsOrDiamond:

[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")  
`<>`

FieldAccess:

[Primary](jls-15.html#jls-Primary "Primary") `.` [Identifier](jls-3.html#jls-Identifier "Identifier")  
`super` `.` [Identifier](jls-3.html#jls-Identifier "Identifier")  
[TypeName](jls-6.html#jls-TypeName "TypeName") `.` `super` `.` [Identifier](jls-3.html#jls-Identifier "Identifier")ArrayAccess:

[ExpressionName](jls-6.html#jls-ExpressionName "ExpressionName") `[` [Expression](jls-15.html#jls-Expression "Expression") `]`  
[PrimaryNoNewArray](jls-15.html#jls-PrimaryNoNewArray "PrimaryNoNewArray") `[` [Expression](jls-15.html#jls-Expression "Expression") `]`

MethodInvocation:

[MethodName](jls-6.html#jls-MethodName "MethodName") `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)`  
[TypeName](jls-6.html#jls-TypeName "TypeName") `.` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier") `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)`  
[ExpressionName](jls-6.html#jls-ExpressionName "ExpressionName") `.` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier") `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)`  
[Primary](jls-15.html#jls-Primary "Primary") `.` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier") `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)`  
`super` `.` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier") `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)`  
[TypeName](jls-6.html#jls-TypeName "TypeName") `.` `super` `.` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier") `(` \[[ArgumentList](jls-15.html#jls-ArgumentList "ArgumentList")\] `)`

ArgumentList:

[Expression](jls-15.html#jls-Expression "Expression") {`,` [Expression](jls-15.html#jls-Expression "Expression")}

MethodReference:

[ExpressionName](jls-6.html#jls-ExpressionName "ExpressionName") `::` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier")  
[ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType") `::` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier")  
[Primary](jls-15.html#jls-Primary "Primary") `::` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier")  
`super` `::` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier")  
[TypeName](jls-6.html#jls-TypeName "TypeName") `.` `super` `::` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] [Identifier](jls-3.html#jls-Identifier "Identifier")  
[ClassType](jls-4.html#jls-ClassType "ClassType") `::` \[[TypeArguments](jls-4.html#jls-TypeArguments "TypeArguments")\] `new`  
[ArrayType](jls-4.html#jls-ArrayType "ArrayType") `::` `new`

ArrayCreationExpression:

`new` [PrimitiveType](jls-4.html#jls-PrimitiveType "PrimitiveType") [DimExprs](jls-15.html#jls-DimExprs "DimExprs") \[[Dims](jls-4.html#jls-Dims "Dims")\]  
`new` [ClassOrInterfaceType](jls-4.html#jls-ClassOrInterfaceType "ClassOrInterfaceType") [DimExprs](jls-15.html#jls-DimExprs "DimExprs") \[[Dims](jls-4.html#jls-Dims "Dims")\]  
`new` [PrimitiveType](jls-4.html#jls-PrimitiveType "PrimitiveType") [Dims](jls-4.html#jls-Dims "Dims") [ArrayInitializer](jls-10.html#jls-ArrayInitializer "ArrayInitializer")  
`new` [ClassOrInterfaceType](jls-4.html#jls-ClassOrInterfaceType "ClassOrInterfaceType") [Dims](jls-4.html#jls-Dims "Dims") [ArrayInitializer](jls-10.html#jls-ArrayInitializer "ArrayInitializer")

DimExprs:

[DimExpr](jls-15.html#jls-DimExpr "DimExpr") {[DimExpr](jls-15.html#jls-DimExpr "DimExpr")}

DimExpr:

{[Annotation](jls-9.html#jls-Annotation "Annotation")} `[` [Expression](jls-15.html#jls-Expression "Expression") `]`

Expression:

[LambdaExpression](jls-15.html#jls-LambdaExpression "LambdaExpression")  
[AssignmentExpression](jls-15.html#jls-AssignmentExpression "AssignmentExpression")

LambdaExpression:

[LambdaParameters](jls-15.html#jls-LambdaParameters "LambdaParameters") `->` [LambdaBody](jls-15.html#jls-LambdaBody "LambdaBody")

LambdaParameters:

[Identifier](jls-3.html#jls-Identifier "Identifier")  
`(` \[[FormalParameterList](jls-8.html#jls-FormalParameterList "FormalParameterList")\] `)`  
`(` [InferredFormalParameterList](jls-15.html#jls-InferredFormalParameterList "InferredFormalParameterList") `)`

InferredFormalParameterList:

[Identifier](jls-3.html#jls-Identifier "Identifier") {`,` [Identifier](jls-3.html#jls-Identifier "Identifier")}

LambdaBody:

[Expression](jls-15.html#jls-Expression "Expression")  
[Block](jls-14.html#jls-Block "Block")

AssignmentExpression:

[ConditionalExpression](jls-15.html#jls-ConditionalExpression "ConditionalExpression")  
[Assignment](jls-15.html#jls-Assignment "Assignment")

Assignment:

[LeftHandSide](jls-15.html#jls-LeftHandSide "LeftHandSide") [AssignmentOperator](jls-15.html#jls-AssignmentOperator "AssignmentOperator") [Expression](jls-15.html#jls-Expression "Expression")

LeftHandSide:

[ExpressionName](jls-6.html#jls-ExpressionName "ExpressionName")  
[FieldAccess](jls-15.html#jls-FieldAccess "FieldAccess")  
[ArrayAccess](jls-15.html#jls-ArrayAccess "ArrayAccess")

AssignmentOperator:

(one of)  

    =

ConditionalExpression:

[ConditionalOrExpression](jls-15.html#jls-ConditionalOrExpression "ConditionalOrExpression")  
[ConditionalOrExpression](jls-15.html#jls-ConditionalOrExpression "ConditionalOrExpression") `?` [Expression](jls-15.html#jls-Expression "Expression") `:` [ConditionalExpression](jls-15.html#jls-ConditionalExpression "ConditionalExpression")  
[ConditionalOrExpression](jls-15.html#jls-ConditionalOrExpression "ConditionalOrExpression") `?` [Expression](jls-15.html#jls-Expression "Expression") `:` [LambdaExpression](jls-15.html#jls-LambdaExpression "LambdaExpression")  

ConditionalOrExpression:

[ConditionalAndExpression](jls-15.html#jls-ConditionalAndExpression "ConditionalAndExpression")  
[ConditionalOrExpression](jls-15.html#jls-ConditionalOrExpression "ConditionalOrExpression") `||` ConditionalAndExpression

ConditionalAndExpression:

[InclusiveOrExpression](jls-15.html#jls-InclusiveOrExpression "InclusiveOrExpression")  
[ConditionalAndExpression](jls-15.html#jls-ConditionalAndExpression "ConditionalAndExpression") `&&` [InclusiveOrExpression](jls-15.html#jls-InclusiveOrExpression "InclusiveOrExpression")

InclusiveOrExpression:

[ExclusiveOrExpression](jls-15.html#jls-ExclusiveOrExpression "ExclusiveOrExpression")  
[InclusiveOrExpression](jls-15.html#jls-InclusiveOrExpression "InclusiveOrExpression") `|` [ExclusiveOrExpression](jls-15.html#jls-ExclusiveOrExpression "ExclusiveOrExpression")

ExclusiveOrExpression:

[AndExpression](jls-15.html#jls-AndExpression "AndExpression")  
[ExclusiveOrExpression](jls-15.html#jls-ExclusiveOrExpression "ExclusiveOrExpression") `^` [AndExpression](jls-15.html#jls-AndExpression "AndExpression")

AndExpression:

[EqualityExpression](jls-15.html#jls-EqualityExpression "EqualityExpression")  
[AndExpression](jls-15.html#jls-AndExpression "AndExpression") `&` [EqualityExpression](jls-15.html#jls-EqualityExpression "EqualityExpression")

EqualityExpression:

[RelationalExpression](jls-15.html#jls-RelationalExpression "RelationalExpression")  
[EqualityExpression](jls-15.html#jls-EqualityExpression "EqualityExpression") `==` [RelationalExpression](jls-15.html#jls-RelationalExpression "RelationalExpression")  
[EqualityExpression](jls-15.html#jls-EqualityExpression "EqualityExpression") `!=` [RelationalExpression](jls-15.html#jls-RelationalExpression "RelationalExpression")

RelationalExpression:

[ShiftExpression](jls-15.html#jls-ShiftExpression "ShiftExpression")  
[RelationalExpression](jls-15.html#jls-RelationalExpression "RelationalExpression") `<` [ShiftExpression](jls-15.html#jls-ShiftExpression "ShiftExpression")  
[RelationalExpression](jls-15.html#jls-RelationalExpression "RelationalExpression") `>` [ShiftExpression](jls-15.html#jls-ShiftExpression "ShiftExpression")  
[RelationalExpression](jls-15.html#jls-RelationalExpression "RelationalExpression") `<=` [ShiftExpression](jls-15.html#jls-ShiftExpression "ShiftExpression")  
[RelationalExpression](jls-15.html#jls-RelationalExpression "RelationalExpression") `>=` [ShiftExpression](jls-15.html#jls-ShiftExpression "ShiftExpression")  
[RelationalExpression](jls-15.html#jls-RelationalExpression "RelationalExpression") `instanceof` [ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType")

ShiftExpression:

[AdditiveExpression](jls-15.html#jls-AdditiveExpression "AdditiveExpression")  
[ShiftExpression](jls-15.html#jls-ShiftExpression "ShiftExpression") `<<` [AdditiveExpression](jls-15.html#jls-AdditiveExpression "AdditiveExpression")  
[ShiftExpression](jls-15.html#jls-ShiftExpression "ShiftExpression") `>>` [AdditiveExpression](jls-15.html#jls-AdditiveExpression "AdditiveExpression")  
[ShiftExpression](jls-15.html#jls-ShiftExpression "ShiftExpression") `>>>` [AdditiveExpression](jls-15.html#jls-AdditiveExpression "AdditiveExpression")

AdditiveExpression:

[MultiplicativeExpression](jls-15.html#jls-MultiplicativeExpression "MultiplicativeExpression")  
[AdditiveExpression](jls-15.html#jls-AdditiveExpression "AdditiveExpression") `+` [MultiplicativeExpression](jls-15.html#jls-MultiplicativeExpression "MultiplicativeExpression")  
[AdditiveExpression](jls-15.html#jls-AdditiveExpression "AdditiveExpression") `-` [MultiplicativeExpression](jls-15.html#jls-MultiplicativeExpression "MultiplicativeExpression")

MultiplicativeExpression:

[UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
[MultiplicativeExpression](jls-15.html#jls-MultiplicativeExpression "MultiplicativeExpression") `*` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
[MultiplicativeExpression](jls-15.html#jls-MultiplicativeExpression "MultiplicativeExpression") `/` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
[MultiplicativeExpression](jls-15.html#jls-MultiplicativeExpression "MultiplicativeExpression") `%` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")

UnaryExpression:

[PreIncrementExpression](jls-15.html#jls-PreIncrementExpression "PreIncrementExpression")  
[PreDecrementExpression](jls-15.html#jls-PreDecrementExpression "PreDecrementExpression")  
`+` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
`-` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
[UnaryExpressionNotPlusMinus](jls-15.html#jls-UnaryExpressionNotPlusMinus "UnaryExpressionNotPlusMinus")

PreIncrementExpression:

`++` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")

PreDecrementExpression:

`--` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")

UnaryExpressionNotPlusMinus:

[PostfixExpression](jls-15.html#jls-PostfixExpression "PostfixExpression")  
`~` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
`!` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
[CastExpression](jls-15.html#jls-CastExpression "CastExpression")

PostfixExpression:

[Primary](jls-15.html#jls-Primary "Primary")  
[ExpressionName](jls-6.html#jls-ExpressionName "ExpressionName")  
[PostIncrementExpression](jls-15.html#jls-PostIncrementExpression "PostIncrementExpression")  
[PostDecrementExpression](jls-15.html#jls-PostDecrementExpression "PostDecrementExpression")

PostIncrementExpression:

[PostfixExpression](jls-15.html#jls-PostfixExpression "PostfixExpression") `++`

PostDecrementExpression:

[PostfixExpression](jls-15.html#jls-PostfixExpression "PostfixExpression") `--`

CastExpression:

`(` [PrimitiveType](jls-4.html#jls-PrimitiveType "PrimitiveType") `)` [UnaryExpression](jls-15.html#jls-UnaryExpression "UnaryExpression")  
`(` [ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType") {[AdditionalBound](jls-4.html#jls-AdditionalBound "AdditionalBound")} `)` [UnaryExpressionNotPlusMinus](jls-15.html#jls-UnaryExpressionNotPlusMinus "UnaryExpressionNotPlusMinus")  
`(` [ReferenceType](jls-4.html#jls-ReferenceType "ReferenceType") {[AdditionalBound](jls-4.html#jls-AdditionalBound "AdditionalBound")} `)` [LambdaExpression](jls-15.html#jls-LambdaExpression "LambdaExpression")  

ConstantExpression:

[Expression](jls-15.html#jls-Expression "Expression")


üçÄ Index

### Index Symbols

\= operator, [15.26.1](jls-15.html#jls-15.26.1)
    assignment contexts, [5.2](jls-5.html#jls-5.2-500-D)
    expressions and run-time checks, [15.5](jls-15.html#jls-15.5-110-D), [15.5](jls-15.html#jls-15.5-210-C)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-I), [15.6](jls-15.html#jls-15.6-200-J)
@Deprecated, [9.6.4.6](jls-9.html#jls-9.6.4.6)
@FunctionalInterface, [9.6.4.9](jls-9.html#jls-9.6.4.9)
@Inherited, [9.6.4.3](jls-9.html#jls-9.6.4.3)
@Override, [9.6.4.4](jls-9.html#jls-9.6.4.4)
@Repeatable, [9.6.4.8](jls-9.html#jls-9.6.4.8)
    repeatable annotation types, [9.6.3](jls-9.html#jls-9.6.3-100)
@Retention, [9.6.4.2](jls-9.html#jls-9.6.4.2)
    repeatable annotation types, [9.6.3](jls-9.html#jls-9.6.3-110-C)
@SafeVarargs, [9.6.4.7](jls-9.html#jls-9.6.4.7)
    formal parameters, [8.4.1](jls-8.html#jls-8.4.1-510)
@SuppressWarnings, [9.6.4.5](jls-9.html#jls-9.6.4.5)
    checked casts and unchecked casts, [5.5.2](jls-5.html#jls-5.5.2-500)
    formal parameters, [8.4.1](jls-8.html#jls-8.4.1-510)
    requirements in overriding and hiding, [8.4.8.3](jls-8.html#jls-8.4.8.3-110)
    unchecked conversion, [5.1.9](jls-5.html#jls-5.1.9-200)
@Target, [9.6.4.1](jls-9.html#jls-9.6.4.1)
    multiple annotations of the same type, [9.7.5](jls-9.html#jls-9.7.5-100)
    repeatable annotation types, [9.6.3](jls-9.html#jls-9.6.3-110-D)
    where annotations may appear, [9.7.4](jls-9.html#jls-9.7.4-100)

### Index A

abrupt completion of do statement, [14.13.1](jls-14.html#jls-14.13.1)
    do statement, [14.13](jls-14.html#jls-14.13-300-B)
abrupt completion of for statement, [14.14.1.3](jls-14.html#jls-14.14.1.3)
    iteration of for statement, [14.14.1.2](jls-14.html#jls-14.14.1.2-100-B-B)
abrupt completion of while statement, [14.12.1](jls-14.html#jls-14.12.1)
    while statement, [14.12](jls-14.html#jls-14.12-320-A-B)
abstract classes, [8.1.1.1](jls-8.html#jls-8.1.1.1), [13.4.1](jls-13.html#jls-13.4.1)
    abstract methods, [8.4.3.1](jls-8.html#jls-8.4.3.1-120)
    anonymous class declarations, [15.9.5](jls-15.html#jls-15.9.5-110)
    array creation expressions, [15.10.1](jls-15.html#jls-15.10.1-200)
    final classes, [8.1.1.2](jls-8.html#jls-8.1.1.2-210)
    superinterfaces, [8.1.5](jls-8.html#jls-8.1.5-500)
abstract interfaces, [9.1.1.1](jls-9.html#jls-9.1.1.1)
abstract methods, [8.4.3.1](jls-8.html#jls-8.4.3.1), [13.4.16](jls-13.html#jls-13.4.16)
    abstract classes, [8.1.1.1](jls-8.html#jls-8.1.1.1-200)
    method body, [8.4.7](jls-8.html#jls-8.4.7-200)
    method declarations, [9.4](jls-9.html#jls-9.4-200)
access control, [6.6](jls-6.html#jls-6.6)
    accessing superclass members using super, [15.11.2](jls-15.html#jls-15.11.2-300)
    class literals, [15.8.2](jls-15.html#jls-15.8.2-310)
    class modifiers, [8.1.1](jls-8.html#jls-8.1.1-200)
    constructor declarations, [8.8](jls-8.html#jls-8.8-400)
    default constructor, [8.8.9](jls-8.html#jls-8.8.9-100-A)
    enum body declarations, [8.9.2](jls-8.html#jls-8.9.2-200)
    explicit constructor invocations, [8.8.7.1](jls-8.html#jls-8.8.7.1-320-B)
    field access using a primary, [15.11.1](jls-15.html#jls-15.11.1-110-A)
    identify potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1-200-B)
    import declarations, [7.5](jls-7.html#jls-7.5-120-B)
    interface modifiers, [9.1.1](jls-9.html#jls-9.1.1-300)
    local class declarations, [14.3](jls-14.html#jls-14.3-200)
    member type declarations, [8.5](jls-8.html#jls-8.5-200)
    method declarations, [9.4](jls-9.html#jls-9.4-120)
    normal annotations, [9.7.1](jls-9.html#jls-9.7.1-130)
    objects, [4.3.1](jls-4.html#jls-4.3.1-200-A)
    qualified expression names, [6.5.6.2](jls-6.html#jls-6.5.6.2-210-A), [6.5.6.2](jls-6.html#jls-6.5.6.2-220-A), [6.5.6.2](jls-6.html#jls-6.5.6.2-230-B)
    qualified type names, [6.5.5.2](jls-6.html#jls-6.5.5.2-110), [6.5.5.2](jls-6.html#jls-6.5.5.2-120)
    reference types and values, [4.3](jls-4.html#jls-4.3-210)
    requirements in overriding and hiding, [8.4.8.3](jls-8.html#jls-8.4.8.3-400)
    single-static-import declarations, [7.5.3](jls-7.html#jls-7.5.3-220)
    single-type-import declarations, [7.5.1](jls-7.html#jls-7.5.1-220)
    static-import-on-demand declarations, [7.5.4](jls-7.html#jls-7.5.4-220)
    superclasses and subclasses, [8.1.4](jls-8.html#jls-8.1.4-210)
    superinterfaces, [8.1.5](jls-8.html#jls-8.1.5-200)
    superinterfaces and subinterfaces, [9.1.3](jls-9.html#jls-9.1.3-140)
    type-import-on-demand declarations, [7.5.2](jls-7.html#jls-7.5.2-220)
access to a protected member, [6.6.2.1](jls-6.html#jls-6.6.2.1)
access to members and constructors, [13.4.7](jls-13.html#jls-13.4.7)
accessing superclass members using super, [15.11.2](jls-15.html#jls-15.11.2)
    declarations, [6.1](jls-6.html#jls-6.1-210-H)
    field declarations, [8.3](jls-8.html#jls-8.3-330)
    field initialization, [8.3.2](jls-8.html#jls-8.3.2-200-B), [8.3.2](jls-8.html#jls-8.3.2-300-B)
    initialization of fields in interfaces, [9.3.1](jls-9.html#jls-9.3.1-210)
    instance initializers, [8.6](jls-8.html#jls-8.6-220)
    static methods, [8.4.3.2](jls-8.html#jls-8.4.3.2-120)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-A-H)
actions, [17.4.2](jls-17.html#jls-17.4.2)
    synchronization order, [17.4.4](jls-17.html#jls-17.4.4-100)
additive operators, [15.18](jls-15.html#jls-15.18)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-E)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-100-B-C)
additive operators (+ and -) for numeric types, [15.18.2](jls-15.html#jls-15.18.2)
    binary numeric promotion, [5.6.2](jls-5.html#jls-5.6.2-300-B)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-100-B-C)
an array of characters is not a String, [10.9](jls-10.html#jls-10.9)
annotation type elements, [9.6.1](jls-9.html#jls-9.6.1)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-C)
    annotation types, [9.6](jls-9.html#jls-9.6-310)
    declarations, [6.1](jls-6.html#jls-6.1-110-G-D-B), [6.1](jls-6.html#jls-6.1-110-G-E-B), [6.1](jls-6.html#jls-6.1-110-H-B)
    marker annotations, [9.7.2](jls-9.html#jls-9.7.2-100)
    normal annotations, [9.7.1](jls-9.html#jls-9.7.1-100)
    single-element annotations, [9.7.3](jls-9.html#jls-9.7.3-100)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-C)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-C)
annotation types, [9.6](jls-9.html#jls-9.6)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-B)
    annotations, [9.7](jls-9.html#jls-9.7-100)
    declarations, [6.1](jls-6.html#jls-6.1-110-G)
    interface declarations, [9.1](jls-9.html#jls-9.1-100)
annotations, [9.7](jls-9.html#jls-9.7)
    declarations, [6.1](jls-6.html#jls-6.1-210-E)
    defaults for annotation type elements, [9.6.2](jls-9.html#jls-9.6.2-120)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-A-E)
anonymous class declarations, [15.9.5](jls-15.html#jls-15.9.5)
    class instance creation expressions, [15.9](jls-15.html#jls-15.9-400-A.1), [15.9](jls-15.html#jls-15.9-410)
    class modifiers, [8.1.1](jls-8.html#jls-8.1.1-200)
    definite assignment and anonymous classes, [16.6](jls-16.html#jls-16.6-100-A)
    enum constants, [8.9.1](jls-8.html#jls-8.9.1-300)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-A-D)
    initialization of fields in interfaces, [9.3.1](jls-9.html#jls-9.3.1-210)
    inner classes and enclosing instances, [8.1.3](jls-8.html#jls-8.1.3-110)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-L)
    where types are used, [4.11](jls-4.html#jls-4.11-100-B-B), [4.11](jls-4.html#jls-4.11-300-A-C)
anonymous constructors, [15.9.5.1](jls-15.html#jls-15.9.5.1)
    choosing the constructor and its arguments, [15.9.3](jls-15.html#jls-15.9.3-310)
    default constructor, [8.8.9](jls-8.html#jls-8.8.9-110)
    form of a binary, [13.1](jls-13.html#jls-13.1-120-L)
argument lists are evaluated left-to-right, [15.7.4](jls-15.html#jls-15.7.4)
array access, [10.4](jls-10.html#jls-10.4)
array access expressions, [15.10.3](jls-15.html#jls-15.10.3)
    array access, [10.4](jls-10.html#jls-10.4-100)
    assignment operators, [15.26](jls-15.html#jls-15.26-210)
    compound assignment operators, [15.26.2](jls-15.html#jls-15.26.2-400)
    simple assignment operator =, [15.26.1](jls-15.html#jls-15.26.1-400)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-120-C)
    unary numeric promotion, [5.6.1](jls-5.html#jls-5.6.1-300-B)
array creation, [10.3](jls-10.html#jls-10.3)
array creation and access expressions, [15.10](jls-15.html#jls-15.10)
    method reference expressions, [15.13](jls-15.html#jls-15.13-100)
array creation expressions, [15.10.1](jls-15.html#jls-15.10.1)
    array creation, [10.3](jls-10.html#jls-10.3-100)
    array initializers, [10.6](jls-10.html#jls-10.6-100)
    objects, [4.3.1](jls-4.html#jls-4.3.1-130)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-M)
    unary numeric promotion, [5.6.1](jls-5.html#jls-5.6.1-300-A)
    where types are used, [4.11](jls-4.html#jls-4.11-100-B-C), [4.11](jls-4.html#jls-4.11-300-B-A)
array initializers, [10.6](jls-10.html#jls-10.6)
    array creation, [10.3](jls-10.html#jls-10.3-100)
    definite assignment and array initializers, [16.4](jls-16.html#jls-16.4-100-A)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-A)
    objects, [4.3.1](jls-4.html#jls-4.3.1-150)
    run-time evaluation of array creation expressions, [15.10.2](jls-15.html#jls-15.10.2-100-A)
array members, [10.7](jls-10.html#jls-10.7)
    declarations, [6.1](jls-6.html#jls-6.1-110-G), [6.1](jls-6.html#jls-6.1-110-G-D-C)
    happens-before order, [17.4.5](jls-17.html#jls-17.4.5-340)
    qualified expression names, [6.5.6.2](jls-6.html#jls-6.5.6.2-230-C-C)
array store exception, [10.5](jls-10.html#jls-10.5)
    array variables, [10.2](jls-10.html#jls-10.2-320)
    assignment contexts, [5.2](jls-5.html#jls-5.2-500-D)
    expressions and run-time checks, [15.5](jls-15.html#jls-15.5-110-D), [15.5](jls-15.html#jls-15.5-210-C)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-J)
    variables, [4.12](jls-4.html#jls-4.12-120)
array types, [10.1](jls-10.html#jls-10.1)
    annotation type elements, [9.6.1](jls-9.html#jls-9.6.1-200-F)
    enhanced for statement, [14.14.2](jls-14.html#jls-14.14.2-200)
    raw types, [4.8](jls-4.html#jls-4.8-100)
    reference types and values, [4.3](jls-4.html#jls-4.3-100)
    reifiable types, [4.7](jls-4.html#jls-4.7-110-E)
    where types are used, [4.11](jls-4.html#jls-4.11-200-G)
array variables, [10.2](jls-10.html#jls-10.2)
    enhanced for statement, [14.14.2](jls-14.html#jls-14.14.2-210)
    field (constant) declarations, [9.3](jls-9.html#jls-9.3-200)
    field declarations, [8.3](jls-8.html#jls-8.3-230)
    formal parameters, [8.4.1](jls-8.html#jls-8.4.1-320), [8.4.1](jls-8.html#jls-8.4.1-500-A), [8.4.1](jls-8.html#jls-8.4.1-500-B)
    lambda parameters, [15.27.1](jls-15.html#jls-15.27.1-210-A), [15.27.1](jls-15.html#jls-15.27.1-210-B), [15.27.1](jls-15.html#jls-15.27.1-320)
    local variable declarators and types, [14.4.1](jls-14.html#jls-14.4.1-200)
    method result, [8.4.5](jls-8.html#jls-8.4.5-120)
arrays, [10](jls-10.html)
    array creation expressions, [15.10.1](jls-15.html#jls-15.10.1-100)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-C)
    when reference types are the same, [4.3.4](jls-4.html#jls-4.3.4-320)
    assert statement, [14.10](jls-14.html#jls-14.10)
    assert statements, [16.2.8](jls-16.html#jls-16.2.8-100)
    detailed initialization procedure, [12.4.2](jls-12.html#jls-12.4.2-300-H)
    when initialization occurs, [12.4.1](jls-12.html#jls-12.4.1-100-E)
assert statements, [16.2.8](jls-16.html#jls-16.2.8)
assignment contexts, [5.2](jls-5.html#jls-5.2)
    array initializers, [10.6](jls-10.html#jls-10.6-200)
    array store exception, [10.5](jls-10.html#jls-10.5-110)
    array variables, [10.2](jls-10.html#jls-10.2-320)
    class instance creation expressions, [15.9](jls-15.html#jls-15.9-500)
    execution of try-catch, [14.20.1](jls-14.html#jls-14.20.1-100-B-A)
    expressions and run-time checks, [15.5](jls-15.html#jls-15.5-110-B), [15.5](jls-15.html#jls-15.5-110-C)
    kinds of types and values, [4.1](jls-4.html#jls-4.1-230)
    lambda expressions, [15.27](jls-15.html#jls-15.27-210)
    method invocation expressions, [15.12](jls-15.html#jls-15.12-300-A)
    method reference expressions, [15.13](jls-15.html#jls-15.13-410)
    normal annotations, [9.7.1](jls-9.html#jls-9.7.1-300-B)
    reference conditional expressions, [15.25.3](jls-15.html#jls-15.25.3-100)
    return statement, [14.17](jls-14.html#jls-14.17-420)
    run-time evaluation of method references, [15.13.3](jls-15.html#jls-15.13.3-300-B.1)
    simple assignment operator =, [15.26.1](jls-15.html#jls-15.26.1-100), [15.26.1](jls-15.html#jls-15.26.1-400-F.1-B.2)
    switch statement, [14.11](jls-14.html#jls-14.11-310-A)
    throw statement, [14.18](jls-14.html#jls-14.18-200), [14.18](jls-14.html#jls-14.18-210-C)
    type of an expression, [15.3](jls-15.html#jls-15.3-110)
    variables, [4.12](jls-4.html#jls-4.12-120)
assignment expressions, [16.1.8](jls-16.html#jls-16.1.8)
assignment operators, [15.26](jls-15.html#jls-15.26)
    assignment contexts, [5.2](jls-5.html#jls-5.2-100)
    assignment expressions, [16.1.8](jls-16.html#jls-16.1.8-100)
    evaluation order for other expressions, [15.7.5](jls-15.html#jls-15.7.5-100-E)
    field initialization, [8.3.2](jls-8.html#jls-8.3.2-100)
    final variables, [4.12.4](jls-4.html#jls-4.12.4-500-A-B)
    forms of expressions, [15.2](jls-15.html#jls-15.2-100-D)
    initial values of variables, [4.12.5](jls-4.html#jls-4.12.5-100-E)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-120-E)
    variables, [4.12](jls-4.html#jls-4.12-110)
asynchronous Exceptions, [11.1.3](jls-11.html#jls-11.1.3)
    causes of Exceptions, [11.1.2](jls-11.html#jls-11.1.2-100-C)

### Index B

basic for statement, [14.14.1](jls-14.html#jls-14.14.1)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-H)
    for statements, [16.2.12](jls-16.html#jls-16.2.12-100)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-530)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-I)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-I)
basic try-with-resources, [14.20.3.1](jls-14.html#jls-14.20.3.1)
binary compatibility, [13](jls-13.html)
binary numeric promotion, [5.6.2](jls-5.html#jls-5.6.2)
    additive operators (+ and -) for numeric types, [15.18.2](jls-15.html#jls-15.18.2-200)
    division operator /, [15.17.2](jls-15.html#jls-15.17.2-200)
    integer bitwise operators &, ^, and |, [15.22.1](jls-15.html#jls-15.22.1-100)
    multiplicative operators, [15.17](jls-15.html#jls-15.17-300)
    numeric conditional expressions, [15.25.2](jls-15.html#jls-15.25.2-200-F)
    numeric contexts, [5.6](jls-5.html#jls-5.6-300)
    numerical comparison operators <, <=, >, and >=, [15.20.1](jls-15.html#jls-15.20.1-110)
    numerical equality operators == and !=, [15.21.1](jls-15.html#jls-15.21.1-100)
    postfix decrement operator --, [15.14.3](jls-15.html#jls-15.14.3-200)
    postfix increment operator ++, [15.14.2](jls-15.html#jls-15.14.2-200)
    prefix decrement operator --, [15.15.2](jls-15.html#jls-15.15.2-200)
    prefix increment operator ++, [15.15.1](jls-15.html#jls-15.15.1-200)
    remainder operator %, [15.17.3](jls-15.html#jls-15.17.3-200)
    shift operators, [15.19](jls-15.html#jls-15.19-200)
bitwise and logical operators, [15.22](jls-15.html#jls-15.22)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-I)
bitwise complement operator ~, [15.15.5](jls-15.html#jls-15.15.5)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-C)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-100-B-G)
    unary numeric promotion, [5.6.1](jls-5.html#jls-5.6.1-300-E)
blocks, [14.2](jls-14.html#jls-14.2), [16.2.2](jls-16.html#jls-16.2.2)
    blocks, [16.2.2](jls-16.html#jls-16.2.2-100-A)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-H.1)
    lambda body, [15.27.2](jls-15.html#jls-15.27.2-100)
    local class declarations, [14.3](jls-14.html#jls-14.3-120)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-500)
blocks and statements, [14](jls-14.html)
boolean conditional expressions, [15.25.1](jls-15.html#jls-15.25.1)
boolean constant expressions, [16.1.1](jls-16.html#jls-16.1.1)
boolean equality operators == and !=, [15.21.2](jls-15.html#jls-15.21.2)
    boolean type and boolean values, [4.2.5](jls-4.html#jls-4.2.5-110-A)
boolean literals, [3.10.3](jls-3.html#jls-3.10.3)
    boolean type and boolean values, [4.2.5](jls-4.html#jls-4.2.5-100)
    boxing conversion, [5.1.7](jls-5.html#jls-5.1.7-300)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-A)
    identifiers, [3.8](jls-3.html#jls-3.8-200)
    lexical literals, [15.8.1](jls-15.html#jls-15.8.1-200-C)
boolean logical operators &, ^, and |, [15.22.2](jls-15.html#jls-15.22.2)
    boolean type and boolean values, [4.2.5](jls-4.html#jls-4.2.5-110-C)
    conditional-and operator &&, [15.23](jls-15.html#jls-15.23-100)
    conditional-or operator ||, [15.24](jls-15.html#jls-15.24-100)
boolean type and boolean values, [4.2.5](jls-4.html#jls-4.2.5)
    boolean literals, [3.10.3](jls-3.html#jls-3.10.3-120)
    lexical literals, [15.8.1](jls-15.html#jls-15.8.1-200-C)
bounds, [18.1.3](jls-18.html#jls-18.1.3)
    bounds involving capture conversion, [18.3.2](jls-18.html#jls-18.3.2-210)
    functional interface parameterization inference, [18.5.3](jls-18.html#jls-18.5.3-220-A)
    invocation applicability inference, [18.5.1](jls-18.html#jls-18.5.1-100-B)
    more specific method inference, [18.5.4](jls-18.html#jls-18.5.4-300-A)
    reduction, [18.2](jls-18.html#jls-18.2-100)
bounds involving capture conversion, [18.3.2](jls-18.html#jls-18.3.2)
    incorporation, [18.3](jls-18.html#jls-18.3-110)
boxing conversion, [5.1.7](jls-5.html#jls-5.1.7)
    assignment contexts, [5.2](jls-5.html#jls-5.2-110-D)
    casting contexts, [5.5](jls-5.html#jls-5.5-110-G)
    class literals, [15.8.2](jls-15.html#jls-15.8.2-210)
    conditional operator ? :, [15.25](jls-15.html#jls-15.25-530)
    creation of new class instances, [12.5](jls-12.html#jls-12.5-110-B)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-370-B)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-310-C)
    invocation contexts, [5.3](jls-5.html#jls-5.3-210-D)
    invocation type inference, [18.5.2](jls-18.html#jls-18.5.2-100-C.1-C-C)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-I)
    numeric conditional expressions, [15.25.2](jls-15.html#jls-15.25.2-200-B)
    objects, [4.3.1](jls-4.html#jls-4.3.1-160)
    postfix decrement operator --, [15.14.3](jls-15.html#jls-15.14.3-200)
    postfix increment operator ++, [15.14.2](jls-15.html#jls-15.14.2-200)
    prefix decrement operator --, [15.15.2](jls-15.html#jls-15.15.2-200)
    prefix increment operator ++, [15.15.1](jls-15.html#jls-15.15.1-200)
    type compatibility constraints, [18.2.2](jls-18.html#jls-18.2.2-100-B), [18.2.2](jls-18.html#jls-18.2.2-100-C)
break statement, [14.15](jls-14.html#jls-14.15)
    break, continue, return, and throw statements, [16.2.13](jls-16.html#jls-16.2.13-100-A)
    labeled statements, [14.7](jls-14.html#jls-14.7-130)
    names and identifiers, [6.2](jls-6.html#jls-6.2-300-B)
    normal and abrupt completion of statements, [14.1](jls-14.html#jls-14.1-110-A)
break, continue, return, and throw statements, [16.2.13](jls-16.html#jls-16.2.13)

### Index C

capture conversion, [5.1.10](jls-5.html#jls-5.1.10)
    array access expressions, [15.10.3](jls-15.html#jls-15.10.3-220)
    assignment operators, [15.26](jls-15.html#jls-15.26-300)
    bounds, [18.1.3](jls-18.html#jls-18.1.3-100-D)
    cast expressions, [15.16](jls-15.html#jls-15.16-220)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-200-A-B), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A.2)
    compile-time step 3: is the chosen method appropriate?, [15.12.3](jls-15.html#jls-15.12.3-600)
    enhanced for statement, [14.14.2](jls-14.html#jls-14.14.2-300-A.4)
    expression compatibility constraints, [18.2.1](jls-18.html#jls-18.2.1-300-C-B), [18.2.1](jls-18.html#jls-18.2.1-300-D-B-C)
    field access using a primary, [15.11.1](jls-15.html#jls-15.11.1-110-C)
    function types, [9.9](jls-9.html#jls-9.9-200-C.1-C-B)
    intersection types, [4.9](jls-4.html#jls-4.9-110)
    least upper bound, [4.10.4](jls-4.html#jls-4.10.4-210-D.7)
    members and constructors of parameterized types, [4.5.2](jls-4.html#jls-4.5.2-200-A)
    parameterized types, [4.5](jls-4.html#jls-4.5-200-C)
    qualified expression names, [6.5.6.2](jls-6.html#jls-6.5.6.2-210-C.1), [6.5.6.2](jls-6.html#jls-6.5.6.2-210-D.1), [6.5.6.2](jls-6.html#jls-6.5.6.2-220-B.1), [6.5.6.2](jls-6.html#jls-6.5.6.2-230-C.2), [6.5.6.2](jls-6.html#jls-6.5.6.2-230-D.1)
    reference conditional expressions, [15.25.3](jls-15.html#jls-15.25.3-210-C)
    resolution, [18.4](jls-18.html#jls-18.4-320-A-C)
    simple expression names, [6.5.6.1](jls-6.html#jls-6.5.6.1-210)
    subtyping among class and interface types, [4.10.2](jls-4.html#jls-4.10.2-300)
    type arguments of parameterized types, [4.5.1](jls-4.html#jls-4.5.1-300-B)
    type of a method reference, [15.13.2](jls-15.html#jls-15.13.2-300-B-B)
cast expressions, [15.16](jls-15.html#jls-15.16)
    array types, [10.1](jls-10.html#jls-10.1-100)
    casting contexts, [5.5](jls-5.html#jls-5.5-100)
    compile-time step 3: is the chosen method appropriate?, [15.12.3](jls-15.html#jls-15.12.3-400-B-B-B)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-B)
    expressions and run-time checks, [15.5](jls-15.html#jls-15.5-110-C), [15.5](jls-15.html#jls-15.5-210-A)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-100-D)
    forms of expressions, [15.2](jls-15.html#jls-15.2-100-C)
    happens-before order, [17.4.5](jls-17.html#jls-17.4.5-340)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-100-D)
    intersection types, [4.9](jls-4.html#jls-4.9-110)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-G)
    objects, [4.3.1](jls-4.html#jls-4.3.1-200-C)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-N)
    type comparison operator instanceof, [15.20.2](jls-15.html#jls-15.20.2-120)
    unary operators, [15.15](jls-15.html#jls-15.15-100)
    where types are used, [4.11](jls-4.html#jls-4.11-100-B-D)
casting contexts, [5.5](jls-5.html#jls-5.5)
    boolean type and boolean values, [4.2.5](jls-4.html#jls-4.2.5-230)
    cast expressions, [15.16](jls-15.html#jls-15.16-210), [15.16](jls-15.html#jls-15.16-320)
    expressions and run-time checks, [15.5](jls-15.html#jls-15.5-110-C), [15.5](jls-15.html#jls-15.5-210-A)
    happens-before order, [17.4.5](jls-17.html#jls-17.4.5-340)
    kinds of types and values, [4.1](jls-4.html#jls-4.1-230)
    lambda expressions, [15.27](jls-15.html#jls-15.27-210)
    method reference expressions, [15.13](jls-15.html#jls-15.13-410)
    objects, [4.3.1](jls-4.html#jls-4.3.1-200-C)
    reference equality operators == and !=, [15.21.3](jls-15.html#jls-15.21.3-110)
casting conversions to primitive types, [5.5](jls-5.html#jls-5.5-320)
casting conversions to reference types, [5.5](jls-5.html#jls-5.5-330)
causes of Exceptions, [11.1.2](jls-11.html#jls-11.1.2)
character literals, [3.10.4](jls-3.html#jls-3.10.4)
    boxing conversion, [5.1.7](jls-5.html#jls-5.1.7-300)
    comments, [3.7](jls-3.html#jls-3.7-130)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-A)
    escape sequences for character and String literals, [3.10.6](jls-3.html#jls-3.10.6-100)
    lexical literals, [15.8.1](jls-15.html#jls-15.8.1-200-D)
    unicode, [3.1](jls-3.html#jls-3.1-300)
check accessibility of type and method, [15.12.4.3](jls-15.html#jls-15.12.4.3)
    run-time evaluation of method references, [15.13.3](jls-15.html#jls-15.13.3-400-A), [15.13.3](jls-15.html#jls-15.13.3-400-B), [15.13.3](jls-15.html#jls-15.13.3-400-C)
checked casts and unchecked casts, [5.5.2](jls-5.html#jls-5.5.2)
    variables of reference type, [4.12.2](jls-4.html#jls-4.12.2-310)
checked casts at run time, [5.5.3](jls-5.html#jls-5.5.3)
    checked casts and unchecked casts, [5.5.2](jls-5.html#jls-5.5.2-700-E.1)
checked exception constraints, [18.2.5](jls-18.html#jls-18.2.5)
choosing the constructor and its arguments, [15.9.3](jls-15.html#jls-15.9.3)
    anonymous constructors, [15.9.5.1](jls-15.html#jls-15.9.5.1-100-B)
    class instance creation expressions, [15.9](jls-15.html#jls-15.9-600)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-200-B-B.1)
    default constructor, [8.8.9](jls-8.html#jls-8.8.9-100-B)
    expression compatibility constraints, [18.2.1](jls-18.html#jls-18.2.1-100-C-B)
    formal parameters, [8.8.1](jls-8.html#jls-8.8.1-200)
choosing the most specific method, [15.12.2.5](jls-15.html#jls-15.12.2.5)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-B), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-B.2)
    compile-time step 2: determine method Signature, [15.12.2](jls-15.html#jls-15.12.2-230)
    conditional operator ? :, [15.25](jls-15.html#jls-15.25-300-A.1-D), [15.25](jls-15.html#jls-15.25-300-B.1-D)
    method and constructor overloading, [13.4.23](jls-13.html#jls-13.4.23-110)
    more specific method inference, [18.5.4](jls-18.html#jls-18.5.4-100), [18.5.4](jls-18.html#jls-18.5.4-300-B.1)
    phase 1: identify matching arity methods applicable by strict invocation, [15.12.2.2](jls-15.html#jls-15.12.2.2-220)
    phase 2: identify matching arity methods applicable by loose invocation, [15.12.2.3](jls-15.html#jls-15.12.2.3-120)
    phase 3: identify methods applicable by variable arity invocation, [15.12.2.4](jls-15.html#jls-15.12.2.4-220)
class body and member declarations, [8.1.6](jls-8.html#jls-8.1.6), [13.4.6](jls-13.html#jls-13.4.6)
    class members, [8.2](jls-8.html#jls-8.2-100-C)
    member type declarations, [8.5](jls-8.html#jls-8.5-100), [8.5](jls-8.html#jls-8.5-110)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-310)
    what binary compatibility is and is not, [13.2](jls-13.html#jls-13.2-200)
class declarations, [8.1](jls-8.html#jls-8.1)
    declarations, [6.1](jls-6.html#jls-6.1-110-D)
    reference types and values, [4.3](jls-4.html#jls-4.3-100)
    types, classes, and interfaces, [4.12.6](jls-4.html#jls-4.12.6-100)
class instance creation expressions, [15.9](jls-15.html#jls-15.9)
    conditional operator ? :, [15.25](jls-15.html#jls-15.25-300-A.1-C), [15.25](jls-15.html#jls-15.25-300-B.1-C)
    constructor declarations, [8.8](jls-8.html#jls-8.8-100), [8.8](jls-8.html#jls-8.8-400)
    constructor overloading, [8.8.8](jls-8.html#jls-8.8.8-100)
    creation of new class instances, [12.5](jls-12.html#jls-12.5-100)
    exception analysis of expressions, [11.2.1](jls-11.html#jls-11.2.1-100)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-F)
    forms of expressions, [15.2](jls-15.html#jls-15.2-300-B)
    functional interfaces, [9.8](jls-9.html#jls-9.8-120)
    initial values of variables, [4.12.5](jls-4.html#jls-4.12.5-100-A), [4.12.5](jls-4.html#jls-4.12.5-100-C)
    instance initializers, [8.6](jls-8.html#jls-8.6-100)
    invocation contexts, [5.3](jls-5.html#jls-5.3-100)
    invocation type inference, [18.5.2](jls-18.html#jls-18.5.2-100-D.1-B-A.1-B), [18.5.2](jls-18.html#jls-18.5.2-100-D.1-B-C)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-E.1)
    method reference expressions, [15.13](jls-15.html#jls-15.13-100)
    names and identifiers, [6.2](jls-6.html#jls-6.2-300-F)
    objects,html#jls-4.3.1-120">4.3.1, [4.3.1](jls-4.html#jls-4.3.1-150)
    return statement, [14.17](jls-14.html#jls-14.17-100)
    run-time handling of an exception, [11.3](jls-11.html#jls-11.3-120-B)
    String conversion, [5.1.11](jls-5.html#jls-5.1.11-110)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-K), [6.5.1](jls-6.html#jls-6.5.1-110-B-L), [6.5.1](jls-6.html#jls-6.5.1-120-B)
    types, classes, and interfaces, [4.12.6](jls-4.html#jls-4.12.6-110)
    where types are used, [4.11](jls-4.html#jls-4.11-100-B-A), [4.11](jls-4.html#jls-4.11-100-B-B), [4.11](jls-4.html#jls-4.11-300-A-C), [4.11](jls-4.html#jls-4.11-300-A.1)
class literals, [15.8.2](jls-15.html#jls-15.8.2)
    declarations, [6.1](jls-6.html#jls-6.1-210-F)
    normal annotations, [9.7.1](jls-9.html#jls-9.7.1-300-B-B)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-A-F)
class loading, [12.2](jls-12.html#jls-12.2)
    causes of Exceptions, [11.1.2](jls-11.html#jls-11.1.2-100-B-B)
    class literals, [15.8.2](jls-15.html#jls-15.8.2-400)
    load the class test, [12.1.1](jls-12.html#jls-12.1.1-100)
class members, [8.2](jls-8.html#jls-8.2)
    abstract classes, [8.1.1.1](jls-8.html#jls-8.1.1.1-210-A)
    declarations, [6.1](jls-6.html#jls-6.1-110-G)
    function types, [9.9](jls-9.html#jls-9.9-100)
    members and constructors of parameterized types, [4.5.2](jls-4.html#jls-4.5.2-100-A)
    method invocation type, [15.12.2.6](jls-15.html#jls-15.12.2.6-100)
class modifiers, [8.1.1](jls-8.html#jls-8.1.1)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-B)
    anonymous class declarations, [15.9.5](jls-15.html#jls-15.9.5-130)
    local class declarations, [14.3](jls-14.html#jls-14.3-200)
    reference type casting, [5.5.1](jls-5.html#jls-5.5.1-200-B-A), [5.5.1](jls-5.html#jls-5.5.1-200-B-B), [5.5.1](jls-5.html#jls-5.5.1-300-B)
class Object, [4.3.2](jls-4.html#jls-4.3.2)
    checked casts at run time, [5.5.3](jls-5.html#jls-5.5.3-300-A), [5.5.3](jls-5.html#jls-5.5.3-400-A)
    method invocation type, [15.12.2.6](jls-15.html#jls-15.12.2.6-100-C-B)
class objects for arrays, [10.8](jls-10.html#jls-10.8)
    types, classes, and interfaces, [4.12.6](jls-4.html#jls-4.12.6-120)
class String, [4.3.3](jls-4.html#jls-4.3.3)
    lexical literals, [15.8.1](jls-15.html#jls-15.8.1-200-E)
    literals, [3.10](jls-3.html#jls-3.10-100)
    objects, [4.3.1](jls-4.html#jls-4.3.1-140)
    String literals, [3.10.5](jls-3.html#jls-3.10.5-200), [3.10.5](jls-3.html#jls-3.10.5-400)
class type parameters, [13.4.5](jls-13.html#jls-13.4.5)
classes, [8](jls-8.html)
    local class declarations, [14.3](jls-14.html#jls-14.3-100)
    package members, [7.1](jls-7.html#jls-7.1-100)
    qualified expression names, [6.5.6.2](jls-6.html#jls-6.5.6.2-210)
    reclassification of contextually ambiguous names, [6.5.2](jls-6.html#jls-6.5.2-110-C)
    top level type declarations, [7.6](jls-7.html#jls-7.6-100)
comments, [3.7](jls-3.html#jls-3.7)
    input elements and tokens, [3.5](jls-3.html#jls-3.5-130)
    lexical grammar, [2.2](jls-2.html#jls-2.2-110)
    lexical translations, [3.2](jls-3.html#jls-3.2-100-C)
    line terminators, [3.4](jls-3.html#jls-3.4-130)
    unicode, [3.1](jls-3.html#jls-3.1-300)
compilation units, [7.3](jls-7.html#jls-7.3)
    determining accessibility, [6.6.1](jls-6.html#jls-6.6.1-100-B)
    host support for packages, [7.2](jls-7.html#jls-7.2-110)
    observability of a package, [7.4.3](jls-7.html#jls-7.4.3-100-A)
    package members, [7.1](jls-7.html#jls-7.1-100)
    reclassification of contextually ambiguous names, [6.5.2](jls-6.html#jls-6.5.2-110-B), [6.5.2](jls-6.html#jls-6.5.2-110-D)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-200)
    shadowing, [6.4.1](jls-6.html#jls-6.4.1-450-B)
    syntactic grammar, [2.3](jls-2.html#jls-2.3-100)
compile-time checking of Exceptions, [11.2](jls-11.html#jls-11.2)
    checked exception constraints, [18.2.5](jls-18.html#jls-18.2.5-100-F)
compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1)
    checked exception constraints, [18.2.5](jls-18.html#jls-18.2.5-200-B)
    choosing the most specific method, [15.12.2.5](jls-15.html#jls-15.12.2.5-310-B)
    compile-time step 2: determine method Signature, [15.12.2](jls-15.html#jls-15.12.2-130)
    expression compatibility constraints, [18.2.1](jls-18.html#jls-18.2.1-300-C), [18.2.1](jls-18.html#jls-18.2.1-300-D-B)
    identify potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1-310-B)
    invocation type inference, [18.5.2](jls-18.html#jls-18.5.2-200-C-B), [18.5.2](jls-18.html#jls-18.5.2-200-D-B)
    method reference expressions, [15.13](jls-15.html#jls-15.13-310)
    phase 1: identify matching arity methods applicable by strict invocation, [15.12.2.2](jls-15.html#jls-15.12.2.2-100-B)
    run-time evaluation of method references, [15.13.3](jls-15.html#jls-15.13.3-400-D-B)
compile-time step 1: determine class or interface to search, [15.12.1](jls-15.html#jls-15.12.1)
    class Object, [4.3.2](jls-4.html#jls-4.3.2-200-D.2)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-200)
    identify potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1-100)
    method invocation type, [15.12.2.6](jls-15.html#jls-15.12.2.6-100-C-B)
    raw types, [4.8](jls-4.html#jls-4.8-510-B)
compile-time step 2: determine method Signature, [15.12.2](jls-15.html#jls-15.12.2)
    choosing the constructor and its arguments, [15.9.3](jls-15.html#jls-15.9.3-120-A.2), [15.9.3](jls-15.html#jls-15.9.3-120-B.1)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-200)
    enum constants, [8.9.1](jls-8.html#jls-8.9.1-200)
    overloading, [8.4.9](jls-8.html#jls-8.4.9-200)
    what binary compatibility is and is not, [13.2](jls-13.html#jls-13.2-120)
compile-time step 3: is the chosen method appropriate?, [15.12.3](jls-15.html#jls-15.12.3)
    check accessibility of type and method, [15.12.4.3](jls-15.html#jls-15.12.4.3-100)
    choosing the most specific method, [15.12.2.5](jls-15.html#jls-15.12.2.5-520)
    create frame, synchronize, transfer control, [15.12.4.5](jls-15.html#jls-15.12.4.5-130)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-E.1)
    locate method to invoke, [15.12.4.4](jls-15.html#jls-15.12.4.4-210), [15.12.4.4](jls-15.html#jls-15.12.4.4-240-A)
    method invocation expressions, [15.12](jls-15.html#jls-15.12-130)
    run-time evaluation of method references, [15.13.3](jls-15.html#jls-15.13.3-400-A-A), [15.13.3](jls-15.html#jls-15.13.3-400-B-A), [15.13.3](jls-15.html#jls-15.13.3-410)
complementary pairs of bounds, [18.3.1](jls-18.html#jls-18.3.1)
    incorporation, [18.3](jls-18.html#jls-18.3-110)
compound assignment operators, [15.26.2](jls-15.html#jls-15.26.2)
    evaluate left-hand operand first, [15.7.1](jls-15.html#jls-15.7.1-110)
compute target reference (if necessary), [15.12.4.1](jls-15.html#jls-15.12.4.1)
    method reference expressions, [15.13](jls-15.html#jls-15.13-300)
    concepts and notation, [18.1](jls-18.html#jls-18.1)
conditional expression type (primitive 3rd operand, part i), [15.25](jls-15.html#jls-15.25-400-A)
conditional expression type (primitive 3rd operand, part ii), [15.25](jls-15.html#jls-15.25-400-B)
conditional expression type (reference 3rd operand, part i), [15.25](jls-15.html#jls-15.25-400-C)
conditional expression type (reference 3rd operand, part ii), [15.25](jls-15.html#jls-15.25-400-D)
conditional expression type (reference 3rd operand, part iii), [15.25](jls-15.html#jls-15.25-400-E)
conditional operator ? :, [15.25](jls-15.html#jls-15.25), [16.1.5](jls-16.html#jls-16.1.5), [16.1.6](jls-16.html#jls-16.1.6)
    binary numeric promotion, [5.6.2](jls-5.html#jls-5.6.2-300-F)
    boolean type and boolean values, [4.2.5](jls-4.html#jls-4.2.5-110-E), [4.2.5](jls-4.html#jls-4.2.5-130)
    conditional operator ? :, [16.1.5](jls-16.html#jls-16.1.5-100-A), [16.1.6](jls-16.html#jls-16.1.6-100-A)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-K)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-100-C)
    forms of expressions, [15.2](jls-15.html#jls-15.2-100-E), [15.2](jls-15.html#jls-15.2-300-E)
    identify potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1-310-E)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-100-C)
    objects, [4.3.1](jls-4.html#jls-4.3.1-200-G)
    phase 1: identify matching arity methods applicable by strict invocation, [15.12.2.2](jls-15.html#jls-15.12.2.2-100-G)
conditional-and operator &&, [15.23](jls-15.html#jls-15.23), [16.1.2](jls-16.html#jls-16.1.2)
    boolean type and boolean values, [4.2.5](jls-4.html#jls-4.2.5-110-D)
    conditional-and operator &&, [16.1.2](jls-16.html#jls-16.1.2-100-A)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-J)
conditional-or operator ||, [15.24](jls-15.html#jls-15.24), [16.1.3](jls-16.html#jls-16.1.3)
    boolean type and boolean values, [4.2.5](jls-4.html#jls-4.2.5-110-D)
    conditional-or operator ||, [16.1.3](jls-16.html#jls-16.1.3-100-A)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-J)
    forms of expressions, [15.2](jls-15.html#jls-15.2-100-D)
constant expressions, [15.28](jls-15.html#jls-15.28)
    assignment contexts, [5.2](jls-5.html#jls-5.2-200)
    boolean constant expressions, [16.1.1](jls-16.html#jls-16.1.1-100-A)
    class String, [4.3.3](jls-4.html#jls-4.3.3-130)
    creation of new class instances, [12.5](jls-12.html#jls-12.5-110-C)
    final fields and static constant variables, [13.4.9](jls-13.html#jls-13.4.9-300)
    final variables, [4.12.4](jls-4.html#jls-4.12.4-300)
    forms of expressions, [15.2](jls-15.html#jls-15.2-400)
    fp-strict expressions, [15.4](jls-15.html#jls-15.4-110)
    initialization of fields in interfaces, [9.3.1](jls-9.html#jls-9.3.1-110)
    normal annotations, [9.7.1](jls-9.html#jls-9.7.1-300-B-A)
    numeric conditional expressions, [15.25.2](jls-15.html#jls-15.25.2-200-D)
    objects, [4.3.1](jls-4.html#jls-4.3.1-140)
    String concatenation operator +, [15.18.1](jls-15.html#jls-15.18.1-120)
    String literals, [3.10.5](jls-3.html#jls-3.10.5-410)
    subsequent modification of final fields, [17.5.3](jls-17.html#jls-17.5.3-110)
    unreachable statements, [14.21](jls-14.html#jls-14.21-300-M-1), [14.21](jls-14.html#jls-14.21-300-N-1), [14.21](jls-14.html#jls-14.21-300-O-1)
constraint formulas, [18.1.2](jls-18.html#jls-18.1.2)
    reduction, [18.2](jls-18.html#jls-18.2-100)
constructor body, [8.8.7](jls-8.html#jls-8.8.7)
    constructor declarations, [8.8](jls-8.html#jls-8.8-400)
    definite assignment, constructors, and instance initializers, [16.9](jls-16.html#jls-16.9-120)
    initial values of variables, [4.12.5](jls-4.html#jls-4.12.5-100-C)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-E.1)
    return statement, [14.17](jls-14.html#jls-14.17-300-B)
    this, [15.8.3](jls-15.html#jls-15.8.3-100-B)
constructor declarations, [8.8](jls-8.html#jls-8.8)
    class body and member declarations, [8.1.6](jls-8.html#jls-8.1.6-110)
    creation of new class instances, [12.5](jls-12.html#jls-12.5-120)
    declarations, [6.1](jls-6.html#jls-6.1-120), [6.1](jls-6.html#jls-6.1-210-D)
    final fields, [8.3.1.2](jls-8.html#jls-8.3.1.2-120)
    raw types, [4.8](jls-4.html#jls-4.8-210)
    return statement, [14.17](jls-14.html#jls-14.17-100)
    run-time evaluation of class instance creation expressions, [15.9.4](jls-15.html#jls-15.9.4-150)
    simple expression names, [6.5.6.1](jls-6.html#jls-6.5.6.1-110)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-A-D)
    where types are used, [4.11](jls-4.html#jls-4.11-120-C)
constructor modifiers, [8.8.3](jls-8.html#jls-8.8.3)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-D)
constructor overloading, [8.8.8](jls-8.html#jls-8.8.8)
constructor Signature, [8.8.2](jls-8.html#jls-8.8.2)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-F.1)
constructor throws, [8.8.5](jls-8.html#jls-8.8.5)
    compile-time checking of Exceptions, [11.2](jls-11.html#jls-11.2-100)
    declarations, [6.1](jls-6.html#jls-6.1-210-L)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-D)
    throw statement, [14.18](jls-14.html#jls-14.18-210-C)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-D), [4.11](jls-4.html#jls-4.11-300-C-A)
context-free grammars, [2.1](jls-2.html#jls-2.1)
    compilation units, [7.3](jls-7.html#jls-7.3-100)
continue statement, [14.16](jls-14.html#jls-14.16)
    break, continue, return, and throw statements, [16.2.13](jls-16.html#jls-16.2.13-100-A)
    labeled statements, [14.7](jls-14.html#jls-14.7-130)
    names and identifiers, [6.2](jls-6.html#jls-6.2-300-B)
    normal and abrupt completion of statements, [14.1](jls-14.html#jls-14.1-110-A)
conversions and contexts, [5](jls-5.html)
    parenthesized expressions, [15.8.5](jls-15.html#jls-15.8.5-200)
    type of an expression, [15.3](jls-15.html#jls-15.3-100)
create frame, synchronize, transfer control, [15.12.4.5](jls-15.html#jls-15.12.4.5)
    run-time evaluation of method references, [15.13.3](jls-15.html#jls-15.13.3-400-A), [15.13.3](jls-15.html#jls-15.13.3-400-B), [15.13.3](jls-15.html#jls-15.13.3-400-C)
creation of new class instances, [12.5](jls-12.html#jls-12.5)
    constructor declarations, [8.8](jls-8.html#jls-8.8-100)
    field initialization, [8.3.2](jls-8.html#jls-8.3.2-300-C)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-C.2)
    instance initializers, [8.6](jls-8.html#jls-8.6-100)
    run-time evaluation of class instance creation expressions, [15.9.4](jls-15.html#jls-15.9.4-150)
    static fields, [8.3.1.1](jls-8.html#jls-8.3.1.1-110)
    String concatenation operator +, [15.18.1](jls-15.html#jls-15.18.1-120)
    when initialization occurs, [12.4.1](jls-12.html#jls-12.4.1-310)

### Index D

declarations, [6.1](jls-6.html#jls-6.1)
    functional interfaces, [9.8](jls-9.html#jls-9.8-200-A)
    members and constructors of parameterized types, [4.5.2](jls-4.html#jls-4.5.2-300)
    names and identifiers, [6.2](jls-6.html#jls-6.2-300-A)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-A)
    where types are used, [4.11](jls-4.html#jls-4.11-200-F), [4.11](jls-4.html#jls-4.11-300-C)
default constructor, [8.8.9](jls-8.html#jls-8.8.9)
    form of a binary, [13.1](jls-13.html#jls-13.1-120-L)
    method and constructor declarations, [13.4.12](jls-13.html#jls-13.4.12-300)
defaults for annotation type elements, [9.6.2](jls-9.html#jls-9.6.2)
    marker annotations, [9.7.2](jls-9.html#jls-9.7.2-200)
    single-element annotations, [9.7.3](jls-9.html#jls-9.7.3-200)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-150-D)
definite assignment, [16](jls-16.html)
    assignment operators, [15.26](jls-15.html#jls-15.26-410)
    final variables, [4.12.4](jls-4.html#jls-4.12.4-100), [4.12.4](jls-4.html#jls-4.12.4-300), [4.12.4](jls-4.html#jls-4.12.4-500-B-B)
    initial values of variables, [4.12.5](jls-4.html#jls-4.12.5-100-E)
    inner classes and enclosing instances, [8.1.3](jls-8.html#jls-8.1.3-520)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-H.2)
    lambda body, [15.27.2](jls-15.html#jls-15.27.2-310)
    parenthesized expressions, [15.8.5](jls-15.html#jls-15.8.5-120-B)
definite assignment and anonymous classes, [16.6](jls-16.html#jls-16.6)
definite assignment and array initializers, [16.4](jls-16.html#jls-16.4)
definite assignment and enum constants, [16.5](jls-16.html#jls-16.5)
definite assignment and expressions, [16.1](jls-16.html#jls-16.1)
definite assignment and member types, [16.7](jls-16.html#jls-16.7)
definite assignment and parameters, [16.3](jls-16.html#jls-16.3)
definite assignment and statements, [16.2](jls-16.html#jls-16.2)
definite assignment and static initializers, [16.8](jls-16.html#jls-16.8)
    definite assignment and enum constants, [16.5](jls-16.html#jls-16.5-100)
    final fields, [8.3.1.2](jls-8.html#jls-8.3.1.2-110)
definite assignment, constructors, and instance initializers, [16.9](jls-16.html#jls-16.9)
    final fields, [8.3.1.2](jls-8.html#jls-8.3.1.2-120)
detailed initialization procedure, [12.4.2](jls-12.html#jls-12.4.2)
    field initialization, [8.3.2](jls-8.html#jls-8.3.2-200-C), [8.3.2](jls-8.html#jls-8.3.2-200-C.1)
    final fields and static constant variables, [13.4.9](jls-13.html#jls-13.4.9-500)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-C.1)
    initialization of fields in interfaces, [9.3.1](jls-9.html#jls-9.3.1-300)
    simple expression names, [6.5.6.1](jls-6.html#jls-6.5.6.1-110)
    static initializers, [8.7](jls-8.html#jls-8.7-100)
    throw statement, [14.18](jls-14.html#jls-14.18-530)
    when initialization occurs, [12.4.1](jls-12.html#jls-12.4.1-310)
details on protected access, [6.6.2](jls-6.html#jls-6.6.2)
    determining accessibility, [6.6.1](jls-6.html#jls-6.6.1-100-D-B-B)
determining accessibility, [6.6.1](jls-6.html#jls-6.6.1)
    top level type declarations, [7.6](jls-7.html#jls-7.6-120)
determining enclosing instances, [15.9.2](jls-15.html#jls-15.9.2)
    anonymous constructors, [15.9.5.1](jls-15.html#jls-15.9.5.1-100-B)
    choosing the constructor and its arguments, [15.9.3](jls-15.html#jls-15.9.3-110-A-B), [15.9.3](jls-15.html#jls-15.9.3-110-C)
    class instance creation expressions, [15.9](jls-15.html#jls-15.9-600)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-330)
    default constructor, [8.8.9](jls-8.html#jls-8.8.9-100-B)
    formal parameters, [8.8.1](jls-8.html#jls-8.8.1-200)
    inner classes and enclosing instances, [8.1.3](jls-8.html#jls-8.1.3-400)
    method reference expressions, [15.13](jls-15.html#jls-15.13-300)
    run-time evaluation of method references, [15.13.3](jls-15.html#jls-15.13.3-400-D-A)
determining the class being instantiated, [15.9.1](jls-15.html#jls-15.9.1)
    abstract classes, [8.1.1.1](jls-8.html#jls-8.1.1.1-110)
    class instance creation expressions, [15.9](jls-15.html#jls-15.9-600)
    enum types, [8.9](jls-8.html#jls-8.9-400)
determining the meaning of a name, [6.5](jls-6.html#jls-6.5)
    class members, [8.2](jls-8.html#jls-8.2-210)
    declarations, [6.1](jls-6.html#jls-6.1-200-B)
    interface members, [9.2](jls-9.html#jls-9.2-120)
    names and identifiers, [6.2](jls-6.html#jls-6.2-200)
    obscuring, [6.4.2](jls-6.html#jls-6.4.2-100)
    where types are used, [4.11](jls-4.html#jls-4.11-200-F)
division operator /, [15.17.2](jls-15.html#jls-15.17.2)
    compound assignment operators, [15.26.2](jls-15.html#jls-15.26.2-400-F-A.2)
    evaluate operands before operation, [15.7.2](jls-15.html#jls-15.7.2-110)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-310-B)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-H)
do statement, [14.13](jls-14.html#jls-14.13)
    boolean type and boolean values, [4.2.5](jls-4.html#jls-4.2.5-120-C)
    do statements, [16.2.11](jls-16.html#jls-16.2.11-100-A)
do statements, [16.2.11](jls-16.html#jls-16.2.11)

### Index E

empty statement, [14.6](jls-14.html#jls-14.6)
    empty statements, [16.2.1](jls-16.html#jls-16.2.1-100-A)
empty statements, [16.2.1](jls-16.html#jls-16.2.1)
enhanced for statement, [14.14.2](jls-14.html#jls-14.14.2)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-H)
    array variables, [10.2](jls-10.html#jls-10.2-200)
    for statements, [16.2.12](jls-16.html#jls-16.2.12-100)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-540)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-I)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-I)
enum body declarations, [8.9.2](jls-8.html#jls-8.9.2)
    constructor declarations, [8.8](jls-8.html#jls-8.8-120)
    declarations, [6.1](jls-6.html#jls-6.1-110-G-D-A), [6.1](jls-6.html#jls-6.1-110-G-E-A), [6.1](jls-6.html#jls-6.1-110-H-A)
enum constants, [8.9.1](jls-8.html#jls-8.9.1)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-F)
    definite assignment and enum constants, [16.5](jls-16.html#jls-16.5-100)
    definite assignment and static initializers, [16.8](jls-16.html#jls-16.8-100-A)
    enum types, [8.9](jls-8.html#jls-8.9-210)
    normal annotations, [9.7.1](jls-9.html#jls-9.7.1-300-B-C)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-F)
enum members, [8.9.3](jls-8.html#jls-8.9.3)
    declarations, [6.1](jls-6.html#jls-6.1-110-G)
    form of a binary, [13.1](jls-13.html#jls-13.1-120-L)
enum types, [8.9](jls-8.html#jls-8.9)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-B)
    abstract methods, [8.4.3.1](jls-8.html#jls-8.4.3.1-110)
    class declarations, [8.1](jls-8.html#jls-8.1-130)
    declarations, [6.1](jls-6.html#jls-6.1-110-G-C)
    normal annotations, [9.7.1](jls-9.html#jls-9.7.1-300-B-C)
    superclasses and subclasses, [8.1.4](jls-8.html#jls-8.1.4-230)
    switch statement, [14.11](jls-14.html#jls-14.11-200)
equality operators, [15.21](jls-15.html#jls-15.21)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-H)
erasure, [4.6](jls-4.html#jls-4.6)
    assignment contexts, [5.2](jls-5.html#jls-5.2-500-A)
    cast expressions, [15.16](jls-15.html#jls-15.16-200-B)
    checked casts and unchecked casts, [5.5.2](jls-5.html#jls-5.5.2-700-E.1)
    checked casts at run time, [5.5.3](jls-5.html#jls-5.5.3-100)
    choosing the most specific method, [15.12.2.5](jls-15.html#jls-15.12.2.5-530-A-B)
    class Object, [4.3.2](jls-4.html#jls-4.3.2-200-D.2)
    class type parameters, [13.4.5](jls-13.html#jls-13.4.5-130)
    compile-time step 3: is the chosen method appropriate?, [15.12.3](jls-15.html#jls-15.12.3-400-B-B-B)
    constructor Signature, [8.8.2](jls-8.html#jls-8.8.2-110)
    create frame, synchronize, transfer control, [15.12.4.5](jls-15.html#jls-15.12.4.5-130)
    declarations, [6.1](jls-6.html#jls-6.1-200-B-A)
    evaluate arguments, [15.12.4.2](jls-15.html#jls-15.12.4.2-200)
    field declarations, [13.4.8](jls-13.html#jls-13.4.8-400)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-D.1), [13.1](jls-13.html#jls-13.1-110-E.1), [13.1](jls-13.html#jls-13.1-110-F.1)
    invocation contexts, [5.3](jls-5.html#jls-5.3-500-A)
    method and constructor formal parameters, [13.4.14](jls-13.html#jls-13.4.14-130)
    method and constructor type parameters, [13.4.13](jls-13.html#jls-13.4.13-130)
    method invocation type, [15.12.2.6](jls-15.html#jls-15.12.2.6-100-C-B)
    method result type, [13.4.15](jls-13.html#jls-13.4.15-110)
    method Signature, [8.4.2](jls-8.html#jls-8.4.2-120-B)
    raw types, [4.8](jls-4.html#jls-4.8-100)
    requirements in overriding and hiding, [8.4.8.3](jls-8.html#jls-8.4.8.3-210-B)
    type variables, [4.4](jls-4.html#jls-4.4-220)
escape sequences for character and String literals, [3.10.6](jls-3.html#jls-3.10.6)
    character literals, [3.10.4](jls-3.html#jls-3.10.4-100)
    String literals, [3.10.5](jls-3.html#jls-3.10.5-100)
evaluate arguments, [15.12.4.2](jls-15.html#jls-15.12.4.2)
    formal parameters, [8.4.1](jls-8.html#jls-8.4.1-610)
    variables of reference type, [4.12.2](jls-4.html#jls-4.12.2-310)
evaluate left-hand operand first, [15.7.1](jls-15.html#jls-15.7.1)
evaluate operands before operation, [15.7.2](jls-15.html#jls-15.7.2)
evaluation order, [15.7](jls-15.html#jls-15.7)
evaluation order for other expressions, [15.7.5](jls-15.html#jls-15.7.5)
evaluation respects parentheses and precedence, [15.7.3](jls-15.html#jls-15.7.3)
evaluation, denotation, and result, [15.1](jls-15.html#jls-15.1)
    assert statement, [14.10](jls-14.html#jls-14.10-210)
evolution of annotation types, [13.5.7](jls-13.html#jls-13.5.7)
evolution of classes, [13.4](jls-13.html#jls-13.4)
evolution of enums, [13.4.26](jls-13.html#jls-13.4.26)
evolution of interfaces, [13.5](jls-13.html#jls-13.5)
evolution of packages, [13.3](jls-13.html#jls-13.3)
example programs, [1.2](jls-1.html#jls-1.2)
exception analysis of expressions, [11.2.1](jls-11.html#jls-11.2.1)
    class instance creation expressions, [15.9](jls-15.html#jls-15.9-320)
    compile-time checking of Exceptions, [11.2](jls-11.html#jls-11.2-200)
    method invocation expressions, [15.12](jls-15.html#jls-15.12-140)
exception analysis of statements, [11.2.2](jls-11.html#jls-11.2.2)
    compile-time checking of Exceptions, [11.2](jls-11.html#jls-11.2-200)
    explicit constructor invocations, [8.8.7.1](jls-8.html#jls-8.8.7.1-400)
    method throws, [8.4.6](jls-8.html#jls-8.4.6-100)
    throw statement, [14.18](jls-14.html#jls-14.18-300)
    try statement, [14.20](jls-14.html#jls-14.20-700)
exception checking, [11.2.3](jls-11.html#jls-11.2.3)
    compile-time checking of Exceptions, [11.2](jls-11.html#jls-11.2-100)
    field initialization, [8.3.2](jls-8.html#jls-8.3.2-400)
    instance initializers, [8.6](jls-8.html#jls-8.6-300)
    method throws, [8.4.6](jls-8.html#jls-8.4.6-300)
    static initializers, [8.7](jls-8.html#jls-8.7-300)
    throw statement, [14.18](jls-14.html#jls-14.18-530), [14.18](jls-14.html#jls-14.18-540)
    try statement, [14.20](jls-14.html#jls-14.20-710)
    type of a lambda expression, [15.27.3](jls-15.html#jls-15.27.3-430)
Exceptions, [11](jls-11.html)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-370)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-310)
    normal and abrupt completion of statements, [14.1](jls-14.html#jls-14.1-140)
    throw statement, [14.18](jls-14.html#jls-14.18-100)
execution, [12](jls-12.html)
execution of local variable declarations, [14.4.2](jls-14.html#jls-14.4.2)
    final variables, [4.12.4](jls-4.html#jls-4.12.4-500-A)
    execution of try-catch, [14.20.1](jls-14.html#jls-14.20.1)
    try statement, [14.20](jls-14.html#jls-14.20-800)
execution of try-finally and try-catch-finally, [14.20.2](jls-14.html#jls-14.20.2)
    try statement, [14.20](jls-14.html#jls-14.20-800)
executions, [17.4.6](jls-17.html#jls-17.4.6)
    well-formed executions, [17.4.7](jls-17.html#jls-17.4.7-100-D)
executions and causality requirements, [17.4.8](jls-17.html#jls-17.4.8)
explicit constructor invocations, [8.8.7.1](jls-8.html#jls-8.8.7.1)
    anonymous constructors, [15.9.5.1](jls-15.html#jls-15.9.5.1-100-A.2), [15.9.5.1](jls-15.html#jls-15.9.5.1-100-B.3)
    constructor body, [8.8.7](jls-8.html#jls-8.8.7-100)
    creation of new class instances, [12.5](jls-12.html#jls-12.5-220-B)
    definite assignment, constructors, and instance initializers, [16.9](jls-16.html#jls-16.9-120-A), [16.9](jls-16.html#jls-16.9-120-B)
    enum body declarations, [8.9.2](jls-8.html#jls-8.9.2-210)
    exception analysis of statements, [11.2.2](jls-11.html#jls-11.2.2-130)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-F)
    inner classes and enclosing instances, [8.1.3](jls-8.html#jls-8.1.3-200), [8.1.3](jls-8.html#jls-8.1.3-440)
    instance initializers, [8.6](jls-8.html#jls-8.6-100)
    invocation contexts, [5.3](jls-5.html#jls-5.3-100)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-K), [6.5.1](jls-6.html#jls-6.5.1-120-A)
    where types are used, [4.11](jls-4.html#jls-4.11-100-B-A), [4.11](jls-4.html#jls-4.11-300-A.1)
expression compatibility constraints, [18.2.1](jls-18.html#jls-18.2.1)
expression names, [15.14.1](jls-15.html#jls-15.14.1)
    declarations, [6.1](jls-6.html#jls-6.1-210-K)
expression statements, [14.8](jls-14.html#jls-14.8), [16.2.6](jls-16.html#jls-16.2.6)
    evaluation, denotation, and result, [15.1](jls-15.html#jls-15.1-130)
    expression statements, [16.2.6](jls-16.html#jls-16.2.6-100-A)
    identify potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1-300-A-B)
    initialization of for statement, [14.14.1.1](jls-14.html#jls-14.14.1.1-100-A)
    type of a lambda expression, [15.27.3](jls-15.html#jls-15.27.3-300-D-A)
expressions, [15](jls-15.html)
    expressions and run-time checks, [15.5](jls-15.html#jls-15.5)
    extended try-with-resources, [14.20.3.2](jls-14.html#jls-14.20.3.2)

### Index F

feedback, [1.5](jls-1.html#jls-1.5)
field (constant) declarations, [9.3](jls-9.html#jls-9.3)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-F)
    array initializers, [10.6](jls-10.html#jls-10.6-100)
    array variables, [10.2](jls-10.html#jls-10.2-100), [10.2](jls-10.html#jls-10.2-200)
    declarations, [6.1](jls-6.html#jls-6.1-110-G-D-B)
    final variables, [4.12.4](jls-4.html#jls-4.12.4-400)
    interface body and member declarations, [9.1.4](jls-9.html#jls-9.1.4-100)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-A)
    obscuring, [6.4.2](jls-6.html#jls-6.4.2-110)
    shadowing, [6.4.1](jls-6.html#jls-6.4.1-110)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-F)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-F)
field access expressions, [15.11](jls-15.html#jls-15.11)
    assignment operators, [15.26](jls-15.html#jls-15.26-210)
    names and identifiers, [6.2](jls-6.html#jls-6.2-300-C)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-E)
    objects, [4.3.1](jls-4.html#jls-4.3.1-200-A)
    raw types, [4.8](jls-4.html#jls-4.8-510-A)
    simple assignment operator =, [15.26.1](jls-15.html#jls-15.26.1-300)
    static initializers, [8.7](jls-8.html#jls-8.7-220)
field access using a primary, [15.11.1](jls-15.html#jls-15.11.1)
field declarations, [8.3](jls-8.html#jls-8.3), [13.4.8](jls-13.html#jls-13.4.8), [13.5.5](jls-13.html#jls-13.5.5)
    array initializers, [10.6](jls-10.html#jls-10.6-100)
    array variables, [10.2](jls-10.html#jls-10.2-100), [10.2](jls-10.html#jls-10.2-200)
    class body and member declarations, [8.1.6](jls-8.html#jls-8.1.6-100)
    creation of new class instances, [12.5](jls-12.html#jls-12.5-200)
    declarations, [6.1](jls-6.html#jls-6.1-110-G-D-A)
    field declarations, [13.5.5](jls-13.html#jls-13.5.5-100)
    obscuring, [6.4.2](jls-6.html#jls-6.4.2-110)
    raw types, [4.8](jls-4.html#jls-4.8-210)
    reclassification of contextually ambiguous names, [6.5.2](jls-6.html#jls-6.5.2-110-A)
    shadowing, [6.4.1](jls-6.html#jls-6.4.1-110)
    simple expression names, [6.5.6.1](jls-6.html#jls-6.5.6.1-110)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-F)
    where annotations may appear, [9.7.4](jls-9.html#jls-9.7.4-210)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-F)
field initialization, [8.3.2](jls-8.html#jls-8.3.2)
    definite assignment and static initializers, [16.8](jls-16.html#jls-16.8-100-A)
    definite assignment, constructors, and instance initializers, [16.9](jls-16.html#jls-16.9-100-A)
    detailed initialization procedure, [12.4.2](jls-12.html#jls-12.4.2-300-F.1)
    exception checking, [11.2.3](jls-11.html#jls-11.2.3-120), [11.2.3](jls-11.html#jls-11.2.3-130)
    final fields and static constant variables, [13.4.9](jls-13.html#jls-13.4.9-500)
    initialization of fields in interfaces, [9.3.1](jls-9.html#jls-9.3.1-310)
    simple expression names, [6.5.6.1](jls-6.html#jls-6.5.6.1-110)
    static initializers, [8.7](jls-8.html#jls-8.7-100)
    this, [15.8.3](jls-15.html#jls-15.8.3-100-D)
field modifiers, [8.3.1](jls-8.html#jls-8.3.1)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-F)
    field declarations, [8.3](jls-8.html#jls-8.3-220)
final classes, [8.1.1.2](jls-8.html#jls-8.1.1.2), [13.4.2](jls-13.html#jls-13.4.2)
    anonymous class declarations, [15.9.5](jls-15.html#jls-15.9.5-120)
    final methods, [8.4.3.3](jls-8.html#jls-8.4.3.3-200)
    superclasses and subclasses, [8.1.4](jls-8.html#jls-8.1.4-220)
    verification of the binary representation, [12.3.1](jls-12.html#jls-12.3.1-110-A)
final field semantics, [17.5](jls-17.html#jls-17.5)
    memory model, [17.4](jls-17.html#jls-17.4-140)
final fields, [8.3.1.2](jls-8.html#jls-8.3.1.2)
final fields and static constant variables, [13.4.9](jls-13.html#jls-13.4.9)
    field declarations, [13.5.5](jls-13.html#jls-13.5.5-100)
    final variables, [4.12.4](jls-4.html#jls-4.12.4-300)
    verification of the binary representation, [12.3.1](jls-12.html#jls-12.3.1-110-A)
final methods, [8.4.3.3](jls-8.html#jls-8.4.3.3), [13.4.17](jls-13.html#jls-13.4.17)
    verification of the binary representation, [12.3.1](jls-12.html#jls-12.3.1-110-A)
final variables, [4.12.4](jls-4.html#jls-4.12.4)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-M), [15.28](jls-15.html#jls-15.28-110-N)
    detailed initialization procedure, [12.4.2](jls-12.html#jls-12.4.2-300-F.1)
    enum body declarations, [8.9.2](jls-8.html#jls-8.9.2-220)
    field initialization, [8.3.2](jls-8.html#jls-8.3.2-200-C.1)
    final fields, [8.3.1.2](jls-8.html#jls-8.3.1.2-100)
    final fields and static constant variables, [13.4.9](jls-13.html#jls-13.4.9-300)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-C)
    initialization of fields in interfaces, [9.3.1](jls-9.html#jls-9.3.1-310)
    inner classes and enclosing instances, [8.1.3](jls-8.html#jls-8.1.3-130), [8.1.3](jls-8.html#jls-8.1.3-510), [8.1.3](jls-8.html#jls-8.1.3-530)
    lambda body, [15.27.2](jls-15.html#jls-15.27.2-300)
    local variable declarators and types, [14.4.1](jls-14.html#jls-14.4.1-110)
    narrowing reference conversion, [5.1.6](jls-5.html#jls-5.1.6-100-A.1)
    try statement, [14.20](jls-14.html#jls-14.20-620)
    try-with-resources, [14.20.3](jls-14.html#jls-14.20.3-230)
    when initialization occurs, [12.4.1](jls-12.html#jls-12.4.1-100-D)
finalization of class instances, [12.6](jls-12.html#jls-12.6)
    class Object, [4.3.2](jls-4.html#jls-4.3.2-200-C)
    enum body declarations, [8.9.2](jls-8.html#jls-8.9.2-310)
    happens-before order, [17.4.5](jls-17.html#jls-17.4.5-110-B)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-B.1)
    unloading of classes and interfaces, [12.7](jls-12.html#jls-12.7-110)
floating-point literals, [3.10.2](jls-3.html#jls-3.10.2)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-A)
    lexical literals, [15.8.1](jls-15.html#jls-15.8.1-200-B)
floating-point operations, [4.2.4](jls-4.html#jls-4.2.4)
    additive operators (+ and -) for numeric types, [15.18.2](jls-15.html#jls-15.18.2-500-I.3)
    division operator /, [15.17.2](jls-15.html#jls-15.17.2-300-H.3)
    multiplication operator \*, [15.17.1](jls-15.html#jls-15.17.1-300-E.3)
    narrowing primitive conversion, [5.1.3](jls-5.html#jls-5.1.3-210)
    widening primitive conversion, [5.1.2](jls-5.html#jls-5.1.2-300)
floating-point types, formats, and values, [4.2.3](jls-4.html#jls-4.2.3)
    cast expressions, [15.16](jls-15.html#jls-15.16-310)
    field declarations, [8.3](jls-8.html#jls-8.3-500)
    floating-point literals, [3.10.2](jls-3.html#jls-3.10.2-200)
    formal parameters, [8.4.1](jls-8.html#jls-8.4.1-620)
    fp-strict expressions, [15.4](jls-15.html#jls-15.4-100)
    lambda parameters, [15.27.1](jls-15.html#jls-15.27.1-410)
    lexical literals, [15.8.1](jls-15.html#jls-15.8.1-200-B), [15.8.1](jls-15.html#jls-15.8.1-200-B.1)
    local variable declarators and types, [14.4.1](jls-14.html#jls-14.4.1-210)
    narrowing primitive conversion, [5.1.3](jls-5.html#jls-5.1.3-300-A-A), [5.1.3](jls-5.html#jls-5.1.3-300-A-B)
    parenthesized expressions, [15.8.5](jls-15.html#jls-15.8.5-120-A)
    return statement, [14.17](jls-14.html#jls-14.17-440)
    unary minus operator -, [15.15.4](jls-15.html#jls-15.15.4-220-A)
floating-point value set parameters, [4.2.3](jls-4.html#jls-4.2.3-140-A)
    floating-point types, formats, and values, [4.2.3](jls-4.html#jls-4.2.3-140), [4.2.3](jls-4.html#jls-4.2.3-150), [4.2.3](jls-4.html#jls-4.2.3-170)
for statement, [14.14](jls-14.html#jls-14.14)
    boolean type and boolean values, [4.2.5](jls-4.html#jls-4.2.5-120-D)
    declarations, [6.1](jls-6.html#jls-6.1-110-I-B)
    initial values of variables, [4.12.5](jls-4.html#jls-4.12.5-100-E)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-H.1)
    local variable declaration statements, [14.4](jls-14.html#jls-14.4-210)
for statements, [16.2.12](jls-16.html#jls-16.2.12)
forbidden conversions, [5.1.12](jls-5.html#jls-5.1.12)
form of a binary, [13.1](jls-13.html#jls-13.1)
    check accessibility of type and method, [15.12.4.3](jls-15.html#jls-15.12.4.3-100)
    compile-time step 3: is the chosen method appropriate?, [15.12.3](jls-15.html#jls-15.12.3-500-B)
    final variables, [4.12.4](jls-4.html#jls-4.12.4-300)
    loading of classes and interfaces, [12.2](jls-12.html#jls-12.2-120)
    locate method to invoke, [15.12.4.4](jls-15.html#jls-15.12.4.4-220-B)
    resolution of symbolic references, [12.3.3](jls-12.html#jls-12.3.3-100)
    top level type declarations, [7.6](jls-7.html#jls-7.6-500)
    when reference types are the same, [4.3.4](jls-4.html#jls-4.3.4-100), [4.3.4](jls-4.html#jls-4.3.4-310)
formal parameters, [8.4.1](jls-8.html#jls-8.4.1), [8.8.1](jls-8.html#jls-8.8.1)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-G)
    array variables, [10.2](jls-10.html#jls-10.2-200)
    choosing the constructor and its arguments, [15.9.3](jls-15.html#jls-15.9.3-110-C)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-410-C)
    compile-time step 3: is the chosen method appropriate?, [15.12.3](jls-15.html#jls-15.12.3-410-B)
    declarations, [6.1](jls-6.html#jls-6.1-110-H-A), [6.1](jls-6.html#jls-6.1-110-H-A)
    default constructor, [8.8.9](jls-8.html#jls-8.8.9-100-B)
    definite assignment and parameters, [16.3](jls-16.html#jls-16.3-100-A), [16.3](jls-16.html#jls-16.3-100-A)
    evaluate arguments, [15.12.4.2](jls-15.html#jls-15.12.4.2-100)
    final variables, [4.12.4](jls-4.html#jls-4.12.4-500-C), [4.12.4](jls-4.html#jls-4.12.4-500-C)
    form of a binary, [13.1](jls-13.html#jls-13.1-120-L)
    formal parameters, [8.8.1](jls-8.html#jls-8.8.1-100)
    initial values of variables, [4.12.5](jls-4.html#jls-4.12.5-100-B), [4.12.5](jls-4.html#jls-4.12.5-100-C)
    invoke test.main, [12.1.4](jls-12.html#jls-12.1.4-110)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-D), [4.12.3](jls-4.html#jls-4.12.3-100-E)
    lambda parameters, [15.27.1](jls-15.html#jls-15.27.1-200), [15.27.1](jls-15.html#jls-15.27.1-360)
    method and constructor formal parameters, [13.4.14](jls-13.html#jls-13.4.14-120)
    method declarations, [8.4](jls-8.html#jls-8.4-120)
    reclassification of contextually ambiguous names, [6.5.2](jls-6.html#jls-6.5.2-110-A), [6.5.2](jls-6.html#jls-6.5.2-110-A)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-340), [6.3](jls-6.html#jls-6.3-340)
    shadowing and obscuring, [6.4](jls-6.html#jls-6.4-100)
    shared variables, [17.4.1](jls-17.html#jls-17.4.1-120)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-G), [6.5.1](jls-6.html#jls-6.5.1-110-B-G), [6.5.1](jls-6.html#jls-6.5.1-110-B-H)
    this, [15.8.3](jls-15.html#jls-15.8.3-100-E)
    variables of reference type, [4.12.2](jls-4.html#jls-4.12.2-310)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-G), [4.11](jls-4.html#jls-4.11-100-A-G), [4.11](jls-4.html#jls-4.11-100-A-H), [4.11](jls-4.html#jls-4.11-120-B)
forms of expressions, [15.2](jls-15.html#jls-15.2)
    boolean conditional expressions, [15.25.1](jls-15.html#jls-15.25.1-100)
    choosing the most specific method, [15.12.2.5](jls-15.html#jls-15.12.2.5-310-A-D)
    class instance creation expressions, [15.9](jls-15.html#jls-15.9-500)
    conditional operator ? :, [15.25](jls-15.html#jls-15.25-300-A.1-A), [15.25](jls-15.html#jls-15.25-300-B.1-A)
    expression compatibility constraints, [18.2.1](jls-18.html#jls-18.2.1-100-B), [18.2.1](jls-18.html#jls-18.2.1-100-C)
    identify potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1-310-F)
    lambda expressions, [15.27](jls-15.html#jls-15.27-200)
    method reference expressions, [15.13](jls-15.html#jls-15.13-400)
    more specific method inference, [18.5.4](jls-18.html#jls-18.5.4-300-B.4-A-D)
    numeric conditional expressions, [15.25.2](jls-15.html#jls-15.25.2-100)
    parenthesized expressions, [15.8.5](jls-15.html#jls-15.8.5-210)
forward references during field initialization, [8.3.3](jls-8.html#jls-8.3.3)
    when initialization occurs, [12.4.1](jls-12.html#jls-12.4.1-300)
fp-strict expressions, [15.4](jls-15.html#jls-15.4)
    additive operators (+ and -) for numeric types, [15.18.2](jls-15.html#jls-15.18.2-500-I-1)
    cast expressions, [15.16](jls-15.html#jls-15.16-310)
    constant expressions, [15.28](jls-15.html#jls-15.28-210)
    division operator /, [15.17.2](jls-15.html#jls-15.17.2-300-H-1)
    floating-point types, formats, and values, [4.2.3](jls-4.html#jls-4.2.3-120)
    formal parameters, [8.4.1](jls-8.html#jls-8.4.1-630)
    method declarations, [9.4](jls-9.html#jls-9.4-230)
    multiplication operator \*, [15.17.1](jls-15.html#jls-15.17.1-300-E-1)
    return statement, [14.17](jls-14.html#jls-14.17-440)
    strictfp classes, [8.1.1.3](jls-8.html#jls-8.1.1.3-100)
    strictfp interfaces, [9.1.1.2](jls-9.html#jls-9.1.1.2-100)
    strictfp methods, [8.4.3.5](jls-8.html#jls-8.4.3.5-100)
    value set conversion, [5.1.13](jls-5.html#jls-5.1.13-110), [5.1.13](jls-5.html#jls-5.1.13-120)
    widening primitive conversion, [5.1.2](jls-5.html#jls-5.1.2-200-D)
fully qualified names and canonical names, [6.7](jls-6.html#jls-6.7)
    compilation units, [7.3](jls-7.html#jls-7.3-120-A)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-A-A), [13.1](jls-13.html#jls-13.1-120-G)
    import declarations, [7.5](jls-7.html#jls-7.5-110), [7.5](jls-7.html#jls-7.5-120-A)
    local class declarations, [14.3](jls-14.html#jls-14.3-100)
    named packages, [7.4.1](jls-7.html#jls-7.4.1-120)
    notation, [1.3](jls-1.html#jls-1.3-100)
    package members, [7.1](jls-7.html#jls-7.1-110)
    single-static-import declarations, [7.5.3](jls-7.html#jls-7.5.3-200)
    single-type-import declarations, [7.5.1](jls-7.html#jls-7.5.1-200)
    static-import-on-demand declarations, [7.5.4](jls-7.html#jls-7.5.4-200)
    top level type declarations, [7.6](jls-7.html#jls-7.6-410)
    type-import-on-demand declarations, [7.5.2](jls-7.html#jls-7.5.2-200)
function types, [9.9](jls-9.html#jls-9.9)
    checked exception constraints, [18.2.5](jls-18.html#jls-18.2.5-200-A)
    expression compatibility constraints, [18.2.1](jls-18.html#jls-18.2.1-300-A)
    functional interface parameterization inference, [18.5.3](jls-18.html#jls-18.5.3-230)
    type of a lambda expression, [15.27.3](jls-15.html#jls-15.27.3-200-B)
    type of a method reference, [15.13.2](jls-15.html#jls-15.13.2-200-A)
functional interface parameterization inference, [18.5.3](jls-18.html#jls-18.5.3)
    expression compatibility constraints, [18.2.1](jls-18.html#jls-18.2.1-200-B)
    type of a lambda expression, [15.27.3](jls-15.html#jls-15.27.3-200-A)
functional interfaces, [9.8](jls-9.html#jls-9.8)
    @FunctionalInterface, [9.6.4.9](jls-9.html#jls-9.6.4.9-100)
    checked exception constraints, [18.2.5](jls-18.html#jls-18.2.5-100-A)
    expression compatibility constraints, [18.2.1](jls-18.html#jls-18.2.1-200-A)
    identify potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1-300-A)
    lambda expressions, [15.27](jls-15.html#jls-15.27-300)
    method reference expressions, [15.13](jls-15.html#jls-15.13-500)
    type of a lambda expression, [15.27.3](jls-15.html#jls-15.27.3-100)
    type of a method reference, [15.13.2](jls-15.html#jls-15.13.2-100)

### Index G

generic classes and type parameters, [8.1.2](jls-8.html#jls-8.1.2)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-E)
    capture conversion, [5.1.10](jls-5.html#jls-5.1.10-100)
    class instance creation expressions, [15.9](jls-15.html#jls-15.9-200)
    declarations, [6.1](jls-6.html#jls-6.1-110-F)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-A-E)
    generic constructors, [8.8.4](jls-8.html#jls-8.8.4-110)
    generic methods, [8.4.4](jls-8.html#jls-8.4.4-110)
    parameterized types, [4.5](jls-4.html#jls-4.5-100)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-400)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-E)
    type variables, [4.4](jls-4.html#jls-4.4-110)
    types, classes, and interfaces, [4.12.6](jls-4.html#jls-4.12.6-310-B)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-E)
generic constructors, [8.8.4](jls-8.html#jls-8.8.4)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-E)
    class instance creation expressions, [15.9](jls-15.html#jls-15.9-220)
    declarations, [6.1](jls-6.html#jls-6.1-110-F)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-A-G)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-430)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-E)
    type erasure, [4.6](jls-4.html#jls-4.6-210)
    type variables, [4.4](jls-4.html#jls-4.4-110)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-E)
generic interfaces and type parameters, [9.1.2](jls-9.html#jls-9.1.2)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-E)
    capture conversion, [5.1.10](jls-5.html#jls-5.1.10-100)
    declarations, [6.1](jls-6.html#jls-6.1-110-F)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-A-E)
    parameterized types, [4.5](jls-4.html#jls-4.5-100)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-410)
    subtyping among class and interface types, [4.10.2](jls-4.html#jls-4.10.2-110-C)
    superinterfaces, [8.1.5](jls-8.html#jls-8.1.5-430)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-E)
    type variables, [4.4](jls-4.html#jls-4.4-110)
    types, classes, and interfaces, [4.12.6](jls-4.html#jls-4.12.6-310-B)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-E)
generic methods, [8.4.4](jls-8.html#jls-8.4.4)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-E)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-410-D)
    compile-time step 2: determine method Signature, [15.12.2](jls-15.html#jls-15.12.2-220)
    declarations, [6.1](jls-6.html#jls-6.1-110-F)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-A-F)
    function types, [9.9](jls-9.html#jls-9.9-110-A.1-B), [9.9](jls-9.html#jls-9.9-110-B.1)
    method declarations, [8.4](jls-8.html#jls-8.4-120), [9.4](jls-9.html#jls-9.4-500)
    method invocation expressions, [15.12](jls-15.html#jls-15.12-300-C)
    method result, [8.4.5](jls-8.html#jls-8.4.5-210-C-A)
    method Signature, [8.4.2](jls-8.html#jls-8.4.2-100)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-420)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-E)
    type erasure, [4.6](jls-4.html#jls-4.6-210)
    type variables, [4.4](jls-4.html#jls-4.4-110)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-E)
grammar notation, [2.4](jls-2.html#jls-2.4)
grammars, [2](jls-2.html)

### Index H

happens-before order, [17.4.5](jls-17.html#jls-17.4.5)
    executions, [17.4.6](jls-17.html#jls-17.4.6-200)
    executions and causality requirements, [17.4.8](jls-17.html#jls-17.4.8-330)
    finalization of class instances, [12.6](jls-12.html#jls-12.6-320)
hiding (by class methods), [8.4.8.2](jls-8.html#jls-8.4.8.2)
    obscuring, [6.4.2](jls-6.html#jls-6.4.2-110)
    shadowing, [6.4.1](jls-6.html#jls-6.4.1-110)
host support for packages, [7.2](jls-7.html#jls-7.2)
    top level type declarations, [7.6](jls-7.html#jls-7.6-510)

### Index I

identifiers, [3.8](jls-3.html#jls-3.8)
    declarations, [6.1](jls-6.html#jls-6.1-100)
    keywords, [3.9](jls-3.html#jls-3.9-100)
    lexical grammar, [2.2](jls-2.html#jls-2.2-110)
identify potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-200-B-A), [15.13.1](jls-15.html#jls-15.13.1-200-B-B.2), [15.13.1](jls-15.html#jls-15.13.1-200-B-D)
    compile-time step 1: determine class or interface to search, [15.12.1](jls-15.html#jls-15.12.1-120-A.1-B)
    compile-time step 2: determine method Signature, [15.12.2](jls-15.html#jls-15.12.2-200)
    phase 1: identify matching arity methods applicable by strict invocation, [15.12.2.2](jls-15.html#jls-15.12.2.2-200)
    phase 2: identify matching arity methods applicable by loose invocation, [15.12.2.3](jls-15.html#jls-15.12.2.3-100)
    phase 3: identify methods applicable by variable arity invocation, [15.12.2.4](jls-15.html#jls-15.12.2.4-200)
identity conversion, [5.1.1](jls-5.html#jls-5.1.1)
    assignment contexts, [5.2](jls-5.html#jls-5.2-110-A)
    boxing conversion, [5.1.7](jls-5.html#jls-5.1.7-200-I)
    capture conversion, [5.1.10](jls-5.html#jls-5.1.10-200)
    casting contexts, [5.5](jls-5.html#jls-5.5-110-A)
    invocation contexts, [5.3](jls-5.html#jls-5.3-200-A), [5.3](jls-5.html#jls-5.3-210-A)
    numeric contexts, [5.6](jls-5.html#jls-5.6-110-A)
    unary numeric promotion, [5.6.1](jls-5.html#jls-5.6.1-100-A)
if statement, [14.9](jls-14.html#jls-14.9)
    boolean type and boolean values, [4.2.5](jls-4.html#jls-4.2.5-120-A)
if statements, [16.2.7](jls-16.html#jls-16.2.7)
if-then statement, [14.9.1](jls-14.html#jls-14.9.1)
    if statements, [16.2.7](jls-16.html#jls-16.2.7-100)
if-then-else statement, [14.9.2](jls-14.html#jls-14.9.2)
    if statements, [16.2.7](jls-16.html#jls-16.2.7-110)
implementing finalization, [12.6.1](jls-12.html#jls-12.6.1)
import declarations, [7.5](jls-7.html#jls-7.5)
    compilation units, [7.3](jls-7.html#jls-7.3-120-B)
incorporation, [18.3](jls-18.html#jls-18.3)
incrementation part of for statement, [16.2.12.2](jls-16.html#jls-16.2.12.2)
inference variables, [18.1.1](jls-18.html#jls-18.1.1)
inheritance and overriding, [9.4.1](jls-9.html#jls-9.4.1)
    compile-time checking of Exceptions, [11.2](jls-11.html#jls-11.2-110)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-320)
    compile-time step 3: is the chosen method appropriate?, [15.12.3](jls-15.html#jls-15.12.3-300-E-D)
    interface members, [9.2](jls-9.html#jls-9.2-110)
    method declarations, [9.4](jls-9.html#jls-9.4-400)
inheritance, overriding, and hiding, [8.4.8](jls-8.html#jls-8.4.8)
    class Object,">4.3.2
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-320)
    enum constants, [8.9.1](jls-8.html#jls-8.9.1-300)
    function types, [9.9](jls-9.html#jls-9.9-100)
inheriting methods with override-equivalent signatures, [8.4.8.4](jls-8.html#jls-8.4.8.4), [9.4.1.3](jls-9.html#jls-9.4.1.3)
    variables of reference type, [4.12.2](jls-4.html#jls-4.12.2-310)
initial values of variables, [4.12.5](jls-4.html#jls-4.12.5)
    array initializers, [10.6](jls-10.html#jls-10.6-300)
    creation of new class instances, [12.5](jls-12.html#jls-12.5-210)
    field initialization, [8.3.2](jls-8.html#jls-8.3.2-200-C.1)
    final fields and static constant variables, [13.4.9](jls-13.html#jls-13.4.9-500)
    initialization of fields in interfaces, [9.3.1](jls-9.html#jls-9.3.1-310)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-A.1), [4.12.3](jls-4.html#jls-4.12.3-100-B.1), [4.12.3](jls-4.html#jls-4.12.3-100-C)
    preparation of a class or interface type, [12.3.2](jls-12.html#jls-12.3.2-100)
    run-time evaluation of array creation expressions, [15.10.2](jls-15.html#jls-15.10.2-100-B-D)
    run-time evaluation of class instance creation expressions, [15.9.4](jls-15.html#jls-15.9.4-130)
    variables, [4.12](jls-4.html#jls-4.12-120)
initialization of classes and interfaces, [12.4](jls-12.html#jls-12.4)
    causes of Exceptions, [11.1.2](jls-11.html#jls-11.1.2-100-B-B)
    initialize test: execute initializers, [12.1.3](jls-12.html#jls-12.1.3-140)
    objects, [4.3.1](jls-4.html#jls-4.3.1-150)
    preparation of a class or interface type, [12.3.2](jls-12.html#jls-12.3.2-100)
    run-time handling of an exception, [11.3](jls-11.html#jls-11.3-120-C)
    static fields, [8.3.1.1](jls-8.html#jls-8.3.1.1-100)
initialization of fields in interfaces, [9.3.1](jls-9.html#jls-9.3.1)
    detailed initialization procedure, [12.4.2](jls-12.html#jls-12.4.2-300-F.1)
    field initialization, [8.3.2](jls-8.html#jls-8.3.2-200-C.1)
    final fields and static constant variables, [13.4.9](jls-13.html#jls-13.4.9-500)
initialization of for statement, [14.14.1.1](jls-14.html#jls-14.14.1.1)
initialization part of for statement, [16.2.12.1](jls-16.html#jls-16.2.12.1)
initialize test: execute initializers, [12.1.3](jls-12.html#jls-12.1.3)
inner classes and enclosing instances, [8.1.3](jls-8.html#jls-8.1.3)
    anonymous class declarations, [15.9.5](jls-15.html#jls-15.9.5-130)
    compile-time step 3: is the chosen method appropriate?, [15.12.3](jls-15.html#jls-15.12.3-300-A-A)
    determining enclosing instances, [15.9.2](jls-15.html#jls-15.9.2-100)
    explicit constructor invocations, [8.8.7.1](jls-8.html#jls-8.8.7.1-110-B-B)
    form of a binary, [13.1](jls-13.html#jls-13.1-120-I)
    local class declarations, [14.3](jls-14.html#jls-14.3-110)
    method reference expressions, [15.13](jls-15.html#jls-15.13-300)
    qualified this, [15.8.4](jls-15.html#jls-15.8.4-100)
    when initialization occurs, [12.4.1](jls-12.html#jls-12.4.1-100-E)
input elements and tokens, [3.5](jls-3.html#jls-3.5)
    invocation type inference, [18.5.2](jls-18.html#jls-18.5.2-100-E-A.1-A)
    lexical grammar, [2.2](jls-2.html#jls-2.2-100), [2.2](jls-2.html#jls-2.2-110)
    lexical translations, [3.2](jls-3.html#jls-3.2-100-C)
    unicode, [3.1](jls-3.html#jls-3.1-300)
instance creation, [12.5](jls-12.html#jls-12.5), [15.9](jls-15.html#jls-15.9)
    conditional operator ? :, [15.25](jls-15.html#jls-15.25-300-A.1-C), [15.25](jls-15.html#jls-15.25-300-B.1-C)
    constructor declarations, [8.8](jls-8.html#jls-8.8-100), [8.8](jls-8.html#jls-8.8-100), [8.8](jls-8.html#jls-8.8-400)
    constructor overloading, [8.8.8](jls-8.html#jls-8.8.8-100)
    creation of new class instances, [12.5](jls-12.html#jls-12.5-100)
    exception analysis of expressions, [11.2.1](jls-11.html#jls-11.2.1-100)
    field initialization, [8.3.2](jls-8.html#jls-8.3.2-300-C)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-C.2), [13.1](jls-13.html#jls-13.1-110-F)
    forms of expressions, [15.2](jls-15.html#jls-15.2-300-B)
    functional interfaces, [9.8](jls-9.html#jls-9.8-120)
    initial values of variables, [4.12.5](jls-4.html#jls-4.12.5-100-A), [4.12.5](jls-4.html#jls-4.12.5-100-C)
    instance initializers, [8.6](jls-8.html#jls-8.6-100), [8.6](jls-8.html#jls-8.6-100)
    invocation contexts, [5.3](jls-5.html#jls-5.3-100)
    invocation type inference, [18.5.2](jls-18.html#jls-18.5.2-100-D.1-B-A.1-B), [18.5.2](jls-18.html#jls-18.5.2-100-D.1-B-C)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-E.1)
    method reference expressions, [15.13](jls-15.html#jls-15.13-100)
    names and identifiers, [6.2](jls-6.html#jls-6.2-300-F)
    objects, [4.3.1](jls-4.html#jls-4.3.1-120), [4.3.1](jls-4.html#jls-4.3.1-150)
    return statement, [14.17](jls-14.html#jls-14.17-100)
    run-time evaluation of class instance creation expressions, [15.9.4](jls-15.html#jls-15.9.4-150)
    run-time handling of an exception, [11.3](jls-11.html#jls-11.3-120-B)
    static fields, [8.3.1.1](jls-8.html#jls-8.3.1.1-110)
    String concatenation operator +, [15.18.1](jls-15.html#jls-15.18.1-120)
    String conversion, [5.1.11](jls-5.html#jls-5.1.11-110)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-K), [6.5.1](jls-6.html#jls-6.5.1-110-B-L), [6.5.1](jls-6.html#jls-6.5.1-120-B)
    types, classes, and interfaces, [4.12.6](jls-4.html#jls-4.12.6-110)
    when initialization occurs, [12.4.1](jls-12.html#jls-12.4.1-310)
    where types are used, [4.11](jls-4.html#jls-4.11-100-B-A), [4.11](jls-4.html#jls-4.11-100-B-B), [4.11](jls-4.html#jls-4.11-300-A-C), [4.11](jls-4.html#jls-4.11-300-A.1)
instance initializers, [8.6](jls-8.html#jls-8.6)
    class body and member declarations, [8.1.6](jls-8.html#jls-8.1.6-110)
    definite assignment, constructors, and instance initializers, [16.9](jls-16.html#jls-16.9-110-A)
    exception checking, [11.2.3](jls-11.html#jls-11.2.3-130)
    return statement, [14.17](jls-14.html#jls-14.17-200)
    simple expression names, [6.5.6.1](jls-6.html#jls-6.5.6.1-110)
    this, [15.8.3](jls-15.html#jls-15.8.3-100-C)
    throw statement, [14.18](jls-14.html#jls-14.18-540)
instanceof operator, [15.20.2](jls-15.html#jls-15.20.2)
    expressions and run-time checks, [15.5](jls-15.html#jls-15.5-110-B)
    objects, [4.3.1](jls-4.html#jls-4.3.1-200-E)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-O)
    where types are used, [4.11](jls-4.html#jls-4.11-100-B-E), [4.11](jls-4.html#jls-4.11-300-B-B)
integer bitwise operators &, ^, and |, [15.22.1](jls-15.html#jls-15.22.1)
    binary numeric promotion, [5.6.2](jls-5.html#jls-5.6.2-300-E)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-100-B-H)
    shift operators, [15.19](jls-15.html#jls-15.19-300), [15.19](jls-15.html#jls-15.19-310)
integer literals, [3.10.1](jls-3.html#jls-3.10.1)
    boxing conversion, [5.1.7](jls-5.html#jls-5.1.7-300)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-A)
    lexical literals, [15.8.1](jls-15.html#jls-15.8.1-200-A)
integer operations, [4.2.2](jls-4.html#jls-4.2.2)
integral types and values, [4.2.1](jls-4.html#jls-4.2.1)
    character literals, [3.10.4](jls-3.html#jls-3.10.4-200)
    integer literals, [3.10.1](jls-3.html#jls-3.10.1-120)
    lexical literals, [15.8.1](jls-15.html#jls-15.8.1-200-A), [15.8.1](jls-15.html#jls-15.8.1-200-A.1), [15.8.1](jls-15.html#jls-15.8.1-200-D)
interaction with the memory model, [12.6.2](jls-12.html#jls-12.6.2)
interactions of waits, notification, and interruption, [17.2.4](jls-17.html#jls-17.2.4)
interface body and member declarations, [9.1.4](jls-9.html#jls-9.1.4)
    interface members, [9.2](jls-9.html#jls-9.2-100-A)
    member type declarations, [8.5](jls-8.html#jls-8.5-100), [8.5](jls-8.html#jls-8.5-110)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-320)
interface declarations, [9.1](jls-9.html#jls-9.1)
    declarations, [6.1](jls-6.html#jls-6.1-110-E)
    reference types and values, [4.3](jls-4.html#jls-4.3-100)
    types, classes, and interfaces, [4.12.6](jls-4.html#jls-4.12.6-100)
interface members, [9.2](jls-9.html#jls-9.2), [13.5.3](jls-13.html#jls-13.5.3)
    check accessibility of type and method, [15.12.4.3](jls-15.html#jls-15.12.4.3-130-B-1)
    declarations, [6.1](jls-6.html#jls-6.1-110-G)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-E), [13.1](jls-13.html#jls-13.1-120-E)
interface method body, [9.4.3](jls-9.html#jls-9.4.3)
    superinterfaces, [8.1.5](jls-8.html#jls-8.1.5-510)
    this, [15.8.3](jls-15.html#jls-15.8.3-100-A)
    when initialization occurs, [12.4.1](jls-12.html#jls-12.4.1-110)
interface method declarations, [13.5.6](jls-13.html#jls-13.5.6)
interface methods, [9.4](jls-9.html#jls-9.4)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-C), [9.6.4.1](jls-9.html#jls-9.6.4.1-210-G)
    array variables, [10.2](jls-10.html#jls-10.2-200)
    declarations, [6.1](jls-6.html#jls-6.1-110-G-E-B), [6.1](jls-6.html#jls-6.1-110-H-B), [6.1](jls-6.html#jls-6.1-210-L)
    final variables, [4.12.4](jls-4.html#jls-4.12.4-500-C)
    inheritance, overriding, and hiding, [8.4.8](jls-8.html#jls-8.4.8-200)
    interface body and member declarations, [9.1.4](jls-9.html#jls-9.1.4-100)
    raw types, [4.8](jls-4.html#jls-4.8-210)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-C), [6.5.1](jls-6.html#jls-6.5.1-110-B-D), [6.5.1](jls-6.html#jls-6.5.1-110-B-G)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-C), [4.11](jls-4.html#jls-4.11-100-A-D), [4.11](jls-4.html#jls-4.11-100-A-G), [4.11](jls-4.html#jls-4.11-300-C-A)
interface modifiers, [9.1.1](jls-9.html#jls-9.1.1)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-B)
    static member type declarations, [8.5.1](jls-8.html#jls-8.5.1-300)
interface type parameters, [13.5.4](jls-13.html#jls-13.5.4)
interfaces, [9](jls-9.html)
    package members, [7.1](jls-7.html#jls-7.1-100)
    qualified expression names, [6.5.6.2](jls-6.html#jls-6.5.6.2-220)
    reclassification of contextually ambiguous names, [6.5.2](jls-6.html#jls-6.5.2-110-C)
    top level type declarations, [7.6](jls-7.html#jls-7.6-100)
interruptions, [17.2.3](jls-17.html#jls-17.2.3)
intersection types, [4.9](jls-4.html#jls-4.9)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-D-C-A), [13.1](jls-13.html#jls-13.1-110-E-B-C-A)
    functional interfaces, [9.8](jls-9.html#jls-9.8-200-D)
    type variables, [4.4](jls-4.html#jls-4.4-300)
    where types are used, [4.11](jls-4.html#jls-4.11-200-E)
introduction, [1](jls-1.html)
invocation applicability inference, [18.5.1](jls-18.html#jls-18.5.1)
    invocation type inference, [18.5.2](jls-18.html#jls-18.5.2-100-A), [18.5.2](jls-18.html#jls-18.5.2-100-B), [18.5.2](jls-18.html#jls-18.5.2-100-C.1-A), [18.5.2](jls-18.html#jls-18.5.2-100-F.1-A)
    phase 1: identify matching arity methods applicable by strict invocation, [15.12.2.2](jls-15.html#jls-15.12.2.2-200-A)
    phase 2: identify matching arity methods applicable by loose invocation, [15.12.2.3](jls-15.html#jls-15.12.2.3-100-A)
    phase 3: identify methods applicable by variable arity invocation, [15.12.2.4](jls-15.html#jls-15.12.2.4-200-A)
invocation contexts, [5.3](jls-5.html#jls-5.3)
    class instance creation expressions, [15.9](jls-15.html#jls-15.9-500)
    constraint formulas, [18.1.2](jls-18.html#jls-18.1.2-100-A), [18.1.2](jls-18.html#jls-18.1.2-100-B)
    create frame, synchronize, transfer control, [15.12.4.5](jls-15.html#jls-15.12.4.5-120)
    expression compatibility constraints, [18.2.1](jls-18.html#jls-18.2.1-100-A)
    formal parameters, [8.4.1](jls-8.html#jls-8.4.1-630)
    kinds of types and values, [4.1](jls-4.html#jls-4.1-230)
    lambda expressions, [15.27](jls-15.html#jls-15.27-210)
    method invocation expressions, [15.12](jls-15.html#jls-15.12-300-A)
    method reference expressions, [15.13](jls-15.html#jls-15.13-410)
    reference conditional expressions, [15.25.3](jls-15.html#jls-15.25.3-100)
    type compatibility constraints, [18.2.2](jls-18.html#jls-18.2.2-100-A)
invocation type inference, [18.5.2](jls-18.html#jls-18.5.2)
    expression compatibility constraints, [18.2.1](jls-18.html#jls-18.2.1-100-C-B), [18.2.1](jls-18.html#jls-18.2.1-300-D-B-B)
    invocation type inference, [18.5.2](jls-18.html#jls-18.5.2-100-D.1-B-A.1-B), [18.5.2](jls-18.html#jls-18.5.2-100-D.1-B-C)
    method invocation type, [15.12.2.6](jls-15.html#jls-15.12.2.6-100-A)
invoke test.main, [12.1.4](jls-12.html#jls-12.1.4)
iteration of for statement, [14.14.1.2](jls-14.html#jls-14.14.1.2)

### Index J

    Java Virtual Machine startup, [12.1](jls-12.html#jls-12.1)

### Index K
keywords, [3.9](jls-3.html#jls-3.9)
    identifiers, [3.8](jls-3.html#jls-3.8-200)
    lexical grammar, [2.2](jls-2.html#jls-2.2-110)
    primitive types and values, [4.2](jls-4.html#jls-4.2-100)
kinds and causes of Exceptions, [11.1](jls-11.html#jls-11.1)
kinds of conversion, [5.1](jls-5.html#jls-5.1)
kinds of Exceptions, [11.1.1](jls-11.html#jls-11.1.1)
    compile-time checking of Exceptions, [11.2](jls-11.html#jls-11.2-110), [11.2](jls-11.html#jls-11.2-120)
    generic classes and type parameters, [8.1.2](jls-8.html#jls-8.1.2-310)
    method throws, [8.4.6](jls-8.html#jls-8.4.6-100), [8.4.6](jls-8.html#jls-8.4.6-220)
    narrowing primitive conversion, [5.1.3](jls-5.html#jls-5.1.3-400)
    throw statement, [14.18](jls-14.html#jls-14.18-210-A)
    widening primitive conversion, [5.1.2](jls-5.html#jls-5.1.2-500)
kinds of types and values, [4.1](jls-4.html#jls-4.1)
    capture conversion, [5.1.10](jls-5.html#jls-5.1.10-110-A)
    lexical literals, [15.8.1](jls-15.html#jls-15.8.1-200-F)
    literals, [3.10](jls-3.html#jls-3.10-100)
    null literal, [3.10.7](jls-3.html#jls-3.10.7-120)
    throw statement, [14.18](jls-14.html#jls-14.18-210-A)
kinds of variables, [4.12.3](jls-4.html#jls-4.12.3)
    formal parameters, [8.4.1](jls-8.html#jls-8.4.1-220)

### Index L

labeled statements, [14.7](jls-14.html#jls-14.7), [16.2.5](jls-16.html#jls-16.2.5)
    break statement, [14.15](jls-14.html#jls-14.15-300)
    continue statement, [14.16](jls-14.html#jls-14.16-300)
    labeled statements, [16.2.5](jls-16.html#jls-16.2.5-100-A)
    names and identifiers, [6.2](jls-6.html#jls-6.2-300-B)
lambda body, [15.27.2](jls-15.html#jls-15.27.2)
    choosing the most specific method, [15.12.2.5](jls-15.html#jls-15.12.2.5-310-A-C.1)
    evaluation, denotation, and result, [15.1](jls-15.html#jls-15.1-130)
    identify potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1-300-A-B), [15.12.2.1](jls-15.html#jls-15.12.2.1-300-A-C)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-F)
    type of a lambda expression, [15.27.3](jls-15.html#jls-15.27.3-300-D-B)
lambda expressions, [15.27](jls-15.html#jls-15.27)
    exception analysis of expressions, [11.2.1](jls-11.html#jls-11.2.1-120)
    forms of expressions, [15.2](jls-15.html#jls-15.2-100-F), [15.2](jls-15.html#jls-15.2-300-F)
    functional interfaces, [9.8](jls-9.html#jls-9.8-120)
    identify potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1-300-A)
    return statement, [14.17](jls-14.html#jls-14.17-300-C)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-340)
lambda parameters, [15.27.1](jls-15.html#jls-15.27.1)
    array variables, [10.2](jls-10.html#jls-10.2-200)
    choosing the most specific method, [15.12.2.5](jls-15.html#jls-15.12.2.5-110), [15.12.2.5](jls-15.html#jls-15.12.2.5-310-A)
    compile-time step 2: determine method Signature, [15.12.2](jls-15.html#jls-15.12.2-130)
    declarations, [6.1](jls-6.html#jls-6.1-110-H-A)
    final variables, [4.12.4](jls-4.html#jls-4.12.4-500-C)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-F)
    phase 1: identify matching arity methods applicable by strict invocation, [15.12.2.2](jls-15.html#jls-15.12.2.2-100-A)
    shadowing and obscuring, [6.4](jls-6.html#jls-6.4-100)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-G)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-G)
least upper bound, [4.10.4](jls-4.html#jls-4.10.4)
    intersection types, [4.9](jls-4.html#jls-4.9-110)
    resolution, [18.4](jls-18.html#jls-18.4-320-A-A)
lexical grammar, [2.2](jls-2.html#jls-2.2)
lexical literals, [15.8.1](jls-15.html#jls-15.8.1)
    kinds of types and values, [4.1](jls-4.html#jls-4.1-200)
lexical structure, [3](jls-3.html)
    lexical grammar, [2.2](jls-2.html#jls-2.2-100)
lexical translations, [3.2](jls-3.html#jls-3.2)
    line terminators, [3.4](jls-3.html#jls-3.4)
    character literals, [3.10.4](jls-3.html#jls-3.10.4-310)
    input elements and tokens, [3.5](jls-3.html#jls-3.5-100)
    lexical translations, [3.2](jls-3.html#jls-3.2-100-B)
    white space, [3.6](jls-3.html#jls-3.6-100)
link test: verify, prepare, (optionally) resolve, [12.1.2](jls-12.html#jls-12.1.2)
linking of classes and interfaces, [12.3](jls-12.html#jls-12.3)
    causes of Exceptions, [11.1.2](jls-11.html#jls-11.1.2-100-B-B)
    check accessibility of type and method, [15.12.4.3](jls-15.html#jls-15.12.4.3-140)
    link test: verify, prepare, (optionally) resolve, [12.1.2](jls-12.html#jls-12.1.2-100)
    resolution of symbolic references, [12.3.3](jls-12.html#jls-12.3.3-130)
literals, [3.10](jls-3.html#jls-3.10)
    lexical grammar, [2.2](jls-2.html#jls-2.2-110)
    lexical literals, [15.8.1](jls-15.html#jls-15.8.1-100)
load the class test, [12.1.1](jls-12.html#jls-12.1.1)
loading of classes and interfaces, [12.2](jls-12.html#jls-12.2)
    causes of Exceptions, [11.1.2](jls-11.html#jls-11.1.2-100-B-B)
    class literals, [15.8.2](jls-15.html#jls-15.8.2-400)
    load the class test, [12.1.1](jls-12.html#jls-12.1.1-100)
loading process, [12.2.1](jls-12.html#jls-12.2.1)
    superclasses and subclasses, [8.1.4](jls-8.html#jls-8.1.4-530)
    superinterfaces and subinterfaces, [9.1.3](jls-9.html#jls-9.1.3-430)
local class declaration statements, [16.2.3](jls-16.html#jls-16.2.3)
local class declarations, [14.3](jls-14.html#jls-14.3)
    class instance creation expressions, [15.9](jls-15.html#jls-15.9-400-A.1)
    class modifiers, [8.1.1](jls-8.html#jls-8.1.1-200)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-A-C)
    inner classes and enclosing instances, [8.1.3](jls-8.html#jls-8.1.3-110)
local class declaration statements, [16.2.3](jls-16.html#jls-16.2.3-100-A)
    reclassification of contextually ambiguous names, [6.5.2](jls-6.html#jls-6.5.2-110-C)
    shadowing and obscuring, [6.4](jls-6.html#jls-6.4-100)
    local variable declaration statements, [14.4](jls-14.html#jls-14.4), [16.2.4](jls-16.html#jls-16.2.4)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-H)
    array initializers, [10.6](jls-10.html#jls-10.6-100)
    declarations, [6.1](jls-6.html#jls-6.1-110-I-A)
    initial values of variables, [4.12.5](jls-4.html#jls-4.12.5-100-E)
    initialization of for statement, [14.14.1.1](jls-14.html#jls-14.14.1.1-100-B)
    initialization part of for statement, [16.2.12.1](jls-16.html#jls-16.2.12.1-100-A)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-H)
local variable declaration statements, [16.2.4](jls-16.html#jls-16.2.4-100-A)
    objects, [4.3.1](jls-4.html#jls-4.3.1-150)
    reclassification of contextually ambiguous names, [6.5.2](jls-6.html#jls-6.5.2-110-A)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-520)
    shadowing and obscuring, [6.4](jls-6.html#jls-6.4-100)
    shared variables, [17.4.1](jls-17.html#jls-17.4.1-120)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-I)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-I)
local variable declarators and types, [14.4.1](jls-14.html#jls-14.4.1)
    array variables, [10.2](jls-10.html#jls-10.2-100), [10.2](jls-10.html#jls-10.2-200)
locate method to invoke, [15.12.4.4](jls-15.html#jls-15.12.4.4)
    run-time evaluation of method references, [15.13.3](jls-15.html#jls-15.13.3-400-A), [15.13.3](jls-15.html#jls-15.13.3-400-B), [15.13.3](jls-15.html#jls-15.13.3-400-C)
    logical complement operator !, [15.15.6](jls-15.html#jls-15.15.6), [16.1.4](jls-16.html#jls-16.1.4)
    boolean type and boolean values, [4.2.5](jls-4.html#jls-4.2.5-110-B)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-C)
    logical complement operator !, [16.1.4](jls-16.html#jls-16.1.4-100-A)

### Index M

marker annotations, [9.7.2](jls-9.html#jls-9.7.2)
    annotations, [9.7](jls-9.html#jls-9.7-320)
meaning of expression names, [6.5.6](jls-6.html#jls-6.5.6)
    expression names, [15.14.1](jls-15.html#jls-15.14.1-100)
    forms of expressions, [15.2](jls-15.html#jls-15.2-100-A)
    names and identifiers, [6.2](jls-6.html#jls-6.2-200)
meaning of method names, [6.5.7](jls-6.html#jls-6.5.7)
    names and identifiers, [6.2](jls-6.html#jls-6.2-200)
meaning of package names, [6.5.3](jls-6.html#jls-6.5.3)
    names and identifiers, [6.2](jls-6.html#jls-6.2-200)
meaning of packageortypenames, [6.5.4](jls-6.html#jls-6.5.4)
    type-import-on-demand declarations, [7.5.2](jls-7.html#jls-7.5.2-210)
meaning of type names, [6.5.5](jls-6.html#jls-6.5.5)
    names and identifiers, [6.2](jls-6.html#jls-6.2-200)
member type declarations, [8.5](jls-8.html#jls-8.5), [9.5](jls-9.html#jls-9.5)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-B), [9.6.4.1](jls-9.html#jls-9.6.4.1-210-B)
    class body and member declarations, [8.1.6](jls-8.html#jls-8.1.6-100)
    class instance creation expressions, [15.9](jls-15.html#jls-15.9-400-A.1), [15.9](jls-15.html#jls-15.9-400-A.1)
    class modifiers, [8.1.1](jls-8.html#jls-8.1.1-200), [8.1.1](jls-8.html#jls-8.1.1-210)
    declarations, [6.1](jls-6.html#jls-6.1-110-G-A), [6.1](jls-6.html#jls-6.1-110-G-A), [6.1](jls-6.html#jls-6.1-110-G-B), [6.1](jls-6.html#jls-6.1-110-G-B)
    definite assignment and member types, [16.7](jls-16.html#jls-16.7-100-A), [16.7](jls-16.html#jls-16.7-100-A)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-A-B), [13.1](jls-13.html#jls-13.1-110-A-B), [13.1](jls-13.html#jls-13.1-120-J), [13.1](jls-13.html#jls-13.1-120-J.1)
    inner classes and enclosing instances, [8.1.3](jls-8.html#jls-8.1.3-110), [8.1.3](jls-8.html#jls-8.1.3-110)
    interface body and member declarations, [9.1.4](jls-9.html#jls-9.1.4-100)
    interface modifiers, [9.1.1](jls-9.html#jls-9.1.1-320)
    member type declarations, [9.5](jls-9.html#jls-9.5-100)
    obscuring, [6.4.2](jls-6.html#jls-6.4.2-110), [6.4.2](jls-6.html#jls-6.4.2-110)
    qualified type names, [6.5.5.2](jls-6.html#jls-6.5.5.2-120), [6.5.5.2](jls-6.html#jls-6.5.5.2-120)
    reclassification of contextually ambiguous names, [6.5.2](jls-6.html#jls-6.5.2-110-C), [6.5.2](jls-6.html#jls-6.5.2-110-C), [6.5.2](jls-6.html#jls-6.5.2-120-C-B), [6.5.2](jls-6.html#jls-6.5.2-120-C-B)
    reference types and values, [4.3](jls-4.html#jls-4.3-210), [4.3](jls-4.html#jls-4.3-210)
    shadowing, [6.4.1](jls-6.html#jls-6.4.1-110), [6.4.1](jls-6.html#jls-6.4.1-110)
    static-import-on-demand declarations, [7.5.4](jls-7.html#jls-7.5.4-330), [7.5.4](jls-7.html#jls-7.5.4-330)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-A), [6.5.1](jls-6.html#jls-6.5.1-110-B-A)
    type-import-on-demand declarations, [7.5.2](jls-7.html#jls-7.5.2-310), [7.5.2](jls-7.html#jls-7.5.2-310)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-A), [4.11](jls-4.html#jls-4.11-100-A-A), [4.11](jls-4.html#jls-4.11-100-A-B), [4.11](jls-4.html#jls-4.11-100-A-B)
members and constructors of parameterized types, [4.5.2](jls-4.html#jls-4.5.2)
memory model, [17.4](jls-17.html#jls-17.4)
    interaction with the memory model, [12.6.2](jls-12.html#jls-12.6.2-100)
    volatile fields, [8.3.1.4](jls-8.html#jls-8.3.1.4-200)
method and constructor body, [13.4.22](jls-13.html#jls-13.4.22)
method and constructor declarations, [13.4.12](jls-13.html#jls-13.4.12)
    method and constructor formal parameters, [13.4.14](jls-13.html#jls-13.4.14-110)
    method result type, [13.4.15](jls-13.html#jls-13.4.15-100)
method and constructor formal parameters, [13.4.14](jls-13.html#jls-13.4.14)
    interface method declarations, [13.5.6](jls-13.html#jls-13.5.6-100)
method and constructor overloading, [13.4.23](jls-13.html#jls-13.4.23)
    interface method declarations, [13.5.6](jls-13.html#jls-13.5.6-100)
method and constructor throws, [13.4.21](jls-13.html#jls-13.4.21)
    interface method declarations, [13.5.6](jls-13.html#jls-13.5.6-100)
method and constructor type parameters, [13.4.13](jls-13.html#jls-13.4.13)
    class type parameters, [13.4.5](jls-13.html#jls-13.4.5-130)
method body, [8.4.7](jls-8.html#jls-8.4.7)
    abstract methods, [8.4.3.1](jls-8.html#jls-8.4.3.1-100)
    constructor body, [8.8.7](jls-8.html#jls-8.8.7-230)
    method declarations, [8.4](jls-8.html#jls-8.4-120)
    native methods, [8.4.3.4](jls-8.html#jls-8.4.3.4-100)
    this, [15.8.3](jls-15.html#jls-15.8.3-100-A)
method declarations, [8.4](jls-8.html#jls-8.4), [9.4](jls-9.html#jls-9.4)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-C), [9.6.4.1](jls-9.html#jls-9.6.4.1-210-G)
    array variables, [10.2](jls-10.html#jls-10.2-200)
    class body and member declarations, [8.1.6](jls-8.html#jls-8.1.6-100)
    declarations, [6.1](jls-6.html#jls-6.1-110-G-E-A), [6.1](jls-6.html#jls-6.1-110-G-E-B), [6.1](jls-6.html#jls-6.1-110-H-B), [6.1](jls-6.html#jls-6.1-210-L)
    evaluation, denotation, and result, [15.1](jls-15.html#jls-15.1-130)
    final variables, [4.12.4](jls-4.html#jls-4.12.4-500-C)
    inheritance, overriding, and hiding, [8.4.8](jls-8.html#jls-8.4.8-200)
    interface body and member declarations, [9.1.4](jls-9.html#jls-9.1.4-100)
    raw types, [4.8](jls-4.html#jls-4.8-210), [4.8](jls-4.html#jls-4.8-210)
    return statement, [14.17](jls-14.html#jls-14.17-100)
    simple expression names, [6.5.6.1](jls-6.html#jls-6.5.6.1-110)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-C), [6.5.1](jls-6.html#jls-6.5.1-110-B-C), [6.5.1](jls-6.html#jls-6.5.1-110-B-D), [6.5.1](jls-6.html#jls-6.5.1-110-B-G)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-C), [4.11](jls-4.html#jls-4.11-100-A-D), [4.11](jls-4.html#jls-4.11-100-A-G), [4.11](jls-4.html#jls-4.11-300-C-A)
method invocation expressions, [15.12](jls-15.html#jls-15.12)
    anonymous constructors, [15.9.5.1](jls-15.html#jls-15.9.5.1-100-A.1), [15.9.5.1](jls-15.html#jls-15.9.5.1-100-B.2)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-100)
    conditional operator ? :, [15.25](jls-15.html#jls-15.25-300-A.1-D), [15.25](jls-15.html#jls-15.25-300-B.1-D)
    constructor declarations, [8.8](jls-8.html#jls-8.8-410)
    declarations, [6.1](jls-6.html#jls-6.1-210-I)
    evaluation, denotation, and result, [15.1](jls-15.html#jls-15.1-130)
    exception analysis of expressions, [11.2.1](jls-11.html#jls-11.2.1-110)
    expressions and run-time checks, [15.5](jls-15.html#jls-15.5-110-A)
    field initialization, [8.3.2](jls-8.html#jls-8.3.2-200-B), [8.3.2](jls-8.html#jls-8.3.2-300-B)
    formal parameters, [8.4.1](jls-8.html#jls-8.4.1-600)
    forms of expressions, [15.2](jls-15.html#jls-15.2-300-C)
    happens-before order, [17.4.5](jls-17.html#jls-17.4.5-340)
    hiding (by class methods), [8.4.8.2](jls-8.html#jls-8.4.8.2-200)
    initial values of variables, [4.12.5](jls-4.html#jls-4.12.5-100-B)
    initialization of fields in interfaces, [9.3.1](jls-9.html#jls-9.3.1-210)
    instance initializers, [8.6](jls-8.html#jls-8.6-220)
    invocation contexts, [5.3](jls-5.html#jls-5.3-100)
    invocation type inference, [18.5.2](jls-18.html#jls-18.5.2-100-D.1-B-A.1-B), [18.5.2](jls-18.html#jls-18.5.2-100-D.1-B-C)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-D.1), [4.12.3](jls-4.html#jls-4.12.3-100-F.1)
    lambda parameters, [15.27.1](jls-15.html#jls-15.27.1-400)
    method declarations, [8.4](jls-8.html#jls-8.4-200)
    names and identifiers, [6.2](jls-6.html#jls-6.2-300-D)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-F), [15.6](jls-15.html#jls-15.6-200-I)
    objects, [4.3.1](jls-4.html#jls-4.3.1-200-B)
    overloading, [8.4.9](jls-8.html#jls-8.4.9-200)
    overriding (by instance methods), [8.4.8.1](jls-8.html#jls-8.4.8.1-400)
    return statement, [14.17](jls-14.html#jls-14.17-100)
    run-time handling of an exception, [11.3](jls-11.html#jls-11.3-120-A)
    simple method names, [6.5.7.1](jls-6.html#jls-6.5.7.1-100)
    static initializers, [8.7](jls-8.html#jls-8.7-220)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-A-I), [6.5.1](jls-6.html#jls-6.5.1-110-B-K), [6.5.1](jls-6.html#jls-6.5.1-130-A)
    this, [15.8.3](jls-15.html#jls-15.8.3-200)
    where types are used, [4.11](jls-4.html#jls-4.11-100-B-A), [4.11](jls-4.html#jls-4.11-300-A.1)
method invocation type, [15.12.2.6](jls-15.html#jls-15.12.2.6)
    choosing the constructor and its arguments, [15.9.3](jls-15.html#jls-15.9.3-120-A.4), [15.9.3](jls-15.html#jls-15.9.3-200)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-400)
    compile-time step 3: is the chosen method appropriate?, [15.12.3](jls-15.html#jls-15.12.3-400-A)
    exception analysis of expressions, [11.2.1](jls-11.html#jls-11.2.1-100-C), [11.2.1](jls-11.html#jls-11.2.1-110-C)
    exception analysis of statements, [11.2.2](jls-11.html#jls-11.2.2-130-B)
    expression compatibility constraints, [18.2.1](jls-18.html#jls-18.2.1-300-D-B-C)
    invocation type inference, [18.5.2](jls-18.html#jls-18.5.2-100)
    type compatibility constraints, [18.2.2](jls-18.html#jls-18.2.2-110)
    type of a method reference, [15.13.2](jls-15.html#jls-15.13.2-300-B-B)
method modifiers, [8.4.3](jls-8.html#jls-8.4.3)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-C)
    method declarations, [8.4](jls-8.html#jls-8.4-120)
    objects, [4.3.1](jls-4.html#jls-4.3.1-400)
method overriding, [13.4.24](jls-13.html#jls-13.4.24)
method reference expressions, [15.13](jls-15.html#jls-15.13)
    access to a protected member, [6.6.2.1](jls-6.html#jls-6.6.2.1-110-A)
    declarations, [6.1](jls-6.html#jls-6.1-210-J)
    expressions and run-time checks, [15.5](jls-15.html#jls-15.5-110-D), [15.5](jls-15.html#jls-15.5-210-C)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-F)
    forms of expressions, [15.2](jls-15.html#jls-15.2-100-B), [15.2](jls-15.html#jls-15.2-300-D)
    functional interfaces, [9.8](jls-9.html#jls-9.8-120)
    identify potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1-310-B)
    names and identifiers, [6.2](jls-6.html#jls-6.2-300-E)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-A-J), [6.5.1](jls-6.html#jls-6.5.1-110-B-P), [6.5.1](jls-6.html#jls-6.5.1-120-F)
    where types are used, [4.11](jls-4.html#jls-4.11-100-B-F), [4.11](jls-4.html#jls-4.11-300-A-D), [4.11](jls-4.html#jls-4.11-300-A.1)
method result, [8.4.5](jls-8.html#jls-8.4.5)
    abstract classes, [8.1.1.1](jls-8.html#jls-8.1.1.1-400)
    abstract methods, [8.4.3.1](jls-8.html#jls-8.4.3.1-100)
    array variables, [10.2](jls-10.html#jls-10.2-210)
    class literals, [15.8.2](jls-15.html#jls-15.8.2-220)
    constructor declarations, [8.8](jls-8.html#jls-8.8-210)
    function types, [9.9](jls-9.html#jls-9.9-110-A.2-B)
    functional interfaces, [9.8](jls-9.html#jls-9.8-110-B)
    interface method body, [9.4.3](jls-9.html#jls-9.4.3-320)
    method body, [8.4.7](jls-8.html#jls-8.4.7-240)
    method declarations, [8.4](jls-8.html#jls-8.4-120)
    requirements in overriding and hiding, [8.4.8.3](jls-8.html#jls-8.4.8.3-100)
    return statement, [14.17](jls-14.html#jls-14.17-300-A)
    type erasure, [4.6](jls-4.html#jls-4.6-210)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-C)
  method result type, [13.4.15](jls-13.html#jls-13.4.15)
    interface method declarations, [13.5.6](jls-13.html#jls-13.5.6-100)
  method Signature, [8.4.2](jls-8.html#jls-8.4.2)
    abstract classes, [8.1.1.1](jls-8.html#jls-8.1.1.1-400)
    abstract methods, [8.4.3.1](jls-8.html#jls-8.4.3.1-100)
    choosing the most specific method, [15.12.2.5](jls-15.html#jls-15.12.2.5-530-A)
    constructor Signature, [8.8.2](jls-8.html#jls-8.8.2-100)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-E.1)
    functional interfaces, [9.8](jls-9.html#jls-9.8-110-A)
    hiding (by class methods), [8.4.8.2](jls-8.html#jls-8.4.8.2-100)
    inheritance and overriding, [9.4.1](jls-9.html#jls-9.4.1-100-B)
    inheritance, overriding, and hiding, [8.4.8](jls-8.html#jls-8.4.8-100-C), [8.4.8](jls-8.html#jls-8.4.8-200-C)
    inheriting methods with override-equivalent signatures, [8.4.8.4](jls-8.html#jls-8.4.8.4-100), [9.4.1.3](jls-9.html#jls-9.4.1.3-100)
    interface members, [9.2](jls-9.html#jls-9.2-100-C.2)
    method declarations, [8.4](jls-8.html#jls-8.4-210), [9.4](jls-9.html#jls-9.4-400)
    method result, [8.4.5](jls-8.html#jls-8.4.5-210-C-C)
    overloading, [9.4.2](jls-9.html#jls-9.4.2-100)
    overriding (by instance methods), [8.4.8.1](jls-8.html#jls-8.4.8.1-100-C), [8.4.8.1](jls-8.html#jls-8.4.8.1-200-C), [9.4.1.1](jls-9.html#jls-9.4.1.1-100-B)
    requirements in overriding and hiding, [8.4.8.3](jls-8.html#jls-8.4.8.3-300-C)
    type erasure, [4.6](jls-4.html#jls-4.6-200)
  method throws, [8.4.6](jls-8.html#jls-8.4.6)
    abstract methods, [8.4.3.1](jls-8.html#jls-8.4.3.1-100)
    compile-time checking of Exceptions, [11.2](jls-11.html#jls-11.2-100)
    constructor throws, [8.8.5](jls-8.html#jls-8.8.5-100)
    declarations, [6.1](jls-6.html#jls-6.1-210-L)
    method declarations, [8.4](jls-8.html#jls-8.4-120)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-D)
    throw statement, [14.18](jls-14.html#jls-14.18-210-C)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-D), [4.11](jls-4.html#jls-4.11-300-C-A)
more specific method inference, [18.5.4](jls-18.html#jls-18.5.4)
    choosing the most specific method, [15.12.2.5](jls-15.html#jls-15.12.2.5-200-A)
multiple annotations of the same type, [9.7.5](jls-9.html#jls-9.7.5)
    annotation types, [9.6](jls-9.html#jls-9.6-120)
    annotations, [9.7](jls-9.html#jls-9.7-320)
    class modifiers, [8.1.1](jls-8.html#jls-8.1.1-120)
    constructor modifiers, [8.8.3](jls-8.html#jls-8.8.3-110)
    enum constants, [8.9.1](jls-8.html#jls-8.9.1-120)
    field (constant) declarations, [9.3](jls-9.html#jls-9.3-110)
    field modifiers, [8.3.1](jls-8.html#jls-8.3.1-110)
    formal parameters, [8.4.1](jls-8.html#jls-8.4.1-300)
    generic classes and type parameters, [8.1.2](jls-8.html#jls-8.1.2-130)
    generic interfaces and type parameters, [9.1.2](jls-9.html#jls-9.1.2-120)
    interface modifiers, [9.1.1](jls-9.html#jls-9.1.1-200)
    lambda parameters, [15.27.1](jls-15.html#jls-15.27.1-300)
    local variable declaration statements, [14.4](jls-14.html#jls-14.4-300)
    method declarations, [9.4](jls-9.html#jls-9.4-110)
    method modifiers, [8.4.3](jls-8.html#jls-8.4.3-110)
    named packages, [7.4.1](jls-7.html#jls-7.4.1-300)
multiplication operator \*, [15.17.1](jls-15.html#jls-15.17.1)
multiplicative operators, [15.17](jls-15.html#jls-15.17)
    binary numeric promotion, [5.6.2](jls-5.html#jls-5.6.2-300-A)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-D)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-100-B-B)
    forms of expressions, [15.2](jls-15.html#jls-15.2-100-D)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-100-B-B)

### Index N

name classification, [6.5.1](jls-6.html#jls-6.5.1)
    access control, [6.6](jls-6.html#jls-6.6-120)
    declarations, [6.1](jls-6.html#jls-6.1-220)
    reference types and values, [4.3](jls-4.html#jls-4.3-210)
name reclassification, [6.5.2](jls-6.html#jls-6.5.2)
    method invocation expressions, [15.12](jls-15.html#jls-15.12-200)
named packages, [7.4.1](jls-7.html#jls-7.4.1)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-A)
names, [6](jls-6.html)
    names and identifiers, [6.2](jls-6.html#jls-6.2)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-300)
    import declarations, [7.5](jls-7.html#jls-7.5-100)
    local class declarations, [14.3](jls-14.html#jls-14.3-100)
    named packages, [7.4.1](jls-7.html#jls-7.4.1-100)
    shadowing and obscuring, [6.4](jls-6.html#jls-6.4-100)
narrowing primitive conversion, [5.1.3](jls-5.html#jls-5.1.3)
    casting contexts, [5.5](jls-5.html#jls-5.5-110-C)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-320)
    narrowing primitive conversion, [5.1.3](jls-5.html#jls-5.1.3-300-B-B)
    postfix decrement operator --, [15.14.3](jls-15.html#jls-15.14.3-200)
    postfix increment operator ++, [15.14.2](jls-15.html#jls-15.14.2-200)
    prefix decrement operator --, [15.15.2](jls-15.html#jls-15.15.2-200)
    prefix increment operator ++, [15.15.1](jls-15.html#jls-15.15.1-200)
    widening and narrowing primitive conversion, [5.1.4](jls-5.html#jls-5.1.4-200)
narrowing reference conversion, [5.1.6](jls-5.html#jls-5.1.6)
    casting contexts, [5.5](jls-5.html#jls-5.5-110-F)
native methods, [8.4.3.4](jls-8.html#jls-8.4.3.4), [13.4.18](jls-13.html#jls-13.4.18)
    method body, [8.4.7](jls-8.html#jls-8.4.7-200)
new keyword, [15.9](jls-15.html#jls-15.9)
    conditional operator ? :, [15.25](jls-15.html#jls-15.25-300-A.1-C), [15.25](jls-15.html#jls-15.25-300-B.1-C)
    constructor declarations, [8.8](jls-8.html#jls-8.8-100), [8.8](jls-8.html#jls-8.8-400)
    constructor overloading, [8.8.8](jls-8.html#jls-8.8.8-100)
    creation of new class instances, [12.5](jls-12.html#jls-12.5-100)
    exception analysis of expressions, [11.2.1](jls-11.html#jls-11.2.1-100)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-F)
    forms of expressions, [15.2](jls-15.html#jls-15.2-300-B)
    functional interfaces, [9.8](jls-9.html#jls-9.8-120)
    initial values of variables, [4.12.5](jls-4.html#jls-4.12.5-100-A), [4.12.5](jls-4.html#jls-4.12.5-100-C)
    instance initializers, [8.6](jls-8.html#jls-8.6-100)
    invocation contexts, [5.3](jls-5.html#jls-5.3-100)
    invocation type inference, [18.5.2](jls-18.html#jls-18.5.2-100-D.1-B-A.1-B), [18.5.2](jls-18.html#jls-18.5.2-100-D.1-B-C)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-E.1)
    method reference expressions, [15.13](jls-15.html#jls-15.13-100)
    names and identifiers, [6.2](jls-6.html#jls-6.2-300-F)
    objects, [4.3.1](jls-4.html#jls-4.3.1-120), [4.3.1](jls-4.html#jls-4.3.1-150)
    return statement, [14.17](jls-14.html#jls-14.17-100)
    run-time handling of an exception, [11.3](jls-11.html#jls-11.3-120-B)
    String conversion, [5.1.11](jls-5.html#jls-5.1.11-110)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-K), [6.5.1](jls-6.html#jls-6.5.1-110-B-L), [6.5.1](jls-6.html#jls-6.5.1-120-B)
    types, classes, and interfaces, [4.12.6](jls-4.html#jls-4.12.6-110)
    where types are used, [4.11](jls-4.html#jls-4.11-100-B-A), [4.11](jls-4.html#jls-4.11-100-B-B), [4.11](jls-4.html#jls-4.11-300-A-C), [4.11](jls-4.html#jls-4.11-300-A.1)
non-atomic treatment of double and long, [17.7](jls-17.html#jls-17.7)
normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6)
    causes of Exceptions, [11.1.2](jls-11.html#jls-11.1.2-100-B-A)
    normal and abrupt completion of statements, [14.1](jls-14.html#jls-14.1-110-B), [14.1](jls-14.html#jls-14.1-140)
    run-time handling of an exception, [11.3](jls-11.html#jls-11.3-210)
normal and abrupt completion of statements, [14.1](jls-14.html#jls-14.1)
    interface method body, [9.4.3](jls-9.html#jls-9.4.3-320)
    method body, [8.4.7](jls-8.html#jls-8.4.7-240)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-400)
    run-time handling of an exception, [11.3](jls-11.html#jls-11.3-210)
normal annotations, [9.7.1](jls-9.html#jls-9.7.1)
    annotations, [9.7](jls-9.html#jls-9.7-320)
    defaults for annotation type elements, [9.6.2](jls-9.html#jls-9.6.2-100)
    names and identifiers, [6.2](jls-6.html#jls-6.2-300-G)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-150-E)
notation, [1.3](jls-1.html#jls-1.3)
notification, [17.2.2](jls-17.html#jls-17.2.2)
null literal, [3.10.7](jls-3.html#jls-3.10.7)
    compile-time step 3: is the chosen method appropriate?, [15.12.3](jls-15.html#jls-15.12.3-400-B-A)
    identifiers, [3.8](jls-3.html#jls-3.8-200)
    kinds of types and values, [4.1](jls-4.html#jls-4.1-200)
    lexical literals, [15.8.1](jls-15.html#jls-15.8.1-200-F)
numeric conditional expressions, [15.25.2](jls-15.html#jls-15.25.2)
numeric contexts, [5.6](jls-5.html#jls-5.6)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-210)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-200)
numerical comparison operators <, <=, >, and >=, [15.20.1](jls-15.html#jls-15.20.1)
    binary numeric promotion, [5.6.2](jls-5.html#jls-5.6.2-300-C)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-100-A-A)
    floating-point types, formats, and values, [4.2.3](jls-4.html#jls-4.2.3-240-A)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-100-A-A)
numerical equality operators == and !=, [15.21.1](jls-15.html#jls-15.21.1)
    binary numeric promotion, [5.6.2](jls-5.html#jls-5.6.2-300-D)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-100-A-B)
    floating-point types, formats, and values, [4.2.3](jls-4.html#jls-4.2.3-240-C)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-100-A-B)

### Index O

object creation, [12.5](jls-12.html#jls-12.5)
    constructor declarations, [8.8](jls-8.html#jls-8.8-100)
    field initialization, [8.3.2](jls-8.html#jls-8.3.2-300-C)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-C.2)
    instance initializers, [8.6](jls-8.html#jls-8.6-100)
    run-time evaluation of class instance creation expressions, [15.9.4](jls-15.html#jls-15.9.4-150)
    static fields, [8.3.1.1](jls-8.html#jls-8.3.1.1-110)
    String concatenation operator +, [15.18.1](jls-15.html#jls-15.18.1-120)
    when initialization occurs, [12.4.1](jls-12.html#jls-12.4.1-310)
objects, [4.3.1](jls-4.html#jls-4.3.1), [4.3.2](jls-4.html#jls-4.3.2)
    checked casts at run time, [5.5.3](jls-5.html#jls-5.5.3-300-A), [5.5.3](jls-5.html#jls-5.5.3-400-A)
    method invocation type, [15.12.2.6](jls-15.html#jls-15.12.2.6-100-C-B)
    String literals, [3.10.5](jls-3.html#jls-3.10.5-400)
obscuring, [6.4.2](jls-6.html#jls-6.4.2)
    labeled statements, [14.7](jls-14.html#jls-14.7-220)
    shadowing, [6.4.1](jls-6.html#jls-6.4.1-110)
observability of a package, [7.4.3](jls-7.html#jls-7.4.3)
    qualified package names, [6.5.3.2](jls-6.html#jls-6.5.3.2-110)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-200)
observable behavior and nonterminating executions, [17.4.9](jls-17.html#jls-17.4.9)
    actions, [17.4.2](jls-17.html#jls-17.4.2-100-E), [17.4.2](jls-17.html#jls-17.4.2-320)
operators, [3.12](jls-3.html#jls-3.12)
    input elements and tokens, [3.5](jls-3.html#jls-3.5-130)
    lexical grammar, [2.2](jls-2.html#jls-2.2-110)
operators ++ and --, [16.1.9](jls-16.html#jls-16.1.9)
organization of the specification, [1.1](jls-1.html#jls-1.1)
other expressions, [16.1.10](jls-16.html#jls-16.1.10)
other expressions of type boolean, [16.1.7](jls-16.html#jls-16.1.7)
overload resolution, [15.12.2](jls-15.html#jls-15.12.2), [15.12.2.1](jls-15.html#jls-15.12.2.1), [15.12.2.2](jls-15.html#jls-15.12.2.2), [15.12.2.3](jls-15.html#jls-15.12.2.3), [15.12.2.4](jls-15.html#jls-15.12.2.4), [15.12.2.5](jls-15.html#jls-15.12.2.5)
    choosing the constructor and its arguments, [15.9.3](jls-15.html#jls-15.9.3-120-A.2), [15.9.3](jls-15.html#jls-15.9.3-120-B.1), [15.9.3](jls-15.html#jls-15.9.3-210)
    choosing the most specific method, [15.12.2.5](jls-15.html#jls-15.12.2.5-110)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-200), [15.13.1](jls-15.html#jls-15.13.1-200-B-A), [15.13.1](jls-15.html#jls-15.13.1-200-B-B.2), [15.13.1](jls-15.html#jls-15.13.1-200-B-D), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A.3), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A.3), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A.3), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A.4), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A.4), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A.4), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-B), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-B), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-B.2), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-B.2)
    compile-time step 1: determine class or interface to search, [15.12.1](jls-15.html#jls-15.12.1-120-A.1-B)
    compile-time step 2: determine method Signature, [15.12.2](jls-15.html#jls-15.12.2-120), [15.12.2](jls-15.html#jls-15.12.2-120), [15.12.2](jls-15.html#jls-15.12.2-120), [15.12.2](jls-15.html#jls-15.12.2-200), [15.12.2](jls-15.html#jls-15.12.2-210-A), [15.12.2](jls-15.html#jls-15.12.2-210-B), [15.12.2](jls-15.html#jls-15.12.2-210-C), [15.12.2](jls-15.html#jls-15.12.2-230)
    conditional operator ? :, [15.25](jls-15.html#jls-15.25-300-A.1-D), [15.25](jls-15.html#jls-15.25-300-B.1-D)
    enum constants, [8.9.1](jls-8.html#jls-8.9.1-200)
    invocation applicability inference, [18.5.1](jls-18.html#jls-18.5.1-100-D.1-A.1), [18.5.1](jls-18.html#jls-18.5.1-100-D.1-C.1)
    invocation type inference, [18.5.2](jls-18.html#jls-18.5.2-100-D.1)
    method and constructor overloading, [13.4.23](jls-13.html#jls-13.4.23-110)
    more specific method inference, [18.5.4](jls-18.html#jls-18.5.4-100), [18.5.4](jls-18.html#jls-18.5.4-210-A), [18.5.4](jls-18.html#jls-18.5.4-210-A), [18.5.4](jls-18.html#jls-18.5.4-210-B), [18.5.4](jls-18.html#jls-18.5.4-300-B.1)
    overloading, [8.4.9](jls-8.html#jls-8.4.9-200)
    phase 1: identify matching arity methods applicable by strict invocation, [15.12.2.2](jls-15.html#jls-15.12.2.2-200), [15.12.2.2](jls-15.html#jls-15.12.2.2-210), [15.12.2.2](jls-15.html#jls-15.12.2.2-220)
    phase 2: identify matching arity methods applicable by loose invocation, [15.12.2.3](jls-15.html#jls-15.12.2.3-100), [15.12.2.3](jls-15.html#jls-15.12.2.3-100-B-A), [15.12.2.3](jls-15.html#jls-15.12.2.3-110), [15.12.2.3](jls-15.html#jls-15.12.2.3-120)
    phase 3: identify methods applicable by variable arity invocation, [15.12.2.4](jls-15.html#jls-15.12.2.4-200), [15.12.2.4](jls-15.html#jls-15.12.2.4-200-B-A), [15.12.2.4](jls-15.html#jls-15.12.2.4-220)
    what binary compatibility is and is not, [13.2](jls-13.html#jls-13.2-120)
overloading, [8.4.9](jls-8.html#jls-8.4.9), [9.4.2](jls-9.html#jls-9.4.2)
    constructor overloading, [8.8.8](jls-8.html#jls-8.8.8-100)
overriding (by instance methods), [8.4.8.1](jls-8.html#jls-8.4.8.1), [9.4.1.1](jls-9.html#jls-9.4.1.1)
    final classes, [8.1.1.2](jls-8.html#jls-8.1.1.2-300)
    locate method to invoke, [15.12.4.4](jls-15.html#jls-15.12.4.4-240-A-B)
    superinterfaces, [8.1.5](jls-8.html#jls-8.1.5-500)

### Index P

  package declarations, [7.4](jls-7.html#jls-7.4)
    compilation units, [7.3](jls-7.html#jls-7.3-120-A)
    declarations, [6.1](jls-6.html#jls-6.1-110-A)
  package members, [7.1](jls-7.html#jls-7.1)
  packages, [7](jls-7.html)
parameterized types, [4.5](jls-4.html#jls-4.5)
    annotation type elements, [9.6.1](jls-9.html#jls-9.6.1-200-C)
    capture conversion, [5.1.10](jls-5.html#jls-5.1.10-110), [5.1.10](jls-5.html#jls-5.1.10-200)
    checked casts and unchecked casts, [5.5.2](jls-5.html#jls-5.5.2-200)
    class literals, [15.8.2](jls-15.html#jls-15.8.2-300)
    declarations, [6.1](jls-6.html#jls-6.1-200-B-B)
    determining the class being instantiated, [15.9.1](jls-15.html#jls-15.9.1-100-A.3)
    field declarations, [13.4.8](jls-13.html#jls-13.4.8-400)
    functional interfaces, [9.8](jls-9.html#jls-9.8-200-B)
    generic classes and type parameters, [8.1.2](jls-8.html#jls-8.1.2-300)
    generic interfaces and type parameters, [9.1.2](jls-9.html#jls-9.1.2-300)
    method and constructor formal parameters, [13.4.14](jls-13.html#jls-13.4.14-130)
    method reference expressions, [15.13](jls-15.html#jls-15.13-250-B)
    method result type, [13.4.15](jls-13.html#jls-13.4.15-110)
    normal annotations, [9.7.1](jls-9.html#jls-9.7.1-300-B-B)
    raw types, [4.8](jls-4.html#jls-4.8-100)
    reference type casting, [5.5.1](jls-5.html#jls-5.5.1-200-A.1)
    reference types and values, [4.3](jls-4.html#jls-4.3-200)
    superclasses and subclasses, [8.1.4](jls-8.html#jls-8.1.4-240)
    superinterfaces, [8.1.5](jls-8.html#jls-8.1.5-210)
    superinterfaces and subinterfaces, [9.1.3](jls-9.html#jls-9.1.3-150)
    type erasure, [4.6](jls-4.html#jls-4.6-100-A)
    types, classes, and interfaces, [4.12.6](jls-4.html#jls-4.12.6-310-B)
    where types are used, [4.11](jls-4.html#jls-4.11-200-C)
parenthesized expressions, [15.8.5](jls-15.html#jls-15.8.5)
    conditional operator ? :, [15.25](jls-15.html#jls-15.25-300-A.1-B), [15.25](jls-15.html#jls-15.25-300-B.1-B)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-L)
    forms of expressions, [15.2](jls-15.html#jls-15.2-300-A)
    identify potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1-310-D)
phase 1: identify matching arity methods applicable by strict invocation, [15.12.2.2](jls-15.html#jls-15.12.2.2-100-F)
    phase 1: identify matching arity methods applicable by strict invocation, [15.12.2.2](jls-15.html#jls-15.12.2.2)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A.3), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A.4), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-B), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-B.2)
    compile-time step 2: determine method Signature, [15.12.2](jls-15.html#jls-15.12.2-120), [15.12.2](jls-15.html#jls-15.12.2-210-A)
    invocation applicability inference, [18.5.1](jls-18.html#jls-18.5.1-100-D.1-A.1)
    more specific method inference, [18.5.4](jls-18.html#jls-18.5.4-210-A)
    phase 2: identify matching arity methods applicable by loose invocation, [15.12.2.3](jls-15.html#jls-15.12.2.3-100-B-A)
    phase 3: identify methods applicable by variable arity invocation, [15.12.2.4](jls-15.html#jls-15.12.2.4-200-B-A)
phase 2: identify matching arity methods applicable by loose invocation, [15.12.2.3](jls-15.html#jls-15.12.2.3)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A.3), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A.4)
    compile-time step 2: determine method Signature, [15.12.2](jls-15.html#jls-15.12.2-120), [15.12.2](jls-15.html#jls-15.12.2-210-B)
    more specific method inference, [18.5.4](jls-18.html#jls-18.5.4-210-A)
    phase 1: identify matching arity methods applicable by strict invocation, [15.12.2.2](jls-15.html#jls-15.12.2.2-210)
phase 3: identify methods applicable by variable arity invocation, [15.12.2.4](jls-15.html#jls-15.12.2.4)
    choosing the constructor and its arguments, [15.9.3](jls-15.html#jls-15.9.3-210)
    choosing the most specific method, [15.12.2.5](jls-15.html#jls-15.12.2.5-110)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A.3), [15.13.1](jls-15.html#jls-15.13.1-200-C.1-A.4)
    compile-time step 2: determine method Signature, [15.12.2](jls-15.html#jls-15.12.2-120), [15.12.2](jls-15.html#jls-15.12.2-210-C)
    invocation applicability inference, [18.5.1](jls-18.html#jls-18.5.1-100-D.1-C.1)
    invocation type inference, [18.5.2](jls-18.html#jls-18.5.2-100-D.1)
    more specific method inference, [18.5.4](jls-18.html#jls-18.5.4-210-B)
    phase 2: identify matching arity methods applicable by loose invocation, [15.12.2.3](jls-15.html#jls-15.12.2.3-110)
poly expressions, [15.2](jls-15.html#jls-15.2)
    boolean conditional expressions, [15.25.1](jls-15.html#jls-15.25.1-100)
    choosing the most specific method, [15.12.2.5](jls-15.html#jls-15.12.2.5-310-A-D)
    class instance creation expressions, [15.9](jls-15.html#jls-15.9-500)
    conditional operator ? :, [15.25](jls-15.html#jls-15.25-300-A.1-A), [15.25](jls-15.html#jls-15.25-300-B.1-A)
    expression compatibility constraints, [18.2.1](jls-18.html#jls-18.2.1-100-B), [18.2.1](jls-18.html#jls-18.2.1-100-C)
    identify potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1-310-F)
    lambda expressions, [15.27](jls-15.html#jls-15.27-200)
    method reference expressions, [15.13](jls-15.html#jls-15.13-400)
    more specific method inference, [18.5.4](jls-18.html#jls-18.5.4-300-B.4-A-D)
    numeric conditional expressions, [15.25.2](jls-15.html#jls-15.25.2-100)
    parenthesized expressions, [15.8.5](jls-15.html#jls-15.8.5-210)
postfix decrement operator --, [15.14.3](jls-15.html#jls-15.14.3)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-100-B-E), [4.2.4](jls-4.html#jls-4.2.4-370-B)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-100-B-E), [4.2.2](jls-4.html#jls-4.2.2-310-C)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-I)
    operators ++ and --, [16.1.9](jls-16.html#jls-16.1.9-100-A)
    variables, [4.12](jls-4.html#jls-4.12-110)
postfix expressions, [15.14](jls-15.html#jls-15.14)
    final variables, [4.12.4](jls-4.html#jls-4.12.4-500-A-C)
    forms of expressions, [15.2](jls-15.html#jls-15.2-100-C)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-120-D)
postfix increment operator ++, [15.14.2](jls-15.html#jls-15.14.2)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-100-B-D), [4.2.4](jls-4.html#jls-4.2.4-370-B)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-100-B-D), [4.2.2](jls-4.html#jls-4.2.2-310-C)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-I)
    operators ++ and --, [16.1.9](jls-16.html#jls-16.1.9-100-A)
    variables, [4.12](jls-4.html#jls-4.12-110)
potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1)
    compile-time declaration of a method reference, [15.13.1](jls-15.html#jls-15.13.1-200-B-A), [15.13.1](jls-15.html#jls-15.13.1-200-B-B.2), [15.13.1](jls-15.html#jls-15.13.1-200-B-D)
    compile-time step 1: determine class or interface to search, [15.12.1](jls-15.html#jls-15.12.1-120-A.1-B)
    compile-time step 2: determine method Signature, [15.12.2](jls-15.html#jls-15.12.2-200)
    phase 1: identify matching arity methods applicable by strict invocation, [15.12.2.2](jls-15.html#jls-15.12.2.2-200)
    phase 2: identify matching arity methods applicable by loose invocation, [15.12.2.3](jls-15.html#jls-15.12.2.3-100)
    phase 3: identify methods applicable by variable arity invocation, [15.12.2.4](jls-15.html#jls-15.12.2.4-200)
predefined annotation types, [9.6.4](jls-9.html#jls-9.6.4)
prefix decrement operator --, [15.15.2](jls-15.html#jls-15.15.2)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-100-B-E), [4.2.4](jls-4.html#jls-4.2.4-370-B)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-100-B-E), [4.2.2](jls-4.html#jls-4.2.2-310-C)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-I)
    operators ++ and --, [16.1.9](jls-16.html#jls-16.1.9-100-A)
    variables, [4.12](jls-4.html#jls-4.12-110)
prefix increment operator ++, [15.15.1](jls-15.html#jls-15.15.1)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-100-B-D), [4.2.4](jls-4.html#jls-4.2.4-370-B)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-100-B-D), [4.2.2](jls-4.html#jls-4.2.2-310-C)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-I)
    operators ++ and --, [16.1.9](jls-16.html#jls-16.1.9-100-A)
    variables, [4.12](jls-4.html#jls-4.12-110)
preparation of a class or interface type, [12.3.2](jls-12.html#jls-12.3.2)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-A.1)
    link test: verify, prepare, (optionally) resolve, [12.1.2](jls-12.html#jls-12.1.2-120)
preventing instantiation of a class, [8.8.10](jls-8.html#jls-8.8.10)
    constructor declarations, [8.8](jls-8.html#jls-8.8-400)
primary expressions, [15.8](jls-15.html#jls-15.8)
    access to a protected member, [6.6.2.1](jls-6.html#jls-6.6.2.1-110-B)
    forms of expressions, [15.2](jls-15.html#jls-15.2-100-B)
    postfix expressions, [15.14](jls-15.html#jls-15.14-100)
primitive types and values, [4.2](jls-4.html#jls-4.2)
    class literals, [15.8.2](jls-15.html#jls-15.8.2-210)
    conditional operator ? :, [15.25](jls-15.html#jls-15.25-300-B.1-A)
    evaluation, denotation, and result, [15.1](jls-15.html#jls-15.1-100-B)
    kinds of types and values, [4.1](jls-4.html#jls-4.1-100)
    literals, [3.10](jls-3.html#jls-3.10-100)
    reifiable types, [4.7](jls-4.html#jls-4.7-110-D)
    unboxing conversion, [5.1.8](jls-5.html#jls-5.1.8-300)
    variables, [4.12](jls-4.html#jls-4.12-100)
    where types are used, [4.11](jls-4.html#jls-4.11-200-A)
program exit, [12.8](jls-12.html#jls-12.8)
programs and program order, [17.4.3](jls-17.html#jls-17.4.3)
    happens-before order, [17.4.5](jls-17.html#jls-17.4.5-410)
    synchronization order, [17.4.4](jls-17.html#jls-17.4.4-100)
public classes, [13.4.3](jls-13.html#jls-13.4.3)
public interfaces, [13.5.1](jls-13.html#jls-13.5.1)

### Index Q

qualified access to a protected constructor, [6.6.2.2](jls-6.html#jls-6.6.2.2)
qualified expression names, [6.5.6.2](jls-6.html#jls-6.5.6.2)
    access control, [6.6](jls-6.html#jls-6.6-120)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-N)
    field access expressions, [15.11](jls-15.html#jls-15.11-120)
    field declarations, [8.3](jls-8.html#jls-8.3-330)
    members and constructors of parameterized types, [4.5.2](jls-4.html#jls-4.5.2-300)
qualified package names, [6.5.3.2](jls-6.html#jls-6.5.3.2)
qualified packageortypenames, [6.5.4.2](jls-6.html#jls-6.5.4.2)
qualified this, [15.8.4](jls-15.html#jls-15.8.4)
    declarations, [6.1](jls-6.html#jls-6.1-210-G)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-A-G)
qualified type names, [6.5.5.2](jls-6.html#jls-6.5.5.2)
    access control, [6.6](jls-6.html#jls-6.6-120)
    members and constructors of parameterized types, [4.5.2](jls-4.html#jls-4.5.2-300)
    single-static-import declarations, [7.5.3](jls-7.html#jls-7.5.3-210)
    single-type-import declarations, [7.5.1](jls-7.html#jls-7.5.1-210)
    static-import-on-demand declarations, [7.5.4](jls-7.html#jls-7.5.4-210)
    type-import-on-demand declarations, [7.5.2](jls-7.html#jls-7.5.2-210)

### Index R
raw types, [4.8](jls-4.html#jls-4.8)
    assignment contexts, [5.2](jls-5.html#jls-5.2-120)
    functional interfaces, [9.8](jls-9.html#jls-9.8-200-C)
    invocation contexts, [5.3](jls-5.html#jls-5.3-220)
    method reference expressions, [15.13](jls-15.html#jls-15.13-250-C)
    reifiable types, [4.7](jls-4.html#jls-4.7-110-C)
    subtyping among class and interface types, [4.10.2](jls-4.html#jls-4.10.2-110)
    type arguments of parameterized types, [4.5.1](jls-4.html#jls-4.5.1-300-B)
    unchecked conversion, [5.1.9](jls-5.html#jls-5.1.9-110)
    variables of reference type, [4.12.2](jls-4.html#jls-4.12.2-310)
    where types are used, [4.11](jls-4.html#jls-4.11-200-D)
reading final fields during construction, [17.5.2](jls-17.html#jls-17.5.2)
reclassification of contextually ambiguous names, [6.5.2](jls-6.html#jls-6.5.2)
    method invocation expressions, [15.12](jls-15.html#jls-15.12-200)
reduction, [18.2](jls-18.html#jls-18.2)
    invocation applicability inference, [18.5.1](jls-18.html#jls-18.5.1-100-E)
reference conditional expressions, [15.25.3](jls-15.html#jls-15.25.3)
reference equality operators == and !=, [15.21.3](jls-15.html#jls-15.21.3)
    objects, [4.3.1](jls-4.html#jls-4.3.1-200-F)
reference type casting, [5.5.1](jls-5.html#jls-5.5.1)
    casting contexts, [5.5](jls-5.html#jls-5.5-200-D)
reference types and values, [4.3](jls-4.html#jls-4.3)
    class literals, [15.8.2](jls-15.html#jls-15.8.2-200)
    evaluation, denotation, and result, [15.1](jls-15.html#jls-15.1-100-B)
    initial values of variables, [4.12.5](jls-4.html#jls-4.12.5-100-A-I)
    kinds of types and values, [4.1](jls-4.html#jls-4.1-100)
    variables, [4.12](jls-4.html#jls-4.12-100)
references, [1.6](jls-1.html#jls-1.6)
reifiable types, [4.7](jls-4.html#jls-4.7)
    @SafeVarargs, [9.6.4.7](jls-9.html#jls-9.6.4.7-100)
    array creation expressions, [15.10.1](jls-15.html#jls-15.10.1-200)
    array initializers, [10.6](jls-10.html#jls-10.6-210)
    expressions and run-time checks, [15.5](jls-15.html#jls-15.5-200), [15.5](jls-15.html#jls-15.5-210-B)
    formal parameters, [8.4.1](jls-8.html#jls-8.4.1-510)
    method reference expressions, [15.13](jls-15.html#jls-15.13-260)
    type comparison operator instanceof, [15.20.2](jls-15.html#jls-15.20.2-110)
relational operators, [15.20](jls-15.html#jls-15.20)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-G)
relationship to predefined classes and interfaces, [1.4](jls-1.html#jls-1.4)
remainder operator %, [15.17.3](jls-15.html#jls-15.17.3)
    evaluate operands before operation, [15.7.2](jls-15.html#jls-15.7.2-110)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-300)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-310-B)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-H)
repeatable annotation types, [9.6.3](jls-9.html#jls-9.6.3)
    @Repeatable, [9.6.4.8](jls-9.html#jls-9.6.4.8-100)
    evolution of annotation types, [13.5.7](jls-13.html#jls-13.5.7-100)
    multiple annotations of the same type, [9.7.5](jls-9.html#jls-9.7.5-100)
requirements in overriding, [9.4.1.2](jls-9.html#jls-9.4.1.2)
    variables of reference type, [4.12.2](jls-4.html#jls-4.12.2-310)
requirements in overriding and hiding, [8.4.8.3](jls-8.html#jls-8.4.8.3)
    compile-time checking of Exceptions, [11.2](jls-11.html#jls-11.2-110)
    method throws, [8.4.6](jls-8.html#jls-8.4.6-400)
    requirements in overriding, [9.4.1.2](jls-9.html#jls-9.4.1.2-100), [9.4.1.2](jls-9.html#jls-9.4.1.2-200), [9.4.1.2](jls-9.html#jls-9.4.1.2-300)
    type of a lambda expression, [15.27.3](jls-15.html#jls-15.27.3-420)
    type of a method reference, [15.13.2](jls-15.html#jls-15.13.2-420)
    variables of reference type, [4.12.2](jls-4.html#jls-4.12.2-310)
resolution, [18.4](jls-18.html#jls-18.4)
    invocation applicability inference, [18.5.1](jls-18.html#jls-18.5.1-100-F)
    invocation type inference, [18.5.2](jls-18.html#jls-18.5.2-100-E-A)
resolution of symbolic references, [12.3.3](jls-12.html#jls-12.3.3)
    link test: verify, prepare, (optionally) resolve, [12.1.2](jls-12.html#jls-12.1.2-170)
return statement, [14.17](jls-14.html#jls-14.17)
    break, continue, return, and throw statements, [16.2.13](jls-16.html#jls-16.2.13-100-A)
    constructor body, [8.8.7](jls-8.html#jls-8.8.7-230), [8.8.7](jls-8.html#jls-8.8.7-240)
    instance initializers, [8.6](jls-8.html#jls-8.6-210)
    interface method body, [9.4.3](jls-9.html#jls-9.4.3-310)
    method body, [8.4.7](jls-8.html#jls-8.4.7-210)
    normal and abrupt completion of statements, [14.1](jls-14.html#jls-14.1-110-A)
    static initializers, [8.7](jls-8.html#jls-8.7-210)
run-time evaluation of array access expressions, [15.10.4](jls-15.html#jls-15.10.4)
    array access, [10.4](jls-10.html#jls-10.4-140)
    evaluation order for other expressions, [15.7.5](jls-15.html#jls-15.7.5-100-C)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-C), [15.6](jls-15.html#jls-15.6-200-D)
run-time evaluation of array creation expressions, [15.10.2](jls-15.html#jls-15.10.2)
    evaluation order for other expressions, [15.7.5](jls-15.html#jls-15.7.5-100-B)
    initial values of variables, [4.12.5](jls-4.html#jls-4.12.5-100-A)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-C)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-A), [15.6](jls-15.html#jls-15.6-200-B)
run-time evaluation of class instance creation expressions, [15.9.4](jls-15.html#jls-15.9.4)
    evaluation order for other expressions, [15.7.5](jls-15.html#jls-15.7.5-100-A)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-A)
    throw statement, [14.18](jls-14.html#jls-14.18-520)
run-time evaluation of lambda expressions, [15.27.4](jls-15.html#jls-15.27.4)
    creation of new class instances, [12.5](jls-12.html#jls-12.5-110-D)
    evaluation order for other expressions, [15.7.5](jls-15.html#jls-15.7.5-100-F)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-A)
run-time evaluation of method invocation, [15.12.4](jls-15.html#jls-15.12.4)
    evaluation order for other expressions, [15.7.5](jls-15.html#jls-15.7.5-100-D)
    overloading, [8.4.9](jls-8.html#jls-8.4.9-200)
run-time evaluation of method references, [15.13.3](jls-15.html#jls-15.13.3)
    creation of new class instances, [12.5](jls-12.html#jls-12.5-110-D)
    evaluation order for other expressions, [15.7.5](jls-15.html#jls-15.7.5-100-G)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-A)
run-time handling of an exception, [11.3](jls-11.html#jls-11.3)
    expressions and run-time checks, [15.5](jls-15.html#jls-15.5-210-D)
    initial values of variables, [4.12.5](jls-4.html#jls-4.12.5-100-D)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-G.1)
    throw statement, [14.18](jls-14.html#jls-14.18-100)
    try statement, [14.20](jls-14.html#jls-14.20-720)

### Index S

scope of a declaration, [6.3](jls-6.html#jls-6.3)
    basic for statement, [14.14.1](jls-14.html#jls-14.14.1-300)
    class body and member declarations, [8.1.6](jls-8.html#jls-8.1.6-200)
    class declarations, [8.1](jls-8.html#jls-8.1-300)
    class literals, [15.8.2](jls-15.html#jls-15.8.2-310)
    compile-time step 1: determine class or interface to search, [15.12.1](jls-15.html#jls-15.12.1-120-A.1)
    enhanced for statement, [14.14.2](jls-14.html#jls-14.14.2-220), [14.14.2](jls-14.html#jls-14.14.2-300-A.3)
    enum constants, [8.9.1](jls-8.html#jls-8.9.1-140)
    field (constant) declarations, [9.3](jls-9.html#jls-9.3-300)
    field declarations, [8.3](jls-8.html#jls-8.3-300)
    formal parameters, [8.4.1](jls-8.html#jls-8.4.1-330)
    forward references during field initialization, [8.3.3](jls-8.html#jls-8.3.3-100)
    generic classes and type parameters, [8.1.2](jls-8.html#jls-8.1.2-210)
    generic constructors, [8.8.4](jls-8.html#jls-8.8.4-200)
    generic interfaces and type parameters, [9.1.2](jls-9.html#jls-9.1.2-210)
    generic methods, [8.4.4](jls-8.html#jls-8.4.4-200)
    import declarations, [7.5](jls-7.html#jls-7.5-200)
    interface body and member declarations, [9.1.4](jls-9.html#jls-9.1.4-120)
    interface declarations, [9.1](jls-9.html#jls-9.1-210)
    lambda parameters, [15.27.1](jls-15.html#jls-15.27.1-330)
    local class declarations, [14.3](jls-14.html#jls-14.3-300)
    local variable declarators and types, [14.4.1](jls-14.html#jls-14.4.1-220)
    member type declarations, [8.5](jls-8.html#jls-8.5-300)
    method declarations, [8.4](jls-8.html#jls-8.4-300)
    named packages, [7.4.1](jls-7.html#jls-7.4.1-200)
    reclassification of contextually ambiguous names, [6.5.2](jls-6.html#jls-6.5.2-110-A), [6.5.2](jls-6.html#jls-6.5.2-110-C)
    simple package names, [6.5.3.1](jls-6.html#jls-6.5.3.1-110)
    top level type declarations, [7.6](jls-7.html#jls-7.6-400)
    try statement, [14.20](jls-14.html#jls-14.20-330)
    try-with-resources, [14.20.3](jls-14.html#jls-14.20.3-250)
    type variables, [4.4](jls-4.html#jls-4.4-130)
semantics of final fields, [17.5.1](jls-17.html#jls-17.5.1)
separators, [3.11](jls-3.html#jls-3.11)
    lexical grammar, [2.2](jls-2.html#jls-2.2-110)
shadowing, [6.4.1](jls-6.html#jls-6.4.1)
    compile-time step 1: determine class or interface to search, [15.12.1](jls-15.html#jls-15.12.1-120-A.1)
    obscuring, [6.4.2](jls-6.html#jls-6.4.2-110)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-100)
    simple expression names, [6.5.6.1](jls-6.html#jls-6.5.6.1-100)
shadowing and obscuring, [6.4](jls-6.html#jls-6.4)
    basic for statement, [14.14.1](jls-14.html#jls-14.14.1-300)
    class body and member declarations, [8.1.6](jls-8.html#jls-8.1.6-200)
    class declarations, [8.1](jls-8.html#jls-8.1-300)
    enhanced for statement, [14.14.2](jls-14.html#jls-14.14.2-220)
    enum constants, [8.9.1](jls-8.html#jls-8.9.1-140)
    field (constant) declarations, [9.3](jls-9.html#jls-9.3-300)
    field declarations, [8.3](jls-8.html#jls-8.3-300)
    formal parameters, [8.4.1](jls-8.html#jls-8.4.1-330)
    generic classes and type parameters, [8.1.2](jls-8.html#jls-8.1.2-210)
    generic constructors, [8.8.4](jls-8.html#jls-8.8.4-200)
    import declarations, [7.5](jls-7.html#jls-7.5-200)
    interface declarations, [9.1](jls-9.html#jls-9.1-210)
    lambda parameters, [15.27.1](jls-15.html#jls-15.27.1-330)
    local class declarations, [14.3](jls-14.html#jls-14.3-300)
    local variable declarators and types, [14.4.1](jls-14.html#jls-14.4.1-220)
    member type declarations, [8.5](jls-8.html#jls-8.5-300)
    method declarations, [8.4](jls-8.html#jls-8.4-300)
    named packages, [7.4.1](jls-7.html#jls-7.4.1-200)
    top level type declarations, [7.6](jls-7.html#jls-7.6-400)
    try statement, [14.20](jls-14.html#jls-14.20-330)
    try-with-resources, [14.20.3](jls-14.html#jls-14.20.3-250)
shared variables, [17.4.1](jls-17.html#jls-17.4.1)
    happens-before order, [17.4.5](jls-17.html#jls-17.4.5-330)
    shift operators, [15.19](jls-15.html#jls-15.19)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-F)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-100-B-F)
    unary numeric promotion, [5.6.1](jls-5.html#jls-5.6.1-300-F)
simple assignment operator =, [15.26.1](jls-15.html#jls-15.26.1)
    assignment contexts, [5.2](jls-5.html#jls-5.2-500-D)
    expressions and run-time checks, [15.5](jls-15.html#jls-15.5-110-D), [15.5](jls-15.html#jls-15.5-210-C)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-I), [15.6](jls-15.html#jls-15.6-200-J)
simple expression names, [6.5.6.1](jls-6.html#jls-6.5.6.1)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-M)
    field access expressions, [15.11](jls-15.html#jls-15.11-130)
simple method names, [6.5.7.1](jls-6.html#jls-6.5.7.1)
    method declarations, [8.4](jls-8.html#jls-8.4-200)
simple package names, [6.5.3.1](jls-6.html#jls-6.5.3.1)
simple packageortypenames, [6.5.4.1](jls-6.html#jls-6.5.4.1)
simple type names, [6.5.5.1](jls-6.html#jls-6.5.5.1)
single-element annotations, [9.7.3](jls-9.html#jls-9.7.3)
    annotation type elements, [9.6.1](jls-9.html#jls-9.6.1-320)
    annotations, [9.7](jls-9.html#jls-9.7-320)
single-static-import declarations, [7.5.3](jls-7.html#jls-7.5.3)
    declarations, [6.1](jls-6.html#jls-6.1-110-C), [6.1](jls-6.html#jls-6.1-210-B)
    identify potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1-110)
    import declarations, [7.5](jls-7.html#jls-7.5-120-C)
    reclassification of contextually ambiguous names, [6.5.2](jls-6.html#jls-6.5.2-110-B), [6.5.2](jls-6.html#jls-6.5.2-110-D)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-250)
    simple method names, [6.5.7.1](jls-6.html#jls-6.5.7.1-100)
single-type-import declarations, [7.5.1](jls-7.html#jls-7.5.1-330)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-A-B)
    single-type-import declarations, [7.5.1](jls-7.html#jls-7.5.1)
    declarations, [6.1](jls-6.html#jls-6.1-110-B), [6.1](jls-6.html#jls-6.1-210-A)
    import declarations, [7.5](jls-7.html#jls-7.5-120-A)
    reclassification of contextually ambiguous names, [6.5.2](jls-6.html#jls-6.5.2-110-D)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-240)
    single-static-import declarations, [7.5.3](jls-7.html#jls-7.5.3-320)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-A-A)
sleep and yield, [17.3](jls-17.html#jls-17.3)
standalone expressions, [15.2](jls-15.html#jls-15.2)
    boolean conditional expressions, [15.25.1](jls-15.html#jls-15.25.1-100)
    choosing the most specific method, [15.12.2.5](jls-15.html#jls-15.12.2.5-310-A-D)
    class instance creation expressions, [15.9](jls-15.html#jls-15.9-500)
    conditional operator ? :, [15.25](jls-15.html#jls-15.25-300-A.1-A), [15.25](jls-15.html#jls-15.25-300-B.1-A)
    expression compatibility constraints, [18.2.1](jls-18.html#jls-18.2.1-100-B), [18.2.1](jls-18.html#jls-18.2.1-100-C)
    identify potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1-310-F)
    lambda expressions, [15.27](jls-15.html#jls-15.27-200)
    method reference expressions, [15.13](jls-15.html#jls-15.13-400)
    more specific method inference, [18.5.4](jls-18.html#jls-18.5.4-300-B.4-A-D)
    numeric conditional expressions, [15.25.2](jls-15.html#jls-15.25.2-100)
    parenthesized expressions, [15.8.5](jls-15.html#jls-15.8.5-210)
statements, [14.5](jls-14.html#jls-14.5)
static fields, [8.3.1.1](jls-8.html#jls-8.3.1.1), [13.4.10](jls-13.html#jls-13.4.10)
    generic classes and type parameters, [8.1.2](jls-8.html#jls-8.1.2-320-A)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-A), [4.12.3](jls-4.html#jls-4.12.3-100-B)
    when initialization occurs, [12.4.1](jls-12.html#jls-12.4.1-120)
static initializers, [8.7](jls-8.html#jls-8.7), [13.4.25](jls-13.html#jls-13.4.25)
    class body and member declarations, [8.1.6](jls-8.html#jls-8.1.6-110)
    definite assignment and static initializers, [16.8](jls-16.html#jls-16.8-110-A)
    exception checking, [11.2.3](jls-11.html#jls-11.2.3-120)
    final fields, [8.3.1.2](jls-8.html#jls-8.3.1.2-110)
    generic classes and type parameters, [8.1.2](jls-8.html#jls-8.1.2-320-C)
    inner classes and enclosing instances, [8.1.3](jls-8.html#jls-8.1.3-120)
    return statement, [14.17](jls-14.html#jls-14.17-200)
    simple expression names, [6.5.6.1](jls-6.html#jls-6.5.6.1-110)
    static initializers, [13.4.25](jls-13.html#jls-13.4.25-100)
    throw statement, [14.18](jls-14.html#jls-14.18-530)
static member type declarations, [8.5.1](jls-8.html#jls-8.5.1)
    anonymous class declarations, [15.9.5](jls-15.html#jls-15.9.5-130)
    class modifiers, [8.1.1](jls-8.html#jls-8.1.1-220)
    generic classes and type parameters, [8.1.2](jls-8.html#jls-8.1.2-320-A)
    interface modifiers, [9.1.1](jls-9.html#jls-9.1.1-310), [9.1.1](jls-9.html#jls-9.1.1-320)
static methods, [8.4.3.2](jls-8.html#jls-8.4.3.2), [13.4.19](jls-13.html#jls-13.4.19)
    generic classes and type parameters, [8.1.2](jls-8.html#jls-8.1.2-320-A)
    interface method declarations, [13.5.6](jls-13.html#jls-13.5.6-100)
    simple expression names, [6.5.6.1](jls-6.html#jls-6.5.6.1-110)
static-import-on-demand declarations, [7.5.4](jls-7.html#jls-7.5.4)
    declarations, [6.1](jls-6.html#jls-6.1-110-C), [6.1](jls-6.html#jls-6.1-210-C)
    identify potentially applicable methods, [15.12.2.1](jls-15.html#jls-15.12.2.1-110)
    import declarations, [7.5](jls-7.html#jls-7.5-120-D)
    reclassification of contextually ambiguous names, [6.5.2](jls-6.html#jls-6.5.2-110-B), [6.5.2](jls-6.html#jls-6.5.2-110-D)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-250)
    simple method names, [6.5.7.1](jls-6.html#jls-6.5.7.1-100)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-A-C)
    type-import-on-demand declarations, [7.5.2](jls-7.html#jls-7.5.2-310)
strictfp classes, [8.1.1.3](jls-8.html#jls-8.1.1.3)
    fp-strict expressions, [15.4](jls-15.html#jls-15.4-120)
strictfp interfaces, [9.1.1.2](jls-9.html#jls-9.1.1.2)
    fp-strict expressions, [15.4](jls-15.html#jls-15.4-120)
strictfp methods, [8.4.3.5](jls-8.html#jls-8.4.3.5)
    fp-strict expressions, [15.4](jls-15.html#jls-15.4-120)
String concatenation operator +, [15.18.1](jls-15.html#jls-15.18.1)
    boolean type and boolean values, [4.2.5](jls-4.html#jls-4.2.5-110-F)
    class String, [4.3.3](jls-4.html#jls-4.3.3-130)
    constructor declarations, [8.8](jls-8.html#jls-8.8-400)
    creation of new class instances, [12.5](jls-12.html#jls-12.5-110-C)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-100-E)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-100-E)
    normal and abrupt completion of evaluation, [15.6](jls-15.html#jls-15.6-200-A)
    objects, [4.3.1](jls-4.html#jls-4.3.1-140), [4.3.1](jls-4.html#jls-4.3.1-200-D)
    String contexts, [5.4](jls-5.html#jls-5.4-110)
    types, classes, and interfaces, [4.12.6](jls-4.html#jls-4.12.6-110)
String contexts, [5.4](jls-5.html#jls-5.4)
    boolean type and boolean values, [4.2.5](jls-4.html#jls-4.2.5-220)
String conversion, [5.1.11](jls-5.html#jls-5.1.11)
    String concatenation operator +, [15.18.1](jls-15.html#jls-15.18.1-100)
    String contexts, [5.4](jls-5.html#jls-5.4-110)
String literals, [3.10.5](jls-3.html#jls-3.10.5)
    class String, [4.3.3](jls-4.html#jls-4.3.3-120)
    comments, [3.7](jls-3.html#jls-3.7-130)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-A)
    creation of new class instances, [12.5](jls-12.html#jls-12.5-110-A)
    escape sequences for character and String literals, [3.10.6](jls-3.html#jls-3.10.6-100)
    lexical literals, [15.8.1](jls-15.html#jls-15.8.1-200-E)
    reference equality operators == and !=, [15.21.3](jls-15.html#jls-15.21.3-400)
    unicode, [3.1](jls-3.html#jls-3.1-300)
strings, [4.3.3](jls-4.html#jls-4.3.3)
    lexical literals, [15.8.1](jls-15.html#jls-15.8.1-200-E)
    literals, [3.10](jls-3.html#jls-3.10-100)
    objects, [4.3.1](jls-4.html#jls-4.3.1-140)
    String literals, [3.10.5](jls-3.html#jls-3.10.5-200), [3.10.5](jls-3.html#jls-3.10.5-400)
subsequent modification of final fields, [17.5.3](jls-17.html#jls-17.5.3)
subtyping, [4.10](jls-4.html#jls-4.10)
    assignment contexts, [5.2](jls-5.html#jls-5.2-300)
    checked casts and unchecked casts, [5.5.2](jls-5.html#jls-5.5.2-100)
    choosing the most specific method, [15.12.2.5](jls-15.html#jls-15.12.2.5-300)
    constraint formulas, [18.1.2](jls-18.html#jls-18.1.2-100-C)
    invocation contexts, [5.3](jls-5.html#jls-5.3-300)
    method throws, [8.4.6](jls-8.html#jls-8.4.6-200)
    narrowing reference conversion, [5.1.6](jls-5.html#jls-5.1.6-100-A)
    parameterized types, [4.5](jls-4.html#jls-4.5-120)
    subtyping constraints, [18.2.3](jls-18.html#jls-18.2.3-100-A)
    type arguments of parameterized types, [4.5.1](jls-4.html#jls-4.5.1-300-B), [4.5.1](jls-4.html#jls-4.5.1-400)
    widening reference conversion, [5.1.5](jls-5.html#jls-5.1.5-100)
subtyping among array types, [4.10.3](jls-4.html#jls-4.10.3)
    array types, [10.1](jls-10.html#jls-10.1-300)
subtyping among class and interface types, [4.10.2](jls-4.html#jls-4.10.2)
    try statement, [14.20](jls-14.html#jls-14.20-450)
subtyping among primitive types, [4.10.1](jls-4.html#jls-4.10.1)
subtyping constraints, [18.2.3](jls-18.html#jls-18.2.3)
superclasses and subclasses, [8.1.4](jls-8.html#jls-8.1.4)
    class members, [8.2](jls-8.html#jls-8.2-100-A)
    class Object, [4.3.2](jls-4.html#jls-4.3.2-100)
    enum types, [8.9](jls-8.html#jls-8.9-300)
    final classes, [8.1.1.2](jls-8.html#jls-8.1.1.2-200)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-B.1)
    loading process, [12.2.1](jls-12.html#jls-12.2.1-120-A)
    subtyping among class and interface types, [4.10.2](jls-4.html#jls-4.10.2-100-A)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-A)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-A), [4.11](jls-4.html#jls-4.11-300-A-A)
superclasses and superinterfaces, [13.4.4](jls-13.html#jls-13.4.4)
    loading process, [12.2.1](jls-12.html#jls-12.2.1-120-A)
    superinterfaces, [13.5.2](jls-13.html#jls-13.5.2-100)
    verification of the binary representation, [12.3.1](jls-12.html#jls-12.3.1-110-A)
superinterfaces, [8.1.5](jls-8.html#jls-8.1.5), [13.5.2](jls-13.html#jls-13.5.2)
    checked casts at run time, [5.5.3](jls-5.html#jls-5.5.3-200-B)
    class members, [8.2](jls-8.html#jls-8.2-100-B)
    subtyping among class and interface types, [4.10.2](jls-4.html#jls-4.10.2-100-B)
    superinterfaces and subinterfaces, [9.1.3](jls-9.html#jls-9.1.3-410-B)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-A)
    types, classes, and interfaces, [4.12.6](jls-4.html#jls-4.12.6-210)
    when initialization occurs, [12.4.1](jls-12.html#jls-12.4.1-110)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-A), [4.11](jls-4.html#jls-4.11-300-A-A)
superinterfaces and subinterfaces, [9.1.3](jls-9.html#jls-9.1.3)
    interface members, [9.2](jls-9.html#jls-9.2-100-B)
    loading process, [12.2.1](jls-12.html#jls-12.2.1-120-A)
    subtyping among class and interface types, [4.10.2](jls-4.html#jls-4.10.2-100-C)
    superclasses and subclasses, [8.1.4](jls-8.html#jls-8.1.4-510-B)
    superinterfaces, [8.1.5](jls-8.html#jls-8.1.5-400-B)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-B)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-B), [4.11](jls-4.html#jls-4.11-300-A-B)
switch statement, [14.11](jls-14.html#jls-14.11)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-330), [6.3](jls-6.html#jls-6.3-510)
    switch statements, [16.2.9](jls-16.html#jls-16.2.9-100-A)
switch statements, [16.2.9](jls-16.html#jls-16.2.9)
synchronization, [17.1](jls-17.html#jls-17.1)
    objects, [4.3.1](jls-4.html#jls-4.3.1-400)
    synchronized methods, [8.4.3.6](jls-8.html#jls-8.4.3.6-100)
    synchronized statement, [14.19](jls-14.html#jls-14.19-100)
    volatile fields, [8.3.1.4](jls-8.html#jls-8.3.1.4-100)
synchronization order, [17.4.4](jls-17.html#jls-17.4.4)
    actions, [17.4.2](jls-17.html#jls-17.4.2-100-C-6)
    interaction with the memory model, [12.6.2](jls-12.html#jls-12.6.2-130)
synchronized methods, [8.4.3.6](jls-8.html#jls-8.4.3.6), [13.4.20](jls-13.html#jls-13.4.20)
    class Object, [4.3.2](jls-4.html#jls-4.3.2-200-D.3)
    synchronization, [17.1](jls-17.html#jls-17.1-120)
    synchronized statement, [14.19](jls-14.html#jls-14.19-400)
synchronized statement, [14.19](jls-14.html#jls-14.19)
    create frame, synchronize, transfer control, [15.12.4.5](jls-15.html#jls-15.12.4.5-210)
    objects, [4.3.1](jls-4.html#jls-4.3.1-400)
    synchronization, [17.1](jls-17.html#jls-17.1-110)
    synchronized statements, [16.2.14](jls-16.html#jls-16.2.14-100-A)
synchronized statements, [16.2.14](jls-16.html#jls-16.2.14)
syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1)
    access control, [6.6](jls-6.html#jls-6.6-120)
    declarations, [6.1](jls-6.html#jls-6.1-220)
    reference types and values, [4.3](jls-4.html#jls-4.3-210)
syntactic grammar, [2.3](jls-2.html#jls-2.3)
    compilation units, [7.3](jls-7.html#jls-7.3-100)
    input elements and tokens, [3.5](jls-3.html#jls-3.5-120)
    lexical translations, [3.2](jls-3.html#jls-3.2-100-C)
syntax, [19](jls-19.html)

### Index T

this, [15.8.3](jls-15.html#jls-15.8.3)
    field initialization, [8.3.2](jls-8.html#jls-8.3.2-200-B), [8.3.2](jls-8.html#jls-8.3.2-300-B)
    initialization of fields in interfaces, [9.3.1](jls-9.html#jls-9.3.1-210)
    instance initializers, [8.6](jls-8.html#jls-8.6-220)
    static initializers, [8.7](jls-8.html#jls-8.7-220)
    static methods, [8.4.3.2](jls-8.html#jls-8.4.3.2-120)
threads and locks, [17](jls-17.html)
    objects, [4.3.1](jls-4.html#jls-4.3.1-400)
    throw statement, [14.18](jls-14.html#jls-14.18-100)
throw statement, [14.18](jls-14.html#jls-14.18)
    break, continue, return, and throw statements, [16.2.13](jls-16.html#jls-16.2.13-100-A)
    causes of Exceptions, [11.1.2](jls-11.html#jls-11.1.2-100-A)
    exception analysis of statements, [11.2.2](jls-11.html#jls-11.2.2-100)
    initial values of variables, [4.12.5](jls-4.html#jls-4.12.5-100-D)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-G.1)
    normal and abrupt completion of statements, [14.1](jls-14.html#jls-14.1-110-B), [14.1](jls-14.html#jls-14.1-140)
    run-time handling of an exception, [11.3](jls-11.html#jls-11.3-100)
top level type declarations, [7.6](jls-7.html#jls-7.6)
    class instance creation expressions, [15.9](jls-15.html#jls-15.9-400-A.1)
    class modifiers, [8.1.1](jls-8.html#jls-8.1.1-200)
    compilation units, [7.3](jls-7.html#jls-7.3-120-C)
    determining accessibility, [6.6.1](jls-6.html#jls-6.6.1-100-D-D)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-A-A)
    host support for packages, [7.2](jls-7.html#jls-7.2-130)
    interface modifiers, [9.1.1](jls-9.html#jls-9.1.1-320)
    package members, [7.1](jls-7.html#jls-7.1-100), [7.1](jls-7.html#jls-7.1-200)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-240), [6.3](jls-6.html#jls-6.3-250), [6.3](jls-6.html#jls-6.3-300)
    shadowing, [6.4.1](jls-6.html#jls-6.4.1-450-B)
    single-static-import declarations, [7.5.3](jls-7.html#jls-7.5.3-310)
    single-type-import declarations, [7.5.1](jls-7.html#jls-7.5.1-320)
    when initialization occurs, [12.4.1](jls-12.html#jls-12.4.1-100-E)
transient fields, [8.3.1.3](jls-8.html#jls-8.3.1.3), [13.4.11](jls-13.html#jls-13.4.11)
try statement, [14.20](jls-14.html#jls-14.20)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-G)
    compile-time checking of Exceptions, [11.2](jls-11.html#jls-11.2-210-A)
    declarations, [6.1](jls-6.html#jls-6.1-110-H-C), [6.1](jls-6.html#jls-6.1-210-M)
    definite assignment and parameters, [16.3](jls-16.html#jls-16.3-100-B)
    exception analysis of statements, [11.2.2](jls-11.html#jls-11.2.2-120)
    expressions and run-time checks, [15.5](jls-15.html#jls-15.5-110-E), [15.5](jls-15.html#jls-15.5-210-D)
    final variables, [4.12.4](jls-4.html#jls-4.12.4-400), [4.12.4](jls-4.html#jls-4.12.4-500-C)
    initial values of variables, [4.12.5](jls-4.html#jls-4.12.5-100-D)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-G)
    labeled statements, [14.7](jls-14.html#jls-14.7-220)
    method throws, [8.4.6](jls-8.html#jls-8.4.6-210)
    reclassification of contextually ambiguous names, [6.5.2](jls-6.html#jls-6.5.2-110-A)
    run-time handling of an exception, [11.3](jls-11.html#jls-11.3-100)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-550)
    shadowing and obscuring, [6.4](jls-6.html#jls-6.4-100)
    shared variables, [17.4.1](jls-17.html#jls-17.4.1-120)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-J)
    throw statement, [14.18](jls-14.html#jls-14.18-100), [14.18](jls-14.html#jls-14.18-210-B), [14.18](jls-14.html#jls-14.18-500)
    try statements, [16.2.15](jls-16.html#jls-16.2.15-100)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-J), [4.11](jls-4.html#jls-4.11-300-C-B)
try statements, [16.2.15](jls-16.html#jls-16.2.15)
try-catch statement, [14.20.1](jls-14.html#jls-14.20.1)
    try statement, [14.20](jls-14.html#jls-14.20-800)
try-catch-finally statement, [14.20.2](jls-14.html#jls-14.20.2)
    try statement, [14.20](jls-14.html#jls-14.20-800)
try-finally statement, [14.20.2](jls-14.html#jls-14.20.2)
    try statement, [14.20](jls-14.html#jls-14.20-800)
try-with-resources, [14.20.3](jls-14.html#jls-14.20.3)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-210-H)
    final variables, [4.12.4](jls-4.html#jls-4.12.4-400)
    local variable declaration statements, [14.4](jls-14.html#jls-14.4-210)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-560)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-I)
    try statement, [14.20](jls-14.html#jls-14.20-900)
    where types are used, [4.11](jls-4.html#jls-4.11-100-A-I)
try-with-resources (basic), [14.20.3.1](jls-14.html#jls-14.20.3.1)
try-with-resources (extended), [14.20.3.2](jls-14.html#jls-14.20.3.2)
type arguments of parameterized types, [4.5.1](jls-4.html#jls-4.5.1)
    capture conversion, [5.1.10](jls-5.html#jls-5.1.10-110-A)
    checked casts and unchecked casts, [5.5.2](jls-5.html#jls-5.5.2-200-B)
    class instance creation expressions, [15.9](jls-15.html#jls-15.9-200), [15.9](jls-15.html#jls-15.9-310)
    constraint formulas, [18.1.2](jls-18.html#jls-18.1.2-100-D)
    explicit constructor invocations, [8.8.7.1](jls-8.html#jls-8.8.7.1-210)
    method invocation expressions, [15.12](jls-15.html#jls-15.12-210)
    method reference expressions, [15.13](jls-15.html#jls-15.13-200)
    reference types and values, [4.3](jls-4.html#jls-4.3-200)
    reifiable types, [4.7](jls-4.html#jls-4.7-110-B)
    subtyping among class and interface types, [4.10.2](jls-4.html#jls-4.10.2-200-B)
    subtyping constraints, [18.2.3](jls-18.html#jls-18.2.3-200)
    type equality constraints, [18.2.4](jls-18.html#jls-18.2.4-200)
    types, classes, and interfaces, [4.12.6](jls-4.html#jls-4.12.6-310-B)
    unchecked conversion, [5.1.9](jls-5.html#jls-5.1.9-200)
    where types are used, [4.11](jls-4.html#jls-4.11-120-A)
type comparison operator instanceof, [15.20.2](jls-15.html#jls-15.20.2)
    expressions and run-time checks, [15.5](jls-15.html#jls-15.5-110-B)
    objects, [4.3.1](jls-4.html#jls-4.3.1-200-E)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B-O)
    where types are used, [4.11](jls-4.html#jls-4.11-100-B-E), [4.11](jls-4.html#jls-4.11-300-B-B)
type compatibility constraints, [18.2.2](jls-18.html#jls-18.2.2)
type equality constraints, [18.2.4](jls-18.html#jls-18.2.4)
type erasure, [4.6](jls-4.html#jls-4.6)
    assignment contexts, [5.2](jls-5.html#jls-5.2-500-A)
    cast expressions, [15.16](jls-15.html#jls-15.16-200-B)
    checked casts and unchecked casts, [5.5.2](jls-5.html#jls-5.5.2-700-E.1)
    checked casts at run time, [5.5.3](jls-5.html#jls-5.5.3-100)
    choosing the most specific method, [15.12.2.5](jls-15.html#jls-15.12.2.5-530-A-B)
    class Object, [4.3.2](jls-4.html#jls-4.3.2-200-D.2)
    class type parameters, [13.4.5](jls-13.html#jls-13.4.5-130)
    compile-time step 3: is the chosen method appropriate?, [15.12.3](jls-15.html#jls-15.12.3-400-B-B-B)
    constructor Signature, [8.8.2](jls-8.html#jls-8.8.2-110)
    create frame, synchronize, transfer control, [15.12.4.5](jls-15.html#jls-15.12.4.5-130)
    declarations, [6.1](jls-6.html#jls-6.1-200-B-A)
    evaluate arguments, [15.12.4.2](jls-15.html#jls-15.12.4.2-200)
    field declarations, [13.4.8](jls-13.html#jls-13.4.8-400)
    form of a binary, [13.1](jls-13.html#jls-13.1-110-D.1), [13.1](jls-13.html#jls-13.1-110-E.1), [13.1](jls-13.html#jls-13.1-110-F.1)
    invocation contexts, [5.3](jls-5.html#jls-5.3-500-A)
    method and constructor formal parameters, [13.4.14](jls-13.html#jls-13.4.14-130)
    method and constructor type parameters, [13.4.13](jls-13.html#jls-13.4.13-130)
    method invocation type, [15.12.2.6](jls-15.html#jls-15.12.2.6-100-C-B)
    method result type, [13.4.15](jls-13.html#jls-13.4.15-110)
    method Signature, [8.4.2](jls-8.html#jls-8.4.2-120-B)
    raw types, [4.8](jls-4.html#jls-4.8-100)
    requirements in overriding and hiding, [8.4.8.3](jls-8.html#jls-8.4.8.3-210-B)
    type variables, [4.4](jls-4.html#jls-4.4-220)
type inference, [18](jls-18.html)
    compile-time step 2: determine method Signature, [15.12.2](jls-15.html#jls-15.12.2-220)
    generic constructors, [8.8.4](jls-8.html#jls-8.8.4-130)
    generic methods, [8.4.4](jls-8.html#jls-8.4.4-120)
type of a constructor, [8.8.6](jls-8.html#jls-8.8.6)
    members and constructors of parameterized types, [4.5.2](jls-4.html#jls-4.5.2-100-A)
type of a lambda expression, [15.27.3](jls-15.html#jls-15.27.3)
    checked exception constraints, [18.2.5](jls-18.html#jls-18.2.5-100-B)
    expression compatibility constraints, [18.2.1](jls-18.html#jls-18.2.1-200-B)
    invocation type inference, [18.5.2](jls-18.html#jls-18.5.2-200-A-B), [18.5.2](jls-18.html#jls-18.5.2-200-B-B)
    lambda parameters, [15.27.1](jls-15.html#jls-15.27.1-130)
type of a method reference, [15.13.2](jls-15.html#jls-15.13.2)
    checked exception constraints, [18.2.5](jls-18.html#jls-18.2.5-200-D)
type of an expression, [15.3](jls-15.html#jls-15.3)
    type variables, [4.4](jls-4.html#jls-4.4)
    class literals, [15.8.2](jls-15.html#jls-15.8.2-300)
    field declarations, [13.4.8](jls-13.html#jls-13.4.8-400)
    generic classes and type parameters, [8.1.2](jls-8.html#jls-8.1.2-100)
    generic constructors, [8.8.4](jls-8.html#jls-8.8.4-100)
    generic interfaces and type parameters, [9.1.2](jls-9.html#jls-9.1.2-100)
    generic methods, [8.4.4](jls-8.html#jls-8.4.4-100)
    intersection types, [4.9](jls-4.html#jls-4.9-110)
    method and constructor formal parameters, [13.4.14](jls-13.html#jls-13.4.14-130)
    method result type, [13.4.15](jls-13.html#jls-13.4.15-110)
    reference types and values, [4.3](jls-4.html#jls-4.3-100)
    type erasure, [4.6](jls-4.html#jls-4.6-100-D)
    types, classes, and interfaces, [4.12.6](jls-4.html#jls-4.12.6-310-B)
    where types are used, [4.11](jls-4.html#jls-4.11-200-B)
type-import-on-demand declarations, [7.5.2](jls-7.html#jls-7.5.2)
    declarations, [6.1](jls-6.html#jls-6.1-110-B)
    import declarations, [7.5](jls-7.html#jls-7.5-120-B)
    reclassification of contextually ambiguous names, [6.5.2](jls-6.html#jls-6.5.2-110-D)
    scope of a declaration, [6.3](jls-6.html#jls-6.3-240)
    shadowing, [6.4.1](jls-6.html#jls-6.4.1-450-C)
    static-import-on-demand declarations, [7.5.4](jls-7.html#jls-7.5.4-330)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-140-B)
types, [4.1](jls-4.html#jls-4.1)
    capture conversion, [5.1.10](jls-5.html#jls-5.1.10-110-A)
    lexical literals, [15.8.1](jls-15.html#jls-15.8.1-200-F)
    literals, [3.10](jls-3.html#jls-3.10-100)
    null literal, [3.10.7](jls-3.html#jls-3.10.7-120)
    throw statement, [14.18](jls-14.html#jls-14.18-210-A)
types, classes, and interfaces, [4.12.6](jls-4.html#jls-4.12.6)
types, values, and variables, [4](jls-4.html)

### Index U

unary minus operator -, [15.15.4](jls-15.html#jls-15.15.4)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-C)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-100-B-A)
    integer literals, [3.10.1](jls-3.html#jls-3.10.1-710), [3.10.1](jls-3.html#jls-3.10.1-810)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-100-B-A)
    unary numeric promotion, [5.6.1](jls-5.html#jls-5.6.1-300-D)
unary numeric promotion, [5.6.1](jls-5.html#jls-5.6.1)
    array access, [10.4](jls-10.html#jls-10.4-120)
    array access expressions, [15.10.3](jls-15.html#jls-15.10.3-210)
    array creation expressions, [15.10.1](jls-15.html#jls-15.10.1-220)
    bitwise complement operator ~, [15.15.5](jls-15.html#jls-15.15.5-110)
    numeric contexts, [5.6](jls-5.html#jls-5.6-300)
    shift operators, [15.19](jls-15.html#jls-15.19-200)
    unary minus operator -, [15.15.4](jls-15.html#jls-15.15.4-110)
    unary plus operator +, [15.15.3](jls-15.html#jls-15.15.3-110)
unary operators, [15.15](jls-15.html#jls-15.15)
    final variables, [4.12.4](jls-4.html#jls-4.12.4-500-A-C)
unary plus operator +, [15.15.3](jls-15.html#jls-15.15.3)
    constant expressions, [15.28](jls-15.html#jls-15.28-110-C)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-100-B-A)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-100-B-A)
    unary numeric promotion, [5.6.1](jls-5.html#jls-5.6.1-300-C)
unboxing conversion, [5.1.8](jls-5.html#jls-5.1.8)
    additive operators, [15.18](jls-15.html#jls-15.18-210), [15.18](jls-15.html#jls-15.18-300)
    array creation expressions, [15.10.1](jls-15.html#jls-15.10.1-210)
    assert statement, [14.10](jls-14.html#jls-14.10-410)
    assignment contexts, [5.2](jls-5.html#jls-5.2-110-E)
    binary numeric promotion, [5.6.2](jls-5.html#jls-5.6.2-100-A)
    bitwise complement operator ~, [15.15.5](jls-15.html#jls-15.15.5-100)
    boolean equality operators == and !=, [15.21.2](jls-15.html#jls-15.21.2-200)
    boolean logical operators &, ^, and |, [15.22.2](jls-15.html#jls-15.22.2-100)
    casting contexts, [5.5](jls-5.html#jls-5.5-110-E), [5.5](jls-5.html#jls-5.5-110-F), [5.5](jls-5.html#jls-5.5-110-H)
    conditional operator ? :, [15.25](jls-15.html#jls-15.25-300-B.1-A), [15.25](jls-15.html#jls-15.25-530)
    conditional-and operator &&, [15.23](jls-15.html#jls-15.23-400), [15.23](jls-15.html#jls-15.23-420)
    conditional-or operator ||, [15.24](jls-15.html#jls-15.24-400), [15.24](jls-15.html#jls-15.24-420)
    do statement, [14.13](jls-14.html#jls-14.13-300-A)
    equality operators, [15.21](jls-15.html#jls-15.21-200)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-370-A)
    if-then statement, [14.9.1](jls-14.html#jls-14.9.1-100)
    if-then-else statement, [14.9.2](jls-14.html#jls-14.9.2-100)
    integer bitwise operators &, ^, and |, [15.22.1](jls-15.html#jls-15.22.1-100)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-310-A)
    invocation contexts, [5.3](jls-5.html#jls-5.3-210-E)
    iteration of for statement, [14.14.1.2](jls-14.html#jls-14.14.1.2-100-A)
    logical complement operator !, [15.15.6](jls-15.html#jls-15.15.6-200)
    multiplicative operators, [15.17](jls-15.html#jls-15.17-200)
    numeric contexts, [5.6](jls-5.html#jls-5.6-110-C)
    numerical comparison operators <, <=, >, and >=, [15.20.1](jls-15.html#jls-15.20.1-100)
    numerical equality operators == and !=, [15.21.1](jls-15.html#jls-15.21.1-100)
    postfix decrement operator --, [15.14.3](jls-15.html#jls-15.14.3-120)
    postfix increment operator ++, [15.14.2](jls-15.html#jls-15.14.2-120)
    prefix decrement operator --, [15.15.2](jls-15.html#jls-15.15.2-110)
    prefix increment operator ++, [15.15.1](jls-15.html#jls-15.15.1-110)
    switch statement, [14.11](jls-14.html#jls-14.11-400)
    unary minus operator -, [15.15.4](jls-15.html#jls-15.15.4-100)
    unary numeric promotion, [5.6.1](jls-5.html#jls-5.6.1-100-A), [5.6.1](jls-5.html#jls-5.6.1-100-B)
    unary plus operator +, [15.15.3](jls-15.html#jls-15.15.3-100)
    while statement, [14.12](jls-14.html#jls-14.12-300)
unchecked conversion, [5.1.9](jls-5.html#jls-5.1.9)
    @SafeVarargs, [9.6.4.7](jls-9.html#jls-9.6.4.7-100)
    assignment contexts, [5.2](jls-5.html#jls-5.2-120)
    casting contexts, [5.5](jls-5.html#jls-5.5-110-E), [5.5](jls-5.html#jls-5.5-110-F)
    invocation contexts, [5.3](jls-5.html#jls-5.3-220)
    method result, [8.4.5](jls-8.html#jls-8.4.5-210-C-B)
    type compatibility constraints, [18.2.2](jls-18.html#jls-18.2.2-110)
    variables of reference type, [4.12.2](jls-4.html#jls-4.12.2-310)
unicode, [3.1](jls-3.html#jls-3.1)
    character literals, [3.10.4](jls-3.html#jls-3.10.4-120)
    lexical grammar, [2.2](jls-2.html#jls-2.2-100)
    primitive types and values, [4.2](jls-4.html#jls-4.2-210)
    unicode escapes, [3.3](jls-3.html#jls-3.3-100)
unicode escapes, [3.3](jls-3.html#jls-3.3)
    escape sequences for character and String literals, [3.10.6](jls-3.html#jls-3.10.6-200)
    input elements and tokens, [3.5](jls-3.html#jls-3.5-100)
    lexical translations, [3.2](jls-3.html#jls-3.2-100-A)
    unicode, [3.1](jls-3.html#jls-3.1-300)
unloading of classes and interfaces, [12.7](jls-12.html#jls-12.7)
    kinds of variables, [4.12.3](jls-4.html#jls-4.12.3-100-A.1)
unnamed packages, [7.4.2](jls-7.html#jls-7.4.2)
    compilation units, [7.3](jls-7.html#jls-7.3-120-A.1)
unreachable statements, [14.21](jls-14.html#jls-14.21)
    final fields and static constant variables, [13.4.9](jls-13.html#jls-13.4.9-300)
    instance initializers, [8.6](jls-8.html#jls-8.6-200)
    lambda body, [15.27.2](jls-15.html#jls-15.27.2-210)
    static initializers, [8.7](jls-8.html#jls-8.7-200)
uses of inference, [18.5](jls-18.html#jls-18.5)

### Index V

value set conversion, [5.1.13](jls-5.html#jls-5.1.13)
    assignment contexts, [5.2](jls-5.html#jls-5.2-400)
    binary numeric promotion, [5.6.2](jls-5.html#jls-5.6.2-200)
    casting contexts, [5.5](jls-5.html#jls-5.5-120)
    compound assignment operators, [15.26.2](jls-15.html#jls-15.26.2-300-D), [15.26.2](jls-15.html#jls-15.26.2-400-F-A.3)
    create frame, synchronize, transfer control, [15.12.4.5](jls-15.html#jls-15.12.4.5-120)
    evaluation, denotation, and result, [15.1](jls-15.html#jls-15.1-120)
    floating-point types, formats, and values, [4.2.3](jls-4.html#jls-4.2.3-120)
    fp-strict expressions, [15.4](jls-15.html#jls-15.4-100)
    invocation contexts, [5.3](jls-5.html#jls-5.3-400)
    simple assignment operator =, [15.26.1](jls-15.html#jls-15.26.1-400-F.1-A.1), [15.26.1](jls-15.html#jls-15.26.1-500-C)
    unary minus operator -, [15.15.4](jls-15.html#jls-15.15.4-130)
    unary numeric promotion, [5.6.1](jls-5.html#jls-5.6.1-200)
variables, [4.12](jls-4.html#jls-4.12)
    evaluation, denotation, and result, [15.1](jls-15.html#jls-15.1-100-A)
variables of primitive type, [4.12.1](jls-4.html#jls-4.12.1)
variables of reference type, [4.12.2](jls-4.html#jls-4.12.2)
    @SafeVarargs, [9.6.4.7](jls-9.html#jls-9.6.4.7-100)
    type of an expression, [15.3](jls-15.html#jls-15.3-110)
    variables, [4.12](jls-4.html#jls-4.12-120)
verification of the binary representation, [12.3.1](jls-12.html#jls-12.3.1)
    link test: verify, prepare, (optionally) resolve, [12.1.2](jls-12.html#jls-12.1.2-110)
volatile fields, [8.3.1.4](jls-8.html#jls-8.3.1.4)
    happens-before order, [17.4.5](jls-17.html#jls-17.4.5-320-B)
    synchronization order, [17.4.4](jls-17.html#jls-17.4.4-110-B)

### Index W

wait, [17.2.1](jls-17.html#jls-17.2.1)
    happens-before order, [17.4.5](jls-17.html#jls-17.4.5-120)
wait sets and notification, [17.2](jls-17.html#jls-17.2)
    class Object, [4.3.2](jls-4.html#jls-4.3.2-200-F)
well-formed executions, [17.4.7](jls-17.html#jls-17.4.7)
    executions, [17.4.6](jls-17.html#jls-17.4.6-110)
what binary compatibility is and is not, [13.2](jls-13.html#jls-13.2)
when initialization occurs, [12.4.1](jls-12.html#jls-12.4.1)
    final variables, [4.12.4](jls-4.html#jls-4.12.4-300)
    initialize test: execute initializers, [12.1.3](jls-12.html#jls-12.1.3-100)
when reference types are the same, [4.3.4](jls-4.html#jls-4.3.4)
    checked casts at run time, [5.5.3](jls-5.html#jls-5.5.3-200-A)
    constraint formulas, [18.1.2](jls-18.html#jls-18.1.2-100-E)
    type equality constraints, [18.2.4](jls-18.html#jls-18.2.4-100-A)
where annotations may appear, [9.7.4](jls-9.html#jls-9.7.4)
    annotation types, [9.6](jls-9.html#jls-9.6-120)
    annotations, [9.7](jls-9.html#jls-9.7-320)
    array types, [10.1](jls-10.html#jls-10.1-120)
    class modifiers, [8.1.1](jls-8.html#jls-8.1.1-120)
    constructor modifiers, [8.8.3](jls-8.html#jls-8.8.3-110)
    enum constants, [8.9.1](jls-8.html#jls-8.9.1-120)
    field (constant) declarations, [9.3](jls-9.html#jls-9.3-110)
    field modifiers, [8.3.1](jls-8.html#jls-8.3.1-110)
    formal parameters, [8.4.1](jls-8.html#jls-8.4.1-300)
    generic classes and type parameters, [8.1.2](jls-8.html#jls-8.1.2-130)
    generic interfaces and type parameters, [9.1.2](jls-9.html#jls-9.1.2-120)
    interface modifiers, [9.1.1](jls-9.html#jls-9.1.1-200)
    lambda parameters, [15.27.1](jls-15.html#jls-15.27.1-300)
    local variable declaration statements, [14.4](jls-14.html#jls-14.4-300)
    method declarations, [9.4](jls-9.html#jls-9.4-110)
    method modifiers, [8.4.3](jls-8.html#jls-8.4.3-110)
    named packages, [7.4.1](jls-7.html#jls-7.4.1-300)
where types are used, [4.11](jls-4.html#jls-4.11)
    @Target, [9.6.4.1](jls-9.html#jls-9.6.4.1-220)
    lexical translations, [3.2](jls-3.html#jls-3.2-110)
    syntactic classification of a name according to context, [6.5.1](jls-6.html#jls-6.5.1-110-B)
    where annotations may appear, [9.7.4](jls-9.html#jls-9.7.4-110)
while statement, [14.12](jls-14.html#jls-14.12)
    boolean type and boolean values, [4.2.5](jls-4.html#jls-4.2.5-120-B)
    while statements, [16.2.10](jls-16.html#jls-16.2.10-100-A)
while statements, [16.2.10](jls-16.html#jls-16.2.10)
white space, [3.6](jls-3.html#jls-3.6)
    input elements and tokens, [3.5](jls-3.html#jls-3.5-130)
    lexical grammar, [2.2](jls-2.html#jls-2.2-110)
    lexical translations, [3.2](jls-3.html#jls-3.2-100-C)
widening and narrowing primitive conversion, [5.1.4](jls-5.html#jls-5.1.4)
    casting contexts, [5.5](jls-5.html#jls-5.5-110-D)
widening primitive conversion, [5.1.2](jls-5.html#jls-5.1.2)
    assignment contexts, [5.2](jls-5.html#jls-5.2-110-B)
    binary numeric promotion, [5.6.2](jls-5.html#jls-5.6.2-100-B)
    casting contexts, [5.5](jls-5.html#jls-5.5-110-B), [5.5](jls-5.html#jls-5.5-110-H)
    invocation contexts, [5.3](jls-5.html#jls-5.3-200-B), [5.3](jls-5.html#jls-5.3-210-B)
    numeric contexts, [5.6](jls-5.html#jls-5.6-110-B)
    unary numeric promotion, [5.6.1](jls-5.html#jls-5.6.1-100-A), [5.6.1](jls-5.html#jls-5.6.1-100-C)
    widening and narrowing primitive conversion, [5.1.4](jls-5.html#jls-5.1.4-200)
widening reference conversion, [5.1.5](jls-5.html#jls-5.1.5)
    assignment contexts, [5.2](jls-5.html#jls-5.2-110-C)
    casting contexts, [5.5](jls-5.html#jls-5.5-110-E), [5.5](jls-5.html#jls-5.5-110-G)
    floating-point operations, [4.2.4](jls-4.html#jls-4.2.4-210)
    integer operations, [4.2.2](jls-4.html#jls-4.2.2-200)
    invocation contexts, [5.3](jls-5.html#jls-5.3-200-C), [5.3](jls-5.html#jls-5.3-210-C)
word tearing, [17.6](jls-17.html#jls-17.6)
write-protected fields, [17.5.4](jls-17.html#jls-17.5.4)

üçÄ Appendix A. Limited License Grant
---------------------------------

Specification: JSR-337 Java¬Æ SE 8 Release Contents ("Specification")  
Version: 8  
Status: Maintenance Release  
Release: March 2015  
  
Copyright ¬© 1997, 2015, Oracle America, Inc. and/or its affiliates.  
500 Oracle Parkway, Redwood City, California 94065, U.S.A.  
All rights reserved.

LIMITED LICENSE GRANTS

1\. License for Evaluation Purposes. Oracle hereby grants you a fully-paid, non-exclusive, non-transferable, worldwide, limited license (without the right to sublicense), under Oracle's applicable intellectual property rights to view, download, use and reproduce the Specification only for the purpose of internal evaluation. This includes (i) developing applications intended to run on an implementation of the Specification, provided that such applications do not themselves implement any portion(s) of the Specification, and (ii) discussing the Specification with any third party; and (iii) excerpting brief portions of the Specification in oral or written communications which discuss the Specification provided that such excerpts do not in the aggregate constitute a significant portion of the Specification.

2\. License for the Distribution of Compliant Implementations. Oracle also grants you a perpetual, non-exclusive, non-transferable, worldwide, fully paid-up, royalty free, limited license (without the right to sublicense) under any applicable copyrights or, subject to the provisions of subsection 4 below, patent rights it may have covering the Specification to create and/or distribute an Independent Implementation of the Specification that: (a) fully implements the Specification including all its required interfaces and functionality; (b) does not modify, subset, superset or otherwise extend the Licensor Name Space, or include any public or protected packages, classes, Java interfaces, fields or methods within the Licensor Name Space other than those required/authorized by the Specification or Specifications being implemented; and (c) passes the Technology Compatibility Kit (including satisfying the requirements of the applicable TCK Users Guide) for such Specification ("Compliant Implementation"). In addition, the foregoing license is expressly conditioned on your not acting outside its scope. No license is granted hereunder for any other purpose (including, for example, modifying the Specification, other than to the extent of your fair use rights, or distributing the Specification to third parties). Also, no right, title, or interest in or to any trademarks, service marks, or trade names of Oracle or Oracle's licensors is granted hereunder. Java, and Java-related logos, marks and names are trademarks or registered trademarks of Oracle in the U.S. and other countries.

3\. Pass-through Conditions. You need not include limitations (a)-(c) from the previous paragraph or any other particular "pass through" requirements in any license You grant concerning the use of your Independent Implementation or products derived from it. However, except with respect to Independent Implementations (and products derived from them) that satisfy limitations (a)-(c) from the previous paragraph, You may neither: (a) grant or otherwise pass through to your licensees any licenses under Oracle's applicable intellectual property rights; nor (b) authorize your licensees to make any claims concerning their implementation's compliance with the Specification in question.

4\. Reciprocity Concerning Patent Licenses.

a. With respect to any patent claims covered by the license granted under subparagraph 2 above that would be infringed by all technically feasible implementations of the Specification, such license is conditioned upon your offering on fair, reasonable and non-discriminatory terms, to any party seeking it from You, a perpetual, non-exclusive, non-transferable, worldwide license under Your patent rights which are or would be infringed by all technically feasible implementations of the Specification to develop, distribute and use a Compliant Implementation.

b. With respect to any patent claims owned by Oracle and covered by the license granted under subparagraph 2, whether or not their infringement can be avoided in a technically feasible manner when implementing the Specification, such license shall terminate with respect to such claims if You initiate a claim against Oracle that it has, in the course of performing its responsibilities as the Specification Lead, induced any other entity to infringe Your patent rights.

c. Also with respect to any patent claims owned by Oracle and covered by the license granted under subparagraph 2 above, where the infringement of such claims can be avoided in a technically feasible manner when implementing the Specification such license, with respect to such claims, shall terminate if You initiate a claim against Oracle that its making, having made, using, offering to sell, selling or importing a Compliant Implementation infringes Your patent rights.

5\. Definitions. For the purposes of this Agreement: "Independent Implementation" shall mean an implementation of the Specification that neither derives from any of Oracle's source code or binary code materials nor, except with an appropriate and separate license from Oracle, includes any of Oracle's source code or binary code materials; "Licensor Name Space" shall mean the public class or interface declarations whose names begin with "java", "javax", "com.sun" or their equivalents in any subsequent naming convention adopted by Oracle through the Java Community Process, or any recognized successors or replacements thereof; and "Technology Compatibility Kit" or "TCK" shall mean the test suite and accompanying TCK User's Guide provided by Oracle which corresponds to the Specification and that was available either (i) from Oracle 120 days before the first release of Your Independent Implementation that allows its use for commercial purposes, or (ii) more recently than 120 days from such release but against which You elect to test Your implementation of the Specification.

This Agreement will terminate immediately without notice from Oracle if you breach the Agreement or act outside the scope of the licenses granted above.

DISCLAIMER OF WARRANTIES

THE SPECIFICATION IS PROVIDED "AS IS". ORACLE MAKES NO REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT (INCLUDING AS A CONSEQUENCE OF ANY PRACTICE OR IMPLEMENTATION OF THE SPECIFICATION), OR THAT THE CONTENTS OF THE SPECIFICATION ARE SUITABLE FOR ANY PURPOSE. This document does not represent any commitment to release or implement any portion of the Specification in any product. In addition, the Specification could include technical inaccuracies or typographical errors.

LIMITATION OF LIABILITY

TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL ORACLE OR ITS LICENSORS BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION, LOST REVENUE, PROFITS OR DATA, OR FOR SPECIAL, INDIRECT, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF OR RELATED IN ANY WAY TO YOUR HAVING, IMPLEMENTING OR OTHERWISE USING THE SPECIFICATION, EVEN IF ORACLE AND/OR ITS LICENSORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

You will indemnify, hold harmless, and defend Oracle and its licensors from any claims arising or resulting from: (i) your use of the Specification; (ii) the use or distribution of your Java application, applet and/or implementation; and/or (iii) any claims that later versions or releases of any Specification furnished to you are incompatible with the Specification provided to you under this license.

RESTRICTED RIGHTS LEGEND

U.S. Government: If this Specification is being acquired by or on behalf of the U.S. Government or by a U.S. Government prime contractor or subcontractor (at any tier), then the Government's rights in the Software and accompanying documentation shall be only as set forth in this license; this is in accordance with 48 C.F.R. 227.7201 through 227.7202-4 (for Department of Defense (DoD) acquisitions) and with 48 C.F.R. 2.101 and 12.212 (for non-DoD acquisitions).

REPORT

If you provide Oracle with any comments or suggestions concerning the Specification ("Feedback"), you hereby: (i) agree that such Feedback is provided on a non-proprietary and non-confidential basis, and (ii) grant Oracle a perpetual, non-exclusive, worldwide, fully paid-up, irrevocable license, with the right to sublicense through multiple levels of sublicensees, to incorporate, disclose, and use without limitation the Feedback for any purpose.

GENERAL TERMS

Any action related to this Agreement will be governed by California law and controlling U.S. federal law. The U.N. Convention for the International Sale of Goods and the choice of law rules of any jurisdiction will not apply.

The Specification is subject to U.S. export control laws and may be subject to export or import regulations in other countries. Licensee agrees to comply strictly with all such laws and regulations and acknowledges that it has the responsibility to obtain such licenses to export, re-export or import as may be required after delivery to Licensee.

This Agreement is the parties' entire agreement relating to its subject matter. It supersedes all prior or contemporaneous oral or written communications, proposals, conditions, representations and warranties and prevails over any conflicting or additional terms of any quote, order, acknowledgment, or other communication between the parties relating to its subject matter during the term of this Agreement. No modification to this Agreement will be binding, unless in writing and signed by an authorized representative of each party.
