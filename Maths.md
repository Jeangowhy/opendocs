
# 词汇

infinity and infinitesimal 无穷大和无穷小

https://bisqwit.iki.fi/jutut/typography.html
ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ΢ΣΤΥΦΧΨΩ
αβγδεζηθικλμνξοπρςστυφχψω
𝔸𝔹ℂⅅ𝔼ℍ𝕀𝕁𝕂𝕃𝕄ℕℙℚℝ𝕐𝕍𝕏ℤ ⅆⅇⅈⅉ 𝕠𝕡𝕢𝕣𝕤𝕥𝕦𝕧𝕨𝕩𝕪𝕫
ℽℼℾℿ⅀ ℯ
∫ ∬ ∭ √ ∛ ∂ ≈ ≃ ≠ ≡ · − ∑ ∏ ∞ ∘ ⌈ ⌉ ⌊ ⌋ ∎
∩ ∪ ∁ ∈ ∉ ⊂ ⊆ ⊊ ∖ ⊔ ∅
∧ ∨ ¬ ⊻ ∀ ∃ ∣∤∥∦
→ ↔ ⊤(always true)
⇒ ⇔ ⊥(always false / perpendicular)
a⃗ b⃗ c⃗ d⃗ e⃗ f⃗ g⃗ h⃗ i⃗ j⃗ k⃗ l⃗ m⃗ n⃗ o⃗ p⃗ q⃗ r⃗ s⃗ t⃗ u⃗ v⃗ w⃗ x⃗ y⃗ z⃗ ω⃗
A⃗ B⃗ C⃗ D⃗ E⃗ F⃗ G⃗ H⃗ I⃗ J⃗ K⃗ L⃗ M⃗ N⃗ O⃗ P⃗ Q⃗ R⃗ S⃗ T⃗ U⃗ V⃗ W⃗ X⃗ Y⃗ Z⃗ φ⃗
â b̂ ĉ d̂ ê f̂ ĝ ĥ î ĵ k̂ l̂ m̂ n̂ ô p̂ q̂ r̂ ŝ t̂ û v̂ ŵ x̂ ŷ ẑ ŵ
Â B̂ Ĉ D̂ Ê F̂ Ĝ Ĥ Î Ĵ K̂ L̂ M̂ N̂ Ô P̂ Q̂ R̂ Ŝ T̂ Û V̂ Ŵ X̂ Ŷ Ẑ φ̂
ā b̄ c̄ d̄ ē f̄ ḡ h̄ ī j̄ k̄ l̄ m̄ n̄ ō p̄ q̄ r̄ s̄ t̄ ū v̄ w̄ x̄ ȳ z̄
Ā B̄ C̄ D̄ Ē F̄ Ḡ H̄ Ī J̄ K̄ L̄ M̄ N̄ Ō P̄ Q̄ R̄ S̄ T̄ Ū V̄ W̄ X̄ Ȳ Z̄
Combining right arrow: ⃗
Combining left arrow: ⃖
Combining macron: ̄
Combining circumflex: ̂

SUP ⁽⁰¹²³⁴⁵⁶⁷⁸⁹⁺⁻⁼⁾    ᴬᴮꟲᴰᴱꟳᴳᴴᴵᴶᴷᴸᴹᴺᴼᴾꟴᴿᵀᵁⱽᵂ
SUP ᵝᵞᵟᵋᶿᶥᶹᵠᵡ             ᵃᵇᶜᵈᵉᶠᵍʰⁱʲᵏˡᵐⁿᵒᵖ𐞥ʳˢᵗᵘᵛʷˣʸᶻ
SUB ₍₀₁₂₃₄₅₆₇₈₉₊₋₌₎⏨ ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ
ᵈ⁄ₔₓ ⅟ₙ ½ ⅓ ¼ ⅕ ⅙ ⅐ ⅛ ⅑ ⅒
↉ ⅔ ⅖ ¾ ⅗ ⅜ ⅘ ⅚ ⅝ ⅞ ↉ ℀ ℁ ℅ ℆ ⅍ ℃


# 人物

战国时代，人称墨子的墨翟便已然达成了“不会打仗的政客不是好科学家”这项成就。除开兼爱非攻尚贤尚同的核心思想，墨家在自然科学以及逻辑学上都有深厚造诣，可算是中国诸多哲学流派中的奇葩。且看墨家对圆的定义：圆，一中同长也。多么微言大义！比“平面上到定点的距离等于定长的点的集合”好背多了好吧！

墨子曾经试图发明飞行器具。《韩非子·外储说左上》曾记载“墨子为木鸢，三年而成，蜚一日而败。”而他的老对手公输班也曾经造出过类似器具，《墨子·鲁问》中说“公输子削竹木以为鹊，成而飞之，三日不下。”可惜曾与儒道并称的墨家却在汉代以后因不能适应社会变革而销声匿迹，其地位被外来的佛教也就是释家取而代之，如今已经没有多少人还知晓墨家学说的精要了。


# 毕达哥拉斯定理(公元前530年)

这是所有几何知识的基础之一：在直角三角形中，斜边的平方(直角的对边)等于另外两个直角边的平方和。这个理论通常被认为是希腊数学家毕达哥拉斯提出的，尽管有证据表明巴比伦数学家理解这个公式。这个定理也有可能为许多人所知，但他是第一个证明它的人。

公元前十一世纪，周朝数学家商高就提出“勾三、股四、弦五”，《周髀算经》中记录。公元三世纪，三国时代的赵爽对《周髀算经》内的勾股定理作出了详细注释，记录于
《九章算术》中，赵爽描述的勾股方圆图：“勾股各自乘，并之为玄实。开方除之，即玄。案玄图有可以勾股相乘为朱实二，倍之为朱实四。以勾股之差自相乘为中黄实。加差实亦成玄实。以差实减玄实，半其余。以差为从法，开方除之，复得勾矣。加差于勾即股。凡并勾股之实，即成玄实。或矩于内，或方于外。形诡而量均，体殊而数齐。勾实之矩以股玄差为广，股玄并为袤...

中王朝时期的古埃及纸莎草上记载了一组勾股数，6、8和10。中王朝是什么时候呢？大约在公元前二十世纪与十八世纪间，搁在中国是在夏朝。夏朝是中国有记载的第一个朝代。埃及中王朝之前还有古王朝，大约在公元前二十七世纪到前二十一世纪间，吉萨金字塔和狮身人面像都是那个时候修建的。那个时候黄帝和炎帝不知道打没打阪泉之战。而在公元前两千年的巴比伦，人们已经发现了众多的勾股数。

哪个文明首先发现勾股定理，并不能证明它就比其他文明要来得优越。最早记录勾股数的古埃及，被希腊、罗马、阿拉伯等更强大的文明反复征服蹂躏，辉煌的古埃及神学系统土崩瓦解消失于历史中，本土产生的象形文字萎缩为只有极少数人说的科普特语，到了近代更是国祚衰弱，被欧洲列国随意掠走文物典籍。

# Complex 复数 
- [Imaginary Numbers](https://www.mathsisfun.com/numbers/imaginary-numbers.html)
- [Complex Plane](https://www.mathsisfun.com/algebra/complex-plane.html)
- [Imaginary Multiplication vs. Imaginary Exponents](https://betterexplained.com/articles/imaginary-multiplication-exponents/)
- [A Visual, Intuitive Guide to Imaginary Numbers](https://betterexplained.com/articles/a-visual-intuitive-guide-to-imaginary-numbers/)
- [「不可能的数字：复数」-图解数学](http://www.360doc.com/content/18/0226/05/682382_732489225.shtml)
- [最“美丽”和“重要”的数学方程](https://baijiahao.baidu.com/s?id=1618724553545630119)
- [世界上第一个提出“复数”概念的人是谁？](https://baijiahao.baidu.com/s?id=1578593530048808943)

数学似乎和所有人开玩笑：当你认为有理数域完备的时候，你发现-1不能开方，所以不得不定义”i^2=-1”。意大利数学家吉罗拉莫·卡达诺(Gerolamo Cardano)是第一个引入复数的人，当时他称复数为虚构的数。然而，i 作为代表-1平方根的虚数的数学发展归功于莱昂哈德·欧拉（Leonhard Euler），他是人类历史上最重要的数学家和科学家之一。

复数基本上是不存在的数，但是对于一些计算非常有用。它们由实数部分(我们都知道的数)和虚数部分(我在这里表示)组成，在物理、化学、生物学、经济学、电气工程和统计学等许多领域都有实际应用。

     i = rooting(-1, 2)
     i = power(-1, 1/2)
     squering on both sides
    -1 = power(i)

实数如果看作水平数轴的的运算，复数则可以看作垂直数轴的运算，对实数 N 在实数数轴对应位置，乘以 i 后就转动 90°, 落在虚数数轴对应的位置。转动两次 90° 会刚好到实数数轴的反向位置。这样，N = N * i * i = -1 * N，-1的平方根相应于 1 的一个90度的旋转, 是虚数单位, 成为之 i。这样定义的虚数和实数结合成了一个复数平面(complex plane)，所有在复平面上的数都满足 z=a+b i 这样的结构, 称之为复数。其中 a 称为实部(real part), b 为虚部(imaginary part)。有了复数后，需要两个数 (x,y) 来描述任意一直角坐标平面的二维点的位置, 现在只用一个复数就够了, 可以用实数组 (a,b) 代表这个复数 a+b i, 并且可以在复平面上绘制出来。

复数的模(modulus, 通常写为|z|)，表示坐标原点到目标点的距离，就是它长度 r。
辐角(argument, 通常写为 arg(z))，表示模与实轴正方向的夹角。
复数的共轭(conjugate,通常写为下面形式)，表示模以实轴为对称轴的两个复数，辐角 φ 表示与实轴的夹角, 就是 a+b i 与 a-b i 共轭。

以图形的方式来理解复数加减乘除运算会更形象, 复数加减是两个复数实部和虚部分别对应相加减, 可以看成是在复数平面上的平移。复数与实数的乘除可以当作在复数平面上的绽放。复数间的乘除则是绽放加旋转，等于两个复数的模相乘(伸缩大小), 辐角相加(旋转量)。 比如 Z 乘以 2 i 的变换就是 - 旋转 90°, 同时放大了2倍。

复数的定义赋予这个i的旋转特性，电场与磁场垂直属性简直完美匹配！当然这是一种巧合，用复数来描述电磁，即可以让电场强度与复数磁场强度相加而不损失各自的信息，又满足了电场与磁场90度垂直的要求。另外，一旦我们需要让任何一个场旋转90度，只要乘一个 i 就可以了。



# 对数 logarithm 与指数

                                Logarithm <====> Exponent
            logarithm 对数    Log a N = x <====> N = a^x
     common logarithm 常用对数   lg N = x <====> N = 10^x
    natural logarithm 自然对数   ln N = x <====> N = e^x

对数基本上是指数的逆函数。你需要一个数字(N)，一个基(A)，基a中N的对数是x，其中N等于x的幂。当a为10时，称以无理数e(e=2.71828...)为底的对数称为自然对数(这似乎只是一种不同的书写方式(从某种意义上说，也是如此)，但对数有无数的实际应用，用于心理学、经济学和许多物理现象的测量(如pH值或震级)。

对数是约翰纳皮尔（John Napier）在1614年公开提出的，在一本名为《密利菲西对数描述》(描述奇妙的对数规则)的书中-一个合适的标题。对数的一个特例是自然对数e，其中e是一个约等于2.71828182845的非理性超越数。事实上，e本身有一个迷人的历史和令人印象深刻的应用程序数量，但这是另一个时代的故事。


# Scalar, Vector, Tensor
- https://www.brighthubengineering.com/machine-design/120073-difference-between-tensors-and-vectors

标量、向量是张量的特殊形式，没有方向分量的张量就是分量，有模有方向的张量就是向量，如果有两个方法就是并矢、并向量。

The tensor is a more generalized form of scalar and vector. Or, the scalar, vector are the special cases of tensor.

- If a *tensor* has only magnitude and no direction (i.e., rank 0 tensor), then it is called *scalar*.
- If a *tensor* has magnitude and one direction (i.e., rank 1 tensor), then it is called *vector*.
- If a *tensor* has magnitude and two directions (i.e., rank 2 tensor), then it is called *dyad*.
- And so on…


# 最美的数学公式 - 欧拉公式

- [我们数学中常用的自然常数e代表什么？](https://baijiahao.baidu.com/s?id=1592672728768901992)
- [数学里最美的公式： e^iπ+1=0 - Surein Aziz 博士](https://www.meipian.cn/588prp7)
- [「参数方程和极坐标」图解普林斯顿微积分](https://www.toutiao.com/i6485479552691733006/)
- [An Intuitive Guide To Exponential Functions & e](https://betterexplained.com/articles/an-intuitive-guide-to-exponential-functions-e/)
- [数学常数e的含义](http://www.ruanyifeng.com/blog/2011/07/mathematical_constant_e.html)

    e = lim(1+1/x)^x{x->infinity} = 1/0!+1/1!+1/2!+1/3!+…………1/n! 
    ~ 2.7 18281828 45904523 536028747 1352662497 7572470936999 59574966967 6277240 76630353547
    π = 2 + 2/3 + 2/3 * 2/5 + 2/3 * 2/5 * 3/7 + ... ~ 3.1415926 535897932 384626 43383279 50288 4197169 39937510 

介绍一下极坐标(polar coordinate)，常用的xy两轴坐标称为 Cartesian 坐标，极坐标的也用 xy 轴，不同的是极坐标除了 xy 轴，还加入了旋转角度，用来θ表示沿x轴正方向逆时针旋转度数，在极坐标平面系统中的任意点可以用半径和旋转角度来表示(r,θ)。 复平面内的点可以转成极坐标的形式 (r,θ), 那么该点所表示的复数是什么呢？可用 x = r cos(θ) 和 y = r sin(θ) 来转化到笛卡尔坐标. 所以极坐标 (r, θ) 表示复数

    z = x + iy = r cos(θ) + i r sin(θ)

特别的, 如果 r = 1, 则 

    z = cos(θ) + i sin(θ)

形如 r e^(i θ) 的复数为极坐标形式, 并且与之相对的 x+iy 为笛卡尔形式. 1743 年, 瑞士数学家欧拉给出了著名的欧拉公式, 对所有实数 θ 都成立。这就是用对数形式表示的欧拉公式，但是，要理解这个公式是如何来的，我们需要一样东西，叫做泰勒级数参考后面:

    e^(iθ) = cos(θ) + i sin(θ)

特别当 θ=π 时，按复数平面规则运算，右边的值为-1，欧拉公式的特殊形式更是被评为数学上最美的公式:

    e^(iπ) + 1 = ０

这个简洁公式包括了数学上最重要的5个常数: 0, 1(自然数的基本单位), e(描述变化率的自然指数), π 圆周率以及 i(虚数的基本单位)。那么为什么会出现这种情况呢？最奇怪的问题是：我们怎样取一个数的i次方？指数上有虚数怎么算？那就是用对数形式导出的欧拉公式。


用几何的方法很快证明该等式, 不同的 θ 值对应的极坐标 e^θ, 请留特别是在复平面旋转角度为 180°, 点落到等于 -1 的时刻。

确有一种方法能将像sin(x)或cos(x)这样的函数表达为无穷和的形式，由数学家布鲁克·泰勒发现，泰勒级数在近似计算中有重要作用。函数e^x的泰勒级数(Taylor series)扩展如下，因为阶乘 0! 和 1! 的值都定义为 1, 式子前两项为 1 + x:

    e^x = x^0/0! + x^1/1! + x^2/2! + x^3/3! + x^4/4! ... x^n/n!

阶乘是基斯顿·卡曼（Christian Kramp，1760～1826）于 1808 年发明的运算符号，是数学术语。一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且0的阶乘为1。自然数n的阶乘写作n!。1808年，基斯顿·卡曼引进这个表示法。

如果n比较大的话，你会发现结果几乎等于你得到的数e^x，且添加的求和项数越多，两个结果越靠近。在某些时候，计算器上的两个结果是一样的，因为计算器无法检测它们之间的微小区别。当你对无穷多项求和时，两个结果是一模一样的。在某些时候，计算器上的两个结果是一样的，因为计算器无法检测它们之间的微小区别。当你对无穷多项求和时，两个结果是一模一样的。出现在欧拉公式的其他两个函数的泰勒级数为，注意角度x是用弧度，而不是度数。

    cos(x) = 1 - x^2/2! + x^4/4! - x^6/6! + ...
    sin(x) = x - x^3/3! + x^5/5! - x^7/7! + ...

现在，让我们将泰勒级数中的变量x换成ix,得到

    e^ix = (ix)^0/0! + (ix)^1/1! + (ix)^2/2! + (ix)^3/3! + (ix)^4/4! ... (ix)^n/n!

将某些i的次方可以简化，例如，按定义i^2=−1，所以i^3=-i及i^4=1，等等。上式简化后，以将涉及i的项合并在一起，给出的简化式会包含两个级数与上面的sin(x)和cos(x)的对应级数一样，所以我们将它们代入而得欧拉公式。



已知的信息表明第一次用到常数e，是莱布尼茨于1690年和1691年给惠更斯的通信，以b表示。1727年欧拉开始用e来表示这常数；而e第一次在出版物用到，是1736年欧拉的《力学》(Mechanica)。可能因为e是指数(exponential)一字的首字母。不过，欧拉选这个字母的原因，不太可能是因为这是他自己名字Euler的首字母，因为他是个很谦虚的人，总是恰当地肯定他人的工作。

自然常数的来法比圆周率简单多了。它就是当x趋于无限大时函数 (1+1/x)^x 的极限值。也可以用阶乘的形式表达，证明省略：

    1/0!+1/1!+1/2!+1/3!+…………1/n!

以复利角度理解这个函数，假设有笔钱存银行，银行抽风了一年利率100%。那么一年后结算，这笔钱会变成2倍。如果半年结算一次，上半年的计息计入下半年的本金，一年后就能得到2.25倍，当这个结算周期无限小，这个值趋于2.71828...即自然常数。

    T1     (1+1)       2
    T1/2   (1+1/2)^2   2.25
    T1/3   (1+1/3)^3   2.37037
    T1/4   (1+1/4)^4   2.44141
    T1/5   (1+1/5)^5   2.48832
    ......
    T1/99  (1+1/99)^99 2.71692
    ......

如细胞的分裂现象是不间断、连续的，每分每秒产生的新细胞，都会立即和母体一样继续分裂，一个单位时间(24小时)最多可以得到多少个细胞呢？当增长率为100%保持不变时，在单位时间内细胞种群最多只能扩大2.71828倍，这也是复利增长极限。 这个值是自然增长的极限，是“自然律”的精髓所在，因此以e为底的对数，就叫做自然对数。综上，e 的含义可以理解为增长的极限，自然常数的也可以理解为它是非人为的，我们只是发现了它。

这里100%的增长率极限可以表达为 e^100%，回到复利的计算，如果银行的利息率是5%，求解100元存款翻倍需要多少时间就等价于解下面的方程：

    e^(5t/100) = 2
    ln2 = 0.05t
    t = 20·ln2 = 20*0.693147 = 100·0.693147/5 = 13.8629年

计算结果得13.86年，约等于72除以增长率，72是金融学估算值，准确值是100ln2，余数就是翻倍的大致时间，这正是经济学上著名的72法则。



# Mathematica 数学软件基本使用

输入以下表达式，按下 Shift+Enter 进行计算。输出结果中有个数值编号，对应的输出值可以用 %1 这样的形式引用这个输出值，%%则引用最后一个输出值。分号 ; 表示省略输出可以用来连接多个表达式，逗号也可以连接表达式但输出结果。N 是自然数求值函数，N[E]可以打印自然常数的近似值，如果需要打印小数100位N[E, 99]，同样N[π]可以打印出圆周率，这个特殊符号π可以通过两种方式输入，一是按两退出键之间输入pi，即 ESC+pi+ESC，另一种方法是斜杠打头的输入方式\[Pi]。


     In[1]:= N[(1 + 1/2)^2]    还可以这样调用自然数求值函数 (1 + 1/2)^2 // N
    Out[1] = 2.25
     In[2]:= (1 + 1/x)^x /. x -> 1     表达式求值
    Out[2] = 2
     In[3]:= (1 + 1/x)^y /. {x -> 1, y -> 2}   表达式求值的多变量设定
    Out[3] = 4
     In[4]:= (1 + 1/x)^x /. {x -> 5}; N[%%]
    Out[4] = 2.48832

另一种对表达式的求值，是使用 Set (=) 运算符直接对变量赋值，这样做有一个缺点，那就是表达式本的关系被常数值覆盖了。对于定义过的变量，可以用问号查询如 ?f：

    In[76]:= f = (1 + 1/x)^x;
             x = 6;
             N[f]
    Out[78]= 2.52163

还有一个方法是使用延时赋值运算符 SetDelayed (:=) 定义函数符号，清理定义过的符号使用 Unset (=.)操作符，或者用内置函数Clear，ClearAll：

    In[164]:= f[x_] := (1 + 1/x)^x;
              f[5] // N
              f[x_] =.
              Clear[f]
    Out[165]= 2.48832

$上海莱士(SZ002252)$因重仓投资万丰奥威股票亏损数十亿复牌一字跌停，用Plot绘制跌停数与剩余价格的关系图表

    In[122]:= floor[x_] := 19.52 (1 - 10/100)^x
    floor[14] // N
    Plot[floor[Floor[x]], {x, 0, 20}, {Filling -> Axis, 
      PlotRange -> {0, 20}, AxesLabel -> {跌停数, 价格}}]

    Out[123]= 4.46555

自然常数 e 在 Mathematica 中使用极限函数表达 Limit[(1 + 1/n)^n, n -> Infinity]

    In[55]:= Limit[(1 + 1/n)^n, n -> Infinity]
    Out[55]= E
    In[56]:= Limit[(1 + x/n)^n, n -> Infinity]
    Out[56]= E^x

求自然对数用 Log[z]，指定基数可以这样调用 Log[b,z]，常用对数用 Log10[z]，二进位对数用 Log2[z]

    In[106]:= Log[2] // N
    Out[106]= 0.693147

对列表绘制线图或点图：

    With[{t = {1，2，3，5，7，9}}, Show[ListLinePlot[t], ListPlot[t]]]

一些常用的命令及常数参考

    Pi              3.1415....的无限精度数值
    E               2.17828...的无限精度数值
    Catalan         0.915966..卡塔兰常数
    EulerGamma      0.5772....高斯常数
    GoldenRatio     1.61803...黄金分割数
    Degree          Pi/180 角度弧度换算
    I               复数单位
    Infinity        无穷大
    -Infinity       负无穷大
    ComplexInfinity 复无穷大
    Indeterminate   不定式


    =      开始处输入一个等号，给出结果以及纯正的 Mathematica 语法。
    ==     开始处输入二个等号，返回完整的 Wolfram|Alpha 网页样式的结果，具有文本、图形和交互式元素。
    Ctrl+= 插入自由格式输入 linguistic from
    Ctrl+- 插入下标输入
    Ctrl+2 开方运算符号
    Ctrl+5 在开方运算中指定N次方根
    Ctrl+6 指数运算输入
    Ctrl+/ 分数输入

    Line1;line2;    顺次执行 Line1 line2 不显示结果
    Line1,line2     顺次执行 Line1 line2 并显示结果
    ?name           查询系统变量 name 的信息
    ??name          查询系统变量 name 的全部信息
    !command        执行Shell命令
    n!              N 的阶乘
    !!filename      显示文件内容
    <<filename      读入文件并执行
    Expr>> filename 写入数据到文件
    Expr>>>filename 写入数据到文件末尾
    ()              结合率
    []              函数
    {}              一个表
    <*Math Fun*>    在c 语言中使用math 的函数
    (*Note*)        程序的注释
    #n              第n 个参数
    ##              所有参数
    rule&           把rule 作用于后面的式子
    %               前一次的输出
    %%              倒数第二次的输出
    %n              第n 个输出
    var::note       变量var 的注释
    "Astring "      字符串
    Context `       上下文
    a+b             加
    a-b             减
    a*b 或a b       乘
    a/b             除
    a^b             乘方
    base^^num       以base 为进位的数 
    lhs&&rhs        且
    lhs||rhs        或
    !lha            非
    ++,--           自加1，自减1
    +=,-=,*=,/=     同C 语言相应的运算符
    >,<,>=,<=,==,!= 逻辑判断（同c）
    lhs=rhs         立即赋值
    lhs:=rhs        建立动态赋值
    lhs:>rhs        建立替换规则
    lhs->rhs        建立替换规则
    expr//funname   相当于filename[expr]
    expr/.rule      将规则rule 应用于expr
    expr//.rule     将规则rule 不断应用于expr 知道不变为止
    param_          名为param 的一个任意表达式（形式变量）
    param__         名为param 的任意多个任意表达式（形式变量）


# 算法时间复杂度

时间复杂度是同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。 计算机科学中，算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。

算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得T(n)/f(n)的极限值（当n趋近于无穷大时）为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。

在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出 T(n) 的同数量级。常见数量级有以下几种，1，log2n，n，n log2n ，n的平方，n的三次方，2的n次方，n!。找出后，f(n) = 该数量级，若 T(n)/f(n) 求极限可得到一常数c，则时间复杂度T(n) = O(f(n))

便捷计算的方法是：看看有几重for循环，只有一重则时间复杂度为O(n)，二重则为O(n^2)，依此类推，如果有二分则为O(logn)，二分例如快速幂、二分查找，如果一个for循环套一个二分，那么时间复杂度则为O(nlogn)。



# 字符串匹配 KMP 字典树 AC自动机

KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。时间复杂度O(m+n)。

朴素的匹配算法，或者说暴力匹配法，就是将两个字符串从头比到尾，若是有一个不同，那么从下一位再开始比。这样太慢了。所以KMP算法的思想是，对匹配串本身先做一个处理，得到一个next数组。这个数组是做什么用的呢？next [j] = k，代表j之前的字符串中有最大长度为k 的相同前缀后缀。记录这个有什么用呢？对于ABCDABC这个串，如果我们匹配ABCDABTBCDABC这个长串，当匹配到第7个字符T的时候就不匹配了,我们就不用直接移到B开始再比一次，而是直接移到第5位来比较，岂不美哉？所以求出了next数组，KMP就完成了一大半。next数组也可以说是开始比较的位数。


Aho-Corasick automaton，该算法在1975年产生于贝尔实验室，是著名的多模匹配算法。AC自动机基本概念是Trie，也就是字典树。Trie树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。


- [Imaginary Numbers](https://www.mathsisfun.com/numbers/imaginary-numbers.html)
- [Complex Plane](https://www.mathsisfun.com/algebra/complex-plane.html)
- [Intuitive Understanding Of Euler’s Formula](https://betterexplained.com/articles/intuitive-understanding-of-eulers-formula/)
- [Imaginary Multiplication vs. Imaginary Exponents](https://betterexplained.com/articles/imaginary-multiplication-exponents/)
- [信号处理 | 傅里叶变换、短时傅里叶变换、小波变换、希尔伯特变换、希尔伯特黄变换](https://zhuanlan.zhihu.com/p/150705777)
- [欧拉公式](https://www.bilibili.com/video/BV1Sb4y1v7tb?p=17)
- [傅里叶级数、傅里叶变换与频谱 by Eugene Khutoryansky](https://www.bilibili.com/video/BV1sS4y1G7WF)
- [什么是傅立叶级数呢？-从热流到画圈圈 by 3Blue1Brown](https://www.bilibili.com/video/BV1vt411N7Ti)
- [But what is the Fourier Transform? A visual introduction by 3Blue1Brown](https://www.bilibili.com/video/BV1pW411J7s8)
- [An Interactive Guide To The Fourier Transform](https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/)
- [Pitch Shifting Using The Fourier Transform](http://blogs.zynaptiq.com/bernsee/pitch-shifting-using-the-ft/)
- [Time and pitch scaling in audio processing](http://www.surina.net/article/time-and-pitch-scaling.html)
- [Fourier Transform: maps image into spatial frequency domain](https://homepages.inf.ed.ac.uk/rbf/HIPR2/fourier.htm)
- [Fourier transforms of images by Rachel Thomas](https://plus.maths.org/content/fourier-transforms-images)
- [Matplotlib — Visualization with Python](https://matplotlib.org/)
- [MATLAB vs Mathematica: Which One is Better for Future?](https://matlabassignmenthelp.com/blog/matlab-vs-mathematica/)
- [CT IEEE Signal Processing Society](https://www.ewh.ieee.org/r1/ct/sps/index.html)
- Essential MATLAB for Engineers and Scientists by Brian D. Hahn Daniel T Valentine
- Signal Processing Algorithms in MATLAB by Samuel D. Stearns, Ruth A. David
- Signals and Systems Using MATLAB by Luis F. Chaparro, Aydin Akan
- Signals & Systems by Alan V. Oppenheim, Alan S. Willsky, S. Hamid Nawab
- Digital Signal Processing A Practical Guide for Engineers and Scientists by Steven Smith
- Digital Signal Processing, Fourth Edition by John G. Proakis, Dimitris K. Manolakis
- Understanding Digital Signal Processing by Richard G. Lyons
- Discrete-time signal processing by Buck, John R.Oppenheim, Alan V.Schafer, Ronald W
- A Student’s Guide to Fourier Transforms with Applications in Physics and Engineering

这里补充一点数字信号处理方面的知识，关于信号处理方面的专业书籍 CT IEEE Signal Processing Society 上有一个书单。并且在线提供了 Matlab、Mathematica 两个专业软件的手册：

- MATLAB Manual: Getting started with MATLAB.
- Mathematica Manual: Getting started with Mathematica.

在信号处理领域，*时域* Time Domain 和*频域* Frequency Domain 是两个非常基础的概念，它们也是两种观察信息的角度。

图像或音频处理 Audio Process 等数字信号处理中，Fourier Analysis 是一种常用方法，这套分析方法来自 18 世界的法国数学家 Joseph Fourier。使用傅里叶变换，可以用时域、频域的观点去观察一个声音。

对于一个信号来说，它有很多方面的特性。如信号强度随时间的变化规律（时域特性），信号是由哪些单一频率的信号合成的（频域特性）

*时域观点*，描述数学函数或物理信号对时间的关系，以时间作基本变量的范围，观察信号如何承时间变化。示波器是一种直观的信号时域波形观察仪器，可以直观看到一个信号的时域波形如果随着时间的变化。

在实际应用中，计算机只能处理*离散信号* Discrete-Time Signal，所以对连续信号进行时域采样，得到离散的采样数据。

若考虑离散时间，时域中的函数或信号，在各个离散时间点的数值均为已知。若考虑连续时间，则函数或信号在任意时间的数值均为已知。  在研究时域的信号时，常会用示波器将信号转换为其时域的波形。

*频域观点*，描述信号在频率方面特性时用到二维坐标系，横向表示频率，纵向表示信息对应频率分量的强度。

在音频信号处理中，*傅里叶变换*（Fourier transform）是常用工具，它是一种线性积分变换，在时域和频域之间对信号进行变换。在实际应用中，计算机只能处理离散信号，所以对连续信号进行时域采样，对离散样本进行傅里叶变换就是 DFT - Discrete Fourier transform。比如，音频中有高频啸叫分量，通过 DFT 可以分解出信息的各种频率分量，并且可以在移除产生高频啸叫的分量后再进行*逆傅里叶变换* Inverse Fourier Transform，就可以过滤掉不需要音频部分。

快速傅里叶变换（Fast Fourier Transform，FFT）是一种可在 O(nlogn) 时间内完成离散傅里叶变换的高效、快速计算方法集的统称。最初的快速傅里叶变换方法早在 1805 年就已由高斯推导出来，并于 1965 年由 Cooley 和 Tukey 重新提出，并渐渐被大众所熟知。从此，对快速傅里叶变换（FFT）算法的研究便不断深入，数字信号处理这门新兴学科也随 FFT 的出现和发展而迅速发展。

简单的说，傅里叶变换就是信号展开为一系列三角函数的和。因为三角函数是周期对称函数，所以展开也就是把对称性进行分解。一般来说对称性分为奇对称性 f(x)=-f(-x)，即中心对称，和偶对称性（f(x)=f(-x)，即轴对称。经过傅里叶变换，奇对称性的分量构成了傅里叶变换的虚部，而偶对称性的部分就构成了变换后的实部。


音频信号和图像信号没有本质区别，像素的颜色值和音频采样值都是数值信息，只不过前者是一维信号，而图像是二维信号。它们都可以使用多个三角函数分量表达，这很具有神秘感，但对于数学家来说，这是非常明显的事。

Fourier transforms of images by Rachel Thomas 是很棒的傅里叶变换图像处理入门教程，使用了 Matlab 作为分析工具。也可以借助 Python 的 matplotlib 图形库，查看傅里叶变换图像处理效果。还有 Robert Bob Fisher 教授的  HIPR2: Hypertext Image Processing Reference 也是不错的在线图像处理方面的参考教材。

可以将图像像素的灰度值看作一个函数，对应 (x, y) 坐标像素，grey = f(x, y)。因此，图像也可以用三角函数表示，只不过是二维的，z = a sin(hx+ky)。

- 式中 x、y 指出空间中点的坐标；
- z 表示三角函数波形在对应坐标点的高度、或灰度值；
- a 表示波幅，即最大高度、灰度值；
- h、k 对应表示三角函数波形沿 x、y 方向重复的次数，即波形频率；

在图像处理中，*空间域* Spatial Domain，又称图像空间(image space)，指由图像像元组成的空间。在图像空间中以长度(距离)为自变量直接对像元值进行处理称为空间域处理。可以简单理解为像素空间，在空域的处理就是在像素级的处理，通过傅立叶变换后，得到的是图像的频谱，表示图像的能量梯度。

对图像进行傅立叶变换，可以得到空间域频率分布图，Spatial Frequency 或者叫做图像频谱，可以作为一张灰度图像。其中的每个像素都有一个坐标值（h，k），位置坐标值也代表 x 方向和 y 方向频率，表示在傅立叶变换中的正弦波分量的对应强度贡献：

- 中心点表示（0, 0）波，表示没有波纹的平面，两个 0 值表示恒定没有波动，其强度（灰度颜色的亮度）是输入图像中像素的平均值。
- 中心点左侧、右侧的点代表沿 x 轴变化的正弦波，k = 0，这些点的亮度表示傅立叶变换中具有该频率的正弦波的强度（强度是正弦波的振幅的平方）。
- 中心点上下垂直的那些点代表原始图像 y 方向中变化，但在 x 方向中保持恒定（h = 0）的正弦波，其波形频率及其强度。
- 傅立叶变换中的其他点表示原始图像对角波的贡献值。

因此，空间域图像离中心越远的位置表示频率越高，离中心点越近表示频率越低。高频分量表示原始图像上单位距离的颜色变化更强烈，低频分量表示更平滑的部分。

如果旋转输入的原始图像，那么变换得到的空间图像也会跟着旋转。

![sinx-ft-zoom](https://plus.maths.org/content/sites/plus.maths.org/files/articles/2017/carola/sinx-ft-zoom.jpg)

举例来说，使用 sin(x) 生成一张原始图像，它的像素颜色看起来就是：在水平方向按正弦波黑白平滑过度，在竖直方向上具有相同的灰度值。经过傅里叶变换得到的空间域也是尺寸一样的灰度图，但只有三个亮点：中心位置，和紧贴左右两侧的亮点，坐标分别为 (0, 0)、(-1,0)、(1,0)。其余所有像素都是黑色的，因为原始图像为 Sin(x) 仅使用（1,0）波进行精确描述，y 方向没有变化。如果 x 方向的频率增大，那么出现的亮点位置也也会向边缘移动。注意坐标值也对应代表了 x、y 方向的频率，以及其灰度值代表了对应频率的波幅强度。

又比如，使用方波生成原始图像，即输入一张左边一半黑色、右边一半白色的图像，经过傅里叶变换得到的空间域图像就只有一条过中心点的水平亮线。之所以有水平亮线，就是因为水平方向在规律的波形变化。如果变化没有规律，亮点就不能组成规则的线条。

注意，方波信号展开为傅里叶级数，也就是由一系列不同频率的正弦波构成。*傅里叶级数* Fourier Series 是一种对周期信号进行分解的方式。

越是简单的原始波形，变换得到的亮点就越少，因为正弦波频率分量越少。而现实中的照片通常含有复杂的像素结构，所以需要极复杂的正弦波分量来表达，所以得到的亮点也极多。

傅里叶变换在音频、图像处理应用十分广泛，特别是用于增强图像清晰度、降低噪点，用于 JPEG 格式图像压缩。

数学研究需要好的工具，Matlab、Mathmatica、Mapple 作为世界三大主流数学工具，都是非常好的辅助。

在工程应用上，使用 Matab 的优势是非常巨大，它最大的用途就是进行模拟分析，而数学分析只是其庞大功能的其中一种。因为在工程计算中，会用到大量的基础模型，Matlab 都提供了，使用起来就非常方便。比如说，有限元分析，这就必须要有强大的数学分析能力，才能完成。还提供了 Simulink 模块图环境，支持使用多域模型进行系统设计，在转至硬件之前进行仿真，并且无需编写代码即可进行部署。

总的来说，对于工程应用，Matlab 的应用范围要远远比 Mathematica 要广，因为使用的人数非常多。在绝大多数情况下，工程应用中或者很多非专业人员是需要一个软件直接提供一个直观的计算结果或者模拟结果的，这就是 Matlab 的优势。

在深度计算上，Mathematica 非专业，并且在用户界面设计上也一样专业。是一款计算功能极其卓越的软件，不仅可以提供常规所有函数的数学模型，而且可以进行深度计算。做数学建模正是它的特长，数分能力可以说是各个软件之首，其数学模型分析方面的能力是 Matlab 远远不可比及的。只是在工程应用和模拟分析的方面就显然要比 Matlab 要稍逊一筹。软件无高低，只是侧重不同，对于学校这个级别的数学建模，是不会用到深度计算的。

要强调的是，这两个软件都是非常卓越的。当下很多基础学科都到了瓶颈期，而这两个软件是最有可能成为将来这些学科突破的开路先锋。所以不存在谁更强的说法，重要的是应用的人以及应用的方式方法，合理的建模和分析模式都会取得同样的结果。

以下是 Matlab R2015B 提供的专业工具箱，使用 *ver* 命令可以查询到，可以看到从机械到工程，信号处理、神经网络，统计、经济、金融等各行各业都可以使用：

    | Aerospace Toolbox              | Global Optimization Toolbox      | OPC Toolbox                             |
    | Antenna Toolbox                | Image Acquisition Toolbox        | Optimization Toolbox                    |
    | Bioinformatics Toolbox         | Image Processing Toolbox         | Partial Differential Equation Toolbox   |
    | Communications System Toolbox  | Instrument Control Toolbox       | Phased Array System Toolbox             |
    | Computer Vision System Toolbox | LTE System Toolbox               | RF Toolbox                              |
    | Control System Toolbox         | Mapping Toolbox                  | Robotics System Toolbox                 |
    | Curve Fitting Toolbox          | Model Predictive Control Toolbox | Robust Control Toolbox                  |
    | Data Acquisition Toolbox       | Model-Based Calibration Toolbox  | Signal Processing Toolbox               |
    | Database Toolbox               | Neural Network Toolbox           | Statistics and Machine Learning Toolbox |
    | Datafeed Toolbox               |                                  | Symbolic Math Toolbox                   |
    | DSP System Toolbox             |                                  | System Identification Toolbox           |
    | Econometrics Toolbox           |                                  | Trading Toolbox                         |
    | Financial Instruments Toolbox  |                                  | Vehicle Network Toolbox                 |
    | Financial Toolbox              |                                  | Vision HDL Toolbox                      |
    | Fuzzy Logic Toolbox            |                                  | Wavelet Toolbox                         |

Fourier transforms of images by Rachel Thomas 文章给出的 Matlab 代码参考，可以保存为 .m 文件格式：

```matlab
% Fourier transforms of images by Rachel Thomas 
% https://plus.maths.org/content/fourier-transforms-images
% https://plus.maths.org/content/sites/plus.maths.org/files/articles/2017/carola/MATLAB.TXT

% HOW TO MAKE A 2D SINE WAVE

% SET SIZE OF IMAGE
X=1:600; 
[Xm Ym]=meshgrid(X, X); 

% DEFINE SINE WAVE, SCALED TO IMAGE SIZE AND SO THAT VALUES WORK IN GRAY SCALE
Z=(sin(Xm*2*pi/600)+1)/2+(sin(Ym*2*pi/600)+1)/2

% PIC OF SURFACE IN 3D
% [need image size to be about 100px for this to look nice, otherwise is just black]
surf(Xm,Ym,Z)

% SHOW WAVE FROM ABOVE - CONTOUR STYLE
imshow(Z)

% FOR FOURIER TRANSFORM
% [FOURIER TRANFORM MOST OBVIOUS IF YOU HAVE SINE WAVES WITH HIGH FREQUENCIES, SAY OVER 10, SO THE BRIGHT PIXELS ARE FAR ENOUGH FROM THE CENTRE]
fftA = fft2(double(Z))
ffB=log(abs(fftshift(fftA)+1))

imshow(ffB)

% FOR IMAGE
PIC = imread('/.../.../picture.jpg')

imshow(PIC)

% TURN INTO GRAYSCALE ARRAY
PIC2=rgb2gray(PIC)

% FOR FOURIER TRANSFORM
% NEED TO DIVIDE BY MAX ELT OF FFTB TO MAKE GRAYSCALE WORK
fftA = fft2(double(PIC)); fftB = log(abs(fftshift(fftA)+1)); fftC = fftB/max(max(max(fftB)));

imshow(fftC)

% ROTATE IMAGE WITH
PIC3=imrotate(PIC,45)
```


# =🚩 Essentials Matlab

数学研究需要好的工具，Matlab、Mathmatica、Mapple 作为世界三大主流数学工具，都是非常好的辅助。

在工程应用上，使用 Matab 的优势是非常巨大，它最大的用途就是进行模拟分析，而数学分析只是其庞大功能的其中一种。因为在工程计算中，会用到大量的基础模型，Matlab 都提供了，使用起来就非常方便。比如说，有限元分析，这就必须要有强大的数学分析能力，才能完成。还提供了 Simulink 模块图环境，支持使用多域模型进行系统设计，在转至硬件之前进行仿真，并且无需编写代码即可进行部署。

总的来说，对于工程应用，Matlab 的应用范围要远远比 Mathematica 要广，因为使用的人数非常多。在绝大多数情况下，工程应用中或者很多非专业人员是需要一个软件直接提供一个直观的计算结果或者模拟结果的，这就是 Matlab 的优势。

在深度计算上，Mathematica 非专业，并且在用户界面设计上也一样专业。是一款计算功能极其卓越的软件，不仅可以提供常规所有函数的数学模型，而且可以进行深度计算。做数学建模正是它的特长，数分能力可以说是各个软件之首，其数学模型分析方面的能力是 Matlab 远远不可比及的。只是在工程应用和模拟分析的方面就显然要比 Matlab 要稍逊一筹。软件无高低，只是侧重不同，对于学校这个级别的数学建模，是不会用到深度计算的。

要强调的是，这两个软件都是非常卓越的。当下很多基础学科都到了瓶颈期，而这两个软件是最有可能成为将来这些学科突破的开路先锋。所以不存在谁更强的说法，重要的是应用的人以及应用的方式方法，合理的建模和分析模式都会取得同样的结果。

以下是 Matlab R2015B 提供的专业工具箱，使用 *ver* 命令可以查询到，可以看到从机械到工程，信号处理、神经网络，统计、经济、金融等各行各业都可以使用：

    | Aerospace Toolbox              | Global Optimization Toolbox      | OPC Toolbox                             |
    | Antenna Toolbox                | Image Acquisition Toolbox        | Optimization Toolbox                    |
    | Bioinformatics Toolbox         | Image Processing Toolbox         | Partial Differential Equation Toolbox   |
    | Communications System Toolbox  | Instrument Control Toolbox       | Phased Array System Toolbox             |
    | Computer Vision System Toolbox | LTE System Toolbox               | RF Toolbox                              |
    | Control System Toolbox         | Mapping Toolbox                  | Robotics System Toolbox                 |
    | Curve Fitting Toolbox          | Model Predictive Control Toolbox | Robust Control Toolbox                  |
    | Data Acquisition Toolbox       | Model-Based Calibration Toolbox  | Signal Processing Toolbox               |
    | Database Toolbox               | Neural Network Toolbox           | Statistics and Machine Learning Toolbox |
    | Datafeed Toolbox               |                                  | Symbolic Math Toolbox                   |
    | DSP System Toolbox             |                                  | System Identification Toolbox           |
    | Econometrics Toolbox           |                                  | Trading Toolbox                         |
    | Financial Instruments Toolbox  |                                  | Vehicle Network Toolbox                 |
    | Financial Toolbox              |                                  | Vision HDL Toolbox                      |
    | Fuzzy Logic Toolbox            |                                  | Wavelet Toolbox                         |


Matlab 是一个宏大的工程软件，各个领域的工具包是以模块的形式提供的，文档也按模块组织。例如部分模块文档如下：

- MATLAB - The Language of Technical Computing
- DSP System Toolbox - Design and simulate streaming signal processing systems
- MATLAB Coder - Generate C and C++ code from MATLAB code
- MATLAB Compiler - Build standalone applications from MATLAB programs
- MATLAB Compiler SDK - Build software components from MATLAB programs
- Signal Processing Toolbox - Perform signal processing and analysis


根据工程应用领域的不同，Matlab 提供数以百计的工具包，本身也支持多种语言的互相调用，带有代码转译器，可以将 Matlab 程序转译生成 C/C++ 等语言代码。以上的 DSP System Toolbox 就是数字信号处理系统工具包，提供多种信号分析方法。如 Discrete Fourier transform 或 Inverse discrete Fourier transform (IDFFT)，实现数字信号数据在 Frequency Domain 与 Time Domain 之间的变换。当然 DSP 工具包之外，还有其它各种行业的工具，涉及领域非常广泛。

Matlab 提供的两个关于信号处理的工具包侧重不同，主要功能如下：

- DSP System Toolbox™ provides algorithms, filters, design tools, and an app for processing streaming signals in MATLAB® and Simulink®. 
- Signal Processing Toolbox™ provides functions and apps to generate, measure, transform, filter, and visualize signals. 

也就是说，Signal Processing Toolbox 工具包主要用于离线的信号数据分析。而 DSP 工具包则用于实时信号处理，最终在硬件内部实现，在 CD/VCD/DVD 播放器中进行的信号处理就是 DSP 的典型应用。DSP 工具箱具有更专业的滤波器设计算法，例如，多速率、多级、自适应滤波器等，可以与 Simulink® 搭配。

Matlab 文档组织有非常好的目录层次结构，主要内容是整个编程环境中的函数、对象等参考。并且更重要的是在关键知识点中还有 Concepts 和 Examples 内容，一方面从基本概念上提供了帮助，同时又以实例提供了实践参考。

Matlab 编程开发文档主要内容目录：

- Language Fundamentals -- Syntax, operators, data types, array indexing and manipulation
- Mathematics
    - Elementary Math
    - Linear Algebra
    - Random Number Generation
    - Interpolation
    - Optimization
    - Numerical Integration and Differential Equations
    - Fourier Analysis and Filtering
    - Sparse Matrices
    - Graph and Network Algorithms
    - Computational Geometry
- Graphics -- Two- and three-dimensional plots, images, animation, visualization
- Programming Scripts and Functions -- Program files, control flow, editing, debugging
- Data Import and Export
    - Text files, spreadsheets, and other file formats; big data; web access
- GUI Building -- Application development using GUIDE and callbacks
- Advanced Software Development
    - Object-Oriented Programming
    - Calling External Functions
    - Toolbox Distribution
    - Exception Handling
    - Unit Testing Framework
    - Source Control Integration
    - Performance and Memory
    - System Commands
    - MATLAB API for Other Languages
- Desktop Environment -- Preferences and settings, platform differences
- Supported Hardware -- Support for third-party hardware, such as webcam, Raspberry Pi™, and Arduino® hardware

MATLAB is an abbreviation for "matrix laboratory." While other programming languages usually work with numbers one at a time, MATLAB® operates on whole matrices and arrays.

Matlab 全名称为矩阵工厂，主程序界面内容包括：

- 顶部菜单栏，提供通用的窗口功能、绘图、APPS、Publish、View 等功能；
- 主体部分包信程序代码编辑器，和命令窗口，分别用于编程脚本等程序代码，或直接执行脚本；
- 两侧有目录树窗口、以及展示当前程序运行中产生的变量信息的 Workspace，使用 Workspace Variables and MAT-Files 相关命令管理；


Startup and Shutdown

Startup command line flags, startup and shutdown files

Functions

- *matlab (Windows)*    Start MATLAB program from Windows system prompt
- *matlab (Mac)*    Start MATLAB program from Mac Terminal
- *matlab (Linux)*  Start MATLAB program from Linux system prompt
- *exit*    Terminate MATLAB program (same as quit)
- *quit*    Terminate MATLAB program

- *matlabrc*    Start up file for MATLAB program
- *startup* Start up file for user-defined options
- *finish*  Termination file for MATLAB program


Platform and License

Information about current computer, license, product version

Functions

- *version* Version number for MATLAB and libraries
- *ver* Version information for MathWorks products
- *verLessThan* Compare toolbox release or version to specified string
- *license* Get license number or perform licensing task
- *ispc*    Determine if version is for Windows (PC) platform
- *ismac*   Determine if version is for Mac OS X platform
- *isunix*  Determine if version is for Linux or Mac platforms
- *isstudent*   Determine if version is Student Version
- *javachk* Error message based on Java feature support
- *usejava* Determine if Java feature is available

Help and Support

Product help, technical support

Functions

- *doc* -- Reference page in Help browserSearch for term in documentation
- *help*    -- Help for functions in Command Window
- *docsearch*   -- Help browser search
- *lookfor* -- Search for keyword in all help entries
- *demo*    -- Access product examples in Help browser
- *echodemo*    -- Run example script step-by-step in Command Window

使用 clear 命令清除符号定义，使用 clc 命令清除命令控制台内容。

使用 who 和 whos 命令查询变量及详细信息，详细信息参考 Data Import and Export - Workspace Variables and MAT-Files，Manage data in the MATLAB® workspace


## ==⚡ Encoding setting

使用 UTF-8 是最好的编码方案，这样可以在程序文件中使用各种符号而不会乱码。

但 Matlab 会根据操作系统区域语言环境设置来选择默认编码方案，列如中文系统中会设置 GBK 为默认编码方案，这样使用 UTF-8 符号就会乱码。

参考文档 Desktop Environment - Internationalization: Locale settings and messages。

要修改 UTF-8 为默认编码方案，需要改变安装目录下的 *bin/lcdata.xml* 编码配置文件来实现，或者修改系统区域设置。直接将 *bin/lcdata_utf8.xml* 覆盖它并不起作用，并且没有提供喜好配置。

首先，使用 *feature('locale')* 或 *feature('DefaultCharacterSet')* 命令找出当前使用默认编码方案设置：

```sh
>> feature('locale')

ans = 

               ctype: 'zh_SG.GBK'
             collate: 'zh_SG.GBK'
                time: 'zh_SG.GBK'
             numeric: 'en_US_POSIX.GBK'
            monetary: 'zh_SG.GBK'
            messages: 'zh_SG.GBK'
            encoding: 'GBK'
    terminalEncoding: 'GBK'
         jvmEncoding: 'GBK'
              status: 'MathWorks locale management system initialized.'
             warning: ''
```

然后，根据输出内容 encoding 部分指定的编码方案，注解掉默认编码设置，并将默认编码方案作为别名添加到 UTF-8 编码设置中：

```xml
<!-- 
<encoding name="GBK">
    <encoding_alias name="936"/>
</encoding>
-->
<encoding name="UTF-8">
    <encoding_alias name="utf8"/>
    <encoding_alias name="GBK"/>
</encoding>
```

这么做的目的就是，将 GBK 编码从一种独立的编码方式，改成了 UTF-8 的一个别名，从而欺骗 Matlab，让它使用 UTF-8。虽然很不优雅，但是真的有用。

Matlab 配置面板中，可以改变 Command Window 或 Editor 使用的字体 ，控制台默认使用 Monospaced 定宽字符，可以设置其它支持 Unicode 字体。

Simulink offers a functions slCharacterEncoding.

Change MATLAB character set encoding

    currentCharacterEncoding = slCharacterEncoding()
    slCharacterEncoding(encoding)

This command allows you to change the current MATLAB® character set encoding to be compatible with the character encoding of a model that you want to open.

currentCharacterEncoding = slCharacterEncoding() returns the current MATLAB character set encoding.

slCharacterEncoding(encoding) changes the MATLAB character set encoding to the specified encoding. You should only specify these values:

- 'US-ASCII'
- 'Windows-1252'
- 'ISO-8859-1'
- 'Shift_JIS'
- 'UTF-8'

## ==⚡ Language Fundamentals

基础内容包括：

- Entering Commands  -- Build and run MATLAB statements
- Matrices and Arrays  -- Array indexing, concatenation, sorting, and reshaping
- Operators and Elementary Operations  -- Arithmetic, relational, logical, set, and bit-wise operations
- Special Characters  -- Symbols
- Data Types  -- Numeric arrays, character arrays, tables, structures, and cell arrays; data type conversion

### ===🗝 Special Characters 

Special Symbols

- [ ]   Brackets are used to form vectors and matrices.
- { }   Curly braces are used in cell array assignment statements. 
- ...   Continuation. Three or more periods at the end of a line continue the current function on the next line.
- ,     Comma. Used to separate matrix subscripts and function arguments. Used to separate statements in multistatement lines.
- ;     Used inside brackets to end rows. Used after an expression or statement to suppress printing or to separate statements.
- !     Indicates that the rest of the input line is issued as a command to the operating system.
- %     Percent. The percent symbol denotes a comment; it indicates a logical end of line. 
- %{ %} Percent-brace. The text enclosed within the %{ and %} symbols is a comment block.
- :     *colon* function. Create vectors, array subscripting, and for-loop iterators
- @     Function handle. MATLAB data type that is a handle to a function. 

```matlab
% Using the colon with integers,
D = 1:4
```

圆括号 ( ) 的功能比较多，除了提升运算符优先级，和函数参数列表中使用，还用于 vectors、matrices 中的下标操作符号，这种用法不常规。

If X and V are vectors, then X(V) is [X(V(1)), X(V(2)), ..., X(V(n))]. The components of V must be integers to be used as subscripts. An error occurs if any such subscript is less than 1 or greater than the size of X. Some examples are

- X(3) is the third element of X.
- X([1 2 3]) is the first three elements of X.

See help paren for more information about ( ).

If X has n components, X(n:–1:1) reverses them. The same indirect subscripting works in matrices. If V has m components and W has n components, then A(V,W) is the m-by-n matrix formed from the elements of A whose subscripts are the elements of V and W. For example, A([1,5],:) = A([5,1],:) interchanges rows 1 and 5 of A.

Some uses of special characters have function equivalents, as shown:

```matlab
% Horizontal concatenation
[A,B,C...]
horzcat(A,B,C...)
% Vertical concatenation
[A;B;C...]
vertcat(A,B,C...)
% Subscript reference
A(i,j,k...)
subsref(A,S)
% Subscript assignment
A(i,j,k...)= B
subsasgn(A,S,B)
```

Special Values

Several functions return important special values that you can use in your own program files.

- *ans* Most recent answer (variable). If you do not assign an output variable to an expression, MATLAB® automatically stores the result in ans.
- *eps* Floating-point relative accuracy. This is the tolerance the MATLAB software uses in its calculations.
- *intmax* Largest 8-, 16-, 32-, or 64-bit integer your computer can represent.
- *intmin* Smallest 8-, 16-, 32-, or 64-bit integer your computer can represent.
- *realmax* Largest floating-point number your computer can represent.
- *realmin* Smallest positive floating-point number your computer can represent.
- *pi* 3.1415926535897...
- *i*, *j* Imaginary unit.
- *inf* Infinity. Calculations like n/0, where n is any nonzero real value, result in inf.
- *NaN* Not a Number, an invalid numeric value. Expressions like 0/0 and inf/inf result in a NaN, as do arithmetic operations involving a NaN. Also, if n is complex with a zero real part, then n/0 returns a value with a NaN real part.
- *computer* Computer type.
- *version* MATLAB version string.


### ===🗝 Entering Commands 

Functions

- *ans* Most recent answer
- *clc* Clear Command Window
- *diary*   Save Command Window text to file
- *format*  Set Command Window output display format
- *home*    Send cursor home
- *iskeyword*   Determine whether input is MATLAB keyword
- *more*    Control paged output for Command Window

在命令窗口直接输入脚本语句，按回车执行，按 Shift + Return 换行继续输入代码：

```matlab
%% define variable
A = pi;
format hex; A   % A = 400921fb54442d18
format rat; A   % A = 355/113   
format long; A  % A = 3.141592653589793
format short; A     % A = 3.1416
format shortEng; A  % A = 3.1416e+000
format longEng; A   % A = 3.14159265358979e+000
%% Reset Format to Default
format short
format loose
```

格式及后缀含义：

- G     -- shortG: short or shortE, longG: long or longE, whichever is more compact.
- E     -- scientific notation
- Eng   -- engineering notation
- +     -- Positive/Negative format with +, -, and blank characters displayed for positive, negative, and zero elements.
- bank  -- Currency format with 2 digits after the decimal point.
- hex   -- Hexadecimal representation of a binary double-precision number.
- rat   -- Ratio of small integers.
- compact -- Suppress excess blank lines to show more output on a single screen.
- loose   -- Add blank lines to make output more readable.


推荐使用程序文件，使用 *edit* 命令创建程序文件。并且使用 .m 程序文件还有个好处，可以使用菜单 Publish 功能将程序输出内容发布为 HTML 页面分享。

同时，使用 %% 注解可以分段执行，单个 % 表示一般注解内容。按 Ctrl + Return，执行当前分段，按 F5 执行整个程序文件。

使用分号结束一个语句，并且不产生输出内容，一般语句会输出相应的内容。

除了默认语句输出内容，还只可以使用 fprintf 格式化输出，或者使用 disp 打印变量值：

```matlab
%% format output
A1 = [9.9, 9900];
A2 = [8.8,  7.7 ; ...
      8800, 7700];
formatSpec = 'X is %4.2f meters or %8.3f mm\n';
fprintf(formatSpec,A1,A2)
disp('Display value of variable')
```

超长内容可以使用 ellipsis (...) 省略号进行换行，字符串使用间引号包括：

```matlab
% Continue Long Statements on Multiple Lines
s = 1 - 1/2 + 1/3 - 1/4 + 1/5 ...
      - 1/6 + 1/7 - 1/8 + 1/9;

mystring = ['Accelerating the pace of ' ... 
            'engineering and science'];
```



### ===🗝 Datetypes 
- https://www.mathworks.com/help/matlab/matlab_prog/fundamental-matlab-classes.html


Matlab 拥有丰富的数据结构，及基本数据类型：

- Numeric Types     -- Integer and floating-point data
- Characters and Strings    -- Text in character arrays
- Dates and Time    -- Arrays of date and time values that can be displayed in different formats
- Categorical Arrays    -- Arrays of qualitative data with values from a finite set of discrete, nonnumeric data
- Tables    -- Arrays in tabular form whose named columns can have different types
- Structures    -- Arrays with named fields that can contain data of varying types and sizes
- Cell Arrays   -- Arrays that can contain data of varying types and sizes
- Function Handles      -- Variables that allow you to invoke a function indirectly
- Map Containers    -- Objects with keys that index to values, where keys need not be integers
- Time Series   -- Data vectors sampled over time

参考文档 Language Fundamentals -> Data Types -> Data Type Identification -> Fundamental MATLAB Classes

MATLAB 中经常会使用到 scalars, vectors, matrices, arrays 这些数据结构概念，实际上它们都是数组结构，只是大小尺寸不同，可以通过 *class()* 函数检查原始类型：

- *array* has any size RxCxPx....(x1x1x1x1...), it can be numeric/logical/char class
- *matrix* is an array with size RxC(x1x1x1x1...)
- *vector* is a array with size 1xC(x1x1...) or Rx1(x1x1x1...).
- *scalar* is a array with size 1x1(x1x1x1...)

上面表达式中的大写字符含义：R - Row 行，C - Column 例，P - Plane 平面或者 Page，分别表示第一维、第二维、第三维的计数值。在进行矩阵索引操作时，也是先指定 Row，再指定 Column，再指定 Page。

在内存中，同一列的元素连续保存，然后是下一列的数据，然后是下一个平面。如果只有一行，那么这一行的数据连续在内存中保存。

例如，1x1 表示只有一个值的数组就是标量；1xC 或 Rx1 分别表示一行多列、多行一列，这就是向量；而矩阵就是行列式 RxC，可以有多行、多列。

使用行、例、页是方便理解多维数据的数据索引操作，其实可以使用更多的维度，例如：

- D-1 is Row;
- D-2 is Column;
- D-3 is Plane/Page;
- 第四维可以叫做 Book；
- 第五维可以叫做 Shelf；
- 第六维可以叫做 Room；
- 第七维可以叫做 Storey；
- 第八维可以叫做 House；
- 第九维可以叫做 Street；

以下用演示如何定义一个 3-D 数组，以及如何进行索引操作，结合 *colon* 函数：

```matlab
%% Multidimensional Arrays
% 3-D Array 3x3x2 
A = [5 7 8; 0 1 9; 4 3 6];       % Page 1
A(:,:,2) = [1 0 4; 3 5 6; 9 8 7] % Page 2
% Indexing operates
A(1)   % [5] at Row 1 (Column 1 and Page 1 by default)
A(1:3) % [5 0 4] All in Row 1 to 3 (Column 1 and Page 1 by default)
A(1,1,2) % [1] at Row 1, Column 1 and Page 2
% Indexing with colon function
A(:)   % [5 0 4 7 1 3 ...] All rows
A(1,:) % [5 7 8 1 0 4] All in Row 1
A(:,1) % [5;0;4] All Row in Column 1 (Page 1 by default)
A(:,1,:) % 3x1x2 Array, All in Column 1
```

除了使用逗号作为分列、分号作为分行，还可以直接使用空格以及换行符来定义一个矩阵，像以下这样定义一个 3-by-3 方阵：

    A=[ 1 2 3 
        4 5 6
        7 8 9]

数组的连接方式，除了可以直接使用方括号表达式进行 2 维数组连接外，还可以使用函数连接多维数组：

```matlab
A = [1 2; 3 4]; % 2x2 Matrix
B = [5 6; 7 8]; % 2x2 Matrix
cat(1, A, B) 
% 4x2 Matrix: Vertically concatenates [1 2; 3 4; 5 6; 7 8]
% vertcat(A,B)
% [A B]
% [[1 2; 3 4] [5 6; 7 8]]
cat(2, A, B) 
% 2x4 Matrix:  Horizontally concatenates [1 2 5 6; 3 4 7 8]
% horzcat(A,B)
% [A; B]
% [[1 2; 3 4]; [5 6; 7 8]]

cat(3, A, B) % 2x2x1 Matrix: 3D concatenation, Page 1: [1 2; 3 4] and Page 2: [5 6; 7 8]]
cat(4, A, B) % 2x2x1x1 Matrix: 4D concatenation
```

因为数组在内存中的数据是线性连续存储的，所以在程序中按任意维度重新组织数组是非常方便的操作，Reshaping Multidimensional Arrays 根本不需要改变内存的数据位置，只需要改变一正数组的维度信息。

```matlab
A = [1 2 3 4 5 6 7 8 9 10 11 12]; % 1x12 Matrix
reshape(A, [12 1]) % 12x1 Matrix
reshape(A,[2 2 3]) % 2x2x3 3-D Array
reshape(['automaticall'], [12 1]) % 1x12 char vector ➡ 12x1 char vector
```

Matlab 提供了许多 Sorting and Reshaping Arrays 函数，如 *sort, rotate, permute, reshape, shiftdim*。

冒号函数是最常用的向量、数组生成函数，也用在 for 循环中生成迭代器。

*colon* 函数有两种基本结构：

- `j:k` 等价矩阵 `[j,j+1,j+2,...,j+m]`，其中 m = fix(k-j)。当 j、k 为整数，简化为 `[j,j+1,...,k]`。当 j > k 返回空矩阵，Empty matrix: 1-by-0。
- `j:i:k` 等价矩阵 `[j,j+i,j+2i, ...,j+m*i]`，其中 m = fix((k-j)/i)。此三种情况都返回空矩阵：

		i == 0, i > 0 and j > k, i < 0 and j < k.

You can use the colon to create a vector of indices to select rows, columns, or elements of arrays, where:

- `A(:,j)` is the jth column of A.
- `A(i,:)` is the ith row of A.
- `A(:,:)` is the equivalent two-dimensional array. For matrices this is the same as A.
- `A(j:k)` is A(j), A(j+1),...,A(k).
- `A(:,j:k)` is A(:,j), A(:,j+1),...,A(:,k).
- `A(:,:,k)` is the kth page of three-dimensional array A.
- `A(i,j,k,:)` is a vector in four-dimensional array A. The vector includes A(i,j,k,1), A(i,j,k,2), A(i,j,k,3), and so on.
- `A(:)` is all the elements of A, regarded as a single column. On the left side of an assignment statement, A(:) fills A, preserving its shape from before. In this case, the right side must contain the same number of elements as A.


By default, MATLAB® stores all numeric variables as double-precision floating-point values. Additional data types store text, integer or single-precision values, or a combination of related data in a single variable.

There are 16 fundamental classes in MATLAB. Each of these classes is in the form of a matrix or array. With the exception of function handles, this matrix or array is a minimum of 0-by-0 in size and can grow to an n-dimensional array of any size. A function handle is always scalar (1-by-1).

Matlab 16 种基本数据类形主要分为两大类，关系如下：

- Matrix or Array (Full or Sparse)
    - 2 Floating-Point Numbers: *double*, *single*
    - 8 Integers Numbers: *int8*, *uint8*, *int16*, *uint16*, *int32*, *uint32*, *int64*, *uint64*
    - 1 Character String: *char*
    - 1 Logical Operations: *logical*
    - 1 Structure: *struct*
    - 1 Table: *table*
    - 1 Cell Arrays: *cell*
- Scalar
    - 1 Function Handles: *function_handle*

![Fundamental MATLAB Classes](https://www.mathworks.com/help/releases/R2019b/matlab/matlab_prog/fundamental_classes.png)

其中 Function Handles 是特殊的一种类型，它就是函数的引用，相当于 C/C++ 中的函数地址的概念，可以将函数当作一个参数来传递而不是调用，使用 @function_name 这样的表达形式，包含匿名函数也是。

MATLAB 的 Matrices 和 Arrays 作为基本的数据结构，可以合并大多数类型，只要矩阵中的所有元素类型相同。如果在构造矩阵时确实包含不同类的元素，则 MATLAB 会转换某些元素，以生成的矩阵的所有元素有相同的类型。

数据类型转换是根据类的预设优先级进行的，列如，下表显示了五个代表类形的连接合并时的类型转换，字符和逻辑除外，它们不能合并。

|    TYPE   | character |  integer  |   single  |   double  | logical |
|-----------|-----------|-----------|-----------|-----------|---------|
| character | character | character | character | character | invalid |
| integer   | character | integer   | integer   | integer   | integer |
| single    | character | integer   | single    | single    | single  |
| double    | character | integer   | single    | double    | double  |
| logical   | invalid   | integer   | single    | double    | logical |

比如，double 和 single 元素的矩阵合并就会产生 single 类型的元素，MATLAB 将 double 元素向低数度的 single 转换，以保证精确性。

```matlab
%% Combining Single and Double Types ➡ single
x = [single(4.5) single(-2.8) pi 5.73*10^300]
% x = 4.5000   -2.8000    3.1416       Inf
class(x) % ans =   single

%% Combining Integer and Double Types ➡ int8
x = [int8(21) int8(-22) int8(23) pi 45/6]
% x = 21  -22   23    3    8
class(x) % ans =   int8

%% Combining Character and Double Types ➡ char
x = ['A' 'B' 'C' 68 69 70]
% x =   ABCDEF
class(x) % ans =   char

%% Combining Logical and Double Types ➡ double
x = [true false false pi sqrt(7)]
% x =    1.0000         0         0    3.1416    2.6458
class(x) % ans =   double
```

注意，数组中所有数值类型与字符类型合并使用时，会将数值转换为 char 类型。而如果与 Cell Array 合并，则会使用 Cell Array，并将原有数据及类型保存在 Cell 容器中。

Matlab 字符类型 *char* 用于文本、Unicode 字符表达，使用单引号包括，可以配合正则表达式进行处理。按 Matlab 的编程思维，除了 Function Handles，其它类型都会和数组、矩阵数据结构产生关联。字符串也是，使用方括号时，字符串在内存中就是连续存储的，所以多个单引号字符会拼接成一个字符串，也就是字符向量。如果要将字符串保存为多行，就需要各行字符数量一致，这是数组的内存结构决定的。而 Cell Array 可以按任意长度保存字符串，不需要像数组一样，各行有固定长度约束。

```matlab
S = ['✔✒▶➡' '↗↘↙↖' '↪↩⤴⤵'] % A string make up with chars
C = {'✔✒▶➡' '↗↘↙↖' '↪↩⤴⤵'} % Strings in Cell Array
V = ['✔✒▶➡';'↗↘↙↖';'↪↩⤴⤵'] % 3 Strings in 3x1 vector
```

字符串简单使用：

```matlab
% Converts to/from numeric.
Ai = int8('A') % 'A' ➡ 65
Ac = char(65)  % 65 ➡ 'A'
% Parse string.
str2num('65')  % '65' ➡ 65
num2str(65)    %  65 ➡ '65'

% Convert the integers 32–127 into a 3-by-32 array of the printable ASCII characters.
A = (32:127);
S = char(A);
S = reshape(S,32,3)'
% Convert string to uint8 array
d = uint8(S);

S =

 !"#$%&'()*+,-./0123456789:;<=>?
@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
`abcdefghijklmnopqrstuvwxyz{|}~
```

reshape 函数可以将数据按新的行列组织，但需要保持数据数量一致。分号 ' 是旋转操作 *rot90*。

单引号包括的字符串不能使用转义，使用换行符等效于 char(10,13) 或 sprintf('\n')，注意 charl(10,13) 是 2-by-1 向量结构。使用换行符与字符向量或字符串串联，或在换行符处拆分文本。

    str = ['A',char(13,10)','B']

Matlab R2016b 中推出 newline 函数用于创建换行符。


### ===🗝 Tables, structures, cell arrays

除了基本的数值、字符串类型，此外，Tables, structures, cell arrays 也是经常用到的数据结构类型。

Table 是一种重要的数据结构，是一种可嵌套的二维关系数据。首先要与数组类型进行区别，尽管它们很相似，特别是二维数组。Table 每列都可以使用不同的数据类型，这一点和数组很不同，并且各行数据结构都一样。

Table 是有表头的数据结构，和 Cell Array、数组、结构体可以通过类似 *cell2table* 或 *table2cell* 这样的函数互相转化。

```matlab
% Create a 4-by-4 cell array containing strings and numeric data.
C = {5 'cereal' 110 'C+'; 12 'pizza' 140 'B';...
    23 'salmon' 367 'A'; 2 'cookies' 160 'D'}

% Convert the cell array, C, to a table and specify variable names.

T = cell2table(C,...
    'VariableNames',{'Age' 'FavoriteFood' 'Calories' 'NutritionGrade'})
% T.Properties.VariableNames = C(1,:)

T = 

    Age    FavoriteFood    Calories    NutritionGrade
    ___    ____________    ________    ______________

     5     'cereal'        110         'C+'          
    12     'pizza'         140         'B'           
    23     'salmon'        367         'A'           
     2     'cookies'       160         'D'   
```

作为二维的数数据结构，Table 和二维数组在操作上差别还是比较大的，数组可以直接使用比较运算符对扬剧有数据进行操作，但 Table 不行，只能在数值类型的数组变量上进行。

Taable 数据的索引访问方式：

|   Methods    |       Syntax       |     Result     |       rows       |        vars/var       |
|--------------|--------------------|----------------|------------------|-----------------------|
| Parentheses  | T(rows,vars)       | table          | One or more rows | One or more variables |
| Curly Braces | T{rows,vars}       | extracted data | One or more rows | One or more variables |
| Dot Indexing | T.var T.(varindex) | extracted data | All rows         | One variable          |
| Dot Indexing | T.var(rows)        | extracted data | One or more rows | One variable          |

索引方式除了数值指定行、列，还可以使用 *RowNames* 和 *VariableNames* 属性指定的表头字符，用它来访问数据行、列。使用 *table* 创建表格数据结构时，会自动设置为传入数据的变量名。

假定 T 为表格对象，并且设置 *VariableNames* 包含了 *Amount* 这样的字段变量名，就可以使用 *T.Amount* 这样的方式访问列数据。

Table Properties 类型属性参考：

|      Properties      |   Default value    |                      Desc                     |
|----------------------|--------------------|-----------------------------------------------|
| VariableNames        |                    | cell array of nonempty, distinct strings      |
| RowNames             | {}                 | cell array of nonempty, distinct strings      |
| DimensionNames       | {'Row' 'Variable'} | two-element cell array of strings             |
| Description          | ''                 | string                                        |
| VariableDescriptions | {}                 | cell array of strings                         |
| VariableUnits        | {}                 | cell array of strings                         |
| UserData             | {}                 | Additional table information in any data type |


Table 不支持直接存储字符串，但可以使用 Cell Array 间接存储：

    table([1:10],[2:5],[{'a cell array'},{'more cell array'}])
    table({'ABC'})

Table 只可以在指定列上进行比较操作，并且不能在 Cell Array 变量上进行，也就是不能对字符串字段进行一些常规类型数组可以的运算操作：

```matlab
%% Table Indexing Methods
T = table([1;10;30], [1.5;2.5;2.0],{'apple'; 'pie'; 'pineapple'});
T.Properties.VariableNames = {'Amount', 'Price', 'Kind'};
T.Properties.RowNames = {'1st', 'R2', 'R3'};
T.Properties.RowNames{'1st'} = 'R1';
T.Properties.RowNames{end} = 'Last';
T.Properties.VariableUnits = {'kg' '$' ''};

% () Numberic/Var/RowName Indexing return table
R1C1 = T(1, 1); % Row 1 and Column 1
R1 = T(1,:);
C1 = T(:,1);
R1To3 = T(1:3, :); % T([1; 2; 3],:)
R1 = T({'R1'},{'Amount','Kind'});


% {} Numberic/Var/RowName Indexing extracts data
C3 = T{:,{'Kind'}};
R1 = T{'R1',1:2};
R1 = T{{'R1'},{'Amount','Price'}};
% Cannot concatenate the table variables 'Amount' and 'Kind', because their types are double and cell. 
% R1 = T{{'R1'},{'Amount','Kind'}}

% Access By VariableNames and logical filter
R1 = T(T.Amount < 10,:);
R2 = T(logical([0;1;0]),:);
% T.Kind is cell array, different from double array

% Edit Table datas
Row.Amount = 30;
Row.Price = 2.0;
Row.Kind = 'corn';
T = [T; struct2table(Row)];
T.Avg = mean(T{:,1:2},2); % sum(T{:,1},1)
T.Value = T{:,1} .* T{:,2};
T.DoublePrice = T{:,{'Price'}}*2;

% Compute Statistics Using a Grouping Variable
% rowfun(@some_fun,T, 'GroupingVariables','Amount','OutputVariableNames','z')
varfun(@mean,T,'InputVariables','Amount',...
    'GroupingVariables','Price')

% Search for Rows To Delete
toDelete = T.Amount<30;
T(toDelete,:) = [];
T(1,:) = []; % delete 1st row
```


Cell Array 和一般数组类似，只是它可以保存不同类型的数据，如 text, numbers, vector 等。在 Workspace 面板中查看并编辑时，可以发现每个 cell 就像是一个数据容器。

这种数据结构使用的 Cell 是一种 indexed data containers，也就是可以通过索引来定位数据的容器。这一点和结构化数组非常不同，它通过字符名来访问数据。

用它来定义数组、合并数组时，如 [100, {uint8(200), 300}, 'MATLAB'] 就会保持为 Cell Array 类型，但是不能用在多维数组中。

因为，同一个数组中的 Cell 容器可以存储不同类型的数据，所以它和一般的数组除了具有类似的索引操作外，许多常用的数组操作都不能在 Cell Array 上使用。同时，也可以注意到 Cell Array 有各种函数转换到 Table、Struct 类型，但是使用 *cell2mt* 时却不一定可以成功将 Cell Array 转换为矩阵。

Cell Array 有两种索引方式，没有 Table 索引方法复杂，并且也像一般数组一样使用方括来进行合并连接操作，因为它本身就是一种特殊的数组类型：

- Cell Indexing with Smooth Parentheses, ()
- Content Indexing with Curly Braces, {}

直接将方括号赋值给一个 Cell 的内容，就可以删除内容，如 `C{2,2} = []`，如果使用圆括号的索引方式进行赋值就需要使用同样的 Cell 类型的内容进行替换。

创建 Cell Array 使用花括号，和一般数组、向量等使用方括号不同，但同样使用分号断行，使用空格或逗号分列：

```matlab
% Cell Array Example: 
C={1, 'h', 5, 7; [1:2:11], 'm', 8, 25}
C={1 'hi' 5 7; [1:2:11] 'me' 8 25}
```

Use *find()* to find index of element in Array in MATLAB. How to find a element in cell array?

和 Table 类似，像 Cell Array 这种不方便对元素进行枚举的类型，提供了 *cellfun*、*rowfun*、*varfun* 这些函数分别枚举 Cell 或者 Table 类型的行或列。

同时，Cell Array 和 Table 也没有现成的 find 函数来查找元素所在位置，只能通过以上这些方法枚举处理：

```matlab
% Create a cell array that contains strings, 
% and abbreviate those strings to the first three characters. 
% Because the output strings are nonscalar, set UniformOutput to false.
days = {'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'};
abbrev = cellfun(@(x) x(1:3), days, 'UniformOutput', false)

days = {{'Monday';1}, {'Tuesday';2}, {'Wednesday';3}, {'Thursday';4}, {'Friday';5}};
index = find(cellfun(@(x) x{2}==3, days, 'UniformOutput', true))
index = find(cellfun(@(x) strcmpi(x{1},'Wednesday'), days))
wed = days{index}
```

如果，回调函数最终返回的是标量，scalar cell array, scalar structure, scalar value，即返回结果包含一个值并且类型、大小相同，就可以设置为 'UniformOutput' 输出格式。

虽然 Cell Arrays 不要求完全连续的内存存储， 但是 Cell 容器需要连续存储，这是基本的数组元素，需要固定位置规律以进行索引定位数据。对于大数组，就可能需要提前分配，Preallocate Memory for a Cell Array，否则有可能导致程序申请不到合适的内存。

使用 *cell* 函数或给 Cell Array 最后一个位置进行赋值都可以分配到相应的内存，如下分配 25-by-50 数组内存空间：

    C = cell(25,50);
    C{25,50} = [];

注意，这只是数组元素的连续内存空间，Cell 容器内的数据所需要的内存并没在此进行分配。


冒号函数 *colon* 经常用来挑选指定行、列、平面的数据组成新的结构：

```matlab
% 2-by-3 Cell Array
C = {'one', 'two', 'three';
     1, 2, 3};
% creates a 2-by-2 cell array
upperLeft = C(1:2,1:2)
% creates a 1-by-3 cell array
topRow = C(1:1,:) % = C(1,:) or C(1, 1:1:3)
botRow = C(end,:) % = C(2,:) or C(2, 1:1:3)
```

结构化数组 Structure Array，是结构体与数组的整合，每个结构体在内存中连续存放，但结构化数组不一定连续存放。

使用 *struct* 创建，也可以直接按以下方式创建，不用先定义字段。注意，避免结构体与现有的变量同名：

```matlab
%% struct Syntax
% Create structure array
% s = struct
% s = struct(field,value)example
% s = struct(field1,value1,...,fieldN,valueN)example
% s = struct([])
% s = struct(obj)

S.Name = {'CLARK';'BROWN';'MARTIN'};
S.Gender = {'M';'F';'M'};
S.SystolicBP = [124;122;130];
S.DiastolicBP = [93;80;92];
S

S = 
           Name: {3x1 cell}
         Gender: {3x1 cell}
     SystolicBP: [3x1 double]
    DiastolicBP: [3x1 double]
```

Matlab 提供了许多示范数据，以 patients.mat 为例，它包含了 100 个病历号的数据，分别用不同的变量保存，可以直接通过 load 命令或函数加载：

```matlab
clear
load patients.mat
whos

  Name                            Size            Bytes  Class      Attributes

  Age                           100x1               800  double               
  Diastolic                     100x1               800  double               
  Gender                        100x1              7012  cell                 
  Height                        100x1               800  double               
  LastName                      100x1              7216  cell                 
  Location                      100x1              9808  cell                 
  SelfAssessedHealthStatus      100x1              7140  cell                 
  Smoker                        100x1               100  logical              
  Systolic                      100x1               800  double               
  Weight                        100x1               800  double  
```

直接通过 *table* 创建表格数据结构，自动设置在构造传入的变量名：

```matlab
Age = [ 38; 43; 38; 40; 49 ];
Gender = { 'Male'; 'Male'; 'Female'; 'Female'; 'Female' };
Weight = [ 71; 69; 64; 67; 64 ];
Height = [ 176; 163; 131; 133; 119 ];
Smoker = [ true; false; false; false; false ];

T = table(Age, Gender, Weight, Height, Smoker);
LastName = {'Smith'; 'Johnson'; 'Williams'; 'Jones'; 'Brown'};
T.Properties.RowNames = LastName;
T
T = 
                Age     Gender     Weight    Height    Smoker
                ___    ________    ______    ______    ______
    Smith       38     'Male'      71        176       true  
    Johnson     43     'Male'      69        163       false 
    Williams    38     'Female'    64        131       false 
    Jones       40     'Female'    67        133       false 
    Brown       49     'Female'    64        119       false 
```


### ===🗝 Data Type Identification

Data Type Identification

Determining data type of a variable

Functions

- *isa* Determine if input is object of specified class
- *iscalendarduration*  Determine if input is calendar duration array
- *iscategorical*   Determine whether input is categorical array
- *iscell*  Determine whether input is cell array
- *iscellstr*   Determine whether input is cell array of strings
- *ischar*  Determine whether item is character array
- *isdatetime*  Determine if input is datetime array
- *isduration*  Determine if input is duration array
- *isfield* Determine whether input is structure array field
- *isfloat* Determine if input is floating-point array
- *isgraphics*  True for valid graphics object handles
- *isinteger*   Determine if input is integer array
- *isjava*  Determine if input is Java object
- *islogical*   Determine if input is logical array
- *isnumeric*   Determine if input is numeric array
- *isobject*    Determine if input is MATLAB object
- *isreal*  Determine whether array is real
- *isenum*  Determine if variable is enumeration
- *isstruct*    Determine whether input is structure array
- *istable* Determine whether input is table

- *is* Detect state
- *class*   Determine class of object
- *validateattributes*  Check validity of array
- *whos*    List variables in workspace, with sizes and types


### ===🗝 Data Type Conversion

Data Type Conversion

Converting between numeric arrays, character arrays, cell arrays, structures, or tables
Functions

- *char*    Convert to character array (string)
- *cellstr* Convert to cell array of strings
- *int2str* Convert integer to string
- *mat2str* Convert matrix to string
- *num2str* Convert number to string
- *str2double*  Convert string to double-precision value
- *str2num* Convert string to number
- *native2unicode*  Convert numeric bytes to Unicode character representation
- *unicode2native*  Convert Unicode character representation to numeric bytes

- *base2dec*    Convert base N number string to decimal number
- *bin2dec* Convert binary number string to decimal number
- *dec2base*    Convert decimal to base N number in string
- *dec2bin* Convert decimal to binary number in string
- *dec2hex* Convert decimal to hexadecimal number in string
- *hex2dec* Convert hexadecimal number string to decimal number
- *hex2num* Convert hexadecimal number string to double-precision number
- *num2hex* Convert singles and doubles to IEEE hexadecimal strings

- *table2array* Convert table to homogeneous array
- *table2cell*  Convert table to cell array
- *table2struct*    Convert table to structure array
- *array2table* Convert homogeneous array to table
- *cell2table*  Convert cell array to table
- *struct2table*    Convert structure array to table

- *cell2mat*    Convert cell array to ordinary array of the underlying data type
- *cell2struct* Convert cell array to structure array
- *mat2cell*    Convert array to cell array with potentially different sized cells
- *num2cell*    Convert array to cell array with consistently sized cells
- *struct2cell* Convert structure to cell array

Conversion Examples

- uintN (e.g., uint8) -- *'Hi'* → *72 105* Convert a character to an integer code that represents that character.
- str2num -- *'72 105'* → *[72 105]* Convert a character type to a numeric type.
- str2double *{'72' -- '105'}* → *[72 105]* Similar to str2num, but offers better performance and works with cell arrays of strings.
- hex2num -- *'A'* → *'-1.4917e-154'* Convert a numeric type to a character type of specified precision, returning a string that MATLAB® can evaluate.
- hex2dec -- *'A'* → *10* Convert a character type of hexadecimal base to a positive integer.
- bin2dec -- *'1010'* → *10* Convert a character type of binary number to a decimal number.
- base2dec -- *'12'* → *10 (if base == 8)* Convert a character type of any base number from 2 through 36 to a decimal number.

- char -- *[72 105]* → *'Hi'* Convert a positive integer to an equivalent character. (Truncates any fractional parts.)
- int2str -- *[72 105]* → *'72 105'* Convert a positive or negative integer to a character type. (Rounds any fractional parts.)
- num2str -- *[72 105]* → *'72/105/' (format set to %1d/)* Convert a numeric type to a character type of the specified precision and format.
- mat2str -- *[72 105]* → *'[72 105]'* Convert a numeric type to a character type of the specified precision, returning a string MATLAB® can evaluate.
- dec2hex -- *[72 105]* → *'48 69'* Convert a positive integer to a character type of hexadecimal base.
- dec2bin -- *[72 105]* → *'1001000 1101001'* Convert a positive integer to a character type of binary base.
- dec2base -- *[72 105]* → *'110 151' (base set to 8)* Convert a positive integer to a character type of any base from 2 through 36.



### ===🗝 Numeric Types

Integer and floating-point data

Numeric classes in MATLAB® include signed and unsigned integers, and single-precision and double-precision floating-point numbers. By default, MATLAB stores all numeric values as double-precision floating point. (You cannot change the default type and precision.) You can choose to store any number, or array of numbers, as integers or as single-precision. Integer and single precision arrays offer more memory-efficient storage than double precision.

All numeric types support basic array operations, such as subscripting, reshaping, and mathematical operations.

Functions

- *double*  Convert to double precision
- *single*  Convert to single precision
- *int8*    Convert to 8-bit signed integer
- *int16*   Convert to 16-bit signed integer
- *int32*   Convert to 32-bit signed integer
- *int64*   Convert to 64-bit signed integer
- *uint8*   Convert to 8-bit unsigned integer
- *uint16*  Convert to 16-bit unsigned integer
- *uint32*  Convert to 32-bit unsigned integer
- *uint64*  Convert to 64-bit unsigned integer

- *cast*    Cast variable to different data type
- *typecast*    Convert data types without changing underlying data

- *isinteger*   Determine if input is integer array
- *isfloat* Determine if input is floating-point array
- *isnumeric*   Determine if input is numeric array
- *isreal*  Determine whether array is real
- *isfinite*    Array elements that are finite
- *isinf*   Array elements that are infinite
- *isnan*   Array elements that are NaN

- *eps* Floating-point relative accuracy
- *flintmax*    Largest consecutive integer in floating-point format
- *Inf* Infinity
- *intmax*  Largest value of specified integer type
- *intmin*  Smallest value of specified integer type
- *NaN* Not-a-Number
- *realmax* Largest positive floating-point number
- *realmin* Smallest positive normalized floating-point number


### ===🗝 Matrices and Arrays

Matrices and Arrays

Array indexing, concatenation, sorting, and reshaping

- Array Creation and Concatenation -- Create or combine scalars, vectors, matrices, or arrays
- Indexing -- Access array elements
- Array Dimensions -- Determine array size or shape
- Sorting and Reshaping Arrays -- Sort, rotate, permute, reshape, or shift array contents

Array Creation and Concatenation

Create or combine scalars, vectors, matrices, or arrays


- *accumarray*  Construct array with accumulation
- *blkdiag* Construct block diagonal matrix from input arguments
- *diag*    Create diagonal matrix or get diagonal elements of matrix
- *eye* Identity matrix
- *freqspace*   Frequency spacing for frequency response
- *linspace*    Generate linearly spaced vector
- *logspace*    Generate logarithmically spaced vector
- *meshgrid*    Rectangular grid in 2-D and 3-D space
- *ndgrid*  Rectangular grid in N-D space
- *rand*    Uniformly distributed random numbers
- *false*   Logical 0 (false)
- *true*    Logical 1 (true)
- *zeros*   Create array of all zeros
- *ones*    Create array of all ones
- *cat* Concatenate arrays along specified dimension
- *horzcat* Concatenate arrays horizontally
- *vertcat* Concatenate arrays vertically

Indexing

Access array elements


- *colon*   Create vectors, array subscripting, and for-loop iterators
- *end* Terminate block of code, or indicate last array index
- *ind2sub* Subscripts from linear index
- *sub2ind* Convert subscripts to linear indices

Array Dimensions

Determine array size or shape

- *length*  Length of largest array dimension
- *ndims*   Number of array dimensions
- *numel*   Number of array elements
- *size*    Array dimensions
- *height*  Number of table rows
- *width*   Number of table variables
- *iscolumn*    Determine whether input is column vector
- *isempty* Determine whether array is empty
- *ismatrix*    Determine whether input is matrix
- *isrow*   Determine whether input is row vector
- *isscalar*    Determine whether input is scalar
- *isvector*    Determine whether input is vector


Sorting and Reshaping Arrays

Sort, rotate, permute, reshape, or shift array contents

- *blkdiag* Construct block diagonal matrix from input arguments
- *circshift*   Shift array circularly
- *ctranspose*  Complex conjugate transpose
- *diag*    Create diagonal matrix or get diagonal elements of matrix
- *flip*    Flip order of elements
- *fliplr*  Flip array left to right
- *flipud*  Flip array up to down
- *ipermute*    Inverse permute dimensions of N-D array
- *permute* Rearrange dimensions of N-D array
- *repelem* Repeat copies of array elements
- *repmat*  Repeat copies of array
- *reshape* Reshape array
- *rot90*   Rotate array 90 degrees
- *shiftdim*    Shift dimensions
- *issorted*    Determine whether set elements are in sorted order
- *sort*    Sort array elements
- *sortrows*    Sort array rows
- *squeeze* Remove singleton dimensions
- *transpose*   Transpose vector or matrix
- *vectorize*   Vectorize expression

Transpose 对矩阵 A 进行转置操作，得到的矩阵叫做 A 转置，即 A^T，把原来的同行元素转变为同一列。对矩阵旋转操作 *rot90* 和转置操作，有点类似，简化符号分别为 .' 和 '：

```matlab
% Rotate array 90 degrees
A = (1:5)'
B = rot90(A)

% Transpose vector or matrix
A = [1:5; 2:6; 3:7].'
B = transpose(A)
```

Four Kinds of Special Matrices

- A diagonal matrix is a matrix where only the diagonal entries are non-zero. 
- An identity matrix, I, is the diagonal matrix with diagonal consisting of all 1’s. AI = A and IA = A.
- An upper triangular matrix is a matrix whose entries lying below the diagonal are all zero.
- A lower triangular matrix is a matrix whose entries lying above the diagonal are all zero.

The empty matrix is represented in MATLAB as [ ]. This is a matrix with dimension zero-by-zero.


```matlab
% Special Matrices: The “diag” Command for Diagonal Matrix-
A = diag([1 2 3]) % generate a diagonal matrix

I = diag([1,1,1]) % 3-by-3 Identity Matrix
I = eye(3) % 3-by-3 Identity Matrix

zeros(n,m) % n-by-m matrix fill 0
ones(n,m)  % n-by-m matrix fill 1
rand(n,m)  % n-by-m matrix with random numbers value between [0, 1]

magic(n)  % n-by-n square matrix whose entries constitute a magic square; i.e.,
% the sum of elements along each row, column, or principal diagonal is the same value.
```


### ===🗝 Complex Number

Complex Number Functions

- *complex* Construct complex data from real and imaginary components.
- *i* or *j* Return the imaginary unit used in constructing complex data.
- *real* Return the real part of a complex number.
- *imag* Return the imaginary part of a complex number.
- *isreal* Determine if a number is real or imaginary.

Matlab 的复数是一种数学概念，不是一种数据类型，直接使用虚数单位 *i* or *j*，电子工程常用后者。

一个复数由两部分构成，包含虚部和实部。

Complex numbers consist of two separate parts: a real part and an imaginary part. The basic imaginary unit is equal to the square root of -1. This is represented in MATLAB® by either of two letters: i or j.

The following statement shows one way of creating a complex value in MATLAB. The variable x is assigned a complex number with a real part of 2 and an imaginary part of 3:

    x = 2 + 3i;

Another way to create a complex number is using the complex function. This function combines two numeric inputs into a complex output, making the first input real and the second imaginary:

    x = rand(3) * 5;
    y = rand(3) * -8;

    z = complex(x, y)
    z =
       4.7842 -1.0921i   0.8648 -1.5931i   1.2616 -2.2753i
       2.6130 -0.0941i   4.8987 -2.3898i   4.3787 -3.7538i
       4.4007 -7.1512i   1.3572 -5.2915i   3.6865 -0.5182i

You can separate a complex number into its real and imaginary parts using the real and imag functions:

    zr = real(z)
    zr =
        4.7842    0.8648    1.2616
        2.6130    4.8987    4.3787
        4.4007    1.3572    3.6865

    zi = imag(z)
    zi =
       -1.0921   -1.5931   -2.2753
       -0.0941   -2.3898   -3.7538
       -7.1512   -5.2915   -0.5182


### ===🗝 Dates and Times

时间、日期、期间分别是三个概念，时间和日期一起标记了一个确定的时间刻度，Duration 表示两个时间刻度的差值具有的时间长度。通过两个 datetime 相减可以得到 duration，但两个 datetime 不能相加，因为没有意义，但可以给 datetime 加上 duration 移动时间刻度。两个 duration 可以相加减，它还是时间长度。

Create Date and Time Arrays

Create arrays to represent dates, time, and duration

The primary way to store date and time information is in datetime arrays, which support arithmetic, sorting, comparisons, plotting, and formatted display. The results of arithmetic computations are returned in duration arrays or, when you use calendar-based functions, in calendarDuration arrays. For more information, see Represent Dates and Times in MATLAB.

- *datetime*    Create array based on current date, or convert from date strings or numbers
- *timezones*   List time zones

- *years*   Duration in years
- *days*    Duration in days
- *hours*   Duration in hours
- *minutes* Duration in minutes
- *seconds* Duration in seconds
- *milliseconds*    Duration in milliseconds
- *duration*    Create duration array from numeric values

- *calyears*    Calendar duration in years
- *calquarters* Calendar duration in quarters
- *calmonths*   Calendar duration in months
- *calweeks*    Calendar duration in weeks
- *caldays* Calendar duration in days
- *calendarDuration*    Create calendar duration array from numeric values

- *exceltime*   Convert MATLAB datetime to Excel date number
- *juliandate*  Convert MATLAB datetime to Julian date
- *posixtime*   Convert MATLAB datetime to POSIX time
- *yyyymmdd*    Convert MATLAB datetime to YYYYMMDD numeric value

Components of Dates and Time
Extract or set quantities of date and time arrays, such as years or seconds

Use the functions and properties on this page to extract values for specific date and time components. Additionally, use datetime properties to assign values to specific date and time components.

- *year*    Year number
- *quarter* Quarter number
- *month*   Month number and name
- *week*    Week number
- *day* Day number or name
- *hour*    Hour number
- *minute*  Minute number
- *second*  Second number

- *ymd* Year, month, and day numbers of datetime
- *hms* Hour, minute, and second numbers of duration
- *split*   Split calendar duration into numeric and duration units
- *time*    Convert time of calendar duration to duration
- *timeofday*   Elapsed time since midnight for datetimes

- *isdst*   Determine daylight saving time elements
- *isweekend*   Determine weekend elements
- *tzoffset*    Time zone offset from UTC

Date and Time Arithmetic and Plotting

Query data, add, subtract, and plot dates and time

Many arithmetic operators and elementary math functions such as plus, minus, max, and min operate on date and time arrays in much the same way that they operate on other arrays, using fixed-length units. To perform calendar calculations, use the functions on this page.

- *between* Calendar math differences
- *caldiff* Calendar math successive differences
- *dateshift*   Shift date or generate sequence of dates and time
- *isbetween*   Determine elements within date and time interval
- *isdatetime*  Determine if input is datetime array
- *isduration*  Determine if input is duration array
- *iscalendarduration*  Determine if input is calendar duration array
- *isnat*   Determine NaT (Not-a-Time) elements
- *NaT* Not-a-Time

Dates and Time as Numbers and Strings
Represent dates and time as double-precision numeric values or strings

If you work with code authored in MATLAB® R2014a or earlier, or if you share code with others who use such a version, you might need to work with dates and time stored as double-precision values or as strings. In addition, numeric representations of dates and time are useful as inputs to some MATLAB functions that do not accept the datetime or duration data types. For more information, see Convert Between Datetime Arrays, Numbers, and Strings

- *datenum* Convert date and time to serial date number
- *datevec* Convert date and time to vector of components
- *datestr* Convert date and time to string format
- *char*    Convert to character array (string)
- *cellstr* Convert to cell array of strings

- *now* Current date and time as serial date number
- *clock*   Current date and time as date vector
- *date*    Current date string

- *calendar*    Calendar for specified month
- *eomday*  Last day of month
- *weekday* Day of week

- *addtodate*   Modify date number by field
- *etime*   Time elapsed between date vectors

Code Performance
Measure and profile MATLAB® code to improve performance

- *timeit*  Measure time required to run function
- *tic* Start stopwatch timer
- *toc* Read elapsed time from stopwatch
- *cputime* Elapsed CPU time
- *profile* Profile execution time for functions
- *bench*   MATLAB benchmark


Properties

datetime Properties Assign date and time components and specify datetime display format

- Format         — Display format: 'default' | 'defaultdate' | string
- TimeZone       — Time zone: '' (default) | string
- Year           — Year number: scalar | vector | matrix | multidimensional array
- Month          — Month number: scalar | vector | matrix | multidimensional array
- Day            — Day-of-month number: scalar | vector | matrix | multidimensional array
- Hour           — Hour number: scalar | vector | matrix | multidimensional array
- Minute         — Minute number: scalar | vector | matrix | multidimensional array
- Second         — Second: scalar | vector | matrix | multidimensional array
- SystemTimeZone — System time zone setting: string. Example: America/New_York

The Format property controls the display of datetime values. The other properties control the values of components such as years and months in the datetime array. Use dot notation to refer to a particular array and property:

```matlab
% relativeDay — Day relative to current date
% 'yesterday' | 'today' | 'tomorrow' | 'now'
t = datetime('now')
t = datetime('2/3/2022 14:31:10','Format','dd/MM/yyyy HH:mm:ss')
t = datetime(2014,07,01,06,0,0);
t.Format = 'MMMM d, y';
```

Display format, specified as a string of the letters A-Z and a-z, that correspond to the Unicode® Locale Data Markup Language (LDML) standard for dates.

Example: 'eeee, MMMM d, yyyy HH:mm:ss' displays a date and time such as Saturday, April 5, 2014 21:41:06.

The following tables show the letters you can use to construct the value for Format. You can include nonletter characters such as a hyphen, space, colon, or any non-ASCII characters to separate the fields. To include the letters A-Z and a-z as literal characters in the format, enclose them with single quotes.

Example: 'uuuu-MM-dd''T''HH:mm:ss' displays a date and time, such as 2014-04-05T09:41:06.

The examples display the formatted output for the date, Saturday, April 5, 2014 at 9:41:06.12345 PM, in New York City.




### ===🗝 Character and Strings

Create and Concatenate Strings

Store text in character arrays, combine character arrays

Functions

- *blanks*  Create character array of blanks
- *cellstr* Convert to cell array of strings
- *char*    Convert to character array (string)
- *iscellstr*   Determine whether input is cell array of strings
- *ischar*  Determine whether item is character array
- *sprintf* Format data into string
- *strcat*  Concatenate strings horizontally
- *strjoin* Join strings in cell array into single string

Compare Strings

Determine if strings or parts of strings are equal

Functions

- *strcmp*  Compare strings
- *strcmpi* Compare strings (case insensitive)
- *strncmp* Compare first n characters of strings (case sensitive)
- *strncmpi*    Compare first n characters of strings (case insensitive)

Change String Case, Blanks, and Justification

Change to upper- or lowercase, create or remove white space

Functions

- *blanks*  Create character array of blanks
- *deblank* Strip trailing blanks from end of string
- *strtrim* Remove leading and trailing white space from string
- *lower*   Convert string to lowercase
- *upper*   Convert string to uppercase
- *strjust* Justify character array

The following MATLAB® functions offer the capability to compose a string that includes ordinary text and data formatted to your specification:

- *sprintf* — Write formatted data to an output string
- *fprintf* — Write formatted data to an output file or the Command Window
- *warning* — Display formatted data in a warning message
- *error* — Display formatted data in an error message and abort
- *assert* — Generate an error when a condition is violated
- *MException* — Capture error information


### ===🗝 Regular Expressions

There are four MATLAB® functions that support searching and replacing characters using regular expressions. The first three are similar in the input values they accept and the output values they return. For details, click the links to the function reference pages.

- *regexp* Match regular expression.
- *regexpi* Match regular expression, ignoring case.
- *regexprep* Replace part of string using regular expression.
- *regexptranslate* Translate string into regular expression.

```matlab
pattern = 'k(ilo)?m(eters)?(/|\sper\s)h(r|our)?';
text = ['The high-speed train traveled at 250 ', ...
   'kilometers per hour alongside the automobile ', ...
   'travelling at 120 km/h.'];
regexp(text, pattern, 'match')
ans = 
    'kilometers per hour'    'km/h'
```

### ===🗝 Operators and Elementary Operations


Arithmetic, relational, logical, set, and bit-wise operations

- Arithmetic    -- Addition, subtraction, multiplication, division, power, rounding
- Relational Operations     -- Value comparisons
- Logical Operations    -- True or false (Boolean) conditions
- Set Operations    -- Unions, intersection, set membership
- Bit-Wise Operations   -- Set, shift, or compare specific bit fields

Arithmetic

Addition, subtraction, multiplication, division, power, rounding
Functions

- *plus*    Addition
- *uplus*   Unary plus
- *minus*   Subtraction
- *uminus*  Unary minus
- *times*   Element-wise multiplication
- *rdivide* Right array division
- *ldivide* Left array division
- *power*   Element-wise power
- *mtimes*  Matrix Multiplication
- *mrdivide*    Solve systems of linear equations xA = B for x
- *mldivide*    Solve systems of linear equations Ax = B for x
- *mpower*  Matrix power
- *cumprod* Cumulative product
- *cumsum*  Cumulative sum
- *diff*    Differences and Approximate Derivatives
- *prod*    Product of array elements
- *sum* Sum of array elements
- *ceil*    Round toward positive infinity
- *fix* Round toward zero
- *floor*   Round toward negative infinity
- *idivide* Integer division with rounding option
- *mod* Remainder after division (modulo operation)
- *rem* Remainder after division
- *round*   Round to nearest decimal or integer

Relational Operations

- *eq*  Determine equality
- *ge*  Determine greater than or equal to
- *gt*  Determine greater than
- *le*  Determine less than or equal to
- *lt*  Determine less than
- *ne*  Determine inequality
- *isequal* Determine array equality
- *isequaln*    Determine array equality, treating NaN values as equal

		| Operator | Function |       Description        |
		|----------|----------|--------------------------|
		| ==       | eq       | Equal to                 |
		| >=       | ge       | Greater than or equal to |
		| >        | gt       | Greater than             |
		| <=       | le       | Less than or equal to    |
		| <        | lt       | Less than                |
		| ~=       | ne       | Not equal to             |


| Operator |  Function |           Purpose           |                         Description                          |
|----------|-----------|-----------------------------|--------------------------------------------------------------|
| +        | plus      | Addition                    | A+B adds A and B.                                            |
| +        | uplus     | Unary plus                  | +A returns A.                                                |
| -        | minus     | Subtraction                 | A-B subtracts B from A                                       |
| -        | uminus    | Unary minus                 | -A negates the elements of A.                                |
| .*       | times     | Element-wise multiplication | A.*B is the element-by-element product of A and B.           |
| .^       | power     | Element-wise power          | A.^B is the matrix with elements A(i,j) to the B(i,j) power. |
| ./       | rdivide   | Right array division        | A./B is the matrix with elements A(i,j)/B(i,j).              |
| .\       | ldivide   | Left array division         | A.\B is the matrix with elements B(i,j)/A(i,j).              |
| .'       | transpose | Array transpose             | A.' is the array transpose of A.                             |

For complex matrices, *transpose* does not involve conjugation.

The following table provides a summary of matrix arithmetic operators in MATLAB. For function-specific information, click the link to the function reference page in the last column.

| Operator |  Function  |           Purpose           |                           Description                            |
|----------|------------|-----------------------------|------------------------------------------------------------------|
| *        | mtimes     | Matrix multiplication       | C = A*B is the linear algebraic product of the matrices A and B. |
| /        | mrdivide   | Matrix right division       | x = B/A is the solution to the equation xA = B. B/A = (A'\B')'.  |
| \        | mldivide   | Matrix left division        | x = A\B is the solution to the equation Ax = B.                  |
| ^        | mpower     | Matrix power                | A^B is A to the power B, if B is a scalar.                       |
| '        | ctranspose | Complex conjugate transpose | A' is the linear algebraic transpose of A.                       |

For other values of B, Matrix power calculation involves eigenvalues and eigenvectors.
For complex matrices, *ctranspose* is the complex conjugate transpose.


Logical Operations

True or false (Boolean) conditions

The logical data type represents true or false states using the numbers 1 and 0, respectively. Certain MATLAB® functions and operators return logical values to indicate fulfillment of a condition. You can use those logical values to index into an array or execute conditional code. For more information, see how to Find Array Elements That Meet a Condition.

Functions

- *Logical Operators: Short-circuit && ||*    Logical operations with short-circuiting
- *and* Find logical AND
- *not* Find logical NOT
- *or*  Find logical OR
- *xor* Logical exclusive-OR

- *all* Determine if all array elements are nonzero or true
- *any* Determine if any array elements are nonzero
- *false*   Logical 0 (false)
- *find*    Find indices and values of nonzero elements
- *islogical*   Determine if input is logical array
- *logical* Convert numeric values to logicals
- *true*    Logical 1 (true)

Set Operations

Unions, intersection, set membership
Functions

- *intersect*   Set intersection of two arrays
- *ismember*    Array elements that are members of set array
- *ismembertol* Members of set within tolerance
- *issorted*    Determine whether set elements are in sorted order
- *setdiff* Set difference of two arrays
- *setxor*  Set exclusive OR of two arrays
- *union*   Set union of two arrays
- *unique*  Unique values in array
- *uniquetol*   Unique values within tolerance

- *join*    Merge two tables by matching up rows using key variables
- *innerjoin*   Inner join between two tables
- *outerjoin*   Outer join between two tables

Bit-Wise Operations

Set, shift, or compare specific bit fields
Functions

- *bitand*  Bit-wise AND
- *bitcmp*  Bit-wise complement
- *bitget*  Get bit at specified position
- *bitor*   Bit-wise OR
- *bitset*  Set bit at specific location
- *bitshift*    Shift bits specified number of places
- *bitxor*  Bit-wise XOR
- *swapbytes*   Swap byte ordering

Operator Precedence

- Parentheses ()
- Transpose (.'), power (.^), complex conjugate transpose ('), matrix power (^)
- Unary plus (+), unary minus (-), logical negation (~)
- Multiplication (.*), right division (./), left division (.\), matrix multiplication (*), matrix right division (/), matrix left division (\)
- Addition (+), subtraction (-)
- Colon operator (:)
- Less than (`<`), less than or equal to (`<=`), greater than (`>`), greater than or equal to (>=), equal to (==), not equal to (~=)
- Element-wise AND (&)
- Element-wise OR (|)
- Short-circuit AND (&&)
- Short-circuit OR (||)


## ==⚡ LaTeX Math Symbols
- A simple guide to LaTeX https://latex-tutorial.com/tutorials/
- LaTeX Tutorial: A Complete Guide https://www.resurchify.com/latex_tutorial/latex_tutorial.php
- LaTeX Tutorial: Symbols in LaTeX https://www.resurchify.com/latex_tutorial/latex_symbols.php
- Learn LaTeX in 30 minutes https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes
- Equation Editor https://latex.codecogs.com/editor.html
- EqnEditor (v5.1 beta)  https://editor.codecogs.com
- CodeCogs LaTeX Engine https://editor.codecogs.com/docs/
- LaTeXTools: A LaTeX Plugin for Sublime Text 2 and 3 https://latextools.readthedocs.io/en/latest/
- Quadratic equations & formula https://www.cuemath.com/algebra/quadratic-equations/
- Trigonometry https://www.cuemath.com/trigonometry/

LaTeX 是 Lamport TeX，文档预处理系统，文档排版功能强大，可以用来生成数学公式，这只是其符号处理功能。

- TeX：美国计算机教授高德纳 (Donald Ervin Knuth) 为了排版他的著作 『The Art of Computer Programming』(TAOCP) 编写的功能强大的排版软件。
- LaTeX：美国计算机科学家莱斯利·兰伯特为了准备他的著作 『The Great American Concurrency Book』基于 TeX 开发的宏
- TeX Live：是由国际 TEX 用户组整理和发布的TEX软件发行套装

可以用 CodeCogs Equation Editor 线上公式图片生成服务调用 LaTex API，比如：

![1/sin(x)](http://latex.codecogs.com/gif.latex?\frac{1}{1+sin%28x%29})

除了 gif 格式，还可以选择 pdf、svg 或 png 等格式：

- https://latex.codecogs.com/svg.latex?\lim_{x%20\to%200}%20f(x)%20=%208
- https://latex.codecogs.com/gif.latex?\dpi{400}\alpha&space;+&space;\frac{2\beta}{\gamma}
- https://latex.codecogs.com/png.latex?\dpi{400}\int%20\frac{1}{x}%20dx%20=%20\ln%20\left|%20x%20\right|%20+%20C


分数、除法表达 *\frac*，花括号用于符号分组，在分数中需要分母、分子两个分组表达式：

    y = y + \frac{sin(k*t)}{k}

上标和下标分别使用 ^ _ 表示，如 S^2 平方和数字下标 A_1，但特殊字符需要使用转义格式，如 \phi_m 表示 φ_m，在后者不能直接在 LaTeX 中使用。

求和表达式基本结构 \sum_{}^{}：

    \sum_{a=-\infty}^{\infty} (a_n sin(2\pi n v_0 t) + b_n cos(2\pi nv_0t))

<img src="http://latex.codecogs.com/svg.latex?\sum_{a=-\infty}^{\infty}&space;(a_n&space;sin(2\pi&space;n&space;v_0&space;t)&space;&plus;&space;b_n&space;cos(2\pi&space;nv_0t))" title="http://latex.codecogs.com/svg.latex?\sum_{a=-\infty}^{\infty} (a_n sin(2\pi n v_0 t) + b_n cos(2\pi nv_0t))" />

平方和公式：

    (a+b)^{2} = a^{2} + 2ab + b^{2}

General quadratic equation 标准一元二次方程表达：

    ax^2 + bx + c = 0

Quadratic Formula to Find Roots 标准一元二次方程求根公式 [-b ± √(b² - 4ac)]/2a：

    x=\frac{-b \pm \sqrt{b^2-4ac}}{2 a}

Discriminant 二次方和判别式：

    D = b^2 - 4ac

- D > 0, the roots are real and distinct
- D = 0, the roots are real and equal.
- D < 0, the roots do not exist or the roots are imaginary.

Sine and Cosine Law in Trigonometry 正弦、余弦定律：

    a^2 + b^2 = c^2 + 2ab cosx

Euler's Identity 

    x^2+e^{\pi i}

Trigonometric Math Functions/Symbols

    | Cosecant  | cscx | csc x |
    | Cosine    | cosx | cos x |
    | Cotangent | cotx | cot x |
    | Secant    | secx | sec x |
    | Sine      | sinx | sin x |
    | Tangent   | tanx | tan x |

Integrals Math Symbols

    | Closed curve integral | \oint_C F ds             |
    | Indefinite integral   | \int f(x) dx             |
    | Domain integral       | \int_D f(x) dx           |
    | Double integral       | \iint f(x,y) dx dy       |
    | Triple integral       | \iiint f(x,y,z) dx dy dz |

Miscellaneous Math Functions/Symbols

    | Logarithmic Function / Logarithm   | \log{x}           |
    | Logarithm (Base a)                 | \log_a{b}         |
    | Square root function / Square root | \sqrt{x}          |
    | N-th root function / N-th root     | \sqrt[n]{x}       |
    | Rational function / Fraction       | \frac{u(x)}{v(x)} |

Greek Symbols

    | Command                    | Symbol   |
    | :------------------------- | -------- |
    | \alpha A                   | α A      |
    | \nu N                      | ν N      |
    | \beta B                    | β B      |
    | \xi\Xi                     | ξ Ξ      |
    | \gamma \Gamma              | γ Γ      |
    | o O                        | o O      |
    | \delta \Delta              | δ Δ      |
    | \pi \Pi                    | π Π      |
    | \epsilon \varepsilon E     | ϵ ε E    |
    | \rho\varrho P              | ρ ϱ P    |
    | \zeta Z                    | ζ Z      |
    | \sigma \Sigma              | σ Σ      |
    | \eta H                     | η H      |
    | \tau T                     | τ T      |
    | \theta \vartheta \Theta    | θ ϑ Θ    |
    | \upsilon \Upsilon          | υ Υ      |
    | \iota I                    | ι I      |
    | \phi \varphi \Phi          | ϕ φ Φ    |
    | \kappa K                   | κ K      |
    | \chi X                     | χ X      |
    | \lambda \Lambda            | λ Λ      |
    | \psi \Psi                  | ψ Ψ      |
    | \mu M                      | μ M      |
    | \omega \Omega              | ω Ω      |

Binary Operation Symbols : Cross Symbol LateX, Union LaTeX Symbol and other Important Symbols

    | \pm              | ± 
    | \vee             | ∨ 
    | \cap             | ∩ 
    | \bigtriangledown | ▽ 
    | \cup (Union)     | ∪ 
    | \triangleleft    | ◃ 
    | \uplus           | ⊎ 
    | \triangleright   | ▹ 
    | \amalg           | ⨿ 
    | \wedge           | ∧ 
    | \bigcirc         | ◯ 
    | \setminus        | ∖ 
    | \dagger          | † 
    | \wr              | ≀ 
    | \ddagger         | ‡ 
    | -                | − 
    | \odot            | ⊙ 
    | \ast             | ∗ 
    | \ominus          | ⊖ 
    | \bullet          | ∙ 
    | \oplus           | ⊕ 
    | \cdot            | ⋅ 
    | \oslash          | ⊘ 
    | \circ            | ∘ 
    | \otimes          | ⊗ 
    | \div             | ÷ 
    | \sqcap           | ⊓ 
    | \mp              | ∓ 
    | \sqcup           | ⊔ 
    | \star            | ⋆ 
    | \bigtriangleup   | △ 
    | \times (Cross)   | × 
    | \diamond         | ⋄ 
    | +                | + 


Relation Symbols

    | \leq        | ≤ 
    | \geq        | ≥ 
    | \equiv      | ≡ 
    | \models     | ⊨ 
    | \prec       | ≺ 
    | \succ       | ≻ 
    | \sim        | ∼ 
    | \perp       | ⊥ 
    | \preceq     | ⪯ 
    | \succeq     | ⪰ 
    | \simeq      | ≃ 
    | \mid        | ∣ 
    | \ll         | ≪ 
    | \gg         | ≫ 
    | \asymp      | ≍ 
    | \parallel   | ∥ 
    | \subset     | ⊂ 
    | \supset     | ⊃ 
    | \approx     | ≈ 
    | \bowtie     | ⋈ 
    | \subseteq   | ⊆ 
    | \supseteq   | ⊇ 
    | \cong       | ≅ 
    | \Join       | ⋈ 
    | \sqsubset   | ⊏ 
    | \sqsupset   | ⊐ 
    | \neq        | ≠ 
    | \smile      | ⌣ 
    | \sqsubseteq | ⊑ 
    | \sqsupseteq | ⊒ 
    | \doteq      | ≐ 
    | \frown      | ⌢ 
    | \in         | ∈ 
    | \ni         | ∋ 
    | \propto     | ∝ 
    | \vdash      | ⊢ 
    | \dashv      | ⊣ 
    | =           | = 
    | <           | < 
    | >           | > 
    | :           | : 

Arrows Symbols

    | \leftarrow          | ← 
    | \longleftarrow      | ⟵ 
    | \uparrow            | ↑ 
    | \Leftarrow          | ⇐ 
    | \Longleftarrow      | ⟸ 
    | \Uparrow            | ⇑ 
    | \rightarrow         | → 
    | \longrightarrow     | ⟶ 
    | \downarrow          | ↓ 
    | \Rightarrow         | ⇒ 
    | \Longrightarrow     | ⟹ 
    | \Downarrow          | ⇓ 
    | \leftrightarrow     | ↔ 
    | \longleftrightarrow | ⟷ 
    | \updownarrow        | ↕ 
    | \Leftrightarrow     | ⇔ 
    | \Longleftrightarrow | ⟺ 
    | \Updownarrow        | ⇕ 
    | \mapsto             | ↦ 
    | \longmapsto         | ⟼ 
    | \nearrow            | ↗ 
    | \hookleftarrow      | ↩ 
    | \hookrightarrow     | ↪ 
    | \searrow            | ↘ 
    | \leftharpoonup      | ↼ 
    | \rightharpoonup     | ⇀ 
    | \swarrow            | ↙ 
    | \leftharpoondown    | ↽ 
    | \rightharpoondown   | ⇁ 
    | \nwarrow            | ↖ 
    | \rightleftharpoons  | ⇌ 
    | \leadsto            | ⇝ 


Miscellaneous Symbols

    | \ldots       | … 
    | \cdots       | ⋯ 
    | \vdots       | ⋮ 
    | \ddots       | ⋱ 
    | \aleph       | ℵ 
    | \prime       | ′ 
    | \forall      | ∀ 
    | \hbar        | ℏ 
    | \emptyset    | ∅ 
    | \exists      | ∃ 
    | \Box         | □ 
    | \imath       | ı 
    | \nabla       | ∇ 
    | \neg         | ¬ 
    | \Diamond     | ◊ 
    | \jmath       | ȷ 
    | \surd        | √ 
    | \flat        | ♭ 
    | \triangle    | △ 
    | \ell         | ℓ 
    | \top         | ⊤ 
    | \natural     | ♮ 
    | \clubsuit    | ♣ 
    | \wp          | ℘ 
    | \bot         | ⊥ 
    | \sharp       | ♯ 
    | \diamondsuit | ♢ 
    | \Re          | R 
    | \|           | ∥ 
    | \backslash   | ∖ 
    | \heartsuit   | ♡ 
    | \Im          | I 
    | \angle       | ∠ 
    | \partial     | ∂ 
    | \spadesuit   | ♠ 
    | \mho         | ℧ 
    | .            | . 
    | |            | | 
    | \infty       | ∞  
    | \neg         | ¬  
    | \blacksquare | ■  
    | \nexists     | ∄ 
    | \cdots       | ⋯  
    | \partial     | ∂  
    | \complement  | ∁  
    | \Re          | R  
    | \emptyset    | ∅  
    | \square      | □  
    | \exists      | ∃  
    | \surd        | √  
    | \forall      | ∀  
    | \triangle    | △  
    | \Im          | I  
    | \varnothing  | ∅  
    | \nabla       | ∇  
    | \wp          | ℘  



## ==⚡ Programming Scripts and Functions

Matlab 程序文件分为脚本文件和函数文件，虽然都使用 m 扩展名，但是函数要独立编写，不能和脚本语句混合。如果程序文件的第一个可执行语句是 function 开头，那就是函数文件。函数文件内定义的变量为局部变量，只在函数文件内部起作用，当函数文件执行完后，这些内部变量将被清除。

Program files can be scripts that simply execute a series of MATLAB® statements, or they can be functions that also accept input arguments and produce output. Both scripts and functions contain MATLAB code, and both are stored in text files with a .m extension. However, functions are more flexible and more easily extensible.

可以使用菜单创建程序文件，也可以使用 edit 命令：

    edit file_name

Functions

- *edit*    Edit or create file
- *input*   Request user input
- *publish* Generate view of MATLAB file in specified format
- *notebook*    Open MATLAB Notebook in Microsoft Word software (on Microsoft Windows platforms)
- *grabcode*    Extract MATLAB code from file published to HTML
- *snapnow* Force snapshot of image for inclusion in published document

Notebook 就是交互式笔记，Matlab 开发了基于 Office Words 的插件，可以直接在文档中插入 Matlab 程序并执行，然后程序运行结果就在文档中保存。另外，基于 Python 的 Jupyter Notebooks 也是一个选择。新的 MATLAB R2019b 提供了 Live Editor，直接在 Web 页面上就可以编写程序。

程序文件可以使用 %% 注解作为段落，紧跟段落（不能有空行）还可以使用 % 注解给段落添加说明内容，要使用 LaTeX 编写数学公式时使用 $$ 符号包括公式内容，或者使用 $ 插入 Inine LaTeX 行内显示的公式。 具体格式标记参考文档 MATLAB -> Programming Scripts and Functions -> Scripts -> Publishing Markup。

```matlab
%% Example Title
% Summary of example objective

%% Section 1 Title
% Description of first code block
% Variable name in italics
% As _k_ increases, ...
% LaTeX equation
% $$ y = y + \frac{sin(k*t)}{k} $$
% Inine LaTeX
% Euler's Identity $x^2+e^{\pi i}$
a=1;
```

LaTeX 语法中 *\frac* 表示分数符号，也就是除法。


比如编写一个直方图脚本：

```matlab
columns = 10000;
rows = 1;
bins = columns/100;

rng(now);
list = 100*rand(rows,columns);
histogram(list,bins)
```

编写函数程序，函数需要单独文件保存，主函数与文件同名：

```matlab
function a = triarea(b,h)
a = 0.5*(b.* h);
end

function [a] = power(x)
    a = x^2;
```

Matlab 会自动在当前目录、搜索路径找到函数所在的文件，在界面的目录导航栏中可以随时改变当前的工作目录，可以使用 *pwd* 命令查看当前目录。

Files and Folders You Should Add to the Search Path.

The MATLAB search path should include:

- Folders containing files that you run.
- Folders containing files that are called by files you run.
- Subfolders containing files that you run. Making a folder accessible does not make its subfolders accessible.

For files in @ (class) and + (package) folders, make the parent folder accessible.

There are two types of folders that can contain class definitions.

- *Path folders* — Folder name does not use an @ character and is itself on the MATLAB® path. Use this type of folder when you want multiple classes in one folder. However, the entire class definition must be in one file.
- *Class folders* — Folder name begins with an @ character followed by the class name. The folder is not on the MATLAB path, but its parent folder is on the path. Use this type of folder when you want to use multiple files for one class definition.

See the *path* function for information about the MATLAB path.

Functions

- *addpath* Add folders to search path
- *rmpath*  Remove folders from search path
- *path*    View or change search path
- *savepath*    Save current search path
- *userpath*    View or change user portion of search path
- *genpath* Generate path string
- *pathsep* Search path separator for current platform

```matlab
% Generate a path, then add the folder and its subfolders to the search path.
folderName = fullfile(matlabroot,'toolbox','images','colorspaces');
p = genpath(folderName);
addpath(p)
```

If files call other files that are in multiple folders, determine the location of all the called files by creating a Dependency Report.

For example, consider a path with the following folders, containing the files indicated:

    | Order in Path | Folder and File  | File Defines |
    |---------------|------------------|--------------|
    |             1 | fldr1/foo.m      | Class foo    |
    |             2 | fldr2/foo.m      | Function foo |
    |             3 | fldr3/@foo/foo.m | Class foo    |
    |             4 | fldr4/@foo/bar.m | Method bar   |
    |             5 | fldr5/foo.m      | Class foo    |

Matlab 在搜索目录查找一个函数时，优先执行 *Class folders* 目录下的类定义的函数，其次才是独立函数和其目录下的类定义的函数。如果同样类形，则执行靠前的版本，如：

- fldr1/foo.m 优先于 fldr3/@foo，类型一样，执行靠前的版本；
- fldr3/@foo  优先于 fldr2/foo.m，类型不一样，优先执行 *Class folders* 目录下的版本:
- fldr2/foo.m 优先于 fldr5/foo，类型不一样，但后者不是 *Class folders* 目录，优先执行靠前的版本；

If fldr3/@foo/foo.m does not contain a *classdef* keyword (that is, it is a MATLAB class prior to Version 7.6), then fldr4/@foo/bar.m becomes a method of the foo class defined in fldr3/@foo


## ==⚡ File Operations

File Operations Functions

Find, view, and change files and folders

- *dir* List folder contents
- *ls*  List folder contents
- *pwd* Identify current folder
- *fileattrib*  Set or get attributes of file or folder
- *exist*   Check existence of variable, function, folder, or class
- *isdir*   Determine whether input is folder
- *type*    Display contents of file
- *visdiff* Compare two text files, MAT-Files, binary files, Zip files, or folders
- *what*    List MATLAB files in folder
- *which*   Locate functions and files

- *cd*  Change current folder
- *copyfile*    Copy file or folder
- *delete*  Delete files or objects
- *recycle* Set option to move deleted files to recycle folder
- *mkdir*   Make new folder
- *movefile*    Move file or folder
- *rmdir*   Remove folder

- *open*    Open file in appropriate application
- *winopen* Open file in appropriate application (Windows)

File Name Construction Functions

Components of full paths, including folders, extensions, and separators

- *fileparts*   Parts of file name and path
- *fullfile*    Build full file name from parts
- *filemarker*  Character to separate file name and internal function name
- *filesep* File separator for current platform

- *tempdir* Name of system's temporary folder
- *tempname*    Unique name for temporary file

- *matlabroot*  Root folder
- *toolboxdir*  Root folder for specified toolbox

File Compression Functions

Zip and tar files; file compression and decompression

- *zip* Compress files into zip file
- *unzip*   Extract contents of zip file
- *gzip*    Compress files into GNU zip files
- *gunzip*  Uncompress GNU zip files
- *tar* Compress files into tar file
- *untar*   Extract contents of tar file

Create a zip archive of a Web page.

```matlab
% Locate the list of files at the MATLAB Central File Exchange uploaded within the past 7 days, that contain "Simulink."
filex = 'http://www.mathworks.com/matlabcentral/fileexchange/';
params = {'duration','7','term','simulink'};

% Save the Web content to a file.
urlwrite(filex,'contains_simulink.html','get',params);

% Create a zip archive of the retrieved Web page, using the zip function.
zip('simulink_matches.zip','contains_simulink.html');
```

## ==⚡ Data Import and Export

数据导入导出类型可以是磁盘文件，也可以是硬件接口输入的数据：

- Standard File Formats -- Text, spreadsheets, images, scientific data, audio and video, XML documents
- Workspace Variables and MAT-Files -- Manage data in the MATLAB® workspace
- Low-Level File I/O -- Read and write operations at the byte or character level
- Large Files and Big Data -- Access and process collections of files and large data sets
- TCP/IP Communication -- Read and write data over TCP/IP interface
- Web Access -- RESTful web services, JSON, email, FTP
- Serial Port Devices -- Read and write to devices connected to a serial port

Images

JPEG, TIFF, PNG, and other formats

Functions

- *im2java* Convert image to Java image
- *imfinfo* Information about graphics file
- *imread*  Read image from graphics file
- *imwrite* Write image to graphics file

Classes

- *Tiff*    MATLAB Gateway to LibTIFF library routines


Low-Level File I/O Functions

Read and write operations at the byte or character level

- *fclose*  Close one or all open files
- *feof*    Test for end-of-file
- *ferror*  Information about file I/O errors
- *fgetl*   Read line from file, removing newline characters
- *fgets*   Read line from file, keeping newline characters
- *fileread*    Read contents of file into string
- *fopen*   Open file, or obtain information about open files
- *fprintf* Write data to text file
- *fread*   Read data from binary file
- *frewind* Move file position indicator to beginning of open file
- *fscanf*  Read data from text file
- *fseek*   Move to specified position in file
- *ftell*   Position in open file
- *fwrite*  Write data to binary file


Web Access Functions

RESTful web services, JSON, email, FTP

- *web* Open Web page or file in browser
- *webread* Read content from RESTful web service
- *webwrite*    Write data to RESTful web service
- *websave* Save content from RESTful web service to file
- *weboptions*  Specify parameters for RESTful web service
- *sendmail*    Send email message to address list
- *ftp* Connect to FTP server


Serial Port Devices Functions

Read and write to devices connected to a serial port

- *delete (serial)* Remove serial port object from memory
- *fclose (serial)* Disconnect serial port object from device
- *fgetl (serial)*  Read line of ASCII text from device and discard terminator
- *fgets (serial)*  Read line of text from device and include terminator
- *fopen (serial)*  Connect serial port object to device
- *fprintf (serial)*    Write text to device
- *fread (serial)*  Read binary data from device
- *fscanf (serial)* Read ASCII data from device, and format as text
- *fwrite (serial)* Write binary data to device
- *get (serial)*    Serial port object properties
- *instrcallback*   Event information when event occurs
- *instrfind*   Read serial port objects from memory to MATLAB workspace
- *instrfindall*    Find visible and hidden serial port objects
- *isvalid (serial)*    Determine whether serial port objects are valid
- *readasync*   Read data asynchronously from device
- *record*  Record data and event information to file
- *serial*  Create serial port object
- *serialbreak* Send break to device connected to serial port
- *set (serial)*    Configure or display serial port object properties
- *stopasync*   Stop asynchronous read and write operations

### ===🗝 Import or export Text Files

Text Files Functions

Delimited and formatted text files

Read and write *numeric* and *nonnumeric* data in delimited and formatted text files, including *.csv* and *.txt* files. Import text file data interactively using the Import Tool.

- *csvread* Read comma-separated value (CSV) file
- *csvwrite*    Write comma-separated value file
- *dlmread* Read ASCII-delimited file of numeric data into matrix
- *dlmwrite*    Write matrix to ASCII-delimited file
- *textscan*    Read formatted data from text file or string
- *readtable*   Create table from file
- *writetable*  Write table to file
- *type*    Display contents of file

注意，CSV 等逗号分隔符格式的数据文件读取方法只支持数值，如果读取非数值就会出现错误，可以使用 *textscan* 或 *readtable* 方法读取，还可以带格式。

    Trouble reading 'Numeric' field from file 

```matlab
% reads a comma-separated value (CSV) formatted file into array M. The file must contain only numeric values.
M = csvread(filename)

% reads data from the file starting at row offset R1 and column offset C1.
% For example, the offsets R1=0, C1=0 specify the first value in the file.
M = csvread(filename,R1,C1) 

% reads only the range bounded by row offsets R1 and R2 and column offsets C1 and C2.
% Another way to define the range is to use spreadsheet notation, such as 'A1..B7' instead of [0 0 6 1].
M = csvread(filename,R1,C1,[R1 C1 R2 C2]) 

% writes matrix M into filename as comma-separated values.
csvwrite(filename,M)

% writes matrix M into filename starting at the specified row and column offset.
% The row and column arguments are zero based, so that row=0 and C=0 specify the first value in the file.
csvwrite(filename,M,row,col) 
```

例如，从示范数据 patients.mat 中获取数据，并将其中 5 个病号数据写入逗号分隔符格式文件：

```matlab
load patients
DateTime = {'02/01/2002 12:18';'01/23/2003 00:49';'02/07/2003 21:15';'04/06/2004 05:44';'03/16/2002 06:18'};
T = table(LastName(1:5),Age(1:5), Gender(1:5), Height(1:5),DateTime);
T.Properties.VariableNames = {'LastName', 'Age', 'Gender', 'Height', 'DateTime'};
writetable(T, 'myCsvTable.csv');
T = readtable('myCsvTable.csv','Format','%s%s%s%s%D');
T.DateTime.Format = 'HH:mm:ss'
T = 
     LastName     Age      Gender     Height    DateTime
    __________    ____    ________    ______    ________
    'Smith'       '38'    'Male'      '71'      12:18:00
    'Johnson'     '43'    'Male'      '69'      00:49:00
    'Williams'    '38'    'Female'    '64'      21:15:00
    'Jones'       '40'    'Female'    '67'      05:44:00
    'Brown'       '49'    'Female'    '64'      06:18:00
```

*readtable*、*textread*、*textscan* 都可以使用格式化字符串，指定要录入的数据类型：

- %d  ➡ Read a signed integer value. Double array
- %u  ➡ Read an integer value. Double array
- %f  ➡ Read a floating-point value. Double array
- %s  ➡ Read a white-space or delimiter-separated string. Cell array of strings
- %q  ➡ Read a double quoted string, ignoring the quotes. Cell array of strings
- %c  ➡ Read characters, including white space. Character array
- %{fmt}D ➡ %{dd-MMM-yyyy}D' specifies the format of a date such as '01-Jan-2014'.
- %[...]  ➡ Read the longest string containing characters specified in the brackets. Cell array of strings
- %[^...]  ➡ Read the longest nonempty string containing characters that are not specified in the brackets. Cell array of strings


### ===🗝 Workspace Variables and MAT-Files
- Statistics and Machine Learning Toolbox - Sample Data Sets https://www.mathworks.com/help/stats/sample-data-sets.html
- MATLAB Example Data Sets https://www.mathworks.com/help/matlab/import_export/matlab-example-data-sets.html
- Analyze Big Data in MATLAB Using Tall Arrays https://www.mathworks.com/help//matlab/import_export/analyze-big-data-in-matlab-using-tall-arrays.html

Workspace Variables and MAT-Files Functions

Manage data in the MATLAB® workspace

- *clear*   Remove items from workspace, freeing up system memory
- *clearvars*   Clear variables from memory
- *disp*    Display value of variable
- *openvar* Open workspace variable in Variables editor or other graphical editing tool
- *who* List variables in workspace
- *whos*    List variables in workspace, with sizes and types
- *load*    Load variables from file into workspace
- *save*    Save workspace variables to file
- *matfile* Access and change variables directly in MAT-files, without loading into memory

MAT-files are binary MATLAB® format files that store workspace variables.

For example, view the contents of the example file durer.mat:

    whos -file durer.mat


MATLAB Example Data Sets 是内置的示范数据集，有统计数据、图像文件、音频文件等等，一些工具包也会提供相应的数据文件。

大多数都以 MAT-Files 格式数据文件 .mat 保存在 \toolbox\matlab\demos 目录下，这种格式是保存 Workspace Variables 的二进制文件，可以直接使用 *load* 和 *save* 方法加载、保存。对于超大的数据文件，就可以使用 *matfile* 方法加载，不必一次过全部装入内存。

```matlab
%% Defile a 2x1 Cell Array and some strings
A = {1:26; char(int8('a'):int8('z'))}
B = ['String' blanks(1) 'append to matfile']
versions = {'MAT-file version' '-v7.3' '-v7' '-v6' '-v4'}

%% Save Varialbes to MAT-File in 7.3 format version
save('alphabet.mat', 'A','versions', '-v7.3')
save('alphabet.mat', 'B', '-append')
%% Save All Workspace Variables to MAT-File
save('alphabet')

%% Load MAT-File
clear
load('alphabet.mat');
```

以 patients.mat 数据为例，它包含了 100 个病历号的数据，分别用不同的变量保存：

```matlab
clear
load patients.mat
whos

  Name                            Size            Bytes  Class      Attributes

  Age                           100x1               800  double               
  Diastolic                     100x1               800  double               
  Gender                        100x1              7012  cell                 
  Height                        100x1               800  double               
  LastName                      100x1              7216  cell                 
  Location                      100x1              9808  cell                 
  SelfAssessedHealthStatus      100x1              7140  cell                 
  Smoker                        100x1               100  logical              
  Systolic                      100x1               800  double               
  Weight                        100x1               800  double  
```

MAT-File Versions

MAT-files are binary MATLAB® files that store workspace variables. By default, all save operations except new file creation with the matfile function create Version 7 MAT-files. When you create new MAT-files using the matfile, the default MAT-file version is 7.3.

The maximum size of a MAT-file is imposed only by your native file system.

To identify or change the default MAT-file version, access the MAT-Files Preferences: On the Home tab, in the Environment section, click  Preferences. Select MATLAB > General > MAT-Files. The preferences apply to both the save function and the Save menu options.

This table lists and compares all MAT-file versions.

| Version | MATLAB Versions |          Maximum Size of Each Variable           |
|---------|-----------------|--------------------------------------------------|
| '-v7.3' | 7.3 (R2006b+)   | ≥ 2 GB on 64-bit computers                       |
| '-v7'   | 7.0 (R14+)      | 2^31 bytes per variable                          |
| '-v6'   | 5 (R8+)         | 2^31 bytes per variable                          |
| '-v4'   | All             | 10^8 elements per array, 2^31 bytes per variable |

New Features

- MATLAB Version 7.3: Saving and loading parts of variables.
- MATLAB Version 7: Unicode® character encoding. Data Compression.
- MATLAB Version 5: N-dimensional arrays, cell arrays, structure arrays, 19-chars long variable names.
- ALl MATLAB Versions: Two-dimensional double, character, and sparse arrays.

可以执行命令将当前工作台保存到文件，并指定格式版本：

    save -v7.3
    save -v7
    save -v6

Statistics and Machine Learning Toolbox - Sample Data Sets

- *acetylene.mat*   Chemical reaction data with correlated predictors
- *arrhythmia.mat*  Cardiac arrhythmia data from the UCI machine learning repository
- *carbig.mat*  Measurements of cars, 1970–1982
- *carsmall.mat*    Subset of carbig.mat. Measurements of cars, 1970, 1976, 1982
- *census1994.mat*  Adult data from the UCI machine learning repository
- *cereal.mat*  Breakfast cereal ingredients
- *cities.mat*  Quality of life ratings for U.S. metropolitan areas
- *discrim.mat* A version of cities.mat used for discriminant analysis
- *examgrades.mat*  Exam grades on a scale of 0–100
- *fisheriris.mat*  Fisher's 1936 iris data
- *flu.mat* Google Flu Trends estimated ILI (influenza-like illness) percentage for various regions of the US, and CDC weighted ILI percentage based on sentinel provider reports
- *gas.mat* Gasoline prices around the state of Massachusetts in 1993
- *hald.mat*    Heat of cement vs. mix of ingredients
- *hogg.mat*    Bacteria counts in different shipments of milk
- *hospital.mat*    Simulated hospital data
- *humanactivity.mat*   Human activity recognition data of five activities: sitting, standing, walking, running, and dancing
- *imports-85*.mat  1985 Auto Imports Database from the UCI repository
- *ionosphere.mat*  Ionosphere dataset from the UCI machine learning repository
- *kmeansdata.mat*  Four-dimensional clustered data
- *lawdata.mat* Grade point average and LSAT scores from 15 law schools
- *mileage.mat* Mileage data for three car models from two factories
- *moore.mat*   Biochemical oxygen demand on five predictors
- *morse.mat*   Recognition of Morse code distinctions by non-coders
- *nlpdata.mat* Natural language processing data extracted from the MathWorks® documentation
- *ovariancancer.mat*   Grouped observations on 4000 predictors [1][2]
- *parts.mat*   Dimensional run-out on 36 circular parts
- *polydata.mat*    Sample data for polynomial fitting
- *popcorn.mat* Popcorn yield by popper type and brand
- *reaction.mat*    Reaction kinetics for Hougen-Watson model
- *spectra.mat* NIR spectra and octane numbers of 60 gasoline samples
- *stockreturns.mat*    Simulated stock returns


以下是 Observational Data 历史观测数据的说明与加载：

```matlab
%% Data on US traffic accidents and fatalities in 2004 from the US Department of Transportation. 
% The data covers all 50 states and the District of Columbia.
% File Size: 8 KB
% Data Size: 51 rows, 17 variables
load accidents.mat

%% US population data from 1790 – 1990.
% File Size: 1 KB
% Data Size: Two column vectors with 21 elements
load census.mat

%% US domestic airline flight data from 1987 – 2008.
% File Size: 11,747 KB
% Data Size: 123,523 rows, 29 variables
% See Analyze Big Data in MATLAB Using Tall Arrays for an example that loads and processes this data.
% Matlab R2018b(V9.5)
ds = tabularTextDatastore('airlinesmall.csv');
ds.TreatAsMissing = 'NA';
ds.SelectedVariableNames = {'Year','Month','ArrDelay','DepDelay','Origin','Dest'};
ds.SelectedFormats(5:6) = {'%C','%C'};
pre = preview(ds)

%% Medical patient information for 100 fictional patients.
% File Size: 3 KB
% Data Size: 100 rows, 10 variables
load patients.mat

%% Data on electric utility outages in the US.
% File Size: 99 KB
% Data Size: 1,468 rows, 6 variables
% Load the CSV data as a table:
T = readtable('outages.csv');

%% A detailed 3-D image of the surface of a US penny.
% File Size: 2 KB
% Data Size: 128-by-128 matrix
% To view a surface plot of the penny or read the script, use the command:
penny
edit penny.m
load penny.mat
imshow (D)

%% A seamount is an underwater mountain.
% The data set consists of a set of longitude (x) and latitude (y) locations,
% and corresponding seamount elevations (z) measured at those coordinates.
% File Size: 2 KB
% Data Size: Three column vectors with 294 elements.
load seamount.mat

%% 3-D data on air currents over North America.
% The data consists of (x,y,z) position components and (u,v,w) velocity components.
% File Size: 142 KB
% Data Size: Six matrices of size 35-by-41-by-15
load wind.mat
```

以下是图像示范数据的说明与加载：

```matlab
%% This NASA Hubble Space Telescope image
% shows one of the most complex planetary nebulae ever seen, 
% NGC 6543, nicknamed the "Cat's Eye Nebula." Hubble reveals 
% surprisingly intricate structures including concentric gas 
% shells, jets of high-speed gas and unusual shock-induced knots of gas.
% File Size: 27 KB
% Image Size: 600 x 650
I = imread('ngc6543a.jpg');
imshow(I)

%% A picture of a city street including cars, pedestrians, signs, and buildings.
% File Size: 37 KB
% Image Size: 640 x 480
I = imread('street1.jpg');
imshow(I)

%% A picture of a busy city intersection.
% File Size: 39 KB
% Image Size: 640 x 480
I = imread('street2.jpg');
imshow(I)

%% An MRI data set that contains 27 image slices of a human head. 
% The images are arranged into a 4-D array of size 128-by-128-by-1-by-27.
% File Size: 130 KB
% Image Size: 302 x 221
% For more information, see Techniques for Visualizing Scalar Volume Data.
load mri.mat
imshow(D(:,:,:,1),map)

%% An image of Albrecht Dürer's Melancolia. Can you find the magic square matrix?
% File Size: 273 KB
% Image Size: 683 x 741
load durer.mat
imshow(X,map)

%% A colorful picture of several varieties of peppers.
% File Size: 281 KB
% Image Size: 512 x 384
I = imread('peppers.png');
imshow(I)

%% A TIF file containing three images of corn (indexed, RGB, and grayscale).
% File Size: 226 KB
% Image Size: 312 x 415

% View the indexed version of the image.
[corn_indexed,map] = imread('corn.tif',1);
imshow(corn_indexed,map)
% View the RGB version of the image.
corn_rgb = imread('corn.tif',2);
imshow(corn_rgb)
% View the grayscale version of the image.
corn_gray = imread('corn.tif',3);
imshow(corn_gray)


%% An image of a simulation of an astrophysical jet experiencing turbulence.
% File Size: 21 KB
% Image Size: 474 x 493
load flujet.mat
imshow(X,map)
spine.mat

%% An X-ray image of a human spine.
% File Size: 33 KB
% Image Size: 664 x 460
load spine.mat
imshow(X,map)
mandrill.mat

%% A colorful picture of a mandrill.
% File Size: 184 KB
% Image Size: 674 x 573
load mandrill.mat
imshow(X,map)
```


以下是 Geographic Data 示范数据集的说明与加载：

```matlab
%% A picture of earth.
% File Size: 32 KB
% Image Size: 424 x 350
load earth.mat
imshow(X,map)

%% NOAA altitude data for New England, including Cape Cod.
% File Size: 37 KB
% Image Size: 534 x 453
load cape.mat
imshow(X,map)

%% An image of the earth. 
% This image can be combined with cloudCombined.jpg to view a map of the earth with cloud cover.
% File Size: 261 KB
% Image Size: 2048 x 1024
% View the earth image:
E = imread('landOcean.jpg');
imshow(E)

%% An image of cloud coverage on the earth.
% This image can be combined with landOcean.jpg to view a map of the earth with cloud cover.
% File Size: 810 KB
% Image Size: 2048 x 1024
% View the cloud cover image:
C = imread('cloudCombined.jpg');
imshow(C)
% See Changing Transparency of Images, Patches or Surfaces for an example that overlays both images with transparency.

%% Data on tsunami occurrences, including locations.
% File Size: 25 KB
% Data Size: 162 rows, 20 variables
T = readtable('tsunamis.xlsx');
geobubble(T.Latitude,T.Longitude,T.MaxHeight)

%% Earth topography data, courtesy of the NOAA.
% File Size: 115 KB
% Data Size: Altitude data is a 180-by-360 matrix
% See Displaying Topographic Data.
load topo.mat

%% Latitude and longitude data for the perimeter of the contiguous United States.
% File Size: 17 KB
% Data Size: Two vectors with 4,205 elements
load usapolygon.mat

%% Latitude and longitude data for each state in the contiguous United States. The data contains a structure array with three fields: Lat, Lon, and Name.
% File Size: 45 KB
% Data Size: Structure array of size 49-by-1
load usastates.mat
```


以下是 Video and Audio Data 示范数据集的说明与加载：

```matlab
%% Video of a space shuttle launch without audio, courtesy of NASA.
% File Size: 1,648 KB
% Video Length: 4 s
% To watch the video on your computer:
winopen('shuttle.avi')

%% Video of a xylophone being played. The MPG version has audio.
% File Size: 465 KB (mp4) and 645 KB (mpg)
% Video Length: 4 s
% To watch the videos on your computer:
winopen('xylophone.mp4')
winopen('xylophone.mpg')

%% An excerpt of the Hallelujah chorus from Handel's Messiah.
% File Size: 137 KB
% Audio Length: 8.9 s
load handel.mat
sound(y,Fs)

%% Birds chirping.
% File Size: 25 KB
% Audio Length: 1.6 s
load chirp.mat
sound(y,Fs)

%% A gong ringing.
% File Size: 90 KB
% Audio Length: 5.1 s
load gong.mat
sound(y,Fs)

%% Hearty laughter.
% File Size: 121 KB
% Audio Length: 6.4 s
load laughter.mat
sound(y,Fs)

%% A person saying "MATLAB".
% File Size: 32 KB
% Audio Length: 0.5 s
load mtlb.mat
sound(mtlb,Fs)

%% A comical splat sound.
% File Size: 18 KB
% Audio Length: 1.2 s
load splat.mat
sound(y,Fs)

%% A train whistle.
% File Size: 30 KB
% Audio Length: 1.6 s
load train.mat
sound(y,Fs)
```

### ===🗝 Database Toolbox & SQL

Exchange data with relational databases

Database Toolbox™ provides an app and functions for exchanging data between relational databases and MATLAB®. You can use SQL commands to read and write data or use the Database Explorer app to interact with a database without using SQL.

The toolbox supports ODBC-compliant and JDBC-compliant databases, including Oracle®, SAS®, MySQL®, Sybase®, Microsoft® SQL Server®, Microsoft Access™, and PostgreSQL. You can apply simple and advanced conditions to database queries from MATLAB. The toolbox lets you access multiple databases simultaneously within a single MATLAB session and enables segmented import of large data sets.

- Database Connection ➡Configure drivers and data sources, open and close a database connection
- Data Import into MATLAB ➡Import data from database into MATLAB workspace
- Data Export from MATLAB ➡Export data from MATLAB into database

Database Connection

Configure drivers and data sources, open and close a database connection
Database Toolbox™ lets you connect MATLAB® to ODBC-compliant and JDBC-compliant relational databases. The Database Explorer app provides a visual way to establish the connection and explore the data in the database. Or, you can use the command line to establish the connection.

Set up a data source, establish a database connection, and explore the database structure.

Data Import into MATLAB

Import data from database into MATLAB® workspace
Database Toolbox™ lets you import large data sets into MATLAB. You can import data using the Database Explorer app or the command line.

The Database Explorer app lets you interact with the database without using SQL. Or, you can write SQL statements to read and write data using the command line.

Run SQL Query

SQL statement to import data into the MATLAB® workspace

- *exec*    Execute SQL statement and open cursor
- *fetch*   Import data into MATLAB workspace from cursor object or from execution of SQL statement
- *fetchmulti*  Import data from multiple resultsets
- *get* Retrieve object properties
- *resultset*   Construct resultset object
- *rsmd*    Construct resultset metadata object
- *runsqlscript*    Run SQL script on database
- *runstoredprocedure*  Call stored procedure with and without input and output arguments
- *set* Set properties for database, cursor, or drivermanager object
- *datastore*   Create datastore to access collection of data in a database

Apps

- Database Explorer   Configure, explore, and import database data

Using Objects

- DatabaseDatastore   Access collection of data stored in database


View Information About Imported Data

Information about the structure of imported data

- *attr*    Retrieve attributes of columns in fetched data set
- *cols*    Retrieve number of columns in fetched data set
- *columnnames* Retrieve names of columns in fetched data set
- *get* Retrieve object properties
- *isnullcolumn*    Determine if last record read in resultset is NULL
- *namecolumn*  Map resultset column name to resultset column index
- *querytimeout*    Get time specified for SQL queries to succeed
- *rows*    Return number of rows in fetched data set
- *set* Set properties for database, cursor, or drivermanager object
- *width*   Return field size of column in fetched data set


Export data from MATLAB® into database

- *commit*  Make database changes permanent
- *datainsert*  Export MATLAB data into database table
- *fastinsert*  Add MATLAB data to database table
- *insert*  Add MATLAB data to database tables
- *rollback*    Undo database changes
- *update*  Replace data in database table with MATLAB data


Analyze Large Data Sets in a Database with MapReduce

```matlab
% Create the DatabaseDatastore
setdbprefs('DataReturnFormat','table')
conn = database('dbname','username','pwd',...
                'Vendor','MySQL',...
                'Server','sname');
sqlquery = 'select ArrDelay from flightdelay';
dbds = datastore(conn,sqlquery);

% Define the Mapper and Reducer Functions
% You can write your own mapper function to process large data sets in chunks. 
% This example uses the mapper, reducer function.
type meanArrivalDelayMapper.m
type meanArrivalDelayReducer.m

% Run MapReduce Using the Mapper and Reducer Functions
outds = mapreduce(dbds,@meanArrivalDelayMapper,@meanArrivalDelayReducer);

% Display the Output from MapReduce
outtab = readall(outds)
meanArrDelay = outtab.Value{1}

% Close the DatabaseDatastore
close(dbds)
```

Delete Data from Databases

Database Toolbox come with an tutorial.mdb which is Microsoft Access database.

Database Toolbox™ has a C++ library that connects natively to an ODBC driver. Database Toolbox has a Java library that connects directly to a pure JDBC driver or uses the JDBC/ODBC bridge to connect to an ODBC driver. The JDBC/ODBC bridge is automatically installed as part of the MATLAB® JVM™.

使用 ODBC 数据源访问 MDB 数据库文件时，需要提前配置 ODBC 数据源，通过 Windows 控制面板打开 ODBC 配置程序，注意 32-bit 或 64-bit 提供可用的数据库驱动程序可能不同，可以试着使用 32-bit 的配置，或者直接通过 Matlab Database Explorer 应用程序进行配置。

添加一个名为 *dbtoolboxdemo* 的数据源配置，并设置数据文件为 \toolbox\database\dbdemos\tutorial.mdb。

在未配置数据源的情况下访问会出现乱七八糟的错误：

    [Microsoft][ODBC 驱动程序管理器] 数据源名称过长
    ODBC Driver Error: [Microsoft][ODBC 驱动程序管理器] 无效的字符串或缓冲区长度
    ODBC Driver Error: [Microsoft][ODBC 驱动程序管理器] 未发现数据源名称并且未指定默认驱动程序


```matlab
%% Delete Data from Databases
% Connect to the Access database using the native ODBC interface
conn = database.ODBCConnection('dbtoolboxdemo','','');

% Display the data in the table inventoryTable
sqlquery = 'select * from inventoryTable';
curs = exec(conn,sqlquery);

setdbprefs('DataReturnFormat','cellarray')
curs = fetch(curs);
curs.Data

% Delete a Specific Record
sqlquery = 'delete * from inventoryTable where productNumber = 13';
curs = exec(conn,sqlquery);

% Delete a Record Using a MATLAB Variable
productID = 12;
sqlquery = ['delete * from inventoryTable where '...
            'productNumber = ' num2str(productID)];
curs = exec(conn,sqlquery);

% Close the Cursor and Database Connection
close(curs);
close(conn);
```

Create an SQL script file named salesvolume.sql with this SQL query. This SQL query uses multiple joins to join these tables in the dbtoolboxdemo database:

- producttable
- salesvolume
- suppliers

The purpose of the query is to import sales volume data for suppliers located in the United States.

```sql
SELECT  salesvolume.January
,   salesvolume.February
,   salesvolume.March
,   salesvolume.April
,   salesvolume.May
,   salesvolume.June
,   salesvolume.July
,   salesvolume.August
,   salesvolume.September
,   salesvolume.October
,   salesvolume.November
,   salesvolume.December
,   suppliers.Country
FROM     ((producttable
INNER JOIN salesvolume
ON  producttable.stockNumber = salesvolume.StockNumber)
INNER JOIN suppliers
ON  producttable.supplierNumber = suppliers.SupplierNumber)
WHERE suppliers.Country LIKE 'United States%'
```

Run the SQL script file named salesvolume.sql using the runsqlscript function.

```matlab
conn = database('dbtoolboxdemo','','');
results = runsqlscript(conn,'salesvolume.sql')
```



### ===🗝 Large Files and Big Data

Access and process collections of files and large data sets

Large data sets can be in the form of large files that do not fit into available memory or take a long time to process. A large data set also can be a collection of numerous small files. There is no single approach to working with large data sets, so MATLAB® provides a number of tools.

Use datastore functions and objects to incrementally access data in a collection of text files, MAT-files, or Sequence files. Process the data in a datastore using a while loop, partition the datastore for parallel processing, or use the MapReduce programming technique. Use matfile objects to access or save parts of large variables in MAT-files without loading the full variables into memory. Map binary file data to memory for faster access.

Large Files and Big Data Basics

- Datastore ➡ Read large collections of data
- MapReduce ➡ Programming technique for analyzing data sets that do not fit in memory
- Large MAT-Files ➡ Access and change variables without loading into memory
- Memory Mapping ➡ Map file data to memory for faster access

Datastore ➡ Read large collections of data

The datastore function creates a datastore, which is a repository for collections of data that are too large to fit in memory. A datastore allows you to read and process multiple files as a single entity. If files are too large to fit in memory, you can manage the incremental import of data or use a datastore as an input to mapreduce for further processing. For more information, see Getting Started with Datastore.

- *datastore*   Create datastore to access collection of data

Using Objects

- *TabularTextDatastore*    Datastore for tabular text files
- *ImageDatastore*  Datastore for image data
- *KeyValueDatastore*   Datastore for key-value pair data
- *DatabaseDatastore* Collections of data in a relational database. Requires Database Toolbox™.

MapReduce ➡ Programming technique for analyzing data sets that do not fit in memory

mapreduce is a programming technique which is suitable for analyzing large data sets that otherwise cannot fit in your computer's memory. Using a datastore to process the data in small chunks, the technique is composed of a Map phase, which formats the data or performs a precursory calculation, and a Reduce phase, which aggregates all of the results from the Map phase. For more information, see Getting Started with MapReduce.

Functions
- *mapreduce*   Programming technique for analyzing data sets that do not fit in memory
- *datastore*   Create datastore to access collection of data
- *mapreducer*  Define execution environment for mapreduce
- *add*         Add single key-value pair to KeyValueStore
- *addmulti*    Add multiple key-value pairs to KeyValueStore

Using Objects
- *KeyValueStore*   Store key-value pairs for use with mapreduce
- *ValueIterator*   An iterator over intermediate values for use with mapreduce

Large MAT-Files ➡ Access and change variables without loading into memory

Use the matfile function to access MATLAB® variables directly from MAT-files on disk, without loading the full variables into memory. When you create a new file using matfile, the function creates a Version 7.3 MAT-file that also lets you save variables larger than 2 GB.

- *matfile* Access and change variables directly in MAT-files, without loading into memory

Memory Mapping ➡ Map file data to memory for faster access

Memory-mapping is a mechanism that maps a file or a portion of a file on disk to a range of addresses within an application's address space. Use memory-mapping when you want to randomly access large files, or frequently access small files. In addition, memory-mapping lets you access file data using standard MATLAB® indexing operations. For more information, see Overview of Memory-Mapping.

- *memmapfile*  Create memory map to a file

Datastore 是一种大文件数据读取方法，以避免因内存不足而出现问题，有以下类型：

- *TabularTextDatastore* -- Text files containing column-oriented data, including CSV files.
- *ImageDatastore* -- Image files, including formats that are supported by imread such as JPEG and PNG.
- *KeyValueDatastore* -- Key-value pair data that are inputs to or outputs of mapreduce.
- *DatabaseDatastore* -- Collections of data in a relational database. Requires Database Toolbox™.

Datastore Object Functions

- *hasdata* Determine if data is available to read
- *numpartitions*   Number of partitions
- *partition*   Partition a datastore
- *preview* Return subset of data from datastore
- *read*    Read data in datastore
- *readall* Read all data in datastore
- *readimage*   Read specified image from datastore
- *reset*   Reset datastore to initial state

```matlab
%% Process "Big Data" in MATLAB using Datastore
% datastore access a collection of data in a chunk-based manner. 
% ds = datastore('airlinesmall.csv');
ds = datastore('airlinesmall.csv','ReadSize', 500000,...
    'TreatAsMissing', {'NA','-'}, 'MissingValue', -1);
ds.SelectedFormats{strcmp(ds.SelectedVariableNames, 'TailNum')} = '%s';
ds.SelectedFormats{strcmp(ds.SelectedVariableNames, 'CancellationCode')} = '%s';
% ds.SelectedVariableNames' % Fields names

dsPreview = preview(ds);
dsPreview(:,{'FlightNum', 'AirTime','TaxiIn','TailNum','CancellationCode'})

%% Scan for rows of interest
subset = [];
while hasdata(ds)
    t = read(ds);
    t = t(strcmp(t.UniqueCarrier, 'UA') & strcmp(t.Origin, 'BOS'), :);
    subset = vertcat(subset, t);
end
subset(1:10,[1,9,10,15:17])
reset(ds);
```

➡ *preview* Display first eight records of data in DatabaseDatastore

Process "Big Data" in MATLAB using MapReduce

Introduction to mapreduce
MapReduce is an algorithmic technique to "divide and conquer" big data problems. In MATLAB, mapreduce requires three input arguments:

- ➡ A datastore to read data from
- ➡ A "mapper" function that is given a subset of the data to operate on. The output of the map function is a partial calculation. mapreduce calls the mapper function one time for each chunk in the datastore, with each call operating independently.
- ➡ A "reducer" function that is given the aggregate outputs from the mapper function. The reducer function finishes the computation begun by the mapper function, and outputs the final answer.

This is an over-simplification to some extent, since the output of a call to the mapper function can be shuffled and combined in interesting ways before being passed to the reducer function. This will be examined later in this example.

Use mapreduce to perform a computation
A simple use of mapreduce is to find the longest flight time in the entire airline data set. To do this:

- The "mapper" function computes the maximum of each chunk from the datastore.
- The "reducer" function then computes the maximum value among all of the maxima computed by the calls to the mapper function.

MapReduce Algorithm Phases

- 算法基本流程：数据源 -> Data Chunk -> Map Phase -> Intermedia Phase -> Reduce Phase -> Output Datastore
- 数据输入会分割成 Chuck 分拆独立的小部分进行处理，输入数据有多少 Chuck，就会有多少次 Map 调用；
- Map 函数根据算法获取相应的 Chuck 并交给下一步的中间处理流程，数据转变为 KeyValueStore；
- 接下来，MapReduce 将所有 KeyValueStore 打包给 Reduce Phase 处理过程；
- 按 Map 函数添加的各个 Unique Key 调用 Reduce 函数，它们关联了数据，并通过 ValueIterator 枚举数据内容；
- Reduce 函数通过 *hasnext* and *getnext* 获取并处理内容，聚合 Map 函数的中间结果之后，再使用 add 和 addmulti 将最终的键值对添加到输出中。

输出内容的 keys 顺序与 Reduce 函数将它们添加到最终 KeyValueStore 中的顺序相同，也就是说，MapReduce 不会显式地对输出进行排序。

```matlab
%% Process "Big Data" in MATLAB using MapReduce
% prepare datastore
ds = datastore('airlinesmall.csv','TreatAsMissing','NA')
ds.SelectedVariableNames = 'Distance';
preview(ds)

% Write Map and Reduce Functions
edit MeanDistMapFun % Write a Map Function ...
edit MeanDistReduceFun % Write a Reduce Function ...

% Run mapreduce
outds = mapreduce(ds, @MeanDistMapFun, @MeanDistReduceFun);
readall(outds)
```

将以下两个函数：MapReduce 算法的 Map 和 Reduce 函数写入相应的程序文件以待调用：

```matlab
function MeanDistMapFun(data, info, intermKVStore)
    distances = data.Distance(~isnan(data.Distance));
    sumLenValue = [sum(distances)  length(distances)];
    add(intermKVStore, 'sumAndLength', sumLenValue);
end

function MeanDistReduceFun(intermKey, intermValIter, outKVStore)
    sumLen = [0 0];
    while hasnext(intermValIter)
        sumLen = sumLen + getnext(intermValIter);
    end
    add(outKVStore, 'Mean', sumLen(1)/sumLen(2));
end
```



Build Effective Algorithms with MapReduce 文档提供的示范例子：

- *MaxMapReduceExample.m* Find Maximum Value with MapReduce. 
    - One intermediate key and minimal computation.
- *MeanMapReduceExample.m* Compute Mean Value with MapReduce. 
    - One intermediate key with intermediate state (accumulating intermediate sum and count).
- *VisualizationMapReduceExample.m* Create Histograms Using MapReduce. 
    - Low-volume summaries of data, sufficient to generate a graphic and gain preliminary insights.
- *MeanByGroupMapReduceExample.m* Compute Mean by Group Using MapReduce. 
    - Perform simple computations on subgroups of input data using several intermediate keys.
- *HueSaturationValueExample.m* Compute Maximum Average HSV of Images with MapReduce. 
    - Analyzes an image datastore using three intermediate keys. The outputs are filenames, which can be used to view the images.
- *SubsettingMapReduceExample.m* Simple Data Subsetting Using MapReduce. 
    - Extraction of subset of large data set to look for patterns. The procedure is generalized using a parameterized map function to pass in the subsetting criteria.
- *CovarianceMapReduceExample.m* Using MapReduce to Compute Covariance and Related Quantities. 
    - Calculate several intermediate values and store them with the same key. Use covariance to obtain a correlation matrix and regression coefficients, and to perform principal components analysis.
- *StatisticsByGroupMapReduceExample.m* Compute Summary Statistics by Group Using MapReduc. 
    - Use an anonymous function to pass an extra grouping parameter to a parameterized map function. This parameterization allows you to quickly recalculate statistics using different grouping variables.
- *LogitMapReduceExample.m* Using MapReduce to Fit a Logistic Regression Model. 
    - Chain multiple mapreduce calls to carry out an iterative regression algorithm. An anonymous function passes information from one iteration to the next to supply information directly to the map function.
- *TSQRMapReduceExample.m* Tall Skinny QR (TSQR) Matrix Factorization Using MapReduce. 
    - Chain multiple mapreduce calls to perform multiple iterations of factorizations. Also use the info input argument of the map function to compute intermediate numeric keys.


### ===🗝 TCP/IP Communication
- https://www.mathworks.com/help/matlab/import_export/use-callbacks-for-tcpip-communication.html
- https://www.mathworks.com/help/matlab/import_export/write-and-read-data-over-the-tcpip-interface.html
- https://www.mathworks.com/help/matlab/import_export/binary-and-ascii-communication-using-tcpclient.html

TCP/IP Communication Functions

Read and write data over TCP/IP interface

- *tcpclient*   Create TCP/IP client object to communicate over TCP/IP
- *read*    Read data from remote host over TCP/IP interface
- *write*   Write data to remote host over TCP/IP interface

The MATLAB® TCP/IP client support lets you connect to remote hosts or hardware from MATLAB for reading and writing data. 

The typical workflow is:

- Create a TCP/IP connection to a server or hardware
- Configure the connection if necessary
- Perform *read* and *write* operations, wait for data come before read it
- *clear* and close the connection

You can create a TCP/IP connection to a server or hardware and perform read/write operations. Use the tcpclient function to create the connection, and the write and read functions for synchronously reading and writing data.

There are three read options:

- Read all bytes available (no arguments)
- Optionally specify the number of bytes to read
- Optionally specify the data type

If you do not specify a size, the default read uses the BytesAvailable property value, which is equal to the numbers of bytes available in the input buffer.

In these examples, a tcpclient object t already exists.

```matlab
% Read all bytes available.
read(t)

% Specify the number of bytes to read, 5 in this case.
read(t, 5)

% Specify the number of bytes to read, 10, and the data type, double.
read(t, 10, 'double')
```

虽然，read、write 都是同步方法，但在读取时如果没有指定具体字节数，则有可以在数据到达前，方法就提前返回，导致没有正确读取到数据。

可以使用根据 BytesAvailable 属性提供当前缓冲区的有效数据长度来处理如何等待数据，也可以单个字节读取，根据数据再决定具体读取多少字节。

Matlab R2019b 引入 configureCallback 函数.The tcpclient properties and functions associated with callbacks follow.

- *NumBytesAvailable*   Number of bytes available to read
- *BytesAvailableFcn*   Bytes available callback function
- *BytesAvailableFcnCount*  Number of bytes of data to trigger callback
- *BytesAvailableFcnMode*   Bytes available callback trigger mode
- *configureCallback*   Set callback function and trigger condition for communication with remote host over TCP/IP
- *ErrorOccurredFcn*    Callback function triggered by error event
- *UserData*    General purpose property for user data


```matlab
configureCallback(t,"byte",50,@callbackFcn) 
configureCallback(t,"terminator",callbackFcn)
configureCallback(t,"byte",count,callbackFcn)
configureCallback(t,"off")

% Write and Read ASCII Data Using Terminator Callback Mode
% Create a callback function called readASCIIFcn to read data each time a terminator is found in the data.
% Store the read data in the UserData property of tcpclient object.
% The callback is triggered when it receives a terminator in the data.
configureCallback(t,"terminator",@readASCIIFcn);
% Set the Terminator property value to "LF".
configureTerminator(t,"LF");
% configureTerminator(t,"LF","CR/LF");
% configureTerminator(t,terminator)
% configureTerminator(t,readterminator,writeterminator)

% Callback Function to Read Binary Data
% This function calls read to read BytesAvailableFcnCount number of bytes of data.
% This data is echoed back by the server.
function readDataFcn(src, ~)
src.UserData = read(src,src.BytesAvailableFcnCount,"uint8");
end

% Callback Function to Read ASCII Data
% This function calls readline to read ASCII data originally sent by the tcpclient object. 
% The data is echoed back by the server.
function readASCIIFcn(src, ~)
src.UserData = readline(src);
end
```

You can enhance the power and flexibility of your TCP/IP client by using events and callbacks. An event occurs after a condition is met and can result in one or more callbacks.

While MATLAB® is connected to a remote host with a TCP/IP client, you can use events to display a message, display data, analyze data, and so on. You can control callbacks through callback properties and callback functions. All event types have an associated callback property. Callback functions are MATLAB functions that you write to suit your specific application needs. Execute a callback when a particular event occurs by specifying the name of the callback function as the value for the associated callback property.


```matlab
host = 'localhost';
web = tcpclient(host, 80, 'timeout', 30)
http = ['GET /index.html HTTP/1.1' char(13,10)'...
       'Host: ' host char(13,10)'...
       char(13,10)'];
write(web, uint8(http))

clc
if (web.BytesAvailable == 0)
    disp('Not any buffer bytes')
    %pause(0.1)
end
while (t.NumBytesAvailable > 0)
    A = readline(t)
end

res = read(web, 1);
res = [res, read(web)];
% char(res)
length(res)

%% Start an EchoServer at TCP:4000
echotcpip('on',4000)
t = tcpclient('localhost',4000)
write(t, uint8('HI'))
% s = read(t) % may passed by before buffer filled
s = char(read(t, 2)) % perfect! read all data.
% s = char(read(t, 3)) % no more data then 3 bytes, cause bloking last to timeout
char(s)
echotcpip('off')
```




## ==⚡ Functions

Input and Output Arguments

Support variable length argument lists, check arguments

Functions

- *nargin*  Number of function input arguments
- *nargout* Number of function output arguments
- *varargin*    Variable-length input argument list
- *varargout*   Variable-length output argument list
- *narginchk*   Validate number of input arguments
- *nargoutchk*  Validate number of output arguments
- *validateattributes*  Check validity of array
- *validatestring*  Check validity of text string
- *inputParser* Parse function inputs
- *inputname*   Variable name of function input

- *global*  Declare variables as global


函数定义示范，注解内容在使用 help 命令时显示，可以使用 Web 页面链接：

```matlab
function c = addme(a,b)
% ADDME  Add two values together.
%   C = ADDME(A) adds A to itself.
%   C = ADDME(A,B) adds A and B together.
%
%   See also SUM, PLUS.
%   For more information, see <a href="matlab: 
%   web('http://www.mathworks.com')">the MathWorks Web site</a>.

switch nargin
    case 2
        c = a + b;
    case 1
        c = a + a;
    otherwise
        c = 0;
end
```

同一个程序文件可以定义多个函数，在内部可以调用。主函数结束关键字 end 可选，本地函数、嵌套函数需要使用 end 关键字。

函数定义语法：

```matlab
% Syntax
function [y1,...,yN] = myfun(x1,...,xM)

% function returns more than one output
function [one,two,three] = myfunction(x)
% function has one output y
function y = myfunction(x)
% If there is no output, either omit it,
function myfunction(x)
% or use empty square brackets:
function [] = myfunction(x)
% function accepts any inputs
function y = myfunction(one,two,three)
```

Ignore Function Inputs 使用波浪号省略传入参数。例如，事件回调第二个参数为数据，如果不使用它就可以省略：

```matlab
function colorButton
figure;
uicontrol('Style','pushbutton','String','Click me','Callback',@btnCallback)

% The function declaration for btnCallback is essentially the same as
% function btnCallback(h,eventdata)

function btnCallback(h,~)
set(h,'BackgroundColor',rand(3,1))
```

Matlab 函数要单独保存到 .m 程序文件，不能和脚本混合。文件名和主函数名要一致，Matlab 通过文件名调用主函数。

Matlab 函数有多种类型，只有匿名函数不需要独立文件保存：

- Local and Nested Functions in a File
- Private Functions in a Subfolder
- Anonymous Functions Without a File

私有函数放置在子目录下，如 *private* ，只能被上级目录中的函数访问。不可以被外部直接访问，但可以通过 help 命令访问其注解信息，如： 

    help private/findme

Files can include multiple local functions or nested functions. Use the *end* keyword to indicate the end of each function in a file if:

- Any function in the file contains a nested function
- Any local function in the file uses the end keyword


虽然，Matlab 的函数不通过 return 返回值，但是配合 *nargin* 和 *nargout* 可以判断用户调用函数时指定了几个输出参数和输入参数，并且根据参数设置返回值列表中的变量，就可以灵活定制返回值的逻辑。

```matlab
% Variable Number of Function Inputs
function varlist(varargin)
   fprintf('Number of arguments: %d\n',nargin)
   celldisp(varargin)

% Call varlist with several inputs.
varlist(ones(3),'some text',pi) % nargin = 0
R = varlist(ones(3),'some text',pi) % nargin = 1: Too many output arguments. 
[R, G, B] = varlist(ones(3),'some text',pi) % nargin = 3: Too many output arguments. 
```

例如，矩阵操作函数 *find* 查找元素位置时，会根据用户设置的返回参数返回不同的值：

- nargin = 0 或 1 时，返回参数列表中的第一个参数设置为一个 n-by-1 vector，里面包含索引值，是将输入的 X 当作一维向量，并找出非零值元素的索引位置；
- nargin = 2 或 3 时，返回参数列表按 [rows, columns, values] 字面意义返回数据。

```matlab
format compact
X = randi(2,[3,3])-1
% Find the nonzero elements in a vector/matrix/array.
[rows, cols, values] = find(X)
% Find first/last n indices corresponding to the nonzero elements in X
Indices = find(X,2) % return 2 indices of nonzero elements in X
Indices = find(X,2,'last')
% Find zero elements in X. X==0 return a new vector/matrix/array.
Indices = find(X==1)
```

对于参数长度不确定的函数，还可以使用变长参数：

```matlab
% Support Variable Number of Inputs
function varlist(varargin)
   fprintf('Number of arguments: %d\n',nargin)
   celldisp(varargin)

% Call varlist with several inputs.
varlist(ones(3),'some text',pi)
```

使用 *varargin* 和 *varargout* 注意，它们是 Cell Array 类型，必需在参数列表中使用这个变量名。并且不能在其后面有其它参数变量，否则它们就和普通参数变量一样，在嵌套函数中也会访问不了。

```matlab
function showArgs(varargin)
nested1(3,4)
nested2(5,6,7)

    function nested1(a,b)
        disp('nested1: Contents of varargin{1}')
        disp(varargin{1})
    end

    function nested2(varargin)
        disp('nested2: Contents of varargin{1}')
        disp(varargin{1})
    end

end

% Call the function and compare the contents of varargin{1} in the two nested functions.
showArgs(0,1,2)
nested1: Contents of varargin{1}
     0

nested2: Contents of varargin{1}
     5
```

### ==⚡ Anonymous functions

An anonymous function is a function that is not stored in a program file, but is associated with a variable whose data type is *function_handle*. Anonymous functions can accept inputs and return outputs, just as standard functions do. However, they can contain only a single executable statement.

Function Handles 是特殊的一种类型，它就是函数的引用，相当于 C/C++ 中的函数地址的概念，可以将函数当作一个参数来传递而不是调用，使用 @function_name 这样的表达形式，用于 @ 来定义匿名函数就是返回一个函数引用。

匿名函数定义与使用，以下匿名函数接收一个输入参数 x，默认返回一个值：

```matlab
>> sqr = @(x) x.^2;
>> sqr(2)

ans =

     4
```

对匿名函数进行积分：

```matlab
q = integral(sqr,0,1);
q = integral(@(x) x.^2,0,1);
```

Variable sqr is a function handle. The @ operator creates the handle, and the parentheses () immediately after the @ operator include the function input arguments. 

You do not need to create a variable in the workspace to store an anonymous function. Instead, you can create a temporary function handle within an expression.


**Variables in the Expression**

Function handles can store not only an expression, but also variables that the expression requires for evaluation.

For example, create a function handle to an anonymous function that requires coefficients a, b, and c.

```matlab
a = 1.3;
b = .2;
c = 30;
parabola = @(x) a*x.^2 + b*x + c;
clear a b c
x = 1;
y = parabola(x)
y =
   31.5000
```

Because a, b, and c are available at the time you create parabola, the function handle includes those values. The values persist within the function handle even if you clear the variables:

**Multiple Anonymous Functions**

The expression in an anonymous function can include another anonymous function. This is useful for passing different parameters to a function that you are evaluating over a range of values. For example, you can solve the equation below for varying values of c by combining two anonymous functions:

    g = @(c) (integral(@(x) (x.^2 + c*x + 1),0,1));


**Functions with No Inputs**

If your function does not require any inputs, use empty parentheses when you define and call the anonymous function. For example:

    t = @() datestr(now);
    d = t()


**Functions with Multiple Inputs or Outputs**

Anonymous functions require that you explicitly specify the input arguments as you would for a standard function, separating multiple inputs with commas. For example, this function accepts two inputs, x and y:

    myfunction = @(x,y) (x^2 + y^2 + x*y);

    x = 1;
    y = 10;
    z = myfunction(x,y)
    z =

       111

However, you do not explicitly define output arguments when you create an anonymous function. If the expression in the function returns multiple outputs, then you can request them when you call the function. Enclose multiple output variables in square brackets.

For example, the ndgrid function can return as many outputs as the number of input vectors. This anonymous function that calls ndgrid can also return multiple outputs:

    c = 10;
    mygrid = @(x,y) ndgrid((-x:x/c:x),(-y:y/c:y));
    [x,y] = mygrid(pi,2*pi);
    z = sin(x) + cos(y);
    mesh(x,y,z)

**Arrays of Anonymous Functions**

Although most MATLAB fundamental data types support multidimensional arrays, function handles must be scalars (single elements). However, you can store multiple function handles using a cell array or structure array. The most common approach is to use a cell array, such as

    f = {@(x)x.^2;
         @(y)y+10;
         @(x,y)x.^2+y+10};

When you create the cell array, keep in mind that MATLAB interprets spaces as column separators. Either omit spaces from expressions, as shown in the previous code, or enclose expressions in parentheses, such as

    f = {@(x) (x.^2);
         @(y) (y + 10);
         @(x,y) (x.^2 + y + 10)};

Access the contents of a cell using curly braces. For example, f{1} returns the first function handle. To execute the function, pass input values in parentheses after the curly braces:

    x = 1;
    y = 10;

    f{1}(x)
    f{2}(y)
    f{3}(x,y)


## ==⚡ Control Flow

MATLAB Language Syntax

- *if, elseif, else*    Execute statements if condition is true
- *for* Execute statements specified number of times
- *parfor*  Parallel for loop
- *switch, case, otherwise* Execute one of several groups of statements
- *try, catch*  Execute statements and catch resulting errors
- *while*   Repeat execution of statements while condition is true

- *break*   Terminate execution of for or while loop
- *continue*    Pass control to next iteration of for or while loop
- *end* Terminate block of code, or indicate last array index
- *pause*   Stop MATLAB execution temporarily
- *return*  Return control to invoking function

The loop runs in parallel when you have the Parallel Computing Toolbox™ or when you create a MEX function or standalone code with MATLAB Coder™. Unlike a traditional for-loop, iterations are not executed in a guaranteed order. You cannot call scripts directly in a parfor-loop. However, you can call functions that call scripts.

    parpool(3)
    parfor i=1:3, c(:,i) = eig(rand(1000)); end

Matlab 安装时点选了并行计算工具箱才可以使用并行循环。

条件、for 循环流程控制语句示范：

```matlab
%% Create a matrix of 1s.
nrows = 4;
ncols = 6;
A = ones(nrows,ncols);

%% Loop through the matrix and assign each element a new value. 
% Assign 2 on the main diagonal, -1 on the adjacent diagonals, and 0 everywhere else.
for c = 1:ncols
    for r = 1:nrows

        if r == c
            A(r,c) = 2;
        elseif abs(r-c) == 1
            A(r,c) = -1;
        else
            A(r,c) = 0;
        end

    end
end
A
```

程序输出：

    A =

         2    -1     0     0     0     0
        -1     2    -1     0     0     0
         0    -1     2    -1     0     0
         0     0    -1     2    -1     0


随机数生成，10 行 1 列，并使用 any 函数进行条件判断：

```matlab
%% Generate 10 * 1 random number
limit = 0.75;
A = rand(10,1)

%% Test if any results are true using the any function.
if any(A > limit)
    disp('There is at least one value above the limit.')
else
    disp('All values are below the limit.')
end
```

判断函数文件是否存在：

```matlab
x = 42;
if exist('myfunction.m','file') && (myfunction(x) >= pi)
    disp('Expressions are true')
end
```

分支选择语句，不需要 break，默认分支 otherwise 可选：

```matlab
n = input('Enter a number: ');

switch n
    case -1
        disp('negative one')
    case 0
        disp('zero')
    case 1
        disp('positive one')
    otherwise
        disp('other value')
end

x = [12 64 24];
plottype = 'pie3';

switch plottype
    case 'bar' 
        bar(x)
        title('Bar Graph')
    case {'pie','pie3'}
        pie3(x)
        title('Pie Chart')
    otherwise
        warning('Unexpected plot type. No plot created.')
end
```

异常捕捉，catch 可以不指定异常：

```matlab
try
    a = notaFunction(5,6);
catch ME
    switch ME.identifier
        case 'MATLAB:UndefinedFunction'
            warning('Function is undefined.  Assigning a value of NaN.');
            a = NaN;
        case 'MATLAB:scriptNotAFunction'
            warning(['Attempting to execute script as function. '...
                'Running script and assigning output a value of 0.']);
            notaFunction;
            a = 0;
        otherwise
            rethrow(ME)
    end
end
```

使用 while 循环统计文件内容行数：

```matlab
fid = fopen('magic.m','r');
count = 0;
while ~feof(fid)
    line = fgetl(fid);
    if isempty(line) || strncmp(line,'%',1) || ~ischar(line)
        continue
    end
    count = count + 1;
end
count
fclose(fid);
```




## ==⚡ Object-Oriented Programming

Matlab 2008a 之后开始真正的支持面向对象编程，类文件也和函数文件一样，类名和文件同名。

From within MATLAB®, call functions in other languages, such as Java, C/C++, .NET, and Python

- Call MEX-File Functions
- Call C Shared Libraries
- Call Java Libraries
- Call .NET Libraries
- Call COM Objects
- Call Python Libraries
- Call WSDL Web Service

类开定义语法：

```matlab
% Syntax
classdef (ClassAttributes) ClassName < SuperClass
   properties (PropertyAttributes)
      PropName
   end
   methods (MethodAttributes)
      methodName
   end
   events (EventAttributes)
      EventName
   end
   enumeration
      EnumName
   end
end
```

Class Building Blocks

MATLAB® organizes class definition code into modular blocks, delimited by keywords. 

All keywords have an associated end statement:

- *classdef...end* — Definition of all class components
- *properties...end* — Declaration of property names, specification of property attributes, assignment of default values
- *methods...end* — Declaration of method signatures, method attributes, and function code
- *events...end* — Declaration of event name and attributes
- *enumeration...end* — Declaration of enumeration members and enumeration values

Sample Class Implementations

```matlab
classdef BasicClass
   properties
      Value
   end
   methods
       % Constructor methods
       function obj = BasicClass(val)
          if nargin > 0
             if isnumeric(val)
                obj.Value = val;
             else
                error('Value must be numeric')
             end
          end
       end
      function r = roundOff(obj)
         r = round([obj.Value],2);
      end
      function r = multiplyBy(obj,n)
         r = [obj.Value] * n;
      end
      % Overload Functions: operator +
      function r = plus(o1,o2)
         r = [o1.Value] + [o2.Value];
      end
   end
end
```

Use class:

```matlab
% Create an object
a = BasicClass

% Access Properties
a.Value = pi/3;

% Call the roundOff method on object a:
a = BasicClass(pi/3);
roundOff(a)

% Vectorize Methods
% By using vector notation, a can be an array:
a(1) = BasicClass(2.7984);
a(2) = BasicClass(sin(pi/3));
a(3) = BasicClass(7);
roundOff(a)

% By implementing a method called plus, you can use the "+" operator with objects of BasicClass.
a = BasicClass(pi/3);
b = BasicClass(pi/4);
a + b
```

Calling Superclass Method

- In C++, you call a superclass method using the scoping operator: superclass::method
- In Java code, you use: superclass.method

The equivalent MATLAB operation is method@superclass.


### ===🗝 Static Methods

Why Define Static Methods
Static methods are associated with a class, but not with specific instances of that class. These methods do not perform operations on individual objects of a class and, therefore, do not require an instance of the class as an input argument, like ordinary methods.

Static methods are useful when you do not want to first create an instance of the class before executing some code. For example, you might want to set up the MATLAB® environment or use the static method to calculate data needed to create class instances.

Suppose a class needs a value for pi calculated to particular tolerances. The class could define its own version of the built-in pi function for use within the class. This approach maintains the encapsulation of the class's internal workings, but does not require an instance of the class to return a value.

Defining a Static Method
To define a method as static, set the methods block Static attribute to true. For example:

```matlab
classdef MyClass
   ...
   methods(Static)
      function p = pi(tol)
         [n d] = rat(pi,tol);
         p = n/d;
      end
    end
end
```

Calling Static Methods
Invoke static methods using the name of the class followed by dot (.), then the name of the method:

    classname.staticMethodName(args,...)

Calling the pi method of MyClass in the previous section would require this statement:

    value = MyClass.pi(.001);

You can also invoke static methods using an instance of the class, like any method:

    obj = MyClass;
    value = obj.pi(.001);

Inheriting Static Methods
Subclasses can redefine static methods unless the method's Sealed attribute is also set to true in the superclass.





### ===🗝 enumeration

```matlab
classdef Boolean < logical
   enumeration
      No  (0)
      Yes (1)
   end
end

classdef Bearing < uint32
   enumeration
      North (0)
      East  (90)
      South (180)
      West  (270)
   end
end

classdef SyntaxColors
   properties
      R
      G
      B
   end
   methods
      function c = SyntaxColors(r, g, b)
         c.R = r; c.G = g; c.B = b;
      end
   end
   enumeration
      Error   (1, 0, 0)
      Comment (0, 1, 0)
      Keyword (0, 0, 1)
      String  (1, 0, 1)
   end
end

classdef WeekDays
   enumeration
      Monday, Tuesday, Wednesday, Thursday, Friday
   end
end
```

When you refer to an enumeration member, the constructor initializes the property values:

    e = SyntaxColors.Error;
    e.R = 0

Usage example, assign the enumeration member WeekDays.Tuesday to the variable today:

```sh
>> today = WeekDays.Tuesday;
>> ['Today is ', char(today)]

ans =

Today is Tuesday

>> whos
  Name      Size            Bytes  Class       Attributes

  ans       1x15               30  char                  
  m         1x1                56  WeekDays              
```

Enumeration classes have default methods:

- Default constructor (WeekDays in this case)
- *char* — converts enumeration members to character strings
- *eq* — enables use of `==` in expressions
- *ne* — enables use of `~=` in expressions

```sh
>> methods(m)

Methods for class WeekDays:

WeekDays  char      eq        ne
```

Testing for Membership in a Set

Determine if today is a meeting day for your team. Create a set of enumeration members corresponding to the days on which the team has meetings.

```matlab
>> today = WeekDays.Tuesday;
>> teamMeetings = [WeekDays.Wednesday WeekDays.Friday];
>> any(today == teamMeetings)

ans =

     0
```


### ===🗝 Events

事件是一种基本的编程模式，事件编程模式要点：

- Events Owner 事件拥有者，定义事件类型，或事件名称，并在适当时机触发事件，通知监听者；
- Listeners 事件的监听者，关注事件的动态：
    - 先通过 *addlistener* 注册事件处理函数，并等待事件触发；
    - 不需要关注事件时，执行 *delete* 删除处理函数句柄，取消注册；

Define and trigger events; create listeners that respond to events

Events are notices broadcast when some change or action occurs involving an object. Listeners define functions that execute when specific events occur. Classes can define and trigger events. MATLAB® can trigger predefined events when code accesses object properties.

Functions

- *events*  Event names
- *handle.notify*   Notify listeners that event is occurring
- *handle.addlistener*  Create event listener
- *handle.delete*   Delete handle object


Classes

- *event.EventData* Base class for all data objects passed to event listeners
- *event.listener*  Class defining listener objects
- *event.PropertyEvent* Data for property events
- *event.proplistener*  Define listener object for property events

事件定义有三个属性：

- *Hidden* 设置 *events* 方法查询时的可见性；
- *ListenAccess* Determines where you can create listeners for the event.
- *NotifyAccess* Determines where code can trigger the event

访问控制方式除了 public、protected、private，还可以指定一个或一组 meta.class，如 *{?ClassName1,?ClassName2,...}*。

```matlab
events (Hidden = false, ListenAccess = 'protected', NotifyAccess = 'private')
   EventName1
   EventName2
end
```

示范，按钮状态变换：

```matlab
classdef ToggleButton < handle
   properties
      State = false
   end
   events
      ToggledState
   end
   methods
      function OnStateChange(obj, newState)
         if newState ~= obj.State
            obj.State = newState;
            notify(obj,'ToggledState');
         end
      end
   end
end

classdef RespondToToggle < handle
   properties
       ListenerHandle
   end
   methods
      function obj = RespondToToggle(toggle_button_obj)
         h = addlistener(toggle_button_obj,'ToggledState',@RespondToToggle.handleEvnt);
         ListenerHandle = h;
      end
   end
   methods (Static)
      function handleEvnt(src,~)
         if src.State
            disp('ToggledState is true')
         else
            disp('ToggledState is false')
         end
      end
   end
end
```

For example, create instances of both classes.

Whenever you call the ToggleButton object's OnStateChange method, notify triggers the event:

```matlab
>> tb = ToggleButton;
>> rtt = RespondToToggle(tb);
>> tb.OnStateChange(false)
ToggledState is false
>> tb.OnStateChange(true)
ToggledState is true
>> delete(rtt.ListenerHandle)
```

执行 notify 触发事件时，可以传递自定义数据，示范：

```matlab
classdef (ConstructOnLoad) ToggleEventData < event.EventData
   properties
      NewState
   end
   
   methods
      function data = ToggleEventData(newState)
         data.NewState = newState;
      end
   end
end
% notify(obj,'ToggledState',ToggleEventData(newState));
```
Syntax to Specify Callback

```matlab
%For a function: functionName
lh = addlistener(eventSourceObj,'EventName',@functionName)

%For an ordinary method called with an object of the class: obj.methodName
lh = addlistener(eventSourceObj,'EventName',@obj.methodName)

%For a static method:ClassName.methodName
lh = addlistener(eventSourceObj,'EventName',@ClassName.methodName)

%For a function in a package:PackageName.functionName
lh = addlistener(eventSourceObj,'EventName',@PackageName.functionName)
```

Method Callback

The TestAnonyFcn class shows the use of an anonymous function with an additional argument. The listener callback displays the inputs arguments to show how MATLAB calls the callback method.

```matlab
classdef TestAnonyFcn < handle
   events
      Update
   end
   methods
      function obj = TestAnonyFcn
         t = datestr(now);
         addlistener(obj,'Update',@(src,evnt)obj.evntCb(src,evnt,t));
      end
      function triggerEvnt(obj)
         notify(obj,'Update')
      end
   end
   methods (Access = private)
      function evntCb(~,~,evnt,varargin)
         disp(['Number of inputs: ',num2str(nargin)])
         disp(evnt.EventName)
         disp(varargin{:})
      end
   end
end

%Create an object and trigger the event by calling the triggerEvt method:
obj = TestAnonyFcn;
obj.triggerEvnt;
```


### ===🗝 Class Metadata

Get detailed information about classes from class metadata

Metadata provides information about class definitions. Find information about all properties, methods, and events defined by the class without constructing objects of the class.

Functions

- *metaclass*   Obtain *meta.class* object
- *meta.abstractDetails*    Find abstract methods and properties
- *meta.class.fromName* Return *meta.class* object associated with named class
- *meta.package.fromName*   Return *meta.package* object for specified package
- *meta.package.getAllPackages* Get all top-level packages

- *properties*  Class property names
- *methods* Class method names
- *events*  Event names
- *superclasses*    Superclass names

Classes

- *meta.class*  Describe MATLAB class
- *meta.property*   Describe property of MATLAB class
- *meta.method* Describe method of MATLAB class
- *meta.event*  Describe event of MATLAB class
- *meta.package*    Describe MATLAB package
- *meta.DynamicProperty*    Describe dynamic property of MATLAB object
- *meta.EnumeratedValue*    Describe enumeration member of MATLAB class
- *meta.MetaData*   Superclass for MATLAB object metadata

Syntax Examples

```matlab
% Obtain meta.class object
mc = metaclass(object)
mc = ?ClassName

% Class method names
methods('classname')
methods(...,'-full')
m = methods(...)

% Superclass names
superclasses('ClassName')
superclasses(obj)
s = superclasses(...)

% Establish superior class relationship
superiorto('class1', 'class2', ...)

% Specify inferior class relationship
inferiorto('class1','class2',...)
```

查询 handle 类型提供的方法：

```matlab
>> methods('handle')

Methods for class handle:

addlistener  eq           findprop     gt           le           ne    
delete       findobj      ge           isvalid      lt           notify
```



### ===🗝 Class Operator Implementation

MATLAB Operators and Associated Functions

How to Define Operators

You can implement MATLAB® operators to work with objects of your class. To implement operators, define the associated class methods.

Each operator has an associated function (e.g., the + operator has an associated plus.m function). You can implement any operator by creating a class method with the appropriate name. This method can perform whatever steps are appropriate for the operation being implemented.

The following table lists the function names for MATLAB operators. Implementing operators to work with arrays (scalar expansion, vectorized arithmetic operations, and so on), can also require modifying indexing and concatenation.

    |    Operation     | Method to Define |         Description         |
    |------------------|------------------|-----------------------------|
    | a + b            | plus(a,b)        | Binary addition             |
    | a - b            | minus(a,b)       | Binary subtraction          |
    | -a               | uminus(a)        | Unary minus                 |
    | +a               | uplus(a)         | Unary plus                  |
    | a.*b             | times(a,b)       | Element-wise multiplication |
    | a*b              | mtimes(a,b)      | Matrix multiplication       |
    | a./b             | rdivide(a,b)     | Right element-wise division |
    | a.\b             | ldivide(a,b)     | Left element-wise division  |
    | a/b              | mrdivide(a,b)    | Matrix right division       |
    | a\b              | mldivide(a,b)    | Matrix left division        |
    | a.^b             | power(a,b)       | Element-wise power          |
    | a^b              | mpower(a,b)      | Matrix power                |
    | a < b            | lt(a,b)          | Less than                   |
    | a > b            | gt(a,b)          | Greater than                |
    | a <= b           | le(a,b)          | Less than or equal to       |
    | a >= b           | ge(a,b)          | Greater than or equal to    |
    | a ~= b           | ne(a,b)          | Not equal to                |
    | a == b           | eq(a,b)          | Equality                    |
    | a & b            | and(a,b)         | Logical AND                 |
    | a | b            | or(a,b)          | Logical OR                  |
    | ~a               | not(a)           | Logical NOT                 |
    | a:d:b            | colon(a,d,b)     | Colon operator              |
    | a:b              | colon(a,b)       | Colon operator              |
    | a'               | ctranspose(a)    | Complex conjugate transpose |
    | a.'              | transpose(a)     | Matrix transpose            |
    | console output   | display(a)       | Display method              |
    | [a b]            | horzcat(a,b,...) | Horizontal concatenation    |
    | [a; b]           | vertcat(a,b,...) | Vertical concatenation      |
    | a(s1,s2,...sn)   | subsref(a,s)     | Subscripted reference       |
    | a(s1,...,sn) = b | subsasgn(a,s,b)  | Subscripted assignment      |
    | b(a)             | subsindex(a)     | Subscript index             |


## ==⚡ Graphics

2-D and 3-D Plots

Plot continuous, discrete, surface, and volume data

- Line Plots ➡ *Linear, log-log, semi-log, error bar plots
- Pie Charts, Bar Plots, and Histograms ➡ *Proportion and distribution of data
- Discrete Data Plots ➡ *Stem, stair, scatter plots
- Polar Plots ➡ *Plots in polar coordinates
- Contour Plots ➡ *2-D and 3-D isoline plots
- Vector Fields ➡ *Comet, compass, feather, quiver and stream plots
- Surfaces, Volumes, and Polygons ➡ *Gridded surface and volume data, ungridded polygon data
- Animation ➡ *Animating plots*

Formatting and Annotation

Add labels, adjust colors, define axis limits, apply lighting or transparency, set camera view

- Titles and Labels ➡ *Add titles, axis labels, informative text, and other graph annotations
- Coordinate System ➡ *Modify axis limits and tick values, add grid lines, combine multiple plots
- Colormaps ➡ *View and modify colormap, control color scaling, add colorbar
- Data Exploration ➡ *Pan, zoom, rotate, interactively edit graph
- Data Brushing ➡ *Interactively mark, delete, modify and save observations in graphs
- 3-D Scene Control ➡ *Add light, set object transparency, control camera view*

Graphics Objects

Customize graphics by setting properties of the underlying objects

Graphics objects are the components used by MATLAB® to create visualizations of data. Each object plays a specific role in the graphics display. For example, a line plot consists of a figure object, an axes object, and a chart line object. You can customize graphics objects by setting their properties. For more information about setting properties, see Access Property Values.

Graphics objects are organized into a hierarchy, as shown in the following diagram. The hierarchical nature of graphics objects reflects the containment of objects by other objects. For more information, see Graphics Objects.

            +=========+
            |  Root   |
            +====^====+
                 |
            +=========+            +============+
            | Figure  | <--------- | UI Objects |
            +====^====+            +============+
                 |
            +=========+
            |  Axes   |
            +====^====+
                 |     
                 +------------------+---------------+
                 |                  |               |
         +===============+  +==============+  +============+
         | Group Objects |  | Illustration |  | Annotation |
         | (Optional)    |  | Objects      |  | Objects    |
         +=======^=======+  +==============+  +============+
                 |
    +============================+
    | Chart and Primitive Objects|
    +============================+

- Graphics Object Properties ➡ *View and set graphics object properties, define default values
- Graphics Object Identification ➡ *Finding, copying, and deleting graphics objects
- Graphics Object Programming ➡ *Comparing, testing for validity, preallocating, and object arrays
- Interactive Control and Callbacks ➡ *Writing programs that respond to user actions, such as mouse clicks
- Object Containers ➡ *Grouping objects and operating on the group as a whole
- Specifying Target for Graphics Output ➡ *Controlling which figures and axes to target and how to update these objects*


### ===🗝 Line Plot Graphs

Line Plots
Linear, log-log, semi-log, error bar plots

- *plot*    2-D line plot
- *plotyy*  2-D line plots with y-axes on both left and right side
- *plot3*   3-D line plot
- *loglog*  Log-log scale plot
- *semilogx*    Semilogarithmic plot
- *semilogy*    Semilogarithmic plot
- *errorbar*    Plot error bars along curve
- *fplot*   Plot function between specified limits
- *ezplot*  Easy-to-use function plotter
- *ezplot3* Easy-to-use 3-D parametric curve plotter

MATLAB Language Syntax

- LineSpec (Line Specification)   Line specification string syntax
- ColorSpec (Color Specification) Color specification

Properties

- Chart Line Properties   Control chart line appearance and behavior
- Errorbar Series Properties  Control errorbar series appearance and behavior

Plots 意思是使用图表说明，illustrate by use of a graph。通常有 2D/3D 两种图表，本质上，它们都是二维的图像，毕竟电脑屏幕只是一个显示 2D 图像的设备。3D 就是抽象的图形，在视觉上的模拟，特别是在运动的情况下 3D 效果更强。

```matlab
%% Plot 3-D Helix
% Define t as values between 0 and 10π.
% Define st and ct as vectors of sine and cosine values.

t = 0:pi/50:10*pi;
st = sin(t);
ct = cos(t);

figure
plot3(st,ct,t)
```

对于一维的情况，没有一维图表，一维图表意味一条直线，只有长度的变化。但是对于一维的数据却是图表绘制的重要输入，1-D Interpolation 插值可以生成各种一维向量数据。所谓插值，就是在采样数据不足的情况下，根据插值算法增加数据。

可以将这些数据以 2D 甚至是 3D 的形式展示，这取决于数据可视化的形式：

- Line Plots ➡ Linear, log-log, semi-log, error bar plots
- Pie Charts, Bar Plots, and Histograms ➡ Proportion and distribution of data
- Discrete Data Plots ➡ Stem, stair, scatter plots
- Polar Plots ➡ Plots in polar coordinates
- Contour Plots ➡ 2-D and 3-D isoline plots
- Vector Fields ➡ Comet, compass, feather, quiver and stream plots
- Surfaces, Volumes, and Polygons ➡ Gridded surface and volume data, ungridded polygon data
- Animation ➡ Animating plots

虽然，像 *plot(Y)* 图表函数可以只接收一个输出向量进行绘图，但实际上它还是 2D 图表，只不过它会自动根据输入的数据类型来绘制图表：

- 输入的是向量，就自动按向量长度制图，[1, length(Y)] 作为 X 轴的值范围；
- 输入的是矩阵，每一列就看作一条线对应的数据向量，[1, rows] 作为 X 轴的值范围；
- 输入的是复数，imaginary part 作为 Y 轴的值，real part 作为 X 轴的，相当于 plot(real(Y),imag(Y));


列如，有 10 个随机值数据，它就是一维的向量，可以将它当作随时间变化的数据，或者与其它数据关联起来，就可以按 2D 图像的形式将数据可视化：

```matlab
% random data visualized
d = rand(1,10);
t = datetime(2014,6,28) + caldays(1:10)
plot(t,d);
```

使用 *linspace* 可以生成固定差值间距的向量，即线性空间，还使用对数算法空间的 *logspace*。线性空间向量的生成和 ":" 操作非常相似，后可以设定一个步长，前者则可以设定线性空间的数据量，并且始终会包含 x1 和 x2 指定值。除非 *linspace* 只生成一个数据，n = 1，返回 [x2]。例如，*linspace(1,10,2)* 和 *1:9:10* 生成的向量相同，都是 [1,10]。

```matlab
% returns a row vector of 100 evenly spaced points between x1 and x2.
y = linspace(x1,x2) 
% generates n points. The spacing between the points is (x2-x1)/(n-1).
y = linspace(x1,x2,n) 

% generates a row vector y of 50 logarithmically spaced points between decades 10^a and 10^b. 
% The logspace function is especially useful for creating frequency vectors. 
y = logspace(a,b) 
% generates n points between decades 10^a and 10^b.
y = logspace(a,b,n)
% generates points between 10^a and pi, which is useful in digital signal processing 
% for creating logarithmically spaced frequencies in the interval [10^a,pi].
y = logspace(a,pi)
```


线图绘制是最常用的一种数据可视化手段，*plot* 可以绘制任意的线条，还可以设置 Colors, Line Styles, and Markers。

图表这些各种各样的属性可以改变外观，LineSpec 和 ColorSpec 可以线条样式和颜色，还 Marker 可以在数据值所在位置设置标记点。

以下是 *plot* 二维线条图表的各种用法：

```matlab
%% Plots - illustrate by use of graph
% 2-D line plot Syntax
% plot(X1,Y1,LineSpec1,...,Xn,Yn,LineSpecn)
x = linspace(1,10,50);
y1 = sin(x);
y2 = cos(x);
figure % new figure window
plot(x,y1)
%% Plot Multiple Lines
plot(x,y1, x,y2);
%% Specify Line Styles
plot(x,y1,'--',x,y2,':')
%% Specify Line Style and Color
plot(x,y1,'--r',x,y2,':r')
%% Specify Line Style, Color, and Markers
plot(x,y1,'--go',x,y2,':r*')
%% Plot Only Data Points
plot(x,y,'*')

%% Add Title and Axis Labels
plot(x,y1,'Color',[0,0.7,0.9])
title('2-D Line Plot')
xlabel('X-Axis')
ylabel('sin(x)')

%% Specify Line Width, Marker Size, and Marker Color
p = plot(x,y1,'--gs',...
    'LineWidth',1,...
    'MarkerSize',2,...
    'MarkerEdgeColor','b',...
    'MarkerFaceColor',[0.5,0.5,0.5])

%% Modify Lines After Creation
p.LineWidth = 1
p.MarkerSize = 2
p.LineStyle = '-'
p.Marker = 'o'
p.Color = 'yellow'

%% Plot Durations and Specify Tick Format
% Define t as seven linearly spaced duration values between 0 and 3 minutes. 
% Plot random data and specify the format of the duration tick marks using 
% the 'DurationTickFormat' name-value pair argument.
t = 0:seconds(30):minutes(3);
y = rand(1, length(t));
plot(t,y,'DurationTickFormat','mm:ss')

%% Specify Axes for Line Plot
ax1 = subplot(2,1,1); % top subplot
ax2 = subplot(2,1,2); % bottom subplot

plot(ax1,x,y1)
title(ax1,'Top Subplot')
ylabel(ax1,'sin(5x)')

plot(ax2,x,y2)
title(ax2,'Bottom Subplot')
ylabel(ax2,'sin(15x)')

%% Plot Circle
% Plot a circle centered at the point (4,3) with a radius equal to 2. 
% Use axis equal to use equal data units along each coordinate direction.
% The standard equation of the circle: (x-a)²+(y-b)²=r² center point at (a, b)
r = 2;
xc = 4;
yc = 3;

theta = linspace(0,2*pi);
x = r*cos(theta) + xc;
y = r*sin(theta) + yc;
plot(x,y)
axis equal
```

*subplot(m,n,p)* divides the current figure into an *m-by-n* grid and creates an axes for a subplot in the position specified by p. MATLAB® numbers its subplots by row, such that the first subplot is the first column of the first row, the second subplot is the second column of the first row, and so on. If the axes already exists, then the command subplot(m,n,p) makes the subplot in position p the current axes.

使用 hold 命令或函数可以打开、关闭原有内容的保持状态，hold on 状态打开后，可以在原有图表上绘制新内容：

```matlab
%% Specify Hold State for Specific Axes
% Create a figure with two subplots and add a line plot to each subplot.
x = linspace(0,2*pi);
ax1 = subplot(2,1,1);
y1 = sin(x);
plot(x,y1)

ax2 = subplot(2,1,2);
y2 = cos(x);
plot(x,y2)

% Add a second line plot to the upper subplot. Hold on previous content.
hold(ax1,'on')
y3 = sin(2*x);
plot(ax1,x,y3)
```


Input Arguments

- Y — y values: scalar | vector | matrix
- X — x values: scalar | vector | matrix
- LineSpec — Line style, marker symbol, and color: string
- ax — Axes object: axes object
- 'Color' — Line color: [0 0.4470 0.7410] (default) | RGB triplet | color string | 'none'
- 'DatetimeTickFormat' — Format for datetime tick labels: string
- 'DurationTickFormat' — Format for duration tick labels: string
- 'LineStyle' — Line style: '-' (default) | '--' | ':' | '-.' | 'none'
- 'LineWidth' — Line width: 0.5 (default) | positive value
- 'Marker' — Marker symbol: 'none' (default) | string
- 'MarkerEdgeColor' — Marker outline color: 'auto' (default) | 'none' | RGB triplet | color string
- 'MarkerFaceColor' — Marker fill color: 'none' (default) | 'auto' | RGB triplet | color string
- 'MarkerSize' — Marker size: 6 (default) | positive value

Marker symbol, specified as one of the marker strings in this table. By default, a chart line does not have markers. Add markers at each data point along the line by specifying a marker symbol.

| String |          Marker Symbol          |
|--------|---------------------------------|
| 'o'    | Circle                          |
| '+'    | Plus sign                       |
| '*'    | Asterisk                        |
| '.'    | Point                           |
| 'x'    | Cross                           |
| 's'    | Square ('square')               |
| 'd'    | Diamond ('diamond')             |
| '^'    | Upward-pointing triangle        |
| 'v'    | Downward-pointing triangle      |
| '>'    | Right-pointing triangle         |
| '<'    | Left-pointing triangle          |
| 'p'    | Five-pointed star ('pentagram') |
| 'h'    | Six-pointed star ('hexagram')   |
| 'none' | No markers                      |


An RGB triplet is a three-element row vector whose elements specify the intensities of the red, green, and blue components of the color. The intensities must be in the range [0,1], for example, [0.4 0.6 0.7]. This table lists RGB triplet values that have equivalent color strings.

| Long Name | Short Name | RGB Triplet |
|-----------|------------|-------------|
| 'yellow'  | 'y'        | [1 1 0]     |
| 'magenta' | 'm'        | [1 0 1]     |
| 'cyan'    | 'c'        | [0 1 1]     |
| 'red'     | 'r'        | [1 0 0]     |
| 'green'   | 'g'        | [0 1 0]     |
| 'blue'    | 'b'        | [0 0 1]     |
| 'white'   | 'w'        | [1 1 1]     |
| 'black'   | 'k'        | [0 0 0]     |

Line style, specified as one of the line style strings listed in this table.

| String |    Line Style    |
|--------|------------------|
| '-'    | Solid line       |
| '--'   | Dashed line      |
| ':'    | Dotted line      |
| '-.'   | Dash-dotted line |
| 'none' | No line No line  |

'DatetimeTickFormat' — Format for datetime tick labels

| Value                            | Example                             |
| :------------------------------- | ----------------------------------- |
| 'yyyy-MM-dd'                     | 2014-04-19                          |
| 'dd/MM/yyyy'                     | 19/04/2014                          |
| 'dd.MM.yyyy'                     | 19.04.2014                          |
| 'yyyy年 MM月 dd日'               | 2014年 04月 19日                    |
| 'MMMM d, yyyy'                   | April 19, 2014                      |
| 'eeee, MMMM d, yyyy HH:mm:ss'    | Saturday, April 19, 2014 21:41:06   |
| 'MMMM d, yyyy HH:mm:ss Z'        | April 19, 2014 21:41:06 -0400       |

'DurationTickFormat' — Format for duration tick labels

| Value |                                    Description                                     |
|-------|------------------------------------------------------------------------------------|
| 'y'   | Number of exact fixed-length years. A fixed-length year is equal to 365.2425 days. |
| 'd'   | Number of exact fixed-length days. A fixed-length day is equal to 24 hours.        |
| 'h'   | Number of hours                                                                    |
| 'm'   | Number of minutes                                                                  |
| 's'   | Number of seconds                                                                  |


### ===🗝 Vector Fields

Comet, compass, feather, quiver and stream plots

- *feather* Plot velocity vectors
- *quiver*  Quiver or velocity plot
- *compass* Plot arrows emanating from origin
- *quiver3* 3-D quiver or velocity plot
- *streamslice* Plot streamlines in slice planes
- *streamline*  Plot streamlines from 2-D or 3-D vector data

Properties

- *Quiver* Series Properties    Control quiver series appearance and behavior


```matlab
%% Projectile Path Over Time
%
% This example shows how to display the path of a projectile 
% as a function of time using a three-dimensional quiver plot.

% Show the path of the following projectile using constants f
% or velocity and acceleration, vz and a.
% $$z(t) = v_zt + \frac{at^2}{2}$$

vz = 10; % velocity constant
a = -32; % acceleration constant

% Calculate z as the height as time varies from 0 to 1.
t = 0:.1:1;
z = vz*t + 1/2*a*t.^2;

% Calculate the position in the x-direction and y-direction.
vx = 2;
x = vx*t;

vy = 3;
y = vy*t;

% Compute the components of the velocity vectors and display the vectors 
% using a 3-D quiver plot. Change the viewpoint of the axes to [70,18].

u = gradient(x);
v = gradient(y);
w = gradient(z);
scale = 0;

figure
quiver3(x,y,z,u,v,w,scale)
for i = -30:0.1:30
    view([70,i])
    drawnow
end
```


```matlab
%% Combine Contour Plot and Quiver Plot
%
% This example shows how to combine a contour plot and a quiver plot using the hold function.
% 
% Plot 10 contours of $x e^{-x^2-y^2}$ over a grid from -2 to 2 in the x and y directions.
% 
[X,Y] = meshgrid(-2:0.2:2);
Z = X .* exp(-X.^2 - Y.^2);
contour(X,Y,Z,10)

% Calculate the 2-D gradient of Z using the gradient function. 
% The gradient function returns U as the gradient in the x-direction 
% and V as the gradient in the y-direction. Display arrows indicating
% the gradient values using the quiver function.

[U,V] = gradient(Z,0.2,0.2);
hold on
quiver(X,Y,U,V)
hold off
```

```matlab
%% Stream Line Plots of Vector Data
%
% Wind Mapping Data
% The MATLAB® vector data set called wind represents air currents over North America. This example uses a combination of techniques:
% 
% - Stream lines to trace the wind velocity
% - Slice planes to show cross-sectional views of the data
% - Contours on the slice planes to improve the visibility of slice-plane coloring
% 
% 1. Determine the Range of the Coordinates
% Load the data and determine minimum and maximum values to locate the slice planes and contour plots (load, min, max).
% 
load wind
xmin = min(x(:));
xmax = max(x(:));
ymax = max(y(:));
zmin = min(z(:));
%  2. Add Slice Planes for Visual Context
%  Calculate the magnitude of the vector field (which represents wind speed) to generate scalar data for the slice command. Create slice planes along the x-axis at xmin, 100, and xmax, along the y-axis at ymax, and along the z-axis at zmin. Specify interpolated face coloring so the slice coloring indicates wind speed, and do not draw edges (sqrt, slice, FaceColor, EdgeColor).
% 
wind_speed = sqrt(u.^2 + v.^2 + w.^2);
hsurfaces = slice(x,y,z,wind_speed,[xmin,100,xmax],ymax,zmin);
set(hsurfaces,'FaceColor','interp','EdgeColor','none')
colormap jet

% 3. Add Contour Lines to the Slice Planes
% Draw light gray contour lines on the slice planes to help quantify the color mapping (contourslice, EdgeColor, LineWidth).
% 
hcont = ...
contourslice(x,y,z,wind_speed,[xmin,100,xmax],ymax,zmin);
set(hcont,'EdgeColor',[0.7 0.7 0.7],'LineWidth',0.5)

% 4. Define the Starting Points for Stream Lines
% In this example, all stream lines start at an x-axis value of 80 and span the range 20 to 50 in the y-direction and 0 to 15 in the z-direction. Save the handles of the stream lines and set the line width and color (meshgrid, streamline, LineWidth, Color).
% 
[sx,sy,sz] = meshgrid(80,20:10:50,0:5:15);
hlines = streamline(x,y,z,u,v,w,sx,sy,sz);
set(hlines,'LineWidth',2,'Color','r')

% 5. Define the View
% Set up the view, expanding the z-axis to make it easier to read the graph (view, daspect, axis).
% 
view(3)
daspect([2,2,1])
axis tight

% See coneplot for an example of the same data plotted with cones.
```


### ===🗝 Discrete Data Plots

Stem, stair, scatter plots

- *stem*    Plot discrete sequence data
- *stairs*  Stairstep graph
- *stem3*   Plot 3-D discrete sequence data
- *scatter* Scatter plot
- *scatter3*    3-D scatter plot
- *spy* Visualize sparsity pattern
- *plotmatrix*  Scatter plot matrix

Properties

- *Stem* Series Properties  Control stem series appearance and behavior
- *Stair* Properties    Control stair appearance and behavior
- *Scatter* Series Properties   Control scatter series appearance and behavior


Related Information

Scattered Data Interpolation


```matlab
%% Combine Line and Stem Plots
x = linspace(-2*pi,2*pi,40);
a = randn(1,length(x));
b = cos(x);
plot(x, b);

% Plot discrete sequence data over previous graph
hold on
stem(x, a)
stem(x, b)
hold off

% Add a title, axis labels, and a legend. 
% Specify the legend descriptions in the order that you create the plots.
title('Linear Combination of Two Functions')
xlabel('Time in \musecs')
ylabel('Magnitude')
legend('a+b','a = randn(x)','b = cos(x)')

%% Overlay Stairstep Plot and Line Plot
t = 0:10;
alpha = 0.01;
beta = 0.5;
f = exp(-alpha*t).*sin(beta*t);
% Display f as a stairstep plot and line plot.
plot(t, f, '-');
hold on
stairs(t,f,':*')
hold off

% Use the axis function to set the axis limits. 
% Label the x-axis and add a title to the graph.
axis([-1, 11, -1.2, 1.2]);
xlabel('t = 0:10')
title('Stairstep plot of e^{-\alpha*t} sin\beta*t');
```


狄洛尼三角剖分是计算几何的一个经典问题，点集的三角剖分（Triangulation），对数值分析（比如有限元分析）以及图形学来说（地形处理），都是极为重要的一项预处理技术。尤其是 Delaunay 三角剖分，由于其独特性，关于点集的很多种几何图都和 Delaunay 三角剖分相关，如 Voronoi 图，EMST 树，Gabriel 图等。

计算机的出现使得很多原本十分繁琐的工作得以大幅度简化，但是也有一些在人类直观看来很容易的问题，却需要拿出一套并不简单的通用解决方案，比如几何问题。作为计算机科学的一个分支，计算几何主要研究解决几何问题的算法。在现代工程和数学领域，计算几何在图形学、机器人技术、超大规模集成电路设计和统计等诸多领域有着十分重要的应用。

In mathematics and computational geometry, a Delaunay triangulation (also known as a Delone triangulation) for a given set P of discrete points in a general position is a triangulation DT(P) such that no point in P is inside the circumcircle of any triangle in DT(P). Delaunay triangulations maximize the minimum angle of all the angles of the triangles in the triangulation; they tend to avoid sliver triangles. The triangulation is named after Boris Delaunay for his work on this topic from 1934.


### ===🗝 Titles and Labels

Titles and Labels
Add titles, axis labels, informative text, and other graph annotations

- *title*   Add title to current axes
- *xlabel*  Label x-axis
- *ylabel*  Label y-axis
- *zlabel*  Label z-axis
- *clabel*  Label contour plot elevation
- *legend*  Add legend to graph
- *colorbar*    Colorbar showing color scale
- *text*    Add text descriptions to data points
- *texlabel*    Format text into TeX string
- *gtext*   Add text to figure using mouse
- *line*    Create line object
- *rectangle*   Create rectangle with sharp or curved corners
- *annotation*  Create annotations

Properties

- Colorbar Properties ➡ Control colorbar appearance and behavior
- Legend Properties ➡   Control legend appearance and behavior
- Primitive Line Properties ➡   Control primitive line appearance and behavior
- Rectangle Properties ➡    Control rectangle appearance and behavior
- Text Properties ➡ Control text appearance and behavior
- Annotation Arrow Properties ➡ Control annotation arrow appearance and behavior
- Annotation Double Arrow Properties ➡  Control annotation double arrow appearance and behavior
- Annotation Ellipse Properties ➡   Control annotation ellipse appearance and behavior
- Annotation Line Properties ➡  Control annotation line appearance and behavior
- Annotation Rectangle Properties ➡ Control annotation rectangle appearance and behavior
- Annotation Text Arrow Properties ➡    Control annotation text arrow appearance and behavior
- Annotation Text Box Properties ➡  Control annotation text box appearance and behavior

Add Title, Axis Labels, and Legend to Graph

```matlab
%% Add Title, Axis Labels, and Legend to Graph

% Create Simple Line Plot
x = linspace(-2*pi,2*pi,100);
y1 = sin(x);
y2 = cos(x);
plot(x,y1,x,y2)
% Add title
title('Graph of Sine and Cosine Between -2\pi and 2\pi')

% Add Axis Labels
xlabel('-2\pi < x < 2\pi') % x-axis label
ylabel('sine and cosine values') % y-axis label

% Add legend
legend('sin(x)','cos(x)')
% Change Legend Location: East Sourth West North Best
legend('y = sin(x)','y = cos(x)','Location','BestOutside')

%% Exclude Objects from Graph Legend
x = linspace(0,5,500);
hold on
y1 = exp(0.1*x).*sin(6*x);
p1 = plot(x,y1);
y2 = exp(0.2*x).*sin(6*x);
p2 = plot(x,y2);
y3 = exp(0.3*x).*sin(6*x);
p3 = plot(x,y3);
y4 = exp(0.4*x).*sin(6*x);
p4 = plot(x,y4);
hold off
legend([p1 p4],'e^{0.1x}sin(6x)','e^{0.4x}sin(6x)','Location','southwest')

%% Specify Legend Descriptions During Line Creation
x = linspace(0,2*pi,100);
hold on
y1 = sin(x);
p1 = plot(x,y1,'DisplayName','sin(x)');
y2 = sin(x) + pi/2;
p2 = plot(x,y2,'DisplayName','sin(x) + \pi/2');
y3 = sin(x) + pi;
p3 = plot(x,y3,'DisplayName','sin(x) + \pi');
hold off
legend([p1 p2 p3])
```

Text with Mathematical Expression Using LaTeX

```matlab
%% Add Text with Integral Expression to Graph
% Plot $y = x^2\sin(x)$. Draw a vertical line at $x = 2$ from the x-axis to the plotted line.
x = linspace(0,3);
y = x.^2.*sin(x);
plot(x,y)
line([2,2],[0,2^2*sin(2)])

% To use LaTeX markup, set the Interpreter property for the text object to 'latex'
str = '$$ \int_{0}^{2} x^2\sin(x) dx $$';
text(0.25,2.5,str,'Interpreter','latex')
annotation('arrow','X',[0.32,0.45],'Y',[0.6,0.4])

str = '$$\sin(x) = \sum_{n=0}^{\infty}{\frac{(-1)^n x^{2n+1}}{(2n+1)!}}$$';
text(-2,1,str,'Interpreter','latex')
```

Include Superscripts and Annotations in Graph Text

```matlab
t = 1:900;
y = 0.25*exp(-0.005*t);
plot(t,y)

title('Ae^{\alphat} for A = 0.25 and \alpha = -0.0005')
xlabel('Time \musec')
ylabel('Amplitude')

str = '\bullet \leftarrow 0.25t e^{-0.005t} at t = 300';
text(t(300),y(300),str)
```

TeX Markup Options
MATLAB® supports a subset of TeX markup. Use TeX markup to add superscripts and subscripts, modify the text type and color, and include special characters in the text string. MATLAB interprets text strings using TeX markup as long as the Interpreter property of the text object is set to 'tex' (the default).

This table lists the supported modifiers with the Interpreter property set to 'tex'. Modifiers remain in effect until the end of the string. Superscripts and subscripts are an exception because they only modify the next character or the text within the curly braces {}.

    |        Modifier        |           Description            |       Example of String       |
    |------------------------|----------------------------------|-------------------------------|
    | ^{ }                   | Superscript                      | 'text^{superscript}'          |
    | _{ }                   | Subscript                        | 'text_{subscript}'            |
    | \bf                    | Bold font                        | '\bf text'                    |
    | \it                    | Italic font                      | '\it text'                    |
    | \sl                    | Oblique font                     | '\sl text'                    |
    | \rm                    | Normal font                      | '\rm text'                    |
    | \fontname{specifier}   | Font name — font family.         | '\fontname{Courier} text'     |
    | \fontsize{specifier}   | Font size                        | '\fontsize{15} text'          |
    | \color{specifier}      | Font color                       | '\color{magenta} text'        |
    | \color[rgb]{specifier} | Custom font color — RGB triplet. | '\color[rgb]{0,0.5,0.5} text' |

Font color — Set specifer as one of these colors: red, green, yellow, magenta, blue, black, white, gray, darkGreen, orange, or lightBlue.

This table lists the supported special characters with the Interpreter property set to 'tex'.

    |     Sequence    | Symbol |   Sequence  | Symbol |  Sequence  | Symbol |
    |-----------------|--------|-------------|--------|------------|--------|
    | \alpha          | α      | \Sigma      | Σ      | \aleph     | ℵ      |
    | \upsilon        | υ      | \rightarrow | →      | \Im        | ℑ      |
    | \sim            | ~      | \kappa      | κ      | \cup       | ∪      |
    | \angle          | ∠      | \Upsilon    | ϒ      | \wp        | ℘      |
    | \phi            | Φ      | \Rightarrow | ⇒      | \otimes    | ⊗      |
    | \leq            | ≤      | \lambda     | λ      | \subseteq  | ⊆      |
    | \ast            | *      | \Phi        | Φ      | \oslash    | ∅      |
    | \chi            | χ      | \downarrow  | ↓      | \cap       | ∩      |
    | \infty          | ∞      | \mu         | µ      | \in        | ∈      |
    | \beta           | β      | \Psi        | Ψ      | \supseteq  | ⊇      |
    | \psi            | ψ      | \circ       | º      | \supset    | ⊃      |
    | \clubsuit       | ♣      | \nu         | ν      | \lceil     | ⌈      |
    | \gamma          | γ      | \Omega      | Ω      | \subset    | ⊂      |
    | \omega          | ω      | \pm         | ±      | \int       | ∫      |
    | \diamondsuit    | ♦      | \xi         | ξ      | \cdot      | ·      |
    | \delta          | δ      | \forall     | ∀      | \o         | ο      |
    | \Gamma          | Γ      | \geq        | ≥      | \rfloor    | ⌋      |
    | \heartsuit      | ♥      | \pi         | π      | \neg       | ¬      |
    | \epsilon        | ɛ      | \exists     | ∃      | \nabla     | ∇      |
    | \Delta          | Δ      | \propto     | ∝      | \lfloor    | ⌊      |
    | \spadesuit      | ♠      | \rho        | ρ      | \times     | x      |
    | \zeta           | ζ      | \ni         | ∍      | \ldots     | ...    |
    | \Theta          | Θ      | \partial    | ∂      | \perp      | ⊥      |
    | \leftrightarrow | ↔      | \sigma      | σ      | \surd      | √      |
    | \eta            | η      | \cong       | ≅      | \prime     | ´      |
    | \Lambda         | Λ      | \bullet     | •      | \wedge     | ∧      |
    | \leftarrow      | ←      | \varsigma   | ς      | \varpi     | ϖ      |
    | \theta          | Θ      | \approx     | ≈      | \0         | ∅      |
    | \Xi             | Ξ      | \div        | ÷      | \rceil     | ⌉      |
    | \Leftarrow      | ⇐      | \tau        | τ      | \rangle    | 〉     |
    | \vartheta       | ϑ      | \Re         | ℜ      | \mid       | |      |
    | \Pi             | Π      | \neq        | ≠      | \vee       | ∨      |
    | \uparrow        | ↑      | \equiv      | ≡      | \langle    | 〈     |
    | \iota           | ι      | \oplus      | ⊕      | \copyright | ©      |

### ===🗝 Coordinate System

Coordinate System
Modify axis limits and tick values, add grid lines, combine multiple plots

- *xlim*    Set or query x-axis limits
- *ylim*    Set or query y-axis limits
- *zlim*    Set or query z-axis limits
- *axis*    Set axis limits and appearance
- *box* Display axes outline
- *grid*    Display or hide axes grid lines
- *daspect* Control data unit length along each axis
- *pbaspect*    Control relative lengths of each axis
- *datetick*    Date formatted tick labels

- *hold*    Retain current plot when adding new plots
- *subplot* Create axes in tiled positions
- *axes*    Create axes graphics object
- *figure*  Create figure window

- *gca* Current axes handle
- *cla* Clear axes

Properties

- *Axes* Properties Control axes appearance and behavior


```matlab
%% Change Axis Limits of Graph
% Create Simple Line Plot
x = linspace(-10, 10, 200);
y = sin(4*x)./exp(x);
plot(x,y)
pause(1)
% Change Axis Limits
axis([0,10, -1,1]) %xlim(0,10), ylim(-1,1)
pause(1)
% Use Semiautomatic Axis Limits
axis([-inf,10,-1,1])

%% Change Axis Tick Value Locations and Labels
x = randn(100) - 0.5;
y = cos(x);
plot(x,y);
pause(1);
% set current axes handle
ax = gca;
ax.XTick = [-3*pi -2*pi -pi 0 pi 2*pi 3*pi];
ax.YTick = [-1 -0.5  0 0.5 1];
% For R2014a and earlier: set(ax,'YTick',[...])
pause(1)
ax.XTickLabel={'-3\pi','-2\pi','-\pi','0','\pi','2\pi','3\pi'};
ax.YTickLabel={'min = -1' '-0.5' '0.0' '0.5' 'max = 1'};
pause(1)
ax.XTickLabelRotation = 45;
ax.YTickLabelRotation = 45;
pause(1)
% Display Axis Lines Through Origin
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
% Turn off the display of the axes outline by setting the Box property.
ax.Box = 'off';

% Change Exponent Value for y-Axis Tick Labels
ax.YAxis.ExponentMode = 2;
ax.YAxis.ExponentMode = 0;
ax.YAxis.ExponentMode = 'auto';

% Display Grid Lines on 2-D Graph
grid on
grid off
ax.XGrid = 'on';
ax.YGrid = 'off';
ax.XMinorGrid = 'on';
ax.YMinorGrid = 'off';
ax.GridLineStyle = '-';
ax.MinorGridLineStyle = ':';
```

Display Text Outside Axes

```matlab
% Create an invisible axes, ax1, 
% that encompasses the entire figure window by specifying its position as [0,0,1,1]. 
% Then, create a smaller axes, ax2, to contain the actual plot. Create a line plot 
% in the smaller axes by passing its axes handle, ax2, to the plot function.

fig = figure;
ax1 = axes('Position',[0 0 1 1],'Visible','off');
ax2 = axes('Position',[.3 .1 .6 .8]);

t = 0:1000;
y = 0.25*exp(-0.005*t);
plot(ax2,t,y)

descr = {'Plot of the function:';
    'y = A{\ite}^{-\alpha{\itt}}';
    ' ';
    'With the values:';
    'A = 0.25';
    '\alpha = .005';
    't = 0:1000'};

axes(ax1) % sets ax1 to current axes
text(.025,0.6,descr)
```

Graph with Multiple x-Axes and y-Axes

```matlab
%% Graph with Multiple x-Axes and y-Axes
x1 = 0:0.1:40;
y1 = 4.*cos(x1)./(x1+2);
x2 = 1:0.2:20;
y2 = x2.^2./x2.^3;

figure;
line(x1,y1, 'Color','r')
ax1 = gca; % current axes
ax1.XColor = 'r';
ax1.YColor = 'r';

pos = ax1.Position; % position of first axes
ax2 = axes('Position', pos,...
    'XAxisLocation', 'top',...
    'YAxisLocation', 'right',...
    'Color', 'none');
line(x2,y2,'Parent',ax2,'Color','k');

```



### ===🗝 Animation

Animating plots

- *movie*   Play recorded movie frames
- *getframe*    Capture axes or figure as movie frame
- *frame2im*    Return image data associated with movie frame
- *im2frame*    Convert image to movie frame

- *animatedline*    Create animated line
- *comet*   2-D comet plot
- *comet3*  3-D comet plot

- *drawnow* Update figures and process callbacks
- *refreshdata* Refresh data in graph when data source is specified

Using Objects

- Animated Line   Line animations

利用 plot函数返回的Line对象，通过向修改对象的XData,YData,ZData等属性，然后利用pause暂停画面，即可实现动态图片。

利用 *getframe* 函数捕获当前图表，并且使用 *frame2im* -> *rgb2ind* 转换成索引色图像，写入 gif 文件：

```matlab
% 画椭圆 x*x/4 + y*y/3 = 1 的切线
a = 12*cos(0:2*acos(1/3):200*pi)+9i*sin(0:2*acos(1/3):200*pi);
figure();
h = plot(a(1));
axis equal
axis([-12,12,-9,9]);
[A,map] = rgb2ind(frame2im(getframe),256);
imwrite(A,map,'1.gif','LoopCount',65535,'DelayTime',0.1);
for ii = 1:length(a)
    h.XData(ii) = real(a(ii));
    h.YData(ii) = imag(a(ii));
    [A,map] = rgb2ind(frame2im(getframe),256);
    imwrite(A,map,'1.gif','WriteMode','append','DelayTime',0.1);
    % pause(0.2)
end
```

使用 VideoWritr 导出动画视频：

```matlab
%% Record Frames and Play Movie
% Use the getframe function in a loop to record frames of the peaks 
% function vibrating. Preallocate an array to store the movie frames.
% To play the movie two times, use movie(F,2).
figure
Z = peaks;
surf(Z)
axis tight manual
ax = gca;
ax.NextPlot = 'replaceChildren';

loops = 40;
F(loops) = struct('cdata',[],'colormap',[]);
for j = 1:loops
    X = sin(j*pi/10)*Z;
    surf(X,Z)
    drawnow
    F(j) = getframe;
end

%% VideoWriter to create video files from frames.
v = VideoWriter('ani.mj2', 'Motion JPEG 2000');
v = VideoWriter('ani.mp4', 'MPEG-4');
% v.CompressionRatio = 3; % Motion JPEG 2000 only
v.VideoCompressionMethod; % This property is read only.
v.FrameRate = 12;
open(v);
writeVideo(v, F);
close(v);
winopen 'ani.mp4';
```

更多动画示范：

```matlab
%% Trace Marker Along Line
x = linspace(0,10,1000);
y = sin(x);
plot(x,y)
hold on
p = plot(x(1),y(1),'o','MarkerFaceColor','red');
hold off
axis manual

% Move the marker by updating the XData and YData properties
for i = 2:length(x)
    p.XData = x(i);
    p.YData = y(i);
    drawnow
end

%% Move Group of Objects Along Line
x = linspace(-6,6,1000);
y = sin(x);
plot(x,y);
axis manual

% Create a transform object and set its parent to the current axes. 
ax = gca
h = hgtransform('Parent', ax);
hold on
plot(x(1),y(1), 'o', 'Parent',h);
hold off
t = text(x(1)-1.5, y(1)-0.1, ['y = ' num2str(y(1))], 'Parent',h,...
    'VerticalAlignment','top', 'FontSize',14);

% Moving by updating the Matrix property of the transform object. 
for i = 2:length(x)
    m = makehgtform('translate',x(i)-x(1),y(i)-y(1),0);
    h.Matrix = m;
    t.String = ['y = ' num2str(y(i))];
    drawnow
end

%% Animate Graphics Object
theta = linspace(-pi,pi);
xc = cos(theta);
yc = -sin(theta);
plot(xc,yc);
axis equal

xt = [-1 0 1];
yt = [ 0 0 0 ];
hold on
% area(X,Y) For vectors X and Y, area(X,Y) is the same as plot(X,Y) 
% except that the area between 0 and Y is filled.
t = area(xt,yt);
hold off
for j = 1:length(theta)-10
    xt(2) = xc(j); % determine new vertex value
    yt(2) = yc(j);
    t.XData = xt; % update data properties
    t.YData = yt;
    drawnow limitrate % display updates
end

%% Create Animated Lines and Add Points
a1 = animatedline('Color',[0 .7 .7]);
a2 = animatedline('Color',[0 .5 .5]);

axis([0 20 -1 1])
x = linspace(0,20,10000);
for k = 1:length(x);
    xk = x(k);
    
    % first line
    ysin = sin(xk);
    addpoints(a1,xk,ysin);
    
    % second line
    ycos = cos(xk);
    addpoints(a2,xk,ycos);
    
    % update screen
    drawnow limitrate
end
% Query Points of Line
[x,y] = getpoints(a1);
```

模拟粒子动画，利用 wind.mat 提供的北美地区的空气对流 3-D 数据，除了 (x,y,z) 位置信息，还有 (u,v,w) 速度向量场，结合流线函数模拟粒子运动。load wind 命令加载后，可以在 Workspace 查看到变量信息，也可以使用 *whos* 命令查询。

- The data consists of (x,y,z) position components and (u,v,w) velocity components.
- File Size: 142 KB
- Data Size: Six matrices of size 35-by-41-by-15

```matlab
>> whos
  Name         Size                Bytes  Class                             Attributes

  u           35x41x15            172200  double                                      
  v           35x41x15            172200  double                                      
  w           35x41x15            172200  double                                      
  x           35x41x15            172200  double                                      
  y           35x41x15            172200  double                                      
  z           35x41x15            172200  double
  ```

```matlab
%% Creating Stream Particle Animations

% 1. Specify Starting Points of the Data Range
load wind
[sx, sy, sz] = meshgrid(100,20:2:50,5);

% 2. Create Stream Lines to Indicate Particle Paths
verts = stream3(x,y,z,u,v,w,sx,sy,sz);
sl = streamline(verts);

% 3. Define the View
% view(az,el) and view([az,el]) 
% set the viewing angle for a three-dimensional plot. 
% The azimuth, az, is the horizontal rotation about the z-axis 
% as measured in degrees from the negative y-axis. 
% Positive values indicate counterclockwise rotation of the viewpoint. 
% el is the vertical elevation of the viewpoint in degrees. 
% Positive values of elevation correspond to moving above the object; 
% negative values correspond to moving below the object.
view(-10.5,25)
daspect([2 2 0.125]) % data aspect ratio
axis tight;
set(gca,'BoxStyle','full','Box','on')

% 4. Calculate the Stream Particle Vertices
iverts = interpstreamspeed(x,y,z,u,v,w,verts,0.03);
set(gca,'SortMethod','childorder');
streamparticles(iverts,15,...
    'Animate',10,...
    'ParticleAlignment','on',...
    'MarkerEdgeColor','none',...
    'MarkerFaceColor','red',...
    'Marker','o');
```

Determine the vertices along the stream line where a particle will be drawn. The interpstreamspeed function returns this data based on the stream line vertices and the speed of the vector data. This example scales the velocities by 0.05 to increase the number of interpolated vertices.

Set the axes SortMethod property to childorder so the animation runs faster.

The streamparticles function sets the following properties:

- *Animate* The number of times to animate the stream particles. The default is 0, which does not animate. Inf animates until you enter Ctrl+C.
- *ParticleAlignment* to on to start all particle traces together.
- *MarkerEdgeColor* to none to draw only the face of the circular marker. Animations usually run faster when marker edges are not drawn.
- *MarkerFaceColor* to red.
- *Marker* to o, which draws a circular marker. You can use other line markers as well.




### ===🗝 Lighting and Transparency
- https://www.mathworks.com/help/matlab/creating_plots/changing-transparency-of-images-patches-or-surfaces.html


Light sources and object transparency

- *camlight*    Create or move light object in camera coordinates
- *light*   Create light object
- *lightangle*  Create or position light object in spherical coordinates
- *lighting*    Specify lighting algorithm
- *diffuse* Calculate diffuse reflectance
- *material*    Control reflectance properties of surfaces and patches
- *specular*    Calculate specular reflectance
- *alim*    Set or query axes alpha limits
- *alpha*   Add transparency to objects in axes
- *alphamap*    Specify figure alphamap (transparency)


```matlab
%% Transparency for Individual Images
earth = imread('landOcean.jpg');
image(earth)    
axis image % scale 1:1
clouds = imread('cloudCombined.jpg');
pause(2)

hold on
im = image(clouds);
im.AlphaData = min(earth,[],3);    
hold off

%% Transparency with Texture Mapping
[px,py,pz] = sphere(50);

sEarth = surface(py, px ,flip(pz));
sEarth.FaceColor = 'texturemap';
sEarth.EdgeColor = 'none';
sEarth.CData = earth;

hold on
sCloud = surface(px*1.02,py*1.02,flip(pz)*1.02); 
sCloud.FaceColor = 'texturemap'; 
sCloud.EdgeColor = 'none';
sCloud.CData = clouds;
sCloud.FaceAlpha = 'texturemap';
sCloud.AlphaData = max(clouds,[],3);
hold off

view([80 2]) 
daspect([1 1 1])
axis off tight
```


### ===🗝 Images

Image
JPEG, TIFF, PNG, and other formats

Read, write, display, and modify images

MATLAB® images are arrays of numeric data on which you can perform analysis. For more information, see Working with Images in MATLAB Graphics.


Functions

- Display Image
- *imshow*  Display image
- *image*   Display image from array
- *imagesc* Display image with scaled colors
- Read and Write Image
- *imread*  Read image from graphics file
- *imwrite* Write image to graphics file
- *imfinfo* Information about graphics file
- *imformats*   Manage image file format registry
- Convert Image Type
- *frame2im*    Return image data associated with movie frame
- *im2frame*    Convert image to movie frame
- *im2java* Convert image to Java image
- *im2double*   Convert image to double precision
- *ind2rgb* Convert indexed image to RGB image
- *rgb2gray*    Convert RGB image or colormap to grayscale
- *rgb2ind* Convert RGB image to indexed image
- Modify Image Colors
- *imapprox*    Approximate indexed image by reducing number of colors
- *dither*  Convert image, increasing apparent color resolution by dithering
- *cmpermute*   Rearrange colors in colormap
- *cmunique*    Eliminate duplicate colors in colormap; convert grayscale or truecolor image to indexed image

Classes

- *Tiff*    MATLAB Gateway to LibTIFF library routines


Properties

- Image Properties    Control image appearance and behavior

Starting in R2014b, you can use dot notation to query and set properties.


MATLAB 支持三种数值表达图像：

- *double* double-precision floating-point
- *uint16* 16-bit unsigned integer
- *uint8* 8-bit unsigned integer

默认使用的是 double 数据，但是这种数据占用内存较大，每个像素至少就是 8-bytes (64-bit)。使用 uint8 或 uint16 就减少到 1/8 或者 1/4 的内存用量。

Bit Depth (bits per pixel) 是像素大小的单位，根据图像格式的压缩算法有所差异，*imread* 会根据格式返回不同的数据类型：

|      Bit Depth in File      |               Class of Array Returned by imread                |
|-----------------------------|----------------------------------------------------------------|
| 1 bit per pixel             | logical                                                        |
| 2 to 8 bits per color plane | uint8                                                          |
| 9 to 16 bits per pixel      | uint16 (BMP, JPEG, PNG, and TIFF)                              |
|                             | For the 16-bit BMP packed format (5-6-5), MATLAB returns uint8 |

一般的图形编码格式有以下三种：

- Indexed Images 索引色模式；
- Intensity Images 灰度模式；
- RGB (Truecolor) Images 真彩色模式；


灰度模式下，每个像素只需要一个数值表示灰度。显示命令使用 *imagesc* Display image with scaled colors。function, which enables you to set the range of intensity values. imagesc scales the image data to use the full colormap. Use the two-input form of imagesc to display an intensity image, for example:

imagesc(I,[0 1]); colormap(gray);

当图像模式处于索引色模式时，像素数据保存的是一个索引值，通过它来查找色板中颜色。比如，调色板中记录了 256 种真彩色，像素中的索引值就只需要 8-bit 来索引这些颜色，调板颜色越少就越节省空间。*imread* 和 *imshow* 都可以正确处理，在读取时可以使用两个变量保存像素中的索引值，和调色板数据：

|    Image Type   |         Display Commands         | Uses Colormap Colors |
|-----------------|----------------------------------|----------------------|
| Indexed         | image(X); colormap(map)          | Yes                  |
| Intensity       | imagesc(I,[0 1]); colormap(gray) | Yes                  |
| RGB (truecolor) | image(RGB)                       | No                   |

一般真彩图像的像素数据是 3-D 数组，如果是索引数据则是 2-D 数组，大小分别表示为 height-by-width-by-3 和 height-by-width，如果有 Alpha 通道就是 height-by-width-by-4，即 RGBA。

真彩色图像每个像素都有不同的颜色分量，有 RGB 也有 RGBA。在图像文件中，RGB 三个分量是连续保存的，称为 RGB triplet。Matlab 读取时，会自动将各个分量提取到数组的同一个维度中保存，这就是为何图像数据显示维度一般为 height-by-width-by-3。

通过构造 CData 像素数据生成图片，有两种模式：

- 3-D array of RGB triplets 模式，像素数据为三维数组 Height-by-Width-by-3，RGB 分量分拆在三个平面上，CData 数据类型决定像素如何解析：
    - CData 数据类型为 *double*，那么 RGB triplet [0 0 0] [1 1 1] 分别对应黑色和白色。
    - CData 数据类型为整数，如 *uint8*，那么 [0 0 0] [255 255 255] 分别对应黑色和白色。如 CData 为 *int8* 那么 [-128 -128 -128] [127 127 127] 分别对应黑色和白色。
    - CData 数据类型为 *logical*，那么 [0 0 0] [1 1 1] 分别对应黑色和白色。
- Vector 或者 Matrix 数据模式，这种模式下，像素数据是色彩索引值，需要设置 *CDataMapping* 属性来决定数据用法，对 3-D Array 数据模式无效。
    - ➡ 'direct' 为默认的映射方法：
        - 数据值解释为当前颜色映射中的索引值，如果是浮点数据就截断小数部分取整。
        - 数据指定的索引值超出调色板的颜色索引值时，会自动修正为第一个或最后一个颜色索引。
        - 如果数据是 *logical* 类型，那么就将 0、1 两个值分别映射到第一个、第二个颜色
    - ➡ 'scaled' 映射方式，相当 *imagesc* 函数，会将数据值伸缩到坐标轴 *CLim* 属性限定的 [min max] 值之中，默认范围 [0 1]，会根据像素数据值调整。


```matlab
% 构造 RGB 数据，R 分量为随机值，G、B 设置为零值。
C = cat(3, rand(8), zeros(8), zeros(8))
image(C)

% 8x8 uint8 matrix
M = ones(8,'uint8');
M(3:6, 3:6) = rand * 5 + 3;
M(4:5, 4:5) = 10;
im = image(M);
C = im.CData
im.CDataMapping = 'scaled';
colorbar % show colormap

% make six gray scales colormap, and set current one
map = [0 0 0; .2 .2 .2; .4 .4 .4; .7 .7 .7; .9 .9 .9; 1 1 1];
colormap(map)
```

图像通道分离：

```matlab
img = 'peppers.png';
I = imread(img);
O = zeros(size(I(:,:,3)));
R = I(:,:,1);
G = I(:,:,2);
B = I(:,:,3);
image(cat(3, R, O, O))
t = text(50, 50, 'R Channel')
pause(1)
delete t;
image(cat(3, O, G, O))
t = text(50, 50, 'G Channel')
pause(1)
delete t;
image(cat(3, O, O, B))
t = text(50, 50, 'B Channel')
pause(1)
delete t;
```


使用内置的 corn.tif 索引模式图像：

```matlab
%% View the indexed version of the image.
[corn_indexed,map] = imread('corn.tif',1);
if ~isempty(map)
    corn_rgb = ind2rgb(corn_indexed,map);
end
imshow(map)
imshow(corn_indexed, map)
%% View the RGB version of the image.
corn_rgb = imread('corn.tif',2);
imshow(corn_rgb)
%% View the grayscale version of the image.
corn_gray = imread('corn.tif',3);
imshow(corn_gray)
```

查询图像信息 BitDepth 24 表示 RGB 色，3 Bytes/Pixel：

```matlab
info = imfinfo('ngc6543a.jpg')
info = 
           Filename: 'C:\Matlab R2015b\toolbox\matlab\demos\ngc6543a.jpg'
        FileModDate: '01-Oct-1996 16:19:44'
           FileSize: 27387
             Format: 'jpg'
      FormatVersion: ''
              Width: 600
             Height: 650
           BitDepth: 24
          ColorType: 'truecolor'
    FormatSignature: ''
    NumberOfSamples: 3
       CodingMethod: 'Huffman'
      CodingProcess: 'Sequential'
            Comment: {[1x69 char]}
```



## ==⚡ Mathematics

Mathematics

Linear algebra, basic statistics, differentiation and integrals, Fourier transforms, and other mathematics
Math functions provide a range of numerical computation methods for analyzing data, developing algorithms, and creating models. Core functions use processor-optimized libraries for fast vector and matrix calculations.

- Elementary Math ➡ *Trigonometry, exponentials and logarithms, complex values, rounding, remainders, descriptive statistics, discrete math, coordinate system conversion
- Linear Algebra ➡ *Matrix analysis, linear equations, eigenvalues, singular values, logarithms, exponentials, factorization
- Random Number Generation ➡ *Seeds, distributions, algorithms
- Interpolation ➡ *Data interpolation, data gridding, polynomial evaluation, nearest point search
- Optimization ➡ *Minimum of single and multivariable functions, nonnegative least-squares constraint problems
- Numerical Integration and Differential Equations ➡ *Numerical integration, ordinary differential equations, partial differential equations, boundary value problems
- Fourier Analysis and Filtering ➡ *Fourier transforms, convolution, digital filtering
- Sparse Matrices ➡ *Elementary sparse matrices, reordering algorithms, iterative methods
- Graph and Network Algorithms ➡ *Directed and undirected graphs, network analysis
- Computational Geometry ➡ *Triangulation, bounding regions, Voronoi diagrams*


### ===🗝 Elementary Math

基础数学内容包括：

Trigonometry, exponentials and logarithms, complex values, rounding, remainders, descriptive statistics, discrete math, coordinate system conversion

- Arithmetic ➡ *Addition, subtraction, multiplication, division, power, rounding
- Trigonometry ➡ *Sine, cosine, and related functions, with results in radians or degrees
- Exponents and Logarithms ➡ *Exponential, logarithm, power, and root functions
- Descriptive Statistics ➡ *Range, central tendency, standard deviation, variance, correlation
- Complex Numbers ➡ *Real and imaginary components, phase angles
- Discrete Math ➡ *Prime factors, factorials, permutations, rational fractions, least common multiple, greatest common divisor
- Polynomials ➡ *Curve fitting, roots, partial fraction expansions
- Special Functions ➡ *Bessel, Legendre, elliptic, error, gamma, and other functions
- Cartesian Coordinate System Conversion ➡ *Cartesian, polar, and spherical coordinates
- Constants and Test Matrices ➡ *Pi, Not-a-Number, infinity; Hadamard, Companion, Pascal, and other specialized matrices*

Complex Numbers
Real and imaginary components, phase angles

- *abs* Absolute value and complex magnitude
- *angle*   Phase angle
- *complex* Create complex array
- *conj*    Complex conjugate
- *cplxpair*    Sort complex numbers into complex conjugate pairs
- *i*   Imaginary unit
- *imag*    Imaginary part of complex number
- *isreal*  Determine whether array is real
- *j*   Imaginary unit
- *real*    Real part of complex number
- *sign*    Sign function (signum function)
- *unwrap*  Correct phase angles to produce smoother phase plots


Cartesian Coordinate System Conversion

Cartesian, polar, and spherical coordinates

- *cart2pol*    Transform Cartesian coordinates to polar or cylindrical
- *cart2sph*    Transform Cartesian coordinates to spherical
- *pol2cart*    Transform polar or cylindrical coordinates to Cartesian
- *sph2cart*    Transform spherical coordinates to Cartesian

Constants and Test Matrices

Pi, Not-a-Number, infinity; Hadamard, Companion, Pascal, and other specialized matrices

- *eps* Floating-point relative accuracy
- *flintmax*    Largest consecutive integer in floating-point format
- *i*   Imaginary unit
- *j*   Imaginary unit
- *Inf* Infinity
- *pi*  Ratio of circle's circumference to its diameter
- *NaN* Not-a-Number
- *isfinite*    Array elements that are finite
- *isinf*   Array elements that are infinite
- *isnan*   Array elements that are NaN
- *compan*  Companion matrix
- *gallery* Test matrices
- *hadamard*    Hadamard matrix
- *hankel*  Hankel matrix
- *hilb*    Hilbert matrix
- *invhilb* Inverse of Hilbert matrix
- *magic*   Magic square
- *pascal*  Pascal matrix
- *rosser*  Classic symmetric eigenvalue test problem
- *toeplitz*    Toeplitz matrix
- *vander*  Vandermonde matrix
- *wilkinson*   Wilkinson's eigenvalue test matrix


Elementary Mathematical Functions
MATLAB has a very large library of built-in functions for mathematical and scientific
computations. Here is a summary of some relevant functions.

A. Trigonometric

| Symbol |             Meaning             | Symbol |            Meaning             |
|--------|---------------------------------|--------|--------------------------------|
| sin    | - Sine                          | sec    | - Secant                       |
| sinh   | - Hyperbolic sine               | sech   | - Hyperbolic secant            |
| asin   | - Inverse sine                  | asec   | - Inverse secant               |
| asinh  | - Inverse hyperbolic sine       | asech  | - Inverse hyperbolic secant    |
| cos    | - Cosine                        | csc    | - Cosecant                     |
| cosh   | - Hyperbolic cosine             | csch   | - Hyperbolic cosecant          |
| acos   | - Inverse cosine                | acsc   | - Inverse cosecant             |
| acosh  | - Inverse hyperbolic cosine     | acsch  | - Inverse hyperbolic cosecant  |
| tan    | - Tangent                       | cot    | - Cotangent                    |
| tanh   | - Hyperbolic tangent            | coth   | - Hyperbolic cotangent         |
| atan   | - Inverse tangent               | acot   | - Inverse cotangent            |
| atan2  | - Four quadrant inverse tangent | acoth  | - Inverse hyperbolic cotangent |
| atanh  | - Inverse hyperbolic tangent    |        |                                |

B. Exponential

|  Symbol  |                       Meaning                        |
|----------|------------------------------------------------------|
| exp      | - Exponential                                        |
| log      | - Natural logarithm                                  |
| log10    | - Common (base 10)                                   |
| log2     | - Base 2 logarithm and dissect floating point number |
| pow2     | - Base 2 power and scale floating point number       |
| sqrt     | - Square root                                        |
| nextpow2 | - Next higher power of 2                             |

C. Additional Math Functions

|    Symbol   |                  Meaning                  |
|-------------|-------------------------------------------|
| square(x)   | - Generate a square wave with period 2π   |
| sawtooth(x) | - Generate a sawtooth wave with period 2π |
| sign(x)     | - Signum function of x                    |
| rem(x,y)    | - Remainder when x is divided by y        |
| sinc(x)     | - sin(πx)/ πx                             |
| erf(x)      | - Error function of x                     |
| erfc(x)     | - Complementary error function of x       |
| erfinv(x)   | - Inverse Error function of x             |


### ===🗝 Linear Algebra

Linear Algebra
Matrix analysis, linear equations, eigenvalues, singular values, logarithms, exponentials, factorization

- Matrix Operations ➡ *Cross and dot products, transpose
- Linear Equations ➡ *Solve linear systems, least squares
- Matrix Decomposition ➡ *Cholesky, LU, and QR factorizations, diagonal forms, singular value decomposition
- Eigenvalues and Singular Values ➡ *Eigenvalues, eigenvectors, Schur decomposition, Hessenburg matrices, etc.
- Matrix Analysis ➡ *Norm, rank, determinant, condition, structure
- Matrix Functions ➡ *Logarithms, exponentials, roots, other functions*

Linear Equations
Solve linear systems, least squares

- *cond*    Condition number with respect to inversion
- *condest* 1-norm condition number estimate
- *inv* Matrix inverse
- *linsolve*    Solve linear system of equations
- *lscov*   Least-squares solution in presence of known covariance
- *lsqnonneg*   Solve nonnegative least-squares constraints problem
- *pinv*    Moore-Penrose pseudoinverse of matrix
- *rcond*   Reciprocal condition number
- *sylvester*   Solve Sylvester equation AX + XB = C for X
- *mldivide*    Solve systems of linear equations Ax = B for x
- *mrdivide*    Solve systems of linear equations xA = B for x

线性方程组 Systems of Linear Equations

- ➡ Computational Considerations
- ➡ General Solution
- ➡ Square Systems
- ➡ Overdetermined Systems
- ➡ Underdetermined Systems
- ➡ Using Multithreaded Computation with Systems of Linear Equations
- ➡ Iterative Methods for Solving Systems of Linear Equations

➡ Computational Considerations

One of the most important problems in technical computing is the solution of systems of simultaneous linear equations.

In matrix notation, the general problem takes the following form: Given two matrices A and b, does there exist a unique matrix x, so that Ax = b or xA = b?

It is instructive to consider a 1-by-1 example. For example, does the equation

    7x = 21

have a unique solution?

The answer, of course, is yes. The equation has the unique solution x = 3. The solution is easily obtained by division:

    x = 21/7 = 3.

The solution is not ordinarily obtained by computing the inverse of 7, that is 7–1 = 0.142857..., and then multiplying 7–1 by 21. This would be more work and, if 7–1 is represented to a finite number of digits, less accurate. Similar considerations apply to sets of linear equations with more than one unknown; the MATLAB® software solves such equations without computing the inverse of the matrix.

解通常不是计算 7 的倒数，即 7^–1 = 0.142857...，然后乘以 21 获得的。这将是更多的工作，有限数位数也不太准确。类似的考虑适用于具有多个未知数的线性方程组，MATLAB 无需计算矩阵的逆即可求解此类方程。

Although it is not standard mathematical notation, MATLAB uses the division terminology familiar in the scalar case to describe the solution of a general system of simultaneous equations. The two division symbols, slash, /, and backslash, \, correspond to the two MATLAB functions mrdivide and mldivide. mrdivide and mldivide are used for the two situations where the unknown matrix appears on the left or right of the coefficient matrix:

    x = b/A Denotes the solution to the matrix equation xA = b.

    x = A\b Denotes the solution to the matrix equation Ax = b.

Think of "dividing" both sides of the equation Ax = b or xA = b by A. The coefficient matrix A is always in the "denominator."

The dimension compatibility conditions for x = A\b require the two matrices A and b to have the same number of rows. The solution x then has the same number of columns as b and its row dimension is equal to the column dimension of A. For x = b/A, the roles of rows and columns are interchanged.

In practice, linear equations of the form Ax = b occur more frequently than those of the form xA = b. Consequently, the backslash is used far more frequently than the slash. The remainder of this section concentrates on the backslash operator; the corresponding properties of the slash operator can be inferred from the identity:

    (b/A)' = (A'\b').

The coefficient matrix A need not be square. If A is m-by-n, there are three cases:

- m = n Square system. Seek an exact solution.
- m > n Overdetermined system. Find a least-squares solution.
- m < n Underdetermined system. Find a basic solution with at most m nonzero components.

The mldivide Algorithm

The mldivide operator employs different solvers to handle different kinds of coefficient matrices. The various cases are diagnosed automatically by examining the coefficient matrix. For more information, see the "Algorithms" section of the mldivide reference page.

➡ General Solution

The general solution to a system of linear equations Ax = b describes all possible solutions. You can find the general solution by:

Solving the corresponding homogeneous system Ax = 0. Do this using the null command, by typing null(A). This returns a basis for the solution space to Ax = 0. Any solution is a linear combination of basis vectors.

Finding a particular solution to the nonhomogeneous system Ax = b.

You can then write any solution to Ax = b as the sum of the particular solution to Ax = b, from step 2, plus a linear combination of the basis vectors from step 1.

The rest of this section describes how to use MATLAB to find a particular solution to Ax = b, as in step 2.

Pascal's Matrix

Pascal's triangle is a triangle formed by rows of numbers. The first row has entry 1. Each succeeding row is formed by adding adjacent entries of the previous row, substituting a 0 where there is no adjacent entry. Pascal's matrix is generated by selecting the portion of Pascal's triangle that corresponds to the specified matrix dimensions, as outlined in the graphic. The matrix outlined corresponds to the MATLAB® command pascal(4).

杨辉三角，是二项式系数在三角形中的一种几何排列。在欧洲，这个表叫做帕斯卡三角形。帕斯卡是在1654年发现这一规律的，比杨辉要迟393年，比贾宪迟600年。杨辉三角是中国古代数学的杰出研究成果之一，它把二项式系数图形化，把组合数内在的一些代数性质直观地从图形中体现出来，是一种离散型的数与形的结合。

扬辉三角以 [1] 作为第一行，[1 1] 作为第二行，后面每行的首尾都为 1，并且其它值都为前一行对应邻近两列的值求和。Pascal's Matrix 则是取左上角的数作为一个矩阵，这样每个数 I(i,j) = P(i-1, j) + P(i, j-1)。

     1     1     1
     1     2     3
     1     3     6

M = magic(n) returns an n-by-n matrix constructed from the integers 1 through n^2 with equal row and column sums. The order n must be a scalar greater than or equal to 3.

魔术矩阵：分别对矩阵行、例、对角线上的数求和都是同一个值：

```matlab
M = magic(3)
sum(M)
sum(M')'
sum(diag(M))
```

幻方算法（Magic Square）按照阶数，即行、列数的奇偶性，可分成了三类：奇数阶幻方、双偶阶幻方、单偶阶幻方。

奇数阶幻方，行列都为奇数，最经典的填法是罗伯法，填写的方法：

1. 把最小的数或 1 放在第一行正中，按以下规律排列剩下的(n×n－1)个数；
2. 每一个数放在前一个数的右上一格；
3. 如果这个数所要放的格已经超出了顶行那么就把它放在底行，仍然要放在右一列；
4. 如果这个数所要放的格已经超出了最右列那么就把它放在最左列，仍然要放在上一行；
5. 如果这个数所要放的格已经超出了顶行且超出了最右列，那么就把它放在底行且最左列；
6. 如果这个数所要放的格已经有数填入，那么就把它放在最后数字填入位置的下一行同一列的格内。

所谓双偶阶幻方就是当 n 可以被 4 整除时的偶阶幻方，即 4K 阶幻方。说明一下“互补数”定义：在 n 阶幻方中，如果两个数的和等于幻方中最大的数与 1 的和，称它们为一对互补数。

双偶数阶幻方最经典的填法是海尔法，以 8 阶幻方为例：

1. 先把数字按顺序填。然后，按 4×4 把它分割成4块（如图）
2. 每个小方阵对角线上的数字（如左上角小方阵部分），换成和它互补的数。

所谓单偶阶幻方就是当 n 不可以被 4 整除的偶阶幻方，即 4K+2 阶幻方，如 n=6，10，14……。

单偶数阶幻方最经典的填法是斯特拉兹法。以 10 阶幻方为例，这时，k=2，填写的方法是：

1. 从左到右、从上到下，把魔方阵分为 A，B，C，D 四个象限，并且都是奇数阶。用罗伯法，依次在 A，D，B，C 象限按奇数阶幻方的填法填数。
2. 在 A 象限的中间行、中间格开始，按自左向右的方向，标出 k 格。A 象限的其它行则标出最左边的 k 格。将这些格，和 C 象限相对位置上的数互换位置。
3. 在 B 象限所有行的中间格，自右向左，标出 k-1 格，将这些格，和 D 象限相对位置上的数互换位置。

注：6 阶幻方由于 k-1=0，所以不用再作 B、D 象限的数据交换。


➡ Square Systems
The most common situation involves a square coefficient matrix A and a single right side column vector b.

Nonsingular Coefficient Matrix
If the matrix A is nonsingular, the solution, x = A\b, is then the same size as b. For example:

    A = pascal(3);
    u = [3; 1; 4];
    x = A\u

    A =
         1     1     1
         1     2     3
         1     3     6
    u =
         3
         1
         4
    x =
        10
       -12
         5

以上是线性代数用于解决方程组，xA = u，最后解 x 包含 x、y、z 三个代数符号的值：

    1x + 1y + 1z = 3
    1x + 2y + 3z = 1
    1x + 3y + 6z = 4

It can be confirmed that A*x is exactly equal to u.

If A and b are square and the same size, x= A\b is also that size:

    b = magic(3);
    X = A\b

    X =
          19    -3    -1
         -17     4    13
           6     0    -6

It can be confirmed that A*x is exactly equal to b.

Both of these examples have exact, integer solutions. This is because the coefficient matrix was chosen to be pascal(3), which is a full rank matrix (nonsingular).

Singular Coefficient Matrix
A square matrix A is singular if it does not have linearly independent columns. If A is singular, the solution to Ax = b either does not exist, or is not unique. The backslash operator, A\b, issues a warning if A is nearly singular and raises an error condition if it detects exact singularity.

If A is singular and Ax = b has a solution, you can find a particular solution that is not unique, by typing

    P = pinv(A)*b

P is a pseudoinverse of A. If Ax = b does not have an exact solution, pinv(A) returns a least-squares solution.

For example:

    A = [ 1     3     7
         -1     4     4
          1    10    18 ]

is singular, as you can verify by typing

    rank(A)

    ans =

         2

Since A is not full rank, it has some singular values equal to zero.

Note:   For information about using pinv to solve systems with rectangular coefficient matrices, see Pseudoinverses.

Exact Solutions.  For b =[5;2;12], the equation Ax = b has an exact solution, given by

    pinv(A)*b

    ans =
        0.3850
       -0.1103
        0.7066

Verify that pinv(A)*b is an exact solution by typing

    A*pinv(A)*b

    ans =
        5.0000
        2.0000
   12.0000

Least-Squares Solutions.  However, if b = [3;6;0], Ax = b does not have an exact solution. In this case, pinv(A)*b returns a least-squares solution. If you type

    A*pinv(A)*b

    ans =
       -1.0000
        4.0000
        2.0000

you do not get back the original vector b.

You can determine whether Ax = b has an exact solution by finding the row reduced echelon form of the augmented matrix [A b]. To do so for this example, enter

    rref([A b])
    ans =
        1.0000         0    2.2857         0
             0    1.0000    1.5714         0
             0         0         0    1.0000

Since the bottom row contains all zeros except for the last entry, the equation does not have a solution. In this case, pinv(A) returns a least-squares solution.


### ===🗝 Matrix Rank
- Introduction to Rank of a Matrix https://www.vedantu.com/maths/matrix-rank
- Rank of a Matrix and Some Special Matrices https://byjus.com/jee/rank-of-a-matrix-and-special-matrices/

所谓相关，通俗理解就是彼此之间的共性，也可以理解为互相替代。

如果数组向量中的某一个或多个向量可以由数组内的其余向量通过加法或数乘表达，则该向量组线性相关，反之则线性无关。

矩阵的秩，Matrix Rand 就是线性无关的列的最大数量值，纵列的极大数，通常表示为 r(A)，rk(A) 或 rank A。

```matlab
rank([1 0 0; 2 0 0; 3 0 0]) % 1
rank([1 0 0; 2 0 0; 3 0 1]) % 2
rank([1 0 0; 0 1 0; 0 0 1]) % 3
```

The maximum number of its linearly independent columns (or rows ) of a matrix is called the rank of a matrix. The rank of a matrix cannot exceed the number of its rows or columns. 

If we consider a square matrix, the columns (rows) are linearly independent only if the matrix is nonsingular. In other words, the rank of any nonsingular matrix of order m is m. Rank of a matrix A is denoted by ρ(A).

The rank of a null matrix is zero. A null matrix has no non-zero rows or columns. So, there are no independent rows or columns. Hence the rank of a null matrix is zero. 

To define the rank of a matrix, we should have prior knowledge of sub-matrices and minors of a matrix. Let A be a given matrix. Matrix obtained by deleting some rows and some columns of matrix A is known as the sub-matrix of A. A matrix (Plural is matrices) is a rectangular array of numbers, symbols, or expressions, which are arranged in the form of rows and columns. Minor of the matrix is the determinant of the square matrix that is obtained by deleting one row and one column from some larger square matrix.

For the students of Class 12 studying subjects like Maths, Matrix is an important concept as it forms the base for more detailed concepts later, the topic is one of the most crucial from the perspective of the JEE main exam, and thus, it is imperative for the students to wisely learn the same.

The rank of a Matrix Definition
The rank of the matrix refers to the number of linearly independent rows or columns in the matrix. ρ(A) is used to denote the rank of matrix A.  A matrix is said to be of rank zero when all of its elements become zero. The rank of the matrix is the dimension of the vector space obtained by its columns. The rank of a matrix cannot exceed more than the number of its rows or columns. The rank of the null matrix is zero.


Nullity of a Matrix
The nullity of a matrix is defined as the number of vectors present in the null space of a given matrix. In other words, it can be defined as the dimension of the null space of matrix A called the nullity of A. Rank+Nullity is the number of all columns in matrix A.




### ===🗝 Determinant of a Matrix
- Determinant of a Matrix https://byjus.com/maths/determinant-of-a-matrix/

The determinant of a matrix is the scalar value computed for a given square matrix. Linear algebra deals with the determinant, it is computed using the elements of a square matrix. It can be considered as the scaling factor for the transformation of a matrix. Useful in solving a system of linear equation, calculating the inverse of a matrix and calculus operations.

Geometrically, the determinant is seen as the volume scaling factor of the linear transformation defined by the matrix. It is also expressed as the volume of the n-dimensional parallelepiped crossed by the column or row vectors of the matrix. The determinant is positive or negative as per the linear mapping preserves or changes the orientation of n-space.

“行列式” 这个翻译是比较让我头痛的。历史上，引入行列式目的是简化解决线性问题，是一种表达式形式，同时也是一种求值方法。Determinant of a Matrix 作为名词，同时也表示一个标量值。而让人头痛的点就是“行列式”作为一个标量的含义使用时，通常它指定的是 det(A) 解决得到的一个标量值，数学上表达为 |A|，但是把 scalar 说成“式”绝对是有点大乱套的感觉。行列值，行列数可能都比行列式这个表达更恰当。

考虑一个 3x3 的方阵 A = [a b c; o p q; x y z]，将其行列式表达按以下方式扩展：

    a b c a b c
     \ \ \
    o p q o p q
       \ \ \
    x y z x y z

从第一个 a 到 c 开始，沿反斜线方向，将斜线上的数相乘，再相加。同里，再按第二个 a 到 c 的位置，沿正斜线方向将数值相乘后求和。

最后将反斜线上的值减去正斜线上的值，结果即为 Determinant of a Matrix，也就是中文所谓的行列式：

    Δ = det(A) = apz + bqx + coy - aqy - boz - cpx

这是一种直观的操作方式，也可以按拆分的方式，使用 Minor of determinant，按 a * det([p q; y z]) - b * det([o q; x z]) + c * det([o p; x y) 这样操作。

考虑 1x1 的方形矩阵乘法，5^-1 * 5 = 1 并且 5 * 5^-1 = 1，这就是可逆矩阵的特殊例子。一个数的倒数和逆矩阵类似，但有些矩阵不可逆，det(A) = 0 就不可逆。可逆矩阵要满足等式 M * M^-1 = I 且 M^-1 * M = I，也就是可逆的情况下，一个矩阵和它的逆矩阵相乘，结果恒等。

A square matrix that is not singular, i.e., one that has a matrix inverse. Nonsingular matrices are sometimes also called regular matrices. A square matrix is nonsingular iff its determinant is nonzero (Lipschutz 1991, p. 45). For example, there are 6 nonsingular 2×2 (0,1)-matrices:

    [1 0; 0 1]   [0 1; 1 0]   [1 1; 1 0]   [1 0; 1 1]   [0 1; 1 1]   [1 1; 0 1]

例如，以下矩阵 A 就不可逆，det(A) = 0：

```matlab
A = [1 0; 0 0];
AI = inv(A); % AI = [Inf,Inf;Inf,Inf]

Warning: Matrix is singular to working precision. 
```

可逆矩阵又称为非奇异矩阵，Why are invertible matrices called 'non-singular'?

假设随机生成一个 n×n 的矩阵，绝大多数情况这个矩阵都是可逆的，也可以理解为它的行列式不为 0。不可逆的情况是少见的，不可逆矩阵就称为奇异矩阵 Singular matrix，这里的 singular means very unusual or strange, not common 的意思。

假设一个 1×1 的矩阵，我们知道只有这个矩阵等于 0 的时候才是不可逆的，其余情况都是可逆的；再看 2×2 的矩阵，这个可以理解成是一个平面上的两条线，只要当这两条线位于经过零点的同一条线上，那么这个矩阵才是不可逆的，显然这种情况是特殊的；3×3 矩阵同理不加赘述。


### ===🗝 Random Number Generation

Random Number Generation

Seeds, distributions, algorithms
Use the rand, randn, and randi functions to create sequences pseudorandom numbers. Use the rng function to control the repeatability of your results. Use the RandStream class when you need more advanced control over random number generation.

Functions

- *rand*    Uniformly distributed random numbers
- *randn*   Normally distributed random numbers
- *randi*   Uniformly distributed pseudorandom integers

- *randperm*    Random permutation

- *rng* Control random number generation

Classes

- *RandStream*  Random number stream


Control random number generation

- *rng(seed)* seeds the random number generator using the nonnegative integer seed so that *rand*, *randi*, and *randn* produce a predictable sequence of numbers.
- *rng('shuffle')* seeds the random number generator based on the current time. Thus, *rand*, *randi*, and *randn* produce a different sequence of numbers after each time you call rng.
- *rng('default')* puts the settings of the random number generator used by *rand*, *randi*, and *randn* to their default values. This way, the same random numbers are produced as if you restarted MATLAB. The default settings are the Mersenne Twister with seed 0.
- *rng(seed, generator)* and *rng('shuffle', generator)* additionally specify the type of the random number generator used by *rand*, *randi*, and *randn*. 

The generator input is one of:

- 'twister': Mersenne Twister
- 'simdTwister': SIMD-oriented Fast Mersenne Twister
- 'combRecursive': Combined Multiple Recursive
- 'multFibonacci': Multiplicative Lagged Fibonacci
- 'v5uniform': Legacy MATLAB® 5.0 uniform generator
- 'v5normal': Legacy MATLAB 5.0 normal generator
- 'v4': Legacy MATLAB 4.0 generator


随机数生成，输出向量、矩阵，多维数组等，*rand* 生成 (0，1) 的分布随机数，*randn* 生成正态分布的随机数，使用 *randperm* 生成排列组合随机数：

```matlab
%% -------------------Syntax------------------- %%

% returns a single uniformly distributed random number in the interval (0,1).
X = rand 

% returns an n-by-n matrix of random numbers.
X = rand(n) 

% returns an sz1-by-...-by-szN array of random numbers 
% where sz1,...,szN indicate the size of each dimension. 
% For example, rand(3,4) returns a 3-by-4 matrix.
X = rand(sz1,...,szN) 

% returns an array of random numbers 
% where size vector sz specifies size(X). 
% For example, rand([3 4]) returns a 3-by-4 matrix.
X = rand(sz) 

% returns an array of random numbers of data type typename. 
% The typename input can be either 'single' or 'double'.
% You can use any of the input arguments in the previous syntaxes.
X = rand(___,typename)

% returns an array of random numbers like p; 
% that is, of the same object type as p. 
% You can specify either typename or 'like', but not both.
X = rand(___,'like',p) 

%% -------------------Examples------------------- %%

%% Random Numbers Within Specified Interval
% Generate a 10-by-1 column vector of uniformly distributed numbers 
% in the interval (-5,5).
r = -5 + (5+5)*rand(10,1)

%% Random Integers
% Use the randi function to generate 5 random integers 
% from the uniform distribution between 10 and 50.
r = randi([10 50],1,5)

%% Normally distributed random numbers
r = randn(50,2)

%% Reset Random Number Generator
% Save the current state of the random number generator 
% and create a 1-by-5 vector of random numbers.
s = rng;
r = rand(1,5)
% Restore the state of the random number generator to s,
% and then create a new 1-by-5 vector of random numbers. 
% The values are the same as before.
rng(s);
r1 = rand(1,5)

%% Random Complex Numbers
% Generate a single random complex number 
% with real and imaginary parts in the interval (0,1).
a = rand(2) + i*rand(2)

%% 3-D Array of Random Numbers
% Create a 3-by-2-by-3 array of random numbers.
X = rand([3,2,3,1])

%% 3-D Array of Random Numbers
% Create a 3-by-2-by-3 array of random numbers.
X = rand([3,2,3])

% Clone Distributed Array
% If you have Parallel Computing Toolbox™, create a 1000-by-1000 distributed array 
% of random numbers with underlying data type single. For the distributed data type, 
% the 'like' syntax clones the underlying data type in addition to the primary data type.
p = rand(1000,'single','distributed');
% Create an array of random numbers that is the same size, primary data type, and underlying data type as p.
X = rand(size(p),'like',p);
```


### ===🗝 Interpolation

1-D Interpolation
Interpolation of 1-D data

- *interp1* 1-D data interpolation (table lookup)
- *griddedInterpolant*  Gridded data interpolation
- *pchip*   Piecewise Cubic Hermite Interpolating Polynomial (PCHIP)
- *spline*  Cubic spline data interpolation
- *ppval*   Evaluate piecewise polynomial
- *mkpp*    Make piecewise polynomial
- *unmkpp*  Piecewise polynomial details
- *padecoef*    Padé approximation of time delays
- *interpft*    1-D interpolation using FFT method

Gridded Data Interpolation
Interpolation of uniformly sampled data in 2-D, 3-D, N-D

- *interp2* Interpolation for 2-D gridded data in meshgrid format
- *interp3* Interpolation for 3-D gridded data in meshgrid format
- *interpn* Interpolation for 1-D, 2-D, 3-D, and N-D gridded data in ndgrid format
- *griddedInterpolant*  Gridded data interpolation
- *ndgrid*  Rectangular grid in N-D space
- *meshgrid*    Rectangular grid in 2-D and 3-D space

Scattered Data Interpolation
Interpolation of scattered data

- *griddata*    Interpolate scattered data
- *griddatan*   Data gridding and hypersurface fitting (dimension ≥ 2)
- *scatteredInterpolant*    Scattered data interpolation

### ===🗝 Optimization
### ===🗝 Numerical Integration and Differential Equations
- 微积分 Calculus https://www.cuemath.com/calculus/

微积分 Calculus，基于微分、积分两个基本概念，differentiation, integration，研究连续变化问题，微分研究函数的变化率，积分研究函数曲线下的面积问题。

微积分也称为无穷小微积分或“无穷小微积分”。无穷小数是值几乎等于零但不完全等于零的量。一般来说，经典微积分是研究函数的连续变化。

Calculus is one of the most important branches of mathematics that deals with continuous change. The two major concepts that calculus is based on are derivatives and integrals. The derivative of a function is the measure of the rate of change of a function, while integral is the measure of the area under the curve of the function. The derivative gives the explanation of the function at a specific point whereas the integral accumulates the discrete values of a function over a range of values.

Calculus is also referred to as infinitesimal calculus or “the calculus of infinitesimals”. Infinitesimal numbers are the quantities that have value nearly equal to zero, but not exactly zero. Generally, classical calculus is the study of continuous change of functions.

What is Calculus?
Calculus focuses on some important topics covered in math such as differentiation, integration, limits, functions, and so on. Calculus, a branch of mathematics, deals with the study of the rate of change, was developed by Newton and Leibniz.

Calculus Definition: Calculus in Mathematics is generally used in mathematical models to obtain optimal solutions and thus helps in understanding the changes between the values related by a function. Calculus is broadly classified into two different sections:

- Differential Calculus
- Integral Calculus

description of important calculus terms

Both differential and integral calculus serve as a foundation for the higher branch of Mathematics known as “Analysis”, dealing with the impact of a slight change in dependent variable, as it leads to zero, on the function.

Functions in calculus represent the relationship between two variables, which are the independent variable and the dependent variable.

对于函数 y = f(x)，应变量是 y，自变量是 x，它们的关系是 f 函数。

Suppose that: y = x^2

    | Value of x | Value of y |
    |------------|------------|
    |          1 |          1 |
    |          2 |          4 |
    |          9 |         81 |
    |         11 |        121 |

We can see that the value of y depends on the value of x. We can conclude that

- INPUT is independent of the OUTPUT
- OUTPUT depends on the INPUT
- Function is responsible for the transformation of the INPUT to the OUTPUT

In calculus,

- INPUT is an independent variable
- OUTPUT is a dependent variable
- Relationship is a function



### ===🗝 Fourier Analysis and Filtering

Fourier Analysis and Filtering
Fourier transforms, convolution, digital filtering

- *abs* Absolute value and complex magnitude
- *angle*   Phase angle
- *cplxpair*    Sort complex numbers into complex conjugate pairs
- *fft* Fast Fourier transform
- *fft2*    2-D fast Fourier transform
- *fftn*    N-D fast Fourier transform
- *fftshift*    Shift zero-frequency component to center of spectrum
- *fftw*    Interface to FFTW library run-time algorithm tuning control
- *ifft*    Inverse fast Fourier transform
- *ifft2*   2-D inverse fast Fourier transform
- *ifftn*   N-D inverse fast Fourier transform
- *ifftshift*   Inverse FFT shift
- *nextpow2*    Exponent of next higher power of 2
- *unwrap*  Correct phase angles to produce smoother phase plots
- *conv*    Convolution and polynomial multiplication
- *conv2*   2-D convolution
- *convn*   N-D convolution
- *deconv*  Deconvolution and polynomial division
- *detrend* Remove linear trends
- *filter*  1-D digital filter
- *filter2* 2-D digital filter



### ===🗝 Sparse Matrices
### ===🗝 Graph and Network Algorithms
### ===🗝 Computational Geometry


## ==⚡ Performance and Memory
- Resolve “Out of Memory” Errors https://www.mathworks.com/help/matlab/matlab_prog/resolving-out-of-memory-errors.html

Improve performance, reduce memory requirements

- Code Performance ➡ Measure and profile MATLAB® code to improve performance
- Memory Usage ➡ Identify and reduce memory requirements

Code Performance

Measure and profile MATLAB® code to improve performance

- *timeit*  Measure time required to run function
- *tic* Start stopwatch timer
- *toc* Read elapsed time from stopwatch
- *cputime* Elapsed CPU time
- *profile* Profile execution time for functions
- *bench*   MATLAB benchmark

Memory Usage

Identify and reduce memory requirements

- *clear*   Remove items from workspace, freeing up system memory
- *inmem*   Names of functions, MEX-files, classes in memory
- *memory*  Display memory information
- *pack*    Consolidate workspace memory
- *whos*    List variables in workspace, with sizes and types


Resolving "Out of Memory" Errors

By default, MATLAB can use up to 100% of the RAM (not including virtual memory) of your computer to allocate memory for arrays, and if an array size would exceed that threshold, then MATLAB produces an error. For example, this code attempts to create an array whose size exceeds the maximum array size limit.

    B = rand(1e6);

Requested 1000000x1000000 (7450.6GB) array exceeds maximum array size preference (63.7GB). This might cause MATLAB to become unresponsive.

double 占 8-bytes，rand(1e6) 占用内存 1000000 * 1000000 * 8 = 1e12 * 8 / 1024^3 = 7.4506e+03 GB 内存。 rand(1e8) 占用 1e16 * 8 / 1024^3 = 7.4506e+07 GB。

If you turn off the array size limit in MATLAB Workspace Preferences, attempting to create an unreasonably large array might cause MATLAB to run out of memory, or it might make MATLAB or even your computer unresponsive due to excessive memory paging (that is, moving memory pages between RAM and disk).

    B = rand(1e6);

Out of memory.

n general in the latest MATLAB releases MathWorks added the option to define a limitation on Variable size as a function of the RAM.
You can access it by going: Preferences -> Workspace

- Maximum array size
- Maximum struct/object nesting levels


**General Suggestions for Reclaiming Memory**

The MATLAB® software generates an Out of Memory message whenever it requests a segment of memory from the operating system that is larger than what is available. When you see the Out of Memory message, use any of the techniques discussed under Strategies for Efficient Use of Memory to help optimize the available memory. If the Out of Memory message still appears, you can try any of the following:

- Compress data to reduce memory fragmentation.
- If possible, break large matrices into several smaller matrices so that less memory is used at any one time.
- If possible, reduce the size of your data.
- Make sure that there are no external constraints on the memory accessible to MATLAB. (On UNIX® systems, use the limit command to check).
- Increase the size of the swap file. We recommend that you configure your system with twice as much swap space as you have RAM. See Increasing System Swap Space, below.
- Add more memory to the system.

**Setting the Process Limit**

The platforms and operating systems that MATLAB supports have different memory characteristics and limitations. In particular, the process limit is the maximum amount of virtual memory a single process (or application) can address. On 32-bit systems, this is the most important factor limiting data set size. The process limit must be large enough for MATLAB to store all of the data it is to process, any MATLAB program files, the MATLAB executable itself, and additional state information.

Where possible, choose an operating system that maximizes this number, that is, a 64-bit operating system. The following is a list of MATLAB supported operating systems and their process limits.

| Operating System                                         | Process Limit   |
| :------------------------------------------------------- | --------------- |
| 32-bit Windows® 7 and higher                             | 2 GB            |
| 32-bit Windows 7 and higher with increaseuserva set      | 3 GB            |
| 64-bit Windows or Linux® running 32-bit MATLAB           | ≤ 4 GB          |
| 64-bit Windows, Apple Mac, Linux running 64-bit MATLAB   | 8 TB            |

```matlab
memory 
[userview systemview] = memory

Maximum possible array:    2044 MB (2.144e+09 bytes) *
Memory available for all arrays:    2853 MB (2.991e+09 bytes) **
Memory used by MATLAB:     895 MB (9.386e+08 bytes)
Physical Memory (RAM):   16301 MB (1.709e+10 bytes)

*  Limited by contiguous virtual address space available.
** Limited by virtual address space available.

userview = 
    MaxPossibleArrayBytes: 2.1438e+09
    MemAvailableAllArrays: 2.9911e+09
            MemUsedMATLAB: 938594304
systemview = 
    VirtualAddressSpace: [1x1 struct]
           SystemMemory: [1x1 struct]
         PhysicalMemory: [1x1 struct]
```

When called with one output variable, the memory function returns or displays the following values. See the function reference for memory to find out how to use it with more than one output.

|  memory Return Value  |                         Description                          |
|-----------------------|--------------------------------------------------------------|
| MaxPossibleArrayBytes | Size of the largest single array MATLAB can currently create |
| MemAvailableAllArrays | Total size of the virtual address space available for data   |
| MemUsedMATLAB         | Total amount of memory used by the MATLAB process            |

**Using the 3GB Switch on Windows Systems**

Microsoft® Windows 7 systems can allocate 3 GB (instead of the default 2 GB) to processes, if you set an appropriate switch in the boot.ini file of the system. This gives an extra 1 GB of virtual memory to MATLAB, not contiguous with the rest of the memory. This enables you to store more data, but not larger arrays, as these are limited by contiguous space. This is mostly beneficial if you have enough RAM (e.g., 3 or 4 GB) to use it.

After setting the switch, confirm the new value of the virtual memory after restarting your computer and using the memory function.

```matlab
[userview systemview] = memory;

systemview.VirtualAddressSpace
ans = 
  Available: 1.6727e+009   % Virtual memory available to MATLAB.
      Total: 2.1474e+009   % Total virtual memory
```


## ==⚡ System Commands

Interact programmatically with the operating system and the MATLAB® application

- Operating System Commands
- *clipboard*   Copy and paste strings to and from system clipboard
- *computer*    Information about computer on which MATLAB software is running
- *system*  Execute operating system command and return output
- *dos* Execute DOS command and return output
- *unix*    Execute UNIX command and return output
- *getenv*  Environment variable
- *setenv*  Set environment variable
- *perl*    Call Perl script using appropriate operating system executable
- *winqueryreg* Item from Windows registry
- MATLAB Environment
- *commandhistory*  Open Command History window, or select it if already open
- *commandwindow*   Open Command Window, or select it if already open
- *filebrowser* Open Current Folder browser, or select it if already open
- *workspace*   Open Workspace browser to manage workspace
- *matlab.io.saveVariablesToScript* Save workspace variables to MATLAB script
- *getpref* Preference
- *setpref* Set preference
- *addpref* Add preference
- *rmpref*  Remove preference
- *ispref*  Test for existence of preference

computer

Information about computer on which MATLAB software is running

```matlab
% Syntax
str = computer 
% returns the string str with the computer type on which MATLAB® is running.
archstr = computer('arch') 
% returns the string archstr which is used by the mex command and standalone applications to locate MATLAB library files.
[str,maxsize] = computer 
% returns the integer maxsize, the maximum number of elements allowed in an array with this version of MATLAB.
[str,maxsize,endian] = computer 
% returns either 'L' for little-endian byte ordering or 'B' for big-endian byte ordering.
```

|  Platform | Word Size |   str   | archstr | maxsize  | endian | ispc | isunix | ismac |
|-----------|-----------|---------|---------|----------|--------|------|--------|-------|
| Windows   | 32-bit    | PCWIN   | win32   | 2^31 - 1 | L      |    1 |      0 |     0 |
|           | 64-bit    | PCWIN64 | win64   | 2^48 - 1 | L      |    1 |      0 |     0 |
|-----------|-----------|---------|---------|----------|--------|------|--------|-------|
| Linux     | 64-bit    | GLNXA64 | glnxa64 | 2^48 - 1 | L      |    0 |      1 |     0 |
| Apple Mac | 64-bit    | MACI64  | maci64  | 2^48 - 1 | L      |    0 |      1 |     1 |


## ==⚡ MATLAB Engine API for C, C++, and Fortran

MATLAB Engine API for C, C++, and Fortran
Call MATLAB® from C/C++ and Fortran programs
Engine applications are standalone C/C++ or Fortran programs that allow you to call MATLAB from your own programs, using MATLAB as a computation engine. Engine applications require an installed version of MATLAB; you cannot run the MATLAB engine on a machine that only has the MATLAB Runtime.

C and Fortran Engine Library Functions

- *engOpen* (C and Fortran) Start MATLAB engine session
- *engOpenSingleUse* (C)    Start MATLAB engine session for single, nonshared use
- *engClose* (C and Fortran)    Quit MATLAB engine session
- *Engine* (C)  Type for MATLAB engine
- *engEvalString* (C and Fortran)   Evaluate expression in string
- *engGetVariable* (C and Fortran)  Copy variable from MATLAB engine workspace
- *engPutVariable* (C and Fortran)  Put variable into MATLAB engine workspace
- *engGetVisible* (C)   Determine visibility of MATLAB engine session
- *engSetVisible* (C)   Show or hide MATLAB engine session
- *engOutputBuffer* (C and Fortran) Specify buffer for MATLAB output

Functions

- *mex* Build MEX function from C/C++ or Fortran source code

To build an engine application, you need:

- The ability to write C/C++ or Fortran source code. You can create these files with the MATLAB® Editor.
- A compiler supported by MATLAB. For an up-to-date list of supported compilers, see the Supported and Compatible Compilers website.
- C/C++ Matrix Library API or Fortran Matrix Library API functions.
- C and Fortran Engine Library functions.
- The mex build script with the -client engine option.
- To use your own build tools, see Build Engine Applications with IDE.

To run the application:

- Set Run-Time Library Path on Windows Systems
- Register MATLAB as a COM Server
- Set Run-Time Library Path on Mac and Linux Systems

MATLAB® libraries are not thread-safe. If you create multithreaded applications, make sure that only one thread accesses the engine application.

Can't Start MATLAB Engine?

If you have multiple versions of MATLAB® installed on your system, the version you use to build your engine applications must be the first listed in your system Path environment variable. Otherwise, MATLAB displays Can't start MATLAB engine.

On Windows® operating systems, you also must register MATLAB as a COM server. If you have multiple versions of MATLAB, the version you are using must be the registered version.


Build Windows Engine Application
This example shows how to verify the build process on Windows® platforms using the C example, engwindemo.c.

Start MATLAB® as a user with administrator privileges. Based on your User Account Control (UAC) settings, you might need to right-click the MATLAB icon and select Run as administrator. If that option is not available, contact your system administrator.

Register MATLAB as a COM server.

    !matlab -regserver

MATLAB displays a second, minimized command window. Close that window.

Verify your current folder is writable and copy the example.

    copyfile(fullfile(matlabroot,'extern','examples','eng_mat','engwindemo.c'),'.','f')

Build the application.

    mex -v -client engine engwindemo.c

Build Standalone Application with MinGW Compiler
If you have installed one of the professional editions of the Microsoft® Visual Studio® compiler and want to build with the MinGW compiler, use the following command to override the default Microsoft compiler.

    mex -v -client engine -f matlabroot\bin\win64\mexopts\mingw64.xml engwindemo.c

If the only compiler on your system is the MinGW compiler, your build command is:

    mex -v -client engine engwindemo.c 



## ==⚡ MATLAB COM Automation Server

Call MATLAB® from COM components and applications

Automation is a COM protocol that allows one application (the controller or client) to control objects exported by another application (the server). MATLAB supports COM Automation server capabilities on Microsoft® Windows® operating systems. Any Windows program that can be configured as an Automation controller can control MATLAB. Some examples are Microsoft Excel® and Microsoft Access™, and many Microsoft Visual Basic® and Microsoft Visual C++® programs.

If you build client application using C/C++, or Fortran, use MATLAB Engine API for C, C++, and Fortran instead of an Automation server.

- *Execute* Execute MATLAB command in Automation server
- *Feval*   Evaluate MATLAB function in Automation server

- *GetCharArray*    Character array from Automation server
- *PutCharArray*    Store character array in Automation server
- *GetFullMatrix*   Matrix from Automation server workspace
- *PutFullMatrix*   Matrix in Automation server workspace
- *GetVariable* Data from variable in Automation server workspace
- *GetWorkspaceData*    Data from Automation server workspace
- *PutWorkspaceData*    Data in Automation server workspace

- *MaximizeCommandWindow*   Open Automation server window
- *MinimizeCommandWindow*   Minimize size of Automation server window

- *Quit*    Terminate MATLAB Automation server

- *regmatlabserver* Register current MATLAB as Automation server
- *enableservice*   Enable, disable, or report status of MATLAB Automation server


Call MATLAB Function from C# Client
This example shows how to call a user-defined MATLAB® function, myfunc, from a C# application.

Create a MATLAB function, myfunc, in the folder c:\temp\example.

    function [x,y] = myfunc(a,b,c) 
    x = a + b; 
    y = sprintf('Hello %s',c); 

Create the C# application.

```C#
using System; 
using System.Collections.Generic; 
using System.Text; 

namespace ConsoleApplication2 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            // Create the MATLAB instance 
            MLApp.MLApp matlab = new MLApp.MLApp(); 

            // Change to the directory where the function is located 
            matlab.Execute(@"cd c:\temp\example"); 

            // Define the output 
            object result = null; 

            // Call the MATLAB function myfunc
            matlab.Feval("myfunc", 2, out result, 3.14, 42.0, "world"); 
             
            // Display result 
            object[] res = result as object[]; 
             
            Console.WriteLine(res[0]); 
            Console.WriteLine(res[1]); 
            Console.ReadLine(); 
        } 
    } 
}
```

In Microsoft® Visual Studio®, add a reference to your C# project to the MATLAB COM object. From the Project menu, select Add Reference.

- Select the COM tab in the Add Reference dialog box.
- Select the MATLAB application.



## ==⚡ GUI Building

有两种创建 GUI 程序界面方式：

- Create a Simple UI Using GUIDE
- Create a Simple UI Programmatically


使用命令 *guide* 或菜单打开图形界面设计器，New -> Graphics User Interface，选择一个界面模板开始定制用户界面。

一个设计好的界面包含两个文件，二进制的界面组件配置文件 .fig，和程序函数定义文件 .m。组件配置文件包括 UI 组件的位置设置，动作回调函数设置等等，可以通过 Object Broswer 和 Properties Inspector 窗口检查和设置。

- *guide*   Open GUIDE
- *inspect* Open Property Inspector

GUI 程序设计主要步骤：

- Component Selection
    - UI Controls and Indicators
    - Menus and Toolbars
    - Predefined Dialog Boxes
- Component Layout
- Coding UI Behavior
- Packaging UIs as Apps


UI Controls and Indicators

Buttons, boxes, sliders, and text

Functions

- *figure*  -- Create figure window
- *axes*    -- Create axes graphics object
- *uicontrol*   -- Create user interface control object
- *uitable* -- Create table UI component
- *uipanel* -- Create panel container object
- *uibuttongroup*   -- Create button group to manage radio buttons and toggle buttons
- *uitab*   -- Create tabbed panel
- *uitabgroup*  -- Create container for tabbed panels
- *actxcontrol* -- Create Microsoft ActiveX control in figure window

Properties

- Figure Properties   -- Control figure window appearance and behavior
- Uicontrol Properties    -- Control appearance and behavior of user interface control
- Uitable Properties  -- Control appearance and behavior of table
- Uipanel Properties  -- Control appearance and behavior of panel
- Uibuttongroup Properties    -- Control appearance and behavior of button group
- Uitab Properties    -- Control appearance and behavior of tabbed panel
- Uitabgroup Properties   -- Control appearance and behavior of tabbed panel container

Menus and Toolbars

Menu items and tools at the top of a window

Functions

- *uimenu*  -- Create menus and menu items on figure windows
- *uicontextmenu*   -- Create context menu
- *uitoolbar*   -- Create toolbar on figure
- *uipushtool*  -- Create push button on toolbar
- *uitoggletool*    -- Create toggle button on toolbar

Properties

- Uimenu Properties   -- Control appearance and behavior of menu
- Uicontextmenu Properties    -- Control appearance and behavior of context menu
- Uitoolbar Properties    -- Control appearance and behavior tool bar
- Uipushtool Properties   -- Control appearance and behavior of uipushtool
- Uitoggletool Properties -- Control appearance and behavior of uitoggletool


Predefined Dialog Boxes

Dialog boxes to report status, gather user input, and interact with operating system or printers

Functions

- *errordlg*    Create error dialog box
- *warndlg* Create warning dialog box
- *msgbox*  Create message dialog box
- *helpdlg* Create help dialog box
- *waitbar* Open or update wait bar dialog box

- *questdlg*    Create question dialog box
- *inputdlg*    Create dialog box that gathers user input
- *listdlg* Create list-selection dialog box
- *uisetcolor*  Open color selection dialog box
- *uisetfont*   Open font selection dialog box
- *export2wsdlg*    Create dialog box for exporting variables to workspace

- *uigetfile*   Open file selection dialog box
- *uiputfile*   Open dialog box for saving files
- *uigetdir*    Open folder selection dialog box
- *uiopen*  Open dialog box for selecting file to load into workspace
- *uisave*  Open dialog box for saving variables to MAT-file

- *printdlg*    Open figure Print dialog box
- *printpreview*    Open figure Print Preview dialog box
- *exportsetupdlg*  Open figure Export Setup dialog box

- *dialog*  Create empty modal dialog box
- *uigetpref*   Conditionally open dialog box according to user preference


## ==⚡ DSP
- Intuitive Understanding Of Euler’s Formula https://betterexplained.com/articles/intuitive-understanding-of-eulers-formula/
- 信号处理 | 傅里叶变换、短时傅里叶变换、小波变换、希尔伯特变换、希尔伯特黄变换 https://zhuanlan.zhihu.com/p/150705777
- 欧拉公式 https://www.bilibili.com/video/BV1Sb4y1v7tb?p=17
- 傅里叶级数、傅里叶变换与频谱 by Eugene Khutoryansky https://www.bilibili.com/video/BV1sS4y1G7WF
- 什么是傅立叶级数呢？-从热流到画圈圈 by 3Blue1Brown https://www.bilibili.com/video/BV1vt411N7Ti
- But what is the Fourier Transform? A visual introduction by 3Blue1Brown https://www.bilibili.com/video/BV1pW411J7s8
- An Interactive Guide To The Fourier Transform https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/
- Pitch Shifting Using The Fourier Transform http://blogs.zynaptiq.com/bernsee/pitch-shifting-using-the-ft/
- Time and pitch scaling in audio processing http://www.surina.net/article/time-and-pitch-scaling.html
- Fourier Transform: maps image into spatial frequency domain https://homepages.inf.ed.ac.uk/rbf/HIPR2/fourier.htm
- Fourier transforms of images by Rachel Thomas https://plus.maths.org/content/fourier-transforms-images
- Matplotlib — Visualization with Python https://matplotlib.org/
- MATLAB vs Mathematica: Which One is Better for Future? https://matlabassignmenthelp.com/blog/matlab-vs-mathematica/
- CT IEEE Signal Processing Society https://www.ewh.ieee.org/r1/ct/sps/index.html
- Essential MATLAB for Engineers and Scientists by Brian D. Hahn Daniel T Valentine
- Signal Processing Algorithms in MATLAB by Samuel D. Stearns, Ruth A. David
- Signals and Systems Using MATLAB by Luis F. Chaparro, Aydin Akan
- Signals & Systems by Alan V. Oppenheim, Alan S. Willsky, S. Hamid Nawab
- Digital Signal Processing A Practical Guide for Engineers and Scientists by Steven Smith
- Digital Signal Processing, Fourth Edition by John G. Proakis, Dimitris K. Manolakis
- Understanding Digital Signal Processing by Richard G. Lyons
- Discrete-time signal processing by Buck, John R.Oppenheim, Alan V.Schafer, Ronald W
- A Student’s Guide to Fourier Transforms with Applications in Physics and Engineering
- The Scientist and Engineer's Guide to Digital signal processing, Second Edition by Steven W. Smith
- First Principles of Discrete Systems and Digital Signal Processing by Robert D. Strum, Donald E. Kirk
- Digital Signal Processing with Matlab Examples, Volume 1 Signals and Data, Filtering, Non-stationary Signals, Modulation by Jose Maria Giron-Sierra

关于信号处理方面的专业书籍 CT IEEE Signal Processing Society 上有一个书单。并且在线提供了 Matlab、Mathematica 两个专业软件的手册：

- MATLAB Manual: Getting started with MATLAB.
- Mathematica Manual: Getting started with Mathematica.

在信号处理领域，*时域* Time Domain 和*频域* Frequency Domain 是两个非常基础的概念，它们也是两种观察信息的角度。

图像或音频处理 Audio Process 等数字信号处理中，Fourier Analysis 是一种常用方法，这套分析方法来自 18 世界的法国数学家 Joseph Fourier。使用傅里叶变换，可以用时域、频域的观点去观察一个声音。

对于一个信号来说，它有很多方面的特性。如信号强度随时间的变化规律（时域特性），信号是由哪些单一频率的信号合成的（频域特性）

*时域观点*，描述数学函数或物理信号对时间的关系，以时间作基本变量的范围，观察信号如何承时间变化。示波器是一种直观的信号时域波形观察仪器，可以直观看到一个信号的时域波形如果随着时间的变化。

在实际应用中，计算机只能处理*离散信号* Discrete-Time Signal，所以对连续信号进行时域采样，得到离散的采样数据。

若考虑离散时间，时域中的函数或信号，在各个离散时间点的数值均为已知。若考虑连续时间，则函数或信号在任意时间的数值均为已知。  在研究时域的信号时，常会用示波器将信号转换为其时域的波形。

*频域观点*，描述信号在频率方面特性时用到二维坐标系，横向表示频率，纵向表示信息对应频率分量的强度。

在音频信号处理中，*傅里叶变换*（Fourier transform）是常用工具，它是一种线性积分变换，在时域和频域之间对信号进行变换。在实际应用中，计算机只能处理离散信号，所以对连续信号进行时域采样，对离散样本进行傅里叶变换就是 DFT - Discrete Fourier transform。比如，音频中有高频啸叫分量，通过 DFT 可以分解出信息的各种频率分量，并且可以在移除产生高频啸叫的分量后再进行*逆傅里叶变换* Inverse Fourier Transform，就可以过滤掉不需要音频部分。

快速傅里叶变换（Fast Fourier Transform，FFT）是一种可在 O(nlogn) 时间内完成离散傅里叶变换的高效、快速计算方法集的统称。最初的快速傅里叶变换方法早在 1805 年就已由高斯推导出来，并于 1965 年由 Cooley 和 Tukey 重新提出，并渐渐被大众所熟知。从此，对快速傅里叶变换（FFT）算法的研究便不断深入，数字信号处理这门新兴学科也随 FFT 的出现和发展而迅速发展。

简单的说，傅里叶变换就是信号展开为一系列三角函数的和。因为三角函数是周期对称函数，所以展开也就是把对称性进行分解。一般来说对称性分为奇对称性 f(x)=-f(-x)，即中心对称，和偶对称性（f(x)=f(-x)，即轴对称。经过傅里叶变换，奇对称性的分量构成了傅里叶变换的虚部，而偶对称性的部分就构成了变换后的实部。


音频信号和图像信号没有本质区别，像素的颜色值和音频采样值都是数值信息，只不过前者是一维信号，而图像是二维信号。它们都可以使用多个三角函数分量表达，这很具有神秘感，但对于数学家来说，这是非常明显的事。

Fourier transforms of images by Rachel Thomas 是很棒的傅里叶变换图像处理入门教程，使用了 Matlab 作为分析工具。也可以借助 Python 的 matplotlib 图形库，查看傅里叶变换图像处理效果。还有 Robert Bob Fisher 教授的  HIPR2: Hypertext Image Processing Reference 也是不错的在线图像处理方面的参考教材。

可以将图像像素的灰度值看作一个函数，对应 (x, y) 坐标像素，grey = f(x, y)。因此，图像也可以用三角函数表示，只不过是二维的，z = a sin(hx+ky)。

- 式中 x、y 指出空间中点的坐标；
- z 表示三角函数波形在对应坐标点的高度、或灰度值；
- a 表示波幅，即最大高度、灰度值；
- h、k 对应表示三角函数波形沿 x、y 方向重复的次数，即波形频率；

在图像处理中，*空间域* Spatial Domain，又称图像空间(image space)，指由图像像元组成的空间。在图像空间中以长度(距离)为自变量直接对像元值进行处理称为空间域处理。可以简单理解为像素空间，在空域的处理就是在像素级的处理，通过傅立叶变换后，得到的是图像的频谱，表示图像的能量梯度。

对图像进行傅立叶变换，可以得到空间域频率分布图，Spatial Frequency 或者叫做图像频谱，可以作为一张灰度图像。其中的每个像素都有一个坐标值（h，k），位置坐标值也代表 x 方向和 y 方向频率，表示在傅立叶变换中的正弦波分量的对应强度贡献：

- 中心点表示（0, 0）波，表示没有波纹的平面，两个 0 值表示恒定没有波动，其强度（灰度颜色的亮度）是输入图像中像素的平均值。
- 中心点左侧、右侧的点代表沿 x 轴变化的正弦波，k = 0，这些点的亮度表示傅立叶变换中具有该频率的正弦波的强度（强度是正弦波的振幅的平方）。
- 中心点上下垂直的那些点代表原始图像 y 方向中变化，但在 x 方向中保持恒定（h = 0）的正弦波，其波形频率及其强度。
- 傅立叶变换中的其他点表示原始图像对角波的贡献值。

因此，空间域图像离中心越远的位置表示频率越高，离中心点越近表示频率越低。高频分量表示原始图像上单位距离的颜色变化更强烈，低频分量表示更平滑的部分。

如果旋转输入的原始图像，那么变换得到的空间图像也会跟着旋转。

![sinx-ft-zoom](https://plus.maths.org/content/sites/plus.maths.org/files/articles/2017/carola/sinx-ft-zoom.jpg)

举例来说，使用 sin(x) 生成一张原始图像，它的像素颜色看起来就是：在水平方向按正弦波黑白平滑过度，在竖直方向上具有相同的灰度值。经过傅里叶变换得到的空间域也是尺寸一样的灰度图，但只有三个亮点：中心位置，和紧贴左右两侧的亮点，坐标分别为 (0, 0)、(-1,0)、(1,0)。其余所有像素都是黑色的，因为原始图像为 Sin(x) 仅使用（1,0）波进行精确描述，y 方向没有变化。如果 x 方向的频率增大，那么出现的亮点位置也也会向边缘移动。注意坐标值也对应代表了 x、y 方向的频率，以及其灰度值代表了对应频率的波幅强度。

又比如，使用方波生成原始图像，即输入一张左边一半黑色、右边一半白色的图像，经过傅里叶变换得到的空间域图像就只有一条过中心点的水平亮线。之所以有水平亮线，就是因为水平方向在规律的波形变化。如果变化没有规律，亮点就不能组成规则的线条。

注意，方波信号展开为傅里叶级数，也就是由一系列不同频率的正弦波构成。*傅里叶级数* Fourier Series 是一种对周期信号进行分解的方式。

越是简单的原始波形，变换得到的亮点就越少，因为正弦波频率分量越少。而现实中的照片通常含有复杂的像素结构，所以需要极复杂的正弦波分量来表达，所以得到的亮点也极多。

傅里叶变换在音频、图像处理应用十分广泛，特别是用于增强图像清晰度、降低噪点，用于 JPEG 格式图像压缩。

Fourier transforms of images by Rachel Thomas 文章给出的 Matlab 代码参考，可以保存为 .m 文件格式：

```matlab
% Fourier transforms of images by Rachel Thomas 
% https://plus.maths.org/content/fourier-transforms-images
% https://plus.maths.org/content/sites/plus.maths.org/files/articles/2017/carola/MATLAB.TXT

% HOW TO MAKE A 2D SINE WAVE

% SET SIZE OF IMAGE
X=1:600; 
[Xm Ym]=meshgrid(X, X); 

% DEFINE SINE WAVE, SCALED TO IMAGE SIZE AND SO THAT VALUES WORK IN GRAY SCALE
Z=(sin(Xm*2*pi/600)+1)/2+(sin(Ym*2*pi/600)+1)/2

% PIC OF SURFACE IN 3D
% [need image size to be about 100px for this to look nice, otherwise is just black]
surf(Xm,Ym,Z)

% SHOW WAVE FROM ABOVE - CONTOUR STYLE
imshow(Z)

% FOR FOURIER TRANSFORM
% [FOURIER TRANFORM MOST OBVIOUS IF YOU HAVE SINE WAVES WITH HIGH FREQUENCIES, SAY OVER 10, SO THE BRIGHT PIXELS ARE FAR ENOUGH FROM THE CENTRE]
fftA = fft2(double(Z))
ffB=log(abs(fftshift(fftA)+1))

imshow(ffB)

% FOR IMAGE
PIC = imread('/.../.../picture.jpg')

imshow(PIC)

% TURN INTO GRAYSCALE ARRAY
PIC2=rgb2gray(PIC)

% FOR FOURIER TRANSFORM
% NEED TO DIVIDE BY MAX ELT OF FFTB TO MAKE GRAYSCALE WORK
fftA = fft2(double(PIC)); fftB = log(abs(fftshift(fftA)+1)); fftC = fftB/max(max(max(fftB)));

imshow(fftC)

% ROTATE IMAGE WITH
PIC3=imrotate(PIC,45)
```


## ==⚡ Matlab FFT 
- MATLAB — Examples https://www.mathworks.com/help/matlab/examples.html
- MATLAB — Examples - Using FFT https://www.mathworks.com/help/releases/R2019b/matlab/math/using-fft.html

Matlab 官方文档提供了傅里叶分析法的示范，在示例文档 Fourier Analysis and Filtering 分类：

- Smooth Data with Convolution -- Smooth noisy, 2-D data using convolution.
- FFT for Spectral Analysis *fftdemo.m*
- Square Wave from Sine Waves *xfourier.m*
- Analyzing Cyclical Data with FFT 或 Matlab R2015 版本 Using FFT *sunspots.m* 

在 Matlab 命令窗口执行 *showdemo sunspots* 或 *edit sunspots* 就可以直接打开示范程序。

这个示例对太阳黑子活动数量历史数据进行 FFT 分析，得到太阳黑子活动周期约为 11 年。

太阳黑子（亦称日斑）是太阳光球上的临时现象，它们在可见光下呈现比周围区域黑暗的斑点，是太阳表面可以看到的最突出的现象。太阳黑子存在于太阳光球表面，是磁场的聚集之处。一个中等大小的黑子大概和地球的大小差不多，其数量和位置每隔一段时间会发生周期性变化。

程序代码位于：

    Matlab R2015b\toolbox\matlab\demos\sunspots.m

还有配套的近 300 年太阳活动数据文件 sunspot.dat，内容为两列，年份和监测到的太阳黑子活跃数量：

    1700    5.0
    1701   11.0
    1702   16.0
    1703   23.0
    1704   36.0
    1705   58.0
    1706   29.0
    1707   20.0
    1708   10.0
    1709    8.0
    1710    3.0
    1711    0.0
    1712    0.0
    1713    2.0
    1714   11.0
    1715   27.0
    ...


```matlab
%% Using FFT
% This example shows how to use the FFT function to analyze the variations in sunspot
% activity over the last 300 years.

% Copyright 1984-2014 The MathWorks, Inc.

%%
% Sunspot activity is cyclical, reaching a maximum about every 11 years.  Let's
% confirm that.  Here is a plot of a quantity called the Zurich sunspot
% relative number, which measures both number and size of sunspots.
% Astronomers have tabulated this number for almost 300 years.

load sunspot.dat
year = sunspot(:,1);
relNums = sunspot(:,2);
plot(year,relNums)
title('Sunspot Data')

%%
% Here is a closer look at the first 50 years.

plot(year(1:50),relNums(1:50),'b.-');

%%
% The fundamental tool of signal processing is the FFT, or fast Finite Fourier
% Transform.  To take the FFT of the sunspot data type the following.
%
% The first component of Y, Y(1), is simply the sum of the data, and can be
% removed.

Y = fft(relNums);
Y(1) = [];

%%
% A graph of the distribution of the Fourier coefficients (given by Y) in the
% complex plane is pretty, but difficult to interpret.  We need a more useful way
% of examining the data in Y.

plot(Y,'ro')
title('Fourier Coefficients in the Complex Plane');
xlabel('Real Axis');
ylabel('Imaginary Axis');

%%
% The complex magnitude squared of Y is called the power, and a plot of power
% versus frequency is a "periodogram".

n = length(Y);
power = abs(Y(1:floor(n/2))).^2;
nyquist = 1/2;
freq = (1:n/2)/(n/2)*nyquist;
plot(freq,power)
xlabel('cycles/year')
title('Periodogram')

%%
% The scale in cycles/year is somewhat inconvenient.  We can plot in years/cycle
% and estimate the length of one cycle.

plot(freq(1:40),power(1:40))
xlabel('cycles/year')

%%
% Now we plot power versus period for convenience (where period = 1./freq).  As
% expected, there is a very prominent cycle with a length of about 11 years.

period = 1./freq;
plot(period,power);
axis([0 40 0 2e+7]);
ylabel('Power');
xlabel('Period (Years/Cycle)');

%%
% Finally, we can fix the cycle length a little more precisely by picking out
% the strongest frequency.  The red dot locates this point.

hold on;
index = find(power == max(power));
mainPeriodStr = num2str(period(index));
plot(period(index),power(index),'r.', 'MarkerSize',25);
text(period(index)+2,power(index),['Period = ',mainPeriodStr]);
hold off;


displayEndOfDemoMessage(mfilename)
```

*displayEndOfDemoMessage* Explain how to get more information about a demo.

*displayEndOfDemoMessage(mfilename)* shows a link to the published HTML version of an M-file written using cells.  Enable Cell Mode using the Cell menu in the MATLAB Editor.


执行 *edit fftdemo* 命令打开 FFT for Spectral Analysis 示例：

```matlab
%% FFT for Spectral Analysis
% This example shows the use of the FFT function for spectral  analysis.  A
% common use of FFT's is to find the frequency components of a signal buried in
% a noisy time domain signal.
%
% Copyright 1984-2005 The MathWorks, Inc. 

%%
% First create some data.  Consider data sampled at 1000 Hz.  Start by forming a
% time axis for our data, running from t=0 until t=.25 in steps of 1
% millisecond.  Then form a signal, x, containing sine waves at 50 Hz and 120
% Hz.

t = 0:.001:.25;
x = sin(2*pi*50*t) + sin(2*pi*120*t);

%%
% Add some random noise with a standard deviation of 2 to  produce a noisy
% signal y.  Take a look at this noisy  signal y by plotting it.

y = x + 2*randn(size(t));
plot(y(1:50))
title('Noisy time domain signal')

%%
% Clearly, it is difficult to identify the frequency components from looking at
% this signal; that's why spectral analysis is so popular.
%
% Finding the discrete Fourier transform of the noisy signal y is easy; just
% take the fast-Fourier transform (FFT).

Y = fft(y,251);

%%
% Compute the power spectral density, a measurement of the energy at various
% frequencies, using the complex conjugate (CONJ).  Form a  frequency axis for
% the first 127 points and use it to plot the result.  (The remainder of the
% points are symmetric.)

Pyy = Y.*conj(Y)/251;
f = 1000/251*(0:127);
plot(f,Pyy(1:128))
title('Power spectral density')
xlabel('Frequency (Hz)')

%%
% Zoom in and plot only up to 200 Hz.  Notice the peaks at 50 Hz and  120 Hz.
% These are the frequencies of the original signal.

plot(f(1:50),Pyy(1:50))
title('Power spectral density')
xlabel('Frequency (Hz)')


displayEndOfDemoMessage(mfilename)
```


# =🚩 A Student’s Guide to Fourier Transforms
- A Students Guide to Fourier Transforms With Applications in Physics and Engineering, 3rd by J. F. James

Fourier transform theory is of central importance in a vast range of applications in
physical science, engineering and applied mathematics. Providing a concise
introduction to the theory and practice of Fourier transforms, this book is invaluable to
students of physics, electrical and electronic engineering and computer science.
After a brief description of the basic ideas and theorems, the power of the technique
is illustrated through applications in optics, spectroscopy, electronics and
telecommunications. The rarely discussed but important field of multi-dimensional
Fourier theory is covered, including a description of Computerized Axial Tomography
(CAT) scanning. The book concludes by discussing digital methods, with particular
attention to the Fast Fourier Transform and its implementation.

## ==⚡ 1 Physics and Fourier transforms
### ===🗝 1.1 The qualitative approach

Ninety percent of all physics is concerned with vibrations and waves of one
sort or another. The same basic thread runs through most branches of physical
science, from acoustics through engineering, fluid mechanics, optics, electro-
magnetic theory and X-rays to quantum mechanics and information theory. It
is closely bound to the idea of a signal and its spectrum. 

To take a simple example: 
imagine an experiment in which a musician plays a steady note on a
trumpet or a violin, and a microphone produces a voltage proportional to the
instantaneous air pressure. An oscilloscope will display a graph of pressure
against time, F(t), which is periodic. The reciprocal of the period is the fre-
quency of the note, 440 Hz, say, for a well-tempered middle A – the tuning-up
frequency for an orchestra.

The waveform is not a pure sinusoid, and it would be boring and colourless
if it were. It contains ‘harmonics’ or ‘overtones’: multiples of the fundamental
frequency, with various amplitudes and in various phases👈, depending on the
timbre of the note, the type of instrument being played and on the player.
The waveform can be analysed to find the amplitudes of the overtones, and
a list can be made of the amplitudes and phases of the sinusoids which it
comprises. Alternatively a graph, A(ν), can be plotted (the sound-spectrum) of
the amplitudes against frequency (Fig. 1.1).

    A(ν) is the Fourier transform of F(t).

Actually it is the modular transform, but at this stage that is a detail.
Suppose that the sound is not periodic – a squawk, a drumbeat or a crash
instead of a pure note. Then to describe it requires not just a set of overtones
with their amplitudes, but a continuous range of frequencies, each present in
an infinitesimal amount. The two curves would then look like Fig. 1.2.

    Fig. 1.1. The spectrum of a steady note: fundamental and overtones.

‘Phase’👈 here is an angle, used to define the ‘retardation’ of one wave or vibration with respect
to another. One wavelength retardation, for example, is equivalent to a phase difference of 2π.
Each harmonic will have its own phase, φ_m , indicating its position within the period.

The uses of a Fourier transform can be imagined: the identification of a
valuable violin; the analysis of the sound of an aero-engine to detect a faulty
gear-wheel; of an electrocardiogram to detect a heart defect; of the light curve
of a periodic variable star to determine the underlying physical causes of the
variation: all these are current applications of Fourier transforms.

### ===🗝 1.2 Fourier series

For a steady note the description requires only the fundamental frequency, its
amplitude and the amplitudes of its harmonics. A discrete sum is sufficient. We
could write

    F(t) = a_0 + a_1 cos(2πν_0 t) + b_1 sin(2πν_0 t) + a_2 cos(4πν_0 t)
    + b_2 sin(4πν_0 t) + a_3 cos(6πν_0 t) + ...

where ν_0 is the fundamental frequency of the note. Sines as well as cosines are
required because the harmonics are not necessarily ‘in step’ (i.e. ‘in phase’)
with the fundamental or with each other.
More formally:

    \sum_{a=-\infty}^{\infty} (a_n sin(2\pi n v_0 t) + b_n cos(2\pi nv_0t))

<img src="http://latex.codecogs.com/svg.latex?\sum_{a=-\infty}^{\infty}&space;(a_n&space;sin(2\pi&space;n&space;v_0&space;t)&space;&plus;&space;b_n&space;cos(2\pi&space;nv_0t))" />

and the sum is taken from -∞ to ∞ for the sake of mathematical symmetry.

    Fig. 1.2. The spectrum of a crash: all frequencies are present.

This process of constructing a waveform by adding together a fundamental
frequency and overtones or harmonics of various amplitudes is called Fourier
synthesis.

There are alternative ways of writing this expression: since cos(x) = cos(-x)
and sin(x) = -sin(-x) we can write

    F(t) = A_0/2 + sum_{n=1}^{\infty} A_n cos(2\pi n v_0 t) + B_n sin(2\pi n v_0 t)

and the two expressions are identical, provided that we set A_n + a_-n + a_n and
B_n = b_n + b_-n. A_0 is divided by two to avoid counting it twice: as it is, A_0 can
be found by the same formula that will be used to find all the A_n’s.

Mathematicians and some theoretical physicists write the expression as

    F(t) = A_0/2 + \sum_{n=1}^{\infty} A_n cos(n\omega_0 t) + B_n sin(n\omega_0 t)

and there are entirely practical reasons, which are discussed later, for not writing
it this way.


### ===🗝 1.3 The amplitudes of the harmonics

The alternative process – of extracting from the signal the various frequencies
and amplitudes that are present – is called Fourier analysis and is much more
important in its practical physical applications. In physics, we usually find the
curve F(t) experimentally and we want to know the values of the amplitudes
A_m and B_m for as many values of m as necessary. To find the values of
these amplitudes, we use the orthogonality property of sines and cosines. This
property is that, if you take a sine and a cosine, or two sines or two cosines,
each a multiple of some fundamental frequency, multiply them together and
integrate the product over one period of that frequency, the resultis always zero
except in special cases.

这个正交性质是，如果你取一个正弦和一个余弦，或者两个正弦或两个余弦，每一个都是某个基频的倍数，将它们相乘，并在该频率的一个周期内积分，结果总是零，除非在特殊情况下。

If P = 1/ν_0 is one period, then

    \int_{t=0}^{p} cos(2\pi n v_0 t) \cdot cos(2\pi m v_0 t)dt = 0

and

    \int_{t=0}^{p} sin(2\pi n v_0 t) \cdot sin(2\pi m v_0 t)dt = 0

unless m = ±n, and

    \int_{t=0}^{p} sin(2\pi n v_0 t) \cdot cos(2\pi m v_0 t)dt = 0

always.

The first two integrals are both equal to 1/(2ν_0) if m = n.
We multiply the expression (1.2) for F(t) by sin(2πmν_0 t) and the product
is integrated over one period, P:


    ### ===🗝 1.4 Fourier transforms
    ### ===🗝 1.5 Conjugate variables
    ### ===🗝 1.6 Graphical representations
    ### ===🗝 1.7 Useful functions
    ### ===🗝 1.8 Worked examples
    ## ==⚡ 2 Useful properties and theorems
    ### ===🗝 2.1 The Dirichlet conditions
    ### ===🗝 2.2 Theorems
    ### ===🗝 2.3 Convolutions and the convolution theorem
    ### ===🗝 2.4 The algebra of convolutions
    ### ===🗝 2.5 Other theorems
    ### ===🗝 2.6 Aliasing
    ### ===🗝 2.7 Worked examples
    ## ==⚡ 3 Applications 1: Fraunhofer diffraction
    ### ===🗝 3.1 Fraunhofer diffraction
    ### ===🗝 3.2 Examples
    ### ===🗝 3.3 Babinet’s principle
    ### ===🗝 3.4 Dipole arrays
    ### ===🗝 3.5 Polar diagrams
    ### ===🗝 3.6 Phase and coherence
    ### ===🗝 3.7 Fringe visibility
    ### ===🗝 3.8 The Michelson stellar interferometer
    ### ===🗝 3.9 The van Cittert–Zernike theorem
    ## ==⚡ 4 Applications 2: signal analysis and communication theory
    ### ===🗝 4.1 Communication channels
    ### ===🗝 4.2 Noise
    ### ===🗝 4.3 Filters
    ### ===🗝 4.4 The matched filter theorem
    ### ===🗝 4.5 Modulations
    ### ===🗝 4.6 Multiplex transmission along a channel
    ### ===🗝 4.7 The passage of some signals through simple filters
    ### ===🗝 4.8 The Gibbs phenomenon
    ## ==⚡ 5 Applications 3: interference spectroscopy and spectral line shapes
    ### ===🗝 5.1 Interference spectrometry
    ### ===🗝 5.2 The Michelson multiplex spectrometer
    ### ===🗝 5.3 The shapes of spectrum lines
    ## ==⚡ 6 Two-dimensional Fourier transforms
    ### ===🗝 6.1 Cartesian coordinates
    ### ===🗝 6.2 Polar coordinates
    ### ===🗝 6.3 Theorems
    ### ===🗝 6.4 Examples of two-dimensional Fourier transforms circular symmetry
    ### ===🗝 6.5 Applications
    ### ===🗝 6.6 Solutions without circular symmetry
    ## ==⚡ 7 Multi-dimensional Fourier transforms
    ### ===🗝 7.1 The Dirac wall
    ### ===🗝 7.2 Computerized axial tomography
    ### ===🗝 7.3 A ‘spike’ or ‘nail’
    ### ===🗝 7.4 The Dirac fence
    ### ===🗝 7.5 The ‘bed of nails’
    ### ===🗝 7.6 Parallel-plane delta-functions
    ### ===🗝 7.7 Point arrays
    ### ===🗝 7.8 Lattices
    ## ==⚡ 8 The formal complex Fourier transform
    ## ==⚡ 9 Discrete and digital Fourier transforms
    ### ===🗝 9.1 History
    ### ===🗝 9.2 The discrete Fourier transform
    ### ===🗝 9.3 The matrix form of the DFT
    ### ===🗝 9.4 A BASIC FFT routine


# =🚩 FFT and Signal Processing
- Fast Fourier Transforms and Signal Processing by Jake Blanchard



# =🚩 IEEE MATLAB Manual Practices
- CT IEEE Signal Processing Society - MATLAB Manual https://www.ewh.ieee.org/r1/ct/sps/download.html
- Basic Electrical Engineering by V. K. Mehta, Rohit Mehta
- Fundations of Electrical Engineering 2nd by J.R.Cogdell
- Fundamentals of Electric Circuits by Charles Alexander, Matthew Sadiku
- Electrical Engineering: Principles and Applications (Global Edition) by Allan R. Hambley
- Basic Electrical and Electronics Engineering by D. P. Kothari, I. J. Nagrath
- Fundamentals of Electric Circuits 6th by Charles K Alexander, Matthew Sadiku
- An Engineer's Guide to MATLAB: With Applications from Mechanical, Aerospace, Electrical, Civil, and Biological Systems Engineering, 3rd

## ==⚡ CH1: Getting started with your Matlab

Complex Numbers
Real and imaginary components, phase angles

- *abs* Absolute value and complex magnitude
- *angle*   Phase angle
- *complex* Create complex array
- *conj*    Complex conjugate
- *cplxpair*    Sort complex numbers into complex conjugate pairs
- *i*   Imaginary unit
- *imag*    Imaginary part of complex number
- *isreal*  Determine whether array is real
- *j*   Imaginary unit
- *real*    Real part of complex number
- *sign*    Sign function (signum function)
- *unwrap*  Correct phase angles to produce smoother phase plots

Vector Fields
Comet, compass, feather, quiver and stream plots

- *feather* Plot velocity vectors
- *quiver*  Quiver or velocity plot
- *compass* Plot arrows emanating from origin
- *quiver3* 3-D quiver or velocity plot
- *streamslice* Plot streamlines in slice planes
- *streamline*  Plot streamlines from 2-D or 3-D vector data

Polar Plots
Plots in polar coordinates

- *polar*   Polar coordinate plot
- *rose*    Angle histogram plot
- *compass* Plot arrows emanating from origin
- *ezpolar* Easy-to-use polar coordinate plotter

Cartesian Coordinate System Conversion
Cartesian, polar, and spherical coordinates

- *cart2pol*    Transform Cartesian coordinates to polar or cylindrical
- *cart2sph*    Transform Cartesian coordinates to spherical
- *pol2cart*    Transform polar or cylindrical coordinates to Cartesian
- *sph2cart*    Transform spherical coordinates to Cartesian



➡ Practice -“cart2pol” Command-

Express the given complex number in polar form

>> z=-2+0.5j; % define a complex number in Cartesian form
>>[theta, mag] = cart2pol(-2,0.5) % provide polar form of z
theta =
 2.8966
mag =
2.0616

∴ z = -2+0.5j = 2.061e^j2.8966

➡ Practice -Complex Numbers- (1)

1. Use MATLAB to evaluate the magnitude and phase of the given complex numbers.

>>z1=2+3j;
>>z2=2+j;
>>z3=-2-3j;
>>z4=1-3j;

2. Express the numbers defined in part (1) in polar form
3. Determine z1 * z2, and z1/z2
4. Determine z3+z4, and z4-z3
5. Determine the real part of (z1)^2 × (z2)^2
6. Determine the imaginary part of (z1)^4 / (z2)^3

Plot z1 using plot(z1,’x’). This command will plot the imaginary part versus the
real part.

1.使用 MATLAB 计算给定复数的大小和相位。

```matlab
z1=2+3j;
z2=2+j;
z3=-2-3j;
z4=1-3j;
z = [z1 z2 z3 z4];
abs(z)
angle(z) % radian
angle(z)*180/pi % degree
[theta, magn] = cart2pol(real(z), imag(z))

ans =
    3.6056    2.2361    3.6056    3.1623
ans =
    0.9828    0.4636   -2.1588   -1.2490
ans =
   56.3099   26.5651 -123.6901  -71.5651
theta =
    0.9828    0.4636   -2.1588   -1.2490
magn =
    3.6056    2.2361    3.6056    3.1623

% Compass - Plot arrows emanating from origin 
compass(real(z),imag(z), '-');
axis([-4 4 -4 4])
legend({'z1' 'z2' 'z3' 'z4'}, 'Location','bestoutside');
% Display Axis Lines Through Origin
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';

hold on
% theta = 0:0.01:2*pi;
% rho = sin(2*theta).*cos(2*theta);
polar(theta,magn,'-r')
hold off
```

∴ Answers:

|              |    z1   |    z2   |     z3    |    z4    |
|--------------|---------|---------|-----------|----------|
| magnitude    |  3.6056 |  2.2361 |    3.6056 |   3.1623 |
| phase radian |  0.9828 |  0.4636 |   -2.1588 |  -1.2490 |
| phase degree | 56.3099 | 26.5651 | -123.6901 | -71.5651 |

z1=2+3j  = 3.6056e^j0.9828
z2=2+j   = 2.2361e^j0.4636
z3=-2-3j = 3.6056e^-j2.1588
z4=1-3j  = 3.1623e^-j1.2490


    ### ===🗝 Evaluation Mathematical Expressions
    ### ===🗝 Basic Mathematical Operation
    ### ===🗝 Character Strings
    ### ===🗝 More You Should Know
    ### ===🗝 Build-in Math Functions & Variables
    ### ===🗝 Rounding to Integers
    ### ===🗝 Base Conversions
    ### ===🗝 Commands & Help
    ### ===🗝 Generation of Vectors
    ### ===🗝 Complex Numbers
    ### ===🗝 Polynomials
    ### ===🗝 Plotting & Graphics
    ### ===🗝 MATLAB Files
    ### ===🗝 Creating Your Own Functions
    ### ===🗝 Additional MATLAB Commands
    ### ===🗝 Formatted Output
    ### ===🗝 Loops & Control
    ### ===🗝 Curve Fitting
    ### ===🗝 Interpolation
    ### ===🗝 Saving & Loading of Data

## ==⚡ CH2 Matrix Operation

    ### ===🗝 Building Large Matrices
    ### ===🗝 Special Matrices
    ### ===🗝 The Empty Matrix
    ### ===🗝 Matrix Operations
    ### ===🗝 Determinant of a Matrix
    ### ===🗝 Rank of a Matrix
    ### ===🗝 Inverse of Matrix
    ### ===🗝 Transpose of a matrix
    ### ===🗝 Symmetric Matrix
    ### ===🗝 Trace of a matrix
    ### ===🗝 Additional Properties of Matrices
    ### ===🗝 Eigenvalues & Eigenvectors
    ### ===🗝 Solving Systems of Linear Equations
    ### ===🗝 Cramer’s Rule

➡ Practice - Commands for Special Matrices- (3)

White a MATLAB code to compute the equivalent resistance of three resistors connected in parallel.

```matlab
% R1=100 ohm, R2=200 ohm, and R3=300 ohm
R=[100 200 300]; % specify vector of resistances
R_inv=ones(size(R)./R; % evaluate 1/R
R_eq=1/sum(R_inv); % evaluate the equivalent resistance
R_eq <enter> % print the equivalent resistance

R_eq =
54.5455
```

电阻并联计算公式 n 个电阻并联的公式是：1/R=1/R1+1/R2...+1/Rn。


## ==⚡ CH3 Linear System Analysis

    ### ===🗝 Basic Discrete-time Sequences
    ### ===🗝 Periodic Signals
    ### ===🗝 Square, Sawtooth & Sinusoidal Waves
    ### ===🗝 Circle
    ### ===🗝 Periodic Signal Generator for Time Response Simulations
    ### ===🗝 Signal Energy
    ### ===🗝 Convolution
    ### ===🗝 Sequence Folding
    ### ===🗝 Ordinary Differential Equation (ODE)
    ### ===🗝 Transfer Function
    ### ===🗝 Step Response & Impulse Response
    ### ===🗝 Pole-zero Plots
    ### ===🗝 The Z-Plane
    ### ===🗝 Stability Design via Routh-Hurwitz
    ### ===🗝 Partial-fraction Expansion
    ### ===🗝 Power Series Expansion with MATLAB
    ### ===🗝 Bode Plots
    ### ===🗝 Interconnection of Systems
    ### ===🗝 Frequency Response Plots
    ### ===🗝 Fourier Synthesis
    ### ===🗝 The Discrete Time Fourier Transform
    ### ===🗝 The Discrete Fourier Transform (DFT)
    ### ===🗝 Timing
    ### ===🗝 Zero-Padding
    ### ===🗝 The Discrete-Time Fourier Series (DTFS)
    ### ===🗝 Circular Convolution
    ### ===🗝 DTMF (Multi-tone Dialing Procedure)
    ### ===🗝 Telephone Tones
    ### ===🗝 DTMF Decoder
    ### ===🗝 Speech Processing
    ### ===🗝 The Spectrogram
    ### ===🗝 Chirp Signals
    ### ===🗝 Goertzel Algorithm
    ### ===🗝 Quantization
    ### ===🗝 Zero-crossings
    ### ===🗝 Audio Effects
## ==⚡ CH4 Symbolic Toolbox

    ### ===🗝 Plotting
    ### ===🗝 Partial Fraction Expansion
    ### ===🗝 Differentiation
    ### ===🗝 Integration
    ### ===🗝 Limits
    ### ===🗝 Symbolic Algebra
    ### ===🗝 Solving Algebraic Equations
    ### ===🗝 Fourier Transformation
    ### ===🗝 Laplace Transformation
    ### ===🗝 Z Transform
    ### ===🗝 Taylor Series
    ### ===🗝 MATRICES
    ### ===🗝 Symbolic Differential Equation
    ### ===🗝 Systems of Linear Differential Equations
## ==⚡ CH5 Design & Analysis of Analog & Digital Filters
    ### ===🗝 Analog Filter Design
    ### ===🗝 Normalized Lowpass Analog Filters
    ### ===🗝 Frequency Response of Analog Filters
    ### ===🗝 Frequency Transformations
    ### ===🗝 Digital Filter Design
    ### ===🗝 Filter Realization Wizard
    ### ===🗝 MATLAB Filter
    ### ===🗝 MATLAB impz

## ==⚡ CH6 Random Signals

Two Classes Signals

Signals are subdivided into two classes, namely,

□ Deterministic signals
□ Random signals

Deterministic Signals & Random Signals

Signals that can be modeled exactly by a mathematical formula are known as deterministic
signals. Deterministic signals are not always adequate to model real-world situations. Random
signals, on the other hand, cannot be described by a mathematical equation; they are modeled in
probabilistic terms. In this chapter we shall use the power of MATLAB to describe some
fundamental aspects of random signals.

### ===🗝 Random Number Generation

Pseudo-random Numbers - Commands: “rand” & “randn”

It’s fairly easy to generate uncorrelated pseudo-random sequences. MATLAB has two built-in
functions to generate pseudo-random numbers, namely rand and randn. The rand function
generates pseudo-random numbers whose elements are uniformly distributed in the interval (0,1).
You can view this as tossing a dart at a line segment from 0 to 1, with the dart being equally
likely to hit any point in the interval [0,1]. The randn function generates pseudo-random
numbers whose elements are normally distributed with mean 0 and variance 1 (standard normal).
Both functions have the same syntax. For example, rand(n) returns a n-by-n matrix of random
numbers, rand(n,m) returns a n-by-m matrix with randomly generated entries distributed
uniformly between 0 and 1., and rand(1) returns a single random number.

➡ Practice - Random Number Generation: Pseudo-random Numbers -

```matlab
%Generate one thousand uniform pseudo-random numbers
rand(1,1000) % return a row vector of 1000 entries
%Generate one thousand gaussian pseudo-random numbers
randn(1,1000); % return a row vector of 1000 entries
```

Keep in mind that rand gives numbers in (0,1), that is, 0 < rand <1.

Normally distributed random numbers 正态分布随机数是符号正态分布规律，这是自然界最普遍的一种状态，二维曲线看着像一个山头。比如人的智商分布，有的智商极高，有人却低智，而大多数都是正常的智商，并且越是极端就越少见。因为是正态分布，理论上没有范围限制。一般上，randn(1eM) 这样的表达中，最大最小值基本会落在 M 值上。

```matlab
s = 1e6;
MM = minmax(randn(1,s))
% minmax from Neural Network Toolbox
```

Random Integers

In some applications, it is desirable to generate random integers. The following code illustrates
one possible way of generating 5 uniform pseudo-random integers over the interval (-20,20).

➡ Practice - Random Number Generation: Random Integers - (1)

```matlab
x=fix(40*rand(5,1))-20 %generate 5 uniform integers
x =
18
-11
4
-1
15
```

Random Binary Vector

➡ Practice - Random Number Generation: Random Binary Vector - (1)

```matlab
>>floor(rand(1,5))
ans =
0 0 0 0 0
>>ceil(rand(0,5))
ans =
1 1 1 1 1
>> ceil(rand(1,5)+0.5)
ans =
2 1 2 1 2
>> floor(rand(1,5)+0.5)
ans =
1 0 0 1 0
```

➡ Practice - Random Number Generation: Random Binary Vector - (2)

Write a MATLAB script to generate M sequences of N coin flips each.

```matlab
M=10;
N=20;
C=floor(rand(N,M)+0.5)
% count the # of heads (1s) in each
% column (sequence of N trials)?
H=sum(C*ones(M,1)) % sum(sum(C))
```

### ===🗝 Randomization

It is a good practice to provide a seed before using the rand command; otherwise you will get the same sequence of random numbers every time you restart the computer. A good way to reseed the random number generator is to use the clock, as follows:

>>rand('state', sum(100 * clock));

If every time you start MATLAB, you type the command above, your random numbers
will be truly random, otherwise they will be pseudo-random


### ===🗝 Bar Graphs

Histogram Construction

The “hist” Command
When the probability density function (pdf) is not available, it can be estimated using a
histogram. A histogram is constructed by subdividing the interval [a,b] containing a collection
of data points into sub-intervals known as bins and count for each bin the number of the data
points that fall within that bin. The function hist provides the histogram of sample values of a
random variable.

>>[n,y]=hist(x,N);

The function hist divides the interval [min(x), max(x)] into N bins and yields the output [n,y],
where n is a vector whose elements are the number of samples in each bin, and y is a vector
whose elements are the centers of the bins. When used in this manner, the hist function does not
produce a graph; instead we use the bar function. The bar function produces a bar graph which
for each value of y, there is a bar whose height is proportional to n.

The “bar” Command
Bar graphs are a good way of examining trends (rising or falling) in one or more variables over a
period of time. MATLAB bar graphs can be created to plot either vertically or horizontally. The
bar function produces a bar graph which for each value of y, there is a bar whose height is
proportional to n.

➡ Practice - Bar Graphs- (1)

Generate 10000 gaussian distributed pseudo-random numbers, and then plot the histogram.

```matlab
%Generate 10000 gaussian pseudo-random numbers and draws a histogram
x=randn(1,10000); % generate a random vector
N=30; % specify the number of bins
% hist(x,N)% draw histgram
[n,y]=hist(x,N); % y=vector of centers of bins; n=centers of bins
bar(y,n) % plot histogram using the bar function
xlabel('Realization of randm variable')
ylabel('Number of occurrences')
```

➡ Practice - Bar Graphs- (2)

Find the approximate distribution of two resistors in a parallel connection assuming that they each have measured values, which vary uniformly about their nominal values by ±5%.

    R1 = 10 kΩ
    R2 = 5 kΩ
    Req = R1//R2 = R1R2/(R1+R2)

```matlab
%Compute 10000 trials and histogram the results.
n=10000;
r1=rand(n,1)*(10500-9500)+9500;
r2=rand(n,1)*(5250-4750)+4750;
r3=r1.*r2./(r1+r2);
subplot(2,1,1);hist(r3,20)
title('Histogram of random resistor values in parallel','FontSize',14);
ylabel('Occurence R1//R2', 'FontSize',14)
xlabel('Range of R3 values','FontSize',14)
```
Kirchhoff’s Current Law [KCL] and Kirchhoff’s Voltage Law [KVL] 基尔霍夫定律是电路中电压和电流所遵循的基本规律，是分析和计算较为复杂电路的基础，1845 年由德国物理学家 G.R.基尔霍夫（Gustav Robert Kirchhoff，1824～1887）提出。

Parallel Resistance Equation

    $$\frac{1}{R_{EQ}} = \frac{1}{R_{1}} +  \frac{1}{R_{2}} +  \frac{1}{R_{3}} + ... + \frac{1}{R_{N}}$$

    1/Req = 1/R1 + 1/R2 + ... + 1/Rn

Resistors in Parallel:

- Have a Common Voltage across them and this is true for all parallel connected elements.

Parallel resistance gives us a value known as Conductance, symbol G with the units of conductance being the Siemens, symbol S. Conductance is the reciprocal or the inverse of resistance, ( G = 1/R ). 


### ===🗝 Scatter Digrams and Correlation Coefficient

Scatter Digram

The scatter diagram is a useful tool for identifying a potential relationship or correlation
between two variables. Correlation implies that as one variable changes, the other also changes.
Sometimes if we know that there is good correlation between two variables, we can use one to
predict the other.


➡ Practice - Scatter Diagram- (1)

```matlab
x=rand(100,1);
y=x+rand(100,1);
plot(x,y,'o','MarkerSize',2) %2-D scatter plot
corrcoef(x,y);
z=randn(100,1);
plot3(x,y,z,'.'); %3-D scatter plot
```

➡ Practice - Scatter Diagram- (2)

```matlab
x=raud(20,1);
y=rand(20,1);
scatter(x,y)
```

➡ Practice - Scatter Diagram- (3)

```matlab
%scatter plot of 2-D gaussian variates
%with unit covariance
x=randn(1000,2);
scatter(x(:,1),x(:,2),'.')
set(gca,'FontSize',15)
```

Correlation Coefficient

The correlation coefficient is a measure of the degree of linear relationship that exists between two variables. When using the corrcoef function, MATLAB produces four correlation values.

```matlab
R = corrcoef(A) 
% returns the matrix of correlation coefficients for A, where the columns of A represent random variables and the rows represent observations.

R = corrcoef(A,B) 
% returns coefficients between two random variables A and B.

[R,P] = corrcoef(___) 
% returns the matrix of correlation coefficients and the matrix of p-values for testing the hypothesis that there is no relationship between the observed phenomena (null hypothesis). Use this syntax with any of the arguments from the previous syntaxes. If an off-diagonal element of P is smaller than the significance level (default is 0.05), then the corresponding correlation in R is considered significant. This syntax is invalid if R contains complex elements.

[R,P,RL,RU] = corrcoef(___) 
% includes matrices containing lower and upper bounds for a 95% confidence interval for each coefficient. This syntax is invalid if R contains complex elements.
```

相关性：两个变量间的线性相关性，用 r 值衡量，r 为正是正相关，r 为负是负相关，范围[-1,1].

两组数据相关系数为 1.0 即完全相关，如果为 0 就是完全不相关。通过后面 y 方程可以知道，y 和 x 是线性相关的。

统计假设检验：对随机变量的分布/参数做出一个假设，利用样本数据来检验这个假设；如果只限定犯第一类错误的概率，则是显著性检验（significance test) [1]，显著性水平用 p 值衡量。

显著性检验是为了判断假设是否成立，即样本与假设的偏差是因为随机误差还是因为假设不真。

These are r_xy, r_xx, r_yy and r_yx. We are only interested in the correlation between x and y, so instead of writing just r, we write r(1,2) to indicate that we are interested in the number positioned in the first row, second column of the matrix r.

➡ Practice - Correlation Coefficient (1)

```matlab
% compute the correlation coefficient of x and y
x=[1 2 3 4 7];
y=[3 5 6 9 8];
r=corrcoef(x,y);
disp(['The correlation coefficient between x and y is: ', num2str(r(1,2))])
```

The correlation coefficient between x and y is: 0.80053


➡ Practice - Correlation Coefficient (2)

```matlab
x=[0:10];
y=5*x+4;
r=corrcoef(x,y)
r =
1.0000 1.0000
1.0000 1.0000
```

➡ Practice - Correlation Coefficient (3)

```matlab
x=[0:10];
y=-5*x+4
r=corrcoef(x,y);
r(1,2)
ans =
    -1.0000
```

### ===🗝 Mean, Standard Deviation & Median

-Commands: “mean”, “std” & “median”

Many times we wish to characterize the probability density function (pdf) with a few numbers.
The mean is a measure of the center or most likely value of a distribution. The variance and
standard deviation are a measure of the extent to which a distribution varies from its mean, and
the median is also a measure of the center. These quantities describe a trend and the variation of
the data about that trend. The median is less sensitive to extreme scores (outliers) than the mean.

The MATLAB commands mean, std, and median determine the sample mean, standard
deviation, and median, respectively. The standard deviation is measured in the same units as the
mean and the median.

➡ Practice - Mean, Standard Deviation & Median-

```matlab
>>x=randn(1,10000); % generate gaussian numbers
>>[mean(x); std(x); median(x)] % compute the mean, standard deviation, and median
ans =
0.0066
1.0036
0.0098
```

Normal Distribution

It is a straightforward matter to simulate from any normal distribution with a specified mean
value and a specified standard deviation. In MATLAB one can produce normally distributed
numbers with mean zero and a standard deviation of unity directly using the function randn. To
produce random numbers from a gaussian distribution of mean m and a standard deviation of sd,
proceed as follows:

```matlab
r=randn; % gaussian number: mean zero, standard deviation unity
z=m+r * sd; % gaussian number: mean m, standard deviation sd.
```

The rand function generates random numbers uniformly distributed from zero to one. Numbers
uniform on the interval [0,1] can be transformed to numbers uniform on [a,b] using the following
transformation:

```matlab
r=rand; % uniform number in [0,1]
x=(b-a) * r+a; % uniform number in [a,b]
```


    ### ===🗝 Gaussian Probabilities
    ### ===🗝 White Noise
    ### ===🗝 Some Useful Functions
    ### ===🗝 Spinning Coins
    ### ===🗝 The Cumsum Function
    ### ===🗝 Counting Techniques
    ### ===🗝 Evaluation of Binomial Coefficients
    ### ===🗝 Correlation
    ### ===🗝 Power Spectral Density
    ### ===🗝 Signal-to-Noise Ratio

## ==⚡ CH7 Graphical User Interface with MATLAB
    ### ===🗝 How to get started?
    ### ===🗝 Got a “Guide Quick Start” Window?
    ### ===🗝 A New Untitle Window
    ### ===🗝 Component Palette
    ### ===🗝 Let’s Start Making a Simple GUI
    ### ===🗝 How to Launch GUI

## ==⚡ CH8 Simulink Tutorial
    ### ===🗝 Starting Up Simulink
    ### ===🗝 Basic Elements
    ### ===🗝 Tutorial-1
    ### ===🗝 Tutorial-2
