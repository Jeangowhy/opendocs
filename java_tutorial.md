# üìú The Java Tutorial
https://docs.oracle.com/javase/tutorial/index.html


Trails Covering the Basics
--------------------------

These trails are available in book form as _The Java Tutorial, Sixth Edition_. To buy this book, refer to the box to the right.

*   [Getting Started](https://docs.oracle.com/javase/tutorialgetStarted/index.html)
     ‚Äî An introduction to Java technology and lessons on installing Java development software and using it to create a simple program.
*   [Learning the Java Language](https://docs.oracle.com/javase/tutorialjava/index.html)
     ‚Äî Lessons describing the essential concepts and features of the Java Programming Language.
*   [Essential Java Classes](https://docs.oracle.com/javase/tutorialessential/index.html)
     ‚Äî Lessons on exceptions, basic input/output, concurrency, regular expressions, and the platform environment.
*   [Collections](https://docs.oracle.com/javase/tutorialcollections/index.html)
     ‚Äî Lessons on using and extending the Java Collections Framework.
*   [Date-Time APIs](https://docs.oracle.com/javase/tutorialdatetime/index.html)
     ‚Äî How to use the java.time pages to write date and time code.
*   [Deployment](https://docs.oracle.com/javase/tutorialdeployment/index.html)
     ‚Äî How to package applications and applets using JAR files, and deploy them using Java Web Start and Java Plug-in.
*   [Preparation for Java Programming Language Certification](https://docs.oracle.com/javase/tutorialextra/certification/index.html)
     ‚Äî List of available training and tutorial resources.

Creating Graphical User Interfaces
----------------------------------

*   [Creating a GUI with Swing](https://docs.oracle.com/javase/tutorialuiswing/index.html)
     ‚Äî A comprehensive introduction to GUI creation on the Java platform.
*   [Creating a JavaFX GUI](https://docs.oracle.com/javafx/index.html)
     ‚Äî A collection of JavaFX tutorials.

Specialized Trails and Lessons
------------------------------

These trails and lessons are only available as web pages.

*   [Custom Networking](https://docs.oracle.com/javase/tutorialnetworking/index.html)
     ‚Äî An introduction to the Java platform's powerful networking features.
*   [The Extension Mechanism](https://docs.oracle.com/javase/tutorialext/index.html)
     ‚Äî How to make custom APIs available to all applications running on the Java platform.
*   [Full-Screen Exclusive Mode API](https://docs.oracle.com/javase/tutorialextra/fullscreen/index.html)
     ‚Äî How to write applications that more fully utilize the user's graphics hardware.
*   [Generics](https://docs.oracle.com/javase/tutorialextra/generics/index.html)
     ‚Äî An enhancement to the type system that supports operations on objects of various types while providing compile-time type safety. Note that this lesson is for advanced users. The [Java Language](https://docs.oracle.com/javase/tutorialjava/index.html) trail contains a [Generics](https://docs.oracle.com/javase/tutorialjava/generics/index.html) lesson that is suitable for beginners.
*   [Internationalization](https://docs.oracle.com/javase/tutoriali18n/index.html)
     ‚Äî An introduction to designing software so that it can be easily adapted (localized) to various languages and regions.
*   [JavaBeans](https://docs.oracle.com/javase/tutorialjavabeans/index.html)
     ‚Äî The Java platform's component technology.
*   [JAXB](https://docs.oracle.com/javase/tutorialjaxb/index.html)
     ‚Äî Introduces the Java architecture for XML Binding (JAXB) technology.
*   [JAXP](https://docs.oracle.com/javase/tutorialjaxp/index.html)
     ‚Äî Introduces the Java API for XML Processing (JAXP) technology.
*   [JDBC Database Access](https://docs.oracle.com/javase/tutorialjdbc/index.html)
     ‚Äî Introduces an API for connectivity between the Java applications and a wide range of databases and data sources.
*   [JMX](https://docs.oracle.com/javase/tutorialjmx/index.html)
    ‚Äî Java Management Extensions provides a standard way of managing resources such as applications, devices, and services.
*   [JNDI](https://docs.oracle.com/javase/tutorialjndi/index.html)
    ‚Äî Java Naming and Directory Interface enables accessing the Naming and Directory Service such as DNS and LDAP.
*   [Reflection](https://docs.oracle.com/javase/tutorialreflect/index.html)
     ‚Äî An API that represents ("reflects") the classes, interfaces, and objects in the current Java Virtual Machine.
*   [RMI](https://docs.oracle.com/javase/tutorialrmi/index.html)
     ‚Äî The Remote Method Invocation API allows an object to invoke methods of an object running on another Java Virtual Machine.
*   [Security](https://docs.oracle.com/javase/tutorialsecurity/index.html)
     ‚Äî Java platform features that help protect applications from malicious software.
*   [Sockets Direct Protocol](https://docs.oracle.com/javase/tutorialsdp/index.html)
     ‚Äî How to enable the Sockets Direct Protocol to take advantage of InfiniBand.
*   [Sound](https://docs.oracle.com/javase/tutorialsound/index.html)
     ‚Äî An API for playing sound data from applications.
*   [2D Graphics](https://docs.oracle.com/javase/tutorial2d/index.html)
     ‚Äî How to display and print 2D graphics in applications.


<a name="sec_toc"></a>

TOC
---------------------------------------------------

üçÄ [Trail: Learning the Java Language](part_a)
üìú 1. [**Object-Oriented Programming Concepts**](#sec_1)
    1.1. [What Is an Object?](#sec_1_1)
    1.2. [What Is a Class?](#sec_1_2)
    1.3. [What Is Inheritance?](#sec_1_3)
    1.4. [What Is an Interface?](#sec_1_4)
    1.5. [What Is a Package?](#sec_1_5)
    1.6. [Questions and Exercises: Object-Oriented Programming Concepts](#sec_1_6)
üìú 2. [**Language Basics**](#sec_2)
    2.1. [Variables](#sec_2_1)
    2.2. [Primitive Data Types](#sec_2_2)
    2.3. [Arrays](#sec_2_3)
    2.4. [Summary of Variables](#sec_2_4)
    2.5. [Questions and Exercises: Variables](#sec_2_5)
    2.6. [Operators](#sec_2_6)
    2.7. [Assignment, Arithmetic, and Unary Operators](#sec_2_7)
    2.8. [Equality, Relational, and Conditional Operators](#sec_2_8)
    2.9. [Bitwise and Bit Shift Operators](#sec_2_9)
    2.10. [Summary of Operators](#sec_2_10)
    2.11. [Questions and Exercises: Operators](#sec_2_11)
    2.12. [Expressions, Statements, and Blocks](#sec_2_12)
    2.13. [Questions and Exercises: Expressions, Statements, and Blocks](#sec_2_13)
    2.14. [Control Flow Statements](#sec_2_14)
    2.15. [The if-then and if-then-else Statements](#sec_2_15)
    2.16. [The switch Statement](#sec_2_16)
    2.17. [The while and do-while Statements](#sec_2_17)
    2.18. [The for Statement](#sec_2_18)
    2.19. [Branching Statements](#sec_2_19)
    2.20. [Summary of Control Flow Statements](#sec_2_20)
    2.21. [Questions and Exercises: Control Flow Statements](#sec_2_21)
üìú 3. [**Classes and Objects**](#sec_3)
    3.1. [Classes](#sec_3_1)
    3.2. [Declaring Classes](#sec_3_2)
    3.3. [Declaring Member Variables](#sec_3_3)
    3.4. [Defining Methods](#sec_3_4)
    3.5. [Providing Constructors for Your Classes](#sec_3_5)
    3.6. [Passing Information to a Method or a Constructor](#sec_3_6)
    3.7. [Objects](#sec_3_7)
    3.8. [Creating Objects](#sec_3_8)
    3.9. [Using Objects](#sec_3_9)
    3.10. [More on Classes](#sec_3_10)
    3.11. [Returning a Value from a Method](#sec_3_11)
    3.12. [Using the this Keyword](#sec_3_12)
    3.13. [Controlling Access to Members of a Class](#sec_3_13)
    3.14. [Understanding Class Members](#sec_3_14)
    3.15. [Initializing Fields](#sec_3_15)
    3.16. [Summary of Creating and Using Classes and Objects](#sec_3_16)
    3.17. [Questions and Exercises: Classes](#sec_3_17)
    3.18. [Questions and Exercises: Objects](#sec_3_18)
    3.19. [Nested Classes](#sec_3_19)
    3.20. [Inner Class Example](#sec_3_20)
    3.21. [Local Classes](#sec_3_21)
    3.22. [Anonymous Classes](#sec_3_22)
    3.23. [Lambda Expressions](#sec_3_23)
    3.24. [Method References](#sec_3_24)
    3.25. [When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions](#sec_3_25)
    3.26. [Questions and Exercises: Nested Classes](#sec_3_26)
    3.27. [Enum Types](#sec_3_27)
    3.28. [Questions and Exercises: Enum Types](#sec_3_28)
üìú 4. [**Annotations**](#sec_4)
    4.1. [Annotations Basics](#sec4_1)
    4.2. [Declaring an Annotation Type](#sec4_2)
    4.3. [Predefined Annotation Types](#sec4_3)
    4.4. [Type Annotations and Pluggable Type Systems](#sec4_4)
    4.5. [Repeating Annotations](#sec4_5)
    4.6. [Questions and Exercises: Annotations](#sec4_6)
üìú 5. [**Interfaces and Inheritance**](#sec_5)
    5.1. [Interfaces](#sec_5_1)
    5.2. [Inheritance](#sec_5_2)
üìú 6. [**Numbers and Strings**](#sec_6)
    6.1. [Numbers](#sec_6_1)
    6.2. [The Numbers Classes](#sec_6_2)
    6.3. [Formatting Numeric Print Output](#sec_6_3)
    6.4. [Beyond Basic Arithmetic](#sec_6_4)
    6.5. [Summary of Numbers](#sec_6_5)
    6.6. [Questions and Exercises: Numbers](#sec_6_6)
    6.7. [Characters](#sec_6_7)
    6.8. [Strings](#sec_6_8)
    6.9. [Converting Between Numbers and Strings](#sec_6_9)
    6.10. [Manipulating Characters in a String](#sec_6_10)
    6.11. [Comparing Strings and Portions of Strings](#sec_6_11)
    6.12. [The StringBuilder Class](#sec_6_12)
    6.13. [Summary of Characters and Strings](#sec_6_13)
    6.14. [Autoboxing and Unboxing](#sec_6_14)
    6.15. [Questions and Exercises: Characters and Strings](#sec_6_15)
üìú 7. [**Generics**](#sec_7)
    7.1. [Why Use Generics?](#sec_7_1)
    7.2. [Generic Types](#sec_7_2)
    7.3. [Raw Types](#sec_7_3)
    7.4. [Generic Methods](#sec_7_4)
    7.5. [Bounded Type Parameters](#sec_7_5)
    7.6. [Generic Methods and Bounded Type Parameters](#sec_7_6)
    7.7. [Generics, Inheritance, and Subtypes](#sec_7_7)
    7.8. [Type Inference](#sec_7_8)
    7.9. [Wildcards](#sec_7_9)
    7.10. [Upper Bounded Wildcards](#sec_7_10)
    7.11. [Unbounded Wildcards](#sec_7_11)
    7.12. [Lower Bounded Wildcards](#sec_7_12)
    7.13. [Wildcards and Subtyping](#sec_7_13)
    7.14. [Wildcard Capture and Helper Methods](#sec_7_14)
    7.15. [Guidelines for Wildcard Use](#sec_7_15)
    7.16. [Type Erasure](#sec_7_16)
    7.17. [Erasure of Generic Types](#sec_7_17)
    7.18. [Erasure of Generic Methods](#sec_7_18)
    7.19. [Effects of Type Erasure and Bridge Methods](#sec_7_19)
    7.20. [Non-Reifiable Types](#sec_7_20)
    7.21. [Restrictions on Generics](#sec_7_21)
    7.22. [Questions and Exercises: Generics](#sec_7_22)
üìú 8. [**Packages**](#sec_8)
    8.1. [Creating and Using Packages](#sec_8_1)
    8.2. [Creating a Package](#sec_8_2)
    8.3. [Naming a Package](#sec_8_3)
    8.4. [Using Package Members](#sec_8_4)
    8.5. [Managing Source and Class Files](#sec_8_5)
    8.6. [Summary of Creating and Using Packages](#sec_8_6)
    8.7. [Questions and Exercises: Creating and Using Packages](#sec_8_7)
üçÄ [Trail: Essential Java Classes](part_b)
üìú 9. [**Exceptions**](#sec_9)
    9.1. [What Is an Exception?](#sec_9_1)
    9.2. [The Catch or Specify Requirement](#sec_9_2)
    9.3. [How to Throw Exceptions](#sec_9_3)
    9.4. [The try-with-resources Statement](#sec_9_4)
    9.5. [Unchecked Exceptions ‚Äî The Controversy](#sec_9_5)
    9.6. [Advantages of Exceptions](#sec_9_6)
    9.7. [Summary](#sec_9_7)
    9.8. [Questions and Exercises](#sec_9_8)
üìú 10. [**Basic I/O**](#sec_10)
    10.1. [I/O Streams](#sec_10_1)
    10.1.1. [Byte Streams](#sec_10_1_1)
    10.1.2. [Character Streams](#sec_10_1_2)
    10.1.3. [Buffered Streams](#sec_10_1_3)
    10.1.4. [Scanning and Formatting](#sec_10_1_4)
    10.1.5. [I/O from the Command Line](#sec_10_1_5)
    10.1.6. [Data Streams](#sec_10_1_6)
    10.1.7. [Object Streams](#sec_10_1_7)
    10.2. [File I/O (Featuring NIO.2)](#sec_10_2)
    10.2.1.  [What is a Path? (And Other File System Facts)](#sec_10_2_1)
    10.2.2.  [The Path Class](#sec_10_2_2)
    10.2.3.  [Path Operations](#sec_10_2_3)
    10.2.4.  [File Operations](#sec_10_2_4)
    10.2.5.  [Checking a File or Directory](#sec_10_2_5)
    10.2.6.  [Deleting a File or Directory](#sec_10_2_6)
    10.2.7.  [Copying a File or Directory](#sec_10_2_7)
    10.2.8.  [Moving a File or Directory](#sec_10_2_8)
    10.2.9.  [Managing Metadata (File and File Store Attributes)](#sec_10_2_9)
    10.2.10.  [Reading, Writing and Creating Files](#sec_10_2_10)
    10.2.11.  [Random Access Files](#sec_10_2_11)
    10.2.12.  [Creating and Reading Directories](#sec_10_2_12)
    10.2.13.  [Links, Symbolic or Otherwise](#sec_10_2_13)
    10.2.14.  [Walking the File Tree](#sec_10_2_14)
    10.2.15.  [Finding Files](#sec_10_2_15)
    10.2.16.  [Watching a Directory for Changes](#sec_10_2_16)
    10.2.17.  [Other Useful Methods](#sec_10_2_17)
    10.2.18.  [Legacy File I/O Code](#sec_10_2_18)
    10.3. [Summary](#sec_10_3)
    10.4. [Questions and Exercises](#sec_10_4)
üìú 11. [**Concurrency**](#sec_11)
üìú 12. [**The Platform Environment**](#sec_12)
üìú 13. [**Regular Expressions**](#sec_13)
üçÄ [Trail: Collections](part_c)
üìú 14. [**Introduction**](#sec_14)
üìú 15. [**Interfaces**](#sec_15)
üìú 16. [**Aggregate Operations**](#sec_16)
üìú 17. [**Implementations**](#sec_17)
üìú 18. [**Algorithms**](#sec_18)
üìú 19. [**Custom Implementations**](#sec_19)
üìú 20. [**Interoperability**](#sec_20)

<a name="part_a"></a>

# üçÄ Trail: Learning the Java Language
https://docs.oracle.com/javase/tutorial/java/index.html

The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available.  
See [Java Language Changes](https://docs.oracle.com/pls/topic/lookup?ctx=en/java/javase&id=java_language_changes) for a summary of updated language features in Java SE 9 and subsequent releases.  
See [JDK Release Notes](https://www.oracle.com/technetwork/java/javase/jdk-relnotes-index-2162236.html) for information about new features, enhancements, and removed or deprecated options for all JDK releases.

This trail covers the fundamentals of programming in the Java programming language.

üìú 1. [**Object-Oriented Programming Concepts**](#sec_1) teaches you the core concepts behind object-oriented programming: objects, messages, classes, and inheritance. This lesson ends by showing you how these concepts translate into code. Feel free to skip this lesson if you are already familiar with object-oriented programming.

üìú 2. [**Language Basics**](#sec_2) describes the traditional features of the language, including variables, arrays, data types, operators, and control flow.

üìú 3. [**Classes and Objects**](#sec_3) describes how to write the classes from which objects are created, and how to create and use the objects.

üìú 4. [**Annotations**](#sec_4) are a form of metadata and provide information for the compiler. This lesson describes where and how to use annotations in a program effectively.

üìú 5. [**Interfaces and Inheritance**](#sec_5) describes interfaces‚Äîwhat they are, why you would want to write one, and how to write one. This section also describes the way in which you can derive one class from another. That is, how a _subclass_ can inherit fields and methods from a _superclass_. You will learn that all classes are derived from the `Object` class, and how to modify the methods that a subclass inherits from superclasses.

üìú 6. [**Numbers and Strings**](#sec_6) This lesson describes how to use `Number` and `String` objects The lesson also shows you how to format data for output.

üìú 7. [**Generics**](#sec_7) are a powerful feature of the Java programming language. They improve the type safety of your code, making more of your bugs detectable at compile time.

üìú 8. [**Packages**](#sec_8) are a feature of the Java programming language that help you to organize and structure your classes and their relationships to one another.

<a name="sec_1"></a>
# üìú/PART [1. Object-Oriented Programming Concepts](#sec_toc)
******
https://docs.oracle.com/javase/tutorial/java/concepts/index.html

1. [What Is an Object?](#sec_1_1)
2. [What Is a Class?](#sec_1_2)
3. [What Is Inheritance?](#sec_1_3)
4. [What Is an Interface?](#sec_1_4)
5. [What Is a Package?](#sec_1_5)
6. [Questions and Exercises](#sec_1_6)

Lesson: Object-Oriented Programming Concepts

If you've never used an object-oriented programming language before, you'll need to learn a few basic concepts before you can begin writing any code. This lesson will introduce you to objects, classes, inheritance, interfaces, and packages. Each discussion focuses on how these concepts relate to the real world, while simultaneously providing an introduction to the syntax of the Java programming language.

[What Is an Object?]
* * *
An object is a software bundle of related state and behavior. Software objects are often used to model the real-world objects that you find in everyday life. This lesson explains how state and behavior are represented within an object, introduces the concept of data encapsulation, and explains the benefits of designing your software in this manner.

[What Is a Class?]
* * *
A class is a blueprint or prototype from which objects are created. This section defines a class that models the state and behavior of a real-world object. It intentionally focuses on the basics, showing how even a simple class can cleanly model state and behavior.

[What Is Inheritance?]
* * *
Inheritance provides a powerful and natural mechanism for organizing and structuring your software. This section explains how classes inherit state and behavior from their superclasses, and explains how to derive one class from another using the simple syntax provided by the Java programming language.

[What Is an Interface?]
* * *
An interface is a contract between a class and the outside world. When a class implements an interface, it promises to provide the behavior published by that interface. This section defines a simple interface and explains the necessary changes for any class that implements it.

[What Is a Package?]
* * *
A package is a namespace for organizing classes and interfaces in a logical manner. Placing your code into packages makes large software projects easier to manage. This section explains why this is useful, and introduces you to the Application Programming Interface (API) provided by the Java platform.

[Questions and Exercises: Object-Oriented Programming Concepts](
* * *
Use the questions and exercises presented in this section to test your understanding of objects, classes, inheritance, interfaces, and packages.


<a name="sec_1_1"></a>
## 1.1. [What Is an Object?](#sec_1_1)
******
https://docs.oracle.com/javase/tutorial/java/concepts/object.html 

Objects are key to understanding _object-oriented_ technology. Look around right now and you'll find many examples of real-world objects: your dog, your desk, your television set, your bicycle.

Real-world objects share two characteristics: They all have _state_ and _behavior_. Dogs have state (name, color, breed, hungry) and behavior (barking, fetching, wagging tail). Bicycles also have state (current gear, current pedal cadence, current speed) and behavior (changing gear, changing pedal cadence, applying brakes). Identifying the state and behavior for real-world objects is a great way to begin thinking in terms of object-oriented programming.

Take a minute right now to observe the real-world objects that are in your immediate area. For each object that you see, ask yourself two questions: "What possible states can this object be in?" and "What possible behavior can this object perform?". Make sure to write down your observations. As you do, you'll notice that real-world objects vary in complexity; your desktop lamp may have only two possible states (on and off) and two possible behaviors (turn on, turn off), but your desktop radio might have additional states (on, off, current volume, current station) and behavior (turn on, turn off, increase volume, decrease volume, seek, scan, and tune). You may also notice that some objects, in turn, will also contain other objects. These real-world observations all translate into the world of object-oriented programming.

![A circle with an inner circle filled with items, surrounded by gray wedges representing methods that allow access to the inner circle.](https://docs.oracle.com/javase/tutorial/figures/java/concepts-object.gif)

A software object.

  

Software objects are conceptually similar to real-world objects: they too consist of state and related behavior. An object stores its state in _fields_ (variables in some programming languages) and exposes its behavior through _methods_ (functions in some programming languages). Methods operate on an object's internal state and serve as the primary mechanism for object-to-object communication. Hiding internal state and requiring all interaction to be performed through an object's methods is known as _data encapsulation_ ‚Äî a fundamental principle of object-oriented programming.

Consider a bicycle, for example:

![A picture of an object, with bicycle methods and instance variables.](https://docs.oracle.com/javase/tutorial/figures/java/concepts-bicycleObject.gif)

A bicycle modeled as a software object.


By attributing state (current speed, current pedal cadence, and current gear) and providing methods for changing that state, the object remains in control of how the outside world is allowed to use it. For example, if the bicycle only has 6 gears, a method to change gears could reject any value that is less than 1 or greater than 6.

Bundling code into individual software objects provides a number of benefits, including:

1.  Modularity: The source code for an object can be written and maintained independently of the source code for other objects. Once created, an object can be easily passed around inside the system.
2.  Information-hiding: By interacting only with an object's methods, the details of its internal implementation remain hidden from the outside world.
3.  Code re-use: If an object already exists (perhaps written by another software developer), you can use that object in your program. This allows specialists to implement/test/debug complex, task-specific objects, which you can then trust to run in your own code.
4.  Pluggability and debugging ease: If a particular object turns out to be problematic, you can simply remove it from your application and plug in a different object as its replacement. This is analogous to fixing mechanical problems in the real world. If a bolt breaks, you replace _it_, not the entire machine.

<a name="sec_1_2"></a>
## 1.2. [What Is a Class?](#sec_1_2)
******
https://docs.oracle.com/javase/tutorial/java/concepts/class.html 

In the real world, you'll often find many individual objects all of the same kind. There may be thousands of other bicycles in existence, all of the same make and model. Each bicycle was built from the same set of blueprints and therefore contains the same components. In object-oriented terms, we say that your bicycle is an _instance_ of the _class of objects_ known as bicycles. A _class_ is the blueprint from which individual objects are created.

The following [`Bicycle`](https://docs.oracle.com/javase/tutorial/java/concepts/examples/Bicycle.java) class is one possible implementation of a bicycle:

class Bicycle {

    int cadence = 0;
    int speed = 0;
    int gear = 1;

    void changeCadence(int newValue) {
         cadence = newValue;
    }

    void changeGear(int newValue) {
         gear = newValue;
    }

    void speedUp(int increment) {
         speed = speed + increment;   
    }

    void applyBrakes(int decrement) {
         speed = speed - decrement;
    }

    void printStates() {
         System.out.println("cadence:" +
             cadence + " speed:" + 
             speed + " gear:" + gear);
    }
}

The syntax of the Java programming language will look new to you, but the design of this class is based on the previous discussion of bicycle objects. The fields `cadence`, `speed`, and `gear` represent the object's state, and the methods (`changeCadence`, `changeGear`, `speedUp` etc.) define its interaction with the outside world.

You may have noticed that the `Bicycle` class does not contain a `main` method. That's because it's not a complete application; it's just the blueprint for bicycles that might be _used_ in an application. The responsibility of creating and using new `Bicycle` objects belongs to some other class in your application.

Here's a [`BicycleDemo`](https://docs.oracle.com/javase/tutorial/java/concepts/examples/BicycleDemo.java) class that creates two separate `Bicycle` objects and invokes their methods:

class BicycleDemo {
    public static void main(String[] args) {

        // Create two different 
        // Bicycle objects
        Bicycle bike1 = new Bicycle();
        Bicycle bike2 = new Bicycle();

        // Invoke methods on 
        // those objects
        bike1.changeCadence(50);
        bike1.speedUp(10);
        bike1.changeGear(2);
        bike1.printStates();

        bike2.changeCadence(50);
        bike2.speedUp(10);
        bike2.changeGear(2);
        bike2.changeCadence(40);
        bike2.speedUp(10);
        bike2.changeGear(3);
        bike2.printStates();
    }
}

The output of this test prints the ending pedal cadence, speed, and gear for the two bicycles:

    cadence:50 speed:10 gear:2
    cadence:40 speed:20 gear:3

<a name="sec_1_3"></a>
## 1.3. [What Is Inheritance?](#sec_1_3)
******
https://docs.oracle.com/javase/tutorial/java/concepts/inheritance.html 

Different kinds of objects often have a certain amount in common with each other. Mountain bikes, road bikes, and tandem bikes, for example, all share the characteristics of bicycles (current speed, current pedal cadence, current gear). Yet each also defines additional features that make them different: tandem bicycles have two seats and two sets of handlebars; road bikes have drop handlebars; some mountain bikes have an additional chain ring, giving them a lower gear ratio.

Object-oriented programming allows classes to _inherit_ commonly used state and behavior from other classes. In this example, `Bicycle` now becomes the _superclass_ of `MountainBike`, `RoadBike`, and `TandemBike`. In the Java programming language, each class is allowed to have one direct superclass, and each superclass has the potential for an unlimited number of _subclasses_:

![A diagram of classes in a hierarchy.](https://docs.oracle.com/javase/tutorial/figures/java/concepts-bikeHierarchy.gif)

A hierarchy of bicycle classes.

The syntax for creating a subclass is simple. At the beginning of your class declaration, use the `extends` keyword, followed by the name of the class to inherit from:

class MountainBike **extends** Bicycle {

    // new fields and methods defining 
    // a mountain bike would go here

}

This gives `MountainBike` all the same fields and methods as `Bicycle`, yet allows its code to focus exclusively on the features that make it unique. This makes code for your subclasses easy to read. However, you must take care to properly document the state and behavior that each superclass defines, since that code will not appear in the source file of each subclass.

<a name="sec_1_4"></a>
## 1.4. [What Is an Interface?](#sec_1_4)
******
https://docs.oracle.com/javase/tutorial/java/concepts/interface.html 

As you've already learned, objects define their interaction with the outside world through the methods that they expose. Methods form the object's _interface_ with the outside world; the buttons on the front of your television set, for example, are the interface between you and the electrical wiring on the other side of its plastic casing. You press the "power" button to turn the television on and off.

In its most common form, an interface is a group of related methods with empty bodies. A bicycle's behavior, if specified as an interface, might appear as follows:

interface Bicycle {

    //  wheel revolutions per minute
    void changeCadence(int newValue);

    void changeGear(int newValue);

    void speedUp(int increment);

    void applyBrakes(int decrement);
}

To implement this interface, the name of your class would change (to a particular brand of bicycle, for example, such as `ACMEBicycle`), and you'd use the `implements` keyword in the class declaration:

class ACMEBicycle **implements** Bicycle {

    int cadence = 0;
    int speed = 0;
    int gear = 1;

   // The compiler will now require that methods
   // changeCadence, changeGear, speedUp, and applyBrakes
   // all be implemented. Compilation will fail if those
   // methods are missing from this class.

    void changeCadence(int newValue) {
         cadence = newValue;
    }

    void changeGear(int newValue) {
         gear = newValue;
    }

    void speedUp(int increment) {
         speed = speed + increment;   
    }

    void applyBrakes(int decrement) {
         speed = speed - decrement;
    }

    void printStates() {
         System.out.println("cadence:" +
             cadence + " speed:" + 
             speed + " gear:" + gear);
    }
}

Implementing an interface allows a class to become more formal about the behavior it promises to provide. Interfaces form a contract between the class and the outside world, and this contract is enforced at build time by the compiler. If your class claims to implement an interface, all methods defined by that interface must appear in its source code before the class will successfully compile.

* * *

**Note:** To actually compile the `ACMEBicycle` class, you'll need to add the `public` keyword to the beginning of the implemented interface methods. You'll learn the reasons for this later in the lessons on [Classes and Objects](#sec_3) and [Interfaces and Inheritance](#sec_5).


<a name="sec_1_5"></a>
## 1.5. [What Is a Package?](#sec_1_5)
******
https://docs.oracle.com/javase/tutorial/java/concepts/package.html 

A package is a namespace that organizes a set of related classes and interfaces. Conceptually you can think of packages as being similar to different folders on your computer. You might keep HTML pages in one folder, images in another, and scripts or applications in yet another. Because software written in the Java programming language can be composed of hundreds or _thousands_ of individual classes, it makes sense to keep things organized by placing related classes and interfaces into packages.

The Java platform provides an enormous class library (a set of packages) suitable for use in your own applications. This library is known as the "Application Programming Interface", or "API" for short. Its packages represent the tasks most commonly associated with general-purpose programming. For example, a `String` object contains state and behavior for character strings; a `File` object allows a programmer to easily create, delete, inspect, compare, or modify a file on the filesystem; a `Socket` object allows for the creation and use of network sockets; various GUI objects control buttons and check boxes and anything else related to graphical user interfaces. There are literally thousands of classes to choose from. This allows you, the programmer, to focus on the design of your particular application, rather than the infrastructure required to make it work.

The [Java Platform API Specification](https://docs.oracle.com/javase/8/docs/api/index.html) contains the complete listing for all packages, interfaces, classes, fields, and methods supplied by the Java SE platform. Load the page in your browser and bookmark it. As a programmer, it will become your single most important piece of reference documentation.

<a name="sec_1_6"></a>
## 1.6. [Questions and Exercises: Object-Oriented Programming Concepts](#sec_1_6)
******
https://docs.oracle.com/javase/tutorial/java/concepts/QandE/questions.html 

Questions
---------

1.  Real-world objects contain ‚ñÅ and ‚ñÅ.
2.  A software object's state is stored in ‚ñÅ.
3.  A software object's behavior is exposed through ‚ñÅ.
4.  Hiding internal data from the outside world, and accessing it only through publicly exposed methods is known as data ‚ñÅ.
5.  A blueprint for a software object is called a ‚ñÅ.
6.  Common behavior can be defined in a ‚ñÅ and inherited into a ‚ñÅ using the ‚ñÅ keyword.
7.  A collection of methods with no implementation is called an ‚ñÅ.
8.  A namespace that organizes classes and interfaces by functionality is called a ‚ñÅ.
9.  The term API stands for ‚ñÅ?

Exercises
---------

1.  Create new classes for each real-world object that you observed at the beginning of this trail. Refer to the Bicycle class if you forget the required syntax.
2.  For each new class that you've created above, create an interface that defines its behavior, then require your class to implement it. Omit one or two methods and try compiling. What does the error look like?


Answers to Questions
--------------------

1.  Real-world objects contain **state** and **behavior**.
2.  A software object's state is stored in **fields**.
3.  A software object's behavior is exposed through **methods**.
4.  Hiding internal data from the outside world, and accessing it only through publicly exposed methods is known as data **encapsulation**.
5.  A blueprint for a software object is called a **class**.
6.  Common behavior can be defined in a **superclass** and inherited into a **subclass** using the **extends** keyword.
7.  A collection of methods with no implementation is called an **interface**.
8.  A namespace that organizes classes and interfaces by functionality is called a **package**.
9.  The term API stands for **Application Programming Interface**.

### Answers to Exercises

1.  Your answers will vary depending on the real-world objects that you are modeling.
2.  Your answers will vary here as well, but the error message will specifically list the required methods that have not been implemented.

<a name="sec_2"></a>
# üìú/PART [2. Language Basics](#sec_toc)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/index.html 

Language Basics

1. [Variables](#sec_2_1)
2. [Primitive Data Types](#sec_2_2)
3. [Arrays](#sec_2_3)
4. [Summary of Variables](#sec_2_4)
5. [Questions and Exercises](#sec_2_5)
6. [Operators](#sec_2_6)
7. [Assignment, Arithmetic, and Unary Operators](#sec_2_7)
8. [Equality, Relational, and Conditional Operators](#sec_2_8)
9. [Bitwise and Bit Shift Operators](#sec_2_9)
10. [Summary of Operators](#sec_2_10)
11. [Questions and Exercises](#sec_2_11)
12. [Expressions, Statements, and Blocks](#sec_2_12)
13. [Questions and Exercises](#sec_2_13)
14. [Control Flow Statements](#sec_2_14)
15. [The if-then and if-then-else Statements](#sec_2_15)
16. [The switch Statement](#sec_2_16)
17. [The while and do-while Statements](#sec_2_17)
18. [The for Statement](#sec_2_18)
19. [Branching Statements](#sec_2_19)
20. [Summary of Control Flow Statements](#sec_2_20)
21. [Questions and Exercises](#sec_2_21)

Variables
* * *
You've already learned that objects store their state in fields. However, the Java programming language also uses the term "variable" as well. This section discusses this relationship, plus variable naming rules and conventions, basic data types (primitive types, character strings, and arrays), default values, and literals.

Operators
* * *
This section describes the operators of the Java programming language. It presents the most commonly-used operators first, and the less commonly-used operators last. Each discussion includes code samples that you can compile and run.

Expressions, Statements, and Blocks
* * *
Operators may be used in building expressions, which compute values; expressions are the core components of statements; statements may be grouped into blocks. This section discusses expressions, statements, and blocks using example code that you've already seen.

Control Flow Statements
* * *
This section describes the control flow statements supported by the Java programming language. It covers the decisions-making, looping, and branching statements that enable your programs to conditionally execute particular blocks of code.


<a name="sec_2_1"></a>
## 2.1. [Variables](#sec_2_1)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html 

Variables
=========

As you learned in the previous lesson, an object stores its state in _fields_.

int **cadence** = 0;
int **speed** = 0;
int **gear** = 1;

The [What Is an Object?](../concepts/object.html) discussion introduced you to fields, but you probably have still a few questions, such as: What are the rules and conventions for naming a field? Besides `int`, what other data types are there? Do fields have to be initialized when they are declared? Are fields assigned a default value if they are not explicitly initialized? We'll explore the answers to such questions in this lesson, but before we do, there are a few technical distinctions you must first become aware of. In the Java programming language, the terms "field" and "variable" are both used; this is a common source of confusion among new developers, since both often seem to refer to the same thing.

The Java programming language defines the following kinds of variables:

*   **Instance Variables (Non-Static Fields)** Technically speaking, objects store their individual states in "non-static fields", that is, fields declared without the `static` keyword. Non-static fields are also known as _instance variables_ because their values are unique to each _instance_ of a class (to each object, in other words); the `currentSpeed` of one bicycle is independent from the `currentSpeed` of another.
*   **Class Variables (Static Fields)** A _class variable_ is any field declared with the `static` modifier; this tells the compiler that there is exactly one copy of this variable in existence, regardless of how many times the class has been instantiated. A field defining the number of gears for a particular kind of bicycle could be marked as `static` since conceptually the same number of gears will apply to all instances. The code `static int numGears = 6;` would create such a static field. Additionally, the keyword `final` could be added to indicate that the number of gears will never change.
*   **Local Variables** Similar to how an object stores its state in fields, a method will often store its temporary state in _local variables_. The syntax for declaring a local variable is similar to declaring a field (for example, `int count = 0;`). There is no special keyword designating a variable as local; that determination comes entirely from the location in which the variable is declared ‚Äî which is between the opening and closing braces of a method. As such, local variables are only visible to the methods in which they are declared; they are not accessible from the rest of the class.
*   **Parameters** You've already seen examples of parameters, both in the `Bicycle` class and in the `main` method of the "Hello World!" application. Recall that the signature for the `main` method is `public static void main(String[] args)`. Here, the `args` variable is the parameter to this method. The important thing to remember is that parameters are always classified as "variables" not "fields". This applies to other parameter-accepting constructs as well (such as constructors and exception handlers) that you'll learn about later in the tutorial.

Having said that, the remainder of this tutorial uses the following general guidelines when discussing fields and variables. If we are talking about "fields in general" (excluding local variables and parameters), we may simply say "fields". If the discussion applies to "all of the above", we may simply say "variables". If the context calls for a distinction, we will use specific terms (static field, local variables, etc.) as appropriate. You may also occasionally see the term "member" used as well. A type's fields, methods, and nested types are collectively called its _members_.

Naming
------

Every programming language has its own set of rules and conventions for the kinds of names that you're allowed to use, and the Java programming language is no different. The rules and conventions for naming your variables can be summarized as follows:

*   Variable names are case-sensitive. A variable's name can be any legal identifier ‚Äî an unlimited-length sequence of Unicode letters and digits, beginning with a letter, the dollar sign "`$`", or the underscore character "`_`". The convention, however, is to always begin your variable names with a letter, not "`$`" or "`_`". Additionally, the dollar sign character, by convention, is never used at all. You may find some situations where auto-generated names will contain the dollar sign, but your variable names should always avoid using it. A similar convention exists for the underscore character; while it's technically legal to begin your variable's name with "`_`", this practice is discouraged. White space is not permitted.
*   Subsequent characters may be letters, digits, dollar signs, or underscore characters. Conventions (and common sense) apply to this rule as well. When choosing a name for your variables, use full words instead of cryptic abbreviations. Doing so will make your code easier to read and understand. In many cases it will also make your code self-documenting; fields named `cadence`, `speed`, and `gear`, for example, are much more intuitive than abbreviated versions, such as `s`, `c`, and `g`. Also keep in mind that the name you choose must not be a [keyword or reserved word](_keywords.html).
*   If the name you choose consists of only one word, spell that word in all lowercase letters. If it consists of more than one word, capitalize the first letter of each subsequent word. The names `gearRatio` and `currentGear` are prime examples of this convention. If your variable stores a constant value, such as `static final int NUM_GEARS = 6`, the convention changes slightly, capitalizing every letter and separating subsequent words with the underscore character. By convention, the underscore character is never used elsewhere.


Java Language Keywords
======================

Here is a list of keywords in the Java programming language. You cannot use any of the following as identifiers in your programs. The keywords `const` and `goto` are reserved, even though they are not currently used. `true`, `false`, and `null` might seem like keywords, but they are actually literals; you cannot use them as identifiers in your programs.

    `abstract`         `implements`        `try`
    `continue`         `protected`         `char`
    `for`              `throw`             `final`
    `new`              `byte`              `interface`
    `switch`           `else`              `static`
    `assert`‚ûå          `import`            `void`
    `default`          `public`            `class`
    `goto`‚ûä            `throws`            `finally`
    `package`          `case`              `long`
    `synchronized`     `enum`‚ûç             `strictfp`‚ûã
    `boolean`          `instanceof`        `volatile`
    `do`               `return`            `const`‚ûä
    `if`               `transient`         `float`
    `private`          `catch`             `native`
    `this`             `extends`           `super`
    `break`            `int`               `while`
    `double`           `short`

‚ûä not used
‚ûã added in 1.2
‚ûå added in 1.4
‚ûç added in 5.0


<a name="sec_2_2"></a>
## 2.2. [Primitive Data Types](#sec_2_2)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html 

The Java programming language is statically-typed, which means that all variables must first be declared before they can be used. This involves stating the variable's type and name, as you've already seen:

int gear = 1;

Doing so tells your program that a field named "gear" exists, holds numerical data, and has an initial value of "1". A variable's data type determines the values it may contain, plus the operations that may be performed on it. In addition to `int`, the Java programming language supports seven other _primitive data types_. A primitive type is predefined by the language and is named by a reserved keyword. Primitive values do not share state with other primitive values. The eight primitive data types supported by the Java programming language are:

*   **byte**: The `byte` data type is an 8-bit signed two's complement integer. It has a minimum value of -128 and a maximum value of 127 (inclusive). The `byte` data type can be useful for saving memory in large [arrays](arrays.html), where the memory savings actually matters. They can also be used in place of `int` where their limits help to clarify your code; the fact that a variable's range is limited can serve as a form of documentation.
    
*   **short**: The `short` data type is a 16-bit signed two's complement integer. It has a minimum value of -32,768 and a maximum value of 32,767 (inclusive). As with `byte`, the same guidelines apply: you can use a `short` to save memory in large arrays, in situations where the memory savings actually matters.
    
*   **int**: By default, the `int` data type is a 32-bit signed two's complement integer, which has a minimum value of -231 and a maximum value of 231\-1. In Java SE 8 and later, you can use the `int` data type to represent an unsigned 32-bit integer, which has a minimum value of 0 and a maximum value of 232\-1. Use the Integer class to use `int` data type as an unsigned integer. See the section The Number Classes for more information. Static methods like `compareUnsigned`, `divideUnsigned` etc have been added to the [`Integer`](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html) class to support the arithmetic operations for unsigned integers.
    
*   **long**: The `long` data type is a 64-bit two's complement integer. The signed long has a minimum value of -263 and a maximum value of 263\-1. In Java SE 8 and later, you can use the `long` data type to represent an unsigned 64-bit long, which has a minimum value of 0 and a maximum value of 264\-1. Use this data type when you need a range of values wider than those provided by `int`. The [`Long`](https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html) class also contains methods like `compareUnsigned`, `divideUnsigned` etc to support arithmetic operations for unsigned long.
    
*   **float**: The `float` data type is a single-precision 32-bit IEEE 754 floating point. Its range of values is beyond the scope of this discussion, but is specified in the [Floating-Point Types, Formats, and Values](https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.3) section of the Java Language Specification. As with the recommendations for `byte` and `short`, use a `float` (instead of `double`) if you need to save memory in large arrays of floating point numbers. This data type should never be used for precise values, such as currency. For that, you will need to use the [java.math.BigDecimal](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html) class instead. [Numbers and Strings](../data/index.html) covers `BigDecimal` and other useful classes provided by the Java platform.
    
*   **double**: The `double` data type is a double-precision 64-bit IEEE 754 floating point. Its range of values is beyond the scope of this discussion, but is specified in the [Floating-Point Types, Formats, and Values](https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.3) section of the Java Language Specification. For decimal values, this data type is generally the default choice. As mentioned above, this data type should never be used for precise values, such as currency.
    
*   **boolean**: The `boolean` data type has only two possible values: `true` and `false`. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its "size" isn't something that's precisely defined.
    
*   **char**: The `char` data type is a single 16-bit Unicode character. It has a minimum value of `'\u0000'` (or 0) and a maximum value of `'\uffff'` (or 65,535 inclusive).
    

In addition to the eight primitive data types listed above, the Java programming language also provides special support for character strings via the [java.lang.String](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html) class. Enclosing your character string within double quotes will automatically create a new `String` object; for example, `String s = "this is a string";`. `String` objects are _immutable_, which means that once created, their values cannot be changed. The `String` class is not technically a primitive data type, but considering the special support given to it by the language, you'll probably tend to think of it as such. You'll learn more about the `String` class in [Simple Data Objects](../data/index.html)

Default Values
--------------

It's not always necessary to assign a value when a field is declared. Fields that are declared but not initialized will be set to a reasonable default by the compiler. Generally speaking, this default will be zero or `null`, depending on the data type. Relying on such default values, however, is generally considered bad programming style.

The following chart summarizes the default values for the above data types.

| **Data Type** | **Default Value (for fields)** |
|---------------|--------------------------------|
| byte          | 0                              |
| short         | 0                              |
| int           | 0                              |
| long          | 0L                             |
| float         | 0.0f                           |
| double        | 0.0d                           |
| char          | '\u0000'                      |
| boolean       | false                          |
| String        | null                           |
| Object        | null                           |


Local variables are slightly different; the compiler never assigns a default value to an uninitialized local variable. If you cannot initialize your local variable where it is declared, make sure to assign it a value before you attempt to use it. Accessing an uninitialized local variable will result in a compile-time error.

### Literals

You may have noticed that the `new` keyword isn't used when initializing a variable of a primitive type. Primitive types are special data types built into the language; they are not objects created from a class. A _literal_ is the source code representation of a fixed value; literals are represented directly in your code without requiring computation. As shown below, it's possible to assign a literal to a variable of a primitive type:

boolean result = true;
char capitalC = 'C';
byte b = 100;
short s = 10000;
int i = 100000;

#### Integer Literals

An integer literal is of type `long` if it ends with the letter `L` or `l`; otherwise it is of type `int`. It is recommended that you use the upper case letter `L` because the lower case letter `l` is hard to distinguish from the digit `1`.

Values of the integral types `byte`, `short`, `int`, and `long` can be created from `int` literals. Values of type `long` that exceed the range of `int` can be created from `long` literals. Integer literals can be expressed by these number systems:

*   Decimal: Base 10, whose digits consists of the numbers 0 through 9; this is the number system you use every day
*   Hexadecimal: Base 16, whose digits consist of the numbers 0 through 9 and the letters A through F
*   Binary: Base 2, whose digits consists of the numbers 0 and 1 (you can create binary literals in Java SE 7 and later)

For general-purpose programming, the decimal system is likely to be the only number system you'll ever use. However, if you need to use another number system, the following example shows the correct syntax. The prefix `0x` indicates hexadecimal and `0b` indicates binary:

// The number 26, in decimal
int decVal = 26;
//  The number 26, in hexadecimal
int hexVal = 0x1a;
// The number 26, in binary
int binVal = 0b11010;

#### Floating-Point Literals

A floating-point literal is of type `float` if it ends with the letter `F` or `f`; otherwise its type is `double` and it can optionally end with the letter `D` or `d`.

The floating point types (`float` and `double`) can also be expressed using E or e (for scientific notation), F or f (32-bit float literal) and D or d (64-bit double literal; this is the default and by convention is omitted).

double d1 = 123.4;
// same value as d1, but in scientific notation
double d2 = 1.234e2;
float f1  = 123.4f;

#### Character and String Literals

Literals of types `char` and `String` may contain any Unicode (UTF-16) characters. If your editor and file system allow it, you can use such characters directly in your code. If not, you can use a "Unicode escape" such as `'\u0108'` (capital C with circumflex), or `"S\u00ED Se\u00F1or"` (S√≠ Se√±or in Spanish). Always use 'single quotes' for `char` literals and "double quotes" for `String` literals. Unicode escape sequences may be used elsewhere in a program (such as in field names, for example), not just in `char` or `String` literals.

The Java programming language also supports a few special escape sequences for `char` and `String` literals: `\b` (backspace), `\t` (tab), `\n` (line feed), `\f` (form feed), `\r` (carriage return), `\"` (double quote), `\'` (single quote), and `\` (backslash).

There's also a special `null` literal that can be used as a value for any reference type. `null` may be assigned to any variable, except variables of primitive types. There's little you can do with a `null` value beyond testing for its presence. Therefore, `null` is often used in programs as a marker to indicate that some object is unavailable.

Finally, there's also a special kind of literal called a _class literal_, formed by taking a type name and appending "`.class"`; for example, `String.class`. This refers to the object (of type `Class`) that represents the type itself.

Using Underscore Characters in Numeric Literals
-----------------------------------------------

In Java SE 7 and later, any number of underscore characters (`_`) can appear anywhere between digits in a numerical literal. This feature enables you, for example. to separate groups of digits in numeric literals, which can improve the readability of your code.

For instance, if your code contains numbers with many digits, you can use an underscore character to separate digits in groups of three, similar to how you would use a punctuation mark like a comma, or a space, as a separator.

The following example shows other ways you can use the underscore in numeric literals:

long creditCardNumber = 1234_5678_9012_3456L;
long socialSecurityNumber = 999_99_9999L;
float pi =  3.14_15F;
long hexBytes = 0xFF_EC_DE_5E;
long hexWords = 0xCAFE_BABE;
long maxLong = 0x7fff_ffff_ffff_ffffL;
byte nybbles = 0b0010_0101;
long bytes = 0b11010010_01101001_10010100_10010010;

You can place underscores only between digits; you cannot place underscores in the following places:

*   At the beginning or end of a number
*   Adjacent to a decimal point in a floating point literal
*   Prior to an `F` or `L` suffix
*   In positions where a string of digits is expected

The following examples demonstrate valid and invalid underscore placements (which are highlighted) in numeric literals:

// **Invalid: cannot put underscores**
// **adjacent to a decimal point**
float pi1 = 3_.1415F;
// **Invalid: cannot put underscores** 
// **adjacent to a decimal point**
float pi2 = 3._1415F;
// **Invalid: cannot put underscores** 
// **prior to an L suffix**
long socialSecurityNumber1 = 999_99_9999_L;

// OK (decimal literal)
int x1 = 5_2;
// **Invalid: cannot put underscores**
// **At the end of a literal**
int x2 = 52_;
// OK (decimal literal)
int x3 = 5‚ñÅ‚ñÅ_2;

// **Invalid: cannot put underscores**
// **in the 0x radix prefix**
int x4 = 0_x52;
// **Invalid: cannot put underscores**
// **at the beginning of a number**
int x5 = 0x_52;
// OK (hexadecimal literal)
int x6 = 0x5_2; 
// **Invalid: cannot put underscores**
// **at the end of a number**
int x7 = 0x52_;


<a name="sec_2_3"></a>
## 2.3. [Arrays](#sec_2_3)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html 

An _array_ is a container object that holds a fixed number of values of a single type. The length of an array is established when the array is created. After creation, its length is fixed. You have seen an example of arrays already, in the `main` method of the "Hello World!" application. This section discusses arrays in greater detail.

![Illustration of an array as 10 boxes numbered 0 through 9; an index of 0 indicates the first element in the array](https://docs.oracle.com/javase/tutorial/figures/java/objects-tenElementArray.gif)

An array of 10 elements.

  

Each item in an array is called an _element_, and each element is accessed by its numerical _index_. As shown in the preceding illustration, numbering begins with 0. The 9th element, for example, would therefore be accessed at index 8.

The following program, [`ArrayDemo`](https://docs.oracle.com/javase/tutorial/examples/ArrayDemo.java), creates an array of integers, puts some values in the array, and prints each value to standard output.

class ArrayDemo {
    public static void main(String[] args) {
        // declares an array of integers
        int[] anArray;

        // allocates memory for 10 integers
        anArray = new int[10];
           
        // initialize first element
        anArray[0] = 100;
        // initialize second element
        anArray[1] = 200;
        // and so forth
        anArray[2] = 300;
        anArray[3] = 400;
        anArray[4] = 500;
        anArray[5] = 600;
        anArray[6] = 700;
        anArray[7] = 800;
        anArray[8] = 900;
        anArray[9] = 1000;

        System.out.println("Element at index 0: "
                           + anArray[0]);
        System.out.println("Element at index 1: "
                           + anArray[1]);
        System.out.println("Element at index 2: "
                           + anArray[2]);
        System.out.println("Element at index 3: "
                           + anArray[3]);
        System.out.println("Element at index 4: "
                           + anArray[4]);
        System.out.println("Element at index 5: "
                           + anArray[5]);
        System.out.println("Element at index 6: "
                           + anArray[6]);
        System.out.println("Element at index 7: "
                           + anArray[7]);
        System.out.println("Element at index 8: "
                           + anArray[8]);
        System.out.println("Element at index 9: "
                           + anArray[9]);
    }
} 

The output from this program is:

Element at index 0: 100
Element at index 1: 200
Element at index 2: 300
Element at index 3: 400
Element at index 4: 500
Element at index 5: 600
Element at index 6: 700
Element at index 7: 800
Element at index 8: 900
Element at index 9: 1000

In a real-world programming situation, you would probably use one of the supported _looping constructs_ to iterate through each element of the array, rather than write each line individually as in the preceding example. However, the example clearly illustrates the array syntax. You will learn about the various looping constructs (`for`, `while`, and `do-while`) in the [Control Flow](flow.html) section.

Declaring a Variable to Refer to an Array
-----------------------------------------

The preceding program declares an array (named `anArray`) with the following line of code:

// declares an array of integers
int[] anArray;

Like declarations for variables of other types, an array declaration has two components: the array's type and the array's name. An array's type is written as `_type_[]`, where `_type_` is the data type of the contained elements; the brackets are special symbols indicating that this variable holds an array. The size of the array is not part of its type (which is why the brackets are empty). An array's name can be anything you want, provided that it follows the rules and conventions as previously discussed in the [naming](variables.html#naming) section. As with variables of other types, the declaration does not actually create an array; it simply tells the compiler that this variable will hold an array of the specified type.

Similarly, you can declare arrays of other types:

byte[] anArrayOfBytes;
short[] anArrayOfShorts;
long[] anArrayOfLongs;
float[] anArrayOfFloats;
double[] anArrayOfDoubles;
boolean[] anArrayOfBooleans;
char[] anArrayOfChars;
String[] anArrayOfStrings;

You can also place the brackets after the array's name:

// this form is discouraged
float anArrayOfFloats[];

However, convention discourages this form; the brackets identify the array type and should appear with the type designation.

Creating, Initializing, and Accessing an Array
----------------------------------------------

One way to create an array is with the `new` operator. The next statement in the `ArrayDemo` program allocates an array with enough memory for 10 integer elements and assigns the array to the `anArray` variable.

// create an array of integers
anArray = new int[10];

If this statement is missing, then the compiler prints an error like the following, and compilation fails:

ArrayDemo.java:4: Variable anArray may not have been initialized.

The next few lines assign values to each element of the array:

anArray[0] = 100; // initialize first element
anArray[1] = 200; // initialize second element
anArray[2] = 300; // and so forth

Each array element is accessed by its numerical index:

System.out.println("Element 1 at index 0: " + anArray[0]);
System.out.println("Element 2 at index 1: " + anArray[1]);
System.out.println("Element 3 at index 2: " + anArray[2]);

Alternatively, you can use the shortcut syntax to create and initialize an array:

int[] anArray = { 
    100, 200, 300,
    400, 500, 600, 
    700, 800, 900, 1000
};

Here the length of the array is determined by the number of values provided between braces and separated by commas.

You can also declare an array of arrays (also known as a _multidimensional_ array) by using two or more sets of brackets, such as `String[][] names`. Each element, therefore, must be accessed by a corresponding number of index values.

In the Java programming language, a multidimensional array is an array whose components are themselves arrays. This is unlike arrays in C or Fortran. A consequence of this is that the rows are allowed to vary in length, as shown in the following [`MultiDimArrayDemo`](https://docs.oracle.com/javase/tutorial/examples/MultiDimArrayDemo.java) program:

class MultiDimArrayDemo {
    public static void main(String[] args) {
        String[][] names = {
            {"Mr. ", "Mrs. ", "Ms. "},
            {"Smith", "Jones"}
        };
        // Mr. Smith
        System.out.println(names[0][0] + names[1][0]);
        // Ms. Jones
        System.out.println(names[0][2] + names[1][1]);
    }
}

The output from this program is:

Mr. Smith
Ms. Jones

Finally, you can use the built-in `length` property to determine the size of any array. The following code prints the array's size to standard output:

 System.out.println(anArray.length);

Copying Arrays
--------------

The `System` class has an `arraycopy` method that you can use to efficiently copy data from one array into another:

public static void arraycopy(Object src, int srcPos,
                             Object dest, int destPos, int length)

The two `Object` arguments specify the array to copy _from_ and the array to copy _to_. The three `int` arguments specify the starting position in the source array, the starting position in the destination array, and the number of array elements to copy.

The following program, [`ArrayCopyDemo`](https://docs.oracle.com/javase/tutorial/examples/ArrayCopyDemo.java), declares an array of `String` elements. It uses the `System.arraycopy` method to copy a subsequence of array components into a second array:

 
class ArrayCopyDemo {
    public static void main(String[] args) {
        String[] copyFrom = {
            "Affogato", "Americano", "Cappuccino", "Corretto", "Cortado",   
            "Doppio", "Espresso", "Frappucino", "Freddo", "Lungo", "Macchiato",      
            "Marocchino", "Ristretto" };
        
        String[] copyTo = new String[7];
        System.arraycopy(copyFrom, 2, copyTo, 0, 7);
        for (String coffee : copyTo) {
            System.out.print(coffee + " ");           
        }
    }
}

The output from this program is:

Cappuccino Corretto Cortado Doppio Espresso Frappucino Freddo 

Array Manipulations
-------------------

Arrays are a powerful and useful concept used in programming. Java SE provides methods to perform some of the most common manipulations related to arrays. For instance, the [`ArrayCopyDemo`](https://docs.oracle.com/javase/tutorial/examples/ArrayCopyDemo.java) example uses the `arraycopy` method of the `System` class instead of manually iterating through the elements of the source array and placing each one into the destination array. This is performed behind the scenes, enabling the developer to use just one line of code to call the method.

For your convenience, Java SE provides several methods for performing array manipulations (common tasks, such as copying, sorting and searching arrays) in the [`java.util.Arrays`](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html) class. For instance, the previous example can be modified to use the `copyOfRange` method of the `java.util.Arrays` class, as you can see in the [`ArrayCopyOfDemo`](https://docs.oracle.com/javase/tutorial/examples/ArrayCopyOfDemo.java) example. The difference is that using the `copyOfRange` method does not require you to create the destination array before calling the method, because the destination array is returned by the method:

class ArrayCopyOfDemo {
    public static void main(String[] args) {
        String[] copyFrom = {
            "Affogato", "Americano", "Cappuccino", "Corretto", "Cortado",   
            "Doppio", "Espresso", "Frappucino", "Freddo", "Lungo", "Macchiato",      
            "Marocchino", "Ristretto" };
        
        String[] copyTo = java.util.Arrays.copyOfRange(copyFrom, 2, 9);        
        for (String coffee : copyTo) {
            System.out.print(coffee + " ");           
        }            
    }
}

As you can see, the output from this program is the same, although it requires fewer lines of code. Note that the second parameter of the `copyOfRange` method is the initial index of the range to be copied, inclusively, while the third parameter is the final index of the range to be copied, _exclusively_. In this example, the range to be copied does not include the array element at index 9 (which contains the string `Lungo`).

Some other useful operations provided by methods in the `java.util.Arrays` class are:

*   Searching an array for a specific value to get the index at which it is placed (the `binarySearch` method).
    
*   Comparing two arrays to determine if they are equal or not (the `equals` method).
    
*   Filling an array to place a specific value at each index (the `fill` method).
    
*   Sorting an array into ascending order. This can be done either sequentially, using the `sort` method, or concurrently, using the `parallelSort` method introduced in Java SE 8. Parallel sorting of large arrays on multiprocessor systems is faster than sequential array sorting.
    
*   Creating a stream that uses an array as its source (the `stream` method). For example, the following statement prints the contents of the `copyTo` array in the same way as in the previous example:
    
    java.util.Arrays.stream(copyTo).map(coffee -> coffee + " ").forEach(System.out::print);  
    
    See [Aggregate Operations](../../collections/streams/index.html) for more information about streams.
    
*   Converting an array to a string. The `toString` method converts each element of the array to a string, separates them with commas, then surrounds them with brackets. For example, the following statement converts the `copyTo` array to a string and prints it:
    
    System.out.println(java.util.Arrays.toString(copyTo)); 
    
    This statement prints the following:
    
    [Cappuccino, Corretto, Cortado, Doppio, Espresso, Frappucino, Freddo] 

<a name="sec_2_4"></a>
## 2.4. [Summary of Variables](#sec_2_4)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variablesummary.html 

The Java programming language uses both "fields" and "variables" as part of its terminology. Instance variables (non-static fields) are unique to each instance of a class. Class variables (static fields) are fields declared with the `static` modifier; there is exactly one copy of a class variable, regardless of how many times the class has been instantiated. Local variables store temporary state inside a method. Parameters are variables that provide extra information to a method; both local variables and parameters are always classified as "variables" (not "fields"). When naming your fields or variables, there are rules and conventions that you should (or must) follow.

The eight primitive data types are: byte, short, int, long, float, double, boolean, and char. The [`java.lang.String`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html) class represents character strings. The compiler will assign a reasonable default value for fields of the above types; for local variables, a default value is never assigned. A literal is the source code representation of a fixed value. An array is a container object that holds a fixed number of values of a single type. The length of an array is established when the array is created. After creation, its length is fixed.

<a name="sec_2_5"></a>
## 2.5. [Questions and Exercises: Variables](#sec_2_5)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/QandE/questions_variables.html 

Questions
---------

1.  The term "instance variable" is another name for ‚ñÅ.
2.  The term "class variable" is another name for ‚ñÅ.
3.  A local variable stores temporary state; it is declared inside a ‚ñÅ.
4.  A variable declared within the opening and closing parenthesis of a method signature is called a ‚ñÅ_.
5.  What are the eight primitive data types supported by the Java programming language?
6.  Character strings are represented by the class ‚ñÅ.
7.  An ‚ñÅ is a container object that holds a fixed number of values of a single type.

Exercises
---------

1.  Create a small program that defines some fields. Try creating some illegal field names and see what kind of error the compiler produces. Use the naming rules and conventions as a guide.
2.  In the program you created in Exercise 1, try leaving the fields uninitialized and print out their values. Try the same with a local variable and see what kind of compiler errors you can produce. Becoming familiar with common compiler errors will make it easier to recognize bugs in your code.

[Check your answers](answers_variables.html)


Answers to Questions 1
--------------------

1.  The term "instance variable" is another name for **non-static field**.
2.  The term "class variable" is another name for **static field**.
3.  A local variable stores temporary state; it is declared inside a **method**.
4.  A variable declared within the opening and closing parenthesis of a method is called a **parameter**.
5.  What are the eight primitive data types supported by the Java programming language? **byte, short, int, long, float, double, boolean, char**
6.  Character strings are represented by the class **java.lang.String**.
7.  An **array** is a container object that holds a fixed number of values of a single type.

Answers to Exercises 2
--------------------

1.  Create a small program that defines some fields. Try creating some illegal field names and see what kind of error the compiler produces. Use the naming rules and conventions as a guide.
    
    There is no single correct answer here. Your results will vary depending on your code.
    
2.  In the program you created in Exercise 1, try leaving the fields uninitialized and print out their values. Try the same with a local variable and see what kind of compiler errors you can produce. Becoming familiar with common compiler errors will make it easier to recognize bugs in your code.
    
    Again, there is no single correct answer for this exercise. Your results will vary depending on your code.

<a name="sec_2_6"></a>
## 2.6. [Operators](#sec_2_6)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html 

Now that you've learned how to declare and initialize variables, you probably want to know how to _do something_ with them. Learning the operators of the Java programming language is a good place to start. Operators are special symbols that perform specific operations on one, two, or three _operands_, and then return a result.

As we explore the operators of the Java programming language, it may be helpful for you to know ahead of time which operators have the highest precedence. The operators in the following table are listed according to precedence order. The closer to the top of the table an operator appears, the higher its precedence. Operators with higher precedence are evaluated before operators with relatively lower precedence. Operators on the same line have equal precedence. When operators of equal precedence appear in the same expression, a rule must govern which is evaluated first. All binary operators except for the assignment operators are evaluated from left to right; assignment operators are evaluated right to left.

**Operator Precedence** 

     postfix               `_expr_++ _expr_--`
     unary                 `++_expr_ --_expr_ +_expr_ -_expr_ ~ !`
     multiplicative        `* / %`
     additive              `+ -`
     shift                 `<< >> >>>`
     relational            `< > <= >= instanceof`
     equality              `== !=`
     bitwise AND           `&`
     bitwise exclusive OR  `^`
     bitwise inclusive OR  `|`
     logical AND           `&&`
     logical OR            `||`
     ternary               `? :`
     assignment            `= += -= *= /= %= &= ^= |= <<= >>= >>>=`
  
In general-purpose programming, certain operators tend to appear more frequently than others; for example, the assignment operator "`=`" is far more common than the unsigned right shift operator "`>>>`". With that in mind, the following discussion focuses first on the operators that you're most likely to use on a regular basis, and ends focusing on those that are less common. Each discussion is accompanied by sample code that you can compile and run. Studying its output will help reinforce what you've just learned.

<a name="sec_2_7"></a>
## 2.7. [Assignment, Arithmetic, and Unary Operators](#sec_2_7)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op1.html 

The Simple Assignment Operator
------------------------------

One of the most common operators that you'll encounter is the simple assignment operator "`=`". You saw this operator in the Bicycle class; it assigns the value on its right to the operand on its left:

 int cadence = 0;
 int speed = 0;
 int gear = 1;

This operator can also be used on objects to assign _object references_, as discussed in [Creating Objects](../javaOO/objectcreation.html).

The Arithmetic Operators
------------------------

The Java programming language provides operators that perform addition, subtraction, multiplication, and division. There's a good chance you'll recognize them by their counterparts in basic mathematics. The only symbol that might look new to you is "`%`", which divides one operand by another and returns the remainder as its result.

| Operator | Description |
|----------|-------------|
| `+` | Additive operator (also used for String concatenation)
| `-` | Subtraction operator
| `*` | Multiplication operator
| `/` | Division operator
| `%` | Remainder operator

The following program, [`ArithmeticDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ArithmeticDemo.java), tests the arithmetic operators.

class ArithmeticDemo {

    public static void main (String[] args) {

        int result = 1 + 2;
        // result is now 3
        System.out.println("1 + 2 = " + result);
        int original_result = result;

        result = result - 1;
        // result is now 2
        System.out.println(original_result + " - 1 = " + result);
        original_result = result;

        result = result * 2;
        // result is now 4
        System.out.println(original_result + " * 2 = " + result);
        original_result = result;

        result = result / 2;
        // result is now 2
        System.out.println(original_result + " / 2 = " + result);
        original_result = result;

        result = result + 8;
        // result is now 10
        System.out.println(original_result + " + 8 = " + result);
        original_result = result;

        result = result % 7;
        // result is now 3
        System.out.println(original_result + " % 7 = " + result);
    }
}

This program prints the following:

1 + 2 = 3
3 - 1 = 2
2 * 2 = 4
4 / 2 = 2
2 + 8 = 10
10 % 7 = 3

You can also combine the arithmetic operators with the simple assignment operator to create _compound assignments_. For example, `x+=1;` and `x=x+1;` both increment the value of `x` by 1.

The `+` operator can also be used for concatenating (joining) two strings together, as shown in the following [`ConcatDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ConcatDemo.java) program:

class ConcatDemo {
    public static void main(String[] args){
        String firstString = "This is";
        String secondString = " a concatenated string.";
        String thirdString = firstString+secondString;
        System.out.println(thirdString);
    }
}

By the end of this program, the variable `thirdString` contains "This is a concatenated string.", which gets printed to standard output.

The Unary Operators
-------------------

The unary operators require only one operand; they perform various operations such as incrementing/decrementing a value by one, negating an expression, or inverting the value of a boolean.

| Operator | Description |
|----------|-------------|
| `+` | Unary plus operator; indicates positive value (numbers are positive without this, however)
| `-` | Unary minus operator; negates an expression
| `++`| Increment operator; increments a value by 1
| `--`| Decrement operator; decrements a value by 1
| `!` | Logical complement operator; inverts the value of a boolean

The following program, [`UnaryDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/UnaryDemo.java), tests the unary operators:

class UnaryDemo {

    public static void main(String[] args) {

        int result = +1;
        // result is now 1
        System.out.println(result);

        result--;
        // result is now 0
        System.out.println(result);

        result++;
        // result is now 1
        System.out.println(result);

        result = -result;
        // result is now -1
        System.out.println(result);

        boolean success = false;
        // false
        System.out.println(success);
        // true
        System.out.println(!success);
    }
}

The increment/decrement operators can be applied before (prefix) or after (postfix) the operand. The code `result++;` and `++result;` will both end in `result` being incremented by one. The only difference is that the prefix version (`++result`) evaluates to the incremented value, whereas the postfix version (`result++`) evaluates to the original value. If you are just performing a simple increment/decrement, it doesn't really matter which version you choose. But if you use this operator in part of a larger expression, the one that you choose may make a significant difference.

The following program, [`PrePostDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/PrePostDemo.java), illustrates the prefix/postfix unary increment operator:

class PrePostDemo {
    public static void main(String[] args){
        int i = 3;
        i++;
        // prints 4
        System.out.println(i);
        ++i;               
        // prints 5
        System.out.println(i);
        // prints 6
        System.out.println(++i);
        // prints 6
        System.out.println(i++);
        // prints 7
        System.out.println(i);
    }
}


<a name="sec_2_8"></a>
## 2.8. [Equality, Relational, and Conditional Operators](#sec_2_8)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op2.html 

The Equality and Relational Operators
-------------------------------------

The equality and relational operators determine if one operand is greater than, less than, equal to, or not equal to another operand. The majority of these operators will probably look familiar to you as well. Keep in mind that you must use "`==`", not "`=`", when testing if two primitive values are equal.

    \==      equal to
    !=      not equal to
    >       greater than
    >=      greater than or equal to
    <       less than
    <=      less than or equal to

The following program, [`ComparisonDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ComparisonDemo.java), tests the comparison operators:

class ComparisonDemo {

    public static void main(String[] args){
        int value1 = 1;
        int value2 = 2;
        if(value1 == value2)
            System.out.println("value1 == value2");
        if(value1 != value2)
            System.out.println("value1 != value2");
        if(value1 > value2)
            System.out.println("value1 > value2");
        if(value1 < value2)
            System.out.println("value1 < value2");
        if(value1 <= value2)
            System.out.println("value1 <= value2");
    }
}

Output:

value1 != value2
value1 <  value2
value1 <= value2

The Conditional Operators
-------------------------

The `&&` and `||` operators perform _Conditional-AND_ and _Conditional-OR_ operations on two boolean expressions. These operators exhibit "short-circuiting" behavior, which means that the second operand is evaluated only if needed.

    && Conditional-AND
    || Conditional-OR

The following program, [`ConditionalDemo1`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ConditionalDemo1.java), tests these operators:

class ConditionalDemo1 {

    public static void main(String[] args){
        int value1 = 1;
        int value2 = 2;
        if((value1 == 1) && (value2 == 2))
            System.out.println("value1 is 1 AND value2 is 2");
        if((value1 == 1) || (value2 == 1))
            System.out.println("value1 is 1 OR value2 is 1");
    }
}

Another conditional operator is `?:`, which can be thought of as shorthand for an `if-then-else` statement (discussed in the [Control Flow Statements](flow.html) section of this lesson). This operator is also known as the _ternary operator_ because it uses three operands. In the following example, this operator should be read as: "If `someCondition` is `true`, assign the value of `value1` to `result`. Otherwise, assign the value of `value2` to `result`."

The following program, [`ConditionalDemo2`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ConditionalDemo2.java), tests the `?:` operator:

class ConditionalDemo2 {

    public static void main(String[] args){
        int value1 = 1;
        int value2 = 2;
        int result;
        boolean someCondition = true;
        result = someCondition ? value1 : value2;

        System.out.println(result);
    }
}

Because `someCondition` is true, this program prints "1" to the screen. Use the `?:` operator instead of an `if-then-else` statement if it makes your code more readable; for example, when the expressions are compact and without side-effects (such as assignments).

The Type Comparison Operator instanceof
---------------------------------------

The `instanceof` operator compares an object to a specified type. You can use it to test if an object is an instance of a class, an instance of a subclass, or an instance of a class that implements a particular interface.

The following program, [`InstanceofDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/InstanceofDemo.java), defines a parent class (named `Parent`), a simple interface (named `MyInterface`), and a child class (named `Child`) that inherits from the parent and implements the interface.

class InstanceofDemo {
    public static void main(String[] args) {

        Parent obj1 = new Parent();
        Parent obj2 = new Child();

        System.out.println("obj1 instanceof Parent: "
            + (obj1 instanceof Parent));
        System.out.println("obj1 instanceof Child: "
            + (obj1 instanceof Child));
        System.out.println("obj1 instanceof MyInterface: "
            + (obj1 instanceof MyInterface));
        System.out.println("obj2 instanceof Parent: "
            + (obj2 instanceof Parent));
        System.out.println("obj2 instanceof Child: "
            + (obj2 instanceof Child));
        System.out.println("obj2 instanceof MyInterface: "
            + (obj2 instanceof MyInterface));
    }
}

class Parent {}
class Child extends Parent implements MyInterface {}
interface MyInterface {}

Output:

obj1 instanceof Parent: true
obj1 instanceof Child: false
obj1 instanceof MyInterface: false
obj2 instanceof Parent: true
obj2 instanceof Child: true
obj2 instanceof MyInterface: true

When using the `instanceof` operator, keep in mind that `null` is not an instance of anything.


<a name="sec_2_9"></a>
## 2.9. [Bitwise and Bit Shift Operators](#sec_2_9)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html 

The Java programming language also provides operators that perform bitwise and bit shift operations on integral types. The operators discussed in this section are less commonly used. Therefore, their coverage is brief; the intent is to simply make you aware that these operators exist.

The unary bitwise complement operator "`~`" inverts a bit pattern; it can be applied to any of the integral types, making every "0" a "1" and every "1" a "0". For example, a `byte` contains 8 bits; applying this operator to a value whose bit pattern is "00000000" would change its pattern to "11111111".

The signed left shift operator "`<<`" shifts a bit pattern to the left, and the signed right shift operator "`>>`" shifts a bit pattern to the right. The bit pattern is given by the left-hand operand, and the number of positions to shift by the right-hand operand. The unsigned right shift operator "`>>>`" shifts a zero into the leftmost position, while the leftmost position after `">>"` depends on sign extension.

The bitwise `&` operator performs a bitwise AND operation.

The bitwise `^` operator performs a bitwise exclusive OR operation.

The bitwise `|` operator performs a bitwise inclusive OR operation.

The following program, [`BitDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/BitDemo.java), uses the bitwise AND operator to print the number "2" to standard output.

class BitDemo {
    public static void main(String[] args) {
        int bitmask = 0x000F;
        int val = 0x2222;
        // prints "2"
        System.out.println(val & bitmask);
    }
}

<a name="sec_2_10"></a>
## 2.10. [Summary of Operators](#sec_2_10)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html 

The following quick reference summarizes the operators supported by the Java programming language.

Simple Assignment Operator
--------------------------

\=       Simple assignment operator

Arithmetic Operators
--------------------

\+       Additive operator (also used
        for String concatenation)
-       Subtraction operator
*       Multiplication operator
/       Division operator
%       Remainder operator

Unary Operators
---------------

\+       Unary plus operator; indicates
        positive value (numbers are 
        positive without this, however)
-       Unary minus operator; negates
        an expression
++      Increment operator; increments
        a value by 1
--      Decrement operator; decrements
        a value by 1
!       Logical complement operator;
        inverts the value of a boolean

Equality and Relational Operators
---------------------------------

\==      Equal to
!=      Not equal to
>       Greater than
>=      Greater than or equal to
<       Less than
<=      Less than or equal to

Conditional Operators
---------------------

&&      Conditional-AND
||      Conditional-OR
?:      Ternary (shorthand for 
        `if-then-else` statement)

Type Comparison Operator
------------------------

instanceof      Compares an object to 
                a specified type 

Bitwise and Bit Shift Operators
-------------------------------

~       Unary bitwise complement
<<      Signed left shift
>>      Signed right shift
>>>     Unsigned right shift
&       Bitwise AND
^       Bitwise exclusive OR
|       Bitwise inclusive OR

<a name="sec_2_11"></a>
## 2.11. [Questions and Exercises: Operators](#sec_2_11)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/QandE/questions_operators.html 

Questions
---------

1.  Consider the following code snippet.
    
    arrayOfInts[j] > arrayOfInts[j+1]
    
    Which operators does the code contain?
2.  Consider the following code snippet.
    
    int i = 10;
    int n = i++%5;
    
    1.  What are the values of `i` and `n` after the code is executed?
    2.  What are the final values of `i` and `n` if instead of using the postfix increment operator (`i++`), you use the prefix version (`++i)`)?
3.  To invert the value of a `boolean`, which operator would you use?
4.  Which operator is used to compare two values, `=` or `==` ?
5.  Explain the following code sample: `result = someCondition ? value1 : value2;`

Exercises
---------

1.  Change the following program to use compound assignments:
    
    class ArithmeticDemo {
    
         public static void main (String[] args){
              
              int result = 1 + 2; // result is now 3
              System.out.println(result);
    
              result = result - 1; // result is now 2
              System.out.println(result);
    
              result = result * 2; // result is now 4
              System.out.println(result);
    
              result = result / 2; // result is now 2
              System.out.println(result);
    
              result = result + 8; // result is now 10
              result = result % 7; // result is now 3
              System.out.println(result);
         }
    }
    
2.  In the following program, explain why the value "6" is printed twice in a row:
    
    class PrePostDemo {
        public static void main(String[] args){
            int i = 3;
            i++;
            System.out.println(i);    // "4"
            ++i;                     
            System.out.println(i);    // "5"
            System.out.println(++i);  // "6"
            System.out.println(i++);  // "6"
            System.out.println(i);    // "7"
        }
    }
    
Answers to Questions and Exercises: Operators
=======================================================================

Questions
---------

1.  Consider the following code snippet:
    
    arrayOfInts[j] > arrayOfInts[j+1]
    
    **Question:** What operators does the code contain?  
    **Answer:** `>`, `+`  
      
    
2.  Consider the following code snippet:
    
    int i = 10;
    int n = i++%5;
    
    1.  **Question:** What are the values of `i` and `n` after the code is executed?  
        **Answer:** `i` is 11, and `n` is 0.  
          
        
    2.  **Question:** What are the final values of `i` and `n` if instead of using the postfix increment operator (`i++`), you use the prefix version (`++i)`)?  
        **Answer:** `i` is 11, and `n` is 1.  
          
        
3.  **Question:** To invert the value of a `boolean`, which operator would you use?  
    **Answer:** The logical complement operator "!".
4.  **Question**: Which operator is used to compare two values, `=` or `==` ?  
    **Answer:** The `==` operator is used for comparison, and `=` is used for assignment.
5.  **Question:** Explain the following code sample: `result = someCondition ? value1 : value2;`  
    **Answer:** This code should be read as: "If `someCondition` is `true`, assign the value of `value1` to `result`. Otherwise, assign the value of `value2` to `result`."

Exercises
---------

1.  Change the following program to use compound assignments:
    
```java
    class ArithmeticDemo {
    
        public static void main (String[] args){
              
            int result = 1 + 2; // result is now 3
            System.out.println(result);
    
            result = result - 1; // result is now 2
            System.out.println(result);
    
            result = result * 2; // result is now 4
            System.out.println(result);
    
            result = result / 2; // result is now 2
            System.out.println(result);
    
            result = result + 8; // result is now 10
            result = result % 7; // result is now 3
            System.out.println(result);
    
        }
    }
    
    Here is one solution:
    
    class ArithmeticDemo {
    
        public static void main (String[] args){
            int result = 3;
            System.out.println(result);
    
            result -= 1; // result is now 2
            System.out.println(result);
    
            result *= 2; // result is now 4
            System.out.println(result);
    
            result /= 2; // result is now 2
            System.out.println(result);
    
            result += 8; // result is now 10
            result %= 7; // result is now 3
            System.out.println(result);
    
        }
    }
```
    
2.  In the following program, explain why the value "6" is printed twice in a row:
    
    class PrePostDemo {
        public static void main(String[] args){
            int i = 3;
            i++;
            System.out.println(i);    // "4"
            ++i;                     
            System.out.println(i);    // "5"
            System.out.println(++i);  // "6"
            System.out.println(i++);  // "6"
            System.out.println(i);    // "7"
        }
    }
    
    The code `System.out.println(++i);` evaluates to 6, because the prefix version of `++` evaluates to the incremented value. The next line, `System.out.println(i++);` evaluates to the current value (6), then increments by one. So "7" doesn't get printed until the next line.


<a name="sec_2_12"></a>
## 2.12. [Expressions, Statements, and Blocks](#sec_2_12)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/expressions.html 

Now that you understand variables and operators, it's time to learn about _expressions_, _statements_, and _blocks_. Operators may be used in building expressions, which compute values; expressions are the core components of statements; statements may be grouped into blocks.

Expressions
-----------

An _expression_ is a construct made up of variables, operators, and method invocations, which are constructed according to the syntax of the language, that evaluates to a single value. You've already seen examples of expressions, illustrated in bold below:

    int cadence = 0;

The data type of the value returned by an expression depends on the elements used in the expression. The expression `cadence = 0` returns an `int` because the assignment operator returns a value of the same data type as its left-hand operand; in this case, `cadence` is an `int`. As you can see from the other expressions, an expression can return other types of values as well, such as `boolean` or `String`.

The Java programming language allows you to construct compound expressions from various smaller expressions as long as the data type required by one part of the expression matches the data type of the other. Here's an example of a compound expression:

    1 * 2 * 3

In this particular example, the order in which the expression is evaluated is unimportant because the result of multiplication is independent of order; the outcome is always the same, no matter in which order you apply the multiplications. However, this is not true of all expressions. For example, the following expression gives different results, depending on whether you perform the addition or the division operation first:

    x + y / 100    // ambiguous

You can specify exactly how an expression will be evaluated using balanced parenthesis: ( and ). For example, to make the previous expression unambiguous, you could write the following:

 
    (x + y) / 100  // unambiguous, recommended

If you don't explicitly indicate the order for the operations to be performed, the order is determined by the precedence assigned to the operators in use within the expression. Operators that have a higher precedence get evaluated first. For example, the division operator has a higher precedence than does the addition operator. Therefore, the following two statements are equivalent:

    x + y / 100   

    x + (y / 100) // unambiguous, recommended

When writing compound expressions, be explicit and indicate with parentheses which operators should be evaluated first. This practice makes code easier to read and to maintain.

Statements
----------

Statements are roughly equivalent to sentences in natural languages. A _statement_ forms a complete unit of execution. The following types of expressions can be made into a statement by terminating the expression with a semicolon (`;`).

*   Assignment expressions
*   Any use of `++` or `--`
*   Method invocations
*   Object creation expressions

Such statements are called _expression statements_. Here are some examples of expression statements.

// assignment statement
aValue = 8933.234;
// increment statement
aValue++;
// method invocation statement
System.out.println("Hello World!");
// object creation statement
Bicycle myBike = new Bicycle();

In addition to expression statements, there are two other kinds of statements: _declaration statements_ and _control flow statements_. A _declaration statement_ declares a variable. You've seen many examples of declaration statements already:

// declaration statement
double aValue = 8933.234;

Finally, _control flow statements_ regulate the order in which statements get executed. You'll learn about control flow statements in the next section, [Control Flow Statements](flow.html)

Blocks
------

A _block_ is a group of zero or more statements between balanced braces and can be used anywhere a single statement is allowed. The following example, [`BlockDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/BlockDemo.java), illustrates the use of blocks:

class BlockDemo {
     public static void main(String[] args) {
          boolean condition = true;
          if (condition) { **// begin block 1**
               System.out.println("Condition is true.");
          } **// end block one**
          else { **// begin block 2**
               System.out.println("Condition is false.");
          } **// end block 2**
     }
}

<a name="sec_2_13"></a>
## 2.13. [Questions and Exercises: Expressions, Statements, and Blocks](#sec_2_13)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/QandE/questions_expressions.html 

Questions
---------

1.  Operators may be used in building ‚ñÅ, which compute values.
2.  Expressions are the core components of ‚ñÅ.
3.  Statements may be grouped into ‚ñÅ.
4.  The following code snippet is an example of a ‚ñÅ expression.
    
     1 * 2 * 3
    
5.  Statements are roughly equivalent to sentences in natural languages, but instead of ending with a period, a statement ends with a ‚ñÅ.
6.  A block is a group of zero or more statements between balanced ‚ñÅ and can be used anywhere a single statement is allowed.

Exercises
---------

Identify the following kinds of expression statements:

*   `aValue = 8933.234;`
*   `aValue++;`
*   `System.out.println("Hello World!");`
*   `Bicycle myBike = new Bicycle();`

Answers to Questions and Exercises: Expressions, Statements, and Blocks
=======================================================================

Questions
---------

1.  Operators may be used in building **expressions**, which compute values.
2.  Expressions are the core components of **statements**.
3.  Statements may be grouped into **blocks**.
4.  The following code snippet is an example of a **compound** expression.
    
     1 * 2 * 3
    
5.  Statements are roughly equivalent to sentences in natural languages, but instead of ending with a period, a statement ends with a **semicolon**.
6.  A block is a group of zero or more statements between balanced **braces** and can be used anywhere a single statement is allowed.

Exercises
---------

Identify the following kinds of expression statements:

*   `aValue = 8933.234; **// assignment statement**`
*   `aValue++; // **increment statement**`
*   `System.out.println("Hello World!"); **// method invocation statement**`
*   `Bicycle myBike = new Bicycle(); **// object creation statement**`

<a name="sec_2_14"></a>
## 2.14. [Control Flow Statements](#sec_2_14)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/flow.html 

The statements inside your source files are generally executed from top to bottom, in the order that they appear. _Control flow statements_, however, break up the flow of execution by employing decision making, looping, and branching, enabling your program to _conditionally_ execute particular blocks of code. This section describes the decision-making statements (`if-then`, `if-then-else`, `switch`), the looping statements (`for`, `while`, `do-while`), and the branching statements (`break`, `continue`, `return`) supported by the Java programming language.

<a name="sec_2_15"></a>
## 2.15. [The if-then and if-then-else Statements](#sec_2_15)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/if.html 

The `if-then` Statement
-----------------------

The `if-then` statement is the most basic of all the control flow statements. It tells your program to execute a certain section of code _only if_ a particular test evaluates to `true`. For example, the `Bicycle` class could allow the brakes to decrease the bicycle's speed _only if_ the bicycle is already in motion. One possible implementation of the `applyBrakes` method could be as follows:

void applyBrakes() {
    // the "if" clause: bicycle must be moving
    if (isMoving){ 
        // the "then" clause: decrease current speed
        currentSpeed--;
    }
}

If this test evaluates to `false` (meaning that the bicycle is not in motion), control jumps to the end of the `if-then` statement.

In addition, the opening and closing braces are optional, provided that the "then" clause contains only one statement:

void applyBrakes() {
    // same as above, but without braces 
    if (isMoving)
        currentSpeed--;
}

Deciding when to omit the braces is a matter of personal taste. Omitting them can make the code more brittle. If a second statement is later added to the "then" clause, a common mistake would be forgetting to add the newly required braces. The compiler cannot catch this sort of error; you'll just get the wrong results.

The `if-then-else` Statement
----------------------------

The `if-then-else` statement provides a secondary path of execution when an "if" clause evaluates to `false`. You could use an `if-then-else` statement in the `applyBrakes` method to take some action if the brakes are applied when the bicycle is not in motion. In this case, the action is to simply print an error message stating that the bicycle has already stopped.

void applyBrakes() {
    if (isMoving) {
        currentSpeed--;
    } else {
        System.err.println("The bicycle has already stopped!");
    } 
}

The following program, [`IfElseDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/IfElseDemo.java), assigns a grade based on the value of a test score: an A for a score of 90% or above, a B for a score of 80% or above, and so on.

class IfElseDemo {
    public static void main(String[] args) {

        int testscore = 76;
        char grade;

        if (testscore >= 90) {
            grade = 'A';
        } else if (testscore >= 80) {
            grade = 'B';
        } else if (testscore >= 70) {
            grade = 'C';
        } else if (testscore >= 60) {
            grade = 'D';
        } else {
            grade = 'F';
        }
        System.out.println("Grade = " + grade);
    }
}

The output from the program is:

    Grade = C

You may have noticed that the value of `testscore` can satisfy more than one expression in the compound statement: `76 >= 70` and `76 >= 60`. However, once a condition is satisfied, the appropriate statements are executed `(grade = 'C';)` and the remaining conditions are not evaluated.

<a name="sec_2_16"></a>
## 2.16. [The switch Statement](#sec_2_16)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html 

Unlike `if-then` and `if-then-else` statements, the `switch` statement can have a number of possible execution paths. A `switch` works with the `byte`, `short`, `char`, and `int` primitive data types. It also works with _enumerated types_ (discussed in [Enum Types](../javaOO/enum.html)), the [`String`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html) class, and a few special classes that wrap certain primitive types: [`Character`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html), [`Byte`](https://docs.oracle.com/javase/8/docs/api/java/lang/Byte.html), [`Short`](https://docs.oracle.com/javase/8/docs/api/java/lang/Short.html), and [`Integer`](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html) (discussed in [Numbers and Strings](../data/index.html)).

The following code example, [`SwitchDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/SwitchDemo.java), declares an `int` named `month` whose value represents a month. The code displays the name of the month, based on the value of `month`, using the `switch` statement.

public class SwitchDemo {
    public static void main(String[] args) {

        int month = 8;
        String monthString;
        switch (month) {
            case 1:  monthString = "January";
                     break;
            case 2:  monthString = "February";
                     break;
            case 3:  monthString = "March";
                     break;
            case 4:  monthString = "April";
                     break;
            case 5:  monthString = "May";
                     break;
            case 6:  monthString = "June";
                     break;
            case 7:  monthString = "July";
                     break;
            case 8:  monthString = "August";
                     break;
            case 9:  monthString = "September";
                     break;
            case 10: monthString = "October";
                     break;
            case 11: monthString = "November";
                     break;
            case 12: monthString = "December";
                     break;
            default: monthString = "Invalid month";
                     break;
        }
        System.out.println(monthString);
    }
}

In this case, `August` is printed to standard output.

The body of a `switch` statement is known as a _switch block_. A statement in the `switch` block can be labeled with one or more `case` or `default` labels. The `switch` statement evaluates its expression, then executes all statements that follow the matching `case` label.

You could also display the name of the month with `if-then-else` statements:

int month = 8;
if (month == 1) {
    System.out.println("January");
} else if (month == 2) {
    System.out.println("February");
}
...  // and so on

Deciding whether to use `if-then-else` statements or a `switch` statement is based on readability and the expression that the statement is testing. An `if-then-else` statement can test expressions based on ranges of values or conditions, whereas a `switch` statement tests expressions based only on a single integer, enumerated value, or `String` object.

Another point of interest is the `break` statement. Each `break` statement terminates the enclosing `switch` statement. Control flow continues with the first statement following the `switch` block. The `break` statements are necessary because without them, statements in `switch` blocks _fall through_: All statements after the matching `case` label are executed in sequence, regardless of the expression of subsequent `case` labels, until a `break` statement is encountered. The program [`SwitchDemoFallThrough`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/SwitchDemoFallThrough.java) shows statements in a `switch` block that fall through. The program displays the month corresponding to the integer `month` and the months that follow in the year:

public class SwitchDemoFallThrough {

    public static void main(String[] args) {
        java.util.ArrayList<String> futureMonths =
            new java.util.ArrayList<String>();

        int month = 8;

        switch (month) {
            case 1:  futureMonths.add("January");
            case 2:  futureMonths.add("February");
            case 3:  futureMonths.add("March");
            case 4:  futureMonths.add("April");
            case 5:  futureMonths.add("May");
            case 6:  futureMonths.add("June");
            case 7:  futureMonths.add("July");
            case 8:  futureMonths.add("August");
            case 9:  futureMonths.add("September");
            case 10: futureMonths.add("October");
            case 11: futureMonths.add("November");
            case 12: futureMonths.add("December");
                     break;
            default: break;
        }

        if (futureMonths.isEmpty()) {
            System.out.println("Invalid month number");
        } else {
            for (String monthName : futureMonths) {
               System.out.println(monthName);
            }
        }
    }
}

This is the output from the code:

August
September
October
November
December

Technically, the final `break` is not required because flow falls out of the `switch` statement. Using a `break` is recommended so that modifying the code is easier and less error prone. The `default` section handles all values that are not explicitly handled by one of the `case` sections.

The following code example, [`SwitchDemo2`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/SwitchDemo2.java), shows how a statement can have multiple `case` labels. The code example calculates the number of days in a particular month:

class SwitchDemo2 {
    public static void main(String[] args) {

        int month = 2;
        int year = 2000;
        int numDays = 0;

        switch (month) {
            case 1: case 3: case 5:
            case 7: case 8: case 10:
            case 12:
                numDays = 31;
                break;
            case 4: case 6:
            case 9: case 11:
                numDays = 30;
                break;
            case 2:
                if (((year % 4 == 0) && 
                     !(year % 100 == 0))
                     || (year % 400 == 0))
                    numDays = 29;
                else
                    numDays = 28;
                break;
            default:
                System.out.println("Invalid month.");
                break;
        }
        System.out.println("Number of Days = "
                           + numDays);
    }
}

This is the output from the code:

Number of Days = 29

Using Strings in switch Statements
----------------------------------

In Java SE 7 and later, you can use a `String` object in the `switch` statement's expression. The following code example, [`StringSwitchDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/StringSwitchDemo.java), displays the number of the month based on the value of the `String` named `month`:

public class StringSwitchDemo {

    public static int getMonthNumber(String month) {

        int monthNumber = 0;

        if (month == null) {
            return monthNumber;
        }

        switch (month.toLowerCase()) {
            case "january":
                monthNumber = 1;
                break;
            case "february":
                monthNumber = 2;
                break;
            case "march":
                monthNumber = 3;
                break;
            case "april":
                monthNumber = 4;
                break;
            case "may":
                monthNumber = 5;
                break;
            case "june":
                monthNumber = 6;
                break;
            case "july":
                monthNumber = 7;
                break;
            case "august":
                monthNumber = 8;
                break;
            case "september":
                monthNumber = 9;
                break;
            case "october":
                monthNumber = 10;
                break;
            case "november":
                monthNumber = 11;
                break;
            case "december":
                monthNumber = 12;
                break;
            default: 
                monthNumber = 0;
                break;
        }

        return monthNumber;
    }

    public static void main(String[] args) {

        String month = "August";

        int returnedMonthNumber =
            StringSwitchDemo.getMonthNumber(month);

        if (returnedMonthNumber == 0) {
            System.out.println("Invalid month");
        } else {
            System.out.println(returnedMonthNumber);
        }
    }
}

The output from this code is `8`.

The `String` in the `switch` expression is compared with the expressions associated with each `case` label as if the [`String.equals`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#equals-java.lang.Object-) method were being used. In order for the `StringSwitchDemo` example to accept any month regardless of case, `month` is converted to lowercase (with the [`toLowerCase`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toLowerCase--) method), and all the strings associated with the `case` labels are in lowercase.

**Note**: This example checks if the expression in the `switch` statement is `null`. Ensure that the expression in any `switch` statement is not null to prevent a `NullPointerException` from being thrown.

<a name="sec_2_17"></a>
## 2.17. [The while and do-while Statements](#sec_2_17)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/while.html 

The `while` statement continually executes a block of statements while a particular condition is `true`. Its syntax can be expressed as:

while (expression) {
     statement(s)
}

The `while` statement evaluates _expression_, which must return a `boolean` value. If the expression evaluates to `true`, the `while` statement executes the _statement_(s) in the `while` block. The `while` statement continues testing the expression and executing its block until the expression evaluates to `false`. Using the `while` statement to print the values from 1 through 10 can be accomplished as in the following [`WhileDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/WhileDemo.java) program:

class WhileDemo {
    public static void main(String[] args){
        int count = 1;
        while (count < 11) {
            System.out.println("Count is: " + count);
            count++;
        }
    }
}

You can implement an infinite loop using the `while` statement as follows:

while (true){
    // your code goes here
}

The Java programming language also provides a `do-while` statement, which can be expressed as follows:

do {
     statement(s)
} while (expression);

The difference between `do-while` and `while` is that `do-while` evaluates its expression at the bottom of the loop instead of the top. Therefore, the statements within the `do` block are always executed at least once, as shown in the following [`DoWhileDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/DoWhileDemo.java) program:

class DoWhileDemo {
    public static void main(String[] args){
        int count = 1;
        do {
            System.out.println("Count is: " + count);
            count++;
        } while (count < 11);
    }
}

<a name="sec_2_18"></a>
## 2.18. [The for Statement](#sec_2_18)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html 

The `for` statement provides a compact way to iterate over a range of values. Programmers often refer to it as the "for loop" because of the way in which it repeatedly loops until a particular condition is satisfied. The general form of the `for` statement can be expressed as follows:

for (_initialization_; _termination_;
     _increment_) {
    _statement(s)_
}

When using this version of the `for` statement, keep in mind that:

*   The _initialization_ expression initializes the loop; it's executed once, as the loop begins.
*   When the _termination_ expression evaluates to `false`, the loop terminates.
*   The _increment_ expression is invoked after each iteration through the loop; it is perfectly acceptable for this expression to increment _or_ decrement a value.

The following program, [`ForDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ForDemo.java), uses the general form of the `for` statement to print the numbers 1 through 10 to standard output:

class ForDemo {
    public static void main(String[] args){
         for(int i=1; i<11; i++){
              System.out.println("Count is: " + i);
         }
    }
}

The output of this program is:

Count is: 1
Count is: 2
Count is: 3
Count is: 4
Count is: 5
Count is: 6
Count is: 7
Count is: 8
Count is: 9
Count is: 10

Notice how the code declares a variable within the initialization expression. The scope of this variable extends from its declaration to the end of the block governed by the `for` statement, so it can be used in the termination and increment expressions as well. If the variable that controls a `for` statement is not needed outside of the loop, it's best to declare the variable in the initialization expression. The names `i`, `j`, and `k` are often used to control `for` loops; declaring them within the initialization expression limits their life span and reduces errors.

The three expressions of the `for` loop are optional; an infinite loop can be created as follows:

// infinite loop
for ( ; ; ) {
    
    // your code goes here
}

The `for` statement also has another form designed for iteration through [Collections](../../collections/index.html) and [arrays](arrays.html) This form is sometimes referred to as the _enhanced for_ statement, and can be used to make your loops more compact and easy to read. To demonstrate, consider the following array, which holds the numbers 1 through 10:

int[] numbers = {1,2,3,4,5,6,7,8,9,10};

The following program, [`EnhancedForDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/EnhancedForDemo.java), uses the enhanced `for` to loop through the array:

class EnhancedForDemo {
    public static void main(String[] args){
         int[] numbers = 
             {1,2,3,4,5,6,7,8,9,10};
         for (int item : numbers) {
             System.out.println("Count is: " + item);
         }
    }
}

In this example, the variable `item` holds the current value from the numbers array. The output from this program is the same as before:

Count is: 1
Count is: 2
Count is: 3
Count is: 4
Count is: 5
Count is: 6
Count is: 7
Count is: 8
Count is: 9
Count is: 10

We recommend using this form of the `for` statement instead of the general form whenever possible.


<a name="sec_2_19"></a>
## 2.19. [Branching Statements](#sec_2_19)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/branch.html 

The `break` Statement
---------------------

The `break` statement has two forms: labeled and unlabeled. You saw the unlabeled form in the previous discussion of the `switch` statement. You can also use an unlabeled `break` to terminate a `for`, `while`, or `do-while` loop, as shown in the following [`BreakDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/BreakDemo.java) program:

class BreakDemo {
    public static void main(String[] args) {

        int[] arrayOfInts = 
            { 32, 87, 3, 589,
              12, 1076, 2000,
              8, 622, 127 };
        int searchfor = 12;

        int i;
        boolean foundIt = false;

        for (i = 0; i < arrayOfInts.length; i++) {
            if (arrayOfInts[i] == searchfor) {
                foundIt = true;
                **break;**
            }
        }

        if (foundIt) {
            System.out.println("Found " + searchfor + " at index " + i);
        } else {
            System.out.println(searchfor + " not in the array");
        }
    }
}

This program searches for the number 12 in an array. The `break` statement, shown in boldface, terminates the `for` loop when that value is found. Control flow then transfers to the statement after the `for` loop. This program's output is:

Found 12 at index 4

An unlabeled `break` statement terminates the innermost `switch`, `for`, `while`, or `do-while` statement, but a labeled `break` terminates an outer statement. The following program, [`BreakWithLabelDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/BreakWithLabelDemo.java), is similar to the previous program, but uses nested `for` loops to search for a value in a two-dimensional array. When the value is found, a labeled `break` terminates the outer `for` loop (labeled "search"):

class BreakWithLabelDemo {
    public static void main(String[] args) {

        int[][] arrayOfInts = { 
            { 32, 87, 3, 589 },
            { 12, 1076, 2000, 8 },
            { 622, 127, 77, 955 }
        };
        int searchfor = 12;

        int i;
        int j = 0;
        boolean foundIt = false;

    search:
        for (i = 0; i < arrayOfInts.length; i++) {
            for (j = 0; j < arrayOfInts[i].length;
                 j++) {
                if (arrayOfInts[i][j] == searchfor) {
                    foundIt = true;
                    break search;
                }
            }
        }

        if (foundIt) {
            System.out.println("Found " + searchfor + " at " + i + ", " + j);
        } else {
            System.out.println(searchfor + " not in the array");
        }
    }
}

This is the output of the program.

Found 12 at 1, 0

The `break` statement terminates the labeled statement; it does not transfer the flow of control to the label. Control flow is transferred to the statement immediately following the labeled (terminated) statement.

The `continue` Statement
------------------------

The `continue` statement skips the current iteration of a `for`, `while` , or `do-while` loop. The unlabeled form skips to the end of the innermost loop's body and evaluates the `boolean` expression that controls the loop. The following program, [`ContinueDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ContinueDemo.java) , steps through a `String`, counting the occurrences of the letter "p". If the current character is not a p, the `continue` statement skips the rest of the loop and proceeds to the next character. If it _is_ a "p", the program increments the letter count.

class ContinueDemo {
    public static void main(String[] args) {

        String searchMe = "peter piper picked a " + "peck of pickled peppers";
        int max = searchMe.length();
        int numPs = 0;

        for (int i = 0; i < max; i++) {
            // interested only in p's
            if (searchMe.charAt(i) != 'p')
                continue;

            // process p's
            numPs++;
        }
        System.out.println("Found " + numPs + " p's in the string.");
    }
}

Here is the output of this program:

Found 9 p's in the string.

To see this effect more clearly, try removing the `continue` statement and recompiling. When you run the program again, the count will be wrong, saying that it found 35 p's instead of 9.

A labeled `continue` statement skips the current iteration of an outer loop marked with the given label. The following example program, `ContinueWithLabelDemo`, uses nested loops to search for a substring within another string. Two nested loops are required: one to iterate over the substring and one to iterate over the string being searched. The following program, [`ContinueWithLabelDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ContinueWithLabelDemo.java), uses the labeled form of continue to skip an iteration in the outer loop.

class ContinueWithLabelDemo {
    public static void main(String[] args) {

        String searchMe = "Look for a substring in me";
        String substring = "sub";
        boolean foundIt = false;

        int max = searchMe.length() - 
                  substring.length();

    test:
        for (int i = 0; i <= max; i++) {
            int n = substring.length();
            int j = i;
            int k = 0;
            while (n-- != 0) {
                if (searchMe.charAt(j++) != substring.charAt(k++)) {
                    continue test;
                }
            }
            foundIt = true;
                break test;
        }
        System.out.println(foundIt ? "Found it" : "Didn't find it");
    }
}

Here is the output from this program.

Found it

The `return` Statement
----------------------

The last of the branching statements is the `return` statement. The `return` statement exits from the current method, and control flow returns to where the method was invoked. The `return` statement has two forms: one that returns a value, and one that doesn't. To return a value, simply put the value (or an expression that calculates the value) after the `return` keyword.

return ++count;

The data type of the returned value must match the type of the method's declared return value. When a method is declared `void`, use the form of `return` that doesn't return a value.

return;

The [Classes and Objects](../javaOO/methods.html) lesson will cover everything you need to know about writing methods.

<a name="sec_2_20"></a>
## 2.20. [Summary of Control Flow Statements](#sec_2_20)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/flowsummary.html 

The `if-then` statement is the most basic of all the control flow statements. It tells your program to execute a certain section of code _only if_ a particular test evaluates to `true`. The `if-then-else` statement provides a secondary path of execution when an "if" clause evaluates to `false`. Unlike `if-then` and `if-then-else`, the `switch` statement allows for any number of possible execution paths. The `while` and `do-while` statements continually execute a block of statements while a particular condition is `true`. The difference between `do-while` and `while` is that `do-while` evaluates its expression at the bottom of the loop instead of the top. Therefore, the statements within the `do` block are always executed at least once. The `for` statement provides a compact way to iterate over a range of values. It has two forms, one of which was designed for looping through collections and arrays.

<a name="sec_2_21"></a>
## 2.21. [Questions and Exercises: Control Flow Statements](#sec_2_21)
******
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/QandE/questions_flow.html 

Questions
---------

1.  The most basic control flow statement supported by the Java programming language is the ‚ñÅ statement.
2.  The ‚ñÅ statement allows for any number of possible execution paths.
3.  The ‚ñÅ statement is similar to the `while` statement, but evaluates its expression at the ‚ñÅ of the loop.
4.  How do you write an infinite loop using the `for` statement?
5.  How do you write an infinite loop using the `while` statement?

Exercises
---------

1.  Consider the following code snippet.
    
    if (aNumber >= 0)
        if (aNumber == 0)
            System.out.println("first string");
    else System.out.println("second string");
    System.out.println("third string");
    
    1.  What output do you think the code will produce if `aNumber` is 3?
    2.  Write a test program containing the previous code snippet; make `aNumber` 3. What is the output of the program? Is it what you predicted? Explain why the output is what it is; in other words, what is the control flow for the code snippet?
    3.  Using only spaces and line breaks, reformat the code snippet to make the control flow easier to understand.
    4.  Use braces, { and }, to further clarify the code.

Answers to Questions and Exercises: Control Flow Statements
===========================================================

Answers to Questions
--------------------

1.  The most basic control flow statement supported by the Java programming language is the **if-then** statement.
2.  The **switch** statement allows for any number of possible execution paths.
3.  The **do-while** statement is similar to the `while` statement, but evaluates its expression at the **bottom** of the loop.
4.  **Question:** How do you write an infinite loop using the `for` statement?
    
    **Answer:**
    
    for ( ; ; ) {
    
    }
    
5.  **Question:** How do you write an infinite loop using the `while` statement?
    
    **Answer:**
    
    while (true) {
    
    }
    

Exercises
---------

1.  Consider the following code snippet.
    
    if (aNumber >= 0)
        if (aNumber == 0)
            System.out.println("first string");
    else 
        System.out.println("second string");
    System.out.println("third string");
    
    1.  **Exercise:** What output do you think the code will produce if `aNumber` is 3?
        
        **Solution:**
        
        second string
        third string
        
    2.  **Exercise:** Write a test program containing the previous code snippet; make `aNumber` 3. What is the output of the program? Is it what you predicted? Explain why the output is what it is. In other words, what is the control flow for the code snippet?
        
        **Solution:** [`NestedIf`](NestedIf.java)
        
        second string
        third string
        
        3 is greater than or equal to 0, so execution progresses to the second `if` statement. The second `if` statement's test fails because 3 is not equal to 0. Thus, the `else` clause executes (since it's attached to the second `if` statement). Thus, `second string` is displayed. The final `println` is completely outside of any `if` statement, so it always gets executed, and thus `third string` is always displayed.
    3.  **Exercise:** Using only spaces and line breaks, reformat the code snippet to make the control flow easier to understand.
        
        **Solution:**
        
        if (aNumber >= 0)
            if (aNumber == 0)
                System.out.println("first string");
            else
                System.out.println("second string");
        
        System.out.println("third string");
        
    4.  **Exercise:** Use braces `{` and `}` to further clarify the code and reduce the possibility of errors by future maintainers of the code.
        
        **Solution:**
        
        if (aNumber >= 0) {
            if (aNumber == 0) {
                System.out.println("first string");
            } else {
                System.out.println("second string");
            }
        }
        
        System.out.println("third string");
        

<a name="sec_3"></a>
# üìú/PART [3. Classes and Objects](#sec_toc)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/index.html 

1. [Classes](#sec_3_1)
2. [Declaring Classes](#sec_3_2)
3. [Declaring Member Variables](#sec_3_3)
4. [Defining Methods](#sec_3_4)
5. [Providing Constructors for Your Classes](#sec_3_5)
6. [Passing Information to a Method or a Constructor](#sec_3_6)
7. [Objects](#sec_3_7)
8. [Creating Objects](#sec_3_8)
9. [Using Objects](#sec_3_9)
10. [More on Classes](#sec_3_10)
11. [Returning a Value from a Method](#sec_3_11)
12. [Using the this Keyword](#sec_3_12)
13. [Controlling Access to Members of a Class](#sec_3_13)
14. [Understanding Class Members](#sec_3_14)
15. [Initializing Fields](#sec_3_15)
16. [Summary of Creating and Using Classes and Objects](#sec_3_16)
17. [Questions and Exercises](#sec_3_17)
18. [Questions and Exercises](#sec_3_18)
19. [Nested Classes](#sec_3_19)
20. [Inner Class Example](#sec_3_20)
21. [Local Classes](#sec_3_21)
22. [Anonymous Classes](#sec_3_22)
23. [Lambda Expressions](#sec_3_23)
24. [Method References](#sec_3_24)
25. [When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions](#sec_3_25)
26. [Questions and Exercises](#sec_3_26)
27. [Enum Types](#sec_3_27)
28. [Questions and Exercises](#sec_3_28)

With the knowledge you now have of the basics of the Java programming language, you can learn to write your own classes. In this lesson, you will find information about defining your own classes, including declaring member variables, methods, and constructors.

You will learn to use your classes to create objects, and how to use the objects you create.

This lesson also covers nesting classes within other classes, and enumerations

Classes
* * *

This section shows you the anatomy of a class, and how to declare fields, methods, and constructors.

Objects
* * *

This section covers creating and using objects. You will learn how to instantiate an object, and, once instantiated, how to use the `dot` operator to access the object's instance variables and methods.

More on Classes
* * *

This section covers more aspects of classes that depend on using object references and the `dot` operator that you learned about in the preceding section: returning values from methods, the `this` keyword, class vs. instance members, and access control.

Nested Classes
* * *

Static nested classes, inner classes, anonymous inner classes, local classes, and lambda expressions are covered. There is also a discussion on when to use which approach.

Enum Types
* * *

This section covers enumerations, specialized classes that allow you to define and use sets of constants.

<a name="sec_3_1"></a>
## 3.1. [Classes](#sec_3_1)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/classes.html

The introduction to object-oriented concepts in the lesson titled [Object-oriented Programming Concepts](../../java/concepts/index.html) used a bicycle class as an example, with racing bikes, mountain bikes, and tandem bikes as subclasses. Here is sample code for a possible implementation of a `Bicycle` class, to give you an overview of a class declaration. Subsequent sections of this lesson will back up and explain class declarations step by step. For the moment, don't concern yourself with the details.

public class Bicycle {
        
    // **the Bicycle class has**
    // **three _fields_**
    public int cadence;
    public int gear;
    public int speed;
        
    // **the Bicycle class has**
    // **one _constructor_**
    public Bicycle(int startCadence, int startSpeed, int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
    }
        
    // **the Bicycle class has**
    // **four _methods_**
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
        
}

A class declaration for a `MountainBike` class that is a subclass of `Bicycle` might look like this:

public class MountainBike extends Bicycle {
        
    // **the MountainBike subclass has**
    // **one _field_**
    public int seatHeight;

    // **the MountainBike subclass has**
    // **one _constructor_**
    public MountainBike(int startHeight, int startCadence,
                        int startSpeed, int startGear) {
        super(startCadence, startSpeed, startGear);
        seatHeight = startHeight;
    }   
        
    // **the MountainBike subclass has**
    // **one _method_**
    public void setHeight(int newValue) {
        seatHeight = newValue;
    }   

}

`MountainBike` inherits all the fields and methods of `Bicycle` and adds the field `seatHeight` and a method to set it (mountain bikes have seats that can be moved up and down as the terrain demands).

<a name="sec_3_2"></a>
## 3.2. [Declaring Classes](#sec_3_2)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/classdecl.html

You've seen classes defined in the following way:

class _MyClass_ {
    // field, constructor, and 
    // method declarations
}

This is a _class declaration_. The _class body_ (the area between the braces) contains all the code that provides for the life cycle of the objects created from the class: constructors for initializing new objects, declarations for the fields that provide the state of the class and its objects, and methods to implement the behavior of the class and its objects.

The preceding class declaration is a minimal one. It contains only those components of a class declaration that are required. You can provide more information about the class, such as the name of its superclass, whether it implements any interfaces, and so on, at the start of the class declaration. For example,

class _MyClass extends MySuperClass implements YourInterface_ {
    // field, constructor, and
    // method declarations
}

means that `MyClass` is a subclass of `MySuperClass` and that it implements the `YourInterface` interface.

You can also add modifiers like _public_ or _private_ at the very beginning‚Äîso you can see that the opening line of a class declaration can become quite complicated. The modifiers _public_ and _private_, which determine what other classes can access `MyClass`, are discussed later in this lesson. The lesson on interfaces and inheritance will explain how and why you would use the _extends_ and _implements_ keywords in a class declaration. For the moment you do not need to worry about these extra complications.

In general, class declarations can include these components, in order:

1.  Modifiers such as _public_, _private_, and a number of others that you will encounter later. (However, note that the _private_ modifier can only be applied to [Nested Classes](../../java/javaOO/nested.html).)
2.  The class name, with the initial letter capitalized by convention.
3.  The name of the class's parent (superclass), if any, preceded by the keyword _extends_. A class can only _extend_ (subclass) one parent.
4.  A comma-separated list of interfaces implemented by the class, if any, preceded by the keyword _implements_. A class can _implement_ more than one interface.
5.  The class body, surrounded by braces, {}.

<a name="sec_3_3"></a>
## 3.3. [Declaring Member Variables](#sec_3_3)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/variables.html

There are several kinds of variables:

*   Member variables in a class‚Äîthese are called _fields_.
*   Variables in a method or block of code‚Äîthese are called _local variables_.
*   Variables in method declarations‚Äîthese are called _parameters_.

The `Bicycle` class uses the following lines of code to define its fields:

public int cadence;
public int gear;
public int speed;

Field declarations are composed of three components, in order:

1.  Zero or more modifiers, such as `public` or `private`.
2.  The field's type.
3.  The field's name.

The fields of `Bicycle` are named `cadence`, `gear`, and `speed` and are all of data type integer (`int`). The `public` keyword identifies these fields as public members, accessible by any object that can access the class.

Access Modifiers
----------------

The first (left-most) modifier used lets you control what other classes have access to a member field. For the moment, consider only `public` and `private`. Other access modifiers will be discussed later.

*   `public` modifier‚Äîthe field is accessible from all classes.
*   `private` modifier‚Äîthe field is accessible only within its own class.

In the spirit of encapsulation, it is common to make fields private. This means that they can only be _directly_ accessed from the Bicycle class. We still need access to these values, however. This can be done _indirectly_ by adding public methods that obtain the field values for us:

public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
        
    public Bicycle(int startCadence, int startSpeed, int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
    }
        
    public int getCadence() {
        return cadence;
    }
        
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public int getGear() {
        return gear;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public int getSpeed() {
        return speed;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
}

Types
-----

All variables must have a type. You can use primitive types such as `int`, `float`, `boolean`, etc. Or you can use reference types, such as strings, arrays, or objects.

Variable Names
--------------

All variables, whether they are fields, local variables, or parameters, follow the same naming rules and conventions that were covered in the Language Basics lesson, [Variables‚ÄîNaming](../../java/nutsandbolts/variables.html#naming).

In this lesson, be aware that the same naming rules and conventions are used for method and class names, except that

*   the first letter of a class name should be capitalized, and
*   the first (or only) word in a method name should be a verb.

<a name="sec_3_4"></a>
## 3.4. [Defining Methods](#sec_3_4)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html

Here is an example of a typical method declaration:

public double calculateAnswer(double wingSpan, int numberOfEngines,
                              double length, double grossTons) {
    //do the calculation here
}

The only required elements of a method declaration are the method's return type, name, a pair of parentheses, `()`, and a body between braces, `{}`.

More generally, method declarations have six components, in order:

1.  Modifiers‚Äîsuch as `public`, `private`, and others you will learn about later.
2.  The return type‚Äîthe data type of the value returned by the method, or `void` if the method does not return a value.
3.  The method name‚Äîthe rules for field names apply to method names as well, but the convention is a little different.
4.  The parameter list in parenthesis‚Äîa comma-delimited list of input parameters, preceded by their data types, enclosed by parentheses, `()`. If there are no parameters, you must use empty parentheses.
5.  An exception list‚Äîto be discussed later.
6.  The method body, enclosed between braces‚Äîthe method's code, including the declaration of local variables, goes here.

Modifiers, return types, and parameters will be discussed later in this lesson. Exceptions are discussed in a later lesson.

* * *

**Definition:**¬†Two of the components of a method declaration comprise the _method signature_‚Äîthe method's name and the parameter types.

* * *

The signature of the method declared above is:

calculateAnswer(double, int, double, double)

Naming a Method
---------------

Although a method name can be any legal identifier, code conventions restrict method names. By convention, method names should be a verb in lowercase or a multi-word name that begins with a verb in lowercase, followed by adjectives, nouns, etc. In multi-word names, the first letter of each of the second and following words should be capitalized. Here are some examples:

    run
    runFast
    getBackground
    getFinalData
    compareTo
    setX
    isEmpty

Typically, a method has a unique name within its class. However, a method might have the same name as other methods due to _method overloading_.

Overloading Methods
-------------------

The Java programming language supports _overloading_ methods, and Java can distinguish between methods with different _method signatures_. This means that methods within a class can have the same name if they have different parameter lists (there are some qualifications to this that will be discussed in the lesson titled "Interfaces and Inheritance").

Suppose that you have a class that can use calligraphy to draw various types of data (strings, integers, and so on) and that contains a method for drawing each data type. It is cumbersome to use a new name for each method‚Äîfor example, `drawString`, `drawInteger`, `drawFloat`, and so on. In the Java programming language, you can use the same name for all the drawing methods but pass a different argument list to each method. Thus, the data drawing class might declare four methods named `draw`, each of which has a different parameter list.

public class DataArtist {
    ...
    public void draw(String s) {
        ...
    }
    public void draw(int i) {
        ...
    }
    public void draw(double f) {
        ...
    }
    public void draw(int i, double f) {
        ...
    }
}

Overloaded methods are differentiated by the number and the type of the arguments passed into the method. In the code sample, `draw(String s)` and `draw(int i)` are distinct and unique methods because they require different argument types.

You cannot declare more than one method with the same name and the same number and type of arguments, because the compiler cannot tell them apart.

The compiler does not consider return type when differentiating methods, so you cannot declare two methods with the same signature even if they have a different return type.

* * *

**Note:**¬†Overloaded methods should be used sparingly, as they can make code much less readable.

* * *

<a name="sec_3_5"></a>
## 3.5. [Providing Constructors for Your Classes](#sec_3_5)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html

A class contains constructors that are invoked to create objects from the class blueprint. Constructor declarations look like method declarations‚Äîexcept that they use the name of the class and have no return type. For example, `Bicycle` has one constructor:

public Bicycle(int startCadence, int startSpeed, int startGear) {
    gear = startGear;
    cadence = startCadence;
    speed = startSpeed;
}

To create a new `Bicycle` object called `myBike`, a constructor is called by the `new` operator:

Bicycle myBike = new Bicycle(30, 0, 8);

`new Bicycle(30, 0, 8)` creates space in memory for the object and initializes its fields.

Although `Bicycle` only has one constructor, it could have others, including a no-argument constructor:

public Bicycle() {
    gear = 1;
    cadence = 10;
    speed = 0;
}

`Bicycle yourBike = new Bicycle();` invokes the no-argument constructor to create a new `Bicycle` object called `yourBike`.

Both constructors could have been declared in `Bicycle` because they have different argument lists. As with methods, the Java platform differentiates constructors on the basis of the number of arguments in the list and their types. You cannot write two constructors that have the same number and type of arguments for the same class, because the platform would not be able to tell them apart. Doing so causes a compile-time error.

You don't have to provide any constructors for your class, but you must be careful when doing this. The compiler automatically provides a no-argument, default constructor for any class without constructors. This default constructor will call the no-argument constructor of the superclass. In this situation, the compiler will complain if the superclass doesn't have a no-argument constructor so you must verify that it does. If your class has no explicit superclass, then it has an implicit superclass of `Object`, which _does_ have a no-argument constructor.

You can use a superclass constructor yourself. The `MountainBike` class at the beginning of this lesson did just that. This will be discussed later, in the lesson on interfaces and inheritance.

You can use access modifiers in a constructor's declaration to control which other classes can call the constructor.

* * *

**Note:**¬†If another class cannot call a `MyClass` constructor, it cannot directly create `MyClass` objects.

* * *

<a name="sec_3_6"></a>
## 3.6. [Passing Information to a Method or a Constructor](#sec_3_6)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html

The declaration for a method or a constructor declares the number and the type of the arguments for that method or constructor. For example, the following is a method that computes the monthly payments for a home loan, based on the amount of the loan, the interest rate, the length of the loan (the number of periods), and the future value of the loan:

public double computePayment(
                  double **loanAmt**,
                  double **rate**,
                  double **futureValue**,
                  int **numPeriods**) {
    double interest = **rate** / 100.0;
    double partial1 = Math.pow((1 + interest), 
                    - **numPeriods**);
    double denominator = (1 - partial1) / interest;
    double answer = (-**loanAmt** / denominator)
                    - ((**futureValue** * partial1) / denominator);
    return answer;
}

This method has four parameters: the loan amount, the interest rate, the future value and the number of periods. The first three are double-precision floating point numbers, and the fourth is an integer. The parameters are used in the method body and at runtime will take on the values of the arguments that are passed in.

* * *

**Note:**¬†_Parameters_ refers to the list of variables in a method declaration. _Arguments_ are the actual values that are passed in when the method is invoked. When you invoke a method, the arguments used must match the declaration's parameters in type and order.

* * *

Parameter Types
---------------

You can use any data type for a parameter of a method or a constructor. This includes primitive data types, such as doubles, floats, and integers, as you saw in the `computePayment` method, and reference data types, such as objects and arrays.

Here's an example of a method that accepts an array as an argument. In this example, the method creates a new `Polygon` object and initializes it from an array of `Point` objects (assume that `Point` is a class that represents an x, y coordinate):

public Polygon polygonFrom(Point[] corners) {
    // method body goes here
}

* * *

**Note:**¬†If you want to pass a method into a method, then use a [lambda expression](lambdaexpressions.html) or a [method reference](methodreferences.html).

* * *

Arbitrary Number of Arguments
-----------------------------

You can use a construct called _varargs_ to pass an arbitrary number of values to a method. You use varargs when you don't know how many of a particular type of argument will be passed to the method. It's a shortcut to creating an array manually (the previous method could have used varargs rather than an array).

To use varargs, you follow the type of the last parameter by an ellipsis (three dots, ...), then a space, and the parameter name. The method can then be called with any number of that parameter, including none.

public Polygon polygonFrom(Point... corners) {
    int numberOfSides = corners.length;
    double squareOfSide1, lengthOfSide1;
    squareOfSide1 = (corners[1].x - corners[0].x)
                     * (corners[1].x - corners[0].x) 
                     + (corners[1].y - corners[0].y)
                     * (corners[1].y - corners[0].y);
    lengthOfSide1 = Math.sqrt(squareOfSide1);

    // more method body code follows that creates and returns a 
    // polygon connecting the Points
}

You can see that, inside the method, `corners` is treated like an array. The method can be called either with an array or with a sequence of arguments. The code in the method body will treat the parameter as an array in either case.

You will most commonly see varargs with the printing methods; for example, this `printf` method:

    public PrintStream printf(String format, Object... args)

allows you to print an arbitrary number of objects. It can be called like this:

    System.out.printf("%s: %d, %s%n", name, idnum, address);

or like this

    System.out.printf("%s: %d, %s, %s, %s%n", name, idnum, address, phone, email);

or with yet a different number of arguments.

Parameter Names
---------------

When you declare a parameter to a method or a constructor, you provide a name for that parameter. This name is used within the method body to refer to the passed-in argument.

The name of a parameter must be unique in its scope. It cannot be the same as the name of another parameter for the same method or constructor, and it cannot be the name of a local variable within the method or constructor.

A parameter can have the same name as one of the class's fields. If this is the case, the parameter is said to _shadow_ the field. Shadowing fields can make your code difficult to read and is conventionally used only within constructors and methods that set a particular field. For example, consider the following `Circle` class and its `setOrigin` method:

public class Circle {
    private int x, y, radius;
    public void setOrigin(int x, int y) {
        ...
    }
}

The `Circle` class has three fields: `x`, `y`, and `radius`. The `setOrigin` method has two parameters, each of which has the same name as one of the fields. Each method parameter shadows the field that shares its name. So using the simple names `x` or `y` within the body of the method refers to the parameter, _not_ to the field. To access the field, you must use a qualified name. This will be discussed later in this lesson in the section titled "Using the `this` Keyword."

Passing Primitive Data Type Arguments
-------------------------------------

Primitive arguments, such as an `int` or a `double`, are passed into methods _by value_. This means that any changes to the values of the parameters exist only within the scope of the method. When the method returns, the parameters are gone and any changes to them are lost. Here is an example:

public class PassPrimitiveByValue {

    public static void main(String[] args) {
           
        int x = 3;
           
        // invoke passMethod() with 
        // x as argument
        passMethod(x);
           
        // print x to see if its 
        // value has changed
        System.out.println("After invoking passMethod, x = " + x);
           
    }
        
    // change parameter in passMethod()
    public static void passMethod(int p) {
        p = 10;
    }
}

When you run this program, the output is:

After invoking passMethod, x = 3

Passing Reference Data Type Arguments
-------------------------------------

Reference data type parameters, such as objects, are also passed into methods _by value_. This means that when the method returns, the passed-in reference still references the same object as before. _However_, the values of the object's fields _can_ be changed in the method, if they have the proper access level.

For example, consider a method in an arbitrary class that moves `Circle` objects:

public void moveCircle(Circle circle, int deltaX, int deltaY) {
    // code to move origin of circle to x+deltaX, y+deltaY
    circle.setX(circle.getX() + deltaX);
    circle.setY(circle.getY() + deltaY);
        
    // code to assign a new reference to circle
    circle = new Circle(0, 0);
}

Let the method be invoked with these arguments:

moveCircle(myCircle, 23, 56)

Inside the method, `circle` initially refers to `myCircle`. The method changes the x and y coordinates of the object that `circle` references (that is, `myCircle`) by 23 and 56, respectively. These changes will persist when the method returns. Then `circle` is assigned a reference to a new `Circle` object with `x = y = 0`. This reassignment has no permanence, however, because the reference was passed in by value and cannot change. Within the method, the object pointed to by `circle` has changed, but, when the method returns, `myCircle` still references the same `Circle` object as before the method was called.

<a name="sec_3_7"></a>
## 3.7. [Objects](#sec_3_7)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/objects.html

A typical Java program creates many objects, which as you know, interact by invoking methods. Through these object interactions, a program can carry out various tasks, such as implementing a GUI, running an animation, or sending and receiving information over a network. Once an object has completed the work for which it was created, its resources are recycled for use by other objects.

Here's a small program, called [`CreateObjectDemo`](https://docs.oracle.com/javase/tutorial/java/data/examples/CreateObjectDemo.java), that creates three objects: one [`Point`](https://docs.oracle.com/javase/tutorial/java/data/examples/Point.java) object and two [`Rectangle`](https://docs.oracle.com/javase/tutorial/java/data/examples/Rectangle.java) objects. You will need all three source files to compile this program.

public class CreateObjectDemo {

    public static void main(String[] args) {
        
        // Declare and create a point object and two rectangle objects.
        Point originOne = new Point(23, 94);
        Rectangle rectOne = new Rectangle(originOne, 100, 200);
        Rectangle rectTwo = new Rectangle(50, 100);
        
        // display rectOne's width, height, and area
        System.out.println("Width of rectOne: " + rectOne.width);
        System.out.println("Height of rectOne: " + rectOne.height);
        System.out.println("Area of rectOne: " + rectOne.getArea());
        
        // set rectTwo's position
        rectTwo.origin = originOne;
        
        // display rectTwo's position
        System.out.println("X Position of rectTwo: " + rectTwo.origin.x);
        System.out.println("Y Position of rectTwo: " + rectTwo.origin.y);
        
        // move rectTwo and display its new position
        rectTwo.move(40, 72);
        System.out.println("X Position of rectTwo: " + rectTwo.origin.x);
        System.out.println("Y Position of rectTwo: " + rectTwo.origin.y);
    }
}

This program creates, manipulates, and displays information about various objects. Here's the output:

Width of rectOne: 100
Height of rectOne: 200
Area of rectOne: 20000
X Position of rectTwo: 23
Y Position of rectTwo: 94
X Position of rectTwo: 40
Y Position of rectTwo: 72

The following three sections use the above example to describe the life cycle of an object within a program. From them, you will learn how to write code that creates and uses objects in your own programs. You will also learn how the system cleans up after an object when its life has ended.

<a name="sec_3_8"></a>
## 3.8. [Creating Objects](#sec_3_8)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/objectcreation.html

As you know, a class provides the blueprint for objects; you create an object from a class. Each of the following statements taken from the [`CreateObjectDemo`](https://docs.oracle.com/javase/tutorial/java/data/examples/CreateObjectDemo.java) program creates an object and assigns it to a variable:

**Point originOne** = new Point(23, 94);
**Rectangle rectOne** = new Rectangle(originOne, 100, 200);
**Rectangle rectTwo** = new Rectangle(50, 100);

The first line creates an object of the [`Point`](https://docs.oracle.com/javase/tutorial/java/data/examples/Point.java) class, and the second and third lines each create an object of the [`Rectangle`](https://docs.oracle.com/javase/tutorial/java/data/examples/Rectangle.java) class.

Each of these statements has three parts (discussed in detail below):

1.  **Declaration**: The code set in **bold** are all variable declarations that associate a variable name with an object type.
2.  **Instantiation**: The new keyword is a Java operator that creates the object.
3.  **Initialization**: The new operator is followed by a call to a constructor, which initializes the new object.

Declaring a Variable to Refer to an Object
------------------------------------------

Previously, you learned that to declare a variable, you write:

_type name_;

This notifies the compiler that you will use _name_ to refer to data whose type is _type_. With a primitive variable, this declaration also reserves the proper amount of memory for the variable.

You can also declare a reference variable on its own line. For example:

Point originOne;

If you declare `originOne` like this, its value will be undetermined until an object is actually created and assigned to it. Simply declaring a reference variable does not create an object. For that, you need to use the `new` operator, as described in the next section. You must assign an object to `originOne` before you use it in your code. Otherwise, you will get a compiler error.

A variable in this state, which currently references no object, can be illustrated as follows (the variable name, `originOne`, plus a reference pointing to nothing):

![originOne is null.](https://docs.oracle.com/javase/tutorial/figures/java/objects-null.gif)

Instantiating a Class
---------------------

The new operator instantiates a class by allocating memory for a new object and returning a reference to that memory. The new operator also invokes the object constructor.

* * *

**Note:**¬†The phrase "instantiating a class" means the same thing as "creating an object." When you create an object, you are creating an "instance" of a class, therefore "instantiating" a class.

* * *

The new operator requires a single, postfix argument: a call to a constructor. The name of the constructor provides the name of the class to instantiate.

The new operator returns a reference to the object it created. This reference is usually assigned to a variable of the appropriate type, like:

    Point originOne = new Point(23, 94);

The reference returned by the new operator does not have to be assigned to a variable. It can also be used directly in an expression. For example:

int height = new Rectangle().height;

This statement will be discussed in the next section.

Initializing an Object
----------------------

Here's the code for the Point class:

public class Point {
    public int x = 0;
    public int y = 0;
    **//constructor
    public Point(int a, int b) {
        x = a;
        y = b;
    }**
}

This class contains a single constructor. You can recognize a constructor because its declaration uses the same name as the class and it has no return type. The constructor in the Point class takes two integer arguments, as declared by the code (int a, int b). The following statement provides 23 and 94 as values for those arguments:

Point originOne = new Point(23, 94);

The result of executing this statement can be illustrated in the next figure:

![originOne now points to a Point object.](https://docs.oracle.com/javase/tutorial/figures/java/objects-oneRef.gif)

Here's the code for the Rectangle class, which contains four constructors:

public class Rectangle {
    public int width = 0;
    public int height = 0;
    public Point origin;

    // four constructors
    public Rectangle() {
        origin = new Point(0, 0);
    }
    public Rectangle(Point p) {
        origin = p;
    }
    public Rectangle(int w, int h) {
        origin = new Point(0, 0);
        width = w;
        height = h;
    }
    public Rectangle(Point p, int w, int h) {
        origin = p;
        width = w;
        height = h;
    }

    // a method for moving the rectangle
    public void move(int x, int y) {
        origin.x = x;
        origin.y = y;
    }

    // a method for computing the area of the rectangle
    public int getArea() {
        return width * height;
    }
}

Each constructor lets you provide initial values for the rectangle's origin, width, and height, using both primitive and reference types. If a class has multiple constructors, they must have different signatures. The Java compiler differentiates the constructors based on the number and the type of the arguments. When the Java compiler encounters the following code, it knows to call the constructor in the Rectangle class that requires a Point argument followed by two integer arguments:

 
Rectangle rectOne = new Rectangle(originOne, 100, 200);

This calls one of `Rectangle`'s constructors that initializes `origin` to `originOne`. Also, the constructor sets `width` to 100 and `height` to 200. Now there are two references to the same Point object‚Äîan object can have multiple references to it, as shown in the next figure:

![Now the rectangle's origin variable also points to the Point.](https://docs.oracle.com/javase/tutorial/figures/java/objects-multipleRefs.gif)

The following line of code calls the `Rectangle` constructor that requires two integer arguments, which provide the initial values for width and height. If you inspect the code within the constructor, you will see that it creates a new Point object whose x and y values are initialized to 0:

Rectangle rectTwo = new Rectangle(50, 100);

The Rectangle constructor used in the following statement doesn't take any arguments, so it's called a _no-argument constructor_:

Rectangle rect = new Rectangle();

All classes have at least one constructor. If a class does not explicitly declare any, the Java compiler automatically provides a no-argument constructor, called the _default constructor_. This default constructor calls the class parent's no-argument constructor, or the `Object` constructor if the class has no other parent. If the parent has no constructor (`Object` does have one), the compiler will reject the program.

<a name="sec_3_9"></a>
## 3.9. [Using Objects](#sec_3_9)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/usingobject.html

Once you've created an object, you probably want to use it for something. You may need to use the value of one of its fields, change one of its fields, or call one of its methods to perform an action.

Referencing an Object's Fields
------------------------------

Object fields are accessed by their name. You must use a name that is unambiguous.

You may use a simple name for a field within its own class. For example, we can add a statement _within_ the `Rectangle` class that prints the `width` and `height`:

System.out.println("Width and height are: " + width + ", " + height);

In this case, `width` and `height` are simple names.

Code that is outside the object's class must use an object reference or expression, followed by the dot (.) operator, followed by a simple field name, as in:

objectReference.fieldName

For example, the code in the CreateObjectDemo class is outside the code for the Rectangle class. So to refer to the origin, width, and height fields within the Rectangle object named rectOne, the CreateObjectDemo class must use the names rectOne.origin, rectOne.width, and rectOne.height, respectively. The program uses two of these names to display the width and the height of rectOne:

System.out.println("Width of rectOne: "  + rectOne.width);
System.out.println("Height of rectOne: " + rectOne.height);

Attempting to use the simple names width and height from the code in the CreateObjectDemo class doesn't make sense ‚Äî those fields exist only within an object ‚Äî and results in a compiler error.

Later, the program uses similar code to display information about rectTwo. Objects of the same type have their own copy of the same instance fields. Thus, each Rectangle object has fields named origin, width, and height. When you access an instance field through an object reference, you reference that particular object's field. The two objects rectOne and rectTwo in the CreateObjectDemo program have different origin, width, and height fields.

To access a field, you can use a named reference to an object, as in the previous examples, or you can use any expression that returns an object reference. Recall that the new operator returns a reference to an object. So you could use the value returned from new to access a new object's fields:

int height = new Rectangle().height;

This statement creates a new Rectangle object and immediately gets its height. In essence, the statement calculates the default height of a Rectangle. Note that after this statement has been executed, the program no longer has a reference to the created Rectangle, because the program never stored the reference anywhere. The object is unreferenced, and its resources are free to be recycled by the Java Virtual Machine.

Calling an Object's Methods
---------------------------

You also use an object reference to invoke an object's method. You append the method's simple name to the object reference, with an intervening dot operator (.). Also, you provide, within enclosing parentheses, any arguments to the method. If the method does not require any arguments, use empty parentheses.

objectReference.methodName(argumentList);

or:

objectReference.methodName();

The Rectangle class has two methods: getArea() to compute the rectangle's area and move() to change the rectangle's origin. Here's the CreateObjectDemo code that invokes these two methods:

System.out.println("Area of rectOne: " + rectOne.getArea());
...
rectTwo.move(40, 72);

The first statement invokes rectOne's `getArea()` method and displays the results. The second line moves rectTwo because the move() method assigns new values to the object's origin.x and origin.y.

As with instance fields, _objectReference_ must be a reference to an object. You can use a variable name, but you also can use any expression that returns an object reference. The new operator returns an object reference, so you can use the value returned from new to invoke a new object's methods:

new Rectangle(100, 50).getArea()

The expression new Rectangle(100, 50) returns an object reference that refers to a Rectangle object. As shown, you can use the dot notation to invoke the new Rectangle's getArea() method to compute the area of the new rectangle.

Some methods, such as getArea(), return a value. For methods that return a value, you can use the method invocation in expressions. You can assign the return value to a variable, use it to make decisions, or control a loop. This code assigns the value returned by getArea() to the variable `areaOfRectangle`:

int areaOfRectangle = new Rectangle(100, 50).getArea();

Remember, invoking a method on a particular object is the same as sending a message to that object. In this case, the object that getArea() is invoked on is the rectangle returned by the constructor.

The Garbage Collector
---------------------

Some object-oriented languages require that you keep track of all the objects you create and that you explicitly destroy them when they are no longer needed. Managing memory explicitly is tedious and error-prone. The Java platform allows you to create as many objects as you want (limited, of course, by what your system can handle), and you don't have to worry about destroying them. The Java runtime environment deletes objects when it determines that they are no longer being used. This process is called _garbage collection_.

An object is eligible for garbage collection when there are no more references to that object. References that are held in a variable are usually dropped when the variable goes out of scope. Or, you can explicitly drop an object reference by setting the variable to the special value null. Remember that a program can have multiple references to the same object; all references to an object must be dropped before the object is eligible for garbage collection.

The Java runtime environment has a garbage collector that periodically frees the memory used by objects that are no longer referenced. The garbage collector does its job automatically when it determines that the time is right.

<a name="sec_3_10"></a>
## 3.10. [More on Classes](#sec_3_10)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/more.html

This section covers more aspects of classes that depend on using object references and the `dot` operator that you learned about in the preceding sections on objects:

*   Returning values from methods.
*   The `this` keyword.
*   Class vs. instance members.
*   Access control.

<a name="sec_3_11"></a>
## 3.11. [Returning a Value from a Method](#sec_3_11)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/returnvalue.html

A method returns to the code that invoked it when it

*   completes all the statements in the method,
*   reaches a `return` statement, or
*   throws an exception (covered later),

whichever occurs first.

You declare a method's return type in its method declaration. Within the body of the method, you use the `return` statement to return the value.

Any method declared `void` doesn't return a value. It does not need to contain a `return` statement, but it may do so. In such a case, a `return` statement can be used to branch out of a control flow block and exit the method and is simply used like this:

return;

If you try to return a value from a method that is declared `void`, you will get a compiler error.

Any method that is not declared `void` must contain a `return` statement with a corresponding return value, like this:

return returnValue;

The data type of the return value must match the method's declared return type; you can't return an integer value from a method declared to return a boolean.

The `getArea()` method in the `Rectangle` [`Rectangle`](https://docs.oracle.com/javase/tutorial/java/data/examples/Rectangle.java) class that was discussed in the sections on objects returns an integer:

    // a method for computing the area of the rectangle
    public int getArea() {
        return width * height;
    }

This method returns the integer that the expression `width*height` evaluates to.

The `getArea` method returns a primitive type. A method can also return a reference type. For example, in a program to manipulate `Bicycle` objects, we might have a method like this:

public Bicycle seeWhosFastest(Bicycle myBike, Bicycle yourBike,
                              Environment env) {
    Bicycle fastest;
    // code to calculate which bike is 
    // faster, given each bike's gear 
    // and cadence and given the 
    // environment (terrain and wind)
    return fastest;
}

Returning a Class or Interface
------------------------------

If this section confuses you, skip it and return to it after you have finished the lesson on interfaces and inheritance.

When a method uses a class name as its return type, such as `whosFastest` does, the class of the type of the returned object must be either a subclass of, or the exact class of, the return type. Suppose that you have a class hierarchy in which `ImaginaryNumber` is a subclass of `java.lang.Number`, which is in turn a subclass of `Object`, as illustrated in the following figure.

![The class hierarchy for ImaginaryNumber](https://docs.oracle.com/javase/tutorial/figures/java/classes-hierarchy.gif)

The class hierarchy for ImaginaryNumber

Now suppose that you have a method declared to return a `Number`:

public Number returnANumber() {
    ...
}

The `returnANumber` method can return an `ImaginaryNumber` but not an `Object`. `ImaginaryNumber` is a `Number` because it's a subclass of `Number`. However, an `Object` is not necessarily a `Number` ‚Äî it could be a `String` or another type.

You can override a method and define it to return a subclass of the original method, like this:

public ImaginaryNumber returnANumber() {
    ...
}

This technique, called _covariant return type_, means that the return type is allowed to vary in the same direction as the subclass.

* * *

**Note:**¬†You also can use interface names as return types. In this case, the object returned must implement the specified interface.

* * *

<a name="sec_3_12"></a>
## 3.12. [Using the this Keyword](#sec_3_12)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html

Within an instance method or a constructor, `this` is a reference to the _current object_ ‚Äî the object whose method or constructor is being called. You can refer to any member of the current object from within an instance method or a constructor by using `this`.

Using `this` with a Field
-------------------------

The most common reason for using the `this` keyword is because a field is shadowed by a method or constructor parameter.

For example, the `Point` class was written like this

public class Point {
    public int x = 0;
    public int y = 0;
        **
    //constructor
    public Point(int a, int b) {
        x = a;
        y = b;
    }**
}

but it could have been written like this:

public class Point {
    public int x = 0;
    public int y = 0;
        **
    //constructor
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }**
}

Each argument to the constructor shadows one of the object's fields ‚Äî inside the constructor **`x`** is a local copy of the constructor's first argument. To refer to the `Point` field **`x`**, the constructor must use `this.x`.

Using `this` with a Constructor
-------------------------------

From within a constructor, you can also use the `this` keyword to call another constructor in the same class. Doing so is called an _explicit constructor invocation_. Here's another `Rectangle` class, with a different implementation from the one in the [Objects](#sec_3_7) section.

public class Rectangle {
    private int x, y;
    private int width, height;
        
    public Rectangle() {
        **this(0, 0, 1, 1);**
    }
    public Rectangle(int width, int height) {
        **this(0, 0, width, height);**
    }
    public Rectangle(int x, int y, int width, int height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    ...
}

This class contains a set of constructors. Each constructor initializes some or all of the rectangle's member variables. The constructors provide a default value for any member variable whose initial value is not provided by an argument. For example, the no-argument constructor creates a 1x1 `Rectangle` at coordinates 0,0. The two-argument constructor calls the four-argument constructor, passing in the width and height but always using the 0,0 coordinates. As before, the compiler determines which constructor to call, based on the number and the type of arguments.

If present, the invocation of another constructor must be the first line in the constructor.

<a name="sec_3_13"></a>
## 3.13. [Controlling Access to Members of a Class](#sec_3_13)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html

Access level modifiers determine whether other classes can use a particular field or invoke a particular method. There are two levels of access control:

*   At the top level‚Äî`public`, or _package-private_ (no explicit modifier).
*   At the member level‚Äî`public`, `private`, `protected`, or _package-private_ (no explicit modifier).

A class may be declared with the modifier `public`, in which case that class is visible to all classes everywhere. If a class has no modifier (the default, also known as _package-private_), it is visible only within its own package (packages are named groups of related classes ‚Äî you will learn about them in a later lesson.)

At the member level, you can also use the `public` modifier or no modifier (_package-private_) just as with top-level classes, and with the same meaning. For members, there are two additional access modifiers: `private` and `protected`. The `private` modifier specifies that the member can only be accessed in its own class. The `protected` modifier specifies that the member can only be accessed within its own package (as with _package-private_) and, in addition, by a subclass of its class in another package.

The following table shows the access to members permitted by each modifier.

Access Levels 

| Modifier | Class | Package | Subclass | World |
|----------|-------|---------|----------|-------|
| `public`    | Y | Y | Y | Y
| `protected` | Y | Y | Y | N
| no modifier | Y | Y | N | N
| `private`   | Y | N | N | N

The first data column indicates whether the class itself has access to the member defined by the access level. As you can see, a class always has access to its own members. The second column indicates whether classes in the same package as the class (regardless of their parentage) have access to the member. The third column indicates whether subclasses of the class declared outside this package have access to the member. The fourth column indicates whether all classes have access to the member.

Access levels affect you in two ways. First, when you use classes that come from another source, such as the classes in the Java platform, access levels determine which members of those classes your own classes can use. Second, when you write a class, you need to decide what access level every member variable and every method in your class should have.

Let's look at a collection of classes and see how access levels affect visibility. The following figure shows the four classes in this example and how they are related.

![Classes and Packages of the Example Used to Illustrate Access Levels](https://docs.oracle.com/javase/tutorial/figures/java/classes-access.gif)

Classes and Packages of the Example Used to Illustrate Access Levels

The following table shows where the members of the Alpha class are visible for each of the access modifiers that can be applied to them.

Visibility 

| Modifier | Alpha | Beta | Alphasub | Gamma |
|----------|-------|------|----------|-------|
| `public`    | Y | Y | Y | Y
| `protected` | Y | Y | Y | N
| no modifier | Y | Y | N | N
| `private`   | Y | N | N | N

* * *

**Tips on Choosing an Access Level:**¬†

If other programmers use your class, you want to ensure that errors from misuse cannot happen. Access levels can help you do this.

*   Use the most restrictive access level that makes sense for a particular member. Use `private` unless you have a good reason not to.
*   Avoid `public` fields except for constants. (Many of the examples in the tutorial use public fields. This may help to illustrate some points concisely, but is not recommended for production code.) Public fields tend to link you to a particular implementation and limit your flexibility in changing your code.

* * *

<a name="sec_3_14"></a>
## 3.14. [Understanding Class Members](#sec_3_14)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html

In this section, we discuss the use of the `static` keyword to create fields and methods that belong to the class, rather than to an instance of the class.

Class Variables
---------------

When a number of objects are created from the same class blueprint, they each have their own distinct copies of _instance variables_. In the case of the `Bicycle` class, the instance variables are `cadence`, `gear`, and `speed`. Each `Bicycle` object has its own values for these variables, stored in different memory locations.

Sometimes, you want to have variables that are common to all objects. This is accomplished with the `static` modifier. Fields that have the `static` modifier in their declaration are called _static fields_ or _class variables_. They are associated with the class, rather than with any object. Every instance of the class shares a class variable, which is in one fixed location in memory. Any object can change the value of a class variable, but class variables can also be manipulated without creating an instance of the class.

For example, suppose you want to create a number of `Bicycle` objects and assign each a serial number, beginning with 1 for the first object. This ID number is unique to each object and is therefore an instance variable. At the same time, you need a field to keep track of how many `Bicycle` objects have been created so that you know what ID to assign to the next one. Such a field is not related to any individual object, but to the class as a whole. For this you need a class variable, `numberOfBicycles`, as follows:

public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
        
    // **add an instance variable for the object ID**
    private int id;
    
    // **add a class variable for the**
    // **number of Bicycle objects instantiated**
    private **static** int numberOfBicycles = 0;
        ...
}

Class variables are referenced by the class name itself, as in

Bicycle.numberOfBicycles

This makes it clear that they are class variables.

* * *

**Note:**¬†You can also refer to static fields with an object reference like

myBike.numberOfBicycles

but this is discouraged because it does not make it clear that they are class variables.

* * *

You can use the `Bicycle` constructor to set the `id` instance variable and increment the `numberOfBicycles` class variable:

public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
    private int id;
    private static int numberOfBicycles = 0;
        
    public Bicycle(int startCadence, int startSpeed, int startGear){
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;

        // **increment number of Bicycles**
        // **and assign ID number**
        **id = ++numberOfBicycles;**
    }

    // **new method to return the ID instance variable**
    public int getID() {
        return id;
    }
        ...
}

Class Methods
-------------

The Java programming language supports static methods as well as static variables. Static methods, which have the `static` modifier in their declarations, should be invoked with the class name, without the need for creating an instance of the class, as in

ClassName.methodName(args)

* * *

**Note:**¬†You can also refer to static methods with an object reference like

instanceName.methodName(args)

but this is discouraged because it does not make it clear that they are class methods.

* * *

A common use for static methods is to access static fields. For example, we could add a static method to the `Bicycle` class to access the `numberOfBicycles` static field:

public **static** int getNumberOfBicycles() {
    return numberOfBicycles;
}

Not all combinations of instance and class variables and methods are allowed:

*   Instance methods can access instance variables and instance methods directly.
*   Instance methods can access class variables and class methods directly.
*   Class methods can access class variables and class methods directly.
*   Class methods **cannot** access instance variables or instance methods directly‚Äîthey must use an object reference. Also, class methods cannot use the `this` keyword as there is no instance for `this` to refer to.

Constants
---------

The `static` modifier, in combination with the `final` modifier, is also used to define constants. The `final` modifier indicates that the value of this field cannot change.

For example, the following variable declaration defines a constant named `PI`, whose value is an approximation of pi (the ratio of the circumference of a circle to its diameter):

static final double PI = 3.141592653589793;

Constants defined in this way cannot be reassigned, and it is a compile-time error if your program tries to do so. By convention, the names of constant values are spelled in uppercase letters. If the name is composed of more than one word, the words are separated by an underscore (_).

* * *

**Note:**¬†If a primitive type or a string is defined as a constant and the value is known at compile time, the compiler replaces the constant name everywhere in the code with its value. This is called a _compile-time constant_. If the value of the constant in the outside world changes (for example, if it is legislated that pi actually should be 3.975), you will need to recompile any classes that use this constant to get the current value.

* * *

The `Bicycle` Class
-------------------

After all the modifications made in this section, the `Bicycle` class is now:

public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
        
    private int id;
    
    private **static** int numberOfBicycles = 0;

        
    public Bicycle(int startCadence,
                   int startSpeed,
                   int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;

        id = ++numberOfBicycles;
    }

    public int getID() {
        return id;
    }

    public static int getNumberOfBicycles() {
        return numberOfBicycles;
    }

    public int getCadence() {
        return cadence;
    }
        
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public int getGear(){
        return gear;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public int getSpeed() {
        return speed;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
}

<a name="sec_3_15"></a>
## 3.15. [Initializing Fields](#sec_3_15)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html

As you have seen, you can often provide an initial value for a field in its declaration:

public class BedAndBreakfast {

    // initialize to 10
    public static int capacity = 10;

    // initialize to false
    private boolean full = false;
}

This works well when the initialization value is available and the initialization can be put on one line. However, this form of initialization has limitations because of its simplicity. If initialization requires some logic (for example, error handling or a `for` loop to fill a complex array), simple assignment is inadequate. Instance variables can be initialized in constructors, where error handling or other logic can be used. To provide the same capability for class variables, the Java programming language includes _static initialization blocks_.

* * *

**Note:**¬†It is not necessary to declare fields at the beginning of the class definition, although this is the most common practice. It is only necessary that they be declared and initialized before they are used.

* * *

Static Initialization Blocks
----------------------------

A _static initialization block_ is a normal block of code enclosed in braces, `{ }`, and preceded by the `static` keyword. Here is an example:

static {
    // whatever code is needed for initialization goes here
}

A class can have any number of static initialization blocks, and they can appear anywhere in the class body. The runtime system guarantees that static initialization blocks are called in the order that they appear in the source code.

There is an alternative to static blocks ‚Äî you can write a private static method:

class Whatever {
    public static varType myVar = initializeClassVariable();
        
    private static varType initializeClassVariable() {

        // initialization code goes here
    }
}

The advantage of private static methods is that they can be reused later if you need to reinitialize the class variable.

Initializing Instance Members
-----------------------------

Normally, you would put code to initialize an instance variable in a constructor. There are two alternatives to using a constructor to initialize instance variables: initializer blocks and final methods.

Initializer blocks for instance variables look just like static initializer blocks, but without the `static` keyword:

{
    // whatever code is needed for initialization goes here
}

The Java compiler copies initializer blocks into every constructor. Therefore, this approach can be used to share a block of code between multiple constructors.

A _final method_ cannot be overridden in a subclass. This is discussed in the lesson on interfaces and inheritance. Here is an example of using a final method for initializing an instance variable:

class Whatever {
    private varType myVar = initializeInstanceVariable();
        
    protected final varType initializeInstanceVariable() {

        // initialization code goes here
    }
}

This is especially useful if subclasses might want to reuse the initialization method. The method is final because calling non-final methods during instance initialization can cause problems.

<a name="sec_3_16"></a>
## 3.16. [Summary of Creating and Using Classes and Objects](#sec_3_16)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/summaryclasses.html

A class declaration names the class and encloses the class body between braces. The class name can be preceded by modifiers. The class body contains fields, methods, and constructors for the class. A class uses fields to contain state information and uses methods to implement behavior. Constructors that initialize a new instance of a class use the name of the class and look like methods without a return type.

You control access to classes and members in the same way: by using an access modifier such as `public` in their declaration.

You specify a class variable or a class method by using the `static` keyword in the member's declaration. A member that is not declared as `static` is implicitly an instance member. Class variables are shared by all instances of a class and can be accessed through the class name as well as an instance reference. Instances of a class get their own copy of each instance variable, which must be accessed through an instance reference.

You create an object from a class by using the `new` operator and a constructor. The new operator returns a reference to the object that was created. You can assign the reference to a variable or use it directly.

Instance variables and methods that are accessible to code outside of the class that they are declared in can be referred to by using a qualified name. The qualified name of an instance variable looks like this:

_objectReference.variableName_

The qualified name of a method looks like this:

_objectReference.methodName(argumentList)_

or:

_objectReference.methodName()_

The garbage collector automatically cleans up unused objects. An object is unused if the program holds no more references to it. You can explicitly drop a reference by setting the variable holding the reference to `null`.

<a name="sec_3_17"></a>
## 3.17. [Questions and Exercises: Classes](#sec_3_17)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/creating-questions.html

Questions
---------

1.  Consider the following class:
    
    public class IdentifyMyParts {
        public static int x = 7; 
        public int y = 3; 
    }
    
    1.  What are the class variables?
        
    2.  What are the instance variables?
        
    3.  What is the output from the following code:
        
        IdentifyMyParts a = new IdentifyMyParts();
        IdentifyMyParts b = new IdentifyMyParts();
        a.y = 5;
        b.y = 6;
        a.x = 1;
        b.x = 2;
        System.out.println("a.y = " + a.y);
        System.out.println("b.y = " + b.y);
        System.out.println("a.x = " + a.x);
        System.out.println("b.x = " + b.x);
        System.out.println("IdentifyMyParts.x = " + IdentifyMyParts.x);
        

Exercises
---------

1.  Write a class whose instances represent a single playing card from a deck of cards. Playing cards have two distinguishing properties: rank and suit. Be sure to keep your solution as you will be asked to rewrite it in [Enum Types](enum-questions.html).
    
    * * *
    
    **Hint:**¬†
    
    You can use the `assert` statement to check your assignments. You write:
    
    assert (boolean expression to test); 
    
    If the boolean expression is false, you will get an error message. For example,
    
    assert toString(ACE) == "Ace";
    
    should return `true`, so there will be no error message.
    
    If you use the `assert` statement, you must run your program with the `ea` flag:
    
    java -ea YourProgram.class
    
    * * *
    
2.  Write a class whose instances represent a **full** deck of cards. You should also keep this solution.
    
3.  3\. Write a small program to test your deck and card classes. The program can be as simple as creating a deck of cards and displaying its cards.
    

Answers to Questions and Exercises: Classes
===========================================

Questions
---------

1.  Consider the following class:
    
    public class IdentifyMyParts {
        public static int x = 7;
        public int y = 3;
    } 
    
    1.  **Question**: What are the class variables?
        
        **Answer**: x
        
    2.  **Question**: What are the instance variables?
        
        **Answer**: y
        
    3.  **Question**: What is the output from the following code:
        
        IdentifyMyParts a = new IdentifyMyParts(); 
        IdentifyMyParts b = new IdentifyMyParts(); 
        a.y = 5; 
        b.y = 6; 
        a.x = 1; 
        b.x = 2; 
        System.out.println("a.y = " + a.y); 
        System.out.println("b.y = " + b.y); 
        System.out.println("a.x = " + a.x); 
        System.out.println("b.x = " + b.x); 
        System.out.println("IdentifyMyParts.x = " + IdentifyMyParts.x);
        
        **Answer**: Here is the output:
        
         a.y = 5 
         b.y = 6 
         a.x = 2 
         b.x = 2
         IdentifyMyParts.x = 2
        
        Because `x` is defined as a `public static int` in the class `IdentifyMyParts`, every reference to `x` will have the value that was last assigned because `x` is a static variable (and therefore a class variable) shared across all instances of the class. That is, there is only one `x`: when the value of `x` changes in any instance it affects the value of `x` for all instances of `IdentifyMyParts`.
        
        This is covered in the Class Variables section of [Understanding Instance and Class Members](../classvars.html).
        

Exercises
---------

1.  **Exercise**: Write a class whose instances represent a single playing card from a deck of cards. Playing cards have two distinguishing properties: rank and suit. Be sure to keep your solution as you will be asked to rewrite it in [Enum Types](enum-questions.html).
    
    **Answer**: [`` `Card.java` ``](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Card.java)![(in a .java source file)](../../../images/sourceIcon.gif).
    
2.  **Exercise**: Write a class whose instances represents a **full** deck of cards. You should also keep this solution.
    
    **Answer**: See [`` `Deck.java` ``](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Deck.java)![(in a .java source file)](../../../images/sourceIcon.gif).
    
3.  **Exercise**: Write a small program to test your deck and card classes. The program can be as simple as creating a deck of cards and displaying its cards.
    
    **Answer**: See [`` `DisplayDeck.java` ``](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/DisplayDeck.java)![(in a .java source file)](../../../images/sourceIcon.gif).
    

<a name="sec_3_18"></a>
## 3.18. [Questions and Exercises: Objects](#sec_3_18)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/objects-questions.html

Questions
---------

1.  What's wrong with the following program?
    
    public class SomethingIsWrong {
        public static void main(String[] args) {
            Rectangle myRect;
            myRect.width = 40;
            myRect.height = 50;
            System.out.println("myRect's area is " + myRect.area());
        }
    }
    
2.  The following code creates one array and one string object. How many references to those objects exist after the code executes? Is either object eligible for garbage collection?
    
    ...
    String[] students = new String[10];
    String studentName = "Peter Parker";
    students[0] = studentName;
    studentName = null;
    ...
    
3.  How does a program destroy an object that it creates?
    

Exercises
---------

1.  Fix the program called `SomethingIsWrong` shown in Question 1.
    
2.  Given the following class, called [`NumberHolder`](NumberHolder.java), write some code that creates an instance of the class, initializes its two member variables, and then displays the value of each member variable.
    
    public class NumberHolder {
        public int anInt;
        public float aFloat;
    }

Questions
---------

1.  **Question**: What's wrong with the following program?
    
    public class SomethingIsWrong {
        public static void main(String[] args) {
            Rectangle myRect;
            myRect.width = 40;
            myRect.height = 50;
            System.out.println("myRect's area is " + myRect.area());
        }
    }
    
    **Answer**: The code never creates a [`Rectangle`](Rectangle.java) object. With this simple program, the compiler generates an error. However, in a more realistic situation, `myRect` might be initialized to `null` in one place, say in a constructor, and used later. In that case, the program will compile just fine, but will generate a `NullPointerException` at runtime.
    
2.  **Question**: The following code creates one array and one string object. How many references to those objects exist after the code executes? Is either object eligible for garbage collection?
    
    ...
    String[] students = new String[10];
    String studentName = "Peter Smith";
    students[0] = studentName;
    studentName = null;
    ...
    
    **Answer**: There is one reference to the `students` array and that array has one reference to the string `Peter Smith`. Neither object is eligible for garbage collection. The array `students` is not eligible for garbage collection because it has one reference to the object `studentName` even though that object has been assigned the value `null`. The object `studentName` is not eligible either because `students[0]` still refers to it.
    
3.  **Question**: How does a program destroy an object that it creates?
    
    **Answer**: A program does not explicitly destroy objects. A program can set all references to an object to `null` so that it becomes eligible for garbage collection. But the program does not actually destroy objects.
    

Exercises
---------

1.  **Exercise**: Fix the program called `SomethingIsWrong` shown in Question 1.
    
    **Answer**: See [`SomethingIsRight`](SomethingIsRight.java):
    
    public class SomethingIsRight {
        public static void main(String[] args) {
            Rectangle myRect = new Rectangle();
            myRect.width = 40;
            myRect.height = 50;
            System.out.println("myRect's area is " + myRect.area());
        }
    }
    
2.  **Exercise**: Given the following class, called [`NumberHolder`](NumberHolder.java), write some code that creates an instance of the class, initializes its two member variables, and then displays the value of each member variable.
    
    public class NumberHolder {
        public int anInt;
        public float aFloat;
    }
    
    **Answer**: See [`NumberHolderDisplay`](NumberHolderDisplay.java):
    
    public class NumberHolderDisplay {
        public static void main(String[] args) {
        NumberHolder aNumberHolder = new NumberHolder();
        aNumberHolder.anInt = 1;
        aNumberHolder.aFloat = 2.3f;
        System.out.println(aNumberHolder.anInt);
        System.out.println(aNumberHolder.aFloat);
        }
    }
    

<a name="sec_3_19"></a>
## 3.19. [Nested Classes](#sec_3_19)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html

The Java programming language allows you to define a class within another class. Such a class is called a _nested class_ and is illustrated here:

class OuterClass {
    ...
    class NestedClass {
        ...
    }
}

* * *

**Terminology:**¬†Nested classes are divided into two categories: non-static and static. Non-static nested classes are called _inner classes_. Nested classes that are declared `static` are called _static nested classes_.

* * *

class OuterClass {
    ...
    class InnerClass {
        ...
    }
    static class StaticNestedClass {
        ...
    }
}

A nested class is a member of its enclosing class. Non-static nested classes (inner classes) have access to other members of the enclosing class, even if they are declared private. Static nested classes do not have access to other members of the enclosing class. As a member of the `OuterClass`, a nested class can be declared `private`, `public`, `protected`, or _package private_. (Recall that outer classes can only be declared `public` or _package private_.)

Why Use Nested Classes?
-----------------------

Compelling reasons for using nested classes include the following:

*   **It is a way of logically grouping classes that are only used in one place**: If a class is useful to only one other class, then it is logical to embed it in that class and keep the two together. Nesting such "helper classes" makes their package more streamlined.
    
*   **It increases encapsulation**: Consider two top-level classes, A and B, where B needs access to members of A that would otherwise be declared `private`. By hiding class B within class A, A's members can be declared private and B can access them. In addition, B itself can be hidden from the outside world.
    
*   **It can lead to more readable and maintainable code**: Nesting small classes within top-level classes places the code closer to where it is used.
    

Inner Classes
-------------

As with instance methods and variables, an inner class is associated with an instance of its enclosing class and has direct access to that object's methods and fields. Also, because an inner class is associated with an instance, it cannot define any static members itself.

Objects that are instances of an inner class exist _within_ an instance of the outer class. Consider the following classes:

class OuterClass {
    ...
    class InnerClass {
        ...
    }
}

An instance of `InnerClass` can exist only within an instance of `OuterClass` and has direct access to the methods and fields of its enclosing instance.

To instantiate an inner class, you must first instantiate the outer class. Then, create the inner object within the outer object with this syntax:

OuterClass outerObject = new OuterClass();
OuterClass.InnerClass innerObject = outerObject.new InnerClass();

There are two special kinds of inner classes: [local classes](localclasses.html) and [anonymous classes](anonymousclasses.html).

Static Nested Classes
---------------------

As with class methods and variables, a static nested class is associated with its outer class. And like static class methods, a static nested class cannot refer directly to instance variables or methods defined in its enclosing class: it can use them only through an object reference. [Inner Class and Nested Static Class Example](#inner-class-and-nested-static-class-example) demonstrates this.

* * *

**Note:**¬†A static nested class interacts with the instance members of its outer class (and other classes) just like any other top-level class. In effect, a static nested class is behaviorally a top-level class that has been nested in another top-level class for packaging convenience. [Inner Class and Nested Static Class Example](#inner-class-and-nested-static-class-example) also demonstrates this.

* * *

You instantiate a static nested class the same way as a top-level class:

StaticNestedClass staticNestedObject = new StaticNestedClass();

Inner Class and Nested Static Class Example
-------------------------------------------

The following example, [`OuterClass`](https://docs.oracle.com/javase/tutorial/java/data/examples/OuterClass.java), along with [`TopLevelClass`](https://docs.oracle.com/javase/tutorial/java/data/examples/TopLevelClass.java), demonstrates which class members of `OuterClass` an inner class (`InnerClass`), a nested static class (`StaticNestedClass`), and a top-level class (`TopLevelClass`) can access:

### OuterClass.java

public class OuterClass {

    String outerField = "Outer field";
    static String staticOuterField = "Static outer field";

    class InnerClass {
        void accessMembers() {
            System.out.println(outerField);
            System.out.println(staticOuterField);
        }
    }

    static class StaticNestedClass {
        void accessMembers(OuterClass outer) {
            // Compiler error: Cannot make a static reference to the non-static
            //     field outerField
            // System.out.println(outerField);
            System.out.println(outer.outerField);
            System.out.println(staticOuterField);
        }
    }

    public static void main(String[] args) {
        System.out.println("Inner class:");
        System.out.println("------------");
        OuterClass outerObject = new OuterClass();
        OuterClass.InnerClass innerObject = outerObject.new InnerClass();
        innerObject.accessMembers();

        System.out.println("\nStatic nested class:");
        System.out.println("--------------------");
        StaticNestedClass staticNestedObject = new StaticNestedClass();        
        staticNestedObject.accessMembers(outerObject);
        
        System.out.println("\nTop-level class:");
        System.out.println("--------------------");
        TopLevelClass topLevelObject = new TopLevelClass();        
        topLevelObject.accessMembers(outerObject);                
    }
}

### TopLevelClass.java

public class TopLevelClass {

    void accessMembers(OuterClass outer) {     
        // Compiler error: Cannot make a static reference to the non-static
        //     field OuterClass.outerField
        // System.out.println(OuterClass.outerField);
        System.out.println(outer.outerField);
        System.out.println(OuterClass.staticOuterField);
    }  
}

This example prints the following output:

Inner class:
------------
Outer field
Static outer field

Static nested class:
--------------------
Outer field
Static outer field

Top-level class:
--------------------
Outer field
Static outer field

Note that a static nested class interacts with the instance members of its outer class just like any other top-level class. The static nested class `StaticNestedClass` can't directly access `outerField` because it's an instance variable of the enclosing class, `OuterClass`. The Java compiler generates an error at the highlighted statement:

static class StaticNestedClass {
    void accessMembers(OuterClass outer) {
       // Compiler error: Cannot make a static reference to the non-static
       //     field outerField
       **System.out.println(outerField);**
    }
}

To fix this error, access `outerField` through an object reference:

System.out.println(outer.outerField);

Similarly, the top-level class `TopLevelClass` can't directly access `outerField` either.

Shadowing
---------

If a declaration of a type (such as a member variable or a parameter name) in a particular scope (such as an inner class or a method definition) has the same name as another declaration in the enclosing scope, then the declaration _shadows_ the declaration of the enclosing scope. You cannot refer to a shadowed declaration by its name alone. The following example, [`ShadowTest`](https://docs.oracle.com/javase/tutorial/java/data/examples/ShadowTest.java), demonstrates this:

 
public class ShadowTest {

    public int x = 0;

    class FirstLevel {

        public int x = 1;

        void methodInFirstLevel(int x) {
            System.out.println("x = " + x);
            System.out.println("this.x = " + this.x);
            System.out.println("ShadowTest.this.x = " + ShadowTest.this.x);
        }
    }

    public static void main(String... args) {
        ShadowTest st = new ShadowTest();
        ShadowTest.FirstLevel fl = st.new FirstLevel();
        fl.methodInFirstLevel(23);
    }
}

The following is the output of this example:

x = 23
this.x = 1
ShadowTest.this.x = 0

This example defines three variables named `x`: the member variable of the class `ShadowTest`, the member variable of the inner class `FirstLevel`, and the parameter in the method `methodInFirstLevel`. The variable `x` defined as a parameter of the method `methodInFirstLevel` shadows the variable of the inner class `FirstLevel`. Consequently, when you use the variable `x` in the method `methodInFirstLevel`, it refers to the method parameter. To refer to the member variable of the inner class `FirstLevel`, use the keyword `this` to represent the enclosing scope:

System.out.println("this.x = " + this.x);

Refer to member variables that enclose larger scopes by the class name to which they belong. For example, the following statement accesses the member variable of the class `ShadowTest` from the method `methodInFirstLevel`:

System.out.println("ShadowTest.this.x = " + ShadowTest.this.x);

Serialization
-------------

[Serialization](https://docs.oracle.com/javase/tutorial/jndi/objects/serial.html) of inner classes, including [local](localclasses.html) and [anonymous](anonymousclasses.html) classes, is strongly discouraged. When the Java compiler compiles certain constructs, such as inner classes, it creates _synthetic constructs_; these are classes, methods, fields, and other constructs that do not have a corresponding construct in the source code. Synthetic constructs enable Java compilers to implement new Java language features without changes to the JVM. However, synthetic constructs can vary among different Java compiler implementations, which means that `.class` files can vary among different implementations as well. Consequently, you may have compatibility issues if you serialize an inner class and then deserialize it with a different JRE implementation. See the section [Implicit and Synthetic Parameters](../../reflect/member/methodparameterreflection.html#implcit_and_synthetic) in the section [Obtaining Names of Method Parameters](../../reflect/member/methodparameterreflection.html) for more information about the synthetic constructs generated when an inner class is compiled.

<a name="sec_3_20"></a>
## 3.20. [Inner Class Example](#sec_3_20)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/innerclasses.html

To see an inner class in use, first consider an array. In the following example, you create an array, fill it with integer values, and then output only values of even indices of the array in ascending order.

The [`DataStructure.java`](https://docs.oracle.com/javase/tutorial/java/data/examples/DataStructure.java) example that follows consists of:

*   The `DataStructure` outer class, which includes a constructor to create an instance of `DataStructure` containing an array filled with consecutive integer values (0, 1, 2, 3, and so on) and a method that prints elements of the array that have an even index value.
*   The `EvenIterator` inner class, which implements the `DataStructureIterator` interface, which extends the [`Iterator`](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)`<` [`Integer`](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html)`>` interface. Iterators are used to step through a data structure and typically have methods to test for the last element, retrieve the current element, and move to the next element.
*   A `main` method that instantiates a `DataStructure` object (`ds`), then invokes the `printEven` method to print elements of the array `arrayOfInts` that have an even index value.

 
public class DataStructure {
    
    // Create an array
    private final static int SIZE = 15;
    private int[] arrayOfInts = new int[SIZE];
    
    public DataStructure() {
        // fill the array with ascending integer values
        for (int i = 0; i < SIZE; i++) {
            arrayOfInts[i] = i;
        }
    }
    
    public void printEven() {
        
        // Print out values of even indices of the array
        DataStructureIterator iterator = this.new EvenIterator();
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
        }
        System.out.println();
    }
    
    interface DataStructureIterator extends java.util.Iterator<Integer> { } 

    // Inner class implements the DataStructureIterator interface,
    // which extends the Iterator<Integer> interface
    
    private class EvenIterator implements DataStructureIterator {
        
        // Start stepping through the array from the beginning
        private int nextIndex = 0;
        
        public boolean hasNext() {
            
            // Check if the current element is the last in the array
            return (nextIndex <= SIZE - 1);
        }        
        
        public Integer next() {
            
            // Record a value of an even index of the array
            Integer retValue = Integer.valueOf(arrayOfInts[nextIndex]);
            
            // Get the next even element
            nextIndex += 2;
            return retValue;
        }
    }
    
    public static void main(String s[]) {
        
        // Fill the array with integer values and print out only
        // values of even indices
        DataStructure ds = new DataStructure();
        ds.printEven();
    }
}

The output is:

0 2 4 6 8 10 12 14 

Note that the `EvenIterator` class refers directly to the `arrayOfInts` instance variable of the `DataStructure` object.

You can use inner classes to implement helper classes such as the one shown in the this example. To handle user interface events, you must know how to use inner classes, because the event-handling mechanism makes extensive use of them.

Local and Anonymous Classes
---------------------------

There are two additional types of inner classes. You can declare an inner class within the body of a method. These classes are known as [local classes](localclasses.html). You can also declare an inner class within the body of a method without naming the class. These classes are known as [anonymous classes](anonymousclasses.html).

Modifiers
---------

You can use the same modifiers for inner classes that you use for other members of the outer class. For example, you can use the access specifiers `private`, `public`, and `protected` to restrict access to inner classes, just as you use them to restrict access do to other class members.

<a name="sec_3_21"></a>
## 3.21. [Local Classes](#sec_3_21)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html

Local classes are classes that are defined in a _block_, which is a group of zero or more statements between balanced braces. You typically find local classes defined in the body of a method.

This section covers the following topics:

*   [Declaring Local Classes](#declaring-local-classes)
*   [Accessing Members of an Enclosing Class](#accessing-members-of-an-enclosing-class)
    *   [Shadowing and Local Classes](#shadowing-and-local-classes)
*   [Local Classes Are Similar To Inner Classes](#local-classes-are-similar-to-inner-classes)

Declaring Local Classes
-----------------------

You can define a local class inside any block (see [Expressions, Statements, and Blocks](../../java/nutsandbolts/expressions.html) for more information). For example, you can define a local class in a method body, a `for` loop, or an `if` clause.

The following example, [`LocalClassExample`](https://docs.oracle.com/javase/tutorial/java/data/examples/LocalClassExample.java), validates two phone numbers. It defines the local class `PhoneNumber` in the method `validatePhoneNumber`:

 
public class LocalClassExample {
  
    static String regularExpression = "[^0-9]";
  
    public static void validatePhoneNumber(
        String phoneNumber1, String phoneNumber2) {
      
        final int numberLength = 10;
        
        // Valid in JDK 8 and later:
       
        // int numberLength = 10;
       
        class PhoneNumber {
            
            String formattedPhoneNumber = null;

            PhoneNumber(String phoneNumber){
                // numberLength = 7;
                String currentNumber = phoneNumber.replaceAll(
                  regularExpression, "");
                if (currentNumber.length() == numberLength)
                    formattedPhoneNumber = currentNumber;
                else
                    formattedPhoneNumber = null;
            }

            public String getNumber() {
                return formattedPhoneNumber;
            }
            
            // Valid in JDK 8 and later:

//            public void printOriginalNumbers() {
//                System.out.println("Original numbers are " + phoneNumber1 +
//                    " and " + phoneNumber2);
//            }
        }

        PhoneNumber myNumber1 = new PhoneNumber(phoneNumber1);
        PhoneNumber myNumber2 = new PhoneNumber(phoneNumber2);
        
        // Valid in JDK 8 and later:

//        myNumber1.printOriginalNumbers();

        if (myNumber1.getNumber() == null) 
            System.out.println("First number is invalid");
        else
            System.out.println("First number is " + myNumber1.getNumber());
        if (myNumber2.getNumber() == null)
            System.out.println("Second number is invalid");
        else
            System.out.println("Second number is " + myNumber2.getNumber());

    }

    public static void main(String... args) {
        validatePhoneNumber("123-456-7890", "456-7890");
    }
}

The example validates a phone number by first removing all characters from the phone number except the digits 0 through 9. After, it checks whether the phone number contains exactly ten digits (the length of a phone number in North America). This example prints the following:

First number is 1234567890
Second number is invalid

Accessing Members of an Enclosing Class
---------------------------------------

A local class has access to the members of its enclosing class. In the previous example, the `PhoneNumber` constructor accesses the member `LocalClassExample.regularExpression`.

In addition, a local class has access to local variables. However, a local class can only access local variables that are declared final. When a local class accesses a local variable or parameter of the enclosing block, it _captures_ that variable or parameter. For example, the `PhoneNumber` constructor can access the local variable `numberLength` because it is declared final; `numberLength` is a _captured variable_.

However, starting in Java SE 8, a local class can access local variables and parameters of the enclosing block that are final or _effectively final_. A variable or parameter whose value is never changed after it is initialized is effectively final. For example, suppose that the variable `numberLength` is not declared final, and you add the highlighted assignment statement in the `PhoneNumber` constructor to change the length of a valid phone number to 7 digits:

PhoneNumber(String phoneNumber) {
    **numberLength = 7;**
    String currentNumber = phoneNumber.replaceAll(
        regularExpression, "");
    if (currentNumber.length() == numberLength)
        formattedPhoneNumber = currentNumber;
    else
        formattedPhoneNumber = null;
}

Because of this assignment statement, the variable `numberLength` is not effectively final anymore. As a result, the Java compiler generates an error message similar to "local variables referenced from an inner class must be final or effectively final" where the inner class `PhoneNumber` tries to access the `numberLength` variable:

if (currentNumber.length() == numberLength)

Starting in Java SE 8, if you declare the local class in a method, it can access the method's parameters. For example, you can define the following method in the `PhoneNumber` local class:

public void printOriginalNumbers() {
    System.out.println("Original numbers are " + phoneNumber1 +
        " and " + phoneNumber2);
}

The method `printOriginalNumbers` accesses the parameters `phoneNumber1` and `phoneNumber2` of the method `validatePhoneNumber`.

### Shadowing and Local Classes

Declarations of a type (such as a variable) in a local class shadow declarations in the enclosing scope that have the same name. See [Shadowing](../../java/javaOO/nested.html#shadowing) for more information.

Local Classes Are Similar To Inner Classes
------------------------------------------

Local classes are similar to inner classes because they cannot define or declare any static members. Local classes in static methods, such as the class `PhoneNumber`, which is defined in the static method `validatePhoneNumber`, can only refer to static members of the enclosing class. For example, if you do not define the member variable `regularExpression` as static, then the Java compiler generates an error similar to "non-static variable `regularExpression` cannot be referenced from a static context."

Local classes are non-static because they have access to instance members of the enclosing block. Consequently, they cannot contain most kinds of static declarations.

You cannot declare an interface inside a block; interfaces are inherently static. For example, the following code excerpt does not compile because the interface `HelloThere` is defined inside the body of the method `greetInEnglish`:

    public void greetInEnglish() {
        interface HelloThere {
           public void greet();
        }
        class EnglishHelloThere implements HelloThere {
            public void greet() {
                System.out.println("Hello " + name);
            }
        }
        HelloThere myGreeting = new EnglishHelloThere();
        myGreeting.greet();
    }

You cannot declare static initializers or member interfaces in a local class. The following code excerpt does not compile because the method `EnglishGoodbye.sayGoodbye` is declared `static`. The compiler generates an error similar to "modifier 'static' is only allowed in constant variable declaration" when it encounters this method definition:

    public void sayGoodbyeInEnglish() {
        class EnglishGoodbye {
            public static void sayGoodbye() {
                System.out.println("Bye bye");
            }
        }
        EnglishGoodbye.sayGoodbye();
    }

A local class can have static members provided that they are constant variables. (A _constant variable_ is a variable of primitive type or type `String` that is declared final and initialized with a compile-time constant expression. A compile-time constant expression is typically a string or an arithmetic expression that can be evaluated at compile time. See [Understanding Class Members](classvars.html) for more information.) The following code excerpt compiles because the static member `EnglishGoodbye.farewell` is a constant variable:

    public void sayGoodbyeInEnglish() {
        class EnglishGoodbye {
            public static final String farewell = "Bye bye";
            public void sayGoodbye() {
                System.out.println(farewell);
            }
        }
        EnglishGoodbye myEnglishGoodbye = new EnglishGoodbye();
        myEnglishGoodbye.sayGoodbye();
    }

<a name="sec_3_22"></a>
## 3.22. [Anonymous Classes](#sec_3_22)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html

Anonymous classes enable you to make your code more concise. They enable you to declare and instantiate a class at the same time. They are like local classes except that they do not have a name. Use them if you need to use a local class only once.

This section covers the following topics:

*   [Declaring Anonymous Classes](#declaring-anonymous-classes)
*   [Syntax of Anonymous Classes](#syntax-of-anonymous-classes)
*   [Accessing Local Variables of the Enclosing Scope, and Declaring and Accessing Members of the Anonymous Class](#accessing)
*   [Examples of Anonymous Classes](#examples-of-anonymous-classes)

Declaring Anonymous Classes
---------------------------

While local classes are class declarations, anonymous classes are expressions, which means that you define the class in another expression. The following example, [`HelloWorldAnonymousClasses`](https://docs.oracle.com/javase/tutorial/java/data/examples/HelloWorldAnonymousClasses.java), uses anonymous classes in the initialization statements of the local variables `frenchGreeting` and `spanishGreeting`, but uses a local class for the initialization of the variable `englishGreeting``:`

public class HelloWorldAnonymousClasses {
  
    interface HelloWorld {
        public void greet();
        public void greetSomeone(String someone);
    }
  
    public void sayHello() {
        
        class EnglishGreeting implements HelloWorld {
            String name = "world";
            public void greet() {
                greetSomeone("world");
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println("Hello " + name);
            }
        }
      
        HelloWorld englishGreeting = new EnglishGreeting();
        
        HelloWorld frenchGreeting = new HelloWorld() {
            String name = "tout le monde";
            public void greet() {
                greetSomeone("tout le monde");
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println("Salut " + name);
            }
        };
        
        HelloWorld spanishGreeting = new HelloWorld() {
            String name = "mundo";
            public void greet() {
                greetSomeone("mundo");
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println("Hola, " + name);
            }
        };
        englishGreeting.greet();
        frenchGreeting.greetSomeone("Fred");
        spanishGreeting.greet();
    }

    public static void main(String... args) {
        HelloWorldAnonymousClasses myApp =
            new HelloWorldAnonymousClasses();
        myApp.sayHello();
    }            
}

Syntax of Anonymous Classes
---------------------------

As mentioned previously, an anonymous class is an expression. The syntax of an anonymous class expression is like the invocation of a constructor, except that there is a class definition contained in a block of code.

Consider the instantiation of the `frenchGreeting` object:

        HelloWorld frenchGreeting = new HelloWorld() {
            String name = "tout le monde";
            public void greet() {
                greetSomeone("tout le monde");
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println("Salut " + name);
            }
        };

The anonymous class expression consists of the following:

*   The `new` operator
    
*   The name of an interface to implement or a class to extend. In this example, the anonymous class is implementing the interface `HelloWorld`.
    
*   Parentheses that contain the arguments to a constructor, just like a normal class instance creation expression. **Note**: When you implement an interface, there is no constructor, so you use an empty pair of parentheses, as in this example.
    
*   A body, which is a class declaration body. More specifically, in the body, method declarations are allowed but statements are not.
    

Because an anonymous class definition is an expression, it must be part of a statement. In this example, the anonymous class expression is part of the statement that instantiates the `frenchGreeting` object. (This explains why there is a semicolon after the closing brace.)

Accessing Local Variables of the Enclosing Scope, and Declaring and Accessing Members of the Anonymous Class
------------------------------------------------------------------------------------------------------------

Like local classes, anonymous classes can [capture variables](localclasses.html#accessing-members-of-an-enclosing-class); they have the same access to local variables of the enclosing scope:

*   An anonymous class has access to the members of its enclosing class.
    
*   An anonymous class cannot access local variables in its enclosing scope that are not declared as `final` or effectively final.
    
*   Like a nested class, a declaration of a type (such as a variable) in an anonymous class shadows any other declarations in the enclosing scope that have the same name. See [Shadowing](../../java/javaOO/nested.html#shadowing) for more information.
    

Anonymous classes also have the same restrictions as local classes with respect to their members:

*   You cannot declare static initializers or member interfaces in an anonymous class.
    
*   An anonymous class can have static members provided that they are constant variables.
    

Note that you can declare the following in anonymous classes:

*   Fields
    
*   Extra methods (even if they do not implement any methods of the supertype)
    
*   Instance initializers
    
*   Local classes
    

However, you cannot declare constructors in an anonymous class.

Examples of Anonymous Classes
-----------------------------

Anonymous classes are often used in graphical user interface (GUI) applications.

Consider the JavaFX example [`HelloWorld.java`](https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm) (from the section [Hello World, JavaFX Style](https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm) from [Getting Started with JavaFX](https://docs.oracle.com/javase/8/javafx/get-started-tutorial/javafx_get_started.htm)). This sample creates a frame that contains a **Say 'Hello World'** button. The anonymous class expression is highlighted:

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;
 
public class HelloWorld extends Application {
    public static void main(String[] args) {
        launch(args);
    }
    
    @Override
    public void start(Stage primaryStage) {
        primaryStage.setTitle("Hello World!");
        Button btn = new Button();
        btn.setText("Say 'Hello World'");
        btn.setOnAction(**new EventHandler<ActionEvent>() {**
 
            **@Override**
            **public void handle(ActionEvent event) {**
                **System.out.println("Hello World!");**
            **}**
        **}**);
        
        StackPane root = new StackPane();
        root.getChildren().add(btn);
        primaryStage.setScene(new Scene(root, 300, 250));
        primaryStage.show();
    }
}

In this example, the method invocation `btn.setOnAction` specifies what happens when you select the **Say 'Hello World'** button. This method requires an object of type `EventHandler<ActionEvent>`. The `EventHandler<ActionEvent>` interface contains only one method, handle. Instead of implementing this method with a new class, the example uses an anonymous class expression. Notice that this expression is the argument passed to the `btn.setOnAction` method.

Because the `EventHandler<ActionEvent>` interface contains only one method, you can use a lambda expression instead of an anonymous class expression. See the section [Lambda Expressions](lambdaexpressions.html) for more information.

Anonymous classes are ideal for implementing an interface that contains two or more methods. The following JavaFX example is from the section [Customization of UI Controls](https://docs.oracle.com/javase/8/javafx/user-interface-tutorial/custom.htm). The highlighted code creates a text field that only accepts numeric values. It redefines the default implementation of the `TextField` class with an anonymous class by overriding the `replaceText` and `replaceSelection` methods inherited from the `TextInputControl` class.

```java
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class CustomTextFieldSample extends Application {
    
    final static Label label = new Label();
 
    @Override
    public void start(Stage stage) {
        Group root = new Group();
        Scene scene = new Scene(root, 300, 150);
        stage.setScene(scene);
        stage.setTitle("Text Field Sample");
 
        GridPane grid = new GridPane();
        grid.setPadding(new Insets(10, 10, 10, 10));
        grid.setVgap(5);
        grid.setHgap(5);
 
        scene.setRoot(grid);
        final Label dollar = new Label("$");
        GridPane.setConstraints(dollar, 0, 0);
        grid.getChildren().add(dollar);
        
        final TextField sum = **new TextField() {**
            **@Override**
            **public void replaceText(int start, int end, String text) {**
                **if (!text.matches("[a-z, A-Z]")) {**
                    **super.replaceText(start, end, text);**                     
                **}**
                **label.setText("Enter a numeric value");**
            **}**
 
            **@Override**
            **public void replaceSelection(String text) {**
                **if (!text.matches("[a-z, A-Z]")) {**
                    **super.replaceSelection(text);**
                **}**
            **}**
        **};**
 
        sum.setPromptText("Enter the total");
        sum.setPrefColumnCount(10);
        GridPane.setConstraints(sum, 1, 0);
        grid.getChildren().add(sum);
        
        Button submit = new Button("Submit");
        GridPane.setConstraints(submit, 2, 0);
        grid.getChildren().add(submit);
        
        submit.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                label.setText(null);
            }
        });
        
        GridPane.setConstraints(label, 0, 1);
        GridPane.setColumnSpan(label, 3);
        grid.getChildren().add(label);
        
        scene.setRoot(grid);
        stage.show();
    }
 
    public static void main(String[] args) {
        launch(args);
    }
}
```

<a name="sec_3_23"></a>
## 3.23. [Lambda Expressions](#sec_3_23)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html

One issue with anonymous classes is that if the implementation of your anonymous class is very simple, such as an interface that contains only one method, then the syntax of anonymous classes may seem unwieldy and unclear. In these cases, you're usually trying to pass functionality as an argument to another method, such as what action should be taken when someone clicks a button. Lambda expressions enable you to do this, to treat functionality as method argument, or code as data.

The previous section, [Anonymous Classes](anonymousclasses.html), shows you how to implement a base class without giving it a name. Although this is often more concise than a named class, for classes with only one method, even an anonymous class seems a bit excessive and cumbersome. Lambda expressions let you express instances of single-method classes more compactly.

This section covers the following topics:

*   [Ideal Use Case for Lambda Expressions](#use-case)
    *   [Approach 1: Create Methods That Search for Members That Match One Characteristic](#approach1)
    *   [Approach 2: Create More Generalized Search Methods](#approach2)
    *   [Approach 3: Specify Search Criteria Code in a Local Class](#approach3)
    *   [Approach 4: Specify Search Criteria Code in an Anonymous Class](#approach4)
    *   [Approach 5: Specify Search Criteria Code with a Lambda Expression](#approach5)
    *   [Approach 6: Use Standard Functional Interfaces with Lambda Expressions](#approach6)
    *   [Approach 7: Use Lambda Expressions Throughout Your Application](#approach7)
    *   [Approach 8: Use Generics More Extensively](#approach8)
    *   [Approach 9: Use Aggregate Operations That Accept Lambda Expressions as Parameters](#approach9)
*   [Lambda Expressions in GUI Applications](#lambda-expressions-in-gui-applications)
*   [Syntax of Lambda Expressions](#syntax)
*   [Accessing Local Variables of the Enclosing Scope](#accessing-local-variables)
*   [Target Typing](#target-typing)
    *   [Target Types and Method Arguments](#target-types-and-method-arguments)
*   [Serialization](#serialization)

Ideal Use Case for Lambda Expressions
-------------------------------------

Suppose that you are creating a social networking application. You want to create a feature that enables an administrator to perform any kind of action, such as sending a message, on members of the social networking application that satisfy certain criteria. The following table describes this use case in detail:

| Field | Description |
|-------|-------------|
| Name          | Perform action on selected members
| Primary Actor | Administrator
| Preconditions | Administrator is logged in to the system.
| Postconditions| Action is performed only on members that fit the specified criteria.

Main Success Scenario

1.  Administrator specifies criteria of members on which to perform a certain action.
2.  Administrator specifies an action to perform on those selected members.
3.  Administrator selects the **Submit** button.
4.  The system finds all members that match the specified criteria.
5.  The system performs the specified action on all matching members.

Extensions

1a. Administrator has an option to preview those members who match the specified criteria before he or she specifies the action to be performed or before selecting the **Submit** button.

Frequency of Occurrence

Many times during the day.

Suppose that members of this social networking application are represented by the following [`Person`](https://docs.oracle.com/javase/tutorial/java/data/examples/Person.java) class:

public class Person {

    public enum Sex {
        MALE, FEMALE
    }

    String name;
    LocalDate birthday;
    Sex gender;
    String emailAddress;

    public int getAge() {
        // ...
    }

    public void printPerson() {
        // ...
    }
}

Suppose that the members of your social networking application are stored in a `List<Person>` instance.

This section begins with a naive approach to this use case. It improves upon this approach with local and anonymous classes, and then finishes with an efficient and concise approach using lambda expressions. Find the code excerpts described in this section in the example [`RosterTest`](https://docs.oracle.com/javase/tutorial/java/data/examples/RosterTest.java).

### Approach 1: Create Methods That Search for Members That Match One Characteristic

One simplistic approach is to create several methods; each method searches for members that match one characteristic, such as gender or age. The following method prints members that are older than a specified age:

public static void printPersonsOlderThan(List<Person> roster, int age) {
    for (Person p : roster) {
        if (p.getAge() >= age) {
            p.printPerson();
        }
    }
}

**Note**: A [`List`](https://docs.oracle.com/javase/8/docs/api/java/util/List.html) is an ordered [`Collection`](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html). A _collection_ is an object that groups multiple elements into a single unit. Collections are used to store, retrieve, manipulate, and communicate aggregate data. For more information about collections, see the [Collections](../../collections/index.html) trail.

This approach can potentially make your application _brittle_, which is the likelihood of an application not working because of the introduction of updates (such as newer data types). Suppose that you upgrade your application and change the structure of the `Person` class such that it contains different member variables; perhaps the class records and measures ages with a different data type or algorithm. You would have to rewrite a lot of your API to accommodate this change. In addition, this approach is unnecessarily restrictive; what if you wanted to print members younger than a certain age, for example?

### Approach 2: Create More Generalized Search Methods

The following method is more generic than `printPersonsOlderThan`; it prints members within a specified range of ages:

public static void printPersonsWithinAgeRange(
    List<Person> roster, int low, int high) {
    for (Person p : roster) {
        if (low <= p.getAge() && p.getAge() < high) {
            p.printPerson();
        }
    }
}

What if you want to print members of a specified sex, or a combination of a specified gender and age range? What if you decide to change the `Person` class and add other attributes such as relationship status or geographical location? Although this method is more generic than `printPersonsOlderThan`, trying to create a separate method for each possible search query can still lead to brittle code. You can instead separate the code that specifies the criteria for which you want to search in a different class.

### Approach 3: Specify Search Criteria Code in a Local Class

The following method prints members that match search criteria that you specify:

public static void printPersons(
    List<Person> roster, CheckPerson tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}

This method checks each `Person` instance contained in the `List` parameter `roster` whether it satisfies the search criteria specified in the `CheckPerson` parameter `tester` by invoking the method `tester.test`. If the method `tester.test` returns a `true` value, then the method `printPersons` is invoked on the `Person` instance.

To specify the search criteria, you implement the `CheckPerson` interface:

interface CheckPerson {
    boolean test(Person p);
}

The following class implements the `CheckPerson` interface by specifying an implementation for the method `test`. This method filters members that are eligible for Selective Service in the United States: it returns a `true` value if its `Person` parameter is male and between the ages of 18 and 25:

class CheckPersonEligibleForSelectiveService implements CheckPerson {
    public boolean test(Person p) {
        return p.gender == Person.Sex.MALE &&
            p.getAge() >= 18 &&
            p.getAge() <= 25;
    }
}

To use this class, you create a new instance of it and invoke the `printPersons` method:

printPersons(
    roster, new CheckPersonEligibleForSelectiveService());

Although this approach is less brittle‚Äîyou don't have to rewrite methods if you change the structure of the `Person`‚Äîyou still have additional code: a new interface and a local class for each search you plan to perform in your application. Because `CheckPersonEligibleForSelectiveService` implements an interface, you can use an anonymous class instead of a local class and bypass the need to declare a new class for each search.

### Approach 4: Specify Search Criteria Code in an Anonymous Class

One of the arguments of the following invocation of the method `printPersons` is an anonymous class that filters members that are eligible for Selective Service in the United States: those who are male and between the ages of 18 and 25:

printPersons(
    roster,
    new CheckPerson() {
        public boolean test(Person p) {
            return p.getGender() == Person.Sex.MALE
                && p.getAge() >= 18
                && p.getAge() <= 25;
        }
    }
);

This approach reduces the amount of code required because you don't have to create a new class for each search that you want to perform. However, the syntax of anonymous classes is bulky considering that the `CheckPerson` interface contains only one method. In this case, you can use a lambda expression instead of an anonymous class, as described in the next section.
```java

```
### Approach 5: Specify Search Criteria Code with a Lambda Expression

The `CheckPerson` interface is a _functional interface_. A functional interface is any interface that contains only one [abstract method](../../java/IandI/abstract.html). (A functional interface may contain one or more [default methods](../../java/IandI/defaultmethods.html) or [static methods](../../java/IandI/defaultmethods.html#static).) Because a functional interface contains only one abstract method, you can omit the name of that method when you implement it. To do this, instead of using an anonymous class expression, you use a _lambda expression_, which is highlighted in the following method invocation:

printPersons(
    roster,
    **(Person p) -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25**
);

See [Syntax of Lambda Expressions](#syntax) for information about how to define lambda expressions.

You can use a standard functional interface in place of the interface `CheckPerson`, which reduces even further the amount of code required.

### Approach 6: Use Standard Functional Interfaces with Lambda Expressions

Reconsider the `CheckPerson` interface:

interface CheckPerson {
    boolean test(Person p);
}

This is a very simple interface. It's a functional interface because it contains only one abstract method. This method takes one parameter and returns a `boolean` value. The method is so simple that it might not be worth it to define one in your application. Consequently, the JDK defines several standard functional interfaces, which you can find in the package `java.util.function`.

For example, you can use the `Predicate<T>` interface in place of `CheckPerson`. This interface contains the method `boolean test(T t)`:

interface Predicate<T> {
    boolean test(T t);
}

The interface `Predicate<T>` is an example of a generic interface. (For more information about generics, see the [Generics (Updated)](../../java/generics/index.html) lesson.) Generic types (such as generic interfaces) specify one or more type parameters within angle brackets (`<>`). This interface contains only one type parameter, `T`. When you declare or instantiate a generic type with actual type arguments, you have a parameterized type. For example, the parameterized type `Predicate<Person>` is the following:

interface Predicate<`Person`> {
    boolean test(`Person` t);
}

This parameterized type contains a method that has the same return type and parameters as `CheckPerson.boolean test(Person p)`. Consequently, you can use `Predicate<T>` in place of `CheckPerson` as the following method demonstrates:

```java
public static void printPersonsWithPredicate(
    List<Person> roster, Predicate<Person> tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}
```

As a result, the following method invocation is the same as when you invoked `printPersons` in [Approach 3: Specify Search Criteria Code in a Local Class](#approach3) to obtain members who are eligible for Selective Service:

```java
printPersonsWithPredicate(
    roster,
    p -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25
);
```

This is not the only possible place in this method to use a lambda expression. The following approach suggests other ways to use lambda expressions.

### Approach 7: Use Lambda Expressions Throughout Your Application

Reconsider the method `printPersonsWithPredicate` to see where else you could use lambda expressions:

```java
public static void printPersonsWithPredicate(
    List<Person> roster, Predicate<Person> tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}
```

This method checks each `Person` instance contained in the `List` parameter `roster` whether it satisfies the criteria specified in the `Predicate` parameter `tester`. If the `Person` instance does satisfy the criteria specified by `tester`, the method `printPerson` is invoked on the `Person` instance.

Instead of invoking the method `printPerson`, you can specify a different action to perform on those `Person` instances that satisfy the criteria specified by `tester`. You can specify this action with a lambda expression. Suppose you want a lambda expression similar to `printPerson`, one that takes one argument (an object of type `Person`) and returns void. Remember, to use a lambda expression, you need to implement a functional interface. In this case, you need a functional interface that contains an abstract method that can take one argument of type `Person` and returns void. The `Consumer<T>` interface contains the method `void accept(T t)`, which has these characteristics. The following method replaces the invocation `p.printPerson()` with an instance of `Consumer<Person>` that invokes the method `accept`:

public static void processPersons(
    List<Person> roster,
    Predicate<Person> tester,
    **Consumer<Person> block**) {
        for (Person p : roster) {
            if (tester.test(p)) {
                **block.accept(p);**
            }
        }
}

As a result, the following method invocation is the same as when you invoked `printPersons` in [Approach 3: Specify Search Criteria Code in a Local Class](#approach3) to obtain members who are eligible for Selective Service. The lambda expression used to print members is highlighted:

processPersons(
     roster,
     p -> p.getGender() == Person.Sex.MALE
         && p.getAge() >= 18
         && p.getAge() <= 25,
     **p -> p.printPerson()**
);

What if you want to do more with your members' profiles than printing them out. Suppose that you want to validate the members' profiles or retrieve their contact information? In this case, you need a functional interface that contains an abstract method that returns a value. The `Function<T,R>` interface contains the method `R apply(T t)`. The following method retrieves the data specified by the parameter `mapper`, and then performs an action on it specified by the parameter `block`:

```java
public static void processPersonsWithFunction(
    List<Person> roster,
    Predicate<Person> tester,
    Function<Person, String> mapper,
    Consumer<String> block) {
    for (Person p : roster) {
        if (tester.test(p)) {
            String data = mapper.apply(p);
            block.accept(data);
        }
    }
}
```

The following method retrieves the email address from each member contained in `roster` who is eligible for Selective Service and then prints it:

```java
processPersonsWithFunction(
    roster,
    p -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25,
    p -> p.getEmailAddress(),
    email -> System.out.println(email)
);
```

### Approach 8: Use Generics More Extensively

Reconsider the method `processPersonsWithFunction`. The following is a generic version of it that accepts, as a parameter, a collection that contains elements of any data type:

```java
public static <X, Y> void processElements(
    Iterable<X> source,
    Predicate<X> tester,
    Function <X, Y> mapper,
    Consumer<Y> block) {
    for (X p : source) {
        if (tester.test(p)) {
            Y data = mapper.apply(p);
            block.accept(data);
        }
    }
}
```

To print the e-mail address of members who are eligible for Selective Service, invoke the `processElements` method as follows:

```java
processElements(
    roster,
    p -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25,
    p -> p.getEmailAddress(),
    email -> System.out.println(email)
);
```

This method invocation performs the following actions:

1.  Obtains a source of objects from the collection `source`. In this example, it obtains a source of `Person` objects from the collection `roster`. Notice that the collection `roster`, which is a collection of type `List`, is also an object of type `Iterable`.
2.  Filters objects that match the `Predicate` object `tester`. In this example, the `Predicate` object is a lambda expression that specifies which members would be eligible for Selective Service.
3.  Maps each filtered object to a value as specified by the `Function` object `mapper`. In this example, the `Function` object is a lambda expression that returns the e-mail address of a member.
4.  Performs an action on each mapped object as specified by the `Consumer` object `block`. In this example, the `Consumer` object is a lambda expression that prints a string, which is the e-mail address returned by the `Function` object.

You can replace each of these actions with an aggregate operation.

### Approach 9: Use Aggregate Operations That Accept Lambda Expressions as Parameters

The following example uses aggregate operations to print the e-mail addresses of those members contained in the collection `roster` who are eligible for Selective Service:

roster
    .stream()
    .filter(
        p -> p.getGender() == Person.Sex.MALE
            && p.getAge() >= 18
            && p.getAge() <= 25)
    .map(p -> p.getEmailAddress())
    .forEach(email -> System.out.println(email));

The following table maps each of the operations the method `processElements` performs with the corresponding aggregate operation:

`processElements` Action

Aggregate Operation

Obtain a source of objects

`Stream<E> **stream**()`

Filter objects that match a `Predicate` object

`Stream<T> **filter**(Predicate<? super T> predicate)`

Map objects to another value as specified by a `Function` object

`<R> Stream<R> **map**(Function<? super T,? extends R> mapper)`

Perform an action as specified by a `Consumer` object

`void **forEach**(Consumer<? super T> action)`

The operations `filter`, `map`, and `forEach` are _aggregate operations_. Aggregate operations process elements from a stream, not directly from a collection (which is the reason why the first method invoked in this example is `stream`). A _stream_ is a sequence of elements. Unlike a collection, it is not a data structure that stores elements. Instead, a stream carries values from a source, such as collection, through a pipeline. A _pipeline_ is a sequence of stream operations, which in this example is `filter`\- `map`\-`forEach`. In addition, aggregate operations typically accept lambda expressions as parameters, enabling you to customize how they behave.

For a more thorough discussion of aggregate operations, see the [Aggregate Operations](../../collections/streams/index.html) lesson.

Lambda Expressions in GUI Applications
--------------------------------------

To process events in a graphical user interface (GUI) application, such as keyboard actions, mouse actions, and scroll actions, you typically create event handlers, which usually involves implementing a particular interface. Often, event handler interfaces are functional interfaces; they tend to have only one method.

In the JavaFX example [`HelloWorld.java`](https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm) (discussed in the previous section [Anonymous Classes](anonymousclasses.html)), you can replace the highlighted anonymous class with a lambda expression in this statement:

        btn.setOnAction(**new EventHandler<ActionEvent>() {**

            **@Override**
            **public void handle(ActionEvent event) {**
                **System.out.println("Hello World!");**
            **}**
        **}**);

The method invocation `btn.setOnAction` specifies what happens when you select the button represented by the `btn` object. This method requires an object of type `EventHandler<ActionEvent>`. The `EventHandler<ActionEvent>` interface contains only one method, `void handle(T event)`. This interface is a functional interface, so you could use the following highlighted lambda expression to replace it:

        btn.setOnAction(
          **event -> System.out.println("Hello World!")**
        );

Syntax of Lambda Expressions
----------------------------

A lambda expression consists of the following:

*   A comma-separated list of formal parameters enclosed in parentheses. The `CheckPerson.test` method contains one parameter, `p`, which represents an instance of the `Person` class.
    
    **Note**: You can omit the data type of the parameters in a lambda expression. In addition, you can omit the parentheses if there is only one parameter. For example, the following lambda expression is also valid:
    
    p -> p.getGender() == Person.Sex.MALE 
        && p.getAge() >= 18
        && p.getAge() <= 25
    
*   The arrow token, `->`
    
*   A body, which consists of a single expression or a statement block. This example uses the following expression:
    
    p.getGender() == Person.Sex.MALE 
        && p.getAge() >= 18
        && p.getAge() <= 25
    
    If you specify a single expression, then the Java runtime evaluates the expression and then returns its value. Alternatively, you can use a return statement:
    
    p -> {
        return p.getGender() == Person.Sex.MALE
            && p.getAge() >= 18
            && p.getAge() <= 25;
    }
    
    A return statement is not an expression; in a lambda expression, you must enclose statements in braces (`{}`). However, you do not have to enclose a void method invocation in braces. For example, the following is a valid lambda expression:
    
    email -> System.out.println(email)
    

Note that a lambda expression looks a lot like a method declaration; you can consider lambda expressions as anonymous methods‚Äîmethods without a name.

The following example, [`Calculator`](https://docs.oracle.com/javase/tutorial/java/data/examples/Calculator.java), is an example of lambda expressions that take more than one formal parameter:

```java
public class Calculator {
  
    interface IntegerMath {
        int operation(int a, int b);   
    }
  
    public int operateBinary(int a, int b, IntegerMath op) {
        return op.operation(a, b);
    }
 
    public static void main(String... args) {
    
        Calculator myApp = new Calculator();
        IntegerMath addition = (a, b) -> a + b;
        IntegerMath subtraction = (a, b) -> a - b;
        System.out.println("40 + 2 = " +
            myApp.operateBinary(40, 2, addition));
        System.out.println("20 - 10 = " +
            myApp.operateBinary(20, 10, subtraction));    
    }
}
```

The method `operateBinary` performs a mathematical operation on two integer operands. The operation itself is specified by an instance of `IntegerMath`. The example defines two operations with lambda expressions, `addition` and `subtraction`. The example prints the following:

40 + 2 = 42
20 - 10 = 10

Accessing Local Variables of the Enclosing Scope
------------------------------------------------

Like local and anonymous classes, lambda expressions can [capture variables](localclasses.html#accessing-members-of-an-enclosing-class); they have the same access to local variables of the enclosing scope. However, unlike local and anonymous classes, lambda expressions do not have any shadowing issues (see [Shadowing](../../java/javaOO/nested.html#shadowing) for more information). Lambda expressions are lexically scoped. This means that they do not inherit any names from a supertype or introduce a new level of scoping. Declarations in a lambda expression are interpreted just as they are in the enclosing environment. The following example, [`LambdaScopeTest`](https://docs.oracle.com/javase/tutorial/java/data/examples/LambdaScopeTest.java), demonstrates this:

 
```java
import java.util.function.Consumer;
 
public class LambdaScopeTest {
 
    public int x = 0;
 
    class FirstLevel {
 
        public int x = 1;
        
        void methodInFirstLevel(int x) {

            int z = 2;
             
            Consumer<Integer> myConsumer = (y) -> 
            {
                // The following statement causes the compiler to generate
                // the error "Local variable z defined in an enclosing scope
                // must be final or effectively final" 
                //
                // z = 99;
                
                System.out.println("x = " + x); 
                System.out.println("y = " + y);
                System.out.println("z = " + z);
                System.out.println("this.x = " + this.x);
                System.out.println("LambdaScopeTest.this.x = " +
                    LambdaScopeTest.this.x);
            };
 
            myConsumer.accept(x);
 
        }
    }
 
    public static void main(String... args) {
        LambdaScopeTest st = new LambdaScopeTest();
        LambdaScopeTest.FirstLevel fl = st.new FirstLevel();
        fl.methodInFirstLevel(23);
    }
}
```

This example generates the following output:

x = 23
y = 23
z = 2
this.x = 1
LambdaScopeTest.this.x = 0

If you substitute the parameter `x` in place of `y` in the declaration of the lambda expression `myConsumer`, then the compiler generates an error:

```java
Consumer<Integer> myConsumer = (x) -> {
    // ...
}
```

The compiler generates the error "Lambda expression's parameter x cannot redeclare another local variable defined in an enclosing scope" because the lambda expression does not introduce a new level of scoping. Consequently, you can directly access fields, methods, and local variables of the enclosing scope. For example, the lambda expression directly accesses the parameter `x` of the method `methodInFirstLevel`. To access variables in the enclosing class, use the keyword `this`. In this example, `this.x` refers to the member variable `FirstLevel.x`.

However, like local and anonymous classes, a lambda expression can only access local variables and parameters of the enclosing block that are final or effectively final. In this example, the variable `z` is effectively final; its value is never changed after it's initialized. However, suppose that you add the following assignment statement in the the lambda expression `myConsumer`:

```java
Consumer<Integer> myConsumer = (y) -> {
    **z = 99;**
    // ...
}
```

Because of this assignment statement, the variable `z` is not effectively final anymore. As a result, the Java compiler generates an error message similar to "Local variable z defined in an enclosing scope must be final or effectively final".

Target Typing
-------------

How do you determine the type of a lambda expression? Recall the lambda expression that selected members who are male and between the ages 18 and 25 years:

p -> p.getGender() == Person.Sex.MALE
    && p.getAge() >= 18
    && p.getAge() <= 25

This lambda expression was used in the following two methods:

*   `public static void printPersons(List<Person> roster, CheckPerson tester)` in [Approach 3: Specify Search Criteria Code in a Local Class](#approach3)
    
*   `public void printPersonsWithPredicate(List<Person> roster, Predicate<Person> tester)` in [Approach 6: Use Standard Functional Interfaces with Lambda Expressions](#approach6)
    

When the Java runtime invokes the method `printPersons`, it's expecting a data type of `CheckPerson`, so the lambda expression is of this type. However, when the Java runtime invokes the method `printPersonsWithPredicate`, it's expecting a data type of `Predicate<Person>`, so the lambda expression is of this type. The data type that these methods expect is called the _target type_. To determine the type of a lambda expression, the Java compiler uses the target type of the context or situation in which the lambda expression was found. It follows that you can only use lambda expressions in situations in which the Java compiler can determine a target type:

*   Variable declarations
*   Assignments
*   Return statements
*   Array initializers
*   Method or constructor arguments
*   Lambda expression bodies
*   Conditional expressions, `?:`
*   Cast expressions
    

### Target Types and Method Arguments

For method arguments, the Java compiler determines the target type with two other language features: overload resolution and type argument inference.

Consider the following two functional interfaces ( [`java.lang.Runnable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html) and [`java.util.concurrent.Callable<V>`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html)):

```java
public interface Runnable {
    void run();
}

public interface Callable<V> {
    V call();
}
```

The method `Runnable.run` does not return a value, whereas `Callable<V>.call` does.

Suppose that you have overloaded the method `invoke` as follows (see [Defining Methods](methods.html) for more information about overloading methods):

```java
void invoke(Runnable r) {
    r.run();
}

<T> T invoke(Callable<T> c) {
    return c.call();
}
```

Which method will be invoked in the following statement?

String s = invoke(() -> "done");

The method `invoke(Callable<T>)` will be invoked because that method returns a value; the method `invoke(Runnable)` does not. In this case, the type of the lambda expression `() -> "done"` is `Callable<T>`.

Serialization
-------------

You can [serialize](../../jndi/objects/serial.html) a lambda expression if its target type and its captured arguments are serializable. However, like [inner classes](nested.html#serialization), the serialization of lambda expressions is strongly discouraged.

<a name="sec_3_24"></a>
## 3.24. [Method References](#sec_3_24)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html

You use [lambda expressions](lambdaexpressions.html) to create anonymous methods. Sometimes, however, a lambda expression does nothing but call an existing method. In those cases, it's often clearer to refer to the existing method by name. Method references enable you to do this; they are compact, easy-to-read lambda expressions for methods that already have a name.

Consider again the [`Person`](https://docs.oracle.com/javase/tutorial/java/data/examples/Person.java) class discussed in the section [Lambda Expressions](lambdaexpressions.html):

```java
public class Person {

    // ...
    
    LocalDate birthday;
    
    public int getAge() {
        // ...
    }
    
    public LocalDate getBirthday() {
        return birthday;
    }   

    public static int compareByAge(Person a, Person b) {
        return a.birthday.compareTo(b.birthday);
    }
    
    // ...
}
```

Suppose that the members of your social networking application are contained in an array, and you want to sort the array by age. You could use the following code (find the code excerpts described in this section in the example [`MethodReferencesTest`](https://docs.oracle.com/javase/tutorial/java/data/examples/MethodReferencesTest.java)):

Person[] rosterAsArray = roster.toArray(new Person[roster.size()]);

class PersonAgeComparator implements Comparator<Person> {
    public int compare(Person a, Person b) {
        return a.getBirthday().compareTo(b.getBirthday());
    }
}
        
Arrays.sort(rosterAsArray, new PersonAgeComparator());

The method signature of this invocation of `sort` is the following:

static <T> void sort(T[] a, Comparator<? super T> c)

Notice that the interface `Comparator` is a functional interface. Therefore, you could use a lambda expression instead of defining and then creating a new instance of a class that implements `Comparator`:

Arrays.sort(rosterAsArray,
    (Person a, Person b) -> {
        return a.getBirthday().compareTo(b.getBirthday());
    }
);

However, this method to compare the birth dates of two `Person` instances already exists as `Person.compareByAge`. You can invoke this method instead in the body of the lambda expression:

Arrays.sort(rosterAsArray,
    (a, b) -> Person.compareByAge(a, b)
);

Because this lambda expression invokes an existing method, you can use a method reference instead of a lambda expression:

Arrays.sort(rosterAsArray, Person::compareByAge);

The method reference `Person::compareByAge` is semantically the same as the lambda expression `(a, b) -> Person.compareByAge(a, b)`. Each has the following characteristics:

*   Its formal parameter list is copied from `Comparator<Person>.compare`, which is `(Person, Person)`.
*   Its body calls the method `Person.compareByAge`.

Kinds of Method References
--------------------------

There are four kinds of method references:

| Kind | Syntax | Examples |
|------|--------|----------|

1.  Reference to a static method

    `_ContainingClass_::_staticMethodName_`

    `Person::compareByAge`  
    `MethodReferencesExamples::appendStrings`

2.  Reference to an instance method of a particular object

    `_containingObject_::_instanceMethodName_`

    `myComparisonProvider::compareByName`  
    `myApp::appendStrings2`

3.  Reference to an instance method of an arbitrary object of a particular type

    `_ContainingType_::_methodName_`

    `String::compareToIgnoreCase`  
    `String::concat`

4.  Reference to a constructor

    `_ClassName_::new`

    `HashSet::new`

The following example, [`MethodReferencesExamples`](https://docs.oracle.com/javase/tutorial/java/data/examples/MethodReferencesExamples.java), contains examples of the first three types of method references:

```java
import java.util.function.BiFunction;

public class MethodReferencesExamples {
    
    public static <T> T mergeThings(T a, T b, BiFunction<T, T, T> merger) {
        return merger.apply(a, b);
    }
    
    public static String appendStrings(String a, String b) {
        return a + b;
    }
    
    public String appendStrings2(String a, String b) {
        return a + b;
    }

    public static void main(String[] args) {
        
        MethodReferencesExamples myApp = new MethodReferencesExamples();

        // Calling the method mergeThings with a lambda expression
        System.out.println(MethodReferencesExamples.
            mergeThings("Hello ", "World!", (a, b) -> a + b));
        
        // Reference to a static method
        System.out.println(MethodReferencesExamples.
            mergeThings("Hello ", "World!", MethodReferencesExamples::appendStrings));

        // Reference to an instance method of a particular object        
        System.out.println(MethodReferencesExamples.
            mergeThings("Hello ", "World!", myApp::appendStrings2));
        
        // Reference to an instance method of an arbitrary object of a
        // particular type
        System.out.println(MethodReferencesExamples.
            mergeThings("Hello ", "World!", String::concat));
    }
}
```

All the `System.out.println()` statements print the same thing: `Hello World!`

[`BiFunction`](https://docs.oracle.com/javase/8/docs/api/java/util/function/BiFunction.html) is one of many functional interfaces in the [`java.util.function`](https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html) package. The `BiFunction` functional interface can represent a lambda expression or method reference that accepts two arguments and produces a result.

### Reference to a Static Method

The method references `Person::compareByAge` and `MethodReferencesExamples::appendStrings` are references to a static method.

### Reference to an Instance Method of a Particular Object

The following is an example of a reference to an instance method of a particular object:

```java
class ComparisonProvider {
    public int compareByName(Person a, Person b) {
        return a.getName().compareTo(b.getName());
    }
        
    public int compareByAge(Person a, Person b) {
        return a.getBirthday().compareTo(b.getBirthday());
    }
}
ComparisonProvider myComparisonProvider = new ComparisonProvider();
Arrays.sort(rosterAsArray, **myComparisonProvider::compareByName**);
```

The method reference `myComparisonProvider::compareByName` invokes the method `compareByName` that is part of the object `myComparisonProvider`. The JRE infers the method type arguments, which in this case are `(Person, Person)`.

Similarly, the method reference `myApp::appendStrings2` invokes the method `appendStrings2` that is part of the object `myApp`. The JRE infers the method type arguments, which in this case are `(String, String)`.

### Reference to an Instance Method of an Arbitrary Object of a Particular Type

The following is an example of a reference to an instance method of an arbitrary object of a particular type:

String[] stringArray = { "Barbara", "James", "Mary", "John",
    "Patricia", "Robert", "Michael", "Linda" };
Arrays.sort(stringArray, String::compareToIgnoreCase);

The equivalent lambda expression for the method reference `String::compareToIgnoreCase` would have the formal parameter list `(String a, String b)`, where `a` and `b` are arbitrary names used to better describe this example. The method reference would invoke the method `a.compareToIgnoreCase(b)`.

Similarly, the method reference `String::concat` would invoke the method `a.concat(b)`.

### Reference to a Constructor

You can reference a constructor in the same way as a static method by using the name `new`. The following method copies elements from one collection to another:

```java
public static <T, SOURCE extends Collection<T>, DEST extends Collection<T>>
    DEST transferElements(
        SOURCE sourceCollection,
        Supplier<DEST> collectionFactory) {
        
    DEST result = collectionFactory.get();
    for (T t : sourceCollection) {
        result.add(t);
    }
    return result;
}
```

The functional interface `Supplier` contains one method `get` that takes no arguments and returns an object. Consequently, you can invoke the method `transferElements` with a lambda expression as follows:

Set<Person> rosterSetLambda =
    transferElements(roster, () -> { return new HashSet<>(); });

You can use a constructor reference in place of the lambda expression as follows:

Set<Person> rosterSet = transferElements(roster, HashSet::new);

The Java compiler infers that you want to create a `HashSet` collection that contains elements of type `Person`. Alternatively, you can specify this as follows:

Set<Person> rosterSet = transferElements(roster, HashSet<Person>::new);

<a name="sec_3_25"></a>
## 3.25. [When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions](#sec_3_25)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/whentouse.html

As mentioned in the section [Nested Classes](nested.html), nested classes enable you to logically group classes that are only used in one place, increase the use of encapsulation, and create more readable and maintainable code. Local classes, anonymous classes, and lambda expressions also impart these advantages; however, they are intended to be used for more specific situations:

*   [Local class](localclasses.html): Use it if you need to create more than one instance of a class, access its constructor, or introduce a new, named type (because, for example, you need to invoke additional methods later).
    
*   [Anonymous class](anonymousclasses.html): Use it if you need to declare fields or additional methods.
    
*   [Lambda expression](lambdaexpressions.html):
    
    *   Use it if you are encapsulating a single unit of behavior that you want to pass to other code. For example, you would use a lambda expression if you want a certain action performed on each element of a collection, when a process is completed, or when a process encounters an error.
        
    *   Use it if you need a simple instance of a functional interface and none of the preceding criteria apply (for example, you do not need a constructor, a named type, fields, or additional methods).
        
*   [Nested class](nested.html): Use it if your requirements are similar to those of a local class, you want to make the type more widely available, and you don't require access to local variables or method parameters.
    
    *   Use a non-static nested class (or inner class) if you require access to an enclosing instance's non-public fields and methods. Use a static nested class if you don't require this access.


<a name="sec_3_26"></a>
## 3.26. [Questions and Exercises: Nested Classes](#sec_3_26)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/nested-questions.html

Questions
---------

1.  The program [`Problem.java`](https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/Problem.java) doesn't compile. What do you need to do to make it compile? Why?
    
2.  Use the Java API documentation for the [`Box`](https://docs.oracle.com/javase/8/docs/api/javax/swing/Box.html) class (in the `javax.swing` package) to help you answer the following questions.
    
    1.  What static nested class does `Box` define?
        
    2.  What inner class does `Box` define?
        
    3.  What is the superclass of `Box`'s inner class?
        
    4.  Which of `Box`'s nested classes can you use from any class?
        
    5.  How do you create an instance of `Box`'s `Filler` class?
        

Exercises
---------

1.  Get the file [`Class1.java`](https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/Class1.java). Compile and run `Class1`. What is the output?
    
2.  The following exercises involve modifying the class [`DataStructure.java`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/DataStructure.java), which the section [Inner Class Example](../../../java/javaOO/innerclasses.html) discusses.
    
    1.  Define a method named `print(DataStructureIterator iterator)`. Invoke this method with an instance of the class `EvenIterator` so that it performs the same function as the method `printEven`.
        
    2.  Invoke the method `print(DataStructureIterator iterator)` so that it prints elements that have an odd index value. Use an anonymous class as the method's argument instead of an instance of the interface `DataStructureIterator`.
        
    3.  Define a method named `print(java.util.function.Function<Integer, Boolean> iterator)` that performs the same function as `print(DataStructureIterator iterator)`. Invoke this method with a lambda expression to print elements that have an even index value. Invoke this method again with a lambda expression to print elements that have an odd index value.
        
    4.  Define two methods so that the following two statements print elements that have an even index value and elements that have an odd index value:
        
        DataStructure ds = new DataStructure()
        // ...
        ds.print(DataStructure::isEvenIndex);
        ds.print(DataStructure::isOddIndex);

Answers to Questions and Exercises: Nested Classes
==================================================

Questions
---------

1.  **Question**: The program [`Problem.java`](https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/Problem.java) doesn't compile. What do you need to do to make it compile? Why?
    
    **Answer**: Delete `static` in front of the declaration of the `Inner` class. An static inner class does not have access to the instance fields of the outer class. See [`ProblemSolved.java`](https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/ProblemSolved.java).
    
2.  Use the Java API documentation for the [`Box`](https://docs.oracle.com/javase/8/docs/api/javax/swing/Box.html) class (in the `javax.swing` package) to help you answer the following questions.
    
    1.  **Question**: What static nested class does `Box` define?
        
        **Answer**: `Box.Filler`
        
    2.  **Question**: What inner class does `Box` define?
        
        **Answer**: `Box.AccessibleBox`
        
    3.  **Question**: What is the superclass of `Box`'s inner class?
        
        **Answer**: `[java.awt.]Container.AccessibleAWTContainer`
        
    4.  **Question**: Which of `Box`'s nested classes can you use from any class?
        
        **Answer**: `Box.Filler`
        
    5.  **Question**: How do you create an instance of `Box`'s `Filler` class?
        
        **Answer**: `new Box.Filler(minDimension, prefDimension, maxDimension)`
        

Exercises
---------

1.  **Exercise**: Get the file [`Class1.java`](https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/Class1.java). Compile and run `Class1`. What is the output?
    
    **Answer**: `InnerClass1: getString invoked.   InnerClass1: getAnotherString invoked.`
    
2.  **Exercise**: The following exercises involve modifying the class [`DataStructure.java`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/DataStructure.java), which the section [Inner Class Example](../../../java/javaOO/innerclasses.html) discusses.
    
    1.  Define a method named `print(DataStructureIterator iterator)`. Invoke this method with an instance of the class `EvenIterator` so that it performs the same function as the method `printEven`.
        
        **Hint**: These statements do not compile if you specify them in the `main` method:
        
        DataStructure ds = new DataStructure();
        ds.print(new EvenIterator());
        
        The compiler generates the error message, "non-static variable this cannot be referenced from a static context" when it encounters the expression `new EvenIterator()`. The class `EvenIterator` is an inner, non-static class. This means that you can create an instance of `EvenIterator` only inside an instance of the outer class, `DataStructure`.
        
        You can define a method in `DataStructure` that creates and returns a new instance of `EvenIterator`.
        
    2.  Invoke the method `print(DataStructureIterator iterator)` so that it prints elements that have an odd index value. Use an anonymous class as the method's argument instead of an instance of the interface `DataStructureIterator`.
        
        **Hint**: You cannot access the private members `SIZE` and `arrayOfInts` outside the class `DataStructure`, which means that you cannot access these private members from an anonymous class defined outside `DataStructure`.
        
        You can define methods that access the private members `SIZE` and `arrayOfInts` and then use them in your anonymous class.
        
    3.  Define a method named `print(java.util.Function<Integer, Boolean> iterator)` that performs the same function as `print(DataStructureIterator iterator)`. Invoke this method with a lambda expression to print elements that have an even index value. Invoke this method again with a lambda expression to print elements that have an odd index value.
        
        **Hint**: In this `print` method, you can step though the elements contained in the array `arrayOfInts` with a `for` expression. For each index value, invoke the method `function.apply`. If this method returns a true value for a particular index value, print the element contained in that index value.
        
        To invoke this `print` method to print elements that have an even index value, you can specify a lambda expression that implements the method `Boolean Function.apply(Integer t)`. This lambda expression takes one `Integer` argument (the index) and returns a `Boolean` value (`Boolean.TRUE` if the index value is even, `Boolean.FALSE` otherwise).
        
    4.  Define two methods so that these statements print elements that have an even index value and then elements that have an odd index value:
        
        DataStructure ds = new DataStructure()
        // ...
        ds.print(DataStructure::isEvenIndex);
        ds.print(DataStructure::isOddIndex);
        
        **Hint**: Create two methods in the class `DataStructure` named `isEvenIndex` and `isOddIndex` that have the same parameter list and return type as the abstract method `Boolean Function<Integer, Boolean>.apply(Integer t)`. This means that the methods take one `Integer` argument (the index) and return a `Boolean` value.
        
    
    **Answer**: See the file [`DataStructure.java`](https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/DataStructure.java).


<a name="sec_3_27"></a>
## 3.27. [Enum Types](#sec_3_27)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html

An _enum type_ is a special data type that enables for a variable to be a set of predefined constants. The variable must be equal to one of the values that have been predefined for it. Common examples include compass directions (values of NORTH, SOUTH, EAST, and WEST) and the days of the week.

Because they are constants, the names of an enum type's fields are in uppercase letters.

In the Java programming language, you define an enum type by using the `enum` keyword. For example, you would specify a days-of-the-week enum type as:

public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
    THURSDAY, FRIDAY, SATURDAY 
}

You should use enum types any time you need to represent a fixed set of constants. That includes natural enum types such as the planets in our solar system and data sets where you know all possible values at compile time‚Äîfor example, the choices on a menu, command line flags, and so on.

Here is some code that shows you how to use the `Day` enum defined above:

```java
public class EnumTest {
    Day day;
    
    public EnumTest(Day day) {
        this.day = day;
    }
    
    public void tellItLikeItIs() {
        switch (day) {
            case MONDAY:
                System.out.println("Mondays are bad.");
                break;
                    
            case FRIDAY:
                System.out.println("Fridays are better.");
                break;
                         
            case SATURDAY: case SUNDAY:
                System.out.println("Weekends are best.");
                break;
                        
            default:
                System.out.println("Midweek days are so-so.");
                break;
        }
    }
    
    public static void main(String[] args) {
        EnumTest firstDay = new EnumTest(Day.MONDAY);
        firstDay.tellItLikeItIs();
        EnumTest thirdDay = new EnumTest(Day.WEDNESDAY);
        thirdDay.tellItLikeItIs();
        EnumTest fifthDay = new EnumTest(Day.FRIDAY);
        fifthDay.tellItLikeItIs();
        EnumTest sixthDay = new EnumTest(Day.SATURDAY);
        sixthDay.tellItLikeItIs();
        EnumTest seventhDay = new EnumTest(Day.SUNDAY);
        seventhDay.tellItLikeItIs();
    }
}
```

The output is:

Mondays are bad.
Midweek days are so-so.
Fridays are better.
Weekends are best.
Weekends are best.

Java programming language enum types are much more powerful than their counterparts in other languages. The `enum` declaration defines a _class_ (called an _enum type_). The enum class body can include methods and other fields. The compiler automatically adds some special methods when it creates an enum. For example, they have a static `values` method that returns an array containing all of the values of the enum in the order they are declared. This method is commonly used in combination with the for-each construct to iterate over the values of an enum type. For example, this code from the `Planet` class example below iterates over all the planets in the solar system.

for (Planet p : Planet.values()) {
    System.out.printf("Your weight on %s is %f%n",
                      p, p.surfaceWeight(mass));
}

* * *

**Note:**¬†_All_ enums implicitly extend `java.lang.Enum`. Because a class can only extend one parent (see [Declaring Classes](classdecl.html)), the Java language does not support multiple inheritance of state (see [Multiple Inheritance of State, Implementation, and Type](../IandI/multipleinheritance.html)), and therefore an enum cannot extend anything else.

* * *

In the following example, `Planet` is an enum type that represents the planets in the solar system. They are defined with constant mass and radius properties.

Each enum constant is declared with values for the mass and radius parameters. These values are passed to the constructor when the constant is created. Java requires that the constants be defined first, prior to any fields or methods. Also, when there are fields and methods, the list of enum constants must end with a semicolon.

* * *

**Note:**¬†The constructor for an enum type must be package-private or private access. It automatically creates the constants that are defined at the beginning of the enum body. You cannot invoke an enum constructor yourself.

* * *

In addition to its properties and constructor, `Planet` has methods that allow you to retrieve the surface gravity and weight of an object on each planet. Here is a sample program that takes your weight on earth (in any unit) and calculates and prints your weight on all of the planets (in the same unit):

```java
public enum Planet {
    MERCURY (3.303e+23, 2.4397e6),
    VENUS   (4.869e+24, 6.0518e6),
    EARTH   (5.976e+24, 6.37814e6),
    MARS    (6.421e+23, 3.3972e6),
    JUPITER (1.9e+27,   7.1492e7),
    SATURN  (5.688e+26, 6.0268e7),
    URANUS  (8.686e+25, 2.5559e7),
    NEPTUNE (1.024e+26, 2.4746e7);

    private final double mass;   // in kilograms
    private final double radius; // in meters
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }
    private double mass() { return mass; }
    private double radius() { return radius; }

    // universal gravitational constant  (m3 kg-1 s-2)
    public static final double G = 6.67300E-11;

    double surfaceGravity() {
        return G * mass / (radius * radius);
    }
    double surfaceWeight(double otherMass) {
        return otherMass * surfaceGravity();
    }
    public static void main(String[] args) {
        if (args.length != 1) {
            System.err.println("Usage: java Planet <earth_weight>");
            System.exit(-1);
        }
        double earthWeight = Double.parseDouble(args[0]);
        double mass = earthWeight/EARTH.surfaceGravity();
        for (Planet p : Planet.values())
           System.out.printf("Your weight on %s is %f%n",
                             p, p.surfaceWeight(mass));
    }
}
```

If you run `Planet.class` from the command line with an argument of 175, you get this output:

$ java Planet 175
Your weight on MERCURY is 66.107583
Your weight on VENUS is 158.374842
Your weight on EARTH is 175.000000
Your weight on MARS is 66.279007
Your weight on JUPITER is 442.847567
Your weight on SATURN is 186.552719
Your weight on URANUS is 158.397260
Your weight on NEPTUNE is 199.207413

<a name="sec_3_28"></a>
## 3.28. [Questions and Exercises: Enum Types](#sec_3_28)
******
https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/enum-questions.html

Questions
---------

1.  True or false: an Enum type can be a subclass of java.lang.String.

Exercises
---------

1.  Rewrite the class `Card` from the exercise in [Questions and Exercises: Classes](creating-questions.html) so that it represents the rank and suit of a card with enum types.
    
2.  Rewrite the `Deck` class.
    
Answers to Questions and Exercises: Enum Types
==============================================

Questions
---------

1.  **Question**: True or false: an Enum type can be a subclass of java.lang.String.
    
    **Answer**: False. All enums implicitly extend java.lang.Enum. Because a class can only extend one parent, the Java language does not support multiple inheritance of state, and therefore an enum cannot extend anything else.
    

Exercises
---------

1.  **Exercise**: Rewrite the class `Card` from the exercise in [Questions and Exercises: Classes](creating-questions.html) so that it represents the rank and suit of a card with enum types.
    
    **Answer**: See [`Card3.java`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Card3.java), [`Suit.java`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Suit.java), and [`Rank.java`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Rank.java).
    
2.  **Exercise**: Rewrite the `Deck` class.
    
    **Answer**: See [`Deck3.java`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Deck3.java).
    

<a name="sec_4"></a>
# üìú/PART [4. Annotations](#sec_toc)
******
https://docs.oracle.com/javase/tutorial/java/annotations/index.html 

1. [Annotations Basics](#4_1)
2. [Declaring an Annotation Type](#4_2)
3. [Predefined Annotation Types](#4_3)
4. [Type Annotations and Pluggable Type Systems](#4_4)
5. [Repeating Annotations](#4_5)
6. [Questions and Exercises](#4_6)

_Annotations_, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate.

Annotations have a number of uses, among them:

*   **Information for the compiler** ‚Äî Annotations can be used by the compiler to detect errors or suppress warnings.
*   **Compile-time and deployment-time processing** ‚Äî Software tools can process annotation information to generate code, XML files, and so forth.
*   **Runtime processing** ‚Äî Some annotations are available to be examined at runtime.

This lesson explains where annotations can be used, how to apply annotations, what predefined annotation types are available in the Java Platform, Standard Edition (Java SE API), how type annotations can be used in conjunction with pluggable type systems to write code with stronger type checking, and how to implement repeating annotations.

<a name="sec4_1"></a>

## 4.1. [Annotations Basics](#sec4_1)
https://docs.oracle.com/javase/tutorial/java/annotations/basics.html 

The Format of an Annotation
---------------------------

In its simplest form, an annotation looks like the following:

@Entity

The at sign character (`@`) indicates to the compiler that what follows is an annotation. In the following example, the annotation's name is `Override`:

@Override
void mySuperMethod() { ... }

The annotation can include _elements_, which can be named or unnamed, and there are values for those elements:

@Author(
   name = "Benjamin Franklin",
   date = "3/27/2003"
)
class MyClass { ... }

or

@SuppressWarnings(value = "unchecked")
void myMethod() { ... }

If there is just one element named `value`, then the name can be omitted, as in:

@SuppressWarnings("unchecked")
void myMethod() { ... }

If the annotation has no elements, then the parentheses can be omitted, as shown in the previous `@Override` example.

It is also possible to use multiple annotations on the same declaration:

@Author(name = "Jane Doe")
@EBook
class MyClass { ... }

If the annotations have the same type, then this is called a repeating annotation:

@Author(name = "Jane Doe")
@Author(name = "John Smith")
class MyClass { ... }

Repeating annotations are supported as of the Java SE 8 release. For more information, see [Repeating Annotations](repeating.html).

The annotation type can be one of the types that are defined in the `java.lang` or `java.lang.annotation` packages of the Java SE API. In the previous examples, `Override` and `SuppressWarnings` are [predefined Java annotations](predefined.html). It is also possible to define your own annotation type. The `Author` and `Ebook` annotations in the previous example are custom annotation types.

Where Annotations Can Be Used
-----------------------------

Annotations can be applied to declarations: declarations of classes, fields, methods, and other program elements. When used on a declaration, each annotation often appears, by convention, on its own line.

As of the Java SE 8 release, annotations can also be applied to the _use_ of types. Here are some examples:

*   Class instance creation expression:
    
        new @Interned MyObject();
    
*   Type cast:
    
        myString = (@NonNull String) str;
    
*   `implements` clause:
    
        class UnmodifiableList<T> implements
            @Readonly List<@Readonly T> { ... }
    
*   Thrown exception declaration:
    
        void monitorTemperature() throws
            @Critical TemperatureException { ... }
    

This form of annotation is called a _type annotation_. For more information, see [Type Annotations and Pluggable Type Systems](type_annotations.html).


<a name="sec4_2"></a>

## 4.2. [Declaring an Annotation Type](#sec4_2)
https://docs.oracle.com/javase/tutorial/java/annotations/declaring.html 

Many annotations replace comments in code.

Suppose that a software group traditionally starts the body of every class with comments providing important information:

```java
public class Generation3List extends Generation2List {

   // Author: John Doe
   // Date: 3/17/2002
   // Current revision: 6
   // Last modified: 4/12/2004
   // By: Jane Doe
   // Reviewers: Alice, Bill, Cindy

   // class code goes here

}
```

To add this same metadata with an annotation, you must first define the _annotation type_. The syntax for doing this is:

@interface ClassPreamble {
   String author();
   String date();
   int currentRevision() default 1;
   String lastModified() default "N/A";
   String lastModifiedBy() default "N/A";
   // Note use of array
   String[] reviewers();
}

The annotation type definition looks similar to an interface definition where the keyword `interface` is preceded by the at sign (`@`) (@ = AT, as in annotation type). Annotation types are a form of _interface_, which will be covered in a later lesson. For the moment, you do not need to understand interfaces.

The body of the previous annotation definition contains _annotation type element_ declarations, which look a lot like methods. Note that they can define optional default values.

After the annotation type is defined, you can use annotations of that type, with the values filled in, like this:

@ClassPreamble (
   author = "John Doe",
   date = "3/17/2002",
   currentRevision = 6,
   lastModified = "4/12/2004",
   lastModifiedBy = "Jane Doe",
   // Note array notation
   reviewers = {"Alice", "Bob", "Cindy"}
)
public class Generation3List extends Generation2List {

// class code goes here

}

* * *

**Note:**¬†To make the information in `@ClassPreamble` appear in Javadoc-generated documentation, you must annotate the `@ClassPreamble` definition with the `@Documented` annotation:

```java
// import this to use `@Documented`
import java.lang.annotation.*;

@Documented
@interface ClassPreamble {

   // Annotation element definitions
   
}
```

* * *


<a name="sec4_3"></a>

## 4.3. [Predefined Annotation Types](#sec4_3)
https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html 

A set of annotation types are predefined in the Java SE API. Some annotation types are used by the Java compiler, and some apply to other annotations.

Annotation Types Used by the Java Language
------------------------------------------

The predefined annotation types defined in `java.lang` are `@Deprecated`, `@Override`, and `@SuppressWarnings`.

**@Deprecated** [`@Deprecated`](https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html) annotation indicates that the marked element is _deprecated_ and should no longer be used. The compiler generates a warning whenever a program uses a method, class, or field with the `@Deprecated` annotation. When an element is deprecated, it should also be documented using the Javadoc `@deprecated` tag, as shown in the following example. The use of the at sign (`@`) in both Javadoc comments and in annotations is not coincidental: they are related conceptually. Also, note that the Javadoc tag starts with a lowercase _d_ and the annotation starts with an uppercase _D_.

   // Javadoc comment follows
    /**
     * _@deprecated_
     * _explanation of why it was deprecated_
     */
    **@Deprecated**
    static void deprecatedMethod() { }
}

**@Override** [`@Override`](https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html) annotation informs the compiler that the element is meant to override an element declared in a superclass. Overriding methods will be discussed in [Interfaces and Inheritance](../IandI/index.html).

   // _mark method as a superclass method_
   // _that has been overridden_
   **@Override** 
   int overriddenMethod() { }

While it is not required to use this annotation when overriding a method, it helps to prevent errors. If a method marked with `@Override` fails to correctly override a method in one of its superclasses, the compiler generates an error.

**@SuppressWarnings** [`@SuppressWarnings`](https://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html) annotation tells the compiler to suppress specific warnings that it would otherwise generate. In the following example, a deprecated method is used, and the compiler usually generates a warning. In this case, however, the annotation causes the warning to be suppressed.

   // _use a deprecated method and tell_ 
   // _compiler not to generate a warning_
   **@SuppressWarnings("deprecation")**
    void useDeprecatedMethod() {
        // deprecation warning
        // - suppressed
        objectOne.deprecatedMethod();
    }

Every compiler warning belongs to a category. The Java Language Specification lists two categories: `deprecation` and `unchecked`. The `unchecked` warning can occur when interfacing with legacy code written before the advent of [generics](../generics/index.html). To suppress multiple categories of warnings, use the following syntax:

@SuppressWarnings({"unchecked", "deprecation"})

**@SafeVarargs** [`@SafeVarargs`](https://docs.oracle.com/javase/8/docs/api/java/lang/SafeVarargs.html) annotation, when applied to a method or constructor, asserts that the code does not perform potentially unsafe operations on its `varargs` parameter. When this annotation type is used, unchecked warnings relating to `varargs` usage are suppressed.

**@FunctionalInterface** [`@FunctionalInterface`](https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html) annotation, introduced in Java SE 8, indicates that the type declaration is intended to be a functional interface, as defined by the Java Language Specification.

Annotations That Apply to Other Annotations
-------------------------------------------

Annotations that apply to other annotations are called _meta-annotations_. There are several meta-annotation types defined in `java.lang.annotation`.

**@Retention** [`@Retention`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html) annotation specifies how the marked annotation is stored:

*   `RetentionPolicy.SOURCE` ‚Äì The marked annotation is retained only in the source level and is ignored by the compiler.
*   `RetentionPolicy.CLASS` ‚Äì The marked annotation is retained by the compiler at compile time, but is ignored by the Java Virtual Machine (JVM).
*   `RetentionPolicy.RUNTIME` ‚Äì The marked annotation is retained by the JVM so it can be used by the runtime environment.

**@Documented** [`@Documented`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Documented.html) annotation indicates that whenever the specified annotation is used those elements should be documented using the Javadoc tool. (By default, annotations are not included in Javadoc.) For more information, see the [Javadoc tools page](https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/index.html).

**@Target** [`@Target`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html) annotation marks another annotation to restrict what kind of Java elements the annotation can be applied to. A target annotation specifies one of the following element types as its value:

*   `ElementType.ANNOTATION_TYPE` can be applied to an annotation type.
*   `ElementType.CONSTRUCTOR` can be applied to a constructor.
*   `ElementType.FIELD` can be applied to a field or property.
*   `ElementType.LOCAL_VARIABLE` can be applied to a local variable.
*   `ElementType.METHOD` can be applied to a method-level annotation.
*   `ElementType.PACKAGE` can be applied to a package declaration.
*   `ElementType.PARAMETER` can be applied to the parameters of a method.
*   `ElementType.TYPE` can be applied to any element of a class.

**@Inherited** [`@Inherited`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Inherited.html) annotation indicates that the annotation type can be inherited from the super class. (This is not true by default.) When the user queries the annotation type and the class has no annotation for this type, the class' superclass is queried for the annotation type. This annotation applies only to class declarations.

**@Repeatable** [`@Repeatable`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Repeatable.html) annotation, introduced in Java SE 8, indicates that the marked annotation can be applied more than once to the same declaration or type use. For more information, see [Repeating Annotations](repeating.html).


<a name="sec4_4"></a>

## 4.4. [Type Annotations and Pluggable Type Systems](#sec4_4)
https://docs.oracle.com/javase/tutorial/java/annotations/type_annotations.html 

Before the Java SE 8 release, annotations could only be applied to declarations. As of the Java SE 8 release, annotations can also be applied to any _type use_. This means that annotations can be used anywhere you use a type. A few examples of where types are used are class instance creation expressions (`new`), casts, `implements` clauses, and `throws` clauses. This form of annotation is called a _type annotation_ and several examples are provided in [Annotations Basics](basics.html).

Type annotations were created to support improved analysis of Java programs way of ensuring stronger type checking. The Java SE 8 release does not provide a type checking framework, but it allows you to write (or download) a type checking framework that is implemented as one or more pluggable modules that are used in conjunction with the Java compiler.

For example, you want to ensure that a particular variable in your program is never assigned to null; you want to avoid triggering a `NullPointerException`. You can write a custom plug-in to check for this. You would then modify your code to annotate that particular variable, indicating that it is never assigned to null. The variable declaration might look like this:

**@NonNull** String str;

When you compile the code, including the `NonNull` module at the command line, the compiler prints a warning if it detects a potential problem, allowing you to modify the code to avoid the error. After you correct the code to remove all warnings, this particular error will not occur when the program runs.

You can use multiple type-checking modules where each module checks for a different kind of error. In this way, you can build on top of the Java type system, adding specific checks when and where you want them.

With the judicious use of type annotations and the presence of pluggable type checkers, you can write code that is stronger and less prone to error.

In many cases, you do not have to write your own type checking modules. There are third parties who have done the work for you. For example, you might want to take advantage of the Checker Framework created by the University of Washington. This framework includes a `NonNull` module, as well as a regular expression module, and a mutex lock module. For more information, see the [Checker Framework](http://types.cs.washington.edu/checker-framework/).


<a name="sec4_5"></a>

## 4.5. [Repeating Annotations](#sec4_5)
https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html 

There are some situations where you want to apply the same annotation to a declaration or type use. As of the Java SE 8 release, _repeating annotations_ enable you to do this.

For example, you are writing code to use a timer service that enables you to run a method at a given time or on a certain schedule, similar to the UNIX cron service. Now you want to set a timer to run a method, doPeriodicCleanup, on the last day of the month and on every Friday at 11:00 p.m. To set the timer to run, create an `@Schedule` annotation and apply it twice to the doPeriodicCleanup method. The first use specifies the last day of the month and the second specifies Friday at 11p.m., as shown in the following code example:

@Schedule(dayOfMonth="last")
@Schedule(dayOfWeek="Fri", hour="23")
public void doPeriodicCleanup() { ... }

The previous example applies an annotation to a method. You can repeat an annotation anywhere that you would use a standard annotation. For example, you have a class for handling unauthorized access exceptions. You annotate the class with one `@Alert` annotation for managers and another for admins:

@Alert(role="Manager")
@Alert(role="Administrator")
public class UnauthorizedAccessException extends SecurityException { ... }

For compatibility reasons, repeating annotations are stored in a _container annotation_ that is automatically generated by the Java compiler. In order for the compiler to do this, two declarations are required in your code.

Step 1: Declare a Repeatable Annotation Type
--------------------------------------------

The annotation type must be marked with the `@Repeatable` meta-annotation. The following example defines a custom `@Schedule` repeatable annotation type:

import java.lang.annotation.Repeatable;

**@Repeatable(Schedules.class)**
public @interface Schedule {
  String dayOfMonth() default "first";
  String dayOfWeek() default "Mon";
  int hour() default 12;
}

The value of the `@Repeatable` meta-annotation, in parentheses, is the type of the container annotation that the Java compiler generates to store repeating annotations. In this example, the containing annotation type is `Schedules`, so repeating `@Schedule` annotations is stored in an `@Schedules` annotation.

Applying the same annotation to a declaration without first declaring it to be repeatable results in a compile-time error.

Step 2: Declare the Containing Annotation Type
----------------------------------------------

The containing annotation type must have a `value` element with an array type. The component type of the array type must be the repeatable annotation type. The declaration for the `Schedules` containing annotation type is the following:

public @interface Schedules {
    Schedule[] value();
}

Retrieving Annotations
----------------------

There are several methods available in the Reflection API that can be used to retrieve annotations. The behavior of the methods that return a single annotation, such as [AnnotatedElement.getAnnotation(Class<T>)](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html#getAnnotation-java.lang.Class-), are unchanged in that they only return a single annotation if _one_ annotation of the requested type is present. If more than one annotation of the requested type is present, you can obtain them by first getting their container annotation. In this way, legacy code continues to work. Other methods were introduced in Java SE 8 that scan through the container annotation to return multiple annotations at once, such as [AnnotatedElement.getAnnotationsByType(Class<T>)](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html#getAnnotationsByType-java.lang.Class-). See the [AnnotatedElement](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html) class specification for information on all of the available methods.

Design Considerations
---------------------

When designing an annotation type, you must consider the _cardinality_ of annotations of that type. It is now possible to use an annotation zero times, once, or, if the annotation's type is marked as `@Repeatable`, more than once. It is also possible to restrict where an annotation type can be used by using the `@Target` meta-annotation. For example, you can create a repeatable annotation type that can only be used on methods and fields. It is important to design your annotation type carefully to ensure that the programmer _using_ the annotation finds it to be as flexible and powerful as possible.


<a name="sec4_6"></a>

## 4.6. [Questions and Exercises: Annotations](#sec4_6)
https://docs.oracle.com/javase/tutorial/java/annotations/QandE/questions.html 

Questions
---------

1.  What is wrong with the following interface?
    
    public interface House {
        @Deprecated
        void open();
        void openFrontDoor();
        void openBackDoor();
    }
    
2.  Consider this implementation of the `House` interface, shown in Question 1.
    
    public class MyHouse implements House {
        public void open() {}
        public void openFrontDoor() {}
        public void openBackDoor() {}
    }
    
    If you compile this program, the compiler produces a warning because `open` was deprecated (in the interface). What can you do to get rid of that warning?
    
3.  Will the following code compile without error? Why or why not?
    
    public @interface Meal { ... }
    
    @Meal("breakfast", mainDish="cereal")
    @Meal("lunch", mainDish="pizza")
    @Meal("dinner", mainDish="salad")
    public void evaluateDiet() { ... }
    

Exercises
---------

1.  Define an annotation type for an enhancement request with elements `id`, `synopsis`, `engineer`, and `date`. Specify the default value as `unassigned` for engineer and `unknown` for date.

Answers to Questions and Exercises: Annotations
===============================================

Questions
---------

1.  **Question**: What is wrong with the following interface:
    
    public interface House {
        @Deprecated
        public void open();
        public void openFrontDoor();
        public void openBackDoor();
    }
    
    **Answer** The documentation should reflect why `open` is deprecated and what to use instead. For example:
    
    ```java
    public interface House { 
        /**
         * @deprecated use of `open` 
         * is discouraged, use
         * `openFrontDoor` or 
         * `openBackDoor` instead.
         */
        @Deprecated
        public void open(); 
        public void openFrontDoor();
        public void openBackDoor();
    }
    ```
    
2.  **Question**: Consider this implementation of the `House` interface, shown in Question 1.
    
    public class MyHouse implements House {
        public void open() {}
        public void openFrontDoor() {}
        public void openBackDoor() {}
    }
    
    If you compile this program, the compiler produces a warning because `open` was deprecated (in the interface). What can you do to get rid of that warning?
    
    **Answer**: You can deprecate the implementation of `open`:
    
    public class MyHouse implements House { 
        // The documentation is 
        // inherited from the interface.
        @Deprecated
        public void open() {} 
        public void openFrontDoor() {}
        public void openBackDoor() {}
    }
    
    Alternatively, you can suppress the warning:
    
    public class MyHouse implements House { 
        @SuppressWarnings("deprecation")
        public void open() {} 
        public void openFrontDoor() {}
        public void openBackDoor() {}
    }
    
3.  Will the following code compile without error? Why or why not?
    
    public @interface Meal { ... }
    
    @Meal("breakfast", mainDish="cereal")
    @Meal("lunch", mainDish="pizza")
    @Meal("dinner", mainDish="salad")
    public void evaluateDiet() { ... }
    
    **Answer**: The code fails to compile. Before JDK 8, repeatable annotations are not supported. As of JDK 8, the code fails to compile because the `Meal` annotation type was not defined to be repeatable. It can be fixed by adding the `@Repeatable` meta-annotation and defining a container annotation type:
    
    public class AnnotationTest {
    
        public @interface MealContainer {
            Meal[] value();
        }
    
        @java.lang.annotation.Repeatable(MealContainer.class)
        public @interface Meal {
            String value();
            String mainDish();
        }
    
        @Meal(value="breakfast", mainDish="cereal")
        @Meal(value="lunch", mainDish="pizza")
        @Meal(value="dinner", mainDish="salad")
        public void evaluateDiet() { }
    }
    

Exercises
---------

1.  **Exercise**: Define an annotation type for an enhancement request with elements `id`, `synopsis`, `engineer`, and `date`. Specify the default value as `unassigned` for engineer and `unknown` for date.
    
    **Answer**:
    
    ```java
    /**
         * Describes the Request-for-Enhancement (RFE) annotation type.
         */
        public @interface RequestForEnhancement {
            int id();
            String synopsis();
            String engineer() default "[unassigned]";
            String date() default "[unknown]";
        }
    ```
    


<a name="sec_5"></a>
# üìú/PART [5. Interfaces and Inheritance](#sec_toc)
******
https://docs.oracle.com/javase/tutorial/java/IandI/index.html 

1. [Interfaces](#sec_5_1)
2. [Inheritance](#sec_5_2)

Interfaces
* * *

You saw an example of implementing an interface in the previous lesson. You can read more about interfaces here‚Äîwhat they are for, why you might want to write one, and how to write one.

Inheritance
* * *

This section describes the way in which you can derive one class from another. That is, how a _subclass_ can inherit fields and methods from a _superclass_. You will learn that all classes are derived from the `Object` class, and how to modify the methods that a subclass inherits from superclasses. This section also covers interface-like _abstract classes_.

<a name="sec_5_1"></a>
## 5.1. [Interfaces](#sec_5_1)
******
https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html 

There are a number of situations in software engineering when it is important for disparate groups of programmers to agree to a "contract" that spells out how their software interacts. Each group should be able to write their code without any knowledge of how the other group's code is written. Generally speaking, _interfaces_ are such contracts.

For example, imagine a futuristic society where computer-controlled robotic cars transport passengers through city streets without a human operator. Automobile manufacturers write software (Java, of course) that operates the automobile‚Äîstop, start, accelerate, turn left, and so forth. Another industrial group, electronic guidance instrument manufacturers, make computer systems that receive GPS (Global Positioning System) position data and wireless transmission of traffic conditions and use that information to drive the car.

The auto manufacturers must publish an industry-standard interface that spells out in detail what methods can be invoked to make the car move (any car, from any manufacturer). The guidance manufacturers can then write software that invokes the methods described in the interface to command the car. Neither industrial group needs to know _how_ the other group's software is implemented. In fact, each group considers its software highly proprietary and reserves the right to modify it at any time, as long as it continues to adhere to the published interface.

Interfaces in Java
------------------

In the Java programming language, an _interface_ is a reference type, similar to a class, that can contain _only_ constants, method signatures, default methods, static methods, and nested types. Method bodies exist only for default methods and static methods. Interfaces cannot be instantiated‚Äîthey can only be _implemented_ by classes or _extended_ by other interfaces. Extension is discussed later in this lesson.

Defining an interface is similar to creating a new class:

```java
public interface OperateCar {

   // constant declarations, if any

   // method signatures
   
   // An enum with values RIGHT, LEFT
   int turn(Direction direction,
            double radius,
            double startSpeed,
            double endSpeed);
   int changeLanes(Direction direction,
                   double startSpeed,
                   double endSpeed);
   int signalTurn(Direction direction,
                  boolean signalOn);
   int getRadarFront(double distanceToCar,
                     double speedOfCar);
   int getRadarRear(double distanceToCar,
                    double speedOfCar);
         ......
   // more method signatures
}
```

Note that the method signatures have no braces and are terminated with a semicolon.

To use an interface, you write a class that _implements_ the interface. When an instantiable class implements an interface, it provides a method body for each of the methods declared in the interface. For example,

```java
public class OperateBMW760i implements OperateCar {

    // the OperateCar method signatures, with implementation --
    // for example:
    public int signalTurn(Direction direction, boolean signalOn) {
       // code to turn BMW's LEFT turn indicator lights on
       // code to turn BMW's LEFT turn indicator lights off
       // code to turn BMW's RIGHT turn indicator lights on
       // code to turn BMW's RIGHT turn indicator lights off
    }

    // other members, as needed -- for example, helper classes not 
    // visible to clients of the interface
}
```

In the robotic car example above, it is the automobile manufacturers who will implement the interface. Chevrolet's implementation will be substantially different from that of Toyota, of course, but both manufacturers will adhere to the same interface. The guidance manufacturers, who are the clients of the interface, will build systems that use GPS data on a car's location, digital street maps, and traffic data to drive the car. In so doing, the guidance systems will invoke the interface methods: turn, change lanes, brake, accelerate, and so forth.

Interfaces as APIs
------------------

The robotic car example shows an interface being used as an industry standard _Application Programming Interface (API)_. APIs are also common in commercial software products. Typically, a company sells a software package that contains complex methods that another company wants to use in its own software product. An example would be a package of digital image processing methods that are sold to companies making end-user graphics programs. The image processing company writes its classes to implement an interface, which it makes public to its customers. The graphics company then invokes the image processing methods using the signatures and return types defined in the interface. While the image processing company's API is made public (to its customers), its implementation of the API is kept as a closely guarded secret‚Äîin fact, it may revise the implementation at a later date as long as it continues to implement the original interface that its customers have relied on.


<a name="sec_5_2"></a>
## 5.2. [Inheritance](#sec_5_2)
******
https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html 

In the preceding lessons, you have seen _inheritance_ mentioned several times. In the Java language, classes can be _derived_ from other classes, thereby _inheriting_ fields and methods from those classes.

* * *

**Definitions:**¬†A class that is derived from another class is called a _subclass_ (also a _derived class_, _extended class_, or _child class_). The class from which the subclass is derived is called a _superclass_ (also a _base class_ or a _parent class_).

Excepting `Object`, which has no superclass, every class has one and only one direct superclass (single inheritance). In the absence of any other explicit superclass, every class is implicitly a subclass of `Object`.  
  
Classes can be derived from classes that are derived from classes that are derived from classes, and so on, and ultimately derived from the topmost class, `Object`. Such a class is said to be _descended_ from all the classes in the inheritance chain stretching back to `Object`.

* * *

The idea of inheritance is simple but powerful: When you want to create a new class and there is already a class that includes some of the code that you want, you can derive your new class from the existing class. In doing this, you can reuse the fields and methods of the existing class without having to write (and debug!) them yourself.

A subclass inherits all the _members_ (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.

The Java Platform Class Hierarchy
---------------------------------

The [`Object`](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html) class, defined in the `java.lang` package, defines and implements behavior common to all classes‚Äîincluding the ones that you write. In the Java platform, many classes derive directly from `Object`, other classes derive from some of those classes, and so on, forming a hierarchy of classes.

![All Classes in the Java Platform are Descendants of Object](https://docs.oracle.com/javase/tutorial/figures/java/classes-object.gif)

All Classes in the Java Platform are Descendants of Object

At the top of the hierarchy, `Object` is the most general of all classes. Classes near the bottom of the hierarchy provide more specialized behavior.

An Example of Inheritance
-------------------------

Here is the sample code for a possible implementation of a `Bicycle` class that was presented in the Classes and Objects lesson:

```java
public class Bicycle {
        
    // **the Bicycle class has three _fields_**
    public int cadence;
    public int gear;
    public int speed;
        
    // **the Bicycle class has one _constructor_**
    public Bicycle(int startCadence, int startSpeed, int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
    }
        
    // **the Bicycle class has four _methods_**
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
        
}
```

A class declaration for a `MountainBike` class that is a subclass of `Bicycle` might look like this:

```java
public class MountainBike extends Bicycle {
        
    // **the MountainBike subclass adds one _field_**
    public int seatHeight;

    // **the MountainBike subclass has one _constructor_**
    public MountainBike(int startHeight,
                        int startCadence,
                        int startSpeed,
                        int startGear) {
        super(startCadence, startSpeed, startGear);
        seatHeight = startHeight;
    }   
        
    // **the MountainBike subclass adds one _method_**
    public void setHeight(int newValue) {
        seatHeight = newValue;
    }   
}
```

`MountainBike` inherits all the fields and methods of `Bicycle` and adds the field `seatHeight` and a method to set it. Except for the constructor, it is as if you had written a new `MountainBike` class entirely from scratch, with four fields and five methods. However, you didn't have to do all the work. This would be especially valuable if the methods in the `Bicycle` class were complex and had taken substantial time to debug.

What You Can Do in a Subclass
-----------------------------

A subclass inherits all of the _public_ and _protected_ members of its parent, no matter what package the subclass is in. If the subclass is in the same package as its parent, it also inherits the _package-private_ members of the parent. You can use the inherited members as is, replace them, hide them, or supplement them with new members:

*   The inherited fields can be used directly, just like any other fields.
*   You can declare a field in the subclass with the same name as the one in the superclass, thus _hiding_ it (not recommended).
*   You can declare new fields in the subclass that are not in the superclass.
*   The inherited methods can be used directly as they are.
*   You can write a new _instance_ method in the subclass that has the same signature as the one in the superclass, thus _overriding_ it.
*   You can write a new _static_ method in the subclass that has the same signature as the one in the superclass, thus _hiding_ it.
*   You can declare new methods in the subclass that are not in the superclass.
*   You can write a subclass constructor that invokes the constructor of the superclass, either implicitly or by using the keyword `super`.

The following sections in this lesson will expand on these topics.

Private Members in a Superclass
-------------------------------

A subclass does not inherit the `private` members of its parent class. However, if the superclass has public or protected methods for accessing its private fields, these can also be used by the subclass.

A nested class has access to all the private members of its enclosing class‚Äîboth fields and methods. Therefore, a public or protected nested class inherited by a subclass has indirect access to all of the private members of the superclass.

Casting Objects
---------------

We have seen that an object is of the data type of the class from which it was instantiated. For example, if we write

public MountainBike myBike = new MountainBike();

then `myBike` is of type `MountainBike`.

`MountainBike` is descended from `Bicycle` and `Object`. Therefore, a `MountainBike` is a `Bicycle` and is also an `Object`, and it can be used wherever `Bicycle` or `Object` objects are called for.

The reverse is not necessarily true: a `Bicycle` _may be_ a `MountainBike`, but it isn't necessarily. Similarly, an `Object` _may be_ a `Bicycle` or a `MountainBike`, but it isn't necessarily.

_Casting_ shows the use of an object of one type in place of another type, among the objects permitted by inheritance and implementations. For example, if we write

Object obj = new MountainBike();

then `obj` is both an `Object` and a `MountainBike` (until such time as `obj` is assigned another object that is _not_ a `MountainBike`). This is called _implicit casting_.

If, on the other hand, we write

MountainBike myBike = obj;

we would get a compile-time error because `obj` is not known to the compiler to be a `MountainBike`. However, we can _tell_ the compiler that we promise to assign a `MountainBike` to `obj` by _explicit casting:_

MountainBike myBike = (MountainBike)obj;

This cast inserts a runtime check that `obj` is assigned a `MountainBike` so that the compiler can safely assume that `obj` is a `MountainBike`. If `obj` is not a `MountainBike` at runtime, an exception will be thrown.

* * *

**Note:**¬†You can make a logical test as to the type of a particular object using the `instanceof` operator. This can save you from a runtime error owing to an improper cast. For example:

if (obj instanceof MountainBike) {
    MountainBike myBike = (MountainBike)obj;
}

Here the `instanceof` operator verifies that `obj` refers to a `MountainBike` so that we can make the cast with knowledge that there will be no runtime exception thrown.

* * *

<a name="sec_6"></a>
# üìú/PART [6. Numbers and Strings](#sec_toc)
******
https://docs.oracle.com/javase/tutorial/java/data/index.html 

1. [Numbers](#sec_6_1)
2. [The Numbers Classes](#sec_6_2)
3. [Formatting Numeric Print Output](#sec_6_3)
4. [Beyond Basic Arithmetic](#sec_6_4)
5. [Summary of Numbers](#sec_6_5)
6. [Questions and Exercises](#sec_6_6)
7. [Characters](#sec_6_7)
8. [Strings](#sec_6_8)
9. [Converting Between Numbers and Strings](#sec_6_9)
10. [Manipulating Characters in a String](#sec_6_10)
11. [Comparing Strings and Portions of Strings](#sec_6_11)
12. [The StringBuilder Class](#sec_6_12)
13. [Summary of Characters and Strings](#sec_6_13)
14. [Autoboxing and Unboxing](#sec_6_14)
15. [Questions and Exercises](#sec_6_15)

Numbers
* * *

This section begins with a discussion of the `Number` class (in the `java.lang` package) and its subclasses. In particular, this section talks about the situations where you would use instantiations of these classes rather than the primitive data types. Additionally, this section talks about other classes you might need to work with numbers, such as formatting or using mathematical functions to complement the operators built into the language. Finally, there is a discussion on autoboxing and unboxing, a compiler feature that simplifies your code.

Strings
* * *

Strings, which are widely used in Java programming, are a sequence of characters. In the Java programming language, strings are objects. This section describes using the `String` class to create and manipulate strings. It also compares the `String` and `StringBuilder` classes.


<a name="sec_6_1"></a>
## 6.1. [Numbers](#sec_6_1)
******
https://docs.oracle.com/javase/tutorial/java/data/numbers.html 

This section begins with a discussion of the [`Number`](https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html) class in the `java.lang` package, its subclasses, and the situations where you would use instantiations of these classes rather than the primitive number types.

This section also presents the [`PrintStream`](https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html) and [`DecimalFormat`](https://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormat.html) classes, which provide methods for writing formatted numerical output.

Finally, the [`Math`](https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html) class in `java.lang` is discussed. It contains mathematical functions to complement the operators built into the language. This class has methods for the trigonometric functions, exponential functions, and so forth.


<a name="sec_6_2"></a>
## 6.2. [The Numbers Classes](#sec_6_2)
******
https://docs.oracle.com/javase/tutorial/java/data/numberclasses.html 

When working with numbers, most of the time you use the primitive types in your code. For example:

int i = 500;
float gpa = 3.65f;
byte mask = 0x7f;

There are, however, reasons to use objects in place of primitives, and the Java platform provides _wrapper_ classes for each of the primitive data types. These classes "wrap" the primitive in an object. Often, the wrapping is done by the compiler‚Äîif you use a primitive where an object is expected, the compiler _boxes_ the primitive in its wrapper class for you. Similarly, if you use a number object when a primitive is expected, the compiler _unboxes_ the object for you. For more information, see [Autoboxing and Unboxing](autoboxing.html)

All of the numeric wrapper classes are subclasses of the abstract class `Number`:

![The class hierarchy of Number.](https://docs.oracle.com/javase/tutorial/figures/java/objects-numberHierarchy.gif)

* * *

**Note:**¬†There are four other subclasses of `Number` that are not discussed here. `BigDecimal` and `BigInteger` are used for high-precision calculations. `AtomicInteger` and `AtomicLong` are used for multi-threaded applications.

* * *

There are three reasons that you might use a `Number` object rather than a primitive:

1.  As an argument of a method that expects an object (often used when manipulating collections of numbers).
2.  To use constants defined by the class, such as `MIN_VALUE` and `MAX_VALUE`, that provide the upper and lower bounds of the data type.
3.  To use class methods for converting values to and from other primitive types, for converting to and from strings, and for converting between number systems (decimal, octal, hexadecimal, binary).

The following table lists the instance methods that all the subclasses of the `Number` class implement.

Methods Implemented by all Subclasses of Number

| Method | Description |
|--------|-------------|

1. `byte byteValue()` `short shortValue()` `int intValue()` `long longValue()` `float floatValue()` `double doubleValue()`

    Converts the value of this `Number` object to the primitive data type returned.

2. `int compareTo(Byte anotherByte)` `int compareTo(Double anotherDouble)` `int compareTo(Float anotherFloat)` `int compareTo(Integer anotherInteger)` `int compareTo(Long anotherLong)` `int compareTo(Short anotherShort)`

    Compares this `Number` object to the argument.

3. `boolean equals(Object obj)`

    Determines whether this number object is equal to the argument.  
    The methods return `true` if the argument is not `null` and is an object of the same type and with the same numeric value.  
    There are some extra requirements for `Double` and `Float` objects that are described in the Java API documentation.

Each `Number` class contains other methods that are useful for converting numbers to and from strings and for converting between number systems. The following table lists these methods in the `Integer` class. Methods for the other `Number` subclasses are similar:

Conversion Methods, `Integer` Class

| Method | Description |
|--------|-------------|

1. `static Integer decode(String s)`

    Decodes a string into an integer. Can accept string representations of decimal, octal, or hexadecimal numbers as input.

2. `static int parseInt(String s)`

    Returns an integer (decimal only).

3. `static int parseInt(String s, int radix)`

    Returns an integer, given a string representation of decimal, binary, octal, or hexadecimal (`radix` equals 10, 2, 8, or 16 respectively) numbers as input.

4. `String toString()`

    Returns a `String` object representing the value of this `Integer`.

5. `static String toString(int i)`

    Returns a `String` object representing the specified integer.

6. `static Integer valueOf(int i)`

    Returns an `Integer` object holding the value of the specified primitive.

7. `static Integer valueOf(String s)`

    Returns an `Integer` object holding the value of the specified string representation.

8. `static Integer valueOf(String s, int radix)`

    Returns an `Integer` object holding the integer value of the specified string representation, parsed with the value of radix. For example, if s = "333" and radix = 8, the method returns the base-ten integer equivalent of the octal number 333.


<a name="sec_6_3"></a>
## 6.3. [Formatting Numeric Print Output](#sec_6_3)
******
https://docs.oracle.com/javase/tutorial/java/data/numberformat.html 

Earlier you saw the use of the `print` and `println` methods for printing strings to standard output (`System.out`). Since all numbers can be converted to strings (as you will see later in this lesson), you can use these methods to print out an arbitrary mixture of strings and numbers. The Java programming language has other methods, however, that allow you to exercise much more control over your print output when numbers are included.

The printf and format Methods
-----------------------------

The `java.io` package includes a `PrintStream` class that has two formatting methods that you can use to replace `print` and `println`. These methods, `format` and `printf`, are equivalent to one another. The familiar `System.out` that you have been using happens to be a `PrintStream` object, so you can invoke `PrintStream` methods on `System.out`. Thus, you can use `format` or `printf` anywhere in your code where you have previously been using `print` or `println`. For example,

    System.out.format(.....);

The syntax for these two [`java.io.PrintStream`](https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html) methods is the same:

    public PrintStream format(String format, Object... args)

where `format` is a string that specifies the formatting to be used and `args` is a list of the variables to be printed using that formatting. A simple example would be

    System.out.format("The value of " + "the float variable is " +
         "%f, while the value of the " + "integer variable is %d, " +
         "and the string is %s", floatVar, intVar, stringVar); 

The first parameter, `format`, is a format string specifying how the objects in the second parameter, `args`, are to be formatted. The format string contains plain text as well as _format specifiers_, which are special characters that format the arguments of `Object... args`. (The notation `Object... args` is called _varargs_, which means that the number of arguments may vary.)

Format specifiers begin with a percent sign (%) and end with a _converter_. The converter is a character indicating the type of argument to be formatted. In between the percent sign (%) and the converter you can have optional flags and specifiers. There are many converters, flags, and specifiers, which are documented in [`java.util.Formatter`](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html)

Here is a basic example:

    int i = 461012;
    System.out.format("The value of i is: %d%n", i);

The `%d` specifies that the single variable is a decimal integer. The `%n` is a platform-independent newline character. The output is:

    The value of i is: 461012

The `printf` and `format` methods are overloaded. Each has a version with the following syntax:

    public PrintStream format(Locale l, String format, Object... args)

To print numbers in the French system (where a comma is used in place of the decimal place in the English representation of floating point numbers), for example, you would use:

    System.out.format(Locale.FRANCE,
        "The value of the float " + "variable is %f, while the " +
        "value of the integer variable " + "is %d, and the string is %s%n", 
        floatVar, intVar, stringVar); 

An Example
----------

The following table lists some of the converters and flags that are used in the sample program, `TestFormat.java`, that follows the table.

Converters and Flags Used in `TestFormat.java`

| Converter | Flag | Explanation |
|-----------|------|-------------|
| d      |      | A decimal integer.
| f      |      | A float.
| n      |      | A new line character appropriate to the platform running the application. You should always use `%n`,rather than `\n`.
| tB     |      | A date & time conversion‚Äîlocale-specific full name of month.
| td, te |      | A date & time conversion‚Äî2-digit day of month. td has leading zeroes as needed, te does not.
| ty, tY |      | A date & time conversion‚Äîty = 2-digit year, tY = 4-digit year.
| tl     |      | A date & time conversion‚Äîhour in 12-hour clock.
| tM     |      | A date & time conversion‚Äîminutes in 2 digits, with leading zeroes as necessary.
| tp     |      | A date & time conversion‚Äîlocale-specific am/pm (lower case).
| tm     |      | A date & time conversion‚Äîmonths in 2 digits, with leading zeroes as necessary.
| tD     |      | A date & time conversion‚Äîdate as %tm%td%ty
|        | 08   | Eight characters in width, with leading zeroes as necessary.
|        | +    | Includes sign, whether positive or negative.
|        | ,    | Includes locale-specific grouping characters.
|        | -    | Left-justified..
|        | .3   | Three places after decimal point.
|        | 10.3 | Ten characters in width, right justified, with three places after decimal point.

The following program shows some of the formatting that you can do with `format`. The output is shown within double quotes in the embedded comment:

```java
import java.util.Calendar;
import java.util.Locale;

public class TestFormat {
    
    public static void main(String[] args) {
      long n = 461012;
      System.out.format("%d%n", n);      //  -->  "461012"
      System.out.format("%08d%n", n);    //  -->  "00461012"
      System.out.format("%+8d%n", n);    //  -->  " +461012"
      System.out.format("%,8d%n", n);    // -->  " 461,012"
      System.out.format("%+,8d%n%n", n); //  -->  "+461,012"
      
      double pi = Math.PI;

      System.out.format("%f%n", pi);       // -->  "3.141593"
      System.out.format("%.3f%n", pi);     // -->  "3.142"
      System.out.format("%10.3f%n", pi);   // -->  "     3.142"
      System.out.format("%-10.3f%n", pi);  // -->  "3.142"
      System.out.format(Locale.FRANCE,
                        "%-10.4f%n%n", pi); // -->  "3,1416"

      Calendar c = Calendar.getInstance();
      System.out.format("%tB %te, %tY%n", c, c, c); // -->  "May 29, 2006"

      System.out.format("%tl:%tM %tp%n", c, c, c);  // -->  "2:34 am"

      System.out.format("%tD%n", c);    // -->  "05/29/06"
    }
}
```

* * *

**Note:**¬† The discussion in this section covers just the basics of the `format` and `printf` methods. Further detail can be found in the [`Basic I/O`](../../essential/io/formatting.html) section of the Essential trail, in the "Formatting" page.  
Using `String.format` to create strings is covered in [Strings](strings.html).

* * *

The DecimalFormat Class
-----------------------

You can use the [`java.text.DecimalFormat`](https://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormat.html) class to control the display of leading and trailing zeros, prefixes and suffixes, grouping (thousands) separators, and the decimal separator. `DecimalFormat` offers a great deal of flexibility in the formatting of numbers, but it can make your code more complex.

The example that follows creates a `DecimalFormat` object, `myFormatter`, by passing a pattern string to the `DecimalFormat` constructor. The `format()` method, which `DecimalFormat` inherits from `NumberFormat`, is then invoked by `myFormatter`‚Äîit accepts a `double` value as an argument and returns the formatted number in a string:

Here is a sample program that illustrates the use of `DecimalFormat`:

```java
import java.text.*;

public class DecimalFormatDemo {

   static public void customFormat(String pattern, double value ) {
      DecimalFormat myFormatter = new DecimalFormat(pattern);
      String output = myFormatter.format(value);
      System.out.println(value + "  " + pattern + "  " + output);
   }

   static public void main(String[] args) {

      customFormat("###,###.###", 123456.789);
      customFormat("###.##", 123456.789);
      customFormat("000000.000", 123.78);
      customFormat("$###,###.###", 12345.67);  
   }
}
```

The output is:

123456.789  ###,###.###  123,456.789
123456.789  ###.##  123456.79
123.78  000000.000  000123.780
12345.67  $###,###.###  $12,345.67

The following table explains each line of output.

`DecimalFormat.java` Output

|   Value    |   Pattern    |    Output   | Explanation |
|------------|--------------|-------------|-------------|
| 123456.789 | ###,###.###  | 123,456.789 | ‚ûä           |
| 123456.789 | ###.##       | 123456.79   | ‚ûã           |
|     123.78 | 000000.000   | 000123.780  | ‚ûå           |
|   12345.67 | $###,###.### | $12,345.67  | ‚ûç           |

1.  The pound sign (#) denotes a digit, the comma is a placeholder for the grouping separator, and the period is a placeholder for the decimal separator.

2.  The `value` has three digits to the right of the decimal point, but the `pattern` has only two. The `format` method handles this by rounding up.

3.  The `pattern` specifies leading and trailing zeros, because the 0 character is used instead of the pound sign (#).

4.  The first character in the `pattern` is the dollar sign ($). Note that it immediately precedes the leftmost digit in the formatted `output`.


<a name="sec_6_4"></a>
## 6.4. [Beyond Basic Arithmetic](#sec_6_4)
******
https://docs.oracle.com/javase/tutorial/java/data/beyondmath.html 

The Java programming language supports basic arithmetic with its arithmetic operators: + - * / and %. The [`Math`](https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html) class in the `java.lang` package provides methods and constants for doing more advanced mathematical computation.

The methods in the `Math` class are all static, so you call them directly from the class, like this:

Math.cos(angle);

* * *

**Note:**¬†Using the [`static import`](../package/usepkgs.html#staticimport) language feature, you don't have to write `Math` in front of every math function:

    import static java.lang.Math.*;

This allows you to invoke the `Math` class methods by their simple names. For example:

    cos(angle);

* * *

Constants and Basic Methods
---------------------------

The `Math` class includes two constants:

*   `Math.E`, which is the base of natural logarithms, and
*   `Math.PI`, which is the ratio of the circumference of a circle to its diameter.

The `Math` class also includes more than 40 static methods. The following table lists a number of the basic methods.

| Basic Math Methods | Method | Description |
|--------------------|--------|-------------|

1. `double abs(double d)   float abs(float f)   int abs(int i)   long abs(long lng)`

    Returns the absolute value of the argument.

2. `double ceil(double d)`

    Returns the smallest integer that is greater than or equal to the argument. Returned as a double.

3. `double floor(double d)`

    Returns the largest integer that is less than or equal to the argument. Returned as a double.

4. `double rint(double d)`

    Returns the integer that is closest in value to the argument. Returned as a double.

5. `long round(double d)   int round(float f)`

    Returns the closest long or int, as indicated by the method's return type, to the argument.

6. `double min(double arg1, double arg2)   float min(float arg1, float arg2)   int min(int arg1, int arg2)   long min(long arg1, long arg2)`

    Returns the smaller of the two arguments.

7. `double max(double arg1, double arg2)   float max(float arg1, float arg2)   int max(int arg1, int arg2)   long max(long arg1, long arg2)`

    Returns the larger of the two arguments.

The following program, [`BasicMathDemo`](https://docs.oracle.com/javase/tutorial/java/data/examples/BasicMathDemo.java) , illustrates how to use some of these methods:

```java
public class BasicMathDemo {
    public static void main(String[] args) {
        double a = -191.635;
        double b = 43.74;
        int c = 16, d = 45;

        System.out.printf("The absolute value " + "of %.3f is %.3f%n", 
                          a, Math.abs(a));

        System.out.printf("The ceiling of " + "%.2f is %.0f%n", 
                          b, Math.ceil(b));

        System.out.printf("The floor of " + "%.2f is %.0f%n", 
                          b, Math.floor(b));

        System.out.printf("The rint of %.2f " + "is %.0f%n", 
                          b, Math.rint(b));

        System.out.printf("The max of %d and " + "%d is %d%n",
                          c, d, Math.max(c, d));

        System.out.printf("The min of of %d " + "and %d is %d%n",
                          c, d, Math.min(c, d));
    }
}
```

Here's the output from this program:

The absolute value of -191.635 is 191.635
The ceiling of 43.74 is 44
The floor of 43.74 is 43
The rint of 43.74 is 44
The max of 16 and 45 is 45
The min of 16 and 45 is 16

Exponential and Logarithmic Methods
-----------------------------------

The next table lists exponential and logarithmic methods of the `Math` class.

Exponential and Logarithmic Methods

| Method | Description |
|--------|-------------|
| `double exp(double d)`| Returns the base of the natural logarithms, e, to the power of the argument.
| `double log(double d)`| Returns the natural logarithm of the argument.
| `double pow(double base, double exponent)`| Returns the value of the first argument raised to the power of the second argument.
| `double sqrt(double d)`| Returns the square root of the argument.

The following program, [`ExponentialDemo`](https://docs.oracle.com/javase/tutorial/java/data/examples/ExponentialDemo.java), displays the value of `e`, then calls each of the methods listed in the previous table on arbitrarily chosen numbers:

```java
public class ExponentialDemo {
    public static void main(String[] args) {
        double x = 11.635;
        double y = 2.76;

        System.out.printf("The value of " + "e is %.4f%n",
                          Math.E);

        System.out.printf("exp(%.3f) " + "is %.3f%n",
                          x, Math.exp(x));

        System.out.printf("log(%.3f) is " + "%.3f%n",
                          x, Math.log(x));

        System.out.printf("pow(%.3f, %.3f) " + "is %.3f%n",
                          x, y, Math.pow(x, y));

        System.out.printf("sqrt(%.3f) is " + "%.3f%n",
                          x, Math.sqrt(x));
    }
}
```

Here's the output you'll see when you run `ExponentialDemo`:

The value of e is 2.7183
exp(11.635) is 112983.831
log(11.635) is 2.454
pow(11.635, 2.760) is 874.008
sqrt(11.635) is 3.411

Trigonometric Methods
---------------------

The `Math` class also provides a collection of trigonometric functions, which are summarized in the following table. The value passed into each of these methods is an angle expressed in radians. You can use the `toRadians` method to convert from degrees to radians.

Trigonometric Methods

| Method | Description |
|--------|-------------|
| `double sin(double d)` | Returns the sine of the specified double value.
| `double cos(double d)` | Returns the cosine of the specified double value.
| `double tan(double d)` | Returns the tangent of the specified double value.
| `double asin(double d)` | Returns the arcsine of the specified double value.
| `double acos(double d)` | Returns the arccosine of the specified double value.
| `double atan(double d)` | Returns the arctangent of the specified double value.
| `double atan2(double y, double x)` | Converts rectangular coordinates `(x, y)` to polar coordinate `(r, theta)` and returns `theta`.
| `double toDegrees(double d)` `double toRadians(double d)` | Converts the argument to degrees or radians.

Here's a program, [`TrigonometricDemo`](https://docs.oracle.com/javase/tutorial/java/data/examples/TrigonometricDemo.java), that uses each of these methods to compute various trigonometric values for a 45-degree angle:

```java
public class TrigonometricDemo {
    public static void main(String[] args) {
        double degrees = 45.0;
        double radians = Math.toRadians(degrees);
        
        System.out.format("The value of pi " + "is %.4f%n",
                           Math.PI);

        System.out.format("The sine of %.1f " + "degrees is %.4f%n",
                          degrees, Math.sin(radians));

        System.out.format("The cosine of %.1f " + "degrees is %.4f%n",
                          degrees, Math.cos(radians));

        System.out.format("The tangent of %.1f " + "degrees is %.4f%n",
                          degrees, Math.tan(radians));

        System.out.format("The arcsine of %.4f " + "is %.4f degrees %n", 
                          Math.sin(radians), 
                          Math.toDegrees(Math.asin(Math.sin(radians))));

        System.out.format("The arccosine of %.4f " + "is %.4f degrees %n", 
                          Math.cos(radians),  
                          Math.toDegrees(Math.acos(Math.cos(radians))));

        System.out.format("The arctangent of %.4f " + "is %.4f degrees %n", 
                          Math.tan(radians), 
                          Math.toDegrees(Math.atan(Math.tan(radians))));
    }
}
```

The output of this program is as follows:

The value of pi is 3.1416
The sine of 45.0 degrees is 0.7071
The cosine of 45.0 degrees is 0.7071
The tangent of 45.0 degrees is 1.0000
The arcsine of 0.7071 is 45.0000 degrees
The arccosine of 0.7071 is 45.0000 degrees
The arctangent of 1.0000 is 45.0000 degrees

Random Numbers
--------------

The `random()` method returns a pseudo-randomly selected number between 0.0 and 1.0. The range includes 0.0 but not 1.0. In other words: `0.0 <= Math.random() < 1.0`. To get a number in a different range, you can perform arithmetic on the value returned by the random method. For example, to generate an integer between 0 and 9, you would write:

    int number = (int)(Math.random() * 10);

By multiplying the value by 10, the range of possible values becomes `0.0 <= number < 10.0`.

Using `Math.random` works well when you need to generate a single random number. If you need to generate a series of random numbers, you should create an instance of `java.util.Random` and invoke methods on that object to generate numbers.


<a name="sec_6_5"></a>
## 6.5. [Summary of Numbers](#sec_6_5)
******
https://docs.oracle.com/javase/tutorial/java/data/numbersummary.html 

You use one of the wrapper classes ‚Äì `Byte`, `Double`, `Float`, `Integer`, `Long`, or `Short` ‚Äì to wrap a number of primitive type in an object. The Java compiler automatically wraps (boxes) primitives for you when necessary and unboxes them, again when necessary.

The `Number` classes include constants and useful class methods. The `MIN_VALUE` and `MAX_VALUE` constants contain the smallest and largest values that can be contained by an object of that type. The `byteValue`, `shortValue`, and similar methods convert one numeric type to another. The `valueOf` method converts a string to a number, and the `toString` method converts a number to a string.

To format a string containing numbers for output, you can use the `printf()` or `format()` methods in the `PrintStream` class. Alternatively, you can use the `NumberFormat` class to customize numerical formats using patterns.

The `Math` class contains a variety of class methods for performing mathematical functions, including exponential, logarithmic, and trigonometric methods. `Math` also includes basic arithmetic functions, such as absolute value and rounding, and a method, `random()`, for generating random numbers.


<a name="sec_6_6"></a>
## 6.6. [Questions and Exercises: Numbers](#sec_6_6)
******
https://docs.oracle.com/javase/tutorial/java/data/QandE/numbers-questions.html 

Questions
---------

1.  Use the API documentation to find the answers to the following questions:
    
    1.  What `Integer` method can you use to convert an `int` into a string that expresses the number in hexadecimal? For example, what method converts the integer 65 into the string "41"?
        
    2.  What `Integer` method would you use to convert a string expressed in base 5 into the equivalent `int`? For example, how would you convert the string "230" into the integer value 65? Show the code you would use to accomplish this task.
        
    3.  What Double method can you use to detect whether a floating-point number has the special value Not a Number (`NaN`)?
        
2.  What is the value of the following expression, and why?
    
    Integer.valueOf(1).equals(Long.valueOf(1))
    

Exercises
---------

1.  Change [`MaxVariablesDemo`](https://docs.oracle.com/javase/tutorial/java/data/QandE/MaxVariablesDemo.java) to show minimum values instead of maximum values. You can delete all code related to the variables `aChar` and `aBoolean`. What is the output?
    
2.  Create a program that reads an unspecified number of integer arguments from the command line and adds them together. For example, suppose that you enter the following:
    
    java Adder 1 3 2 10
    
    The program should display `16` and then exit. The program should display an error message if the user enters only one argument. You can base your program on [`ValueOfDemo`](https://docs.oracle.com/javase/tutorial/java/data/examples/ValueOfDemo.java).
    
3.  Create a program that is similar to the previous one but has the following differences:
    
    *   Instead of reading integer arguments, it reads floating-point arguments.
    *   It displays the sum of the arguments, using exactly two digits to the right of the decimal point.
    
    For example, suppose that you enter the following:
    
    java FPAdder 1 1e2 3.0 4.754
    
    The program would display `108.75`. Depending on your locale, the decimal point might be a comma (`,`) instead of a period (`.`).

Answers to Questions and Exercises: Numbers
===========================================

Questions
---------

1.  Use the API documentation to find the answers to the following questions:
    
    1.  **Question:** What `Integer` method can you use to convert an `int` into a string that expresses the number in hexadecimal? For example, what method converts the integer 65 into the string "41"?
        
        **Answer:** `toHexString`
        
    2.  **Question:**What `Integer` method would you use to convert a string expressed in base 5 into the equivalent `int`? For example, how would you convert the string "230" into the integer value 65? Show the code you would use to accomplish this task.
        
        **Answer:** `valueOf`. Here's how:
        
        String base5String = "230";
        int result = Integer.valueOf(base5String, 5);
        
    3.  **Question:** What Double method can you use to detect whether a floating-point number has the special value Not a Number (`NaN`)?
        
        **Answer:** `isNaN`
        
2.  **Question:** What is the value of the following expression, and why?
    
    Integer.valueOf(1).equals(Long.valueOf(1))
    
    **Answer:** False. The two objects (the `Integer` and the `Long`) have different types.
    

Exercises
---------

1.  **Exercise:** Change [`MaxVariablesDemo`](https://docs.oracle.com/javase/tutorial/java/data/QandE/MaxVariablesDemo.java) to show minimum values instead of maximum values. You can delete all code related to the variables `aChar` and `aBoolean`. What is the output?
    
    **Answer:** See [`MinVariablesDemo`](https://docs.oracle.com/javase/tutorial/java/data/QandE/MinVariablesDemo.java). Here is the output:
    
    The smallest byte value is -128
    The smallest short value is -32768
    The smallest integer value is -2147483648
    The smallest long value is -9223372036854775808
    The smallest float value is 1.4E-45
    The smallest double value is 4.9E-324
    
2.  **Exercise:** Create a program that reads an unspecified number of integer arguments from the command line and adds them together. For example, suppose that you enter the following:
    
           java Adder 1 3 2 10
    
    The program should display `16` and then exit. The program should display an error message if the user enters only one argument. You can base your program on [`ValueOfDemo`](https://docs.oracle.com/javase/tutorial/java/data/examples/ValueOfDemo.java).
    
    **Answer:** See [`Adder`](https://docs.oracle.com/javase/tutorial/java/data/QandE/Adder.java).
    
3.  **Exercise:** Create a program that is similar to the previous one but has the following differences:
    
    *   Instead of reading integer arguments, it reads floating-point arguments.
    *   It displays the sum of the arguments, using exactly two digits to the right of the decimal point.
    
    For example, suppose that you enter the following:
    
    java FPAdder 1 1e2 3.0 4.754
    
    The program would display `108.75`. Depending on your locale, the decimal point might be a comma (`,`) instead of a period (`.`).
    
    **Answer:** See [`FPAdder`](https://docs.oracle.com/javase/tutorial/java/data/QandE/FPAdder.java).


<a name="sec_6_7"></a>
## 6.7. [Characters](#sec_6_7)
******
https://docs.oracle.com/javase/tutorial/java/data/characters.html 

Most of the time, if you are using a single character value, you will use the primitive `char` type. For example:

```java
char ch = 'a'; 
// Unicode for uppercase Greek omega character
char uniChar = '\u03A9';
// an array of chars
char[] charArray = { 'a', 'b', 'c', 'd', 'e' };
```

There are times, however, when you need to use a char as an object‚Äîfor example, as a method argument where an object is expected. The Java programming language provides a _wrapper_ class that "wraps" the `char` in a `Character` object for this purpose. An object of type `Character` contains a single field, whose type is `char`. This [Character](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html) class also offers a number of useful class (that is, static) methods for manipulating characters.

You can create a `Character` object with the `Character` constructor:

    Character ch = new Character('a');

The Java compiler will also create a `Character` object for you under some circumstances. For example, if you pass a primitive `char` into a method that expects an object, the compiler automatically converts the `char` to a `Character` for you. This feature is called _autoboxing_ or _unboxing_, if the conversion goes the other way. For more information on autoboxing and unboxing, see [Autoboxing and Unboxing](autoboxing.html).

* * *

**Note:**¬†The `Character` class is immutable, so that once it is created, a `Character` object cannot be changed.

* * *

The following table lists some of the most useful methods in the `Character` class, but is not exhaustive. For a complete listing of all methods in this class (there are more than 50), refer to the [java.lang.Character](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html) API specification.

Useful Methods in the `Character` Class

| Method | Description |
|--------|-------------|

1. `boolean isLetter(char ch)   boolean isDigit(char ch)`

    Determines whether the specified char value is a letter or a digit, respectively.

2. `boolean isWhitespace(char ch)`

    Determines whether the specified char value is white space.

3. `boolean isUpperCase(char ch)   boolean isLowerCase(char ch)`

    Determines whether the specified char value is uppercase or lowercase, respectively.

4. `char toUpperCase(char ch)   char toLowerCase(char ch)`

    Returns the uppercase or lowercase form of the specified char value.

5. `toString(char ch)`

    Returns a `String` object representing the specified character value ‚Äî that is, a one-character string.

Escape Sequences
----------------

A character preceded by a backslash (\) is an _escape sequence_ and has special meaning to the compiler. The following table shows the Java escape sequences:

Escape Sequences

| Escape Sequence | Description |
|-----------------|-------------|
| `\t`  | Insert a tab in the text at this point.
| `\b`  | Insert a backspace in the text at this point.
| `\n`  | Insert a newline in the text at this point.
| `\r`  | Insert a carriage return in the text at this point.
| `\f`  | Insert a form feed in the text at this point.
| `\'`  | Insert a single quote character in the text at this point.
| `\"`  | Insert a double quote character in the text at this point.
| `\` | Insert a backslash character in the text at this point.

When an escape sequence is encountered in a print statement, the compiler interprets it accordingly. For example, if you want to put quotes within quotes you must use the escape sequence, `\"`, on the interior quotes. To print the sentence

    She said "Hello!" to me.

you would write

    System.out.println("She said \"Hello!\" to me.");


<a name="sec_6_8"></a>
## 6.8. [Strings](#sec_6_8)
******
https://docs.oracle.com/javase/tutorial/java/data/strings.html 

Strings, which are widely used in Java programming, are a sequence of characters. In the Java programming language, strings are objects.

The Java platform provides the [`String`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html) class to create and manipulate strings.

Creating Strings
----------------

The most direct way to create a string is to write:

String greeting = "Hello world!";

In this case, "Hello world!" is a _string literal_‚Äîa series of characters in your code that is enclosed in double quotes. Whenever it encounters a string literal in your code, the compiler creates a `String` object with its value‚Äîin this case, `Hello world!`.

As with any other object, you can create `String` objects by using the `new` keyword and a constructor. The `String` class has thirteen constructors that allow you to provide the initial value of the string using different sources, such as an array of characters:

char[] helloArray = { 'h', 'e', 'l', 'l', 'o', '.' };
String helloString = new String(helloArray);
System.out.println(helloString);

The last line of this code snippet displays `hello`.

* * *

**Note:**¬†The `String` class is immutable, so that once it is created a `String` object cannot be changed. The `String` class has a number of methods, some of which will be discussed below, that appear to modify strings. Since strings are immutable, what these methods really do is create and return a new string that contains the result of the operation.

* * *

String Length
-------------

Methods used to obtain information about an object are known as _accessor methods_. One accessor method that you can use with strings is the `length()` method, which returns the number of characters contained in the string object. After the following two lines of code have been executed, `len` equals 17:

String palindrome = "Dot saw I was Tod";
int len = palindrome.length();

A _palindrome_ is a word or sentence that is symmetric‚Äîit is spelled the same forward and backward, ignoring case and punctuation. Here is a short and inefficient program to reverse a palindrome string. It invokes the `String` method `charAt(i)`, which returns the ith character in the string, counting from 0.

```java
public class StringDemo {
    public static void main(String[] args) {
        String palindrome = "Dot saw I was Tod";
        int len = palindrome.length();
        char[] tempCharArray = new char[len];
        char[] charArray = new char[len];
        
        // put original string in an 
        // array of chars
        for (int i = 0; i < len; i++) {
            tempCharArray[i] = 
                palindrome.charAt(i);
        } 
        
        // reverse array of chars
        for (int j = 0; j < len; j++) {
            charArray[j] =
                tempCharArray[len - 1 - j];
        }
        
        String reversePalindrome =
            new String(charArray);
        System.out.println(reversePalindrome);
    }
}
```

Running the program produces this output:

doT saw I was toD

To accomplish the string reversal, the program had to convert the string to an array of characters (first `for` loop), reverse the array into a second array (second `for` loop), and then convert back to a string. The [`String`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html) class includes a method, `getChars()`, to convert a string, or a portion of a string, into an array of characters so we could replace the first `for` loop in the program above with

palindrome.getChars(0, len, tempCharArray, 0);

Concatenating Strings
---------------------

The `String` class includes a method for concatenating two strings:

    string1.concat(string2); 

This returns a new string that is string1 with string2 added to it at the end.

You can also use the `concat()` method with string literals, as in:

    "My name is ".concat("Rumplestiltskin");

Strings are more commonly concatenated with the `+` operator, as in

    "Hello," + " world" + "!"

which results in

    "Hello, world!"

The `+` operator is widely used in `print` statements. For example:

    String string1 = "saw I was ";
    System.out.println("Dot " + string1 + "Tod");

which prints

    Dot saw I was Tod

Such a concatenation can be a mixture of any objects. For each object that is not a `String`, its `toString()` method is called to convert it to a `String`.

* * *

**Note:**¬†The Java programming language does not permit literal strings to span lines in source files, so you must use the `+` concatenation operator at the end of each line in a multi-line string. For example:

    String quote = 
        "Now is the time for all good " +
        "men to come to the aid of their country.";

Breaking strings between lines using the `+` concatenation operator is, once again, very common in `print` statements.

* * *

Creating Format Strings
-----------------------

You have seen the use of the `printf()` and `format()` methods to print output with formatted numbers. The `String` class has an equivalent class method, `format()`, that returns a `String` object rather than a `PrintStream` object.

Using `String's` static `format()` method allows you to create a formatted string that you can reuse, as opposed to a one-time print statement. For example, instead of

System.out.printf("The value of the float " +
                  "variable is %f, while " +
                  "the value of the " + 
                  "integer variable is %d, " +
                  "and the string is %s", 
                  floatVar, intVar, stringVar); 

you can write

String fs;
fs = String.format("The value of the float " +
                   "variable is %f, while " +
                   "the value of the " + 
                   "integer variable is %d, " +
                   " and the string is %s",
                   floatVar, intVar, stringVar);
System.out.println(fs);


<a name="sec_6_9"></a>
## 6.9. [Converting Between Numbers and Strings](#sec_6_9)
******
https://docs.oracle.com/javase/tutorial/java/data/converting.html 

Converting Strings to Numbers
-----------------------------

Frequently, a program ends up with numeric data in a string object‚Äîa value entered by the user, for example.

The `Number` subclasses that wrap primitive numeric types ( [`Byte`](https://docs.oracle.com/javase/8/docs/api/java/lang/Byte.html), [`Integer`](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html), [`Double`](https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html), [`Float`](https://docs.oracle.com/javase/8/docs/api/java/lang/Float.html), [`Long`](https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html), and [`Short`](https://docs.oracle.com/javase/8/docs/api/java/lang/Short.html)) each provide a class method named `valueOf` that converts a string to an object of that type. Here is an example, [`ValueOfDemo`](https://docs.oracle.com/javase/tutorial/java/data/examples/ValueOfDemo.java) , that gets two strings from the command line, converts them to numbers, and performs arithmetic operations on the values:

```java
public class ValueOfDemo {
    public static void main(String[] args) {

        // this program requires two 
        // arguments on the command line 
        if (args.length == 2) {
            // convert strings to numbers
            float a = (Float.valueOf(args[0])).floatValue(); 
            float b = (Float.valueOf(args[1])).floatValue();

            // do some arithmetic
            System.out.println("a + b = " +
                               (a + b));
            System.out.println("a - b = " +
                               (a - b));
            System.out.println("a * b = " +
                               (a * b));
            System.out.println("a / b = " +
                               (a / b));
            System.out.println("a % b = " +
                               (a % b));
        } else {
            System.out.println("This program " +
                "requires two command-line arguments.");
        }
    }
}
```

The following is the output from the program when you use `4.5` and `87.2` for the command-line arguments:

a + b = 91.7
a - b = -82.7
a * b = 392.4
a / b = 0.0516055
a % b = 4.5

* * *

**Note:**¬†Each of the `Number` subclasses that wrap primitive numeric types also provides a `parseXXXX()` method (for example, `parseFloat()`) that can be used to convert strings to primitive numbers. Since a primitive type is returned instead of an object, the `parseFloat()` method is more direct than the `valueOf()` method. For example, in the `ValueOfDemo` program, we could use:

    float a = Float.parseFloat(args[0]);
    float b = Float.parseFloat(args[1]);

* * *

Converting Numbers to Strings
-----------------------------

Sometimes you need to convert a number to a string because you need to operate on the value in its string form. There are several easy ways to convert a number to a string:

    int i;
    // Concatenate "i" with an empty string; conversion is handled for you.
    String s1 = "" + i;

or

    // The valueOf class method.
    String s2 = String.valueOf(i);

Each of the `Number` subclasses includes a class method, `toString()`, that will convert its primitive type to a string. For example:

    int i;
    double d;
    String s3 = Integer.toString(i); 
    String s4 = Double.toString(d); 

The [`ToStringDemo`](https://docs.oracle.com/javase/tutorial/java/data/examples/ToStringDemo.java) example uses the `toString` method to convert a number to a string. The program then uses some string methods to compute the number of digits before and after the decimal point:

```java
public class ToStringDemo {
    
    public static void main(String[] args) {
        double d = 858.48;
        String s = Double.toString(d);
        
        int dot = s.indexOf('.');
        
        System.out.println(dot + " digits " +
            "before decimal point.");
        System.out.println( (s.length() - dot - 1) +
            " digits after decimal point.");
    }
}
```

The output of this program is:

3 digits before decimal point.
2 digits after decimal point.


<a name="sec_6_10"></a>
## 6.10. [Manipulating Characters in a String](#sec_6_10)
******
https://docs.oracle.com/javase/tutorial/java/data/manipstrings.html 

The `String` class has a number of methods for examining the contents of strings, finding characters or substrings within a string, changing case, and other tasks.

Getting Characters and Substrings by Index
------------------------------------------

You can get the character at a particular index within a string by invoking the `charAt()` accessor method. The index of the first character is 0, while the index of the last character is `length()-1`. For example, the following code gets the character at index 9 in a string:

    String anotherPalindrome = "Niagara. O roar again!"; 
    char aChar = anotherPalindrome.charAt(9);

Indices begin at 0, so the character at index 9 is 'O', as illustrated in the following figure:

![Use the charAt method to get a character at a particular index.](https://docs.oracle.com/javase/tutorial/figures/java/objects-charAt.gif)

If you want to get more than one consecutive character from a string, you can use the `substring` method. The `substring` method has two versions, as shown in the following table:

The `substring` Methods in the `String` Class

| Method | Description |
|--------|-------------|

1. `String substring(int beginIndex, int endIndex)`

    Returns a new string that is a substring of this string. The substring begins at the specified `beginIndex` and extends to the character at index `endIndex - 1`.

2. `String substring(int beginIndex)`

    Returns a new string that is a substring of this string. The integer argument specifies the index of the first character. Here, the returned substring extends to the end of the original string.

The following code gets from the Niagara palindrome the substring that extends from index 11 up to, but not including, index 15, which is the word "roar":

    String anotherPalindrome = "Niagara. O roar again!"; 
    String roar = anotherPalindrome.substring(11, 15); 

![Use the substring method to get part of a string.](https://docs.oracle.com/javase/tutorial/figures/java/objects-substring.gif)

Other Methods for Manipulating Strings
--------------------------------------

Here are several other `String` methods for manipulating strings:

Other Methods in the `String` Class for Manipulating Strings

| Method | Description |
|--------|-------------|

1. `String[] split(String regex)` `String[] split(String regex, int limit)`

    Searches for a match as specified by the string argument (which contains a regular expression) and splits this string into an array of strings accordingly. The optional integer argument specifies the maximum size of the returned array. Regular expressions are covered in the lesson titled "Regular Expressions."

2. `CharSequence subSequence(int beginIndex, int endIndex)`

    Returns a new character sequence constructed from `beginIndex` index up until `endIndex` - 1.

3. `String trim()`

    Returns a copy of this string with leading and trailing white space removed.

4. `String toLowerCase()   String toUpperCase()`

    Returns a copy of this string converted to lowercase or uppercase. If no conversions are necessary, these methods return the original string.

Searching for Characters and Substrings in a String
---------------------------------------------------

Here are some other `String` methods for finding characters or substrings within a string. The `String` class provides accessor methods that return the position within the string of a specific character or substring: `indexOf()` and `lastIndexOf()`. The `indexOf()` methods search forward from the beginning of the string, and the `lastIndexOf()` methods search backward from the end of the string. If a character or substring is not found, `indexOf()` and `lastIndexOf()` return -1.

The `String` class also provides a search method, `contains`, that returns true if the string contains a particular character sequence. Use this method when you only need to know that the string contains a character sequence, but the precise location isn't important.

The following table describes the various string search methods.

The Search Methods in the `String` Class

| Method | Description |
|--------|-------------|

1. `int indexOf(int ch)`   `int lastIndexOf(int ch)`

    Returns the index of the first (last) occurrence of the specified character.

2. `int indexOf(int ch, int fromIndex)`   `int lastIndexOf(int ch, int fromIndex)`

    Returns the index of the first (last) occurrence of the specified character, searching forward (backward) from the specified index.

3. `int indexOf(String str)`   `int lastIndexOf(String str)`

    Returns the index of the first (last) occurrence of the specified substring.

4. `int indexOf(String str, int fromIndex)`   `int lastIndexOf(String str, int fromIndex)`

    Returns the index of the first (last) occurrence of the specified substring, searching forward (backward) from the specified index.

5. `boolean contains(CharSequence s)`

    Returns true if the string contains the specified character sequence.

* * *

**Note:**¬†`CharSequence` is an interface that is implemented by the `String` class. Therefore, you can use a string as an argument for the `contains()` method.

* * *

Replacing Characters and Substrings into a String
-------------------------------------------------

The `String` class has very few methods for inserting characters or substrings into a string. In general, they are not needed: You can create a new string by concatenation of substrings you have _removed_ from a string with the substring that you want to insert.

The `String` class does have four methods for _replacing_ found characters or substrings, however. They are:

Methods in the `String` Class for Manipulating Strings

| Method | Description |
|--------|-------------|

1. `String replace(char oldChar, char newChar)`

    Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar.

2. `String replace(CharSequence target, CharSequence replacement)`

    Replaces each substring of this string that matches the literal target sequence with the specified literal replacement sequence.

3. `String replaceAll(String regex, String replacement)`

    Replaces each substring of this string that matches the given regular expression with the given replacement.

4. `String replaceFirst(String regex, String replacement)`

    Replaces the first substring of this string that matches the given regular expression with the given replacement.

An Example
----------

The following class, [`Filename`](https://docs.oracle.com/javase/tutorial/java/data/examples/Filename.java), illustrates the use of `lastIndexOf()` and `substring()` to isolate different parts of a file name.

* * *

**Note:**¬†The methods in the following `Filename` class don't do any error checking and assume that their argument contains a full directory path and a filename with an extension. If these methods were production code, they would verify that their arguments were properly constructed.

* * *

```java
public class Filename {
    private String fullPath;
    private char pathSeparator, 
                 extensionSeparator;

    public Filename(String str, char sep, char ext) {
        fullPath = str;
        pathSeparator = sep;
        extensionSeparator = ext;
    }

    public String extension() {
        int dot = fullPath.lastIndexOf(extensionSeparator);
        return fullPath.substring(dot + 1);
    }

    // gets filename without extension
    public String filename() {
        int dot = fullPath.lastIndexOf(extensionSeparator);
        int sep = fullPath.lastIndexOf(pathSeparator);
        return fullPath.substring(sep + 1, dot);
    }

    public String path() {
        int sep = fullPath.lastIndexOf(pathSeparator);
        return fullPath.substring(0, sep);
    }
}
```

Here is a program, [`FilenameDemo`](https://docs.oracle.com/javase/tutorial/java/data/examples/FilenameDemo.java), that constructs a `Filename` object and calls all of its methods:

```java
public class FilenameDemo {
    public static void main(String[] args) {
        final String FPATH = "/home/user/index.html";
        Filename myHomePage = new Filename(FPATH, '/', '.');
        System.out.println("Extension = " + myHomePage.extension());
        System.out.println("Filename = " + myHomePage.filename());
        System.out.println("Path = " + myHomePage.path());
    }
}
```

And here's the output from the program:

    Extension = html
    Filename = index
    Path = /home/user

As shown in the following figure, our `extension` method uses `lastIndexOf` to locate the last occurrence of the period (.) in the file name. Then `substring` uses the return value of `lastIndexOf` to extract the file name extension ‚Äî that is, the substring from the period to the end of the string. This code assumes that the file name has a period in it; if the file name does not have a period, `lastIndexOf` returns -1, and the substring method throws a `StringIndexOutOfBoundsException`.

![The use of lastIndexOf and substring in the extension method in the Filename class.](https://docs.oracle.com/javase/tutorial/figures/java/objects-lastIndexOf.gif)

Also, notice that the `extension` method uses `dot + 1` as the argument to `substring`. If the period character (.) is the last character of the string, `dot + 1` is equal to the length of the string, which is one larger than the largest index into the string (because indices start at 0). This is a legal argument to `substring` because that method accepts an index equal to, but not greater than, the length of the string and interprets it to mean "the end of the string."


<a name="sec_6_11"></a>
## 6.11. [Comparing Strings and Portions of Strings](#sec_6_11)
******
https://docs.oracle.com/javase/tutorial/java/data/comparestrings.html 

The `String` class has a number of methods for comparing strings and portions of strings. The following table lists these methods.

Methods for Comparing Strings

| Method | Description |
|--------|-------------|

1. `boolean endsWith(String suffix)   boolean startsWith(String prefix)`

    Returns `true` if this string ends with or begins with the substring specified as an argument to the method.

2. `boolean startsWith(String prefix, int offset)`

    Considers the string beginning at the index `offset`, and returns `true` if it begins with the substring specified as an argument.

3. `int compareTo(String anotherString)`

    Compares two strings lexicographically. Returns an integer indicating whether this string is greater than (result is > 0), equal to (result is = 0), or less than (result is < 0) the argument.

4. `int compareToIgnoreCase(String str)`

    Compares two strings lexicographically, ignoring differences in case. Returns an integer indicating whether this string is greater than (result is > 0), equal to (result is = 0), or less than (result is < 0) the argument.

5. `boolean equals(Object anObject)`

    Returns `true` if and only if the argument is a `String` object that represents the same sequence of characters as this object.

6. `boolean equalsIgnoreCase(String anotherString)`

    Returns `true` if and only if the argument is a `String` object that represents the same sequence of characters as this object, ignoring differences in case.

7. `boolean regionMatches(int toffset, String other, int ooffset, int len)`

    Tests whether the specified region of this string matches the specified region of the String argument.

    Region is of length `len` and begins at the index `toffset` for this string and `ooffset` for the other string.

8. `boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)`

    Tests whether the specified region of this string matches the specified region of the String argument.

    Region is of length `len` and begins at the index `toffset` for this string and `ooffset` for the other string.

    The boolean argument indicates whether case should be ignored; if true, case is ignored when comparing characters.

9. `boolean matches(String regex)`

    Tests whether this string matches the specified regular expression. Regular expressions are discussed in the lesson titled "Regular Expressions."

The following program, `RegionMatchesDemo`, uses the `regionMatches` method to search for a string within another string:

```java
public class RegionMatchesDemo {
    public static void main(String[] args) {
        String searchMe = "Green Eggs and Ham";
        String findMe = "Eggs";
        int searchMeLength = searchMe.length();
        int findMeLength = findMe.length();
        boolean foundIt = false;
        for (int i = 0; 
             i <= (searchMeLength - findMeLength);
             i++) {
           if (searchMe.regionMatches(i, findMe, 0, findMeLength)) {
              foundIt = true;
              System.out.println(searchMe.substring(i, i + findMeLength));
              break;
           }
        }
        if (!foundIt)
            System.out.println("No match found.");
    }
}
```

The output from this program is `Eggs`.

The program steps through the string referred to by `searchMe` one character at a time. For each character, the program calls the regionMatches method to determine whether the substring beginning with the current character matches the string the program is looking for.


<a name="sec_6_12"></a>
## 6.12. [The StringBuilder Class](#sec_6_12)
******
https://docs.oracle.com/javase/tutorial/java/data/buffers.html 

[`StringBuilder`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html) objects are like [`String`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html) objects, except that they can be modified. Internally, these objects are treated like variable-length arrays that contain a sequence of characters. At any point, the length and content of the sequence can be changed through method invocations.

Strings should always be used unless string builders offer an advantage in terms of simpler code (see the sample program at the end of this section) or better performance. For example, if you need to concatenate a large number of strings, appending to a `StringBuilder` object is more efficient.

Length and Capacity
-------------------

The `StringBuilder` class, like the `String` class, has a `length()` method that returns the length of the character sequence in the builder.

Unlike strings, every string builder also has a _capacity_, the number of character spaces that have been allocated. The capacity, which is returned by the `capacity()` method, is always greater than or equal to the length (usually greater than) and will automatically expand as necessary to accommodate additions to the string builder.

`StringBuilder` Constructors

| Constructor | Description |
|-------------|-------------|

1. `StringBuilder()`

    Creates an empty string builder with a capacity of 16 (16 empty elements).

2. `StringBuilder(CharSequence cs)`

    Constructs a string builder containing the same characters as the specified `CharSequence`, plus an extra 16 empty elements trailing the `CharSequence`.

3. `StringBuilder(int initCapacity)`

    Creates an empty string builder with the specified initial capacity.

4. `StringBuilder(String s)`

    Creates a string builder whose value is initialized by the specified string, plus an extra 16 empty elements trailing the string.

For example, the following code

```java
// creates empty builder, capacity 16
StringBuilder sb = new StringBuilder();
// adds 9 character string at beginning
sb.append("Greetings");
```

will produce a string builder with a length of 9 and a capacity of 16:

![A string builder's length is the number of characters it contains; a string builder's capacity is the number of character spaces that have been allocated.](https://docs.oracle.com/javase/tutorial/figures/java/objects-stringBuffer.gif)

The `StringBuilder` class has some methods related to length and capacity that the `String` class does not have:

Length and Capacity Methods

| Method | Description |
|--------|-------------|

1. `void setLength(int newLength)`

    Sets the length of the character sequence. If `newLength` is less than `length()`, the last characters in the character sequence are truncated. If `newLength` is greater than `length()`, null characters are added at the end of the character sequence.

2. `void ensureCapacity(int minCapacity)`

    Ensures that the capacity is at least equal to the specified minimum.

A number of operations (for example, `append()`, `insert()`, or `setLength()`) can increase the length of the character sequence in the string builder so that the resultant `length()` would be greater than the current `capacity()`. When this happens, the capacity is automatically increased.

StringBuilder Operations
------------------------

The principal operations on a `StringBuilder` that are not available in `String` are the `append()` and `insert()` methods, which are overloaded so as to accept data of any type. Each converts its argument to a string and then appends or inserts the characters of that string to the character sequence in the string builder. The append method always adds these characters at the end of the existing character sequence, while the insert method adds the characters at a specified point.

Here are a number of the methods of the `StringBuilder` class.

Various `StringBuilder` Methods

| Method | Description |
|--------|-------------|

1. `StringBuilder append(boolean b)`
   `StringBuilder append(char c)`
   `StringBuilder append(char[] str)`
   `StringBuilder append(char[] str, int offset, int len)`
   `StringBuilder append(double d)`
   `StringBuilder append(float f)`
   `StringBuilder append(int i)`
   `StringBuilder append(long lng)`
   `StringBuilder append(Object obj)`
   `StringBuilder append(String s)`

    Appends the argument to this string builder. The data is converted to a string before the append operation takes place.

2. `StringBuilder delete(int start, int end)`
   `StringBuilder deleteCharAt(int index)`

    The first method deletes the subsequence from start to end-1 (inclusive) in the `StringBuilder`'s char sequence. The second method deletes the character located at `index`.

3. `StringBuilder insert(int offset, boolean b)`
   `StringBuilder insert(int offset, char c)`
   `StringBuilder insert(int offset, char[] str)`
   `StringBuilder insert(int index, char[] str, int offset, int len)`
   `StringBuilder insert(int offset, double d)`
   `StringBuilder insert(int offset, float f)`
   `StringBuilder insert(int offset, int i)`
   `StringBuilder insert(int offset, long lng)`
   `StringBuilder insert(int offset, Object obj)`
   `StringBuilder insert(int offset, String s)`

    Inserts the second argument into the string builder. The first integer argument indicates the index before which the data is to be inserted. The data is converted to a string before the insert operation takes place.

4. `StringBuilder replace(int start, int end, String s)`
   `void setCharAt(int index, char c)`

    Replaces the specified character(s) in this string builder.

5. `StringBuilder reverse()`

    Reverses the sequence of characters in this string builder.

6. `String toString()`

    Returns a string that contains the character sequence in the builder.

* * *

**Note:**¬†You can use any `String` method on a `StringBuilder` object by first converting the string builder to a string with the `toString()` method of the `StringBuilder` class. Then convert the string back into a string builder using the `StringBuilder(String str)` constructor.

* * *

An Example
----------

The `StringDemo` program that was listed in the section titled "Strings" is an example of a program that would be more efficient if a `StringBuilder` were used instead of a `String`.

`StringDemo` reversed a palindrome. Here, once again, is its listing:

```java
public class StringDemo {
    public static void main(String[] args) {
        String palindrome = "Dot saw I was Tod";
        int len = palindrome.length();
        char[] tempCharArray = new char[len];
        char[] charArray = new char[len];
        
        // put original string in an 
        // array of chars
        for (int i = 0; i < len; i++) {
            tempCharArray[i] = 
                palindrome.charAt(i);
        } 
        
        // reverse array of chars
        for (int j = 0; j < len; j++) {
            charArray[j] =
                tempCharArray[len - 1 - j];
        }
        
        String reversePalindrome =
            new String(charArray);
        System.out.println(reversePalindrome);
    }
}
```

Running the program produces this output:

    doT saw I was toD

To accomplish the string reversal, the program converts the string to an array of characters (first `for` loop), reverses the array into a second array (second `for` loop), and then converts back to a string.

If you convert the `palindrome` string to a string builder, you can use the `reverse()` method in the `StringBuilder` class. It makes the code simpler and easier to read:

```java
public class StringBuilderDemo {
    public static void main(String[] args) {
        String palindrome = "Dot saw I was Tod";
         
        StringBuilder sb = new StringBuilder(palindrome);
        
        sb.reverse();  // reverse it
        
        System.out.println(sb);
    }
}
```

Running this program produces the same output:

    doT saw I was toD

Note that `println()` prints a string builder, as in:

    System.out.println(sb);

because `sb.toString()` is called implicitly, as it is with any other object in a `println()` invocation.

* * *

**Note:**¬†There is also a `StringBuffer` class that is _exactly_ the same as the `StringBuilder` class, except that it is thread-safe by virtue of having its methods synchronized. Threads will be discussed in the lesson on concurrency.

* * *


<a name="sec_6_13"></a>
## 6.13. [Summary of Characters and Strings](#sec_6_13)
******
https://docs.oracle.com/javase/tutorial/java/data/stringsummary.html 

Most of the time, if you are using a single character value, you will use the primitive `char` type. There are times, however, when you need to use a char as an object‚Äîfor example, as a method argument where an object is expected. The Java programming language provides a _wrapper_ class that "wraps" the `char` in a `Character` object for this purpose. An object of type `Character` contains a single field whose type is `char`. This [`Character`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html) class also offers a number of useful class (that is, static) methods for manipulating characters.

Strings are a sequence of characters and are widely used in Java programming. In the Java programming language, strings are objects. The [`String`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html) class has over 60 methods and 13 constructors.

Most commonly, you create a string with a statement like

    String s = "Hello world!";

rather than using one of the `String` constructors.

The `String` class has many methods to find and retrieve substrings; these can then be easily reassembled into new strings using the `+` concatenation operator.

The `String` class also includes a number of utility methods, among them `split()`, `toLowerCase()`, `toUpperCase()`, and `valueOf()`. The latter method is indispensable in converting user input strings to numbers. The `Number` subclasses also have methods for converting strings to numbers and vice versa.

In addition to the `String` class, there is also a [`StringBuilder`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html) class. Working with `StringBuilder` objects can sometimes be more efficient than working with strings. The `StringBuilder` class offers a few methods that can be useful for strings, among them `reverse()`. In general, however, the `String` class has a wider variety of methods.

A string can be converted to a string builder using a `StringBuilder` constructor. A string builder can be converted to a string with the `toString()` method.


<a name="sec_6_14"></a>
## 6.14. [Autoboxing and Unboxing](#sec_6_14)
******
https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html 

_Autoboxing_ is the automatic conversion that the Java compiler makes between the primitive types and their corresponding object wrapper classes. For example, converting an int to an Integer, a double to a Double, and so on. If the conversion goes the other way, this is called _unboxing_.

Here is the simplest example of autoboxing:

    Character ch = 'a';

The rest of the examples in this section use generics. If you are not yet familiar with the syntax of generics, see the [Generics (Updated)](../generics/index.html) lesson.

Consider the following code:

    List<Integer> li = new ArrayList<>();
    for (int i = 1; i < 50; i += 2)
        li.add(i);

Although you add the int values as primitive types, rather than Integer objects, to li, the code compiles. Because li is a list of Integer objects, not a list of int values, you may wonder why the Java compiler does not issue a compile-time error. The compiler does not generate an error because it creates an Integer object from i and adds the object to li. Thus, the compiler converts the previous code to the following at runtime:

    List<Integer> li = new ArrayList<>();
    for (int i = 1; i < 50; i += 2)
        li.add(Integer.valueOf(i));

Converting a primitive value (an int, for example) into an object of the corresponding wrapper class (Integer) is called autoboxing. The Java compiler applies autoboxing when a primitive value is:

*   Passed as a parameter to a method that expects an object of the corresponding wrapper class.
*   Assigned to a variable of the corresponding wrapper class.

Consider the following method:

```java
public static int sumEven(List<Integer> li) {
    int sum = 0;
    for (Integer i: li)
        if (i % 2 == 0)
            sum += i;
        return sum;
}
```

Because the remainder (%) and unary plus (+=) operators do not apply to Integer objects, you may wonder why the Java compiler compiles the method without issuing any errors. The compiler does not generate an error because it invokes the intValue method to convert an Integer to an int at runtime:

```java
public static int sumEven(List<Integer> li) {
    int sum = 0;
    for (Integer i : li)
        if (i.intValue() % 2 == 0)
            sum += i.intValue();
        return sum;
}
```

Converting an object of a wrapper type (Integer) to its corresponding primitive (int) value is called unboxing. The Java compiler applies unboxing when an object of a wrapper class is:

*   Passed as a parameter to a method that expects a value of the corresponding primitive type.
*   Assigned to a variable of the corresponding primitive type.

The [`Unboxing`](https://docs.oracle.com/javase/tutorial/java/data/examples/Unboxing.java) example shows how this works:

```java
import java.util.ArrayList;
import java.util.List;

public class Unboxing {

    public static void main(String[] args) {
        Integer i = new Integer(-8);

        // 1. Unboxing through method invocation
        int absVal = absoluteValue(i);
        System.out.println("absolute value of " + i + " = " + absVal);

        List<Double> ld = new ArrayList<>();
        ld.add(3.1416);    // Œ† is autoboxed through method invocation.

        // 2. Unboxing through assignment
        double pi = ld.get(0);
        System.out.println("pi = " + pi);
    }

    public static int absoluteValue(int i) {
        return (i < 0) ? -i : i;
    }
}
```

The program prints the following:

    absolute value of -8 = 8
    pi = 3.1416

Autoboxing and unboxing lets developers write cleaner code, making it easier to read. The following table lists the primitive types and their corresponding wrapper classes, which are used by the Java compiler for autoboxing and unboxing:

| Primitive type | Wrapper class |
|----------------|---------------|
| boolean | Boolean   |
| byte    | Byte      |
| char    | Character |
| float   | Float     |
| int     | Integer   |
| long    | Long      |
| short   | Short     |
| double  | Double    |


<a name="sec_6_15"></a>
## 6.15. [Questions and Exercises: Characters and Strings](#sec_6_15)
******
https://docs.oracle.com/javase/tutorial/java/data/QandE/characters-questions.html 

Questions
---------

1.  What is the initial capacity of the following string builder?
    
    StringBuilder sb = new StringBuilder("Able was I ere I saw Elba.");
    
2.  Consider the following string:
    
    String hannah = "Did Hannah see bees? Hannah did.";
    
    1.  What is the value displayed by the expression `hannah.length()`?
        
    2.  What is the value returned by the method call `hannah.charAt(12)`?
        
    3.  Write an expression that refers to the letter `b` in the string referred to by `hannah`.
        
3.  How long is the string returned by the following expression? What is the string?
    
    "Was it a car or a cat I saw?".substring(9, 12)
    
4.  In the following program, called [`ComputeResult`](https://docs.oracle.com/javase/tutorial/java/data/QandE/ComputeResult.java), what is the value of `result` after each numbered line executes?
    
    ```java
    public class ComputeResult {
            public static void main(String[] args) {
                String original = "software";
                StringBuilder result = new StringBuilder("hi");
                int index = original.indexOf('a');
        
        /*1*/   result.setCharAt(0, original.charAt(0));
        /*2*/   result.setCharAt(1, original.charAt(original.length()-1));
        /*3*/   result.insert(1, original.charAt(4));
        /*4*/   result.append(original.substring(1,4));
        /*5*/   result.insert(3, (original.substring(index, index+2) + " ")); 
        
                System.out.println(result);
            }
        }
    ```
    

Exercises
---------

1.  Show two ways to concatenate the following two strings together to get the string `"Hi, mom."`:
    
    String hi = "Hi, ";
    String mom = "mom.";
    
2.  Write a program that computes your initials from your full name and displays them.
    
3.  An anagram is a word or a phrase made by transposing the letters of another word or phrase; for example, "parliament" is an anagram of "partial men," and "software" is an anagram of "swear oft." Write a program that figures out whether one string is an anagram of another string. The program should ignore white space and punctuation.

Answers to Questions and Exercises: Characters and Strings
==========================================================

Questions
---------

1.  **Question:** What is the initial capacity of the following string builder?
    
    StringBuilder sb = new StringBuilder("Able was I ere I saw Elba.");
    
    **Answer:** It's the length of the initial string + 16: 26 + 16 = 42.
    
2.  Consider the following string:
    
    String hannah = "Did Hannah see bees? Hannah did.";
    
    1.  **Question:** What is the value displayed by the expression `hannah.length()`?
        
        **Answer:** 32.
        
    2.  **Question:** What is the value returned by the method call `hannah.charAt(12)`?
        
        **Answer:** `e`.
        
    3.  **Question:** Write an expression that refers to the letter `b` in the string referred to by `hannah`.
        
        **Answer:** `hannah.charAt(15)`.
        
3.  **Question:** How long is the string returned by the following expression? What is the string?
    
    "Was it a car or a cat I saw?".substring(9, 12)
    
    **Answer:** It's 3 characters in length: `car`. It does not include the space after car.
    
4.  **Question:** In the following program, called [`ComputeResult`](https://docs.oracle.com/javase/tutorial/java/data/QandE/ComputeResult.java), what is the value of `result` after each numbered line executes?
    
    ```java
    public class ComputeResult {
            public static void main(String[] args) {
                String original = "software";
                StringBuilder result = new StringBuilder("hi");
                int index = original.indexOf('a');
        
        /*1*/   result.setCharAt(0, original.charAt(0));
        /*2*/   result.setCharAt(1, original.charAt(original.length()-1));
        /*3*/   result.insert(1, original.charAt(4));
        /*4*/   result.append(original.substring(1,4));
        /*5*/   result.insert(3, (original.substring(index, index+2) + " ")); 
        
                System.out.println(result);
            }
        }
    ```
    
    **Answer:**
    
    1.  si
    2.  se
    3.  swe
    4.  sweoft
    5.  swear oft

Exercises
---------

1.  **Exercise:** Show two ways to concatenate the following two strings together to get the string `"Hi, mom."`:
    
    String hi = "Hi, ";
    String mom = "mom.";
    
    **Answer:** `hi.concat(mom)` and `hi + mom`.
    
2.  **Exercise:** Write a program that computes your initials from your full name and displays them.
    
    **Answer:** [`ComputeInitials`](https://docs.oracle.com/javase/tutorial/java/data/QandE/ComputeInitials.java)
    
    public class ComputeInitials {
        public static void main(String[] args) {
            String myName = "Fred F. Flintstone";
            StringBuffer myInitials = new StringBuffer();
            int length = myName.length();
    
            for (int i = 0; i < length; i++) {
                if (Character.isUpperCase(myName.charAt(i))) {
                    myInitials.append(myName.charAt(i));
                }
            }
            System.out.println("My initials are: " + myInitials);
        }
    }
    
3.  **Exercise:** An anagram is a word or a phrase made by transposing the letters of another word or phrase; for example, "parliament" is an anagram of "partial men," and "software" is an anagram of "swear oft." Write a program that figures out whether one string is an anagram of another string. The program should ignore white space and punctuation.
    
    **Answer:** [`Anagram`](https://docs.oracle.com/javase/tutorial/java/data/QandE/Anagram.java)
    
     
    
    public class Anagram {
    
        public static boolean areAnagrams(String string1,
                                          String string2) {
    
            String workingCopy1 = removeJunk(string1);
            String workingCopy2 = removeJunk(string2);
    
            workingCopy1 = workingCopy1.toLowerCase();
            workingCopy2 = workingCopy2.toLowerCase();
    
            workingCopy1 = sort(workingCopy1);
            workingCopy2 = sort(workingCopy2);
    
            return workingCopy1.equals(workingCopy2);
        }
    
        protected static String removeJunk(String string) {
            int i, len = string.length();
            StringBuilder dest = new StringBuilder(len);
            char c;
    
            for (i = (len - 1); i >= 0; i--) {
                c = string.charAt(i);
                if (Character.isLetter(c)) {
                    dest.append(c);
                }
            }
    
            return dest.toString();
        }
    
        protected static String sort(String string) {
            char[] charArray = string.toCharArray();
    
            java.util.Arrays.sort(charArray);
    
            return new String(charArray);
        }
    
        public static void main(String[] args) {
            String string1 = "Cosmo and Laine:";
            String string2 = "Maid, clean soon!";
    
            System.out.println();
            System.out.println("Testing whether the following "
                             + "strings are anagrams:");
            System.out.println("    String 1: " + string1);
            System.out.println("    String 2: " + string2);
            System.out.println();
    
            if (areAnagrams(string1, string2)) {
                System.out.println("They ARE anagrams!");
            } else {
                System.out.println("They are NOT anagrams!");
            }
            System.out.println();
        }
    }
    

<a name="sec_7"></a>
# üìú/PART [7. Generics (Updated)](#sec_toc)
******
https://docs.oracle.com/javase/tutorial/java/generics/index.html 

1. [Why Use Generics?](#sec_7_1)
2. [Generic Types](#sec_7_2)
3. [Raw Types](#sec_7_3)
4. [Generic Methods](#sec_7_4)
5. [Bounded Type Parameters](#sec_7_5)
6. [Generic Methods and Bounded Type Parameters](#sec_7_6)
7. [Generics, Inheritance, and Subtypes](#sec_7_7)
8. [Type Inference](#sec_7_8)
9. [Wildcards](#sec_7_9)
10. [Upper Bounded Wildcards](#sec_7_10)
11. [Unbounded Wildcards](#sec_7_11)
12. [Lower Bounded Wildcards](#sec_7_12)
13. [Wildcards and Subtyping](#sec_7_13)
14. [Wildcard Capture and Helper Methods](#sec_7_14)
15. [Guidelines for Wildcard Use](#sec_7_15)
16. [Type Erasure](#sec_7_16)
17. [Erasure of Generic Types](#sec_7_17)
18. [Erasure of Generic Methods](#sec_7_18)
19. [Effects of Type Erasure and Bridge Methods](#sec_7_19)
20. [Non-Reifiable Types](#sec_7_20)
21. [Restrictions on Generics](#sec_7_21)
22. [Questions and Exercises](#sec_7_22)

In any nontrivial software project, bugs are simply a fact of life. Careful planning, programming, and testing can help reduce their pervasiveness, but somehow, somewhere, they'll always find a way to creep into your code. This becomes especially apparent as new features are introduced and your code base grows in size and complexity.

Fortunately, some bugs are easier to detect than others. Compile-time bugs, for example, can be detected early on; you can use the compiler's error messages to figure out what the problem is and fix it, right then and there. Runtime bugs, however, can be much more problematic; they don't always surface immediately, and when they do, it may be at a point in the program that is far removed from the actual cause of the problem.

Generics add stability to your code by making more of your bugs detectable at compile time. After completing this lesson, you may want to follow up with the [Generics](../../extra/generics/index.html) tutorial by Gilad Bracha.

<a name="sec_7_1"></a>
## 7.1. [Why Use Generics?](#sec_7_1)
******
https://docs.oracle.com/javase/tutorial/java/generics/why.html 

In a nutshell, generics enable _types_ (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar _formal parameters_ used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to type parameters are types.

Code that uses generics has many benefits over non-generic code:

*   Stronger type checks at compile time.  
    A Java compiler applies strong type checking to generic code and issues errors if the code violates type safety. Fixing compile-time errors is easier than fixing runtime errors, which can be difficult to find.  
      
    
*   Elimination of casts.  
    The following code snippet without generics requires casting:
    
    List list = new ArrayList();
    list.add("hello");
    String s = **(String)** list.get(0);
    
    When re-written to use generics, the code does not require casting:
    
    List<String> list = new ArrayList<String>();
    list.add("hello");
    String s = list.get(0);   // no cast
    
*   Enabling programmers to implement generic algorithms.  
    By using generics, programmers can implement generic algorithms that work on collections of different types, can be customized, and are type safe and easier to read.


<a name="sec_7_2"></a>
## 7.2. [Generic Types](#sec_7_2)
******
https://docs.oracle.com/javase/tutorial/java/generics/types.html 

A _generic type_ is a generic class or interface that is parameterized over types. The following Box class will be modified to demonstrate the concept.

A Simple Box Class
------------------

Begin by examining a non-generic Box class that operates on objects of any type. It needs only to provide two methods: set, which adds an object to the box, and get, which retrieves it:

```java
public class Box {
    private Object object;

    public void set(Object object) { this.object = object; }
    public Object get() { return object; }
}
```

Since its methods accept or return an Object, you are free to pass in whatever you want, provided that it is not one of the primitive types. There is no way to verify, at compile time, how the class is used. One part of the code may place an Integer in the box and expect to get Integers out of it, while another part of the code may mistakenly pass in a String, resulting in a runtime error.

A Generic Version of the Box Class
----------------------------------

A _generic class_ is defined with the following format:

    class name<T1, T2, ..., Tn> { /* ... */ }

The type parameter section, delimited by angle brackets (<>), follows the class name. It specifies the _type parameters_ (also called _type variables_) T1, T2, ..., and Tn.

To update the Box class to use generics, you create a _generic type declaration_ by changing the code "public class Box" to "public class Box<T>". This introduces the type variable, T, that can be used anywhere inside the class.

With this change, the Box class becomes:

```java
/**
 * Generic version of the Box class.
 * @param <T> the type of the value being boxed
 */
public class Box<T> {
    // T stands for "Type"
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
```

As you can see, all occurrences of Object are replaced by T. A type variable can be any **non-primitive** type you specify: any class type, any interface type, any array type, or even another type variable.

This same technique can be applied to create generic interfaces.

Type Parameter Naming Conventions
---------------------------------

By convention, type parameter names are single, uppercase letters. This stands in sharp contrast to the variable [naming](../nutsandbolts/variables.html#naming) conventions that you already know about, and with good reason: Without this convention, it would be difficult to tell the difference between a type variable and an ordinary class or interface name.

The most commonly used type parameter names are:

*   E - Element (used extensively by the Java Collections Framework)
*   K - Key
*   N - Number
*   T - Type
*   V - Value
*   S,U,V etc. - 2nd, 3rd, 4th types

You'll see these names used throughout the Java SE API and the rest of this lesson.

Invoking and Instantiating a Generic Type
-----------------------------------------

To reference the generic Box class from within your code, you must perform a _generic type invocation_, which replaces T with some concrete value, such as Integer:

    Box<Integer> integerBox;

You can think of a generic type invocation as being similar to an ordinary method invocation, but instead of passing an argument to a method, you are passing a _type argument_ ‚Äî Integer in this case ‚Äî to the Box class itself.

* * *

**Type Parameter and Type Argument Terminology:**¬†Many developers use the terms "type parameter" and "type argument" interchangeably, but these terms are not the same. When coding, one provides type arguments in order to create a parameterized type. Therefore, the T in `Foo<T>` is a type parameter and the String in `Foo<String>` f is a type argument. This lesson observes this definition when using these terms.

* * *

Like any other variable declaration, this code does not actually create a new Box object. It simply declares that integerBox will hold a reference to a "Box of Integer", which is how `Box<Integer>` is read.

An invocation of a generic type is generally known as a _parameterized type_.

To instantiate this class, use the new keyword, as usual, but place `<Integer>` between the class name and the parenthesis:

    Box<Integer> integerBox = new Box<Integer>();

The Diamond
-----------

In Java SE 7 and later, you can replace the type arguments required to invoke the constructor of a generic class with an empty set of type arguments (<>) as long as the compiler can determine, or infer, the type arguments from the context. This pair of angle brackets, <>, is informally called _the diamond_. For example, you can create an instance of `Box<Integer>` with the following statement:

    Box<Integer> integerBox = new Box<>();

For more information on diamond notation and type inference, see [Type Inference](genTypeInference.html).

Multiple Type Parameters
------------------------

As mentioned previously, a generic class can have multiple type parameters. For example, the generic OrderedPair class, which implements the generic Pair interface:

```java
public interface Pair<K, V> {
    public K getKey();
    public V getValue();
}

public class OrderedPair<K, V> implements Pair<K, V> {

    private K key;
    private V value;

    public OrderedPair(K key, V value) {
    this.key = key;
    this.value = value;
    }

    public K getKey()   { return key; }
    public V getValue() { return value; }
}
```

The following statements create two instantiations of the OrderedPair class:

    Pair<String, Integer> p1 = new OrderedPair<String, Integer>("Even", 8);
    Pair<String, String>  p2 = new OrderedPair<String, String>("hello", "world");

The code, new `OrderedPair<String, Integer>`, instantiates K as a String and V as an Integer. Therefore, the parameter types of OrderedPair's constructor are String and Integer, respectively. Due to [autoboxing](../data/autoboxing.html), it is valid to pass a String and an int to the class.

As mentioned in [The Diamond](#diamond), because a Java compiler can infer the K and V types from the declaration `OrderedPair<String, Integer>`, these statements can be shortened using diamond notation:

    OrderedPair<String, Integer> p1 = new OrderedPair**<>**("Even", 8);
    OrderedPair<String, String>  p2 = new OrderedPair**<>**("hello", "world");

To create a generic interface, follow the same conventions as for creating a generic class.

Parameterized Types
-------------------

You can also substitute a type parameter (that is, K or V) with a parameterized type (that is, `List<String>`). For example, using the `OrderedPair<K, V>` example:

    OrderedPair<String, **Box<Integer>**> p = new OrderedPair<>("primes", new Box<Integer>(...));


<a name="sec_7_3"></a>
## 7.3. [Raw Types](#sec_7_3)
******
https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html 

A _raw type_ is the name of a generic class or interface without any type arguments. For example, given the generic Box class:

```java
public class Box<T> {
    public void set(T t) { /* ... */ }
    // ...
}
```

To create a parameterized type of Box<T>, you supply an actual type argument for the formal type parameter T:

    Box<Integer> intBox = new Box<>();

If the actual type argument is omitted, you create a raw type of Box<T>:

    Box rawBox = new Box();

Therefore, Box is the raw type of the generic type `Box<T>`. However, a non-generic class or interface type is _not_ a raw type.

Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior ‚Äî a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:

```java
Box<String> stringBox = new Box<>();
Box rawBox = stringBox;               // OK

```
But if you assign a raw type to a parameterized type, you get a warning:

```java
Box rawBox = new Box();           // rawBox is a raw type of Box<T>
Box<Integer> intBox = rawBox;     // warning: unchecked conversion
```

You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:

```java
Box<String> stringBox = new Box<>();
Box rawBox = stringBox;
rawBox.set(8);  // warning: unchecked invocation to set(T)
```

The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.

The [Type Erasure](erasure.html) section has more information on how the Java compiler uses raw types.

Unchecked Error Messages
------------------------

As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:

Note: Example.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.

This can happen when using an older API that operates on raw types, as shown in the following example:

```java
public class WarningDemo {
    public static void main(String[] args){
        Box<Integer> bi;
        bi = createBox();
    }

    static Box createBox(){
        return new Box();
    }
}
```

The term "unchecked" means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The "unchecked" warning is disabled, by default, though the compiler gives a hint. To see all "unchecked" warnings, recompile with `-Xlint:unchecked`.

Recompiling the previous example with `-Xlint:unchecked` reveals the following additional information:

```sh
WarningDemo.java:4: warning: [unchecked] unchecked conversion
found   : Box
required: Box<java.lang.Integer>
        bi = createBox();
                      ^
1 warning
```

To completely disable unchecked warnings, use the `-Xlint:-unchecked` flag. The @SuppressWarnings("unchecked") annotation suppresses unchecked warnings. If you are unfamiliar with the `@SuppressWarnings` syntax, see [Annotations](../../java/annotations/index.html).


<a name="sec_7_4"></a>
## 7.4. [Generic Methods](#sec_7_4)
******
https://docs.oracle.com/javase/tutorial/java/generics/methods.html 

_Generic methods_ are methods that introduce their own type parameters. This is similar to declaring a generic type, but the type parameter's scope is limited to the method where it is declared. Static and non-static generic methods are allowed, as well as generic class constructors.

The syntax for a generic method includes a list of type parameters, inside angle brackets, which appears before the method's return type. For static generic methods, the type parameter section must appear before the method's return type.

The Util class includes a generic method, compare, which compares two Pair objects:

public class Util {
    **public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2)** {
        return p1.getKey().equals(p2.getKey()) &&
               p1.getValue().equals(p2.getValue());
    }
}

public class Pair<K, V> {

    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public void setKey(K key) { this.key = key; }
    public void setValue(V value) { this.value = value; }
    public K getKey()   { return key; }
    public V getValue() { return value; }
}

The complete syntax for invoking this method would be:

    Pair<Integer, String> p1 = new Pair<>(1, "apple");
    Pair<Integer, String> p2 = new Pair<>(2, "pear");
    boolean same = Util.**<Integer, String>**compare(p1, p2);

The type has been explicitly provided, as shown in bold. Generally, this can be left out and the compiler will infer the type that is needed:

    Pair<Integer, String> p1 = new Pair<>(1, "apple");
    Pair<Integer, String> p2 = new Pair<>(2, "pear");
    boolean same = Util.compare(p1, p2);

This feature, known as _type inference_, allows you to invoke a generic method as an ordinary method, without specifying a type between angle brackets. This topic is further discussed in the following section, [Type Inference](genTypeInference.html).


<a name="sec_7_5"></a>
## 7.5. [Bounded Type Parameters](#sec_7_5)
******
https://docs.oracle.com/javase/tutorial/java/generics/bounded.html 

There may be times when you want to restrict the types that can be used as type arguments in a parameterized type. For example, a method that operates on numbers might only want to accept instances of `Number` or its subclasses. This is what _bounded type parameters_ are for.

To declare a bounded type parameter, list the type parameter's name, followed by the `extends` keyword, followed by its _upper bound_, which in this example is `Number`. Note that, in this context, `extends` is used in a general sense to mean either "extends" (as in classes) or "implements" (as in interfaces).

```java
public class Box<T> {

    private T t;          

    public void set(T t) {
        this.t = t;
    }

    public T get() {
        return t;
    }

    public <U **extends Number**> void inspect(U u){
        System.out.println("T: " + t.getClass().getName());
        System.out.println("U: " + u.getClass().getName());
    }

    public static void main(String[] args) {
        Box<Integer> integerBox = new Box<Integer>();
        integerBox.set(new Integer(10));
        integerBox.inspect("some text"); // **error: this is still String!**
    }
}
```

By modifying our generic method to include this bounded type parameter, compilation will now fail, since our invocation of `inspect` still includes a `String`:

    Box.java:21: <U>inspect(U) in Box<java.lang.Integer> cannot
      be applied to (java.lang.String)
                            integerBox.inspect("10");
                                      ^
    1 error

In addition to limiting the types you can use to instantiate a generic type, bounded type parameters allow you to invoke methods defined in the bounds:

```java
public class NaturalNumber<T extends Integer> {

    private T n;

    public NaturalNumber(T n)  { this.n = n; }

    public boolean isEven() {
        return **n.intValue()** % 2 == 0;
    }

    // ...
}
```

The isEven method invokes the intValue method defined in the Integer class through n.

Multiple Bounds
---------------

The preceding example illustrates the use of a type parameter with a single bound, but a type parameter can have _multiple bounds_:

    <T extends B1 & B2 & B3>

A type variable with multiple bounds is a subtype of all the types listed in the bound. If one of the bounds is a class, it must be specified first. For example:

```java
    Class A { /* ... */ }
    interface B { /* ... */ }
    interface C { /* ... */ }

    class D <T extends A & B & C> { /* ... */ }
```

If bound A is not specified first, you get a compile-time error:

    class D <T extends B & A & C> { /* ... */ }  // compile-time error


<a name="sec_7_6"></a>
## 7.6. [Generic Methods and Bounded Type Parameters](#sec_7_6)
******
https://docs.oracle.com/javase/tutorial/java/generics/boundedTypeParams.html 

Bounded type parameters are key to the implementation of generic algorithms. Consider the following method that counts the number of elements in an array T[] that are greater than a specified element elem.

```java
public static <T> int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e > elem)  // compiler error
            ++count;
    return count;
}
```

The implementation of the method is straightforward, but it does not compile because the greater than operator (>) applies only to primitive types such as short, int, double, long, float, byte, and char. You cannot use the > operator to compare objects. To fix the problem, use a type parameter bounded by the `Comparable<T>` interface:

```java
public interface Comparable<T> {
    public int compareTo(T o);
}
```

The resulting code will be:

```java
public static <T extends Comparable<T>> int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e.compareTo(elem) > 0)
            ++count;
    return count;
}
```


<a name="sec_7_7"></a>
## 7.7. [Generics, Inheritance, and Subtypes](#sec_7_7)
******
https://docs.oracle.com/javase/tutorial/java/generics/inheritance.html 

As you already know, it is possible to assign an object of one type to an object of another type provided that the types are compatible. For example, you can assign an Integer to an Object, since Object is one of Integer's supertypes:

    Object someObject = new Object();
    Integer someInteger = new Integer(10);
    someObject = someInteger;   // OK

In object-oriented terminology, this is called an "is a" relationship. Since an Integer _is a_ kind of Object, the assignment is allowed. But Integer is also a kind of Number, so the following code is valid as well:

    public void someMethod(Number n) { /* ... */ }

    someMethod(new Integer(10));   // OK
    someMethod(new Double(10.1));   // OK

The same is also true with generics. You can perform a generic type invocation, passing Number as its type argument, and any subsequent invocation of add will be allowed if the argument is compatible with Number:

    Box<Number> box = new Box<Number>();
    box.add(new Integer(10));   // OK
    box.add(new Double(10.1));  // OK

Now consider the following method:

    public void boxTest(Box<Number> n) { /* ... */ }

What type of argument does it accept? By looking at its signature, you can see that it accepts a single argument whose type is `Box<Number>`. But what does that mean? Are you allowed to pass in `Box<Integer>` or `Box<Double>`, as you might expect? The answer is "no", because `Box<Integer>` and `Box<Double>` are not subtypes of `Box<Number>`.

This is a common misunderstanding when it comes to programming with generics, but it is an important concept to learn.

![diagram showing that `Box<Integer>` is not a subtype of `Box<Number>`](https://docs.oracle.com/javase/tutorial/figures/java/generics-subtypeRelationship.gif)

`Box<Integer>` is not a subtype of `Box<Number>` even though Integer is a subtype of Number.

* * *

**Note:**¬†Given two concrete types A and B (for example, Number and Integer), `MyClass<A>` has no relationship to `MyClass<B>`, regardless of whether or not A and B are related. The common parent of `MyClass<A>` and `MyClass<B>` is Object.  
  
For information on how to create a subtype-like relationship between two generic classes when the type parameters are related, see [Wildcards and Subtyping](subtyping.html).

* * *

Generic Classes and Subtyping
-----------------------------

You can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the extends and implements clauses.

Using the Collections classes as an example, `ArrayList<E>` implements `List<E>`, and `List<E>` extends `Collection<E>`. So `ArrayList<String>` is a subtype of `List<String>`, which is a subtype of `Collection<String>`. So long as you do not vary the type argument, the subtyping relationship is preserved between the types.

![diagram showing a sample collections hierarchy: `ArrayList<String>` is a subtype of `List<String>`, which is a subtype of `Collection<String>`.](https://docs.oracle.com/javase/tutorial/figures/java/generics-sampleHierarchy.gif)

A sample Collections hierarchy

Now imagine we want to define our own list interface, PayloadList, that associates an optional value of generic type P with each element. Its declaration might look like:

    interface PayloadList<E,P> extends List<E> {
      void setPayload(int index, P val);
      ...
    }

The following parameterizations of PayloadList are subtypes of `List<String>`:

*   `PayloadList<String,String>`
*   `PayloadList<String,Integer>`
*   `PayloadList<String,Exception>`

![diagram showing an example PayLoadList hierarchy: `PayloadList<String, String>` is a subtype of `List<String>`, which is a subtype of `Collection<String>`. At the same level of `PayloadList<String,String>` is `PayloadList<String, Integer>` and `PayloadList<String, Exceptions>`.](https://docs.oracle.com/javase/tutorial/figures/java/generics-payloadListHierarchy.gif)

A sample PayloadList hierarchy


<a name="sec_7_8"></a>
## 7.8. [Type Inference](#sec_7_8)
******
https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html 

_Type inference_ is a Java compiler's ability to look at each method invocation and corresponding declaration to determine the type argument (or arguments) that make the invocation applicable. The inference algorithm determines the types of the arguments and, if available, the type that the result is being assigned, or returned. Finally, the inference algorithm tries to find the _most specific_ type that works with all of the arguments.

To illustrate this last point, in the following example, inference determines that the second argument being passed to the pick method is of type Serializable:

    static <T> T pick(T a1, T a2) { return a2; }
    Serializable s = pick("d", new ArrayList<String>());

Type Inference and Generic Methods
----------------------------------

[Generic Methods](methods.html) introduced you to type inference, which enables you to invoke a generic method as you would an ordinary method, without specifying a type between angle brackets. Consider the following example, [`BoxDemo`](https://docs.oracle.com/javase/tutorial/java/generics/examples/BoxDemo.java), which requires the [`Box`](https://docs.oracle.com/javase/tutorial/java/generics/examples/Box.java) class:

```java
public class BoxDemo {

  public static <U> void addBox(U u, 
      java.util.List<Box<U>> boxes) {
    Box<U> box = new Box<>();
    box.set(u);
    boxes.add(box);
  }

  public static <U> void outputBoxes(java.util.List<Box<U>> boxes) {
    int counter = 0;
    for (Box<U> box: boxes) {
      U boxContents = box.get();
      System.out.println("Box #" + counter + " contains [" +
             boxContents.toString() + "]");
      counter++;
    }
  }

  public static void main(String[] args) {
    java.util.ArrayList<Box<Integer>> listOfIntegerBoxes =
      new java.util.ArrayList<>();
    BoxDemo.<Integer>addBox(Integer.valueOf(10), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(30), listOfIntegerBoxes);
    BoxDemo.outputBoxes(listOfIntegerBoxes);
  }
}
```

The following is the output from this example:

    Box #0 contains [10]
    Box #sec_1 contains [20]
    Box #2 contains [30]

The generic method `addBox` defines one type parameter named `U`. Generally, a Java compiler can infer the type parameters of a generic method call. Consequently, in most cases, you do not have to specify them. For example, to invoke the generic method `addBox`, you can specify the type parameter with a _type witness_ as follows:

    BoxDemo.**<Integer>**addBox(Integer.valueOf(10), listOfIntegerBoxes);

Alternatively, if you omit the type witness,a Java compiler automatically infers (from the method's arguments) that the type parameter is `Integer`:

    BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);

Type Inference and Instantiation of Generic Classes
---------------------------------------------------

You can replace the type arguments required to invoke the constructor of a generic class with an empty set of type parameters (`<>`) as long as the compiler can infer the type arguments from the context. This pair of angle brackets is informally called [the diamond](types.html#diamond).

For example, consider the following variable declaration:

    Map<String, List<String>> myMap = new HashMap<String, List<String>>();

You can substitute the parameterized type of the constructor with an empty set of type parameters (<>):

    Map<String, List<String>> myMap = new HashMap<>();

Note that to take advantage of type inference during generic class instantiation, you must use the diamond. In the following example, the compiler generates an unchecked conversion warning because the `HashMap()` constructor refers to the `HashMap` raw type, not the `Map<String, List<String>>` type:

    Map<String, List<String>> myMap = new HashMap(); // unchecked conversion warning

Type Inference and Generic Constructors of Generic and Non-Generic Classes
--------------------------------------------------------------------------

Note that constructors can be generic (in other words, declare their own formal type parameters) in both generic and non-generic classes. Consider the following example:

    class MyClass<X> {
      <T> MyClass(T t) {
        // ...
      }
    }

Consider the following instantiation of the class `MyClass`:

    new MyClass<Integer>("")

This statement creates an instance of the parameterized type `MyClass<Integer>`; the statement explicitly specifies the type `Integer` for the formal type parameter, `X`, of the generic class `MyClass<X>`. Note that the constructor for this generic class contains a formal type parameter, `T`. The compiler infers the type `String` for the formal type parameter, `T`, of the constructor of this generic class (because the actual parameter of this constructor is a `String` object).

Compilers from releases prior to Java SE 7 are able to infer the actual type parameters of generic constructors, similar to generic methods. However, compilers in Java SE 7 and later can infer the actual type parameters of the generic class being instantiated if you use the diamond (`<>`). Consider the following example:

    MyClass<Integer> myObject = new MyClass<>("");

In this example, the compiler infers the type `Integer` for the formal type parameter, `X`, of the generic class `MyClass<X>`. It infers the type `String` for the formal type parameter, `T`, of the constructor of this generic class.

* * *

**Note:**¬†It is important to note that the inference algorithm uses only invocation arguments, target types, and possibly an obvious expected return type to infer types. The inference algorithm does not use results from later in the program.

* * *

Target Types
------------

The Java compiler takes advantage of target typing to infer the type parameters of a generic method invocation. The _target type_ of an expression is the data type that the Java compiler expects depending on where the expression appears. Consider the method `Collections.emptyList`, which is declared as follows:

    static <T> List<T> emptyList();

Consider the following assignment statement:

    List<String> listOne = Collections.emptyList();

This statement is expecting an instance of `List<String>`; this data type is the target type. Because the method `emptyList` returns a value of type `List<T>`, the compiler infers that the type argument `T` must be the value `String`. This works in both Java SE 7 and 8. Alternatively, you could use a type witness and specify the value of `T` as follows:

    List<String> listOne = Collections.<String>emptyList();

However, this is not necessary in this context. It was necessary in other contexts, though. Consider the following method:

    void processStringList(List<String> stringList) {
        // process stringList
    }

Suppose you want to invoke the method `processStringList` with an empty list. In Java SE 7, the following statement does not compile:

    processStringList(Collections.emptyList());

The Java SE 7 compiler generates an error message similar to the following:

    List<Object> cannot be converted to List<String>

The compiler requires a value for the type argument `T` so it starts with the value `Object`. Consequently, the invocation of `Collections.emptyList` returns a value of type `List<Object>`, which is incompatible with the method `processStringList`. Thus, in Java SE 7, you must specify the value of the value of the type argument as follows:

    processStringList(Collections.<String>emptyList());

This is no longer necessary in Java SE 8. The notion of what is a target type has been expanded to include method arguments, such as the argument to the method `processStringList`. In this case, `processStringList` requires an argument of type `List<String>`. The method `Collections.emptyList` returns a value of `List<T>`, so using the target type of `List<String>`, the compiler infers that the type argument `T` has a value of `String`. Thus, in Java SE 8, the following statement compiles:

    processStringList(Collections.emptyList());

See [Target Typing](../../java/javaOO/lambdaexpressions.html#target-typing) in [Lambda Expressions](../../java/javaOO/lambdaexpressions.html) for more information.


<a name="sec_7_9"></a>
## 7.9. [Wildcards](#sec_7_9)
******
https://docs.oracle.com/javase/tutorial/java/generics/wildcards.html 

In generic code, the question mark (?), called the _wildcard_, represents an unknown type. The wildcard can be used in a variety of situations: as the type of a parameter, field, or local variable; sometimes as a return type (though it is better programming practice to be more specific). The wildcard is never used as a type argument for a generic method invocation, a generic class instance creation, or a supertype.

The following sections discuss wildcards in more detail, including upper bounded wildcards, lower bounded wildcards, and wildcard capture.


<a name="sec_7_10"></a>
## 7.10. [Upper Bounded Wildcards](#sec_7_10)
******
https://docs.oracle.com/javase/tutorial/java/generics/upperBounded.html 

You can use an upper bounded wildcard to relax the restrictions on a variable. For example, say you want to write a method that works on `List<Integer>`, `List<Double>`, _and_ `List<Number>`; you can achieve this by using an upper bounded wildcard.

To declare an upper-bounded wildcard, use the wildcard character ('?'), followed by the extends keyword, followed by its _upper bound_. Note that, in this context, extends is used in a general sense to mean either "extends" (as in classes) or "implements" (as in interfaces).

To write the method that works on lists of Number and the subtypes of Number, such as Integer, Double, and Float, you would specify `List<? extends Number>`. The term `List<Number>` is more restrictive than `List<? extends Number>` because the former matches a list of type Number only, whereas the latter matches a list of type Number or any of its subclasses.

Consider the following process method:

    public static void process(List**<? extends Foo>** list) { /* ... */ }

The upper bounded wildcard, `<? extends Foo>`, where Foo is any type, matches Foo and any subtype of Foo. The process method can access the list elements as type Foo:

public static void process(List<? extends Foo> list) {
    for (Foo elem : list) {
        // ...
    }
}

In the foreach clause, the elem variable iterates over each element in the list. Any method defined in the Foo class can now be used on elem.

The sumOfList method returns the sum of the numbers in a list:

    public static double sumOfList(List<? extends Number> list) {
        double s = 0.0;
        for (Number n : list)
            s += n.doubleValue();
        return s;
    }

The following code, using a list of Integer objects, prints sum = 6.0:

    List<Integer> li = Arrays.asList(1, 2, 3);
    System.out.println("sum = " + sumOfList(li));

A list of Double values can use the same sumOfList method. The following code prints sum = 7.0:

    List<Double> ld = Arrays.asList(1.2, 2.3, 3.5);
    System.out.println("sum = " + sumOfList(ld));


<a name="sec_7_11"></a>
## 7.11. [Unbounded Wildcards](#sec_7_11)
******
https://docs.oracle.com/javase/tutorial/java/generics/unboundedWildcards.html 

The unbounded wildcard type is specified using the wildcard character (?), for example, `List<?>`. This is called a _list of unknown type_. There are two scenarios where an unbounded wildcard is a useful approach:

*   If you are writing a method that can be implemented using functionality provided in the Object class.
*   When the code is using methods in the generic class that don't depend on the type parameter. For example, List.size or List.clear. In fact, `Class<?>` is so often used because most of the methods in `Class<T>` do not depend on T.

Consider the following method, printList:

    public static void printList(List<Object> list) {
        for (Object elem : list)
            System.out.println(elem + " ");
        System.out.println();
    }

The goal of printList is to print a list of any type, but it fails to achieve that goal ‚Äî it prints only a list of Object instances; it cannot print `List<Integer>`, `List<String>`, `List<Double>`, and so on, because they are not subtypes of `List<Object>`. To write a generic printList method, use `List<?>`:

    public static void printList(List<?> list) {
        for (Object elem: list)
            System.out.print(elem + " ");
        System.out.println();
    }

Because for any concrete type A, `List<A>` is a subtype of `List<?>`, you can use printList to print a list of any type:

    List<Integer> li = Arrays.asList(1, 2, 3);
    List<String>  ls = Arrays.asList("one", "two", "three");
    printList(li);
    printList(ls);

* * *

**Note:**¬†The [Arrays.asList](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-) method is used in examples throughout this lesson. This static factory method converts the specified array and returns a fixed-size list.

* * *

It's important to note that `List<Object>` and `List<?>` are not the same. You can insert an Object, or any subtype of Object, into a `List<Object>`. But you can only insert null into a `List<?>`. The [Guidelines for Wildcard Use](wildcardGuidelines.html) section has more information on how to determine what kind of wildcard, if any, should be used in a given situation.


<a name="sec_7_12"></a>
## 7.12. [Lower Bounded Wildcards](#sec_7_12)
******
https://docs.oracle.com/javase/tutorial/java/generics/lowerBounded.html 

The [Upper Bounded Wildcards](upperBounded.html) section shows that an upper bounded wildcard restricts the unknown type to be a specific type or a subtype of that type and is represented using the extends keyword. In a similar way, a _lower bounded_ wildcard restricts the unknown type to be a specific type or a _super type_ of that type.

A lower bounded wildcard is expressed using the wildcard character ('?'), following by the super keyword, followed by its _lower bound_: <? super A>.

* * *

**Note:**¬†You can specify an upper bound for a wildcard, or you can specify a lower bound, but you cannot specify both.

* * *

Say you want to write a method that puts Integer objects into a list. To maximize flexibility, you would like the method to work on `List<Integer>`, `List<Number>`, and `List<Object>` ‚Äî anything that can hold Integer values.

To write the method that works on lists of Integer and the supertypes of Integer, such as Integer, Number, and Object, you would specify `List<? super Integer>`. The term `List<Integer>` is more restrictive than `List<? super Integer>` because the former matches a list of type Integer only, whereas the latter matches a list of any type that is a supertype of Integer.

The following code adds the numbers 1 through 10 to the end of a list:

    public static void addNumbers(List<? super Integer> list) {
        for (int i = 1; i <= 10; i++) {
            list.add(i);
        }
    }

The [Guidelines for Wildcard Use](wildcardGuidelines.html) section provides guidance on when to use upper bounded wildcards and when to use lower bounded wildcards.


<a name="sec_7_13"></a>
## 7.13. [Wildcards and Subtyping](#sec_7_13)
******
https://docs.oracle.com/javase/tutorial/java/generics/subtyping.html 

As described in [Generics, Inheritance, and Subtypes](inheritance.html), generic classes or interfaces are not related merely because there is a relationship between their types. However, you can use wildcards to create a relationship between generic classes or interfaces.

Given the following two regular (non-generic) classes:

    class A { /* ... */ }
    class B extends A { /* ... */ }

It would be reasonable to write the following code:

    B b = new B();
    A a = b;

This example shows that inheritance of regular classes follows this rule of subtyping: class B is a subtype of class A if B extends A. This rule does not apply to generic types:

    List<B> lb = new ArrayList<>();
    List<A> la = lb;   // compile-time error

Given that Integer is a subtype of Number, what is the relationship between `List<Integer>` and `List<Number>`?

![diagram showing that the common parent of `List<Number>` and `List<Integer>` is the list of unknown type](https://docs.oracle.com/javase/tutorial/figures/java/generics-listParent.gif)

The common parent is `List<?>`.

Although Integer is a subtype of Number, `List<Integer>` is not a subtype of `List<Number>` and, in fact, these two types are not related. The common parent of `List<Number>` and `List<Integer>` is `List<?>`.

In order to create a relationship between these classes so that the code can access Number's methods through `List<Integer>`'s elements, use an upper bounded wildcard:

    List<? extends Integer> intList = new ArrayList<>();
    List<? extends Number>  numList = intList;  // OK. List<? extends Integer> is a subtype of List<? extends Number>

Because Integer is a subtype of Number, and numList is a list of Number objects, a relationship now exists between intList (a list of Integer objects) and numList. The following diagram shows the relationships between several List classes declared with both upper and lower bounded wildcards.

![diagram showing that `List<Integer>` is a subtype of both `List<? extends Integer>` and `List<?super Integer>`. `List<? extends Integer>` is a subtype of `List<? extends Number>` which is a subtype of `List<?>`. `List<Number>` is a subtype of `List<? super Number> and List>? extends Number>`. `List<? super Number>` is a subtype of `List<? super Integer>` which is a subtype of `List<?>`.](https://docs.oracle.com/javase/tutorial/figures/java/generics-wildcardSubtyping.gif)

A hierarchy of several generic List class declarations.

The [Guidelines for Wildcard Use](wildcardGuidelines.html) section has more information about the ramifications of using upper and lower bounded wildcards.


<a name="sec_7_14"></a>
## 7.14. [Wildcard Capture and Helper Methods](#sec_7_14)
******
https://docs.oracle.com/javase/tutorial/java/generics/capture.html 

In some cases, the compiler infers the type of a wildcard. For example, a list may be defined as List<?> but, when evaluating an expression, the compiler infers a particular type from the code. This scenario is known as _wildcard capture_.

For the most part, you don't need to worry about wildcard capture, except when you see an error message that contains the phrase "capture of".

The [`WildcardError`](https://docs.oracle.com/javase/tutorial/java/generics/examples/WildcardError.java) example produces a capture error when compiled:

```java
import java.util.List;

public class WildcardError {

    void foo(List<?> i) {
        i.set(0, i.get(0));
    }
}
```

In this example, the compiler processes the i input parameter as being of type Object. When the foo method invokes [List.set(int, E)](https://docs.oracle.com/javase/8/docs/api/java/util/List.html#set-int-E-), the compiler is not able to confirm the type of object that is being inserted into the list, and an error is produced. When this type of error occurs it typically means that the compiler believes that you are assigning the wrong type to a variable. Generics were added to the Java language for this reason ‚Äî to enforce type safety at compile time.

The WildcardError example generates the following error when compiled by Oracle's JDK 7 javac implementation:

    WildcardError.java:6: error: method set in interface List<E> cannot be applied to given types;
        i.set(0, i.get(0));
         ^
      required: int,CAP#sec_1
      found: int,Object
      reason: actual argument Object cannot be converted to CAP#sec_1 by method invocation conversion
      where E is a type-variable:
        E extends Object declared in interface List
      where CAP#sec_1 is a fresh type-variable:
        CAP#sec_1 extends Object from capture of ?
    1 error

In this example, the code is attempting to perform a safe operation, so how can you work around the compiler error? You can fix it by writing a _private helper method_ which captures the wildcard. In this case, you can work around the problem by creating the private helper method, fooHelper, as shown in [`WildcardFixed`](https://docs.oracle.com/javase/tutorial/java/generics/examples/WildcardFixed.java):

```java
public class WildcardFixed {

    void foo(List<?> i) {
        fooHelper(i);
    }


    // Helper method created so that the wildcard can be captured
    // through type inference.
    **private <T> void fooHelper(List<T> l) {
        l.set(0, l.get(0));
    }**

}
```

Thanks to the helper method, the compiler uses inference to determine that T is CAP#sec_1, the capture variable, in the invocation. The example now compiles successfully.

By convention, helper methods are generally named _originalMethodName_Helper.

Now consider a more complex example, [`WildcardErrorBad`](https://docs.oracle.com/javase/tutorial/java/generics/examples/WildcardErrorBad.java):

```java
import java.util.List;

public class WildcardErrorBad {

    void swapFirst(List<? extends Number> l1, List<? extends Number> l2) {
      Number temp = l1.get(0);
      l1.set(0, l2.get(0)); // expected a CAP#sec_1 extends Number,
                            // got a CAP#2 extends Number;
                            // same bound, but different types
      l2.set(0, temp);      // expected a CAP#sec_1 extends Number,
                            // got a Number
    }
}
```

In this example, the code is attempting an unsafe operation. For example, consider the following invocation of the swapFirst method:

    List<Integer> li = Arrays.asList(1, 2, 3);
    List<Double>  ld = Arrays.asList(10.10, 20.20, 30.30);
    swapFirst(li, ld);

While `List<Integer>` and `List<Double>` both fulfill the criteria of `List<? extends Number>`, it is clearly incorrect to take an item from a list of Integer values and attempt to place it into a list of Double values.

Compiling the code with Oracle's JDK javac compiler produces the following error:

```sh
WildcardErrorBad.java:7: error: method set in interface List<E> cannot be applied to given types;
      l1.set(0, l2.get(0)); // expected a CAP#sec_1 extends Number,
        ^
  required: int,CAP#sec_1
  found: int,Number
  reason: actual argument Number cannot be converted to CAP#sec_1 by method invocation conversion
  where E is a type-variable:
    E extends Object declared in interface List
  where CAP#sec_1 is a fresh type-variable:
    CAP#sec_1 extends Number from capture of ? extends Number
WildcardErrorBad.java:10: error: method set in interface List<E> cannot be applied to given types;
      l2.set(0, temp);      // expected a CAP#sec_1 extends Number,
        ^
  required: int,CAP#sec_1
  found: int,Number
  reason: actual argument Number cannot be converted to CAP#sec_1 by method invocation conversion
  where E is a type-variable:
    E extends Object declared in interface List
  where CAP#sec_1 is a fresh type-variable:
    CAP#sec_1 extends Number from capture of ? extends Number
WildcardErrorBad.java:15: error: method set in interface List<E> cannot be applied to given types;
        i.set(0, i.get(0));
         ^
  required: int,CAP#sec_1
  found: int,Object
  reason: actual argument Object cannot be converted to CAP#sec_1 by method invocation conversion
  where E is a type-variable:
    E extends Object declared in interface List
  where CAP#sec_1 is a fresh type-variable:
    CAP#sec_1 extends Object from capture of ?
3 errors
```

There is no helper method to work around the problem, because the code is fundamentally wrong: it is clearly incorrect to take an item from a list of Integer values and attempt to place it into a list of Double values.


<a name="sec_7_15"></a>
## 7.15. [Guidelines for Wildcard Use](#sec_7_15)
******
https://docs.oracle.com/javase/tutorial/java/generics/wildcardGuidelines.html 

One of the more confusing aspects when learning to program with generics is determining when to use an upper bounded wildcard and when to use a lower bounded wildcard. This page provides some guidelines to follow when designing your code.

For purposes of this discussion, it is helpful to think of variables as providing one of two functions:

**An "In" Variable**

An "in" variable serves up data to the code. Imagine a copy method with two arguments: copy(src, dest). The src argument provides the data to be copied, so it is the "in" parameter.

**An "Out" Variable**

An "out" variable holds data for use elsewhere. In the copy example, copy(src, dest), the dest argument accepts data, so it is the "out" parameter.

Of course, some variables are used both for "in" and "out" purposes ‚Äî this scenario is also addressed in the guidelines.

You can use the "in" and "out" principle when deciding whether to use a wildcard and what type of wildcard is appropriate. The following list provides the guidelines to follow:

* * *

**Wildcard Guidelines:**¬†

*   An "in" variable is defined with an upper bounded wildcard, using the extends keyword.
*   An "out" variable is defined with a lower bounded wildcard, using the super keyword.
*   In the case where the "in" variable can be accessed using methods defined in the Object class, use an unbounded wildcard.
*   In the case where the code needs to access the variable as both an "in" and an "out" variable, do not use a wildcard.

* * *

These guidelines do not apply to a method's return type. Using a wildcard as a return type should be avoided because it forces programmers using the code to deal with wildcards.

A list defined by `List<? extends ...>` can be informally thought of as read-only, but that is not a strict guarantee. Suppose you have the following two classes:

```java
    class NaturalNumber {
    
            private int i;
    
            public NaturalNumber(int i) { this.i = i; }
            // ...
        }
    
        class EvenNumber extends NaturalNumber {
    
            public EvenNumber(int i) { super(i); }
            // ...
        }
```

Consider the following code:

    List<EvenNumber> le = new ArrayList<>();
    List<? extends NaturalNumber> ln = le;
    ln.add(new NaturalNumber(35));  // compile-time error

Because `List<EvenNumber>` is a subtype of `List<? extends NaturalNumber>`, you can assign le to ln. But you cannot use ln to add a natural number to a list of even numbers. The following operations on the list are possible:

*   You can add null.
*   You can invoke clear.
*   You can get the iterator and invoke remove.
*   You can capture the wildcard and write elements that you've read from the list.

You can see that the list defined by `List<? extends NaturalNumber>` is not read-only in the strictest sense of the word, but you might think of it that way because you cannot store a new element or change an existing element in the list.


<a name="sec_7_16"></a>
## 7.16. [Type Erasure](#sec_7_16)
******
https://docs.oracle.com/javase/tutorial/java/generics/erasure.html 

Generics were introduced to the Java language to provide tighter type checks at compile time and to support generic programming. To implement generics, the Java compiler applies type erasure to:

*   Replace all type parameters in generic types with their bounds or Object if the type parameters are unbounded. The produced bytecode, therefore, contains only ordinary classes, interfaces, and methods.
*   Insert type casts if necessary to preserve type safety.
*   Generate bridge methods to preserve polymorphism in extended generic types.

Type erasure ensures that no new classes are created for parameterized types; consequently, generics incur no runtime overhead.


<a name="sec_7_17"></a>
## 7.17. [Erasure of Generic Types](#sec_7_17)
******
https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html 

During the type erasure process, the Java compiler erases all type parameters and replaces each with its first bound if the type parameter is bounded, or Object if the type parameter is unbounded.

Consider the following generic class that represents a node in a singly linked list:

```java
    public class Node<T> {

        private T data;
        private Node<T> next;

        public Node(T data, Node<T> next) {
            this.data = data;
            this.next = next;
        }

        public T getData() { return data; }
        // ...
    }
```

Because the type parameter T is unbounded, the Java compiler replaces it with Object:

```java
    public class Node {

        private Object data;
        private Node next;

        public Node(Object data, Node next) {
            this.data = data;
            this.next = next;
        }

        public Object getData() { return data; }
        // ...
    }
```

In the following example, the generic Node class uses a bounded type parameter:

```java
    public class Node<T extends Comparable<T>> {

        private T data;
        private Node<T> next;

        public Node(T data, Node<T> next) {
            this.data = data;
            this.next = next;
        }

        public T getData() { return data; }
        // ...
    }
```

The Java compiler replaces the bounded type parameter T with the first bound class, Comparable:

```java
    public class Node {

        private Comparable data;
        private Node next;

        public Node(Comparable data, Node next) {
            this.data = data;
            this.next = next;
        }

        public Comparable getData() { return data; }
        // ...
    }
```


<a name="sec_7_18"></a>
## 7.18. [Erasure of Generic Methods](#sec_7_18)
******
https://docs.oracle.com/javase/tutorial/java/generics/genMethods.html 

The Java compiler also erases type parameters in generic method arguments. Consider the following generic method:

```java
    // Counts the number of occurrences of elem in anArray.
    //
    public static <T> int count(T[] anArray, T elem) {
        int cnt = 0;
        for (T e : anArray)
            if (e.equals(elem))
                ++cnt;
            return cnt;
    }
```

Because T is unbounded, the Java compiler replaces it with Object:

```java
    public static int count(Object[] anArray, Object elem) {
        int cnt = 0;
        for (Object e : anArray)
            if (e.equals(elem))
                ++cnt;
            return cnt;
    }
```

Suppose the following classes are defined:

    class Shape { /* ... */ }
    class Circle extends Shape { /* ... */ }
    class Rectangle extends Shape { /* ... */ }

You can write a generic method to draw different shapes:

    public static <T extends Shape> void draw(T shape) { /* ... */ }

The Java compiler replaces T with Shape:

    public static void draw(Shape shape) { /* ... */ }


<a name="sec_7_19"></a>
## 7.19. [Effects of Type Erasure and Bridge Methods](#sec_7_19)
******
https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html 

Sometimes type erasure causes a situation that you may not have anticipated. The following example shows how this can occur. The following example shows how a compiler sometimes creates a synthetic method, which is called a _bridge method_, as part of the type erasure process.

Given the following two classes:

```java
public class Node<T> {

    public T data;

    public Node(T data) { this.data = data; }

    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node<Integer> {
    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

Consider the following code:

```java
MyNode mn = new MyNode(5);
Node n = mn;            // A raw type - compiler throws an unchecked warning
n.setData("Hello");     // Causes a ClassCastException to be thrown.
Integer x = mn.data;    

After type erasure, this code becomes:

MyNode mn = new MyNode(5);
Node n = mn;            // A raw type - compiler throws an unchecked warning
                        // Note: This statement could instead be the following:
                        //     Node n = (Node)mn;
                        // However, the compiler doesn't generate a cast because
                        // it isn't required.
n.setData("Hello");     // Causes a ClassCastException to be thrown.
Integer x = (Integer)mn.data; 
```

The next section explains why a `ClassCastException` is thrown at the `n.setData("Hello");` statement.

Bridge Methods
--------------

When compiling a class or interface that extends a parameterized class or implements a parameterized interface, the compiler may need to create a synthetic method, which is called a bridge method, as part of the type erasure process. You normally don't need to worry about bridge methods, but you might be puzzled if one appears in a stack trace.

After type erasure, the Node and MyNode classes become:

```java
public class Node {

    public Object data;

    public Node(Object data) { this.data = data; }

    public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}
```

```java
public class MyNode extends Node {

    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

After type erasure, the method signatures do not match; the Node.setData(T) method becomes Node.setData(Object). As a result, the MyNode.setData(Integer) method does not override the Node.setData(Object) method.

To solve this problem and preserve the [polymorphism](../IandI/polymorphism.html) of generic types after type erasure, the Java compiler generates a bridge method to ensure that subtyping works as expected.

For the MyNode class, the compiler generates the following bridge method for setData:

```java
class MyNode extends Node {

    **// Bridge method generated by the compiler
    //
    public void setData(Object data) {
        setData((Integer) data);
    }**

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }

    // ...
}
```

The bridge method `MyNode.setData(object)` delegates to the original `MyNode.setData(Integer)` method. As a result, the `n.setData("Hello");` statement calls the method `MyNode.setData(Object)`, and a `ClassCastException` is thrown because `"Hello"` can't be cast to `Integer`.


<a name="sec_7_20"></a>
## 7.20. [Non-Reifiable Types](#sec_7_20)
******
https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html 

The section [Type Erasure](erasure.html) discusses the process where the compiler removes information related to type parameters and type arguments. Type erasure has consequences related to variable arguments (also known as _varargs_ ) methods whose varargs formal parameter has a non-reifiable type. See the section [Arbitrary Number of Arguments](../javaOO/arguments.html#varargs) in [Passing Information to a Method or a Constructor](../javaOO/arguments.html) for more information about varargs methods.

This page covers the following topics:

*   [Non-Reifiable Types](#non-reifiable-types)
*   [Heap Pollution](#heap_pollution)
*   [Potential Vulnerabilities of Varargs Methods with Non-Reifiable Formal Parameters](#vulnerabilities)
*   [Preventing Warnings from Varargs Methods with Non-Reifiable Formal Parameters](#suppressing)

Non-Reifiable Types
-------------------

A _reifiable_ type is a type whose type information is fully available at runtime. This includes primitives, non-generic types, raw types, and invocations of unbound wildcards.

_Non-reifiable types_ are types where information has been removed at compile-time by type erasure ‚Äî invocations of generic types that are not defined as unbounded wildcards. A non-reifiable type does not have all of its information available at runtime. Examples of non-reifiable types are List<String> and List<Number>; the JVM cannot tell the difference between these types at runtime. As shown in [Restrictions on Generics](restrictions.html), there are certain situations where non-reifiable types cannot be used: in an instanceof expression, for example, or as an element in an array.

Heap Pollution
--------------

_Heap pollution_ occurs when a variable of a parameterized type refers to an object that is not of that parameterized type. This situation occurs if the program performed some operation that gives rise to an unchecked warning at compile-time. An _unchecked warning_ is generated if, either at compile-time (within the limits of the compile-time type checking rules) or at runtime, the correctness of an operation involving a parameterized type (for example, a cast or method call) cannot be verified. For example, heap pollution occurs when mixing raw types and parameterized types, or when performing unchecked casts.

In normal situations, when all code is compiled at the same time, the compiler issues an unchecked warning to draw your attention to potential heap pollution. If you compile sections of your code separately, it is difficult to detect the potential risk of heap pollution. If you ensure that your code compiles without warnings, then no heap pollution can occur.

Potential Vulnerabilities of Varargs Methods with Non-Reifiable Formal Parameters
---------------------------------------------------------------------------------

Generic methods that include vararg input parameters can cause heap pollution.

Consider the following ArrayBuilder class:

```java
public class ArrayBuilder {

  public static <T> void addToList (List<T> listArg, T... elements) {
    for (T x : elements) {
      listArg.add(x);
    }
  }

  public static void faultyMethod(List<String>... l) {
    Object[] objectArray = l;     // Valid
    objectArray[0] = Arrays.asList(42);
    String s = l[0].get(0);       // ClassCastException thrown here
  }

}
```

The following example, HeapPollutionExample uses the ArrayBuiler class:

```java
public class HeapPollutionExample {

  public static void main(String[] args) {

    List<String> stringListA = new ArrayList<String>();
    List<String> stringListB = new ArrayList<String>();

    ArrayBuilder.addToList(stringListA, "Seven", "Eight", "Nine");
    ArrayBuilder.addToList(stringListB, "Ten", "Eleven", "Twelve");
    List<List<String>> listOfStringLists =
      new ArrayList<List<String>>();
    ArrayBuilder.addToList(listOfStringLists,
      stringListA, stringListB);

    ArrayBuilder.faultyMethod(Arrays.asList("Hello!"), Arrays.asList("World!"));
  }
}
```

When compiled, the following warning is produced by the definition of the ArrayBuilder.addToList method:

    warning: [varargs] Possible heap pollution from parameterized vararg type T

When the compiler encounters a varargs method, it translates the varargs formal parameter into an array. However, the Java programming language does not permit the creation of arrays of parameterized types. In the method `ArrayBuilder.addToList`, the compiler translates the varargs formal parameter `T... elements` to the formal parameter `T[] elements`, an array. However, because of type erasure, the compiler converts the varargs formal parameter to `Object[] elements`. Consequently, there is a possibility of heap pollution.

The following statement assigns the varargs formal parameter `l` to the `Object` array `objectArgs`:

    Object[] objectArray = l;

This statement can potentially introduce heap pollution. A value that does match the parameterized type of the varargs formal parameter `l` can be assigned to the variable `objectArray`, and thus can be assigned to `l`. However, the compiler does not generate an unchecked warning at this statement. The compiler has already generated a warning when it translated the varargs formal parameter `List<String>... l` to the formal parameter `List[] l`. This statement is valid; the variable `l` has the type `List[]`, which is a subtype of `Object[]`.

Consequently, the compiler does not issue a warning or error if you assign a `List` object of any type to any array component of the `objectArray` array as shown by this statement:

    objectArray[0] = Arrays.asList(42);

This statement assigns to the first array component of the `objectArray` array with a `List` object that contains one object of type `Integer`.

Suppose you invoke `ArrayBuilder.faultyMethod` with the following statement:

    ArrayBuilder.faultyMethod(Arrays.asList("Hello!"), Arrays.asList("World!"));

At runtime, the JVM throws a `ClassCastException` at the following statement:

    // ClassCastException thrown here
    String s = l[0].get(0);

The object stored in the first array component of the variable `l` has the type `List<Integer>`, but this statement is expecting an object of type `List<String>`.

Prevent Warnings from Varargs Methods with Non-Reifiable Formal Parameters
--------------------------------------------------------------------------

If you declare a varargs method that has parameters of a parameterized type, and you ensure that the body of the method does not throw a `ClassCastException` or other similar exception due to improper handling of the varargs formal parameter, you can prevent the warning that the compiler generates for these kinds of varargs methods by adding the following annotation to static and non-constructor method declarations:

    @SafeVarargs

The `@SafeVarargs` annotation is a documented part of the method's contract; this annotation asserts that the implementation of the method will not improperly handle the varargs formal parameter.

It is also possible, though less desirable, to suppress such warnings by adding the following to the method declaration:

    @SuppressWarnings({"unchecked", "varargs"})

However, this approach does not suppress warnings generated from the method's call site. If you are unfamiliar with the `@SuppressWarnings` syntax, see [Annotations](../../java/annotations/index.html).


<a name="sec_7_21"></a>
## 7.21. [Restrictions on Generics](#sec_7_21)
******
https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html 

To use Java generics effectively, you must consider the following restrictions:

*   [Cannot Instantiate Generic Types with Primitive Types](#instantiate)
*   [Cannot Create Instances of Type Parameters](#createObjects)
*   [Cannot Declare Static Fields Whose Types are Type Parameters](#createStatic)
*   [Cannot Use Casts or instanceof With Parameterized Types](#cannotCast)
*   [Cannot Create Arrays of Parameterized Types](#createArrays)
*   [Cannot Create, Catch, or Throw Objects of Parameterized Types](#cannotCatch)
*   [Cannot Overload a Method Where the Formal Parameter Types of Each Overload Erase to the Same Raw Type](#cannotOverload)

Cannot Instantiate Generic Types with Primitive Types
-----------------------------------------------------

Consider the following parameterized type:

```java
class Pair<K, V> {

    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    // ...
}
```

When creating a Pair object, you cannot substitute a primitive type for the type parameter K or V:

    Pair<**int, char**> p = new Pair<>(8, 'a');  // compile-time error

You can substitute only non-primitive types for the type parameters K and V:

    Pair<**Integer, Character**> p = new Pair<>(8, 'a');

Note that the Java compiler autoboxes 8 to Integer.valueOf(8) and 'a' to Character('a'):

    Pair<Integer, Character> p = new Pair<>(Integer.valueOf(8), new Character('a'));

For more information on autoboxing, see [Autoboxing and Unboxing](../data/autoboxing.html) in the [Numbers and Strings](../data/index.html) lesson.

Cannot Create Instances of Type Parameters
------------------------------------------

You cannot create an instance of a type parameter. For example, the following code causes a compile-time error:

    public static <E> void append(List<E> list) {
        E elem = new E();  // compile-time error
        list.add(elem);
    }

As a workaround, you can create an object of a type parameter through reflection:

    public static <E> void append(List<E> list, Class<E> cls) throws Exception {
        E elem = cls.newInstance();   // OK
        list.add(elem);
    }

You can invoke the append method as follows:

    List<String> ls = new ArrayList<>();
    append(ls, String.class);

Cannot Declare Static Fields Whose Types are Type Parameters
------------------------------------------------------------

A class's static field is a class-level variable shared by all non-static objects of the class. Hence, static fields of type parameters are not allowed. Consider the following class:

    public class MobileDevice<T> {
        private static T os;

        // ...
    }

If static fields of type parameters were allowed, then the following code would be confused:

    MobileDevice<Smartphone> phone = new MobileDevice<>();
    MobileDevice<Pager> pager = new MobileDevice<>();
    MobileDevice<TabletPC> pc = new MobileDevice<>();

Because the static field os is shared by phone, pager, and pc, what is the actual type of os? It cannot be Smartphone, Pager, and TabletPC at the same time. You cannot, therefore, create static fields of type parameters.

Cannot Use Casts or instanceof with Parameterized Types
-------------------------------------------------------

Because the Java compiler erases all type parameters in generic code, you cannot verify which parameterized type for a generic type is being used at runtime:

    public static <E> void rtti(List<E> list) {
        if (list instanceof ArrayList<Integer>) {  // compile-time error
            // ...
        }
    }

The set of parameterized types passed to the rtti method is:

    S = { ArrayList<Integer>, ArrayList<String> LinkedList<Character>, ... }

The runtime does not keep track of type parameters, so it cannot tell the difference between an ArrayList<Integer> and an ArrayList<String>. The most you can do is to use an unbounded wildcard to verify that the list is an ArrayList:

    public static void rtti(List<?> list) {
        if (list instanceof ArrayList<?>) {  // OK; instanceof requires a reifiable type
            // ...
        }
    }

Typically, you cannot cast to a parameterized type unless it is parameterized by unbounded wildcards. For example:

    List<Integer> li = new ArrayList<>();
    List<Number> ln = (List<Number>) li;  // compile-time error

However, in some cases the compiler knows that a type parameter is always valid and allows the cast. For example:

    List<String> l1 = ...;
    ArrayList<String> l2 = (ArrayList<String>)l1;  // OK

Cannot Create Arrays of Parameterized Types
-------------------------------------------

You cannot create arrays of parameterized types. For example, the following code does not compile:

    List<Integer>[] arrayOfLists = new List<Integer>[2];  // compile-time error

The following code illustrates what happens when different types are inserted into an array:

    Object[] strings = new String[2];
    strings[0] = "hi";   // OK
    strings[1] = 100;    // An ArrayStoreException is thrown.

If you try the same thing with a generic list, there would be a problem:

    Object[] stringLists = new List<String>[2];  // compiler error, but pretend it's allowed
    stringLists[0] = new ArrayList<String>();   // OK
    stringLists[1] = new ArrayList<Integer>();  // An ArrayStoreException should be thrown,
                                            // but the runtime can't detect it.

If arrays of parameterized lists were allowed, the previous code would fail to throw the desired ArrayStoreException.

Cannot Create, Catch, or Throw Objects of Parameterized Types
-------------------------------------------------------------

A generic class cannot extend the Throwable class directly or indirectly. For example, the following classes will not compile:

```java
// Extends Throwable indirectly
class MathException<T> extends Exception { /* ... */ }    // compile-time error

// Extends Throwable directly
class QueueFullException<T> extends Throwable { /* ... */ // compile-time error
```

A method cannot catch an instance of a type parameter:

```java
public static <T extends Exception, J> void execute(List<J> jobs) {
    try {
        for (J job : jobs)
            // ...
    } catch (T e) {   // compile-time error
        // ...
    }
}
```

You can, however, use a type parameter in a throws clause:

```java
class Parser<T extends Exception> {
    public void parse(File file) throws T {     // OK
        // ...
    }
}
```

Cannot Overload a Method Where the Formal Parameter Types of Each Overload Erase to the Same Raw Type
-----------------------------------------------------------------------------------------------------

A class cannot have two overloaded methods that will have the same signature after type erasure.

    public class Example {
        public void print(Set<String> strSet) { }
        public void print(Set<Integer> intSet) { }
    }

The overloads would all share the same classfile representation and will generate a compile-time error.


<a name="sec_7_22"></a>
## 7.22. [Questions and Exercises: Generics](#sec_7_22)
******
https://docs.oracle.com/javase/tutorial/java/generics/QandE/generics-questions.html 

1.  Write a generic method to count the number of elements in a collection that have a specific property (for example, odd integers, prime numbers, palindromes).  
      
    
2.  Will the following class compile? If not, why?
    
    public final class Algorithm {
        public static <T> T max(T x, T y) {
            return x > y ? x : y;
        }
    }
    
3.  Write a generic method to exchange the positions of two different elements in an array.  
      
    
4.  If the compiler erases all type parameters at compile time, why should you use generics?  
      
    
5.  What is the following class converted to after type erasure?
    
    public class Pair<K, V> {
    
        public Pair(K key, V value) {
            this.key = key;
            this.value = value;
        }
    
        public K getKey() { return key; }
        public V getValue() { return value; }
    
        public void setKey(K key)     { this.key = key; }
        public void setValue(V value) { this.value = value; }
    
        private K key;
        private V value;
    }
    
6.  What is the following method converted to after type erasure?
    
    public static <T extends Comparable<T>>
        int findFirstGreaterThan(T[] at, T elem) {
        // ...
    }
    
7.  Will the following method compile? If not, why?
    
    public static void print(List<? extends Number> list) {
        for (Number n : list)
            System.out.print(n + " ");
        System.out.println();
    }
    
8.  Write a generic method to find the maximal element in the range [begin, end) of a list.  
      
    
9.  Will the following class compile? If not, why?
    
    public class Singleton<T> {
    
        public static T getInstance() {
            if (instance == null)
                instance = new Singleton<T>();
    
            return instance;
        }
    
        private static T instance = null;
    }
    
10.  Given the following classes:
    
    ```java
    class Shape { /* ... */ }
        class Circle extends Shape { /* ... */ }
        class Rectangle extends Shape { /* ... */ }
        
        class Node<T> { /* ... */ }
        
        Will the following code compile? If not, why?
        
        Node<Circle> nc = new Node<>();
        Node<Shape>  ns = nc;
    ```
    
11.  Consider this class:
    
    ```java
    class Node<T> implements Comparable<T> {
            public int compareTo(T obj) { /* ... */ }
            // ...
        }
        
        Will the following code compile? If not, why?
        
        Node<String> node = new Node<>();
        Comparable<String> comp = node;
    ```
    
12.  How do you invoke the following method to find the first integer in a list that is relatively prime to a list of specified integers?
    
    public static <T>
        int findFirst(List<T> list, int begin, int end, UnaryPredicate<T> p)
    
    Note that two integers _a_ and _b_ are relatively prime if gcd(_a, b_) = 1, where gcd is short for greatest common divisor.


Answer to Questions and Exercises: Generics
===========================================

1.  Write a generic method to count the number of elements in a collection that have a specific property (for example, odd integers, prime numbers, palindromes).  
      
    **Answer**:
    
    ```java
    public final class Algorithm {
            public static <T> int countIf(Collection<T> c, UnaryPredicate<T> p) {
        
                int count = 0;
                for (T elem : c)
                    if (p.test(elem))
                        ++count;
                return count;
            }
        }
        
        where the generic UnaryPredicate interface is defined as follows:
        
        public interface UnaryPredicate<T> {
            public boolean test(T obj);
        }
    ```
    
    For example, the following program counts the number of odd integers in an integer list:
    
    ```java
    import java.util.*;
        
        class OddPredicate implements UnaryPredicate<Integer> {
            public boolean test(Integer i) { return i % 2 != 0; }
        }
        
        public class Test {
            public static void main(String[] args) {
                Collection<Integer> ci = Arrays.asList(1, 2, 3, 4);
                int count = Algorithm.countIf(ci, new OddPredicate());
                System.out.println("Number of odd integers = " + count);
            }
        }
    ```
    
    The program prints:
    
    Number of odd integers = 2
    
2.  Will the following class compile? If not, why?
    
    public final class Algorithm {
        public static <T> T max(T x, T y) {
            return x > y ? x : y;
        }
    }
    
    **Answer**: No. The greater than (>) operator applies only to primitive numeric types.  
      
    
3.  Write a generic method to exchange the positions of two different elements in an array.  
      
    **Answer**:
    
    public final class Algorithm {
        public static <T> void swap(T[] a, int i, int j) {
            T temp = a[i];
            a[i] = a[j];
            a[j] = temp;
        }
    }
    
4.  If the compiler erases all type parameters at compile time, why should you use generics?  
      
    **Answer**: You should use generics because:
    
    *   The Java compiler enforces tighter type checks on generic code at compile time.
    *   Generics support programming types as parameters.
    *   Generics enable you to implement generic algorithms.
    
      
      
    
5.  What is the following class converted to after type erasure?
    
    public class Pair<K, V> {
    
        public Pair(K key, V value) {
            this.key = key;
            this.value = value;
        }
    
        public K getKey(); { return key; }
        public V getValue(); { return value; }
    
        public void setKey(K key)     { this.key = key; }
        public void setValue(V value) { this.value = value; }
    
        private K key;
        private V value;
    }
    
    **Answer**:
    
    public class Pair {
    
        public Pair(Object key, Object value) {
            this.key = key;
            this.value = value;
        }
    
        public Object getKey()   { return key; }
        public Object getValue() { return value; }
    
        public void setKey(Object key)     { this.key = key; }
        public void setValue(Object value) { this.value = value; }
    
        private Object key;
        private Object value;
    }
    
6.  What is the following method converted to after type erasure?
    
    public static <T extends Comparable<T>>
        int findFirstGreaterThan(T[] at, T elem) {
        // ...
    }
    
    **Answer**:
    
    public static int findFirstGreaterThan(Comparable[] at, Comparable elem) {
        // ...
        }
    
7.  Will the following method compile? If not, why?
    
    public static void print(List<? extends Number> list) {
        for (Number n : list)
            System.out.print(n + " ");
        System.out.println();
    }
    
    **Answer**: Yes.  
      
    
8.  Write a generic method to find the maximal element in the range [begin, end) of a list.  
      
    **Answer**:
    
    ```java
    import java.util.*;
        
        public final class Algorithm {
            public static <T extends Object & Comparable<? super T>>
                T max(List<? extends T> list, int begin, int end) {
        
                T maxElem = list.get(begin);
        
                for (++begin; begin < end; ++begin)
                    if (maxElem.compareTo(list.get(begin)) < 0)
                        maxElem = list.get(begin);
                return maxElem;
            }
        }
    ```
    
9.  Will the following class compile? If not, why?
    
    public class Singleton<T> {
    
        public static T getInstance() {
            if (instance == null)
                instance = new Singleton<T>();
    
            return instance;
        }
    
        private static T instance = null;
    }
    
    **Answer**: No. You cannot create a static field of the type parameter T.  
      
    
10.  Given the following classes:
    
    ```java
    class Shape { /* ... */ }
        class Circle extends Shape { /* ... */ }
        class Rectangle extends Shape { /* ... */ }
        
        class Node<T> { /* ... */ }
    ```
    
    Will the following code compile? If not, why?
    
    Node<Circle> nc = new Node<>();
    Node<Shape>  ns = nc;
    
    **Answer**: No. Because Node<Circle> is not a subtype of Node<Shape>.  
      
    
11.  Consider this class:
    
    ```java
    class Node<T> implements Comparable<T> {
            public int compareTo(T obj) { /* ... */ }
            // ...
        }
    ```
    
    Will the following code compile? If not, why?
    
    Node<String> node = new Node<>();
    Comparable<String> comp = node;
    
    **Answer**: Yes.

12.  How do you invoke the following method to find the first integer in a list that is relatively prime to a list of specified integers?
    
    public static <T>
        int findFirst(List<T> list, int begin, int end, UnaryPredicate<T> p)
    
    Note that two integers _a_ and _b_ are relatively prime if gcd(_a, b_) = 1, where gcd is short for greatest common divisor.  
      
    **Answer**:
    
    ```java
    import java.util.*;
        
        public final class Algorithm {
        
            public static <T>
                int findFirst(List<T> list, int begin, int end, UnaryPredicate<T> p) {
        
                for (; begin < end; ++begin)
                    if (p.test(list.get(begin)))
                        return begin;
                return -1;
            }
        
            // x > 0 and y > 0
            public static int gcd(int x, int y) {
                for (int r; (r = x % y) != 0; x = y, y = r) { }
                    return y;
            }
        }
    ```
    
    The generic UnaryPredicate interface is defined as follows:
    
    public interface UnaryPredicate<T> {
        public boolean test(T obj);
    }
    
    The following program tests the findFirst method:
    
    ```java
    import java.util.*;
        
        class RelativelyPrimePredicate implements UnaryPredicate<Integer> {
            public RelativelyPrimePredicate(Collection<Integer> c) {
                this.c = c;
            }
        
            public boolean test(Integer x) {
                for (Integer i : c)
                    if (Algorithm.gcd(x, i) != 1)
                        return false;
        
                return c.size() > 0;
            }
        
            private Collection<Integer> c;
        }
        
        public class Test {
            public static void main(String[] args) throws Exception {
        
                List<Integer> li = Arrays.asList(3, 4, 6, 8, 11, 15, 28, 32);
                Collection<Integer> c = Arrays.asList(7, 18, 19, 25);
                UnaryPredicate<Integer> p = new RelativelyPrimePredicate(c);
        
                int i = ALgorithm.findFirst(li, 0, li.size(), p);
        
                if (i != -1) {
                    System.out.print(li.get(i) + " is relatively prime to ");
                    for (Integer k : c)
                        System.out.print(k + " ");
                    System.out.println();
                }
            }
        }
    ```
    
    The program prints:
    
    11 is relatively prime to 7 18 19 25
    


<a name="sec_8"></a>
# üìú/PART [8. Packages](#sec_toc)
******
https://docs.oracle.com/javase/tutorial/java/package/index.html 

1. [Creating and Using Packages](#sec_8_1)
2. [Creating a Package](#sec_8_2)
3. [Naming a Package](#sec_8_3)
4. [Using Package Members](#sec_8_4)
5. [Managing Source and Class Files](#sec_8_5)
6. [Summary of Creating and Using Packages](#sec_8_6)
7. [Questions and Exercises](#sec_8_7)

This lesson explains how to bundle classes and interfaces into packages, how to use classes that are in packages, and how to arrange your file system so that the compiler can find your source files.

<a name="sec_8_1"></a>
## 8.1. [Creating and Using Packages](#sec_8_1)
******
https://docs.oracle.com/javase/tutorial/java/package/packages.html 

To make types easier to find and use, to avoid naming conflicts, and to control access, programmers bundle groups of related types into packages.

* * *

**Definition:**¬†A _package_ is a grouping of related types providing access protection and name space management. Note that _types_ refers to classes, interfaces, enumerations, and annotation types. Enumerations and annotation types are special kinds of classes and interfaces, respectively, so _types_ are often referred to in this lesson simply as _classes and interfaces_.

* * *

The types that are part of the Java platform are members of various packages that bundle classes by function: fundamental classes are in `java.lang`, classes for reading and writing (input and output) are in `java.io`, and so on. You can put your types in packages too.

Suppose you write a group of classes that represent graphic objects, such as circles, rectangles, lines, and points. You also write an interface, `Draggable`, that classes implement if they can be dragged with the mouse.

//_in the Draggable.java file_
public interface Draggable {
    ...
}

//_in the Graphic.java file_
public abstract class Graphic {
    ...
}

//_in the Circle.java file_
public class Circle extends Graphic
    implements Draggable {
    . . .
}

//_in the Rectangle.java file_
public class Rectangle extends Graphic
    implements Draggable {
    . . .
}

//_in the Point.java file_
public class Point extends Graphic
    implements Draggable {
    . . .
}

//_in the Line.java file_
public class Line extends Graphic
    implements Draggable {
    . . .
}

You should bundle these classes and the interface in a package for several reasons, including the following:  

*   You and other programmers can easily determine that these types are related.
*   You and other programmers know where to find types that can provide graphics-related functions.
*   The names of your types won't conflict with the type names in other packages because the package creates a new namespace.
*   You can allow types within the package to have unrestricted access to one another yet still restrict access for types outside the package.


<a name="sec_8_2"></a>
## 8.2. [Creating a Package](#sec_8_2)
******
https://docs.oracle.com/javase/tutorial/java/package/createpkgs.html 

To create a package, you choose a name for the package (naming conventions are discussed in the next section) and put a `package` statement with that name at the top of _every source file_ that contains the types (classes, interfaces, enumerations, and annotation types) that you want to include in the package.

The package statement (for example, `package graphics;`) must be the first line in the source file. There can be only one package statement in each source file, and it applies to all types in the file.

* * *

**Note:**¬†If you put multiple types in a single source file, only one can be `public`, and it must have the same name as the source file. For example, you can define `public class Circle` in the file `Circle.java`, define `public interface Draggable` in the file `Draggable.java`, define `public enum Day` in the file `Day.java`, and so forth.  
  
You can include non-public types in the same file as a public type (this is strongly discouraged, unless the non-public types are small and closely related to the public type), but only the public type will be accessible from outside of the package. All the top-level, non-public types will be _package private_.

* * *

If you put the graphics interface and classes listed in the preceding section in a package called `graphics`, you would need six source files, like this:

//_in the Draggable.java file_
package graphics;
public interface Draggable {
    . . .
}

//_in the Graphic.java file_
package graphics;
public abstract class Graphic {
    . . .
}

//_in the Circle.java file_
package graphics;
public class Circle extends Graphic
    implements Draggable {
    . . .
}

//_in the Rectangle.java file_
package graphics;
public class Rectangle extends Graphic
    implements Draggable {
    . . .
}

//_in the Point.java file_
package graphics;
public class Point extends Graphic
    implements Draggable {
    . . .
}

//_in the Line.java file_
package graphics;
public class Line extends Graphic
    implements Draggable {
    . . .
}

If you do not use a `package` statement, your type ends up in an unnamed package. Generally speaking, an unnamed package is only for small or temporary applications or when you are just beginning the development process. Otherwise, classes and interfaces belong in named packages.


<a name="sec_8_3"></a>
## 8.3. [Naming a Package](#sec_8_3)
******
https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html 

With programmers worldwide writing classes and interfaces using the Java programming language, it is likely that many programmers will use the same name for different types. In fact, the previous example does just that: It defines a `Rectangle` class when there is already a `Rectangle` class in the `java.awt` package. Still, the compiler allows both classes to have the same name if they are in different packages. The fully qualified name of each `Rectangle` class includes the package name. That is, the fully qualified name of the `Rectangle` class in the `graphics` package is `graphics.Rectangle`, and the fully qualified name of the `Rectangle` class in the `java.awt` package is `java.awt.Rectangle`.

This works well unless two independent programmers use the same name for their packages. What prevents this problem? Convention.

Naming Conventions
------------------

Package names are written in all lower case to avoid conflict with the names of classes or interfaces.

Companies use their reversed Internet domain name to begin their package names‚Äîfor example, `com.example.mypackage` for a package named `mypackage` created by a programmer at `example.com`.

Name collisions that occur within a single company need to be handled by convention within that company, perhaps by including the region or the project name after the company name (for example, `com.example.region.mypackage`).

Packages in the Java language itself begin with `java.` or `javax.`

In some cases, the internet domain name may not be a valid package name. This can occur if the domain name contains a hyphen or other special character, if the package name begins with a digit or other character that is illegal to use as the beginning of a Java name, or if the package name contains a reserved Java keyword, such as "int". In this event, the suggested convention is to add an underscore. For example:

Legalizing Package Names

| Domain Name | Package Name Prefix |
|-------------|---------------------|
| `hyphenated-name.example.org` | `org.example.hyphenated_name` |
| `example.int`                 | `int_.example`                |
| `123name.example.com`         | `com.example._123name`        |


<a name="sec_8_4"></a>
## 8.4. [Using Package Members](#sec_8_4)
******
https://docs.oracle.com/javase/tutorial/java/package/usepkgs.html 

The types that comprise a package are known as the _package members_.

To use a `public` package member from outside its package, you must do one of the following:

*   Refer to the member by its fully qualified name
*   Import the package member
*   Import the member's entire package

Each is appropriate for different situations, as explained in the sections that follow.

Referring to a Package Member by Its Qualified Name
---------------------------------------------------

So far, most of the examples in this tutorial have referred to types by their simple names, such as `Rectangle` and `StackOfInts`. You can use a package member's simple name if the code you are writing is in the same package as that member or if that member has been imported.

However, if you are trying to use a member from a different package and that package has not been imported, you must use the member's fully qualified name, which includes the package name. Here is the fully qualified name for the `Rectangle` class declared in the `graphics` package in the previous example.

    graphics.Rectangle

You could use this qualified name to create an instance of `graphics.Rectangle`:

    graphics.Rectangle myRect = new graphics.Rectangle();

Qualified names are all right for infrequent use. When a name is used repetitively, however, typing the name repeatedly becomes tedious and the code becomes difficult to read. As an alternative, you can _import_ the member or its package and then use its simple name.

Importing a Package Member
--------------------------

To import a specific member into the current file, put an `import` statement at the beginning of the file before any type definitions but after the `package` statement, if there is one. Here's how you would import the `Rectangle` class from the `graphics` package created in the previous section.

    import graphics.Rectangle;

Now you can refer to the `Rectangle` class by its simple name.

    Rectangle myRectangle = new Rectangle();

This approach works well if you use just a few members from the `graphics` package. But if you use many types from a package, you should import the entire package.

Importing an Entire Package
---------------------------

To import all the types contained in a particular package, use the `import` statement with the asterisk `(*)` wildcard character.

    import graphics.*;

Now you can refer to any class or interface in the `graphics` package by its simple name.

    Circle myCircle = new Circle();
    Rectangle myRectangle = new Rectangle();

The asterisk in the `import` statement can be used only to specify all the classes within a package, as shown here. It cannot be used to match a subset of the classes in a package. For example, the following does not match all the classes in the `graphics` package that begin with `A`.

    // _does not work_
    import graphics.A*;

Instead, it generates a compiler error. With the `import` statement, you generally import only a single package member or an entire package.

* * *

**Note:**¬†Another, less common form of `import` allows you to import the public nested classes of an enclosing class. For example, if the `graphics.Rectangle` class contained useful nested classes, such as `Rectangle.DoubleWide` and `Rectangle.Square`, you could import `Rectangle` and its nested classes by using the following _two_ statements.

    import graphics.Rectangle;
    import graphics.Rectangle.*;

Be aware that the second import statement will _not_ import `Rectangle`.  
  
Another less common form of `import`, the _static import statement_, will be discussed at the end of this section.

* * *

For convenience, the Java compiler automatically imports two entire packages for each source file: (1) the `java.lang` package and (2) the current package (the package for the current file).

Apparent Hierarchies of Packages
--------------------------------

At first, packages appear to be hierarchical, but they are not. For example, the Java API includes a `java.awt` package, a `java.awt.color` package, a `java.awt.font` package, and many others that begin with `java.awt`. However, the `java.awt.color` package, the `java.awt.font` package, and other `java.awt.xxxx` packages are _not included_ in the `java.awt` package. The prefix `java.awt` (the Java Abstract Window Toolkit) is used for a number of related packages to make the relationship evident, but not to show inclusion.

Importing `java.awt.*` imports all of the types in the `java.awt` package, but it _does not import_ `java.awt.color`, `java.awt.font`, or any other `java.awt.xxxx` packages. If you plan to use the classes and other types in `java.awt.color` as well as those in `java.awt`, you must import both packages with all their files:

    import java.awt.*;
    import java.awt.color.*;

Name Ambiguities
----------------

If a member in one package shares its name with a member in another package and both packages are imported, you must refer to each member by its qualified name. For example, the `graphics` package defined a class named `Rectangle`. The `java.awt` package also contains a `Rectangle` class. If both `graphics` and `java.awt` have been imported, the following is ambiguous.

    Rectangle rect;

In such a situation, you have to use the member's fully qualified name to indicate exactly which `Rectangle` class you want. For example,

    graphics.Rectangle rect;

The Static Import Statement
---------------------------

There are situations where you need frequent access to static final fields (constants) and static methods from one or two classes. Prefixing the name of these classes over and over can result in cluttered code. The _static import_ statement gives you a way to import the constants and static methods that you want to use so that you do not need to prefix the name of their class.

The `java.lang.Math` class defines the `PI` constant and many static methods, including methods for calculating sines, cosines, tangents, square roots, maxima, minima, exponents, and many more. For example,

    public static final double PI 
        = 3.141592653589793;
    public static double cos(double a)
    {
        ...
    }

Ordinarily, to use these objects from another class, you prefix the class name, as follows.

    double r = Math.cos(Math.PI * theta);

You can use the static import statement to import the static members of java.lang.Math so that you don't need to prefix the class name, `Math`. The static members of `Math` can be imported either individually:

    import **static** java.lang.Math.PI;

or as a group:

    import **static** java.lang.Math.*;

Once they have been imported, the static members can be used without qualification. For example, the previous code snippet would become:

    double r = cos(PI * theta);

Obviously, you can write your own classes that contain constants and static methods that you use frequently, and then use the static import statement. For example,

    import **static** mypackage.MyConstants.*;

* * *

**Note:**¬†Use static import very sparingly. Overusing static import can result in code that is difficult to read and maintain, because readers of the code won't know which class defines a particular static object. Used properly, static import makes code more readable by removing class name repetition.

* * *


<a name="sec_8_5"></a>
## 8.5. [Managing Source and Class Files](#sec_8_5)
******
https://docs.oracle.com/javase/tutorial/java/package/managingfiles.html 

Many implementations of the Java platform rely on hierarchical file systems to manage source and class files, although _The Java Language Specification_ does not require this. The strategy is as follows.

Put the source code for a class, interface, enumeration, or annotation type in a text file whose name is the simple name of the type and whose extension is `.java`. For example:

//in the Rectangle.java file 
package graphics;
public class Rectangle {
   ... 
}

Then, put the source file in a directory whose name reflects the name of the package to which the type belongs:

.....\graphics\Rectangle.java

The qualified name of the package member and the path name to the file are parallel, assuming the Microsoft Windows file name separator backslash (for UNIX, use the forward slash).

*   **class name** ‚Äì `graphics.Rectangle`
*   **pathname to file** ‚Äì `graphics\Rectangle.java`

As you should recall, by convention a company uses its reversed Internet domain name for its package names. The Example company, whose Internet domain name is `example.com`, would precede all its package names with `com.example`. Each component of the package name corresponds to a subdirectory. So, if the Example company had a `com.example.graphics` package that contained a `Rectangle.java` source file, it would be contained in a series of subdirectories like this:

....\com\example\graphics\Rectangle.java

When you compile a source file, the compiler creates a different output file for each type defined in it. The base name of the output file is the name of the type, and its extension is `.class`. For example, if the source file is like this

//in the Rectangle.java file
package com.example.graphics;
public class Rectangle {
      . . . 
}

class Helper{
      . . . 
}

then the compiled files will be located at:

<path to the parent directory of the output files>\com\example\graphics\Rectangle.class
<path to the parent directory of the output files>\com\example\graphics\Helper.class

Like the `.java` source files, the compiled `.class` files should be in a series of directories that reflect the package name. However, the path to the `.class` files does not have to be the same as the path to the `.java` source files. You can arrange your source and class directories separately, as:

<path_one>\sources\com\example\graphics\Rectangle.java

<path_two>\classes\com\example\graphics\Rectangle.class

By doing this, you can give the `classes` directory to other programmers without revealing your sources. You also need to manage source and class files in this manner so that the compiler and the Java Virtual Machine (JVM) can find all the types your program uses.

The full path to the `classes` directory, `<path_two>\classes`, is called the _class path_, and is set with the `CLASSPATH` system variable. Both the compiler and the JVM construct the path to your `.class` files by adding the package name to the class path. For example, if

<path_two>\classes

is your class path, and the package name is

com.example.graphics,

then the compiler and JVM look for `.class files` in

<path_two>\classes\com\example\graphics.

A class path may include several paths, separated by a semicolon (Windows) or colon (UNIX). By default, the compiler and the JVM search the current directory and the JAR file containing the Java platform classes so that these directories are automatically in your class path.

Setting the CLASSPATH System Variable
-------------------------------------

To display the current `CLASSPATH` variable, use these commands in Windows and UNIX (Bourne shell):

In Windows:   C:\> set CLASSPATH
In UNIX:      % echo $CLASSPATH

To delete the current contents of the `CLASSPATH` variable, use these commands:

In Windows:   C:\> set CLASSPATH=
In UNIX:      % unset CLASSPATH; export CLASSPATH

To set the `CLASSPATH` variable, use these commands (for example):

In Windows:   C:\> set CLASSPATH=C:\users\george\java\classes
In UNIX:      % CLASSPATH=/home/george/java/classes; export CLASSPATH


<a name="sec_8_6"></a>
## 8.6. [Summary of Creating and Using Packages](#sec_8_6)
******
https://docs.oracle.com/javase/tutorial/java/package/summary-package.html 

To create a package for a type, put a `package` statement as the first statement in the source file that contains the type (class, interface, enumeration, or annotation type).

To use a public type that's in a different package, you have three choices: (1) use the fully qualified name of the type, (2) import the type, or (3) import the entire package of which the type is a member.

The path names for a package's source and class files mirror the name of the package.

You might have to set your `CLASSPATH` so that the compiler and the JVM can find the `.class` files for your types.


<a name="sec_8_7"></a>
## 8.7. [Questions and Exercises: Creating and Using Packages](#sec_8_7)
******
https://docs.oracle.com/javase/tutorial/java/package/QandE/packages-questions.html 

Questions
---------

Assume you have written some classes. Belatedly, you decide they should be split into three packages, as listed in the following table. Furthermore, assume the classes are currently in the default package (they have no `package` statements).

Destination Packages

| Package Name | Class Name |
|--------------|------------|
| `mygame.server` | `Server`
| `mygame.shared` | `Utilities`
| `mygame.client` | `Client`

1.  Which line of code will you need to add to each source file to put each class in the right package?
2.  To adhere to the directory structure, you will need to create some subdirectories in the development directory and put source files in the correct subdirectories. What subdirectories must you create? Which subdirectory does each source file go in?
3.  Do you think you'll need to make any other changes to the source files to make them compile correctly? If so, what?

Exercises
---------

Download the source files as listed here.

*   [`Client`](https://docs.oracle.com/javase/tutorial/java/package/QandE/question/Client.java)
*   [`Server`](https://docs.oracle.com/javase/tutorial/java/package/QandE/question/Server.java)
*   [`Utilities`](https://docs.oracle.com/javase/tutorial/java/package/QandE/question/Utilities.java)

1.  Implement the changes you proposed in questions 1 through 3 using the source files you just downloaded.
2.  Compile the revised source files. (_Hint:_ If you're invoking the compiler from the command line (as opposed to using a builder), invoke the compiler from the directory that contains the `mygame` directory you just created.)

Answers to Questions and Exercises: Creating and Using Packages
===============================================================

Answers
-------

Question 1: Assume that you have written some classes. Belatedly, you decide that they should be split into three packages, as listed in the table below. Furthermore, assume that the classes are currently in the default package (they have no `package` statements).

| Package Name | Class Name |
|--------------|------------|
| `mygame.server`  | `Server`
| `mygame.shared`  | `Utilities`
| `mygame.client`  | `Client`

a. What line of code will you need to add to each source file to put each class in the right package?  

Answer 1a: The first line of each file must specify the package:

In `Client.java` add:

`package mygame.client;`

In `Server.java` add:

`package mygame.server;`:

In `Utilities.java` add:

`package mygame.shared;`

b. To adhere to the directory structure, you will need to create some subdirectories in your development directory, and put source files in the correct subdirectories. What subdirectories must you create? Which subdirectory does each source file go in?  

Answer 1b: Within the `mygame` directory, you need to create three subdirectories: `client`, `server`, and `shared`.

In `mygame/client/` place:

`Client.java`

In `mygame/server/` place:

`Server.java`

In `mygame/shared/` place:

`Utilities.java`

c. Do you think you'll need to make any other changes to the source files to make them compile correctly? If so, what?  

Answer 1c: Yes, you need to add import statements. `Client.java` and `Server.java` need to import the `Utilities` class, which they can do in one of two ways:

import mygame.shared.*;
       --or--
import mygame.shared.Utilities;

Also, `Server.java` needs to import the `Client` class:

import mygame.client.Client;

Exercises
---------

Exercise 1: Download three source files:

*   [`Client`](https://docs.oracle.com/javase/tutorial/java/package/QandE/question/Client.java)
*   [`Server`](https://docs.oracle.com/javase/tutorial/java/package/QandE/question/Server.java)
*   [`Utilities`](https://docs.oracle.com/javase/tutorial/java/package/QandE/question/Utilities.java)

a. Implement the changes you proposed in question 1, using the source files you just downloaded.  
b. Compile the revised source files. (_Hint:_ If you're invoking the compiler from the command line (as opposed to using a builder), invoke the compiler from the directory that contains the `mygame` directory you just created.) Answer 1: Download this zip file with the solution: [`mygame.zip`](https://docs.oracle.com/javase/tutorial/java/package/QandE/mygame.zip)  
You might need to change your proposed import code to reflect our implementation.

<a name="part_b"></a>

# üçÄ Trail: Essential Java Classes
https://docs.oracle.com/javase/tutorial/essential/index.html

This trail discusses classes from the Java platform that are essential to most programmers.

üìú 9.  [**Exceptions**](#sec_9) explains the exception mechanism and how it is used to handle errors and other exceptional conditions. This lesson describes what an exception is, how to throw and catch exceptions, what to do with an exception once it has been caught, and how to use the exception class hierarchy.

üìú 10.  [**Basic I/O**](#sec_10) covers the Java platform classes used for basic input and output. It focuses primarily on _I/O Streams_, a powerful concept that greatly simplifies I/O operations. The lesson also looks at Serialization, which lets a program write whole objects out to streams and read them back again. Then the lesson looks at some file system operations, including random access files. Finally, it touches briefly on the advanced features of the New I/O API.

üìú 11.  [**Concurrency**](#sec_11) explains how to write applications that perform multiple tasks simultaneously. The Java platform is designed from the ground up to support concurrent programming, with basic concurrency support in the Java programming language and the Java class libraries. Since version 5.0, the Java platform has also included high-level concurrency APIs. This lesson introduces the platform's basic concurrency support and summarizes some of the high-level APIs in the `java.util.concurrent` packages.

üìú 12.  [**The Platform Environment**](#sec_12) is defined by the underlying operating system, the Java virtual machine, the class libraries, and various configuration data supplied when the application is launched. This lesson describes some of the APIs an application uses to examine and configure its platform environment.

üìú 13.  [**Regular Expressions**](#sec_13) are a way to describe a set of strings based on common characteristics shared by each string in the set. They can be used to search, edit, or manipulate text and data. Regular expressions vary in complexity, but once you understand the basics of how they're constructed, you'll be able to decipher (or create) any regular expression. This lesson teaches the regular expression syntax supported by the `java.util.regex` API, and presents several working examples to illustrate how the various objects interact.

<a name="sec_9"></a>
# üìú/PART 9.  [**Exceptions**](#sec_9)
******
https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html 

The Java programming language uses _exceptions_ to handle errors and other exceptional events. This lesson describes when and how to use exceptions.

1. [What Is an Exception?](#sec_9_1)

    An exception is an event that occurs during the execution of a program that disrupts the normal flow of instructions.

2. [The Catch or Specify Requirement](#sec_9_2)

    This section covers how to catch and handle exceptions. The discussion includes the try, catch, and finally blocks, as well as chained exceptions and logging.

3. [How to Throw Exceptions](#sec_9_3)

    This section covers the throw statement and the Throwable class and its subclasses.

4. [The try-with-resources Statement](#sec_9_4)

    This section describes the `try`\-with-resources statement, which is a `try` statement that declares one or more resources. A resource is as an object that must be closed after the program is finished with it. The `try`\-with-resources statement ensures that each resource is closed at the end of the statement.

5. [Unchecked Exceptions ‚Äî The Controversy](#sec_9_5)

    This section explains the correct and incorrect use of the unchecked exceptions indicated by subclasses of `RuntimeException`.

6. [Advantages of Exceptions](#sec_9_6)

    The use of exceptions to manage errors has some advantages over traditional error-management techniques. You'll learn more in this section.

7. [Summary](#sec_9_7)

8. [Questions and Exercises](#sec_9_8)


<a name="sec_9_1"></a>
## 9.1. [What Is an Exception?](#sec_9_1)
******
https://docs.oracle.com/javase/tutorial/essential/exceptions/definition.html 

The term _exception_ is shorthand for the phrase "exceptional event."

* * *

**Definition:**¬†An _exception_ is an event, which occurs during the execution of a program, that disrupts the normal flow of the program's instructions.

* * *

When an error occurs within a method, the method creates an object and hands it off to the runtime system. The object, called an _exception object_, contains information about the error, including its type and the state of the program when the error occurred. Creating an exception object and handing it to the runtime system is called _throwing an exception_.

After a method throws an exception, the runtime system attempts to find something to handle it. The set of possible "somethings" to handle the exception is the ordered list of methods that had been called to get to the method where the error occurred. The list of methods is known as the _call stack_ (see the next figure).

![The call stack showing three method calls, where the first method called has the exception handler.](https://docs.oracle.com/javase/tutorial/figures/essential/exceptions-callstack.gif)

The call stack.

The runtime system searches the call stack for a method that contains a block of code that can handle the exception. This block of code is called an _exception handler_. The search begins with the method in which the error occurred and proceeds through the call stack in the reverse order in which the methods were called. When an appropriate handler is found, the runtime system passes the exception to the handler. An exception handler is considered appropriate if the type of the exception object thrown matches the type that can be handled by the handler.

The exception handler chosen is said to _catch the exception_. If the runtime system exhaustively searches all the methods on the call stack without finding an appropriate exception handler, as shown in the next figure, the runtime system (and, consequently, the program) terminates.

![The call stack showing three method calls, where the first method called has the exception handler.](https://docs.oracle.com/javase/tutorial/figures/essential/exceptions-errorOccurs.gif)

Searching the call stack for the exception handler.

Using exceptions to manage errors has some advantages over traditional error-management techniques. You can learn more in the [Advantages of Exceptions](advantages.html) section.


<a name="sec_9_2"></a>
## 9.2. [The Catch or Specify Requirement](#sec_9_2)
******
https://docs.oracle.com/javase/tutorial/essential/exceptions/catchOrDeclare.html 

Valid Java programming language code must honor the _Catch or Specify Requirement_. This means that code that might throw certain exceptions must be enclosed by either of the following:

*   A `try` statement that catches the exception. The `try` must provide a handler for the exception, as described in [Catching and Handling Exceptions](handling.html).
*   A method that specifies that it can throw the exception. The method must provide a `throws` clause that lists the exception, as described in [Specifying the Exceptions Thrown by a Method](declaring.html).

Code that fails to honor the Catch or Specify Requirement will not compile.

Not all exceptions are subject to the Catch or Specify Requirement. To understand why, we need to look at the three basic categories of exceptions, only one of which is subject to the Requirement.

The Three Kinds of Exceptions
-----------------------------

The first kind of exception is the _checked exception_. These are exceptional conditions that a well-written application should anticipate and recover from. For example, suppose an application prompts a user for an input file name, then opens the file by passing the name to the constructor for `java.io.FileReader`. Normally, the user provides the name of an existing, readable file, so the construction of the `FileReader` object succeeds, and the execution of the application proceeds normally. But sometimes the user supplies the name of a nonexistent file, and the constructor throws `java.io.FileNotFoundException`. A well-written program will catch this exception and notify the user of the mistake, possibly prompting for a corrected file name.

Checked exceptions _are subject_ to the Catch or Specify Requirement. All exceptions are checked exceptions, except for those indicated by `Error`, `RuntimeException`, and their subclasses.

The second kind of exception is the _error_. These are exceptional conditions that are external to the application, and that the application usually cannot anticipate or recover from. For example, suppose that an application successfully opens a file for input, but is unable to read the file because of a hardware or system malfunction. The unsuccessful read will throw `java.io.IOError`. An application might choose to catch this exception, in order to notify the user of the problem ‚Äî but it also might make sense for the program to print a stack trace and exit.

Errors _are not subject_ to the Catch or Specify Requirement. Errors are those exceptions indicated by `Error` and its subclasses.

The third kind of exception is the _runtime exception_. These are exceptional conditions that are internal to the application, and that the application usually cannot anticipate or recover from. These usually indicate programming bugs, such as logic errors or improper use of an API. For example, consider the application described previously that passes a file name to the constructor for `FileReader`. If a logic error causes a `null` to be passed to the constructor, the constructor will throw `NullPointerException`. The application can catch this exception, but it probably makes more sense to eliminate the bug that caused the exception to occur.

Runtime exceptions _are not subject_ to the Catch or Specify Requirement. Runtime exceptions are those indicated by `RuntimeException` and its subclasses.

Errors and runtime exceptions are collectively known as _unchecked exceptions_.

Bypassing Catch or Specify
--------------------------

Some programmers consider the Catch or Specify Requirement a serious flaw in the exception mechanism and bypass it by using unchecked exceptions in place of checked exceptions. In general, this is not recommended. The section [Unchecked Exceptions ‚Äî The Controversy](runtime.html) talks about when it is appropriate to use unchecked exceptions.


<a name="sec_9_3"></a>
## 9.3. [How to Throw Exceptions](#sec_9_3)
******
https://docs.oracle.com/javase/tutorial/essential/exceptions/throwing.html 

Before you can catch an exception, some code somewhere must throw one. Any code can throw an exception: your code, code from a package written by someone else such as the packages that come with the Java platform, or the Java runtime environment. Regardless of what throws the exception, it's always thrown with the `throw` statement.

As you have probably noticed, the Java platform provides numerous exception classes. All the classes are descendants of the [`Throwable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html) class, and all allow programs to differentiate among the various types of exceptions that can occur during the execution of a program.

You can also create your own exception classes to represent problems that can occur within the classes you write. In fact, if you are a package developer, you might have to create your own set of exception classes to allow users to differentiate an error that can occur in your package from errors that occur in the Java platform or other packages.

You can also create _chained_ exceptions. For more information, see the [Chained Exceptions](../../essential/exceptions/chained.html) section.

The throw Statement
-------------------

All methods use the `throw` statement to throw an exception. The `throw` statement requires a single argument: a throwable object. Throwable objects are instances of any subclass of the `Throwable` class. Here's an example of a `throw` statement.

throw _someThrowableObject_;

Let's look at the `throw` statement in context. The following `pop` method is taken from a class that implements a common stack object. The method removes the top element from the stack and returns the object.

public Object pop() {
    Object obj;

    if (size == 0) {
        **throw new EmptyStackException();**
    }

    obj = objectAt(size - 1);
    setObjectAt(size - 1, null);
    size--;
    return obj;
}

The `pop` method checks to see whether any elements are on the stack. If the stack is empty (its size is equal to `0`), `pop` instantiates a new `EmptyStackException` object (a member of `java.util`) and throws it. The [Creating Exception Classes](../../essential/exceptions/creating.html) section in this chapter explains how to create your own exception classes. For now, all you need to remember is that you can throw only objects that inherit from the `java.lang.Throwable` class.

Note that the declaration of the `pop` method does not contain a `throws` clause. `EmptyStackException` is not a checked exception, so `pop` is not required to state that it might occur.

Throwable Class and Its Subclasses
----------------------------------

The objects that inherit from the `Throwable` class include direct descendants (objects that inherit directly from the `Throwable` class) and indirect descendants (objects that inherit from children or grandchildren of the `Throwable` class). The figure below illustrates the class hierarchy of the `Throwable` class and its most significant subclasses. As you can see, `Throwable` has two direct descendants: [`Error`](https://docs.oracle.com/javase/8/docs/api/java/lang/Error.html) and [`Exception`](https://docs.oracle.com/javase/8/docs/api/java/lang/Exception.html).

![The Throwable class and its most significant subclasses.](https://docs.oracle.com/javase/tutorial/figures/essential/exceptions-throwable.gif)

The Throwable class.

Error Class
-----------

When a dynamic linking failure or other hard failure in the Java virtual machine occurs, the virtual machine throws an `Error`. Simple programs typically do _not_ catch or throw `Error`s.

Exception Class
---------------

Most programs throw and catch objects that derive from the `Exception` class. An `Exception` indicates that a problem occurred, but it is not a serious system problem. Most programs you write will throw and catch `Exception`s as opposed to `Error`s.

The Java platform defines the many descendants of the `Exception` class. These descendants indicate various types of exceptions that can occur. For example, `IllegalAccessException` signals that a particular method could not be found, and `NegativeArraySizeException` indicates that a program attempted to create an array with a negative size.

One `Exception` subclass, `RuntimeException`, is reserved for exceptions that indicate incorrect use of an API. An example of a runtime exception is `NullPointerException`, which occurs when a method tries to access a member of an object through a `null` reference. The section [Unchecked Exceptions ‚Äî The Controversy](runtime.html) discusses why most applications shouldn't throw runtime exceptions or subclass `RuntimeException`.


<a name="sec_9_4"></a>
## 9.4. [The try-with-resources Statement](#sec_9_4)
******
https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html 

The `try`-with-resources statement is a `try` statement that declares one or more resources. A _resource_ is an object that must be closed after the program is finished with it. The `try`-with-resources statement ensures that each resource is closed at the end of the statement. Any object that implements `java.lang.AutoCloseable`, which includes all objects which implement `java.io.Closeable`, can be used as a resource.

The following example reads the first line from a file. It uses an instance of `FileReader` and `BufferedReader` to read data from the file. `FileReader` and `BufferedReader` are resources that must be closed after the program is finished with it:

    static String readFirstLineFromFile(String path) throws IOException {
        **try (FileReader fr = new FileReader(path);
             BufferedReader br = new BufferedReader(fr))** {
            return br.readLine();
        }
    }   

In this example, the resources declared in the `try`-with-resources statement are a `FileReader` and a `BufferedReader`. The declaration statements of these resources appear within parentheses immediately after the `try` keyword. The classes `FileReader` and `BufferedReader`, in Java SE 7 and later, implement the interface `java.lang.AutoCloseable`. Because the `FileReader` and `BufferedReader` instances are declared in a `try`-with-resource statement, they will be closed regardless of whether the `try` statement completes normally or abruptly (as a result of the method `BufferedReader.readLine` throwing an `IOException`).

Prior to Java SE 7, you can use a `finally` block to ensure that a resource is closed regardless of whether the `try` statement completes normally or abruptly. The following example uses a `finally` block instead of a `try`-with-resources statement:

static String readFirstLineFromFileWithFinallyBlock(String path) throws IOException {
   
    FileReader fr = new FileReader(path);
    BufferedReader br = new BufferedReader(fr);
    try {
        return br.readLine();
    } finally {
        br.close();
        fr.close();
    }
}

However, this example might have a resource leak. A program has to do more than rely on the garbage collector (GC) to reclaim a resource's memory when it's finished with it. The program must also release the resoure back to the operating system, typically by calling the resource's `close` method. However, if a program fails to do this before the GC reclaims the resource, then the information needed to release the resource is lost. The resource, which is still considered by the operaing system to be in use, has leaked.

In this example, if the `readLine` method throws an exception, and the statement `br.close()` in the `finally` block throws an exception, then the `FileReader` has leaked. Therefore, use a `try`-with-resources statement instead of a `finally` block to close your program's resources.

If the methods `readLine` and `close` both throw exceptions, then the method `readFirstLineFromFileWithFinallyBlock` throws the exception thrown from the `finally` block; the exception thrown from the `try` block is suppressed. In contrast, in the example `readFirstLineFromFile`, if exceptions are thrown from both the `try` block and the `try`-with-resources statement, then the method `readFirstLineFromFile` throws the exception thrown from the `try` block; the exception thrown from the `try`-with-resources block is suppressed. In Java SE 7 and later, you can retrieve suppressed exceptions; see the section [Suppressed Exceptions](#suppressed-exceptions) for more information.

The following example retrieves the names of the files packaged in the zip file `zipFileName` and creates a text file that contains the names of these files:

public static void writeToFileZipFileContents(String zipFileName,
                                           String outputFileName)
                                           throws java.io.IOException {

    java.nio.charset.Charset charset =
         java.nio.charset.StandardCharsets.US_ASCII;
    java.nio.file.Path outputFilePath =
         java.nio.file.Paths.get(outputFileName);

    // Open zip file and create output file with 
    // try-with-resources statement

    **try (
        java.util.zip.ZipFile zf =
             new java.util.zip.ZipFile(zipFileName);
        java.io.BufferedWriter writer = 
            java.nio.file.Files.newBufferedWriter(outputFilePath, charset)
    )** {
        // Enumerate each entry
        for (java.util.Enumeration entries =
                                zf.entries(); entries.hasMoreElements();) {
            // Get the entry name and write it to the output file
            String newLine = System.getProperty("line.separator");
            String zipEntryName =
                 ((java.util.zip.ZipEntry)entries.nextElement()).getName() +
                 newLine;
            writer.write(zipEntryName, 0, zipEntryName.length());
        }
    }
}

In this example, the `try`-with-resources statement contains two declarations that are separated by a semicolon: `ZipFile` and `BufferedWriter`. When the block of code that directly follows it terminates, either normally or because of an exception, the `close` methods of the `BufferedWriter` and `ZipFile` objects are automatically called in this order. Note that the `close` methods of resources are called in the _opposite_ order of their creation.

The following example uses a `try`-with-resources statement to automatically close a `java.sql.Statement` object:

public static void viewTable(Connection con) throws SQLException {

    String query = "select COF_NAME, SUP_ID, PRICE, SALES, TOTAL from COFFEES";

    **try (Statement stmt = con.createStatement())** {
        ResultSet rs = stmt.executeQuery(query);

        while (rs.next()) {
            String coffeeName = rs.getString("COF_NAME");
            int supplierID = rs.getInt("SUP_ID");
            float price = rs.getFloat("PRICE");
            int sales = rs.getInt("SALES");
            int total = rs.getInt("TOTAL");

            System.out.println(coffeeName + ", " + supplierID + ", " + 
                               price + ", " + sales + ", " + total);
        }
    } catch (SQLException e) {
        JDBCTutorialUtilities.printSQLException(e);
    }
}

The resource `java.sql.Statement` used in this example is part of the JDBC 4.1 and later API.

**Note**: A `try`-with-resources statement can have `catch` and `finally` blocks just like an ordinary `try` statement. In a `try`-with-resources statement, any `catch` or `finally` block is run after the resources declared have been closed.

Suppressed Exceptions
---------------------

An exception can be thrown from the block of code associated with the `try`-with-resources statement. In the example `writeToFileZipFileContents`, an exception can be thrown from the `try` block, and up to two exceptions can be thrown from the `try`-with-resources statement when it tries to close the `ZipFile` and `BufferedWriter` objects. If an exception is thrown from the `try` block and one or more exceptions are thrown from the `try`-with-resources statement, then those exceptions thrown from the `try`-with-resources statement are suppressed, and the exception thrown by the block is the one that is thrown by the `writeToFileZipFileContents` method. You can retrieve these suppressed exceptions by calling the `Throwable.getSuppressed` method from the exception thrown by the `try` block.

Classes That Implement the AutoCloseable or Closeable Interface
---------------------------------------------------------------

See the Javadoc of the [`AutoCloseable`](https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html) and [`Closeable`](https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html) interfaces for a list of classes that implement either of these interfaces. The `Closeable` interface extends the `AutoCloseable` interface. The `close` method of the `Closeable` interface throws exceptions of type `IOException` while the `close` method of the `AutoCloseable` interface throws exceptions of type `Exception`. Consequently, subclasses of the `AutoCloseable` interface can override this behavior of the `close` method to throw specialized exceptions, such as `IOException`, or no exception at all.


<a name="sec_9_5"></a>
## 9.5. [Unchecked Exceptions ‚Äî The Controversy](#sec_9_5)
******
https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html 

Because the Java programming language does not require methods to catch or to specify unchecked exceptions (`RuntimeException`, `Error`, and their subclasses), programmers may be tempted to write code that throws only unchecked exceptions or to make all their exception subclasses inherit from `RuntimeException`. Both of these shortcuts allow programmers to write code without bothering with compiler errors and without bothering to specify or to catch any exceptions. Although this may seem convenient to the programmer, it sidesteps the intent of the `catch` or `specify` requirement and can cause problems for others using your classes.

Why did the designers decide to force a method to specify all uncaught checked exceptions that can be thrown within its scope? Any `Exception` that can be thrown by a method is part of the method's public programming interface. Those who call a method must know about the exceptions that a method can throw so that they can decide what to do about them. These exceptions are as much a part of that method's programming interface as its parameters and `return` value.

The next question might be: "If it's so good to document a method's API, including the exceptions it can throw, why not specify runtime exceptions too?" Runtime exceptions represent problems that are the result of a programming problem, and as such, the API client code cannot reasonably be expected to recover from them or to handle them in any way. Such problems include arithmetic exceptions, such as dividing by zero; pointer exceptions, such as trying to access an object through a null reference; and indexing exceptions, such as attempting to access an array element through an index that is too large or too small.

Runtime exceptions can occur anywhere in a program, and in a typical one they can be very numerous. Having to add runtime exceptions in every method declaration would reduce a program's clarity. Thus, the compiler does not require that you catch or specify runtime exceptions (although you can).

One case where it is common practice to throw a `RuntimeException` is when the user calls a method incorrectly. For example, a method can check if one of its arguments is incorrectly `null`. If an argument is `null`, the method might throw a `NullPointerException`, which is an _unchecked_ exception.

Generally speaking, do not throw a `RuntimeException` or create a subclass of `RuntimeException` simply because you don't want to be bothered with specifying the exceptions your methods can throw.

Here's the bottom line guideline: If a client can reasonably be expected to recover from an exception, make it a checked exception. If a client cannot do anything to recover from the exception, make it an unchecked exception.


<a name="sec_9_6"></a>
## 9.6. [Advantages of Exceptions](#sec_9_6)
******
https://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html 

Now that you know what exceptions are and how to use them, it's time to learn the advantages of using exceptions in your programs.

Advantage 1: Separating Error-Handling Code from "Regular" Code
---------------------------------------------------------------

Exceptions provide the means to separate the details of what to do when something out of the ordinary happens from the main logic of a program. In traditional programming, error detection, reporting, and handling often lead to confusing spaghetti code. For example, consider the pseudocode method here that reads an entire file into memory.

readFile {
    **_open the file;
    determine its size;
    allocate that much memory;
    read the file into memory;
    close the file;_**
}

At first glance, this function seems simple enough, but it ignores all the following potential errors.

*   What happens if the file can't be opened?
*   What happens if the length of the file can't be determined?
*   What happens if enough memory can't be allocated?
*   What happens if the read fails?
*   What happens if the file can't be closed?

To handle such cases, the `readFile` function must have more code to do error detection, reporting, and handling. Here is an example of what the function might look like.

errorCodeType **readFile {**
    initialize errorCode = 0;
    
    **_open the file;_**
    if (_theFileIsOpen_) {
        **_determine the length of the file;_**
        if (_gotTheFileLength_) {
            **_allocate that much memory;_**
            if (_gotEnoughMemory_) {
                **_read the file into memory;_**
                if (_readFailed_) {
                    errorCode = -1;
                }
            } else {
                errorCode = -2;
            }
        } else {
            errorCode = -3;
        }
        **_close the file;_**
        if (_theFileDidntClose_ && _errorCode_ == 0) {
            errorCode = -4;
        } else {
            errorCode = errorCode and -4;
        }
    } else {
        errorCode = -5;
    }
    return errorCode;
}

There's so much error detection, reporting, and returning here that the original seven lines of code are lost in the clutter. Worse yet, the logical flow of the code has also been lost, thus making it difficult to tell whether the code is doing the right thing: Is the file really being closed if the function fails to allocate enough memory? It's even more difficult to ensure that the code continues to do the right thing when you modify the method three months after writing it. Many programmers solve this problem by simply ignoring it ‚Äî errors are reported when their programs crash.

Exceptions enable you to write the main flow of your code and to deal with the exceptional cases elsewhere. If the `readFile` function used exceptions instead of traditional error-management techniques, it would look more like the following.

**_readFile_** {
    try {
        **_open the file;
        determine its size;
        allocate that much memory;
        read the file into memory;
        close the file;_**
    } catch (_fileOpenFailed_) {
       **_doSomething;_**
    } catch (_sizeDeterminationFailed_) {
        **_doSomething;_**
    } catch (_memoryAllocationFailed_) {
        **_doSomething;_**
    } catch (_readFailed_) {
        **_doSomething;_**
    } catch (_fileCloseFailed_) {
        **_doSomething;_**
    }
}

Note that exceptions don't spare you the effort of doing the work of detecting, reporting, and handling errors, but they do help you organize the work more effectively.

Advantage 2: Propagating Errors Up the Call Stack
-------------------------------------------------

A second advantage of exceptions is the ability to propagate error reporting up the call stack of methods. Suppose that the `readFile` method is the fourth method in a series of nested method calls made by the main program: `method1` calls `method2`, which calls `method3`, which finally calls `readFile`.

method1 {
    **_call method2;_**
}

method2 {
    **_call method3;_**
}

method3 {
    **_call readFile;_**
}

Suppose also that `method1` is the only method interested in the errors that might occur within `readFile`. Traditional error-notification techniques force `method2` and `method3` to propagate the error codes returned by `readFile` up the call stack until the error codes finally reach `method1`‚Äîthe only method that is interested in them.

**method1** {
    errorCodeType error;
    error = **_call method2;_**
    if (error)
        **_doErrorProcessing;_**
    else
        **_proceed;_**
**}**

errorCodeType **method2 {**
    errorCodeType error;
    error = call **method3;**
    if (error)
        return error;
    else
        **_proceed;_**
**}**

errorCodeType **method3 {**
    errorCodeType error;
    error = **call readFile;**
    if (error)
        return error;
    else
        **_proceed;_**
**}**

Recall that the Java runtime environment searches backward through the call stack to find any methods that are interested in handling a particular exception. A method can duck any exceptions thrown within it, thereby allowing a method farther up the call stack to catch it. Hence, only the methods that care about errors have to worry about detecting errors.

**method1** {
    try {
        **_call method2;_**
    } catch (_exception_ e) {
        **_doErrorProcessing;_**
    }
}

**method2** throws _exception_ {
    **_call method3;_**
}

**method3** throws exception **{
    _call readFile;_
}**

However, as the pseudocode shows, ducking an exception requires some effort on the part of the middleman methods. Any checked exceptions that can be thrown within a method must be specified in its `throws` clause.

Advantage 3: Grouping and Differentiating Error Types
-----------------------------------------------------

Because all exceptions thrown within a program are objects, the grouping or categorizing of exceptions is a natural outcome of the class hierarchy. An example of a group of related exception classes in the Java platform are those defined in `java.io` ‚Äî `IOException` and its descendants. `IOException` is the most general and represents any type of error that can occur when performing I/O. Its descendants represent more specific errors. For example, `FileNotFoundException` means that a file could not be located on disk.

A method can write specific handlers that can handle a very specific exception. The `FileNotFoundException` class has no descendants, so the following handler can handle only one type of exception.

catch (FileNotFoundException e) {
    ...
}

A method can catch an exception based on its group or general type by specifying any of the exception's superclasses in the `catch` statement. For example, to catch all I/O exceptions, regardless of their specific type, an exception handler specifies an `IOException` argument.

catch (IOException e) {
    ...
}

This handler will be able to catch all I/O exceptions, including `FileNotFoundException`, `EOFException`, and so on. You can find details about what occurred by querying the argument passed to the exception handler. For example, use the following to print the stack trace.

catch (IOException e) {
    // Output goes to System.err.
    e.printStackTrace();
    // Send trace to stdout.
    e.printStackTrace(System.out);
}

You could even set up an exception handler that handles any `Exception` with the handler here.

// _A (too) general exception handler_
catch (Exception e) {
    ...
}

The `Exception` class is close to the top of the `Throwable` class hierarchy. Therefore, this handler will catch many other exceptions in addition to those that the handler is intended to catch. You may want to handle exceptions this way if all you want your program to do, for example, is print out an error message for the user and then exit.

In most situations, however, you want exception handlers to be as specific as possible. The reason is that the first thing a handler must do is determine what type of exception occurred before it can decide on the best recovery strategy. In effect, by not catching specific errors, the handler must accommodate any possibility. Exception handlers that are too general can make code more error-prone by catching and handling exceptions that weren't anticipated by the programmer and for which the handler was not intended.

As noted, you can create groups of exceptions and handle exceptions in a general fashion, or you can use the specific exception type to differentiate exceptions and handle exceptions in an exact fashion.


<a name="sec_9_7"></a>
## 9.7. [Summary](#sec_9_7)
******
https://docs.oracle.com/javase/tutorial/essential/exceptions/summary.html 

A program can use exceptions to indicate that an error occurred. To throw an exception, use the `throw` statement and provide it with an exception object ‚Äî a descendant of `Throwable` ‚Äî to provide information about the specific error that occurred. A method that throws an uncaught, checked exception must include a `throws` clause in its declaration.

A program can catch exceptions by using a combination of the `try`, `catch`, and `finally` blocks.

*   The `try` block identifies a block of code in which an exception can occur.
*   The `catch` block identifies a block of code, known as an exception handler, that can handle a particular type of exception.
*   The `finally` block identifies a block of code that is guaranteed to execute, and is the right place to close files, recover resources, and otherwise clean up after the code enclosed in the `try` block.

The `try` statement should contain at least one `catch` block or a `finally` block and may have multiple `catch` blocks.

The class of the exception object indicates the type of exception thrown. The exception object can contain further information about the error, including an error message. With exception chaining, an exception can point to the exception that caused it, which can in turn point to the exception that caused _it_, and so on.


<a name="sec_9_8"></a>
## 9.8. [Questions and Exercises: Exceptions](#sec_9_8)
******
https://docs.oracle.com/javase/tutorial/essential/exceptions/QandE/questions.html 
https://docs.oracle.com/javase/tutorial/essential/exceptions/QandE/answers.html 

Questions
---------

1.  Is the following code legal?
    
    try {
        
    } finally {
        
    }
    
2.  What exception types can be caught by the following handler?
    
    catch (Exception e) {
         
    }
    
    What is wrong with using this type of exception handler?
3.  Is there anything wrong with the following exception handler as written? Will this code compile?
    
    try {
    
    } catch (Exception e) {
        
    } catch (ArithmeticException a) {
        
    }
    
4.  Match each situation in the first list with an item in the second list.
    
    1.  `int[] A;   A[0] = 0;`
    2.  The JVM starts running your program, but the JVM can't find the Java platform classes. (The Java platform classes reside in `classes.zip` or `rt.jar`.)
    3.  A program is reading a stream and reaches the `end of stream` marker.
    4.  Before closing the stream and after reaching the `end of stream` marker, a program tries to read the stream again.
    
    1.  __ error
    2.  __ checked exception
    3.  __ compile error
    4.  __ no exception
    
    Exercises
    ---------
    
    1.  Add a `readList` method to [`` `ListOfNumbers.java` ``](../examples/ListOfNumbers.java). This method should read in `int` values from a file, print each value, and append them to the end of the vector. You should catch all appropriate errors. You will also need a text file containing numbers to read in.
    2.  Modify the following `cat` method so that it will compile.
        
        public static void cat(File file) {
            RandomAccessFile input = null;
            String line = null;
        
            try {
                input = new RandomAccessFile(file, "r");
                while ((line = input.readLine()) != null) {
                    System.out.println(line);
                }
                return;
            } finally {
                if (input != null) {
                    input.close();
                }
            }
        }

Answers to Questions and Exercises
==================================

Questions
---------

1.  **Question:** Is the following code legal?
    
    try {
        
    } finally {
       
    }
    
    **Answer:** Yes, it's legal ‚Äî and very useful A `try` statement does not have to have a `catch` block if it has a `finally` block. If the code in the `try` statement has multiple exit points and no associated `catch` clauses, the code in the `finally` block is executed no matter how the `try` block is exited. Thus it makes sense to provide a `finally` block whenever there is code that _must always_ be executed. This include resource recovery code, such as the code to close I/O streams.
2.  **Question:** What exception types can be caught by the following handler?
    
    catch (Exception e) {
         
    }
    
    What is wrong with using this type of exception handler?
    
    **Answer:** This handler catches exceptions of type `Exception`; therefore, it catches any exception. This can be a poor implementation because you are losing valuable information about the type of exception being thrown and making your code less efficient. As a result, your program may be forced to determine the type of exception before it can decide on the best recovery strategy.
    
3.  **Question:** Is there anything wrong with this exception handler as written? Will this code compile?
    
    try {
    
    } catch (Exception e) {
       
    } catch (ArithmeticException a) {
        
    }
    
    **Answer:** This first handler catches exceptions of type `Exception`; therefore, it catches any exception, including `ArithmeticException`. The second handler could never be reached. This code will not compile.
4.  **Question:** Match each situation in the first list with an item in the second list.
    
    1.  `int[] A;   A[0] = 0;`
    2.  The JVM starts running your program, but the JVM can't find the Java platform classes. (The Java platform classes reside in `classes.zip` or `rt.jar`.)
    3.  A program is reading a stream and reaches the `end of stream` marker.
    4.  Before closing the stream and after reaching the `end of stream` marker, a program tries to read the stream again.
    
    1.  __ error
    2.  __ checked exception
    3.  __ compile error
    4.  __ no exception
    
    Answer:
    
    1.  3 (compile error). The array is not initialized and will not compile.
    2.  1 (error).
    3.  4 (no exception). When you read a stream, you expect there to be an end of stream marker. You should use exceptions to catch unexpected behavior in your program.
    4.  2 (checked exception).

Exercises
---------

1.  **Exercise:** Add a `readList` method to [`` `ListOfNumbers.java` ``](../examples/ListOfNumbers.java). This method should read in `int` values from a file, print each value, and append them to the end of the vector. You should catch all appropriate errors. You will also need a text file containing numbers to read in.
    
    **Answer:** See ```[`` `ListOfNumbers2.java` ``](../examples/ListOfNumbers2.java).```
    
2.  **Exercise:** Modify the following `cat` method so that it will compile:
    
    public static void cat(File file) {
        RandomAccessFile input = null;
        String line = null;
    
        try {
            input = new RandomAccessFile(file, "r");
            while ((line = input.readLine()) != null) {
                System.out.println(line);
            }
            return;
        } finally {
            if (input != null) {
                input.close();
            }
        }
    }
    
    **Answer:** The code to catch exceptions is shown in bold:
    
    public static void cat(File file) {
        RandomAccessFile input = null;
        String line = null;
    
        try {
            input = new RandomAccessFile(file, "r");
            while ((line = input.readLine()) != null) {
                System.out.println(line);
            }
            return;
        **} catch(FileNotFoundException fnf) {
            System.err.format("File: %s not found%n", file);
        } catch(IOException e) {
            System.err.println(e.toString());**
        } finally {
            if (input != null) {
                **try {**
                    input.close();
                **} catch(IOException io) {
                }**
            }
        }
    }


<a name="sec_10"></a>
# üìú/PART 10.  [**Basic I/O**](#sec_10)
******
https://docs.oracle.com/javase/tutorial/essential/io/index.html 

This lesson covers the Java platform classes used for basic I/O. It first focuses on _I/O Streams_, a powerful concept that greatly simplifies I/O operations. The lesson also looks at serialization, which lets a program write whole objects out to streams and read them back again. Then the lesson looks at file I/O and file system operations, including random access files.

Most of the classes covered in the `I/O Streams` section are in the `java.io` package. Most of the classes covered in the `File I/O` section are in the `java.nio.file` package.

1. [I/O Streams](#sec_10_1)
---------------------------

1.  [Byte Streams](#sec_10_1_1) handle I/O of raw binary data.
2.  [Character Streams](#sec_10_1_2) handle I/O of character data, automatically handling translation to and from the local character set.
3.  [Buffered Streams](#sec_10_1_3) optimize input and output by reducing the number of calls to the native API.
4.  [Scanning and Formatting](#sec_10_1_4) allows a program to read and write formatted text.
5.  [I/O from the Command Line](#sec_10_1_5) describes the Standard Streams and the Console object.
6.  [Data Streams](#sec_10_1_6) handle binary I/O of primitive data type and `String` values.
7.  [Object Streams](#sec_10_1_7) handle binary I/O of objects.

2. [File I/O (Featuring NIO.2)](#sec_10_2)
-----------------------------------------

1.  [What is a Path?](#sec_10_2_1) examines the concept of a path on a file system.
2.  [The Path Class](#sec_10_2_2) introduces the cornerstone class of the `java.nio.file` package.
3.  [Path Operations](#sec_10_2_3) looks at methods in the `Path` class that deal with syntactic operations.
4.  [File Operations](#sec_10_2_4) introduces concepts common to many of the file I/O methods.
5.  [Checking a File or Directory](#sec_10_2_5) shows how to check a file's existence and its level of accessibility.
6.  [Deleting a File or Directory](#sec_10_2_6).
7.  [Copying a File or Directory](#sec_10_2_7).
8.  [Moving a File or Directory](#sec_10_2_8).
9.  [Managing Metadata](#sec_10_2_9) explains how to read and set file attributes.
10. [Reading, Writing and Creating Files](#sec_10_2_10) shows the stream and channel methods for reading and writing files.
11. [Random Access Files](#sec_10_2_11) shows how to read or write files in a non-sequentially manner.
12. [Creating and Reading Directories](#sec_10_2_12) covers API specific to directories, such as how to list a directory's contents.
13. [Links, Symbolic or Otherwise](#sec_10_2_13) covers issues specific to symbolic and hard links.
14. [Walking the File Tree](#sec_10_2_14) demonstrates how to recursively visit each file and directory in a file tree.
15. [Finding Files](#sec_10_2_15) shows how to search for files using pattern matching.
16. [Watching a Directory for Changes](#sec_10_2_16) shows how to use the watch service to detect files that are added, removed or updated in one or more directories.
17. [Other Useful Methods](#sec_10_2_17) covers important API that didn't fit elsewhere in the lesson.
18. [Legacy File I/O Code](#sec_10_2_18) shows how to leverage `Path` functionality if you have older code using the `java.io.File` class. A table mapping `java.io.File` API to `java.nio.file` API is provided.

3. [Summary](#sec_10_3)
-----------------------

A summary of the key points covered in this trail.

4. [Questions and Exercises](#sec_10_4)
-----------------------------------------------

Test what you've learned in this trail by trying these questions and exercises.

The I/O Classes in Action
-------------------------

Many of the examples in the next trail, [Custom Networking](../../networking/index.html) use the I/O streams described in this lesson to read from and write to network connections.

* * *

**Security consideration:**¬†Some I/O operations are subject to approval by the current security manager. The example programs contained in these lessons are standalone applications, which by default have no security manager. To work in an applet, most of these examples would have to be modified. See [What Applets Can and Cannot Do](../../deployment/applet/security.html) for information about the security restrictions placed on applets.

* * *

<a name="sec_10_1"></a>
## 10.1. [I/O Streams](#sec_10_1)
******
https://docs.oracle.com/javase/tutorial/essential/io/streams.html 

An _I/O Stream_ represents an input source or an output destination. A stream can represent many different kinds of sources and destinations, including disk files, devices, other programs, and memory arrays.

Streams support many different kinds of data, including simple bytes, primitive data types, localized characters, and objects. Some streams simply pass on data; others manipulate and transform the data in useful ways.

No matter how they work internally, all streams present the same simple model to programs that use them: A stream is a sequence of data. A program uses an _input stream_ to read data from a source, one item at a time:

![Reading information into a program.](https://docs.oracle.com/javase/tutorial/figures/essential/io-ins.gif)

Reading information into a program.

A program uses an _output stream_ to write data to a destination, one item at time:

![Writing information from a program.](https://docs.oracle.com/javase/tutorial/figures/essential/io-outs.gif)

Writing information from a program.

In this lesson, we'll see streams that can handle all kinds of data, from primitive values to advanced objects.

The data source and data destination pictured above can be anything that holds, generates, or consumes data. Obviously this includes disk files, but a source or destination can also be another program, a peripheral device, a network socket, or an array.

In the next section, we'll use the most basic kind of streams, byte streams, to demonstrate the common operations of Stream I/O. For sample input, we'll use the example file [`xanadu.txt`](https://docs.oracle.com/javase/tutorial/essential/io/examples/xanadu.txt), which contains the following verse:

In Xanadu did Kubla Khan
A stately pleasure-dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.

<a name="sec_10_1_1"></a>
## 10.1.1. [Byte Streams](#sec_10_1_1)
******
https://docs.oracle.com/javase/tutorial/essential/io/bytestreams.html

Programs use _byte streams_ to perform input and output of 8-bit bytes. All byte stream classes are descended from [`InputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html) and [`OutputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html).

There are many byte stream classes. To demonstrate how byte streams work, we'll focus on the file I/O byte streams, [`FileInputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/FileInputStream.html) and [`FileOutputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/FileOutputStream.html). Other kinds of byte streams are used in much the same way; they differ mainly in the way they are constructed.

Using Byte Streams
------------------

We'll explore `FileInputStream` and `FileOutputStream` by examining an example program named [`CopyBytes`](examples/CopyBytes.java), which uses byte streams to copy `xanadu.txt`, one byte at a time.

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyBytes {
    public static void main(String[] args) throws IOException {

        FileInputStream in = null;
        FileOutputStream out = null;

        try {
            in = new FileInputStream("xanadu.txt");
            out = new FileOutputStream("outagain.txt");
            int c;

            while ((c = in.read()) != -1) {
                out.write(c);
            }
        } finally {
            if (in != null) {
                in.close();
            }
            if (out != null) {
                out.close();
            }
        }
    }
}
```

`CopyBytes` spends most of its time in a simple loop that reads the input stream and writes the output stream, one byte at a time, as shown in the following figure.

![Simple byte stream input and output.](https://docs.oracle.com/javase/tutorial/figures/essential/byteStream.gif)

Simple byte stream input and output.

Always Close Streams
--------------------

Closing a stream when it's no longer needed is very important ‚Äî so important that `CopyBytes` uses a `finally` block to guarantee that both streams will be closed even if an error occurs. This practice helps avoid serious resource leaks.

One possible error is that `CopyBytes` was unable to open one or both files. When that happens, the stream variable corresponding to the file never changes from its initial `null` value. That's why `CopyBytes` makes sure that each stream variable contains an object reference before invoking `close`.

When Not to Use Byte Streams
----------------------------

`CopyBytes` seems like a normal program, but it actually represents a kind of low-level I/O that you should avoid. Since `xanadu.txt` contains character data, the best approach is to use [character streams](charstreams.html), as discussed in the next section. There are also streams for more complicated data types. Byte streams should only be used for the most primitive I/O.

So why talk about byte streams? Because all other stream types are built on byte streams.

<a name="sec_10_1_2"></a>
## 10.1.2. [Character Streams](#sec_10_1_2)
******
https://docs.oracle.com/javase/tutorial/essential/io/charstreams.html

Line-Oriented I/O
-----------------

Character I/O usually occurs in bigger units than single characters. One common unit is the line: a string of characters with a line terminator at the end. A line terminator can be a carriage-return/line-feed sequence (`"\r\n"`), a single carriage-return (`"\r"`), or a single line-feed (`"\n"`). Supporting all possible line terminators allows programs to read text files created on any of the widely used operating systems.

Let's modify the `CopyCharacters` example to use line-oriented I/O. To do this, we have to use two classes we haven't seen before, [`BufferedReader`](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html) and [`PrintWriter`](https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html). We'll explore these classes in greater depth in [Buffered I/O](buffers.html) and [Formatting](formatting.html). Right now, we're just interested in their support for line-oriented I/O.

The [`CopyLines`](examples/CopyLines.java) example invokes `BufferedReader.readLine` and `PrintWriter.println` to do input and output one line at a time.

```java
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.IOException;

public class CopyLines {
    public static void main(String[] args) throws IOException {

        BufferedReader inputStream = null;
        PrintWriter outputStream = null;

        try {
            inputStream = new BufferedReader(new FileReader("xanadu.txt"));
            outputStream = new PrintWriter(new FileWriter("characteroutput.txt"));

            String l;
            while ((l = inputStream.readLine()) != null) {
                outputStream.println(l);
            }
        } finally {
            if (inputStream != null) {
                inputStream.close();
            }
            if (outputStream != null) {
                outputStream.close();
            }
        }
    }
}
```

Invoking `readLine` returns a line of text with the line. `CopyLines` outputs each line using `println`, which appends the line terminator for the current operating system. This might not be the same line terminator that was used in the input file.

There are many ways to structure text input and output beyond characters and lines. For more information, see [Scanning and Formatting](scanfor.html).

<a name="sec_10_1_3"></a>
## 10.1.3. [Buffered Streams](#sec_10_1_3)
******
https://docs.oracle.com/javase/tutorial/essential/io/buffers.html

Most of the examples we've seen so far use _unbuffered_ I/O. This means each read or write request is handled directly by the underlying OS. This can make a program much less efficient, since each such request often triggers disk access, network activity, or some other operation that is relatively expensive.

To reduce this kind of overhead, the Java platform implements _buffered_ I/O streams. Buffered input streams read data from a memory area known as a _buffer_; the native input API is called only when the buffer is empty. Similarly, buffered output streams write data to a buffer, and the native output API is called only when the buffer is full.

A program can convert an unbuffered stream into a buffered stream using the wrapping idiom we've used several times now, where the unbuffered stream object is passed to the constructor for a buffered stream class. Here's how you might modify the constructor invocations in the `CopyCharacters` example to use buffered I/O:

inputStream = new BufferedReader(new FileReader("xanadu.txt"));
outputStream = new BufferedWriter(new FileWriter("characteroutput.txt"));

There are four buffered stream classes used to wrap unbuffered streams: [`BufferedInputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedInputStream.html) and [`BufferedOutputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedOutputStream.html) create buffered byte streams, while [`BufferedReader`](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html) and [`BufferedWriter`](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedWriter.html) create buffered character streams.

Flushing Buffered Streams
-------------------------

It often makes sense to write out a buffer at critical points, without waiting for it to fill. This is known as _flushing_ the buffer.

Some buffered output classes support _autoflush_, specified by an optional constructor argument. When autoflush is enabled, certain key events cause the buffer to be flushed. For example, an autoflush `PrintWriter` object flushes the buffer on every invocation of `println` or `format`. See [Formatting](formatting.html) for more on these methods.

To flush a stream manually, invoke its `flush` method. The `flush` method is valid on any output stream, but has no effect unless the stream is buffered.

<a name="sec_10_1_4"></a>
## 10.1.4. [Scanning and Formatting](#sec_10_1_4)
******
https://docs.oracle.com/javase/tutorial/essential/io/scanfor.html
https://docs.oracle.com/javase/tutorial/essential/io/scanning.html
https://docs.oracle.com/javase/tutorial/essential/io/formatting.html

Programming I/O often involves translating to and from the neatly formatted data humans like to work with. To assist you with these chores, the Java platform provides two APIs. The [scanner](scanning.html) API breaks input into individual tokens associated with bits of data. The [formatting](formatting.html) API assembles data into nicely formatted, human-readable form.

Scanning
========

Objects of type [`Scanner`](https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html) are useful for breaking down formatted input into tokens and translating individual tokens according to their data type.

Breaking Input into Tokens
--------------------------

By default, a scanner uses white space to separate tokens. (White space characters include blanks, tabs, and line terminators. For the full list, refer to the documentation for [`Character.isWhitespace`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isWhitespace-char-).) To see how scanning works, let's look at [`ScanXan`](examples/ScanXan.java), a program that reads the individual words in `xanadu.txt` and prints them out, one per line.

```java
import java.io.*;
import java.util.Scanner;

public class ScanXan {
    public static void main(String[] args) throws IOException {

        Scanner s = null;

        try {
            s = new Scanner(new BufferedReader(new FileReader("xanadu.txt")));

            while (s.hasNext()) {
                System.out.println(s.next());
            }
        } finally {
            if (s != null) {
                s.close();
            }
        }
    }
}
```

Notice that `ScanXan` invokes `Scanner`'s `close` method when it is done with the scanner object. Even though a scanner is not a stream, you need to close it to indicate that you're done with its underlying stream.

The output of `ScanXan` looks like this:

    In
    Xanadu
    did
    Kubla
    Khan
    A
    stately
    pleasure-dome
    ...

To use a different token separator, invoke `useDelimiter()`, specifying a regular expression. For example, suppose you wanted the token separator to be a comma, optionally followed by white space. You would invoke,

    s.useDelimiter(",\\s*");

Translating Individual Tokens
-----------------------------

The `ScanXan` example treats all input tokens as simple `String` values. `Scanner` also supports tokens for all of the Java language's primitive types (except for `char`), as well as `BigInteger` and `BigDecimal`. Also, numeric values can use thousands separators. Thus, in a `US` locale, `Scanner` correctly reads the string "32,767" as representing an integer value.

We have to mention the locale, because thousands separators and decimal symbols are locale specific. So, the following example would not work correctly in all locales if we didn't specify that the scanner should use the `US` locale. That's not something you usually have to worry about, because your input data usually comes from sources that use the same locale as you do. But this example is part of the Java Tutorial and gets distributed all over the world.

The [`ScanSum`](examples/ScanSum.java) example reads a list of `double` values and adds them up. Here's the source:

```java
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.IOException;
import java.util.Scanner;
import java.util.Locale;

public class ScanSum {
    public static void main(String[] args) throws IOException {

        Scanner s = null;
        double sum = 0;

        try {
            s = new Scanner(new BufferedReader(new FileReader("usnumbers.txt")));
            s.useLocale(Locale.US);

            while (s.hasNext()) {
                if (s.hasNextDouble()) {
                    sum += s.nextDouble();
                } else {
                    s.next();
                }   
            }
        } finally {
            s.close();
        }

        System.out.println(sum);
    }
}
```

And here's the sample input file, [`usnumbers.txt`](examples/usnumbers.txt)

    8.5
    32,767
    3.14159
    1,000,000.1

The output string is "1032778.74159". The period will be a different character in some locales, because `System.out` is a `PrintStream` object, and that class doesn't provide a way to override the default locale. We could override the locale for the whole program ‚Äî or we could just use formatting, as described in the next topic, [Formatting](formatting.html).

Formatting
==========

Stream objects that implement formatting are instances of either [`PrintWriter`](https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html), a character stream class, or [`PrintStream`](https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html), a byte stream class.

* * *

**Note:**¬†The only `PrintStream` objects you are likely to need are [`System.out`](https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#out) and [`System.err`](https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#err). (See [I/O from the Command Line](cl.html) for more on these objects.) When you need to create a formatted output stream, instantiate `PrintWriter`, not `PrintStream`.

* * *

Like all byte and character stream objects, instances of `PrintStream` and `PrintWriter` implement a standard set of `write` methods for simple byte and character output. In addition, both `PrintStream` and `PrintWriter` implement the same set of methods for converting internal data into formatted output. Two levels of formatting are provided:

*   `print` and `println` format individual values in a standard way.
*   `format` formats almost any number of values based on a format string, with many options for precise formatting.

The `print` and `println` Methods
---------------------------------

Invoking `print` or `println` outputs a single value after converting the value using the appropriate `toString` method. We can see this in the [`Root`](examples/Root.java) example:

```java
public class Root {
    public static void main(String[] args) {
        int i = 2;
        double r = Math.sqrt(i);
        
        System.out.print("The square root of ");
        System.out.print(i);
        System.out.print(" is ");
        System.out.print(r);
        System.out.println(".");

        i = 5;
        r = Math.sqrt(i);
        System.out.println("The square root of " + i + " is " + r + ".");
    }
}
```

Here is the output of `Root`:

The square root of 2 is 1.4142135623730951.
The square root of 5 is 2.23606797749979.

The `i` and `r` variables are formatted twice: the first time using code in an overload of `print`, the second time by conversion code automatically generated by the Java compiler, which also utilizes `toString`. You can format any value this way, but you don't have much control over the results.

The `format` Method
-------------------

The `format` method formats multiple arguments based on a _format string_. The format string consists of static text embedded with _format specifiers_; except for the format specifiers, the format string is output unchanged.

Format strings support many features. In this tutorial, we'll just cover some basics. For a complete description, see [`format string syntax`](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax) in the API specification.

The [`Root2`](examples/Root2.java) example formats two values with a single `format` invocation:

```java
public class Root2 {
    public static void main(String[] args) {
        int i = 2;
        double r = Math.sqrt(i);
        
        System.out.format("The square root of %d is %f.%n", i, r);
    }
}
```

Here is the output:

The square root of 2 is 1.414214.

Like the three used in this example, all format specifiers begin with a `%` and end with a 1- or 2-character _conversion_ that specifies the kind of formatted output being generated. The three conversions used here are:

*   `d` formats an integer value as a decimal value.
*   `f` formats a floating point value as a decimal value.
*   `n` outputs a platform-specific line terminator.

Here are some other conversions:

*   `x` formats an integer as a hexadecimal value.
*   `s` formats any value as a string.
*   `tB` formats an integer as a locale-specific month name.

There are many other conversions.

* * *

**Note:**¬†

Except for `%%` and `%n`, all format specifiers must match an argument. If they don't, an exception is thrown.

In the Java programming language, the `\n` escape always generates the linefeed character (`\u000A`). Don't use `\n` unless you specifically want a linefeed character. To get the correct line separator for the local platform, use `%n`.

* * *

In addition to the conversion, a format specifier can contain several additional elements that further customize the formatted output. Here's an example, [`Format`](examples/Format.java), that uses every possible kind of element.

```java
public class Format {
    public static void main(String[] args) {
        System.out.format("%f, %1$+020.10f %n", Math.PI);
    }
}
```

Here's the output:

3.141593, +00000003.1415926536

The additional elements are all optional. The following figure shows how the longer specifier breaks down into elements.

![Elements of a format specifier](https://docs.oracle.com/javase/tutorial/figures/essential/io-spec.gif)

Elements of a Format Specifier.

The elements must appear in the order shown. Working from the right, the optional elements are:

*   **Precision**. For floating point values, this is the mathematical precision of the formatted value. For `s` and other general conversions, this is the maximum width of the formatted value; the value is right-truncated if necessary.
*   **Width**. The minimum width of the formatted value; the value is padded if necessary. By default the value is left-padded with blanks.
*   **Flags** specify additional formatting options. In the `Format` example, the `+` flag specifies that the number should always be formatted with a sign, and the `0` flag specifies that `0` is the padding character. Other flags include `-` (pad on the right) and `,` (format number with locale-specific thousands separators). Note that some flags cannot be used with certain other flags or with certain conversions.
*   The **Argument Index** allows you to explicitly match a designated argument. You can also specify `<` to match the same argument as the previous specifier. Thus the example could have said: `System.out.format("%f, %<+020.10f %n", Math.PI);`

<a name="sec_10_1_5"></a>
## 10.1.5. [I/O from the Command Line](#sec_10_1_5)
******
https://docs.oracle.com/javase/tutorial/essential/io/cl.html

A program is often run from the command line and interacts with the user in the command line environment. The Java platform supports this kind of interaction in two ways: through the Standard Streams and through the Console.

Standard Streams
----------------

Standard Streams are a feature of many operating systems. By default, they read input from the keyboard and write output to the display. They also support I/O on files and between programs, but that feature is controlled by the command line interpreter, not the program.

The Java platform supports three Standard Streams: _Standard Input_, accessed through `System.in`; _Standard Output_, accessed through `System.out`; and _Standard Error_, accessed through `System.err`. These objects are defined automatically and do not need to be opened. Standard Output and Standard Error are both for output; having error output separately allows the user to divert regular output to a file and still be able to read error messages. For more information, refer to the documentation for your command line interpreter.

You might expect the Standard Streams to be character streams, but, for historical reasons, they are byte streams. `System.out` and `System.err` are defined as [`PrintStream`](https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html) objects. Although it is technically a byte stream, `PrintStream` utilizes an internal character stream object to emulate many of the features of character streams.

By contrast, `System.in` is a byte stream with no character stream features. To use Standard Input as a character stream, wrap `System.in` in `InputStreamReader`.

InputStreamReader cin = new InputStreamReader(System.in);

The Console
-----------

A more advanced alternative to the Standard Streams is the Console. This is a single, predefined object of type [`Console`](https://docs.oracle.com/javase/8/docs/api/java/io/Console.html) that has most of the features provided by the Standard Streams, and others besides. The Console is particularly useful for secure password entry. The Console object also provides input and output streams that are true character streams, through its `reader` and `writer` methods.

Before a program can use the Console, it must attempt to retrieve the Console object by invoking `System.console()`. If the Console object is available, this method returns it. If `System.console` returns `NULL`, then Console operations are not permitted, either because the OS doesn't support them or because the program was launched in a noninteractive environment.

The Console object supports secure password entry through its `readPassword` method. This method helps secure password entry in two ways. First, it suppresses echoing, so the password is not visible on the user's screen. Second, `readPassword` returns a character array, not a `String`, so the password can be overwritten, removing it from memory as soon as it is no longer needed.

The [`Password`](examples/Password.java) example is a prototype program for changing a user's password. It demonstrates several `Console` methods.

```java
import java.io.Console;
import java.util.Arrays;
import java.io.IOException;

public class Password {
    
    public static void main (String args[]) throws IOException {

        Console c = System.console();
        if (c == null) {
            System.err.println("No console.");
            System.exit(1);
        }

        String login = c.readLine("Enter your login: ");
        char [] oldPassword = c.readPassword("Enter your old password: ");

        if (verify(login, oldPassword)) {
            boolean noMatch;
            do {
                char [] newPassword1 = c.readPassword("Enter your new password: ");
                char [] newPassword2 = c.readPassword("Enter new password again: ");
                noMatch = ! Arrays.equals(newPassword1, newPassword2);
                if (noMatch) {
                    c.format("Passwords don't match. Try again.%n");
                } else {
                    change(login, newPassword1);
                    c.format("Password for %s changed.%n", login);
                }
                Arrays.fill(newPassword1, ' ');
                Arrays.fill(newPassword2, ' ');
            } while (noMatch);
        }

        Arrays.fill(oldPassword, ' ');
    }
    
    // Dummy change method.
    static boolean verify(String login, char[] password) {
        // This method always returns
        // true in this example.
        // Modify this method to verify
        // password according to your rules.
        return true;
    }

    // Dummy change method.
    static void change(String login, char[] password) {
        // Modify this method to change
        // password according to your rules.
    }
}
```

The `Password` class follows these steps:

1.  Attempt to retrieve the Console object. If the object is not available, abort.
2.  Invoke `Console.readLine` to prompt for and read the user's login name.
3.  Invoke `Console.readPassword` to prompt for and read the user's existing password.
4.  Invoke `verify` to confirm that the user is authorized to change the password. (In this example, `verify` is a dummy method that always returns `true`.)
5.  Repeat the following steps until the user enters the same password twice:
    1.  Invoke `Console.readPassword` twice to prompt for and read a new password.
    2.  If the user entered the same password both times, invoke `change` to change it. (Again, `change` is a dummy method.)
    3.  Overwrite both passwords with blanks.
6.  Overwrite the old password with blanks.

<a name="sec_10_1_6"></a>
## 10.1.6. [Data Streams](#sec_10_1_6)
******
https://docs.oracle.com/javase/tutorial/essential/io/datastreams.html

Data streams support binary I/O of primitive data type values (`boolean`, `char`, `byte`, `short`, `int`, `long`, `float`, and `double`) as well as String values. All data streams implement either the [`DataInput`](https://docs.oracle.com/javase/8/docs/api/java/io/DataInput.html) interface or the [`DataOutput`](https://docs.oracle.com/javase/8/docs/api/java/io/DataOutput.html) interface. This section focuses on the most widely-used implementations of these interfaces, [`DataInputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/DataInputStream.html) and [`DataOutputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/DataOutputStream.html).

The [`DataStreams`](examples/DataStreams.java) example demonstrates data streams by writing out a set of data records, and then reading them in again. Each record consists of three values related to an item on an invoice, as shown in the following table:

| Order in record | Data type | Data description | Output Method | Input Method | Sample Value |
|-----------------|-----------|------------------|---------------|--------------|--------------|
| 1 | `double` | Item price |`DataOutputStream.writeDouble` | `DataInputStream.readDouble` | `19.99`
| 2 | `int`    | Unit count |`DataOutputStream.writeInt` | `DataInputStream.readInt` | `12`
| 3 | `String` | Item description |`DataOutputStream.writeUTF` | `DataInputStream.readUTF` | `"Java T-Shirt"`

Let's examine crucial code in `DataStreams`. First, the program defines some constants containing the name of the data file and the data that will be written to it:

```java
static final String dataFile = "invoicedata";

static final double[] prices = { 19.99, 9.99, 15.99, 3.99, 4.99 };
static final int[] units = { 12, 8, 13, 29, 50 };
static final String[] descs = {
    "Java T-shirt",
    "Java Mug",
    "Duke Juggling Dolls",
    "Java Pin",
    "Java Key Chain"
};
```

Then `DataStreams` opens an output stream. Since a `DataOutputStream` can only be created as a wrapper for an existing byte stream object, `DataStreams` provides a buffered file output byte stream.

out = new DataOutputStream(new BufferedOutputStream(
              new FileOutputStream(dataFile)));

`DataStreams` writes out the records and closes the output stream.

```java
for (int i = 0; i < prices.length; i ++) {
    out.writeDouble(prices[i]);
    out.writeInt(units[i]);
    out.writeUTF(descs[i]);
}
```

The `writeUTF` method writes out `String` values in a modified form of UTF-8. This is a variable-width character encoding that only needs a single byte for common Western characters.

Now `DataStreams` reads the data back in again. First it must provide an input stream, and variables to hold the input data. Like `DataOutputStream`, `DataInputStream` must be constructed as a wrapper for a byte stream.

in = new DataInputStream(new
            BufferedInputStream(new FileInputStream(dataFile)));

double price;
int unit;
String desc;
double total = 0.0;

Now `DataStreams` can read each record in the stream, reporting on the data it encounters.

```java
try {
    while (true) {
        price = in.readDouble();
        unit = in.readInt();
        desc = in.readUTF();
        System.out.format("You ordered %d" + " units of %s at $%.2f%n",
            unit, desc, price);
        total += unit * price;
    }
} catch (EOFException e) {
}
```

Notice that `DataStreams` detects an end-of-file condition by catching [`EOFException`](https://docs.oracle.com/javase/8/docs/api/java/io/EOFException.html), instead of testing for an invalid return value. All implementations of `DataInput` methods use `EOFException` instead of return values.

Also notice that each specialized `write` in `DataStreams` is exactly matched by the corresponding specialized `read`. It is up to the programmer to make sure that output types and input types are matched in this way: The input stream consists of simple binary data, with nothing to indicate the type of individual values, or where they begin in the stream.

`DataStreams` uses one very bad programming technique: it uses floating point numbers to represent monetary values. In general, floating point is bad for precise values. It's particularly bad for decimal fractions, because common values (such as `0.1`) do not have a binary representation.

The correct type to use for currency values is [`java.math.BigDecimal`](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html). Unfortunately, `BigDecimal` is an object type, so it won't work with data streams. However, `BigDecimal` _will_ work with object streams, which are covered in the next section.

<a name="sec_10_1_7"></a>
## 10.1.7. [Object Streams](#sec_10_1_7)
******
https://docs.oracle.com/javase/tutorial/essential/io/objectstreams.html

Just as data streams support I/O of primitive data types, object streams support I/O of objects. Most, but not all, standard classes support serialization of their objects. Those that do implement the marker interface [`Serializable`](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html).

The object stream classes are [`ObjectInputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInputStream.html) and [`ObjectOutputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutputStream.html). These classes implement [`ObjectInput`](https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInput.html) and [`ObjectOutput`](https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutput.html), which are subinterfaces of `DataInput` and `DataOutput`. That means that all the primitive data I/O methods covered in [Data Streams](datastreams.html) are also implemented in object streams. So an object stream can contain a mixture of primitive and object values. The [`ObjectStreams`](examples/ObjectStreams.java) example illustrates this. `ObjectStreams` creates the same application as `DataStreams`, with a couple of changes. First, prices are now [`BigDecimal`](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html)objects, to better represent fractional values. Second, a [`Calendar`](https://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html) object is written to the data file, indicating an invoice date.

If `readObject()` doesn't return the object type expected, attempting to cast it to the correct type may throw a [`ClassNotFoundException`](https://docs.oracle.com/javase/8/docs/api/java/lang/ClassNotFoundException.html). In this simple example, that can't happen, so we don't try to catch the exception. Instead, we notify the compiler that we're aware of the issue by adding `ClassNotFoundException` to the `main` method's `throws` clause.

Output and Input of Complex Objects
-----------------------------------

The `writeObject` and `readObject` methods are simple to use, but they contain some very sophisticated object management logic. This isn't important for a class like Calendar, which just encapsulates primitive values. But many objects contain references to other objects. If `readObject` is to reconstitute an object from a stream, it has to be able to reconstitute all of the objects the original object referred to. These additional objects might have their own references, and so on. In this situation, `writeObject` traverses the entire web of object references and writes all objects in that web onto the stream. Thus a single invocation of `writeObject` can cause a large number of objects to be written to the stream.

This is demonstrated in the following figure, where `writeObject` is invoked to write a single object named **a**. This object contains references to objects **b** and **c**, while **b** contains references to **d** and **e**. Invoking `writeobject(a)` writes not just **a**, but all the objects necessary to reconstitute **a**, so the other four objects in this web are written also. When **a** is read back by `readObject`, the other four objects are read back as well, and all the original object references are preserved.

![I/O of multiple referred-to objects](https://docs.oracle.com/javase/tutorial/figures/essential/io-trav.gif)

I/O of multiple referred-to objects

You might wonder what happens if two objects on the same stream both contain references to a single object. Will they both refer to a single object when they're read back? The answer is "yes." A stream can only contain one copy of an object, though it can contain any number of references to it. Thus if you explicitly write an object to a stream twice, you're really writing only the reference twice. For example, if the following code writes an object `ob` twice to a stream:

Object ob = new Object();
out.writeObject(ob);
out.writeObject(ob);

Each `writeObject` has to be matched by a `readObject`, so the code that reads the stream back will look something like this:

Object ob1 = in.readObject();
Object ob2 = in.readObject();

This results in two variables, `ob1` and `ob2`, that are references to a single object.

However, if a single object is written to two different streams, it is effectively duplicated ‚Äî a single program reading both streams back will see two distinct objects.

<a name="sec_10_2"></a>
## 10.2. [File I/O (Featuring NIO.2)](#sec_10_2)
******
https://docs.oracle.com/javase/tutorial/essential/io/fileio.html 

* * *

**Note:** This tutorial reflects the file I/O mechanism introduced in the JDK 7 release. The Java SE 6 version of the File I/O tutorial was brief, but you can download the [Java SE Tutorial 2008-03-14](http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-tutorials-419421.html#tutorial-2008_03_14-oth-JPR) version of the tutorial which contains the earlier File I/O content.

* * *

The `java.nio.file` package and its related package, `java.nio.file.attribute`, provide comprehensive support for file I/O and for accessing the default file system. Though the API has many classes, you need to focus on only a few entry points. You will see that this API is very intuitive and easy to use.

The tutorial starts by asking [what is a path?](#sec_10_2_1) Then, the [Path class](#sec_10_2_2), the primary entry point for the package, is introduced. Methods in the `Path` class relating to [syntactic operations](#sec_10_2_3) are explained. The tutorial then moves on to the other primary class in the package, the `Files` class, which contains methods that deal with file operations. First, some concepts common to many [file operations](#sec_10_2_4) are introduced. The tutorial then covers methods for [checking](#sec_10_2_5), [deleting](#sec_10_2_6), [copying](#sec_10_2_7), and [moving](#sec_10_2_8) files.

The tutorial shows how [metadata](#sec_10_2_9) is managed, before moving on to [file I/O](#sec_10_2_10) and [directory I/O](#sec_10_2_11). [Random access files](#sec_10_2_12) are explained and issues specific to [symbolic and hard links](#sec_10_2_13) are examined.

Next, some of the very powerful, but more advanced, topics are covered. First, the capability to [recursively walk the file tree](#sec_10_2_14) is demonstrated, followed by information about how to [search for files using wild cards](#sec_10_2_15). Next, how to [watch a directory for changes](#sec_10_2_16) is explained and demonstrated. Then, [methods that didn't fit elsewhere](#sec_10_2_17) are given some attention.

Finally, if you have file I/O code written prior to the Java SE 7 release, there is a [map from the old API to the new API](#sec_10_2_18), as well as important information about the `File.toPath` method for developers who would like to [leverage the new API without rewriting existing code](#sec_10_2_18).

<a name="sec_10_2_1"></a>
## 10.2.1.  [What is a Path? (And Other File System Facts)](#sec_10_2_1)
******
https://docs.oracle.com/javase/tutorial/essential/io/path.html

A file system stores and organizes files on some form of media, generally one or more hard drives, in such a way that they can be easily retrieved. Most file systems in use today store the files in a tree (or _hierarchical_) structure. At the top of the tree is one (or more) root nodes. Under the root node, there are files and directories (_folders_ in Microsoft Windows). Each directory can contain files and subdirectories, which in turn can contain files and subdirectories, and so on, potentially to an almost limitless depth.

This section covers the following:

*   [What Is a Path?](#path)
*   [Relative or Absolute?](#relative)
*   [Symbolic Links](#symlink)

What Is a Path?
---------------

The following figure shows a sample directory tree containing a single root node. Microsoft Windows supports multiple root nodes. Each root node maps to a volume, such as `C:\` or `D:\`. The Solaris OS supports a single root node, which is denoted by the slash character, `/`.

![Sample directory structure](https://docs.oracle.com/javase/tutorial/figures/essential/io-dirStructure.gif)

Sample Directory Structure

A file is identified by its path through the file system, beginning from the root node. For example, the `statusReport` file in the previous figure is described by the following notation in the Solaris OS:

    /home/sally/statusReport

In Microsoft Windows, `statusReport` is described by the following notation:

    C:\home\sally\statusReport

The character used to separate the directory names (also called the _delimiter_) is specific to the file system: The Solaris OS uses the forward slash (`/`), and Microsoft Windows uses the backslash slash (`\`).

Relative or Absolute?
---------------------

A path is either _relative_ or _absolute_. An absolute path always contains the root element and the complete directory list required to locate the file. For example, `/home/sally/statusReport` is an absolute path. All of the information needed to locate the file is contained in the path string.

A relative path needs to be combined with another path in order to access a file. For example, `joe/foo` is a relative path. Without more information, a program cannot reliably locate the `joe/foo` directory in the file system.

Symbolic Links
--------------

File system objects are most typically directories or files. Everyone is familiar with these objects. But some file systems also support the notion of symbolic links. A symbolic link is also referred to as a _symlink_ or a _soft link_.

A _symbolic link_ is a special file that serves as a reference to another file. For the most part, symbolic links are transparent to applications, and operations on symbolic links are automatically redirected to the target of the link. (The file or directory being pointed to is called the _target_ of the link.) Exceptions are when a symbolic link is deleted, or renamed in which case the link itself is deleted, or renamed and not the target of the link.

In the following figure, `logFile` appears to be a regular file to the user, but it is actually a symbolic link to `dir/logs/HomeLogFile`. `HomeLogFile` is the target of the link.

![Sample symbolic link](https://docs.oracle.com/javase/tutorial/figures/essential/io-symlink.gif)

Example of a Symbolic Link.

A symbolic link is usually transparent to the user. Reading or writing to a symbolic link is the same as reading or writing to any other file or directory.

The phrase _resolving a link_ means to substitute the actual location in the file system for the symbolic link. In the example, resolving `logFile` yields `dir/logs/HomeLogFile`.

In real-world scenarios, most file systems make liberal use of symbolic links. Occasionally, a carelessly created symbolic link can cause a circular reference. A circular reference occurs when the target of a link points back to the original link. The circular reference might be indirect: directory `a` points to directory `b`, which points to directory `c`, which contains a subdirectory pointing back to directory `a`. Circular references can cause havoc when a program is recursively walking a directory structure. However, this scenario has been accounted for and will not cause your program to loop infinitely.

The next page discusses the heart of file I/O support in the Java programming language, the `Path` class.

<a name="sec_10_2_2"></a>
## 10.2.2.  [The Path Class](#sec_10_2_2)
******
https://docs.oracle.com/javase/tutorial/essential/io/pathClass.html

The [`Path`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html) class, introduced in the Java SE 7 release, is one of the primary entrypoints of the [`java.nio.file`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/package-summary.html) package. If your application uses file I/O, you will want to learn about the powerful features of this class.

* * *

**Version Note:**¬†If you have pre-JDK7 code that uses `java.io.File`, you can still take advantage of the `Path` class functionality by using the [`File.toPath`](https://docs.oracle.com/javase/8/docs/api/java/io/File.html#toPath--) method. See [Legacy File I/O Code](sec_10_2_18) for more information.

* * *

As its name implies, the `Path` class is a programmatic representation of a path in the file system. A `Path` object contains the file name and directory list used to construct the path, and is used to examine, locate, and manipulate files.

A `Path` instance reflects the underlying platform. In the Solaris OS, a `Path` uses the Solaris syntax (`/home/joe/foo`) and in Microsoft Windows, a `Path` uses the Windows syntax (`C:\home\joe\foo`). A `Path` is not system independent. You cannot compare a `Path` from a Solaris file system and expect it to match a `Path` from a Windows file system, even if the directory structure is identical and both instances locate the same relative file.

The file or directory corresponding to the `Path` might not exist. You can create a `Path` instance and manipulate it in various ways: you can append to it, extract pieces of it, compare it to another path. At the appropriate time, you can use the methods in the [`Files`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html) class to check the existence of the file corresponding to the `Path`, create the file, open it, delete it, change its permissions, and so on.

The next page examines the `Path` class in detail.

<a name="sec_10_2_3"></a>
## 10.2.3.  [Path Operations](#sec_10_2_3)
******
https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html

The [`Path`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html) class includes various methods that can be used to obtain information about the path, access elements of the path, convert the path to other forms, or extract portions of a path. There are also methods for matching the path string and methods for removing redundancies in a path. This lesson addresses these `Path` methods, sometimes called _syntactic_ operations, because they operate on the path itself and don't access the file system.

This section covers the following:

*   [Creating a Path](#create)
*   [Retrieving Information About a Path](#info)
*   [Removing Redundancies from a Path](#normal)
*   [Converting a Path](#convert)
*   [Joining Two Paths](#resolve)
*   [Creating a Path Between Two Paths](#relativize)
*   [Comparing Two Paths](#compare)

Creating a Path
---------------

A `Path` instance contains the information used to specify the location of a file or directory. At the time it is defined, a `Path` is provided with a series of one or more names. A root element or a file name might be included, but neither are required. A `Path` might consist of just a single directory or file name.

You can easily create a `Path` object by using one of the following `get` methods from the [`Paths`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Paths.html) (note the plural) helper class:

    Path p1 = Paths.get("/tmp/foo");
    Path p2 = Paths.get(args[0]);
    Path p3 = Paths.get(URI.create("file:///Users/joe/FileTest.java"));

The `Paths.get` method is shorthand for the following code:

    Path p4 = FileSystems.getDefault().getPath("/users/sally");

The following example creates `/u/joe/logs/foo.log` assuming your home directory is `/u/joe`, or `C:\joe\logs\foo.log` if you are on Windows.

    Path p5 = Paths.get(System.getProperty("user.home"),"logs", "foo.log");

Retrieving Information about a Path
-----------------------------------

You can think of the `Path` as storing these name elements as a sequence. The highest element in the directory structure would be located at index 0. The lowest element in the directory structure would be located at index `[n-1]`, where `n` is the number of name elements in the `Path`. Methods are available for retrieving individual elements or a subsequence of the `Path` using these indexes.

The examples in this lesson use the following directory structure.

![Sample directory structure](https://docs.oracle.com/javase/tutorial/figures/essential/io-dirStructure.gif)

Sample Directory Structure

The following code snippet defines a `Path` instance and then invokes several methods to obtain information about the path:

```java
// None of these methods requires that the file corresponding
// to the Path exists.
// Microsoft Windows syntax
Path path = Paths.get("C:\\home\\joe\\foo");

// Solaris syntax
Path path = Paths.get("/home/joe/foo");

System.out.format("toString: %s%n", path.toString());
System.out.format("getFileName: %s%n", path.getFileName());
System.out.format("getName(0): %s%n", path.getName(0));
System.out.format("getNameCount: %d%n", path.getNameCount());
System.out.format("subpath(0,2): %s%n", path.subpath(0,2));
System.out.format("getParent: %s%n", path.getParent());
System.out.format("getRoot: %s%n", path.getRoot());
```

Here is the output for both Windows and the Solaris OS:

| Method Invoked | Returns in the Solaris OS | Returns in Microsoft Windows | Comment |
| :---:          | :---:           | :---:             | :---: |
| `toString`     | `/home/joe/foo` | `C:\home\joe\foo` | ‚ûä     |
| `getFileName`  | `foo`           | `foo`             | ‚ûã     |
| `getName(0)`   | `home`          | `home`            | ‚ûå     |
| `getNameCount` | `3`             | `3`               | ‚ûç     |
| `subpath(0,2)` | `home/joe`      | `home\joe`        | ‚ûé     |
| `getParent`    | `/home/joe`     | `\home\joe`       | ‚ûè     |
| `getRoot`      | `/`             | `C:\`             | ‚ûê     |

‚ûä Returns the string representation of the `Path`. If the path was created using `Filesystems.getDefault().getPath(String)` or `Paths.get` (the latter is a convenience method for `getPath`), the method performs minor syntactic cleanup. For example, in a UNIX operating system, it will correct the input string `//home/joe/foo` to `/home/joe/foo`.

‚ûã Returns the file name or the last element of the sequence of name elements.

‚ûå Returns the path element corresponding to the specified index. The 0th element is the path element closest to the root.

‚ûç Returns the number of elements in the path.

‚ûé Returns the subsequence of the `Path` (not including a root element) as specified by the beginning and ending indexes.

‚ûè Returns the path of the parent directory.

‚ûê Returns the root of the path.

The previous example shows the output for an absolute path. In the following example, a relative path is specified:

    // Solaris syntax
    Path path = Paths.get("sally/bar");

or

    // Microsoft Windows syntax
    Path path = Paths.get("sally\\bar");

Here is the output for Windows and the Solaris OS:

| Method Invoked | Returns in the Solaris OS | Returns in Microsoft Windows
|----------------|-------------|-------------|
| `toString`     | `sally/bar` | `sally\bar` |
| `getFileName`  | `bar`       | `bar`       |
| `getName(0)`   | `sally`     | `sally`     |
| `getNameCount` | `2`         | `2`         |
| `subpath(0,1)` | `sally`     | `sally`     |
| `getParent`    | `sally`     | `sally`     |
| `getRoot`      | `null`      | `null`      |

Removing Redundancies From a Path
---------------------------------

Many file systems use "." notation to denote the current directory and ".." to denote the parent directory. You might have a situation where a `Path` contains redundant directory information. Perhaps a server is configured to save its log files in the "`/dir/logs/.`" directory, and you want to delete the trailing "`/.`" notation from the path.

The following examples both include redundancies:

    /home/./joe/foo
    /home/sally/../joe/foo

The `normalize` method removes any redundant elements, which includes any "`.`" or "`_directory_/..`" occurrences. Both of the preceding examples normalize to `/home/joe/foo`.

It is important to note that `normalize` doesn't check at the file system when it cleans up a path. It is a purely syntactic operation. In the second example, if `sally` were a symbolic link, removing `sally/..` might result in a `Path` that no longer locates the intended file.

To clean up a path while ensuring that the result locates the correct file, you can use the `toRealPath` method. This method is described in the next section, [Converting a Path](#convert).

Converting a Path
-----------------

You can use three methods to convert the `Path`. If you need to convert the path to a string that can be opened from a browser, you can use [`toUri`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#toUri--). For example:

    Path p1 = Paths.get("/home/logfile");
    // Result is **file:///home/logfile**
    System.out.format("%s%n", p1.toUri());

The [`toAbsolutePath`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#toAbsolutePath--) method converts a path to an absolute path. If the passed-in path is already absolute, it returns the same `Path` object. The `toAbsolutePath` method can be very helpful when processing user-entered file names. For example:

```java
public class FileTest {
    public static void main(String[] args) {

        if (args.length < 1) {
            System.out.println("usage: FileTest file");
            System.exit(-1);
        }

        // Converts the input string to a Path object.
        Path inputPath = Paths.get(args[0]);

        **// Converts the input Path
        // to an absolute path.
        // Generally, this means prepending
        // the current working
        // directory.  If this example
        // were called like this:
        //     java FileTest foo
        // the getRoot and getParent methods
        // would return null
        // on the original "inputPath"
        // instance.  Invoking getRoot and
        // getParent on the "fullPath"
        // instance returns expected values.
        Path fullPath = inputPath.toAbsolutePath();**
    }
}
```

The `toAbsolutePath` method converts the user input and returns a `Path` that returns useful values when queried. The file does not need to exist for this method to work.

The [`toRealPath`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#toRealPath-java.nio.file.LinkOption...-) method returns the _real_ path of an existing file. This method performs several operations in one:

*   If `true` is passed to this method and the file system supports symbolic links, this method resolves any symbolic links in the path.
*   If the `Path` is relative, it returns an absolute path.
*   If the `Path` contains any redundant elements, it returns a path with those elements removed.

This method throws an exception if the file does not exist or cannot be accessed. You can catch the exception when you want to handle any of these cases. For example:

```java
try {
    Path fp = path.toRealPath();
} catch (NoSuchFileException x) {
    System.err.format("%s: no such" + " file or directory%n", path);
    // Logic for case when file doesn't exist.
} catch (IOException x) {
    System.err.format("%s%n", x);
    // Logic for other sort of file error.
}
```

Joining Two Paths
-----------------

You can combine paths by using the `resolve` method. You pass in a _partial path_ , which is a path that does not include a root element, and that partial path is appended to the original path.

For example, consider the following code snippet:

```java
// Solaris
Path p1 = Paths.get("/home/joe/foo");
// Result is **/home/joe/foo/bar**
System.out.format("%s%n", p1.resolve("bar"));

```
or

```java
// Microsoft Windows
Path p1 = Paths.get("C:\\home\\joe\\foo");
// Result is **C:\home\joe\foo\bar**
System.out.format("%s%n", p1.resolve("bar"));

```
Passing an absolute path to the `resolve` method returns the passed-in path:

```java
// Result is **/home/joe**
Paths.get("foo").resolve("/home/joe");

```
Creating a Path Between Two Paths
---------------------------------

A common requirement when you are writing file I/O code is the capability to construct a path from one location in the file system to another location. You can meet this using the `relativize` method. This method constructs a path originating from the original path and ending at the location specified by the passed-in path. The new path is _relative_ to the original path.

For example, consider two relative paths defined as `joe` and `sally`:

```java
Path p1 = Paths.get("joe");
Path p2 = Paths.get("sally");
```

In the absence of any other information, it is assumed that `joe` and `sally` are siblings, meaning nodes that reside at the same level in the tree structure. To navigate from `joe` to `sally`, you would expect to first navigate one level up to the parent node and then down to `sally`:

```java
// Result is **../sally**
Path p1_to_p2 = p1.relativize(p2);
// Result is **../joe**
Path p2_to_p1 = p2.relativize(p1);
```

Consider a slightly more complicated example:

```java
Path p1 = Paths.get("home");
Path p3 = Paths.get("home/sally/bar");
// Result is **sally/bar**
Path p1_to_p3 = p1.relativize(p3);
// Result is **../..**
Path p3_to_p1 = p3.relativize(p1);
```

In this example, the two paths share the same node, `home`. To navigate from `home` to `bar`, you first navigate one level down to `sally` and then one more level down to `bar`. Navigating from `bar` to `home` requires moving up two levels.

A relative path cannot be constructed if only one of the paths includes a root element. If both paths include a root element, the capability to construct a relative path is system dependent.

The recursive [`` `Copy` ``](examples/Copy.java) example uses the `relativize` and `resolve` methods.

Comparing Two Paths
-------------------

The `Path` class supports [`equals`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#equals-java.lang.Object-), enabling you to test two paths for equality. The [`startsWith`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#startsWith-java.nio.file.Path-) and [`endsWith`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#endsWith-java.nio.file.Path-) methods enable you to test whether a path begins or ends with a particular string. These methods are easy to use. For example:

    Path path = ...;
    Path otherPath = ...;
    Path beginning = Paths.get("/home");
    Path ending = Paths.get("foo");

    if (path.equals(otherPath)) {
        // _equality logic here_
    } else if (path.startsWith(beginning)) {
        // _path begins with "/home"_
    } else if (path.endsWith(ending)) {
        // _path ends with "foo"_
    }

The `Path` class implements the [`Iterable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html) interface. The [`iterator`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#iterator--) method returns an object that enables you to iterate over the name elements in the path. The first element returned is that closest to the root in the directory tree. The following code snippet iterates over a path, printing each name element:

Path path = ...;
for (Path name: path) {
    System.out.println(name);
}

The `Path` class also implements the [`Comparable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html) interface. You can compare `Path` objects by using `compareTo` which is useful for sorting.

You can also put `Path` objects into a `Collection`. See the [Collections](../../collections/index.html) trail for more information about this powerful feature.

When you want to verify that two `Path` objects locate the same file, you can use the `isSameFile` method, as described in [Checking Whether Two Paths Locate the Same File](check.html#same).

<a name="sec_10_2_4"></a>
## 10.2.4.  [File Operations](#sec_10_2_4)
******
https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html > raw.zq

The [`Files`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html) class is the other primary entrypoint of the `java.nio.file` package. This class offers a rich set of static methods for reading, writing, and manipulating files and directories. The `Files` methods work on instances of `Path` objects. Before proceeding to the remaining sections, you should familiarize yourself with the following common concepts:

*   [Releasing System Resources](#resources)
*   [Catching Exceptions](#exception)
*   [Varargs](#varargs)
*   [Atomic Operations](#atomic)
*   [Method Chaining](#chaining)
*   [What _Is_ a Glob?](#glob)
*   [Link Awareness](#linkaware)

Releasing System Resources
--------------------------

Many of the resources that are used in this API, such as streams or channels, implement or extend the [`java.io.Closeable`](https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html) interface. A requirement of a `Closeable` resource is that the `close` method must be invoked to release the resource when no longer required. Neglecting to close a resource can have a negative implication on an application's performance. The `try-`with-resources statement, described in the next section, handles this step for you.

Catching Exceptions
-------------------

With file I/O, unexpected conditions are a fact of life: a file exists (or doesn't exist) when expected, the program doesn't have access to the file system, the default file system implementation does not support a particular function, and so on. Numerous errors can be encountered.

All methods that access the file system can throw an `IOException`. It is best practice to catch these exceptions by embedding these methods into a `try-`with-resources statement, introduced in the Java SE 7 release. The `try-`with-resources statement has the advantage that the compiler automatically generates the code to close the resource(s) when no longer required. The following code shows how this might look:

Charset charset = Charset.forName("US-ASCII");
String s = ...;
try (BufferedWriter writer = Files.newBufferedWriter(file, charset)) {
    writer.write(s, 0, s.length());
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}

For more information, see [The try-with-resources Statement](../../essential/exceptions/tryResourceClose.html).

Alternatively, you can embed the file I/O methods in a `try` block and then catch any exceptions in a `catch` block. If your code has opened any streams or channels, you should close them in a `finally` block. The previous example would look something like the following using the try-catch-finally approach:

Charset charset = Charset.forName("US-ASCII");
String s = ...;
BufferedWriter writer = null;
try {
    writer = Files.newBufferedWriter(file, charset);
    writer.write(s, 0, s.length());
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
} finally {
    if (writer != null) writer.close();
}

For more information, see [Catching and Handling Exceptions](../../essential/exceptions/handling.html).

In addition to `IOException`, many specific exceptions extend [`FileSystemException`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html). This class has some useful methods that return the file involved [(`getFile`)](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getFile--), the detailed message string [(`getMessage`)](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getMessage--), the reason why the file system operation failed [(`getReason`)](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getReason--), and the "other" file involved, if any [(`getOtherFile`)](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getOtherFile--).

The following code snippet shows how the `getFile` method might be used:

try (...) {
    ...    
} catch (NoSuchFileException x) {
    System.err.format("%s does not exist\\n", x.getFile());
}

For purposes of clarity, the file I/O examples in this lesson may not show exception handling, but your code should always include it.

Varargs
-------

Several `Files` methods accept an arbitrary number of arguments when flags are specified. For example, in the following method signature, the ellipses notation after the `CopyOption` argument indicates that the method accepts a variable number of arguments, or _varargs_, as they are typically called:

Path Files.move(Path, Path, **CopyOption...**)

When a method accepts a varargs argument, you can pass it a comma-separated list of values or an array (`CopyOption[]`) of values.

In the `move` example, the method can be invoked as follows:

```java
import static java.nio.file.StandardCopyOption.*;

Path source = ...;
Path target = ...;
Files.move(source,
           target,
           REPLACE_EXISTING,
           ATOMIC_MOVE);
```

For more information about varargs syntax, see [Arbitrary Number of Arguments](../../java/javaOO/arguments.html#varargs).

Atomic Operations
-----------------

Several `Files` methods, such as `move`, can perform certain operations atomically in some file systems.

An _atomic file operation_ is an operation that cannot be interrupted or "partially" performed. Either the entire operation is performed or the operation fails. This is important when you have multiple processes operating on the same area of the file system, and you need to guarantee that each process accesses a complete file.

Method Chaining
---------------

Many of the file I/O methods support the concept of _method chaining_.

You first invoke a method that returns an object. You then immediately invoke a method on _that_ object, which returns yet another object, and so on. Many of the I/O examples use the following technique:

String value = Charset.defaultCharset().decode(buf).toString();
UserPrincipal group =
    file.getFileSystem().getUserPrincipalLookupService().
         lookupPrincipalByName("me");

This technique produces compact code and enables you to avoid declaring temporary variables that you don't need.

What _Is_ a Glob?
-----------------

Two methods in the `Files` class accept a glob argument, but what is a _glob_?

You can use glob syntax to specify pattern-matching behavior.

A glob pattern is specified as a string and is matched against other strings, such as directory or file names. Glob syntax follows several simple rules:

*   An asterisk, `*`, matches any number of characters (including none).
*   Two asterisks, `**`, works like `*` but crosses directory boundaries. This syntax is generally used for matching complete paths.
*   A question mark, `?`, matches exactly one character.
*   Braces specify a collection of subpatterns. For example:
    *   `{sun,moon,stars}` matches "sun", "moon", or "stars".
    *   `{temp*,tmp*}` matches all strings beginning with "temp" or "tmp".
*   Square brackets convey a set of single characters or, when the hyphen character (`-`) is used, a range of characters. For example:
    
    *   `[aeiou]` matches any lowercase vowel.
    *   `[0-9]` matches any digit.
    *   `[A-Z]` matches any uppercase letter.
    *   `[a-z,A-Z]` matches any uppercase or lowercase letter.
    
    Within the square brackets, `*`, `?`, and `\` match themselves.
*   All other characters match themselves.
*   To match `*`, `?`, or the other special characters, you can escape them by using the backslash character, `\`. For example: `\\` matches a single backslash, and `\?` matches the question mark.

Here are some examples of glob syntax:

*   `*.html` ‚Äì Matches all strings that end in _.html_
*   `???` ‚Äì Matches all strings with exactly three letters or digits
*   `*[0-9]*` ‚Äì Matches all strings containing a numeric value
*   `*.{htm,html,pdf}` ‚Äì Matches any string ending with _.htm_, _.html_ or _.pdf_
*   `a?*.java` ‚Äì Matches any string beginning with `a`, followed by at least one letter or digit, and ending with _.java_
*   `{foo*,*[0-9]*}` ‚Äì Matches any string beginning with _foo_ or any string containing a numeric value

* * *

**Note:**¬†If you are typing the glob pattern at the keyboard and it contains one of the special characters, you must put the pattern in quotes (`"*"`), use the backslash (`*`), or use whatever escape mechanism is supported at the command line.

* * *

The glob syntax is powerful and easy to use. However, if it is not sufficient for your needs, you can also use a regular expression. For more information, see the [Regular Expressions](../../essential/regex/index.html) lesson.

For more information about the glob syntax, see the API specification for the [`getPathMatcher`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-) method in the `FileSystem` class.

Link Awareness
--------------

The `Files` class is "link aware." Every `Files` method either detects what to do when a symbolic link is encountered, or it provides an option enabling you to configure the behavior when a symbolic link is encountered.

<a name="sec_10_2_5"></a>
## 10.2.5.  [Checking a File or Directory](#sec_10_2_5)
******
https://docs.oracle.com/javase/tutorial/essential/io/check.html

You have a `Path` instance representing a file or directory, but does that file exist on the file system? Is it readable? Writable? Executable?

Verifying the Existence of a File or Directory
----------------------------------------------

The methods in the `Path` class are syntactic, meaning that they operate on the `Path` instance. But eventually you must access the file system to verify that a particular `Path` exists, or does not exist. You can do so with the [`exists(Path, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#exists-java.nio.file.Path-java.nio.file.LinkOption...-) and the [`notExists(Path, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#notExists-java.nio.file.Path-java.nio.file.LinkOption...-) methods. Note that `!Files.exists(path)` is not equivalent to `Files.notExists(path)`. When you are testing a file's existence, three results are possible:

*   The file is verified to exist.
*   The file is verified to not exist.
*   The file's status is unknown. This result can occur when the program does not have access to the file.

If both `exists` and `notExists` return `false`, the existence of the file cannot be verified.

Checking File Accessibility
---------------------------

To verify that the program can access a file as needed, you can use the [`isReadable(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isReadable-java.nio.file.Path-), [`isWritable(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isWritable-java.nio.file.Path-), and [`isExecutable(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isExecutable-java.nio.file.Path-) methods.

The following code snippet verifies that a particular file exists and that the program has the ability to execute the file.

Path file = ...;
boolean isRegularExecutableFile = Files.isRegularFile(file) &
         Files.isReadable(file) & Files.isExecutable(file);

* * *

**Note:**¬†Once any of these methods completes, there is no guarantee that the file can be accessed. A common security flaw in many applications is to perform a check and then access the file. For more information, use your favorite search engine to look up `TOCTTOU` (pronounced _TOCK-too_).

* * *

Checking Whether Two Paths Locate the Same File
-----------------------------------------------

When you have a file system that uses symbolic links, it is possible to have two different paths that locate the same file. The [`isSameFile(Path, Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isSameFile-java.nio.file.Path-java.nio.file.Path-) method compares two paths to determine if they locate the same file on the file system. For example:

Path p1 = ...;
Path p2 = ...;

if (Files.isSameFile(p1, p2)) {
    // Logic when the paths locate the same file
}

<a name="sec_10_2_6"></a>
## 10.2.6.  [Deleting a File or Directory](#sec_10_2_6)
******
https://docs.oracle.com/javase/tutorial/essential/io/delete.html

You can delete files, directories or links. With symbolic links, the link is deleted and not the target of the link. With directories, the directory must be empty, or the deletion fails.

The `Files` class provides two deletion methods.

The [`delete(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#delete-java.nio.file.Path-) method deletes the file or throws an exception if the deletion fails. For example, if the file does not exist a `NoSuchFileException` is thrown. You can catch the exception to determine why the delete failed as follows:

try {
    Files.delete(path);
} catch (NoSuchFileException x) {
    System.err.format("%s: no such" + " file or directory%n", path);
} catch (DirectoryNotEmptyException x) {
    System.err.format("%s not empty%n", path);
} catch (IOException x) {
    // File permission problems are caught here.
    System.err.println(x);
}

The [`deleteIfExists(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#deleteIfExists-java.nio.file.Path-) method also deletes the file, but if the file does not exist, no exception is thrown. Failing silently is useful when you have multiple threads deleting files and you don't want to throw an exception just because one thread did so first.

<a name="sec_10_2_7"></a>
## 10.2.7.  [Copying a File or Directory](#sec_10_2_7)
******
https://docs.oracle.com/javase/tutorial/essential/io/copy.html

You can copy a file or directory by using the [`copy(Path, Path, CopyOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-) method. The copy fails if the target file exists, unless the `REPLACE_EXISTING` option is specified.

Directories can be copied. However, files inside the directory are not copied, so the new directory is empty even when the original directory contains files.

When copying a symbolic link, the target of the link is copied. If you want to copy the link itself, and not the contents of the link, specify either the `NOFOLLOW_LINKS` or `REPLACE_EXISTING` option.

This method takes a varargs argument. The following `StandardCopyOption` and `LinkOption` enums are supported:

*   `REPLACE_EXISTING` ‚Äì Performs the copy even when the target file already exists. If the target is a symbolic link, the link itself is copied (and not the target of the link). If the target is a non-empty directory, the copy fails with the `DirectoryNotEmptyException` exception.
*   `COPY_ATTRIBUTES` ‚Äì Copies the file attributes associated with the file to the target file. The exact file attributes supported are file system and platform dependent, but `last-modified-time` is supported across platforms and is copied to the target file.
*   `NOFOLLOW_LINKS` ‚Äì Indicates that symbolic links should not be followed. If the file to be copied is a symbolic link, the link is copied (and not the target of the link).

If you are not familiar with `enums`, see [Enum Types](../../java/javaOO/enum.html).

The following shows how to use the `copy` method:

import static java.nio.file.StandardCopyOption.*;
...
Files.copy(source, target, REPLACE_EXISTING);

In addition to file copy, the `Files` class also defines methods that may be used to copy between a file and a stream. The [`copy(InputStream, Path, CopyOptions...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.io.InputStream-java.nio.file.Path-java.nio.file.CopyOption...-) method may be used to copy all bytes from an input stream to a file. The [`copy(Path, OutputStream)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.nio.file.Path-java.io.OutputStream-) method may be used to copy all bytes from a file to an output stream.

The [`` `Copy` ``](examples/Copy.java) example uses the `copy` and `Files.walkFileTree` methods to support a recursive copy. See [Walking the File Tree](walk.html) for more information.

<a name="sec_10_2_8"></a>
## 10.2.8.  [Moving a File or Directory](#sec_10_2_8)
******
https://docs.oracle.com/javase/tutorial/essential/io/move.html

You can move a file or directory by using the [`move(Path, Path, CopyOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#move-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-) method. The move fails if the target file exists, unless the `REPLACE_EXISTING` option is specified.

Empty directories can be moved. If the directory is not empty, the move is allowed when the directory can be moved without moving the contents of that directory. On UNIX systems, moving a directory within the same partition generally consists of renaming the directory. In that situation, this method works even when the directory contains files.

This method takes a varargs argument ‚Äì the following `StandardCopyOption` enums are supported:

*   `REPLACE_EXISTING` ‚Äì Performs the move even when the target file already exists. If the target is a symbolic link, the symbolic link is replaced but what it points to is not affected.
*   `ATOMIC_MOVE` ‚Äì Performs the move as an atomic file operation. If the file system does not support an atomic move, an exception is thrown. With an `ATOMIC_MOVE` you can move a file into a directory and be guaranteed that any process watching the directory accesses a complete file.

The following shows how to use the `move` method:

import static java.nio.file.StandardCopyOption.*;
...
Files.move(source, target, REPLACE_EXISTING);

Though you can implement the `move` method on a single directory as shown, the method is most often used with the file tree recursion mechanism. For more information, see [Walking the File Tree](walk.html).

<a name="sec_10_2_9"></a>
## 10.2.9.  [Managing Metadata (File and File Store Attributes)](#sec_10_2_9)
******
https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html

The definition of _metadata_ is "data about other data." With a file system, the data is contained in its files and directories, and the metadata tracks information about each of these objects: Is it a regular file, a directory, or a link? What is its size, creation date, last modified date, file owner, group owner, and access permissions?

A file system's metadata is typically referred to as its _file attributes_. The `Files` class includes methods that can be used to obtain a single attribute of a file, or to set an attribute.

| Methods | Comment |
|---------|---------|
| [`size(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#size-java.nio.file.Path-) |\
Returns the size of the specified file in bytes.

[`isDirectory(Path, LinkOption)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isDirectory-java.nio.file.Path-java.nio.file.LinkOption...-)

Returns true if the specified `Path` locates a file that is a directory.

[`isRegularFile(Path, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isRegularFile-java.nio.file.Path-java.nio.file.LinkOption...-)

Returns true if the specified `Path` locates a file that is a regular file.

[`isSymbolicLink(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isSymbolicLink-java.nio.file.Path-)

Returns true if the specified `Path` locates a file that is a symbolic link.

[`isHidden(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isHidden-java.nio.file.Path-)

Returns true if the specified `Path` locates a file that is considered hidden by the file system.

[`getLastModifiedTime(Path, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getLastModifiedTime-java.nio.file.Path-java.nio.file.LinkOption...-)  
[`setLastModifiedTime(Path, FileTime)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#setLastModifiedTime-java.nio.file.Path-java.nio.file.attribute.FileTime-)

Returns or sets the specified file's last modified time.

[`getOwner(Path, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getOwner-java.nio.file.Path-java.nio.file.LinkOption...-)  
[`setOwner(Path, UserPrincipal)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#setOwner-java.nio.file.Path-java.nio.file.attribute.UserPrincipal-)

Returns or sets the owner of the file.

[`getPosixFilePermissions(Path, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getPosixFilePermissions-java.nio.file.Path-java.nio.file.LinkOption...-)  
[`setPosixFilePermissions(Path, Set<PosixFilePermission>)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#setPosixFilePermissions-java.nio.file.Path-java.util.Set-)

Returns or sets a file's POSIX file permissions.

[`getAttribute(Path, String, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getAttribute-java.nio.file.Path-java.lang.String-java.nio.file.LinkOption...-)  
[`setAttribute(Path, String, Object, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#setAttribute-java.nio.file.Path-java.lang.String-java.lang.Object-java.nio.file.LinkOption...-)

Returns or sets the value of a file attribute.

If a program needs multiple file attributes around the same time, it can be inefficient to use methods that retrieve a single attribute. Repeatedly accessing the file system to retrieve a single attribute can adversely affect performance. For this reason, the `Files` class provides two `readAttributes` methods to fetch a file's attributes in one bulk operation.

Method

Comment

[`readAttributes(Path, String, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readAttributes-java.nio.file.Path-java.lang.String-java.nio.file.LinkOption...-)

Reads a file's attributes as a bulk operation. The `String` parameter identifies the attributes to be read.

[`readAttributes(Path, Class<A>, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-)

Reads a file's attributes as a bulk operation. The `Class<A>` parameter is the type of attributes requested and the method returns an object of that class.

Before showing examples of the `readAttributes` methods, it should be mentioned that different file systems have different notions about which attributes should be tracked. For this reason, related file attributes are grouped together into views. A _view_ maps to a particular file system implementation, such as POSIX or DOS, or to a common functionality, such as file ownership.

The supported views are as follows:

*   [`BasicFileAttributeView`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/BasicFileAttributeView.html) ‚Äì Provides a view of basic attributes that are required to be supported by all file system implementations.
*   [`DosFileAttributeView`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/DosFileAttributeView.html) ‚Äì Extends the basic attribute view with the standard four bits supported on file systems that support the DOS attributes.
*   [`PosixFileAttributeView`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFileAttributeView.html) ‚Äì Extends the basic attribute view with attributes supported on file systems that support the POSIX family of standards, such as UNIX. These attributes include file owner, group owner, and the nine related access permissions.
*   [`FileOwnerAttributeView`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/FileOwnerAttributeView.html) ‚Äì Supported by any file system implementation that supports the concept of a file owner.
*   [`AclFileAttributeView`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/AclFileAttributeView.html) ‚Äì Supports reading or updating a file's Access Control Lists (ACL). The NFSv4 ACL model is supported. Any ACL model, such as the Windows ACL model, that has a well-defined mapping to the NFSv4 model might also be supported.
*   [`UserDefinedFileAttributeView`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/UserDefinedFileAttributeView.html) ‚Äì Enables support of metadata that is user defined. This view can be mapped to any extension mechanisms that a system supports. In the Solaris OS, for example, you can use this view to store the MIME type of a file.

A specific file system implementation might support only the basic file attribute view, or it may support several of these file attribute views. A file system implementation might support other attribute views not included in this API.

In most instances, you should not have to deal directly with any of the `FileAttributeView` interfaces. (If you do need to work directly with the `FileAttributeView`, you can access it via the [`getFileAttributeView(Path, Class<V>, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getFileAttributeView-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-) method.)

The `readAttributes` methods use generics and can be used to read the attributes for any of the file attributes views. The examples in the rest of this page use the `readAttributes` methods.

The remainder of this section covers the following topics:

*   [Basic File Attributes](#basic)
*   [Setting Time Stamps](#time)
*   [DOS File Attributes](#dos)
*   [POSIX File Permissions](#posix)
*   [Setting a File or Group Owner](#lookup)
*   [User-Defined File Attributes](#user)
*   [File Store Attributes](#store)

Basic File Attributes
---------------------

As mentioned previously, to read the basic attributes of a file, you can use one of the `Files.readAttributes` methods, which reads all the basic attributes in one bulk operation. This is far more efficient than accessing the file system separately to read each individual attribute. The varargs argument currently supports the [`LinkOption`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/LinkOption.html) enum, `NOFOLLOW_LINKS`. Use this option when you do not want symbolic links to be followed.

* * *

**A word about time stamps:**¬†The set of basic attributes includes three time stamps: `creationTime`, `lastModifiedTime`, and `lastAccessTime`. Any of these time stamps might not be supported in a particular implementation, in which case the corresponding accessor method returns an implementation-specific value. When supported, the time stamp is returned as an [`FileTime`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/FileTime.html) object.

* * *

The following code snippet reads and prints the basic file attributes for a given file and uses the methods in the [`BasicFileAttributes`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/BasicFileAttributes.html) class.

Path file = ...;
BasicFileAttributes attr = Files.readAttributes(file, BasicFileAttributes.class);

System.out.println("creationTime: " + attr.creationTime());
System.out.println("lastAccessTime: " + attr.lastAccessTime());
System.out.println("lastModifiedTime: " + attr.lastModifiedTime());

System.out.println("isDirectory: " + attr.isDirectory());
System.out.println("isOther: " + attr.isOther());
System.out.println("isRegularFile: " + attr.isRegularFile());
System.out.println("isSymbolicLink: " + attr.isSymbolicLink());
System.out.println("size: " + attr.size());

In addition to the accessor methods shown in this example, there is a `fileKey` method that returns either an object that uniquely identifies the file or `null` if no file key is available.

Setting Time Stamps
-------------------

The following code snippet sets the last modified time in milliseconds:

Path file = ...;
BasicFileAttributes attr =
    Files.readAttributes(file, BasicFileAttributes.class);
long currentTime = System.currentTimeMillis();
FileTime ft = FileTime.fromMillis(currentTime);
Files.setLastModifiedTime(file, ft);
}

DOS File Attributes
-------------------

DOS file attributes are also supported on file systems other than DOS, such as Samba. The following snippet uses the methods of the [`DosFileAttributes`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/DosFileAttributes.html) class.

Path file = ...;
try {
    DosFileAttributes attr =
        Files.readAttributes(file, DosFileAttributes.class);
    System.out.println("isReadOnly is " + attr.isReadOnly());
    System.out.println("isHidden is " + attr.isHidden());
    System.out.println("isArchive is " + attr.isArchive());
    System.out.println("isSystem is " + attr.isSystem());
} catch (UnsupportedOperationException x) {
    System.err.println("DOS file" +
        " attributes not supported:" + x);
}

However, you can set a DOS attribute using the [`setAttribute(Path, String, Object, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#setAttribute-java.nio.file.Path-java.lang.String-java.lang.Object-java.nio.file.LinkOption...-) method, as follows:

Path file = ...;
Files.setAttribute(file, "dos:hidden", true);

POSIX File Permissions
----------------------

_POSIX_ is an acronym for Portable Operating System Interface for UNIX and is a set of IEEE and ISO standards designed to ensure interoperability among different flavors of UNIX. If a program conforms to these POSIX standards, it should be easily ported to other POSIX-compliant operating systems.

Besides file owner and group owner, POSIX supports nine file permissions: read, write, and execute permissions for the file owner, members of the same group, and "everyone else."

The following code snippet reads the POSIX file attributes for a given file and prints them to standard output. The code uses the methods in the [`PosixFileAttributes`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFileAttributes.html) class.

Path file = ...;
PosixFileAttributes attr =
    Files.readAttributes(file, PosixFileAttributes.class);
System.out.format("%s %s %s%n",
    attr.owner().getName(),
    attr.group().getName(),
    PosixFilePermissions.toString(attr.permissions()));

The [`PosixFilePermissions`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFilePermissions.html) helper class provides several useful methods, as follows:

*   The `toString` method, used in the previous code snippet, converts the file permissions to a string (for example, `rw-r--r--`).
*   The `fromString` method accepts a string representing the file permissions and constructs a `Set` of file permissions.
*   The `asFileAttribute` method accepts a `Set` of file permissions and constructs a file attribute that can be passed to the `Path.createFile` or `Path.createDirectory` method.

The following code snippet reads the attributes from one file and creates a new file, assigning the attributes from the original file to the new file:

Path sourceFile = ...;
Path newFile = ...;
PosixFileAttributes attrs =
    Files.readAttributes(sourceFile, PosixFileAttributes.class);
FileAttribute<Set<PosixFilePermission>> attr =
    PosixFilePermissions.asFileAttribute(attrs.permissions());
Files.createFile(file, attr);

The `asFileAttribute` method wraps the permissions as a `FileAttribute`. The code then attempts to create a new file with those permissions. Note that the `umask` also applies, so the new file might be more secure than the permissions that were requested.

To set a file's permissions to values represented as a hard-coded string, you can use the following code:

Path file = ...;
Set<PosixFilePermission> perms =
    PosixFilePermissions.fromString("rw-------");
FileAttribute<Set<PosixFilePermission>> attr =
    PosixFilePermissions.asFileAttribute(perms);
Files.setPosixFilePermissions(file, perms);

The [`` `Chmod` ``](examples/Chmod.java) example recursively changes the permissions of files in a manner similar to the `chmod` utility.

Setting a File or Group Owner
-----------------------------

To translate a name into an object you can store as a file owner or a group owner, you can use the [`UserPrincipalLookupService`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/UserPrincipalLookupService.html) service. This service looks up a name or group name as a string and returns a `UserPrincipal` object representing that string. You can obtain the user principal look-up service for the default file system by using the [`FileSystem.getUserPrincipalLookupService`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getUserPrincipalLookupService--) method.

The following code snippet shows how to set the file owner by using the `setOwner` method:

Path file = ...;
UserPrincipal owner = file.GetFileSystem().getUserPrincipalLookupService()
        .lookupPrincipalByName("sally");
Files.setOwner(file, owner);

There is no special-purpose method in the `Files` class for setting a group owner. However, a safe way to do so directly is through the POSIX file attribute view, as follows:

Path file = ...;
GroupPrincipal group =
    file.getFileSystem().getUserPrincipalLookupService()
        .lookupPrincipalByGroupName("green");
Files.getFileAttributeView(file, PosixFileAttributeView.class)
     .setGroup(group);

User-Defined File Attributes
----------------------------

If the file attributes supported by your file system implementation aren't sufficient for your needs, you can use the `UserDefinedAttributeView` to create and track your own file attributes.

Some implementations map this concept to features like NTFS Alternative Data Streams and extended attributes on file systems such as ext3 and ZFS. Most implementations impose restrictions on the size of the value, for example, ext3 limits the size to 4 kilobytes.

A file's MIME type can be stored as a user-defined attribute by using this code snippet:

Path file = ...;
UserDefinedFileAttributeView view = Files
    .getFileAttributeView(file, UserDefinedFileAttributeView.class);
view.write("user.mimetype",
           Charset.defaultCharset().encode("text/html");

To read the MIME type attribute, you would use this code snippet:

Path file = ...;
UserDefinedFileAttributeView view = Files
.getFileAttributeView(file,UserDefinedFileAttributeView.class);
String name = "user.mimetype";
ByteBuffer buf = ByteBuffer.allocate(view.size(name));
view.read(name, buf);
buf.flip();
String value = Charset.defaultCharset().decode(buf).toString();

The [`` `Xdd` ``](examples/Xdd.java) example shows how to get, set, and delete a user-defined attribute.

* * *

**Note:**¬†In Linux, you might have to enable extended attributes for user-defined attributes to work. If you receive an `UnsupportedOperationException` when trying to access the user-defined attribute view, you need to remount the file system. The following command remounts the root partition with extended attributes for the ext3 file system. If this command does not work for your flavor of Linux, consult the documentation.

$ sudo mount -o remount,user_xattr /

If you want to make the change permanent, add an entry to `/etc/fstab`.

* * *

File Store Attributes
---------------------

You can use the [`FileStore`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileStore.html) class to learn information about a file store, such as how much space is available. The [`getFileStore(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getFileStore-java.nio.file.Path-) method fetches the file store for the specified file.

The following code snippet prints the space usage for the file store where a particular file resides:

Path file = ...;
FileStore store = Files.getFileStore(file);

long total = store.getTotalSpace() / 1024;
long used = (store.getTotalSpace() -
             store.getUnallocatedSpace()) / 1024;
long avail = store.getUsableSpace() / 1024;

The [`DiskUsage`](examples/DiskUsage.java) example uses this API to print disk space information for all the stores in the default file system. This example uses the [`getFileStores`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getFileStores--) method in the `FileSystem` class to fetch all the file stores for the file system.

<a name="sec_10_2_10"></a>
## 10.2.10.  [Reading, Writing and Creating Files](#sec_10_2_10)
******
https://docs.oracle.com/javase/tutorial/essential/io/file.html

<a name="sec_10_2_11"></a>
## 10.2.11.  [Random Access Files](#sec_10_2_11)
******
https://docs.oracle.com/javase/tutorial/essential/io/rafs.html

<a name="sec_10_2_12"></a>
## 10.2.12.  [Creating and Reading Directories](#sec_10_2_12)
******
https://docs.oracle.com/javase/tutorial/essential/io/dirs.html

<a name="sec_10_2_13"></a>
## 10.2.13.  [Links, Symbolic or Otherwise](#sec_10_2_13)
******
https://docs.oracle.com/javase/tutorial/essential/io/links.html

<a name="sec_10_2_14"></a>
## 10.2.14.  [Walking the File Tree](#sec_10_2_14)
******
https://docs.oracle.com/javase/tutorial/essential/io/walk.html

<a name="sec_10_2_15"></a>
## 10.2.15.  [Finding Files](#sec_10_2_15)
******
https://docs.oracle.com/javase/tutorial/essential/io/find.html

<a name="sec_10_2_16"></a>
## 10.2.16.  [Watching a Directory for Changes](#sec_10_2_16)
******
https://docs.oracle.com/javase/tutorial/essential/io/notification.html

<a name="sec_10_2_17"></a>
## 10.2.17.  [Other Useful Methods](#sec_10_2_17)
******
https://docs.oracle.com/javase/tutorial/essential/io/misc.html

<a name="sec_10_2_18"></a>
## 10.2.18.  [Legacy File I/O Code](#sec_10_2_18)
******
https://docs.oracle.com/javase/tutorial/essential/io/legacy.html


<a name="sec_10_3"></a>
## 10.3. [Summary](#sec_10_3)
******
https://docs.oracle.com/javase/tutorial/essential/io/summary.html 

<a name="sec_10_4"></a>
## 10.4. [Questions and Exercises](#sec_10_4)
******
https://docs.oracle.com/javase/tutorial/essential/io/QandE/questions.html 


<a name="sec_11"></a>
# üìú/PART 11.  [**Concurrency**](#sec_11)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html 

1. [Processes and Threads](#sec_11_1)
2. [Thread Objects](#sec_11_2)
3. [Defining and Starting a Thread](#sec_11_3)
4. [Pausing Execution with Sleep](#sec_11_4)
5. [Interrupts](#sec_11_5)
6. [Joins](#sec_11_6)
7. [The SimpleThreads Example](#sec_11_7)
8. [Synchronization](#sec_11_8)
9. [Thread Interference](#sec_11_9)
10. [Memory Consistency Errors](#sec_11_10)
11. [Synchronized Methods](#sec_11_11)
12. [Intrinsic Locks and Synchronization](#sec_11_12)
13. [Atomic Access](#sec_11_13)
14. [Liveness](#sec_11_14)
15. [Deadlock](#sec_11_15)
16. [Starvation and Livelock](#sec_11_16)
17. [Guarded Blocks](#sec_11_17)
18. [Immutable Objects](#sec_11_18)
19. [A Synchronized Class Example](#sec_11_19)
20. [A Strategy for Defining Immutable Objects](#sec_11_20)
21. [High Level Concurrency Objects](#sec_11_21)
22. [Lock Objects](#sec_11_22)
23. [Executors](#sec_11_23)
24. [Executor Interfaces](#sec_11_24)
25. [Thread Pools](#sec_11_25)
26. [Fork/Join](#sec_11_26)
27. [Concurrent Collections](#sec_11_27)
28. [Atomic Variables](#sec_11_28)
29. [Concurrent Random Numbers](#sec_11_29)
30. [For Further Reading](#sec_11_30)
31. [Questions and Exercises](#sec_11_31)

Computer users take it for granted that their systems can do more than one thing at a time. They assume that they can continue to work in a word processor, while other applications download files, manage the print queue, and stream audio. Even a single application is often expected to do more than one thing at a time. For example, that streaming audio application must simultaneously read the digital audio off the network, decompress it, manage playback, and update its display. Even the word processor should always be ready to respond to keyboard and mouse events, no matter how busy it is reformatting text or updating the display. Software that can do such things is known as _concurrent_ software.

The Java platform is designed from the ground up to support concurrent programming, with basic concurrency support in the Java programming language and the Java class libraries. Since version 5.0, the Java platform has also included high-level concurrency APIs. This lesson introduces the platform's basic concurrency support and summarizes some of the high-level APIs in the `java.util.concurrent` packages.


<a name="sec_11_1"></a>
## 11.1. [Processes and Threads](#sec_11_1)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html

This page discusses the details of reading, writing, creating, and opening files. There are a wide array of file I/O methods to choose from. To help make sense of the API, the following diagram arranges the file I/O methods by complexity.

![Line drawing with file I/O methods arranged from least complex (on the left) to most complex (on the right).](https://docs.oracle.com/javase/tutorial/figures/essential/io-fileiomethods.gif)

File I/O Methods Arranged from Less Complex to More Complex

On the far left of the diagram are the utility methods `readAllBytes`, `readAllLines`, and the `write` methods, designed for simple, common cases. To the right of those are the methods used to iterate over a stream or lines of text, such as `newBufferedReader`, `newBufferedWriter`, then `newInputStream` and `newOutputStream`. These methods are interoperable with the `java.io` package. To the right of those are the methods for dealing with `ByteChannels`, `SeekableByteChannels`, and `ByteBuffers`, such as the `newByteChannel` method. Finally, on the far right are the methods that use `FileChannel` for advanced applications needing file locking or memory-mapped I/O.

* * *

**Note:**¬†The methods for creating a new file enable you to specify an optional set of initial attributes for the file. For example, on a file system that supports the POSIX set of standards (such as UNIX), you can specify a file owner, group owner, or file permissions at the time the file is created. The [Managing Metadata](fileAttr.html) page explains file attributes, and how to access and set them.

* * *

This page has the following topics:

*   [The `OpenOptions` Parameter](#openOptions)
*   [Commonly Used Methods for Small Files](#common)
*   [Buffered I/O Methods for Text Files](#textfiles)
*   [Methods for Unbuffered Streams and Interoperable with `java.io` APIs](#streams)
*   [Methods for Channels and `ByteBuffers`](#channels)
*   [Methods for Creating Regular and Temporary Files](#creating)

* * *

The `OpenOptions` Parameter
---------------------------

Several of the methods in this section take an optional `OpenOptions` parameter. This parameter is optional and the API tells you what the default behavior is for the method when none is specified.

The following `StandardOpenOptions` enums are supported:

*   `WRITE` ‚Äì Opens the file for write access.
*   `APPEND` ‚Äì Appends the new data to the end of the file. This option is used with the `WRITE` or `CREATE` options.
*   `TRUNCATE_EXISTING` ‚Äì Truncates the file to zero bytes. This option is used with the `WRITE` option.
*   `CREATE_NEW` ‚Äì Creates a new file and throws an exception if the file already exists.
*   `CREATE` ‚Äì Opens the file if it exists or creates a new file if it does not.
*   `DELETE_ON_CLOSE` ‚Äì Deletes the file when the stream is closed. This option is useful for temporary files.
*   `SPARSE` ‚Äì Hints that a newly created file will be sparse. This advanced option is honored on some file systems, such as NTFS, where large files with data "gaps" can be stored in a more efficient manner where those empty gaps do not consume disk space.
*   `SYNC` ‚Äì Keeps the file (both content and metadata) synchronized with the underlying storage device.
*   `DSYNC` ‚Äì Keeps the file content synchronized with the underlying storage device.

* * *

Commonly Used Methods for Small Files
-------------------------------------

### Reading All Bytes or Lines from a File

If you have a small-ish file and you would like to read its entire contents in one pass, you can use the [`readAllBytes(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readAllBytes-java.nio.file.Path-) or [`readAllLines(Path, Charset)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readAllLines-java.nio.file.Path-java.nio.charset.Charset-) method. These methods take care of most of the work for you, such as opening and closing the stream, but are not intended for handling large files. The following code shows how to use the `readAllBytes` method:

Path file = ...;
byte[] fileArray;
fileArray = Files.readAllBytes(file);

### Writing All Bytes or Lines to a File

You can use one of the write methods to write bytes, or lines, to a file.

*   [`write(Path, byte[], OpenOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#write-java.nio.file.Path-byte:A-java.nio.file.OpenOption...-)
*   [`write(Path, Iterable< extends CharSequence>, Charset, OpenOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#write-java.nio.file.Path-java.lang.Iterable-java.nio.charset.Charset-java.nio.file.OpenOption...-)

The following code snippet shows how to use a `write` method.

Path file = ...;
byte[] buf = ...;
Files.write(file, buf);

* * *

Buffered I/O Methods for Text Files
-----------------------------------

The `java.nio.file` package supports channel I/O, which moves data in buffers, bypassing some of the layers that can bottleneck stream I/O.

### Reading a File by Using Buffered Stream I/O

The [`newBufferedReader(Path, Charset)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newBufferedReader-java.nio.file.Path-java.nio.charset.Charset-) method opens a file for reading, returning a `BufferedReader` that can be used to read text from a file in an efficient manner.

The following code snippet shows how to use the `newBufferedReader` method to read from a file. The file is encoded in "US-ASCII."

Charset charset = Charset.forName("US-ASCII");
try (BufferedReader reader = Files.newBufferedReader(file, charset)) {
    String line = null;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}

### Writing a File by Using Buffered Stream I/O

You can use the [`newBufferedWriter(Path, Charset, OpenOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newBufferedWriter-java.nio.file.Path-java.nio.charset.Charset-java.nio.file.OpenOption...-) method to write to a file using a `BufferedWriter`.

The following code snippet shows how to create a file encoded in "US-ASCII" using this method:

Charset charset = Charset.forName("US-ASCII");
String s = ...;
try (BufferedWriter writer = Files.newBufferedWriter(file, charset)) {
    writer.write(s, 0, s.length());
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}

* * *

Methods for Unbuffered Streams and Interoperable with `java.io` APIs
--------------------------------------------------------------------

### Reading a File by Using Stream I/O

To open a file for reading, you can use the [`newInputStream(Path, OpenOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newInputStream-java.nio.file.Path-java.nio.file.OpenOption...-) method. This method returns an unbuffered input stream for reading bytes from the file.

Path file = ...;
try (InputStream in = Files.newInputStream(file);
    BufferedReader reader =
      new BufferedReader(new InputStreamReader(in))) {
    String line = null;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException x) {
    System.err.println(x);
}

### Creating and Writing a File by Using Stream I/O

You can create a file, append to a file, or write to a file by using the [`newOutputStream(Path, OpenOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newOutputStream-java.nio.file.Path-java.nio.file.OpenOption...-) method. This method opens or creates a file for writing bytes and returns an unbuffered output stream.

The method takes an optional `OpenOption` parameter. If no open options are specified, and the file does not exist, a new file is created. If the file exists, it is truncated. This option is equivalent to invoking the method with the `CREATE` and `TRUNCATE_EXISTING` options.

The following example opens a log file. If the file does not exist, it is created. If the file exists, it is opened for appending.

```java
import static java.nio.file.StandardOpenOption.*;
import java.nio.file.*;
import java.io.*;

public class LogFileTest {

  public static void main(String[] args) {

    // Convert the string to a
    // byte array.
    String s = "Hello World! ";
    byte data[] = s.getBytes();
    Path p = Paths.get("./logfile.txt");

    try (OutputStream out = new BufferedOutputStream(
      Files.newOutputStream(p, CREATE, APPEND))) {
      out.write(data, 0, data.length);
    } catch (IOException x) {
      System.err.println(x);
    }
  }
}
```

* * *

Methods for Channels and `ByteBuffers`
--------------------------------------

### Reading and Writing Files by Using Channel I/O

While stream I/O reads a character at a time, channel I/O reads a buffer at a time. The [`ByteChannel`](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/ByteChannel.html) interface provides basic `read` and `write` functionality. A [`SeekableByteChannel`](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html) is a `ByteChannel` that has the capability to maintain a position in the channel and to change that position. A `SeekableByteChannel` also supports truncating the file associated with the channel and querying the file for its size.

The capability to move to different points in the file and then read from or write to that location makes random access of a file possible. See [Random Access Files](rafs.html) for more information.

There are two methods for reading and writing channel I/O.

*   [`newByteChannel(Path, OpenOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newByteChannel-java.nio.file.Path-java.nio.file.OpenOption...-)
*   [`newByteChannel(Path, Set<? extends OpenOption>, FileAttribute<?>...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newByteChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-)

* * *

**Note:**¬†The `newByteChannel` methods return an instance of a `SeekableByteChannel`. With a default file system, you can cast this seekable byte channel to a [`FileChannel`](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/FileChannel.html) providing access to more advanced features such mapping a region of the file directly into memory for faster access, locking a region of the file so other processes cannot access it, or reading and writing bytes from an absolute position without affecting the channel's current position.

* * *

Both `newByteChannel` methods enable you to specify a list of `OpenOption` options. The same [open options](#openOptions) used by the `newOutputStream` methods are supported, in addition to one more option: `READ` is required because the `SeekableByteChannel` supports both reading and writing.

Specifying `READ` opens the channel for reading. Specifying `WRITE` or `APPEND` opens the channel for writing. If none of these options are specified, then the channel is opened for reading.

The following code snippet reads a file and prints it to standard output:

```java
public static void readFile(Path path) throws IOException {

    // Files.newByteChannel() defaults to StandardOpenOption.READ
    try (SeekableByteChannel sbc = Files.newByteChannel(path)) {
        final int BUFFER_CAPACITY = 10;
        ByteBuffer buf = ByteBuffer.allocate(BUFFER_CAPACITY);

        // Read the bytes with the proper encoding for this platform. If
        // you skip this step, you might see foreign or illegible
        // characters.
        String encoding = System.getProperty("file.encoding");
        while (sbc.read(buf) > 0) {
            buf.flip();
            System.out.print(Charset.forName(encoding).decode(buf));
            buf.clear();
        }
    }    
}
```

The following example, written for UNIX and other POSIX file systems, creates a log file with a specific set of file permissions. This code creates a log file or appends to the log file if it already exists. The log file is created with read/write permissions for owner and read only permissions for group.

```java
import static java.nio.file.StandardOpenOption.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.io.*;
import java.util.*;

public class LogFilePermissionsTest {

  public static void main(String[] args) {
  
    // Create the set of options for appending to the file.
    Set<OpenOption> options = new HashSet<OpenOption>();
    options.add(APPEND);
    options.add(CREATE);

    // Create the custom permissions attribute.
    Set<PosixFilePermission> perms =
      PosixFilePermissions.fromString("rw-r-----");
    FileAttribute<Set<PosixFilePermission>> attr =
      PosixFilePermissions.asFileAttribute(perms);

    // Convert the string to a ByteBuffer.
    String s = "Hello World! ";
    byte data[] = s.getBytes();
    ByteBuffer bb = ByteBuffer.wrap(data);
    
    Path file = Paths.get("./permissions.log");

    try (SeekableByteChannel sbc =
      Files.newByteChannel(file, options, attr)) {
      sbc.write(bb);
    } catch (IOException x) {
      System.out.println("Exception thrown: " + x);
    }
  }
}
```

* * *

Methods for Creating Regular and Temporary Files
------------------------------------------------

### Creating Files

You can create an empty file with an initial set of attributes by using the [`createFile(Path, FileAttribute<?>)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-) method. For example, if, at the time of creation, you want a file to have a particular set of file permissions, use the `createFile` method to do so. If you do not specify any attributes, the file is created with default attributes. If the file already exists, `createFile` throws an exception.

In a single atomic operation, the `createFile` method checks for the existence of the file and creates that file with the specified attributes, which makes the process more secure against malicious code.

The following code snippet creates a file with default attributes:

```java
Path file = ...;
try {
    // Create the empty file with default permissions, etc.
    Files.createFile(file);
} catch (FileAlreadyExistsException x) {
    System.err.format("file named %s" +
        " already exists%n", file);
} catch (IOException x) {
    // Some other sort of failure, such as permissions.
    System.err.format("createFile error: %s%n", x);
}
```

[POSIX File Permissions](fileAttr.html#posix) has an example that uses `createFile(Path, FileAttribute<?>)` to create a file with pre-set permissions.

You can also create a new file by using the `newOutputStream` methods, as described in [Creating and Writing a File using Stream I/O](file.html#createStream). If you open a new output stream and close it immediately, an empty file is created.

### Creating Temporary Files

You can create a temporary file using one of the following `createTempFile` methods:

*   [`createTempFile(Path, String, String, FileAttribute<?>)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempFile-java.nio.file.Path-java.lang.String-java.lang.String-java.nio.file.attribute.FileAttribute...-)
*   [`createTempFile(String, String, FileAttribute<?>)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempFile-java.lang.String-java.lang.String-java.nio.file.attribute.FileAttribute...-)

The first method allows the code to specify a directory for the temporary file and the second method creates a new file in the default temporary-file directory. Both methods allow you to specify a suffix for the filename and the first method allows you to also specify a prefix. The following code snippet gives an example of the second method:

```java
try {
    Path tempFile = Files.createTempFile(null, ".myapp");
    System.out.format("The temporary file" +
        " has been created: %s%n", tempFile)
;
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}
```

The result of running this file would be something like the following:

The temporary file has been created: /tmp/509668702974537184.myapp

The specific format of the temporary file name is platform specific.

<a name="sec_11_2"></a>
## 11.2. [Thread Objects](#sec_11_2)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/threads.html

Each thread is associated with an instance of the class [`Thread`](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html). There are two basic strategies for using `Thread` objects to create a concurrent application.

*   To directly control thread creation and management, simply instantiate `Thread` each time the application needs to initiate an asynchronous task.
*   To abstract thread management from the rest of your application, pass the application's tasks to an _executor_.

This section documents the use of `Thread` objects. Executors are discussed with other [high-level concurrency objects](highlevel.html).

<a name="sec_11_3"></a>
## 11.3. [Defining and Starting a Thread](#sec_11_3)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html

An application that creates an instance of `Thread` must provide the code that will run in that thread. There are two ways to do this:

*   _Provide a `Runnable` object._ The [`Runnable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html) interface defines a single method, `run`, meant to contain the code executed in the thread. The `Runnable` object is passed to the `Thread` constructor, as in the [`` `HelloRunnable` ``](examples/HelloRunnable.java) example:
    
    ```java
    public class HelloRunnable implements Runnable {
        
            public void run() {
                System.out.println("Hello from a thread!");
            }
        
            public static void main(String args[]) {
                (new Thread(new HelloRunnable())).start();
            }
        
        }
    ```
    
*   _Subclass `Thread`._ The `Thread` class itself implements `Runnable`, though its `run` method does nothing. An application can subclass `Thread`, providing its own implementation of `run`, as in the [`` `HelloThread` ``](examples/HelloThread.java) example:
    
    ```java
    public class HelloThread extends Thread {
        
            public void run() {
                System.out.println("Hello from a thread!");
            }
        
            public static void main(String args[]) {
                (new HelloThread()).start();
            }
        
        }
    ```
    

Notice that both examples invoke `Thread.start` in order to start the new thread.

Which of these idioms should you use? The first idiom, which employs a `Runnable` object, is more general, because the `Runnable` object can subclass a class other than `Thread`. The second idiom is easier to use in simple applications, but is limited by the fact that your task class must be a descendant of `Thread`. This lesson focuses on the first approach, which separates the `Runnable` task from the `Thread` object that executes the task. Not only is this approach more flexible, but it is applicable to the high-level thread management APIs covered later.

The `Thread` class defines a number of methods useful for thread management. These include `static` methods, which provide information about, or affect the status of, the thread invoking the method. The other methods are invoked from other threads involved in managing the thread and `Thread` object. We'll examine some of these methods in the following sections.

<a name="sec_11_4"></a>
## 11.4. [Pausing Execution with Sleep](#sec_11_4)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/sleep.html

`Thread.sleep` causes the current thread to suspend execution for a specified period. This is an efficient means of making processor time available to the other threads of an application or other applications that might be running on a computer system. The `sleep` method can also be used for pacing, as shown in the example that follows, and waiting for another thread with duties that are understood to have time requirements, as with the `SimpleThreads` example in a later section.

Two overloaded versions of `sleep` are provided: one that specifies the sleep time to the millisecond and one that specifies the sleep time to the nanosecond. However, these sleep times are not guaranteed to be precise, because they are limited by the facilities provided by the underlying OS. Also, the sleep period can be terminated by interrupts, as we'll see in a later section. In any case, you cannot assume that invoking `sleep` will suspend the thread for precisely the time period specified.

The [`` `SleepMessages` ``](examples/SleepMessages.java) example uses `sleep` to print messages at four-second intervals:

```java
public class SleepMessages {
    public static void main(String args[])
        throws InterruptedException {
        String importantInfo[] = {
            "Mares eat oats",
            "Does eat oats",
            "Little lambs eat ivy",
            "A kid will eat ivy too"
        };

        for (int i = 0;
             i < importantInfo.length;
             i++) {
            //Pause for 4 seconds
            Thread.sleep(4000);
            //Print a message
            System.out.println(importantInfo[i]);
        }
    }
}
```

Notice that `main` declares that it `throws InterruptedException`. This is an exception that `sleep` throws when another thread interrupts the current thread while `sleep` is active. Since this application has not defined another thread to cause the interrupt, it doesn't bother to catch `InterruptedException`.

<a name="sec_11_5"></a>
## 11.5. [Interrupts](#sec_11_5)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/interrupt.html

An _interrupt_ is an indication to a thread that it should stop what it is doing and do something else. It's up to the programmer to decide exactly how a thread responds to an interrupt, but it is very common for the thread to terminate. This is the usage emphasized in this lesson.

A thread sends an interrupt by invoking [`interrupt`](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#interrupt--) on the `Thread` object for the thread to be interrupted. For the interrupt mechanism to work correctly, the interrupted thread must support its own interruption.

Supporting Interruption
-----------------------

How does a thread support its own interruption? This depends on what it's currently doing. If the thread is frequently invoking methods that throw `InterruptedException`, it simply returns from the `run` method after it catches that exception. For example, suppose the central message loop in the `SleepMessages` example were in the `run` method of a thread's `Runnable` object. Then it might be modified as follows to support interrupts:

```java
for (int i = 0; i < importantInfo.length; i++) {
    // Pause for 4 seconds
    try {
        Thread.sleep(4000);
    } catch (InterruptedException e) {
        // We've been interrupted: no more messages.
        return;
    }
    // Print a message
    System.out.println(importantInfo[i]);
}
```

Many methods that throw `InterruptedException`, such as `sleep`, are designed to cancel their current operation and return immediately when an interrupt is received.

What if a thread goes a long time without invoking a method that throws `InterruptedException`? Then it must periodically invoke `Thread.interrupted`, which returns `true` if an interrupt has been received. For example:

```java
for (int i = 0; i < inputs.length; i++) {
    heavyCrunch(inputs[i]);
    if (Thread.interrupted()) {
        // We've been interrupted: no more crunching.
        return;
    }
}
```

In this simple example, the code simply tests for the interrupt and exits the thread if one has been received. In more complex applications, it might make more sense to throw an `InterruptedException`:

```java
if (Thread.interrupted()) {
    throw new InterruptedException();
}
```

This allows interrupt handling code to be centralized in a `catch` clause.

The Interrupt Status Flag
-------------------------

The interrupt mechanism is implemented using an internal flag known as the _interrupt status_. Invoking `Thread.interrupt` sets this flag. When a thread checks for an interrupt by invoking the static method `Thread.interrupted`, interrupt status is cleared. The non-static `isInterrupted` method, which is used by one thread to query the interrupt status of another, does not change the interrupt status flag.

By convention, any method that exits by throwing an `InterruptedException` clears interrupt status when it does so. However, it's always possible that interrupt status will immediately be set again, by another thread invoking `interrupt`.

<a name="sec_11_6"></a>
## 11.6. [Joins](#sec_11_6)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/join.html

The `join` method allows one thread to wait for the completion of another. If `t` is a `Thread` object whose thread is currently executing,

t.join();

causes the current thread to pause execution until `t`'s thread terminates. Overloads of `join` allow the programmer to specify a waiting period. However, as with `sleep`, `join` is dependent on the OS for timing, so you should not assume that `join` will wait exactly as long as you specify.

Like `sleep`, `join` responds to an interrupt by exiting with an `InterruptedException`.

<a name="sec_11_7"></a>
## 11.7. [The SimpleThreads Example](#sec_11_7)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/simple.html

The following example brings together some of the concepts of this section. [`SimpleThreads`](examples/SimpleThreads.java) consists of two threads. The first is the main thread that every Java application has. The main thread creates a new thread from the `Runnable` object, `MessageLoop`, and waits for it to finish. If the `MessageLoop` thread takes too long to finish, the main thread interrupts it.

The `MessageLoop` thread prints out a series of messages. If interrupted before it has printed all its messages, the `MessageLoop` thread prints a message and exits.

```java
public class SimpleThreads {

    // Display a message, preceded by
    // the name of the current thread
    static void threadMessage(String message) {
        String threadName =
            Thread.currentThread().getName();
        System.out.format("%s: %s%n",
                          threadName,
                          message);
    }

    private static class MessageLoop
        implements Runnable {
        public void run() {
            String importantInfo[] = {
                "Mares eat oats",
                "Does eat oats",
                "Little lambs eat ivy",
                "A kid will eat ivy too"
            };
            try {
                for (int i = 0;
                     i < importantInfo.length;
                     i++) {
                    // Pause for 4 seconds
                    Thread.sleep(4000);
                    // Print a message
                    threadMessage(importantInfo[i]);
                }
            } catch (InterruptedException e) {
                threadMessage("I wasn't done!");
            }
        }
    }

    public static void main(String args[])
        throws InterruptedException {

        // Delay, in milliseconds before
        // we interrupt MessageLoop
        // thread (default one hour).
        long patience = 1000 * 60 * 60;

        // If command line argument
        // present, gives patience
        // in seconds.
        if (args.length > 0) {
            try {
                patience = Long.parseLong(args[0]) * 1000;
            } catch (NumberFormatException e) {
                System.err.println("Argument must be an integer.");
                System.exit(1);
            }
        }

        threadMessage("Starting MessageLoop thread");
        long startTime = System.currentTimeMillis();
        Thread t = new Thread(new MessageLoop());
        t.start();

        threadMessage("Waiting for MessageLoop thread to finish");
        // loop until MessageLoop
        // thread exits
        while (t.isAlive()) {
            threadMessage("Still waiting...");
            // Wait maximum of 1 second
            // for MessageLoop thread
            // to finish.
            t.join(1000);
            if (((System.currentTimeMillis() - startTime) > patience)
                  && t.isAlive()) {
                threadMessage("Tired of waiting!");
                t.interrupt();
                // Shouldn't be long now
                // -- wait indefinitely
                t.join();
            }
        }
        threadMessage("Finally!");
    }
}
```

<a name="sec_11_8"></a>
## 11.8. [Synchronization](#sec_11_8)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html

<a name="sec_11_9"></a>
## 11.9. [Thread Interference](#sec_11_9)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/interfere.html

Threads communicate primarily by sharing access to fields and the objects reference fields refer to. This form of communication is extremely efficient, but makes two kinds of errors possible: _thread interference_ and _memory consistency errors_. The tool needed to prevent these errors is _synchronization_.

However, synchronization can introduce _thread contention_, which occurs when two or more threads try to access the same resource simultaneously _and_ cause the Java runtime to execute one or more threads more slowly, or even suspend their execution. [Starvation and livelock](../../essential/concurrency/starvelive.html) are forms of thread contention. See the section [Liveness](../../essential/concurrency/liveness.html) for more information.

This section covers the following topics:

*   [Thread Interference](interfere.html) describes how errors are introduced when multiple threads access shared data.
*   [Memory Consistency Errors](memconsist.html) describes errors that result from inconsistent views of shared memory.
*   [Synchronized Methods](syncmeth.html) describes a simple idiom that can effectively prevent thread interference and memory consistency errors.
*   [Implicit Locks and Synchronization](locksync.html) describes a more general synchronization idiom, and describes how synchronization is based on implicit locks.
*   [Atomic Access](atomic.html) talks about the general idea of operations that can't be interfered with by other threads.

<a name="sec_11_10"></a>
## 11.10. [Memory Consistency Errors](#sec_11_10)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/memconsist.html

_Memory consistency errors_ occur when different threads have inconsistent views of what should be the same data. The causes of memory consistency errors are complex and beyond the scope of this tutorial. Fortunately, the programmer does not need a detailed understanding of these causes. All that is needed is a strategy for avoiding them.

The key to avoiding memory consistency errors is understanding the _happens-before_ relationship. This relationship is simply a guarantee that memory writes by one specific statement are visible to another specific statement. To see this, consider the following example. Suppose a simple `int` field is defined and initialized:

int counter = 0;

The `counter` field is shared between two threads, A and B. Suppose thread A increments `counter`:

counter++;

Then, shortly afterwards, thread B prints out `counter`:

System.out.println(counter);

If the two statements had been executed in the same thread, it would be safe to assume that the value printed out would be "1". But if the two statements are executed in separate threads, the value printed out might well be "0", because there's no guarantee that thread A's change to `counter` will be visible to thread B ‚Äî unless the programmer has established a happens-before relationship between these two statements.

There are several actions that create happens-before relationships. One of them is synchronization, as we will see in the following sections.

We've already seen two actions that create happens-before relationships.

*   When a statement invokes `Thread.start`, every statement that has a happens-before relationship with that statement also has a happens-before relationship with every statement executed by the new thread. The effects of the code that led up to the creation of the new thread are visible to the new thread.
*   When a thread terminates and causes a `Thread.join` in another thread to return, then all the statements executed by the terminated thread have a happens-before relationship with all the statements following the successful join. The effects of the code in the thread are now visible to the thread that performed the join.

For a list of actions that create happens-before relationships, refer to the [Summary page of the `java.util.concurrent` package.](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#MemoryVisibility).

<a name="sec_11_11"></a>
## 11.11. [Synchronized Methods](#sec_11_11)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html

The Java programming language provides two basic synchronization idioms: _synchronized methods_ and _synchronized statements_. The more complex of the two, synchronized statements, are described in the next section. This section is about synchronized methods.

To make a method synchronized, simply add the `synchronized` keyword to its declaration:

```java
public class SynchronizedCounter {
    private int c = 0;

    public synchronized void increment() {
        c++;
    }

    public synchronized void decrement() {
        c--;
    }

    public synchronized int value() {
        return c;
    }
}
```

If `count` is an instance of `SynchronizedCounter`, then making these methods synchronized has two effects:

*   First, it is not possible for two invocations of synchronized methods on the same object to interleave. When one thread is executing a synchronized method for an object, all other threads that invoke synchronized methods for the same object block (suspend execution) until the first thread is done with the object.
*   Second, when a synchronized method exits, it automatically establishes a happens-before relationship with _any subsequent invocation_ of a synchronized method for the same object. This guarantees that changes to the state of the object are visible to all threads.

Note that constructors cannot be synchronized ‚Äî using the `synchronized` keyword with a constructor is a syntax error. Synchronizing constructors doesn't make sense, because only the thread that creates an object should have access to it while it is being constructed.

* * *

**Warning:**¬†When constructing an object that will be shared between threads, be very careful that a reference to the object does not "leak" prematurely. For example, suppose you want to maintain a `List` called `instances` containing every instance of class. You might be tempted to add the following line to your constructor:

instances.add(this);

But then other threads can use `instances` to access the object before construction of the object is complete.

* * *

Synchronized methods enable a simple strategy for preventing thread interference and memory consistency errors: if an object is visible to more than one thread, all reads or writes to that object's variables are done through `synchronized` methods. (An important exception: `final` fields, which cannot be modified after the object is constructed, can be safely read through non-synchronized methods, once the object is constructed) This strategy is effective, but can present problems with [liveness](liveness.html), as we'll see later in this lesson.

<a name="sec_11_12"></a>
## 11.12. [Intrinsic Locks and Synchronization](#sec_11_12)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html

Synchronization is built around an internal entity known as the _intrinsic lock_ or _monitor lock_. (The API specification often refers to this entity simply as a "monitor.") Intrinsic locks play a role in both aspects of synchronization: enforcing exclusive access to an object's state and establishing happens-before relationships that are essential to visibility.

Every object has an intrinsic lock associated with it. By convention, a thread that needs exclusive and consistent access to an object's fields has to _acquire_ the object's intrinsic lock before accessing them, and then _release_ the intrinsic lock when it's done with them. A thread is said to _own_ the intrinsic lock between the time it has acquired the lock and released the lock. As long as a thread owns an intrinsic lock, no other thread can acquire the same lock. The other thread will block when it attempts to acquire the lock.

When a thread releases an intrinsic lock, a happens-before relationship is established between that action and any subsequent acquisition of the same lock.

Locks In Synchronized Methods
-----------------------------

When a thread invokes a synchronized method, it automatically acquires the intrinsic lock for that method's object and releases it when the method returns. The lock release occurs even if the return was caused by an uncaught exception.

You might wonder what happens when a static synchronized method is invoked, since a static method is associated with a class, not an object. In this case, the thread acquires the intrinsic lock for the `Class` object associated with the class. Thus access to class's static fields is controlled by a lock that's distinct from the lock for any instance of the class.

Synchronized Statements
-----------------------

Another way to create synchronized code is with _synchronized statements_. Unlike synchronized methods, synchronized statements must specify the object that provides the intrinsic lock:

```java
public void addName(String name) {
    synchronized(this) {
        lastName = name;
        nameCount++;
    }
    nameList.add(name);
}
```

In this example, the `addName` method needs to synchronize changes to `lastName` and `nameCount`, but also needs to avoid synchronizing invocations of other objects' methods. (Invoking other objects' methods from synchronized code can create problems that are described in the section on [Liveness](liveness.html).) Without synchronized statements, there would have to be a separate, unsynchronized method for the sole purpose of invoking `nameList.add`.

Synchronized statements are also useful for improving concurrency with fine-grained synchronization. Suppose, for example, class `MsLunch` has two instance fields, `c1` and `c2`, that are never used together. All updates of these fields must be synchronized, but there's no reason to prevent an update of c1 from being interleaved with an update of c2 ‚Äî and doing so reduces concurrency by creating unnecessary blocking. Instead of using synchronized methods or otherwise using the lock associated with `this`, we create two objects solely to provide locks.

```java
public class MsLunch {
    private long c1 = 0;
    private long c2 = 0;
    private Object lock1 = new Object();
    private Object lock2 = new Object();

    public void inc1() {
        synchronized(lock1) {
            c1++;
        }
    }

    public void inc2() {
        synchronized(lock2) {
            c2++;
        }
    }
}
```

Use this idiom with extreme care. You must be absolutely sure that it really is safe to interleave access of the affected fields.

Reentrant Synchronization
-------------------------

Recall that a thread cannot acquire a lock owned by another thread. But a thread _can_ acquire a lock that it already owns. Allowing a thread to acquire the same lock more than once enables _reentrant synchronization_. This describes a situation where synchronized code, directly or indirectly, invokes a method that also contains synchronized code, and both sets of code use the same lock. Without reentrant synchronization, synchronized code would have to take many additional precautions to avoid having a thread cause itself to block.

<a name="sec_11_13"></a>
## 11.13. [Atomic Access](#sec_11_13)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html

In programming, an _atomic_ action is one that effectively happens all at once. An atomic action cannot stop in the middle: it either happens completely, or it doesn't happen at all. No side effects of an atomic action are visible until the action is complete.

We have already seen that an increment expression, such as `c++`, does not describe an atomic action. Even very simple expressions can define complex actions that can decompose into other actions. However, there are actions you can specify that are atomic:

*   Reads and writes are atomic for reference variables and for most primitive variables (all types except `long` and `double`).
*   Reads and writes are atomic for _all_ variables declared `volatile` (_including_ `long` and `double` variables).

Atomic actions cannot be interleaved, so they can be used without fear of thread interference. However, this does not eliminate all need to synchronize atomic actions, because memory consistency errors are still possible. Using `volatile` variables reduces the risk of memory consistency errors, because any write to a `volatile` variable establishes a happens-before relationship with subsequent reads of that same variable. This means that changes to a `volatile` variable are always visible to other threads. What's more, it also means that when a thread reads a `volatile` variable, it sees not just the latest change to the `volatile`, but also the side effects of the code that led up the change.

Using simple atomic variable access is more efficient than accessing these variables through synchronized code, but requires more care by the programmer to avoid memory consistency errors. Whether the extra effort is worthwhile depends on the size and complexity of the application.

Some of the classes in the [`java.util.concurrent`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html) package provide atomic methods that do not rely on synchronization. We'll discuss them in the section on [High Level Concurrency Objects](highlevel.html).

<a name="sec_11_14"></a>
## 11.14. [Liveness](#sec_11_14)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/liveness.html

A concurrent application's ability to execute in a timely manner is known as its _liveness_. This section describes the most common kind of liveness problem, [deadlock](deadlock.html), and goes on to briefly describe two other liveness problems, [starvation and livelock](starvelive.html).

<a name="sec_11_15"></a>
## 11.15. [Deadlock](#sec_11_15)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/deadlock.html

_Deadlock_ describes a situation where two or more threads are blocked forever, waiting for each other. Here's an example.

Alphonse and Gaston are friends, and great believers in courtesy. A strict rule of courtesy is that when you bow to a friend, you must remain bowed until your friend has a chance to return the bow. Unfortunately, this rule does not account for the possibility that two friends might bow to each other at the same time. This example application, [`` `Deadlock` ``](https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/Deadlock.java), models this possibility:

```java
public class Deadlock {
    static class Friend {
        private final String name;
        public Friend(String name) {
            this.name = name;
        }
        public String getName() {
            return this.name;
        }
        public synchronized void bow(Friend bower) {
            System.out.format("%s: %s"
                + "  has bowed to me!%n", 
                this.name, bower.getName());
            bower.bowBack(this);
        }
        public synchronized void bowBack(Friend bower) {
            System.out.format("%s: %s"
                + " has bowed back to me!%n",
                this.name, bower.getName());
        }
    }

    public static void main(String[] args) {
        final Friend alphonse =
            new Friend("Alphonse");
        final Friend gaston =
            new Friend("Gaston");
        new Thread(new Runnable() {
            public void run() { alphonse.bow(gaston); }
        }).start();
        new Thread(new Runnable() {
            public void run() { gaston.bow(alphonse); }
        }).start();
    }
}
```

When `Deadlock` runs, it's extremely likely that both threads will block when they attempt to invoke `bowBack`. Neither block will ever end, because each thread is waiting for the other to exit `bow`.

<a name="sec_11_16"></a>
## 11.16. [Starvation and Livelock](#sec_11_16)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/starvelive.html

Starvation and livelock are much less common a problem than deadlock, but are still problems that every designer of concurrent software is likely to encounter.

Starvation
----------

_Starvation_ describes a situation where a thread is unable to gain regular access to shared resources and is unable to make progress. This happens when shared resources are made unavailable for long periods by "greedy" threads. For example, suppose an object provides a synchronized method that often takes a long time to return. If one thread invokes this method frequently, other threads that also need frequent synchronized access to the same object will often be blocked.

Livelock
--------

A thread often acts in response to the action of another thread. If the other thread's action is also a response to the action of another thread, then _livelock_ may result. As with deadlock, livelocked threads are unable to make further progress. However, the threads are not blocked ‚Äî they are simply too busy responding to each other to resume work. This is comparable to two people attempting to pass each other in a corridor: Alphonse moves to his left to let Gaston pass, while Gaston moves to his right to let Alphonse pass. Seeing that they are still blocking each other, Alphone moves to his right, while Gaston moves to his left. They're still blocking each other, so...

<a name="sec_11_17"></a>
## 11.17. [Guarded Blocks](#sec_11_17)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html

Threads often have to coordinate their actions. The most common coordination idiom is the _guarded block_. Such a block begins by polling a condition that must be true before the block can proceed. There are a number of steps to follow in order to do this correctly.

Suppose, for example `guardedJoy` is a method that must not proceed until a shared variable `joy` has been set by another thread. Such a method could, in theory, simply loop until the condition is satisfied, but that loop is wasteful, since it executes continuously while waiting.

```java
public void guardedJoy() {
    // Simple loop guard. Wastes
    // processor time. Don't do this!
    while(!joy) {}
    System.out.println("Joy has been achieved!");
}
```

A more efficient guard invokes [`Object.wait`](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait--) to suspend the current thread. The invocation of `wait` does not return until another thread has issued a notification that some special event may have occurred ‚Äî though not necessarily the event this thread is waiting for:

```java
public synchronized void guardedJoy() {
    // This guard only loops once for each special event, which may not
    // be the event we're waiting for.
    while(!joy) {
        try {
            wait();
        } catch (InterruptedException e) {}
    }
    System.out.println("Joy and efficiency have been achieved!");
}
```

* * *

**Note:**¬†Always invoke `wait` inside a loop that tests for the condition being waited for. Don't assume that the interrupt was for the particular condition you were waiting for, or that the condition is still true.

* * *

Like many methods that suspend execution, `wait` can throw `InterruptedException`. In this example, we can just ignore that exception ‚Äî we only care about the value of `joy`.

Why is this version of `guardedJoy` synchronized? Suppose `d` is the object we're using to invoke `wait`. When a thread invokes `d.wait`, it must own the intrinsic lock for `d` ‚Äî otherwise an error is thrown. Invoking `wait` inside a synchronized method is a simple way to acquire the intrinsic lock.

When `wait` is invoked, the thread releases the lock and suspends execution. At some future time, another thread will acquire the same lock and invoke [`Object.notifyAll`](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll--), informing all threads waiting on that lock that something important has happened:

```java
public synchronized notifyJoy() {
    joy = true;
    notifyAll();
}
```

Some time after the second thread has released the lock, the first thread reacquires the lock and resumes by returning from the invocation of `wait`.

* * *

**Note:**¬†There is a second notification method, `notify`, which wakes up a single thread. Because `notify` doesn't allow you to specify the thread that is woken up, it is useful only in massively parallel applications ‚Äî that is, programs with a large number of threads, all doing similar chores. In such an application, you don't care which thread gets woken up.

* * *

Let's use guarded blocks to create a _Producer-Consumer_ application. This kind of application shares data between two threads: the _producer_, that creates the data, and the _consumer_, that does something with it. The two threads communicate using a shared object. Coordination is essential: the consumer thread must not attempt to retrieve the data before the producer thread has delivered it, and the producer thread must not attempt to deliver new data if the consumer hasn't retrieved the old data.

In this example, the data is a series of text messages, which are shared through an object of type [`` `Drop` ``](examples/Drop.java):

```java
public class Drop {
    // Message sent from producer
    // to consumer.
    private String message;
    // True if consumer should wait
    // for producer to send message,
    // false if producer should wait for
    // consumer to retrieve message.
    private boolean empty = true;

    public synchronized String take() {
        // Wait until message is
        // available.
        while (empty) {
            try {
                wait();
            } catch (InterruptedException e) {}
        }
        // Toggle status.
        empty = true;
        // Notify producer that
        // status has changed.
        notifyAll();
        return message;
    }

    public synchronized void put(String message) {
        // Wait until message has
        // been retrieved.
        while (!empty) {
            try { 
                wait();
            } catch (InterruptedException e) {}
        }
        // Toggle status.
        empty = false;
        // Store message.
        this.message = message;
        // Notify consumer that status
        // has changed.
        notifyAll();
    }
}
```

The producer thread, defined in [`` `Producer` ``](examples/Producer.java), sends a series of familiar messages. The string "DONE" indicates that all messages have been sent. To simulate the unpredictable nature of real-world applications, the producer thread pauses for random intervals between messages.

```java
import java.util.Random;

public class Producer implements Runnable {
    private Drop drop;

    public Producer(Drop drop) {
        this.drop = drop;
    }

    public void run() {
        String importantInfo[] = {
            "Mares eat oats",
            "Does eat oats",
            "Little lambs eat ivy",
            "A kid will eat ivy too"
        };
        Random random = new Random();

        for (int i = 0;
             i < importantInfo.length;
             i++) {
            drop.put(importantInfo[i]);
            try {
                Thread.sleep(random.nextInt(5000));
            } catch (InterruptedException e) {}
        }
        drop.put("DONE");
    }
}
```

The consumer thread, defined in [`` `Consumer` ``](examples/Consumer.java), simply retrieves the messages and prints them out, until it retrieves the "DONE" string. This thread also pauses for random intervals.

```java
import java.util.Random;

public class Consumer implements Runnable {
    private Drop drop;

    public Consumer(Drop drop) {
        this.drop = drop;
    }

    public void run() {
        Random random = new Random();
        for (String message = drop.take();
             ! message.equals("DONE");
             message = drop.take()) {
            System.out.format("MESSAGE RECEIVED: %s%n", message);
            try {
                Thread.sleep(random.nextInt(5000));
            } catch (InterruptedException e) {}
        }
    }
}
```

Finally, here is the main thread, defined in [`` `ProducerConsumerExample` ``](examples/ProducerConsumerExample.java), that launches the producer and consumer threads.

```java
public class ProducerConsumerExample {
    public static void main(String[] args) {
        Drop drop = new Drop();
        (new Thread(new Producer(drop))).start();
        (new Thread(new Consumer(drop))).start();
    }
}
```

* * *

**Note:**¬†The `Drop` class was written in order to demonstrate guarded blocks. To avoid re-inventing the wheel, examine the existing data structures in the [Java Collections Framework](../../collections/index.html) before trying to code your own data-sharing objects. For more information, refer to the [Questions and Exercises](QandE/questions.html) section.

* * *

<a name="sec_11_18"></a>
## 11.18. [Immutable Objects](#sec_11_18)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/immutable.html

An object is considered _immutable_ if its state cannot change after it is constructed. Maximum reliance on immutable objects is widely accepted as a sound strategy for creating simple, reliable code.

Immutable objects are particularly useful in concurrent applications. Since they cannot change state, they cannot be corrupted by thread interference or observed in an inconsistent state.

Programmers are often reluctant to employ immutable objects, because they worry about the cost of creating a new object as opposed to updating an object in place. The impact of object creation is often overestimated, and can be offset by some of the efficiencies associated with immutable objects. These include decreased overhead due to garbage collection, and the elimination of code needed to protect mutable objects from corruption.

The following subsections take a class whose instances are mutable and derives a class with immutable instances from it. In so doing, they give general rules for this kind of conversion and demonstrate some of the advantages of immutable objects.

<a name="sec_11_19"></a>
## 11.19. [A Synchronized Class Example](#sec_11_19)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/syncrgb.html

The class, [`` `SynchronizedRGB` ``](https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/SynchronizedRGB.java), defines objects that represent colors. Each object represents the color as three integers that stand for primary color values and a string that gives the name of the color.

```java
public class SynchronizedRGB {

    // Values must be between 0 and 255.
    private int red;
    private int green;
    private int blue;
    private String name;

    private void check(int red,
                       int green,
                       int blue) {
        if (red < 0 || red > 255
            || green < 0 || green > 255
            || blue < 0 || blue > 255) {
            throw new IllegalArgumentException();
        }
    }

    public SynchronizedRGB(int red,
                           int green,
                           int blue,
                           String name) {
        check(red, green, blue);
        this.red = red;
        this.green = green;
        this.blue = blue;
        this.name = name;
    }

    public void set(int red,
                    int green,
                    int blue,
                    String name) {
        check(red, green, blue);
        synchronized (this) {
            this.red = red;
            this.green = green;
            this.blue = blue;
            this.name = name;
        }
    }

    public synchronized int getRGB() {
        return ((red << 16) | (green << 8) | blue);
    }

    public synchronized String getName() {
        return name;
    }

    public synchronized void invert() {
        red = 255 - red;
        green = 255 - green;
        blue = 255 - blue;
        name = "Inverse of " + name;
    }
}
```

`SynchronizedRGB` must be used carefully to avoid being seen in an inconsistent state. Suppose, for example, a thread executes the following code:

SynchronizedRGB color =
    new SynchronizedRGB(0, 0, 0, "Pitch Black");
...
int myColorInt = color.getRGB();      //Statement 1
String myColorName = color.getName(); //Statement 2

If another thread invokes `color.set` after Statement 1 but before Statement 2, the value of `myColorInt` won't match the value of `myColorName`. To avoid this outcome, the two statements must be bound together:

synchronized (color) {
    int myColorInt = color.getRGB();
    String myColorName = color.getName();
} 

This kind of inconsistency is only possible for mutable objects ‚Äî it will not be an issue for the immutable version of `SynchronizedRGB`.

<a name="sec_11_20"></a>
## 11.20. [A Strategy for Defining Immutable Objects](#sec_11_20)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/imstrat.html

The following rules define a simple strategy for creating immutable objects. Not all classes documented as "immutable" follow these rules. This does not necessarily mean the creators of these classes were sloppy ‚Äî they may have good reason for believing that instances of their classes never change after construction. However, such strategies require sophisticated analysis and are not for beginners.

1.  Don't provide "setter" methods ‚Äî methods that modify fields or objects referred to by fields.
2.  Make all fields `final` and `private`.
3.  Don't allow subclasses to override methods. The simplest way to do this is to declare the class as `final`. A more sophisticated approach is to make the constructor `private` and construct instances in factory methods.
4.  If the instance fields include references to mutable objects, don't allow those objects to be changed:
    *   Don't provide methods that modify the mutable objects.
    *   Don't share references to the mutable objects. Never store references to external, mutable objects passed to the constructor; if necessary, create copies, and store references to the copies. Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods.

Applying this strategy to `SynchronizedRGB` results in the following steps:

1.  There are two setter methods in this class. The first one, `set`, arbitrarily transforms the object, and has no place in an immutable version of the class. The second one, `invert`, can be adapted by having it create a new object instead of modifying the existing one.
2.  All fields are already `private`; they are further qualified as `final`.
3.  The class itself is declared `final`.
4.  Only one field refers to an object, and that object is itself immutable. Therefore, no safeguards against changing the state of "contained" mutable objects are necessary.

After these changes, we have [`` `ImmutableRGB` ``](https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/ImmutableRGB.java):

```java
final public class ImmutableRGB {

    // Values must be between 0 and 255.
    final private int red;
    final private int green;
    final private int blue;
    final private String name;

    private void check(int red,
                       int green,
                       int blue) {
        if (red < 0 || red > 255
            || green < 0 || green > 255
            || blue < 0 || blue > 255) {
            throw new IllegalArgumentException();
        }
    }

    public ImmutableRGB(int red,
                        int green,
                        int blue,
                        String name) {
        check(red, green, blue);
        this.red = red;
        this.green = green;
        this.blue = blue;
        this.name = name;
    }


    public int getRGB() {
        return ((red << 16) | (green << 8) | blue);
    }

    public String getName() {
        return name;
    }

    public ImmutableRGB invert() {
        return new ImmutableRGB(255 - red,
                       255 - green,
                       255 - blue,
                       "Inverse of " + name);
    }
}
```

<a name="sec_11_21"></a>
## 11.21. [High Level Concurrency Objects](#sec_11_21)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/highlevel.html

So far, this lesson has focused on the low-level APIs that have been part of the Java platform from the very beginning. These APIs are adequate for very basic tasks, but higher-level building blocks are needed for more advanced tasks. This is especially true for massively concurrent applications that fully exploit today's multiprocessor and multi-core systems.

In this section we'll look at some of the high-level concurrency features introduced with version 5.0 of the Java platform. Most of these features are implemented in the new `java.util.concurrent` packages. There are also new concurrent data structures in the Java Collections Framework.

*   [Lock objects](newlocks.html) support locking idioms that simplify many concurrent applications.
*   [Executors](executors.html) define a high-level API for launching and managing threads. Executor implementations provided by `java.util.concurrent` provide thread pool management suitable for large-scale applications.
*   [Concurrent collections](collections.html) make it easier to manage large collections of data, and can greatly reduce the need for synchronization.
*   [Atomic variables](atomicvars.html) have features that minimize synchronization and help avoid memory consistency errors.
*   [`ThreadLocalRandom`](threadlocalrandom.html) (in JDK 7) provides efficient generation of pseudo-random numbers from multiple threads.

<a name="sec_11_22"></a>
## 11.22. [Lock Objects](#sec_11_22)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/newlocks.html

Synchronized code relies on a simple kind of reentrant lock. This kind of lock is easy to use, but has many limitations. More sophisticated locking idioms are supported by the [`java.util.concurrent.locks`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/package-summary.html) package. We won't examine this package in detail, but instead will focus on its most basic interface, [`Lock`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html).

`Lock` objects work very much like the implicit locks used by synchronized code. As with implicit locks, only one thread can own a `Lock` object at a time. `Lock` objects also support a `wait/notify` mechanism, through their associated [`Condition`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html) objects.

The biggest advantage of `Lock` objects over implicit locks is their ability to back out of an attempt to acquire a lock. The `tryLock` method backs out if the lock is not available immediately or before a timeout expires (if specified). The `lockInterruptibly` method backs out if another thread sends an interrupt before the lock is acquired.

Let's use `Lock` objects to solve the deadlock problem we saw in [Liveness](liveness.html). Alphonse and Gaston have trained themselves to notice when a friend is about to bow. We model this improvement by requiring that our `Friend` objects must acquire locks for _both_ participants before proceeding with the bow. Here is the source code for the improved model, [`` `Safelock` ``](examples/Safelock.java). To demonstrate the versatility of this idiom, we assume that Alphonse and Gaston are so infatuated with their newfound ability to bow safely that they can't stop bowing to each other:

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.Random;

public class Safelock {
    static class Friend {
        private final String name;
        private final Lock lock = new ReentrantLock();

        public Friend(String name) {
            this.name = name;
        }

        public String getName() {
            return this.name;
        }

        public boolean impendingBow(Friend bower) {
            Boolean myLock = false;
            Boolean yourLock = false;
            try {
                myLock = lock.tryLock();
                yourLock = bower.lock.tryLock();
            } finally {
                if (! (myLock && yourLock)) {
                    if (myLock) {
                        lock.unlock();
                    }
                    if (yourLock) {
                        bower.lock.unlock();
                    }
                }
            }
            return myLock && yourLock;
        }
            
        public void bow(Friend bower) {
            if (impendingBow(bower)) {
                try {
                    System.out.format("%s: %s has"
                        + " bowed to me!%n", 
                        this.name, bower.getName());
                    bower.bowBack(this);
                } finally {
                    lock.unlock();
                    bower.lock.unlock();
                }
            } else {
                System.out.format("%s: %s started"
                    + " to bow to me, but saw that"
                    + " I was already bowing to"
                    + " him.%n",
                    this.name, bower.getName());
            }
        }

        public void bowBack(Friend bower) {
            System.out.format("%s: %s has" +
                " bowed back to me!%n",
                this.name, bower.getName());
        }
    }

    static class BowLoop implements Runnable {
        private Friend bower;
        private Friend bowee;

        public BowLoop(Friend bower, Friend bowee) {
            this.bower = bower;
            this.bowee = bowee;
        }
    
        public void run() {
            Random random = new Random();
            for (;;) {
                try {
                    Thread.sleep(random.nextInt(10));
                } catch (InterruptedException e) {}
                bowee.bow(bower);
            }
        }
    }
            

    public static void main(String[] args) {
        final Friend alphonse =
            new Friend("Alphonse");
        final Friend gaston =
            new Friend("Gaston");
        new Thread(new BowLoop(alphonse, gaston)).start();
        new Thread(new BowLoop(gaston, alphonse)).start();
    }
}
```

<a name="sec_11_23"></a>
## 11.23. [Executors](#sec_11_23)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/executors.html

In all of the previous examples, there's a close connection between the task being done by a new thread, as defined by its `Runnable` object, and the thread itself, as defined by a `Thread` object. This works well for small applications, but in large-scale applications, it makes sense to separate thread management and creation from the rest of the application. Objects that encapsulate these functions are known as _executors_. The following subsections describe executors in detail.

*   [Executor Interfaces](exinter.html) define the three executor object types.
*   [Thread Pools](pools.html) are the most common kind of executor implementation.
*   [Fork/Join](forkjoin.html) is a framework (new in JDK 7) for taking advantage of multiple processors.

<a name="sec_11_24"></a>
## 11.24. [Executor Interfaces](#sec_11_24)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/exinter.html

The `java.util.concurrent` package defines three executor interfaces:

*   `Executor`, a simple interface that supports launching new tasks.
*   `ExecutorService`, a subinterface of `Executor`, which adds features that help manage the life cycle, both of the individual tasks and of the executor itself.
*   `ScheduledExecutorService`, a subinterface of `ExecutorService`, supports future and/or periodic execution of tasks.

Typically, variables that refer to executor objects are declared as one of these three interface types, not with an executor class type.

The `Executor` Interface
------------------------

The [`Executor`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html) interface provides a single method, `execute`, designed to be a drop-in replacement for a common thread-creation idiom. If `r` is a `Runnable` object, and `e` is an `Executor` object you can replace

(new Thread(r)).start();

with

e.execute(r);

However, the definition of `execute` is less specific. The low-level idiom creates a new thread and launches it immediately. Depending on the `Executor` implementation, `execute` may do the same thing, but is more likely to use an existing worker thread to run `r`, or to place `r` in a queue to wait for a worker thread to become available. (We'll describe worker threads in the section on [Thread Pools](pools.html).)

The executor implementations in `java.util.concurrent` are designed to make full use of the more advanced `ExecutorService` and `ScheduledExecutorService` interfaces, although they also work with the base `Executor` interface.

The `ExecutorService` Interface
-------------------------------

The [`ExecutorService`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html) interface supplements `execute` with a similar, but more versatile `submit` method. Like `execute`, `submit` accepts `Runnable` objects, but also accepts [`Callable`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html) objects, which allow the task to return a value. The `submit` method returns a [`Future`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html) object, which is used to retrieve the `Callable` return value and to manage the status of both `Callable` and `Runnable` tasks.

`ExecutorService` also provides methods for submitting large collections of `Callable` objects. Finally, `ExecutorService` provides a number of methods for managing the shutdown of the executor. To support immediate shutdown, tasks should handle [interrupts](interrupt.html) correctly.

The `ScheduledExecutorService` Interface
----------------------------------------

The [`ScheduledExecutorService`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html) interface supplements the methods of its parent `ExecutorService` with `schedule`, which executes a `Runnable` or `Callable` task after a specified delay. In addition, the interface defines `scheduleAtFixedRate` and `scheduleWithFixedDelay`, which executes specified tasks repeatedly, at defined intervals.

<a name="sec_11_25"></a>
## 11.25. [Thread Pools](#sec_11_25)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html

Most of the executor implementations in `java.util.concurrent` use _thread pools_, which consist of _worker threads_. This kind of thread exists separately from the `Runnable` and `Callable` tasks it executes and is often used to execute multiple tasks.

Using worker threads minimizes the overhead due to thread creation. Thread objects use a significant amount of memory, and in a large-scale application, allocating and deallocating many thread objects creates a significant memory management overhead.

One common type of thread pool is the _fixed thread pool_. This type of pool always has a specified number of threads running; if a thread is somehow terminated while it is still in use, it is automatically replaced with a new thread. Tasks are submitted to the pool via an internal queue, which holds extra tasks whenever there are more active tasks than threads.

An important advantage of the fixed thread pool is that applications using it _degrade gracefully_. To understand this, consider a web server application where each HTTP request is handled by a separate thread. If the application simply creates a new thread for every new HTTP request, and the system receives more requests than it can handle immediately, the application will suddenly stop responding to _all_ requests when the overhead of all those threads exceed the capacity of the system. With a limit on the number of the threads that can be created, the application will not be servicing HTTP requests as quickly as they come in, but it will be servicing them as quickly as the system can sustain.

A simple way to create an executor that uses a fixed thread pool is to invoke the [`newFixedThreadPool`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newFixedThreadPool-int-) factory method in [`java.util.concurrent.Executors`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html) This class also provides the following factory methods:

*   The [`newCachedThreadPool`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newCachedThreadPool-int-) method creates an executor with an expandable thread pool. This executor is suitable for applications that launch many short-lived tasks.
*   The [`newSingleThreadExecutor`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newSingleThreadExecutor-int-) method creates an executor that executes a single task at a time.
*   Several factory methods are `ScheduledExecutorService` versions of the above executors.

If none of the executors provided by the above factory methods meet your needs, constructing instances of [`java.util.concurrent.ThreadPoolExecutor`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html) or [`java.util.concurrent.ScheduledThreadPoolExecutor`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html) will give you additional options.

<a name="sec_11_26"></a>
## 11.26. [Fork/Join](#sec_11_26)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html

The fork/join framework is an implementation of the `ExecutorService` interface that helps you take advantage of multiple processors. It is designed for work that can be broken into smaller pieces recursively. The goal is to use all the available processing power to enhance the performance of your application.

As with any `ExecutorService` implementation, the fork/join framework distributes tasks to worker threads in a thread pool. The fork/join framework is distinct because it uses a _work-stealing_ algorithm. Worker threads that run out of things to do can steal tasks from other threads that are still busy.

The center of the fork/join framework is the [`ForkJoinPool`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html) class, an extension of the `AbstractExecutorService` class. `ForkJoinPool` implements the core work-stealing algorithm and can execute [`ForkJoinTask`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html) processes.

Basic Use
---------

The first step for using the fork/join framework is to write code that performs a segment of the work. Your code should look similar to the following pseudocode:

if (my portion of the work is small enough)
  do the work directly
else
  split my work into two pieces
  invoke the two pieces and wait for the results

Wrap this code in a `ForkJoinTask` subclass, typically using one of its more specialized types, either [`RecursiveTask`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveTask.html) (which can return a result) or [`RecursiveAction`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveAction.html).

After your `ForkJoinTask` subclass is ready, create the object that represents all the work to be done and pass it to the `invoke()` method of a `ForkJoinPool` instance.

Blurring for Clarity
--------------------

To help you understand how the fork/join framework works, consider the following example. Suppose that you want to blur an image. The original _source_ image is represented by an array of integers, where each integer contains the color values for a single pixel. The blurred _destination_ image is also represented by an integer array with the same size as the source.

Performing the blur is accomplished by working through the source array one pixel at a time. Each pixel is averaged with its surrounding pixels (the red, green, and blue components are averaged), and the result is placed in the destination array. Since an image is a large array, this process can take a long time. You can take advantage of concurrent processing on multiprocessor systems by implementing the algorithm using the fork/join framework. Here is one possible implementation:

```java
public class ForkBlur extends RecursiveAction {
    private int[] mSource;
    private int mStart;
    private int mLength;
    private int[] mDestination;
  
    // Processing window size; should be odd.
    private int mBlurWidth = 15;
  
    public ForkBlur(int[] src, int start, int length, int[] dst) {
        mSource = src;
        mStart = start;
        mLength = length;
        mDestination = dst;
    }

    protected void computeDirectly() {
        int sidePixels = (mBlurWidth - 1) / 2;
        for (int index = mStart; index < mStart + mLength; index++) {
            // Calculate average.
            float rt = 0, gt = 0, bt = 0;
            for (int mi = -sidePixels; mi <= sidePixels; mi++) {
                int mindex = Math.min(Math.max(mi + index, 0),
                                    mSource.length - 1);
                int pixel = mSource[mindex];
                rt += (float)((pixel & 0x00ff0000) >> 16)
                      / mBlurWidth;
                gt += (float)((pixel & 0x0000ff00) >>  8)
                      / mBlurWidth;
                bt += (float)((pixel & 0x000000ff) >>  0)
                      / mBlurWidth;
            }
          
            // Reassemble destination pixel.
            int dpixel = (0xff000000     ) |
                   (((int)rt) << 16) |
                   (((int)gt) <<  8) |
                   (((int)bt) <<  0);
            mDestination[index] = dpixel;
        }
    }
  
  ...
```

Now you implement the abstract `compute()` method, which either performs the blur directly or splits it into two smaller tasks. A simple array length threshold helps determine whether the work is performed or split.

```java
protected static int sThreshold = 100000;

protected void compute() {
    if (mLength < sThreshold) {
        computeDirectly();
        return;
    }
    
    int split = mLength / 2;
    
    invokeAll(new ForkBlur(mSource, mStart, split, mDestination),
              new ForkBlur(mSource, mStart + split, mLength - split,
                           mDestination));
}
```

If the previous methods are in a subclass of the `RecursiveAction` class, then setting up the task to run in a `ForkJoinPool` is straightforward, and involves the following steps:

1.  Create a task that represents all of the work to be done.
    
    // source image pixels are in src
    // destination image pixels are in dst
    ForkBlur fb = new ForkBlur(src, 0, src.length, dst);
    
2.  Create the `ForkJoinPool` that will run the task.
    
    ForkJoinPool pool = new ForkJoinPool();
    
3.  Run the task.
    
    pool.invoke(fb);
    

For the full source code, including some extra code that creates the destination image file, see the [`` `ForkBlur` ``](examples/ForkBlur.java) example.

Standard Implementations
------------------------

Besides using the fork/join framework to implement custom algorithms for tasks to be performed concurrently on a multiprocessor system (such as the `ForkBlur.java` example in the previous section), there are some generally useful features in Java SE which are already implemented using the fork/join framework. One such implementation, introduced in Java SE 8, is used by the [`java.util.Arrays`](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html) class for its `parallelSort()` methods. These methods are similar to `sort()`, but leverage concurrency via the fork/join framework. Parallel sorting of large arrays is faster than sequential sorting when run on multiprocessor systems. However, how exactly the fork/join framework is leveraged by these methods is outside the scope of the Java Tutorials. For this information, see the Java API documentation.

Another implementation of the fork/join framework is used by methods in the `java.util.streams` package, which is part of [Project Lambda](http://openjdk.java.net/projects/lambda/) scheduled for the Java SE 8 release. For more information, see the [Lambda Expressions](../../java/javaOO/lambdaexpressions.html) section.


<a name="sec_11_27"></a>
## 11.27. [Concurrent Collections](#sec_11_27)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/collections.html

The `java.util.concurrent` package includes a number of additions to the Java Collections Framework. These are most easily categorized by the collection interfaces provided:

*   [`BlockingQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html) defines a first-in-first-out data structure that blocks or times out when you attempt to add to a full queue, or retrieve from an empty queue.
*   [`ConcurrentMap`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html) is a subinterface of [`java.util.Map`](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html) that defines useful atomic operations. These operations remove or replace a key-value pair only if the key is present, or add a key-value pair only if the key is absent. Making these operations atomic helps avoid synchronization. The standard general-purpose implementation of `ConcurrentMap` is [`ConcurrentHashMap`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html), which is a concurrent analog of [`HashMap`](https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html).
*   [`ConcurrentNavigableMap`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentNavigableMap.html) is a subinterface of `ConcurrentMap` that supports approximate matches. The standard general-purpose implementation of `ConcurrentNavigableMap` is [`ConcurrentSkipListMap`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentSkipListMap.html), which is a concurrent analog of [`TreeMap`](https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html).

All of these collections help avoid [Memory Consistency Errors](memconsist.html) by defining a happens-before relationship between an operation that adds an object to the collection with subsequent operations that access or remove that object.


<a name="sec_11_28"></a>
## 11.28. [Atomic Variables](#sec_11_28)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/atomicvars.html

The [`java.util.concurrent.atomic`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html) package defines classes that support atomic operations on single variables. All classes have `get` and `set` methods that work like reads and writes on `volatile` variables. That is, a `set` has a happens-before relationship with any subsequent `get` on the same variable. The atomic `compareAndSet` method also has these memory consistency features, as do the simple atomic arithmetic methods that apply to integer atomic variables.

To see how this package might be used, let's return to the [`` `Counter` ``](https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/Counter.java) class we originally used to demonstrate thread interference:

```java
class Counter {
    private int c = 0;

    public void increment() {
        c++;
    }

    public void decrement() {
        c--;
    }

    public int value() {
        return c;
    }

}
```

One way to make `Counter` safe from thread interference is to make its methods synchronized, as in [`` `SynchronizedCounter` ``](https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/SynchronizedCounter.java):

```java
class SynchronizedCounter {
    private int c = 0;

    public synchronized void increment() {
        c++;
    }

    public synchronized void decrement() {
        c--;
    }

    public synchronized int value() {
        return c;
    }

}
```

For this simple class, synchronization is an acceptable solution. But for a more complicated class, we might want to avoid the liveness impact of unnecessary synchronization. Replacing the `int` field with an `AtomicInteger` allows us to prevent thread interference without resorting to synchronization, as in [`` `AtomicCounter` ``](https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/AtomicCounter.java):

```java
import java.util.concurrent.atomic.AtomicInteger;

class AtomicCounter {
    private AtomicInteger c = new AtomicInteger(0);

    public void increment() {
        c.incrementAndGet();
    }

    public void decrement() {
        c.decrementAndGet();
    }

    public int value() {
        return c.get();
    }

}
```


<a name="sec_11_29"></a>
## 11.29. [Concurrent Random Numbers](#sec_11_29)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/threadlocalrandom.html

In JDK 7, [`java.util.concurrent`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html) includes a convenience class, [`ThreadLocalRandom`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadLocalRandom.html), for applications that expect to use random numbers from multiple threads or `ForkJoinTask`s.

For concurrent access, using `ThreadLocalRandom` instead of `Math.random()` results in less contention and, ultimately, better performance.

All you need to do is call `ThreadLocalRandom.current()`, then call one of its methods to retrieve a random number. Here is one example:

int r = ThreadLocalRandom.current() .nextInt(4, 77);


<a name="sec_11_30"></a>
## 11.30. [For Further Reading](#sec_11_30)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/further.html

*   _Concurrent Programming in Java: Design Principles and Pattern (2nd Edition)_ by Doug Lea. A comprehensive work by a leading expert, who's also the architect of the Java platform's concurrency framework.
*   _Java Concurrency in Practice_ by Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea. A practical guide designed to be accessible to the novice.
*   _Effective Java Programming Language Guide (2nd Edition)_ by Joshua Bloch. Though this is a general programming guide, its chapter on threads contains essential "best practices" for concurrent programming.
*   _Concurrency: State Models & Java Programs (2nd Edition)_, by Jeff Magee and Jeff Kramer. An introduction to concurrent programming through a combination of modeling and practical examples.
*   _[Java Concurrent Animated](http://sourceforge.net/projects/javaconcurrenta/):_ Animations that show usage of concurrency features.


<a name="sec_11_31"></a>
## 11.31. [Questions and Exercises](#sec_11_31)
******
https://docs.oracle.com/javase/tutorial/essential/concurrency/QandE/questions.html
https://docs.oracle.com/javase/tutorial/essential/concurrency/QandE/answers.html

Questions
---------

1.  Can you pass a `Thread` object to `Executor.execute`? Would such an invocation make sense?

Exercises
---------

1.  Compile and run [`` `BadThreads.java` ``](BadThreads.java):
    
    ```java
    public class BadThreads {
        
            static String message;
        
            private static class CorrectorThread
                extends Thread {
        
                public void run() {
                    try {
                        sleep(1000); 
                    } catch (InterruptedException e) {}
                    // Key statement 1:
                    message = "Mares do eat oats."; 
                }
            }
        
            public static void main(String args[])
                throws InterruptedException {
        
                (new CorrectorThread()).start();
                message = "Mares do not eat oats.";
                Thread.sleep(2000);
                // Key statement 2:
                System.out.println(message);
            }
        }
    ```
    
    The application should print out "Mares do eat oats." Is it guaranteed to always do this? If not, why not? Would it help to change the parameters of the two invocations of `Sleep`? How would you guarantee that all changes to `message` will be visible in the main thread?
    
2.  Modify the producer-consumer example in [Guarded Blocks](../guardmeth.html) to use a standard library class instead of the `Drop` class.

[Check your answers.](answers.html)


Questions
---------

1.  **Question:** Can you pass a `Thread` object to `Executor.execute`? Would such an invocation make sense? Why or why not?
    
    **Answer:** `Thread` implements the `Runnable` interface, so you can pass an instance of `Thread` to `Executor.execute`. However it doesn't make sense to use `Thread` objects this way. If the object is directly instantiated from `Thread`, its `run` method doesn't do anything. You can define a subclass of `Thread` with a useful `run` method ‚Äî but such a class would implement features that the executor would not use.
    

Exercises
---------

1.  **Exercise:** Compile and run [`` `BadThreads.java` ``](https://docs.oracle.com/javase/tutorial/essential/concurrency/QandE/BadThreads.java):
    
    ```java
    public class BadThreads {
        
            static String message;
        
            private static class CorrectorThread
                extends Thread {
        
                public void run() {
                    try {
                        sleep(1000); 
                    } catch (InterruptedException e) {}
                    // Key statement 1:
                    message = "Mares do eat oats."; 
                }
            }
        
            public static void main(String args[])
                throws InterruptedException {
        
                (new CorrectorThread()).start();
                message = "Mares do not eat oats.";
                Thread.sleep(2000);
                // Key statement 2:
                System.out.println(message);
            }
        }
    ```
    
    The application should print out "Mares do eat oats." Is it guaranteed to always do this? If not, why not? Would it help to change the parameters of the two invocations of `Sleep`? How would you guarantee that all changes to `message` will be visible to the main thread?
    
    **Solution:** The program will almost always print out "Mares do eat oats." However, this result is not guaranteed, because there is no happens-before relationship between "Key statement 1" and "Key statement 2". This is true even if "Key statement 1" actually executes before "Key statement 2" ‚Äî remember, a happens-before relationship is about visibility, not sequence.
    
    There are two ways you can guarantee that all changes to `message` will be visible to the main thread:
    
    *   In the main thread, retain a reference to the `CorrectorThread` instance. Then invoke `join` on that instance before referring to `message`
    *   Encapsulate `message` in an object with synchronized methods. Never reference `message` except through those methods.
    
    Both of these techniques establish the necessary happens-before relationship, making changes to `message` visible.
    
    A third technique is to simply declare `message` as `volatile`. This guarantees that any write to `message` (as in "Key statement 1") will have a happens-before relationship with any subsequent reads of `message` (as in "Key statement 2"). But it does not guarantee that "Key statement 1" will _literally_ happen before "Key statement 2". They will _probably_ happen in sequence, but because of scheduling uncertainties and the unknown granularity of `sleep`, this is not guaranteed.
    
    Changing the arguments of the two `sleep` invocations does not help either, since this does nothing to guarantee a happens-before relationship.
    
2.  **Exercise:** Modify the producer-consumer example in [Guarded Blocks](../guardmeth.html) to use a standard library class instead of the `Drop` class.
    
    **Solution:** The [`java.util.concurrent.BlockingQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html) interface defines a `get` method that blocks if the queue is empty, and a `put` methods that blocks if the queue is full. These are effectively the same operations defined by `Drop` ‚Äî except that `Drop` is not a queue! However, there's another way of looking at Drop: it's a queue with a capacity of zero. Since there's no room in the queue for _any_ elements, every `get` blocks until the corresponding `take` and every `take` blocks until the corresponding `get`. There is an implementation of `BlockingQueue` with precisely this behavior: [`java.util.concurrent.SynchronousQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/SynchronousQueue.html).
    
    `BlockingQueue` is almost a drop-in replacement for `Drop`. The main problem in [`` `Producer` ``](Producer.java) is that with `BlockingQueue`, the `put` and `get` methods throw `InterruptedException`. This means that the existing `try` must be moved up a level:
    
    ```java
    import java.util.Random;
        import java.util.concurrent.BlockingQueue;
        
        public class Producer implements Runnable {
            private BlockingQueue<String> drop;
        
            public Producer(BlockingQueue<String> drop) {
                this.drop = drop;
            }
        
            public void run() {
                String importantInfo[] = {
                    "Mares eat oats",
                    "Does eat oats",
                    "Little lambs eat ivy",
                    "A kid will eat ivy too"
                };
                Random random = new Random();
        
                try {
                    for (int i = 0;
                         i < importantInfo.length;
                         i++) {
                        drop.put(importantInfo[i]);
                        Thread.sleep(random.nextInt(5000));
                    }
                    drop.put("DONE");
                } catch (InterruptedException e) {}
            }
        }
        
        Similar changes are required for [`` `Consumer` ``](Consumer.java):
        
        import java.util.Random;
        import java.util.concurrent.BlockingQueue;
        
        public class Consumer implements Runnable {
            private BlockingQueue<String> drop;
        
            public Consumer(BlockingQueue<String> drop) {
                this.drop = drop;
            }
        
            public void run() {
                Random random = new Random();
                try {
                    for (String message = drop.take();
                         ! message.equals("DONE");
                         message = drop.take()) {
                        System.out.format("MESSAGE RECEIVED: %s%n",
                                          message);
                        Thread.sleep(random.nextInt(5000));
                    }
                } catch (InterruptedException e) {}
            }
        }
        
        For [`` `ProducerConsumerExample` ``](ProducerConsumerExample.java), we simply change the declaration for the `drop` object:
        
        import java.util.concurrent.BlockingQueue;
        import java.util.concurrent.SynchronousQueue;
        
        public class ProducerConsumerExample {
            public static void main(String[] args) {
                BlockingQueue<String> drop =
                    new SynchronousQueue<String> ();
                (new Thread(new Producer(drop))).start();
                (new Thread(new Consumer(drop))).start();
            }
        }
    ```
    

<a name="sec_12"></a>
# üìú/PART 12.  [**The Platform Environment**](#sec_12)
******
https://docs.oracle.com/javase/tutorial/essential/environment/index.html 

1. [Configuration Utilities](#sec_12_1)
2. [Properties](#sec_12_2)
3. [Command-Line Arguments](#sec_12_3)
4. [Environment Variables](#sec_12_4)
5. [Other Configuration Utilities](#sec_12_5)
6. [System Utilities](#sec_12_6)
7. [Command-Line I/O Objects](#sec_12_7)
8. [System Properties](#sec_12_8)
9. [The Security Manager](#sec_12_9)
10. [Miscellaneous Methods in System](#sec_12_10)
11. [PATH and CLASSPATH](#sec_12_11)
12. [Questions and Exercises](#sec_12_12)

An application runs in a _platform environment_, defined by the underlying operating system, the Java virtual machine, the class libraries, and various configuration data supplied when the application is launched. This lesson describes some of the APIs an application uses to examine and configure its platform environment. The lesson consists of three sections:

*   [Configuration Utilities](config.html) describes APIs used to access configuration data supplied when the application is deployed, or by the application's user.
*   [System Utilities](system.html) describes miscellaneous APIs defined in the `System` and `Runtime` classes.
*   [PATH and CLASSPATH](paths.html) describes environment variables used to configure JDK development tools and other applications.

<a name="sec_12_1"></a>
## 12.1. [Configuration Utilities](#sec_12_1)
******
https://docs.oracle.com/javase/tutorial/essential/environment/config.html

This section describes some of the configuration utilities that help an application access its startup context.


<a name="sec_12_2"></a>
## 12.2. [Properties](#sec_12_2)
******
https://docs.oracle.com/javase/tutorial/essential/environment/properties.html

_Properties_ are configuration values managed as _key/value pairs_. In each pair, the key and value are both [`String`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html) values. The key identifies, and is used to retrieve, the value, much as a variable name is used to retrieve the variable's value. For example, an application capable of downloading files might use a property named "download.lastDirectory" to keep track of the directory used for the last download.

To manage properties, create instances of [`java.util.Properties`](https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html). This class provides methods for the following:

*   loading key/value pairs into a `Properties` object from a stream,
*   retrieving a value from its key,
*   listing the keys and their values,
*   enumerating over the keys, and
*   saving the properties to a stream.

For an introduction to streams, refer to the section [I/O Streams](../../essential/io/streams.html) in the [Basic I/O](../../essential/io/index.html) lesson.

`Properties` extends [`java.util.Hashtable`](https://docs.oracle.com/javase/8/docs/api/java/util/Hashtable.html). Some of the methods inherited from `Hashtable` support the following actions:

*   testing to see if a particular key or value is in the `Properties` object,
*   getting the current number of key/value pairs,
*   removing a key and its value,
*   adding a key/value pair to the `Properties` list,
*   enumerating over the values or the keys,
*   retrieving a value by its key, and
*   finding out if the `Properties` object is empty.

* * *

**Security Considerations:**¬†Access to properties is subject to approval by the current security manager. The example code segments in this section are assumed to be in standalone applications, which, by default, have no security manager. The same code in an applet may not work depending on the browser in which it is running. See [What Applets Can and Cannot Do](../../deployment/applet/security.html) in the [Java Applets](../../deployment/applet/index.html) lesson for information about security restrictions on applets.

* * *

The `System` class maintains a `Properties` object that defines the configuration of the current working environment. For more about these properties, see [System Properties](sysprop.html). The remainder of this section explains how to use properties to manage application configuration.

Properties in the Application Life Cycle
----------------------------------------

The following figure illustrates how a typical application might manage its configuration data with a `Properties` object over the course of its execution.

![Possible lifecycle of a Properties object](../../figures/essential/environment-1loads.gif)

*   `Starting Up`  
    The actions given in the first three boxes occur when the application is starting up. First, the application loads the default properties from a well-known location into a `Properties` object. Normally, the default properties are stored in a file on disk along with the `.class` and other resource files for the application.  
    Next, the application creates another `Properties` object and loads the properties that were saved from the last time the application was run. Many applications store properties on a per-user basis, so the properties loaded in this step are usually in a specific file in a particular directory maintained by this application in the user's home directory. Finally, the application uses the default and remembered properties to initialize itself.  
    The key here is consistency. The application must always load and save properties to the same location so that it can find them the next time it's executed.  
    
*   `Running`  
    During the execution of the application, the user may change some settings, perhaps in a Preferences window, and the `Properties` object is updated to reflect these changes. If the users changes are to be remembered in future sessions, they must be saved.
*   `Exiting`  
    Upon exiting, the application saves the properties to its well-known location, to be loaded again when the application is next started up.

Setting Up the Properties Object
--------------------------------

The following Java code performs the first two steps described in the previous section: loading the default properties and loading the remembered properties:

. . .
// create and load default properties
Properties defaultProps = new Properties();
FileInputStream in = new FileInputStream("defaultProperties");
defaultProps.load(in);
in.close();

// create application properties with default
Properties applicationProps = new Properties(defaultProps);

// now load properties 
// from last invocation
in = new FileInputStream("appProperties");
applicationProps.load(in);
in.close();
. . .

First, the application sets up a default `Properties` object. This object contains the set of properties to use if values are not explicitly set elsewhere. Then the load method reads the default values from a file on disk named `defaultProperties`.

Next, the application uses a different constructor to create a second `Properties` object, `applicationProps`, whose default values are contained in `defaultProps`. The defaults come into play when a property is being retrieved. If the property can't be found in `applicationProps`, then its default list is searched.

Finally, the code loads a set of properties into `applicationProps` from a file named `appProperties`. The properties in this file are those that were saved from the application the last time it was invoked, as explained in the next section.

Saving Properties
-----------------

The following example writes out the application properties from the previous example using `Properties.store`. The default properties don't need to be saved each time because they never change.

FileOutputStream out = new FileOutputStream("appProperties");
applicationProps.store(out, "---No Comment---");
out.close();

The `store` method needs a stream to write to, as well as a string that it uses as a comment at the top of the output.

Getting Property Information
----------------------------

Once the application has set up its `Properties` object, the application can query the object for information about various keys and values that it contains. An application gets information from a `Properties` object after start up so that it can initialize itself based on choices made by the user. The `Properties` class has several methods for getting property information:

*   `contains(Object value)` and `containsKey(Object key)`  
    Returns `true` if the value or the key is in the `Properties` object. `Properties` inherits these methods from `Hashtable`. Thus they accept `Object` arguments, but only `String` values should be used.
*   `getProperty(String key)` and `getProperty(String key, String default)`  
    Returns the value for the specified property. The second version provides for a default value. If the key is not found, the default is returned.
*   `list(PrintStream s)` and `list(PrintWriter w)`  
    Writes all of the properties to the specified stream or writer. This is useful for debugging.
*   `elements()`, `keys()`, and `propertyNames()`  
    Returns an `Enumeration` containing the keys or values (as indicated by the method name) contained in the `Properties` object. The `keys` method only returns the keys for the object itself; the `propertyNames` method returns the keys for default properties as well.
*   `stringPropertyNames()`  
    Like `propertyNames`, but returns a `Set<String>`, and only returns names of properties where both key and value are strings. Note that the `Set` object is not backed by the `Properties` object, so changes in one do not affect the other.
*   `size()`  
    Returns the current number of key/value pairs.

Setting Properties
------------------

A user's interaction with an application during its execution may impact property settings. These changes should be reflected in the `Properties` object so that they are saved when the application exits (and calls the `store` method). The following methods change the properties in a `Properties` object:

*   `setProperty(String key, String value)`  
    Puts the key/value pair in the `Properties` object.
*   `remove(Object key)`  
    Removes the key/value pair associated with key.

* * *

**Note:**¬†Some of the methods described above are defined in `Hashtable`, and thus accept key and value argument types other than `String`. Always use `String`s for keys and values, even if the method allows other types. Also do not invoke `Hashtable.set` or `Hastable.setAll` on `Properties` objects; always use `Properties.setProperty`.

* * *


<a name="sec_12_3"></a>
## 12.3. [Command-Line Arguments](#sec_12_3)
******
https://docs.oracle.com/javase/tutorial/essential/environment/cmdLineArgs.html

A Java application can accept any number of arguments from the command line. This allows the user to specify configuration information when the application is launched.

The user enters command-line arguments when invoking the application and specifies them after the name of the class to be run. For example, suppose a Java application called `Sort` sorts lines in a file. To sort the data in a file named `friends.txt`, a user would enter:

java Sort friends.txt

When an application is launched, the runtime system passes the command-line arguments to the application's main method via an array of `String`s. In the previous example, the command-line arguments passed to the `Sort` application in an array that contains a single `String`: `"friends.txt"`.

Echoing Command-Line Arguments
------------------------------

The [`` `Echo` ``](examples/Echo.java) example displays each of its command-line arguments on a line by itself:

```java
public class Echo {
    public static void main (String[] args) {
        for (String s: args) {
            System.out.println(s);
        }
    }
}
```

The following example shows how a user might run `Echo`. User input is in italics.

_java Echo Drink Hot Java_
Drink
Hot
Java

Note that the application displays each word ‚Äî `Drink`, `Hot`, and `Java` ‚Äî on a line by itself. This is because the space character separates command-line arguments. To have `Drink`, `Hot`, and `Java` interpreted as a single argument, the user would join them by enclosing them within quotation marks.

_java Echo "Drink Hot Java"_
Drink Hot Java

Parsing Numeric Command-Line Arguments
--------------------------------------

If an application needs to support a numeric command-line argument, it must convert a `String` argument that represents a number, such as "34", to a numeric value. Here is a code snippet that converts a command-line argument to an `int`:

```java
int firstArg;
if (args.length > 0) {
    try {
        firstArg = Integer.parseInt(args[0]);
    } catch (NumberFormatException e) {
        System.err.println("Argument" + args[0] + " must be an integer.");
        System.exit(1);
    }
}
```

`parseInt` throws a `NumberFormatException` if the format of `args[0]` isn't valid. All of the `Number` classes ‚Äî `Integer`, `Float`, `Double`, and so on ‚Äî have `parseXXX` methods that convert a `String` representing a number to an object of their type.


<a name="sec_12_4"></a>
## 12.4. [Environment Variables](#sec_12_4)
******
https://docs.oracle.com/javase/tutorial/essential/environment/env.html

Many operating systems use _environment variables_ to pass configuration information to applications. Like properties in the Java platform, environment variables are key/value pairs, where both the key and the value are strings. The conventions for setting and using environment variables vary between operating systems, and also between command line interpreters. To learn how to pass environment variables to applications on your system, refer to your system documentation.

Querying Environment Variables
------------------------------

On the Java platform, an application uses [`System.getenv`](https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getenv--) to retrieve environment variable values. Without an argument, `getenv` returns a read-only instance of `java.util.Map`, where the map keys are the environment variable names, and the map values are the environment variable values. This is demonstrated in the [`` `EnvMap` ``](examples/EnvMap.java) example:

```java
import java.util.Map;

public class EnvMap {
    public static void main (String[] args) {
        Map<String, String> env = System.getenv();
        for (String envName : env.keySet()) {
            System.out.format("%s=%s%n",
                              envName,
                              env.get(envName));
        }
    }
}
```

With a `String` argument, `getenv` returns the value of the specified variable. If the variable is not defined, `getenv` returns `null`. The [`` `Env` ``](examples/Env.java) example uses `getenv` this way to query specific environment variables, specified on the command line:

```java
public class Env {
    public static void main (String[] args) {
        for (String env: args) {
            String value = System.getenv(env);
            if (value != null) {
                System.out.format("%s=%s%n",
                                  env, value);
            } else {
                System.out.format("%s is"
                    + " not assigned.%n", env);
            }
        }
    }
}
```

Passing Environment Variables to New Processes
----------------------------------------------

When a Java application uses a [`ProcessBuilder`](https://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.html) object to create a new process, the default set of environment variables passed to the new process is the same set provided to the application's virtual machine process. The application can change this set using `ProcessBuilder.environment`.

Platform Dependency Issues
--------------------------

There are many subtle differences between the way environment variables are implemented on different systems. For example, Windows ignores case in environment variable names, while UNIX does not. The way environment variables are used also varies. For example, Windows provides the user name in an environment variable called `USERNAME`, while UNIX implementations might provide the user name in `USER`, `LOGNAME`, or both.

To maximize portability, never refer to an environment variable when the same value is available in a system property. For example, if the operating system provides a user name, it will always be available in the system property `user.name`.


<a name="sec_12_5"></a>
## 12.5. [Other Configuration Utilities](#sec_12_5)
******
https://docs.oracle.com/javase/tutorial/essential/environment/other.html

Here is a summary of some other configuration utilities.

The _Preferences API_ allows applications to store and retrieve configuration data in an implementation-dependent backing store. Asynchronous updates are supported, and the same set of preferences can be safely updated by multiple threads and even multiple applications. For more information, refer to the [Preferences API Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/preferences/index.html).

An application deployed in a _JAR archive_ uses a _manifest_ to describe the contents of the archive. For more information, refer to the [Packaging Programs in JAR Files](../../deployment/jar/index.html) lesson.

The configuration of a _Java Web Start application_ is contained in a _JNLP file_. For more information, refer to the [Java Web Start](../../deployment/webstart/index.html) lesson.

The configuration of a _Java Plug-in applet_ is partially determined by the HTML tags used to embed the applet in the web page. Depending on the applet and the browser, these tags can include `<applet>`, `<object>`, `<embed>`, and `<param>`. For more information, refer to the [Java Applets](../../deployment/applet/index.html) lesson.

The class [`java.util.ServiceLoader`](https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html) provides a simple _service provider_ facility. A service provider is an implementation of a _service_ ‚Äî a well-known set of interfaces and (usually abstract) classes. The classes in a service provider typically implement the interfaces and subclass the classes defined in the service. Service providers can be installed as extensions (see [The Extension Mechanism](../../ext/index.html)). Providers can also be made available by adding them to the class path or by some other platform-specific means.


<a name="sec_12_6"></a>
## 12.6. [System Utilities](#sec_12_6)
******
https://docs.oracle.com/javase/tutorial/essential/environment/system.html

The [`System`](https://docs.oracle.com/javase/8/docs/api/java/lang/System.html) class implements a number of system utilities. Some of these have already been covered in the previous section on [Configuration Utilities](config.html). This section covers some of the other system utilities.


<a name="sec_12_7"></a>
## 12.7. [Command-Line I/O Objects](#sec_12_7)
******
https://docs.oracle.com/javase/tutorial/essential/environment/cl.html

`System` provides several predefined I/O objects that are useful in a Java application that is meant to be launched from the command line. These implement the Standard I/O streams provided by most operating systems, and also a console object that is useful for entering passwords. For more information, refer to [I/O from the Command Line](../../essential/io/cl.html) in the [Basic I/O](../../essential/io/index.html) lesson.


<a name="sec_12_8"></a>
## 12.8. [System Properties](#sec_12_8)
******
https://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html

In [Properties](properties.html), we examined the way an application can use `Properties` objects to maintain its configuration. The Java platform itself uses a `Properties` object to maintain its own configuration. The `System` class maintains a `Properties` object that describes the configuration of the current working environment. System properties include information about the current user, the current version of the Java runtime, and the character used to separate components of a file path name.

The following table describes some of the most important system properties

| Key | Meaning |
|-----|---------|
| `"file.separator"`  | Character that separates components of a file path. This is "`/`" on UNIX and "`\`" on Windows.
| `"java.class.path"` | Path used to find directories and JAR archives containing class files. Elements of the class path are separated by a platform-specific character specified in the `path.separator` property.
| `"java.home"`       | Installation directory for Java Runtime Environment (JRE)
| `"java.vendor"`     | JRE vendor name
| `"java.vendor.url"` | JRE vendor URL
| `"java.version"`    | JRE version number
| `"line.separator"`  | Sequence used by operating system to separate lines in text files
| `"os.arch"`         | Operating system architecture
| `"os.name"`         | Operating system name
| `"os.version"`      | Operating system version
| `"path.separator"`  | Path separator character used in `java.class.path`
| `"user.dir"`        | User working directory
| `"user.home"`       | User home directory
| `"user.name"`       | User account name

* * *

**Security consideration:**¬†Access to system properties can be restricted by the [Security Manager](security.html). This is most often an issue in applets, which are prevented from reading some system properties, and from writing _any_ system properties. For more on accessing system properties in applets, refer to [System Properties](../../deployment/doingMoreWithRIA/properties.html) in the [Doing More With Java Rich Internet Applications](../../deployment/doingMoreWithRIA/index.html) lesson.

* * *

Reading System Properties
-------------------------

The `System` class has two methods used to read system properties: `getProperty` and `getProperties`.

The `System` class has two different versions of `getProperty`. Both retrieve the value of the property named in the argument list. The simpler of the two `getProperty` methods takes a single argument, a property key For example, to get the value of `path.separator`, use the following statement:

System.getProperty("path.separator");

The `getProperty` method returns a string containing the value of the property. If the property does not exist, this version of `getProperty` returns null.

The other version of `getProperty` requires two `String` arguments: the first argument is the key to look up and the second argument is a default value to return if the key cannot be found or if it has no value. For example, the following invocation of `getProperty` looks up the `System` property called `subliminal.message`. This is not a valid system property, so instead of returning null, this method returns the default value provided as a second argument: "`Buy StayPuft Marshmallows!`"

System.getProperty("subliminal.message", "Buy StayPuft Marshmallows!");

The last method provided by the `System` class to access property values is the `getProperties` method, which returns a [`Properties`](https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html) object. This object contains a complete set of system property definitions.

Writing System Properties
-------------------------

To modify the existing set of system properties, use `System.setProperties`. This method takes a `Properties` object that has been initialized to contain the properties to be set. This method replaces the entire set of system properties with the new set represented by the `Properties` object.

* * *

**Warning:**¬†Changing system properties is potentially dangerous and should be done with discretion. Many system properties are not reread after start-up and are there for informational purposes. Changing some properties may have unexpected side-effects.

* * *

The next example, [`PropertiesTest`](examples/PropertiesTest.java), creates a `Properties` object and initializes it from [`myProperties.txt`](examples/myProperties.txt) .

subliminal.message=Buy StayPuft Marshmallows!

`PropertiesTest` then uses `System.setProperties` to install the new `Properties` objects as the current set of system properties.

import java.io.FileInputStream;
import java.util.Properties;

public class PropertiesTest {
    public static void main(String\[\] args)
        throws Exception {

        // set up new properties object
        // from file "myProperties.txt"
        FileInputStream propFile =
            new FileInputStream( "myProperties.txt");
        Properties p =
            new Properties(System.getProperties());
        p.load(propFile);

        // set the system properties
        System.setProperties(p);
        // display new properties
        System.getProperties().list(System.out);
    }
}

Note how `PropertiesTest` creates the `Properties` object, `p`, which is used as the argument to `setProperties`:

Properties p = new Properties(System.getProperties());

This statement initializes the new properties object, `p`, with the current set of system properties, which in the case of this small application, is the set of properties initialized by the runtime system. Then the application loads additional properties into `p` from the file `myProperties.txt` and sets the system properties to `p`. This has the effect of adding the properties listed in `myProperties.txt` to the set of properties created by the runtime system at startup. Note that an application can create `p` without any default `Properties` object, like this:

Properties p = new Properties();

Also note that the value of system properties can be overwritten! For example, if `myProperties.txt` contains the following line, the `java.vendor` system property will be overwritten:

java.vendor=Acme Software Company

In general, be careful not to overwrite system properties.

The `setProperties` method changes the set of system properties for the current running application. These changes are not persistent. That is, changing the system properties within an application will not affect future invocations of the Java interpreter for this or any other application. The runtime system re-initializes the system properties each time its starts up. If changes to system properties are to be persistent, then the application must write the values to some file before exiting and read them in again upon startup.


<a name="sec_12_9"></a>
## 12.9. [The Security Manager](#sec_12_9)
******
https://docs.oracle.com/javase/tutorial/essential/environment/security.html

A _security manager_ is an object that defines a security policy for an application. This policy specifies actions that are unsafe or sensitive. Any actions not allowed by the security policy cause a [`SecurityException`](https://docs.oracle.com/javase/8/docs/api/java/lang/SecurityException.html) to be thrown. An application can also query its security manager to discover which actions are allowed.

Typically, a web applet runs with a security manager provided by the browser or Java Web Start plugin. Other kinds of applications normally run without a security manager, unless the application itself defines one. If no security manager is present, the application has no security policy and acts without restrictions.

This section explains how an application interacts with an existing security manager. For more detailed information, including information on how to design a security manager, refer to the [Security Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html).

Interacting with the Security Manager
-------------------------------------

The security manager is an object of type [`SecurityManager`](https://docs.oracle.com/javase/8/docs/api/java/lang/SecurityManager.html); to obtain a reference to this object, invoke `System.getSecurityManager`.

SecurityManager appsm = System.getSecurityManager();

If there is no security manager, this method returns `null`.

Once an application has a reference to the security manager object, it can request permission to do specific things. Many classes in the standard libraries do this. For example, `System.exit`, which terminates the Java virtual machine with an exit status, invokes `SecurityManager.checkExit` to ensure that the current thread has permission to shut down the application.

The SecurityManager class defines many other methods used to verify other kinds of operations. For example, `SecurityManager.checkAccess` verifies thread accesses, and `SecurityManager.checkPropertyAccess` verifies access to the specified property. Each operation or group of operations has its own `check_XXX_()` method.

In addition, the set of `check_XXX_()` methods represents the set of operations that are already subject to the protection of the security manager. Typically, an application does not have to directly invoke any `check_XXX_()` methods.

Recognizing a Security Violation
--------------------------------

Many actions that are routine without a security manager can throw a `SecurityException` when run with a security manager. This is true even when invoking a method that isn't documented as throwing `SecurityException`. For example, consider the following code used to write to a file:

reader = new FileWriter("xanadu.txt");

In the absence of a security manager, this statement executes without error, provided `xanadu.txt` exists and is writeable. But suppose this statement is inserted in a web applet, which typically runs under a security manager that does not allow file output. The following error messages might result:

_appletviewer fileApplet.html_
    Exception in thread "AWT-EventQueue-1" java.security.AccessControlException: access denied (java.io.FilePermission xanadu.txt write)
        at java.security.AccessControlContext.checkPermission(AccessControlContext.java:323)
        at java.security.AccessController.checkPermission(AccessController.java:546)
        at java.lang.SecurityManager.checkPermission(SecurityManager.java:532)
        at java.lang.SecurityManager.checkWrite(SecurityManager.java:962)
        at java.io.FileOutputStream.<init>(FileOutputStream.java:169)
        at java.io.FileOutputStream.<init>(FileOutputStream.java:70)
        at java.io.FileWriter.<init>(FileWriter.java:46)
_..._

Note that the specific exception thrown in this case, [`java.security.AccessControlException`](https://docs.oracle.com/javase/8/docs/api/java/security/AccessControlException.html), is a subclass of `SecurityException`.


<a name="sec_12_10"></a>
## 12.10. [Miscellaneous Methods in System](#sec_12_10)
******
https://docs.oracle.com/javase/tutorial/essential/environment/sysmisc.html

This section describes some of the methods in `System` that aren't covered in the previous sections.

The `arrayCopy` method efficiently copies data between arrays. For more information, refer to [Arrays](../../java/nutsandbolts/arrays.html) in the [Language Basics](../../java/nutsandbolts/index.html) lesson.

The [`currentTimeMillis`](https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#currentTimeMillis--) and [`nanoTime`](https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#nanoTime--) methods are useful for measuring time intervals during execution of an application. To measure a time interval in milliseconds, invoke `currentTimeMillis` twice, at the beginning and end of the interval, and subtract the first value returned from the second. Similarly, invoking `nanoTime` twice measures an interval in nanoseconds.

* * *

**Note:**¬†The accuracy of both `currentTimeMillis` and `nanoTime` is limited by the time services provided by the operating system. Do not assume that `currentTimeMillis` is accurate to the nearest millisecond or that `nanoTime` is accurate to the nearest nanosecond. Also, neither `currentTimeMillis` nor `nanoTime` should be used to determine the current time. Use a high-level method, such as [`java.util.Calendar.getInstance`](https://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--).

* * *

The [`exit`](https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#exit-int-) method causes the Java virtual machine to shut down, with an integer exit status specified by the argument. The exit status is available to the process that launched the application. By convention, an exit status of `0` indicates normal termination of the application, while any other value is an error code.


<a name="sec_12_11"></a>
## 12.11. [PATH and CLASSPATH](#sec_12_11)
******
https://docs.oracle.com/javase/tutorial/essential/environment/paths.html

This section explains how to use the `PATH` and `CLASSPATH` environment variables on Microsoft Windows, Solaris, and Linux. Consult the installation instructions included with your installation of the Java Development Kit (JDK) software bundle for current information.

After installing the software, the JDK directory will have the structure shown below.

![JDK directory structure](https://docs.oracle.com/javase/tutorial/figures/essential/environment-directories.gif)

The `bin` directory contains both the compiler and the launcher.

Update the PATH Environment Variable (Microsoft Windows)
--------------------------------------------------------

You can run Java applications just fine without setting the `PATH` environment variable. Or, you can optionally set it as a convenience.

Set the `PATH` environment variable if you want to be able to conveniently run the executables (`javac.exe`, `java.exe`, `javadoc.exe`, and so on) from any directory without having to type the full path of the command. If you do not set the `PATH` variable, you need to specify the full path to the executable every time you run it, such as:

C:\\Java\\jdk1.7.0\\bin\\javac MyClass.java

The `PATH` environment variable is a series of directories separated by semicolons (`;`). Microsoft Windows looks for programs in the `PATH` directories in order, from left to right. You should have only one `bin` directory for the JDK in the path at a time (those following the first are ignored), so if one is already present, you can update that particular entry.

The following is an example of a `PATH` environment variable:

C:\\Java\\jdk1.7.0\\bin;C:\\Windows\\System32\\;C:\\Windows\\;C:\\Windows\\System32\\Wbem

It is useful to set the `PATH` environment variable permanently so it will persist after rebooting. To make a permanent change to the `PATH` variable, use the **System** icon in the Control Panel. The precise procedure varies depending on the version of Windows:

**Windows XP**

1.  Select **Start**, select **Control Panel**. double click **System**, and select the **Advanced** tab.
2.  Click **Environment Variables**. In the section **System Variables**, find the `PATH` environment variable and select it. Click **Edit**. If the `PATH` environment variable does not exist, click `New`.
3.  In the **Edit System Variable** (or **New System Variable**) window, specify the value of the `PATH` environment variable. Click **OK**. Close all remaining windows by clicking **OK**.

**Windows Vista:**

1.  From the desktop, right click the **My Computer** icon.
2.  Choose **Properties** from the context menu.
3.  Click the **Advanced** tab (**Advanced system settings** link in Vista).
4.  Click **Environment Variables**. In the section **System Variables**, find the `PATH` environment variable and select it. Click **Edit**. If the `PATH` environment variable does not exist, click `New`.
5.  In the **Edit System Variable** (or **New System Variable**) window, specify the value of the `PATH` environment variable. Click **OK**. Close all remaining windows by clicking **OK**.

**Windows 7:**

1.  From the desktop, right click the **Computer** icon.
2.  Choose **Properties** from the context menu.
3.  Click the **Advanced system settings** link.
4.  Click **Environment Variables**. In the section **System Variables**, find the `PATH` environment variable and select it. Click **Edit**. If the `PATH` environment variable does not exist, click `New`.
5.  In the **Edit System Variable** (or **New System Variable**) window, specify the value of the `PATH` environment variable. Click **OK**. Close all remaining windows by clicking **OK**.

* * *

**Note:**¬†You may see a `PATH` environment variable similar to the following when editing it from the Control Panel:

%JAVA_HOME%\\bin;%SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem

Variables enclosed in percentage signs (`%`) are existing environment variables. If one of these variables is listed in the **Environment Variables** window from the Control Panel (such as `JAVA_HOME`), then you can edit its value. If it does not appear, then it is a special environment variable that the operating system has defined. For example, `SystemRoot` is the location of the Microsoft Windows system folder. To obtain the value of a environment variable, enter the following at a command prompt. (This example obtains the value of the `SystemRoot` environment variable):

echo %SystemRoot%

* * *

Update the PATH Variable (Solaris and Linux)
--------------------------------------------

You can run the JDK just fine without setting the `PATH` variable, or you can optionally set it as a convenience. However, you should set the path variable if you want to be able to run the executables (`javac`, `java`, `javadoc`, and so on) from any directory without having to type the full path of the command. If you do not set the `PATH` variable, you need to specify the full path to the executable every time you run it, such as:

% /usr/local/jdk1.7.0/bin/javac MyClass.java

To find out if the path is properly set, execute:

% java -version

This will print the version of the `java` tool, if it can find it. If the version is old or you get the error **java: Command not found**, then the path is not properly set.

To set the path permanently, set the path in your startup file.

For C shell (`csh`), edit the startup file `(~/.cshrc`):

set path=(/usr/local/jdk1.7.0/bin $path)

For `bash`, edit the startup file (`~/.bashrc`):

PATH=/usr/local/jdk1.7.0/bin:$PATH
export PATH

For `ksh`, the startup file is named by the environment variable, `ENV`. To set the path:

PATH=/usr/local/jdk1.7.0/bin:$PATH
export PATH

For `sh`, edit the profile file (`~/.profile`):

PATH=/usr/local/jdk1.7.0/bin:$PATH
export PATH

Then load the startup file and verify that the path is set by repeating the `java` command:

For C shell (`csh`):

% source ~/.cshrc
% java -version

For `ksh`, `bash`, or `sh`:

% . /.profile
% java -version

Checking the CLASSPATH variable (All platforms)
-----------------------------------------------

The `CLASSPATH` variable is one way to tell applications, including the JDK tools, where to look for user classes. (Classes that are part of the JRE, JDK platform, and extensions should be defined through other means, such as the bootstrap class path or the extensions directory.)

The preferred way to specify the class path is by using the `-cp` command line switch. This allows the `CLASSPATH` to be set individually for each application without affecting other applications. _Setting the `CLASSPATH` can be tricky and should be performed with care._

The default value of the class path is ".", meaning that only the current directory is searched. Specifying either the CLASSPATH variable or the `-cp` command line switch overrides this value.

To check whether `CLASSPATH` is set on Microsoft Windows NT/2000/XP, execute the following:

C:> echo %CLASSPATH%

On Solaris or Linux, execute the following:

% echo $CLASSPATH

If `CLASSPATH` is not set you will get a **CLASSPATH: Undefined variable** error (Solaris or Linux) or simply **%CLASSPATH%** (Microsoft Windows NT/2000/XP).

To modify the `CLASSPATH`, use the same procedure you used for the `PATH` variable.

Class path wildcards allow you to include an entire directory of `.jar` files in the class path without explicitly naming them individually. For more information, including an explanation of class path wildcards, and a detailed description on how to clean up the `CLASSPATH` environment variable, see the [Setting the Class Path](https://docs.oracle.com/javase/8/docs/technotes/tools/windows/classpath.html) technical note.


<a name="sec_12_12"></a>
## 12.12. [Questions and Exercises](#sec_12_12)
******
https://docs.oracle.com/javase/tutorial/essential/environment/QandE/answers.html

Questions
---------

1\. A programmer installs a new library contained in a .jar file. In order to access the library from his code, he sets the CLASSPATH environment variable to point to the new .jar file. Now he finds that he gets an error message when he tries to launch simple applications:

**java Hello**
Exception in thread "main" java.lang.NoClassDefFoundError: Hello

In this case, the `Hello` class is compiled into a .class file in the current directory ‚Äî yet the `java` command can't seem to find it. What's going wrong?

Exercises
---------

1\. Write an application, `PersistentEcho`, with the following features:

*   If `PersistentEcho` is run with command line arguments, it prints out those arguments. It also saves the string printed out to a property, and saves the property to a file called `PersistentEcho.txt`
*   If `PersistentEcho` is run with no command line arguments, it looks for an environment variable called PERSISTENTECHO. If that variable exists, `PersistentEcho` prints out its value, and also saves the value in the same way it does for command line arguments.
*   If `PersistentEcho` is run with no command line arguments, and the PERSISTENTECHO environment variable is not defined, it retrieves the property value from `PersistentEcho.txt` and prints that out.

[Check your answers.](answers.html)


Questions
---------

**Question 1.**A programmer installs a new library contained in a .jar file. In order to access the library from his code, he sets the CLASSPATH environment variable to point to the new .jar file. Now he finds that he gets an error message when he tries to launch simple applications:

**java Hello**
Exception in thread "main" java.lang.NoClassDefFoundError: Hello

In this case, the `Hello` class is compiled into a .class file in the current directory ‚Äî yet the `java` command can't seem to find it. What's going wrong?

**Answer 1.** A class is only found if it appears in the class path. By default, the class path consists of the current directory. If the CLASSPATH environment variable is set, and doesn't include the current directory, the launcher can no longer find classes in the current directory. The solution is to change the CLASSPATH variable to include the current directory. For example, if the CLASSPATH value is `c:\java\newLibrary.jar` (Windows) or `/home/me/newLibrary.jar` (UNIX or Linux) it needs to be changed to `.;c:\java\newLibrary.jar` or `.:/home/me/newLibrary.jar`.

Exercises
---------

**Exercise 1.**

Write an application, `PersistentEcho`, with the following features:

*   If `PersistentEcho` is run with command line arguments, it prints out those arguments. It also saves the string printed out to a property, and saves the property to a file called `PersistentEcho.txt`
*   If `PersistentEcho` is run with no command line arguments, it looks for an environment variable called PERSISTENTECHO. If that variable exists, `PersistentEcho` prints out its value, and also saves the value in the same way it does for command line arguments.
*   If `PersistentEcho` is run with no command line arguments, and the PERSISTENTECHO environment variable is not defined, it retrieves the property value from `PersistentEcho.txt` and prints that out.

**Answer 1.**

```java
import java.util.Properties;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class PersistentEcho {
    public static void main (String\[\] args) {
        String argString = "";
        boolean notProperty = true;

        // Are there arguments? 
        // If so retrieve them.
        if (args.length > 0) {
            for (String arg: args) {
                argString += arg + " ";
            }
            argString = argString.trim();
        }
        // No arguments, is there
        // an environment variable?
        // If so, //retrieve it.
        else if ((argString = System.getenv("PERSISTENTECHO")) != null) {}
        // No environment variable
        // either. Retrieve property value.
        else {
            notProperty = false;
            // Set argString to null.
            // If it's still null after
            // we exit the try block,
            // we've failed to retrieve
            // the property value.
            argString = null;
            FileInputStream fileInputStream = null;
            try {
                fileInputStream =
                    new FileInputStream("PersistentEcho.txt");
                Properties inProperties
                    = new Properties();
                inProperties.load(fileInputStream);
                argString = inProperties.getProperty("argString");
            } catch (IOException e) {
                System.err.println("Can't read property file.");
                System.exit(1);
            } finally {
                if (fileInputStream != null) {
                    try {
                        fileInputStream.close();
                    } catch(IOException e) {};
                }
            }
        }
        if (argString == null) {
            System.err.println("Couldn't find argString property");
            System.exit(1);
        }

        // Somehow, we got the
        // value. Echo it already!
        System.out.println(argString);

        // If we didn't retrieve the
        // value from the property,
        // save it //in the property.
        if (notProperty) {
            Properties outProperties =
                new Properties();
            outProperties.setProperty("argString",
                                      argString);
            FileOutputStream fileOutputStream = null;
            try {
                fileOutputStream =
                    new FileOutputStream("PersistentEcho.txt");
                outProperties.store(fileOutputStream,
                        "PersistentEcho properties");
            } catch (IOException e) {}
            finally {
                if (fileOutputStream != null) {
                    try {
                        fileOutputStream.close();
                    } catch(IOException e) {};
                }
            }
        }
    }
}
```


<a name="sec_13"></a>
# üìú/PART 13.  [**Regular Expressions**](#sec_13)
******
https://docs.oracle.com/javase/tutorial/essential/regex/index.html 

1.  [Introduction](#sec_13_1)
2.  [Test Harness](#sec_13_2)
3.  [String Literals](#sec_13_3)
4.  [Character Classes](#sec_13_4)
5.  [Predefined Character Classes](#sec_13_5)
6.  [Quantifiers](#sec_13_6)
7.  [Capturing Groups](#sec_13_7)
8.  [Boundary Matchers](#sec_13_8)
9.  [Methods of the Pattern Class](#sec_13_9)
10. [Methods of the Matcher Class](#sec_13_10)
11. [Methods of the PatternSyntaxException Class](#sec_13_11)
12. [Unicode Support](#sec_13_12)
13. [Additional Resources](#sec_13_13)
14. [Questions and Exercises](#sec_13_14)

*   Introduction

    Provides a general overview of regular expressions. It also introduces the core classes that comprise this API.

*   Test Harness

    Defines a simple application for testing pattern matching with regular expressions.

*   String Literals

    Introduces basic pattern matching, metacharacters, and quoting.

*   Character Classes

    Describes simple character classes, negation, ranges, unions, intersections, and subtraction.

*   Predefined Character Classes

    Describes the basic predefined character classes for whitespace, word, and digit characters.

*   Quantifiers

    Explains greedy, reluctant, and possessive quantifiers for matching a specified expression _x_ number of times.

*   Capturing Groups

    Explains how to treat multiple characters as a single unit.

*   Boundary Matchers

    Describes line, word, and input boundaries.

*   Methods of the Pattern Class

    Examines other useful methods of the `Pattern` class, and explores advanced features such as compiling with flags and using embedded flag expressions.

*   Methods of the Matcher Class

    Describes the commonly-used methods of the `Matcher` class.

*   Methods of the PatternSyntaxException Class

    Describes how to examine a `PatternSyntaxException`.

*   Additional Resources

    To read more about regular expressions, consult this section for additional resources.

<a name="sec_13_1"></a>
## 13.1.  [Introduction](#sec_13_1)
******
https://docs.oracle.com/javase/tutorial/essential/regex/intro.html 

What Are Regular Expressions?
-----------------------------

_Regular expressions_ are a way to describe a set of strings based on common characteristics shared by each string in the set. They can be used to search, edit, or manipulate text and data. You must learn a specific syntax to create regular expressions ‚Äî one that goes beyond the normal syntax of the Java programming language. Regular expressions vary in complexity, but once you understand the basics of how they're constructed, you'll be able to decipher (or create) any regular expression.

This trail teaches the regular expression syntax supported by the [`java.util.regex`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/package-summary.html) API and presents several working examples to illustrate how the various objects interact. In the world of regular expressions, there are many different flavors to choose from, such as grep, Perl, Tcl, Python, PHP, and awk. The regular expression syntax in the `java.util.regex` API is most similar to that found in Perl.

How Are Regular Expressions Represented in This Package?
--------------------------------------------------------

The `java.util.regex` package primarily consists of three classes: 
[`Pattern`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html), 
[`Matcher`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html), and 
[`PatternSyntaxException`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html).

*   A `Pattern` object is a compiled representation of a regular expression. The `Pattern` class provides no public constructors. To create a pattern, you must first invoke one of its `public static compile` methods, which will then return a `Pattern` object. These methods accept a regular expression as the first argument; the first few lessons of this trail will teach you the required syntax.
*   A `Matcher` object is the engine that interprets the pattern and performs match operations against an input string. Like the `Pattern` class, `Matcher` defines no public constructors. You obtain a `Matcher` object by invoking the `matcher` method on a `Pattern` object.
*   A `PatternSyntaxException` object is an unchecked exception that indicates a syntax error in a regular expression pattern.

The last few lessons of this trail explore each class in detail. But first, you must understand how regular expressions are actually constructed. Therefore, the next section introduces a simple test harness that will be used repeatedly to explore their syntax.



<a name="sec_13_2"></a>
## 13.2.  [Test Harness](#sec_13_2)
******
https://docs.oracle.com/javase/tutorial/essential/regex/test_harness.html 

This section defines a reusable test harness, [`RegexTestHarness.java`](examples/RegexTestHarness.java) , for exploring the regular expression constructs supported by this API. The command to run this code is `java RegexTestHarness`; no command-line arguments are accepted. The application loops repeatedly, prompting the user for a regular expression and input string. Using this test harness is optional, but you may find it convenient for exploring the test cases discussed in the following pages.

```java
import java.io.Console;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class RegexTestHarness {

    public static void main(String\[\] args){
        Console console = System.console();
        if (console == null) {
            System.err.println("No console.");
            System.exit(1);
        }
        while (true) {

            Pattern pattern = 
            Pattern.compile(console.readLine("%nEnter your regex: "));

            Matcher matcher = 
            pattern.matcher(console.readLine("Enter input string to search: "));

            boolean found = false;
            while (matcher.find()) {
                console.format("I found the text" +
                    " \\"%s\\" starting at " +
                    "index %d and ending at index %d.%n",
                    matcher.group(),
                    matcher.start(),
                    matcher.end());
                found = true;
            }
            if(!found){
                console.format("No match found.%n");
            }
        }
    }
}
```

Before continuing to the next section, save and compile this code to ensure that your development environment supports the required packages.



<a name="sec_13_3"></a>
## 13.3.  [String Literals](#sec_13_3)
******
https://docs.oracle.com/javase/tutorial/essential/regex/literals.html 

The most basic form of pattern matching supported by this API is the match of a string literal. For example, if the regular expression is `foo` and the input string is `foo`, the match will succeed because the strings are identical. Try this out with the test harness:
     
    Enter your regex: foo
    Enter input string to search: foo
    I found the text foo starting at index 0 and ending at index 3.


This match was a success. Note that while the input string is 3 characters long, the start index is 0 and the end index is 3. By convention, ranges are inclusive of the beginning index and exclusive of the end index, as shown in the following figure:

![The string literal foo, with numbered cells and index values.](https://docs.oracle.com/javase/tutorial/figures/essential/cells.gif)

The string literal foo, with numbered cells and index values.

Each character in the string resides in its own _cell_, with the index positions pointing between each cell. The string "foo" starts at index 0 and ends at index 3, even though the characters themselves only occupy cells 0, 1, and 2.

With subsequent matches, you'll notice some overlap; the start index for the next match is the same as the end index of the previous match:

 
    Enter your regex: foo
    Enter input string to search: foofoofoo
    I found the text foo starting at index 0 and ending at index 3.
    I found the text foo starting at index 3 and ending at index 6.
    I found the text foo starting at index 6 and ending at index 9.

Metacharacters
--------------

This API also supports a number of special characters that affect the way a pattern is matched. Change the regular expression to `cat.` and the input string to `cats`. The output will appear as follows:

Enter your regex: cat.
Enter input string to search: cats
I found the text cats starting at index 0 and ending at index 4.

The match still succeeds, even though the dot "`.`" is not present in the input string. It succeeds because the dot is a _metacharacter_ ‚Äî a character with special meaning interpreted by the matcher. The metacharacter "." means "any character" which is why the match succeeds in this example.

The metacharacters supported by this API are: `<([{\^-=$!|]})?*+.>`

* * *

**Note:**¬†In certain situations the special characters listed above will _not_ be treated as metacharacters. You'll encounter this as you learn more about how regular expressions are constructed. You can, however, use this list to check whether or not a specific character will ever be considered a metacharacter. For example, the characters `@` and `#` never carry a special meaning.

* * *

There are two ways to force a metacharacter to be treated as an ordinary character:

*   precede the metacharacter with a backslash, or
*   enclose it within `\Q` (which starts the quote) and `\E` (which ends it).

When using this technique, the `\Q` and `\E` can be placed at any location within the expression, provided that the `\Q` comes first.



<a name="sec_13_4"></a>
## 13.4.  [Character Classes](#sec_13_4)
******
https://docs.oracle.com/javase/tutorial/essential/regex/char_classes.html 

If you browse through the [`Pattern`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html) class specification, you'll see tables summarizing the supported regular expression constructs. In the "Character Classes" section you'll find the following:

| Construct | Description |
|-----------|-------------|
| `[abc]`         | a, b, or c (simple class)
| `[^abc]`        | Any character except a, b, or c (negation)
| `[a-zA-Z]`      | a through z, or A through Z, inclusive (range)
| `[a-d[m-p]]`    | a through d, or m through p: \[a-dm-p\] (union)
| `[a-z&&[def]]`  | d, e, or f (intersection)
| `[a-z&&[^bc]]`  | a through z, except for b and c: \[ad-z\] (subtraction)
| `[a-z&&[^m-p]]` | a through z, and not m through p: \[a-lq-z\] (subtraction)

The left-hand column specifies the regular expression constructs, while the right-hand column describes the conditions under which each construct will match.

* * *

**Note:**¬†The word "class" in the phrase "character class" does not refer to a `.class` file. In the context of regular expressions, a _character class_ is a set of characters enclosed within square brackets. It specifies the characters that will successfully match a single character from a given input string.

* * *

Simple Classes
--------------

The most basic form of a character class is to simply place a set of characters side-by-side within square brackets. For example, the regular expression `[bcr]at` will match the words "bat", "cat", or "rat" because it defines a character class (accepting either "b", "c", or "r") as its first character.

 
    Enter your regex: \[bcr\]at
    Enter input string to search: bat
    I found the text "bat" starting at index 0 and ending at index 3.

    Enter your regex: \[bcr\]at
    Enter input string to search: cat
    I found the text "cat" starting at index 0 and ending at index 3.

    Enter your regex: \[bcr\]at
    Enter input string to search: rat
    I found the text "rat" starting at index 0 and ending at index 3.

    Enter your regex: \[bcr\]at
    Enter input string to search: hat
    No match found.

In the above examples, the overall match succeeds only when the first letter matches one of the characters defined by the character class.

### Negation

To match all characters _except_ those listed, insert the "`^`" metacharacter at the beginning of the character class. This technique is known as _negation_.

 
    Enter your regex: \[^bcr\]at
    Enter input string to search: bat
    No match found.

    Enter your regex: \[^bcr\]at
    Enter input string to search: cat
    No match found.

    Enter your regex: \[^bcr\]at
    Enter input string to search: rat
    No match found.

    Enter your regex: \[^bcr\]at
    Enter input string to search: hat
    I found the text "hat" starting at index 0 and ending at index 3.

The match is successful only if the first character of the input string does _not_ contain any of the characters defined by the character class.

### Ranges

Sometimes you'll want to define a character class that includes a range of values, such as the letters "a through h" or the numbers "1 through 5". To specify a range, simply insert the "`-`" metacharacter between the first and last character to be matched, such as `[1-5]` or `[a-h]`. You can also place different ranges beside each other within the class to further expand the match possibilities. For example, `[a-zA-Z]` will match any letter of the alphabet: a to z (lowercase) or A to Z (uppercase).

Here are some examples of ranges and negation:

    Enter your regex: \[a-c\]
    Enter input string to search: a
    I found the text "a" starting at index 0 and ending at index 1.

    Enter your regex: \[a-c\]
    Enter input string to search: b
    I found the text "b" starting at index 0 and ending at index 1.

    Enter your regex: \[a-c\]
    Enter input string to search: c
    I found the text "c" starting at index 0 and ending at index 1.

    Enter your regex: \[a-c\]
    Enter input string to search: d
    No match found.

    Enter your regex: foo\[1-5\]
    Enter input string to search: foo1
    I found the text "foo1" starting at index 0 and ending at index 4.

    Enter your regex: foo\[1-5\]
    Enter input string to search: foo5
    I found the text "foo5" starting at index 0 and ending at index 4.

    Enter your regex: foo\[1-5\]
    Enter input string to search: foo6
    No match found.

    Enter your regex: foo\[^1-5\]
    Enter input string to search: foo1
    No match found.

    Enter your regex: foo\[^1-5\]
    Enter input string to search: foo6
    I found the text "foo6" starting at index 0 and ending at index 4.

### Unions

You can also use _unions_ to create a single character class comprised of two or more separate character classes. To create a union, simply nest one class inside the other, such as `[0-4[6-8]]`. This particular union creates a single character class that matches the numbers 0, 1, 2, 3, 4, 6, 7, and 8.

    Enter your regex: \[0-4\[6-8\]\]
    Enter input string to search: 0
    I found the text "0" starting at index 0 and ending at index 1.

    Enter your regex: \[0-4\[6-8\]\]
    Enter input string to search: 5
    No match found.

    Enter your regex: \[0-4\[6-8\]\]
    Enter input string to search: 6
    I found the text "6" starting at index 0 and ending at index 1.

    Enter your regex: \[0-4\[6-8\]\]
    Enter input string to search: 8
    I found the text "8" starting at index 0 and ending at index 1.

    Enter your regex: \[0-4\[6-8\]\]
    Enter input string to search: 9
    No match found.

### Intersections

To create a single character class matching only the characters common to all of its nested classes, use `&&`, as in `[0-9&&[345]]`. This particular intersection creates a single character class matching only the numbers common to both character classes: 3, 4, and 5.

 
    Enter your regex: \[0-9&&\[345\]\]
    Enter input string to search: 3
    I found the text "3" starting at index 0 and ending at index 1.

    Enter your regex: \[0-9&&\[345\]\]
    Enter input string to search: 4
    I found the text "4" starting at index 0 and ending at index 1.

    Enter your regex: \[0-9&&\[345\]\]
    Enter input string to search: 5
    I found the text "5" starting at index 0 and ending at index 1.

    Enter your regex: \[0-9&&\[345\]\]
    Enter input string to search: 2
    No match found.

    Enter your regex: \[0-9&&\[345\]\]
    Enter input string to search: 6
    No match found.

And here's an example that shows the intersection of two ranges:

     
    Enter your regex: \[2-8&&\[4-6\]\]
    Enter input string to search: 3
    No match found.

    Enter your regex: \[2-8&&\[4-6\]\]
    Enter input string to search: 4
    I found the text "4" starting at index 0 and ending at index 1.

    Enter your regex: \[2-8&&\[4-6\]\]
    Enter input string to search: 5
    I found the text "5" starting at index 0 and ending at index 1.

    Enter your regex: \[2-8&&\[4-6\]\]
    Enter input string to search: 6
    I found the text "6" starting at index 0 and ending at index 1.

    Enter your regex: \[2-8&&\[4-6\]\]
    Enter input string to search: 7
    No match found.

### Subtraction

Finally, you can use _subtraction_ to negate one or more nested character classes, such as `[0-9&&[^345]]`. This example creates a single character class that matches everything from 0 to 9, _except_ the numbers 3, 4, and 5.

 
    Enter your regex: \[0-9&&\[^345\]\]
    Enter input string to search: 2
    I found the text "2" starting at index 0 and ending at index 1.

    Enter your regex: \[0-9&&\[^345\]\]
    Enter input string to search: 3
    No match found.

    Enter your regex: \[0-9&&\[^345\]\]
    Enter input string to search: 4
    No match found.

    Enter your regex: \[0-9&&\[^345\]\]
    Enter input string to search: 5
    No match found.

    Enter your regex: \[0-9&&\[^345\]\]
    Enter input string to search: 6
    I found the text "6" starting at index 0 and ending at index 1.

    Enter your regex: \[0-9&&\[^345\]\]
    Enter input string to search: 9
    I found the text "9" starting at index 0 and ending at index 1.

Now that we've covered how character classes are created, You may want to review the [Character Classes table](#CHART) before continuing with the next section.



<a name="sec_13_5"></a>
## 13.5.  [Predefined Character Classes](#sec_13_5)
******
https://docs.oracle.com/javase/tutorial/essential/regex/pre_char_classes.html 

The [`Pattern`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html) API contains a number of useful _predefined character classes_, which offer convenient shorthands for commonly used regular expressions:

| Construct | Description |
|-----------|-------------|
| `.`  | Any character (may or may not match line terminators)
| `\d` | A digit: `[0-9]`
| `\D` | A non-digit: `[^0-9]`
| `\s` | A whitespace character: `[ \t\n\x0B\f\r]`
| `\S` | A non-whitespace character: `[^\s]`
| `\w` | A word character: `[a-zA-Z_0-9]`
| `\W` | A non-word character: `[^\w]`

In the table above, each construct in the left-hand column is shorthand for the character class in the right-hand column. For example, `\d` means a range of digits (0-9), and `\w` means a word character (any lowercase letter, any uppercase letter, the underscore character, or any digit). Use the predefined classes whenever possible. They make your code easier to read and eliminate errors introduced by malformed character classes.

Constructs beginning with a backslash are called _escaped constructs_. We previewed escaped constructs in the [String Literals](literals.html) section where we mentioned the use of backslash and `\Q` and `\E` for quotation. If you are using an escaped construct within a string literal, you must precede the backslash with another backslash for the string to compile. For example:

 
private final String REGEX = "\\\\d"; // a single digit

In this example `\d` is the regular expression; the extra backslash is required for the code to compile. The test harness reads the expressions directly from the `Console`, however, so the extra backslash is unnecessary.

The following examples demonstrate the use of predefined character classes.

 
    Enter your regex: .
    Enter input string to search: @
    I found the text "@" starting at index 0 and ending at index 1.

    Enter your regex: . 
    Enter input string to search: 1
    I found the text "1" starting at index 0 and ending at index 1.

    Enter your regex: .
    Enter input string to search: a
    I found the text "a" starting at index 0 and ending at index 1.

    Enter your regex: \\d
    Enter input string to search: 1
    I found the text "1" starting at index 0 and ending at index 1.

    Enter your regex: \\d
    Enter input string to search: a
    No match found.

    Enter your regex: \\D
    Enter input string to search: 1
    No match found.

    Enter your regex: \\D
    Enter input string to search: a
    I found the text "a" starting at index 0 and ending at index 1.

    Enter your regex: \\s
    Enter input string to search:  
    I found the text " " starting at index 0 and ending at index 1.

    Enter your regex: \\s
    Enter input string to search: a
    No match found.

    Enter your regex: \\S
    Enter input string to search:  
    No match found.

    Enter your regex: \\S
    Enter input string to search: a
    I found the text "a" starting at index 0 and ending at index 1.

    Enter your regex: \\w
    Enter input string to search: a
    I found the text "a" starting at index 0 and ending at index 1.

    Enter your regex: \\w
    Enter input string to search: !
    No match found.

    Enter your regex: \\W
    Enter input string to search: a
    No match found.

    Enter your regex: \\W
    Enter input string to search: !
    I found the text "!" starting at index 0 and ending at index 1.

In the first three examples, the regular expression is simply `.` (the "dot" metacharacter) that indicates "any character." Therefore, the match is successful in all three cases (a randomly selected `@` character, a digit, and a letter). The remaining examples each use a single regular expression construct from the [Predefined Character Classes table](#CHART). You can refer to this table to figure out the logic behind each match:

*   `\d` matches all digits
*   `\s` matches spaces
*   `\w` matches word characters

Alternatively, a capital letter means the opposite:

*   `\D` matches non-digits
*   `\S` matches non-spaces
*   `\W` matches non-word characters



<a name="sec_13_6"></a>
## 13.6.  [Quantifiers](#sec_13_6)
******
https://docs.oracle.com/javase/tutorial/essential/regex/quant.html 

_Quantifiers_ allow you to specify the number of occurrences to match against. For convenience, the three sections of the Pattern API specification describing greedy, reluctant, and possessive quantifiers are presented below. At first glance it may appear that the quantifiers `X?`, `X??` and `X?+` do exactly the same thing, since they all promise to match "`X`, once or not at all". There are subtle implementation differences which will be explained near the end of this section.

| Greedy | Reluctant | Possessive | Meaning |
|--------|-----------|------------|---------|
| `X?`   | `X??` | `X?+` | `X`, once or not at all
| `X*`   | `X*?` | `X*+` | `X`, zero or more times
| `X+`   | `X+?` | `X++` | `X`, one or more times
| `X{n}` | `X{n}?` | `X{n}+` | `X`, exactly _`n`_ times
| `X{n,}` | `X{n,}?` | `X{n,}+` | `X`, at least _`n`_ times
| `X{n,m}` | `X{n,m}?` | `X{n,m}+` | `X`, at least _`n`_ but not more than _`m`_ times

Let's start our look at greedy quantifiers by creating three different regular expressions: the letter "a" followed by either `?`, `*`, or `+`. Let's see what happens when these expressions are tested against an empty input string `""`:

    Enter your regex: a?
    Enter input string to search: 
    I found the text "" starting at index 0 and ending at index 0.

    Enter your regex: a*
    Enter input string to search: 
    I found the text "" starting at index 0 and ending at index 0.

    Enter your regex: a+
    Enter input string to search: 
    No match found.
 

Zero-Length Matches
-------------------

In the above example, the match is successful in the first two cases because the expressions `a?` and `a*` both allow for zero occurrences of the letter `a`. You'll also notice that the start and end indices are both zero, which is unlike any of the examples we've seen so far. The empty input string `""` has no length, so the test simply matches nothing at index 0. Matches of this sort are known as a _zero-length matches_. A zero-length match can occur in several cases: in an empty input string, at the beginning of an input string, after the last character of an input string, or in between any two characters of an input string. Zero-length matches are easily identifiable because they always start and end at the same index position.

Let's explore zero-length matches with a few more examples. Change the input string to a single letter "a" and you'll notice something interesting:

 
    Enter your regex: a?
    Enter input string to search: a
    I found the text "a" starting at index 0 and ending at index 1.
    I found the text "" starting at index 1 and ending at index 1.

    Enter your regex: a*
    Enter input string to search: a
    I found the text "a" starting at index 0 and ending at index 1.
    I found the text "" starting at index 1 and ending at index 1.

    Enter your regex: a+
    Enter input string to search: a
    I found the text "a" starting at index 0 and ending at index 1.

All three quantifiers found the letter "a", but the first two also found a zero-length match at index 1; that is, after the last character of the input string. Remember, the matcher sees the character "a" as sitting in the cell between index 0 and index 1, and our test harness loops until it can no longer find a match. Depending on the quantifier used, the presence of "nothing" at the index after the last character may or may not trigger a match.

Now change the input string to the letter "a" five times in a row and you'll get the following:

 
    Enter your regex: a?
    Enter input string to search: aaaaa
    I found the text "a" starting at index 0 and ending at index 1.
    I found the text "a" starting at index 1 and ending at index 2.
    I found the text "a" starting at index 2 and ending at index 3.
    I found the text "a" starting at index 3 and ending at index 4.
    I found the text "a" starting at index 4 and ending at index 5.
    I found the text "" starting at index 5 and ending at index 5.

    Enter your regex: a*
    Enter input string to search: aaaaa
    I found the text "aaaaa" starting at index 0 and ending at index 5.
    I found the text "" starting at index 5 and ending at index 5.

    Enter your regex: a+
    Enter input string to search: aaaaa
    I found the text "aaaaa" starting at index 0 and ending at index 5.

The expression `a?` finds an individual match for each character, since it matches when "a" appears zero or one times. The expression `a*` finds two separate matches: all of the letter "a"'s in the first match, then the zero-length match after the last character at index 5. And finally, `a+` matches all occurrences of the letter "a", ignoring the presence of "nothing" at the last index.

At this point, you might be wondering what the results would be if the first two quantifiers encounter a letter other than "a". For example, what happens if it encounters the letter "b", as in "ababaaaab"?

Let's find out:

 
    Enter your regex: a?
    Enter input string to search: ababaaaab
    I found the text "a" starting at index 0 and ending at index 1.
    I found the text "" starting at index 1 and ending at index 1.
    I found the text "a" starting at index 2 and ending at index 3.
    I found the text "" starting at index 3 and ending at index 3.
    I found the text "a" starting at index 4 and ending at index 5.
    I found the text "a" starting at index 5 and ending at index 6.
    I found the text "a" starting at index 6 and ending at index 7.
    I found the text "a" starting at index 7 and ending at index 8.
    I found the text "" starting at index 8 and ending at index 8.
    I found the text "" starting at index 9 and ending at index 9.

    Enter your regex: a*
    Enter input string to search: ababaaaab
    I found the text "a" starting at index 0 and ending at index 1.
    I found the text "" starting at index 1 and ending at index 1.
    I found the text "a" starting at index 2 and ending at index 3.
    I found the text "" starting at index 3 and ending at index 3.
    I found the text "aaaa" starting at index 4 and ending at index 8.
    I found the text "" starting at index 8 and ending at index 8.
    I found the text "" starting at index 9 and ending at index 9.

    Enter your regex: a+
    Enter input string to search: ababaaaab
    I found the text "a" starting at index 0 and ending at index 1.
    I found the text "a" starting at index 2 and ending at index 3.
    I found the text "aaaa" starting at index 4 and ending at index 8.

Even though the letter "b" appears in cells 1, 3, and 8, the output reports a zero-length match at those locations. The regular expression `a?` is not specifically looking for the letter "b"; it's merely looking for the presence (or lack thereof) of the letter "a". If the quantifier allows for a match of "a" zero times, anything in the input string that's not an "a" will show up as a zero-length match. The remaining a's are matched according to the rules discussed in the previous examples.

To match a pattern exactly _n_ number of times, simply specify the number inside a set of braces:

     
    Enter your regex: a{3}
    Enter input string to search: aa
    No match found.

    Enter your regex: a{3}
    Enter input string to search: aaa
    I found the text "aaa" starting at index 0 and ending at index 3.

    Enter your regex: a{3}
    Enter input string to search: aaaa
    I found the text "aaa" starting at index 0 and ending at index 3.

Here, the regular expression `a{3}` is searching for three occurrences of the letter "a" in a row. The first test fails because the input string does not have enough a's to match against. The second test contains exactly 3 a's in the input string, which triggers a match. The third test also triggers a match because there are exactly 3 a's at the beginning of the input string. Anything following that is irrelevant to the first match. If the pattern should appear again after that point, it would trigger subsequent matches:

 
    Enter your regex: a{3}
    Enter input string to search: aaaaaaaaa
    I found the text "aaa" starting at index 0 and ending at index 3.
    I found the text "aaa" starting at index 3 and ending at index 6.
    I found the text "aaa" starting at index 6 and ending at index 9.

To require a pattern to appear at least _n_ times, add a comma after the number:

 
    Enter your regex: a{3,}
    Enter input string to search: aaaaaaaaa
    I found the text "aaaaaaaaa" starting at index 0 and ending at index 9.

With the same input string, this test finds only one match, because the 9 a's in a row satisfy the need for "at least" 3 a's.

Finally, to specify an upper limit on the number of occurrences, add a second number inside the braces:

 
    Enter your regex: a{3,6} // find at least 3 (but no more than 6) a's in a row
    Enter input string to search: aaaaaaaaa
    I found the text "aaaaaa" starting at index 0 and ending at index 6.
    I found the text "aaa" starting at index 6 and ending at index 9.

Here the first match is forced to stop at the upper limit of 6 characters. The second match includes whatever is left over, which happens to be three a's ‚Äî the minimum number of characters allowed for this match. If the input string were one character shorter, there would not be a second match since only two a's would remain.

Capturing Groups and Character Classes with Quantifiers
-------------------------------------------------------

Until now, we've only tested quantifiers on input strings containing one character. In fact, quantifiers can only attach to one character at a time, so the regular expression "abc+" would mean "a, followed by b, followed by c one or more times". It would not mean "abc" one or more times. However, quantifiers can also attach to [Character Classes](char_classes.html) and [Capturing Groups](groups.html), such as `[abc]+` (a or b or c, one or more times) or `(abc)+` (the group "abc", one or more times).

Let's illustrate by specifying the group `(dog)`, three times in a row.

 
    Enter your regex: (dog){3}
    Enter input string to search: dogdogdogdogdogdog
    I found the text "dogdogdog" starting at index 0 and ending at index 9.
    I found the text "dogdogdog" starting at index 9 and ending at index 18.

    Enter your regex: dog{3}
    Enter input string to search: dogdogdogdogdogdog
    No match found.

Here the first example finds three matches, since the quantifier applies to the entire capturing group. Remove the parentheses, however, and the match fails because the quantifier `{3}` now applies only to the letter "g".

Similarly, we can apply a quantifier to an entire character class:

    Enter your regex: \[abc\]{3}
    Enter input string to search: abccabaaaccbbbc
    I found the text "abc" starting at index 0 and ending at index 3.
    I found the text "cab" starting at index 3 and ending at index 6.
    I found the text "aaa" starting at index 6 and ending at index 9.
    I found the text "ccb" starting at index 9 and ending at index 12.
    I found the text "bbc" starting at index 12 and ending at index 15.

    Enter your regex: abc{3}
    Enter input string to search: abccabaaaccbbbc
    No match found.

Here the quantifier `{3}` applies to the entire character class in the first example, but only to the letter "c" in the second.

Differences Among Greedy, Reluctant, and Possessive Quantifiers
---------------------------------------------------------------

There are subtle differences among greedy, reluctant, and possessive quantifiers.

Greedy quantifiers are considered "greedy" because they force the matcher to read in, or _eat_, the entire input string prior to attempting the first match. If the first match attempt (the entire input string) fails, the matcher backs off the input string by one character and tries again, repeating the process until a match is found or there are no more characters left to back off from. Depending on the quantifier used in the expression, the last thing it will try matching against is 1 or 0 characters.

The reluctant quantifiers, however, take the opposite approach: They start at the beginning of the input string, then reluctantly eat one character at a time looking for a match. The last thing they try is the entire input string.

Finally, the possessive quantifiers always eat the entire input string, trying once (and only once) for a match. Unlike the greedy quantifiers, possessive quantifiers never back off, even if doing so would allow the overall match to succeed.

To illustrate, consider the input string `xfooxxxxxxfoo`.

 
    Enter your regex: .*foo  // greedy quantifier
    Enter input string to search: xfooxxxxxxfoo
    I found the text "xfooxxxxxxfoo" starting at index 0 and ending at index 13.

    Enter your regex: .*?foo  // reluctant quantifier
    Enter input string to search: xfooxxxxxxfoo
    I found the text "xfoo" starting at index 0 and ending at index 4.
    I found the text "xxxxxxfoo" starting at index 4 and ending at index 13.

    Enter your regex: .*+foo // possessive quantifier
    Enter input string to search: xfooxxxxxxfoo
    No match found.

The first example uses the greedy quantifier `.*` to find "anything", zero or more times, followed by the letters `"f" "o" "o"`. Because the quantifier is greedy, the `.*` portion of the expression first eats the entire input string. At this point, the overall expression cannot succeed, because the last three letters (`"f" "o" "o"`) have already been consumed. So the matcher slowly backs off one letter at a time until the rightmost occurrence of "foo" has been regurgitated, at which point the match succeeds and the search ends.

The second example, however, is reluctant, so it starts by first consuming "nothing". Because "foo" doesn't appear at the beginning of the string, it's forced to swallow the first letter (an "x"), which triggers the first match at 0 and 4. Our test harness continues the process until the input string is exhausted. It finds another match at 4 and 13.

The third example fails to find a match because the quantifier is possessive. In this case, the entire input string is consumed by `.*+`, leaving nothing left over to satisfy the "foo" at the end of the expression. Use a possessive quantifier for situations where you want to seize all of something without ever backing off; it will outperform the equivalent greedy quantifier in cases where the match is not immediately found.



<a name="sec_13_7"></a>
## 13.7.  [Capturing Groups](#sec_13_7)
******
https://docs.oracle.com/javase/tutorial/essential/regex/groups.html 

In the [previous section](quant.html), we saw how quantifiers attach to one character, character class, or capturing group at a time. But until now, we have not discussed the notion of capturing groups in any detail.

_Capturing groups_ are a way to treat multiple characters as a single unit. They are created by placing the characters to be grouped inside a set of parentheses. For example, the regular expression `(dog)` creates a single group containing the letters `"d" "o"` and `"g"`. The portion of the input string that matches the capturing group will be saved in memory for later recall via backreferences (as discussed below in the section, [Backreferences](#backref)).

Numbering
---------

As described in the [`Pattern`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html) API, capturing groups are numbered by counting their opening parentheses from left to right. In the expression `((A)(B(C)))`, for example, there are four such groups:

1.  `((A)(B(C)))`
2.  `(A)`
3.  `(B(C))`
4.  `(C)`

To find out how many groups are present in the expression, call the `groupCount` method on a matcher object. The `groupCount` method returns an `int` showing the number of capturing groups present in the matcher's pattern. In this example, `groupCount` would return the number `4`, showing that the pattern contains 4 capturing groups.

There is also a special group, group 0, which always represents the entire expression. This group is not included in the total reported by `groupCount`. Groups beginning with `(?` are pure, _non-capturing groups_ that do not capture text and do not count towards the group total. (You'll see examples of non-capturing groups later in the section [Methods of the Pattern Class](pattern.html).)

It's important to understand how groups are numbered because some `Matcher` methods accept an `int` specifying a particular group number as a parameter:

*   [`public int start(int group)`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#start-int-): Returns the start index of the subsequence captured by the given group during the previous match operation.
*   [`public int end (int group)`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#end-int-): Returns the index of the last character, plus one, of the subsequence captured by the given group during the previous match operation.
*   [`public String group (int group)`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#group-int-): Returns the input subsequence captured by the given group during the previous match operation.

Backreferences
--------------

The section of the input string matching the capturing group(s) is saved in memory for later recall via _backreference_. A backreference is specified in the regular expression as a backslash (`\`) followed by a digit indicating the number of the group to be recalled. For example, the expression `(\d\d)` defines one capturing group matching two digits in a row, which can be recalled later in the expression via the backreference `\1`.

To match any 2 digits, followed by the exact same two digits, you would use `(\d\d)\1` as the regular expression:

     
    Enter your regex: (\\d\\d)\\1
    Enter input string to search: 1212
    I found the text "1212" starting at index 0 and ending at index 4.

    If you change the last two digits the match will fail:

     
    Enter your regex: (\\d\\d)\\1
    Enter input string to search: 1234
    No match found.

For nested capturing groups, backreferencing works in exactly the same way: Specify a backslash followed by the number of the group to be recalled.



<a name="sec_13_8"></a>
## 13.8.  [Boundary Matchers](#sec_13_8)
******
https://docs.oracle.com/javase/tutorial/essential/regex/bounds.html 

Until now, we've only been interested in whether or not a match is found _at some location_ within a particular input string. We never cared about _where_ in the string the match was taking place.

You can make your pattern matches more precise by specifying such information with _boundary matchers_. For example, maybe you're interested in finding a particular word, but only if it appears at the beginning or end of a line. Or maybe you want to know if the match is taking place on a word boundary, or at the end of the previous match.

The following table lists and explains all the boundary matchers.

| Boundary Construct | Description |
|--------------------|-------------|
| `^`  | The beginning of a line
| `$`  | The end of a line
| `\b` | A word boundary
| `\B` | A non-word boundary
| `\A` | The beginning of the input
| `\G` | The end of the previous match
| `\Z` | The end of the input but for the final terminator, if any
| `\z` | The end of the input

The following examples demonstrate the use of boundary matchers `^` and `$`. As noted above, `^` matches the beginning of a line, and `$` matches the end.

 
    Enter your regex: ^dog$
    Enter input string to search: dog
    I found the text "dog" starting at index 0 and ending at index 3.

    Enter your regex: ^dog$
    Enter input string to search:       dog
    No match found.

    Enter your regex: \s*dog$
    Enter input string to search:             dog
    I found the text "            dog" starting at index 0 and ending at index 15.

    Enter your regex: ^dog\w*
    Enter input string to search: dogblahblah
    I found the text "dogblahblah" starting at index 0 and ending at index 11.

The first example is successful because the pattern occupies the entire input string. The second example fails because the input string contains extra whitespace at the beginning. The third example specifies an expression that allows for unlimited white space, followed by "dog" on the end of the line. The fourth example requires "dog" to be present at the beginning of a line followed by an unlimited number of word characters.

To check if a pattern begins and ends on a word boundary (as opposed to a substring within a longer string), just use `\b` on either side; for example, `\bdog\b`

 
    Enter your regex: \bdog\b
    Enter input string to search: The dog plays in the yard.
    I found the text "dog" starting at index 4 and ending at index 7.

    Enter your regex: \bdog\b
    Enter input string to search: The doggie plays in the yard.
    No match found.


To match the expression on a non-word boundary, use `\B` instead:

    Enter your regex: \bdog\B
    Enter input string to search: The dog plays in the yard.
    No match found.

    Enter your regex: \bdog\B
    Enter input string to search: The doggie plays in the yard.
    I found the text "dog" starting at index 4 and ending at index 7.
 

To require the match to occur only at the end of the previous match, use `\G`:

    Enter your regex: dog 
    Enter input string to search: dog dog
    I found the text "dog" starting at index 0 and ending at index 3.
    I found the text "dog" starting at index 4 and ending at index 7.

    Enter your regex: \Gdog 
    Enter input string to search: dog dog
    I found the text "dog" starting at index 0 and ending at index 3.
 

Here the second example finds only one match, because the second occurrence of "dog" does not start at the end of the previous match.



<a name="sec_13_9"></a>
## 13.9.  [Methods of the Pattern Class](#sec_13_9)
******
https://docs.oracle.com/javase/tutorial/essential/regex/pattern.html 

Until now, we've only used the test harness to create `Pattern` objects in their most basic form. This section explores advanced techniques such as creating patterns with flags and using embedded flag expressions. It also explores some additional useful methods that we haven't yet discussed.

Creating a Pattern with Flags
-----------------------------

The `Pattern` class defines an alternate `compile` method that accepts a set of flags affecting the way the pattern is matched. The flags parameter is a bit mask that may include any of the following public static fields:

*   [`Pattern.CANON_EQ`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#CANON_EQ) Enables canonical equivalence. When this flag is specified, two characters will be considered to match if, and only if, their full canonical decompositions match. The expression `"a\u030A"`, for example, will match the string `"\u00E5"` when this flag is specified. By default, matching does not take canonical equivalence into account. Specifying this flag may impose a performance penalty.
*   [`Pattern.CASE_INSENSITIVE`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#CASE_INSENSITIVE) Enables case-insensitive matching. By default, case-insensitive matching assumes that only characters in the US-ASCII charset are being matched. Unicode-aware case-insensitive matching can be enabled by specifying the UNICODE_CASE flag in conjunction with this flag. Case-insensitive matching can also be enabled via the embedded flag expression `(?i)`. Specifying this flag may impose a slight performance penalty.
*   [`Pattern.COMMENTS`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#COMMENTS) Permits whitespace and comments in the pattern. In this mode, whitespace is ignored, and embedded comments starting with `#` are ignored until the end of a line. Comments mode can also be enabled via the embedded flag expression `(?x)`.
*   [`Pattern.DOTALL`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#DOTALL) Enables dotall mode. In dotall mode, the expression `.` matches any character, including a line terminator. By default this expression does not match line terminators. Dotall mode can also be enabled via the embedded flag expression `(?s)`. (The s is a mnemonic for "single-line" mode, which is what this is called in Perl.)
*   [`Pattern.LITERAL`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#LITERAL) Enables literal parsing of the pattern. When this flag is specified then the input string that specifies the pattern is treated as a sequence of literal characters. Metacharacters or escape sequences in the input sequence will be given no special meaning. The flags `CASE_INSENSITIVE` and `UNICODE_CASE` retain their impact on matching when used in conjunction with this flag. The other flags become superfluous. There is no embedded flag character for enabling literal parsing.
*   [`Pattern.MULTILINE`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#MULTILINE) Enables multiline mode. In multiline mode the expressions `^` and `$` match just after or just before, respectively, a line terminator or the end of the input sequence. By default these expressions only match at the beginning and the end of the entire input sequence. Multiline mode can also be enabled via the embedded flag expression `(?m)`.
*   [`Pattern.UNICODE_CASE`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#UNICODE_CASE) Enables Unicode-aware case folding. When this flag is specified then case-insensitive matching, when enabled by the `CASE_INSENSITIVE` flag, is done in a manner consistent with the Unicode Standard. By default, case-insensitive matching assumes that only characters in the US-ASCII charset are being matched. Unicode-aware case folding can also be enabled via the embedded flag expression `(?u)`. Specifying this flag may impose a performance penalty.
*   [`Pattern.UNIX_LINES`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#UNIX_LINES) Enables UNIX lines mode. In this mode, only the `'\n'` line terminator is recognized in the behavior of `.`, `^`, and `$`. UNIX lines mode can also be enabled via the embedded flag expression `(?d)`.

In the following steps we will modify the test harness, [`RegexTestHarness.java`](https://docs.oracle.com/javase/tutorial/essential/regex/examples/RegexTestHarness.java) to create a pattern with case-insensitive matching.

First, modify the code to invoke the alternate version of `compile`:

Pattern pattern = 
Pattern.compile(console.readLine("%nEnter your regex: "),
Pattern.CASE_INSENSITIVE);

Then compile and run the test harness to get the following results:

 
    Enter your regex: dog
    Enter input string to search: DoGDOg
    I found the text "DoG" starting at index 0 and ending at index 3.
    I found the text "DOg" starting at index 3 and ending at index 6.

As you can see, the string literal "dog" matches both occurences, regardless of case. To compile a pattern with multiple flags, separate the flags to be included using the bitwise OR operator "`|`". For clarity, the following code samples hardcode the regular expression instead of reading it from the `Console`:

 
pattern = Pattern.compile("[az]$", Pattern.MULTILINE **|** Pattern.UNIX_LINES);

You could also specify an `int` variable instead:

 
final int flags = Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE;
Pattern pattern = Pattern.compile("aa", flags);

Embedded Flag Expressions
-------------------------

It's also possible to enable various flags using _embedded flag expressions_. Embedded flag expressions are an alternative to the two-argument version of `compile`, and are specified in the regular expression itself. The following example uses the original test harness, [`RegexTestHarness.java`](examples/RegexTestHarness.java) with the embedded flag expression `(?i)` to enable case-insensitive matching.

 
Enter your regex: (?i)foo
Enter input string to search: FOOfooFoOfoO
I found the text "FOO" starting at index 0 and ending at index 3.
I found the text "foo" starting at index 3 and ending at index 6.
I found the text "FoO" starting at index 6 and ending at index 9.
I found the text "foO" starting at index 9 and ending at index 12.

Once again, all matches succeed regardless of case.

The embedded flag expressions that correspond to `Pattern`'s publicly accessible fields are presented in the following table:

|          Constant          | Equivalent Embedded Flag Expression |
|----------------------------|-------------------------------------|
| `Pattern.CANON_EQ`         | None                                |
| `Pattern.CASE_INSENSITIVE` | `(?i)`                              |
| `Pattern.COMMENTS`         | `(?x)`                              |
| `Pattern.MULTILINE`        | `(?m)`                              |
| `Pattern.DOTALL`           | `(?s)`                              |
| `Pattern.LITERAL`          | None                                |
| `Pattern.UNICODE_CASE`     | `(?u)`                              |
| `Pattern.UNIX_LINES`       | `(?d)`                              |

Using the `matches(String,CharSequence)` Method
-----------------------------------------------

The `Pattern` class defines a convenient [`matches`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#matches-java.lang.String-java.lang.CharSequence-) method that allows you to quickly check if a pattern is present in a given input string. As with all public static methods, you should invoke `matches` by its class name, such as `Pattern.matches("\d","1");`. In this example, the method returns `true`, because the digit "1" matches the regular expression `\d`.

Using the `split(String)` Method
--------------------------------

The [`split`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#split-java.lang.CharSequence-) method is a great tool for gathering the text that lies on either side of the pattern that's been matched. As shown below in [`SplitDemo.java`](examples/SplitDemo.java), the `split` method could extract the words "`one two three four five`" from the string "`one:two:three:four:five`":

```java
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class SplitDemo {

    private static final String REGEX = ":";
    private static final String INPUT =
        "one:two:three:four:five";
    
    public static void main(String[] args) {
        Pattern p = Pattern.compile(REGEX);
        String[] items = p.split(INPUT);
        for(String s : items) {
            System.out.println(s);
        }
    }
}
```

OUTPUT:

    one
    two
    three
    four
    five

For simplicity, we've matched a string literal, the colon (`:`) instead of a complex regular expression. Since we're still using `Pattern` and `Matcher` objects, you can use split to get the text that falls on either side of any regular expression. Here's the same example, [`SplitDemo2.java`](examples/SplitDemo2.java), modified to split on digits instead:

```java
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class SplitDemo2 {

    private static final String REGEX = "\\d";
    private static final String INPUT =
        "one9two4three7four1five";

    public static void main(String[] args) {
        Pattern p = Pattern.compile(REGEX);
        String[] items = p.split(INPUT);
        for(String s : items) {
            System.out.println(s);
        }
    }
}
```

OUTPUT:

    one
    two
    three
    four
    five

Other Utility Methods
---------------------

You may find the following methods to be of some use as well:

*   [`public static String quote(String s)`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#quote-java.lang.String-) Returns a literal pattern `String` for the specified `String`. This method produces a `String` that can be used to create a `Pattern` that would match `String s` as if it were a literal pattern. Metacharacters or escape sequences in the input sequence will be given no special meaning.
*   [`public String toString()`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#toString--) Returns the `String` representation of this pattern. This is the regular expression from which this pattern was compiled.

Pattern Method Equivalents in `java.lang.String`
------------------------------------------------

Regular expression support also exists in `java.lang.String` through several methods that mimic the behavior of `java.util.regex.Pattern`. For convenience, key excerpts from their API are presented below.

*   [`public boolean matches(String regex)`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#matches-java.lang.String-): Tells whether or not this string matches the given regular expression. An invocation of this method of the form `_str_.matches(_regex_)` yields exactly the same result as the expression `Pattern.matches(_regex_, _str_)`.
*   [`public String[] split(String regex, int limit)`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-int-): Splits this string around matches of the given regular expression. An invocation of this method of the form `_str_.split(_regex_, _n_)` yields the same result as the expression `Pattern.compile(_regex_).split(_str_, _n_)`
*   [`public String[] split(String regex)`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-): Splits this string around matches of the given regular expression. This method works the same as if you invoked the two-argument split method with the given expression and a limit argument of zero. Trailing empty strings are not included in the resulting array.

There is also a replace method, that replaces one `CharSequence` with another:

*   [`public String replace(CharSequence target,CharSequence replacement)`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#replace-java.lang.CharSequence-java.lang.CharSequence-): Replaces each substring of this string that matches the literal target sequence with the specified literal replacement sequence. The replacement proceeds from the beginning of the string to the end, for example, replacing "aa" with "b" in the string "aaa" will result in "ba" rather than "ab".



<a name="sec_13_10"></a>
## 13.10. [Methods of the Matcher Class](#sec_13_10)
******
https://docs.oracle.com/javase/tutorial/essential/regex/matcher.html 

This section describes some additional useful methods of the `Matcher` class. For convenience, the methods listed below are grouped according to functionality.

Index Methods
-------------

_Index methods_ provide useful index values that show precisely where the match was found in the input string:

*   [`public int start()`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#start--): Returns the start index of the previous match.
*   [`public int start(int group)`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#start-int-): Returns the start index of the subsequence captured by the given group during the previous match operation.
*   [`public int end()`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#end--): Returns the offset after the last character matched.
*   [`public int end(int group)`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#end-int-): Returns the offset after the last character of the subsequence captured by the given group during the previous match operation.

Study Methods
-------------

_Study methods_ review the input string and return a boolean indicating whether or not the pattern is found.

*   [`public boolean lookingAt()`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#lookingAt--): Attempts to match the input sequence, starting at the beginning of the region, against the pattern.
*   [`public boolean find()`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#find--): Attempts to find the next subsequence of the input sequence that matches the pattern.
*   [`public boolean find(int start)`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#find-int-): Resets this matcher and then attempts to find the next subsequence of the input sequence that matches the pattern, starting at the specified index.
*   [`public boolean matches()`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#matches--): Attempts to match the entire region against the pattern.

Replacement Methods
-------------------

_Replacement methods_ are useful methods for replacing text in an input string.

*   [`public Matcher appendReplacement(StringBuffer sb, String replacement)`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#appendReplacement-java.lang.StringBuffer-java.lang.String-): Implements a non-terminal append-and-replace step.
*   [`public StringBuffer appendTail(StringBuffer sb)`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#appendTail-java.lang.StringBuffer-): Implements a terminal append-and-replace step.
*   [`public String replaceAll(String replacement)`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#replaceAll-java.lang.String-): Replaces every subsequence of the input sequence that matches the pattern with the given replacement string.
*   [`public String replaceFirst(String replacement)`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#replaceFirst-java.lang.String-): Replaces the first subsequence of the input sequence that matches the pattern with the given replacement string.
*   [`public static String quoteReplacement(String s)`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#quoteReplacement-java.lang.String-): Returns a literal replacement `String` for the specified `String`. This method produces a `String` that will work as a literal replacement `s` in the `appendReplacement` method of the `Matcher` class. The `String` produced will match the sequence of characters in `s` treated as a literal sequence. Slashes (`'\'`) and dollar signs (`'$'`) will be given no special meaning.

Using the `start` and `end` Methods
-----------------------------------

Here's an example, [`MatcherDemo.java`](examples/MatcherDemo.java), that counts the number of times the word "dog" appears in the input string.

```java
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class MatcherDemo {

    private static final String REGEX =
        "\\bdog\\b";
    private static final String INPUT =
        "dog dog dog doggie dogg";

    public static void main(String[] args) {
       Pattern p = Pattern.compile(REGEX);
       //  get a matcher object
       Matcher m = p.matcher(INPUT);
       int count = 0;
       while(m.find()) {
           count++;
           System.out.println("Match number "
                              + count);
           System.out.println("start(): "
                              + m.start());
           System.out.println("end(): "
                              + m.end());
      }
   }
}
```

OUTPUT:

    Match number 1
    start(): 0
    end(): 3
    Match number 2
    start(): 4
    end(): 7
    Match number 3
    start(): 8
    end(): 11

You can see that this example uses word boundaries to ensure that the letters `"d" "o" "g"` are not merely a substring in a longer word. It also gives some useful information about where in the input string the match has occurred. The `start` method returns the start index of the subsequence captured by the given group during the previous match operation, and `end` returns the index of the last character matched, plus one.

Using the `matches` and `lookingAt` Methods
-------------------------------------------

The `matches` and `lookingAt` methods both attempt to match an input sequence against a pattern. The difference, however, is that `matches` requires the entire input sequence to be matched, while `lookingAt` does not. Both methods always start at the beginning of the input string. Here's the full code, [`MatchesLooking.java`](examples/MatchesLooking.java):

```java
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class MatchesLooking {

    private static final String REGEX = "foo";
    private static final String INPUT =
        "fooooooooooooooooo";
    private static Pattern pattern;
    private static Matcher matcher;

    public static void main(String[] args) {
   
        // Initialize
        pattern = Pattern.compile(REGEX);
        matcher = pattern.matcher(INPUT);

        System.out.println("Current REGEX is: "
                           + REGEX);
        System.out.println("Current INPUT is: "
                           + INPUT);

        System.out.println("lookingAt(): "
            + matcher.lookingAt());
        System.out.println("matches(): "
            + matcher.matches());
    }
}
```

Current REGEX is: foo
Current INPUT is: fooooooooooooooooo
lookingAt(): true
matches(): false

Using `replaceFirst(String)` and `replaceAll(String)`
-----------------------------------------------------

The `replaceFirst` and `replaceAll` methods replace text that matches a given regular expression. As their names indicate, `replaceFirst` replaces the first occurrence, and `replaceAll` replaces all occurrences. Here's the [`ReplaceDemo.java`](examples/ReplaceDemo.java) code:

```java
import java.util.regex.Pattern; 
import java.util.regex.Matcher;

public class ReplaceDemo {
 
    private static String REGEX = "dog";
    private static String INPUT =
        "The dog says meow. All dogs say meow.";
    private static String REPLACE = "cat";
 
    public static void main(String[] args) {
        Pattern p = Pattern.compile(REGEX);
        // get a matcher object
        Matcher m = p.matcher(INPUT);
        INPUT = m.replaceAll(REPLACE);
        System.out.println(INPUT);
    }
}
```

OUTPUT: The cat says meow. All cats say meow.

In this first version, all occurrences of `dog` are replaced with `cat`. But why stop here? Rather than replace a simple literal like `dog`, you can replace text that matches _any_ regular expression. The API for this method states that "given the regular expression `a*b`, the input `aabfooaabfooabfoob`, and the replacement string `-`, an invocation of this method on a matcher for that expression would yield the string `-foo-foo-foo-`."

Here's the [`ReplaceDemo2.java`](https://docs.oracle.com/javase/tutorial/essential/regex/examples/ReplaceDemo2.java) code:

```java
import java.util.regex.Pattern;
import java.util.regex.Matcher;
 
public class ReplaceDemo2 {
 
    private static String REGEX = "a*b";
    private static String INPUT =
        "aabfooaabfooabfoob";
    private static String REPLACE = "-";
 
    public static void main(String[] args) {
        Pattern p = Pattern.compile(REGEX);
        // get a matcher object
        Matcher m = p.matcher(INPUT);
        INPUT = m.replaceAll(REPLACE);
        System.out.println(INPUT);
    }
}
```

OUTPUT: -foo-foo-foo-

To replace only the first occurrence of the pattern, simply call `replaceFirst` instead of `replaceAll`. It accepts the same parameter.

Using `appendReplacement(StringBuffer,String)` and `appendTail(StringBuffer)`
-----------------------------------------------------------------------------

The `Matcher` class also provides `appendReplacement` and `appendTail` methods for text replacement. The following example, [`RegexDemo.java`](https://docs.oracle.com/javase/tutorial/essential/regex/examples/RegexDemo.java    ), uses these two methods to achieve the same effect as `replaceAll`.

```java
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class RegexDemo {
 
    private static String REGEX = "a*b";
    private static String INPUT = "aabfooaabfooabfoob";
    private static String REPLACE = "-";
 
    public static void main(String[] args) {
        Pattern p = Pattern.compile(REGEX);
        Matcher m = p.matcher(INPUT); // get a matcher object
        StringBuffer sb = new StringBuffer();
        while(m.find()){
            m.appendReplacement(sb,REPLACE);
        }
        m.appendTail(sb);
        System.out.println(sb.toString());
    }
}
```

OUTPUT: -foo-foo-foo- 

Matcher Method Equivalents in `java.lang.String`
------------------------------------------------

For convenience, the `String` class mimics a couple of `Matcher` methods as well:

*   [`public String replaceFirst(String regex, String replacement)`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#replaceFirst-java.lang.String-java.lang.String-): Replaces the first substring of this string that matches the given regular expression with the given replacement. An invocation of this method of the form `_str_.replaceFirst(_regex_, _repl_)` yields exactly the same result as the expression `Pattern.compile(_regex_).matcher(_str_).replaceFirst(_repl_)`
*   [`public String replaceAll(String regex, String replacement)`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#replaceAll-java.lang.String-java.lang.String-): Replaces each substring of this string that matches the given regular expression with the given replacement. An invocation of this method of the form `_str_.replaceAll(_regex_, _repl_)` yields exactly the same result as the expression `Pattern.compile(_regex_).matcher(_str_).replaceAll(_repl_)`



<a name="sec_13_11"></a>
## 13.11. [Methods of the PatternSyntaxException Class](#sec_13_11)
******
https://docs.oracle.com/javase/tutorial/essential/regex/pse.html 

A [`PatternSyntaxException`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html) is an unchecked exception that indicates a syntax error in a regular expression pattern. The `PatternSyntaxException` class provides the following methods to help you determine what went wrong:

*   [`public String getDescription()`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html#getDescription--): Retrieves the description of the error.
*   [`public int getIndex()`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html#getIndex--): Retrieves the error index.
*   [`public String getPattern()`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html#getPattern--): Retrieves the erroneous regular expression pattern.
*   [`public String getMessage()`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html#getMessage--): Returns a multi-line string containing the description of the syntax error and its index, the erroneous regular-expression pattern, and a visual indication of the error index within the pattern.

The following source code, [`RegexTestHarness2.java`](https://docs.oracle.com/javase/tutorial/essential/regex/examples/RegexTestHarness2.java), updates our test harness to check for malformed regular expressions:

```java
import java.io.Console;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.regex.PatternSyntaxException;

public class RegexTestHarness2 {

    public static void main(String\[\] args){
        Pattern pattern = null;
        Matcher matcher = null;

        Console console = System.console();
        if (console == null) {
            System.err.println("No console.");
            System.exit(1);
        }
        while (true) {
            try{
                pattern = 
                Pattern.compile(console.readLine("%nEnter your regex: "));

                matcher = 
                pattern.matcher(console.readLine("Enter input string to search: "));
            }
            catch(PatternSyntaxException pse){
                console.format("There is a problem" +
                               " with the regular expression!%n");
                console.format("The pattern in question is: %s%n",
                               pse.getPattern());
                console.format("The description is: %s%n",
                               pse.getDescription());
                console.format("The message is: %s%n",
                               pse.getMessage());
                console.format("The index is: %s%n",
                               pse.getIndex());
                System.exit(0);
            }
            boolean found = false;
            while (matcher.find()) {
                console.format("I found the text" +
                    " \\"%s\\" starting at " +
                    "index %d and ending at index %d.%n",
                    matcher.group(),
                    matcher.start(),
                    matcher.end());
                found = true;
            }
            if(!found){
                console.format("No match found.%n");
            }
        }
    }
}
```

To run this test, enter `?i)foo` as the regular expression. This mistake is a common scenario in which the programmer has forgotten the opening parenthesis in the embedded flag expression `(?i)`. Doing so will produce the following results:

    Enter your regex: ?i)
    There is a problem with the regular expression!
    The pattern in question is: ?i)
    The description is: Dangling meta character '?'
    The message is: Dangling meta character '?' near index 0
    ?i)
    ^
    The index is: 0

From this output, we can see that the syntax error is a dangling metacharacter (the question mark) at index 0. A missing opening parenthesis is the culprit.



<a name="sec_13_12"></a>
## 13.12. [Unicode Support](#sec_13_12)
******
https://docs.oracle.com/javase/tutorial/essential/regex/unicode.html 

Now that you've completed this lesson on regular expressions, you'll probably find that your main references will be the API documentation for the following classes: [`Pattern`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html), [`Matcher`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html), and [`PatternSyntaxException`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html).

For a more precise description of the behavior of regular expression constructs, we recommend reading the book [_Mastering Regular Expressions_](http://www.amazon.com/exec/obidos/ASIN/0596002890/javasoftsunmicroA/) by Jeffrey E. F. Friedl.



<a name="sec_13_13"></a>
## 13.13. [Additional Resources](#sec_13_13)
******
https://docs.oracle.com/javase/tutorial/essential/regex/resources.html 

Now that you've completed this lesson on regular expressions, you'll probably find that your main references will be the API documentation for the following classes: [`Pattern`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html), [`Matcher`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html), and [`PatternSyntaxException`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html).

For a more precise description of the behavior of regular expression constructs, we recommend reading the book [_Mastering Regular Expressions_](http://www.amazon.com/exec/obidos/ASIN/0596002890/javasoftsunmicroA/) by Jeffrey E. F. Friedl.



<a name="sec_13_14"></a>
## 13.14. [Questions and Exercises](#sec_13_14)
******
https://docs.oracle.com/javase/tutorial/essential/regex/QandE/answers.html 

Questions
---------

1.  What are the three public classes in the `java.util.regex` package? Describe the purpose of each.
2.  Consider the string literal `"foo"`. What is the start index? What is the end index? Explain what these numbers mean.
3.  What is the difference between an ordinary character and a metacharacter? Give an example of each.
4.  How do you force a metacharacter to act like an ordinary character?
5.  What do you call a set of characters enclosed in square brackets? What is it for?
6.  Here are three predefined character classes: `\d`, `\s`, and `\w`. Describe each one, and rewrite it using square brackets.
7.  For each of `\d`, `\s`, and `\w`, write _two_ simple expressions that match the _opposite_ set of characters.
8.  Consider the regular expression `(dog){3}`. Identify the two subexpressions. What string does the expression match?

Exercises
---------

1.  Use a backreference to write an expression that will match a person's name only if that person's first name and last name are the same.

[Check your answers.](answers.html)


Questions
---------

1.  Question: What are the three public classes in the `java.util.regex` package? Describe the purpose of each.
    
    Answer:
    
    *   `Pattern` instances are compiled representations of regular expressions.
    *   `Matcher` instances are engines that interpret patterns and perform match operations against input strings.
    *   `PatternSyntaxException` defines an unchecked exception indicating a syntax error in a regular expression.
2.  Question: Consider the string literal `"foo"`. What is the start index? What is the end index? Explain what these numbers mean.
    
    Answer: Each character in the string resides in its own cell. Index positions point between cells. The string `"foo"` starts at index 0 and ends at index 3, even though the characters only occupy cells 0, 1, and 2.
    
3.  Question: What is the difference between an ordinary character and a metacharacter? Give an example of each.
    
    Answer: An ordinary character in a regular expression matches itself. A metacharacter is a special character that affects the way a pattern is matched. The letter `A` is an ordinary character. The punctuation mark `.` is a metacharacter that matches any single character.
    
4.  Question: How do you force a metacharacter to act like an ordinary character?
    
    Answer: There are two ways:
    
    *   Precede the metacharacter with a backslash (`\`);
    *   Enclose the metacharacter within the quote expressions, `\Q` (at the beginning) and `\E` (at the end).
5.  Question: What do you call a set of characters enclosed in square brackets? What is it for?
    
    Answer: This is a character class. It matches any single character that is in the class of characters specified by the expression between the brackets.
    
6.  Question: Here are three predefined character classes: `\d`, `\s`, and `\w`. Describe each one, and rewrite it using square brackets.
    
    Answer:
    
    `\d`
    
    Matches any digit.
    
    `[0-9]`
    
    `\s`
    
    Matches any white space character.
    
    `[ \t\n-x0B\f\r]`
    
    `\w`
    
    Matches any word character.
    
    `[a-zA-Z_0-9]`
    
7.  Question: For each of `\d`, `\s`, and `\w`, write _two_ simple expressions that match the _opposite_ set of characters.
    
    Answer:
    
    `\d`
    
    `\D`
    
    `[^\d]`
    
    `\s`
    
    `\S`
    
    `[^\s]`
    
    `\w`
    
    `\W`
    
    `[^\w]`
    
8.  Question: Consider the regular expression `(dog){3}`. Identify the two subexpressions. What string does the expression match?
    
    Answer: The expression consists of a capturing group, `(dog)`, followed by a greedy quantifier `{3}`. It matches the string "dogdogdog".
    
    Exercises
    ---------
    
    1.  Exercise: Use a backreference to write an expression that will match a person's name only if that person's first name and last name are the same.
        
        Solution: `([A-Z][a-zA-Z]*)\s\1`


<a name="part_c"></a>

# üçÄ Trail: Collections
https://docs.oracle.com/javase/tutorial/collections/index.html

Now that you've completed this lesson on regular expressions, you'll probably find that your main references will be the API documentation for the following classes: [`Pattern`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html), [`Matcher`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html), and [`PatternSyntaxException`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html).

For a more precise description of the behavior of regular expression constructs, we recommend reading the book [_Mastering Regular Expressions_](http://www.amazon.com/exec/obidos/ASIN/0596002890/javasoftsunmicroA/) by Jeffrey E. F. Friedl.


This section describes the Java Collections Framework. Here, you will learn what collections are and how they can make your job easier and programs better. You'll learn about the core elements ‚Äî interfaces, implementations, aggregate operations, and algorithms ‚Äî that comprise the Java Collections Framework.

*  [**Introduction**] tells you what collections are, and how they'll make your job easier and your programs better. You'll learn about the core elements that comprise the Collections Framework: _interfaces_, _implementations_ and _algorithms_.

*  [**Interfaces**] describes the _core collection interfaces_, which are the heart and soul of the Java Collections Framework. You'll learn general guidelines for effective use of these interfaces, including when to use which interface. You'll also learn idioms for each interface that will help you get the most out of the interfaces.

*  [**Aggregate Operations**] iterate over collections on your behalf, which enable you to write more concise and efficient code that process elements stored in collections.

*  [**Implementations**] describes the JDK's _general-purpose collection implementations_ and tells you when to use which implementation. You'll also learn about the _wrapper implementations_, which add functionality to general-purpose implementations.

*  [**Algorithms**] describes the _polymorphic algorithms_ provided by the JDK to operate on collections. With any luck you'll never have to write your own sort routine again!

*  [**Custom Implementations**] tells you why you might want to write your own collection implementation (instead of using one of the general-purpose implementations provided by the JDK), and how you'd go about it. It's easy with the JDK's _abstract collection implementations_!

*  [**Interoperability**] tells you how the Collections Framework interoperates with older APIs that predate the addition of Collections to Java. Also, it tells you how to design new APIs so that they'll interoperate seamlessly with other new APIs.

<a name="sec_14"></a>
## 14. Introduction
******
https://docs.oracle.com/javase/tutorial/collections/intro/index.html

A _collection_ ‚Äî sometimes called a container ‚Äî is simply an object that groups multiple elements into a single unit. Collections are used to store, retrieve, manipulate, and communicate aggregate data. Typically, they represent data items that form a natural group, such as a poker hand (a collection of cards), a mail folder (a collection of letters), or a telephone directory (a mapping of names to phone numbers). If you have used the Java programming language ‚Äî or just about any other programming language ‚Äî you are already familiar with collections.

What Is a Collections Framework?
--------------------------------

A _collections framework_ is a unified architecture for representing and manipulating collections. All collections frameworks contain the following:

*   **Interfaces:** These are abstract data types that represent collections. Interfaces allow collections to be manipulated independently of the details of their representation. In object-oriented languages, interfaces generally form a hierarchy.
*   **Implementations:** These are the concrete implementations of the collection interfaces. In essence, they are reusable data structures.
*   **Algorithms:** These are the methods that perform useful computations, such as searching and sorting, on objects that implement collection interfaces. The algorithms are said to be _polymorphic_: that is, the same method can be used on many different implementations of the appropriate collection interface. In essence, algorithms are reusable functionality.

Apart from the Java Collections Framework, the best-known examples of collections frameworks are the C++ Standard Template Library (STL) and Smalltalk's collection hierarchy. Historically, collections frameworks have been quite complex, which gave them a reputation for having a steep learning curve. We believe that the Java Collections Framework breaks with this tradition, as you will learn for yourself in this chapter.

Benefits of the Java Collections Framework
------------------------------------------

The Java Collections Framework provides the following benefits:

*   **Reduces programming effort:** By providing useful data structures and algorithms, the Collections Framework frees you to concentrate on the important parts of your program rather than on the low-level "plumbing" required to make it work. By facilitating interoperability among unrelated APIs, the Java Collections Framework frees you from writing adapter objects or conversion code to connect APIs.
*   **Increases program speed and quality:** This Collections Framework provides high-performance, high-quality implementations of useful data structures and algorithms. The various implementations of each interface are interchangeable, so programs can be easily tuned by switching collection implementations. Because you're freed from the drudgery of writing your own data structures, you'll have more time to devote to improving programs' quality and performance.
*   **Allows interoperability among unrelated APIs:** The collection interfaces are the vernacular by which APIs pass collections back and forth. If my network administration API furnishes a collection of node names and if your GUI toolkit expects a collection of column headings, our APIs will interoperate seamlessly, even though they were written independently.
*   **Reduces effort to learn and to use new APIs:** Many APIs naturally take collections on input and furnish them as output. In the past, each such API had a small sub-API devoted to manipulating its collections. There was little consistency among these ad hoc collections sub-APIs, so you had to learn each one from scratch, and it was easy to make mistakes when using them. With the advent of standard collection interfaces, the problem went away.
*   **Reduces effort to design new APIs:** This is the flip side of the previous advantage. Designers and implementers don't have to reinvent the wheel each time they create an API that relies on collections; instead, they can use standard collection interfaces.
*   **Fosters software reuse:** New data structures that conform to the standard collection interfaces are by nature reusable. The same goes for new algorithms that operate on objects that implement these interfaces.



<a name="sec_15"></a>
## 15. Interfaces
******
https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html

15.1. [The Collection Interface]
15.2. [The Set Interface]
15.3. [The List Interface]
15.4. [The Queue Interface]
15.5. [The Deque Interface]
15.6. [The Map Interface]
15.7. [Object Ordering]
15.8. [The SortedSet Interface]
15.9. [The SortedMap Interface]
15.10. [Summary of Interfaces]
15.11. [Questions and Exercises]

The _core collection interfaces_ encapsulate different types of collections, which are shown in the figure below. These interfaces allow collections to be manipulated independently of the details of their representation. Core collection interfaces are the foundation of the Java Collections Framework. As you can see in the following figure, the core collection interfaces form a hierarchy.

![Two interface trees, one starting with Collection and including Set, SortedSet, List, and Queue, and the other starting with Map and including SortedMap.](https://docs.oracle.com/javase/tutorial/figures/collections/colls-coreInterfaces.gif)

The core collection interfaces.

A `Set` is a special kind of `Collection`, a `SortedSet` is a special kind of `Set`, and so forth. Note also that the hierarchy consists of two distinct trees ‚Äî a `Map` is not a true `Collection`.

Note that all the core collection interfaces are generic. For example, this is the declaration of the `Collection` interface.

public interface Collection<E>...

The `<E>` syntax tells you that the interface is generic. When you declare a `Collection` instance you can _and should_ specify the type of object contained in the collection. Specifying the type allows the compiler to verify (at compile-time) that the type of object you put into the collection is correct, thus reducing errors at runtime. For information on generic types, see the [Generics (Updated)](../../java/generics/index.html) lesson.

When you understand how to use these interfaces, you will know most of what there is to know about the Java Collections Framework. This chapter discusses general guidelines for effective use of the interfaces, including when to use which interface. You'll also learn programming idioms for each interface to help you get the most out of it.

To keep the number of core collection interfaces manageable, the Java platform doesn't provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated _optional_ ‚Äî a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an [`UnsupportedOperationException`](https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html). Implementations are responsible for documenting which of the optional operations they support. All of the Java platform's general-purpose implementations support all of the optional operations.

The following list describes the core collection interfaces:

*   `Collection` ‚Äî the root of the collection hierarchy. A collection represents a group of objects known as its _elements_. The `Collection` interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn't provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as `Set` and `List`. Also see [The Collection Interface](collection.html) section.
*   `Set` ‚Äî a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student's schedule, or the processes running on a machine. See also [The Set Interface](set.html) section.
*   `List` ‚Äî an ordered collection (sometimes called a _sequence_). `List`s can contain duplicate elements. The user of a `List` generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you've used `Vector`, you're familiar with the general flavor of `List`. Also see [The List Interface](list.html) section.
*   `Queue` ‚Äî a collection used to hold multiple elements prior to processing. Besides basic `Collection` operations, a `Queue` provides additional insertion, extraction, and inspection operations.
    
    Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to `remove` or `poll`. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every `Queue` implementation must specify its ordering properties. Also see [The Queue Interface](queue.html) section.
    
*   `Deque` ‚Äî a collection used to hold multiple elements prior to processing. Besides basic `Collection` operations, a `Deque` provides additional insertion, extraction, and inspection operations.
    
    Deques can be used both as FIFO (first-in, first-out) and LIFO (last-in, first-out). In a deque all new elements can be inserted, retrieved and removed at both ends. Also see [The Deque Interface](deque.html) section.
    
*   `Map` ‚Äî an object that maps keys to values. A `Map` cannot contain duplicate keys; each key can map to at most one value. If you've used `Hashtable`, you're already familiar with the basics of `Map`. Also see [The Map Interface](map.html) section.

The last two core collection interfaces are merely sorted versions of `Set` and `Map`:

*   `SortedSet` ‚Äî a `Set` that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see [The SortedSet Interface](sorted-set.html) section.
*   `SortedMap` ‚Äî a `Map` that maintains its mappings in ascending key order. This is the `Map` analog of `SortedSet`. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see [The SortedMap Interface](sorted-map.html) section.

To understand how the sorted interfaces maintain the order of their elements, see the [Object Ordering](order.html) section.



<a name="sec_15_1"></a>
## 15.1. The Collection Interface
******

A [`Collection`](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html) represents a group of objects known as its elements. The `Collection` interface is used to pass around collections of objects where maximum generality is desired. For example, by convention all general-purpose collection implementations have a constructor that takes a `Collection` argument. This constructor, known as a _conversion constructor_, initializes the new collection to contain all of the elements in the specified collection, whatever the given collection's subinterface or implementation type. In other words, it allows you to _convert_ the collection's type.

Suppose, for example, that you have a `Collection<String> c`, which may be a `List`, a `Set`, or another kind of `Collection`. This idiom creates a new `ArrayList` (an implementation of the `List` interface), initially containing all the elements in `c`.

    List<String> list = new ArrayList<String>(c);

Or ‚Äî if you are using JDK 7 or later ‚Äî you can use the diamond operator:

    List<String> list = new ArrayList<>(c);

The `Collection` interface contains methods that perform basic operations, such as `int size()`, `boolean isEmpty()`, `boolean contains(Object element)`, `boolean add(E element)`, `boolean remove(Object element)`, and `Iterator<E> iterator()`.

It also contains methods that operate on entire collections, such as `boolean containsAll(Collection<?> c)`, `boolean addAll(Collection<? extends E> c)`, `boolean removeAll(Collection<?> c)`, `boolean retainAll(Collection<?> c)`, and `void clear()`.

Additional methods for array operations (such as `Object[] toArray()` and `<T> T[] toArray(T[] a)` exist as well.

In JDK 8 and later, the `Collection` interface also exposes methods `Stream<E> stream()` and `Stream<E> parallelStream()`, for obtaining sequential or parallel streams from the underlying collection. (See the lesson entitled [Aggregate Operations](../../collections/streams/index.html) for more information about using streams.)

The `Collection` interface does about what you'd expect given that a `Collection` represents a group of objects. It has methods that tell you how many elements are in the collection (`size`, `isEmpty`), methods that check whether a given object is in the collection (`contains`), methods that add and remove an element from the collection (`add`, `remove`), and methods that provide an iterator over the collection (`iterator`).

The `add` method is defined generally enough so that it makes sense for collections that allow duplicates as well as those that don't. It guarantees that the `Collection` will contain the specified element after the call completes, and returns `true` if the `Collection` changes as a result of the call. Similarly, the `remove` method is designed to remove a single instance of the specified element from the `Collection`, assuming that it contains the element to start with, and to return `true` if the `Collection` was modified as a result.

Traversing Collections
----------------------

There are three ways to traverse collections: (1) using aggregate operations (2) with the `for-each` construct and (3) by using `Iterator`s.

### Aggregate Operations

In JDK 8 and later, the preferred method of iterating over a collection is to obtain a stream and perform aggregate operations on it. Aggregate operations are often used in conjunction with lambda expressions to make programming more expressive, using less lines of code. The following code sequentially iterates through a collection of shapes and prints out the red objects:

    myShapesCollection.stream()
    .filter(e -> e.getColor() == Color.RED)
    .forEach(e -> System.out.println(e.getName()));

Likewise, you could easily request a parallel stream, which might make sense if the collection is large enough and your computer has enough cores:

    myShapesCollection.parallelStream()
    .filter(e -> e.getColor() == Color.RED)
    .forEach(e -> System.out.println(e.getName()));

There are many different ways to collect data with this API. For example, you might want to convert the elements of a `Collection` to `String` objects, then join them, separated by commas:

    String joined = elements.stream()
    .map(Object::toString)
    .collect(Collectors.joining(", "));

Or perhaps sum the salaries of all employees:

    int total = employees.stream()
    .collect(Collectors.summingInt(Employee::getSalary)));

These are but a few examples of what you can do with streams and aggregate operations. For more information and examples, see the lesson entitled [Aggregate Operations](../../collections/streams/index.html).

The Collections framework has always provided a number of so-called "bulk operations" as part of its API. These include methods that operate on entire collections, such as `containsAll`, `addAll`, `removeAll`, etc. Do not confuse those methods with the aggregate operations that were introduced in JDK 8. The key difference between the new aggregate operations and the existing bulk operations (`containsAll`, `addAll`, etc.) is that the old versions are all _mutative_, meaning that they all modify the underlying collection. In contrast, the new aggregate operations _do not_ modify the underlying collection. When using the new aggregate operations and lambda expressions, you must take care to avoid mutation so as not to introduce problems in the future, should your code be run later from a parallel stream.

### for-each Construct

The `for-each` construct allows you to concisely traverse a collection or array using a `for` loop ‚Äî see [The for Statement](../../java/nutsandbolts/for.html). The following code uses the `for-each` construct to print out each element of a collection on a separate line.

    for (Object o : collection)
        System.out.println(o);

### Iterators

An [`Iterator`](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html) is an object that enables you to traverse through a collection and to remove elements from the collection selectively, if desired. You get an `Iterator` for a collection by calling its `iterator` method. The following is the `Iterator` interface.

    public interface Iterator<E> {
        boolean hasNext();
        E next();
        void remove(); //optional
    }

The `hasNext` method returns `true` if the iteration has more elements, and the `next` method returns the next element in the iteration. The `remove` method removes the last element that was returned by `next` from the underlying `Collection`. The `remove` method may be called only once per call to `next` and throws an exception if this rule is violated.

Note that `Iterator.remove` is the _only_ safe way to modify a collection during iteration; the behavior is unspecified if the underlying collection is modified in any other way while the iteration is in progress.

Use `Iterator` instead of the `for-each` construct when you need to:

*   Remove the current element. The `for-each` construct hides the iterator, so you cannot call `remove`. Therefore, the `for-each` construct is not usable for filtering.
*   Iterate over multiple collections in parallel.

The following method shows you how to use an `Iterator` to filter an arbitrary `Collection` ‚Äî that is, traverse the collection removing specific elements.

    static void filter(Collection<?> c) {
        for (Iterator<?> it = c.iterator(); it.hasNext(); )
            if (!cond(it.next()))
                it.remove();
    }

This simple piece of code is polymorphic, which means that it works for _any_ `Collection` regardless of implementation. This example demonstrates how easy it is to write a polymorphic algorithm using the Java Collections Framework.

Collection Interface Bulk Operations
------------------------------------

_Bulk operations_ perform an operation on an entire `Collection`. You could implement these shorthand operations using the basic operations, though in most cases such implementations would be less efficient. The following are the bulk operations:

*   `containsAll` ‚Äî returns `true` if the target `Collection` contains all of the elements in the specified `Collection`.
*   `addAll` ‚Äî adds all of the elements in the specified `Collection` to the target `Collection`.
*   `removeAll` ‚Äî removes from the target `Collection` all of its elements that are also contained in the specified `Collection`.
*   `retainAll` ‚Äî removes from the target `Collection` all its elements that are _not_ also contained in the specified `Collection`. That is, it retains only those elements in the target `Collection` that are also contained in the specified `Collection`.
*   `clear` ‚Äî removes all elements from the `Collection`.

The `addAll`, `removeAll`, and `retainAll` methods all return `true` if the target `Collection` was modified in the process of executing the operation.

As a simple example of the power of bulk operations, consider the following idiom to remove _all_ instances of a specified element, `e`, from a `Collection`, `c`.

    c.removeAll(Collections.singleton(e));

More specifically, suppose you want to remove all of the `null` elements from a `Collection`.

    c.removeAll(Collections.singleton(null));

This idiom uses `Collections.singleton`, which is a static factory method that returns an immutable `Set` containing only the specified element.

Collection Interface Array Operations
-------------------------------------

The `toArray` methods are provided as a bridge between collections and older APIs that expect arrays on input. The array operations allow the contents of a `Collection` to be translated into an array. The simple form with no arguments creates a new array of `Object`. The more complex form allows the caller to provide an array or to choose the runtime type of the output array.

For example, suppose that `c` is a `Collection`. The following snippet dumps the contents of `c` into a newly allocated array of `Object` whose length is identical to the number of elements in `c`.

    Object[] a = c.toArray();

Suppose that `c` is known to contain only strings (perhaps because `c` is of type `Collection<String>`). The following snippet dumps the contents of `c` into a newly allocated array of `String` whose length is identical to the number of elements in `c`.

    String[] a = c.toArray(new String[0]);


<a name="sec_15_2"></a>
## 15.2. The Set Interface
******

A [`Set`](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html) is a [`Collection`](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html) that cannot contain duplicate elements. It models the mathematical set abstraction. The `Set` interface contains _only_ methods inherited from `Collection` and adds the restriction that duplicate elements are prohibited. `Set` also adds a stronger contract on the behavior of the `equals` and `hashCode` operations, allowing `Set` instances to be compared meaningfully even if their implementation types differ. Two `Set` instances are equal if they contain the same elements.

The Java platform contains three general-purpose `Set` implementations: `HashSet`, `TreeSet`, and `LinkedHashSet`. [`HashSet`](https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html), which stores its elements in a hash table, is the best-performing implementation; however it makes no guarantees concerning the order of iteration. [`TreeSet`](https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html), which stores its elements in a red-black tree, orders its elements based on their values; it is substantially slower than `HashSet`. [`LinkedHashSet`](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashSet.html), which is implemented as a hash table with a linked list running through it, orders its elements based on the order in which they were inserted into the set (insertion-order). `LinkedHashSet` spares its clients from the unspecified, generally chaotic ordering provided by `HashSet` at a cost that is only slightly higher.

Here's a simple but useful `Set` idiom. Suppose you have a `Collection`, `c`, and you want to create another `Collection` containing the same elements but with all duplicates eliminated. The following one-liner does the trick.

    Collection<Type> noDups = new HashSet<Type>(c);

It works by creating a `Set` (which, by definition, cannot contain duplicates), initially containing all the elements in `c`. It uses the standard conversion constructor described in the [The Collection Interface](collection.html) section.

Or, if using JDK 8 or later, you could easily collect into a `Set` using aggregate operations:

    c.stream()
    .collect(Collectors.toSet()); // no duplicates

Here's a slightly longer example that accumulates a `Collection` of names into a `TreeSet`:

    Set<String> set = people.stream()
    .map(Person::getName)
    .collect(Collectors.toCollection(TreeSet::new));

And the following is a minor variant of the first idiom that preserves the order of the original collection while removing duplicate elements:

    Collection<Type> noDups = new LinkedHashSet<Type>(c);

The following is a generic method that encapsulates the preceding idiom, returning a `Set` of the same generic type as the one passed.

    public static <E> Set<E> removeDups(Collection<E> c) {
        return new LinkedHashSet<E>(c);
    }

Set Interface Basic Operations
------------------------------

The `size` operation returns the number of elements in the `Set` (its _cardinality_). The `isEmpty` method does exactly what you think it would. The `add` method adds the specified element to the `Set` if it is not already present and returns a boolean indicating whether the element was added. Similarly, the `remove` method removes the specified element from the `Set` if it is present and returns a boolean indicating whether the element was present. The `iterator` method returns an `Iterator` over the `Set`.

The following [`program`](https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/FindDups.java) prints out all distinct words in its argument list. Two versions of this program are provided. The first uses JDK 8 aggregate operations. The second uses the for-each construct.

Using JDK 8 Aggregate Operations:

```java
import java.util.*;
import java.util.stream.*;

public class FindDups {
    public static void main(String[] args) {
        Set<String> distinctWords = Arrays.asList(args).stream()
        .collect(Collectors.toSet()); 
        System.out.println(distinctWords.size()+ 
                           " distinct words: " + 
                           distinctWords);
    }
}
```

Using the `for-each` Construct:

```java
import java.util.*;

public class FindDups {
    public static void main(String[] args) {
        Set<String> s = new HashSet<String>();
        for (String a : args)
               s.add(a);
        System.out.println(s.size() + " distinct words: " + s);
    }
}
```

Now run either version of the program.

    java FindDups i came i saw i left

The following output is produced:

    4 distinct words: [left, came, saw, i]

Note that the code always refers to the `Collection` by its interface type (`Set`) rather than by its implementation type. This is a _strongly_ recommended programming practice because it gives you the flexibility to change implementations merely by changing the constructor. If either of the variables used to store a collection or the parameters used to pass it around are declared to be of the `Collection`'s implementation type rather than its interface type, _all_ such variables and parameters must be changed in order to change its implementation type.

Furthermore, there's no guarantee that the resulting program will work. If the program uses any nonstandard operations present in the original implementation type but not in the new one, the program will fail. Referring to collections only by their interface prevents you from using any nonstandard operations.

The implementation type of the `Set` in the preceding example is `HashSet`, which makes no guarantees as to the order of the elements in the `Set`. If you want the program to print the word list in alphabetical order, merely change the `Set`'s implementation type from `HashSet` to `TreeSet`. Making this trivial one-line change causes the command line in the previous example to generate the following output.

    java FindDups i came i saw i left

    4 distinct words: [came, i, left, saw]

Set Interface Bulk Operations
-----------------------------

Bulk operations are particularly well suited to `Set`s; when applied, they perform standard set-algebraic operations. Suppose `s1` and `s2` are sets. Here's what bulk operations do:

*   `s1.containsAll(s2)` ‚Äî returns `true` if `s2` is a **subset** of `s1`. (`s2` is a subset of `s1` if set `s1` contains all of the elements in `s2`.)
*   `s1.addAll(s2)` ‚Äî transforms `s1` into the **union** of `s1` and `s2`. (The union of two sets is the set containing all of the elements contained in either set.)
*   `s1.retainAll(s2)` ‚Äî transforms `s1` into the intersection of `s1` and `s2`. (The intersection of two sets is the set containing only the elements common to both sets.)
*   `s1.removeAll(s2)` ‚Äî transforms `s1` into the (asymmetric) set difference of `s1` and `s2`. (For example, the set difference of `s1` minus `s2` is the set containing all of the elements found in `s1` but not in `s2`.)

To calculate the union, intersection, or set difference of two sets _nondestructively_ (without modifying either set), the caller must copy one set before calling the appropriate bulk operation. The following are the resulting idioms.

    Set<Type> union = new HashSet<Type>(s1);
    union.addAll(s2);

    Set<Type> intersection = new HashSet<Type>(s1);
    intersection.retainAll(s2);

    Set<Type> difference = new HashSet<Type>(s1);
    difference.removeAll(s2);

The implementation type of the result `Set` in the preceding idioms is `HashSet`, which is, as already mentioned, the best all-around `Set` implementation in the Java platform. However, any general-purpose `Set` implementation could be substituted.

Let's revisit the `FindDups` program. Suppose you want to know which words in the argument list occur only once and which occur more than once, but you do not want any duplicates printed out repeatedly. This effect can be achieved by generating two sets ‚Äî one containing every word in the argument list and the other containing only the duplicates. The words that occur only once are the set difference of these two sets, which we know how to compute. Here's how [`the resulting program`](https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/FindDups2.java) looks.

```java
import java.util.*;

public class FindDups2 {
    public static void main(String[] args) {
        Set<String> uniques = new HashSet<String>();
        Set<String> dups    = new HashSet<String>();

        for (String a : args)
            if (!uniques.add(a))
                dups.add(a);

        // Destructive set-difference
        uniques.removeAll(dups);

        System.out.println("Unique words:    " + uniques);
        System.out.println("Duplicate words: " + dups);
    }
}
```

When run with the same argument list used earlier (`i came i saw i left`), the program yields the following output.

    Unique words:    [left, saw, came]
    Duplicate words: [i]

A less common set-algebraic operation is the _symmetric set difference_ ‚Äî the set of elements contained in either of two specified sets but not in both. The following code calculates the symmetric set difference of two sets nondestructively.

    Set<Type> symmetricDiff = new HashSet<Type>(s1);
    symmetricDiff.addAll(s2);
    Set<Type> tmp = new HashSet<Type>(s1);
    tmp.retainAll(s2);
    symmetricDiff.removeAll(tmp);

Set Interface Array Operations
------------------------------

The array operations don't do anything special for `Set`s beyond what they do for any other `Collection`. These operations are described in [The Collection Interface](collection.html) section.


<a name="sec_15_3"></a>
## 15.3. The List Interface
******

A [`List`](https://docs.oracle.com/javase/8/docs/api/java/util/List.html) is an ordered [`Collection`](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html) (sometimes called a _sequence_). Lists may contain duplicate elements. In addition to the operations inherited from `Collection`, the `List` interface includes operations for the following:

*   `Positional access` ‚Äî manipulates elements based on their numerical position in the list. This includes methods such as `get`, `set`, `add`, `addAll`, and `remove`.
*   `Search` ‚Äî searches for a specified object in the list and returns its numerical position. Search methods include `indexOf` and `lastIndexOf`.
*   `Iteration` ‚Äî extends `Iterator` semantics to take advantage of the list's sequential nature. The `listIterator` methods provide this behavior.
*   `Range-view` ‚Äî The `sublist` method performs arbitrary _range operations_ on the list.

The Java platform contains two general-purpose `List` implementations. [`ArrayList`](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html), which is usually the better-performing implementation, and [`LinkedList`](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html) which offers better performance under certain circumstances.

Collection Operations
---------------------

The operations inherited from `Collection` all do about what you'd expect them to do, assuming you're already familiar with them. If you're not familiar with them from `Collection`, now would be a good time to read [The Collection Interface](collection.html) section. The `remove` operation always removes _the first_ occurrence of the specified element from the list. The `add` and `addAll` operations always append the new element(s) to the _end_ of the list. Thus, the following idiom concatenates one list to another.

    list1.addAll(list2);

Here's a nondestructive form of this idiom, which produces a third `List` consisting of the second list appended to the first.

    List<Type> list3 = new ArrayList<Type>(list1);
    list3.addAll(list2);

Note that the idiom, in its nondestructive form, takes advantage of `ArrayList`'s standard conversion constructor.

And here's an example (JDK 8 and later) that aggregates some names into a `List`:

    List<String> list = people.stream()
    .map(Person::getName)
    .collect(Collectors.toList());

Like the [`Set`](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html) interface, `List` strengthens the requirements on the `equals` and `hashCode` methods so that two `List` objects can be compared for logical equality without regard to their implementation classes. Two `List` objects are equal if they contain the same elements in the same order.

Positional Access and Search Operations
---------------------------------------

The basic `positional access` operations are `get`, `set`, `add` and `remove`. (The `set` and `remove` operations return the old value that is being overwritten or removed.) Other operations (`indexOf` and `lastIndexOf`) return the first or last index of the specified element in the list.

The `addAll` operation inserts all the elements of the specified `Collection` starting at the specified position. The elements are inserted in the order they are returned by the specified `Collection`'s iterator. This call is the positional access analog of `Collection`'s `addAll` operation.

Here's a little method to swap two indexed values in a `List`.

    public static <E> void swap(List<E> a, int i, int j) {
        E tmp = a.get(i);
        a.set(i, a.get(j));
        a.set(j, tmp);
    }

Of course, there's one big difference. This is a polymorphic algorithm: It swaps two elements in any `List`, regardless of its implementation type. Here's another polymorphic algorithm that uses the preceding `swap` method.

    public static void shuffle(List<?> list, Random rnd) {
        for (int i = list.size(); i > 1; i--)
            swap(list, i - 1, rnd.nextInt(i));
    }

This algorithm, which is included in the Java platform's [`Collections`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html) class, randomly permutes the specified list using the specified source of randomness. It's a bit subtle: It runs up the list from the bottom, repeatedly swapping a randomly selected element into the current position. Unlike most naive attempts at shuffling, it's _fair_ (all permutations occur with equal likelihood, assuming an unbiased source of randomness) and _fast_ (requiring exactly `list.size()-1` swaps). The following program uses this algorithm to print the words in its argument list in random order.

```java
import java.util.*;

public class Shuffle {
    public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        for (String a : args)
            list.add(a);
        Collections.shuffle(list, new Random());
        System.out.println(list);
    }
}
```

In fact, this program can be made even shorter and faster. The [`Arrays`](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html) class has a static factory method called `asList`, which allows an array to be viewed as a `List`. This method does not copy the array. Changes in the `List` write through to the array and vice versa. The resulting List is not a general-purpose `List` implementation, because it doesn't implement the (optional) `add` and `remove` operations: Arrays are not resizable. Taking advantage of `Arrays.asList` and calling the library version of `shuffle`, which uses a default source of randomness, you get the following [`tiny program`](https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/Shuffle.java) whose behavior is identical to the previous program.

```java
import java.util.*;

public class Shuffle {
    public static void main(String[] args) {
        List<String> list = Arrays.asList(args);
        Collections.shuffle(list);
        System.out.println(list);
    }
}
```

Iterators
---------

As you'd expect, the `Iterator` returned by `List`'s `iterator` operation returns the elements of the list in proper sequence. `List` also provides a richer iterator, called a `ListIterator`, which allows you to traverse the list in either direction, modify the list during iteration, and obtain the current position of the iterator.

The three methods that `ListIterator` inherits from `Iterator` (`hasNext`, `next`, and `remove`) do exactly the same thing in both interfaces. The `hasPrevious` and the `previous` operations are exact analogues of `hasNext` and `next`. The former operations refer to the element before the (implicit) cursor, whereas the latter refer to the element after the cursor. The `previous` operation moves the cursor backward, whereas `next` moves it forward.

Here's the standard idiom for iterating backward through a list.

    for (ListIterator<Type> it = list.listIterator(list.size()); it.hasPrevious(); ) {
        Type t = it.previous();
        ...
    }

Note the argument to `listIterator` in the preceding idiom. The `List` interface has two forms of the `listIterator` method. The form with no arguments returns a `ListIterator` positioned at the beginning of the list; the form with an `int` argument returns a `ListIterator` positioned at the specified index. The index refers to the element that would be returned by an initial call to `next`. An initial call to `previous` would return the element whose index was `index-1`. In a list of length `n`, there are `n+1` valid values for `index`, from `0` to `n`, inclusive.

Intuitively speaking, the cursor is always between two elements ‚Äî the one that would be returned by a call to `previous` and the one that would be returned by a call to `next`. The `n+1` valid `index` values correspond to the `n+1` gaps between elements, from the gap before the first element to the gap after the last one. The following figure shows the five possible cursor positions in a list containing four elements.

![Five arrows representing five cursor positions, from 0 to 4, with four elements, one between each arrow.](https://docs.oracle.com/javase/tutorial/figures/collections/colls-fivePossibleCursor.gif)

The five possible cursor positions.

Calls to `next` and `previous` can be intermixed, but you have to be a bit careful. The first call to `previous` returns the same element as the last call to `next`. Similarly, the first call to `next` after a sequence of calls to `previous` returns the same element as the last call to `previous`.

It should come as no surprise that the `nextIndex` method returns the index of the element that would be returned by a subsequent call to `next`, and `previousIndex` returns the index of the element that would be returned by a subsequent call to `previous`. These calls are typically used either to report the position where something was found or to record the position of the `ListIterator` so that another `ListIterator` with identical position can be created.

It should also come as no surprise that the number returned by `nextIndex` is always one greater than the number returned by `previousIndex`. This implies the behavior of the two boundary cases: (1) a call to `previousIndex` when the cursor is before the initial element returns `-1` and (2) a call to `nextIndex` when the cursor is after the final element returns `list.size()`. To make all this concrete, the following is a possible implementation of `List.indexOf`.

    public int indexOf(E e) {
        for (ListIterator<E> it = listIterator(); it.hasNext(); )
            if (e == null ? it.next() == null : e.equals(it.next()))
                return it.previousIndex();
        // Element not found
        return -1;
    }

Note that the `indexOf` method returns `it.previousIndex()` even though it is traversing the list in the forward direction. The reason is that `it.nextIndex()` would return the index of the element we are about to examine, and we want to return the index of the element we just examined.

The `Iterator` interface provides the `remove` operation to remove the last element returned by `next` from the `Collection`. For `ListIterator`, this operation removes the last element returned by `next` or `previous`. The `ListIterator` interface provides two additional operations to modify the list ‚Äî `set` and `add`. The `set` method overwrites the last element returned by `next` or `previous` with the specified element. The following polymorphic algorithm uses `set` to replace all occurrences of one specified value with another.

    public static <E> void replace(List<E> list, E val, E newVal) {
        for (ListIterator<E> it = list.listIterator(); it.hasNext(); )
            if (val == null ? it.next() == null : val.equals(it.next()))
                it.set(newVal);
    }

The only bit of trickiness in this example is the equality test between `val` and `it.next`. You need to special-case a `val` value of `null` to prevent a `NullPointerException`.

The `add` method inserts a new element into the list immediately before the current cursor position. This method is illustrated in the following polymorphic algorithm to replace all occurrences of a specified value with the sequence of values contained in the specified list.

    public static <E> 
        void replace(List<E> list, E val, List<? extends E> newVals) {
        for (ListIterator<E> it = list.listIterator(); it.hasNext(); ){
            if (val == null ? it.next() == null : val.equals(it.next())) {
                it.remove();
                for (E e : newVals)
                    it.add(e);
            }
        }
    }

Range-View Operation
--------------------

The `range-view` operation, `subList(int fromIndex, int toIndex)`, returns a `List` view of the portion of this list whose indices range from `fromIndex`, inclusive, to `toIndex`, exclusive. This _half-open range_ mirrors the typical `for` loop.

    for (int i = fromIndex; i < toIndex; i++) {
        ...
    }

As the term _view_ implies, the returned `List` is backed up by the `List` on which `subList` was called, so changes in the former are reflected in the latter.

This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a `List` can be used as a range operation by passing a `subList` view instead of a whole `List`. For example, the following idiom removes a range of elements from a `List`.

    list.subList(fromIndex, toIndex).clear();

Similar idioms can be constructed to search for an element in a range.

    int i = list.subList(fromIndex, toIndex).indexOf(o);
    int j = list.subList(fromIndex, toIndex).lastIndexOf(o);

Note that the preceding idioms return the index of the found element in the `subList`, not the index in the backing `List`.

Any polymorphic algorithm that operates on a `List`, such as the `replace` and `shuffle` examples, works with the `List` returned by `subList`.

Here's a polymorphic algorithm whose implementation uses `subList` to deal a hand from a deck. That is, it returns a new `List` (the "hand") containing the specified number of elements taken from the end of the specified `List` (the "deck"). The elements returned in the hand are removed from the deck.

    public static <E> List<E> dealHand(List<E> deck, int n) {
        int deckSize = deck.size();
        List<E> handView = deck.subList(deckSize - n, deckSize);
        List<E> hand = new ArrayList<E>(handView);
        handView.clear();
        return hand;
    }

Note that this algorithm removes the hand from the _end_ of the deck. For many common `List` implementations, such as `ArrayList`, the performance of removing elements from the end of the list is substantially better than that of removing elements from the beginning.

The following is [`a program`](https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/Deal.java) that uses the `dealHand` method in combination with `Collections.shuffle` to generate hands from a normal 52-card deck. The program takes two command-line arguments: (1) the number of hands to deal and (2) the number of cards in each hand.

```java
import java.util.*;

public class Deal {
    public static void main(String[] args) {
        if (args.length < 2) {
            System.out.println("Usage: Deal hands cards");
            return;
        }
        int numHands = Integer.parseInt(args[0]);
        int cardsPerHand = Integer.parseInt(args[1]);
    
        // Make a normal 52-card deck.
        String[] suit = new String[] {
            "spades", "hearts", 
            "diamonds", "clubs" 
        };
        String[] rank = new String[] {
            "ace", "2", "3", "4",
            "5", "6", "7", "8", "9", "10", 
            "jack", "queen", "king" 
        };

        List<String> deck = new ArrayList<String>();
        for (int i = 0; i < suit.length; i++)
            for (int j = 0; j < rank.length; j++)
                deck.add(rank[j] + " of " + suit[i]);
    
        // Shuffle the deck.
        Collections.shuffle(deck);
    
        if (numHands * cardsPerHand > deck.size()) {
            System.out.println("Not enough cards.");
            return;
        }
    
        for (int i = 0; i < numHands; i++)
            System.out.println(dealHand(deck, cardsPerHand));
    }
  
    public static <E> List<E> dealHand(List<E> deck, int n) {
        int deckSize = deck.size();
        List<E> handView = deck.subList(deckSize - n, deckSize);
        List<E> hand = new ArrayList<E>(handView);
        handView.clear();
        return hand;
    }
}
```

Running the program produces output like the following.

    % java Deal 4 5

    [8 of hearts, jack of spades, 3 of spades, 4 of spades,
        king of diamonds]
    [4 of diamonds, ace of clubs, 6 of clubs, jack of hearts,
        queen of hearts]
    [7 of spades, 5 of spades, 2 of diamonds, queen of diamonds,
        9 of clubs]
    [8 of spades, 6 of diamonds, ace of spades, 3 of hearts,
        ace of hearts]

Although the `subList` operation is extremely powerful, some care must be exercised when using it. The semantics of the `List` returned by `subList` become undefined if elements are added to or removed from the backing `List` in any way other than via the returned `List`. Thus, it's highly recommended that you use the `List` returned by `subList` only as a transient object ‚Äî to perform one or a sequence of range operations on the backing `List`. The longer you use the `subList` instance, the greater the probability that you'll compromise it by modifying the backing `List` directly or through another `subList` object. Note that it is legal to modify a sublist of a sublist and to continue using the original sublist (though not concurrently).

List Algorithms
---------------

Most polymorphic algorithms in the `Collections` class apply specifically to `List`. Having all these algorithms at your disposal makes it very easy to manipulate lists. Here's a summary of these algorithms, which are described in more detail in the [Algorithms](../algorithms/index.html) section.

*   `sort` ‚Äî sorts a `List` using a merge sort algorithm, which provides a fast, stable sort. (A _stable sort_ is one that does not reorder equal elements.)
*   `shuffle` ‚Äî randomly permutes the elements in a `List`.
*   `reverse` ‚Äî reverses the order of the elements in a `List`.
*   `rotate` ‚Äî rotates all the elements in a `List` by a specified distance.
*   `swap` ‚Äî swaps the elements at specified positions in a `List`.
*   `replaceAll` ‚Äî replaces all occurrences of one specified value with another.
*   `fill` ‚Äî overwrites every element in a `List` with the specified value.
*   `copy` ‚Äî copies the source `List` into the destination `List`.
*   `binarySearch` ‚Äî searches for an element in an ordered `List` using the binary search algorithm.
*   `indexOfSubList` ‚Äî returns the index of the first sublist of one `List` that is equal to another.
*   `lastIndexOfSubList` ‚Äî returns the index of the last sublist of one `List` that is equal to another.


<a name="sec_15_4"></a>
## 15.4. The Queue Interface
******

A [`Queue`](https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html) is a collection for holding elements prior to processing. Besides basic `Collection` operations, queues provide additional insertion, removal, and inspection operations. The `Queue` interface follows.

    public interface Queue<E> extends Collection<E> {
        E element();
        boolean offer(E e);
        E peek();
        E poll();
        E remove();
    }

Each `Queue` method exists in two forms: (1) one throws an exception if the operation fails, and (2) the other returns a special value if the operation fails (either `null` or `false`, depending on the operation). The regular structure of the interface is illustrated in the following table.

**Queue Interface Structure**

| Type of Operation | Throws exception | Returns special value |
|-------------------|------------------|-----------------------|
| Insert  | `add(e)`    |  `offer(e)`
| Remove  | `remove()`  |  `poll()`
| Examine | `element()` |  `peek()`

  

Queues typically, but not necessarily, order elements in a FIFO (first-in-first-out) manner. Among the exceptions are priority queues, which order elements according to their values ‚Äî see the [Object Ordering](order.html) section for details). Whatever ordering is used, the head of the queue is the element that would be removed by a call to `remove` or `poll`. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every `Queue` implementation must specify its ordering properties.

It is possible for a `Queue` implementation to restrict the number of elements that it holds; such queues are known as _bounded_. Some `Queue` implementations in `java.util.concurrent` are bounded, but the implementations in `java.util` are not.

The `add` method, which `Queue` inherits from `Collection`, inserts an element unless it would violate the queue's capacity restrictions, in which case it throws `IllegalStateException`. The `offer` method, which is intended solely for use on bounded queues, differs from `add` only in that it indicates failure to insert an element by returning `false`.

The `remove` and `poll` methods both remove and return the head of the queue. Exactly which element gets removed is a function of the queue's ordering policy. The `remove` and `poll` methods differ in their behavior only when the queue is empty. Under these circumstances, `remove` throws `NoSuchElementException`, while `poll` returns `null`.

The `element` and `peek` methods return, but do not remove, the head of the queue. They differ from one another in precisely the same fashion as `remove` and `poll`: If the queue is empty, `element` throws `NoSuchElementException`, while `peek` returns `null`.

`Queue` implementations generally do not allow insertion of `null` elements. The `LinkedList` implementation, which was retrofitted to implement `Queue`, is an exception. For historical reasons, it permits `null` elements, but you should refrain from taking advantage of this, because `null` is used as a special return value by the `poll` and `peek` methods.

Queue implementations generally do not define element-based versions of the `equals` and `hashCode` methods but instead inherit the identity-based versions from `Object`.

The `Queue` interface does not define the blocking queue methods, which are common in concurrent programming. These methods, which wait for elements to appear or for space to become available, are defined in the interface [`java.util.concurrent.BlockingQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html), which extends `Queue`.

In the following example program, a queue is used to implement a countdown timer. The queue is preloaded with all the integer values from a number specified on the command line to zero, in descending order. Then, the values are removed from the queue and printed at one-second intervals. The program is artificial in that it would be more natural to do the same thing without using a queue, but it illustrates the use of a queue to store elements prior to subsequent processing.

```java
import java.util.*;

public class Countdown {
    public static void main(String[] args) throws InterruptedException {
        int time = Integer.parseInt(args[0]);
        Queue<Integer> queue = new LinkedList<Integer>();

        for (int i = time; i >= 0; i--)
            queue.add(i);

        while (!queue.isEmpty()) {
            System.out.println(queue.remove());
            Thread.sleep(1000);
        }
    }
}
```

In the following example, a priority queue is used to sort a collection of elements. Again this program is artificial in that there is no reason to use it in favor of the `sort` method provided in `Collections`, but it illustrates the behavior of priority queues.

```java
static <E> List<E> heapSort(Collection<E> c) {
    Queue<E> queue = new PriorityQueue<E>(c);
    List<E> result = new ArrayList<E>();

    while (!queue.isEmpty())
        result.add(queue.remove());

    return result;
}
```


<a name="sec_15_5"></a>
## 15.5. The Deque Interface
******

Usually pronounced as `deck`, a deque is a double-ended-queue. A double-ended-queue is a linear collection of elements that supports the insertion and removal of elements at both end points. The `Deque` interface is a richer abstract data type than both `Stack` and `Queue` because it implements both stacks and queues at the same time. The [`Deque`](https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html) interface, defines methods to access the elements at both ends of the `Deque` instance. Methods are provided to insert, remove, and examine the elements. Predefined classes like [`ArrayDeque`](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html) and [`LinkedList`](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html) implement the `Deque` interface.

Note that the `Deque` interface can be used both as last-in-first-out stacks and first-in-first-out queues. The methods given in the `Deque` interface are divided into three parts:

Insert
------

The `addfirst` and `offerFirst` methods insert elements at the beginning of the `Deque` instance. The methods `addLast` and `offerLast` insert elements at the end of the `Deque` instance. When the capacity of the `Deque` instance is restricted, the preferred methods are `offerFirst` and `offerLast` because `addFirst` might fail to throw an exception if it is full.

Remove
------

The `removeFirst` and `pollFirst` methods remove elements from the beginning of the `Deque` instance. The `removeLast` and `pollLast` methods remove elements from the end. The methods `pollFirst` and `pollLast` return `null` if the `Deque` is empty whereas the methods `removeFirst` and `removeLast` throw an exception if the `Deque` instance is empty.

Retrieve
--------

The methods `getFirst` and `peekFirst` retrieve the first element of the `Deque` instance. These methods dont remove the value from the `Deque` instance. Similarly, the methods `getLast` and `peekLast` retrieve the last element. The methods `getFirst` and `getLast` throw an exception if the `deque` instance is empty whereas the methods `peekFirst` and `peekLast` return `NULL`.

The 12 methods for insertion, removal and retrieval of Deque elements are summarized in the following table:

**Deque Methods**

| Type of Operation | First Element | Last Element |
|-------------------|---------------|--------------|
| Insert  | `addFirst(e)` `offerFirst(e)`  | `addLast(e)` `offerLast(e)`
| Remove  | `removeFirst()` `pollFirst()`  | `removeLast()` `pollLast()`
| Examine | `getFirst()` `peekFirst()`     | `getLast()` `peekLast()`

In addition to these basic methods to insert,remove and examine a `Deque` instance, the `Deque` interface also has some more predefined methods. One of these is `removeFirstOccurence`, this method removes the first occurrence of the specified element if it exists in the `Deque` instance. If the element does not exist then the `Deque` instance remains unchanged. Another similar method is `removeLastOccurence`; this method removes the last occurrence of the specified element in the `Deque` instance. The return type of these methods is `boolean`, and they return `true` if the element exists in the `Deque` instance.


<a name="sec_15_6"></a>
## 15.6. The Map Interface
******

A [`Map`](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html) is an object that maps keys to values. A map cannot contain duplicate keys: Each key can map to at most one value. It models the mathematical _function_ abstraction. The `Map` interface includes methods for basic operations (such as `put`, `get`, `remove`, `containsKey`, `containsValue`, `size`, and `empty`), bulk operations (such as `putAll` and `clear`), and collection views (such as `keySet`, `entrySet`, and `values`).

The Java platform contains three general-purpose `Map` implementations: [`HashMap`](https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html), [`TreeMap`](https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html), and [`LinkedHashMap`](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html). Their behavior and performance are precisely analogous to `HashSet`, `TreeSet`, and `LinkedHashSet`, as described in [The Set Interface](set.html) section.

The remainder of this page discusses the `Map` interface in detail. But first, here are some more examples of collecting to `Map`s using JDK 8 aggregate operations. Modeling real-world objects is a common task in object-oriented programming, so it is reasonable to think that some programs might, for example, group employees by department:

```java
// Group employees by department
Map<Department, List<Employee>> byDept = employees.stream()
.collect(Collectors.groupingBy(Employee::getDepartment));

Or compute the sum of all salaries by department:

// Compute sum of salaries by department
Map<Department, Integer> totalByDept = employees.stream()
.collect(Collectors.groupingBy(Employee::getDepartment,
Collectors.summingInt(Employee::getSalary)));

Or perhaps group students by passing or failing grades:

// Partition students into passing and failing
Map<Boolean, List<Student>> passingFailing = students.stream()
.collect(Collectors.partitioningBy(s -> s.getGrade()>= PASS_THRESHOLD)); 

You could also group people by city:

// Classify Person objects by city
Map<String, List<Person>> peopleByCity
         = personStream.collect(Collectors.groupingBy(Person::getCity));
```

Or even cascade two collectors to classify people by state and city:

```java
// Cascade Collectors 
Map<String, Map<String, List<Person>>> peopleByStateAndCity
  = personStream.collect(Collectors.groupingBy(Person::getState,
  Collectors.groupingBy(Person::getCity)))
```

Again, these are but a few examples of how to use the new JDK 8 APIs. For in-depth coverage of lambda expressions and aggregate operations see the lesson entitled [Aggregate Operations](../../collections/streams/index.html).

Map Interface Basic Operations
------------------------------

The basic operations of `Map` (`put`, `get`, `containsKey`, `containsValue`, `size`, and `isEmpty`) behave exactly like their counterparts in `Hashtable`. The [`following program`](https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/Freq.java) generates a frequency table of the words found in its argument list. The frequency table maps each word to the number of times it occurs in the argument list.

```java
import java.util.*;

public class Freq {
    public static void main(String[] args) {
        Map<String, Integer> m = new HashMap<String, Integer>();

        // Initialize frequency table from command line
        for (String a : args) {
            Integer freq = m.get(a);
            m.put(a, (freq == null) ? 1 : freq + 1);
        }

        System.out.println(m.size() + " distinct words:");
        System.out.println(m);
    }
}
```

The only tricky thing about this program is the second argument of the `put` statement. That argument is a conditional expression that has the effect of setting the frequency to one if the word has never been seen before or one more than its current value if the word has already been seen. Try running this program with the command:
    
    java Freq if it is to be it is up to me to delegate

The program yields the following output.

    8 distinct words:
    {to=3, delegate=1, be=1, it=2, up=1, if=1, me=1, is=2}

Suppose you'd prefer to see the frequency table in alphabetical order. All you have to do is change the implementation type of the `Map` from `HashMap` to `TreeMap`. Making this four-character change causes the program to generate the following output from the same command line.

    8 distinct words:
    {be=1, delegate=1, if=1, is=2, it=2, me=1, to=3, up=1}

Similarly, you could make the program print the frequency table in the order the words first appear on the command line simply by changing the implementation type of the map to `LinkedHashMap`. Doing so results in the following output.

    8 distinct words:
    {if=1, it=2, is=2, to=3, be=1, up=1, me=1, delegate=1}

This flexibility provides a potent illustration of the power of an interface-based framework.

Like the [`Set`](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html)and [`List`](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)interfaces, `Map` strengthens the requirements on the `equals` and `hashCode` methods so that two `Map` objects can be compared for logical equality without regard to their implementation types. Two `Map` instances are equal if they represent the same key-value mappings.

By convention, all general-purpose `Map` implementations provide constructors that take a `Map` object and initialize the new `Map` to contain all the key-value mappings in the specified `Map`. This standard `Map` conversion constructor is entirely analogous to the standard `Collection` constructor: It allows the caller to create a `Map` of a desired implementation type that initially contains all of the mappings in another `Map`, regardless of the other `Map`'s implementation type. For example, suppose you have a `Map`, named `m`. The following one-liner creates a new `HashMap` initially containing all of the same key-value mappings as `m`.

    Map<K, V> copy = new HashMap<K, V>(m);

Map Interface Bulk Operations
-----------------------------

The `clear` operation does exactly what you would think it could do: It removes all the mappings from the `Map`. The `putAll` operation is the `Map` analogue of the `Collection` interface's `addAll` operation. In addition to its obvious use of dumping one `Map` into another, it has a second, more subtle use. Suppose a `Map` is used to represent a collection of attribute-value pairs; the `putAll` operation, in combination with the `Map` conversion constructor, provides a neat way to implement attribute map creation with default values. The following is a static factory method that demonstrates this technique.

    static <K, V> Map<K, V> newAttributeMap(Map<K, V>defaults, Map<K, V> overrides) {
        Map<K, V> result = new HashMap<K, V>(defaults);
        result.putAll(overrides);
        return result;
    }

Collection Views
----------------

The `Collection` view methods allow a `Map` to be viewed as a `Collection` in these three ways:

*   `keySet` ‚Äî the `Set` of keys contained in the `Map`.
*   `values` ‚Äî The `Collection` of values contained in the `Map`. This `Collection` is not a `Set`, because multiple keys can map to the same value.
*   `entrySet` ‚Äî the `Set` of key-value pairs contained in the `Map`. The `Map` interface provides a small nested interface called `Map.Entry`, the type of the elements in this `Set`.

The `Collection` views provide the _only_ means to iterate over a `Map`. This example illustrates the standard idiom for iterating over the keys in a `Map` with a `for-each` construct:

    for (KeyType key : m.keySet())
        System.out.println(key);

and with an `iterator`:

    // Filter a map based on some 
    // property of its keys.
    for (Iterator<Type> it = m.keySet().iterator(); it.hasNext(); )
        if (it.next().isBogus())
            it.remove();

The idiom for iterating over values is analogous. Following is the idiom for iterating over key-value pairs.

    for (Map.Entry<KeyType, ValType> e : m.entrySet())
        System.out.println(e.getKey() + ": " + e.getValue());

At first, many people worry that these idioms may be slow because the `Map` has to create a new `Collection` instance each time a `Collection` view operation is called. Rest easy: There's no reason that a `Map` cannot always return the same object each time it is asked for a given `Collection` view. This is precisely what all the `Map` implementations in `java.util` do.

With all three `Collection` views, calling an `Iterator`'s `remove` operation removes the associated entry from the backing `Map`, assuming that the backing `Map` supports element removal to begin with. This is illustrated by the preceding filtering idiom.

With the `entrySet` view, it is also possible to change the value associated with a key by calling a `Map.Entry`'s `setValue` method during iteration (again, assuming the `Map` supports value modification to begin with). Note that these are the _only_ safe ways to modify a `Map` during iteration; the behavior is unspecified if the underlying `Map` is modified in any other way while the iteration is in progress.

The `Collection` views support element removal in all its many forms ‚Äî `remove`, `removeAll`, `retainAll`, and `clear` operations, as well as the `Iterator.remove` operation. (Yet again, this assumes that the backing `Map` supports element removal.)

The `Collection` views _do not_ support element addition under any circumstances. It would make no sense for the `keySet` and `values` views, and it's unnecessary for the `entrySet` view, because the backing `Map`'s `put` and `putAll` methods provide the same functionality.

Fancy Uses of Collection Views: Map Algebra
-------------------------------------------

When applied to the `Collection` views, bulk operations (`containsAll`, `removeAll`, and `retainAll`) are surprisingly potent tools. For starters, suppose you want to know whether one `Map` is a submap of another ‚Äî that is, whether the first `Map` contains all the key-value mappings in the second. The following idiom does the trick.

    if (m1.entrySet().containsAll(m2.entrySet())) {
        ...
    }

Along similar lines, suppose you want to know whether two `Map` objects contain mappings for all of the same keys.

    if (m1.keySet().equals(m2.keySet())) {
        ...
    }

Suppose you have a `Map` that represents a collection of attribute-value pairs, and two `Set`s representing required attributes and permissible attributes. (The permissible attributes include the required attributes.) The following snippet determines whether the attribute map conforms to these constraints and prints a detailed error message if it doesn't.

```java
static <K, V> boolean validate(Map<K, V> attrMap, Set<K> requiredAttrs, Set<K>permittedAttrs) {
    boolean valid = true;
    Set<K> attrs = attrMap.keySet();

    if (! attrs.containsAll(requiredAttrs)) {
        Set<K> missing = new HashSet<K>(requiredAttrs);
        missing.removeAll(attrs);
        System.out.println("Missing attributes: " + missing);
        valid = false;
    }
    if (! permittedAttrs.containsAll(attrs)) {
        Set<K> illegal = new HashSet<K>(attrs);
        illegal.removeAll(permittedAttrs);
        System.out.println("Illegal attributes: " + illegal);
        valid = false;
    }
    return valid;
}
```

Suppose you want to know all the keys common to two `Map` objects.

    Set<KeyType>commonKeys = new HashSet<KeyType>(m1.keySet());
    commonKeys.retainAll(m2.keySet());

A similar idiom gets you the common values.

All the idioms presented thus far have been nondestructive; that is, they don't modify the backing `Map`. Here are a few that do. Suppose you want to remove all of the key-value pairs that one `Map` has in common with another.

    m1.entrySet().removeAll(m2.entrySet());

Suppose you want to remove from one `Map` all of the keys that have mappings in another.

    m1.keySet().removeAll(m2.keySet());

What happens when you start mixing keys and values in the same bulk operation? Suppose you have a `Map`, `managers`, that maps each employee in a company to the employee's manager. We'll be deliberately vague about the types of the key and the value objects. It doesn't matter, as long as they're the same. Now suppose you want to know who all the "individual contributors" (or nonmanagers) are. The following snippet tells you exactly what you want to know.

Set<Employee> individualContributors = new HashSet<Employee>(managers.keySet());
individualContributors.removeAll(managers.values());

Suppose you want to fire all the employees who report directly to some manager, Simon.

    Employee simon = ... ;
    managers.values().removeAll(Collections.singleton(simon));

Note that this idiom makes use of `Collections.singleton`, a static factory method that returns an immutable `Set` with the single, specified element.

Once you've done this, you may have a bunch of employees whose managers no longer work for the company (if any of Simon's direct-reports were themselves managers). The following code will tell you which employees have managers who no longer works for the company.

    Map<Employee, Employee> m = new HashMap<Employee, Employee>(managers);
    m.values().removeAll(managers.keySet());
    Set<Employee> slackers = m.keySet();

This example is a bit tricky. First, it makes a temporary copy of the `Map`, and it removes from the temporary copy all entries whose (manager) value is a key in the original `Map`. Remember that the original `Map` has an entry for each employee. Thus, the remaining entries in the temporary `Map` comprise all the entries from the original `Map` whose (manager) values are no longer employees. The keys in the temporary copy, then, represent precisely the employees that we're looking for.

There are many more idioms like the ones contained in this section, but it would be impractical and tedious to list them all. Once you get the hang of it, it's not that difficult to come up with the right one when you need it.

Multimaps
---------

A _multimap_ is like a `Map` but it can map each key to multiple values. The Java Collections Framework doesn't include an interface for multimaps because they aren't used all that commonly. It's a fairly simple matter to use a `Map` whose values are `List` instances as a multimap. This technique is demonstrated in the next code example, which reads a word list containing one word per line (all lowercase) and prints out all the anagram groups that meet a size criterion. An _anagram group_ is a bunch of words, all of which contain exactly the same letters but in a different order. The program takes two arguments on the command line: (1) the name of the dictionary file and (2) the minimum size of anagram group to print out. Anagram groups containing fewer words than the specified minimum are not printed.

There is a standard trick for finding anagram groups: For each word in the dictionary, alphabetize the letters in the word (that is, reorder the word's letters into alphabetical order) and put an entry into a multimap, mapping the alphabetized word to the original word. For example, the word _bad_ causes an entry mapping _abd_ into _bad_ to be put into the multimap. A moment's reflection will show that all the words to which any given key maps form an anagram group. It's a simple matter to iterate over the keys in the multimap, printing out each anagram group that meets the size constraint.

[`The following program`](https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/Anagrams.java) is a straightforward implementation of this technique.

```java
import java.util.*;
import java.io.*;

public class Anagrams {
    public static void main(String[] args) {
        int minGroupSize = Integer.parseInt(args[1]);

        // Read words from file and put into a simulated multimap
        Map<String, List<String>> m = new HashMap<String, List<String>>();

        try {
            Scanner s = new Scanner(new File(args[0]));
            while (s.hasNext()) {
                String word = s.next();
                String alpha = alphabetize(word);
                List<String> l = m.get(alpha);
                if (l == null)
                    m.put(alpha, l=new ArrayList<String>());
                l.add(word);
            }
        } catch (IOException e) {
            System.err.println(e);
            System.exit(1);
        }

        // Print all permutation groups above size threshold
        for (List<String> l : m.values())
            if (l.size() >= minGroupSize)
                System.out.println(l.size() + ": " + l);
    }

    private static String alphabetize(String s) {
        char[] a = s.toCharArray();
        Arrays.sort(a);
        return new String(a);
    }
}
```

Running this program on a 173,000-word dictionary file with a minimum anagram group size of eight produces the following output.

    9: [estrin, inerts, insert, inters, niters, nitres, sinter,
         triens, trines]
    8: [lapse, leaps, pales, peals, pleas, salep, sepal, spale]
    8: [aspers, parses, passer, prases, repass, spares, sparse,
         spears]
    10: [least, setal, slate, stale, steal, stela, taels, tales,
          teals, tesla]
    8: [enters, nester, renest, rentes, resent, tenser, ternes,
         treens]
    8: [arles, earls, lares, laser, lears, rales, reals, seral]
    8: [earings, erasing, gainers, reagins, regains, reginas,
         searing, seringa]
    8: [peris, piers, pries, prise, ripes, speir, spier, spire]
    12: [apers, apres, asper, pares, parse, pears, prase, presa,
          rapes, reaps, spare, spear]
    11: [alerts, alters, artels, estral, laster, ratels, salter,
          slater, staler, stelar, talers]
    9: [capers, crapes, escarp, pacers, parsec, recaps, scrape,
         secpar, spacer]
    9: [palest, palets, pastel, petals, plates, pleats, septal,
         staple, tepals]
    9: [anestri, antsier, nastier, ratines, retains, retinas,
         retsina, stainer, stearin]
    8: [ates, east, eats, etas, sate, seat, seta, teas]
    8: [carets, cartes, caster, caters, crates, reacts, recast,
         traces]

Many of these words seem a bit bogus, but that's not the program's fault; they're in the dictionary file. Here's the [`dictionary file`](https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/dictionary.txt) we used. It was derived from the Public Domain ENABLE benchmark reference word list.


<a name="sec_15_7"></a>
## 15.7. Object Ordering
******

A `List` `l` may be sorted as follows.

Collections.sort(l);

If the `List` consists of `String` elements, it will be sorted into alphabetical order. If it consists of `Date` elements, it will be sorted into chronological order. How does this happen? `String` and `Date` both implement the `[Comparable](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html)` interface. `Comparable` implementations provide a _natural ordering_ for a class, which allows objects of that class to be sorted automatically. The following table summarizes some of the more important Java platform classes that implement `Comparable`.

**Classes Implementing Comparable**

|     Class      |        Natural Ordering       |
|----------------|-------------------------------|
| `Byte`         | Signed numerical              |
| `Character`    | Unsigned numerical            |
| `Long`         | Signed numerical              |
| `Integer`      | Signed numerical              |
| `Short`        | Signed numerical              |
| `Double`       | Signed numerical              |
| `Float`        | Signed numerical              |
| `BigInteger`   | Signed numerical              |
| `BigDecimal`   | Signed numerical              |
| `Boolean`      | `Boolean.FALSE < Boolean.TRUE` 
| `File`         | System-dependent lexicographic on path name
| `String`       | Lexicographic                 |
| `Date`         | Chronological                 |
| `CollationKey` | Locale-specific lexicographic |


If you try to sort a list, the elements of which do not implement `Comparable`, `Collections.sort(list)` will throw a [`ClassCastException`](https://docs.oracle.com/javase/8/docs/api/java/lang/ClassCastException.html). Similarly, `Collections.sort(list, comparator)` will throw a `ClassCastException` if you try to sort a list whose elements cannot be compared to one another using the `comparator`. Elements that can be compared to one another are called _mutually comparable_. Although elements of different types may be mutually comparable, none of the classes listed here permit interclass comparison.

This is all you really need to know about the `Comparable` interface if you just want to sort lists of comparable elements or to create sorted collections of them. The next section will be of interest to you if you want to implement your own `Comparable` type.

Writing Your Own Comparable Types
---------------------------------

The `Comparable` interface consists of the following method.

    public interface Comparable<T> {
        public int compareTo(T o);
    }

The `compareTo` method compares the receiving object with the specified object and returns a negative integer, 0, or a positive integer depending on whether the receiving object is less than, equal to, or greater than the specified object. If the specified object cannot be compared to the receiving object, the method throws a `ClassCastException`.

The [`following class representing a person's name`](https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/Name.java) implements `Comparable`.

```java
import java.util.*;

public class Name implements Comparable<Name> {
    private final String firstName, lastName;

    public Name(String firstName, String lastName) {
        if (firstName == null || lastName == null)
            throw new NullPointerException();
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String firstName() { return firstName; }
    public String lastName()  { return lastName;  }

    public boolean equals(Object o) {
        if (!(o instanceof Name))
            return false;
        Name n = (Name) o;
        return n.firstName.equals(firstName) && n.lastName.equals(lastName);
    }

    public int hashCode() {
        return 31*firstName.hashCode() + lastName.hashCode();
    }

    public String toString() {
    return firstName + " " + lastName;
    }

    public int compareTo(Name n) {
        int lastCmp = lastName.compareTo(n.lastName);
        return (lastCmp != 0 ? lastCmp : firstName.compareTo(n.firstName));
    }
}
```

To keep the preceding example short, the class is somewhat limited: It doesn't support middle names, it demands both a first and a last name, and it is not internationalized in any way. Nonetheless, it illustrates the following important points:

*   `Name` objects are _immutable_. All other things being equal, immutable types are the way to go, especially for objects that will be used as elements in `Set`s or as keys in `Map`s. These collections will break if you modify their elements or keys while they're in the collection.
*   The constructor checks its arguments for `null`. This ensures that all `Name` objects are well formed so that none of the other methods will ever throw a `NullPointerException`.
*   The `hashCode` method is redefined. This is essential for any class that redefines the `equals` method. (Equal objects must have equal hash codes.)
*   The `equals` method returns `false` if the specified object is `null` or of an inappropriate type. The `compareTo` method throws a runtime exception under these circumstances. Both of these behaviors are required by the general contracts of the respective methods.
*   The `toString` method has been redefined so it prints the `Name` in human-readable form. This is always a good idea, especially for objects that are going to get put into collections. The various collection types' `toString` methods depend on the `toString` methods of their elements, keys, and values.

Since this section is about element ordering, let's talk a bit more about `Name`'s `compareTo` method. It implements the standard name-ordering algorithm, where last names take precedence over first names. This is exactly what you want in a natural ordering. It would be very confusing indeed if the natural ordering were unnatural!

Take a look at how `compareTo` is implemented, because it's quite typical. First, you compare the most significant part of the object (in this case, the last name). Often, you can just use the natural ordering of the part's type. In this case, the part is a `String` and the natural (lexicographic) ordering is exactly what's called for. If the comparison results in anything other than zero, which represents equality, you're done: You just return the result. If the most significant parts are equal, you go on to compare the next most-significant parts. In this case, there are only two parts ‚Äî first name and last name. If there were more parts, you'd proceed in the obvious fashion, comparing parts until you found two that weren't equal or you were comparing the least-significant parts, at which point you'd return the result of the comparison.

Just to show that it all works, here's [`a program that builds a list of names and sorts them`](https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/NameSort.java).

```java
import java.util.*;

public class NameSort {
    public static void main(String[] args) {
        Name nameArray[] = {
            new Name("John", "Smith"),
            new Name("Karl", "Ng"),
            new Name("Jeff", "Smith"),
            new Name("Tom", "Rich")
        };

        List<Name> names = Arrays.asList(nameArray);
        Collections.sort(names);
        System.out.println(names);
    }
}
```

If you run this program, here's what it prints.

    [Karl Ng, Tom Rich, Jeff Smith, John Smith]

There are four restrictions on the behavior of the `compareTo` method, which we won't go into now because they're fairly technical and boring and are better left in the API documentation. It's really important that all classes that implement `Comparable` obey these restrictions, so read the documentation for `Comparable` if you're writing a class that implements it. Attempting to sort a list of objects that violate the restrictions has undefined behavior. Technically speaking, these restrictions ensure that the natural ordering is a _total order_ on the objects of a class that implements it; this is necessary to ensure that sorting is well defined.

Comparators
-----------

What if you want to sort some objects in an order other than their natural ordering? Or what if you want to sort some objects that don't implement `Comparable`? To do either of these things, you'll need to provide a [`Comparator`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html) ‚Äî an object that encapsulates an ordering. Like the `Comparable` interface, the `Comparator` interface consists of a single method.

```java
public interface Comparator<T> {
    int compare(T o1, T o2);
}
```

The `compare` method compares its two arguments, returning a negative integer, 0, or a positive integer depending on whether the first argument is less than, equal to, or greater than the second. If either of the arguments has an inappropriate type for the `Comparator`, the `compare` method throws a `ClassCastException`.

Much of what was said about `Comparable` applies to `Comparator` as well. Writing a `compare` method is nearly identical to writing a `compareTo` method, except that the former gets both objects passed in as arguments. The `compare` method has to obey the same four technical restrictions as `Comparable`'s `compareTo` method for the same reason ‚Äî a `Comparator` must induce a total order on the objects it compares.

Suppose you have a class called `Employee`, as follows.

```java
public class Employee implements Comparable<Employee> {
    public Name name()     { ... }
    public int number()    { ... }
    public Date hireDate() { ... }
       ...
}
```

Let's assume that the natural ordering of `Employee` instances is `Name` ordering (as defined in the previous example) on employee name. Unfortunately, the boss has asked for a list of employees in order of seniority. This means we have to do some work, but not much. The following program will produce the required list.

```java
import java.util.*;
public class EmpSort {
    static final Comparator<Employee> SENIORITY_ORDER = 
                                        new Comparator<Employee>() {
            public int compare(Employee e1, Employee e2) {
                return e2.hireDate().compareTo(e1.hireDate());
            }
    };

    // Employee database
    static final Collection<Employee> employees = ... ;

    public static void main(String[] args) {
        List<Employee> e = new ArrayList<Employee>(employees);
        Collections.sort(e, SENIORITY_ORDER);
        System.out.println(e);
    }
}
```

The `Comparator` in the program is reasonably straightforward. It relies on the natural ordering of `Date` applied to the values returned by the `hireDate` accessor method. Note that the `Comparator` passes the hire date of its second argument to its first rather than vice versa. The reason is that the employee who was hired most recently is the least senior; sorting in the order of hire date would put the list in reverse seniority order. Another technique people sometimes use to achieve this effect is to maintain the argument order but to negate the result of the comparison.

    // Don't do this!!
    return -r1.hireDate().compareTo(r2.hireDate());

You should always use the former technique in favor of the latter because the latter is not guaranteed to work. The reason for this is that the `compareTo` method can return any negative `int` if its argument is less than the object on which it is invoked. There is one negative `int` that remains negative when negated, strange as it may seem.

    -Integer.MIN_VALUE == Integer.MIN_VALUE

The `Comparator` in the preceding program works fine for sorting a `List`, but it does have one deficiency: It cannot be used to order a sorted collection, such as `TreeSet`, because it generates an ordering that is _not compatible with_ equals. This means that this `Comparator` equates objects that the `equals` method does not. In particular, any two employees who were hired on the same date will compare as equal. When you're sorting a `List`, this doesn't matter; but when you're using the `Comparator` to order a sorted collection, it's fatal. If you use this `Comparator` to insert multiple employees hired on the same date into a `TreeSet`, only the first one will be added to the set; the second will be seen as a duplicate element and will be ignored.

To fix this problem, simply tweak the `Comparator` so that it produces an ordering that _is compatible with_ `equals`. In other words, tweak it so that the only elements seen as equal when using `compare` are those that are also seen as equal when compared using `equals`. The way to do this is to perform a two-part comparison (as for `Name`), where the first part is the one we're interested in ‚Äî in this case, the hire date ‚Äî and the second part is an attribute that uniquely identifies the object. Here the employee number is the obvious attribute. This is the `Comparator` that results.

```java
static final Comparator<Employee> SENIORITY_ORDER = 
                                        new Comparator<Employee>() {
    public int compare(Employee e1, Employee e2) {
        int dateCmp = e2.hireDate().compareTo(e1.hireDate());
        if (dateCmp != 0)
            return dateCmp;

        return (e1.number() < e2.number() ? -1 :
               (e1.number() == e2.number() ? 0 : 1));
    }
};
```

One last note: You might be tempted to replace the final `return` statement in the `Comparator` with the simpler:

    return e1.number() - e2.number();

Don't do it unless you're _absolutely sure_ no one will ever have a negative employee number! This trick does not work in general because the signed integer type is not big enough to represent the difference of two arbitrary signed integers. If `i` is a large positive integer and `j` is a large negative integer, `i - j` will overflow and will return a negative integer. The resulting `comparator` violates one of the four technical restrictions we keep talking about (transitivity) and produces horrible, subtle bugs. This is not a purely theoretical concern; people get burned by it.


<a name="sec_15_8"></a>
## 15.8. The SortedSet Interface
******

A [`SortedSet`](https://docs.oracle.com/javase/8/docs/api/java/util/SortedSet.html) is a [`Set`](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html) that maintains its elements in ascending order, sorted according to the elements' natural ordering or according to a `Comparator` provided at `SortedSet` creation time. In addition to the normal `Set` operations, the `SortedSet` interface provides operations for the following:

*   `Range view` ‚Äî allows arbitrary range operations on the sorted set
*   `Endpoints` ‚Äî returns the first or last element in the sorted set
*   `Comparator access` ‚Äî returns the `Comparator`, if any, used to sort the set

The code for the `SortedSet` interface follows.

```java
public interface SortedSet<E> extends Set<E> {
    // Range-view
    SortedSet<E> subSet(E fromElement, E toElement);
    SortedSet<E> headSet(E toElement);
    SortedSet<E> tailSet(E fromElement);

    // Endpoints
    E first();
    E last();

    // Comparator access
    Comparator<? super E> comparator();
}
```

Set Operations
--------------

The operations that `SortedSet` inherits from `Set` behave identically on sorted sets and normal sets with two exceptions:

*   The `Iterator` returned by the `iterator` operation traverses the sorted set in order.
*   The array returned by `toArray` contains the sorted set's elements in order.

Although the interface doesn't guarantee it, the `toString` method of the Java platform's `SortedSet` implementations returns a string containing all the elements of the sorted set, in order.

Standard Constructors
---------------------

By convention, all general-purpose `Collection` implementations provide a standard conversion constructor that takes a `Collection`; `SortedSet` implementations are no exception. In `TreeSet`, this constructor creates an instance that sorts its elements according to their natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified collection was a `SortedSet` instance and, if so, to sort the new `TreeSet` according to the same criterion (comparator or natural ordering). Because `TreeSet` took the approach that it did, it also provides a constructor that takes a `SortedSet` and returns a new `TreeSet` containing the same elements sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines which of these two constructors is invoked (and whether the sorting criterion is preserved).

`SortedSet` implementations also provide, by convention, a constructor that takes a `Comparator` and returns an empty set sorted according to the specified `Comparator`. If `null` is passed to this constructor, it returns a set that sorts its elements according to their natural ordering.

Range-view Operations
---------------------

The `range-view` operations are somewhat analogous to those provided by the `List` interface, but there is one big difference. Range views of a sorted set remain valid even if the backing sorted set is modified directly. This is feasible because the endpoints of a range view of a sorted set are absolute points in the element space rather than specific elements in the backing collection, as is the case for lists. A `range-view` of a sorted set is really just a window onto whatever portion of the set lies in the designated part of the element space. Changes to the `range-view` write back to the backing sorted set and vice versa. Thus, it's okay to use `range-view`s on sorted sets for long periods of time, unlike `range-view`s on lists.

Sorted sets provide three `range-view` operations. The first, `subSet`, takes two endpoints, like `subList`. Rather than indices, the endpoints are objects and must be comparable to the elements in the sorted set, using the `Set`'s `Comparator` or the natural ordering of its elements, whichever the `Set` uses to order itself. Like `subList`, the range is half open, including its low endpoint but excluding the high one.

Thus, the following line of code tells you how many words between `"doorbell"` and `"pickle"`, including `"doorbell"` but excluding `"pickle"`, are contained in a `SortedSet` of strings called `dictionary`:

int count = dictionary.subSet("doorbell", "pickle").size();

In like manner, the following one-liner removes all the elements beginning with the letter `f`.

    dictionary.subSet("f", "g").clear();

A similar trick can be used to print a table telling you how many words begin with each letter.

    for (char ch = 'a'; ch <= 'z'; ) {
        String from = String.valueOf(ch++);
        String to = String.valueOf(ch);
        System.out.println(from + ": " + dictionary.subSet(from, to).size());
    }

Suppose you want to view a _closed interval_, which contains both of its endpoints, instead of an open interval. If the element type allows for the calculation of the successor of a given value in the element space, merely request the `subSet` from `lowEndpoint` to `successor(highEndpoint)`. Although it isn't entirely obvious, the successor of a string `s` in `String`'s natural ordering is `s + "\0"` ‚Äî that is, `s` with a `null` character appended.

Thus, the following one-liner tells you how many words between `"doorbell"` and `"pickle"`, including doorbell _and_ pickle, are contained in the dictionary.

    count = dictionary.subSet("doorbell", "pickle\0").size();

A similar technique can be used to view an _open interval_, which contains neither endpoint. The open-interval view from `lowEndpoint` to `highEndpoint` is the half-open interval from `successor(lowEndpoint)` to `highEndpoint`. Use the following to calculate the number of words between `"doorbell"` and `"pickle"`, excluding both.

    count = dictionary.subSet("doorbell\0", "pickle").size();

The `SortedSet` interface contains two more `range-view` operations ‚Äî `headSet` and `tailSet`, both of which take a single `Object` argument. The former returns a view of the initial portion of the backing `SortedSet`, up to but not including the specified object. The latter returns a view of the final portion of the backing `SortedSet`, beginning with the specified object and continuing to the end of the backing `SortedSet`. Thus, the following code allows you to view the dictionary as two disjoint `volumes` (`a-m` and `n-z`).

    SortedSet<String> volume1 = dictionary.headSet("n");
    SortedSet<String> volume2 = dictionary.tailSet("n");

Endpoint Operations
-------------------

The `SortedSet` interface contains operations to return the first and last elements in the sorted set, not surprisingly called `first` and `last`. In addition to their obvious uses, `last` allows a workaround for a deficiency in the `SortedSet` interface. One thing you'd like to do with a `SortedSet` is to go into the interior of the `Set` and iterate forward or backward. It's easy enough to go forward from the interior: Just get a `tailSet` and iterate over it. Unfortunately, there's no easy way to go backward.

The following idiom obtains the first element that is less than a specified object `o` in the element space.

    Object predecessor = ss.headSet(o).last();

This is a fine way to go one element backward from a point in the interior of a sorted set. It could be applied repeatedly to iterate backward, but this is very inefficient, requiring a lookup for each element returned.

Comparator Accessor
-------------------

The `SortedSet` interface contains an accessor method called `comparator` that returns the `Comparator` used to sort the set, or `null` if the set is sorted according to the _natural ordering_ of its elements. This method is provided so that sorted sets can be copied into new sorted sets with the same ordering. It is used by the `SortedSet` constructor described [previously](#constructor).


<a name="sec_15_9"></a>
## 15.9. The SortedMap Interface
******

A [`SortedMap`](https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html) is a [`Map`](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html) that maintains its entries in ascending order, sorted according to the keys' natural ordering, or according to a `Comparator` provided at the time of the `SortedMap` creation. Natural ordering and `Comparator`s are discussed in the [Object Ordering](order.html) section. The `SortedMap` interface provides operations for normal `Map` operations and for the following:

*   `Range view` ‚Äî performs arbitrary range operations on the sorted map
*   `Endpoints` ‚Äî returns the first or the last key in the sorted map
*   `Comparator access` ‚Äî returns the `Comparator`, if any, used to sort the map

The following interface is the `Map` analog of [`SortedSet`](https://docs.oracle.com/javase/8/docs/api/java/util/SortedSet.html).

```java
public interface SortedMap<K, V> extends Map<K, V>{
    Comparator<? super K> comparator();
    SortedMap<K, V> subMap(K fromKey, K toKey);
    SortedMap<K, V> headMap(K toKey);
    SortedMap<K, V> tailMap(K fromKey);
    K firstKey();
    K lastKey();
}
```

Map Operations
--------------

The operations `SortedMap` inherits from `Map` behave identically on sorted maps and normal maps with two exceptions:

*   The `Iterator` returned by the `iterator` operation on any of the sorted map's `Collection` views traverse the collections in order.
*   The arrays returned by the `Collection` views' `toArray` operations contain the keys, values, or entries in order.

Although it isn't guaranteed by the interface, the `toString` method of the `Collection` views in all the Java platform's `SortedMap` implementations returns a string containing all the elements of the view, in order.

Standard Constructors
---------------------

By convention, all general-purpose `Map` implementations provide a standard conversion constructor that takes a `Map`; `SortedMap` implementations are no exception. In `TreeMap`, this constructor creates an instance that orders its entries according to their keys' natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified `Map` instance was a `SortedMap` and, if so, to sort the new map according to the same criterion (comparator or natural ordering). Because `TreeMap` took the approach it did, it also provides a constructor that takes a `SortedMap` and returns a new `TreeMap` containing the same mappings as the given `SortedMap`, sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines whether the `SortedMap` constructor is invoked in preference to the ordinary `map` constructor.

`SortedMap` implementations also provide, by convention, a constructor that takes a `Comparator` and returns an empty map sorted according to the specified `Comparator`. If `null` is passed to this constructor, it returns a `Map` that sorts its mappings according to their keys' natural ordering.

Comparison to SortedSet
-----------------------

Because this interface is a precise `Map` analog of `SortedSet`, all the idioms and code examples in [The SortedSet Interface](sorted-set.html) section apply to `SortedMap` with only trivial modifications.


<a name="sec_15_10"></a>
## 15.10. Summary of Interfaces
******

The core collection interfaces are the foundation of the Java Collections Framework.

The Java Collections Framework hierarchy consists of two distinct interface trees:

*   The first tree starts with the `Collection` interface, which provides for the basic functionality used by all collections, such as `add` and `remove` methods. Its subinterfaces ‚Äî `Set`, `List`, and `Queue` ‚Äî provide for more specialized collections.
*   The `Set` interface does not allow duplicate elements. This can be useful for storing collections such as a deck of cards or student records. The `Set` interface has a subinterface, `SortedSet`, that provides for ordering of elements in the set.
    
*   The `List` interface provides for an ordered collection, for situations in which you need precise control over where each element is inserted. You can retrieve elements from a `List` by their exact position.
    
*   The `Queue` interface enables additional insertion, extraction, and inspection operations. Elements in a `Queue` are typically ordered in on a FIFO basis.
    
*   The `Deque` interface enables insertion, deletion, and inspection operations at both the ends. Elements in a `Deque` can be used in both LIFO and FIFO.
    
*   The second tree starts with the `Map` interface, which maps keys and values similar to a `Hashtable`.
    
*   `Map`'s subinterface, `SortedMap`, maintains its key-value pairs in ascending order or in an order specified by a `Comparator`.
    

These interfaces allow collections to be manipulated independently of the details of their representation.


<a name="sec_15_11"></a>
## 15.11. Questions and Exercises
******

Questions
---------

1.  At the beginning of this lesson, you learned that the core collection interfaces are organized into two distinct inheritance trees. One interface in particular is not considered to be a true `Collection`, and therefore sits at the top of its own tree. What is the name of this interface?
2.  Each interface in the collections framework is declared with the `<E>` syntax, which tells you that it is generic. When you declare a `Collection` instance, what is the advantage of specifying the type of objects that it will contain?
3.  What interface represents a collection that does not allow duplicate elements?
4.  What interface forms the root of the collections hierarchy?
5.  What interface represents an ordered collection that may contain duplicate elements?
6.  What interface represents a collection that holds elements prior to processing?
7.  What interface represents a type that maps keys to values?
8.  What interface represents a double-ended queue?
9.  Name three different ways to iterate over the elements of a `List`.
10.  True or False: Aggregate operations are mutative operations that modify the underlying collection.

Exercises
---------

1.  Write a program that prints its arguments in random order. Do not make a copy of the argument array. Demonstrate how to print out the elements using both streams and the traditional enhanced for statement.
2.  Take the [`FindDups`](../examples/FindDups.java) example and modify it to use a `SortedSet` instead of a `Set`. Specify a `Comparator` so that case is ignored when sorting and identifying set elements.
3.  Write a method that takes a `List<String>` and applies [`String.trim`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim--) to each element.
4.  Consider the four core interfaces, `Set`, `List`, `Queue`, and `Map`. For each of the following four assignments, specify which of the four core interfaces is best-suited, and explain how to use it to implement the assignment.
    1.  Whimsical Toys Inc (WTI) needs to record the names of all its employees. Every month, an employee will be chosen at random from these records to receive a free toy.
    2.  WTI has decided that each new product will be named after an employee but only first names will be used, and each name will be used only once. Prepare a list of unique first names.
    3.  WTI decides that it only wants to use the most popular names for its toys. Count up the number of employees who have each first name.
    4.  WTI acquires season tickets for the local lacrosse team, to be shared by employees. Create a waiting list for this popular sport.

[Check your answers.](answers.html)


Questions
---------

1.  Question: At the beginning of this lesson, you learned that the core collection interfaces are organized into two distinct inheritance trees. One interface in particular is not considered to be a true `Collection`, and therefore sits at the top of its own tree. What is the name of this interface?  
    Answer: `Map`  
      
    
2.  Question: Each interface in the collections framework is declared with the `<E>` syntax, which tells you that it is generic. When you declare a `Collection` instance, what is the advantage of specifying the type of objects that it will contain?  
    Answer: Specifying the type allows the compiler to verify (at compile time) that the type of object you put into the collection is correct, thus reducing errors at runtime.  
      
    
3.  Question: What interface represents a collection that does not allow duplicate elements?  
    Answer: `Set`  
      
    
4.  Question: What interface forms the root of the collections hierarchy?  
    Answer: `Collection`  
      
    
5.  Question: What interface represents an ordered collection that may contain duplicate elements?  
    Answer: `List`  
      
    
6.  Question: What interface represents a collection that holds elements prior to processing?  
    Answer: `Queue`  
      
    
7.  Question: What interface represents a type that maps keys to values?  
    Answer: `Map`  
      
    
8.  Question: What interface represents a double-ended queue?  
    Answer: `Deque`  
      
    
9.  Question: Name three different ways to iterate over the elements of a `List`.  
    Answer: You can iterate over a `List` using streams, the enhanced `for` statement, or iterators.  
      
    
10.  Question: True or False: Aggregate operations are mutative operations that modify the underlying collection.  
    Answer: False. Aggregate operations do not mutate the underlying collection. In fact, you must be careful to never mutate a collection while invoking its aggregate operations. Doing so could lead to concurrency problems should the stream be changed to a parallel stream at some point in the future.  
    

Exercises
---------

1.  Exercise: Write a program that prints its arguments in random order. Do not make a copy of the argument array. Demonstrate how to print out the elements using both streams and the traditional enhanced for statement.  
    Answer:  
    
    ```java
    import java.util.*;
        
        public class Ran {
        
            public static void main(String[] args) {
                
                // Get and shuffle the list of arguments
                List<String> argList = Arrays.asList(args);
                Collections.shuffle(argList);
        
                // Print out the elements using JDK 8 Streams
                argList.stream()
                .forEach(e->System.out.format("%s ",e));
        
                // Print out the elements using for-each
                for (String arg: argList) {
                    System.out.format("%s ", arg);
                }
        
                System.out.println();
            }
        }
    ```
    
2.  Exercise: Take the [`FindDups`](https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/FindDups.java) example and modify it to use a `SortedSet` instead of a `Set`. Specify a `Comparator` so that case is ignored when sorting and identifying set elements.  
    Answer:  
    
    ```java
    import java.util.*;
        
        public class FindDups {
        
            static final Comparator<String> IGNORE_CASE_ORDER
                    = new Comparator<String>() {
                public int compare(String s1, String s2) {
                    return s1.compareToIgnoreCase(s2);
                }
            };
        
            public static void main(String[] args) {
                
                SortedSet<String> s = new TreeSet<String>(IGNORE_CASE_ORDER);
                for (String a : args) {
                    s.add(a);
                }
                System.out.println(s.size() + " distinct words: " + s);
            }
        }
    ```
    
3.  Exercise: Write a method that takes a `List<String>` and applies [`String.trim`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim--) to each element.  
    Answer:  
    The enhanced `for` statement does not allow you to modify the `List`. Using an instance of the `Iterator` class allows you to delete elements, but not replace an existing element or add a new one. That leaves `ListIterator`:
    
    ```java
    import java.util.*;
        
        public class ListTrim {
            static void listTrim(List<String> strings) {
                for (ListIterator<String> lit = strings.listIterator(); lit.hasNext(); ) {
                    lit.set(lit.next().trim());
                }
            }
        
            public static void main(String[] args) {
                List<String> l = Arrays.asList(" red ", " white ", " blue ");
                listTrim(l);
                for (String s : l) {
                    System.out.format("\"%s\"%n", s);
                }
            }
        }
    ```
    
4.  Exercise: Consider the four core interfaces, `Set`, `List`, `Queue`, and `Map`. For each of the following four assignments, specify which of the four core interfaces is best-suited, and explain how to use it to implement the assignment.  
    Answers:  
    *   Whimsical Toys Inc (WTI) needs to record the names of all its employees. Every month, an employee will be chosen at random from these records to receive a free toy.  
        Use a `List`. Choose a random employee by picking a number between `0` and `size()-1`.
    *   WTI has decided that each new product will be named after an employee ‚Äî but only first names will be used, and each name will be used only once. Prepare a list of unique first names.  
        Use a `Set`. Collections that implement this interface don't allow the same element to be entered more than once.
    *   WTI decides that it only wants to use the most popular names for its toys. Count up the number of employees who have each first name.  
        Use a `Map`, where the keys are first names, and each value is a count of the number of employees with that first name.
    *   WTI acquires season tickets for the local lacrosse team, to be shared by employees. Create a waiting list for this popular sport.  
        Use a `Queue`. Invoke `add()` to add employees to the waiting list, and `remove()` to remove them.




<a name="sec_16"></a>
## 16. Aggregate Operations
******
https://docs.oracle.com/javase/tutorial/collections/streams/index.html

16.1. [Reduction]
16.2. [Parallelism]
16.3. [Questions and Exercises]

**Note**: To better understand the concepts in this section, review the sections [Lambda Expressions](../../java/javaOO/lambdaexpressions.html) and [Method References](../../java/javaOO/methodreferences.html).

For what do you use collections? You don't simply store objects in a collection and leave them there. In most cases, you use collections to retrieve items stored in them.

Consider again the scenario described in the section [Lambda Expressions](../../java/javaOO/lambdaexpressions.html). Suppose that you are creating a social networking application. You want to create a feature that enables an administrator to perform any kind of action, such as sending a message, on members of the social networking application that satisfy certain criteria.

As before, suppose that members of this social networking application are represented by the following [`Person`](https://docs.oracle.com/javase/tutorial/collections/streams/examples/Person.java) class:

```java
public class Person {

    public enum Sex {
        MALE, FEMALE
    }

    String name;
    LocalDate birthday;
    Sex gender;
    String emailAddress;
    
    // ...

    public int getAge() {
        // ...
    }

    public String getName() {
        // ...
    }
}
```

The following example prints the name of all members contained in the collection `roster` with a for-each loop:

for (Person p : roster) {
    System.out.println(p.getName());
}

The following example prints all members contained in the collection `roster` but with the aggregate operation `forEach`:

roster
    .stream()
    .forEach(e -> System.out.println(e.getName());

Although, in this example, the version that uses aggregate operations is longer than the one that uses a for-each loop, you will see that versions that use bulk-data operations will be more concise for more complex tasks.

The following topics are covered:

*   [Pipelines and Streams](#pipelines)
*   [Differences Between Aggregate Operations and Iterators](#differences)

Find the code excerpts described in this section in the example [`BulkDataOperationsExamples`](https://docs.oracle.com/javase/tutorial/collections/streams/examples/BulkDataOperationsExamples.java).

### Pipelines and Streams

A _pipeline_ is a sequence of aggregate operations. The following example prints the male members contained in the collection `roster` with a pipeline that consists of the aggregate operations `filter` and `forEach`:

roster
    .stream()
    .filter(e -> e.getGender() == Person.Sex.MALE)
    .forEach(e -> System.out.println(e.getName()));

Compare this example to the following that prints the male members contained in the collection `roster` with a for-each loop:

for (Person p : roster) {
    if (p.getGender() == Person.Sex.MALE) {
        System.out.println(p.getName());
    }
}

A pipeline contains the following components:

*   A source: This could be a collection, an array, a generator function, or an I/O channel. In this example, the source is the collection `roster`.
    
*   Zero or more _intermediate operations_. An intermediate operation, such as `filter`, produces a new stream.
    
    A _stream_ is a sequence of elements. Unlike a collection, it is not a data structure that stores elements. Instead, a stream carries values from a source through a pipeline. This example creates a stream from the collection `roster` by invoking the method `stream`.
    
    The `filter` operation returns a new stream that contains elements that match its predicate (this operation's parameter). In this example, the predicate is the lambda expression `e -> e.getGender() == Person.Sex.MALE`. It returns the boolean value `true` if the `gender` field of object `e` has the value `Person.Sex.MALE`. Consequently, the `filter` operation in this example returns a stream that contains all male members in the collection `roster`.
    
*   A _terminal operation_. A terminal operation, such as `forEach`, produces a non-stream result, such as a primitive value (like a double value), a collection, or in the case of `forEach`, no value at all. In this example, the parameter of the `forEach` operation is the lambda expression `e -> System.out.println(e.getName())`, which invokes the method `getName` on the object `e`. (The Java runtime and compiler infer that the type of the object `e` is `Person`.)
    

The following example calculates the average age of all male members contained in the collection `roster` with a pipeline that consists of the aggregate operations `filter`, `mapToInt`, and `average`:

double average = roster
    .stream()
    .filter(p -> p.getGender() == Person.Sex.MALE)
    .mapToInt(Person::getAge)
    .average()
    .getAsDouble();

The `mapToInt` operation returns a new stream of type `IntStream` (which is a stream that contains only integer values). The operation applies the function specified in its parameter to each element in a particular stream. In this example, the function is `Person::getAge`, which is a method reference that returns the age of the member. (Alternatively, you could use the lambda expression `e -> e.getAge()`.) Consequently, the `mapToInt` operation in this example returns a stream that contains the ages of all male members in the collection `roster`.

The `average` operation calculates the average value of the elements contained in a stream of type `IntStream`. It returns an object of type `OptionalDouble`. If the stream contains no elements, then the `average` operation returns an empty instance of `OptionalDouble`, and invoking the method `getAsDouble` throws a `NoSuchElementException`. The JDK contains many terminal operations such as `average` that return one value by combining the contents of a stream. These operations are called _reduction operations_; see the section [Reduction](../../collections/streams/reduction.html) for more information.

### Differences Between Aggregate Operations and Iterators

Aggregate operations, like `forEach`, appear to be like iterators. However, they have several fundamental differences:

*   **They use internal iteration**: Aggregate operations do not contain a method like `next` to instruct them to process the next element of the collection. With _internal delegation_, your application determines _what_ collection it iterates, but the JDK determines _how_ to iterate the collection. With _external iteration_, your application determines both what collection it iterates and how it iterates it. However, external iteration can only iterate over the elements of a collection sequentially. Internal iteration does not have this limitation. It can more easily take advantage of parallel computing, which involves dividing a problem into subproblems, solving those problems simultaneously, and then combining the results of the solutions to the subproblems. See the section [Parallelism](../../collections/streams/parallelism.html) for more information.
    
*   **They process elements from a stream**: Aggregate operations process elements from a stream, not directly from a collection. Consequently, they are also called _stream operations_.
    
*   **They support behavior as parameters**: You can specify [lambda expressions](../../java/javaOO/lambdaexpressions.html) as parameters for most aggregate operations. This enables you to customize the behavior of a particular aggregate operation.
    

<a name="sec_16_1"></a>
## 16.1. Reduction
******

The section [Aggregate Operations](../../collections/streams/index.html) describes the following pipeline of operations, which calculates the average age of all male members in the collection `roster`:

    double average = roster
        .stream()
        .filter(p -> p.getGender() == Person.Sex.MALE)
        .mapToInt(Person::getAge)
        .average()
        .getAsDouble();

The JDK contains many terminal operations (such as 
[`average`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#average--java/lang/reflect/Executable.html), 
[`sum`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#sum--), 
[`min`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#min-java.util.Comparator-), 
[`max`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#max-java.util.Comparator-), and 
[`count`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#count--)) that return one value by combining the contents of a stream. These operations are called _reduction operations_. The JDK also contains reduction operations that return a collection instead of a single value. Many reduction operations perform a specific task, such as finding the average of values or grouping elements into categories. However, the JDK provides you with the general-purpose reduction operations 
[`reduce`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-) and 
[`collect`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BiConsumer-), which this section describes in detail.

This section covers the following topics:

*   [The Stream.reduce Method](#reduce)
*   [The Stream.collect Method](#collect)

You can find the code excerpts described in this section in the example [`ReductionExamples`](examples/ReductionExamples.java).

The Stream.reduce Method
------------------------

The [`Stream.reduce`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-) method is a general-purpose reduction operation. Consider the following pipeline, which calculates the sum of the male members' ages in the collection `roster`. It uses the [`Stream.sum`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#sum--) reduction operation:

    Integer totalAge = roster
        .stream()
        .mapToInt(Person::getAge)
        .sum();

Compare this with the following pipeline, which uses the `Stream.reduce` operation to calculate the same value:

    Integer totalAgeReduce = roster
       .stream()
       .map(Person::getAge)
       .reduce(
           0,
           (a, b) -> a + b);

The `reduce` operation in this example takes two arguments:

*   `identity`: The identity element is both the initial value of the reduction and the default result if there are no elements in the stream. In this example, the identity element is `0`; this is the initial value of the sum of ages and the default value if no members exist in the collection `roster`.
    
*   `accumulator`: The accumulator function takes two parameters: a partial result of the reduction (in this example, the sum of all processed integers so far) and the next element of the stream (in this example, an integer). It returns a new partial result. In this example, the accumulator function is a lambda expression that adds two `Integer` values and returns an `Integer` value:
    
    (a, b) -> a + b
    

The `reduce` operation always returns a new value. However, the accumulator function also returns a new value every time it processes an element of a stream. Suppose that you want to reduce the elements of a stream to a more complex object, such as a collection. This might hinder the performance of your application. If your `reduce` operation involves adding elements to a collection, then every time your accumulator function processes an element, it creates a new collection that includes the element, which is inefficient. It would be more efficient for you to update an existing collection instead. You can do this with the [`Stream.collect`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BiConsumer-) method, which the next section describes.

The Stream.collect Method
-------------------------

Unlike the `reduce` method, which always creates a new value when it processes an element, the [`collect`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BiConsumer-) method modifies, or mutates, an existing value.

Consider how to find the average of values in a stream. You require two pieces of data: the total number of values and the sum of those values. However, like the `reduce` method and all other reduction methods, the `collect` method returns only one value. You can create a new data type that contains member variables that keep track of the total number of values and the sum of those values, such as the following class, [`Averager`](examples/Averager.java):

```java
class Averager implements IntConsumer
{
    private int total = 0;
    private int count = 0;
        
    public double average() {
        return count > 0 ? ((double) total)/count : 0;
    }
        
    public void accept(int i) { total += i; count++; }
    public void combine(Averager other) {
        total += other.total;
        count += other.count;
    }
}
```

The following pipeline uses the `Averager` class and the `collect` method to calculate the average age of all male members:

```java
Averager averageCollect = roster.stream()
    .filter(p -> p.getGender() == Person.Sex.MALE)
    .map(Person::getAge)
    .collect(Averager::new, Averager::accept, Averager::combine);
                   
System.out.println("Average age of male members: " +
    averageCollect.average());
```

The `collect` operation in this example takes three arguments:

*   `supplier`: The supplier is a factory function; it constructs new instances. For the `collect` operation, it creates instances of the result container. In this example, it is a new instance of the `Averager` class.
*   `accumulator`: The accumulator function incorporates a stream element into a result container. In this example, it modifies the `Averager` result container by incrementing the `count` variable by one and adding to the `total` member variable the value of the stream element, which is an integer representing the age of a male member.
*   `combiner`: The combiner function takes two result containers and merges their contents. In this example, it modifies an `Averager` result container by incrementing the `count` variable by the `count` member variable of the other `Averager` instance and adding to the `total` member variable the value of the other `Averager` instance's `total` member variable.

Note the following:

*   The supplier is a lambda expression (or a method reference) as opposed to a value like the identity element in the `reduce` operation.
*   The accumulator and combiner functions do not return a value.
*   You can use the `collect` operations with parallel streams; see the section [Parallelism](../../collections/streams/parallelism.html) for more information. (If you run the `collect` method with a parallel stream, then the JDK creates a new thread whenever the combiner function creates a new object, such as an `Averager` object in this example. Consequently, you do not have to worry about synchronization.)

Although the JDK provides you with the `average` operation to calculate the average value of elements in a stream, you can use the `collect` operation and a custom class if you need to calculate several values from the elements of a stream.

The `collect` operation is best suited for collections. The following example puts the names of the male members in a collection with the `collect` operation:

    List<String> namesOfMaleMembersCollect = roster
        .stream()
        .filter(p -> p.getGender() == Person.Sex.MALE)
        .map(p -> p.getName())
        .collect(Collectors.toList());

This version of the `collect` operation takes one parameter of type [`Collector`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html). This class encapsulates the functions used as arguments in the `collect` operation that requires three arguments (supplier, accumulator, and combiner functions).

The [`Collectors`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html) class contains many useful reduction operations, such as accumulating elements into collections and summarizing elements according to various criteria. These reduction operations return instances of the class `Collector`, so you can use them as a parameter for the `collect` operation.

This example uses the [`Collectors.toList`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toList--) operation, which accumulates the stream elements into a new instance of `List`. As with most operations in the `Collectors` class, the `toList` operator returns an instance of `Collector`, not a collection.

The following example groups members of the collection `roster` by gender:

    Map<Person.Sex, List<Person>> byGender =
        roster
            .stream()
            .collect(
                Collectors.groupingBy(Person::getGender));

The [`groupingBy`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingBy-java.util.function.Function-) operation returns a map whose keys are the values that result from applying the lambda expression specified as its parameter (which is called a _classification function_). In this example, the returned map contains two keys, `Person.Sex.MALE` and `Person.Sex.FEMALE`. The keys' corresponding values are instances of `List` that contain the stream elements that, when processed by the classification function, correspond to the key value. For example, the value that corresponds to key `Person.Sex.MALE` is an instance of `List` that contains all male members.

The following example retrieves the names of each member in the collection `roster` and groups them by gender:

    Map<Person.Sex, List<String>> namesByGender =
        roster
            .stream()
            .collect(
                Collectors.groupingBy(
                    Person::getGender,
                    Collectors.mapping(
                        Person::getName,
                        Collectors.toList())));

The [`groupingBy`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.stream.Collector-) operation in this example takes two parameters, a classification function and an instance of `Collector`. The `Collector` parameter is called a _downstream collector_. This is a collector that the Java runtime applies to the results of another collector. Consequently, this `groupingBy` operation enables you to apply a `collect` method to the `List` values created by the `groupingBy` operator. This example applies the collector [`mapping`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#mapping-java.util.function.Function-java.util.stream.Collector-java.util.stream.Collector-), which applies the mapping function `Person::getName` to each element of the stream. Consequently, the resulting stream consists of only the names of members. A pipeline that contains one or more downstream collectors, like this example, is called a _multilevel reduction_.

The following example retrieves the total age of members of each gender:

    Map<Person.Sex, Integer> totalAgeByGender =
        roster
            .stream()
            .collect(
                Collectors.groupingBy(
                    Person::getGender,
                    Collectors.reducing(
                        0,
                        Person::getAge,
                        Integer::sum)));

The [`reducing`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#reducing-U-java.util.function.Function-java.util.function.BinaryOperator-) operation takes three parameters:

*   `identity`: Like the `Stream.reduce` operation, the identity element is both the initial value of the reduction and the default result if there are no elements in the stream. In this example, the identity element is `0`; this is the initial value of the sum of ages and the default value if no members exist.
*   `mapper`: The `reducing` operation applies this mapper function to all stream elements. In this example, the mapper retrieves the age of each member.
*   `operation`: The operation function is used to reduce the mapped values. In this example, the operation function adds `Integer` values.

The following example retrieves the average age of members of each gender:

    Map<Person.Sex, Double> averageAgeByGender = roster
        .stream()
        .collect(
            Collectors.groupingBy(
                Person::getGender,
                Collectors.averagingInt(Person::getAge)));


<a name="sec_16_2"></a>
## 16.2. Parallelism
******

Parallel computing involves dividing a problem into subproblems, solving those problems simultaneously (in parallel, with each subproblem running in a separate thread), and then combining the results of the solutions to the subproblems. Java SE provides the [fork/join framework](../../essential/concurrency/forkjoin.html), which enables you to more easily implement parallel computing in your applications. However, with this framework, you must specify how the problems are subdivided (partitioned). With aggregate operations, the Java runtime performs this partitioning and combining of solutions for you.

One difficulty in implementing parallelism in applications that use collections is that collections are not thread-safe, which means that multiple threads cannot manipulate a collection without introducing [thread interference](../../essential/concurrency/interfere.html) or [memory consistency errors](../../essential/concurrency/memconsist.html). The Collections Framework provides [synchronization wrappers](../../collections/implementations/wrapper.html), which add automatic synchronization to an arbitrary collection, making it thread-safe. However, synchronization introduces [thread contention](../../essential/concurrency/sync.html#thread_contention). You want to avoid thread contention because it prevents threads from running in parallel. Aggregate operations and parallel streams enable you to implement parallelism with non-thread-safe collections provided that you do not modify the collection while you are operating on it.

Note that parallelism is not automatically faster than performing operations serially, although it can be if you have enough data and processor cores. While aggregate operations enable you to more easily implement parallelism, it is still your responsibility to determine if your application is suitable for parallelism.

This section covers the following topics:

*   [Executing Streams in Parallel](#executing_streams_in_parallel)
*   [Concurrent Reduction](#concurrent_reduction)
*   [Ordering](#ordering)
*   [Side Effects](#side_effects)
    *   [Laziness](#laziness)
    *   [Interference](#interference)
    *   [Stateful Lambda Expressions](#stateful_lambda_expressions)

You can find the code excerpts described in this section in the example [`ParallelismExamples`](examples/ParallelismExamples.java).

Executing Streams in Parallel
-----------------------------

You can execute streams in serial or in parallel. When a stream executes in parallel, the Java runtime partitions the stream into multiple substreams. Aggregate operations iterate over and process these substreams in parallel and then combine the results.

When you create a stream, it is always a serial stream unless otherwise specified. To create a parallel stream, invoke the operation [`Collection.parallelStream`](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#parallelStream--). Alternatively, invoke the operation [`BaseStream.parallel`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#parallel--). For example, the following statement calculates the average age of all male members in parallel:

    double average = roster
        .parallelStream()
        .filter(p -> p.getGender() == Person.Sex.MALE)
        .mapToInt(Person::getAge)
        .average()
        .getAsDouble();

Concurrent Reduction
--------------------

Consider again the following example (which is described in the section [Reduction](../../collections/streams/reduction.html)) that groups members by gender. This example invokes the `collect` operation, which reduces the collection `roster` into a `Map`:

```java
Map<Person.Sex, List<Person>> byGender =
    roster
        .stream()
        .collect(
            Collectors.groupingBy(Person::getGender));
```

The following is the parallel equivalent:

```java
ConcurrentMap<Person.Sex, List<Person>> byGender =
    roster
        .parallelStream()
        .collect(
            Collectors.groupingByConcurrent(Person::getGender));
```

This is called a _concurrent reduction_. The Java runtime performs a concurrent reduction if all of the following are true for a particular pipeline that contains the `collect` operation:

*   The stream is parallel.
*   The parameter of the `collect` operation, the collector, has the characteristic [`Collector.Characteristics.CONCURRENT`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html#CONCURRENT). To determine the characteristics of a collector, invoke the [`Collector.characteristics`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html) method.
*   Either the stream is unordered, or the collector has the characteristic [`Collector.Characteristics.UNORDERED`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html#UNORDERED). To ensure that the stream is unordered, invoke the [`BaseStream.unordered`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#unordered--) operation.

**Note**: This example returns an instance of [`ConcurrentMap`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html) instead of `Map` and invokes the [`groupingByConcurrent`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-) operation instead of `groupingBy`. (See the section [Concurrent Collections](../../essential/concurrency/collections.html) for more information about `ConcurrentMap`.) Unlike the operation `groupingByConcurrent`, the operation `groupingBy` performs poorly with parallel streams. (This is because it operates by merging two maps by key, which is computationally expensive.) Similarly, the operation [`Collectors.toConcurrentMap`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-) performs better with parallel streams than the operation [`Collectors.toMap`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-).

Ordering
--------

The order in which a pipeline processes the elements of a stream depends on whether the stream is executed in serial or in parallel, the source of the stream, and intermediate operations. For example, consider the following example that prints the elements of an instance of `ArrayList` with the `forEach` operation several times:

    Integer[] intArray = {1, 2, 3, 4, 5, 6, 7, 8 };
    List<Integer> listOfIntegers =
        new ArrayList<>(Arrays.asList(intArray));

    System.out.println("listOfIntegers:");
    listOfIntegers
        .stream()
        .forEach(e -> System.out.print(e + " "));
    System.out.println("");

    System.out.println("listOfIntegers sorted in reverse order:");
    Comparator<Integer> normal = Integer::compare;
    Comparator<Integer> reversed = normal.reversed(); 
    Collections.sort(listOfIntegers, reversed);  
    listOfIntegers
        .stream()
        .forEach(e -> System.out.print(e + " "));
    System.out.println("");
         
    System.out.println("Parallel stream");
    listOfIntegers
        .parallelStream()
        .forEach(e -> System.out.print(e + " "));
    System.out.println("");
        
    System.out.println("Another parallel stream:");
    listOfIntegers
        .parallelStream()
        .forEach(e -> System.out.print(e + " "));
    System.out.println("");
         
    System.out.println("With forEachOrdered:");
    listOfIntegers
        .parallelStream()
        .forEachOrdered(e -> System.out.print(e + " "));
    System.out.println("");

This example consists of five pipelines. It prints output similar to the following:

    listOfIntegers:
    1 2 3 4 5 6 7 8
    listOfIntegers sorted in reverse order:
    8 7 6 5 4 3 2 1
    Parallel stream:
    3 4 1 6 2 5 7 8
    Another parallel stream:
    6 3 1 5 7 8 4 2
    With forEachOrdered:
    8 7 6 5 4 3 2 1

This example does the following:

*   The first pipeline prints the elements of the list `listOfIntegers` in the order that they were added to the list.
*   The second pipeline prints the elements of `listOfIntegers` after it was sorted by the method [`Collections.sort`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-).
*   The third and fourth pipelines print the elements of the list in an apparently random order. Remember that stream operations use internal iteration when processing elements of a stream. Consequently, when you execute a stream in parallel, the Java compiler and runtime determine the order in which to process the stream's elements to maximize the benefits of parallel computing unless otherwise specified by the stream operation.
*   The fifth pipeline uses the method [`forEachOrdered`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#forEachOrdered-java.util.function.Consumer-), which processes the elements of the stream in the order specified by its source, regardless of whether you executed the stream in serial or parallel. Note that you may lose the benefits of parallelism if you use operations like `forEachOrdered` with parallel streams.

Side Effects
------------

A method or an expression has a side effect if, in addition to returning or producing a value, it also modifies the state of the computer. Examples include mutable reductions (operations that use the `collect` operation; see the section [Reduction](../../collections/streams/reduction.html) for more information) as well as invoking the `System.out.println` method for debugging. The JDK handles certain side effects in pipelines well. In particular, the `collect` method is designed to perform the most common stream operations that have side effects in a parallel-safe manner. Operations like `forEach` and `peek` are designed for side effects; a lambda expression that returns void, such as one that invokes `System.out.println`, can do nothing but have side effects. Even so, you should use the `forEach` and `peek` operations with care; if you use one of these operations with a parallel stream, then the Java runtime may invoke the lambda expression that you specified as its parameter concurrently from multiple threads. In addition, never pass as parameters lambda expressions that have side effects in operations such as `filter` and `map`. The following sections discuss [interference](#interference) and [stateful lambda expressions](#stateful_lambda_expressions), both of which can be sources of side effects and can return inconsistent or unpredictable results, especially in parallel streams. However, the concept of [laziness](#laziness) is discussed first, because it has a direct effect on interference.

### Laziness

All intermediate operations are _lazy_. An expression, method, or algorithm is lazy if its value is evaluated only when it is required. (An algorithm is _eager_ if it is evaluated or processed immediately.) Intermediate operations are lazy because they do not start processing the contents of the stream until the terminal operation commences. Processing streams lazily enables the Java compiler and runtime to optimize how they process streams. For example, in a pipeline such as the `filter`\-`mapToInt`\-`average` example described in the section [Aggregate Operations](../../collections/streams/index.html), the `average` operation could obtain the first several integers from the stream created by the `mapToInt` operation, which obtains elements from the `filter` operation. The `average` operation would repeat this process until it had obtained all required elements from the stream, and then it would calculate the average.

### Interference

Lambda expressions in stream operations should not _interfere_. Interference occurs when the source of a stream is modified while a pipeline processes the stream. For example, the following code attempts to concatenate the strings contained in the `List` `listOfStrings`. However, it throws a `ConcurrentModificationException`:

```java
try {
    List<String> listOfStrings =
        new ArrayList<>(Arrays.asList("one", "two"));
         
    // This will fail as the peek operation will attempt to add the
    // string "three" to the source after the terminal operation has
    // commenced. 
             
    String concatenatedString = listOfStrings
        .stream()
        
        // Don't do this! Interference occurs here.
        .peek(s -> listOfStrings.add("three"))
        
        .reduce((a, b) -> a + " " + b)
        .get();
                 
    System.out.println("Concatenated string: " + concatenatedString);
         
} catch (Exception e) {
    System.out.println("Exception caught: " + e.toString());
}
```

This example concatenates the strings contained in `listOfStrings` into an `Optional<String>` value with the `reduce` operation, which is a terminal operation. However, the pipeline here invokes the intermediate operation `peek`, which attempts to add a new element to `listOfStrings`. Remember, all intermediate operations are lazy. This means that the pipeline in this example begins execution when the operation `get` is invoked, and ends execution when the `get` operation completes. The argument of the `peek` operation attempts to modify the stream source during the execution of the pipeline, which causes the Java runtime to throw a `ConcurrentModificationException`.

### Stateful Lambda Expressions

Avoid using _stateful lambda expressions_ as parameters in stream operations. A stateful lambda expression is one whose result depends on any state that might change during the execution of a pipeline. The following example adds elements from the `List` `listOfIntegers` to a new `List` instance with the `map` intermediate operation. It does this twice, first with a serial stream and then with a parallel stream:

    List<Integer> serialStorage = new ArrayList<>();
     
    System.out.println("Serial stream:");
    listOfIntegers
        .stream()
        
        // Don't do this! It uses a stateful lambda expression.
        .map(e -> { serialStorage.add(e); return e; })
        
        .forEachOrdered(e -> System.out.print(e + " "));
    System.out.println("");
         
    serialStorage
        .stream()
        .forEachOrdered(e -> System.out.print(e + " "));
    System.out.println("");

    System.out.println("Parallel stream:");
    List<Integer> parallelStorage = Collections.synchronizedList(
        new ArrayList<>());
    listOfIntegers
        .parallelStream()
        
        // Don't do this! It uses a stateful lambda expression.
        .map(e -> { parallelStorage.add(e); return e; })
        
        .forEachOrdered(e -> System.out.print(e + " "));
    System.out.println("");
         
    parallelStorage
        .stream()
        .forEachOrdered(e -> System.out.print(e + " "));
    System.out.println("");

The lambda expression `e -> { parallelStorage.add(e); return e; }` is a stateful lambda expression. Its result can vary every time the code is run. This example prints the following:

    Serial stream:
    8 7 6 5 4 3 2 1
    8 7 6 5 4 3 2 1
    Parallel stream:
    8 7 6 5 4 3 2 1
    1 3 6 2 4 5 8 7

The operation `forEachOrdered` processes elements in the order specified by the stream, regardless of whether the stream is executed in serial or parallel. However, when a stream is executed in parallel, the `map` operation processes elements of the stream specified by the Java runtime and compiler. Consequently, the order in which the lambda expression `e -> { parallelStorage.add(e); return e; }` adds elements to the `List` `parallelStorage` can vary every time the code is run. For deterministic and predictable results, ensure that lambda expression parameters in stream operations are not stateful.

**Note**: This example invokes the method [`synchronizedList`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedList-java.util.List-) so that the `List` `parallelStorage` is thread-safe. Remember that collections are not thread-safe. This means that multiple threads should not access a particular collection at the same time. Suppose that you do not invoke the method `synchronizedList` when creating `parallelStorage`:

    List<Integer> parallelStorage = new ArrayList<>();

The example behaves erratically because multiple threads access and modify `parallelStorage` without a mechanism like synchronization to schedule when a particular thread may access the `List` instance. Consequently, the example could print output similar to the following:

    Parallel stream:
    8 7 6 5 4 3 2 1
    null 3 5 4 7 8 1 2


<a name="sec_16_3"></a>
## 16.3. Questions and Exercises
******

Questions
---------

1.  A sequence of aggregate operations is known as a ___ .
2.  Each pipeline contains zero or more ___ operations.
3.  Each pipeline ends with a ___ operation.
4.  What kind of operation produces another stream as its output?
5.  Describe one way in which the `forEach` aggregate operation differs from the enhanced `for` statement or iterators.
6.  True or False: A stream is similar to a collection in that it is a data structure that stores elements.
7.  Identify the intermediate and terminal operations in this code:
    
    double average = roster
        .stream()
        .filter(p -> p.getGender() == Person.Sex.MALE)
        .mapToInt(Person::getAge)
        .average()
        .getAsDouble();
    
8.  The code `p -> p.getGender() == Person.Sex.MALE` is an example of what?
9.  The code `Person::getAge` is an example of what?
10.  Terminal operations that combine the contents of a stream and return one value are known as what?
11.  Name one important difference between the `Stream.reduce` method and the `Stream.collect` method.
12.  If you wanted to process a stream of names, extract the male names, and store them in a new `List`, would `Stream.reduce` or `Stream.collect` be the most appropriate operation to use?
13.  True or False: Aggregate operations make it possible to implement parallelism with non-thread-safe collections.
14.  Streams are always serial unless otherwise specified. How do you request that a stream be processed in parallel?

Exercises
---------

1.  Write the following enhanced `for` statement as a pipeline with lambda expressions. Hint: Use the `filter` intermediate operation and the `forEach` terminal operation.  
    
    for (Person p : roster) {
        if (p.getGender() == Person.Sex.MALE) {
            System.out.println(p.getName());
        }
    }
    
2.  Convert the following code into a new implementation that uses lambda expressions and aggregate operations instead of nested `for` loops. Hint: Make a pipeline that invokes the `filter`, `sorted`, and `collect` operations, in that order.
    
    ```java
    List<Album> favs = new ArrayList<>();
        for (Album a : albums) {
            boolean hasFavorite = false;
            for (Track t : a.tracks) {
                if (t.rating >= 4) {
                    hasFavorite = true;
                    break;
                }
            }
            if (hasFavorite)
                favs.add(a);
        }
        Collections.sort(favs, new Comparator<Album>() {
                                   public int compare(Album a1, Album a2) {
                                       return a1.name.compareTo(a2.name);
                                   }});
    ```
    

[Check your answers.](answers.html)



Questions
---------

1.  Q: A sequence of aggregate operations is known as a ___ .  
    A: Pipeline  
      
    
2.  Q: Each pipeline contains zero or more ___ operations.  
    A: Intermediate  
      
    
3.  Q: Each pipeline ends with a ___ operation.  
    A: Terminal  
      
    
4.  Q: What kind of operation produces another stream as its output?  
    A: Intermediate  
      
    
5.  Q: Describe one way in which the `forEach` aggregate operation differs from the enhanced `for` statement or iterators.  
    A: The `forEach` aggregate operation lets the system decide "how" the iteration takes place. Using aggregate operations lets you focus on "what" instead of "how."  
      
    
6.  Q: True or False: A stream is similar to a collection in that it is a data structure that stores elements.  
    A: False. Unlike a collection, a stream is not a data structure. It instead carries values from a source through a pipeline.  
      
    
7.  Q: Identify the intermediate and terminal operations in this code:
    
    double average = roster
        .stream()
        .filter(p -> p.getGender() == Person.Sex.MALE)
        .mapToInt(Person::getAge)
        .average()
        .getAsDouble();
    
      
    A: Intermediate: `filter`, `mapToInt`  
    Terminal: `average`  
    The terminal operation `average` returns an `OptionalDouble`. The `getAsDouble` method is then invoked on that returned object. It is always a good idea to consult the [API Specification](https://docs.oracle.com/javase/8/docs/api/index.html) for information about whether an operation is intermediate or terminal.  
      
    
8.  Q: The code `p -> p.getGender() == Person.Sex.MALE` is an example of what?  
    A: A lambda expression.  
      
    
9.  Q: The code `Person::getAge` is an example of what?  
    A: A method reference.  
      
    
10.  Q: Terminal operations that combine the contents of a stream and return one value are known as what?  
    A: Reduction operations.  
      
    
11.  Q: Name one important difference between the `Stream.reduce` method and the `Stream.collect` method.  
    A: `Stream.reduce` always creates a new value when it processes an element. `Stream.collect` modifies (or mutates) the existing value.  
      
    
12.  Q: If you wanted to process a stream of names, extract the male names, and store them in a new `List`, would `Stream.reduce` or `Stream.collect` be the most appropriate operation to use?  
    A: The collect operation is most appropriate for collecting into a `List`.  
      
    Example:
    
    List<String> namesOfMaleMembersCollect = roster
        .stream()
        .filter(p -> p.getGender() == Person.Sex.MALE)
        .map(p -> p.getName())
        .collect(Collectors.toList());
    
      
      
    
13.  Q: True or False: Aggregate operations make it possible to implement parallelism with non-thread-safe collections.  
    A: True, provided that you do not modify (mutate) the underlying collection while you are operating on it.  
      
    
14.  Q: Streams are always serial unless otherwise specified. How do you request that a stream be processed in parallel?  
    A: Obtain the parallel stream by invoking `parallelStream()` instead of `stream()`.  
      
    

Exercises
---------

1.  Exercise: Write the following enhanced `for` statement as a pipeline with lambda expressions. Hint: Use the `filter` intermediate operation and the `forEach` terminal operation.  
    
    for (Person p : roster) {
        if (p.getGender() == Person.Sex.MALE) {
            System.out.println(p.getName());
        }
    }
    
      
    Answer:
    
    roster
        .stream()
        .filter(e -> e.getGender() == Person.Sex.MALE)
        .forEach(e -> System.out.println(e.getName());
    
2.  Convert the following code into a new implementation that uses lambda expressions and aggregate operations instead of nested `for` loops. Hint: Make a pipeline that invokes the `filter`, `sorted`, and `collect` operations, in that order.
    
    List<Album> favs = new ArrayList<>();
    for (Album a : albums) {
        boolean hasFavorite = false;
        for (Track t : a.tracks) {
            if (t.rating >= 4) {
                hasFavorite = true;
                break;
            }
        }
        if (hasFavorite)
            favs.add(a);
    }
    Collections.sort(favs, new Comparator<Album>() {
                               public int compare(Album a1, Album a2) {
                                   return a1.name.compareTo(a2.name);
                               }});
    
      
    Answer:
    
    List<Album> sortedFavs =
      albums.stream()
            .filter(a -> a.tracks.anyMatch(t -> (t.rating >= 4)))
            .sorted(Comparator.comparing(a -> a.name))
            .collect(Collectors.toList());
    
      
    Here we have used the stream operations to simplify each of the three major steps -- identification of whether any track in an album has a rating of at least 4 (`anyMatch`), the sorting, and the collection of albums matching our criteria into a `List`. The `Comparator.comparing()` method takes a function that extracts a `Comparable` sort key, and returns a `Comparator` that compares on that key.  
      


<a name="sec_17"></a>
## 17. Implementations
******
https://docs.oracle.com/javase/tutorial/collections/implementations/index.html

17.1. [Set Implementations]
17.2. [List Implementations]
17.3. [Map Implementations]
17.4. [Queue Implementations]
17.5. [Deque Implementations]
17.6. [Wrapper Implementations]
17.7. [Convenience Implementations]
17.8. [Summary of Implementations]
17.9. [Questions and Exercises]

Implementations are the data objects used to store collections, which implement the interfaces described in [the Interfaces section](../interfaces/index.html). This lesson describes the following kinds of implementations:

*   **General-purpose implementations** are the most commonly used implementations, designed for everyday use. They are summarized in the table titled General-purpose-implementations.
*   **Special-purpose implementations** are designed for use in special situations and display nonstandard performance characteristics, usage restrictions, or behavior.
*   **Concurrent implementations** are designed to support high concurrency, typically at the expense of single-threaded performance. These implementations are part of the `java.util.concurrent` package.
*   **Wrapper implementations** are used in combination with other types of implementations, often the general-purpose ones, to provide added or restricted functionality.
*   **Convenience implementations** are mini-implementations, typically made available via static factory methods, that provide convenient, efficient alternatives to general-purpose implementations for special collections (for example, singleton sets).
*   **Abstract implementations** are skeletal implementations that facilitate the construction of custom implementations ‚Äî described later in the [Custom Collection Implementations](../custom-implementations/index.html) section. An advanced topic, it's not particularly difficult, but relatively few people will need to do it.

The general-purpose implementations are summarized in the following table.

**General-purpose Implementations**

| Interfaces | Hash table | Resizable array | Tree | Linked list | Hashed Linked list |
|------------|------------|-----------------|------|-------------|--------------------|
| `Set` | `HashSet` | ¬† | `TreeSet` | ¬† | `LinkedHashSet`
| `List` | ¬† | `ArrayList` | ¬† | `LinkedList` | ¬†
| `Queue` | ¬† | ¬† | ¬† | ¬† | ¬†
| `Deque` | ¬† | `ArrayDeque` | ¬† | `LinkedList` | ¬†
| `Map` | `HashMap` | ¬† | `TreeMap` | ¬† | `LinkedHashMap`

As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the 
[`Set`](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html), 
[`List`](https://docs.oracle.com/javase/8/docs/api/java/util/List.html) , and 
[`Map`](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html) interfaces. In each case, one implementation ‚Äî 
[`HashSet`](https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html), 
[`ArrayList`](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html), and 
[`HashMap`](https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html) ‚Äî is clearly the one to use for most applications, all other things being equal. Note that the 
[`SortedSet`](https://docs.oracle.com/javase/8/docs/api/java/util/SortedSet.html) and the 
[`SortedMap`](https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html) interfaces do not have rows in the table. Each of those interfaces has one implementation 
[(`TreeSet`](https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html) and 
[`TreeMap`](https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html)) and is listed in the `Set` and the `Map` rows. There are two general-purpose `Queue` implementations ‚Äî 
[`LinkedList`](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html), which is also a `List` implementation, and 
[`PriorityQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html), which is omitted from the table. These two implementations provide very different semantics: `LinkedList` provides FIFO semantics, while `PriorityQueue` orders its elements according to their values.

Each of the general-purpose implementations provides all optional operations contained in its interface. All permit `null` elements, keys, and values. None are synchronized (thread-safe). All have _fail-fast iterators_, which detect illegal concurrent modification during iteration and fail quickly and cleanly rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. All are `Serializable` and all support a public `clone` method.

The fact that these implementations are unsynchronized represents a break with the past: The legacy collections `Vector` and `Hashtable` are synchronized. The present approach was taken because collections are frequently used when the synchronization is of no benefit. Such uses include single-threaded use, read-only use, and use as part of a larger data object that does its own synchronization. In general, it is good API design practice not to make users pay for a feature they don't use. Furthermore, unnecessary synchronization can result in deadlock under certain circumstances.

If you need thread-safe collections, the synchronization wrappers, described in the [Wrapper Implementations](wrapper.html) section, allow _any_ collection to be transformed into a synchronized collection. Thus, synchronization is optional for general-purpose implementations, whereas it is mandatory for legacy implementations. Moreover, the `java.util.concurrent` package provides concurrent implementations of the `BlockingQueue` interface, which extends `Queue`, and of the `ConcurrentMap` interface, which extends `Map`. These implementations offer much higher concurrency than mere synchronized implementations.

As a rule, you should be thinking about the interfaces, _not_ the implementations. That is why there are no programming examples in this section. For the most part, the choice of implementation affects only performance. The preferred style, as mentioned in the [Interfaces](../interfaces/index.html) section, is to choose an implementation when a `Collection` is created and to immediately assign the new collection to a variable of the corresponding interface type (or to pass the collection to a method expecting an argument of the interface type). In this way, the program does not become dependent on any added methods in a given implementation, leaving the programmer free to change implementations anytime that it is warranted by performance concerns or behavioral details.

The sections that follow briefly discuss the implementations. The performance of the implementations is described using words such as _constant-time_, _log_, _linear_, _n log(n)_, and _quadratic_ to refer to the asymptotic upper-bound on the time complexity of performing the operation. All this is quite a mouthful, and it doesn't matter much if you don't know what it means. If you're interested in knowing more, refer to any good algorithms textbook. One thing to keep in mind is that this sort of performance metric has its limitations. Sometimes, the nominally slower implementation may be faster. When in doubt, measure the performance!

<a name="sec17_1"></a>
## 17.1. Set Implementations
******

The `Set` implementations are grouped into general-purpose and special-purpose implementations.

General-Purpose Set Implementations
-----------------------------------

There are three general-purpose [`Set`](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html) implementations ‚Äî [`HashSet`](https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html), [`TreeSet`](https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html), and [`LinkedHashSet`](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashSet.html). Which of these three to use is generally straightforward. `HashSet` is much faster than `TreeSet` (constant-time versus log-time for most operations) but offers no ordering guarantees. If you need to use the operations in the `SortedSet` interface, or if value-ordered iteration is required, use `TreeSet`; otherwise, use `HashSet`. It's a fair bet that you'll end up using `HashSet` most of the time.

`LinkedHashSet` is in some sense intermediate between `HashSet` and `TreeSet`. Implemented as a hash table with a linked list running through it, it provides _insertion-ordered_ iteration (least recently inserted to most recently) and runs nearly as fast as `HashSet`. The `LinkedHashSet` implementation spares its clients from the unspecified, generally chaotic ordering provided by `HashSet` without incurring the increased cost associated with `TreeSet`.

One thing worth keeping in mind about `HashSet` is that iteration is linear in the sum of the number of entries and the number of buckets (the _capacity_). Thus, choosing an initial capacity that's too high can waste both space and time. On the other hand, choosing an initial capacity that's too low wastes time by copying the data structure each time it's forced to increase its capacity. If you don't specify an initial capacity, the default is 16. In the past, there was some advantage to choosing a prime number as the initial capacity. This is no longer true. Internally, the capacity is always rounded up to a power of two. The initial capacity is specified by using the `int` constructor. The following line of code allocates a `HashSet` whose initial capacity is 64.

    Set<String> s = new HashSet<String>(64);

The `HashSet` class has one other tuning parameter called the _load factor_. If you care a lot about the space consumption of your `HashSet`, read the `HashSet` documentation for more information. Otherwise, just accept the default; it's almost always the right thing to do.

If you accept the default load factor but want to specify an initial capacity, pick a number that's about twice the size to which you expect the set to grow. If your guess is way off, you may waste a bit of space, time, or both, but it's unlikely to be a big problem.

`LinkedHashSet` has the same tuning parameters as `HashSet`, but iteration time is not affected by capacity. `TreeSet` has no tuning parameters.

Special-Purpose Set Implementations
-----------------------------------

There are two special-purpose `Set` implementations ‚Äî [`EnumSet`](https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html) and [`CopyOnWriteArraySet`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CopyOnWriteArraySet.html).

`EnumSet` is a high-performance `Set` implementation for enum types. All of the members of an enum set must be of the same enum type. Internally, it is represented by a bit-vector, typically a single `long`. Enum sets support iteration over ranges of enum types. For example, given the enum declaration for the days of the week, you can iterate over the weekdays. The `EnumSet` class provides a static factory that makes it easy.

    for (Day d : EnumSet.range(Day.MONDAY, Day.FRIDAY))
        System.out.println(d);

Enum sets also provide a rich, typesafe replacement for traditional bit flags.

    EnumSet.of(Style.BOLD, Style.ITALIC)

`CopyOnWriteArraySet` is a `Set` implementation backed up by a copy-on-write array. All mutative operations, such as `add`, `set`, and `remove`, are implemented by making a new copy of the array; no locking is ever required. Even iteration may safely proceed concurrently with element insertion and deletion. Unlike most `Set` implementations, the `add`, `remove`, and `contains` methods require time proportional to the size of the set. This implementation is _only_ appropriate for sets that are rarely modified but frequently iterated. It is well suited to maintaining event-handler lists that must prevent duplicates.


<a name="sec17_2"></a>
## 17.2. List Implementations
******

`List` implementations are grouped into general-purpose and special-purpose implementations.

General-Purpose List Implementations
------------------------------------

There are two general-purpose [`List`](https://docs.oracle.com/javase/8/docs/api/java/util/List.html) implementations ‚Äî [`ArrayList`](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html) and [`LinkedList`](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html). Most of the time, you'll probably use `ArrayList`, which offers constant-time positional access and is just plain fast. It does not have to allocate a node object for each element in the `List`, and it can take advantage of `System.arraycopy` when it has to move multiple elements at the same time. Think of `ArrayList` as `Vector` without the synchronization overhead.

If you frequently add elements to the beginning of the `List` or iterate over the `List` to delete elements from its interior, you should consider using `LinkedList`. These operations require constant-time in a `LinkedList` and linear-time in an `ArrayList`. But you pay a big price in performance. Positional access requires linear-time in a `LinkedList` and constant-time in an `ArrayList`. Furthermore, the constant factor for `LinkedList` is much worse. If you think you want to use a `LinkedList`, measure the performance of your application with both `LinkedList` and `ArrayList` before making your choice; `ArrayList` is usually faster.

`ArrayList` has one tuning parameter ‚Äî the _initial capacity_, which refers to the number of elements the `ArrayList` can hold before it has to grow. `LinkedList` has no tuning parameters and seven optional operations, one of which is `clone`. The other six are `addFirst`, `getFirst`, `removeFirst`, `addLast`, `getLast`, and `removeLast`. `LinkedList` also implements the `Queue` interface.

Special-Purpose List Implementations
------------------------------------

[`CopyOnWriteArrayList`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CopyOnWriteArrayList.html) is a `List` implementation backed up by a copy-on-write array. This implementation is similar in nature to `CopyOnWriteArraySet`. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw `ConcurrentModificationException`. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.

If you need synchronization, a `Vector` will be slightly faster than an `ArrayList` synchronized with `Collections.synchronizedList`. But `Vector` has loads of legacy operations, so be careful to always manipulate the `Vector` with the `List` interface or else you won't be able to replace the implementation at a later time.

If your `List` is fixed in size ‚Äî that is, you'll never use `remove`, `add`, or any of the bulk operations other than `containsAll` ‚Äî you have a third option that's definitely worth considering. See `Arrays.asList` in the [Convenience Implementations](convenience.html) section for more information.


<a name="sec17_3"></a>
## 17.3. Map Implementations
******

`Map` implementations are grouped into general-purpose, special-purpose, and concurrent implementations.

General-Purpose Map Implementations
-----------------------------------

The three general-purpose [`Map`](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html) implementations are [`HashMap`](https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html), [`TreeMap`](https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html) and [`LinkedHashMap`](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html). If you need `SortedMap` operations or key-ordered `Collection`\-view iteration, use `TreeMap`; if you want maximum speed and don't care about iteration order, use `HashMap`; if you want near-`HashMap` performance and insertion-order iteration, use `LinkedHashMap`. In this respect, the situation for `Map` is analogous to `Set`. Likewise, everything else in the [Set Implementations](../implementations/set.html) section also applies to `Map` implementations.

`LinkedHashMap` provides two capabilities that are not available with `LinkedHashSet`. When you create a `LinkedHashMap`, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, `LinkedHashMap` provides the `removeEldestEntry` method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.

For example, this override will allow the map to grow up to as many as 100 entries and then it will delete the eldest entry each time a new entry is added, maintaining a steady state of 100 entries.

    private static final int MAX_ENTRIES = 100;

    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() > MAX_ENTRIES;
    }

Special-Purpose Map Implementations
-----------------------------------

There are three special-purpose Map implementations ‚Äî [`EnumMap`](https://docs.oracle.com/javase/8/docs/api/java/util/EnumMap.html), [`WeakHashMap`](https://docs.oracle.com/javase/8/docs/api/java/util/WeakHashMap.html) and [`IdentityHashMap`](https://docs.oracle.com/javase/8/docs/api/java/util/IdentityHashMap.html). `EnumMap`, which is internally implemented as an `array`, is a high-performance `Map` implementation for use with enum keys. This implementation combines the richness and safety of the `Map` interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an `EnumMap` in preference to an array.

`WeakHashMap` is an implementation of the `Map` interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the `WeakHashMap`. This class provides the easiest way to harness the power of weak references. It is useful for implementing "registry-like" data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.

`IdentityHashMap` is an identity-based `Map` implementation based on a hash table. This class is useful for topology-preserving object graph transformations, such as serialization or deep-copying. To perform such transformations, you need to maintain an identity-based "node table" that keeps track of which objects have already been seen. Identity-based maps are also used to maintain object-to-meta-information mappings in dynamic debuggers and similar systems. Finally, identity-based maps are useful in thwarting "spoof attacks" that are a result of intentionally perverse `equals` methods because `IdentityHashMap` never invokes the `equals` method on its keys. An added benefit of this implementation is that it is fast.

Concurrent Map Implementations
------------------------------

The [`java.util.concurrent`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html) package contains the [`ConcurrentMap`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html) interface, which extends `Map` with atomic `putIfAbsent`, `remove`, and `replace` methods, and the [`ConcurrentHashMap`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html) implementation of that interface.

`ConcurrentHashMap` is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for `Hashtable`: in addition to implementing `ConcurrentMap`, it supports all the legacy methods peculiar to `Hashtable`. Again, if you don't need the legacy operations, be careful to manipulate it with the `ConcurrentMap` interface.


<a name="sec17_4"></a>
## 17.4. Queue Implementations
******

The `Queue` implementations are grouped into general-purpose and concurrent implementations.

General-Purpose Queue Implementations
-------------------------------------

As mentioned in the previous section, `LinkedList` implements the `Queue` interface, providing first in, first out (FIFO) queue operations for `add`, `poll`, and so on.

The [`PriorityQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html) class is a priority queue based on the _heap_ data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit `Comparator`.

The queue retrieval operations ‚Äî `poll`, `remove`, `peek`, and `element` ‚Äî access the element at the head of the queue. The _head of the queue_ is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily.

`PriorityQueue` and its iterator implement all of the optional methods of the `Collection` and `Iterator` interfaces. The iterator provided in method `iterator` is not guaranteed to traverse the elements of the `PriorityQueue` in any particular order. For ordered traversal, consider using `Arrays.sort(pq.toArray())`.

Concurrent Queue Implementations
--------------------------------

The `java.util.concurrent` package contains a set of synchronized `Queue` interfaces and classes. [`BlockingQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html) extends `Queue` with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:

*   [`LinkedBlockingQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingQueue.html) ‚Äî an optionally bounded FIFO blocking queue backed by linked nodes
*   [`ArrayBlockingQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ArrayBlockingQueue.html) ‚Äî a bounded FIFO blocking queue backed by an array
*   [`PriorityBlockingQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/PriorityBlockingQueue.html) ‚Äî an unbounded blocking priority queue backed by a heap
*   [`DelayQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/DelayQueue.html) ‚Äî a time-based scheduling queue backed by a heap
*   [`SynchronousQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/SynchronousQueue.html) ‚Äî a simple rendezvous mechanism that uses the `BlockingQueue` interface

In JDK 7, [`TransferQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TransferQueue.html) is a specialized `BlockingQueue` in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. `TransferQueue` has a single implementation:

*   [`LinkedTransferQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedTransferQueue.html) ‚Äî an unbounded `TransferQueue` based on linked nodes


<a name="sec17_5"></a>
## 17.5. Deque Implementations
******

The `Deque` interface, pronounced as _"deck"_, represents a double-ended queue. The `Deque` interface can be implemented as various types of `Collections`. The `Deque` interface implementations are grouped into general-purpose and concurrent implementations.

General-Purpose Deque Implementations
-------------------------------------

The general-purpose implementations include `LinkedList` and `ArrayDeque` classes. The `Deque` interface supports insertion, removal and retrieval of elements at both ends. The [`ArrayDeque`](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html) class is the resizeable array implementation of the `Deque` interface, whereas the [`LinkedList`](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html) class is the list implementation.

The basic insertion, removal and retrieval operations in the `Deque` interface `addFirst`, `addLast`, `removeFirst`, `removeLast`, `getFirst` and `getLast`. The method `addFirst` adds an element at the head whereas `addLast` adds an element at the tail of the `Deque` instance.

The `LinkedList` implementation is more flexible than the `ArrayDeque` implementation. `LinkedList` implements all optional list operations. `null` elements are allowed in the `LinkedList` implementation but not in the `ArrayDeque` implementation.

In terms of efficiency, `ArrayDeque` is more efficient than the `LinkedList` for add and remove operation at both ends. The best operation in a `LinkedList` implementation is removing the current element during the iteration. `LinkedList` implementations are not ideal structures to iterate.

The `LinkedList` implementation consumes more memory than the `ArrayDeque` implementation. For the `ArrayDeque` instance traversal use any of the following:

### foreach

The `foreach` is fast and can be used for all kinds of lists.

ArrayDeque<String> aDeque = new ArrayDeque<String>();

    . . .
    for (String str : aDeque) {
        System.out.println(str);
    }

### Iterator

The `Iterator` can be used for the forward traversal on all kinds of lists for all kinds of data.

    ArrayDeque<String> aDeque = new ArrayDeque<String>();
    . . .
    for (Iterator<String> iter = aDeque.iterator(); iter.hasNext();  ) {
        System.out.println(iter.next());
    }

The `ArrayDeque` class is used in this tutorial to implement the `Deque` interface. The complete code of the example used in this tutorial is available in [`` `ArrayDequeSample` ``](../interfaces/examples/ArrayDequeSample.java). Both the `LinkedList` and `ArrayDeque` classes do not support concurrent access by multiple threads.

Concurrent Deque Implementations
--------------------------------

The [`LinkedBlockingDeque`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingDeque.html) class is the concurrent implementation of the `Deque` interface. If the deque is empty then methods such as `takeFirst` and `takeLast` wait until the element becomes available, and then retrieves and removes the same element.


<a name="sec17_6"></a>
## 17.6. Wrapper Implementations
******

Wrapper implementations delegate all their real work to a specified collection but add extra functionality on top of what this collection offers. For design pattern fans, this is an example of the _decorator_ pattern. Although it may seem a bit exotic, it's really pretty straightforward.

These implementations are anonymous; rather than providing a public class, the library provides a static factory method. All these implementations are found in the [`Collections`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html) class, which consists solely of static methods.

Synchronization Wrappers
------------------------

The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces ‚Äî [`Collection`](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html), [`Set`](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html), [`List`](https://docs.oracle.com/javase/8/docs/api/java/util/List.html), [`Map`](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html), [`SortedSet`](https://docs.oracle.com/javase/8/docs/api/java/util/SortedSet.html), and [`SortedMap`](https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html) ‚Äî has one static factory method.

    public static <T> Collection<T> synchronizedCollection(Collection<T> c);
    public static <T> Set<T> synchronizedSet(Set<T> s);
    public static <T> List<T> synchronizedList(List<T> list);
    public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m);
    public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s);
    public static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m);

Each of these methods returns a synchronized (thread-safe) `Collection` backed up by the specified collection. To guarantee serial access, _all_ access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick.

    List<Type> list = Collections.synchronizedList(new ArrayList<Type>());

A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a [`Vector`](https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html).

In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection.

    Collection<Type> c = Collections.synchronizedCollection(myCollection);
    synchronized(c) {
        for (Type e : c)
            foo(e);
    }

If an explicit iterator is used, the `iterator` method must be called from within the `synchronized` block. Failure to follow this advice may result in nondeterministic behavior. The idiom for iterating over a `Collection` view of a synchronized `Map` is similar. It is imperative that the user synchronize on the synchronized `Map` when iterating over any of its `Collection` views rather than synchronizing on the `Collection` view itself, as shown in the following example.

    Map<KeyType, ValType> m = Collections.synchronizedMap(new HashMap<KeyType, ValType>());
        ...
    Set<KeyType> s = m.keySet();
        ...
    // Synchronizing on m, not s!
    synchronized(m) {
        while (KeyType k : s)
            foo(k);
    }

One minor downside of using wrapper implementations is that you do not have the ability to execute any _noninterface_ operations of a wrapped implementation. So, for instance, in the preceding `List` example, you cannot call `ArrayList`'s [`ensureCapacity`](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ensureCapacity-int-) operation on the wrapped `ArrayList`.

Unmodifiable Wrappers
---------------------

Unlike synchronization wrappers, which add functionality to the wrapped collection, the unmodifiable wrappers take functionality away. In particular, they take away the ability to modify the collection by intercepting all the operations that would modify the collection and throwing an `UnsupportedOperationException`. Unmodifiable wrappers have two main uses, as follows:

*   To make a collection immutable once it has been built. In this case, it's good practice not to maintain a reference to the backing collection. This absolutely guarantees immutability.
*   To allow certain clients read-only access to your data structures. You keep a reference to the backing collection but hand out a reference to the wrapper. In this way, clients can look but not modify, while you maintain full access.

Like synchronization wrappers, each of the six core `Collection` interfaces has one static factory method.

    public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c);
    public static <T> Set<T> unmodifiableSet(Set<? extends T> s);
    public static <T> List<T> unmodifiableList(List<? extends T> list);
    public static <K,V> Map<K, V> unmodifiableMap(Map<? extends K, ? extends V> m);
    public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<? extends T> s);
    public static <K,V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, ? extends V> m);

Checked Interface Wrappers
--------------------------

The `Collections.checked` _interface_ wrappers are provided for use with generic collections. These implementations return a _dynamically_ type-safe view of the specified collection, which throws a `ClassCastException` if a client attempts to add an element of the wrong type. The generics mechanism in the language provides compile-time (static) type-checking, but it is possible to defeat this mechanism. Dynamically type-safe views eliminate this possibility entirely.


<a name="sec17_7"></a>
## 17.7. Convenience Implementations
******

This section describes several mini-implementations that can be more convenient and more efficient than general-purpose implementations when you don't need their full power. All the implementations in this section are made available via static factory methods rather than `public` classes.

List View of an Array
---------------------

The [`Arrays.asList`](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-) method returns a `List` view of its array argument. Changes to the `List` write through to the array and vice versa. The size of the collection is that of the array and cannot be changed. If the `add` or the `remove` method is called on the `List`, an `UnsupportedOperationException` will result.

The normal use of this implementation is as a bridge between array-based and collection-based APIs. It allows you to pass an array to a method expecting a `Collection` or a `List`. However, this implementation also has another use. If you need a fixed-size `List`, it's more efficient than any general-purpose `List` implementation. This is the idiom.

    List<String> list = Arrays.asList(new String[size]);

Note that a reference to the backing array is not retained.

Immutable Multiple-Copy List
----------------------------

Occasionally you'll need an immutable `List` consisting of multiple copies of the same element. The [`Collections.nCopies`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#nCopies-int-T-) method returns such a list. This implementation has two main uses. The first is to initialize a newly created `List`; for example, suppose you want an `ArrayList` initially consisting of 1,000 `null` elements. The following incantation does the trick.

List<Type> list = new ArrayList<Type>(Collections.nCopies(1000, (Type)null));

Of course, the initial value of each element need not be `null`. The second main use is to grow an existing `List`. For example, suppose you want to add 69 copies of the string `"fruit bat"` to the end of a `List<String>`. It's not clear why you'd want to do such a thing, but let's just suppose you did. The following is how you'd do it.

    lovablePets.addAll(Collections.nCopies(69, "fruit bat"));

By using the form of `addAll` that takes both an index and a `Collection`, you can add the new elements to the middle of a `List` instead of to the end of it.

Immutable Singleton Set
-----------------------

Sometimes you'll need an immutable _singleton_ `Set`, which consists of a single, specified element. The [`Collections.singleton`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singleton-T-) method returns such a `Set`. One use of this implementation is to remove all occurrences of a specified element from a `Collection`.

    c.removeAll(Collections.singleton(e));

A related idiom removes all elements that map to a specified value from a `Map`. For example, suppose you have a `Map` ‚Äî `job` ‚Äî that maps people to their line of work and suppose you want to eliminate all the lawyers. The following one-liner will do the deed.

    job.values().removeAll(Collections.singleton(LAWYER));

One more use of this implementation is to provide a single input value to a method that is written to accept a collection of values.

Empty Set, List, and Map Constants
----------------------------------

The [`Collections`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html) class provides methods to return the empty `Set`, `List`, and `Map` ‚Äî [`emptySet`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#emptySet--), [`emptyList`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#emptyList--), and [`emptyMap`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#emptyMap--). The main use of these constants is as input to methods that take a `Collection` of values when you don't want to provide any values at all, as in this example.

    tourist.declarePurchases(Collections.emptySet());


<a name="sec17_8"></a>
## 17.8. Summary of Implementations
******

Implementations are the data objects used to store collections, which implement the interfaces described in the [Interfaces lesson](../interfaces/index.html).

The Java Collections Framework provides several general-purpose implementations of the core interfaces:

*   For the `Set` interface, `HashSet` is the most commonly used implementation.
*   For the `List` interface, `ArrayList` is the most commonly used implementation.
*   For the `Map` interface, `HashMap` is the most commonly used implementation.
*   For the `Queue` interface, `LinkedList` is the most commonly used implementation.
*   For the `Deque` interface, `ArrayDeque` is the most commonly used implementation.

Each of the general-purpose implementations provides all optional operations contained in its interface.

The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.

The `java.util.concurrent` package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.

The `Collections` class (as opposed to the `Collection` interface), provides static methods that operate on or return collections, which are known as Wrapper implementations.

Finally, there are several Convenience implementations, which can be more efficient than general-purpose implementations when you don't need their full power. The Convenience implementations are made available through static factory methods.




<a name="sec17_9"></a>
## 17.9. Questions and Exercises
******
https://docs.oracle.com/javase/tutorial/collections/implementations/QandE/answers.html 

Questions
---------

1.  You plan to write a program that uses several basic collection interfaces: `Set`, `List`, `Queue`, and `Map`. You're not sure which implementations will work best, so you decide to use general-purpose implementations until you get a better idea how your program will work in the real world. Which implementations are these?
2.  If you need a `Set` implementation that provides value-ordered iteration, which class should you use?
3.  Which class do you use to access wrapper implementations?

Exercises
---------

1.  Write a program that reads a text file, specified by the first command line argument, into a `List`. The program should then print random lines from the file, the number of lines printed to be specified by the second command line argument. Write the program so that a correctly-sized collection is allocated all at once, instead of being gradually expanded as the file is read in. Hint: To determine the number of lines in the file, use [`java.io.File.length`](https://docs.oracle.com/javase/8/docs/api/java/io/File.html#length--) to obtain the size of the file, then divide by an assumed size of an average line.

[Check your answers.](answers.html)


Questions
---------

1.  Question: You plan to write a program that uses several basic collection interfaces: `Set`, `List`, `Queue`, and `Map`. You're not sure which implementations will work best, so you decide to use general-purpose implementations until you get a better idea how your program will work in the real world. Which implementations are these?  
    Answer:  
    `Set`: `HashSet`  
    `List`: `ArrayList`  
    `Queue`: `LinkedList`  
    `Map`: `HashMap`
2.  Question: If you need a `Set` implementation that provides value-ordered iteration, which class should you use?  
    Answer:  
    `TreeSet` guarantees that the sorted set is in ascending element order, sorted according to the natural order of the elements or by the `Comparator` provided.
3.  Question: Which class do you use to access wrapper implementations?  
    Answer:  
    You use the `Collections` class, which provides static methods that operate on or return collections.

Exercises
---------

1.  Exercise: Write a program that reads a text file, specified by the first command line argument, into a `List`. The program should then print random lines from the file, the number of lines printed to be specified by the second command line argument. Write the program so that a correctly-sized collection is allocated all at once, instead of being gradually expanded as the file is read in. Hint: To determine the number of lines in the file, use [`java.io.File.length`](https://docs.oracle.com/javase/8/docs/api/java/io/File.html#length--) to obtain the size of the file, then divide by an assumed size of an average line.  
    Answer:  
    Since we are accessing the `List` randomly, we will use `ArrayList`. We estimate the number of lines by taking the file size and dividing by 50. We then double that figure, since it is more efficient to overestimate than to underestimate.
    
    ```java
    import java.util.*;
        import java.io.*;
        
        public class FileList {
            public static void main(String[] args) {
                final int assumedLineLength = 50;
                File file = new File(args[0]);
                List<String> fileList = 
                    new ArrayList<String>((int)(file.length() / assumedLineLength) * 2);
                BufferedReader reader = null;
                int lineCount = 0;
                try {
                    reader = new BufferedReader(new FileReader(file));
                    for (String line = reader.readLine(); line != null;
                            line = reader.readLine()) {
                        fileList.add(line);
                        lineCount++;
                    }
                } catch (IOException e) {
                    System.err.format("Could not read %s: %s%n", file, e);
                    System.exit(1);
                } finally {
                    if (reader != null) {
                        try {
                            reader.close();
                        } catch (IOException e) {}
                    }
                }
                int repeats = Integer.parseInt(args[1]);
                Random random = new Random();
                for (int i = 0; i < repeats; i++) {
                    System.out.format("%d: %s%n", i,
                            fileList.get(random.nextInt(lineCount - 1)));
                }
            }
        }
    ```
    
    This program actually spends most of its time reading in the file, so pre-allocating the `ArrayList` has little affect on its performance. Specifying an initial capacity in advance is more likely to be useful when your program repeatedly creates large `ArrayList` objects without intervening I/O.




<a name="sec_18"></a>
## 18. Algorithms
******
https://docs.oracle.com/javase/tutorial/collections/algorithms/index.html

The _polymorphic algorithms_ described here are pieces of reusable functionality provided by the Java platform. All of them come from the [`Collections`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html) class, and all take the form of static methods whose first argument is the collection on which the operation is to be performed. The great majority of the algorithms provided by the Java platform operate on [`List`](https://docs.oracle.com/javase/8/docs/api/java/util/List.html) instances, but a few of them operate on arbitrary [`Collection`](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html) instances. This section briefly describes the following algorithms:

*   [Sorting](#sorting)
*   [Shuffling](#shuffling)
*   [Routine Data Manipulation](#rdm)
*   [Searching](#searching)
*   [Composition](#composition)
*   [Finding Extreme Values](#fev)

Sorting
-------

The `sort` algorithm reorders a `List` so that its elements are in ascending order according to an ordering relationship. Two forms of the operation are provided. The simple form takes a `List` and sorts it according to its elements' _natural ordering_. If you're unfamiliar with the concept of natural ordering, read the [Object Ordering](../interfaces/order.html) section.

The `sort` operation uses a slightly optimized _merge sort_ algorithm that is fast and stable:

*   **Fast**: It is guaranteed to run in `n log(n)` time and runs substantially faster on nearly sorted lists. Empirical tests showed it to be as fast as a highly optimized quicksort. A quicksort is generally considered to be faster than a merge sort but isn't stable and doesn't guarantee `n log(n)` performance.
*   **Stable**: It doesn't reorder equal elements. This is important if you sort the same list repeatedly on different attributes. If a user of a mail program sorts the inbox by mailing date and then sorts it by sender, the user naturally expects that the now-contiguous list of messages from a given sender will (still) be sorted by mailing date. This is guaranteed only if the second sort was stable.

The following [`trivial program`](examples/Sort.java) prints out its arguments in lexicographic (alphabetical) order.

```java
import java.util.*;

public class Sort {
    public static void main(String[] args) {
        List<String> list = Arrays.asList(args);
        Collections.sort(list);
        System.out.println(list);
    }
}
```

Let's run the program.

    % java Sort i walk the line

The following output is produced.

    [i, line, the, walk]

The program was included only to show you that algorithms really are as easy to use as they appear to be.

The second form of `sort` takes a [`Comparator`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html) in addition to a `List` and sorts the elements with the `Comparator`. Suppose you want to print out the anagram groups from our earlier example in reverse order of size ‚Äî largest anagram group first. The example that follows shows you how to achieve this with the help of the second form of the `sort` method.

Recall that the anagram groups are stored as values in a `Map`, in the form of `List` instances. The revised printing code iterates through the `Map`'s values view, putting every `List` that passes the minimum-size test into a `List` of `List`s. Then the code sorts this `List`, using a `Comparator` that expects `List` instances, and implements reverse size-ordering. Finally, the code iterates through the sorted `List`, printing its elements (the anagram groups). The following code replaces the printing code at the end of the `main` method in the `Anagrams` example.

```java
// Make a List of all anagram groups above size threshold.
List<List<String>> winners = new ArrayList<List<String>>();
for (List<String> l : m.values())
    if (l.size() >= minGroupSize)
        winners.add(l);

// Sort anagram groups according to size
Collections.sort(winners, new Comparator<List<String>>() {
    public int compare(List<String> o1, List<String> o2) {
        return o2.size() - o1.size();
    }});

// Print anagram groups.
for (List<String> l : winners)
    System.out.println(l.size() + ": " + l);
```

Running [`the program`](examples/Anagrams2.java) on the [`same dictionary`](../interfaces/examples/dictionary.txt) as in [The Map Interface](../interfaces/map.html) section, with the same minimum anagram group size (eight), produces the following output.

    12: [apers, apres, asper, pares, parse, pears, prase,
           presa, rapes, reaps, spare, spear]
    11: [alerts, alters, artels, estral, laster, ratels,
           salter, slater, staler, stelar, talers]
    10: [least, setal, slate, stale, steal, stela, taels,
           tales, teals, tesla]
    9: [estrin, inerts, insert, inters, niters, nitres,
           sinter, triens, trines]
    9: [capers, crapes, escarp, pacers, parsec, recaps,
           scrape, secpar, spacer]
    9: [palest, palets, pastel, petals, plates, pleats,
           septal, staple, tepals]
    9: [anestri, antsier, nastier, ratines, retains, retinas,
           retsina, stainer, stearin]
    8: [lapse, leaps, pales, peals, pleas, salep, sepal, spale]
    8: [aspers, parses, passer, prases, repass, spares,
           sparse, spears]
    8: [enters, nester, renest, rentes, resent, tenser,
           ternes,ÔøΩÔøΩtreens]
    8: [arles, earls, lares, laser, lears, rales, reals, seral]
    8: [earings, erasing, gainers, reagins, regains, reginas,
           searing, seringa]
    8: [peris, piers, pries, prise, ripes, speir, spier, spire]
    8: [ates, east, eats, etas, sate, seat, seta, teas]
    8: [carets, cartes, caster, caters, crates, reacts,
           recast,ÔøΩÔøΩtraces]

Shuffling
---------

The `shuffle` algorithm does the opposite of what `sort` does, destroying any trace of order that may have been present in a `List`. That is, this algorithm reorders the `List` based on input from a source of randomness such that all possible permutations occur with equal likelihood, assuming a fair source of randomness. This algorithm is useful in implementing games of chance. For example, it could be used to shuffle a `List` of `Card` objects representing a deck. Also, it's useful for generating test cases.

This operation has two forms: one takes a `List` and uses a default source of randomness, and the other requires the caller to provide a [Random](https://docs.oracle.com/javase/8/docs/api/java/util/Random.html) object to use as a source of randomness. The code for this algorithm is used as an example in the [`List` section](../interfaces/list.html#shuffle).

Routine Data Manipulation
-------------------------

The `Collections` class provides five algorithms for doing routine data manipulation on `List` objects, all of which are pretty straightforward:

*   `reverse` ‚Äî reverses the order of the elements in a `List`.
*   `fill` ‚Äî overwrites every element in a `List` with the specified value. This operation is useful for reinitializing a `List`.
*   `copy` ‚Äî takes two arguments, a destination `List` and a source `List`, and copies the elements of the source into the destination, overwriting its contents. The destination `List` must be at least as long as the source. If it is longer, the remaining elements in the destination `List` are unaffected.
*   `swap` ‚Äî swaps the elements at the specified positions in a `List`.
*   `addAll` ‚Äî adds all the specified elements to a `Collection`. The elements to be added may be specified individually or as an array.

Searching
---------

The `binarySearch` algorithm searches for a specified element in a sorted `List`. This algorithm has two forms. The first takes a `List` and an element to search for (the "search key"). This form assumes that the `List` is sorted in ascending order according to the natural ordering of its elements. The second form takes a `Comparator` in addition to the `List` and the search key, and assumes that the `List` is sorted into ascending order according to the specified `Comparator`. The `sort` algorithm can be used to sort the `List` prior to calling `binarySearch`.

The return value is the same for both forms. If the `List` contains the search key, its index is returned. If not, the return value is `(-(insertion point) - 1)`, where the insertion point is the point at which the value would be inserted into the `List`, or the index of the first element greater than the value or `list.size()` if all elements in the `List` are less than the specified value. This admittedly ugly formula guarantees that the return value will be `>= 0` if and only if the search key is found. It's basically a hack to combine a boolean `(found)` and an integer `(index)` into a single `int` return value.

The following idiom, usable with both forms of the `binarySearch` operation, looks for the specified search key and inserts it at the appropriate position if it's not already present.

int pos = Collections.binarySearch(list, key);
if (pos < 0)
   l.add(-pos-1, key);

Composition
-----------

The frequency and disjoint algorithms test some aspect of the composition of one or more `Collections`:

*   `frequency` ‚Äî counts the number of times the specified element occurs in the specified collection
*   `disjoint` ‚Äî determines whether two `Collections` are disjoint; that is, whether they contain no elements in common

Finding Extreme Values
----------------------

The `min` and the `max` algorithms return, respectively, the minimum and maximum element contained in a specified `Collection`. Both of these operations come in two forms. The simple form takes only a `Collection` and returns the minimum (or maximum) element according to the elements' natural ordering. The second form takes a `Comparator` in addition to the `Collection` and returns the minimum (or maximum) element according to the specified `Comparator`.



<a name="sec_19"></a>
## 19 Custom Implementations
******
https://docs.oracle.com/javase/tutorial/collections/custom-implementations/index.html

Many programmers will never need to implement their own `Collection`s classes. You can go pretty far using the implementations described in the preceding sections of this chapter. However, someday you might want to write your own implementation. It is fairly easy to do this with the aid of the abstract implementations provided by the Java platform. Before we discuss _how_ to write an implementation, let's discuss why you might want to write one.

Reasons to Write an Implementation
----------------------------------

The following list illustrates the sort of custom `Collection`s you might want to implement. It is not intended to be exhaustive:

*   **Persistent**: All of the built-in `Collection` implementations reside in main memory and vanish when the program exits. If you want a collection that will still be present the next time the program starts, you can implement it by building a veneer over an external database. Such a collection might be concurrently accessible by multiple programs.
*   **Application-specific**: This is a very broad category. One example is an unmodifiable `Map` containing real-time telemetry data. The keys could represent locations, and the values could be read from sensors at these locations in response to the `get` operation.
*   **High-performance, special-purpose**: Many data structures take advantage of restricted usage to offer better performance than is possible with general-purpose implementations. For instance, consider a `List` containing long runs of identical element values. Such lists, which occur frequently in text processing, can be _run-length encoded_ ‚Äî runs can be represented as a single object containing the repeated element and the number of consecutive repetitions. This example is interesting because it trades off two aspects of performance: It requires less space but more time than an `ArrayList`.
*   **High-performance, general-purpose**: The Java Collections Framework's designers tried to provide the best general-purpose implementations for each interface, but many, many data structures could have been used, and new ones are invented every day. Maybe you can come up with something faster!
*   **Enhanced functionality**: Suppose you need an efficient bag implementation (also known as a _multiset_): a `Collection` that offers constant-time containment checks while allowing duplicate elements. It's reasonably straightforward to implement such a collection atop a `HashMap`.
*   **Convenience**: You may want additional implementations that offer conveniences beyond those offered by the Java platform. For instance, you may frequently need `List` instances representing a contiguous range of `Integer`s.
*   **Adapter**: Suppose you are using a legacy API that has its own ad hoc collections' API. You can write an adapter implementation that permits these collections to operate in the Java Collections Framework. An _adapter implementation_ is a thin veneer that wraps objects of one type and makes them behave like objects of another type by translating operations on the latter type into operations on the former.

How to Write a Custom Implementation
------------------------------------

Writing a custom implementation is surprisingly easy. The Java Collections Framework provides abstract implementations designed expressly to facilitate custom implementations. We'll start with the following example of an implementation of [`Arrays.asList`](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-).

```java
public static <T> List<T> asList(T[] a) {
    return new MyArrayList<T>(a);
}

private static class MyArrayList<T> extends AbstractList<T> {

    private final T[] a;

    MyArrayList(T[] array) {
        a = array;
    }

    public T get(int index) {
        return a[index];
    }

    public T set(int index, T element) {
        T oldValue = a[index];
        a[index] = element;
        return oldValue;
    }

    public int size() {
        return a.length;
    }
}
```

Believe it or not, this is very close to the implementation that is contained in `java.util.Arrays`. It's that simple! You provide a constructor and the `get`, `set`, and `size` methods, and `AbstractList` does all the rest. You get the `ListIterator`, bulk operations, search operations, hash code computation, comparison, and string representation for free.

Suppose you want to make the implementation a bit faster. The API documentation for abstract implementations describes precisely how each method is implemented, so you'll know which methods to override to get the performance you want. The preceding implementation's performance is fine, but it can be improved a bit. In particular, the `toArray` method iterates over the `List`, copying one element at a time. Given the internal representation, it's a lot faster and more sensible just to clone the array.

```java
public Object[] toArray() {
    return (Object[]) a.clone();
}
```

With the addition of this override and a few more like it, this implementation is exactly the one found in `java.util.Arrays`. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.

The following list summarizes the abstract implementations:

*   [`AbstractCollection`](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html) ‚Äî a `Collection` that is neither a `Set` nor a `List`. At a minimum, you must provide the `iterator` and the `size` methods.
*   [`AbstractSet`](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractSet.html) ‚Äî a `Set`; use is identical to `AbstractCollection`.
*   [`AbstractList`](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractList.html) ‚Äî a `List` backed up by a random-access data store, such as an array. At a minimum, you must provide the `positional access` methods (`get` and, optionally, `set`, `remove`, and `add`) and the `size` method. The abstract class takes care of `listIterator` (and `iterator`).
*   [`AbstractSequentialList`](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractSequentialList.html) ‚Äî a `List` backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the `listIterator` and `size` methods. The abstract class takes care of the positional access methods. (This is the opposite of `AbstractList`.)
*   [`AbstractQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractQueue.html) ‚Äî at a minimum, you must provide the `offer`, `peek`, `poll`, and `size` methods and an `iterator` supporting `remove`.
*   [`AbstractMap`](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractMap.html) ‚Äî a `Map`. At a minimum you must provide the `entrySet` view. This is typically implemented with the `AbstractSet` class. If the `Map` is modifiable, you must also provide the `put` method.

The process of writing a custom implementation follows:

1.  Choose the appropriate abstract implementation class from the preceding list.
2.  Provide implementations for all the abstract methods of the class. If your custom collection is to be modifiable, you will have to override one or more of the concrete methods as well. The API documentation for the abstract implementation class will tell you which methods to override.
3.  Test and, if necessary, debug the implementation. You now have a working custom collection implementation.
4.  If you are concerned about performance, read the API documentation of the abstract implementation class for all the methods whose implementations you're inheriting. If any seem too slow, override them. If you override any methods, be sure to measure the performance of the method before and after the override. How much effort you put into tweaking performance should be a function of how much use the implementation will get and how critical to performance its use is. (Often this step is best omitted.)


<a name="sec_20"></a>
## 20. Interoperability
******
https://docs.oracle.com/javase/tutorial/collections/interoperability/index.html

*  [Compatibility](compatibility.html)
*  [API Design](api-design.html)

The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available.  
See [Java Language Changes](https://docs.oracle.com/pls/topic/lookup?ctx=en/java/javase&id=java_language_changes) for a summary of updated language features in Java SE 9 and subsequent releases.  
See [JDK Release Notes](https://www.oracle.com/technetwork/java/javase/jdk-relnotes-index-2162236.html) for information about new features, enhancements, and removed or deprecated options for all JDK releases.

Lesson: Interoperability
========================

In this section, you'll learn about the following two aspects of interoperability:

*   [Compatibility](compatibility.html): This subsection describes how collections can be made to work with older APIs that predate the addition of `Collection`s to the Java platform.
*   [API Design](api-design.html): This subsection describes how to design new APIs so that they will interoperate seamlessly with one another.


<a name="sec_20_1"></a>
## 20.1 Compatibility
******
https://docs.oracle.com/javase/tutorial/collections/interoperability/compatibility.html

The Java Collections Framework was designed to ensure complete interoperability between the core [collection interfaces](../interfaces/index.html) and the types that were used to represent collections in the early versions of the Java platform: 
[`Vector`](https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html), 
[`Hashtable`](https://docs.oracle.com/javase/8/docs/api/java/util/Hashtable.html), 
[array](../../java/nutsandbolts/arrays.html), and 
[`Enumeration`](https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html). In this section, you'll learn how to transform old collections to the Java Collections Framework collections and vice versa.

Upward Compatibility
--------------------

Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy.

Suppose the old API returns an array of objects and the new API requires a `Collection`. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a `List`. You use [`Arrays.asList`](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-) to pass an array to any method requiring a `Collection` or a `List`.

Foo[] result = oldMethod(arg);
newMethod(Arrays.asList(result));

If the old API returns a `Vector` or a `Hashtable`, you have no work to do at all because `Vector` was retrofitted to implement the `List` interface, and `Hashtable` was retrofitted to implement `Map`. Therefore, a `Vector` may be passed directly to any method calling for a `Collection` or a `List`.

Vector result = oldMethod(arg);
newMethod(result);

Similarly, a `Hashtable` may be passed directly to any method calling for a `Map`.

Hashtable result = oldMethod(arg);
newMethod(result);

Less frequently, an API may return an `Enumeration` that represents a collection of objects. The `Collections.list` method translates an `Enumeration` into a `Collection`.

Enumeration e = oldMethod(arg);
newMethod(Collections.list(e));

Backward Compatibility
----------------------

Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.

Suppose the new API returns a `Collection`, and the old API requires an array of `Object`. As you're probably aware, the `Collection` interface contains a `toArray` method designed expressly for this situation.

Collection c = newMethod();
oldMethod(c.toArray());

What if the old API requires an array of `String` (or another type) instead of an array of `Object`? You just use the other form of `toArray` ‚Äî the one that takes an array on input.

Collection c = newMethod();
oldMethod((String[]) c.toArray(new String[0]));

If the old API requires a `Vector`, the standard collection constructor comes in handy.

Collection c = newMethod();
oldMethod(new Vector(c));

The case where the old API requires a `Hashtable` is handled analogously.

Map m = newMethod();
oldMethod(new Hashtable(m));

Finally, what do you do if the old API requires an `Enumeration`? This case isn't common, but it does happen from time to time, and the [`Collections.enumeration`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-) method was provided to handle it. This is a static factory method that takes a `Collection` and returns an `Enumeration` over the elements of the `Collection`.

Collection c = newMethod();
oldMethod(Collections.enumeration(c));



<a name="sec_20_2"></a>
## 20.2 API Design
******
https://docs.oracle.com/javase/tutorial/collections/interoperability/api-design.html

In this short but important section, you'll learn a few simple guidelines that will allow your API to interoperate seamlessly with all other APIs that follow these guidelines. In essence, these rules define what it takes to be a good "citizen" in the world of collections.

Parameters
----------

If your API contains a method that requires a collection on input, it is of paramount importance that you declare the relevant parameter type to be one of the collection [interface](../interfaces/index.html) types. **Never** use an [implementation](../implementations/index.html) type because this defeats the purpose of an interface-based Collections Framework, which is to allow collections to be manipulated without regard to implementation details.

Further, you should always use the least-specific type that makes sense. For example, don't require a [`List`](../interfaces/list.html) or a [`Set`](../interfaces/set.html) if a [`Collection`](../interfaces/collection.html) would do. It's not that you should never require a `List` or a `Set` on input; it is correct to do so if a method depends on a property of one of these interfaces. For example, many of the algorithms provided by the Java platform require a `List` on input because they depend on the fact that lists are ordered. As a general rule, however, the best types to use on input are the most general: `Collection` and `Map`.

* * *

**Caution:**¬†Never define your own ad hoc `collection` class and require objects of this class on input. By doing this, you'd lose all the [benefits provided by the Java Collections Framework](../intro/index.html).

* * *

Return Values
-------------

You can afford to be much more flexible with return values than with input parameters. It's fine to return an object of any type that implements or extends one of the collection interfaces. This can be one of the interfaces or a special-purpose type that extends or implements one of these interfaces.

For example, one could imagine an image-processing package, called `ImageList`, that returned objects of a new class that implements `List`. In addition to the `List` operations, `ImageList` could support any application-specific operations that seemed desirable. For example, it might provide an `indexImage` operation that returned an image containing thumbnail images of each graphic in the `ImageList`. It's critical to note that even if the API furnishes `ImageList` instances on output, it should accept arbitrary `Collection` (or perhaps `List`) instances on input.

In one sense, return values should have the opposite behavior of input parameters: It's best to return the most specific applicable collection interface rather than the most general. For example, if you're sure that you'll always return a `SortedMap`, you should give the relevant method the return type of `SortedMap` rather than `Map`. `SortedMap` instances are more time-consuming to build than ordinary `Map` instances and are also more powerful. Given that your module has already invested the time to build a `SortedMap`, it makes good sense to give the user access to its increased power. Furthermore, the user will be able to pass the returned object to methods that demand a `SortedMap`, as well as those that accept any `Map`.

Legacy APIs
-----------

There are currently plenty of APIs out there that define their own ad hoc collection types. While this is unfortunate, it's a fact of life, given that there was no Collections Framework in the first two major releases of the Java platform. Suppose you own one of these APIs; here's what you can do about it.

If possible, retrofit your legacy collection type to implement one of the standard collection interfaces. Then all the collections you return will interoperate smoothly with other collection-based APIs. If this is impossible (for example, because one or more of the preexisting type signatures conflict with the standard collection interfaces), define an _adapter class_ that wraps one of your legacy collections objects, allowing it to function as a standard collection. (The `Adapter` class is an example of a [_custom implementation_](../custom-implementations/index.html).)

Retrofit your API with new calls that follow the input guidelines to accept objects of a standard collection interface, if possible. Such calls can coexist with the calls that take the legacy collection type. If this is impossible, provide a constructor or static factory for your legacy type that takes an object of one of the standard interfaces and returns a legacy collection containing the same elements (or mappings). Either of these approaches will allow users to pass arbitrary collections into your API.

