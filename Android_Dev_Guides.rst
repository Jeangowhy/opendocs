#::

   #!/usr/bin/env bash
   
   #pandoc -r html /pl/out.html -t rst --wrap=preserve --columns=120 --list-table=false; exit

   url=https://developer.android.google.cn/topic/architecture/intro?hl=en
   curl "$url" | sed -n '/devsite-page-title/,/Last updated/p' | pandoc -r html -t rst --list-table=true > /pl/out.html ; exit
   url=https://devdoc.net/android/Android-r15/guide/topics/fundamentals/activities.html
   curl "$url" | sed -n '/h1/,/Go to top/p' | pandoc -r html -t rst --list-table=true > /pl/out.html ; exit

   while read it; do
      url="$it?hl=en"
      echo "::$url" > /pl/out.html
      curl "$url" | sed -n '/devsite-article-body/,/Last updated/p' | pandoc -r html -t rst --columns=80 --list-table=true >> /pl/out.html
      exit
   done <<EOF
   https://source.android.google.cn/docs/setup
   EOF
   exit

/TOC üíõ Android Developer
========================

.. container:: devsite-header-upper-tabs

   `Essentials <https://developer.android.google.cn/get-started>`__

   .. container:: 

      -  Modern Android
      -  Quickly bring your app to life with less code, using a modern
         declarative approach to UI, and the simplicity of Kotlin.
      -  `Explore Modern Android <https://developer.android.google.cn/modern-android-development>`__
      -  `Adopt Compose for teams <https://developer.android.google.cn/jetpack/compose/adopt>`__

         .. container:: 

            -  Get started
            -  Start by creating your first app. Go deeper with our training
               courses or explore app development on your own.
            -  `Hello world <https://developer.android.google.cn/get-started/overview>`__
            -  `Training courses <https://developer.android.google.cn/courses>`__
            -  `Tutorials <https://developer.android.google.cn/get-started/codelabs>`__
            -  `Kotlin for Android <https://developer.android.google.cn/kotlin>`__
            -  `Monetization with Play ‚ÜóÔ∏è <https://play.google.com/console/about/guides/monetize/>`__

         .. container:: 

            -  Extend by device
            -  Build apps that give your users seamless experiences from phones to
               tablets, watches, and more.
            -  `Large screens (e.g., tablets) <https://developer.android.google.cn/large-screens>`__
            -  `Wear OS <https://developer.android.google.cn/wear>`__
            -  `Android for Cars <https://developer.android.google.cn/cars>`__
            -  `Android TV <https://developer.android.google.cn/tv>`__
            -  `ChromeOS <https://developer.android.google.cn/chrome-os>`__
            -  `Cross-device SDK <https://developer.android.google.cn/multi-device-development>`__

         .. container:: 

            -  Build by category
            -  Learn to build for your use case by following Google's prescriptive
               and opinionated guidance.
            -  `Games <https://developer.android.google.cn/games>`__
            -  `Media apps <https://developer.android.google.cn/media>`__
            -  `Health & Fitness <https://developer.android.google.cn/health-and-fitness>`__
            -  `Enterprise apps <https://developer.android.google.cn/work/overview>`__

         .. container:: 

            -  Get the latest
            -  Stay in touch with the latest releases throughout the year, join
               our preview programs, and give us your feedback.
            -  `Platform releases <https://developer.android.google.cn/about/versions>`__
            -  `Android Studio preview <https://developer.android.google.cn/studio/preview>`__
            -  `Jetpack & Compose libraries <https://developer.android.google.cn/jetpack/androidx/versions>`__
            -  `Wear OS preview <https://developer.android.google.cn/training/wearables/versions/4>`__
            -  `Privacy Sandbox <https://developer.android.google.cn/design-for-safety/privacy-sandbox>`__

   `Design & Plan <https://developer.android.google.cn/design>`__

   .. container:: 

      .. container::
      

         -  Kits & more
         -  Get one of our Figma kits for Android, Material Design, or Wear OS,
            and start designing your app's UI today.
         -  `Go to Android & Material kits <https://developer.android.google.cn/design/ui/mobile#explore-our-kits>`__
         -  `Go to Wear OS kits <https://developer.android.google.cn/design/ui/wear#explore-our-kits>`__

      .. container:: 

         -  UI Design
         -  Design a beautiful user interface using Android best practices.
         -  `Design for Android <https://developer.android.google.cn/design/ui>`__
         -  `Mobile <https://developer.android.google.cn/design/ui/mobile>`__
         -  `Large screens (e.g., tablets) <https://developer.android.google.cn/design/ui/large-screens>`__
         -  `Wear OS <https://developer.android.google.cn/design/ui/wear>`__
         -  `Android TV <https://developer.android.google.cn/design/ui/tv>`__

      .. container:: 

         -  Architecture
         -  Design robust, testable, and maintainable app logic and services.
         -  `Introduction <https://developer.android.google.cn/topic/architecture/intro>`__
         -  `Libraries <https://developer.android.google.cn/topic/libraries/view-binding>`__
         -  `Navigation <https://developer.android.google.cn/guide/navigation/navigation-principles>`__
         -  `Modularization <https://developer.android.google.cn/topic/modularization>`__
         -  `Testing <https://developer.android.google.cn/training/testing/fundamentals>`__

      .. container:: 

         -  Quality
         -  Plan for app quality and align with Play store guidelines.
         -  `Overview <https://developer.android.google.cn/quality>`__
         -  `Core value <https://developer.android.google.cn/quality/core-value>`__
         -  `User experience <https://developer.android.google.cn/quality/user-experience>`__
         -  `Technical quality <https://developer.android.google.cn/quality/technical>`__
         -  `Privacy & security <https://developer.android.google.cn/quality/privacy-and-security>`__

      .. container:: 

         -  Build for Billions
         -  Create the best experience for entry-level devices
         -  `Overview <https://developer.android.google.cn/build-for-billions>`__
         -  `About new markets <https://developer.android.google.cn/docs/quality-guidelines/build-for-billions>`__
         -  `Android (Go edition) <https://developer.android.google.cn/guide/topics/androidgo>`__

   `Develop <https://developer.android.google.cn/develop>`__

   .. container:: 

      .. container::
      

         -  Gemini is here
         -  Gemini in Android Studio is your AI development companion for
            Android development.
         -  `Learn more <https://developer.android.google.cn/gemini-in-android>`__
         -  `Get Android Studio <https://developer.android.google.cn/studio>`__

      .. container:: 

         -  Core areas
         -  Get the samples and docs for the features you need.
         -  `Samples <https://developer.android.google.cn/samples>`__
         -  `User interfaces <https://developer.android.google.cn/develop/ui>`__
         -  `Permissions <https://developer.android.google.cn/guide/topics/permissions/overview>`__
         -  `Background work <https://developer.android.google.cn/develop/background-work>`__
         -  `Data and files <https://developer.android.google.cn/guide/topics/data>`__
         -  `User identity <https://developer.android.google.cn/training/sign-in>`__
         -  `All core areas ‚§µÔ∏è <https://developer.android.google.cn/develop#core-areas>`__

      .. container:: 

         -  Tools and workflow
         -  Use the IDE to write and build your app, or create your own pipeline.
         -  `Write and debug code <https://developer.android.google.cn/studio/write>`__
         -  `Build projects <https://developer.android.google.cn/build>`__
         -  `Test your app <https://developer.android.google.cn/training/testing>`__
         -  `Performance <https://developer.android.google.cn/topic/performance/overview>`__
         -  `Command-line tools <https://developer.android.google.cn/tools>`__
         -  `Gradle plugin API <https://developer.android.google.cn/reference/tools/gradle-api>`__

      .. container:: 

         -  Device tech
         -  Write code for form factors. Connect devices and share data.
         -  `Large screens (e.g., tablets) <https://developer.android.google.cn/guide/topics/large-screens/get-started-with-large-screens>`__
         -  `Wear OS <https://developer.android.google.cn/training/wearables>`__
         -  `Android Health <https://developer.android.google.cn/health-and-fitness/guides>`__
         -  `Cross-device SDK <https://developer.android.google.cn/guide/topics/connectivity/cross-device-sdk/overview>`__
         -  `Android for Cars <https://developer.android.google.cn/training/cars>`__
         -  `Android TV <https://developer.android.google.cn/training/tv>`__
         -  `ChromeOS <https://developer.android.google.cn/chrome-os/intro>`__

      .. container:: 

         -  Libraries
         -  Browse API reference documentation with all the details.
         -  `Android platform <https://developer.android.google.cn/reference/packages>`__
         -  `Jetpack libraries <https://developer.android.google.cn/jetpack/androidx/explorer>`__
         -  `Compose libraries <https://developer.android.google.cn/jetpack/androidx/releases/compose>`__
         -  `Google Play services ‚ÜóÔ∏è <https://developers.google.cn/android/reference/packages>`__
         -  `Google Play SDK index ‚ÜóÔ∏è <https://play.google.com/sdks>`__

   *  `Google Play <https://developer.android.google.cn/distribute>`__
   *  `Community <https://developer.android.google.cn/community>`__


.. container:: devsite-doc-set-nav-row

   *  `Android Studio <https://developer.android.google.cn/studio>`__
   *  `Download <https://developer.android.google.cn/studio>`__ 
   *  `Android Studio editor <https://developer.android.google.cn/studio/intro>`__
   *  `Gemini in Android Studio <https://developer.android.google.cn/gemini-in-android>`__
   *  `Android Gradle Plugin <https://developer.android.google.cn/build>`__ 
   *  `SDK tools <https://developer.android.google.cn/tools>`__
   *  `Preview <https://developer.android.google.cn/studio/preview>`__


.. container:: 

   .. figure::
      https://developer.android.google.cn/static/images/cluster-illustrations/build-apps.svg

.. container:: 

   .. container:: 

      `Develop for Android <https://developer.android.google.cn/get-started/overview>`__

      The code samples, guides, and API reference you
      need‚Äîwhether you're building for phones,
      watches, tablets, laptops, foldables, TVs, or
      cars. Take advantage of these resources to
      develop your app faster and with higher
      quality.

   `I'm new to Android <https://developer.android.google.cn/get-started/overview>`__


.. container::

   .. image:: https://developer.android.google.cn/static/images/cluster-illustrations/samples.svg

   .. container:: 

         `Download samples <https://developer.android.google.cn/samples>`__

         Accelerate your app development by example.

      .. container:: 

         `See code <https://developer.android.google.cn/samples>`__


.. container::

   .. image:: https://developer.android.google.cn/static/images/cluster-illustrations/android-studio.svg

   .. container:: 

         `Develop with Android Studio <https://developer.android.google.cn/studio/write>`__

         Code in the IDE custom-built for Android.

      .. container:: 

         `Write code <https://developer.android.google.cn/studio/write>`__


.. container::

   .. image:: https://developer.android.google.cn/static/images/picto-icons/code.svg

   .. container:: 

         `Browse API reference <https://developer.android.google.cn/reference>`__

         Find information about the Android APIs you're using.

      .. container:: 

         `Look up code <https://developer.android.google.cn/reference>`__


.. container::

   .. rubric:: Devices
      :name: devices

      .. container:: 

         ..  image:: https://developer.android.google.cn/static/images/picto-icons/dual-screen-devices.svg

         `Large screens <https://developer.android.google.cn/guide/topics/large-screens/get-started-with-large-screens>`__

         Extend your mobile app to tablets and foldables.

      .. container:: 

         .. image:: https://developer.android.google.cn/static/images/picto-icons/wearable-app.svg

         `Wear OS <https://developer.android.google.cn/training/wearables>`__

         Create an app for watches running Wear OS.

      .. container:: 

         .. image:: https://developer.android.google.cn/static/images/spot-icons/tv.svg

         `Android TV <https://developer.android.google.cn/training/tv>`__

         Extend your app for TV viewing.

      .. container:: 

         .. image:: https://developer.android.google.cn/static/images/picto-icons/courses.svg

         `ChromeOS <https://developer.android.google.cn/chrome-os/intro>`__

         Build and optimize your app for ChromeOS.

      .. container::
      
         .. image:: https://developer.android.google.cn/static/images/spot-icons/car.svg

         `Android for Cars <https://developer.android.google.cn/training/cars>`__

         Extend your app for vehicle dashboard use.

      .. container::

         ..  image:: https://developer.android.google.cn/static/images/picto-icons/kotlin-friendly-sdk.svg

         `Cross device SDK <https://developer.android.google.cn/guide/topics/connectivity/cross-device-sdk/overview>`__

         Easily make your app compatible with multiple devices.

      .. container:: 

         .. image:: https://developer.android.google.cn/static/images/picto-icons/heart.svg

         `Health Connect <https://developer.android.google.cn/guide/health-and-fitness/health-connect>`__

         Tap into and share on-device health and fitness data.

      .. container::
      
         .. image:: https://developer.android.google.cn/static/images/picto-icons/assistant.svg

         `Assistant <https://developer.android.google.cn/guide/app-actions/overview>`__

         Enable voice control in your app.


.. rubric:: Developer centers
   :name: developer-centers

   .. container:: 

      .. figure::
         https://developer.android.google.cn/static/images/cluster-illustrations/enhance-media-16-9.svg

      .. container:: New

         `Media apps <https://developer.android.google.cn/media>`__

         Learn how to build and extend engaging media
         experiences to users across Android's
         multidevice ecosystem.

         `Learn more <https://developer.android.google.cn/media>`__

   .. container:: 

      .. figure::
         https://developer.android.google.cn/static/images/cluster-illustrations/controllers.svg

      .. container:: New

         `Games <https://developer.android.google.cn/games>`__

         You use a game engine for most of your game
         design and development, but you still need to
         use Android tools to get the job done.

         `Learn more <https://developer.android.google.cn/games>`__

   .. container:: 

      .. figure::
         https://developer.android.google.cn/static/images/picto-icons/health-premium-experience.svg

      .. container:: New

         `Health & Fitness <https://developer.android.google.cn/health-and-fitness>`__

         Take your health and fitness app to the next
         level using Health Services with Health
         Connect.

         `Learn more <https://developer.android.google.cn/health-and-fitness>`__


.. rubric:: Core areas
   :name: core-areas

   .. figure::
      https://developer.android.google.cn/static/images/cluster-illustrations/ui-guidelines.svg

      .. rubric:: User interfaces

         The guides you need to write the code for your
         UI‚Äîwhether you're using Jetpack Compose or
         Views-based APIs, or migrating from Views to
         Compose.

   .. container:: 

      .. container:: 

         `Develop your UI <https://developer.android.google.cn/develop/ui>`__

      .. container::  Guides

         `Data & files <https://developer.android.google.cn/guide/topics/data>`__

         Store, manage, and share data.

      .. container::  Guides

         `Permissions <https://developer.android.google.cn/guide/topics/permissions/overview>`__

         Access and protect restricted data and actions.

      .. container::  Guides

         `User identity <https://developer.android.google.cn/training/sign-in>`__

         Manage user identity and related data.

      .. container::  Guides

         `Navigation <https://developer.android.google.cn/guide/navigation/use-graph/navigate>`__

         Navigate between screens and apps.

      .. container::  Guides

         `Intents and intent filters <https://developer.android.google.cn/guide/components/intents-filters>`__

         Request actions from other apps.

      .. container::  Guides

         `Background tasks <https://developer.android.google.cn/guide/background-work>`__

         Run app tasks in the background.

      .. container::  Guides

         `Services <https://developer.android.google.cn/guide/components/services>`__

         Perform long-running background operations.

      .. container::  Guides

         `Alarms <https://developer.android.google.cn/training/scheduling>`__

         Run scheduled operations in the background.

      .. container::  Dev Center

         `Audio & video <https://developer.android.google.cn/guide/topics/media>`__

         Play and record audio and video.

      .. container::  Dev Center

         `Camera <https://developer.android.google.cn/training/camera/choose-camera-library>`__

         Easily use the camera.

      .. container::  Guides

         `Sensors <https://developer.android.google.cn/guide/topics/sensors/sensors_overview>`__

         Orient your app in the real world.

      .. container::  Guides

         `User location <https://developer.android.google.cn/training/location>`__

         Make your app location aware.

      .. container::  Guides

         `Connectivity <https://developer.android.google.cn/develop/connectivity>`__

         Connect your app through various protocols.

      .. container::  Guides

         `App compatibility <https://developer.android.google.cn/guide/app-compatibility>`__

         Maintain backward compatibility.

      .. container::  Guides

         `App bundles <https://developer.android.google.cn/guide/app-bundle>`__

         Publish your app to Google Play.


.. rubric:: Build and test
   :name: build-and-test

   .. container:: devsite-landing-row-group

      .. figure::
         https://developer.android.google.cn/static/images/cluster-illustrations/new-android-studio.svg

         Configure your build

         Use Android Studio with Gradle to automate and
         manage the build process.

         `Configure <https://developer.android.google.cn/build>`__

      .. figure::
         https://developer.android.google.cn/static/images/cluster-illustrations/build-apps.svg

         Test

         Test your app's correctness, functional
         behavior, and usability before releasing it
         publicly.

         `Test <https://developer.android.google.cn/training/testing>`__


.. rubric:: Developer stories
   :name: developer-stories

   How developers are finding success with Android.

   `View all stories <https://developer.android.google.cn/stories>`__

   .. container::

      .. image:: https://developer.android.google.cn/static/images/logos/googlephotos.png

      `Google Photos builds for large screens <https://developer.android.google.cn/stories/apps/google-photos>`__

      See how the Google Photos team increased daily
      active users by investing in developing
      responsive layouts across across tablets,
      foldables, and ChromeOS devices.

   .. container::

      .. image:: https://developer.android.google.cn/static/images/logos/monzo.svg

      `Monzo moves to CameraX <https://developer.android.google.cn/stories/apps/monzo-camerax>`__

      Monzo reduced over 9,000 lines of code and
      improved registration dropout by 5x with
      CameraX.

   .. container::
   
      .. image:: https://developer.android.google.cn/static/images/distribute/stories/evernote.png

      `Evernote users spend more time on large screens <https://developer.android.google.cn/stories/apps/evernote>`__

      After investing in making their Android app
      work on ChromeOS, Evernote saw those users
      tripled the time they spent using the app.


-  .. rubric:: More Android
      :name: more-android

   -  `Android <https://www.android.com>`__
   -  `Android for Enterprise <https://www.android.com/enterprise/>`__
   -  `Security <https://www.android.com/security-center/>`__
   -  `Source <https://source.android.com>`__
   -  `News <https://developer.android.google.cn/news>`__
   -  `Blog <https://android-developers.googleblog.com/>`__
   -  `Podcasts <https://developer.android.google.cn/podcasts>`__

-  .. rubric:: Discover
      :name: discover

   -  `Gaming <https://developer.android.google.cn/games>`__
   -  `Machine Learning <https://developer.android.google.cn/ml>`__
   -  `Health & Fitness <https://developer.android.google.cn/health-and-fitness>`__
   -  `Camera & Media <https://developer.android.google.cn/media>`__
   -  `Privacy <https://developer.android.google.cn/privacy>`__
   -  `5G <https://developer.android.google.cn/training/connectivity/5g>`__

-  .. rubric:: Android Devices
      :name: android-devices

   -  `Large screens <https://developer.android.google.cn/large-screens>`__
   -  `Wear OS <https://developer.android.google.cn/wear>`__
   -  `ChromeOS devices <https://developer.android.google.cn/chrome-os>`__
   -  `Android for cars <https://developer.android.google.cn/cars>`__
   -  `Android TV <https://developer.android.google.cn/tv>`__

-  .. rubric:: Releases
      :name: releases

   -  `Android 14 <https://developer.android.google.cn/about/versions/14>`__
   -  `Android 13 <https://developer.android.google.cn/about/versions/13>`__
   -  `Android 12 <https://developer.android.google.cn/about/versions/12>`__
   -  `Android 11 <https://developer.android.google.cn/about/versions/11>`__
   -  `Android 10 <https://developer.android.google.cn/about/versions/10>`__
   -  `Pie <https://developer.android.google.cn/about/versions/pie>`__
   -  `Oreo <https://developer.android.google.cn/about/versions/oreo>`__
   -  `Nougat <https://developer.android.google.cn/about/versions/nougat>`__

-  .. rubric:: Documentation and Downloads
      :name: documentation-and-downloads

   -  `Android Studio guide <https://developer.android.google.cn/studio/intro>`__
   -  `Developers guides <https://developer.android.google.cn/guide>`__
   -  `API reference <https://developer.android.google.cn/reference>`__
   -  `Download Studio <https://developer.android.google.cn/studio>`__
   -  `Android NDK <https://developer.android.google.cn/ndk>`__

-  .. rubric:: Support
      :name: support

   -  `Report platform bug <https://issuetracker.google.com/issues/new?component=190923&template=841312>`__
   -  `Report documentation bug <https://issuetracker.google.com/issues/new?component=192697>`__
   -  `Google Play support <https://support.google.com/googleplay/android-developer>`__
   -  `Join research studies <https://g.co/userresearch/androiddeveloperfooter>`__


.. |Android Developers| image:: https://www.gstatic.cn/devrel-devsite/prod/v7ec1cdbf90989ab082f30bf9b9cbe627804848c18b70d722062aeb6c6d8958b5/android/images/lockup.svg
   :class: devsite-site-logo
.. |Google Developers| image:: https://www.gstatic.cn/devrel-devsite/prod/v7ec1cdbf90989ab082f30bf9b9cbe627804848c18b70d722062aeb6c6d8958b5/android/images/lockup-google-for-developers.svg
   :class: devsite-footer-sites-logo



/Platform architecture
======================

DOCPATH: Essentials -> Get The Latest -> Platform Release -> Technology
https://developer.android.google.cn/guide/platform

.. container:: devsite-article-body clearfix

   Android is an open source, Linux-based software stack created for a
   wide array of devices and form factors. Figure 1 shows the major
   components of the Android platform.

   .. image:: https://developer.android.google.cn/static/guide/platform/images/android-stack_2x.png
      :alt: The Android software stack
      :width: 519px

   **Figure 1.** The Android software stack.

   .. rubric:: Linux kernel
      :name: linux-kernel

   The foundation of the Android platform is the Linux kernel. For
   example, `the Android Runtime (ART) <#art>`__ relies on the Linux
   kernel for underlying functionalities such as threading and low-level
   memory management.

   Using a Linux kernel lets Android take advantage of 
   `key security features <https://source.android.google.cn/security/overview/kernel-security.html>`__
   and lets device manufacturers develop hardware drivers for a
   well-known kernel.

   .. rubric:: Hardware abstraction layer (HAL)
      :name: hal

   The `hardware abstraction layer (HAL) <https://source.android.google.cn/devices/architecture/hal>`__
   provides standard interfaces that expose device hardware capabilities
   to the higher-level `Java API framework <#api-framework>`__. The HAL
   consists of multiple library modules, each of which implements an
   interface for a specific type of hardware component, such as the
   `camera <https://source.android.google.cn/devices/camera/index.html>`__
   or
   `Bluetooth <https://source.android.google.cn/devices/bluetooth.html>`__
   module. When a framework API makes a call to access device hardware,
   the Android system loads the library module for that hardware
   component.

   .. rubric:: Android runtime
      :name: art

   For devices running Android version 5.0 (API level 21) or higher,
   each app runs in its own process and with its own instance of the
   `Android Runtime (ART) <https://source.android.google.cn/devices/tech/dalvik/index.html>`__.
   ART is written to run multiple virtual machines on low-memory devices
   by executing Dalvik Executable format (DEX) files, a bytecode format
   designed specifically for Android that's optimized for a minimal
   memory footprint. Build tools, such as
   `d8 <#>`__, compile Java sources into DEX
   bytecode, which can run on the Android platform.

   Some of the major features of ART include the following:

   -  Ahead-of-time (AOT) and just-in-time (JIT) compilation
   -  Optimized garbage collection (GC)
   -  On Android 9 (API level 28) and higher,
      `conversion <#art-aot-dex>`__ of an
      app package's DEX files to more compact machine code
   -  Better debugging support, including a dedicated sampling profiler,
      detailed diagnostic exceptions and crash reporting, and the
      ability to set watchpoints to monitor specific fields

   Prior to Android version 5.0 (API level 21), Dalvik was the Android
   runtime. If your app runs well on ART, then it can work on Dalvik as
   well, but `the reverse might not be true <#>`__.

   Android also includes a set of core runtime libraries that provide
   most of the functionality of the Java programming language, including
   some `Java 8 language features <#>`__, that the
   Java API framework uses.

   .. rubric:: Native C/C++ libraries
      :name: native-libs

   Many core Android system components and services, such as ART and
   HAL, are built from native code that requires native libraries
   written in C and C++. The Android platform provides Java framework
   APIs to expose the functionality of some of these native libraries to
   apps. For example, you can access `OpenGL ES <#>`__ through the
   Android framework‚Äôs `Java OpenGL API <#>`__ to add support for
   drawing and manipulating 2D and 3D graphics in your app.

   If you are developing an app that requires C or C++ code, you can use
   the `Android NDK <#>`__ to access some of these 
   `native platform libraries <#>`__ directly from your native code.

   .. rubric:: Java API framework
      :name: api-framework

   The entire feature-set of the Android OS is available to you through
   APIs written in the Java language. These APIs form the building
   blocks you need to create Android apps by simplifying the reuse of
   core, modular system components and services, which include the
   following:

   -  A rich and extensible `view system <https://developer.android.google.cn/guide/topics/ui/overview>`__
      you can use to build an app‚Äôs UI, including lists, grids, text
      boxes, buttons, and even an embeddable web browser
   -  A `resource manager <https://developer.android.google.cn/guide/topics/resources/overview>`__,
      providing access to non-code resources such as localized strings,
      graphics, and layout files
   -  A `notification manager <https://developer.android.google.cn/guide/topics/ui/notifiers/notifications>`__ 
      that enables all apps to display custom alerts in the status bar
   -  An `activity manager <https://developer.android.google.cn/guide/components/activities/intro-activities>`__ 
      that manages the lifecycle of apps and provides a common 
      `navigation back stack <https://developer.android.google.cn/guide/components/tasks-and-back-stack>`__
   -  `Content providers <https://developer.android.google.cn/guide/topics/providers/content-providers>`__
      that enable apps to access data from other apps, such as the
      Contacts app, or to share their own data

   Developers have full access to the same 
   `framework APIs <https://developer.android.google.cn/reference/packages>`__ that Android system apps use.

   .. rubric:: System apps
      :name: system-apps

   Android comes with a set of core apps for email, SMS messaging,
   calendars, internet browsing, contacts, and more. Apps included with
   the platform have no special status among the apps the user chooses
   to install. So, a third-party app can become the user's default web
   browser, SMS messenger, or even the default keyboard. Some exceptions
   apply, such as the system's Settings app.

   The system apps function both as apps for users and to provide key
   capabilities that developers can access from their own app. For
   example, if you want your app to deliver SMS messages, you don't need
   to build that functionality yourself. You can instead invoke
   whichever SMS app is already installed to deliver a message to the
   recipient you specify.

Last updated 2023-05-04 UTC.



/TOC üíõ Developer Guides
========================

.. container:: devsite-mobile-nav-bottom

   -  `Developer guides <https://developer.android.google.cn/guide>`__

   - App basics

      -  `Build your first app <https://developer.android.google.cn/get-started/overview>`__
      -  `App fundamentals <https://developer.android.google.cn/guide/components/fundamentals>`__

      -  App resources

         -  `About app resources <https://developer.android.google.cn/guide/topics/resources/providing-resources>`__
         -  `Handle configuration changes <https://developer.android.google.cn/guide/topics/resources/runtime-changes>`__

         -  Localization

            -  `Localize your app <https://developer.android.google.cn/guide/topics/resources/localization>`__
            -  `Test your app with pseudolocales <https://developer.android.google.cn/guide/topics/resources/pseudolocales>`__
            -  `Unicode and internationalization support <https://developer.android.google.cn/guide/topics/resources/internationalization>`__
            -  `Language and locale resolution <https://developer.android.google.cn/guide/topics/resources/multilingual-support>`__
            -  `Per-app language preferences <https://developer.android.google.cn/guide/topics/resources/app-languages>`__

         -  `Complex XML resources <https://developer.android.google.cn/guide/topics/resources/complex-xml-resources>`__

         -  Resource types

            -  `About resource types <https://developer.android.google.cn/guide/topics/resources/available-resources>`__
            -  `Animation <https://developer.android.google.cn/guide/topics/resources/animation-resource>`__
            -  `Color state list <https://developer.android.google.cn/guide/topics/resources/color-list-resource>`__
            -  `Drawable <https://developer.android.google.cn/guide/topics/resources/drawable-resource>`__
            -  `Layout <https://developer.android.google.cn/guide/topics/resources/layout-resource>`__
            -  `Menu <https://developer.android.google.cn/guide/topics/resources/menu-resource>`__
            -  `String <https://developer.android.google.cn/guide/topics/resources/string-resource>`__
            -  `Style <https://developer.android.google.cn/guide/topics/resources/style-resource>`__
            -  `Font <https://developer.android.google.cn/guide/topics/resources/font-resource>`__
            -  `More types <https://developer.android.google.cn/guide/topics/resources/more-resources>`__

      -  App manifest file

         -  `About app manifests <https://developer.android.google.cn/guide/topics/manifest/manifest-intro>`__
         -  `<action> <https://developer.android.google.cn/guide/topics/manifest/action-element>`__
         -  `<activity> <https://developer.android.google.cn/guide/topics/manifest/activity-element>`__
         -  `<activity-alias> <https://developer.android.google.cn/guide/topics/manifest/activity-alias-element>`__
         -  `<application> <https://developer.android.google.cn/guide/topics/manifest/application-element>`__
         -  `<category> <https://developer.android.google.cn/guide/topics/manifest/category-element>`__
         -  `<compatible-screens> <https://developer.android.google.cn/guide/topics/manifest/compatible-screens-element>`__
         -  `<data> <https://developer.android.google.cn/guide/topics/manifest/data-element>`__
         -  `<grant-uri-permission> <https://developer.android.google.cn/guide/topics/manifest/grant-uri-permission-element>`__
         -  `<instrumentation> <https://developer.android.google.cn/guide/topics/manifest/instrumentation-element>`__
         -  `<intent-filter> <https://developer.android.google.cn/guide/topics/manifest/intent-filter-element>`__
         -  `<layout> <https://developer.android.google.cn/guide/topics/manifest/layout-element>`__
         -  `<manifest> <https://developer.android.google.cn/guide/topics/manifest/manifest-element>`__
         -  `<meta-data> <https://developer.android.google.cn/guide/topics/manifest/meta-data-element>`__
         -  `<path-permission> <https://developer.android.google.cn/guide/topics/manifest/path-permission-element>`__
         -  `<permission> <https://developer.android.google.cn/guide/topics/manifest/permission-element>`__
         -  `<permission-group> <https://developer.android.google.cn/guide/topics/manifest/permission-group-element>`__
         -  `<permission-tree> <https://developer.android.google.cn/guide/topics/manifest/permission-tree-element>`__
         -  `<profileable> <https://developer.android.google.cn/guide/topics/manifest/profileable-element>`__
         -  `<property> <https://developer.android.google.cn/guide/topics/manifest/property-element>`__
         -  `<provider> <https://developer.android.google.cn/guide/topics/manifest/provider-element>`__
         -  `<queries> <https://developer.android.google.cn/guide/topics/manifest/queries-element>`__
         -  `<receiver> <https://developer.android.google.cn/guide/topics/manifest/receiver-element>`__
         -  `<service> <https://developer.android.google.cn/guide/topics/manifest/service-element>`__
         -  `<supports-gl-texture> <https://developer.android.google.cn/guide/topics/manifest/supports-gl-texture-element>`__
         -  `<supports-screens> <https://developer.android.google.cn/guide/topics/manifest/supports-screens-element>`__
         -  `<uses-configuration> <https://developer.android.google.cn/guide/topics/manifest/uses-configuration-element>`__
         -  `<uses-feature> <https://developer.android.google.cn/guide/topics/manifest/uses-feature-element>`__
         -  `<uses-library> <https://developer.android.google.cn/guide/topics/manifest/uses-library-element>`__
         -  `<uses-native-library> <https://developer.android.google.cn/guide/topics/manifest/uses-native-library-element>`__
         -  `<uses-permission> <https://developer.android.google.cn/guide/topics/manifest/uses-permission-element>`__
         -  `<uses-permission-sdk-23> <https://developer.android.google.cn/guide/topics/manifest/uses-permission-sdk-23-element>`__
         -  `<uses-sdk> <https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element>`__

   - Devices

      -  Device compatibility

         -  `About device compatibility <https://developer.android.google.cn/guide/practices/compatibility>`__
         -  `About screen compatibility <https://developer.android.google.cn/guide/practices/screens_support>`__
         -  `Support different pixel densities <https://developer.android.google.cn/training/multiscreen/screendensities>`__

         -  Multiple APK support

            -  `About multiple APKs <https://developer.android.google.cn/google/play/publishing/multiple-apks>`__
            -  `Create multiple APKs for different API levels <https://developer.android.google.cn/training/multiple-apks/api>`__
            -  `Create multiple APKs for different screen sizes <https://developer.android.google.cn/training/multiple-apks/screensize>`__
            -  `Create multiple APKs for different GL textures <https://developer.android.google.cn/training/multiple-apks/texture>`__
            -  `Create multiple APKs with several dimensions <https://developer.android.google.cn/training/multiple-apks/multiple>`__

         -  `Support different languages and cultures <https://developer.android.google.cn/training/basics/supporting-devices/languages>`__
         -  `Support different platform versions <https://developer.android.google.cn/training/basics/supporting-devices/platforms>`__
         -  `Filters on Google Play <https://developer.android.google.cn/google/play/filters>`__
         -  `64-bit Support <https://developer.android.google.cn/google/play/requirements/64-bit>`__
         -  `Support 16 KB page sizes <https://developer.android.google.cn/guide/practices/page-sizes>`__

      -  Large screens ‚Äî tablets, foldables, ChromeOS

         -  `Get started with large screens <https://developer.android.google.cn/guide/topics/large-screens>`__
         -  `Large screen canonical layouts <https://developer.android.google.cn/guide/topics/large-screens/large-screen-canonical-layouts>`__

         -  Large screen ready

            -  `Overview <https://developer.android.google.cn/guide/topics/large-screens/tier_3_overview>`__
            -  `Configuration and continuity <https://developer.android.google.cn/guide/topics/large-screens/configuration_and_continuity>`__
            -  `Camera preview and media projection <https://developer.android.google.cn/guide/topics/large-screens/camera_preview_and_media_projection>`__
            -  `Multi-window support <https://developer.android.google.cn/guide/topics/large-screens/multi-window-support>`__
            -  `Input compatibility on large screens <https://developer.android.google.cn/guide/topics/large-screens/input-compatibility-large-screens>`__

         -  Large screen optimized

            -  `Overview <https://developer.android.google.cn/guide/topics/large-screens/tier_2_overview>`__
            -  `Support different screen sizes <https://developer.android.google.cn/guide/topics/large-screens/support-different-screen-sizes>`__
            -  `Migrate your UI to responsive layouts <https://developer.android.google.cn/guide/topics/large-screens/migrate-to-responsive-layouts>`__
            -  `Navigation for responsive UIs <https://developer.android.google.cn/guide/topics/large-screens/navigation-for-responsive-uis>`__
            -  `Activity embedding <https://developer.android.google.cn/guide/topics/large-screens/activity-embedding>`__

         -  Large screen differentiated

            -  `Overview <https://developer.android.google.cn/guide/topics/large-screens/tier_1_overview>`__
            -  `Learn about foldables <https://developer.android.google.cn/guide/topics/large-screens/learn-about-foldables>`__
            -  `Make your app fold aware <https://developer.android.google.cn/guide/topics/large-screens/make-apps-fold-aware>`__
            -  `Support foldable display modes <https://developer.android.google.cn/guide/topics/large-screens/foldable-display-modes>`__
            -  `Create a note-taking app <https://developer.android.google.cn/guide/topics/large-screens/create-a-note-taking-app>`__
            -  `Support advanced stylus features <https://developer.android.google.cn/guide/topics/large-screens/support-advanced-stylus-features>`__

         -  `Large screen compatibility mode <https://developer.android.google.cn/guide/topics/large-screens/large-screen-compatibility-mode>`__
         -  `Large screen cookbook <https://developer.android.google.cn/guide/topics/large-screens/large-screen-cookbook>`__

      -  Wear OS

         -  `Get started <https://developer.android.google.cn/training/wearables>`__
         -  `Design Wear OS UI ‚çà <https://developer.android.google.cn/design/ui/wear>`__
         -  `Principles of Wear OS development <https://developer.android.google.cn/training/wearables/principles>`__
         -  `Wear OS versus mobile development <https://developer.android.google.cn/training/wearables/wear-v-mobile>`__
         -  `Wear OS user interfaces <https://developer.android.google.cn/training/wearables/user-interfaces>`__
         -  `Accessibility on Wear OS <https://developer.android.google.cn/training/wearables/accessibility>`__

         -  Getting started

            -  `Wear OS developer pathway <https://developer.android.google.cn/courses/pathways/wear>`__
            -  `Create and run an app <https://developer.android.google.cn/training/wearables/get-started/creating>`__
            -  `Debug a Wear OS app <https://developer.android.google.cn/training/wearables/get-started/debugging>`__
            -  `Connect a watch to a phone <https://developer.android.google.cn/training/wearables/get-started/connect-phone>`__
            -  `Capture Wear UI screenshots <https://developer.android.google.cn/training/wearables/get-started/screenshots>`__

         -  Apps

            -  `About Wear OS apps <https://developer.android.google.cn/training/wearables/apps>`__
            -  `Standalone apps <https://developer.android.google.cn/training/wearables/apps/standalone-apps>`__
            -  `Conserve power <https://developer.android.google.cn/training/wearables/apps/power>`__
            -  `Authentication <https://developer.android.google.cn/training/wearables/apps/auth-wear>`__
            -  `Request permissions <https://developer.android.google.cn/training/wearables/apps/permissions>`__
            -  `Add a splash screen <https://developer.android.google.cn/training/wearables/apps/splash-screen>`__
            -  `Detect location <https://developer.android.google.cn/training/wearables/apps/location-detection>`__
            -  `Playing audio on wearables <https://developer.android.google.cn/training/wearables/apps/audio>`__
            -  `Test Bluetooth audio on emulators <https://developer.android.google.cn/training/wearables/apps/test-bluetooth-audio>`__
            -  `Appear in recents and app resume <https://developer.android.google.cn/training/wearables/apps/launcher>`__

         -  Building UI with Compose

            -  `Use Jetpack Compose on Wear OS <https://developer.android.google.cn/training/wearables/compose>`__
            -  `View design guidelines for UI components <https://developer.android.google.cn/design/ui/wear/guides/components/buttons>`__
            -  `Compose performance <https://developer.android.google.cn/training/wearables/compose/performance>`__
            -  `Lists with Compose <https://developer.android.google.cn/training/wearables/compose/lists>`__
            -  `Rotary input on Compose <https://developer.android.google.cn/training/wearables/compose/rotary-input>`__
            -  `Navigation with Compose for Wear OS <https://developer.android.google.cn/training/wearables/compose/navigation>`__

         -  Building UI with Views

            -  `Build View-based UIs on Wear OS <https://developer.android.google.cn/training/wearables/views>`__
            -  `Handle different watch shapes <https://developer.android.google.cn/training/wearables/views/layouts>`__
            -  `Create lists <https://developer.android.google.cn/training/wearables/views/lists>`__
            -  `Navigation <https://developer.android.google.cn/training/wearables/views/navigation>`__
            -  `Exit full screen activities on Wear <https://developer.android.google.cn/training/wearables/views/exit>`__
            -  `Show confirmations <https://developer.android.google.cn/training/wearables/views/confirm>`__
            -  `Keep your app visible on Wear <https://developer.android.google.cn/training/wearables/views/always-on>`__

         -  Tiles

            -  `About tiles <https://developer.android.google.cn/training/wearables/tiles>`__
            -  `Get started with tiles <https://developer.android.google.cn/training/wearables/tiles/get_started>`__
            -  `Show periodic updates <https://developer.android.google.cn/training/wearables/tiles/update>`__
            -  `Show dynamic updates <https://developer.android.google.cn/training/wearables/tiles/dynamic>`__
            -  `Animate tile elements <https://developer.android.google.cn/training/wearables/tiles/animations>`__
            -  `Interact with tiles <https://developer.android.google.cn/training/wearables/tiles/interactions>`__
            -  `Migrate to ProtoLayout namespaces <https://developer.android.google.cn/training/wearables/tiles/migrate-to-protolayout>`__

         -  Complications

            -  `About complications <https://developer.android.google.cn/training/wearables/complications>`__
            -  `Expose data to complications <https://developer.android.google.cn/training/wearables/complications/exposing-data>`__

         -  Notifications

            -  `Notifications on Wear OS <https://developer.android.google.cn/training/wearables/notifications>`__
            -  `Bridging options for notifications <https://developer.android.google.cn/training/wearables/notifications/bridger>`__
            -  `Ongoing Activities <https://developer.android.google.cn/training/wearables/notifications/ongoing-activity>`__

         -  Handling data

            -  `Dynamic expressions <https://developer.android.google.cn/training/wearables/data/dynamic>`__
            -  `Send and sync data on Wear OS <https://developer.android.google.cn/training/wearables/data/data-layer>`__
            -  `Network access and sync on Wear OS <https://developer.android.google.cn/training/wearables/data/network-access>`__
            -  `Access the Wearable Data Layer <https://developer.android.google.cn/training/wearables/data/accessing>`__
            -  `Transfer data to a new mobile device <https://developer.android.google.cn/training/wearables/data/transfer-to-new-mobile>`__
            -  `Transfer assets <https://developer.android.google.cn/training/wearables/data/assets>`__
            -  `Send and receive messages <https://developer.android.google.cn/training/wearables/data/messages>`__
            -  `Handle data layer events <https://developer.android.google.cn/training/wearables/data/events>`__
            -  `Sync data items with the Data Layer API <https://developer.android.google.cn/training/wearables/data/data-items>`__
            -  `Use cloud backup and restore <https://developer.android.google.cn/training/wearables/data/cloud-backup-restore>`__

         -  User input

            -  `Physical buttons <https://developer.android.google.cn/training/wearables/user-input/physical-buttons>`__
            -  `Rotary input on Views <https://developer.android.google.cn/training/wearables/user-input/rotary-input>`__
            -  `Create input method editors in Wear <https://developer.android.google.cn/training/wearables/user-input/wear-ime>`__
            -  `Voice <https://developer.android.google.cn/training/wearables/user-input/voice>`__

         -  `Read sensor data using Health Services <https://developer.android.google.cn/health-and-fitness/guides/health-services>`__

         -  Creating watch faces

            -  `About watch faces <https://developer.android.google.cn/training/wearables/watch-faces>`__

            - Watch Face Format

               -  `Overview <https://developer.android.google.cn/training/wearables/wff>`__
               -  `Setup <https://developer.android.google.cn/training/wearables/wff/setup>`__
               -  `Optimize memory usage <https://developer.android.google.cn/training/wearables/wff/memory-usage>`__
               -  `XML reference <https://developer.android.google.cn/training/wearables/wff/watch-face>`__

            - Jetpack Watch Face APIs

               -  `Design watch faces <https://developer.android.google.cn/training/wearables/watch-faces/designing>`__
               -  `Build a watch face service <https://developer.android.google.cn/training/wearables/watch-faces/service>`__
               -  `Draw watch faces <https://developer.android.google.cn/training/wearables/watch-faces/drawing>`__
               -  `Adding complications to a watch face <https://developer.android.google.cn/training/wearables/watch-faces/adding-complications>`__
               -  `Creating interactive watch faces <https://developer.android.google.cn/training/wearables/watch-faces/interacting>`__
               -  `Provide configuration activities <https://developer.android.google.cn/training/wearables/watch-faces/configuration>`__
               -  `Address common issues <https://developer.android.google.cn/training/wearables/watch-faces/issues>`__
               -  `Improve performance with hardware acceleration <https://developer.android.google.cn/training/wearables/watch-faces/hardware-acceleration>`__
               -  `Optimize performance and battery life <https://developer.android.google.cn/training/wearables/watch-faces/performance>`__
               -  `Self-tag watch faces <https://developer.android.google.cn/training/wearables/watch-faces/self-tag>`__

         -  `Wear OS app quality <https://developer.android.google.cn/docs/quality-guidelines/wear-app-quality>`__
         -  `Package Wear OS apps <https://developer.android.google.cn/training/wearables/packaging>`__
         -  `Distribute to Wear OS <https://developer.android.google.cn/distribute/best-practices/launch/distribute-wear>`__
         -  `Create Wear OS apps for China <https://developer.android.google.cn/training/wearables/creating-app-china>`__

         -  Releases

            - Wear OS 4

               -  `Overview <https://developer.android.google.cn/training/wearables/versions/4>`__
               -  `Prepare for behavior changes <https://developer.android.google.cn/training/wearables/versions/4/changes>`__
               -  `Update target SDK version <https://developer.android.google.cn/training/wearables/versions/4/update-target-sdk>`__
               -  `Explore features <https://developer.android.google.cn/training/wearables/versions/4/features>`__

            -  `Wear OS 3 migration guide <https://developer.android.google.cn/training/wearables/versions/3/update>`__
            -  `Library release notes <https://developer.android.google.cn/wear/releases>`__

      -  Android TV

         -  `In this guide <https://developer.android.google.cn/training/tv>`__
         -  `Design TV UI ‚çà <https://developer.android.google.cn/design/ui/tv>`__

         -  Build TV Apps

            -  `In this guide <https://developer.android.google.cn/training/tv/start>`__
            -  `Get started with TV apps <https://developer.android.google.cn/training/tv/start/start>`__
            -  `AndroidX TV libraries <https://developer.android.google.cn/training/tv/start/libraries>`__
            -  `Handle TV hardware <https://developer.android.google.cn/training/tv/start/hardware>`__
            -  `Manage TV controllers <https://developer.android.google.cn/training/tv/start/controllers>`__
            -  `On-screen keyboard <https://developer.android.google.cn/training/tv/start/onscreen-keyboard>`__
            -  `Create TV navigation <https://developer.android.google.cn/training/tv/start/navigation>`__
            -  `Best practices for driving engagement on Google TV <https://developer.android.google.cn/training/tv/start/google-tv>`__

         -  Build TV playback apps

            -  `In this guide <https://developer.android.google.cn/training/tv/playback>`__

            - Buidling UI with Compose

               -  `Use Jetpack Compose on Android TV <https://developer.android.google.cn/training/tv/playback/compose>`__
               -  `Create a catalog browser <https://developer.android.google.cn/training/tv/playback/compose/browse>`__
               -  `Build a details screen <https://developer.android.google.cn/training/tv/playback/compose/details>`__

            - Building UI with Leanback API

               -  `Create a catalog browser <https://developer.android.google.cn/training/tv/playback/browse>`__
               -  `Provide a card view <https://developer.android.google.cn/training/tv/playback/card>`__
               -  `Build a details view <https://developer.android.google.cn/training/tv/playback/details>`__
               -  `Use transport controls <https://developer.android.google.cn/training/tv/playback/transport-controls>`__
               -  `Introduce first-time users to your app <https://developer.android.google.cn/training/tv/playback/onboarding>`__
               -  `Add a guided step <https://developer.android.google.cn/training/tv/playback/guided-step>`__
               -  `Build TV layouts <https://developer.android.google.cn/training/tv/playback/leanback/layouts>`__

            -  `Ambient mode <https://developer.android.google.cn/training/tv/playback/ambient-mode>`__
            -  `Playback controls on TV <https://developer.android.google.cn/training/tv/playback/controls>`__
            -  `Implement a media session <https://developer.android.google.cn/training/tv/playback/media-session>`__
            -  `Background playback in a Now Playing card <https://developer.android.google.cn/training/tv/playback/now-playing>`__
            -  `Audio capabilities <https://developer.android.google.cn/training/tv/playback/audio-capabilities>`__
            -  `Match content frame rate <https://developer.android.google.cn/training/tv/playback/framerate>`__

         -  Help users find content on TV

            -  `About finding TV content <https://developer.android.google.cn/training/tv/discovery>`__

            - Recommend TV content

               -  `About recommending TV content <https://developer.android.google.cn/training/tv/discovery/recommendations>`__
               -  `Channels on the home screen <https://developer.android.google.cn/training/tv/discovery/recommendations-channel>`__
               -  `Video program attributes <https://developer.android.google.cn/training/tv/discovery/video-programs>`__
               -  `Audio program attributes <https://developer.android.google.cn/training/tv/discovery/audio-programs>`__
               -  `Game program attributes <https://developer.android.google.cn/training/tv/discovery/game-programs>`__

                  -  Watch Next

                  -  `Add programs <https://developer.android.google.cn/training/tv/discovery/watch-next-add-programs>`__
                  -  `Attributes <https://developer.android.google.cn/training/tv/discovery/watch-next-programs>`__
                  -  `Guidelines for app developers <https://developer.android.google.cn/training/tv/discovery/guidelines-app-developers>`__
                  -  `Guidelines for TV providers <https://developer.android.google.cn/training/tv/discovery/guidelines-tv-providers>`__

               -  `Preview videos <https://developer.android.google.cn/training/tv/discovery/preview-videos>`__
               -  `Recommendations in Android N and earlier <https://developer.android.google.cn/training/tv/discovery/recommendations-row>`__

            -  `Make TV apps searchable <https://developer.android.google.cn/training/tv/discovery/searchable>`__
            -  `Search within TV Apps <https://developer.android.google.cn/training/tv/discovery/in-app-search>`__

         -  Build TV games

            -  `About TV games <https://developer.android.google.cn/training/tv/games>`__

         -  Build TV input services

            -  `About TV input services <https://developer.android.google.cn/training/tv/tif>`__
            -  `Develop a TV input service <https://developer.android.google.cn/training/tv/tif/tvinput>`__
            -  `Work with channel data <https://developer.android.google.cn/training/tv/tif/channel>`__
            -  `Manage TV user interaction <https://developer.android.google.cn/training/tv/tif/ui>`__
            -  `Support time-shifting <https://developer.android.google.cn/training/tv/tif/time-shifting>`__
            -  `Support content recording <https://developer.android.google.cn/training/tv/tif/content-recording>`__

         -  TV Accessibility

            -  `Accessibility best practices <https://developer.android.google.cn/training/tv/accessibility>`__
            -  `TalkBack evaluation examples <https://developer.android.google.cn/training/tv/accessibility/talkback>`__
            -  `Support TalkBack in TV apps <https://developer.android.google.cn/training/tv/accessibility/talkback-support>`__
            -  `Adopt system caption settings <https://developer.android.google.cn/training/tv/accessibility/system-caption-settings>`__
            -  `Custom view accessibility support <https://developer.android.google.cn/training/tv/accessibility/custom-views>`__
            -  `Custom view accessibility sample <https://developer.android.google.cn/training/tv/accessibility/custom-views-sample>`__

         -  `TV Apps checklist <https://developer.android.google.cn/training/tv/publishing/checklist>`__
         -  `Distribute to Android TV <https://developer.android.google.cn/training/tv/publishing/distribute>`__

         -  Releases

            -  `Android 12 for TV <https://developer.android.google.cn/tv/release/12>`__
            -  `Android 13 for TV <https://developer.android.google.cn/tv/release/13>`__

      -  Android for Cars

         -  `About Android for Cars <https://developer.android.google.cn/training/cars>`__

         -  `Car app quality ‚çà <https://developer.android.google.cn/docs/quality-guidelines/car-app-quality>`__

         -  Build media apps for cars

            -  `Build media apps for cars <https://developer.android.google.cn/training/cars/media>`__
            -  `Add support for Android Auto <https://developer.android.google.cn/training/cars/media/auto>`__
            -  `Add support for Android Automotive OS <https://developer.android.google.cn/training/cars/media/automotive-os>`__

         -  `Build messaging apps for Android Auto <https://developer.android.google.cn/training/cars/messaging>`__

         -  Build point of interest, internet of things, and navigation apps for cars

            -  `Using the Android for Cars App Library <https://developer.android.google.cn/training/cars/apps>`__
            -  `Build point of interest apps for cars <https://developer.android.google.cn/training/cars/apps/poi>`__
            -  `Build internet of things apps for cars <https://developer.android.google.cn/training/cars/apps/iot>`__
            -  `Build navigation apps for cars <https://developer.android.google.cn/training/cars/apps/navigation>`__
            -  `Get coarse location <https://developer.android.google.cn/training/cars/apps/coarse-location>`__
            -  `Add support for Android Auto <https://developer.android.google.cn/training/cars/apps/auto>`__
            -  `Add support for Android Automotive OS <https://developer.android.google.cn/training/cars/apps/automotive-os>`__

         -  Build parked apps for Android Automotive OS

            -  `About parked apps <https://developer.android.google.cn/training/cars/parked>`__
            -  `Build video apps <https://developer.android.google.cn/training/cars/parked/video>`__
            -  `Build games <https://developer.android.google.cn/training/cars/parked/games>`__
            -  `Build browsers <https://developer.android.google.cn/training/cars/parked/browser>`__

         -  Test Android apps for cars

            -  `Overview <https://developer.android.google.cn/training/cars/testing>`__
            -  `Test using the Desktop Head Unit <https://developer.android.google.cn/training/cars/testing/dhu>`__
            -  `Test using the Android Automotive OS emulator <https://developer.android.google.cn/training/cars/testing/emulator>`__

         -  `Distribute Android apps for cars <https://developer.android.google.cn/training/cars/distribute>`__
         -  `Google Play services for cars <https://developer.android.google.cn/training/cars/google-services>`__
         -  `Notifications on Android Automotive OS <https://developer.android.google.cn/training/cars/notifications>`__

      -  ChromeOS devices

         -  `About ChromeOS <https://developer.android.google.cn/chrome-os/intro>`__
         -  `Building apps for ChromeOS <https://developer.android.google.cn/topic/arc>`__
         -  `Optimizing Apps for ChromeOS <https://developer.android.google.cn/topic/arc/optimizing>`__
         -  `Preparing your development environment <https://developer.android.google.cn/topic/arc/development-environment>`__
         -  `App Manifest Compatibility for Chromebooks <https://developer.android.google.cn/topic/arc/manifest>`__
         -  `ChromeOS Device Support for Apps <https://developer.android.google.cn/topic/arc/device-support>`__
         -  `App Rendering Differences on Chromebooks <https://developer.android.google.cn/topic/arc/differences>`__
         -  `Window management <https://developer.android.google.cn/topic/arc/window-management>`__
         -  `Adapting Games on ChromeOS <https://developer.android.google.cn/topic/arc/adapting-games>`__
         -  `Smooth animation on ChromeOS <https://developer.android.google.cn/topic/arc/animation>`__
         -  `Test Cases for Android Apps on ChromeOS <https://developer.android.google.cn/topic/arc/tests>`__

      -  Cross device SDK

         -  `About the Cross device SDK <https://developer.android.google.cn/guide/topics/connectivity/cross-device-sdk/overview>`__
         -  `Get started <https://developer.android.google.cn/guide/topics/connectivity/cross-device-sdk/get-started>`__
         -  `Device discovery API <https://developer.android.google.cn/guide/topics/connectivity/cross-device-sdk/device-discovery>`__
         -  `Secure connection API <https://developer.android.google.cn/guide/topics/connectivity/cross-device-sdk/secure-connection>`__
         -  `Sessions API <https://developer.android.google.cn/guide/topics/connectivity/cross-device-sdk/sessions>`__
         -  `Test and debug <https://developer.android.google.cn/guide/topics/connectivity/cross-device-sdk/testing-debugging>`__
         -  `API Reference <https://developer.android.google.cn/reference/crossdevice/packages>`__

      -  Google Assistant

         -  `About Assistant for Android <https://developer.android.google.cn/guide/app-actions/overview>`__

         -  Build

            -  `About App Actions <https://developer.android.google.cn/guide/app-actions/get-started>`__
            -  `Implement built-in intents <https://developer.android.google.cn/guide/app-actions/intents>`__
            -  `Create shortcuts.xml <https://developer.android.google.cn/guide/app-actions/action-schema>`__
            -  `Push dynamic shortcuts to Assistant <https://developer.android.google.cn/guide/app-actions/dynamic-shortcuts>`__
            -  `Release notes <https://developer.android.google.cn/guide/app-actions/release-notes>`__

         -  Test

            -  `Google Assistant plugin <https://developer.android.google.cn/guide/app-actions/test-tool>`__
            -  `App Actions Test Library <https://developer.android.google.cn/guide/app-actions/app-actions-test-library>`__

         -  Grow

            -  `Engage your users <https://developer.android.google.cn/guide/app-actions/grow-overview>`__
            -  `In-App Shortcut Promo SDK <https://developer.android.google.cn/guide/app-actions/in-app-promo-sdk>`__

         -  Add more features

            -  `Custom intents <https://developer.android.google.cn/guide/app-actions/custom-intents>`__
            -  `Android widgets <https://developer.android.google.cn/guide/app-actions/widgets>`__
            -  `Foreground app invocation <https://developer.android.google.cn/guide/app-actions/foreground-app>`__
            -  `Inline inventory <https://developer.android.google.cn/guide/app-actions/inline-inventory>`__
            -  `Web inventory <https://developer.android.google.cn/guide/app-actions/web-inventory>`__
            -  `Assistant sharing <https://developer.android.google.cn/guide/app-actions/assistant-sharing>`__
            -  `Read It <https://developer.android.google.cn/guide/app-actions/read-it>`__

         -  Devices

            -  `App Actions for cars <https://developer.android.google.cn/guide/app-actions/cars>`__
            -  `Assistant for Wear OS <https://developer.android.google.cn/guide/app-actions/wear>`__

         -  `Support <https://developer.android.google.cn/guide/app-actions/app-actions-support>`__

      -  Android (Go edition)

         -  `About Android Go edition <https://developer.android.google.cn/guide/topics/androidgo>`__
         -  `Develop for Android (Go edition) <https://developer.android.google.cn/guide/topics/androidgo/develop>`__
         -  `Test Android Go apps <https://developer.android.google.cn/guide/topics/androidgo/test>`__

         -  Optimize for Android (Go edition)

            -  `Approach <https://developer.android.google.cn/guide/topics/androidgo/optimize>`__
            -  `Optimize app memory <https://developer.android.google.cn/guide/topics/androidgo/optimize-memory>`__
            -  `Improve startup latency <https://developer.android.google.cn/guide/topics/androidgo/optimize-startup>`__
            -  `Reduce app size <https://developer.android.google.cn/guide/topics/androidgo/optimize-size>`__

         -  `Best practices <https://developer.android.google.cn/guide/topics/androidgo/best-practices>`__

   - App architecture

      -  `Introduction <https://developer.android.google.cn/topic/architecture/intro>`__

      -  Guide to app architecture

         -  `About app architecture <https://developer.android.google.cn/topic/architecture>`__

         -  UI layer

            -  `About the UI layer <https://developer.android.google.cn/topic/architecture/ui-layer>`__
            -  `UI events <https://developer.android.google.cn/topic/architecture/ui-layer/events>`__
            -  `State holders and UI state <https://developer.android.google.cn/topic/architecture/ui-layer/stateholders>`__
            -  `State production <https://developer.android.google.cn/topic/architecture/ui-layer/state-production>`__

         -  `Domain layer <https://developer.android.google.cn/topic/architecture/domain-layer>`__

         -  Data layer

            -  `About the data layer <https://developer.android.google.cn/topic/architecture/data-layer>`__
            -  `Offline first <https://developer.android.google.cn/topic/architecture/data-layer/offline-first>`__

         -  `Architecture recommendations <https://developer.android.google.cn/topic/architecture/recommendations>`__
         -  `Learning pathway <https://developer.android.google.cn/courses/pathways/android-architecture>`__

      -  Modularization

         -  `About modularization <https://developer.android.google.cn/topic/modularization>`__
         -  `Common patterns <https://developer.android.google.cn/topic/modularization/patterns>`__

         -  Recipes

            -  `Navigation <https://developer.android.google.cn/guide/navigation/navigation-multi-module>`__

      -  Architecture components

         -  UI layer libraries

            - View binding

               -  `About view binding <https://developer.android.google.cn/topic/libraries/view-binding>`__
               -  `Migrate from Kotlin synthetics to view binding <https://developer.android.google.cn/topic/libraries/view-binding/migration>`__

            - Data binding library

               -  `About data binding <https://developer.android.google.cn/topic/libraries/data-binding>`__
               -  `Get started <https://developer.android.google.cn/topic/libraries/data-binding/start>`__
               -  `Layouts and binding expressions <https://developer.android.google.cn/topic/libraries/data-binding/expressions>`__
               -  `Work with observable data objects <https://developer.android.google.cn/topic/libraries/data-binding/observability>`__
               -  `Generated binding classes <https://developer.android.google.cn/topic/libraries/data-binding/generated-binding>`__
               -  `Binding adapters <https://developer.android.google.cn/topic/libraries/data-binding/binding-adapters>`__
               -  `Bind layout views to Architecture Components <https://developer.android.google.cn/topic/libraries/data-binding/architecture>`__
               -  `Two-way data binding <https://developer.android.google.cn/topic/libraries/data-binding/two-way>`__

            - Lifecycle-aware components

               -  Lifecycles

                  -  `Handle lifecycles <https://developer.android.google.cn/topic/libraries/architecture/lifecycle>`__
                  -  `Integrate with Compose <https://developer.android.google.cn/topic/libraries/architecture/compose>`__

               -  ViewModel

                  -  `Overview: ViewModel overview <https://developer.android.google.cn/topic/libraries/architecture/viewmodel>`__
                  -  `Create ViewModels with dependencies <https://developer.android.google.cn/topic/libraries/architecture/viewmodel/viewmodel-factories>`__
                  -  `ViewModel Scoping APIs <https://developer.android.google.cn/topic/libraries/architecture/viewmodel/viewmodel-apis>`__
                  -  `Saved State module for ViewModel <https://developer.android.google.cn/topic/libraries/architecture/viewmodel/viewmodel-savedstate>`__
                  -  `ViewModel APIs cheat sheet <https://developer.android.google.cn/topic/libraries/architecture/viewmodel/viewmodel-cheatsheet>`__

               -  `LiveData <https://developer.android.google.cn/topic/libraries/architecture/livedata>`__
               -  `Save UI states <https://developer.android.google.cn/topic/libraries/architecture/saving-states>`__
               -  `Use Kotlin coroutines with lifecycle-aware components <https://developer.android.google.cn/topic/libraries/architecture/coroutines>`__

               - Paging Library

                  -  `Overview: Paging library overview <https://developer.android.google.cn/topic/libraries/architecture/paging/v3-overview>`__
                  -  `Load and display paged data <https://developer.android.google.cn/topic/libraries/architecture/paging/v3-paged-data>`__
                  -  `Page from network and database <https://developer.android.google.cn/topic/libraries/architecture/paging/v3-network-db>`__
                  -  `Transform data streams <https://developer.android.google.cn/topic/libraries/architecture/paging/v3-transform>`__
                  -  `Manage and present loading states <https://developer.android.google.cn/topic/libraries/architecture/paging/load-state>`__
                  -  `Test your Paging implementation <https://developer.android.google.cn/topic/libraries/architecture/paging/test>`__
                  -  `Migrate to Paging 3 <https://developer.android.google.cn/topic/libraries/architecture/paging/v3-migration>`__

                  -  Paging 2

                     -  `About Paging 2 <https://developer.android.google.cn/topic/libraries/architecture/paging>`__
                     -  `Display paged lists <https://developer.android.google.cn/topic/libraries/architecture/paging/ui>`__
                     -  `Load paged data <https://developer.android.google.cn/topic/libraries/architecture/paging/data>`__

         -  Data layer libraries

            -  `DataStore <https://developer.android.google.cn/topic/libraries/architecture/datastore>`__

            - WorkManager

               -  `Overview: Schedule tasks with WorkManager <https://developer.android.google.cn/topic/libraries/architecture/workmanager>`__
               -  `Getting Started <https://developer.android.google.cn/topic/libraries/architecture/workmanager/basics>`__

               -  How-To Guides

                  -  `Defining your WorkRequests <https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/define-work>`__
                  -  `Work states <https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/states-and-observation>`__
                  -  `Managing work <https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/managing-work>`__
                  -  `Observing intermediate Worker progress <https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/intermediate-progress>`__
                  -  `Chaining work together <https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/chain-work>`__
                  -  `Testing Worker implementation <https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/testing-worker-impl>`__
                  -  `Integration tests with WorkManager <https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/integration-testing>`__
                  -  `Debugging WorkManager <https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/debugging>`__

               -  Advanced Concepts

                  -  `Configuration and Initialization <https://developer.android.google.cn/topic/libraries/architecture/workmanager/advanced/custom-configuration>`__

                  -  Threading in WorkManager

                     -  `About threading in WorkManager <https://developer.android.google.cn/topic/libraries/architecture/workmanager/advanced/threading>`__
                     -  `Threading in Worker <https://developer.android.google.cn/topic/libraries/architecture/workmanager/advanced/worker>`__
                     -  `Threading in CoroutineWorker <https://developer.android.google.cn/topic/libraries/architecture/workmanager/advanced/coroutineworker>`__
                     -  `Threading in RxWorker <https://developer.android.google.cn/topic/libraries/architecture/workmanager/advanced/rxworker>`__
                     -  `Threading in ListenableWorker <https://developer.android.google.cn/topic/libraries/architecture/workmanager/advanced/listenableworker>`__

                  -  `Support for long-running workers <https://developer.android.google.cn/topic/libraries/architecture/workmanager/advanced/long-running>`__

               -  `Migrating from Firebase JobDispatcher <https://developer.android.google.cn/topic/libraries/architecture/workmanager/migrating-fb>`__
               -  `Migrating from GCMNetworkManager <https://developer.android.google.cn/topic/libraries/architecture/workmanager/migrating-gcm>`__

      -  App entry points

         -  Activities

            -  `Introduction to activities <https://developer.android.google.cn/guide/components/activities/intro-activities>`__
            -  `The activity lifecycle <https://developer.android.google.cn/guide/components/activities/activity-lifecycle>`__
            -  `Activity state changes <https://developer.android.google.cn/guide/components/activities/state-changes>`__
            -  `Test your app's activities <https://developer.android.google.cn/guide/components/activities/testing>`__
            -  `Tasks and the back stack <https://developer.android.google.cn/guide/components/activities/tasks-and-back-stack>`__
            -  `Processes and app lifecycle <https://developer.android.google.cn/guide/components/activities/process-lifecycle>`__
            -  `Parcelables and bundles <https://developer.android.google.cn/guide/components/activities/parcelables-and-bundles>`__
            -  `Loaders <https://developer.android.google.cn/guide/components/loaders>`__
            -  `Recents screen <https://developer.android.google.cn/guide/components/activities/recents>`__
            -  `Restrictions on starting activities from the background <https://developer.android.google.cn/guide/components/activities/background-starts>`__

         -  App shortcuts

            -  `Overview: About app shortcuts <https://developer.android.google.cn/guide/topics/ui/shortcuts>`__
            -  `Create shortcuts <https://developer.android.google.cn/guide/topics/ui/shortcuts/creating-shortcuts>`__
            -  `Add capabilities <https://developer.android.google.cn/guide/topics/ui/shortcuts/adding-capabilities>`__
            -  `Manage shortcuts <https://developer.android.google.cn/guide/topics/ui/shortcuts/managing-shortcuts>`__
            -  `Best practices for shortcuts <https://developer.android.google.cn/guide/topics/ui/shortcuts/best-practices>`__

      -  App navigation

         -  `Principles of navigation <https://developer.android.google.cn/guide/navigation/principles>`__

         -  Navigation component

            -  `Overview: Navigation <https://developer.android.google.cn/guide/navigation>`__
            -  `Navigation controller <https://developer.android.google.cn/guide/navigation/navcontroller>`__

            - Design your navigation graph

               -  `Overview <https://developer.android.google.cn/guide/navigation/design>`__
               -  `Dialog destinations <https://developer.android.google.cn/guide/navigation/design/dialog-destinations>`__
               -  `Activity destinations <https://developer.android.google.cn/guide/navigation/design/activity-destinations>`__
               -  `Nested graphs <https://developer.android.google.cn/guide/navigation/design/nested-graphs>`__
               -  `Deep links <https://developer.android.google.cn/guide/navigation/design/deep-link>`__
               -  `New destination types <https://developer.android.google.cn/guide/navigation/design/add-new>`__
               -  `Type safety <https://developer.android.google.cn/guide/navigation/design/type-safety>`__
               -  `Global actions <https://developer.android.google.cn/guide/navigation/design/actions>`__
               -  `Build a graph programmatically using the Kotlin DSL <https://developer.android.google.cn/guide/navigation/design/kotlin-dsl>`__
               -  `Use the Navigation editor <https://developer.android.google.cn/guide/navigation/design/editor>`__

            - Use your navigation graph

               -  `Navigate to a destination <https://developer.android.google.cn/guide/navigation/use-graph/navigate>`__
               -  `Navigate with options <https://developer.android.google.cn/guide/navigation/use-graph/navoptions>`__
               -  `Safe args <https://developer.android.google.cn/guide/navigation/use-graph/safe-args>`__
               -  `Pass data between destinations <https://developer.android.google.cn/guide/navigation/use-graph/pass-data>`__
               -  `Animate transitions between destinations <https://developer.android.google.cn/guide/navigation/use-graph/animate-transitions>`__
               -  `Conditional navigation <https://developer.android.google.cn/guide/navigation/use-graph/conditional>`__
               -  `Interact programmatically with the Navigation component <https://developer.android.google.cn/guide/navigation/use-graph/programmatic>`__

            - The back stack

               -  `Overview <https://developer.android.google.cn/guide/navigation/backstack>`__
               -  `Dialogs and the back stack <https://developer.android.google.cn/guide/navigation/backstack/dialog>`__
               -  `Circular navigation and the back stack <https://developer.android.google.cn/guide/navigation/backstack/circular>`__
               -  `Multiple back stacks <https://developer.android.google.cn/guide/navigation/backstack/multi-back-stacks>`__

            - Integrations

               -  `Navigate with feature modules <https://developer.android.google.cn/guide/navigation/integrations/feature-modules>`__
               -  `Multi-module projects <https://developer.android.google.cn/guide/navigation/integrations/multi-module>`__
               -  `Connect UI components to NavController <https://developer.android.google.cn/guide/navigation/integrations/ui>`__

            -  `Migrate to the Navigation component <https://developer.android.google.cn/guide/navigation/migrate>`__
            -  `Test Navigation <https://developer.android.google.cn/guide/navigation/testing>`__

         -  Custom back navigation

            -  `Custom back navigation <https://developer.android.google.cn/guide/navigation/custom-back>`__
            -  `Predictive back gesture <https://developer.android.google.cn/guide/navigation/custom-back/predictive-back-gesture>`__
            -  `Add support for predictive back animations <https://developer.android.google.cn/guide/navigation/custom-back/support-animations>`__

         -  Responsive design

            -  `Handling configuration changes <https://developer.android.google.cn/guide/navigation/responsive/config-changes>`__
            -  `Design for different form factors <https://developer.android.google.cn/guide/navigation/responsive/form-factors>`__

         -  Swipe between views

            -  `Swipe views using ViewPager2 <https://developer.android.google.cn/guide/navigation/advanced/swipe-view-2>`__
            -  `Swipe views using ViewPager <https://developer.android.google.cn/guide/navigation/advanced/swipe-view>`__

         -  Fragments

            -  `Overview: Fragments <https://developer.android.google.cn/guide/fragments>`__
            -  `Create a fragment <https://developer.android.google.cn/guide/fragments/create>`__
            -  `Fragment manager <https://developer.android.google.cn/guide/fragments/fragmentmanager>`__
            -  `Fragment transactions <https://developer.android.google.cn/guide/fragments/transactions>`__
            -  `Animate transitions between fragments <https://developer.android.google.cn/guide/fragments/animate>`__
            -  `Fragment lifecycle <https://developer.android.google.cn/guide/fragments/lifecycle>`__
            -  `Saving state with fragments <https://developer.android.google.cn/guide/fragments/saving-state>`__
            -  `Communicate with fragments <https://developer.android.google.cn/guide/fragments/communicate>`__
            -  `Working with the app bar <https://developer.android.google.cn/guide/fragments/appbar>`__
            -  `Displaying dialogs with DialogFragment <https://developer.android.google.cn/guide/fragments/dialogs>`__
            -  `Debug your fragments <https://developer.android.google.cn/guide/fragments/debugging>`__
            -  `Test your fragments <https://developer.android.google.cn/guide/fragments/test>`__

         -  App links

            -  `About app links <https://developer.android.google.cn/training/app-links>`__
            -  `Enabling links to app content <https://developer.android.google.cn/training/app-links/deep-linking>`__
            -  `Verify app links <https://developer.android.google.cn/training/app-links/verify-android-applinks>`__
            -  `Create app links for instant apps <https://developer.android.google.cn/training/app-links/instant-app-links>`__

         -  Interact with other apps

            -  `About interacting with other apps <https://developer.android.google.cn/training/basics/intents>`__
            -  `About intents and intent filters <https://developer.android.google.cn/guide/components/intents-filters>`__
            -  `About common intents <https://developer.android.google.cn/guide/components/intents-common>`__
            -  `Send users to another app <https://developer.android.google.cn/training/basics/intents/sending>`__
            -  `Get a result from an activity <https://developer.android.google.cn/training/basics/intents/result>`__
            -  `Allow other apps to start your activity <https://developer.android.google.cn/training/basics/intents/filters>`__
            -  `Limit loading in on-device Android containers <https://developer.android.google.cn/training/basics/intents/limit-play-loading>`__

            - Package visibility

               -  `About package visibility <https://developer.android.google.cn/training/package-visibility>`__
               -  `Know which packages are visible automatically <https://developer.android.google.cn/training/package-visibility/automatic>`__
               -  `Declare package visibility needs <https://developer.android.google.cn/training/package-visibility/declaring>`__
               -  `Fulfill common use cases <https://developer.android.google.cn/training/package-visibility/use-cases>`__
               -  `Test package visibility <https://developer.android.google.cn/training/package-visibility/testing>`__

      -  Dependency injection

         -  `About dependency injection <https://developer.android.google.cn/training/dependency-injection>`__
         -  `Manual dependency injection <https://developer.android.google.cn/training/dependency-injection/manual>`__
         -  `Dependency injection with Hilt <https://developer.android.google.cn/training/dependency-injection/hilt-android>`__
         -  `Hilt in multi-module apps <https://developer.android.google.cn/training/dependency-injection/hilt-multi-module>`__
         -  `Use Hilt with other Jetpack libraries <https://developer.android.google.cn/training/dependency-injection/hilt-jetpack>`__
         -  `Hilt testing guide <https://developer.android.google.cn/training/dependency-injection/hilt-testing>`__
         -  `Hilt and Dagger annotations cheat sheet <https://developer.android.google.cn/training/dependency-injection/hilt-cheatsheet>`__

         -  Dagger

            -  `Dagger basics <https://developer.android.google.cn/training/dependency-injection/dagger-basics>`__
            -  `Using Dagger in Android apps <https://developer.android.google.cn/training/dependency-injection/dagger-android>`__
            -  `Using Dagger in multi-module apps <https://developer.android.google.cn/training/dependency-injection/dagger-multi-module>`__

      -  `App Startup - Part of Android Jetpack <https://developer.android.google.cn/topic/libraries/app-startup>`__

   - Google Play

      -  `Google Play Billing ‚çà <https://developer.android.google.cn/google/play/billing>`__
      -  `Google Play Core libraries <https://developer.android.google.cn/guide/playcore>`__

      -  Engage SDK

         -  `About Engage SDK <https://developer.android.google.cn/guide/playcore/engage>`__
         -  `Engage SDK Watch integration guide <https://developer.android.google.cn/guide/playcore/engage/watch>`__
         -  `Engage SDK Listen integration guide <https://developer.android.google.cn/guide/playcore/engage/listen>`__
         -  `Engage SDK Read integration guide <https://developer.android.google.cn/guide/playcore/engage/read>`__
         -  `Engage SDK Shopping integration guide <https://developer.android.google.cn/guide/playcore/engage/shopping>`__
         -  `Engage SDK Food integration guide <https://developer.android.google.cn/guide/playcore/engage/food>`__
         -  `Engage SDK Social integration guide <https://developer.android.google.cn/guide/playcore/engage/social>`__
         -  `Engage SDK integration workflow <https://developer.android.google.cn/guide/playcore/engage/workflow>`__
         -  `Engage SDK Cluster publishing guidelines <https://developer.android.google.cn/guide/playcore/engage/publish>`__
         -  `Engage SDK Frequently asked questions <https://developer.android.google.cn/guide/playcore/engage/faq>`__
         -  `Engage SDK Release Notes <https://developer.android.google.cn/guide/playcore/engage/release>`__
         -  `Engage SDK Sample Apps <https://developer.android.google.cn/guide/playcore/engage/samples>`__

      -  Play Points

         -  `About Play Points <https://developer.android.google.cn/guide/playpoints>`__
         -  `Create products and promotions <https://developer.android.google.cn/guide/playpoints/create-products>`__
         -  `Detect and deliver products <https://developer.android.google.cn/guide/playpoints/deliver-items>`__
         -  `Test products <https://developer.android.google.cn/guide/playpoints/test>`__

      -  Play Asset Delivery

         -  `About Play Asset Delivery <https://developer.android.google.cn/guide/playcore/asset-delivery>`__
         -  `Integrate asset delivery (Kotlin and Java) <https://developer.android.google.cn/guide/playcore/asset-delivery/integrate-java>`__
         -  `Integrate asset delivery (native) <https://developer.android.google.cn/guide/playcore/asset-delivery/integrate-native>`__
         -  `Integrate asset delivery (Unity) <https://developer.android.google.cn/guide/playcore/asset-delivery/integrate-unity>`__
         -  `Target texture compression formats <https://developer.android.google.cn/guide/playcore/asset-delivery/texture-compression>`__
         -  `Test asset delivery <https://developer.android.google.cn/guide/playcore/asset-delivery/test>`__

      -  Play Feature Delivery

         -  `About Play Feature Delivery <https://developer.android.google.cn/guide/playcore/feature-delivery>`__
         -  `Configure install-time delivery <https://developer.android.google.cn/guide/playcore/feature-delivery/install-time>`__
         -  `Configure conditional delivery <https://developer.android.google.cn/guide/playcore/feature-delivery/conditional>`__
         -  `Configure on-demand delivery <https://developer.android.google.cn/guide/playcore/feature-delivery/on-demand>`__
         -  `On-demand delivery best practices <https://developer.android.google.cn/guide/playcore/feature-delivery/ux-guidelines>`__
         -  `Configure instant delivery <https://developer.android.google.cn/guide/playcore/feature-delivery/instant>`__
         -  `Additional resources <https://developer.android.google.cn/guide/playcore/feature-delivery/additional-resources>`__

      -  In-app reviews

         -  `Overview <https://developer.android.google.cn/guide/playcore/in-app-review>`__
         -  `Integrate using Kotlin or Java <https://developer.android.google.cn/guide/playcore/in-app-review/kotlin-java>`__
         -  `Integrate using native code <https://developer.android.google.cn/guide/playcore/in-app-review/native>`__
         -  `Integrate using Unity <https://developer.android.google.cn/guide/playcore/in-app-review/unity>`__
         -  `Test in-app reviews <https://developer.android.google.cn/guide/playcore/in-app-review/test>`__

      -  In-app updates

         -  `About in-app updates <https://developer.android.google.cn/guide/playcore/in-app-updates>`__
         -  `Support in-app updates (Kotlin or Java) <https://developer.android.google.cn/guide/playcore/in-app-updates/kotlin-java>`__
         -  `Support in-app updates (Native) <https://developer.android.google.cn/guide/playcore/in-app-updates/native>`__
         -  `Support in-app updates (Unity) <https://developer.android.google.cn/guide/playcore/in-app-updates/unity>`__
         -  `Test in-app updates <https://developer.android.google.cn/guide/playcore/in-app-updates/test>`__

      -  Play as you Download

         -  `About Play as you Download <https://developer.android.google.cn/google/play/play-as-you-download>`__
         -  `Best practices <https://developer.android.google.cn/google/play/play-as-you-download/best-practices>`__

         -  Google Play Instant

            -  `About Google Play Instant <https://developer.android.google.cn/topic/google-play-instant/overview>`__

            -  Get started with instant apps

                  -  `Create an instant-enabled app bundle <https://developer.android.google.cn/topic/google-play-instant/getting-started/instant-enabled-app-bundle>`__
                  -  `UX best practices for apps <https://developer.android.google.cn/topic/google-play-instant/best-practices/apps>`__

            -  Get started with instant games

                  -  `About instant games <https://developer.android.google.cn/topic/google-play-instant/getting-started/game-instant-app>`__
                  -  `Unity plugin <https://developer.android.google.cn/topic/google-play-instant/getting-started/game-unity-plugin>`__
                  -  `UX best practices for games <https://developer.android.google.cn/topic/google-play-instant/best-practices/games>`__
                  -  `Migrate to Android App Bundles <https://developer.android.google.cn/topic/google-play-instant/feature-module-migration>`__
                  -  `Implement cloud delivery of assets <https://developer.android.google.cn/topic/google-play-instant/getting-started/cloud-delivery-assets>`__
                  -  `Support Google Play Games Services <https://developer.android.google.cn/topic/google-play-instant/getting-started/support-play-games-services>`__
                  -  `Instant Play games <https://developer.android.google.cn/topic/google-play-instant/instant-play-games>`__
                  -  `Instant Play games checklist <https://developer.android.google.cn/topic/google-play-instant/instant-play-games-checklist>`__

            -  `Reduce the size of your instant app or game <https://developer.android.google.cn/topic/google-play-instant/guides/reduce-module-size>`__

            -  `Add ads to your instant app or game <https://developer.android.google.cn/topic/google-play-instant/guides/advertising>`__

            -  `Provide multiple entry points <https://developer.android.google.cn/topic/google-play-instant/guides/multiple-entry-points>`__

            -  Integrate with Firebase

                  -  `Add Google Analytics for Firebase to your instant app <https://developer.android.google.cn/topic/google-play-instant/guides/analytics>`__
                  -  `Use Firebase Dynamic Links with instant apps <https://developer.android.google.cn/topic/google-play-instant/guides/dynamic-links>`__

            -  `Technical requirements checklist <https://developer.android.google.cn/topic/google-play-instant/tech-requirements>`__

            -  `Google Play Instant policy <https://play.google.com/about/other-programs/android-instant-apps/>`__

            -  Resources

               -  `Reference <https://developers.google.com/android/reference/com/google/android/gms/instantapps/package-summary>`__
               -  `Code samples <https://developer.android.google.cn/topic/google-play-instant/samples>`__
               -  `SDK release notes <https://developer.android.google.cn/topic/google-play-instant/release-notes>`__
               -  `Instant App Intents <https://developer.android.google.cn/topic/google-play-instant/instant-app-intents>`__

            -  Support

               -  `Known issues <https://issuetracker.google.com/issues?q=status:open%20componentid:316045>`__
               -  `StackOverflow <https://stackoverflow.com/questions/tagged/android-instant-apps>`__

      -  `Play Developer APIs <https://developer.android.google.cn/google/play/developer-api>`__

      -  Play Install Referrer

         -  `Overview <https://developer.android.google.cn/google/play/installreferrer>`__

         -  Play Install Referrer Library

            -  `Overview <https://developer.android.google.cn/google/play/installreferrer/library>`__
            -  `Reference ‚çà <https://developer.android.google.cn/reference/com/android/installreferrer/packages>`__
            -  `Release notes <https://developer.android.google.cn/google/play/installreferrer/release-notes>`__

         -  `Play Install Referrer API <https://developer.android.google.cn/google/play/installreferrer/igetinstallreferrerservice>`__

      -  `Play Integrity API ‚çà <https://developer.android.google.cn/google/play/integrity>`__

      -  Play Requirements

         -  `Play Policies ‚çà <https://developer.android.google.cn/distribute/play-policies>`__
         -  `Target API Level ‚çà <https://developer.android.google.cn/google/play/requirements/target-sdk>`__
         -  `Support 64-bit architectures ‚çà <https://developer.android.google.cn/google/play/requirements/64-bit>`__

      -  Application Licensing

         -  `Overview <https://developer.android.google.cn/google/play/licensing>`__
         -  `Licensing Overview <https://developer.android.google.cn/google/play/licensing/overview>`__
         -  `Setting Up for Licensing <https://developer.android.google.cn/google/play/licensing/setting-up>`__
         -  `Adding Server-Side Verification <https://developer.android.google.cn/google/play/licensing/server-side-verification>`__
         -  `Adding Client-Side Verification <https://developer.android.google.cn/google/play/licensing/client-side-verification>`__
         -  `Licensing Reference <https://developer.android.google.cn/google/play/licensing/licensing-reference>`__

      -  `APK Expansion Files <https://developer.android.google.cn/google/play/expansion-files>`__
      -  `App updates <https://developer.android.google.cn/google/play/app-updates>`__

   - Core areas

      -  App compatibility

         -  `About app compatibility <https://developer.android.google.cn/guide/app-compatibility>`__
         -  `Compatibility framework tools <https://developer.android.google.cn/guide/app-compatibility/test-debug>`__
         -  `Restrictions on non-SDK interfaces <https://developer.android.google.cn/guide/app-compatibility/restrictions-non-sdk-interfaces>`__

      -  `User interfaces ‚çà <https://developer.android.google.cn/develop/ui>`__
      -  `Audio & video ‚çà <https://developer.android.google.cn/media/audio-and-video>`__
      -  `Services ‚çà <https://developer.android.google.cn/develop/background-work/services>`__
      -  `Background tasks ‚çà <https://developer.android.google.cn/develop/background-work/background-tasks>`__
      -  `Alarms ‚çà <https://developer.android.google.cn/develop/background-work/services/alarms>`__

      -  Permissions

         -  `About permissions <https://developer.android.google.cn/guide/topics/permissions/overview>`__
         -  `Declare app permissions <https://developer.android.google.cn/training/permissions/declaring>`__

         -  Request app permissions

            -  `Request runtime permissions <https://developer.android.google.cn/training/permissions/requesting>`__
            -  `Request special permissions <https://developer.android.google.cn/training/permissions/requesting-special>`__

         -  `Explain access to more sensitive information <https://developer.android.google.cn/training/permissions/explaining-access>`__
         -  `App permissions best practices <https://developer.android.google.cn/training/permissions/usage-notes>`__
         -  `Permissions used only in default handlers <https://developer.android.google.cn/guide/topics/permissions/default-handlers>`__
         -  `Restrict interactions with other apps <https://developer.android.google.cn/training/permissions/restrict-interactions>`__
         -  `Define custom permissions <https://developer.android.google.cn/guide/topics/permissions/defining>`__

      -  App data and files

         -  `About app data and files <https://developer.android.google.cn/guide/topics/data>`__
         -  `About storage <https://developer.android.google.cn/training/data-storage>`__
         -  `Save to app-specific storage <https://developer.android.google.cn/training/data-storage/app-specific>`__

         -  Save to shared storage

            -  `About shared storage <https://developer.android.google.cn/training/data-storage/shared>`__
            -  `Media <https://developer.android.google.cn/training/data-storage/shared/media>`__
            -  `Photo picker <https://developer.android.google.cn/training/data-storage/shared/photopicker>`__
            -  `Documents and other files <https://developer.android.google.cn/training/data-storage/shared/documents-files>`__
            -  `Datasets <https://developer.android.google.cn/training/data-storage/shared/datasets>`__

         -  `Manage all files on a storage device <https://developer.android.google.cn/training/data-storage/manage-all-files>`__
         -  `Save key-value data <https://developer.android.google.cn/training/data-storage/shared-preferences>`__

         -  Save data in a local database

            -  `About the local database <https://developer.android.google.cn/training/data-storage/room>`__
            -  `Define data using entities <https://developer.android.google.cn/training/data-storage/room/defining-data>`__
            -  `Access data using DAOs <https://developer.android.google.cn/training/data-storage/room/accessing-data>`__
            -  `Define relationships between objects <https://developer.android.google.cn/training/data-storage/room/relationships>`__
            -  `Write asynchronous DAO queries <https://developer.android.google.cn/training/data-storage/room/async-queries>`__
            -  `Create views into a database <https://developer.android.google.cn/training/data-storage/room/creating-views>`__
            -  `Prepopulate your database <https://developer.android.google.cn/training/data-storage/room/prepopulate>`__
            -  `Migrate your database <https://developer.android.google.cn/training/data-storage/room/migrating-db-versions>`__
            -  `Test and debug your database <https://developer.android.google.cn/training/data-storage/room/testing-db>`__
            -  `Reference complex data <https://developer.android.google.cn/training/data-storage/room/referencing-data>`__
            -  `Migrate from SQLite to Room <https://developer.android.google.cn/training/data-storage/room/sqlite-room-migration>`__
            -  `Save data using SQLite <https://developer.android.google.cn/training/data-storage/sqlite>`__

         -  `Storage use cases and best practices <https://developer.android.google.cn/training/data-storage/use-cases>`__

         -  Sharing data

            -  `About sharing data <https://developer.android.google.cn/training/sharing>`__
            -  `Sending simple data to other apps <https://developer.android.google.cn/training/sharing/send>`__
            -  `Receiving simple data from other apps <https://developer.android.google.cn/training/sharing/receive>`__
            -  `Provide Direct Share targets <https://developer.android.google.cn/training/sharing/direct-share-targets>`__

         -  Sharing files

            -  `About sharing files <https://developer.android.google.cn/training/secure-file-sharing>`__
            -  `Setting up file sharing <https://developer.android.google.cn/training/secure-file-sharing/setup-sharing>`__
            -  `Sharing a file <https://developer.android.google.cn/training/secure-file-sharing/share-file>`__
            -  `Requesting a shared file <https://developer.android.google.cn/training/secure-file-sharing/request-file>`__
            -  `Retrieving file information <https://developer.android.google.cn/training/secure-file-sharing/retrieve-info>`__

         -  Printing files

            -  `About printing <https://developer.android.google.cn/training/printing>`__
            -  `Printing photos <https://developer.android.google.cn/training/printing/photos>`__
            -  `Printing HTML documents <https://developer.android.google.cn/training/printing/html-docs>`__
            -  `Printing custom documents <https://developer.android.google.cn/training/printing/custom-docs>`__

         -  Content providers

            -  `About content providers <https://developer.android.google.cn/guide/topics/providers/content-providers>`__
            -  `Content provider basics <https://developer.android.google.cn/guide/topics/providers/content-provider-basics>`__
            -  `Creating a content provider <https://developer.android.google.cn/guide/topics/providers/content-provider-creating>`__
            -  `Open files using storage access framework <https://developer.android.google.cn/guide/topics/providers/document-provider>`__
            -  `Create a custom document provider <https://developer.android.google.cn/guide/topics/providers/create-document-provider>`__
            -  `Create a cloud media provider <https://developer.android.google.cn/guide/topics/providers/cloud-media-provider>`__

         -  `App install location <https://developer.android.google.cn/guide/topics/data/install-location>`__

      -  User data and identity

         -  `About user data <https://developer.android.google.cn/guide/user-data>`__
         -  `Add sign-in workflow <https://developer.android.google.cn/training/sign-in>`__

         -  Credential Manager

            -  `Sign in your user <https://developer.android.google.cn/training/sign-in/passkeys>`__
            -  `Integrate with Sign in with Google <https://developer.android.google.cn/training/sign-in/credential-manager>`__
            -  `Migrate from FIDO2 <https://developer.android.google.cn/training/sign-in/fido2-migration>`__
            -  `Migrate from Smart Lock <https://developer.android.google.cn/training/sign-in/smart-lock-migration>`__
            -  `Migrate from legacy Google Sign-In <https://developer.android.google.cn/training/sign-in/legacy-gsi-migration>`__
            -  `Integrate with WebView <https://developer.android.google.cn/training/sign-in/credential-manager-webview>`__
            -  `Integrate with your credential provider solution <https://developer.android.google.cn/training/sign-in/credential-provider>`__
            -  `Make calls on behalf of other parties for privileged apps <https://developer.android.google.cn/training/sign-in/privileged-apps>`__

         -  Autofill framework

            -  `About autofill <https://developer.android.google.cn/guide/topics/text/autofill>`__
            -  `Optimize your app for autofill <https://developer.android.google.cn/guide/topics/text/autofill-optimize>`__
            -  `Build autofill services <https://developer.android.google.cn/guide/topics/text/autofill-services>`__
            -  `Integrate autofill with keyboards <https://developer.android.google.cn/guide/topics/text/ime-autofill>`__

         -  `Show a biometric authentication dialog <https://developer.android.google.cn/training/sign-in/biometric-auth>`__
         -  `Identify developer-owned apps <https://developer.android.google.cn/training/articles/app-set-id>`__
         -  `Get a user-resettable advertising ID <https://developer.android.google.cn/training/articles/ad-id>`__
         -  `About the calendar provider <https://developer.android.google.cn/guide/topics/providers/calendar-provider>`__

         -  Contacts provider

            -  `About the contacts provider <https://developer.android.google.cn/guide/topics/providers/contacts-provider>`__
            -  `Retrieving a list of contacts <https://developer.android.google.cn/training/contacts-provider/retrieve-names>`__
            -  `Retrieving details for a contact <https://developer.android.google.cn/training/contacts-provider/retrieve-details>`__
            -  `Modifying contacts using intents <https://developer.android.google.cn/training/contacts-provider/modify-data>`__
            -  `Displaying the quick contact badge <https://developer.android.google.cn/training/contacts-provider/display-contact-badge>`__

         -  `Account transfer <https://developer.android.google.cn/guide/topics/data/account-transfer>`__

         -  Data backup

            -  `About backup <https://developer.android.google.cn/guide/topics/data/backup>`__
            -  `Back up user data <https://developer.android.google.cn/guide/topics/data/autobackup>`__
            -  `Back up key-value pairs <https://developer.android.google.cn/guide/topics/data/keyvaluebackup>`__
            -  `Test backup and restore <https://developer.android.google.cn/guide/topics/data/testingbackup>`__

         -  `Best practices for unique identifiers <https://developer.android.google.cn/training/articles/user-data-ids>`__

         -  Remember and authenticate users

            -  `About authentication <https://developer.android.google.cn/training/id-auth>`__
            -  `Remember your user <https://developer.android.google.cn/training/id-auth/identify>`__
            -  `Authenticate to OAuth2 services <https://developer.android.google.cn/training/id-auth/authenticate>`__
            -  `Create a custom account type <https://developer.android.google.cn/training/id-auth/custom_auth>`__

      -  `Add camera capabilities to your app ‚çà <https://developer.android.google.cn/media/camera/choose-camera-library>`__
      -  `User location ‚çà <https://developer.android.google.cn/develop/sensors-and-location/location>`__
      -  `Sensors ‚çà <https://developer.android.google.cn/develop/sensors-and-location/sensors/sensors_overview>`__
      -  `Connectivity ‚çà <https://developer.android.google.cn/develop/connectivity>`__

      -  Renderscript

         -  `About Renderscript <https://developer.android.google.cn/guide/topics/renderscript/compute>`__
         -  `Advanced RenderScript <https://developer.android.google.cn/guide/topics/renderscript/advanced>`__

         -  Migrate from RenderScript

            -  `Overview <https://developer.android.google.cn/guide/topics/renderscript/migrate>`__
            -  `Migrate scripts to OpenGL ES 3.1 <https://developer.android.google.cn/guide/topics/renderscript/migrate/migrate-gles>`__
            -  `Migrate scripts to Vulkan <https://developer.android.google.cn/guide/topics/renderscript/migrate/migrate-vulkan>`__

         -  Runtime API reference

            -  `About Runtime API <https://developer.android.google.cn/guide/topics/renderscript/reference/overview>`__
            -  `Numerical types <https://developer.android.google.cn/guide/topics/renderscript/reference/rs_value_types>`__
            -  `Object types <https://developer.android.google.cn/guide/topics/renderscript/reference/rs_object_types>`__
            -  `Conversion functions <https://developer.android.google.cn/guide/topics/renderscript/reference/rs_convert>`__
            -  `Mathematical constants and functions <https://developer.android.google.cn/guide/topics/renderscript/reference/rs_math>`__
            -  `Vector math functions <https://developer.android.google.cn/guide/topics/renderscript/reference/rs_vector_math>`__
            -  `Matrix functions <https://developer.android.google.cn/guide/topics/renderscript/reference/rs_matrix>`__
            -  `Quaternion functions <https://developer.android.google.cn/guide/topics/renderscript/reference/rs_quaternion>`__
            -  `Atomic update functions <https://developer.android.google.cn/guide/topics/renderscript/reference/rs_atomic>`__
            -  `Time functions and types <https://developer.android.google.cn/guide/topics/renderscript/reference/rs_time>`__
            -  `Allocation data access functions <https://developer.android.google.cn/guide/topics/renderscript/reference/rs_allocation_data>`__
            -  `Object characteristics functions <https://developer.android.google.cn/guide/topics/renderscript/reference/rs_object_info>`__
            -  `Kernel invocation functions and types <https://developer.android.google.cn/guide/topics/renderscript/reference/rs_for_each>`__
            -  `Input/output functions <https://developer.android.google.cn/guide/topics/renderscript/reference/rs_io>`__
            -  `Debugging functions <https://developer.android.google.cn/guide/topics/renderscript/reference/rs_debug>`__
            -  `Graphics functions and types <https://developer.android.google.cn/guide/topics/renderscript/reference/rs_graphics>`__
            -  `Index <https://developer.android.google.cn/guide/topics/renderscript/reference>`__

      -  Android app bundles

         -  `About app bundles <https://developer.android.google.cn/guide/app-bundle>`__
         -  `Configure the base module <https://developer.android.google.cn/guide/app-bundle/configure-base>`__
         -  `Build and test your app bundle <https://developer.android.google.cn/guide/app-bundle/test>`__
         -  `Add code transparency <https://developer.android.google.cn/guide/app-bundle/code-transparency>`__
         -  `About the app bundle format <https://developer.android.google.cn/guide/app-bundle/app-bundle-format>`__
         -  `Frequently asked questions <https://developer.android.google.cn/guide/app-bundle/faq>`__

      -  `SDK Extensions <https://developer.android.google.cn/guide/sdk-extensions>`__

   - Build for enterprise

      -  `About enterprise apps <https://developer.android.google.cn/work>`__
      -  `Developer guide <https://developer.android.google.cn/work/guide>`__
      -  `Work profiles <https://developer.android.google.cn/work/managed-profiles>`__
      -  `Set up managed configurations <https://developer.android.google.cn/work/managed-configurations>`__

      -  App feedback

         -  `Send app feedback to EMMs <https://developer.android.google.cn/work/app-feedback/overview>`__
         -  `Test app feedback <https://developer.android.google.cn/work/app-feedback/testing>`__

      -  `Work contacts <https://developer.android.google.cn/work/contacts>`__
      -  `Device management policies <https://developer.android.google.cn/work/device-management-policy>`__

      -  Device management

         -  `Build a device policy controller <https://developer.android.google.cn/work/dpc/build-dpc>`__

         -  Dedicated devices

            -  `Overview <https://developer.android.google.cn/work/dpc/dedicated-devices>`__
            -  `Lock task mode <https://developer.android.google.cn/work/dpc/dedicated-devices/lock-task-mode>`__
            -  `Multiple users <https://developer.android.google.cn/work/dpc/dedicated-devices/multiple-users>`__
            -  `Cookbook <https://developer.android.google.cn/work/dpc/dedicated-devices/cookbook>`__

         -  `Device control <https://developer.android.google.cn/work/dpc/device-management>`__
         -  `Networking and telephony <https://developer.android.google.cn/work/dpc/network-telephony>`__
         -  `Security <https://developer.android.google.cn/work/dpc/security>`__
         -  `System updates <https://developer.android.google.cn/work/dpc/system-updates>`__
         -  `Network activity logging <https://developer.android.google.cn/work/dpc/logging>`__

      -  Android versions

         -  `About the versions <https://developer.android.google.cn/work/versions>`__
         -  `Android 14 <https://developer.android.google.cn/work/versions/android-14>`__
         -  `Android 13 <https://developer.android.google.cn/work/versions/android-13>`__
         -  `Android 12 <https://developer.android.google.cn/work/versions/android-12>`__
         -  `Android 11 <https://developer.android.google.cn/work/versions/android-11>`__
         -  `Android 10 <https://developer.android.google.cn/work/versions/android-10>`__
         -  `Android 9 <https://developer.android.google.cn/work/versions/android-9.0>`__
         -  `Android 8.0 <https://developer.android.google.cn/work/versions/android-8.0>`__
         -  `Android 7.0 <https://developer.android.google.cn/work/versions/android-7.0>`__

      -  `Device administration <https://developer.android.google.cn/work/device-admin>`__

   - Best practices

      -  Testing

         -  `Test apps on Android <https://developer.android.google.cn/training/testing>`__

         -  Fundamentals

            -  `Fundamentals of testing Android apps <https://developer.android.google.cn/training/testing/fundamentals>`__
            -  `What to test in Android <https://developer.android.google.cn/training/testing/fundamentals/what-to-test>`__
            -  `Using test doubles in Android <https://developer.android.google.cn/training/testing/fundamentals/test-doubles>`__

         -  Local tests

            -  `Build local tests <https://developer.android.google.cn/training/testing/local-tests>`__

         -  Instrumented tests

               -  `Build instrumented tests <https://developer.android.google.cn/training/testing/instrumented-tests>`__
               -  `Automate UI tests <https://developer.android.google.cn/training/testing/instrumented-tests/ui-tests>`__

               - AndroidX test libraries

                  -  `Set up project for AndroidX Test <https://developer.android.google.cn/training/testing/instrumented-tests/androidx-test-libraries/test-setup>`__
                  -  `JUnit4 rules with AndroidX Test <https://developer.android.google.cn/training/testing/instrumented-tests/androidx-test-libraries/rules>`__
                  -  `AndroidJUnitRunner <https://developer.android.google.cn/training/testing/instrumented-tests/androidx-test-libraries/runner>`__

         -  Continuous integration

            -  `Basics <https://developer.android.google.cn/training/testing/continuous-integration>`__
            -  `Types of automation <https://developer.android.google.cn/training/testing/continuous-integration/automation>`__
            -  `Common features <https://developer.android.google.cn/training/testing/continuous-integration/features>`__

         -  Espresso

            -  `Espresso <https://developer.android.google.cn/training/testing/espresso>`__
            -  `Espresso basics <https://developer.android.google.cn/training/testing/espresso/basics>`__
            -  `Espresso setup instructions <https://developer.android.google.cn/training/testing/espresso/setup>`__
            -  `Espresso cheat sheet <https://developer.android.google.cn/training/testing/espresso/cheat-sheet>`__
            -  `Espresso idling resources <https://developer.android.google.cn/training/testing/espresso/idling-resource>`__
            -  `Espresso-Intents <https://developer.android.google.cn/training/testing/espresso/intents>`__
            -  `Espresso lists <https://developer.android.google.cn/training/testing/espresso/lists>`__
            -  `Multiprocess Espresso <https://developer.android.google.cn/training/testing/espresso/multiprocess>`__
            -  `Espresso recipes <https://developer.android.google.cn/training/testing/espresso/recipes>`__
            -  `Espresso Web <https://developer.android.google.cn/training/testing/espresso/web>`__
            -  `Accessibility checking <https://developer.android.google.cn/training/testing/espresso/accessibility-checking>`__
            -  `Additional Resources for Espresso <https://developer.android.google.cn/training/testing/espresso/additional-resources>`__

         -  Testing different screen sizes

            -  `Overview <https://developer.android.google.cn/training/testing/different-screens>`__
            -  `Libraries and tools <https://developer.android.google.cn/training/testing/different-screens/tools>`__

         -  Testing other components

            -  `Test content providers <https://developer.android.google.cn/training/testing/other-components/content-providers>`__
            -  `Test your service <https://developer.android.google.cn/training/testing/other-components/services>`__
            -  `Write automated tests with UI Automator <https://developer.android.google.cn/training/testing/other-components/ui-automator>`__

      -  `Performance ‚çà <https://developer.android.google.cn/topic/performance>`__
      -  `Accessibility ‚çà <https://developer.android.google.cn/guide/topics/ui/accessibility>`__
      -  `Privacy ‚çà <https://developer.android.google.cn/privacy-and-security/about>`__
      -  `Security ‚çà <https://developer.android.google.cn/privacy-and-security/security-tips>`__

      -  SDKs

        -  `SDK best practices <https://developer.android.google.cn/guide/practices/sdk-best-practices>`__

   -  `Games ‚çà <https://developer.android.google.cn/games/guides>`__
   -  `Health Connect ‚çà <https://developer.android.google.cn/health-and-fitness/guides/health-connect>`__
   -  `Health Services on Wear OS ‚çà <https://developer.android.google.cn/health-and-fitness/guides/health-services>`__


/Developer guides
=================

.. https://developer.android.google.cn/guide

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   Welcome to the Android developer guides. These documents teach you
   how to build Android apps using APIs in the Android framework and
   other libraries.

   If you're brand new to Android and want to jump into code, start with
   the `Build your first Android app <#>`__
   tutorial.

   And check out these other resources to learn Android development:

   -  `Codelabs <https://developers.google.cn/codelabs/?cat=Android>`__:
      Short, self-paced tutorials that each cover a discrete topic. Most
      codelabs step you through the process of building a small app, or
      adding a new feature to an existing app.
   -  `Courses <#>`__: Guided training paths that teach you how
      to build Android apps.

   Otherwise, the following is a small selection of essential developer
   guides that you should be familiar with.

   .. container:: section dac-section dac-small
      :name: essential

      .. container:: wrap

         .. rubric:: Essential documentation
            :name: essential-documentation
            :class: norule



   .. container:: devsite-card

      .. image:: https://developer.android.google.cn/static/images/components/intent-filters_2x.png 
         :class: devsite-card-image 
         :target: https://developer.android.google.cn/guide/components/intents-filters?hl=en

         .. rubric:: Intents and intent filters
            :name: intents-and-intent-filters

         An Intent is a messaging object you can use to
         request an action from another app component.
         Although intents facilitate communication between
         components in several ways, there are three
         fundamental use cases: An Activity represents a
         single screen



   .. container:: devsite-card

      .. image:: https://developer.android.google.cn/static/images/android-compose-ui-logo.png 
         :class: devsite-card-image 
         :target: https://developer.android.google.cn/develop/ui/views/animations/overview?hl=en

         .. rubric:: Introduction to animations
            :name: introduction-to-animations

         Animations can add visual cues that notify users
         about what's going on in your app. They are
         especially useful when the UI changes state, such
         as when new content loads or new actions become
         available. Animations also add a polished look to
         your app,



   .. container:: devsite-card

      .. image:: https://developer.android.google.cn/static/images/training/data-storage/room_architecture.png 
         :class: devsite-card-image 
         :target: https://developer.android.google.cn/training/data-storage?hl=en

         .. rubric:: Data and file storage overview
            :name: data-and-file-storage-overview

         Android uses a file system that's similar to
         disk-based file systems on other platforms. The
         system provides several options for you to save
         your app data: The characteristics of these options
         are summarized in the following table: The solution
         you



   .. container:: devsite-card

      .. image:: https://developer.android.google.cn/static/images/android-compose-ui-logo.png 
         :class: devsite-card-image 
         :target: https://developer.android.google.cn/develop/ui/views/theming/themes?hl=en

         .. rubric:: Styles and themes
            :name: styles-and-themes

         Styles and themes on Android let you separate the
         details of your app design from the UI structure
         and behavior, similar to stylesheets in web design.
         A style is a collection of attributes that
         specifies the appearance for a single View. A style
         can



   .. container:: devsite-card

      .. image:: https://developer.android.google.cn/static/images/social/android-developers.png 
         :class: devsite-card-image 
         :target: https://developer.android.google.cn/develop/sensors-and-location/location/request-updates?hl=en

         .. rubric:: Request location updates
            :name: request-location-updates

         Appropriate use of location information can be
         beneficial to users of your app. For example, if
         your app helps the user find their way while
         walking or driving, or if your app tracks the
         location of assets, it needs to get the location of
         the device



   .. container:: devsite-card

      .. image:: https://developer.android.google.cn/static/images/android-7.0/notifications-card.png 
         :class: devsite-card-image 
         :target: https://developer.android.google.cn/develop/ui/views/notifications?hl=en

         .. rubric:: Notifications overview
            :name: notifications-overview

         A notification is a message that Android displays
         outside your app's UI to provide the user with
         reminders, communication from other people, or
         other timely information from your app. Users can
         tap the notification to open your app or take an
         action



   .. container:: devsite-card

      .. image:: https://developer.android.google.cn/static/images/screens_support/devices_2x.png 
         :class: devsite-card-image 
         :target: https://developer.android.google.cn/guide/practices/screens_support?hl=en

         .. rubric:: Screen compatibility overview
            :name: screen-compatibility-overview

         Android runs on a variety of devices that have
         different screen sizes and pixel densities. The
         system performs basic scaling and resizing to adapt
         your user interface to different screens, but there
         are ways to help your UI adapt better to each



   .. container:: devsite-card

      .. image:: https://developer.android.google.cn/static/images/picto-icons/measurement.svg :class: devsite-card-image 
      :target: https://developer.android.google.cn/topic/performance/overview?hl=en


         .. rubric:: App performance guide
            :name: app-performance-guide

         This guide provides an overview of libraries,
         tools, and best practices to inspect, improve, and
         monitor performance on Android.



   .. container:: devsite-card

      .. image:: https://developer.android.google.cn/static/images/layoutparams.png 
         :class: devsite-card-image 
         :target: https://developer.android.google.cn/develop/ui/views/layout/declaring-layout?hl=en

         .. rubric:: Views
            :name: views

         Develop your UI on Android.



   .. container:: devsite-card

      .. image:: https://developer.android.google.cn/static/images/resources/resource_devices_diagram2.png 
         :class: devsite-card-image 
         :target: https://developer.android.google.cn/guide/topics/resources/providing-resources?hl=en

         .. rubric:: App resources overview
            :name: app-resources-overview

         Resources are the additional files and static
         content that your code uses, such as bitmaps,
         layout definitions, user interface strings,
         animation instructions, and more. Always
         externalize app resources such as images and
         strings from your code, so



   .. container:: devsite-card

      .. image:: https://developer.android.google.cn/static/images/training/permissions/workflow-overview.svg :class: devsite-card-image 
         :target: https://developer.android.google.cn/games/develop/permissions?hl=en

         .. rubric:: Determine sensitive data access needs
            :name: determine-sensitive-data-access-needs

         App permissions help support user privacy by
         protecting access to the following: This page
         provides an overview to how Android permissions
         work, including a high-level workflow for using
         permissions, descriptions of different types of
         permissions,


   .. container:: devsite-card

      .. image:: https://developer.android.google.cn/static/images/social/android-developers.png 
         :class: devsite-card-image 
         :target: https://developer.android.google.cn/guide/components/fundamentals?hl=en

         .. rubric:: Application fundamentals
            :name: application-fundamentals

         Android apps can be written using Kotlin, the Java
         programming language, and C++ languages. The
         Android SDK tools compile your code along with any
         data and resource files into an APK or an Android
         App Bundle. An Android package, which is an archive


   .. container:: devsite-card

      .. image:: https://developer.android.google.cn/static/images/social/android-developers.png 
         :class: devsite-card-image 
         :target: https://developer.android.google.cn/topic/arc?hl=en

         .. rubric:: Start building apps for ChromeOS
            :name: start-building-apps-for-chromeos

         ChromeOS devices, such as Chromebooks, support the
         Google Play Store and Android apps. This article
         assumes you have an existing Android app designed
         for phones or tablets that you want to optimize for
         Chromebooks. To learn the basics of building


   .. container:: devsite-card

      .. image:: https://developer.android.google.cn/static/design/tv/images/focus.png 
         :class: devsite-card-image 
         :target: https://developer.android.google.cn/training/tv/start?hl=en

         .. rubric:: Build TV apps
            :name: build-tv-apps

         Android offers a rich user experience that's
         optimized for apps running on large screen devices,
         such as high-definition televisions. Apps on TV
         offer new opportunities to delight your users from
         the comfort of their couch. TV apps use the same


Last updated 2023-06-05 UTC.


/Application fundamentals
=========================

.. container:: devsite-article-body clearfix

   Android apps can be written using Kotlin, the Java programming
   language, and C++ languages. The Android SDK tools compile your code
   along with any data and resource files into an APK or an Android App
   Bundle.

   An *Android package*, which is an archive file with an ``.apk``
   suffix, contains the contents of an Android app required at runtime,
   and it is the file that Android-powered devices use to install the
   app.

   An Android App Bundle, which is an archive file with an ``.aab``
   suffix, contains the contents of an Android app project, including
   some additional metadata that isn't required at runtime. An AAB is a
   publishing format and can't be installed on Android devices. It
   defers APK generation and signing to a later stage.

   When distributing your app through Google Play, for example, Google
   Play's servers generate optimized APKs that contain only the
   resources and code that are required by the particular device
   requesting installation of the app.

   Each Android app lives in its own security sandbox, protected by the
   following Android security features:

   -  The Android operating system is a multi-user Linux system in which
      each app is a different user.
   -  By default, the system assigns each app a unique Linux user ID,
      which is used only by the system and is unknown to the app. The
      system sets permissions for all the files in an app so that only
      the user ID assigned to that app can access them.
   -  Each process has its own virtual machine (VM), so an app's code
      runs in isolation from other apps.
   -  By default, every app runs in its own Linux process. The Android
      system starts the process when any of the app's components need to
      be executed, and then shuts down the process when it's no longer
      needed or when the system must recover memory for other apps.

   The Android system implements the *principle of least privilege*.
   That is, each app, by default, has access only to the components that
   it requires to do its work and no more. This creates a very secure
   environment in which an app can't access parts of the system it is
   not given permission for.

   However, there are ways for an app to share data with other apps and
   for an app to access system services:

   -  It's possible to arrange for two apps to share the same Linux user
      ID, in which case they are able to access each other's files. To
      conserve system resources, apps with the same user ID can also
      arrange to run in the same Linux process and share the same VM.
      The apps must also be signed with the same certificate.
   -  An app can request permission to access device data such as the
      device's location, camera, and Bluetooth connection. The user has
      to explicitly grant these permissions. For more information about
      permissions, see `Permissions on Android <#>`__.

   The rest of this document introduces the following concepts:

   -  The core framework components that define your app.
   -  The manifest file in which you declare the components and the
      required device features for your app.
   -  Resources that are separate from the app code and that let your
      app gracefully optimize its behavior for a variety of device
      configurations.

   .. rubric:: App components
      :name: Components

   App components are the essential building blocks of an Android app.
   Each component is an entry point through which the system or a user
   can enter your app. Some components depend on others.

   There are four types of app components:

   -  Activities
   -  Services
   -  Broadcast receivers
   -  Content providers

   Each type serves a distinct purpose and has a distinct lifecycle that
   defines how a component is created and destroyed. The following
   sections describe the four types of app components.

   **Activities**
      An *activity* is the entry point for interacting with the user. It
      represents a single screen with a user interface. For example, an
      email app might have one activity that shows a list of new emails,
      another activity to compose an email, and another activity for
      reading emails. Although the activities work together to form a
      cohesive user experience in the email app, each one is independent
      of the others.

      A different app can start any one of these activities if the email
      app allows it. For example, a camera app might start the activity
      in the email app for composing a new email to let the user share a
      picture.

      An activity facilitates the following key interactions between
      system and app:

      -  Keeping track of what the user currently cares about‚Äîwhat is
         on-screen‚Äîso that the system keeps running the process that is
         hosting the activity.
      -  Knowing which previously used processes contain stopped
         activities the user might return to and prioritizing those
         processes more highly to keep them available.
      -  Helping the app handle having its process killed so the user
         can return to activities with their previous state restored.
      -  Providing a way for apps to implement user flows between each
         other, and for the system to coordinate these flows. The
         primary example of this is sharing.

      You implement an activity as a subclass of the
      `Activity <#>`__ class. For more
      information about the ``Activity`` class, see `Introduction to activities <#>`__.

   **Services**
      A *service* is a general-purpose entry point for keeping an app
      running in the background for all kinds of reasons. It is a
      component that runs in the background to perform long-running
      operations or to perform work for remote processes. A service does
      not provide a user interface.

      For example, a service might play music in the background while
      the user is in a different app, or it might fetch data over the
      network without blocking user interaction with an activity.
      Another component, such as an activity, can start the service and
      let it run or bind to it to interact with it.

      There are two types of services that tell the system how to manage
      an app: started services and bound services.

      **Started services** tell the system to keep them running until
      their work is completed. This might be to sync some data in the
      background or play music even after the user leaves the app.
      Syncing data in the background or playing music represent
      different types of started services, which the system handles
      differently:

      -  Music playback is something the user is directly aware of, and
         the app communicates this to the system by indicating that it
         wants to be in the foreground, with a notification to tell the
         user that it is running. In this case, the system prioritizes
         keeping that service's process running, because the user has a
         bad experience if it goes away.
      -  A regular background service is not something the user is
         directly aware of, so the system has more freedom in managing
         its process. It might let it be killed, restarting the service
         sometime later, if it needs RAM for things that are of more
         immediate concern to the user.

      **Bound services** run because some other app (or the system) has
      said that it wants to make use of the service. A bound service
      provides an API to another process, and the system knows there is
      a dependency between these processes. So if process A is bound to
      a service in process B, the system knows that it needs to keep
      process B and its service running for A. Further, if process A is
      something the user cares about, then it knows to treat process B
      as something the user also cares about.

      Because of their flexibility, services are useful building blocks
      for all kinds of higher-level system concepts. Live wallpapers,
      notification listeners, screen savers, input methods,
      accessibility services, and many other core system features are
      all built as services that applications implement and the system
      binds to when they run.

      A service is implemented as a subclass of
      `Service <#>`__. For more
      information about the ``Service`` class, see the `Services overview <#>`__.

      **Note:** If your app targets Android 5.0 (API level 21) or
      higher, use the `JobScheduler <#>`__
      class to schedule actions. JobScheduler has the advantage of
      conserving battery by optimally scheduling jobs to reduce power
      consumption and by working with the `Doze <#>`__ API. For
      more information about using this class, see the
      `JobScheduler <#>`__ reference documentation.

   **Broadcast receivers**
      A *broadcast receiver* is a component that lets the system deliver
      events to the app outside of a regular user flow so the app can
      respond to system-wide broadcast announcements. Because broadcast
      receivers are another well-defined entry into the app, the system
      can deliver broadcasts even to apps that aren't currently running.

      So, for example, an app can schedule an alarm to post a
      notification to tell the user about an upcoming event. Because the
      alarm is delivered to a ``BroadcastReceiver`` in the app, there is
      no need for the app to remain running until the alarm goes off.

      Many broadcasts originate from the system, like a broadcast
      announcing that the screen is turned off, the battery is low, or a
      picture is captured. Apps can also initiate broadcasts, such as to
      let other apps know that some data is downloaded to the device and
      is available for them to use.

      Although broadcast receivers don't display a user interface, they
      can `create a status bar notification <#>`__ to alert the
      user when a broadcast event occurs. More commonly, though, a
      broadcast receiver is just a *gateway* to other components and is
      intended to do a very minimal amount of work.

      For instance, a broadcast receiver might schedule a
      `JobService <#>`__ to perform some work based on an event using
      `JobScheduler <#>`__.
      Broadcast receivers often involve apps interacting with each
      other, so it's important to be aware of the security implications
      when setting them up.

      A broadcast receiver is implemented as a subclass of
      `BroadcastReceiver <#>`__, and each broadcast is delivered as an
      `Intent <#>`__ object. For more information, see the
      `BroadcastReceiver <#>`__
      class.

   **Content providers**
      A *content provider* manages a shared set of app data that you can
      store in the file system, in a SQLite database, on the web, or on
      any other persistent storage location that your app can access.
      Through the content provider, other apps can query or modify the
      data, if the content provider permits it.

      For example, the Android system provides a content provider that
      manages the user's contact information. Any app with the proper
      permissions can query the content provider, such as using
      `ContactsContract.Data <#>`__,
      to read and write information about a particular person.

      It is tempting to think of a content provider as an abstraction on
      a database, because there is a lot of API and support built in to
      them for that common case. However, they have a different core
      purpose from a system-design perspective.

      To the system, a content provider is an entry point into an app
      for publishing named data items, identified by a URI scheme. Thus,
      an app can decide how it wants to map the data it contains to a
      URI namespace, handing out those URIs to other entities which can
      in turn use them to access the data. There are a few particular
      things this lets the system do in managing an app:

      -  Assigning a URI doesn't require that the app remain running, so
         URIs can persist after their owning apps exit. The system only
         needs to make sure that an owning app is still running when it
         retrieves the app's data from the corresponding URI.
      -  These URIs also provide an important fine-grained security
         model. For example, an app can place the URI for an image it
         has on the clipboard, but leave its content provider locked up
         so that other apps cannot freely access it. When a second app
         attempts to access that URI on the clipboard, the system can
         let that app access the data using a temporary *URI permission
         grant* so that it accesses the data only behind that URI, and
         nothing else in the second app.

      Content providers are also useful for reading and writing data
      that is private to your app and not shared.

      A content provider is implemented as a subclass of
      `ContentProvider <#>`__
      and must implement a standard set of APIs that enable other apps
      to perform transactions. For more information, see the 
      `Content providers <#>`__ developer guide.

   A unique aspect of the Android system design is that any app can
   start another app‚Äôs component. For example, if you want the user to
   capture a photo with the device camera, there's probably another app
   that does that‚Äîand your app can use it instead of developing an
   activity to capture a photo yourself. You don't need to incorporate
   or even link to the code from the camera app. Instead, you can start
   the activity in the camera app that captures a photo. When complete,
   the photo is even returned to your app so you can use it. To the
   user, it seems as if the camera is actually a part of your app.

   When the system starts a component, it starts the process for that
   app, if it's not already running, and instantiates the classes needed
   for the component. For example, if your app starts the activity in
   the camera app that captures a photo, that activity runs in the
   process that belongs to the camera app, not in your app's process.
   Therefore, unlike apps on most other systems, Android apps don't have
   a single entry point: there's no ``main()`` function.

   Because the system runs each app in a separate process with file
   permissions that restrict access to other apps, your app can't
   directly activate a component from another app. However, the Android
   system can. To activate a component in another app, you deliver a
   message to the system that specifies your *intent* to start a
   particular component. The system then activates the component for
   you.

   .. rubric:: Activate components
      :name: ActivatingComponents

   An asynchronous message called an *intent* activates three of the
   four component types: activities, services, and broadcast receivers.
   Intents bind individual components to each other at runtime. You can
   think of them as the messengers that request an action from other
   components, whether the component belongs to your app or another.

   An intent is created with an
   `Intent <#>`__ object, which
   defines a message to activate either a specific component (an
   *explicit* intent) or a specific type of component (an *implicit*
   intent).

   For activities and services, an intent defines the action to perform,
   such as to *view* or *send* something, and might specify the URI of
   the data to act on, among other things that the component being
   started might need to know.

   For example, an intent might convey a request for an activity to show
   an image or to open a web page. In some cases, you can start an
   activity to receive a result, in which case the activity also returns
   the result in an ``Intent``. You can also issue an intent to let the
   user pick a personal contact and have it returned to you. The return
   intent includes a URI pointing to the chosen contact.

   For broadcast receivers, the intent defines the broadcast
   announcement. For example, a broadcast to indicate that the device
   battery is low includes only a known action string that indicates
   *battery is low*.

   Unlike activities, services, and broadcast receivers, content
   providers are activated when targeted by a request from a
   `ContentResolver <#>`__.
   The content resolver handles all direct transactions with the content
   provider, and the component performing transactions with the provider
   calls methods on the ``ContentResolver`` object. This leaves a layer
   of abstraction for security reasons between the content provider and
   the component requesting information.

   There are separate methods for activating each type of component:

   -  You can start an activity or give it something new to do by
      passing an ``Intent`` to
      `startActivity() <#startActivity>`__
      or, when you want the activity to return a result,
      `startActivityForResult() <#startActivityForResult>`__.
   -  On Android 5.0 (API level 21) and higher, you can use the
      `JobScheduler <#>`__
      class to schedule actions. For earlier Android versions, you can
      start a service or give new instructions to an ongoing service by
      passing an ``Intent`` to
      `startService() <#startService>`__.
      You can bind to the service by passing an ``Intent`` to
      `bindService() <#bindService>`__.
   -  You can initiate a broadcast by passing an ``Intent`` to methods
      such as `sendBroadcast() <#sendBroadcast>`__
      or `sendOrderedBroadcast() <#sendOrderedBroadcast>`__.
   -  You can perform a query to a content provider by calling
      `query() <#query>`__
      on a ``ContentResolver``.

   For more information about using intents, see the `Intents and Intent Filters <#>`__ document. The
   following documents provide more information about activating
   specific components: `Introduction to activities <#>`__,
   `Services overview <#>`__, `BroadcastReceiver <#>`__,
   and `Content providers <#>`__.

   .. rubric:: The manifest file
      :name: Manifest

   Before the Android system can start an app component, the system must
   know that the component exists by reading the app's *manifest file*,
   ``AndroidManifest.xml``. Your app declares all its components in this
   file, which is at the root of the app project directory.

   The manifest does a number of things in addition to declaring the
   app's components, such as the following:

   -  Identifies any user permissions the app requires, such as internet
      access or read-access to the user's contacts.
   -  Declares the minimum `API level <#ApiLevels>`__
      required by the app, based on which APIs the app uses.
   -  Declares hardware and software features used or required by the
      app, such as a camera, Bluetooth services, or a multitouch screen.
   -  Declares API libraries the app needs to be linked against (other
      than the Android framework APIs), such as the `Google Maps library <http://code.google.com/android/add-ons/google-apis/maps-overview.html>`__.

   .. rubric:: Declare components
      :name: DeclaringComponents

   The primary task of the manifest is to inform the system about the
   app's components. For example, a manifest file can declare an
   activity as follows:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <manifest ... >
          <application android:icon="@drawable/app_icon.png" ... >
              <activity android:name="com.example.project.ExampleActivity"
                        android:label="@string/example_label" ... >
              </activity>
              ...
          </application>
      </manifest>

   In the ``<application>``
   element, the ``android:icon`` attribute points to resources for an
   icon that identifies the app.

   In the ``<activity>``
   element, the ``android:name`` attribute specifies the fully qualified
   class name of the `Activity <#>`__
   subclass, and the ``android:label`` attribute specifies a string to
   use as the user-visible label for the activity.

   You must declare all app components using the following elements:

   -  ``<activity>`` elements for activities
   -  ``<service>`` elements for services
   -  ``<receiver>`` elements for broadcast receivers
   -  ``<provider>`` elements for content providers

   Activities, services, and content providers that you include in your
   source but don't declare in the manifest aren't visible to the system
   and, consequently, can never run. However, broadcast receivers can
   either be declared in the manifest or created dynamically in code as
   `BroadcastReceiver <#>`__
   objects and registered with the system by calling
   `registerReceiver() <#registerReceiver>`__.

   For more about how to structure the manifest file for your app, see
   the `App manifest overview <#>`__.

   .. rubric:: Declare component capabilities
      :name: DeclaringComponentCapabilities

   As discussed in the `Activate components <#ActivatingComponents>`__
   section, you can use an `Intent <#>`__ to start
   activities, services, and broadcast receivers. You do this by
   explicitly naming the target component, using the component class
   name, in the intent. You can also use an implicit intent, which
   describes the type of action to perform and, optionally, the data you
   want to perform the action on. An implicit intent lets the system
   find a component on the device that can perform the action and start
   it. If there are multiple components that can perform the action
   described by the intent, the user selects which one to use.

   **Caution:** If you use an intent to start a
   `Service <#>`__, make sure that your
   app is secure by using an `explicit <#Types>`__ intent. Using
   an implicit intent to start a service is a security hazard, because
   you can't be certain what service responds to the intent and the user
   can't see which service starts. Beginning with Android 5.0 (API level
   21), the system throws an exception if you call
   `bindService() <#bindService>`__
   with an implicit intent. Don't declare intent filters for your
   services.

   The system identifies the components that can respond to an intent by
   comparing the intent received to the *intent filters* provided in the
   manifest file of other apps on the device.

   When you declare an activity in your app's manifest, you can
   optionally include intent filters that declare the capabilities of
   the activity so it can respond to intents from other apps. You do
   this by adding an
   ``<intent-filter>``
   element as a child of the component's declaration element.

   For example, if you build an email app with an activity for composing
   a new email, you can declare an intent filter to respond to "send"
   intents to send a new email, as shown in the following example:

   .. code:: prettyprint

      <manifest ... >
          ...
          <application ... >
              <activity android:name="com.example.project.ComposeEmailActivity">
                  <intent-filter>
                      <action android:name="android.intent.action.SEND" />
                      <data android:type="*/*" />
                      <category android:name="android.intent.category.DEFAULT" />
                  </intent-filter>
              </activity>
          </application>
      </manifest>

   If another app creates an intent with the
   `ACTION_SEND <#ACTION_SEND>`__ action and passes it to
   `startActivity() <#startActivity>`__,
   the system might start your activity so the user can draft and send
   an email.

   For more about creating intent filters, see the `Intents and Intent Filters <#>`__ document.

   .. rubric:: Declare app requirements
      :name: DeclaringRequirements

   There are a variety of devices powered by Android, and not all of
   them provide the same features and capabilities. To prevent your app
   from being installed on devices that lack features needed by your
   app, it's important that you clearly define a profile for the types
   of devices your app supports by declaring device and software
   requirements in your manifest file.

   Most of these declarations are informational only. The system doesn't
   read them, but external services such as Google Play do read them to
   provide filtering for users when they search for apps from their
   device.

   For example, suppose your app requires a camera and uses APIs
   introduced in Android 8.0 (API level 26). You must declare these
   requirements. The values for ``minSdkVersion`` and
   ``targetSdkVersion`` are set in your app module's ``build.gradle``
   file:

   .. code:: prettyprint

      android {
        ...
        defaultConfig {
          ...
          minSdkVersion 26
          targetSdkVersion 29
        }
      }

   **Note:** Don't set ``minSdkVersion`` and ``targetSdkVersion``
   directly in the manifest file, since they are overwritten by Gradle
   during the build process. For more information, see `Specify API level requirements <#minsdk>`__.

   You declare the camera feature in your app's manifest file:

   .. code:: prettyprint

      <manifest ... >
          <uses-feature android:name="android.hardware.camera.any"
                        android:required="true" />
          ...
      </manifest>

   With the declarations shown in these examples, devices that do *not*
   have a camera or have an Android version *lower* than 8.0 can't
   install your app from Google Play. However, you can also declare that
   your app uses the camera, but does not *require* it. To do so, you
   set the
   `required <#required>`__
   attribute to ``false``, check at runtime whether the device has a
   camera, and disable any camera features as needed.

   More information about how you can manage your app's compatibility
   with different devices is provided in the `Device compatibility overview <#>`__.

   .. rubric:: App resources
      :name: Resources

   An Android app is composed of more than just code. It requires
   resources that are separate from the source code, such as images,
   audio files, and anything relating to the visual presentation of the
   app. For example, you can define animations, menus, styles, colors,
   and the layout of activity user interfaces with XML files.

   Using app resources makes it easy to update various characteristics
   of your app without modifying code. Providing sets of alternative
   resources lets you optimize your app for a variety of device
   configurations, such as different languages and screen sizes.

   For every resource that you include in your Android project, the SDK
   build tools define a unique integer ID, which you can use to
   reference the resource from your app code or from other resources
   defined in XML. For example, if your app contains an image file named
   ``logo.png`` (saved in the ``res/drawable/`` directory), the SDK
   tools generate a resource ID named ``R.drawable.logo``. This ID maps
   to an app-specific integer, which you can use to reference the image
   and insert it in your user interface.

   One of the most important aspects of providing resources separate
   from your source code is the ability to provide alternative resources
   for different device configurations.

   For example, by defining UI strings in XML, you can translate the
   strings into other languages and save those strings in separate
   files. Then Android applies the appropriate language strings to your
   UI based on a language *qualifier* that you append to the resource
   directory's name, such as ``res/values-fr/`` for French string
   values, and the user's language setting.

   Android supports many qualifiers for your alternative resources. The
   qualifier is a short string that you include in the name of your
   resource directories to define the device configuration those
   resources are used for.

   For example, you can create different layouts for your activities
   depending on the device's screen orientation and size. When the
   device screen is in portrait (tall) orientation, you might want a
   layout with buttons arranged vertically, but when the screen is in
   landscape (wide) orientation, you might want the buttons aligned
   horizontally. To change the layout depending on the orientation, you
   can define two layouts and apply the appropriate qualifier to each
   layout's directory name. Then, the system automatically applies the
   appropriate layout depending on the current device orientation.

   For more information about the different kinds of resources you can
   include in your application and how to create alternative resources
   for different device configurations, read the `App resources overview <#>`__. To learn
   more about best practices and designing robust, production-quality
   apps, see the `Guide to app architecture <#>`__.

   .. rubric:: Additional resources
      :name: Resources

   To learn Android development using videos and code tutorials, see the
   `Developing Android Apps with Kotlin <https://www.udacity.com/course/ud9012>`__ Udacity course.

   .. container:: cols

      .. container:: col-1of2

         .. rubric:: Continue reading about:
            :name: continue-reading-about:
            :class: hide-from-toc

         `Intents and Intent Filters <#>`__
            Learn how to use the
            `Intent <#>`__ APIs to
            activate app components, such as activities and services,
            and how to make your app components available for use by
            other apps.
         `Introduction to activities <#>`__
            Learn how to create an instance of the
            `Activity <#>`__ class,
            which provides a distinct screen in your application with a
            user interface.
         `App resources overview <#>`__
            Learn how Android apps are structured to separate app
            resources from the app code, including how you can provide
            alternative resources for specific device configurations.

      .. container:: col-1of2

         .. rubric:: Also of interest:
            :name: also-of-interest:
            :class: hide-from-toc

         `Device compatibility overview <#>`__
            Learn how Android works on different types of devices and
            how you can optimize your app for each device or restrict
            your app's availability to different devices.
         `Permissions on Android <#>`__
            Learn how Android restricts app access to certain APIs with
            a permission system that requires the user's consent for
            your app to use those APIs.

Last updated 2023-10-10 UTC.


/üíõ App resources
=================


/Overview: App resources overview
=================================

.. container:: devsite-article-body clearfix

   Resources are the additional files and static content that your code
   uses, such as bitmaps, layout definitions, user interface strings,
   animation instructions, and more.

   Always externalize app resources such as images and strings from your
   code, so that you can maintain them independently. Also, provide
   alternative resources for specific device configurations by grouping
   them in specially named resource directories. At runtime, Android
   uses the appropriate resource based on the current configuration. For
   example, you might want to provide a different UI layout depending on
   the screen size or different strings depending on the language
   setting.

   Once you externalize your app resources, you can access them using
   resource IDs that are generated in your project's ``R`` class. This
   document shows you how to group the resources in your Android
   project. It also shows you how to provide alternative resources for
   specific device configurations and then access them from your app
   code or other XML files.

   .. rubric:: Group resource types
      :name: ResourceTypes

   Place each type of resource in a specific subdirectory of your
   project's ``res/`` directory. For example, here's the file hierarchy
   for a simple project:

   .. code:: none

      MyProject/
          src/
              MyActivity.java
          res/
              drawable/
                  graphic.png
              layout/
                  main.xml
                  info.xml
              mipmap/
                  icon.png
              values/
                  strings.xml

   The ``res/`` directory contains all the resources in its
   subdirectories: an image resource, two layout resources, a
   ``mipmap/`` directory for launcher icons, and a string resource file.
   The resource directory names are important and are described in table
   1.

   **Note:** For more information about using the mipmap folders, see
   `Put app icons in mipmap directories <#mipmap>`__.

   **Table 1.** Resource directories supported inside project ``res/``
   directory.

   .. list-table::
      :widths: 36 36
      :header-rows: 1

      - 

         - Directory
         - Resource Type
      - 

         - ``animator/``
         - XML files that define `Property animations <#>`__.
      - 

         - ``anim/``
         - XML files that define `Tween animations <#tween-animation>`__.
            Property animations can also be saved in this directory, but
            the ``animator/`` directory is preferred for property
            animations to distinguish between the two types.
      - 

         - ``color/``
         - XML files that define a state list of colors. For more
            information, see `Color state list resource <#>`__.
      - 

         - ``drawable/``
         - Bitmap files (PNG, ``.9.png``, JPG, or GIF) or XML files that
            are compiled into the following drawable resource subtypes:

            -  Bitmap files
            -  Nine-patches (re-sizable bitmaps)
            -  State lists
            -  Shapes
            -  Animation drawables
            -  Other drawables

            For more information, see `Drawable resources <#>`__.
      - 

         - ``mipmap/``
         - Drawable files for different launcher icon densities. For
            more information on managing launcher icons with ``mipmap/``
            folders, see `Put app icons in mipmap directories <#mipmap>`__.
      - 

         - ``layout/``
         - XML files that define a user interface layout. For more
            information, see `Layout resource <#>`__.
      - 

         - ``menu/``
         - XML files that define app menus, such as an options menu,
            context menu, or submenu. For more information, see `Menu resource <#>`__.
      - 

         - ``raw/``
         - Arbitrary files to save in their raw form. To open these
            resources with a raw
            `InputStream <#>`__, call
            `Resources.openRawResource() <#openRawResource>`__
            with the resource ID, which is ``R.raw.``\ *``filename``*.

            However, if you need access to the original filenames and
            file hierarchy, consider saving resources in the ``assets/``
            directory instead of ``res/raw/``. Files in ``assets/``
            aren't given a resource ID, so you can only read them using
            `AssetManager <#>`__.
      - 

         - ``values/``
         - XML files that contain simple values, such as strings,
            integers, and colors.

            Whereas XML resource files in other ``res/`` subdirectories
            define a single resource based on the XML filename, files in
            the ``values/`` directory describe multiple resources. For a
            file in this directory, each child of the ``<resources>``
            element defines a single resource. For example, a
            ``<string>`` element creates an ``R.string`` resource, and a
            ``<color>`` element creates an ``R.color`` resource.

            Because each resource is defined with its own XML element,
            you can name the file whatever you want and place different
            resource types in one file. However, for clarity, you might
            want to place unique resource types in different files. For
            example, here are some filename conventions for resources
            you can create in this directory:

            -  ``arrays.xml`` for resource arrays (`Typed
               arrays </guide/topics/resources/more-resources#TypedArray>`__)
            -  ``colors.xml`` for `Color values <#Color>`__
            -  ``dimens.xml`` for `Dimension values <#Dimension>`__
            -  ``strings.xml`` for `String values <#>`__
            -  ``styles.xml`` for
               `Styles <#>`__

            For more information, see `String resources <#>`__,
            `Style resource <#>`__,
            and `More resource types <#>`__.
      - 

         - ``xml/``
         - Arbitrary XML files that can be read at runtime by calling
            `Resources.getXML() <#getXml>`__.
            Various XML configuration files must be saved here, such as
            a `Search configuration <#>`__.
      - 

         - ``font/``
         - Font files with extensions such as TTF, OTF, or TTC, or XML
            files that include a ``<font-family>`` element. For more
            information about fonts as resources, see `Add a font as an XML resource <#>`__.

   **Caution:** Never save resource files directly inside the ``res/``
   directory. It causes a compiler error.

   For more information about the individual types of resources, see the
   `Resource types overview <#>`__.

   The resources that you save in the subdirectories defined in table 1
   are your default resources. That is, these resources define the
   default design and content for your app. However, different types of
   Android-powered devices might call for different types of resources.

   For example, you can provide different layout resources for devices
   that have larger than normal screens to take advantage of the extra
   screen space. You can also provide different string resources that
   translate the text in your user interface based on the device's
   language setting. To provide these different resources for different
   device configurations, you need to provide alternative resources in
   addition to your default resources.

   .. rubric:: Provide alternative resources
      :name: AlternativeResources

   Most apps provide alternative resources to support specific device
   configurations. For instance, include alternative drawable resources
   for different screen densities and alternative string resources for
   different languages. At runtime, Android detects the current device
   configuration and loads the appropriate resources for your app.

   .. image:: https://developer.android.google.cn/static/images/resources/resource_devices_diagram2.png
      :class: android-image-dark-theme-background

   **Figure 1.** Two devices using different layout resources based on
   screen size.

   To specify configuration-specific alternatives for a set of
   resources, do the following:

   #. Create a new directory in ``res/`` named in the form
      *``<resources_name>``*\ ``-``\ *``<qualifier>``*.

      -  *``<resources_name>``* is the directory name of the
         corresponding default resources (defined in table 1).
      -  *``<qualifier>``* is a name that specifies an individual
         configuration for which these resources are to be used (defined
         in table 2).

      You can append more than one *``<qualifier>``*. Separate each one
      with a dash.

      **Caution:** When appending multiple qualifiers, you must place
      them in the same order in which they are listed in table 2. If the
      qualifiers are ordered incorrectly, the resources are ignored.

   #. Save the appropriate alternative resources in this new directory.
      The resource files must be named exactly the same as the default
      resource files.

   For example, here are some default and alternative resources:

   .. code:: none

      res/
          drawable/
              icon.png
              background.png
          drawable-hdpi/
              icon.png
              background.png

   The ``hdpi`` qualifier indicates that the resources in that directory
   are for devices with a high-density screen. The images in these
   drawable directories are sized for specific screen densities, but the
   filenames are exactly the same. This way, the resource ID that you
   use to reference the ``icon.png`` or ``background.png`` image is
   always the same. Android selects the version of each resource that
   best matches the current device by comparing the device configuration
   information with the qualifiers in the resource directory name.

   **Caution:** When defining an alternative resource, make sure you
   also define the resource in a default configuration. Otherwise, your
   app might encounter runtime exceptions when the device changes a
   configuration. For example, if you add a string to only ``values-en``
   and not ``values``, your app might encounter a ``Resource Not Found``
   exception when the user changes the default system language.

   Table 2 lists the valid configuration qualifiers in order of
   precedence. You can add multiple qualifiers to one directory name by
   separating each qualifier with a dash. If you use multiple qualifiers
   for a resource directory, you must add them to the directory name in
   the order they are listed in the table.

   **Table 2.** Configuration qualifier names.

   .. list-table::
      :widths: 24 24 24
      :header-rows: 1

      - 

         - Configuration
         - Qualifier values
         - Description
      - 

         - MCC and MNC
         - Examples:
            ``mcc310``
            ``mcc310-mnc004``
            ``mcc208-mnc00``
         - The mobile country code (MCC), optionally followed by the
            mobile network code (MNC) from the SIM card in the device.
            For example, ``mcc310`` is U.S. on any carrier,
            ``mcc310-mnc004`` is U.S. on Verizon, and ``mcc208-mnc00``
            is France on Orange.

            If the device uses a radio connection (that is, it's a GSM
            phone), the MCC and MNC values come from the SIM card.

            You can also use the MCC alone, for example, to include
            country-specific legal resources in your app. If you need to
            specify based on the language only, then use the *language,
            script (optional), and region (optional)* qualifier instead.
            If you use the MCC and MNC qualifier, do so with care and
            test that it works as expected.

            Also see the configuration fields
            `mcc <#mcc>`__,
            and
            `mnc <#mnc>`__,
            which indicate the current mobile country code and mobile
            network code, respectively.
      - 

         - Language, script (optional), and region (optional)
         - Examples:
            ``en``
            ``fr``
            ``en-rUS``
            ``fr-rFR``
            ``fr-rCA``
            ``b+en``
            ``b+en+US``
            ``b+es+419``
            ``b+zh+Hant``
            ``b+sr+Latn+RS``
         - The language is defined by a two-letter `ISO 639-1 <http://www.loc.gov/standards/iso639-2/php/code_list.php>`__
            language code, optionally followed by a two-letter `ISO 3166-1-alpha-2 <https://www.iso.org/obp/ui/#iso:pub:PUB500001:en>`__
            region code (preceded by lowercase ``r``).

            The codes are *not* case-sensitive. The ``r`` prefix is used
            to distinguish the region portion. You can't specify a
            region alone.

            Android 7.0 (API level 24) introduced support for `BCP 47 language tags <https://tools.ietf.org/html/bcp47>`__, which
            you can use to qualify language- and region-specific
            resources. A language tag is composed from a sequence of one
            or more subtags, each of which refines or narrows the range
            of language identified by the overall tag. For more
            information about language tags, see `Tags for Identifying Languages <https://tools.ietf.org/html/rfc5646>`__.

            To use a BCP 47 language tag, concatenate ``b+`` and a
            two-letter `ISO 639-1 <http://www.loc.gov/standards/iso639-2/php/code_list.php>`__
            language code, optionally followed by additional subtags
            separated by ``+``.

            The language tag can change during the life of your app if
            users change their language in the system settings. For
            information about how this can affect your app during
            runtime, see `Handle configuration changes <#>`__.

            For a complete guide to localizing your app for other
            languages, See `Localize your app <#>`__.

            Also see the
            ``\ `getLocales() <#getLocales>`__
            method, which provides the defined list of locales. This
            list includes the primary locale.
      - 

         - Layout direction
         - ``ldrtl``
            ``ldltr``
         - The layout direction of your app. ``ldrtl`` means
            "layout-direction-right-to-left." ``ldltr`` means
            "layout-direction-left-to-right" and is the default implicit
            value.

            This can apply to any resource, such as layouts, drawables,
            or values.

            For example, if you want to provide a specific layout for
            the Arabic language and a generic layout for any other
            "right-to-left" language, like Persian or Hebrew, then you
            use directories like the following:

            | ``res/``
            | ``  layout/``
            | ``    main.xml`` (default layout)
            | ``  layout-ar/``
            | ``    main.xml`` (specific layout for Arabic)
            | ``  layout-ldrtl/``
            | ``    main.xml`` (any right-to-left language except for
              Arabic, because the "ar" language qualifier has a higher
              precedence)

            **Note:** To enable right-to-left layout features for your
            app, you must set `SupportsRtl <#supportsrtl>`__
            to ``"true"`` and set `TargetSdkVersion <#target>`__
            to 17 or higher.

            *Added in API level 17.*
      - 

         - Smallest width
         - ``sw<N>dp``
            Examples:
            ``sw320dp``
            ``sw600dp``
            ``sw720dp``
            etc.
         - The shortest dimension of the screen area available to an
            app. Specifically, the app window's ``smallestWidth`` is the
            shortest of the window's available height and width. You can
            also think of it as the "smallest possible width" for the
            window. You can use this qualifier so that your app has at
            least ``<N>`` dps of width available for its UI.

            For example, if your layout requires that its smallest
            dimension of screen area be at least 600 dp at all times,
            then you can use this qualifier to create the layout
            resources in a ``res/layout-sw600dp/`` directory. The system
            uses these resources only when the smallest dimension of
            available screen is at least 600 dp, regardless of whether
            the 600 dp side is the user-perceived height or width. The
            smallest width can change if the window is resized, changing
            the available width/height, or repositioned, potentially
            changing the system insets.

            Using smallest width to determine the general screen size is
            useful because width is often the driving factor in
            designing a layout. A UI often scrolls vertically, but has
            fairly hard constraints on the minimum space it needs
            horizontally.

            The available width is also the key factor in determining
            whether to use a one-pane layout for handsets or a multipane
            layout for tablets. Thus, you likely care most about what
            the smallest possible width is on each device.

            The smallest width of a device takes into account screen
            decorations and system UI. For example, if the device has
            persistent UI elements on the screen that account for space
            along the axis of the smallest width, the system declares
            the smallest width to be smaller than the actual screen
            size, because those are screen pixels not available for your
            UI.

            Some values you might use here for common screen sizes:

            -  320, for devices with screen configurations such as:

               -  240x320 ldpi (QVGA handset)
               -  320x480 mdpi (handset)
               -  480x800 hdpi (high-density handset)

            -  480, for screens such as 480x800 mdpi (tablet/handset)
            -  600, for screens such as 600x1024 mdpi (7" tablet)
            -  720, for screens such as 720x1280 mdpi (10" tablet)

            When your app provides multiple resource directories with
            different values for the ``smallestWidth`` qualifier, the
            system uses the one closest to (without exceeding) the
            device's ``smallestWidth``.

            *Added in API level 13.*

            Also see the
            `android:requiresSmallestWidthDp <#requiresSmallest>`__
            attribute, which declares the minimum ``smallestWidth`` with
            which your app is compatible, and the
            `smallestScreenWidthDp <#smallestScreenWidthDp>`__
            configuration field, which holds the device's
            ``smallestWidth`` value.

            For more information about designing for different screens
            using this qualifier, see `Support different screen sizes <#>`__.
      - 

         - Available width and height
         - ``w<N>dp`` ``h<N>dp``
            Examples: ``w720dp`` ``w1024dp`` ``h720dp`` ``h1024dp`` etc.
         - Specifies the minimum available screen width or height (in
            ``dp`` units defined by the ``<N>`` value) at which the
            resource is used. These configuration values are compared to
            the current display width and height as the device
            orientation changes between portrait and landscape, the
            device folds or unfolds, or the system enters or exits
            multi-window mode. In multi-window mode, the values reflect
            the width and height of the window that contains the app,
            not the width and height of the device screen. Similarly,
            for embedded activities, the values pertain to the width and
            height of the individual activities, not the width and
            height of the screen. For more information, see `Activity embedding <#>`__.

            Available width and height are often useful for determining
            whether to use a multipane layout, because even on a tablet
            device you often don't want the same multipane layout for
            portrait orientation as you do for landscape. Thus, you can
            use these to specify the minimum width and/or height
            required for the layout, instead of using both the screen
            size and orientation qualifiers together.

            When your app provides multiple resource directories with
            different values for these configurations, the system uses
            the one closest to (without exceeding) the device's current
            screen width. *Closest to* is determined by adding the
            differences between the actual screen width and the
            specified width to the difference between the actual screen
            height and the specified height, with unspecified heights
            and widths having a value of 0.

            The values exclude the area occupied by `Window insets <#>`__, so if the
            device has persistent UI elements on the edges of the
            display, the values for width and height are smaller than
            the real screen dimensions, even when the app is displayed
            edge to edge using
            `Window.setDecorFitsSystemWindows <#setDecorFitsSystemWindows>`__
            or
            `WindowCompat.setDecorFitsSystemWindows <#setDecorFitsSystemWindows>`__.

            Some vertical screen decorations that aren't fixed (such as
            a phone status bar that can be hidden when full screen) are
            *not* accounted for here, nor are window decorations like
            the title bar or action bar, so apps must be prepared to
            deal with a somewhat smaller space than they specify.

            **Note:** The system chooses the resource that matches both
            in width and height. Therefore a resource that specifies
            both is strongly preferred over one that specifies only one
            or the other. For example, if the actual screen is 720 dp
            wide by 1280 dp high and one resource is qualified with
            w720dp and another is qualified as w700dp-h1200dp, the
            latter is chosen even though the former is an exact match
            for what it specifies.

            *Added in API level 13.*

            Also see the
            `screenWidthDp <#screenWidthDp>`__
            and
            `screenHeightDp <#screenHeightDp>`__
            configuration fields, which hold the current screen width
            and height.

            For more information about designing for different screens
            using this qualifier, see `Support different screen sizes <#>`__.
      - 

         - Screen size
         - ``small`` ``normal`` ``large`` ``xlarge``
         - 

            -  ``small``: screens that are of similar size to a
               low-density QVGA screen. The minimum layout size for a
               small screen is approximately 320x426 dp units. Examples
               are QVGA low density and VGA high density.
            -  ``normal``: screens that are of similar size to a
               medium-density HVGA screen. The minimum layout size for a
               normal screen is approximately 320x470 dp units. Examples
               of such screens are a WQVGA low density, HVGA medium
               density, and WVGA high density.
            -  ``large``: screens that are of similar size to a
               medium-density VGA screen. The minimum layout size for a
               large screen is approximately 480x640 dp units. Examples
               are VGA and WVGA medium-density screens.
            -  ``xlarge``: screens that are considerably larger than the
               traditional medium-density HVGA screen. The minimum
               layout size for an xlarge screen is approximately 720x960
               dp units. In most cases, devices with extra-large screens
               are too large to carry in a pocket and most likely are
               tablet-style devices. *Added in API level 9.*

            **Note:** Using a size qualifier does not imply that the
            resources are *only* for screens of that size. If you do not
            provide alternative resources with qualifiers that better
            match the current device configuration, the system can use
            whichever resources are the `best match <#BestMatch>`__.

            **Caution:** If all your resources use a size qualifier that
            is *larger* than the current screen, the system **doesn't**
            use them and your app crashes at runtime. This happens, for
            example, if all layout resources are tagged with the
            ``xlarge`` qualifier but the device has a normal-size
            screen.

            *Added in API level 4.*

            Also see the
            `screenLayout <#screenLayout>`__
            configuration field, which indicates whether the screen is
            small, normal, or large.

            For more information, see `Screen compatibility overview <#>`__.
      - 

         - Screen aspect
         - ``long`` ``notlong``
         - 

            -  ``long``: long screens, such as WQVGA, WVGA, FWVGA
            -  ``notlong``: not long screens, such as QVGA, HVGA, and
               VGA

            *Added in API level 4.*

            This is based purely on the aspect ratio of the screen (a
            ``long`` screen is wider). This isn't related to the screen
            orientation.

            Also see the
            `screenLayout <#screenLayout>`__
            configuration field, which indicates whether the screen is
            long.
      - 

         - Round screen
         - ``round`` ``notround``
         - 

            -  ``round``: round screens, such as a round wearable device
            -  ``notround``: rectangular screens, such as phones or
               tablets

            *Added in API level 23.*

            Also see the
            `isScreenRound() <#isScreenRound>`__
            configuration method, which indicates whether the screen is
            round.
      - 

         - Wide Color Gamut
         - ``widecg`` ``nowidecg``
         - 

            -  ``widecg``: displays with a wide color gamut such as
               Display P3 or AdobeRGB
            -  ``nowidecg``: displays with a narrow color gamut such as
               sRGB

            *Added in API level 26.*

            Also see the
            `isScreenWideColorGamut() <#isScreenWideColorGamut>`__
            configuration method, which indicates whether the screen has
            a wide color gamut.
      - 

         - High Dynamic Range (HDR)
         - ``highdr`` ``lowdr``
         - 

            -  ``highdr``: displays with a high dynamic range
            -  ``lowdr``: displays with a low/standard dynamic range

            *Added in API level 26.*

            Also see the
            `isScreenHdr() <#isScreenHdr>`__
            configuration method, which indicates whether the screen has
            HDR capabilities.
      - 

         - Screen orientation
         - ``port`` ``land``
         - 

            -  ``port``: device is in portrait orientation (vertical)
            -  ``land``: device is in landscape orientation (horizontal)

            This can change during the life of your app if the user
            rotates the screen. For information about how this affects
            your app during runtime, see `Handle configuration changes <#>`__.

            Also see the
            `orientation <#orientation>`__
            configuration field, which indicates the current device
            orientation.
      - 

         - UI mode
         - ``car`` ``desk`` ``television`` ``appliance`` ``watch`` ``vrheadset``
         - 

            -  ``car``: device is displaying in a car dock
            -  ``desk``: device is displaying in a desk dock
            -  ``television``: device is displaying on a television,
               providing a "ten-foot" experience where its UI is on a
               large screen that the user is far away from, and the
               experience is primarily oriented around D-pad or other
               non-pointer interaction
            -  ``appliance``: device is serving as an appliance, with no
               display
            -  ``watch``: device has a display and is worn on the wrist
            -  ``vrheadset``: device is displaying in a virtual reality
               headset

            *Added in API level 8; television added in API 13; watch
            added in API 20.*

            For information about how your app can respond when the
            device is inserted into or removed from a dock, read
            `Determine and monitor the docking state and type <#>`__.

            This can change during the life of your app if the user
            places the device in a dock. You can enable or disable some
            of these modes using
            `UiModeManager <#>`__.
            For information about how this affects your app during
            runtime, see `Handle configuration changes <#>`__.
      - 

         - Night mode
         - ``night`` ``notnight``
         - 

            -  ``night``: night time
            -  ``notnight``: day time

            *Added in API level 8.*

            This can change during the life of your app if night mode is
            left in auto mode (default), in which case the mode changes
            based on the time of day. You can enable or disable this
            mode using
            `UiModeManager <#>`__.
            For information about how this affects your app during
            runtime, see `Handle configuration changes <#>`__.
      - 

         - Screen pixel density (dpi)
         - ``ldpi`` ``mdpi`` ``hdpi`` ``xhdpi`` ``xxhdpi`` ``xxxhdpi``
            ``nodpi`` ``tvdpi`` ``anydpi`` ``nnn dpi``
         - 

            -  ``ldpi``: low-density screens; approximately 120 dpi.
            -  ``mdpi``: medium-density (on traditional HVGA) screens;
               approximately 160 dpi.
            -  ``hdpi``: high-density screens; approximately 240 dpi.
            -  ``xhdpi``: extra-high-density screens; approximately 320
               dpi. *Added in API level 8.*
            -  ``xxhdpi``: extra-extra-high-density screens;
               approximately 480 dpi. *Added in API level 16.*
            -  ``xxxhdpi``: extra-extra-extra-high-density uses
               (launcher icon only‚Äîsee `Support different pixel densities <#>`__);
               approximately 640 dpi. *Added in API level 18.*
            -  ``nodpi``: used for bitmap resources that you don't want
               to be scaled to match the device density.
            -  ``tvdpi``: screens somewhere between mdpi and hdpi;
               approximately 213 dpi. This isn't considered a "primary"
               density group. It is mostly intended for 720p
               televisions, and most apps don't need it. For 1080p TV
               panels, use ``xhdpi``, and for 4K TV panels, use
               ``xxxhdpi``. *Added in API level 13.*
            -  ``anydpi``: matches all screen densities and takes
               precedence over other qualifiers. This is useful for
               `vector drawables <#VectorDrawables>`__.
               *Added in API level 21.*
            -  ``nnn` dpi``: used to represent non-standard
               densities, where ``nnn`` is a positive integer screen
               density. This isn't used in most cases. Using standard
               density buckets greatly reduces the overhead of
               supporting the various device screen densities on the
               market.

            There is a 3:4:6:8:12:16 scaling ratio between the six
            primary densities (ignoring the tvdpi density). So, a 9x9
            bitmap in ldpi is 12x12 in mdpi, 18x18 in hdpi, 24x24 in
            xhdpi, and so on.

            **Note:** Using a density qualifier doesn't imply that the
            resources are *only* for screens of that density. If you
            don't provide alternative resources with qualifiers that
            better match the current device configuration, the system
            uses whichever resources are the `best match <#BestMatch>`__.

            For more information about how to handle different screen
            densities and how Android might scale your bitmaps to fit
            the current density, see `Screen compatibility overview <#>`__.
      - 

         - Touchscreen type
         - ``notouch`` ``finger``
         - 

            -  ``notouch``: device doesn't have a touchscreen.
            -  ``finger``: device has a touchscreen that is intended to
               be used through direction interaction of the user's
               finger.

            Also see the
            `touchscreen <#touchscreen>`__
            configuration field, which indicates the type of touchscreen
            on the device.
      - 

         - Keyboard availability
         - ``keysexposed`` ``keyshidden`` ``keyssoft``
         - 

            -  ``keysexposed``: device has a keyboard available. If the
               device has a software keyboard enabled (which is likely),
               this is used even when the hardware keyboard *isn't*
               exposed to the user or when the device has no hardware
               keyboard. If no software keyboard is provided or it's
               disabled, then this is only used when a hardware keyboard
               is exposed.
            -  ``keyshidden``: device has a hardware keyboard available
               but it is hidden *and* the device does *not* have a
               software keyboard enabled.
            -  ``keyssoft``: device has a software keyboard enabled,
               whether it's visible or not.

            If you provide ``keysexposed`` resources, but not
            ``keyssoft`` resources, the system uses the ``keysexposed``
            resources regardless of whether a keyboard is visible, as
            long as the system has a software keyboard enabled.

            This can change during the life of your app if the user
            opens a hardware keyboard. For information about how this
            affects your app during runtime, see `Handle configuration changes <#>`__.

            Also see the configuration fields
            `hardKeyboardHidden <#hardKeyboardHidden>`__
            and
            `keyboardHidden <#keyboardHidden>`__,
            which indicate the visibility of a hardware keyboard and the
            visibility of any kind of keyboard (including software),
            respectively.
      - 

         - Primary text input method
         - ``nokeys`` ``qwerty`` ``12key``
         - 

            -  ``nokeys``: device has no hardware keys for text input.
            -  ``qwerty``: device has a hardware QWERTY keyboard,
               whether it's visible to the user or not.
            -  ``12key``: device has a hardware 12-key keyboard, whether
               it's visible to the user or not.

            Also see the
            `keyboard <#keyboard>`__
            configuration field, which indicates the primary text input
            method available.
      - 

         - Navigation key availability
         - ``navexposed`` ``navhidden``
         - 

            -  ``navexposed``: navigation keys are available to the
               user.
            -  ``navhidden``: navigation keys aren't available (such as
               behind a closed lid).

            This can change during the life of your app if the user
            reveals the navigation keys. For information about how this
            affects your app during runtime, see `Handle configuration changes <#>`__.

            Also see the
            `navigationHidden <#navigationHidden>`__
            configuration field, which indicates whether the navigation
            keys are hidden.
      - 

         - Primary non-touch navigation method
         - ``nonav`` ``dpad`` ``trackball`` ``wheel``
         - 

            -  ``nonav``: device has no navigation facility other than
               using the touchscreen.
            -  ``dpad``: device has a directional-pad (D-pad) for
               navigation.
            -  ``trackball``: device has a trackball for navigation.
            -  ``wheel``: device has a directional wheel(s) for
               navigation (uncommon).

            Also see the
            `navigation <#navigation>`__
            configuration field, which indicates the type of navigation
            method available.
      - 

         - Platform version (API level)
         - Examples: ``v3`` ``v4`` ``v7`` etc.
         - The API level supported by the device. For example, ``v1``
            for API level 1 (devices with Android 1.0 or higher) and
            ``v4`` for API level 4 (devices with Android 1.6 or higher).
            For more information about these values, see the `Android API levels <#ApiLevels>`__
            document.

   **Note:** Not all versions of Android support all the qualifiers.
   Using a new qualifier implicitly adds the platform version qualifier
   so that older devices can ignore it. For example, using a ``w600dp``
   qualifier automatically includes the ``v13`` qualifier, because the
   available-width qualifier was new in API level 13. To avoid any
   issues, always include a set of default resources (a set of resources
   with *no qualifiers*). For more information, see the section about
   `Providing the best device compatibility with resources <#Compatibility>`__.

   .. rubric:: Qualifier name rules
      :name: QualifierRules

   Here are some rules about using configuration qualifier names:

   -  You can specify multiple qualifiers for a single set of resources,
      separated by dashes. For example, ``drawable-en-rUS-land`` applies
      to US-English devices in landscape orientation.
   -  The qualifiers must be in the order listed in `table 2 <#table2>`__.

      -  Wrong: ``drawable-hdpi-port/``
      -  Correct: ``drawable-port-hdpi/``

   -  Alternative resource directories can't be nested. For example, you
      can't have ``res/drawable/drawable-en/``.
   -  Values are case-insensitive. The resource compiler converts
      directory names to lowercase before processing to avoid problems
      on case-insensitive file systems. Any capitalization in the names
      is only to benefit readability.
   -  Only one value for each qualifier type is supported. For example,
      if you want to use the same drawable files for Spain and France,
      you *can't* have a directory named ``drawable-es-fr/``. Instead,
      you need two resource directories, such as ``drawable-es/`` and
      ``drawable-fr/``, which contain the appropriate files. However,
      you aren't required to actually duplicate the files in both
      locations. Instead, you can create an *alias* to a resource, as
      described in the `Create alias resources <#AliasResources>`__
      section.

   After you save alternative resources into directories named with
   these qualifiers, Android automatically applies the resources in your
   app based on the current device configuration. Each time a resource
   is requested, Android checks for alternative resource directories
   that contain the requested resource file, then `finds the best-matching resource <#BestMatch>`__.

   If there are no alternative resources that match a particular device
   configuration, then Android uses the corresponding default
   resources‚Äîthe set of resources for a particular resource type that
   doesn't include a configuration qualifier.

   .. rubric:: Create alias resources
      :name: AliasResources

   When you have a resource that you'd like to use for more than one
   device configuration but you don't want to provide it as a default
   resource, you don't need to put the same resource in more than one
   alternative resource directory. Instead, you can create an
   alternative resource that acts as an alias for a resource saved in
   your default resource directory.

   **Note:** Not all resources offer a mechanism by which you can create
   an alias to another resource. In particular, animation, menu, raw,
   and other unspecified resources in the ``xml/`` directory don't offer
   this feature.

   For example, imagine you have an app icon, ``icon.png``, and need a
   unique version of it for different locales. However, two locales,
   English-Canadian and French-Canadian, need to use the same version.
   You don't need to copy the same image into the resource directory for
   both English-Canadian and French-Canadian. Instead, you can save the
   image that's used for both using any name *other than* ``icon.png``,
   such as ``icon_ca.png``, and put it in the default ``res/drawable/``
   directory. Then create an ``icon.xml`` file in
   ``res/drawable-en-rCA/`` and ``res/drawable-fr-rCA/`` that refers to
   the ``icon_ca.png`` resource using the ``<bitmap>`` element. This
   lets you store just one version of the PNG file and two small XML
   files that point to it. See the examples in the following sections
   for details.

   .. rubric:: Drawable
      :name: drawable

   To create an alias to an existing drawable, use the ``<drawable>``
   element:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <resources>
          <drawable name="icon">@drawable/icon_ca</drawable>
      </resources>

   If you save this file as ``icon.xml`` in an alternative resource
   directory, such as ``res/values-en-rCA/``, it is compiled into a
   resource that you can reference as ``R.drawable.icon``, but is
   actually an alias for the ``R.drawable.icon_ca`` resource, which is
   saved in ``res/drawable/``.

   .. rubric:: Layout
      :name: layout

   To create an alias to an existing layout, use the ``<include>``
   element, wrapped in a ``<merge>``:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <merge>
          <include layout="@layout/main_ltr"/>
      </merge>

   If you save this file as ``main.xml``, it is compiled into a resource
   you can reference as ``R.layout.main``, but is actually an alias for
   the ``R.layout.main_ltr`` resource.

   .. rubric:: Strings and other simple values
      :name: strings-and-other-simple-values

   To create an alias to an existing string, use the resource ID of the
   desired string as the value for the new string:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <resources>
          <string name="hello">Hello</string>
          <string name="hi">@string/hello</string>
      </resources>

   The ``R.string.hi`` resource is now an alias for the
   ``R.string.hello``.

   `Other simple values <#>`__ work
   the same way, such as colors:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <resources>
          <color name="red">#f00</color>
          <color name="highlight">@color/red</color>
      </resources>

   .. rubric:: Access your app resources
      :name: Accessing

   Once you provide a resource in your application, you can apply it by
   referencing its resource ID. All resource IDs are defined in your
   project's ``R`` class, which the ``aapt`` tool automatically
   generates.

   When your application is compiled, ``aapt`` generates the ``R``
   class, which contains resource IDs for all the resources in your
   ``res/`` directory. For each type of resource, there is an ``R``
   subclass, such as ``R.drawable`` for all drawable resources. And for
   each resource of that type, there is a static integer, for example,
   ``R.drawable.icon``. This integer is the resource ID that you can use
   to retrieve your resource.

   Although the ``R`` class is where resource IDs are specified, you
   don't need to look there to discover a resource ID. A resource ID is
   always composed of the following:

   -  The *resource type*: each resource is grouped into a "type," such
      as ``string``, ``drawable``, and ``layout``. For more information
      about the different types, see `Resource types overview <#>`__.
   -  The *resource name*, which is either the filename excluding the
      extension or the value in the XML ``android:name`` attribute, if
      the resource is a simple value, such as a string.

   There are two ways you can access a resource:

   -  **In code:** using a static integer from a subclass of your ``R``
      class, such as:

      .. code:: none

         R.string.hello

      ``string`` is the resource type and ``hello`` is the resource
      name. There are many Android APIs that can access your resources
      when you provide a resource ID in this format. For more
      information, see the `Access resources in code <#ResourcesFromCode>`__ section.

   -  **In XML:** using a special XML syntax that corresponds to the
      resource ID defined in your ``R`` class, such as:

      .. code:: none

         @string/hello

      ``string`` is the resource type and ``hello`` is the resource
      name. You can use this syntax in an XML resource any place where a
      value is expected that you provide in a resource. For more
      information, see the `Access resources from XML <#ResourcesFromXml>`__ section.

   .. rubric:: Access resources in code
      :name: ResourcesFromCode

   You can use a resource in code by passing the resource ID as a method
   parameter. For example, you can set an
   `ImageView <#>`__ to use the
   ``res/drawable/myimage.png`` resource using
   `setImageResource() <#setImageResource>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val imageView = findViewById(R.id.myimageview) as ImageView
               imageView.setImageResource(R.drawable.myimage)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ImageView imageView = (ImageView) findViewById(R.id.myimageview);
               imageView.setImageResource(R.drawable.myimage);

   You can also retrieve individual resources using methods in
   `Resources <#>`__, which
   you can get an instance of with
   `getResources() <#getResources>`__.

   .. rubric:: Syntax
      :name: fromCodeSytax

   Here's the syntax to reference a resource in code:

   .. code:: none

      [<package_name>.]R.<resource_type>.<resource_name>

   -  *``<package_name>``* is the name of the package in which the
      resource is located (not required when referencing resources from
      your own package).
   -  *``<resource_type>``* is the ``R`` subclass for the resource type.
   -  *``<resource_name>``* is either the resource filename without the
      extension or the ``android:name`` attribute value in the XML
      element, for simple values.

   For more information about each resource type and how to reference
   them, see `Resource types overview <#>`__.

   .. rubric:: Use cases
      :name: fromCodeUses

   There are many methods that accept a resource ID parameter, and you
   can retrieve resources using methods in
   `Resources <#>`__. You can
   get an instance of ``Resources`` using
   `Context.getResources() <#getResources>`__.

   Here are some examples of accessing resources in code:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Load a background for the current screen from a drawable resource.
               window.setBackgroundDrawableResource(R.drawable.my_background_image)

               // Set the Activity title by getting a string from the Resources object, because
               //  this method requires a CharSequence rather than a resource ID.
               window.setTitle(resources.getText(R.string.main_title))

               // Load a custom layout for the current screen.
               setContentView(R.layout.main_screen)

               // Set a slide in animation by getting an Animation from the Resources object.
               flipper.setInAnimation(AnimationUtils.loadAnimation(this,
                       R.anim.hyperspace_in))

               // Set the text on a TextView object using a resource ID.
               val msgTextView = findViewById(R.id.msg) as TextView
               msgTextView.setText(R.string.hello_message)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Load a background for the current screen from a drawable resource.
               getWindow().setBackgroundDrawableResource(R.drawable.my_background_image) ;

               // Set the Activity title by getting a string from the Resources object, because
               //  this method requires a CharSequence rather than a resource ID.
               getWindow().setTitle(getResources().getText(R.string.main_title));

               // Load a custom layout for the current screen.
               setContentView(R.layout.main_screen);

               // Set a slide in animation by getting an Animation from the Resources object.
               flipper.setInAnimation(AnimationUtils.loadAnimation(this,
                       R.anim.hyperspace_in));

               // Set the text on a TextView object using a resource ID.
               TextView msgTextView = (TextView) findViewById(R.id.msg);
               msgTextView.setText(R.string.hello_message);

   **Caution:** Don't modify the ``R.java`` file by hand. It is
   generated by the ``aapt`` tool when your project is compiled. Any
   changes are overridden next time you compile.

   .. rubric:: Access resources from XML
      :name: ResourcesFromXml

   You can define values for some XML attributes and elements using a
   reference to an existing resource. You often do this when creating
   layout files, to supply strings and images for your widgets.

   For example, if you add a `Button <#>`__ to your layout, use
   a `string resource <#>`__ for the button text:

   .. code:: prettyprint

      <Button
          android:layout_width="fill_parent"
          android:layout_height="wrap_content"
          android:text="@string/submit" />

   .. rubric:: Syntax
      :name: fromXmlSyntax

   Here is the syntax to reference a resource in an XML resource:

   .. code:: prettyprint

      @[<package_name>:]<resource_type>/<resource_name>

   -  ``<package_name>`` is the name of the package in which the
      resource is located (not required when referencing resources from
      the same package).
   -  ``<resource_type>`` is the ``R`` subclass for the resource type.
   -  ``<resource_name>`` is either the resource filename without the
      extension or the ``android:name`` attribute value in the XML
      element, for simple values.

   For more information about each resource type and how to reference
   them, see `Resource types overview <#>`__.

   .. rubric:: Use cases
      :name: fromXmlUses

   In some cases, you must use a resource for a value in XML, such as to
   apply a drawable image to a widget, but you can also use a resource
   in XML any place that accepts a simple value. For example, if you
   have the following resource file that includes a `color resource <#Color>`__ and a
   `string resource <#>`__:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <resources>
         <color name="opaque_red">#f00</color>
         <string name="hello">Hello!</string>
      </resources>

   You can use these resources in the following layout file to set the
   text color and text string:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <EditText xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="fill_parent"
          android:layout_height="fill_parent"
          android:textColor="@color/opaque_red"
          android:text="@string/hello" />

   In this case, you don't need to specify the package name in the
   resource reference, because the resources are from your own package.
   To reference a system resource, you need to include the package name,
   as shown in the following example:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <EditText xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="fill_parent"
          android:layout_height="fill_parent"
          android:textColor="@android:color/secondary_text_dark"
          android:text="@string/hello" />

   **Note:** Always use string resources, so that your application can
   be localized for other languages. For information about creating
   alternative resources (such as localized strings), see `Provide alternative resources <#AlternativeResources>`__. For a complete
   guide to localizing your application for other languages, see
   `Localize your app <#>`__.

   You can even use resources in XML to create aliases. For example, you
   can create a drawable resource that is an alias for another drawable
   resource:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <bitmap xmlns:android="http://schemas.android.com/apk/res/android"
          android:src="@drawable/other_drawable" />

   This sounds redundant, but can be very useful when using alternative
   resource. For more information, see the section about `creating alias resources <#AliasResources>`__.

   .. rubric:: Reference style attributes
      :name: ReferencesToThemeAttributes

   A style attribute resource lets you reference the value of an
   attribute in the currently applied theme. Referencing a style
   attribute lets you customize the look of UI elements by styling them
   to match standard variations supplied by the current theme, instead
   of supplying a hardcoded value. Referencing a style attribute
   essentially says, "Use the style that is defined by this attribute in
   the current theme."

   To reference a style attribute, the name syntax is almost identical
   to the normal resource format, but instead of the "at" symbol
   (``@``), use a question mark (``?``). The resource type portion is
   optional. So the reference syntax is as follows:

   .. code:: none

      ?[<package_name>:][<resource_type>/]<resource_name>

   For example, here's how you can reference an attribute to set the
   text color to match the secondary text color of the system theme:

   .. code:: prettyprint

      <EditText id="text"
          android:layout_width="fill_parent"
          android:layout_height="wrap_content"
          android:textColor="?android:textColorSecondary"
          android:text="@string/hello_world" />

   Here, the ``android:textColor`` attribute specifies the name of a
   style attribute in the current theme. Android now uses the value
   applied to the ``android:textColorSecondary`` style attribute as the
   value for ``android:textColor`` in this widget. Because the system
   resource tool knows that an attribute resource is expected in this
   context, you do not need to explicitly state the type, which is
   ``?android:attr/textColorSecondary``. You can exclude the ``attr``
   type.

   .. rubric:: Access original files
      :name: OriginalFiles

   While uncommon, you might need access your original files and
   directories. If you do, then saving your files in ``res/`` won't work
   for you, because the only way to read a resource from ``res/`` is
   with the resource ID. Instead, you can save your resources in the
   ``assets/`` directory.

   Files saved in the ``assets/`` directory are *not* given a resource
   ID, so you can't reference them through the ``R`` class or from XML
   resources. Instead, you can query files in the ``assets/`` directory
   like a normal file system and read raw data using
   `AssetManager <#>`__.

   However, if all you require is the ability to read raw data (such as
   a video or audio file), then save the file in the ``res/raw/``
   directory and read a stream of bytes using
   `openRawResource() <#openRawResource>`__.

   .. rubric:: Access platform resources
      :name: PlatformResources

   Android contains a number of standard resources, such as styles,
   themes, and layouts. To access these resources, qualify your resource
   reference with the ``android`` package name. For example, Android
   provides a layout resource you can use for list items in a
   `ListAdapter <#>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               listAdapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, myarray)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, myarray));

   In this example, `simple_list_item_1 <#simple_list_item_1>`__
   is a layout resource defined by the platform for items in a
   `ListView <#>`__. You can use
   this instead of creating your own layout for list items.

   .. rubric:: Provide the best device compatibility with resources
      :name: Compatibility

   For your app to support multiple device configurations, it's very
   important that you always provide default resources for each type of
   resource that your app uses.

   For example, if your app supports several languages, always include a
   ``values/`` directory (in which your strings are saved) *without* a
   `language and region qualifier <#LocaleQualifier>`__. If you instead
   put all your string files in directories that have a language and
   region qualifier, then your app crashes when run on a device set to a
   language that your strings don't support.

   As long as you provide default ``values/`` resources, then your app
   runs properly, even if the user doesn't understand the language it
   presents. It's better than crashing.

   Likewise, if you provide different layout resources based on the
   screen orientation, pick one orientation as your default. For
   example, instead of providing layout resources in ``layout-land/``
   for landscape and ``layout-port/`` for portrait, leave one as the
   default, such as ``layout/`` for landscape and ``layout-port/`` for
   portrait.

   Providing default resources is important not only because your app
   might run on a configuration you hadn't anticipated, but also because
   new versions of Android sometimes add configuration qualifiers that
   older versions don't support. If you use a new resource qualifier,
   but maintain code compatibility with older versions of Android, then
   when an older version of Android runs your app, it crashes if you
   don't provide default resources, because it can't use the resources
   named with the new qualifier.

   For example, if your
   `minSdkVersion <#min>`__
   is set to 4, and you qualify all of your drawable resources using
   `night mode <#NightQualifier>`__ (``night`` or ``notnight``, which
   were added in API level 8), then an API level 4 device can't access
   your drawable resources and crashes. In this case, you probably want
   ``notnight`` to be your default resources, so exclude that qualifier
   and put your drawable resources in either ``drawable/`` or
   ``drawable-night/``.

   In short, to provide the best device compatibility, always provide
   default resources for the resources your app needs to perform
   properly. Then create alternative resources for specific device
   configurations using configuration qualifiers.

   There is one exception to this rule: If your app's
   `minSdkVersion <#min>`__
   is 4 or greater, you *don't* need default drawable resources when you
   provide alternative drawable resources with the `screen density <#DensityQualifier>`__ qualifier. Even without default
   drawable resources, Android can find the best match among the
   alternative screen densities and scale the bitmaps as necessary.
   However, for the best experience on all types of devices, provide
   alternative drawables for all three types of density.

   .. rubric:: How Android finds the best-matching resource
      :name: BestMatch

   When you request a resource for which you provide alternatives,
   Android selects which alternative resource to use at runtime,
   depending on the current device configuration. To demonstrate how
   Android selects an alternative resource, assume the following
   drawable directories each contain different versions of the same
   images:

   .. code:: none

      drawable/
      drawable-en/
      drawable-fr-rCA/
      drawable-en-port/
      drawable-en-notouch-12key/
      drawable-port-ldpi/
      drawable-port-notouch-12key/

   And assume the following is the device configuration:

   | Locale = ``en-GB``
   | Screen orientation = ``port``
   | Screen pixel density = ``hdpi``
   | Touchscreen type = ``notouch``
   | Primary text input method = ``12key``

   By comparing the device configuration to the available alternative
   resources, Android selects drawables from ``drawable-en-port``.

   The system arrives at its decision for which resources to use with
   the following logic:

   .. container:: attempt-right

      .. image:: https://developer.android.google.cn/static/images/resources/res-selection-flowchart.png
         :height: 471px

      **Figure 2.** Flowchart of how Android finds the best-matching
      resource.

   #. Eliminate resource files that contradict the device configuration.

      The ``drawable-fr-rCA/`` directory is eliminated, because it
      contradicts the ``en-GB`` locale.

      .. code:: none

         drawable/
         drawable-en/
         drawable-fr-rCA/
         drawable-en-port/
         drawable-en-notouch-12key/
         drawable-port-ldpi/
         drawable-port-notouch-12key/

      **Exception:** Screen pixel density is the one qualifier that is
      not eliminated due to a contradiction. Even though the screen
      density of the device is hdpi, ``drawable-port-ldpi/`` isn't
      eliminated because every screen density is considered to be a
      match at this point. For information, see `Screen compatibility overview <#>`__.

   #. Find the next-highest-precedence qualifier in the list (`table
      2 <#table2>`__). (Start with MCC.)

   #. Do any of the resource directories include this qualifier?

      -  If no, return to step two and look at the next qualifier. In
         this example, the answer is "no" until the language qualifier
         is reached.
      -  If yes, continue to step four.

   #. Eliminate resource directories that don't include this qualifier.
      In this example, the system next eliminates all the directories
      that don't include a language qualifier:

      .. code:: none

         drawable/
         drawable-en/
         drawable-en-port/
         drawable-en-notouch-12key/
         drawable-port-ldpi/
         drawable-port-notouch-12key/

      **Exception:** If the qualifier in question is screen pixel
      density, Android selects the option that most closely matches the
      device screen density. In general, Android prefers scaling down a
      larger original image to scaling up a smaller original image. For
      more information, see `Screen compatibility overview <#>`__.

   #. Repeat steps two, three, and four until only one directory
      remains. In this example, screen orientation is the next qualifier
      for which there are any matches. So, resources that don't specify
      a screen orientation are eliminated:

      .. code:: none

         drawable-en/
         drawable-en-port/
         drawable-en-notouch-12key/

      The remaining directory is ``drawable-en-port``.

   Though this procedure is executed for each resource requested, the
   system optimizes some aspects of it. One such optimization is that
   once the device configuration is known, it might eliminate
   alternative resources that can never match. For example, if the
   configuration language is English, then any resource directory that
   has a language qualifier set to something other than English is never
   included in the pool of resources checked (though a resource
   directory *without* the language qualifier is still included).

   When selecting resources based on the screen size qualifiers, the
   system uses resources designed for a screen smaller than the current
   screen if there are no resources that better match. For example, a
   large-size screen uses normal-size screen resources if necessary.

   However, if the only available resources are *larger* than the
   current screen, the system **doesn't** use them and your app crashes
   if no other resources match the device configuration. This happens,
   for example, if all layout resources are tagged with the ``xlarge``
   qualifier, but the device is a normal-size screen.

   **Note:** The *precedence* of the qualifier (in `table 2 <#table2>`__) is more important than the number of qualifiers that
   exactly match the device. In the preceding example, at step four the
   last choice on the list includes three qualifiers that exactly match
   the device (orientation, touchscreen type, and input method), while
   ``drawable-en`` has only one parameter that matches (language).
   However, language has a higher precedence than these other
   qualifiers, so ``drawable-port-notouch-12key`` is eliminated.

Last updated 2024-04-10 UTC.


/Handle configuration changes
=============================

.. container:: devsite-article-body clearfix

   Some device configurations can change while the app is running. These
   include, but aren't limited to:

   -  App display size
   -  Screen orientation
   -  Font size and weight
   -  Locale
   -  Dark mode versus light mode
   -  Keyboard availability

   Most of these configuration changes occur due to some user
   interaction. For example, rotating or folding the device changes the
   amount of screen space available to your app. Likewise, altering
   device settings like the font size, language, or preferred theme
   changes their respective values in the
   `Configuration <#>`__
   object.

   **Note:**\  Connecting or disconnecting external peripherals and
   multi-tasking is more common on `large screen devices <#>`__ such as tablets, foldables, or Chrome OS.
   Configuration changes can occur more often in those devices due to
   their flexibility.
   These parameters usually require large enough changes to your
   application's UI that the Android platform has a purpose-built
   mechanism for when they change. This mechanism is *``Activity``
   recreation*.

   .. rubric:: Activity recreation
      :name: activity-recreation

   The system recreates an ``Activity`` when a configuration change
   occurs. To do this, the system calls `onDestroy() <#onDestroy>`__ and
   destroys the existing ``Activity`` instance. It then creates a new
   instance using `onCreate() <#onCreate>`__,
   and this new ``Activity`` instance is initialized with the new,
   updated configuration. This also means that the system also recreates
   the UI with the new configuration.

   The recreation behavior helps your application adapt to new
   configurations by automatically reloading your application with
   alternative resources that match the new device configuration.

   .. rubric:: Recreation example
      :name: recreation-example

   Consider a ``TextView`` that displays a static title using
   ``android:text="@string/title"``, as defined in a layout XML file.
   When the view is created, it sets the text exactly once, based on the
   current language. If the language changes, the system recreates the
   activity. Consequently, the system also recreates the view and
   initializes it to the correct value based on the new language.

   The recreation also clears out any state kept as fields in the
   ``Activity`` or in any of its contained ``Fragment``, ``View``, or
   other objects. This is because ``Activity`` recreation creates a
   completely new instance of the ``Activity`` and the UI. Furthermore,
   the old ``Activity`` is no longer visible or valid, so any remaining
   references to it or its contained objects are stale. They can cause
   bugs, memory leaks, and crashes.

   **Note:**\  ``Activity`` recreation due to configuration changes is
   only one of the cases in which the system might destroy an
   ``Activity`` and recreate it later. For more information, read about
   the `Activity lifecycle <#mtal>`__.

   .. rubric:: User expectations
      :name: user-expectations

   The user of an app expects state to be preserved. If a user is
   filling out a form and opens another app in
   `multi-window <#>`__ mode to reference
   information, it is a bad user experience if they return to a cleared
   form or to somewhere else in the app entirely. As a developer, you
   must provide a consistent user experience through configuration
   changes and activity recreation.

   To verify whether state is preserved in your application, you can
   perform actions that cause configuration changes both while the app
   is in the foreground and while it is in the background. These actions
   include:

   -  Rotating the device
   -  Entering multi-window mode
   -  Resizing the application while in multi-window mode or a free-form
      window
   -  Folding a foldable device with multiple displays
   -  Changing the system theme, such as dark mode versus light mode
   -  Changing the font size
   -  Changing the system or app language
   -  Connecting or disconnecting a hardware keyboard
   -  Connecting or disconnecting a dock

   **Note:**\  Historically, you could prevent some of these
   configuration changes by restricting supported aspect ratios and
   orientations or disabling resizing. In Android 12L (API level 32) and
   higher, an app that has added these restrictions enters a
   `compatibility mode <#>`__ if it
   does not directly support the current device state. If an app has
   added these restrictions to avoid ``Activity`` recreation, make sure
   that the app functions correctly and that it does not lose state when
   unlocking those restrictions to make full use of the screen on all
   devices.
   There are three primary approaches you can take to preserve relevant
   state through ``Activity`` recreation. Which to use depends on the
   type of state you want to preserve:

   -  `Local persistence <#local>`__
      to handle process death for complex or large data. Persistent
      local storage includes databases or
      `DataStore <#>`__.
   -  `Retained objects <#viewmodel>`__
      such as
      `ViewModel <#>`__
      instances to handle UI-related state in memory while the user is
      actively using the app.
   -  `Saved instance state <#onsaveinstancestate>`__
      to handle system-initiated process death and keep transient state
      that depends on user input or navigation.

   To read about the APIs for each of these in detail, and when using
   each is appropriate, see `Save UI states <#>`__.

   .. rubric:: Restrict activity recreation
      :name: restrict-activity

   You can prevent automatic activity recreation for certain
   configuration changes. ``Activity`` recreation results in recreating
   the entire UI, and any objects derived from the ``Activity``. You
   might have good reasons to avoid this. For example, your app might
   not need to update resources during a specific configuration change,
   or you might have a performance limitation. In that case, you can
   declare that your activity handles the configuration change itself
   and prevent the system from restarting your activity.

   To disable activity recreation for particular configuration changes,
   add the configuration type to ``android:configChanges`` in the
   ``<activity>`` entry in
   your ``AndroidManifest.xml`` file. Possible values appear in the
   documentation for the
   `android:configChanges <#config>`__
   attribute.

   The following manifest code disables ``Activity`` recreation for
   ``MyActivity`` when the screen orientation and keyboard availability
   change:

   .. code:: prettyprint

      <activity
          android:name=".MyActivity"
          android:configChanges="orientation|screenSize|screenLayout|keyboardHidden"
          android:label="@string/app_name">

   Some configuration changes always cause the activity to restart. You
   can't disable them. For example, you can't disable the `dynamic colors change <#>`__
   introduced in Android 12L (API level 32).

   **Warning:**\  Even when you disable activity recreation for a given
   configuration change, the change itself continues to occur. Disabling
   ``Activity`` recreation transfers the responsibility of handling that
   configuration change to the ``Activity``. If you disable ``Activity``
   recreation, your app must appropriately handle the change when it
   does occur.

   .. rubric:: React to configuration changes in the View system
      :name: react-changes-views

   In the ``View`` system, when a configuration change occurs for which
   you have disabled ``Activity`` recreation, the activity receives a
   call to
   `Activity.onConfigurationChanged() <#onConfigurationChanged>`__.
   Any attached views also receive a call to
   `View.onConfigurationChanged() <#onconfigurationchanged>`__.
   For configuration changes you have not added to
   ``android:configChanges``, the system recreates the activity as
   usual.

   **Warning:**\  In the ``View`` system, disabling ``Activity``
   recreation can make it much more difficult to use alternative
   resources. This is because the system no longer applies them for you.
   In apps built with the ``View`` system, only disable ``Activity``
   recreation as a last resort when you must avoid restarts due to a
   configuration change. It is not recommended for most applications.
   The ``onConfigurationChanged()`` callback method receives a
   `Configuration <#>`__
   object that specifies the new device configuration. Read the fields
   in the ``Configuration`` object to determine what your new
   configuration is. To make the subsequent changes, update the
   resources you use in your interface. When the system calls this
   method, your activity's ``Resources`` object is updated to return
   resources based on the new configuration. This lets you reset
   elements of your UI without the system restarting your activity.

   For example, the following ``onConfigurationChanged()``
   implementation checks whether a keyboard is available:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            override fun onConfigurationChanged(newConfig: Configuration) {
                super.onConfigurationChanged(newConfig)

                // Checks whether a keyboard is available
                if (newConfig.keyboardHidden === Configuration.KEYBOARDHIDDEN_YES) {
                    Toast.makeText(this, "Keyboard available", Toast.LENGTH_SHORT).show()
                } else if (newConfig.keyboardHidden === Configuration.KEYBOARDHIDDEN_NO) {
                    Toast.makeText(this, "No keyboard", Toast.LENGTH_SHORT).show()
                }
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            @Override
            public void onConfigurationChanged(Configuration newConfig) {
                super.onConfigurationChanged(newConfig);

                // Checks whether a keyboard is available
                if (newConfig.keyboardHidden == Configuration.KEYBOARDHIDDEN_YES) {
                    Toast.makeText(this, "Keyboard available", Toast.LENGTH_SHORT).show();
                } else if (newConfig.keyboardHidden == Configuration.KEYBOARDHIDDEN_NO){
                    Toast.makeText(this, "No keyboard", Toast.LENGTH_SHORT).show();
                }
            }

   If you don't need to update your application based on these
   configuration changes, you can instead not implement
   ``onConfigurationChanged()``. In that case, all the resources used
   before the configuration change are still used, and you only avoided
   the restart of your activity. For example, a TV app might not want to
   react when a Bluetooth keyboard is attached or detached.

   .. rubric:: Retain state
      :name: retain-state

   When you use this technique, you must still retain state during the
   normal activity lifecycle. This is because of the following:

   -  **Unavoidable changes:** configuration changes that you cannot
      prevent can restart your application.
   -  **Process death:** your application must be able to handle
      system-initiated process death. If the user leaves your
      application and the app goes to the background, the system might
      destroy the app.

   **Important:**\  When you disable activity recreation for a
   configuration change, you are responsible for resetting any elements
   for which you provide alternatives. For example, if you disable
   activity recreation for an ``Activity`` that has images that change
   between landscape and portrait, you must reassign each resource to
   each element during
   `onConfigurationChanged <#onConfigurationChanged>`__\ ().

   .. rubric:: React to configuration changes in Jetpack Compose
      :name: react-changes-compose

   Jetpack Compose lets your app more easily react to configuration
   changes. However, if you disable ``Activity`` recreation for all
   configuration changes where it is possible to do so, your app still
   must correctly handle configuration changes.

   The
   `Configuration <#>`__
   object is available in the Compose UI hierarchy with the
   `LocalConfiguration <#LocalConfiguration>`__
   composition local. Whenever it changes, composable functions reading
   from ``LocalConfiguration.current`` recompose. For information about
   how composition locals work, see `Locally scoped data with CompositionLocal <#>`__.

   **Important:**\  As discussed in the `Restrict ``Activity``
   recreation <#restrict-activity>`__ section, it is impossible to
   entirely disable ``Activity`` recreation in an Android app, so it is
   still necessary to save state correctly when the system recreates an
   ``Activity``. In addition, views embedded in Compose with the
   `interoperability APIs <#>`__,
   such as ``AndroidView``, can expect ``Activity`` recreation to occur
   on configuration changes. Also, if a composable function recomposes
   due to a configuration change, views used inside the interoperability
   APIs recompose as well.

   .. rubric:: Example
      :name: example

   In the following example, a composable displays a date with a
   specific format. The composable reacts to system locale configuration
   changes by calling
   `ConfigurationCompat.getLocales() <#getLocales>`__
   with ``LocalConfiguration.current``.

   .. code:: prettyprint

      @Composable
      fun DateText(year: Int, dayOfYear: Int) {
          val dateTimeFormatter = DateTimeFormatter.ofPattern(
              "MMM dd",
              ConfigurationCompat.getLocales(LocalConfiguration.current)[0]
          )
          Text(
              dateTimeFormatter.format(LocalDate.ofYearDay(year, dayOfYear))
          )
      }

   To avoid ``Activity`` recreation when the locale changes, the
   ``Activity`` hosting the Compose code needs to opt out of locale
   configuration changes. To do so, you set ``android:configChanges`` to
   ``locale|layoutDirection``.

   **Warning:**\  For composable functions to recompose, the read state
   must be of type
   `State <#>`__.
   This is the case with configuration-related composition locals and
   ``LocalConfiguration`` in particular. Attempting to read the current
   locale in Compose using ``Locale.getDefault()`` doesn't cause the
   composable to recompose and doesn't react to configuration changes.
   This is because it's of type ``State``. For more information about
   state in Compose, see `State and Jetpack Compose <#>`__.

   .. rubric:: Configuration changes: Key concepts and best practices
      :name: configuration-changes

   These are the key concepts you need to know when working on
   configuration changes:

   -  **Configurations:** device configurations define how the UI
      displays to the user, such as app display size, locale, or system
      theme.
   -  **Configuration changes:** configurations change through user
      interaction. For example, the user might change device settings or
      how they physically interact with the device. There's no way to
      prevent configuration changes.
   -  **``Activity`` recreation:** configuration changes result in
      ``Activity`` recreation by default. This is a built-in mechanism
      to re-initialize app state for the new configuration.
   -  **``Activity`` destruction:** ``Activity`` recreation causes the
      system to destroy the old ``Activity`` instance and create a new
      one in its place. The old instance is now obsolete. Any remaining
      references to it result in memory leaks, bugs, or crashes.
   -  **State:** state in the old ``Activity`` instance is not present
      in the new ``Activity`` instance, because they are two different
      object instances. Preserve the app and user's state as described
      in `Save UI states <#>`__.
   -  **Opt-out:** opting out of activity recreation for a type of
      configuration change is a potential optimization. It requires that
      your app properly updates in reaction to the new configuration.

   To provide a good user experience, observe the following best
   practices:

   -  **Be prepared for frequent configuration changes:** don't assume
      that configuration changes are rare or never happen, regardless of
      API level, form factor, or UI toolkit. When a user causes a
      configuration change, they expect apps to update and continue to
      work correctly with the new configuration.
   -  **Preserve state:** don't lose the user's state when ``Activity``
      recreation occurs. Preserve the state as described in `Save UI states <#>`__.
   -  **Avoid opting out as a quick fix:** don't opt-out of ``Activity``
      recreation as a shortcut to avoid state loss. Opting out of
      activity recreation requires you to fulfill the promise of
      handling the change, and you can still lose the state due to
      ``Activity`` recreation from other configuration changes, process
      death, or closing the app. It is impossible to entirely disable
      ``Activity`` recreation. Preserve the state as described in `Save UI states <#>`__.
   -  **Don't avoid configuration changes:** don't put restrictions on
      orientation, aspect ratio, or resizability to avoid configuration
      changes and ``Activity`` recreation. This negatively impacts users
      who want to use your app in their preferred way.

   .. rubric:: Handle size-based config changes
      :name: handle-size-based

   Size-based configuration changes can happen at any time and are more
   likely when your app runs on a `large screen <#>`__
   device where users can enter `multi-window mode <#config>`__.
   They expect your app to work well in that environment.

   There are two general types of size changes: significant and
   insignificant. A *significant* size change is one where a `different set of alternative resources <#alternative_layout_resources>`__
   applies to the new configuration due to a difference in screen size,
   such as width, height, or smallest width. These resources include
   those that the app defines itself and those from any of its
   libraries.

   .. rubric:: Restrict activity recreation for size-based config
      changes
      :name: restrict_activity_recreation_for_size-based_config_changes

   When you disable ``Activity`` recreation for size-based configuration
   changes, the system doesn't recreate the ``Activity``. Instead, it
   receives a call to
   `Activity.onConfigurationChanged() <#onConfigurationChanged>`__.
   Any attached views receive a call to
   `View.onConfigurationChanged() <#onconfigurationchanged>`__.

   **Important:**\  In Android 12 (API level 31) and Android 12L (API
   level 32), ``Activity.onConfigurationChanged()`` is called only when
   the change is significant. This is a bug that was fixed in future API
   versions.
   ``Activity`` recreation is disabled for size-based configuration
   changes when you have
   ``android:configChanges="screenSize|smallestScreenSize|orientation|screenLayout``"
   in your manifest file.

   .. rubric:: Allow activity recreation for size-based config changes
      :name: allow-activity

   On Android 7.0 (API level 24) and higher, ``Activity`` recreation
   *only* occurs for size-based configuration changes if the size change
   is significant. When the system doesn't recreate an ``Activity`` due
   to insufficient size, the system might call
   `Activity.onConfigurationChanged() <#onConfigurationChanged>`__
   and
   `View.onConfigurationChanged() <#onconfigurationchanged>`__
   instead.

   There are some caveats to observe regarding the ``Activity`` and
   ``View`` callbacks when the ``Activity`` isn't recreated:

   -  On Android 11 (API level 30) through Android 13 (API level 33),
      ``Activity.onConfigurationChanged()`` isn't called.
   -  There is a known issue where ``View.onConfigurationChanged()`` may
      not be called in some cases on Android 12L (API level 32) and
      early versions of Android 13 (API level 33). For more information,
      see `this public issue <https://issuetracker.google.com/issues/247143459>`__. This
      has since been addressed in later Android 13 releases and Android
      14.

   For code that is dependent on listening for size-based configuration
   changes, we recommend using a utility ``View`` with an overridden
   ``View.onConfigurationChanged()`` instead of relying on ``Activity``
   recreation or ``Activity.onConfigurationChanged()``.

   **Note:**\  ``Activity`` recreation isn't disabled if you have
   ``android:configChanges=""`` for the ``Activity`` in the manifest
   file. This also occurs with unrelated size-based configuration
   changes like ``android:configChanges="uiMode"``.

Last updated 2023-07-25 UTC.


/Localize your app
==================

.. container:: devsite-article-body clearfix

   Android runs on many devices in many regions. To reach the most
   users, make sure that your app handles text, audio files, numbers,
   currency, and graphics in ways appropriate to the locales where your
   app is used.

   This page describes best practices for localizing Android apps.

   You need to have a working knowledge of either Kotlin or the Java
   programming language and be familiar with `Android resource loading <#>`__, `declaring user interface elements in XML <#>`__, development
   considerations such as the `activity lifecycle <#>`__, and
   general principles of internationalization and localization.

   It is good practice to use the Android resource framework to separate
   the localized aspects of your app as much as possible from core app
   functionality.

   -  Put most or all of the *contents* of your app's user interface
      into resource files, as described on this page and in the `App resources overview <#>`__.
   -  The *behavior* of the user interface, on the other hand, is driven
      by your Kotlin-based or Java-based code. For example, if users
      input data that needs to be formatted or sorted differently
      depending on locale, then you use Kotlin or the Java programming
      language to handle the data programmatically. This page doesn't
      cover how to localize your Kotlin-based or Java-based code.

   For a short guide to localizing strings in your app, see `Support different languages and cultures <#>`__.

   .. rubric:: Overview: Resource switching in Android
      :name: resource-switching

   Resources are text strings, layouts, sounds, graphics, and any other
   static data that your Android app needs. An app can include multiple
   sets of resources, each customized for a different device
   configuration. When a user runs the app, Android automatically
   selects and loads the resources that best match the device.

   This page focuses on localization and locale. For a complete
   description of resource-switching and all the types of configurations
   that you can specify, such as screen orientation or touchscreen type,
   see `Provide alternative resources <#AlternativeResources>`__.

   When you write your app, you create default and alternative resources
   for your app to use. When users run your app, the Android system
   selects which resources to load based on the device's locale. To
   create resources, you place files within specially named
   subdirectories of the project's ``res/`` directory.

   .. rubric:: Why default resources are important
      :name: defaults-r-important

   When the app runs in any locale that you haven't provided
   locale-specific text for, Android loads the default strings from
   ``res/values/strings.xml``. If this default file is absent, or if
   it's missing a string that your app needs, then your app doesn't run
   and shows an error. The following example illustrates what can happen
   when the default text file is incomplete.

   *Example:*

   An app's Kotlin-based or Java-based code refers to just two strings,
   ``text_a`` and ``text_b``. The app includes a localized resource file
   (``res/values-en/strings.xml``) that defines ``text_a`` and
   ``text_b`` in English. The app also includes a default resource file
   (``res/values/strings.xml``) that includes a definition for
   ``text_a``, but not for ``text_b``.

   -  When this app is launched on a device with locale set to English,
      the app might run without a problem, because
      ``res/values-en/strings.xml`` contains both of the needed text
      strings.
   -  However, when this app is launched on a device set to a language
      other than English, the user sees an error message and a Force
      Close button. The app doesn't load.

   To prevent this situation, make sure that a
   ``res/values/strings.xml`` file exists and that it defines every
   needed string. This situation applies to all types of resources, not
   just strings: you need to create a set of default resource files
   containing all the resources that your app calls on, such as layouts,
   drawables, or animations. For information about testing, see the
   `Test for default resources <#test-for-default>`__ section.

   .. rubric:: Use resources for localization
      :name: using-framework

   This section discusses how to create default resources as well as
   alternative resources. It also explains how resources are assigned
   precedence and how you refer to your resources in code.

   .. rubric:: Create default resources
      :name: creating-defaults

   Put the app's default text in ``res/values/strings.xml``. For these
   strings, use the default language‚Äîthe language you expect most of
   your app's users to speak.

   The default resource set also includes any default drawables and
   layouts and can include other types of resources such as animations.
   These resources go in the following directories:

   -  ``res/drawable/``: required directory holding at least one graphic
      file, for the app's icon on Google Play
   -  ``res/layout/``: required directory holding an XML file that
      defines the default layout
   -  ``res/anim/``: required if you have any
      ``res/anim-``\ *``<qualifiers>``* folders
   -  ``res/xml/``: required if you have any
      ``res/xml-``\ *``<qualifiers>``* folders
   -  ``res/raw/``: required if you have any
      ``res/raw-``\ *``<qualifiers>``* folders

   **Tip:** In your code, examine each reference to an Android resource.
   Make sure that a default resource is defined for each one. Also make
   sure that the default string file is complete: a *localized* string
   file can contain a subset of the strings, but the *default* string
   file must contain them all.

   .. rubric:: Create alternative resources
      :name: creating-alternatives

   A large part of localizing an app is providing alternative text for
   different languages. In some cases, you also provide alternative
   graphics, sounds, layouts, and other locale-specific resources.

   An app can specify many ``res/``\ *``<qualifiers>``*\ ``/``
   directories, each with different qualifiers. To create an alternative
   resource for a different locale, you use a qualifier that specifies a
   language or a language-region combination. The name of a resource
   directory must conform to the naming scheme described in `Provide alternative resources <#AlternativeResources>`__,
   or else your app can't compile.

   *Example:*

   Suppose that your app's default language is English and that you want
   to localize all the text in your app to French and all the text
   except the app's title to Japanese. In this case, you create three
   ``strings.xml`` files, each stored in a locale-specific resource
   directory:

   #. ``res/values/strings.xml``
      Contains English text for all the strings that the app uses,
      including text for a string named ``title``.
   #. ``res/values-fr/strings.xml``
      Contain French text for all the strings, including ``title``.
   #. ``res/values-ja/strings.xml``
      Contain Japanese text for all the strings *except* ``title``.

   If your Kotlin-based or Java-based code refers to ``R.string.title``,
   here is what happens at runtime:

   -  If the device is set to any language other than French, Android
      loads ``title`` from the ``res/values/strings.xml`` file.
   -  If the device is set to French, Android loads ``title`` from the
      ``res/values-fr/strings.xml`` file.

   If the device is set to Japanese, Android looks for ``title`` in the
   ``res/values-ja/strings.xml`` file. But because no such string is
   included in that file, Android falls back to the default, and loads
   the ``title`` in English from the ``res/values/strings.xml`` file.

   .. rubric:: Which resources take precedence?
      :name: resource-precedence

   If multiple resource files match a device's configuration, Android
   follows a set of rules in deciding which file to use. Among the
   qualifiers that can be specified in a resource directory name, locale
   almost always takes precedence.

   *Example:*

   Assume that an app includes a default set of graphics and two other
   sets of graphics, each optimized for a different device setup:

   -  ``res/drawable/``
      Contains default graphics.
   -  ``res/drawable-small-land-stylus/``
      Contains graphics optimized for use with a device that expects
      input from a stylus and has a QVGA low-density screen in landscape
      orientation.
   -  ``res/drawable-ja/``
      Contains graphics optimized for use with Japanese.

   If the app runs on a device that is configured to use Japanese,
   Android loads graphics from ``res/drawable-ja/``, even if the device
   happens to be one that expects input from a stylus and has a QVGA
   low-density screen in landscape orientation.

   **Exception:** The only qualifiers that take precedence over locale
   in the selection process are mobile country code (MCC) and mobile
   network code (MNC).

   *Example:*

   Assume that you have the following situation:

   -  The app code calls for ``R.string.text_a``
   -  Two relevant resource files are available:

      -  ``res/values-mcc404/strings.xml``, which includes ``text_a`` in
         the app's default language, in this case English.
      -  ``res/values-hi/strings.xml``, which includes ``text_a`` in
         Hindi.

   -  The app is running on a device that has the following
      configuration:

      -  The SIM card is connected to a mobile network in India (MCC
         404).
      -  The language is set to Hindi (``hi``).

   Android loads ``text_a`` from ``res/values-mcc404/strings.xml`` (in
   English), even if the device is configured for Hindi. That is because
   in the resource-selection process, Android prefers an MCC match over
   a language match.

   The selection process isn't always as straightforward as these
   examples suggest. For a more nuanced description of the process, see
   `How android finds the best-matching resource <#BestMatch>`__.
   All the qualifiers are described and listed in order of precedence in
   the `App resources overview <#table2>`__.

   .. rubric:: Refer to resources in code
      :name: referring-to-resources

   In your app's Kotlin-based or Java-based code, you refer to resources
   using the syntax
   ``R.``\ *``resource_type``*\ ``.``\ *``resource_name``* or
   ``android.R.``\ *``resource_type``*\ ``.``\ *``resource_name``.* For
   more information, see `Access your app resources <#>`__.

   .. rubric:: Manage strings for localization
      :name: managing-strings

   This section describes best practices for managing your strings
   related to localization.

   .. rubric:: Move all strings into strings.xml
      :name: move-strings-xml

   As you build your apps, don't hardcode any strings. Instead, declare
   all your strings as resources in a default ``strings.xml`` file,
   which makes it easy to update and localize them. Strings in the
   ``strings.xml`` file can be easily extracted, translated, and
   integrated back into your app, with appropriate qualifiers, without
   any changes to the compiled code.

   If you generate images with text, put those strings in
   ``strings.xml`` as well, and regenerate the images after translation.

   .. rubric:: Follow Android guidelines for UI strings
      :name: follow-guidelines-ui-strings

   As you design and develop your UIs, pay close attention to how you
   talk to your user. In general, use a succinct style that is friendly
   but brief, and use a consistent style throughout your UIs.

   Make sure that you read and follow the Material Design
   recommendations for `writing style and word choice <https://m1.material.io/style/writing.html#writing-language>`__.
   Doing so makes your apps appear more polished to the user and helps
   users understand your UI more quickly.

   Also, always use Android standard terminology wherever possible, such
   as for UI elements like the app bar, options menu, system bar, and
   notifications. Using Android terms correctly and consistently makes
   translation easier and results in a better end-product for users.

   .. rubric:: Provide sufficient context for declared strings
      :name: provide-context-strings

   As you declare strings in your ``strings.xml`` file, make sure to
   describe the context in which the string is used. This information is
   invaluable to the translator and results in better quality
   translation. It also helps you manage your strings more effectively.

   Here is an example:

   .. code:: prettyprint

      <!-- The action for submitting a form. This text is on a button that can fit 30 chars -->
      <string name="login_submit_button">Sign in</string>

   Consider providing context information like the following:

   -  What is this string for? When and where is it presented to the
      user?
   -  Where is this in the layout? For example, translations are less
      flexible in buttons than in text boxes.

   .. rubric:: Mark message parts that aren't to be translated
      :name: mark-message-parts

   Often, strings contain text that isn't meant to be translated into
   other languages. Common examples are a piece of code, a placeholder
   for a value, a special symbol, or a name. As you prepare your strings
   for translation, look for and mark text that must remain as-is,
   without translation, so that the translator doesn't change it.

   To mark text that isn't to be translated, use an ``<xliff:g>``
   placeholder tag. Here is an example tag that indicates that the text
   ``"%1$s"`` isn't to be changed during translation, to avoid breaking
   the message:

   .. code:: prettyprint

      <string name="countdown">
        <xliff:g id="time" example="5 days">%1$s</xliff:g> until holiday
      </string>

   When you declare a placeholder tag, add an ID attribute that explains
   what the placeholder is for. If your app later replaces the
   placeholder value, be sure to provide an example attribute to clarify
   the expected use.

   Here are some more examples of placeholder tags:

   .. code:: prettyprint

      <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
      <!-- Example placeholder for a special Unicode symbol -->
      <string name="star_rating">Check out our 5
          <xliff:g id="star">\u2605</xliff:g>
      </string>
      <!-- Example placeholder for a URL -->
      <string name="app_homeurl">
          Visit us at <xliff:g
          id="application_homepage">http://my/app/home.html</xliff:g>
      </string>
      <!-- Example placeholder for a name -->
      <string name="prod_name">
          Learn more at <xliff:g id="prod_gamegroup">Game Group</xliff:g>
      </string>
      <!-- Example placeholder for a literal -->
      <string name="promo_message">
          Please use the "<xliff:g id="promotion_code">ABCDEFG</xliff:g>" to get a discount.
      </string>
      ...
      </resources>

   .. rubric:: Localization checklist
      :name: checklist

   For a complete overview of the process of localizing and distributing
   an Android app, see `Translate and localize your app <https://support.google.com/googleplay/android-developer/answer/9844778?_ga=2.188605422.756657181.1679783723-1569914833.1659556491>`__.

   .. rubric:: Localization tips
      :name: strategies

   Follow these tips as you localize your app.

   .. rubric:: Design your app to work in any locale
      :name: failing2

   Don't assume anything about the device on which a user runs your app.
   The device might have hardware that you were not anticipating, or it
   might be set to a locale that you didn't plan for or that you can't
   test. Design your app so that it functions normally or fails
   gracefully no matter what device it runs on.

   **Important:** Make sure that your app includes a full set of default
   resources: include ``res/drawable/`` and a ``res/values/`` folders
   without any additional modifiers in the folder names, that contain
   all the images and text that your app needs.

   If an app is missing even one default resource, it doesn't run on a
   device that is set to an unsupported locale. For example, if the
   ``res/values/strings.xml`` default file lacks one string that the app
   needs, when the app runs in an unsupported locale and attempts to
   load ``res/values/strings.xml``, the user sees an error message and a
   Force Close button.

   For more information, see the `Test for default resources <#test-for-default>`__ section.

   .. rubric:: Design a flexible layout
      :name: design-a-flexible-layout

   If you need to rearrange your layout to fit a certain language, you
   can create an alternative layout for that language, such as
   ``res/layout-de/main.xml`` for a German-language layout. However,
   doing this can make your app harder to maintain. It is better to
   create a single layout that is more flexible.

   Another typical situation is a language that requires something
   different in its layout. For example, you might have a contact form
   that includes two name fields when the app runs in Japanese, but
   three name fields when the app runs in some other language. You can
   handle this in either of two ways:

   -  Create one layout with a field that you can programmatically
      enable or disable, based on the language.
   -  Have the main layout include another layout that includes the
      changeable field. The second layout can have different
      configurations for different languages.

   .. rubric:: Avoid creating more resource files and text strings than
      you need
      :name: avoid-creating-more-resource-files-and-text-strings-than-you-need

   You probably don't need to create a locale-specific alternative for
   every resource in your app. For example, the layout defined in the
   ``res/layout/main.xml`` file might work in any locale, in which case
   there is no need to create any alternative layout files.

   Also, you might not need to create alternative text for every string.
   For example, assume the following:

   -  Your app's default language is American English. Every string that
      the app uses is defined, using American English spellings, in
      ``res/values/strings.xml``.
   -  For a few important phrases, you want to provide British English
      spelling. You want these alternative strings to be used when your
      app runs on a device in the United Kingdom.

   To do this, create a small file called
   ``res/values-en-rGB/strings.xml`` that includes only the strings that
   are different when the app runs in the U.K. For all the rest of the
   strings, the app falls back to the defaults and uses what is defined
   in ``res/values/strings.xml``.

   .. rubric:: Use the Android Context object for manual locale lookup
      :name: use-the-android-context-object-for-manual-locale-lookup

   You can look up the locale using the
   `Context <#>`__ object that
   Android makes available, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val primaryLocale: Locale = context.resources.configuration.locales[0]
               val locale: String = primaryLocale.displayName

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Locale primaryLocale = context.getResources().getConfiguration().getLocales().get(0);
               String locale = primaryLocale.getDisplayName();

   .. rubric:: Use the app translation service
      :name: use-the-app-translation-service

   The `App Translation Service <https://support.google.com/l10n/answer/6359997>`__ is
   integrated into the `Play Console <https://support.google.com/l10n/answer/6341304>`__. It lets
   you get an instant quote and place an order with a translation
   company. You can order translations into one or more languages for
   app UI strings, Play Store Listing text, IAP names, and ad campaign
   text.

   .. rubric:: Test localized apps
      :name: testing

   Test your localized app on a device or using the Android Emulator. In
   particular, test your app to ensure that all the necessary default
   resources are included.

   .. rubric:: Test on a device
      :name: device

   Bear in mind that the device you are testing on might be
   significantly different from the devices available to consumers in
   other places. The locales available on your device can differ from
   those available on other devices. Also, the resolution and density of
   the device screen might differ, which can affect the display of
   strings and drawables in your UI.

   To change the locale or language on a device, use the Settings app.

   .. rubric:: Test on an emulator
      :name: emulator

   For details about using the emulator, see `Run apps on the Android Emulator <#>`__.

   .. rubric:: Create and using a custom locale
      :name: create-and-using-a-custom-locale

   A "custom" locale is a language or region combination that the
   Android system image doesn't explicitly support. You can test how
   your app runs in a custom locale by creating a custom locale in the
   emulator. There are two ways to do this:

   -  Use the Custom Locale app, which is accessible from the app tab.
      After you create a custom locale, switch to it by touching &
      holding the locale name.
   -  Change to a custom locale from the ``adb`` shell, as described in
      the following section.

   When you set the emulator to a locale that isn't available in the
   Android system image, the system itself displays in its default
   language. Your app, however, localizes properly.

   .. rubric:: Change the emulator locale from the adb shell
      :name: change-the-emulator-locale-from-the-adb-shell

   To change the locale in the emulator by using the ``adb`` shell, do
   the following:

   #. Pick the locale you want to test and determine its BCP-47 language
      tag, such as ``fr-CA`` for Canadian French.
   #. Launch an emulator.
   #. From a command-line shell on the host computer, run the following
      command:
      ``adb shell``
      or, if you have a device attached, specify that you want the
      emulator by adding the ``-e`` option:
      ``adb -e shell``
   #. At the ``adb`` shell prompt (``#``), run this command:
      ``setprop persist.sys.locale [``\ *``BCP-47 language tag``*\ ``];stop;sleep 5;start``
      Replace the bracketed sections with the appropriate codes from
      Step 1.
      For instance, to test in Canadian French:
      ``setprop persist.sys.locale fr-CA;stop;sleep 5;start``

   This causes the emulator to restart. Once the Home screen appears
   again, re-launch your app, and the app launches with the new locale.

   .. rubric:: Test for default resources
      :name: test-for-default

   To test whether an app includes every string resource that it needs,
   do the following:

   #. Set the emulator or device to a language that your app doesn't
      support. For example, if the app has French strings in
      ``res/values-fr/`` but doesn't have any Spanish strings in
      ``res/values-es/``, then set the emulator's locale to Spanish. You
      can use the Custom Locale app to set the emulator to an
      unsupported locale.
   #. Run the app.
   #. If the app shows an error message and a Force Close button, it
      might be looking for a string that isn't available. Make sure that
      your ``res/values/strings.xml`` file includes a definition for
      every string that the app uses.

   If the test is successful, repeat it for other types of
   configurations. For example, if the app has a layout file called
   ``res/layout-land/main.xml`` but doesn't contain a file called
   ``res/layout-port/main.xml``, then set the emulator or device to
   portrait orientation and see whether the app runs.

.. container:: devsite-steps

Last updated 2024-01-03 UTC.

/Test your app with pseudolocales
=================================

.. container:: devsite-article-body clearfix

   A pseudolocale is a locale that is designed to simulate
   characteristics of languages that cause UI, layout, and other
   translation-related problems when an app is translated. Pseudolocales
   are created by instant and automatic translations that are readable
   in English for all *localizable* messages. Un-pseudolocalized text
   points to untranslatable messages in your source code.

   Pseudolocales save time and money because you can make adjustments to
   the UI text and its layout before you commit your messages to the
   source repository to be sent for translation later. For a list of
   potential translation problems, see the `Spot localization issues <#spot_localization_issues>`__ section.

   .. container:: attempt-right

      .. image:: https://developer.android.google.cn/static/images/develop/pseudo-locale-example-app_2x.png 
         :width: 291px

      **Figure 1.** English (XA) pseudolocale.

   The Android pseudolocale names follow standard locale naming
   conventions, and their locale IDs can be parsed by any BCP 47
   compliant programming language. In this sense, pseudolocales are just
   like any other locales, such as French, Chinese, or Russian.

   The Android platform provides the following two pseudolocales to
   represent left-to-right (LTR) and right-to-left (RTL) languages:

   .. container:: attempt-right

      .. image:: https://developer.android.google.cn/static/images/develop/pseudo-locale-example-app-rtl_2x.png 
         :width: 291px

      **Figure 2.** AR (XB) pseudolocale.

   **English (XA):** adds Latin accents to the base English UI text,
   expands the original text by adding non-accented text, and brackets
   each message unit to expose potential issues from expanded text.
   Potential issues can be layout breakage and badly formed message
   syntax, such as a sentence split into multiple parts displaying as
   multiple bracketed messages. The English (XA) pseudolocale is shown
   in figure 1.

   **AR (XB):** sets the text direction of the original left-to-right
   messages to the right-to-left direction, which reverses the order of
   the characters in the original message. The AR (XB) pseudolocale is
   shown in figure 2.

   Pseudolocales can help you make an RTL version of your app, even if
   you don't write or speak any RTL languages.

   .. rubric:: Enable pseudolocales
      :name: enable_pseudolocales

   Pseudolocales are usually added to developer-oriented builds. When
   you choose a pseudolocale on your device, all the apps that support
   pseudolocales take on the characteristics of the selected
   pseudolocale, including all the system apps such as the Settings app
   and Quick Settings panel.

   To use the Android pseudolocales, you must be running Android 4.3
   (API level 18) or higher and have `developer options <#>`__ enabled on your device.

   The following procedure explains how to enable pseudolocales:

   #. In Android Studio, enable pseudolocales for a specific app by
      adding the following configuration to your ``build.gradle`` file:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Groovy
                  :name: groovy

               .. code:: prettyprint

                  android {
                     ...
                     buildTypes {
                         debug {
                             pseudoLocalesEnabled true
                         }
                     }
                  }

            .. container:: section

               .. rubric:: Kotlin
                  :name: kts

               .. code:: prettyprint

                  android {
                     ...
                     buildTypes.getByName("debug") {
                         isPseudoLocalesEnabled = true
                     }
                  }

   #. `Build and run your app <#>`__.

      .. container:: attempt-right

         |image.. image:: https://developer.android.google.cn/static/images/develop/pseudo-locale-select_2x.png 
            :width: 291px

         **Figure 3.** Select a pseudolocale.

   #. Use the Settings app to select a pseudolocale. This step varies
      based on your Android version, as follows:

      **Android 5.0 (API level 21) or higher**

      a. On the device, open the Settings app and tap **Languages and
         input > Language preferences**.
      b. In the **Language preferences** list, drag the tab to move a
         pseudolocale to the top of the list and make it the active
         language. See figure 3.

      **Android 4.4.4 (API level 19) or lower**

      a. On the device, open the Settings app and tap **Languages and
         input > Language preferences > Add a language**.
      b. Tap a pseudolocale to add it to the **Language preferences**
         list.
      c. In the **Language preferences** list, drag the tab to move a
         pseudolocale to the top of the list and make it the active
         language See figure 3.

   .. rubric:: Spot localization issues
      :name: spot_localization_issues

   Pseudolocales provide a time-saving and effective way to spot
   potential localizability issues in the UI by helping you identify
   problems in the following areas:

   -  Hardcoded strings, which can't be sent to translation, display as
      unaccented text in the pseudolocale to make them noticeable.

   -  UI layout issues caused by text expansion, showing where the UI
      can break due to text length.

   -  String concatenation, which displays as one message split across
      two or more brackets. This can make correct translation difficult,
      because translators have to translate each part independently
      without knowing that the parts are related. String concatenation
      can also make correct translation impossible, because different
      languages might require a different order of parts or a completely
      different sentence structure. For example, languages such as
      Japanese, Korean, and Tamil place the verb at the end of a
      sentence. When a sentence is concatenated, translators can't
      change the word order as needed.

   -  Bidirectional (BIDI) text problems, such as when content in one
      text direction includes an inline phrase in the opposite text
      direction, making the string difficult to read.

   -  Right-to-left (RTL) problems, such as elements not being mirrored.
      Some examples are a UI element not moving to the left, text not
      reversing and moving to the left, or misplaced punctuation, such
      as "pseudolocales rule!" changing to "elur selacoloduesp!" instead
      of "!elur selacoloduesp".

.. container:: devsite-steps

Last updated 2023-05-04 UTC.


/Unicode and internationalization support
=========================================

.. container:: devsite-article-body clearfix

   Android leverages the `ICU library <http://site.icu-project.org/>`__
   and `CLDR project <http://cldr.unicode.org/>`__ to provide Unicode
   and other internationalization support. This page's discussion of
   Unicode and internationalization support is divided into two
   sections: Android 6.0 (API level 23) and lower, and Android 7.0 (API
   level 24) and higher.

   .. rubric:: Unicode and internationalization support through Android
      6.0 (API level 23)
      :name: prenougat

   The Android platform uses ICU and CLDR to implement various classes
   for handling both Latin and non-Latin orthographies, exposing classes
   like `Locale <#>`__,
   `Character <#>`__, and many
   subclasses of
   `java.text <#>`__. An app that
   requires internationalization functionalities beyond the exposed
   classes, and targets versions of the platform through Android 6.0
   (API level 23), must include the ICU library.

   .. rubric:: Versioning
      :name: versioning-prenougat

   Successive releases of the Android platform correspond to newer
   versions of ICU and the corresponding CLDR and Unicode versions.
   Table 1 shows this correspondence through Android 6.0 (API level 23).

   **Table 1.** ICU and CLDR versions used through Android 6.0 (API
   level 23).

   ================================= ==== ====== =======
   Platform (API level)              ICU  CLDR   Unicode
   ================================= ==== ====== =======
   Android 1.5‚Äì2.0 (API levels 3‚Äì7)  3.8  1.5    5.0
   Android 2.2 (API level 8)         4.2  1.7    5.1
   Android 2.3‚Äì3.0 (API levels 9‚Äì13) 4.4  1.8    5.2
   Android 4.0 (API levels 14‚Äì15)    4.6  1.9    6.0
   Android 4.1 (API levels 16‚Äì17)    4.8  2.0    6.0
   Android 4.3 (API level 18)        50   22.1   6.2
   Android 4.4 (API levels 19‚Äì20)    51   23     6.2
   Android 5.0 (API levels 21‚Äì22)    53   25     6.3
   Android 6.0 (API level 23)        55.1 27.0.1 7.0
   ================================= ==== ====== =======

   The Android framework provides more comprehensive support for Unicode
   and internationalization for apps targeting Android 7.0 (API level
   24) and higher. The next section of this page provides details about
   that support.

   .. rubric:: Unicode and internationalization support in Android 7.0
      (API level 24) and higher
      :name: nougat

   For Android 7.0 (API level 24) and higher, the Android platform
   exposes a subset of the ICU4J APIs for app developers to use under
   the ``android.icu`` package. ICU4J is an open-source, widely used set
   of Java libraries providing Unicode and internationalization support
   for software applications.

   The ICU4J APIs use localization data present on the device. As a
   result, you can reduce your app's footprint by not compiling the
   ICU4J libraries into your app. Instead, you can call out to them in
   the framework. If you do this, you might want to provide `multiple versions of your APK <#>`__, so
   users running versions of Android lower than Android 7.0 (API level
   24) can download a version of the app that contains the ICU4J
   libraries.

   This section begins by providing some basic information on the
   minimum Android API levels required to support these libraries. It
   then explains what you need to know about the Android-specific
   implementation of ICU4J. Finally, it tells you how to use the ICU4J
   APIs in the Android framework.

   .. rubric:: ICU4J on Android
      :name: relation

   Android exposes a subset of the ICU4J APIs through the
   ``android.icu`` package, rather than ``com.ibm.icu``. Some ICU4J APIs
   are not exposed by the Android framework, for reasons such as the
   APIs being deprecated or not declared stable. As the ICU team
   deprecates APIs in the future, Android also marks them as deprecated
   but continues to include them.

   Here are a few reminders:

   -  The ICU4J Android framework APIs don't include all the ICU4J APIs.
   -  The APIs in the Android framework don't replace Android‚Äôs support
      for `localizing with resources <#>`__.
   -  In some cases, the Android framework supports more characters than
      the ICU libraries do. This is true, for example, of the
      `android.text <#>`__
      class's support for emoji.

   .. rubric:: Migrate to the android.icu package from com.ibm.icu
      :name: migration

   If you are already using the ICU4J APIs in your app, and the
   ``android.icu`` APIs meet your requirements, then migrating to the
   framework APIs requires you to change your Java imports from
   ``com.ibm.icu`` to ``android.icu``. You can then remove your own copy
   of ICU4J files from the app.

   **Note**: The ICU4J framework APIs use the ``android.icu`` namespace
   instead of ``com.ibm.icu``. This is to avoid namespace conflicts in
   apps that contain their own ``com.ibm.icu`` libraries.

   .. rubric:: Migrate to android.icu APIs from other Android SDK APIs
      :name: migrate-from-android

   Some classes in the ``java`` and ``android`` packages have
   equivalents to those found in ICU4J. However, ICU4J often provides
   broader support for standards and languages.

   Table 2 shows some examples of these equivalencies to get you
   started:

   **Table 2.**\ Android and Java ICU4J classes

   +-----------------------------------+----------------------------------+
   | Class                             | Alternatives                     |
   +===================================+==================================+
   | ``java.lang.Character``           | ``android.icu.lang.UCharacter``  |
   +-----------------------------------+----------------------------------+
   | ``java.text.BreakIterator``       | ``                               |
   |                                   | android.icu.text.BreakIterator`` |
   +-----------------------------------+----------------------------------+
   | ``java.text.DecimalFormat``       | ``                               |
   |                                   | android.icu.text.DecimalFormat`` |
   +-----------------------------------+----------------------------------+
   | ``java.util.Calendar``            | ``android.icu.util.Calendar``    |
   +-----------------------------------+----------------------------------+
   | ``android.text.BidiFormatter``    | ``android.icu.text.Bidi``        |
   +-----------------------------------+----------------------------------+
   | ``                                | ``android.icu.text.DateFormat``  |
   | android.text.format.DateFormat``  |                                  |
   +-----------------------------------+----------------------------------+
   |                                   | ``android.icu.text.DateFormat``  |
   | ``android.text.format.DateUtils`` | ``android.icu.                   |
   |                                   | text.RelativeDateTimeFormatter`` |
   +-----------------------------------+----------------------------------+

   .. rubric:: ICU4C on Android
      :name: icu4c

   Android exposes a subset of the ICU4C APIs through the ``libicu.so``
   library, rather than ``libicuuc.so`` or ``libicui18n.so``. The APIs
   are available starting with Android 12 (API level 31). The NDK
   headers are available starting with the NDK release r22b. No C++ API
   is exposed through the Android NDK. Some of the C APIs are not
   available.

   .. rubric:: Versioning
      :name: versioning-nougat

   Successive releases of the Android platform correspond to newer
   versions of ICU and the corresponding CLDR and Unicode versions.
   Table 3 shows this correspondence starting from Android 7.0 (API
   level 24).

   **Table 3.** ICU and CLDR versions used in Android 7.0 (API level 24)
   and higher.

   ====================================== ==== ====== =======
   Platform (API level)                   ICU  CLDR   Unicode
   ====================================== ==== ====== =======
   Android 7.0 - 7.1 (API levels 24 - 25) 56   28     8.0
   Android 8.0 - 8.1 (API levels 26 - 27) 58.2 30.0.3 9.0
   Android 9 (API level 28)               60.2 32.0.1 10.0
   Android 10 (API level 29)              63.2 34     11.0
   Android 11 (API level 30)              66.1 36     13.0
   Android 12 (API level 31)              68.2 38.1   13.0
   ====================================== ==== ====== =======

   .. rubric:: 24h/12h Time format setting
      :name: 24h-setting

   ICU on Android doesn't observe the user's 24h/12h time format
   setting, obtained from
   `DateFormat.is24HourFormat() <#is24HourFormat>`__.
   To observe this setting, either use
   `DateFormat <#>`__ or
   `DateUtils <#>`__ time
   formatting methods or use ICU time formatting patterns with
   appropriate hour pattern symbols ('h' for 12h, 'H' for 24h) for
   different ``is24HourFormat()`` return values. For example, this code
   generates a string with the current time that observes the user's
   12h/24h setting:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val skeleton: String = if (DateFormat.is24HourFormat(context)) "Hm" else "hm"
               val formattedTime: String = android.icu.text.DateFormat.getInstanceForSkeleton(
                       skeleton,
                       Locale.getDefault()).format(Date()
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               String skeleton = DateFormat.is24HourFormat(context) ? "Hm" : "hm";
               String formattedTime = android.icu.text.DateFormat.getInstanceForSkeleton(skeleton, Locale.getDefault()).format(new Date());

   .. rubric:: Stability of Transliterator
      :name: transliteration

   Starting from Android 10 (API level 29),
   `Transliterator <#>`__
   is provided to transliterate text from one format to another. The set
   of available transliteation IDs is unstable across Android releases
   and devices. Device manufacturers might add extra transliteration
   IDs. Developers must check the available IDs, obtained from
   `Transliterator.getAvailableIDs() <#getAvailableIDs>`__,
   before transliterating text.

   .. rubric:: Licensing
      :name: licence

   ICU4J is released under the ICU license. For details, see the `ICU user guide <http://userguide.icu-project.org/icufaq#TOC-How-is-the-ICU-licensed->`__.

.. container:: devsite-steps

Last updated 2024-05-03 UTC.

/Overview: Language and locale resolution overview
==================================================

.. container:: devsite-article-body clearfix

   Starting in Android 7.0 (API level 24), Android provides enhanced
   support for multilingual users, allowing them to select multiple
   locales in settings. Android provides this capability by greatly
   expanding the number of locales supported and changing the way the
   system resolves resources.

   This document starts by explaining the resource resolution strategy
   in versions of Android lower than 7.0 (API level 24). Next, it
   describes the improved resource resolution strategy in Android 7.0.
   Last, it explains how to take advantage of the expanded number of
   locales to support more multilingual users.

   .. rubric:: Challenges in resolving language resources
      :name: preN

   Prior to Android 7.0, Android could not always successfully match app
   and system locales.

   For example, assume that you have the following situation:

   -  Your app's default language is ``en_US`` (US English), and it also
      has Spanish strings localized in ``es_ES`` resource files.
   -  A device is set to ``es_MX``

   When your Java code refers to strings, the system would load strings
   from the default (``en_US``) resource file, even if the app has
   Spanish resources localized under ``es_ES``. This is because when the
   system cannot find an exact match, it continues to look for resources
   by stripping the country code off the locale. Finally, if no match is
   found, the system falls back to the default, which is ``en_US``.

   The system would also default to ``en_US`` if the user chose a
   language that the app didn't support at all, like French. For
   example:

   **Table 1.** Resource resolution without an exact locale match.

   +-----------------------+-----------------------+-----------------------+
   | User Settings         | App Resources         | Resource Resolution   |
   +-----------------------+-----------------------+-----------------------+
   | fr_CH                 | default (en)          | Try fr_CH => Fail     |
   |                       | de_DE                 | Try fr => Fail        |
   |                       | es_ES                 | Use default (en)      |
   |                       | fr_FR                 |                       |
   |                       | it_IT                 |                       |
   +-----------------------+-----------------------+-----------------------+

   In this example, the system displays English strings without knowing
   whether the user can understand English. This behavior is pretty
   common today.

   .. rubric:: Improvements to resource-resolution strategy
      :name: postN

   Android 7.0 (API level 24) brings more robust resource resolution,
   and finds better fallbacks automatically. However, to speed up
   resolution and improve maintainability, you should store resources in
   the most common parent dialect. For example, if you were storing
   Spanish resources in the ``values-es-rUS`` directory before, move
   them into the ``values-b+es+419`` directory, which contains Latin
   American Spanish. Similarly, if you have resource strings in a
   directory named ``values-en-rGB``, rename the directory to
   ``values-b+en+001`` (International English), because the most common
   parent for ``en-GB`` strings is ``en-001``. The following examples
   explain why these practices improve performance and reliability of
   resource resolution.

   .. rubric:: Resource resolution examples
      :name: resource-resolution-examples

   With versions of Android greater than 7.0, the case described in
   **Table 1** is resolved differently:

   **Table 2.** An improved resolution strategy for when there is no
   exact locale match.

   +-----------------------+-----------------------+-----------------------+
   | User Settings         | App Resources         | Resource Resolution   |
   +=======================+=======================+=======================+
   | #. fr_CH              | default (en)          | Try fr_CH => Fail     |
   |                       | de_DE                 | Try fr => Fail        |
   |                       | es_ES                 | Try children of fr => |
   |                       | fr_FR                 | fr_FR                 |
   |                       | it_IT                 | Use fr_FR             |
   +-----------------------+-----------------------+-----------------------+

   Now the user gets French resources instead of English. This example
   also shows why you should store French strings in ``fr`` rather than
   ``fr_FR`` for Android 7.0 or higher. Here the course of action is to
   match the closest parent dialect, making resolution faster and more
   predictable.

   In addition to this improved resolution logic, Android now offers
   more user languages to choose from. Let‚Äôs try the above example again
   with Italian specified as an additional user language, but without
   app support for French.

   **Table 3.** Resource resolution when the app only matches the user's
   second-preferred locale setting.

   +-----------------------+-----------------------+-----------------------+
   | User Settings         | App Resources         | Resource Resolution   |
   +=======================+=======================+=======================+
   | #. fr_CH              | default (en)          | Try fr_CH => Fail     |
   | #. it_CH              | de_DE                 | Try fr => Fail        |
   |                       | es_ES                 | Try children of fr => |
   |                       | it_IT                 | Fail                  |
   |                       |                       | Try it_CH => Fail     |
   |                       |                       | Try it => Fail        |
   |                       |                       | Try children of it => |
   |                       |                       | it_IT                 |
   |                       |                       | Use it_IT             |
   +-----------------------+-----------------------+-----------------------+

   The user still gets a language they understand, even though the app
   doesn‚Äôt support French.

   .. rubric:: Designing your app to support additional locales
      :name: design

   Android provides tools that make it easier to localize app content
   and engage users in their preferred languages. We recommend using the
   following techniques to configure your app so it can accommodate
   different languages and formatting conventions, in a scalable way.

   .. rubric:: Specify the languages your app supports
      :name: specify-the-languages-your-app-supports

   To ensure that languages are resolved correctly, specify the
   languages your app supports using the ``resConfigs`` property in the
   module-level ``build.gradle`` file.

   The following code sample shows how to use ``resConfigs`` to denote
   languages supported. In this example, the app supports both English
   and Spanish.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               android {
                   defaultConfig {
                       ...
                       resConfigs "en", "es"
                   }
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               android {
                   defaultConfig {
                       ...
                       resConfigs("en", "es")
                   }
               }

   Due to the way the build system merges resources from your app and
   its dependencies, you must specify supported languages in this way to
   ensure that user language settings are received correctly.

   .. rubric:: LocaleList API
      :name: localelist-api

   Starting with Android 7.0 (API level 24), Android exposes the
   ``LocaleList.getDefault()`` API that lets apps directly query the
   list of languages a user has specified. This API allows you to create
   more sophisticated app behavior and better-optimized display of
   content. For example, Search can show results in multiple languages
   based on user‚Äôs settings. Browser apps can avoid offering to
   translate pages in a language the user already knows, and keyboard
   apps can auto-enable all appropriate layouts.

   .. rubric:: Formatters
      :name: formatters

   Up through Android 6.0 (API level 23), Android supported only one or
   two locales for many common languages (en, es, ar, fr, ru). Because
   there were only a few variants of each language, apps could get away
   with storing some numbers and dates as hard coded strings in resource
   files. However, with Android's broadened set of supported locales,
   there can be significant differences in formats for dates, times,
   currencies, and similar information even within a single locale.
   Hard-coding your formats can produce a confusing experience for end
   users. Therefore, when developing for Android 7.0 or higher versions,
   make sure to use formatters instead of hard coding numbers and date
   strings.

   For example, Android 7.0 and higher includes support for 27 Arabic
   locales. These locales can share most resources, but some prefer
   ASCII digits, while others prefer native digits. For example, when
   you want to create a sentence with a digit variable, such as "Choose
   a 4 digit pin", use formatters as shown below:

   .. code:: none

       format(locale, "Choose a %d-digit PIN", 4)

.. container:: devsite-steps

Last updated 2021-09-17 UTC.


/Per-app language preferences
=============================

.. container:: devsite-article-body clearfix

   .. figure:: https://developer.android.google.cn/static/images/about/versions/13/app-languages.png
      :width: 285px

      Per-app languages in system settings

   In many cases, multilingual users set their system language to one
   language‚Äîsuch as English‚Äîbut they want to select other languages for
   specific apps, such as Dutch, Chinese, or Hindi. To help apps provide
   a better experience for these users, Android 13 introduces the
   following features for apps that support multiple languages:

   -  **System settings**: A centralized location where users can select
      a preferred language for each app.

      You can configure your app to automatically generate the files
      needed to support per-app language preferences and show up in the
      system settings. To learn more, see the instructions for `enabling automatic per-app language support <#auto-localeconfig>`__.

   -  **Additional APIs**: These public APIs, such as the
      `setApplicationLocales() <#setApplicationLocales>`__
      and
      `getApplicationLocales() <#getApplicationLocales>`__
      methods in
      `LocaleManager <#>`__, let
      apps set a different language from the system language at runtime.

      These APIs automatically sync with system settings; therefore,
      apps that use these APIs to create custom in-app language pickers
      will ensure their users have a consistent user experience
      regardless of where they select their language preferences. The
      public APIs also help you reduce the amount of boilerplate code,
      they support split APKs, and they support `Auto Backup for Apps <#>`__ to store app-level user
      language settings.

      For backward compatibility with previous Android versions,
      equivalent APIs are also available in AndroidX. However, the
      backward compatible APIs work with the AppCompatActivity context,
      not the application context, for Android 12 (API level 32) and
      earlier. Access the backward compatible APIs with `Appcompat 1.6.0 <#version_160_3>`__ or
      higher.

   .. rubric:: Overview of implementing this feature
      :name: impl-overview

   The following table shows recommended implementations based on
   different use cases.

   .. list-table::
      :widths: 36 36
      :header-rows: 1

      - 

         - Use case
         - Recommended implementation
      - 

         - Your app doesn't have an in-app language picker
         - 

            #. Enable automatic per-app language support to generate a
               ``LocaleConfig`` file and add your app's languages to
               system settings.
            #. Optionally, if you want to add an in-app language picker:
               use the AndroidX library and opt in to our `API implementation <#androidx-impl>`__ to support backward
               compatibility through ``autoStoreLocales``.
      - 

         - Your app already has an in-app language picker
         - 

            #. Enable automatic per-app language support to generate a
               ``LocaleConfig`` file and add your app's languages to
               system settings.
            #. Migrate your app's custom logic to use the `public APIs <#androidx-impl>`__ to ensure users see a consistent
               experience.
            #. Handle the following corner cases:

               #. Call ``AppCompatDelegate.setApplicationLocales()`` the
                  first time your app is run on a device running Android
                  13.
               #. Call ``AppCompatDelegate.setApplicationLocales()`` to
                  provide pre-existing user-requested locales to the
                  system for the following cases:

                  -  If you opt your app in to auto-storage for Android
                     12 (API level 32) and lower
                  -  If your app needs to `migrate data from a custom backup storage location <#custom-storage>`__

   .. rubric:: System settings for users
      :name: app-language-settings

   Starting in Android 13, Android includes a centralized location in
   system settings for setting per-app language preferences. To ensure
   your app's languages are configurable in system settings on devices
   running Android 13 or higher, enable automatic per-app language
   support (recommended) or `configure support manually <#use-localeconfig>`__.

   .. rubric:: Enable automatic per-app language support
      :name: auto-localeconfig

   **Note:**\  This feature won't make changes to your project in the
   same way as the `manual setup process <#use-localeconfig>`__.
   All changes from the automatic process are done in generated files.
   For example, you won't see an ``android:localeConfig`` entry in your
   app's manifest or a file at ``res/xml/locales_config.xml``. That is
   expected since all of the changes are generated automatically when
   the app is built.
   Starting with Android Studio Giraffe and AGP 8.1, you can configure
   your app to support `per-app language preferences <#>`__ automatically.
   Based on your project resources, AGP generates the ``LocaleConfig``
   file and adds a reference to it in the final manifest file, so you no
   longer have to do it manually. AGP uses the resources in the ``res``
   folders of your app modules and any library module dependencies to
   determine the locales to include in the ``LocaleConfig`` file. This
   means that if you add resources for a new language to your app, you
   don't have to worry about updating the ``LocaleConfig`` file.

   Note that the automatic per-app language feature supports apps that
   run Android 13 (API level 33) or higher. To use the feature, you must
   set ``compileSdkVersion`` to 33 or higher. To configure per-app
   language preferences for prior versions of Android, you still need to
   `use the APIs and in-app language pickers <#api-implementation>`__.

   **Caution:**\  If you turn on automatic per-app language support for
   an app in production, make sure that all the locales in your app and
   library module dependency resources are also ready to be published
   with your app.
   To enable automatic per-app language support, follow these steps:

   #. To turn the feature on, use the ``generateLocaleConfig`` setting
      in the ``androidResources {}`` block of the module-level
      ``build.gradle.kts`` file (``build.gradle`` file if you're using
      Groovy). The feature is off by default.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kts
                  :class: two-line-tab

               .. code:: prettyprint

                      android {
                        androidResources {
                          generateLocaleConfig = true
                        }
                      }
                      

            .. container:: section

               .. rubric:: Groovy
                  :name: groovy
                  :class: two-line-tab

               .. code:: prettyprint

                      android {
                        androidResources {
                          generateLocaleConfig true
                        }
                      }
                      

   #. Specify a default locale:

      #. In the app module's ``res`` folder, create a new file called
         ``resources.properties``.

      #. In the ``resources.properties`` file, set the default locale
         with the ``unqualifiedResLocale`` label. To format the locale
         names, see `How to form locale names <#locale-names>`__.

   AGP adds this default locale and any `alternative locales <#creating-alternatives>`__
   you've specified, using ``values-*`` directories in the ``res``
   folder, to the auto-generated ``LocaleConfig`` file.

   **Caution:**\  If automatic per-app language support is on, the build
   fails if you *do* manually create a ``LocaleConfig`` file. You must
   remove your manually created ``LocaleConfig`` file before you enable
   automatic per-app language support and build your app.

   .. rubric:: How to form locale names
      :name: locale-names

   To form locale names, combine the language code with the optional
   script and region codes, separating each with a dash:

   -  Language: Use the two- or three-letter `ISO 639-1 <http://www.loc.gov/standards/iso639-2/php/code_list.php>`__
      code.
   -  Script (optional): Use the `ISO 15924 <https://unicode.org/iso15924/iso15924-codes.html>`__\ code.
   -  Region (optional): Use either the two-letter `ISO 3166-1-alpha-2 <https://www.iso.org/obp/ui/#iso:pub:PUB500001:en>`__
      code or three-digit
      `UN_M.49 <https://unstats.un.org/unsd/methodology/m49/overview/>`__
      code.

   For example if your default locale is American English:

   .. code:: prettyprint

      unqualifiedResLocale=en-US

   .. rubric:: Use ``android:localeConfig`` to add supported languages
      to system settings
      :name: use-localeconfig

   **Note:**\  We recommend using `enabling automatic per-app language support <#auto-localeconfig>`__ instead of configuring it manually if
   possible.
   You can manually set up your app to to ensure its languages are
   configurable in system settings on devices running Android 13 or
   higher. To do this, create a ``locales_config`` XML file and add it
   your app's manifest using the ``android:localeConfig`` attribute.
   Omitting the ``android:localeConfig`` manifest entry signals that
   users shouldn't be able to set your app's language independent of
   their system language within their system settings.

   To manually add your app's supported languages to a user's system
   settings:

   #. Create a file called ``res/xml/locales_config.xml`` and specify
      your app's languages, including your app's `ultimate fallback locale <#>`__, which is
      the locale specified in ``res/values/strings.xml``.

      See `How to form locale names <#locale-names>`__ for the format
      requirements. See also the `sample ``locale_config.xml``\ file <#sample-config>`__ for a list of the
      most commonly used locales.

      For example, format the ``locales_config.xml`` file like this for
      an app that supports the following languages:

      -  English (United States) as the ultimate fallback locale
      -  English (United Kingdom)
      -  French
      -  Japanese
      -  Chinese (Simplified, Macau)
      -  Chinese (Traditional, Macau)

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <locale-config xmlns:android="http://schemas.android.com/apk/res/android">
            <locale android:name="en-US"/>
            <locale android:name="en-GB"/>
            <locale android:name="fr"/>
            <locale android:name="ja"/>
            <locale android:name="zh-Hans-MO"/>
            <locale android:name="zh-Hant-MO"/>
         </locale-config>

   #. In the manifest, add a line pointing to this new file:

      .. code:: prettyprint

         <manifest>
             ...
             <application
                 ...
                 android:localeConfig="@xml/locales_config">
             </application>
         </manifest>

   You can dynamically update your app's ``localeConfig`` with
   ``LocaleManager.setOverrideLocaleConfig`` to customize the set of
   languages displayed in the per-app language list in Android Settings.
   This lets you customize the language list per region, run A/B
   experiments, and provide updated locales if your app utilizes
   server-side localization pushes as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               //For setOverrideLocaleConfig
               val localeManager = applicationContext
                   .getSystemService(LocaleManager::class.java)
               localeManager.overrideLocaleConfig = LocaleConfig(
               LocaleList.forLanguageTags("en-US,ja-JP,zh-Hans-SG")
               )

               //For getOverrideLocaleConfig
               // The app calls the API to get the override LocaleConfig
               val overrideLocaleConfig = localeManager.overrideLocaleConfig
               // If the returned overrideLocaleConfig isn't equal to NULL, then the app calls the API to get the supported Locales
               val supportedLocales = overrideLocaleConfig.supportedLocales()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               //For setOverrideLocaleConfig
               mContext.getSystemService(LocaleManager.class).setOverrideLocaleConfig(new LocaleConfig(LocaleList.forLanguageTags("en-US,ja-JP,zh-Hans-SG")));

               //For getOverrideLocaleConfig
               // The app calls the API to get the override LocaleConfig
               LocaleConfig overrideLocaleConfig = mContext.getSystemService(LocaleManager.class).getOverrideLocaleConfig();
               // If the returned overrideLocaleConfig isn't equal to NULL, then the app calls the API to get the supported Locales
               LocaleList supportedLocales = overrideLocaleConfig.getSupportedLocales();

   Additionally, IMEs can now use
   `LocaleManager.getApplicationLocales <#getApplicationLocales>`__
   to know the UI language of the current app to update the keyboard
   language as shown:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val currentAppLocales: LocaleList = applicationContext.getSystemService(LocaleManager::class.java).getApplicationLocales(appPackageName)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               LocaleList currentAppLocales =
                   mContext.getSystemService(LocaleManager.class).getApplicationLocales(appPackageName);

   .. rubric:: Specify supported languages in Gradle
      :name: gradle-config

   If not already present, specify the same languages using the
   `resourceConfigurations <#resourceConfigurations>`__
   property in your app's module-level ``build.gradle`` file:

   .. code:: prettyprint

      android {
        ...
        defaultConfig {
          resourceConfigurations += ["en", "en-rGB", "fr", "ja", "b+zh+Hans+MO", "b+zh+Hant+MO"]
        }
      }

   When the ``resourceConfigurations`` property is present, the build
   system only includes language resource in the APK for these specified
   languages, preventing translated strings from being included from
   other libraries that might support languages that your app does not
   support. For more information, see `specify the languages your app supports <#specify-the-languages-your-app-supports>`__.

   **Important:**\  If you're adding support for any languages for the
   first time, make sure to follow the guidance in `localize your app <#>`__ for those languages.
   Adding per-app language settings does not automatically translate
   your app's resources into those languages.

   .. rubric:: How users select an app language in system settings
      :name: how-user

   Users can select their preferred language for each app through the
   system settings. They can access these settings in two different
   ways:

   -  Access through the **System** settings

      **Settings > System > Languages & Input > App Languages > (select
      an app)**

   -  Access through **Apps** settings

      **Settings > Apps > (select an app) > Language**

   .. rubric:: Handle in-app language pickers
      :name: api-implementation

   For apps that already have an in-app language picker or want to use
   one, use the public APIs instead of custom app logic to handle
   setting and getting a user's preferred language for your app. If you
   use the public APIs for your in-app language picker, the device's
   system settings are automatically updated to match whichever language
   the user selects through your in-app experience.

   For backward compatibility with previous Android versions, we
   strongly recommend using the AndroidX support library when
   implementing an in-app language picker. However, you can also
   `implement the framework APIs directly <#framework-impl>`__ if you
   need to.

   .. rubric:: Implement using the AndroidX support library
      :name: androidx-impl

   Use the `setApplicationLocales() <#setApplicationLocales>`__
   and `getApplicationLocales() <#getApplicationLocales>`__
   methods in `Appcompat 1.6.0 <#version_160_3>`__ or
   higher. Note the backward compatible APIs work with the
   AppCompatActivity context, not the application context, for Android
   12 (API level 32) and earlier.

   **Caution:**\  If you're using Compose with
   ``setApplicationLocales()``, you must extend your activity from
   ``AppCompatActivity``. Otherwise, setting the app locale won't work.
   Refer to our `sample app <https://github.com/android/user-interface-samples/tree/main/PerAppLanguages/compose_app>`__
   to get started.
   For example, to set a user's preferred language, you would ask the
   user to select a locale in the language picker, then set that value
   in the system:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val appLocale: LocaleListCompat = LocaleListCompat.forLanguageTags("xx-YY")
               // Call this on the main thread as it may require Activity.restart()
               AppCompatDelegate.setApplicationLocales(appLocale)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               LocaleListCompat appLocale = LocaleListCompat.forLanguageTags("xx-YY");
               // Call this on the main thread as it may require Activity.restart()
               AppCompatDelegate.setApplicationLocales(appLocale);

   Note that calling ``setApplicationLocales()`` recreates your
   ``Activity``, unless your app `handles locale configuration changes <#>`__ by itself.

   Use
   `AppCompatDelegate.getApplicationLocales() <#getApplicationLocales>`__
   to retrieve the user's preferred locale. The user might have selected
   their app locale from `system settings <#app-language-settings>`__ or
   from your in-app language picker.

   .. rubric:: Support Android 12 and lower
      :name: android12-impl

   To support for devices running Android 12 (API level 32) and lower,
   tell AndroidX to handle locale storage by setting an
   ``autoStoreLocales`` value to ``true`` and ``android:enabled`` to
   ``false`` in the manifest entry for your app's
   ``AppLocalesMetadataHolderService`` service, as shown in the
   following code snippet:

   .. code:: prettyprint

      <application
        ...
        <service
          android:name="androidx.appcompat.app.AppLocalesMetadataHolderService"
          android:enabled="false"
          android:exported="false">
          <meta-data
            android:name="autoStoreLocales"
            android:value="true" />
        </service>
        ...
      </application>

   Note that setting an ``autoStoreLocales`` value to ``true`` causes a
   blocking read on the main thread and might cause a
   `StrictMode <#>`__
   ``diskRead`` and ``diskWrite`` violation if you are logging thread
   violations. See
   `AppCompatDelegate.setApplicationLocales() <#setApplicationLocales>`__
   for more information.

   .. rubric:: Custom storage handling
      :name: custom-storage

   Omitting the manifest entry or setting ``autoStoreLocales`` to
   ``false`` signals that you are handling your own storage. In this
   case, you must provide the stored locales before ``onCreate`` in the
   activity lifecycle and gate calls to
   ``AppCompatDelegate.setApplicationLocales()`` in Android 12 (API
   level 32) or lower.

   If your app has a custom locale storage location, we recommend using
   a one-time handoff between your custom locale storage solution and
   ``autoStoreLocales`` so users continue to enjoy your app in the
   language they prefer. This is especially applicable in cases when
   your app is first run after a device has upgraded to Android 13. In
   this case, you can provide pre-existing, user-requested locales by
   retrieving the locales from your custom storage and passing the
   locales into ``AppCompatDelegate.setApplicationLocales()``.

   .. rubric:: Implement using the Android framework APIs
      :name: framework-impl

   While we strongly recommend that you use the AndroidX support library
   to implement in-app language pickers, you can also use the
   `setApplicationLocales() <#setApplicationLocales>`__
   and
   `getApplicationLocales() <#getApplicationLocales>`__
   methods in the Android framework for devices running Android 13.

   For example, to set a user's preferred language, you would ask the
   user to select a locale in the language picker, then set that value
   in the system:

   .. code:: prettyprint

      // 1. Inside an activity, in-app language picker gets an input locale "xx-YY"
      // 2. App calls the API to set its locale
      mContext.getSystemService(LocaleManager.class
          ).setApplicationLocales(new LocaleList(Locale.forLanguageTag("xx-YY")));
      // 3. The system updates the locale and restarts the app, including any configuration updates
      // 4. The app is now displayed in "xx-YY" language

   To get a user's current preferred language to display in the language
   picker, your app can get the value back from the system:

   .. code:: prettyprint

      // 1. App calls the API to get the preferred locale
      LocaleList currentAppLocales =
          mContext.getSystemService(LocaleManager.class).getApplicationLocales();
      // 2. App uses the returned LocaleList to display languages to the user

   .. rubric:: Additional best practices
      :name: additional-best

   Take note of the following best practices.

   .. rubric:: Consider language when invoking an intent in another app
      :name: consider-language

   Language-focused intents might allow you to specify the language you
   want the invoked app to be in. One example is the
   `EXTRA_LANGUAGE <#EXTRA_LANGUAGE>`__
   feature from the Speech Recognizer API.

   .. rubric:: Consider the Accept-Language header for Chrome Custom tab
      :name: consider-header

   Consider adding the `Accept-Language Header <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language>`__
   through the
   `Browser.EXTRA_HEADERS <#EXTRA_HEADERS>`__
   to open a web page in your app's language when invoking a Chrome
   Custom tab.

   .. rubric:: If you remove per-app language preferences within system
      settings, reset your app locale to the system locale
      :name: reset-locale

   If you remove your app's language preferences from system settings
   (by removing ``android:localeConfig`` from your app's
   ``AndroidManifest.xml``), users can't easily reset their app language
   back to the system default.

   For this reason, if you remove ``android:localeConfig``, consider
   resetting the app locale to the system locale using
   `LocaleListCompat.getEmptyLocaleList() <#getEmptyLocaleList>`__
   or
   `LocaleList.getEmptyLocaleList() <#getEmptyLocaleList>`__
   as seen in the following code snippet:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Use the AndroidX APIs to reset to the system locale for backward and forward compatibility
               AppCompatDelegate.setApplicationLocales(
                 LocaleListCompat.getEmptyLocaleList()
               )

               // Or use the Framework APIs for Android 13 and above to reset to the system locale
               val context = LocalContext.current
               context.getSystemService(LocaleManager::class.java)
                 .applicationLocales = LocaleList.getEmptyLocaleList()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Use the AndroidX APIs to reset to the system locale for backward and forward compatibility
               AppCompatDelegate.setApplicationLocales(
                 LocaleListCompat.getEmptyLocaleList()
               );

               // Or use the Framework APIs for Android 13 and above to reset to the system locale
               mContext.getSystemService(LocaleManager.class)
                 .setApplicationLocales(LocaleList.getEmptyLocaleList());

   .. rubric:: Additional resources
      :name: additional-resources

   .. container:: video-wrapper

   See our code samples, blog articles, and videos for additional
   information.

   -  `Per-App Language Preferences Part 1 <https://android-developers.googleblog.com/2022/11/per-app-language-preferences-part-1.html>`__
      blog
   -  `Per-App Language Preferences Part 2 <https://android-developers.googleblog.com/2022/12/per-app-language-preferences-part-2.html>`__
      blog
   -  `Sample Apps <https://github.com/android/user-interface-samples/tree/main/PerAppLanguages>`__
   -  `Building for a multilingual world <https://www.youtube.com/watch?v=Tq7TSUzAGm8>`__ video

   .. rubric:: Sample locale_config.xml file
      :name: sample-config

   By default, Android includes system-level translations in the Android
   Open Source Project (AOSP) for a standard set of the most
   commonly-used locales. The sample ``locale_config.xml`` file that's
   included in this section shows the suggested format for each of these
   locales. Reference this sample file to help you construct your own
   ``locale_config.xml`` file for the set of languages that your app
   supports.

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <locale-config xmlns:android="http://schemas.android.com/apk/res/android">
         <locale android:name="af"/> <!-- Afrikaans -->
         <locale android:name="am"/> <!-- Amharic -->
         <locale android:name="ar"/> <!-- Arabic -->
         <locale android:name="as"/> <!-- Assamese -->
         <locale android:name="az"/> <!-- Azerbaijani -->
         <locale android:name="be"/> <!-- Belarusian -->
         <locale android:name="bg"/> <!-- Bulgarian -->
         <locale android:name="bn"/> <!-- Bengali -->
         <locale android:name="bs"/> <!-- Bosnian -->
         <locale android:name="ca"/> <!-- Catalan -->
         <locale android:name="cs"/> <!-- Czech -->
         <locale android:name="da"/> <!-- Danish -->
         <locale android:name="de"/> <!-- German -->
         <locale android:name="el"/> <!-- Greek -->
         <locale android:name="en-AU"/> <!-- English (Australia) -->
         <locale android:name="en-CA"/> <!-- English (Canada) -->
         <locale android:name="en-GB"/> <!-- English (United Kingdom) -->
         <locale android:name="en-IN"/> <!-- English (India) -->
         <locale android:name="en-US"/> <!-- English (United States) -->
         <locale android:name="en-XA"/> <!-- English (Pseudo-Accents) -->
         <locale android:name="es"/> <!-- Spanish (Spain) -->
         <locale android:name="es-US"/> <!-- Spanish (United States) -->
         <locale android:name="et"/> <!-- Estonian -->
         <locale android:name="eu"/> <!-- Basque -->
         <locale android:name="fa"/> <!-- Farsi -->
         <locale android:name="fi"/> <!-- Finnish -->
         <locale android:name="fr"/> <!-- French (France) -->
         <locale android:name="fr-CA"/> <!-- French (Canada) -->
         <locale android:name="gl"/> <!-- Galician -->
         <locale android:name="gu"/> <!-- Gujarati -->
         <locale android:name="hi"/> <!-- Hindi -->
         <locale android:name="hr"/> <!-- Croatian -->
         <locale android:name="hu"/> <!-- Hungarian -->
         <locale android:name="hy"/> <!-- Armenian -->
         <locale android:name="in"/> <!-- Indonesian -->
         <locale android:name="is"/> <!-- Icelandic -->
         <locale android:name="it"/> <!-- Italian -->
         <locale android:name="iw"/> <!-- Hebrew -->
         <locale android:name="ja"/> <!-- Japanese -->
         <locale android:name="ka"/> <!-- Georgian -->
         <locale android:name="kk"/> <!-- Kazakh -->
         <locale android:name="km"/> <!-- Khmer -->
         <locale android:name="kn"/> <!-- Kannada -->
         <locale android:name="ko"/> <!-- Korean -->
         <locale android:name="ky"/> <!-- Kyrgyz -->
         <locale android:name="lo"/> <!-- Lao -->
         <locale android:name="lt"/> <!-- Lithuanian -->
         <locale android:name="lv"/> <!-- Latvian -->
         <locale android:name="mk"/> <!-- Macedonian -->
         <locale android:name="ml"/> <!-- Malayalam -->
         <locale android:name="mn"/> <!-- Mongolian -->
         <locale android:name="mr"/> <!-- Marathi -->
         <locale android:name="ms"/> <!-- Malay -->
         <locale android:name="my"/> <!-- Burmese -->
         <locale android:name="my-MM"/> <!-- Burmese (Myanmar) -->
         <locale android:name="nb"/> <!-- Norwegian -->
         <locale android:name="ne"/> <!-- Nepali -->
         <locale android:name="nl"/> <!-- Dutch -->
         <locale android:name="or"/> <!-- Odia -->
         <locale android:name="pa"/> <!-- Punjabi -->
         <locale android:name="pl"/> <!-- Polish -->
         <locale android:name="pt-BR"/> <!-- Portuguese (Brazil) -->
         <locale android:name="pt-PT"/> <!-- Portuguese (Portugal) -->
         <locale android:name="ro"/> <!-- Romanian -->
         <locale android:name="ru"/> <!-- Russian -->
         <locale android:name="si"/> <!-- Sinhala -->
         <locale android:name="sk"/> <!-- Slovak -->
         <locale android:name="sl"/> <!-- Slovenian -->
         <locale android:name="sq"/> <!-- Albanian -->
         <locale android:name="sr"/> <!-- Serbian (Cyrillic) -->
         <locale android:name="sr-Latn"/> <!-- Serbian (Latin) -->
         <locale android:name="sv"/> <!-- Swedish -->
         <locale android:name="sw"/> <!-- Swahili -->
         <locale android:name="ta"/> <!-- Tamil -->
         <locale android:name="te"/> <!-- Telugu -->
         <locale android:name="th"/> <!-- Thai -->
         <locale android:name="tl"/> <!-- Filipino -->
         <locale android:name="tr"/> <!-- Turkish -->
         <locale android:name="uk"/> <!-- Ukrainian -->
         <locale android:name="ur"/> <!-- Urdu -->
         <locale android:name="uz"/> <!-- Uzbek -->
         <locale android:name="vi"/> <!-- Vietnamese -->
         <locale android:name="zh-CN"/> <!-- Chinese (Simplified) -->
         <locale android:name="zh-HK"/> <!-- Chinese (Hong Kong) -->
         <locale android:name="zh-TW"/> <!-- Chinese (Traditional) -->
         <locale android:name="zu"/> <!-- Zulu -->
      </locale-config>

.. container:: devsite-steps

Last updated 2024-03-11 UTC.


/Inline complex XML resources
=============================

.. container:: devsite-article-body clearfix

   Certain resource types are a composition of multiple complex
   resources represented by XML files. One example is an animated vector
   drawable, which is a drawable resource encapsulating a vector
   drawable and an animation. This requires the use of at least three
   XML files, as shown in the following examples.

   ``res/drawable/avd.xml``
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
             android:drawable="@drawable/vectordrawable" >
             <target
                 android:name="rotationGroup"
                 android:animation="@anim/rotation" />
         </animated-vector>

   ``res/drawable/vectordrawable.xml``
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <vector xmlns:android="http://schemas.android.com/apk/res/android"
             android:height="64dp"
             android:width="64dp"
             android:viewportHeight="600"
             android:viewportWidth="600" >
             <group
                 android:name="rotationGroup"
                 android:pivotX="300.0"
                 android:pivotY="300.0"
                 android:rotation="45.0" >
                 <path
                     android:fillColor="#000000"
                     android:pathData="M300,70 l 0,-70 70,70 0,0 -70,70z" />
             </group>
         </vector>

   ``res/anim/rotation.xml``
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <objectAnimator xmlns:android="http://schemas.android.com/apk/android"
             android:duration="6000"
             android:propertyName="rotation"
             android:valueFrom="0"
             android:valueTo="360" />

   If the vector drawable and animations are re-used elsewhere, this is
   the best way to implement an animated vector drawable. But if these
   files are only used for this animated vector drawable, then there is
   a more compact way to implement them.

   Using AAPT‚Äôs inline resource format, you can define all three
   resources in the same XML file, as shown in the following example.
   For an animated vector drawable, put the file under
   ``res/drawable/``.

   ``res/drawable/avd.xml``
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
             xmlns:aapt="http://schemas.android.com/aapt" >

             <aapt:attr name="android:drawable" >
                 <vector
                     android:height="64dp"
                     android:width="64dp"
                     android:viewportHeight="600"
                     android:viewportWidth="600" >
                     <group
                         android:name="rotationGroup"
                         android:pivotX="300.0"
                         android:pivotY="300.0"
                         android:rotation="45.0" >
                         <path
                             android:fillColor="#000000"
                             android:pathData="M300,70 l 0,-70 70,70 0,0 -70,70z" />
                     </group>
                 </vector>
             </aapt:attr>

             <target android:name="rotationGroup">
                 <aapt:attr name="android:animation" >
                     <objectAnimator
                         android:duration="6000"
                         android:propertyName="rotation"
                         android:valueFrom="0"
                         android:valueTo="360" />
                 </aapt:attr>
             </target>
         </animated-vector>

   The XML tag ``<aapt:attr >`` tells AAPT to treat the tag‚Äôs child as a
   resource and extract it into its own resource file. The value in the
   attribute name specifies where to use the inline resource within the
   parent tag.

   AAPT generates resource files and names for all the inline resources.
   Applications built using this inline format are compatible with all
   versions of Android.

Last updated 2023-03-29 UTC.


/Overview: Resource types overview
==================================

.. container:: devsite-article-body clearfix

   Each page in this section describes the usage, format, and syntax for
   a certain type of `app resource <#>`__ that you
   can provide in your project resources directory (``res/``).

   Here's a brief summary of each page:

   `Animation resources <#>`__
      Define pre-determined animations.
      Tween animations are saved in ``res/anim/`` and accessed from the
      ``R.anim`` class.
      Frame animations are saved in ``res/drawable/`` and accessed from
      the ``R.drawable`` class.
   `Color state list resource <#>`__
      Define a color resource that changes based on the ``View`` state.
      Saved in ``res/color/`` and accessed from the ``R.color`` class.
   `Drawable resources <#>`__
      Define various graphics with bitmaps or XML.
      Saved in ``res/drawable/`` and accessed from the ``R.drawable``
      class.
   `Layout resource <#>`__
      Define the layout for your application UI.
      Saved in ``res/layout/`` and accessed from the ``R.layout`` class.
   `Menu resource <#>`__
      Define the contents of your application menus.
      Saved in ``res/menu/`` and accessed from the ``R.menu`` class.
   `String resources <#>`__
      Define strings, string arrays, and plurals and include string
      formatting and styling.
      Saved in ``res/values/`` and accessed from the ``R.string``,
      ``R.array``, and ``R.plurals`` classes.
   `Style resource <#>`__
      Define the look and format for UI elements.
      Saved in ``res/values/`` and accessed from the ``R.style`` class.
   `Font resources <#>`__
      Define font families and include custom fonts in XML.
      Saved in ``res/font/`` and accessed from the ``R.font`` class.
   `More resource types <#>`__
      Define other primitive values as static resources, including the
      following:

      `Bool <#Bool>`__
         XML resource that carries a boolean value.
      `Color <#Color>`__
         XML resource that carries a hexadecimal color value.
      `Dimension <#Dimension>`__
         XML resource that carries a dimension value with a unit of
         measure.
      `ID <#Id>`__
         XML resource that provides a unique identifier for application
         resources and components.
      `Integer <#Integer>`__
         XML resource that carries an integer value.
      `Integer array <#IntegerArray>`__
         XML resource that provides an array of integers.
      `Typed array <#TypedArray>`__
         XML resource that provides a
         `TypedArray <#>`__,
         which you can use for an array of drawables.

.. container:: devsite-steps

Last updated 2023-03-29 UTC.


/Animation resources
====================

.. container:: devsite-article-body clearfix

   An animation resource can define one of two types of animations:

   `Property animation <#Property>`__
      Creates an animation by modifying an object's property values over
      a set period with an
      `Animator <#>`__.
   `View animation <#View>`__
      There are two types of animations that you can do with the view
      animation framework:

      -  `Tween animation <#Tween>`__: creates an animation by
         performing a series of transformations on a single image with
         an
         `Animation <#>`__.
      -  `Frame animation <#Frame>`__: creates an animation by showing a
         sequence of images in order with an
         `AnimationDrawable <#>`__.

   .. rubric:: Property animation
      :name: Property

   An animation defined in XML that modifies properties of the target
   object, such as background color or alpha value, over a set amount of
   time.

   file location:
      ``res/animator/``\ *``filename``*\ ``.xml``
      The filename is used as the resource ID.
   compiled resource datatype:
      Resource pointer to a
      `ValueAnimator <#>`__,
      `ObjectAnimator <#>`__,
      or `AnimatorSet <#>`__
   resource reference:
      In Java-based or Kotlin code: ``R.animator.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]animator/``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <set
           android:ordering=["together" | "sequentially"]>

             <objectAnimator
                 android:propertyName="string"
                 android:duration="int"
                 android:valueFrom="float | int | color"
                 android:valueTo="float | int | color"
                 android:startOffset="int"
                 android:repeatCount="int"
                 android:repeatMode=["restart" | "reverse"]
                 android:valueType=["intType" | "floatType"]/>

             <animator
                 android:duration="int"
                 android:valueFrom="float | int | color"
                 android:valueTo="float | int | color"
                 android:startOffset="int"
                 android:repeatCount="int"
                 android:repeatMode=["restart" | "reverse"]
                 android:valueType=["intType" | "floatType"]/>

             <set>
                 ...
             </set>
         </set>

      The file must have a single root element: either ``<set>``,
      ``<objectAnimator>``, or ``<valueAnimator>``. You can group
      animation elements together inside the ``<set>`` element,
      including other ``<set>`` elements.

   elements:
      ``<set>``
         A container that holds other animation elements
         (``<objectAnimator>``, ``<valueAnimator>``, or other ``<set>``
         elements). Represents an
         `AnimatorSet <#>`__.

         You can specify nested ``<set>`` tags to further group
         animations. Each ``<set>`` can define its own ``ordering``
         attribute.

         Attributes:

         ``android:ordering``
            *Keyword*. Specifies the play ordering of animations in this
            set.

            .. list-table::
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - ``sequentially``
                  - Play animations in this set sequentially.
               - 

                  - ``together`` (default)
                  - Play animations in this set at the same time.

      ``<objectAnimator>``
         Animates a specific property of an object over a specific
         amount of time. Represents an
         `ObjectAnimator <#>`__.

         Attributes:

         ``android:propertyName``
            *String*. **Required**. The object's property to animate,
            referenced by its name. For example, you can specify
            ``"alpha"`` or ``"backgroundColor"`` for a ``View`` object.
            The ``objectAnimator`` element doesn't expose a ``target``
            attribute, however, so you can't set the object to animate
            in the XML declaration. You have to inflate your animation
            XML resource by calling
            `loadAnimator() <#loadAnimator>`__,
            and call
            `setTarget() <#setTarget>`__
            to set the target object that contains this property.
         ``android:valueTo``
            *float, int, or color*. **Required**. The value where the
            animated property ends. Colors are represented as six-digit
            hexadecimal numbers, such as #333333.
         ``android:valueFrom``
            *float, int, or color*. The value where the animated
            property starts. If not specified, the animation starts at
            the value obtained by the property's ``get`` method. Colors
            are represented as six-digit hexadecimal numbers, such as
            #333333.
         ``android:duration``
            *int*. The time in milliseconds of the animation. 300
            milliseconds is the default.
         ``android:startOffset``
            *int*. The amount of milliseconds the animation delays after
            `start() <#start>`__
            is called.
         ``android:repeatCount``
            *int*. How many times to repeat an animation. Set to
            ``"-1"`` to infinitely repeat or to a positive integer. For
            example, a value of ``"1"`` means that the animation is
            repeated once after the initial run of the animation, so the
            animation plays a total of two times. The default value is
            ``"0"``, which means no repetition.
         ``android:repeatMode``
            *int*. How an animation behaves when it reaches the end of
            the animation. ``android:repeatCount`` must be set to a
            positive integer or ``"-1"`` for this attribute to have an
            effect. Set to ``"reverse"`` to have the animation reverse
            direction with each iteration or ``"restart"`` to have the
            animation loop from the beginning each time.
         ``android:valueType``
            *Keyword*. Don't specify this attribute if the value is a
            color. The animation framework automatically handles color
            values.

            .. list-table::
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - ``intType``
                  - Specifies that the animated values are integers.
               - 

                  - ``floatType`` (default)
                  - Specifies that the animated values are floats.

      ``<animator>``
         Performs an animation over a specified amount of time.
         Represents a
         `ValueAnimator <#>`__.

         Attributes:

         ``android:valueTo``
            *float, int, or color*. **Required**. The value where the
            animation ends. Colors are represented as six-digit
            hexadecimal numbers, such as #333333.
         ``android:valueFrom``
            *float, int, or color*. **Required**. The value where the
            animation starts. Colors are represented as six-digit
            hexadecimal numbers, such as #333333.
         ``android:duration``
            *int*. The time in milliseconds of the animation. 300ms is
            the default.
         ``android:startOffset``
            *int*. The amount of milliseconds the animation delays after
            `start() <#start>`__
            is called.
         ``android:repeatCount``
            *int*. How many times to repeat an animation. Set to
            ``"-1"`` to infinitely repeat or to a positive integer. For
            example, a value of ``"1"`` means that the animation is
            repeated once after the initial run of the animation, so the
            animation plays a total of two times. The default value is
            ``"0"``, which means no repetition.
         ``android:repeatMode``
            *int*. How an animation behaves when it reaches the end of
            the animation. ``android:repeatCount`` must be set to a
            positive integer or ``"-1"`` for this attribute to have an
            effect. Set to ``"reverse"`` to have the animation reverse
            direction with each iteration or ``"restart"`` to have the
            animation loop from the beginning each time.
         ``android:valueType``
            *Keyword*. Don't specify this attribute if the value is a
            color. The animation framework automatically handles color
            values.

            .. list-table::
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - ``intType``
                  - Specifies that the animated values are integers.
               - 

                  - ``floatType`` (default)
                  - Specifies that the animated values are floats.

   example:
      XML file saved at ``res/animator/property_animator.xml``:

      .. code:: prettyprint

         <set android:ordering="sequentially">
             <set>
                 <objectAnimator
                     android:propertyName="x"
                     android:duration="500"
                     android:valueTo="400"
                     android:valueType="intType"/>
                 <objectAnimator
                     android:propertyName="y"
                     android:duration="500"
                     android:valueTo="300"
                     android:valueType="intType"/>
             </set>
             <objectAnimator
                 android:propertyName="alpha"
                 android:duration="500"
                 android:valueTo="1f"/>
         </set>

      To run this animation, inflate the XML resources in your code to
      an `AnimatorSet <#>`__
      object, and then set the target objects for all the animations
      before starting the animation set. Calling
      `setTarget() <#setTarget>`__
      sets a single target object for all children of the
      ``AnimatorSet`` as a convenience. The following code shows how to
      do this:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val set: AnimatorSet = AnimatorInflater.loadAnimator(myContext, R.animator.property_animator)
                      .apply {
                          setTarget(myObject)
                          start()
                      }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,
                      R.animator.property_animator);
                  set.setTarget(myObject);
                  set.start();

   see also:
      -  `Property Animation Overview <#>`__
      -  `API demos <#>`__ for examples of how
         to use the property animation system

   .. rubric:: View animation
      :name: View

   The view animation framework supports both tween and frame-by-frame
   animations, which are both declared in XML. The following sections
   describe how to use both methods.

   .. rubric:: Tween animation
      :name: Tween

   An animation defined in XML that performs transitions on a graphic
   such as rotating, fading, moving, and stretching.

   file location:
      ``res/anim/``\ *``filename``*\ ``.xml``
      The filename is used as the resource ID.
   compiled resource datatype:
      Resource pointer to an
      `Animation <#>`__
   resource reference:
      In Java: ``R.anim.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]anim/``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <set xmlns:android="http://schemas.android.com/apk/res/android"
             android:interpolator="@[package:]anim/interpolator_resource"
             android:shareInterpolator=["true" | "false"] >
             <alpha
                 android:fromAlpha="float"
                 android:toAlpha="float" />
             <scale
                 android:fromXScale="float"
                 android:toXScale="float"
                 android:fromYScale="float"
                 android:toYScale="float"
                 android:pivotX="float"
                 android:pivotY="float" />
             <translate
                 android:fromXDelta="float"
                 android:toXDelta="float"
                 android:fromYDelta="float"
                 android:toYDelta="float" />
             <rotate
                 android:fromDegrees="float"
                 android:toDegrees="float"
                 android:pivotX="float"
                 android:pivotY="float" />
             <set>
                 ...
             </set>
         </set>

      The file must have a single root element: either an ``<alpha>``,
      ``<scale>``, ``<translate>``, ``<rotate>``, or ``<set>`` element
      that holds a group (or groups) of other animation elements
      (including nested ``<set>`` elements).

   elements:
      ``<set>``
         A container that holds other animation elements (``<alpha>``,
         ``<scale>``, ``<translate>``, ``<rotate>``) or other ``<set>``
         elements. Represents an
         `AnimationSet <#>`__.

         Attributes:

         ``android:interpolator``
            *Interpolator resource*. An
            `Interpolator <#>`__
            to apply on the animation. The value must be a reference to
            a resource that specifies an interpolator, not an
            interpolator class name. There are default interpolator
            resources available from the platform or you can create your
            own interpolator resource. See the following discussion for
            more information about `interpolators <#Interpolators>`__.
         ``android:shareInterpolator``
            *Boolean*. ``"true"`` if you want to share the same
            interpolator among all child elements.

      ``<alpha>``
         A fade-in or fade-out animation. Represents an
         `AlphaAnimation <#>`__.

         Attributes:

         ``android:fromAlpha``
            *Float*. Starting opacity offset, where 0.0 is transparent
            and 1.0 is opaque.
         ``android:toAlpha``
            *Float*. Ending opacity offset, where 0.0 is transparent and
            1.0 is opaque.

         For more attributes supported by ``<alpha>``, see the class
         reference for
         `Animation <#>`__,
         whose XML attributes are inherited by this element.

      ``<scale>``
         A resizing animation. You can specify the center point of the
         image from which it grows outward or inward by specifying
         ``pivotX`` and ``pivotY``. For example, if these values are 0,0
         (the top-left corner), all growth is down and to the right.
         Represents a
         `ScaleAnimation <#>`__.

         Attributes:

         ``android:fromXScale``
            *Float*. Starting X size offset, where 1.0 is no change.
         ``android:toXScale``
            *Float*. Ending X size offset, where 1.0 is no change.
         ``android:fromYScale``
            *Float*. Starting Y size offset, where 1.0 is no change.
         ``android:toYScale``
            *Float*. Ending Y size offset, where 1.0 is no change.
         ``android:pivotX``
            *Float*. The X coordinate to remain fixed when the object is
            scaled.
         ``android:pivotY``
            *Float*. The Y coordinate to remain fixed when the object is
            scaled.

         For more attributes supported by ``<scale>``, see the class
         reference for
         `Animation <#>`__,
         whose XML attributes are inherited by this element.

      ``<translate>``
         A vertical and/or horizontal motion. Represents a
         `TranslateAnimation <#>`__.
         Supports the following attributes in any of these three
         formats:

         -  Values from -100 to 100 ending with "%", indicating a
            percentage relative to itself.
         -  Values from -100 to 100 ending in "%p", indicating a
            percentage relative to its parent.
         -  A float value with no suffix, indicating an absolute value.

         Attributes:

         ``android:fromXDelta``
            *Float or percentage*. Starting X offset. Expressed either
            in pixels relative to the normal position, such as ``"5"``;
            in percentage relative to the element width, such as
            ``"5%"``; or in percentage relative to the parent width,
            such as ``"5%p"``.
         ``android:toXDelta``
            *Float or percentage*. Ending X offset. Expressed either in
            pixels relative to the normal position, such as ``"5"``; in
            percentage relative to the element width, such as ``"5%"``;
            or in percentage relative to the parent width, such as
            ``"5%p"``.
         ``android:fromYDelta``
            *Float or percentage*. Starting Y offset. Expressed either
            in pixels relative to the normal position, such as ``"5"``;
            in percentage relative to the element height, such as
            ``"5%"``; or in percentage relative to the parent height,
            such as ``"5%p"``.
         ``android:toYDelta``
            *Float or percentage*. Ending Y offset. Expressed either in
            pixels relative to the normal position, such as ``"5"``; in
            percentage relative to the element height, such as ``"5%"``;
            or in percentage relative to the parent height, such as
            ``"5%p"``.

         For more attributes supported by ``<translate>``, see the class
         reference for
         `Animation <#>`__,
         whose XML attributes are inherited by this element.

      ``<rotate>``
         A rotation animation. Represents a
         `RotateAnimation <#>`__.

         Attributes:

         ``android:fromDegrees``
            *Float*. Starting angular position, in degrees.
         ``android:toDegrees``
            *Float*. Ending angular position, in degrees.
         ``android:pivotX``
            *Float or percentage*. The X coordinate of the center of
            rotation. Expressed either in pixels relative to the
            object's left edge, such as ``"5"``; in percentage relative
            to the object's left edge, such as ``"5%"``; or in
            percentage relative to the parent container's left edge,
            such as ``"5%p"``.
         ``android:pivotY``
            *Float or percentage*. The Y coordinate of the center of
            rotation. Expressed either in pixels relative to the
            object's top edge, such as ``"5"``; in percentage relative
            to the object's top edge, such as ``"5%"``; or in percentage
            relative to the parent container's top edge, such as
            ``"5%p"``.

         For more attributes supported by ``<rotate>``, see the class
         reference for
         `Animation <#>`__,
         whose XML attributes are inherited by this element.

   example:
      XML file saved at ``res/anim/hyperspace_jump.xml``:

      .. code:: prettyprint

         <set xmlns:android="http://schemas.android.com/apk/res/android"
             android:shareInterpolator="false">
             <scale
                 android:interpolator="@android:anim/accelerate_decelerate_interpolator"
                 android:fromXScale="1.0"
                 android:toXScale="1.4"
                 android:fromYScale="1.0"
                 android:toYScale="0.6"
                 android:pivotX="50%"
                 android:pivotY="50%"
                 android:fillAfter="false"
                 android:duration="700" />
             <set
                 android:interpolator="@android:anim/accelerate_interpolator"
                 android:startOffset="700">
                 <scale
                     android:fromXScale="1.4"
                     android:toXScale="0.0"
                     android:fromYScale="0.6"
                     android:toYScale="0.0"
                     android:pivotX="50%"
                     android:pivotY="50%"
                     android:duration="400" />
                 <rotate
                     android:fromDegrees="0"
                     android:toDegrees="-45"
                     android:toYScale="0.0"
                     android:pivotX="50%"
                     android:pivotY="50%"
                     android:duration="400" />
             </set>
         </set>

      The following application code applies the animation to an
      `ImageView <#>`__ and starts
      the animation:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val image: ImageView = findViewById(R.id.image)
                  val hyperspaceJump: Animation = AnimationUtils.loadAnimation(this, R.anim.hyperspace_jump)
                  image.startAnimation(hyperspaceJump)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  ImageView image = (ImageView) findViewById(R.id.image);
                  Animation hyperspaceJump = AnimationUtils.loadAnimation(this, R.anim.hyperspace_jump);
                  image.startAnimation(hyperspaceJump);

   see also:
      -  `View Animation <#>`__

   .. rubric:: Interpolators
      :name: Interpolators

   An interpolator is an animation modifier defined in XML that affects
   the rate of change in an animation. This lets your existing animation
   effects be accelerated, decelerated, repeated, bounced, etc.

   An interpolator is applied to an animation element with the
   ``android:interpolator`` attribute, the value of which is a reference
   to an interpolator resource.

   All interpolators available in Android are subclasses of the
   `Interpolator <#>`__
   class. For each interpolator class, Android includes a public
   resource you can reference to apply the interpolator to an animation
   using the ``android:interpolator`` attribute. The following table
   specifies the resource to use for each interpolator:

   .. list-table::
      :header-rows: 1

      - 

         - Interpolator class
         - Resource ID
      - 

         - `AccelerateDecelerateInterpolator <#>`__
         - ``@android:anim/accelerate_decelerate_interpolator``
      - 

         - `AccelerateInterpolator <#>`__
         - ``@android:anim/accelerate_interpolator``
      - 

         - `AnticipateInterpolator <#>`__
         - ``@android:anim/anticipate_interpolator``
      - 

         - `AnticipateOvershootInterpolator <#>`__
         - ``@android:anim/anticipate_overshoot_interpolator``
      - 

         - `BounceInterpolator <#>`__
         - ``@android:anim/bounce_interpolator``
      - 

         - `CycleInterpolator <#>`__
         - ``@android:anim/cycle_interpolator``
      - 

         - `DecelerateInterpolator <#>`__
         - ``@android:anim/decelerate_interpolator``
      - 

         - `LinearInterpolator <#>`__
         - ``@android:anim/linear_interpolator``
      - 

         - `OvershootInterpolator <#>`__
         - ``@android:anim/overshoot_interpolator``

   Here's how you can apply one of these with the
   ``android:interpolator`` attribute:

   .. code:: prettyprint

      <set android:interpolator="@android:anim/accelerate_interpolator">
          ...
      </set>

   .. rubric:: Custom interpolators
      :name: custom-interpolators

   If you're not satisfied with the interpolators provided by the
   platform, you can create a custom interpolator resource with modified
   attributes. For example, you can adjust the rate of acceleration for
   the
   `AnticipateInterpolator <#>`__
   or adjust the number of cycles for the
   `CycleInterpolator <#>`__.
   To do so, you create your own interpolator resource in an XML file.

   file location:
      ``res/anim/``\ *``filename``*\ ``.xml``
      The filename is used as the resource ID.
   compiled resource datatype:
      Resource pointer to the corresponding interpolator object
   resource reference:
      In XML: ``@[``\ *``package``*\ ``:]anim/``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <InterpolatorName xmlns:android="http://schemas.android.com/apk/res/android"
             android:attribute_name="value"
             />

      If you don't apply any attributes, then your interpolator
      functions exactly the same as those provided by the platform,
      listed in the preceding table.

   elements:
      Notice that each
      `Interpolator <#>`__
      implementation, when defined in XML, has a name that begins with a
      lowercase letter.

      ``<accelerateDecelerateInterpolator>``
         The rate of change starts and ends slowly but accelerates
         through the middle.

         No attributes.

      ``<accelerateInterpolator>``
         The rate of change starts slowly, then accelerates.

         Attributes:

         ``android:factor``
            *Float*. The acceleration rate. The default is 1.

      ``<anticipateInterpolator>``
         The change starts backward, then flings forward.

         Attributes:

         ``android:tension``
            *Float*. The amount of tension to apply. The default is 2.

      ``<anticipateOvershootInterpolator>``
         The change starts backward, then flings forward and overshoots
         the target value, then settles at the final value.

         Attributes:

         ``android:tension``
            *Float*. The amount of tension to apply. The default is 2.
         ``android:extraTension``
            *Float*. The amount by which to multiply the tension. The
            default is 1.5.

      ``<bounceInterpolator>``
         The change bounces at the end.

         No attributes

      ``<cycleInterpolator>``
         Repeats the animation for a specified number of cycles. The
         rate of change follows a sinusoidal pattern.

         Attributes:

         ``android:cycles``
            *Integer*. The number of cycles. The default is 1.

      ``<decelerateInterpolator>``
         The rate of change starts out quickly, then decelerates.

         Attributes:

         ``android:factor``
            *Float*. The deceleration rate. The default is 1.

      ``<linearInterpolator>``
         The rate of change is constant.

         No attributes.

      ``<overshootInterpolator>``
         The change flings forward and overshoots the last value, then
         comes back.

         Attributes:

         ``android:tension``
            *Float*. The amount of tension to apply. The default is 2.
   example:
      XML file saved at ``res/anim/my_overshoot_interpolator.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <overshootInterpolator xmlns:android="http://schemas.android.com/apk/res/android"
             android:tension="7.0"
             />

      This animation XML applies the interpolator:

      .. code:: prettyprint

         <scale xmlns:android="http://schemas.android.com/apk/res/android"
             android:interpolator="@anim/my_overshoot_interpolator"
             android:fromXScale="1.0"
             android:toXScale="3.0"
             android:fromYScale="1.0"
             android:toYScale="3.0"
             android:pivotX="50%"
             android:pivotY="50%"
             android:duration="700" />

   .. rubric:: Frame animation
      :name: Frame

   An animation defined in XML that shows a sequence of images in order,
   like a film.

   file location:
      ``res/drawable/``\ *``filename``*\ ``.xml``
      The filename is used as the resource ID.
   compiled resource datatype:
      Resource pointer to an
      `AnimationDrawable <#>`__
   resource reference:
      In Java: ``R.drawable.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]drawable.``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <animation-list xmlns:android="http://schemas.android.com/apk/res/android"
             android:oneshot=["true" | "false"] >
             <item
                 android:drawable="@[package:]drawable/drawable_resource_name"
                 android:duration="integer" />
         </animation-list>

   elements:
      ``<animation-list>``
         **Required**. This must be the root element. Contains one or
         more ``<item>`` elements.

         Attributes:

         ``android:oneshot``
            *Boolean*. ``"true"`` if you want to perform the animation
            once; ``"false"`` to loop the animation.

      ``<item>``
         A single frame of animation. Must be a child of a
         ``<animation-list>`` element.

         Attributes:

         ``android:drawable``
            *Drawable resource*. The drawable to use for this frame.
         ``android:duration``
            *Integer*. The duration to show this frame, in milliseconds.

   example:
      XML file saved at ``res/drawable/rocket_thrust.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <animation-list xmlns:android="http://schemas.android.com/apk/res/android"
             android:oneshot="false">
             <item android:drawable="@drawable/rocket_thrust1" android:duration="200" />
             <item android:drawable="@drawable/rocket_thrust2" android:duration="200" />
             <item android:drawable="@drawable/rocket_thrust3" android:duration="200" />
         </animation-list>

      The following application code sets the animation as the
      background for a ``View``, then play the animation:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val rocketImage: ImageView = findViewById(R.id.rocket_image)
                  rocketImage.setBackgroundResource(R.drawable.rocket_thrust)

                  val rocketAnimation = rocketImage.background
                  if (rocketAnimation is Animatable) {
                      rocketAnimation.start()
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  ImageView rocketImage = (ImageView) findViewById(R.id.rocket_image);
                  rocketImage.setBackgroundResource(R.drawable.rocket_thrust);

                  rocketAnimation = rocketImage.getBackground();
                  if (rocketAnimation instanceof Animatable) {
                      ((Animatable)rocketAnimation).start();
                  }

   see also:
      -  `View Animation <#>`__

.. container:: devsite-steps

Last updated 2024-01-03 UTC.


/Color state list resource
==========================

.. container:: devsite-article-body clearfix

   A
   `ColorStateList <#>`__
   is an object you can define in XML and apply as a color that actually
   changes colors depending on the state of the
   `View <#>`__ object it is applied to.
   For example, a `Button <#>`__
   widget can exist in one of several states: pressed, focused, or
   neither. Using a color state list, you can provide a different color
   for each state.

   You describe the state list in an XML file. Each color is defined in
   an ``<item>`` element inside a single ``<selector>`` element. Each
   ``<item>`` uses various attributes to describe the state in which it
   is used.

   During each state change, the state list is traversed top to bottom,
   and the first item that matches the current state is used. The
   selection is *isn't* based on the "best" match, but rather the first
   item that meets the minimum criteria of the state.

   **Note:** If you want to provide a static color resource, use a
   simple `color <#Color>`__
   value.

   file location:
      ``res/color/``\ *``filename``*\ ``.xml``
      The filename is used as the resource ID.
   compiled resource datatype:
      Resource pointer to a
      `ColorStateList <#>`__
   resource reference:
      In Java: ``R.color.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]color/``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <selector xmlns:android="http://schemas.android.com/apk/res/android" >
             <item
                 android:color="hex_color"
                 android:lStar="floating_point_value"
                 android:state_pressed=["true" | "false"]
                 android:state_focused=["true" | "false"]
                 android:state_selected=["true" | "false"]
                 android:state_checkable=["true" | "false"]
                 android:state_checked=["true" | "false"]
                 android:state_enabled=["true" | "false"]
                 android:state_window_focused=["true" | "false"] />
         </selector>

   elements:
      ``<selector>``
         **Required.** This is the root element. Contains one or more
         ``<item>`` elements.

         Attributes:

         ``xmlns:android``
            *String*. **Required.** Defines the XML namespace, which is
            ``"http://schemas.android.com/apk/res/android"``.

      ``<item>``
         Defines a color to use during certain states, as described by
         its attributes. It is a child of a ``<selector>`` element.

         Attributes:

         ``android:color``
            *Hexadeximal color*. **Required**. The color is specified
            with an RGB value and optional alpha channel.

            The value always begins with a pound (``#``) character,
            followed by the Alpha-Red-Green-Blue information in one of
            the following formats:

            -  #\ *RGB*
            -  #\ *ARGB*
            -  #\ *RRGGBB*
            -  #\ *AARRGGBB*

         ``android:lStar``
            *Floating point*. **Optional**. This attribute modifies the
            base color's perceptual luminance. It takes either a
            floating-point value between 0 and 100 or a theme attribute
            that resolves as such. The item's overall color is
            calculated by converting the base color to an accessibility
            friendly color space and setting its L\* to the value
            specified on the ``lStar`` attribute.

            Example: ``android:lStar="50"``

         ``android:state_pressed``
            *Boolean*. ``"true"`` if this item is used when the object
            is tapped, such as when a button is touched or clicked. It's
            ``"false"`` if this item is used in the default, non-tapped
            state.
         ``android:state_focused``
            *Boolean*. ``"true"`` if this item is used when the object
            is focused, such as when a button is highlighted using the
            trackball or D-pad. It's ``"false"`` if this item is used in
            the default, non-focused state.
         ``android:state_selected``
            *Boolean*. ``"true"`` if this item is used when the object
            is selected, such as when a tab is opened. It's ``"false"``
            if this item it used when the object isn't selected.
         ``android:state_checkable``
            *Boolean*. ``"true"`` if this item is used when the object
            is checkable. It's ``"false"`` if this item is used when the
            object isn't checkable. Only useful if the object can
            transition between a checkable and non-checkable widget.
         ``android:state_checked``
            *Boolean*. ``"true"`` if this item is used when the object
            is checked. It's ``"false"`` if it is used when the object
            is deselected.
         ``android:state_enabled``
            *Boolean*. ``"true"`` if this item is used when the object
            is enabled, capable of receiving touch or click events. It's
            ``"false"`` if it is used when the object is disabled.
         ``android:state_window_focused``
            *Boolean*. ``"true"`` if this item is used when the
            application window has focus, meaning the application is in
            the foreground. It's ``"false"`` if this item is used when
            the application window doesn't have focus, such as if the
            notification shade is pulled down or a dialog appears.

         **Note:** The first item in the state list that matches the
         current state of the object is applied. So, if the first item
         in the list contains none of the preceding state attributes,
         then it applies every time. For this reason, place your default
         value last, as shown in the following example.

   example:
      XML file saved at ``res/color/button_text.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <selector xmlns:android="http://schemas.android.com/apk/res/android">
             <item android:state_pressed="true"
                   android:color="#ffff0000"/> <!-- pressed -->
             <item android:state_focused="true"
                   android:color="#ff0000ff"/> <!-- focused -->
             <item android:color="#ff000000"/> <!-- default -->
         </selector>

      The following layout XML applies the color list to a ``View``:

      .. code:: prettyprint

         <Button
             android:layout_width="fill_parent"
             android:layout_height="wrap_content"
             android:text="@string/button_text"
             android:textColor="@color/button_text" />

   see also:
      -  `Color (simple value) <#Color>`__
      -  `ColorStateList <#>`__
      -  `State list drawable <#StateList>`__

.. container:: devsite-steps

Last updated 2023-05-04 UTC.


/Drawable resources
===================

.. container:: devsite-article-body clearfix

   A drawable resource is a general concept for a graphic that can be
   drawn to the screen and that you can retrieve with APIs such as
   `getDrawable(int) <#getDrawable>`__
   or apply to another XML resource with attributes such as
   ``android:drawable`` and ``android:icon``. There are several types of
   drawables:

   `Bitmap file <#Bitmap>`__
      A bitmap graphic file (PNG, WEBP, JPG, or GIF). Creates a
      `BitmapDrawable <#>`__.
   `Nine-patch file <#NinePatch>`__
      A PNG file with stretchable regions to let images resize based on
      content (``.9.png``). Creates a
      `NinePatchDrawable <#>`__.
   `Layer list <#LayerList>`__
      A drawable that manages an array of other drawables. These are
      drawn in array order, so the element with the largest index is
      drawn on top. Creates a
      `LayerDrawable <#>`__.
   `State list <#StateList>`__
      An XML file that references different bitmap graphics for
      different states‚Äîfor example, to use a different image when a
      button is tapped. Creates a
      `StateListDrawable <#>`__.
   `Level list <#LevelList>`__
      An XML file that defines a drawable that manages a number of
      alternate drawables, each assigned a maximum numerical value.
      Creates a
      `LevelListDrawable <#>`__.
   `Transition drawable <#Transition>`__
      An XML file that defines a drawable that can cross-fade between
      two drawable resources. Creates a
      `TransitionDrawable <#>`__.
   `Inset drawable <#Inset>`__
      An XML file that defines a drawable that insets another drawable
      by a specified distance. This is useful when a view needs a
      background drawable that is smaller than the view's actual bounds.
   `Clip drawable <#Clip>`__
      An XML file that defines a drawable that clips another drawable
      based on this drawable's current level value. Creates a
      `ClipDrawable <#>`__.
   `Scale drawable <#Scale>`__
      An XML file that defines a drawable that changes the size of
      another drawable based on its current level value. Creates a
      `ScaleDrawable <#>`__
   `Shape drawable <#Shape>`__.
      An XML file that defines a geometric shape, including colors and
      gradients. Creates a
      `GradientDrawable <#>`__.

   For information about how to create an
   `AnimationDrawable <#>`__,
   see the `Animation resources <#>`__ document.

   **Note:** A `color resource <#Color>`__ can also
   be used as a drawable in XML. For example, when creating a `state list drawable <#StateList>`__, you can reference a color resource for
   the ``android:drawable`` attribute
   (``android:drawable="@color/green"``).

   .. rubric:: Bitmap
      :name: Bitmap

   A bitmap image. Android supports bitmap files in the following
   formats: PNG (preferred), WEBP (preferred, requires API level 17 or
   higher), JPG (acceptable), GIF (discouraged).

   You can reference a bitmap file directly, using the filename as the
   resource ID, or create an alias resource ID in XML.

   | **Note:** Bitmap files might be automatically optimized with
     lossless image compression by the ``aapt`` tool during the build
     process. For example, a true-color PNG that doesn't require more
     than 256 colors might be converted to an 8-bit PNG with a color
     palette. This results in an image of equal quality that requires
     less memory.
   | So, be aware that the image binaries placed in this directory can
     change during the build. If you plan to read an image as a bit
     stream to convert it to a bitmap, put your images in the
     ``res/raw/`` folder instead, where they aren't optimized.

   .. rubric:: Bitmap file
      :name: BitmapFile

   A bitmap file is a PNG, WEBP, JPG, or GIF file. Android creates a
   `Drawable <#>`__
   resource for any of these files when you save them in the
   ``res/drawable/`` directory.

   file location:
      ``res/drawable/``\ *``filename``*\ ``.png`` (``.png``, ``.webp``,
      ``.jpg``, or ``.gif``)
      The filename is the resource ID
   compiled resource datatype:
      Resource pointer to a
      `BitmapDrawable <#>`__
   resource reference:
      In Java: ``R.drawable.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]drawable/``\ *``filename``*
   example:
      With an image saved at ``res/drawable/myimage.png``, this layout
      XML applies the image to a view:

      .. code:: prettyprint

         <ImageView
             android:layout_height="wrap_content"
             android:layout_width="wrap_content"
             android:src="@drawable/myimage" />

      The following application code retrieves the image as a
      `Drawable <#>`__:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val drawable: Drawable? = ResourcesCompat.getDrawable(resources, R.drawable.myimage, null)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Resources res = getResources();
               Drawable drawable = ResourcesCompat.getDrawable(res, R.drawable.myimage, null);

   see also:
      -  `Drawables overview <#>`__
      -  `BitmapDrawable <#>`__

   .. rubric:: XML bitmap
      :name: XmlBitmap

   An XML bitmap is a resource defined in XML that points to a bitmap
   file. The effect is an alias for a raw bitmap file. The XML can
   specify additional properties for the bitmap, such as dithering and
   tiling.

   **Note:** You can use a ``<bitmap>`` element as a child of an
   ``<item>`` element. For example, when creating a `state list <#StateList>`__ or `layer list <#LayerList>`__, you can exclude
   the ``android:drawable`` attribute from an ``<item>`` element and
   nest a ``<bitmap>`` inside it that defines the drawable item.

   file location:
      ``res/drawable/``\ *``filename``*\ ``.xml``
      The filename is the resource ID
   compiled resource datatype:
      Resource pointer to a
      `BitmapDrawable <#>`__
   resource reference:
      In Java: ``R.drawable.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]drawable/``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <bitmap
             xmlns:android="http://schemas.android.com/apk/res/android"
             android:src="@[package:]drawable/drawable_resource"
             android:antialias=["true" | "false"]
             android:dither=["true" | "false"]
             android:filter=["true" | "false"]
             android:gravity=["top" | "bottom" | "left" | "right" | "center_vertical" |
                               "fill_vertical" | "center_horizontal" | "fill_horizontal" |
                               "center" | "fill" | "clip_vertical" | "clip_horizontal"]
             android:mipMap=["true" | "false"]
             android:tileMode=["disabled" | "clamp" | "repeat" | "mirror"] />

   elements:
      ``<bitmap>``
         **Required.** Defines the bitmap source and its properties.

         Attributes:

         ``xmlns:android``
            *String*. Defines the XML namespace, which must be
            ``"http://schemas.android.com/apk/res/android"``. This is
            required only if the ``<bitmap>`` is the root element. It
            isn't needed when the ``<bitmap>`` is nested inside an
            ``<item>``.
         ``android:src``
            *Drawable resource*. **Required**. Reference to a drawable
            resource.
         ``android:antialias``
            *Boolean*. Enables or disables antialiasing.
         ``android:dither``
            *Boolean*. Enables or disables dithering of the bitmap if
            the bitmap doesn't have the same pixel configuration as the
            screen, such as an ARGB 8888 bitmap on an RGB 565 screen.
         ``android:filter``
            *Boolean*. Enables or disables bitmap filtering. Filtering
            is used when the bitmap is shrunk or stretched to smooth its
            appearance.
         ``android:gravity``
            *Keyword*. Defines the gravity for the bitmap. The gravity
            indicates where to position the drawable in its container if
            the bitmap is smaller than the container.

            Must be one or more of the following constant values,
            separated by ``|``:

            .. list-table::
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - ``top``
                  - Put the object at the top of its container, not
                     changing its size.
               - 

                  - ``bottom``
                  - Put the object at the bottom of its container, not
                     changing its size.
               - 

                  - ``left``
                  - Put the object at the left edge of its container,
                     not changing its size.
               - 

                  - ``right``
                  - Put the object at the right edge of its container,
                     not changing its size.
               - 

                  - ``center_vertical``
                  - Put the object in the vertical center of its
                     container, not changing its size.
               - 

                  - ``fill_vertical``
                  - Grow the vertical size of the object if needed so it
                     completely fills its container.
               - 

                  - ``center_horizontal``
                  - Place object in the horizontal center of its
                     container, not changing its size.
               - 

                  - ``fill_horizontal``
                  - Grow the horizontal size of the object if needed so
                     it completely fills its container.
               - 

                  - ``center``
                  - Put the object in the center of its container in
                     both the vertical and horizontal axis, not changing
                     its size.
               - 

                  - ``fill``
                  - Grow the horizontal and vertical size of the object
                     if needed so it completely fills its container.
                     This is the default.
               - 

                  - ``clip_vertical``
                  - Additional option that can be set to have the top
                     and/or bottom edges of the child clipped to its
                     container's bounds. The clip is based on the
                     vertical gravity: a top gravity clips the bottom
                     edge, a bottom gravity clips the top edge, and
                     neither clips both edges.
               - 

                  - ``clip_horizontal``
                  - Additional option that can be set to have the left
                     and/or right edges of the child clipped to its
                     container's bounds. The clip is based on the
                     horizontal gravity: a left gravity clips the right
                     edge, a right gravity clips the left edge, and
                     neither clips both edges.

         ``android:mipMap``
            *Boolean*. Enables or disables the mipmap hint. See
            `setHasMipMap() <#setHasMipMap>`__
            for more information. The default value is false.
         ``android:tileMode``
            *Keyword*. Defines the tile mode. When the tile mode is
            enabled, the bitmap is repeated. Gravity is ignored when the
            tile mode is enabled.

            Must be one of the following constant values:

            .. list-table::
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - ``disabled``
                  - Don't tile the bitmap. This is the default value.
               - 

                  - ``clamp``
                  - Replicate the edge color if the shader draws outside
                     its original bounds
               - 

                  - ``repeat``
                  - Repeat the shader's image horizontally and
                     vertically.
               - 

                  - ``mirror``
                  - Repeat the shader's image horizontally and
                     vertically, alternating mirror images so that
                     adjacent images always seam.

   example:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <bitmap xmlns:android="http://schemas.android.com/apk/res/android"
             android:src="@drawable/icon"
             android:tileMode="repeat" />

   see also:
      -  `BitmapDrawable <#>`__
      -  `Create alias resources <#AliasResources>`__

   .. rubric:: Nine-patch
      :name: NinePatch

   A `NinePatch <#>`__ is a PNG
   image in which you can define stretchable regions that Android scales
   when content within the view exceeds the normal image bounds. You
   typically assign this type of image as the background of a view that
   has at least one dimension set to ``"wrap_content"``.

   When the view grows to accommodate the content, the nine-patch image
   is also scaled to match the size of the view. An example use of a
   nine-patch image is the background used by Android's standard
   `Button <#>`__ widget, which must
   stretch to accommodate the text (or image) inside the button.

   As with a normal `bitmap <#Bitmap>`__, you can reference a nine-patch
   file directly or from a resource defined by XML.

   For a complete discussion about how to create a nine-patch file with
   stretchable regions, see `Create resizable bitmaps (9-patch files) <#>`__.

   .. rubric:: Nine-patch file
      :name: NinePatchFile

   file location:
      ``res/drawable/``\ *``filename``*\ ``.9.png``
      The filename is the resource ID
   compiled resource datatype:
      Resource pointer to a
      `NinePatchDrawable <#>`__
   resource reference:
      In Java: ``R.drawable.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]drawable/``\ *``filename``*
   example:
      With an image saved at ``res/drawable/myninepatch.9.png``, this
      layout XML applies the nine-patch to a view:

      .. code:: prettyprint

         <Button
             android:layout_height="wrap_content"
             android:layout_width="wrap_content"
             android:background="@drawable/myninepatch" />

   see also:
      -  `Create resizable bitmaps (9-patch files) <#>`__
      -  `NinePatchDrawable <#>`__

   .. rubric:: XML nine-patch
      :name: NinePatchXml

   An XML nine-patch is a resource defined in XML that points to a
   nine-patch file. The XML can specify dithering for the image.

   file location:
      ``res/drawable/``\ *``filename``*\ ``.xml``
      The filename is the resource ID
   compiled resource datatype:
      Resource pointer to a
      `NinePatchDrawable <#>`__
   resource reference:
      In Java: ``R.drawable.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]drawable/``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <nine-patch
             xmlns:android="http://schemas.android.com/apk/res/android"
             android:src="@[package:]drawable/drawable_resource"
             android:dither=["true" | "false"] />

   elements:
      ``<nine-patch>``
         **Required.** Defines the nine-patch source and its properties.

         Attributes:

         ``xmlns:android``
            *String*. **Required.** Defines the XML namespace, which
            must be ``"http://schemas.android.com/apk/res/android"``.
         ``android:src``
            *Drawable resource*. **Required**. Reference to a nine-patch
            file.
         ``android:dither``
            *Boolean*. Enables or disables dithering of the bitmap if
            the bitmap doesn't have the same pixel configuration as the
            screen, such as an ARGB 8888 bitmap on an RGB 565 screen.

   example:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <nine-patch xmlns:android="http://schemas.android.com/apk/res/android"
             android:src="@drawable/myninepatch"
             android:dither="false" />

   .. rubric:: Layer list
      :name: LayerList

   A
   `LayerDrawable <#>`__
   is a drawable object that manages an array of other drawables. Each
   drawable in the list is drawn in the order of the list. The last
   drawable in the list is drawn on top.

   Each drawable is represented by an ``<item>`` element inside a single
   ``<layer-list>`` element.

   file location:
      ``res/drawable/``\ *``filename``*\ ``.xml``
      The filename is the resource ID
   compiled resource datatype:
      Resource pointer to a
      `LayerDrawable <#>`__
   resource reference:
      In Java: ``R.drawable.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]drawable/``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <layer-list
             xmlns:android="http://schemas.android.com/apk/res/android" >
             <item
                 android:drawable="@[package:]drawable/drawable_resource"
                 android:id="@[+][package:]id/resource_name"
                 android:top="dimension"
                 android:right="dimension"
                 android:bottom="dimension"
                 android:left="dimension" />
         </layer-list>

   elements:
      ``<layer-list>``
         **Required.** This must be the root element. Contains one or
         more ``<item>`` elements.

         Attributes:

         ``xmlns:android``
            *String*. **Required.** Defines the XML namespace, which
            must be ``"http://schemas.android.com/apk/res/android"``.

      ``<item>``
         Defines a drawable to place in the layer drawable, in a
         position defined by its attributes. Must be a child of a
         ``<layer-list>`` element. Accepts child ``<bitmap>`` elements.

         Attributes:

         ``android:drawable``
            *Drawable resource*. **Required**. Reference to a drawable
            resource.
         ``android:id``
            *Resource ID*. A unique resource ID for this drawable. To
            create a new resource ID for this item, use the form:
            ``"@+id/``\ *``name``*\ ``"``. The plus symbol indicates
            that this is created as a new ID. You can use this
            identifier to retrieve and modify the drawable with
            `View.findViewById() <#findViewById>`__
            or
            `Activity.findViewById() <#findViewById>`__.
         ``android:top``
            *Dimension*. The top offset, as a dimension value or
            `dimension resource <#Dimension>`__.
         ``android:right``
            *Dimension*. The right offset, as a dimension value or
            `dimension resource <#Dimension>`__.
         ``android:bottom``
            *Dimension*. The bottom offset, as a dimension value or
            `dimension resource <#Dimension>`__.
         ``android:left``
            *Dimension*. The left offset, as a dimension value or
            `dimension resource <#Dimension>`__.

         All drawable items are scaled to fit the size of the containing
         view, by default. Thus, placing your images in a layer list at
         different positions might increase the size of the view, and
         some images scale as appropriate.

         To avoid scaling items in the list, use a ``<bitmap>`` element
         inside the ``<item>`` element to specify the drawable and
         define the gravity to something that doesn't scale, such as
         ``"center"``. For example, the following ``<item>`` defines an
         item that scales to fit its container view:

         .. code:: prettyprint

            <item android:drawable="@drawable/image" />

         To avoid scaling, the following example uses a ``<bitmap>``
         element with centered gravity:

         .. code:: prettyprint

            <item>
              <bitmap android:src="@drawable/image"
                      android:gravity="center" />
            </item>

   example:
      XML file saved at ``res/drawable/layers.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <layer-list xmlns:android="http://schemas.android.com/apk/res/android">
             <item>
               <bitmap android:src="@drawable/android_red"
                 android:gravity="center" />
             </item>
             <item android:top="10dp" android:left="10dp">
               <bitmap android:src="@drawable/android_green"
                 android:gravity="center" />
             </item>
             <item android:top="20dp" android:left="20dp">
               <bitmap android:src="@drawable/android_blue"
                 android:gravity="center" />
             </item>
         </layer-list>

      This example uses a nested ``<bitmap>`` element to define the
      drawable resource for each item with a ``"center"`` gravity. This
      ensures that none of the images are scaled to fit the size of the
      container, due to resizing caused by the offset images.

      This layout XML applies the drawable to a view:

      .. code:: prettyprint

         <ImageView
             android:layout_height="wrap_content"
             android:layout_width="wrap_content"
             android:src="@drawable/layers" />

      The result is a stack of increasingly offset images:

      .. image:: https://developer.android.google.cn/static/images/resources/layers.png

   see also:
      -  `LayerDrawable <#>`__

   .. rubric:: State list
      :name: StateList

   A
   `StateListDrawable <#>`__
   is a drawable object defined in XML that uses multiple images to
   represent the same graphic, depending on the state of the object. For
   example, the state of a
   `Button <#>`__ widget can be
   tapped, focused, or neither; using a state list drawable, you can
   provide a different background image for each state.

   You describe the state list in an XML file. Each graphic is
   represented by an ``<item>`` element inside a single ``<selector>``
   element. Each ``<item>`` uses various attributes to describe the
   state in which it is used as the graphic for the drawable.

   During each state change, the state list is traversed top to bottom,
   and the first item that matches the current state is used. The
   selection is *not* based on the "best match," but rather the first
   item that meets the minimum criteria of the state.

   file location:
      ``res/drawable/``\ *``filename``*\ ``.xml``
      The filename is the resource ID
   compiled resource datatype:
      Resource pointer to a
      `StateListDrawable <#>`__
   resource reference:
      In Java: ``R.drawable.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]drawable/``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <selector xmlns:android="http://schemas.android.com/apk/res/android"
             android:constantSize=["true" | "false"]
             android:dither=["true" | "false"]
             android:variablePadding=["true" | "false"] >
             <item
                 android:drawable="@[package:]drawable/drawable_resource"
                 android:state_pressed=["true" | "false"]
                 android:state_focused=["true" | "false"]
                 android:state_hovered=["true" | "false"]
                 android:state_selected=["true" | "false"]
                 android:state_checkable=["true" | "false"]
                 android:state_checked=["true" | "false"]
                 android:state_enabled=["true" | "false"]
                 android:state_activated=["true" | "false"]
                 android:state_window_focused=["true" | "false"] />
         </selector>

   elements:
      ``<selector>``
         **Required.** This must be the root element. Contains one or
         more ``<item>`` elements.

         Attributes:

         ``xmlns:android``
            *String*. **Required.** Defines the XML namespace, which
            must be ``"http://schemas.android.com/apk/res/android"``.
         ``android:constantSize``
            *Boolean*. True if the drawable's reported internal size
            remains constant as the state changes (the size is the
            maximum of all of the states); false if the size varies
            based on the current state. The default is false.
         ``android:dither``
            *Boolean*. True to enable dithering of the bitmap if the
            bitmap doesn't have the same pixel configuration as the
            screen, such as an ARGB 8888 bitmap on an RGB 565 screen;
            false to disable dithering. The default is true.
         ``android:variablePadding``
            *Boolean*. True if the drawable's padding changes based on
            the current state that is selected; false if the padding
            must stay the same, based on the maximum padding of all the
            states. Enabling this feature requires that you deal with
            performing layout when the state changes, which is often not
            supported. The default is false.

      ``<item>``
         Defines a drawable to use during certain states, as described
         by its attributes. Must be a child of a ``<selector>`` element.

         Attributes:

         ``android:drawable``
            *Drawable resource*. **Required**. Reference to a drawable
            resource.
         ``android:state_pressed``
            *Boolean*. True if this item is used when the object is
            tapped, such as when a button is touched; false if this item
            is used in the default, non-tapped state.
         ``android:state_focused``
            *Boolean*. True if this item is used when the object has
            input focus, such as when the user selects a text input;
            false if this item is used in the default, non-focused
            state.
         ``android:state_hovered``
            *Boolean*. True if this item is used when the cursor hovers
            over the object; false if this item is used in the default,
            non-hovered state. Often, this drawable can be the same
            drawable used for the "focused" state.

            Introduced in API level 14.

         ``android:state_selected``
            *Boolean*. True if this item is used when the object is the
            current user selection when navigating with a directional
            control, such as when navigating through a list with a
            D-pad; false if this item is used when the object isn't
            selected.

            The selected state is used when ``android:state_focused``
            isn't sufficient, such as when the list view has focus and
            an item within it is selected with a D-pad.

         ``android:state_checkable``
            *Boolean*. True if this item is used when the object is
            selectable; false if this item is used when the object isn't
            selectable. Only useful if the object can transition between
            a selectable and non-selectable widget.
         ``android:state_checked``
            *Boolean*. True if this item is used when the object is
            selected; false if it is used when the object is
            un-selected.
         ``android:state_enabled``
            *Boolean*. True if this item is used when the object is
            enabled, meaning capable of receiving touch or click events;
            false if it is used when the object is disabled.
         ``android:state_activated``
            *Boolean*. True if this item is used when the object is
            activated as the persistent selection, such as to
            "highlight" the previously selected list item in a
            persistent navigation view; false if it is used when the
            object isn't activated.

            Introduced in API level 11.

         ``android:state_window_focused``
            *Boolean*. True if this item is used when the application
            window has focus, meaning the application is in the
            foreground; false if this item is used when the application
            window doesn't have focus, for example, if the notification
            shade is pulled down or a dialog appears.

         **Note:** Android applies the first item in the state list that
         matches the current state of the object. So, if the first item
         in the list contains none of the preceding state attributes,
         then it is applied every time. This is why you want your
         default value to always be last, as demonstrated in the
         following example.

   example:
      XML file saved at ``res/drawable/button.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <selector xmlns:android="http://schemas.android.com/apk/res/android">
             <item android:state_pressed="true"
                   android:drawable="@drawable/button_pressed" /> <!-- pressed -->
             <item android:state_focused="true"
                   android:drawable="@drawable/button_focused" /> <!-- focused -->
             <item android:state_hovered="true"
                   android:drawable="@drawable/button_focused" /> <!-- hovered -->
             <item android:drawable="@drawable/button_normal" /> <!-- default -->
         </selector>

      This layout XML applies the state list drawable to a button:

      .. code:: prettyprint

         <Button
             android:layout_height="wrap_content"
             android:layout_width="wrap_content"
             android:background="@drawable/button" />

   see also:
      -  `StateListDrawable <#>`__

   .. rubric:: Level list
      :name: LevelList

   A drawable that manages a number of alternate drawables, each
   assigned a maximum numerical value. Setting the level value of the
   drawable with
   `setLevel() <#setLevel>`__
   loads the drawable resource in the level list that has an
   ``android:maxLevel`` value greater than or equal to the value passed
   to the method.

   file location:
      ``res/drawable/``\ *``filename``*\ ``.xml``
      The filename is the resource ID
   compiled resource datatype:
      Resource pointer to a
      `LevelListDrawable <#>`__
   resource reference:
      In Java: ``R.drawable.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]drawable/``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <level-list
             xmlns:android="http://schemas.android.com/apk/res/android" >
             <item
                 android:drawable="@drawable/drawable_resource"
                 android:maxLevel="integer"
                 android:minLevel="integer" />
         </level-list>

   elements:
      ``<level-list>``
         **Required.** This must be the root element. Contains one or
         more ``<item>`` elements.

         Attributes:

         ``xmlns:android``
            *String*. **Required.** Defines the XML namespace, which
            must be ``"http://schemas.android.com/apk/res/android"``.

      ``<item>``
         Defines a drawable to use at a certain level.

         Attributes:

         ``android:drawable``
            *Drawable resource*. **Required**. Reference to a drawable
            resource to be inset.
         ``android:maxLevel``
            *Integer*. The maximum level permitted for this item.
         ``android:minLevel``
            *Integer*. The minimum level permitted for this item.

   example:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <level-list xmlns:android="http://schemas.android.com/apk/res/android" >
             <item
                 android:drawable="@drawable/status_off"
                 android:maxLevel="0" />
             <item
                 android:drawable="@drawable/status_on"
                 android:maxLevel="1" />
         </level-list>

      Once this is applied to a
      `View <#>`__, the level can be
      changed with
      `setLevel() <#setLevel>`__
      or
      `setImageLevel() <#setImageLevel>`__.

   see also:
      -  `LevelListDrawable <#>`__

   .. rubric:: Transition drawable
      :name: Transition

   A
   `TransitionDrawable <#>`__
   is a drawable object that can cross-fade between two other drawable
   resources.

   Each drawable is represented by an ``<item>`` element inside a single
   ``<transition>`` element. No more than two items are supported. To
   transition forward, call
   `startTransition() <#startTransition>`__.
   To transition backward, call
   `reverseTransition() <#reverseTransition>`__.

   file location:
      ``res/drawable/``\ *``filename``*\ ``.xml``
      The filename is the resource ID
   compiled resource datatype:
      Resource pointer to a
      `TransitionDrawable <#>`__
   resource reference:
      In Java: ``R.drawable.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]drawable/``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <transition
         xmlns:android="http://schemas.android.com/apk/res/android" >
             <item
                 android:drawable="@[package:]drawable/drawable_resource"
                 android:id="@[+][package:]id/resource_name"
                 android:top="dimension"
                 android:right="dimension"
                 android:bottom="dimension"
                 android:left="dimension" />
         </transition>

   elements:
      ``<transition>``
         **Required.** This must be the root element. Contains one or
         more ``<item>`` elements.

         Attributes:

         ``xmlns:android``
            *String*. **Required.** Defines the XML namespace, which
            must be ``"http://schemas.android.com/apk/res/android"``.

      ``<item>``
         Defines a drawable to use as part of the drawable transition.
         Must be a child of a ``<transition>`` element. Accepts child
         ``<bitmap>`` elements.

         Attributes:

         ``android:drawable``
            *Drawable resource*. **Required**. Reference to a drawable
            resource.
         ``android:id``
            *Resource ID*. A unique resource ID for this drawable. To
            create a new resource ID for this item, use the form:
            ``"@+id/``\ *``name``*\ ``"``. The plus symbol indicates
            that this is created as a new ID. You can use this
            identifier to retrieve and modify the drawable with
            `View.findViewById() <#findViewById>`__
            or
            `Activity.findViewById() <#findViewById>`__.
         ``android:top``
            *Integer*. The top offset in pixels.
         ``android:right``
            *Integer*. The right offset in pixels.
         ``android:bottom``
            *Integer*. The bottom offset in pixels.
         ``android:left``
            *Integer*. The left offset in pixels.

   example:
      XML file saved at ``res/drawable/transition.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <transition xmlns:android="http://schemas.android.com/apk/res/android">
             <item android:drawable="@drawable/on" />
             <item android:drawable="@drawable/off" />
         </transition>

      This layout XML applies the drawable to a view:

      .. code:: prettyprint

         <ImageButton
             android:id="@+id/button"
             android:layout_height="wrap_content"
             android:layout_width="wrap_content"
             android:src="@drawable/transition" />

      And the following code performs a 500 ms transition from the first
      item to the second:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val button: ImageButton = findViewById(R.id.button)
               val drawable: Drawable = button.drawable
               if (drawable is TransitionDrawable) {
                   drawable.startTransition(500)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ImageButton button = (ImageButton) findViewById(R.id.button);
               Drawable drawable = button.getDrawable();
               if (drawable instanceof TransitionDrawable) {
                   ((TransitionDrawable) drawable).startTransition(500);
               }

   see also:
      -  `TransitionDrawable <#>`__

   .. rubric:: Inset drawable
      :name: Inset

   A drawable defined in XML that insets another drawable by a specified
   distance. This is useful when a view needs a background that is
   smaller than the view's actual bounds.

   file location:
      ``res/drawable/``\ *``filename``*\ ``.xml``
      The filename is the resource ID
   compiled resource datatype:
      Resource pointer to a
      `InsetDrawable <#>`__
   resource reference:
      In Java: ``R.drawable.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]drawable/``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <inset
             xmlns:android="http://schemas.android.com/apk/res/android"
             android:drawable="@drawable/drawable_resource"
             android:insetTop="dimension"
             android:insetRight="dimension"
             android:insetBottom="dimension"
             android:insetLeft="dimension" />

   elements:
      ``<inset>``
         **Required.** Defines the inset drawable. This must be the root
         element.

         Attributes:

         ``xmlns:android``
            *String*. **Required.** Defines the XML namespace, which
            must be ``"http://schemas.android.com/apk/res/android"``.
         ``android:drawable``
            *Drawable resource*. **Required**. Reference to a drawable
            resource to be inset.
         ``android:insetTop``
            *Dimension*. The top inset, as a dimension value or
            `dimension resource <#Dimension>`__.
         ``android:insetRight``
            *Dimension*. The right inset, as a dimension value or
            `dimension resource <#Dimension>`__.
         ``android:insetBottom``
            *Dimension*. The bottom inset, as a dimension value or
            `dimension resource <#Dimension>`__.
         ``android:insetLeft``
            *Dimension*. The left inset, as a dimension value or
            `dimension resource <#Dimension>`__.

   example:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <inset xmlns:android="http://schemas.android.com/apk/res/android"
             android:drawable="@drawable/background"
             android:insetTop="10dp"
             android:insetLeft="10dp" />

   see also:
      -  `InsetDrawable <#>`__

   .. rubric:: Clip drawable
      :name: Clip

   A drawable defined in XML that clips another drawable based on this
   drawable's current level. You can control how much the child drawable
   gets clipped in width and height based on the level, as well as a
   gravity to control where it is placed in its overall container. Most
   often used to implement things like progress bars.

   file location:
      ``res/drawable/``\ *``filename``*\ ``.xml``
      The filename is the resource ID
   compiled resource datatype:
      Resource pointer to a
      `ClipDrawable <#>`__
   resource reference:
      In Java: ``R.drawable.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]drawable/``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <clip
             xmlns:android="http://schemas.android.com/apk/res/android"
             android:drawable="@drawable/drawable_resource"
             android:clipOrientation=["horizontal" | "vertical"]
             android:gravity=["top" | "bottom" | "left" | "right" | "center_vertical" |
                              "fill_vertical" | "center_horizontal" | "fill_horizontal" |
                              "center" | "fill" | "clip_vertical" | "clip_horizontal"] />

   elements:
      ``<clip>``
         **Required.** Defines the clip drawable. This must be the root
         element.

         Attributes:

         ``xmlns:android``
            *String*. **Required.** Defines the XML namespace, which
            must be ``"http://schemas.android.com/apk/res/android"``.
         ``android:drawable``
            *Drawable resource*. **Required**. Reference to a drawable
            resource to be clipped.
         ``android:clipOrientation``
            *Keyword*. The orientation for the clip.

            Must be one of the following constant values:

            .. list-table::
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - ``horizontal``
                  - Clip the drawable horizontally.
               - 

                  - ``vertical``
                  - Clip the drawable vertically.

         ``android:gravity``
            *Keyword*. Specifies where to clip within the drawable.

            Must be one or more of the following constant values,
            separated by ``|``:

            .. list-table::
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - ``top``
                  - Put the object at the top of its container, not
                     changing its size. When ``clipOrientation`` is
                     ``"vertical"``, clipping occurs at the bottom of
                     the drawable.
               - 

                  - ``bottom``
                  - Put the object at the bottom of its container, not
                     changing its size. When ``clipOrientation`` is
                     ``"vertical"``, clipping occurs at the top of the
                     drawable.
               - 

                  - ``left``
                  - Put the object at the left edge of its container,
                     not changing its size. This is the default. When
                     ``clipOrientation`` is ``"horizontal"``, clipping
                     occurs at the right side of the drawable.
               - 

                  - ``right``
                  - Put the object at the right edge of its container,
                     not changing its size. When ``clipOrientation`` is
                     ``"horizontal"``, clipping occurs at the left side
                     of the drawable.
               - 

                  - ``center_vertical``
                  - Put the object in the vertical center of its
                     container, not changing its size. Clipping behaves
                     the same as when gravity is ``"center"``.
               - 

                  - ``fill_vertical``
                  - Grow the vertical size of the object if needed so it
                     completely fills its container. When
                     ``clipOrientation`` is ``"vertical"``, no clipping
                     occurs because the drawable fills the vertical
                     space (unless the drawable level is 0, in which
                     case it's not visible).
               - 

                  - ``center_horizontal``
                  - Put the object in the horizontal center of its
                     container, not changing its size. Clipping behaves
                     the same as when gravity is ``"center"``.
               - 

                  - ``fill_horizontal``
                  - Grow the horizontal size of the object if needed so
                     it completely fills its container. When
                     ``clipOrientation`` is ``"horizontal"``, no
                     clipping occurs because the drawable fills the
                     horizontal space (unless the drawable level is 0,
                     in which case it's not visible).
               - 

                  - ``center``
                  - Put the object in the center of its container in
                     both the vertical and horizontal axis, not changing
                     its size. When ``clipOrientation`` is
                     ``"horizontal"``, clipping occurs on the left and
                     right. When ``clipOrientation`` is ``"vertical"``,
                     clipping occurs on the top and bottom.
               - 

                  - ``fill``
                  - Grow the horizontal and vertical size of the object
                     if needed so it completely fills its container. No
                     clipping occurs because the drawable fills the
                     horizontal and vertical space (unless the drawable
                     level is 0, in which case it's not visible).
               - 

                  - ``clip_vertical``
                  - Additional option that can be set to have the top
                     and/or bottom edges of the child clipped to its
                     container's bounds. The clip is based on the
                     vertical gravity: a top gravity clips the bottom
                     edge, a bottom gravity clips the top edge, and
                     neither clips both edges.
               - 

                  - ``clip_horizontal``
                  - Additional option that can be set to have the left
                     and/or right edges of the child clipped to its
                     container's bounds. The clip is based on the
                     horizontal gravity: a left gravity clips the right
                     edge, a right gravity clips the left edge, and
                     neither clips both edges.

   example:
      XML file saved at ``res/drawable/clip.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <clip xmlns:android="http://schemas.android.com/apk/res/android"
             android:drawable="@drawable/android"
             android:clipOrientation="horizontal"
             android:gravity="left" />

      The following layout XML applies the clip drawable to a view:

      .. code:: prettyprint

         <ImageView
             android:id="@+id/image"
             android:src="@drawable/clip"
             android:layout_height="wrap_content"
             android:layout_width="wrap_content" />

      The following code gets the drawable and increases the amount of
      clipping to progressively reveal the image:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val imageview: ImageView = findViewById(R.id.image)
               val drawable: Drawable = imageview.background
               if (drawable is ClipDrawable) {
                   drawable.level = drawable.level + 1000
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ImageView imageview = (ImageView) findViewById(R.id.image);
               Drawable drawable = imageview.getBackground();
               if (drawable instanceof ClipDrawable) {
                   ((ClipDrawable)drawable).setLevel(drawable.getLevel() + 1000);
               }

      Increasing the level reduces the amount of clipping and slowly
      reveals the image. Here it is at a level of 7000:

      .. image:: https://developer.android.google.cn/static/images/resources/clip.png

      **Note:** The default level is 0, which is fully clipped so the
      image isn't visible. When the level is 10,000, the image isn't
      clipped and is completely visible.

   see also:
      -  `ClipDrawable <#>`__

   .. rubric:: Scale drawable
      :name: Scale

   A drawable defined in XML that changes the size of another drawable
   based on its current level.

   file location:
      ``res/drawable/``\ *``filename``*\ ``.xml``
      The filename is the resource ID
   compiled resource datatype:
      Resource pointer to a
      `ScaleDrawable <#>`__
   resource reference:
      In Java: ``R.drawable.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]drawable/``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <scale
             xmlns:android="http://schemas.android.com/apk/res/android"
             android:drawable="@drawable/drawable_resource"
             android:scaleGravity=["top" | "bottom" | "left" | "right" | "center_vertical" |
                                   "fill_vertical" | "center_horizontal" | "fill_horizontal" |
                                   "center" | "fill" | "clip_vertical" | "clip_horizontal"]
             android:scaleHeight="percentage"
             android:scaleWidth="percentage" />

   elements:
      ``<scale>``
         **Required.** Defines the scale drawable. This must be the root
         element.

         Attributes:

         ``xmlns:android``
            *String*. **Required.** Defines the XML namespace, which
            must be ``"http://schemas.android.com/apk/res/android"``.
         ``android:drawable``
            *Drawable resource*. **Required**. Reference to a drawable
            resource.
         ``android:scaleGravity``
            *Keyword*. Specifies the gravity position after scaling.

            Must be one or more of the following constant values,
            separated by ``|``:

            .. list-table::
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - ``top``
                  - Put the object at the top of its container, not
                     changing its size.
               - 

                  - ``bottom``
                  - Put the object at the bottom of its container, not
                     changing its size.
               - 

                  - ``left``
                  - Put the object at the left edge of its container,
                     not changing its size. This is the default.
               - 

                  - ``right``
                  - Put the object at the right edge of its container,
                     not changing its size.
               - 

                  - ``center_vertical``
                  - Put the object in the vertical center of its
                     container, not changing its size.
               - 

                  - ``fill_vertical``
                  - Grow the vertical size of the object if needed so it
                     completely fills its container.
               - 

                  - ``center_horizontal``
                  - Put the object in the horizontal center of its
                     container, not changing its size.
               - 

                  - ``fill_horizontal``
                  - Grow the horizontal size of the object if needed so
                     it completely fills its container.
               - 

                  - ``center``
                  - Put the object in the center of its container in
                     both the vertical and horizontal axis, not changing
                     its size.
               - 

                  - ``fill``
                  - Grow the horizontal and vertical size of the object
                     if needed so it completely fills its container.
               - 

                  - ``clip_vertical``
                  - Additional option that can be set to have the top
                     and/or bottom edges of the child clipped to its
                     container's bounds. The clip is based on the
                     vertical gravity: a top gravity clips the bottom
                     edge, a bottom gravity clips the top edge, and
                     neither clips both edges.
               - 

                  - ``clip_horizontal``
                  - Additional option that can be set to have the left
                     and/or right edges of the child clipped to its
                     container's bounds. The clip is based on the
                     horizontal gravity: a left gravity clips the right
                     edge, a right gravity clips the left edge, and
                     neither clips both edges.

         ``android:scaleHeight``
            *Percentage*. The scale height, expressed as a percentage of
            the drawable's bound. The value's format is XX%, such as
            100% or 12.5%.
         ``android:scaleWidth``
            *Percentage*. The scale width, expressed as a percentage of
            the drawable's bound. The value's format is XX%, such as
            100% or 12.5%.

   example:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <scale xmlns:android="http://schemas.android.com/apk/res/android"
             android:drawable="@drawable/logo"
             android:scaleGravity="center_vertical|center_horizontal"
             android:scaleHeight="80%"
             android:scaleWidth="80%" />

   see also:
      -  `ScaleDrawable <#>`__

   .. rubric:: Shape drawable
      :name: Shape

   This is a generic shape defined in XML.

   file location:
      ``res/drawable/``\ *``filename``*\ ``.xml``
      The filename is the resource ID
   compiled resource datatype:
      Resource pointer to a
      `GradientDrawable <#>`__
   resource reference:
      In Java: ``R.drawable.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]drawable/``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <shape
             xmlns:android="http://schemas.android.com/apk/res/android"
             android:shape=["rectangle" | "oval" | "line" | "ring"] >
             <corners
                 android:radius="integer"
                 android:topLeftRadius="integer"
                 android:topRightRadius="integer"
                 android:bottomLeftRadius="integer"
                 android:bottomRightRadius="integer" />
             <gradient
                 android:angle="integer"
                 android:centerX="float"
                 android:centerY="float"
                 android:centerColor="integer"
                 android:endColor="color"
                 android:gradientRadius="integer"
                 android:startColor="color"
                 android:type=["linear" | "radial" | "sweep"]
                 android:useLevel=["true" | "false"] />
             <padding
                 android:left="integer"
                 android:top="integer"
                 android:right="integer"
                 android:bottom="integer" />
             <size
                 android:width="integer"
                 android:height="integer" />
             <solid
                 android:color="color" />
             <stroke
                 android:width="integer"
                 android:color="color"
                 android:dashWidth="integer"
                 android:dashGap="integer" />
         </shape>

   elements:
      ``<shape>``
         **Required.** The shape drawable. This must be the root
         element.

         Attributes:

         ``xmlns:android``
            *String*. **Required.** Defines the XML namespace, which
            must be ``"http://schemas.android.com/apk/res/android"``.
         ``android:shape``
            *Keyword*. Defines the type of shape. Valid values are:

            .. list-table::
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - ``"rectangle"``
                  - A rectangle that fills the containing view. This is
                     the default shape.
               - 

                  - ``"oval"``
                  - An oval shape that fits the dimensions of the
                     containing view.
               - 

                  - ``"line"``
                  - A horizontal line that spans the width of the
                     containing view. This shape requires the
                     ``<stroke>`` element to define the width of the
                     line.
               - 

                  - ``"ring"``
                  - A ring shape.

         The following attributes are used only when
         ``android:shape="ring"``:

         ``android:innerRadius``
            *Dimension*. The radius for the inner part of the ring (the
            hole in the middle), as a dimension value or `dimension resource <#Dimension>`__.
         ``android:innerRadiusRatio``
            *Float*. The radius for the inner part of the ring,
            expressed as a ratio of the ring's width. For instance, if
            ``android:innerRadiusRatio="5"``, then the inner radius
            equals the ring's width divided by 5. This value is
            overridden by ``android:innerRadius``. The default value is
            9.
         ``android:thickness``
            *Dimension*. The thickness of the ring, as a dimension value
            or `dimension resource <#Dimension>`__.
         ``android:thicknessRatio``
            *Float*. The thickness of the ring expressed as a ratio of
            the ring's width. For instance, if
            ``android:thicknessRatio="2"``, then the thickness equals
            the ring's width divided by 2. This value is overridden by
            ``android:innerRadius``. The default value is 3.
         ``android:useLevel``
            *Boolean*. True if this is used as a
            `LevelListDrawable <#>`__.
            This normally is false, or else your shape might not appear.

      ``<corners>``
         Creates rounded corners for the shape. Applies only when the
         shape is a rectangle.

         Attributes:

         ``android:radius``
            *Dimension*. The radius for all corners, as a dimension
            value or `dimension resource <#Dimension>`__.
            This is overridden for each corner by the following
            attributes.
         ``android:topLeftRadius``
            *Dimension*. The radius for the top-left corner, as a
            dimension value or `dimension resource <#Dimension>`__.
         ``android:topRightRadius``
            *Dimension*. The radius for the top-right corner, as a
            dimension value or `dimension resource <#Dimension>`__.
         ``android:bottomLeftRadius``
            *Dimension*. The radius for the bottom-left corner, as a
            dimension value or `dimension resource <#Dimension>`__.
         ``android:bottomRightRadius``
            *Dimension*. The radius for the bottom-right corner, as a
            dimension value or `dimension resource <#Dimension>`__.

         **Note:** Every corner must initially be provided a corner
         radius greater than 1, or else no corners are rounded. If you
         want specific corners to *not* be rounded, a workaround is to
         use ``android:radius`` to set a default corner radius greater
         than 1 and then override every corner with the values you
         really want, providing 0 ("0dp") where you don't want rounded
         corners.

      ``<gradient>``
         Specifies a gradient color for the shape.

         Attributes:

         ``android:angle``
            *Integer*. The angle for the gradient, in degrees. 0 is left
            to right, 90 is bottom to top. It must be a multiple of 45.
            The default is 0.
         ``android:centerX``
            *Float*. The relative X-position for the center of the
            gradient (0 - 1.0).
         ``android:centerY``
            *Float*. The relative Y-position for the center of the
            gradient (0 - 1.0).
         ``android:centerColor``
            *Color*. Optional color that comes between the start and end
            colors, as a hexadecimal value or `color resource <#Color>`__.
         ``android:endColor``
            *Color*. The ending color, as a hexadecimal value or `color resource <#Color>`__.
         ``android:gradientRadius``
            *Float*. The radius for the gradient. Only applied when
            ``android:type="radial"``.
         ``android:startColor``
            *Color*. The starting color, as a hexadecimal value or
            `color resource <#Color>`__.
         ``android:type``
            *Keyword*. The type of gradient pattern to apply. Valid
            values are:

            .. list-table::
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - ``"linear"``
                  - A linear gradient. This is the default.
               - 

                  - ``"radial"``
                  - A radial gradient. The start color is the center
                     color.
               - 

                  - ``"sweep"``
                  - A sweeping line gradient.
         ``android:useLevel``
            *Boolean*. True if this is used as a
            `LevelListDrawable <#>`__.

      ``<padding>``
         Padding to apply to the containing view element. This pads the
         position of the view content, not the shape.

         Attributes:

         ``android:left``
            *Dimension*. Left padding, as a dimension value or
            `dimension resource <#Dimension>`__.
         ``android:top``
            *Dimension*. Top padding, as a dimension value or `dimension resource <#Dimension>`__.
         ``android:right``
            *Dimension*. Right padding, as a dimension value or
            `dimension resource <#Dimension>`__.
         ``android:bottom``
            *Dimension*. Bottom padding, as a dimension value or
            `dimension resource <#Dimension>`__.

      ``<size>``
         The size of the shape.

         Attributes:

         ``android:height``
            *Dimension*. The height of the shape, as a dimension value
            or `dimension resource <#Dimension>`__.
         ``android:width``
            *Dimension*. The width of the shape, as a dimension value or
            `dimension resource <#Dimension>`__.

         **Note:** By default, the shape scales to the size of the
         container view proportionate to the dimensions defined here.
         When you use the shape in an
         `ImageView <#>`__, you
         can restrict scaling by setting the
         `android:scaleType <#attr_android:scaleType>`__
         to ``"center"``.

      ``<solid>``
         A solid color to fill the shape.

         Attributes:

         ``android:color``
            *Color*. The color to apply to the shape, as a hexadecimal
            value or `color resource <#Color>`__.

      ``<stroke>``
         A stroke line for the shape.

         Attributes:

         ``android:width``
            *Dimension*. The thickness of the line, as a dimension value
            or `dimension resource <#Dimension>`__.
         ``android:color``
            *Color*. The color of the line, as a hexadecimal value or
            `color resource <#Color>`__.
         ``android:dashGap``
            *Dimension*. The distance between line dashes, as a
            dimension value or `dimension resource <#Dimension>`__.
            Only valid if ``android:dashWidth`` is set.
         ``android:dashWidth``
            *Dimension*. The size of each dash line, as a dimension
            value or `dimension resource <#Dimension>`__.
            Only valid if ``android:dashGap`` is set.

   example:
      XML file saved at ``res/drawable/gradient_box.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <shape xmlns:android="http://schemas.android.com/apk/res/android"
             android:shape="rectangle">
             <gradient
                 android:startColor="#FFFF0000"
                 android:endColor="#80FF00FF"
                 android:angle="45"/>
             <padding android:left="7dp"
                 android:top="7dp"
                 android:right="7dp"
                 android:bottom="7dp" />
             <corners android:radius="8dp" />
         </shape>

      This layout XML applies the shape drawable to a view:

      .. code:: prettyprint

         <TextView
             android:background="@drawable/gradient_box"
             android:layout_height="wrap_content"
             android:layout_width="wrap_content" />

      This application code gets the shape drawable and applies it to a
      view:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val shape: Drawable? = getDrawable(resources, R.drawable.gradient_box, getTheme())

               val tv: TextView = findViewById(R.id.textview)
               tv.background = shape

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Resources res = getResources();
               Drawable shape = ResourcesCompat.getDrawable(res, R.drawable.gradient_box, getTheme());

               TextView tv = (TextView)findViewById(R.id.textview);
               tv.setBackground(shape);

   see also:
      -  `ShapeDrawable <#>`__

.. container:: devsite-steps

Last updated 2024-01-03 UTC.


/Layout resource
================

.. container:: devsite-article-body clearfix

   A layout resource defines the architecture for the UI in an
   ``Activity`` or a component of a UI.

   file location:
      ``res/layout/``\ *``filename``*\ ``.xml``
      The filename is used as the resource ID.
   compiled resource datatype:
      Resource pointer to a `View <#>`__
      (or subclass) resource
   resource reference:
      In Java: ``R.layout.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]layout/``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <ViewGroup
             xmlns:android="http://schemas.android.com/apk/res/android"
             android:id="@[+][package:]id/resource_name"
             android:layout_height=["dimension" | "match_parent" | "wrap_content"]
             android:layout_width=["dimension" | "match_parent" | "wrap_content"]
             [ViewGroup-specific attributes] >
             <View
                 android:id="@[+][package:]id/resource_name"
                 android:layout_height=["dimension" | "match_parent" | "wrap_content"]
                 android:layout_width=["dimension" | "match_parent" | "wrap_content"]
                 [View-specific attributes] >
                 <requestFocus/>
             </View>
             <ViewGroup >
                 <View />
             </ViewGroup>
             <include layout="@layout/layout_resource"/>
         </ViewGroup>

      **Note:** The root element can be a
      `ViewGroup <#>`__, a
      `View <#>`__, or a
      `<merge> <#merge-element>`__ element, but there can be only
      one root element and it must contain the ``xmlns:android``
      attribute with the ``android`` namespace as shown in the preceding
      syntax example.

   elements:
      ``<ViewGroup>``
         A container for other
         `View <#>`__ elements. There are
         many different kinds of
         `ViewGroup <#>`__ objects,
         and each one lets you specify the layout of the child elements
         in different ways. Different kinds of ``ViewGroup`` objects
         include
         `LinearLayout <#>`__,
         `RelativeLayout <#>`__,
         and
         `FrameLayout <#>`__.

         Don't assume that any derivation of ``ViewGroup`` accepts
         nested views. Some view groups are implementations of the
         `AdapterView <#>`__
         class, which determines its children only from an
         `Adapter <#>`__.

         Attributes:

         ``android:id``
            *Resource ID*. A unique resource name for the element, which
            you can use to obtain a reference to the ``ViewGroup`` from
            your application. For more information, see the `Value for android:id <#idvalue>`__ section.
         ``android:layout_height``
            *Dimension or keyword*. **Required**. The height for the
            group, as a dimension value (or `dimension resource <#Dimension>`__)
            or a keyword (``"match_parent"`` or ``"wrap_content"``). For
            more information, see the `Values for android:layout_height and android:layout_width <#layoutvalues>`__ section.
         ``android:layout_width``
            *Dimension or keyword*. **Required**. The width for the
            group, as a dimension value (or `dimension resource <#Dimension>`__)
            or a keyword (``"match_parent"`` or ``"wrap_content"``). For
            more information, see the `Values for android:layout_height and android:layout_width <#layoutvalues>`__ section.

         The ``ViewGroup`` base class supports more attributes, and many
         more are supported by each implementation of ``ViewGroup``. For
         a reference of all available attributes, see the corresponding
         reference documentation for the
         `ViewGroup <#>`__ class,
         for example, the `LinearLayout`` XML
         attributes </reference/android/widget/LinearLayout#lattrs>`__.

      ``<View>``
         An individual UI component, generally referred to as a
         *widget*. Different kinds of
         `View <#>`__ objects include
         `TextView <#>`__,
         `Button <#>`__, and
         `CheckBox <#>`__.

         Attributes:

         ``android:id``
            *Resource ID*. A unique resource name for the element, which
            you can use to obtain a reference to the ``View`` from your
            application. For more information, see the `Value for android:id <#idvalue>`__ section.
         ``android:layout_height``
            *Dimension or keyword*. **Required**. The height for the
            element, as a dimension value (or `dimension resource <#Dimension>`__)
            or a keyword (``"match_parent"`` or ``"wrap_content"``). For
            more information, see the `Values for android:layout_height and android:layout_width <#layoutvalues>`__ section.
         ``android:layout_width``
            *Dimension or keyword*. **Required**. The width for the
            element, as a dimension value (or `dimension resource <#Dimension>`__)
            or a keyword (``"match_parent"`` or ``"wrap_content"``). For
            more information, see the `Values for android:layout_height and android:layout_width <#layoutvalues>`__ section.

         The ``View`` base class supports more attributes, and many more
         are supported by each implementation of ``View``. For more
         information, read
         `Layouts <#>`__. For a
         reference of all available attributes, see the corresponding
         reference documentation, for example, the `TextView`` XML
         attributes </reference/android/widget/TextView#lattrs>`__.

      ``<requestFocus>``
         Any element representing a
         `View <#>`__ object can include
         this empty element, which gives its parent initial focus on the
         screen. You can have only one of these elements per file.
      ``<include>``
         Includes a layout file into this layout.

         Attributes:

         ``layout``
            *Layout resource*. **Required**. Reference to a layout
            resource.
         ``android:id``
            *Resource ID*. Overrides the ID given to the root view in
            the included layout.
         ``android:layout_height``
            *Dimension or keyword*. Overrides the height given to the
            root view in the included layout. Only effective if
            ``android:layout_width`` is also declared.
         ``android:layout_width``
            *Dimension or keyword*. Overrides the width given to the
            root view in the included layout. Only effective if
            ``android:layout_height`` is also declared.

         You can include any other layout attributes in the
         ``<include>`` that are supported by the root element in the
         included layout and they override those defined in the root
         element.

         **Caution:** If you want to override layout attributes using
         the ``<include>`` tag, you must override both
         ``android:layout_height`` and ``android:layout_width`` in order
         for other layout attributes to take effect.

         Another way to include a layout is to use
         `ViewStub <#>`__: a
         lightweight view that consumes no layout space until you
         explicitly inflate it. When you do, it includes a layout file
         defined by its ``android:layout`` attribute. For more
         information about using ``ViewStub``, read `Load views on demand <#>`__.

      ``<merge>``
         An alternative root element that isn't drawn in the layout
         hierarchy. Using this as the root element is useful when you
         know that this layout is placed into a layout that already
         contains the appropriate parent ``View`` to contain the
         children of the ``<merge>`` element.

         This is particularly useful when you plan to include this
         layout in another layout file using
         `<include> <#include-element>`__ and this layout doesn't
         require a different
         `ViewGroup <#>`__
         container. For more information about merging layouts, read
         `Reuse layouts with <include> <#>`__.

      .. rubric:: Value for android:id
         :name: idvalue

      For the ID value, you typically use this syntax form:
      ``"@+id/``\ *``name``*\ ``"``, as shown in the following example.
      The plus symbol, ``+``, indicates that this is a new resource ID,
      and the ``aapt`` tool creates a new resource integer in the
      ``R.java`` class, if it doesn't already exist.

      .. code:: prettyprint

         <TextView android:id="@+id/nameTextbox"/>

      The ``nameTextbox`` name is now a resource ID attached to this
      element. You can then refer to the
      `TextView <#>`__ to which the
      ID is associated in Java:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val textView: TextView? = findViewById(R.id.nameTextbox)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               TextView textView = findViewById(R.id.nameTextbox);

      This code returns the ``TextView`` object.

      However, if you have already defined an `ID resource <#Id>`__, and it
      isn't already used, then you can apply that ID to a ``View``
      element by excluding the plus symbol in the ``android:id`` value.

      .. rubric:: Values for android:layout_height and
         android:layout_width
         :name: layoutvalues

      The height and width values are expressed using any of the
      `dimension units <#Dimension>`__
      supported by Android (px, dp, sp, pt, in, mm) or with the
      following keywords:

      .. list-table::
         :header-rows: 1

         - 

            - Value
            - Description
         - 

            - ``match_parent``
            - Sets the dimension to match that of the parent element.
               Added in API level 8 to deprecate ``fill_parent``.
         - 

            - ``wrap_content``
            - Sets the dimension only to the size required to fit the
               content of this element.

      .. rubric:: Custom view elements
         :name: custom-view-elements

      You can create custom `View <#>`__
      and `ViewGroup <#>`__ elements
      and apply them to your layout the same as a standard layout
      element. You can also specify the attributes supported in the XML
      element. For more information, see `Create custom view components <#>`__.

   example:
      XML file saved at ``res/layout/main_activity.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                       android:layout_width="match_parent"
                       android:layout_height="match_parent"
                       android:orientation="vertical" >
             <TextView android:id="@+id/text"
                       android:layout_width="wrap_content"
                       android:layout_height="wrap_content"
                       android:text="Hello, I am a TextView" />
             <Button android:id="@+id/button"
                     android:layout_width="wrap_content"
                     android:layout_height="wrap_content"
                     android:text="Hello, I am a Button" />
         </LinearLayout>

      This application code loads the layout for an
      `Activity <#>`__ in the
      `onCreate() <#onCreate>`__
      method:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               public override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)
                   setContentView(R.layout.main_activity)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public void onCreate(Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);
                   setContentView(R.layout.main_activity);
               }

   see also:
      -  `Layouts <#>`__
      -  `View <#>`__
      -  `ViewGroup <#>`__

.. container:: devsite-steps

Last updated 2024-01-03 UTC.


/Menu resource
==============

.. container:: devsite-article-body clearfix

   A menu resource defines an application menu‚Äîan options menu, context
   menu, or submenu‚Äîthat can be inflated with
   `MenuInflater <#>`__.

   For a guide to using menus, see `Add menus <#>`__.

   file location:
      ``res/menu/``\ *``filename``*\ ``.xml``
      The filename is used as the resource ID
   compiled resource datatype:
      Resource pointer to a `Menu <#>`__
      (or subclass) resource
   resource reference:
      In Java: ``R.menu.``\ *``filename``*
      In XML: ``@[``\ *``package``*\ ``:]menu.``\ *``filename``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <menu xmlns:android="http://schemas.android.com/apk/res/android">
             <item android:id="@[+][package:]id/resource_name"
                   android:title="string"
                   android:titleCondensed="string"
                   android:icon="@[package:]drawable/drawable_resource_name"
                   android:onClick="method name"
                   android:showAsAction=["ifRoom" | "never" | "withText" | "always" | "collapseActionView"]
                   android:actionLayout="@[package:]layout/layout_resource_name"
                   android:actionViewClass="class name"
                   android:actionProviderClass="class name"
                   android:alphabeticShortcut="string"
                   android:alphabeticModifiers=["META" | "CTRL" | "ALT" | "SHIFT" | "SYM" | "FUNCTION"]
                   android:numericShortcut="string"
                   android:numericModifiers=["META" | "CTRL" | "ALT" | "SHIFT" | "SYM" | "FUNCTION"]
                   android:checkable=["true" | "false"]
                   android:visible=["true" | "false"]
                   android:enabled=["true" | "false"]
                   android:menuCategory=["container" | "system" | "secondary" | "alternative"]
                   android:orderInCategory="integer" />
             <group android:id="@[+][package:]id/resource name"
                    android:checkableBehavior=["none" | "all" | "single"]
                    android:visible=["true" | "false"]
                    android:enabled=["true" | "false"]
                    android:menuCategory=["container" | "system" | "secondary" | "alternative"]
                    android:orderInCategory="integer" >
                 <item />
             </group>
             <item >
                 <menu>
                   <item />
                 </menu>
             </item>
         </menu>

   elements:
      ``<menu>``
         **Required.** This must be the root node. Contains ``<item>``
         and/or ``<group>`` elements.

         Attributes:

         ``xmlns:android``
            *XML namespace*. **Required.** Defines the XML namespace,
            which must be
            ``"http://schemas.android.com/apk/res/android"``.

      ``<item>``
         A menu item. Might contain a ``<menu>`` element (for a
         submenu). Must be a child of a ``<menu>`` or ``<group>``
         element.

         Attributes:

         ``android:id``
            *Resource ID*. A unique resource ID. To create a new
            resource ID for this item, use the form:
            ``"@+id/``\ *``name``*\ ``"``. The plus symbol indicates
            that this is created as a new ID.
         ``android:title``
            *String resource*. The menu title as a string resource or
            raw string.
         ``android:titleCondensed``
            *String resource*. A condensed title as a string resource or
            a raw string. This title is used for situations in which the
            normal title is too long.
         ``android:icon``
            *Drawable resource*. An image to be used as the menu item
            icon.
         ``android:onClick``
            *Method name*. The method to call when this menu item is
            clicked. The method must be declared in the activity as
            public. It accepts a
            `MenuItem <#>`__ as its
            only parameter, which indicates the item clicked. This
            method takes precedence over the standard callback to
            `onOptionsItemSelected() <#onOptionsItemSelected>`__.
            See the example at the end of this page.

            **Warning:** If you obfuscate your code using
            `ProGuard <#>`__ or a similar tool, be
            sure to exclude the method you specify in this attribute
            from renaming, because it can break the functionality.

            Introduced in API level 11.

         ``android:showAsAction``
            *Keyword*. When and how this item appears as an action item
            in the app bar. A menu item can appear as an action item
            only when the activity includes an app bar. Valid values:

            .. list-table::
               :widths: 36 36
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - ``ifRoom``
                  - Only place this item in the app bar if there is room
                     for it. If there isn't room for all the items
                     marked ``"ifRoom"``, the items with the lowest
                     ``orderInCategory`` values are displayed as
                     actions, and the remaining items are displayed in
                     the overflow menu.
               - 

                  - ``withText``
                  - Also include the title text (defined by
                     ``android:title``) with the action item. You can
                     include this value along with one of the others as
                     a flag set by separating them with a pipe ``|``.
               - 

                  - ``never``
                  - Never place this item in the app bar. Instead, list
                     the item in the app bar's overflow menu.
               - 

                  - ``always``
                  - Always place this item in the app bar. Avoid using
                     this unless it's critical that the item always
                     appear in the action bar. Setting multiple items to
                     always appear as action items can result in them
                     overlapping with other UI in the app bar.
               - 

                  - ``collapseActionView``
                  - The action view associated with this action item (as
                     declared by ``android:actionLayout`` or
                     ``android:actionViewClass``) is collapsible.
                     Introduced in API level 14.

            See `Add the app bar <#>`__ for more
            information.

            Introduced in API level 11.

         ``android:actionLayout``
            *Layout resource*. A layout to use as the action view.

            For more information, see `Use action views and action providers <#>`__.

            Introduced in API level 11.

         ``android:actionViewClass``
            *Class name*. A fully-qualified class name for the
            `View <#>`__ to use as the
            action view. For example, ``"android.widget.SearchView"`` to
            use
            `SearchView <#>`__ as
            an action view.

            For more information, see `Use action views and action providers <#>`__.

            **Warning:** If you obfuscate your code using
            `ProGuard <#>`__ or a similar tool, be
            sure to exclude the class you specify in this attribute from
            renaming, because it can break the functionality.

            Introduced in API level 11.

         ``android:actionProviderClass``
            *Class name*. A fully qualified class name for the
            `ActionProvider <#>`__
            to use in place of the action item. For example,
            ``"android.widget.ShareActionProvider"`` to use
            `ShareActionProvider <#>`__.

            For more information, see `Use action views and action providers <#>`__.

            **Warning:** If you obfuscate your code using
            `ProGuard <#>`__ or a similar tool, be
            sure to exclude the class you specify in this attribute from
            renaming, because it can break the functionality.

            Introduced in API level 14.

         ``android:alphabeticShortcut``
            *Char*. A character for the alphabetic shortcut key.
         ``android:numericShortcut``
            *Integer*. A number for the numeric shortcut key.
         ``android:alphabeticModifiers``
            *Keyword*. A modifier for the menu item's alphabetic
            shortcut. The default value corresponds to the Control key.
            Valid values:

            .. list-table::
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - ``META``
                  - Corresponds to the Meta meta key.
               - 

                  - CTRL
                  - Corresponds to the Control meta key.
               - 

                  - ALT
                  - Corresponds to the Alt meta key.
               - 

                  - SHIFT
                  - Corresponds to the Shift meta key.
               - 

                  - SYM
                  - Corresponds to the Sym meta key.
               - 

                  - FUNCTION
                  - Corresponds to the Function meta key.

            **Note**: You can specify multiple keywords in an attribute.
            For example, ``android:alphabeticModifiers="CTRL|SHIFT"``
            indicates that to trigger the corresponding menu item, the
            user needs to press both the Control and Shift meta keys
            along with the shortcut.

            You can use the ``setAlphabeticShortcut()`` method to set
            the attribute values programmatically. For more information
            about the ``alphabeticModifier`` attribute, see
            `alphabeticModifiers <#alphabeticModifiers>`__.

         ``android:numericModifiers``
            *Keyword*. A modifier for the menu item's numeric shortcut.
            The default value corresponds to the Control key. Valid
            values:

            .. list-table::
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - META
                  - Corresponds to the Meta meta key.
               - 

                  - CTRL
                  - Corresponds to the Control meta key.
               - 

                  - ALT
                  - Corresponds to the Alt meta key.
               - 

                  - SHIFT
                  - Corresponds to the Shift meta key.
               - 

                  - SYM
                  - Corresponds to the Sym meta key.
               - 

                  - FUNCTION
                  - Corresponds to the Function meta key.

            **Note**: You can specify multiple keywords in an attribute.
            For example, ``android:numericModifiers="CTRL|SHIFT"``
            indicates that to trigger the corresponding menu item, the
            user needs to press both the Control and Shift meta keys
            along with the shortcut.

            You can use the ``setNumericShortcut()`` method to set the
            attribute values programmatically. For more information
            about the ``numericModifier`` attribute, see
            `numericModifiers <#numericModifiers>`__.

         ``android:checkable``
            *Boolean*. True if the item is checkable.
         ``android:checked``
            *Boolean*. True if the item is checked by default.
         ``android:visible``
            *Boolean*. True if the item is visible by default.
         ``android:enabled``
            *Boolean*. True if the item is enabled by default.
         ``android:menuCategory``
            *Keyword*. Value corresponding to the
            `Menu <#>`__ ``CATEGORY_*``
            constants, which define the item's priority. Valid values:

            .. list-table::
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - ``container``
                  - For items that are part of a container.
               - 

                  - ``system``
                  - For items that are provided by the system.
               - 

                  - ``secondary``
                  - For items that are user-supplied secondary
                     (infrequently used) options.
               - 

                  - ``alternative``
                  - For items that are alternative actions on the data
                     that is currently displayed.
         ``android:orderInCategory``
            *Integer*. The order of importance of the item within a
            group.

      ``<group>``
         A menu group, to create a collection of items that share
         traits, such as whether they are visible, enabled, or
         selectable. Contains one or more ``<item>`` elements. Must be a
         child of a ``<menu>`` element.

         Attributes:

         ``android:id``
            *Resource ID*. A unique resource ID. To create a new
            resource ID for this item, use the form:
            ``"@+id/``\ *``name``*\ ``"``. The plus symbol indicates
            that this is created as a new ID.
         ``android:checkableBehavior``
            *Keyword*. The type of selectable behavior for the group.
            Valid values:

            .. list-table::
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - ``none``
                  - Not selectable.
               - 

                  - ``all``
                  - All items can be selected (use checkboxes).
               - 

                  - ``single``
                  - Only one item can be selected (use radio buttons).
         ``android:visible``
            *Boolean*. True if the group is visible.
         ``android:enabled``
            *Boolean*. True if the group is enabled.
         ``android:menuCategory``
            *Keyword*. Value corresponding to the
            `Menu <#>`__ ``CATEGORY_*``
            constants, which define the group's priority. Valid values:

            .. list-table::
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - ``container``
                  - For groups that are part of a container.
               - 

                  - ``system``
                  - For groups that are provided by the system.
               - 

                  - ``secondary``
                  - For groups that are user-supplied secondary
                     (infrequently used) options.
               - 

                  - ``alternative``
                  - For groups that are alternative actions on the data
                     that is currently displayed.
         ``android:orderInCategory``
            *Integer*. The default order of the items within the
            category.

   example:
      XML file saved at ``res/menu/example_menu.xml``:

      .. code:: prettyprint

         <menu xmlns:android="http://schemas.android.com/apk/res/android"
             xmlns:app="http://schemas.android.com/apk/res-auto">
             <item android:id="@+id/item1"
                   android:title="@string/item1"
                   android:icon="@drawable/group_item1_icon"
                   app:showAsAction="ifRoom|withText"/>
             <group android:id="@+id/group">
                 <item android:id="@+id/group_item1"
                       android:onClick="onGroupItemClick"
                       android:title="@string/group_item1"
                       android:icon="@drawable/group_item1_icon" />
                 <item android:id="@+id/group_item2"
                       android:onClick="onGroupItemClick"
                       android:title="@string/group_item2"
                       android:icon="@drawable/group_item2_icon" />
             </group>
             <item android:id="@+id/submenu"
                   android:title="@string/submenu_title"
                   app:showAsAction="ifRoom|withText" >
                 <menu>
                     <item android:id="@+id/submenu_item1"
                           android:title="@string/submenu_item1" />
                 </menu>
             </item>
         </menu>

      The following application code inflates the menu from the
      `onCreateOptionsMenu(Menu) <#onCreateOptionsMenu>`__
      callback and also declares the on-click callback for two of the
      items:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreateOptionsMenu(menu: Menu): Boolean {
                   menuInflater.inflate(R.menu.example_menu, menu)
                   return true
               }

               fun onGroupItemClick(item: MenuItem) {
                   // One of the group items (using the onClick attribute) was clicked.
                   // The item parameter passed here indicates which item it is.
                   // All other menu item clicks are handled by Activity.onOptionsItemSelected.
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public boolean onCreateOptionsMenu(Menu menu) {
                   MenuInflater inflater = getMenuInflater();
                   inflater.inflate(R.menu.example_menu, menu);
                   return true;
               }

               public void onGroupItemClick(MenuItem item) {
                   // One of the group items (using the onClick attribute) was clicked.
                   // The item parameter passed here indicates which item it is.
                   // All other menu item clicks are handled by Activity.onOptionsItemSelected.
               }

.. container:: devsite-steps

Last updated 2024-01-03 UTC.


/String resources
=================

.. container:: devsite-article-body clearfix

   A string resource provides text strings for your application with
   optional text styling and formatting. There are three types of
   resources that can provide your application with strings:

   `String <#String>`__
      XML resource that provides a single string.
   `String Array <#StringArray>`__
      XML resource that provides an array of strings.
   `Quantity Strings (Plurals) <#Plurals>`__
      XML resource that carries different strings for pluralization.

   All strings are capable of applying some styling markup and
   formatting arguments. For information about styling and formatting
   strings, see the section about `Formatting and Styling <#FormattingAndStyling>`__.

   .. rubric:: String
      :name: String

   A single string that can be referenced from the application or from
   other resource files (such as an XML layout).

   **Note:** A string is a simple resource that is referenced using the
   value provided in the ``name`` attribute (not the name of the XML
   file). So, you can combine string resources with other simple
   resources in the one XML file, under one ``<resources>`` element.

   file location:
      ``res/values/``\ *``filename``*\ ``.xml``
      The filename is arbitrary. The ``<string>`` element's ``name`` is
      used as the resource ID.
   compiled resource datatype:
      Resource pointer to a
      `String <#>`__.
   resource reference:
      In Java: ``R.string.``\ *``string_name``*
      In XML:``@string/``\ *``string_name``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <string
                 name="string_name"
                 >text_string</string>
         </resources>

   elements:
      ``<resources>``
         **Required.** This must be the root node.

         No attributes.

      ``<string>``
         A string, which can include styling tags. Beware that you must
         escape apostrophes and quotation marks. For more information
         about how to properly style and format your strings see
         `Formatting and Styling <#FormattingAndStyling>`__, below.

         attributes:

         ``name``
            *String*. A name for the string. This name is used as the
            resource ID.

   example:
      XML file saved at ``res/values/strings.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <string name="hello">Hello!</string>
         </resources>

      This layout XML applies a string to a View:

      .. code:: prettyprint

         <TextView
             android:layout_width="fill_parent"
             android:layout_height="wrap_content"
             android:text="@string/hello" />

      This application code retrieves a string:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val string: String = getString(R.string.hello)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  String string = getString(R.string.hello);

      You can use either
      `getString(int) <#getString>`__
      or
      `getText(int) <#getText>`__
      to retrieve a string.
      `getText(int) <#getText>`__
      retains any rich text styling applied to the string.

   .. rubric:: String array
      :name: StringArray

   An array of strings that can be referenced from the application.

   **Note:** A string array is a simple resource that is referenced
   using the value provided in the ``name`` attribute (not the name of
   the XML file). As such, you can combine string array resources with
   other simple resources in the one XML file, under one ``<resources>``
   element.

   file location:
      ``res/values/``\ *``filename``*\ ``.xml``
      The filename is arbitrary. The ``<string-array>`` element's
      ``name`` is used as the resource ID.
   compiled resource datatype:
      Resource pointer to an array of
      `String <#>`__\ s.
   resource reference:
      In Java: ``R.array.``\ *``string_array_name``*
      In XML:
      ``@[``\ *``package``*\ ``:]array/``\ *``string_array_name``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <string-array
                 name="string_array_name">
                 <item
                     >text_string</item>
             </string-array>
         </resources>

   elements:
      ``<resources>``
         **Required.** This must be the root node.

         No attributes.

      ``<string-array>``
         Defines an array of strings. Contains one or more ``<item>``
         elements.

         attributes:

         ``name``
            *String*. A name for the array. This name is used as the
            resource ID to reference the array.

      ``<item>``
         A string, which can include styling tags. The value can be a
         reference to another string resource. Must be a child of a
         ``<string-array>`` element. Beware that you must escape
         apostrophes and quotation marks. See `Formatting and Styling <#FormattingAndStyling>`__, below, for information
         about to properly style and format your strings.

         No attributes.

   example:
      XML file saved at ``res/values/strings.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <string-array name="planets_array">
                 <item>Mercury</item>
                 <item>Venus</item>
                 <item>Earth</item>
                 <item>Mars</item>
             </string-array>
         </resources>

      This application code retrieves a string array:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val array: Array<String> = resources.getStringArray(R.array.planets_array)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  Resources res = getResources();
                  String[] planets = res.getStringArray(R.array.planets_array);

   .. rubric:: Quantity strings (plurals)
      :name: Plurals

   Different languages have different rules for grammatical agreement
   with quantity. In English, for example, the quantity 1 is a special
   case. We write "1 book", but for any other quantity we'd write "*n*
   books". This distinction between singular and plural is very common,
   but other languages make finer distinctions. The full set supported
   by Android is ``zero``, ``one``, ``two``, ``few``, ``many``, and
   ``other``.

   The rules for deciding which case to use for a given language and
   quantity can be very complex, so Android provides you with methods
   such as
   `getQuantityString() <#getQuantityString>`__
   to select the appropriate resource for you.

   Although historically called "quantity strings" (and still called
   that in API), quantity strings should *only* be used for plurals. It
   would be a mistake to use quantity strings to implement something
   like Gmail's "Inbox" versus "Inbox (12)" when there are unread
   messages, for example. It might seem convenient to use quantity
   strings instead of an ``if`` statement, but it's important to note
   that some languages (such as Chinese) don't make these grammatical
   distinctions at all, so you'll always get the ``other`` string.

   The selection of which string to use is made solely based on
   grammatical *necessity*. In English, a string for ``zero`` is ignored
   even if the quantity is 0, because 0 isn't grammatically different
   from 2, or any other number except 1 ("zero books", "one book", "two
   books", and so on). Conversely, in Korean *only* the ``other`` string
   is ever used.

   Don't be misled either by the fact that, say, ``two`` sounds like it
   could only apply to the quantity 2: a language may require that 2,
   12, 102 (and so on) are all treated like one another but differently
   to other quantities. Rely on your translator to know what
   distinctions their language actually insists upon.

   If your message doesn't contain the quantity number, it is probably
   not a good candidate for a plural. For example, in Lithuanian the
   singular form is used for both 1 and 101, so "1 book" is translated
   as "1 knyga", and "101 books" is translated as "101 knyga". Meanwhile
   "a book" is "knyga" and "many books" is "daug knyg≈≥". If an English
   plural message contains "a book" (singular) and "many books" (plural)
   without the actual number, it can be translated as "knyga" (a
   book)/"daug knyg≈≥" (many books), but with Lithuanian rules, it will
   show "knyga" (a single book), when the number happens to be 101.

   It's often possible to avoid quantity strings by using
   quantity-neutral formulations such as "Books: 1". This makes your
   life and your translators' lives easier, if it's an acceptable style
   for your application.

   On API 24+ you can use the much more powerful ICU
   `MessageFormat <https://developer.android.google.cn/reference/android/icu/text/MessageFormat>`__
   class instead.

   **Note:** A plurals collection is a simple resource that is
   referenced using the value provided in the ``name`` attribute (not
   the name of the XML file). As such, you can combine plurals resources
   with other simple resources in the one XML file, under one
   ``<resources>`` element.

   file location:
      ``res/values/``\ *``filename``*\ ``.xml``
      The filename is arbitrary. The ``<plurals>`` element's ``name`` is
      used as the resource ID.
   resource reference:
      In Java: ``R.plurals.``\ *``plural_name``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <plurals
                 name="plural_name">
                 <item
                     quantity=["zero" | "one" | "two" | "few" | "many" | "other"]
                     >text_string</item>
             </plurals>
         </resources>

   elements:
      ``<resources>``
         **Required.** This must be the root node.

         No attributes.

      ``<plurals>``
         A collection of strings, of which, one string is provided
         depending on the amount of something. Contains one or more
         ``<item>`` elements.

         attributes:

         ``name``
            *String*. A name for the pair of strings. This name is used
            as the resource ID.

      ``<item>``
         A plural or singular string. The value can be a reference to
         another string resource. Must be a child of a ``<plurals>``
         element. Beware that you must escape apostrophes and quotation
         marks. See `Formatting and Styling <#FormattingAndStyling>`__,
         below, for information about to properly style and format your
         strings.

         attributes:

         ``quantity``
            *Keyword*. A value indicating when this string should be
            used. Valid values, with non-exhaustive examples in
            parentheses:

            .. list-table::
               :header-rows: 1

               - 

                  - Value
                  - Description
               - 

                  - ``zero``
                  - When the language requires special treatment of the
                     number 0 (as in Arabic).
               - 

                  - ``one``
                  - When the language requires special treatment of
                     numbers like one (as with the number 1 in English
                     and most other languages; in Russian, any number
                     ending in 1 but not ending in 11 is in this class).
               - 

                  - ``two``
                  - When the language requires special treatment of
                     numbers like two (as with 2 in Welsh, or 102 in
                     Slovenian).
               - 

                  - ``few``
                  - When the language requires special treatment of
                     "small" numbers (as with 2, 3, and 4 in Czech; or
                     numbers ending 2, 3, or 4 but not 12, 13, or 14 in
                     Polish).
               - 

                  - ``many``
                  - When the language requires special treatment of
                     "large" numbers (as with numbers ending 11-99 in
                     Maltese).
               - 

                  - ``other``
                  - When the language does not require special treatment
                     of the given quantity (as with all numbers in
                     Chinese, or 42 in English).

   example:
      XML file saved at ``res/values/strings.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <plurals name="numberOfSongsAvailable">
                 <!--
                      As a developer, you should always supply "one" and "other"
                      strings. Your translators will know which strings are actually
                      needed for their language. Always include %d in "one" because
                      translators will need to use %d for languages where "one"
                      doesn't mean 1 (as explained above).
                   -->
                 <item quantity="one">%d song found.</item>
                 <item quantity="other">%d songs found.</item>
             </plurals>
         </resources>

      XML file saved at ``res/values-pl/strings.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <plurals name="numberOfSongsAvailable">
                 <item quantity="one">Znaleziono %d piosenkƒô.</item>
                 <item quantity="few">Znaleziono %d piosenki.</item>
                 <item quantity="other">Znaleziono %d piosenek.</item>
             </plurals>
         </resources>

      Usage:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val count = getNumberOfSongsAvailable()
                  val songsFound = resources.getQuantityString(R.plurals.numberOfSongsAvailable, count, count)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  int count = getNumberOfSongsAvailable();
                  Resources res = getResources();
                  String songsFound = res.getQuantityString(R.plurals.numberOfSongsAvailable, count, count);

      When using the
      `getQuantityString() <#getQuantityString>`__
      method, you need to pass the ``count`` twice if your string
      includes `string formatting <#FormattingAndStyling>`__ with a
      number. For example, for the string ``%d songs found``, the first
      ``count`` parameter selects the appropriate plural string and the
      second ``count`` parameter is inserted into the ``%d``
      placeholder. If your plural strings do not include string
      formatting, you don't need to pass the third parameter to
      `getQuantityString <#getQuantityString>`__.

   .. rubric:: Format and style
      :name: FormattingAndStyling

   Here are a few important things you should know about how to properly
   format and style your string resources.

   .. rubric:: Handle special characters
      :name: escaping_quotes

   When a string contains characters that have special usage in XML, you
   must escape the characters according to the standard XML/HTML
   escaping rules. If you need to escape a character that has special
   meaning in Android you should use a preceding backslash.

   By default Android will collapse sequences of whitespace characters
   into a single space. You can avoid this by enclosing the relevant
   part of your string in double quotes. In this case all whitespace
   characters (including new lines) will get preserved within the quoted
   region. Double quotes will allow you to use regular single unescaped
   quotes as well.

   .. list-table::
      :widths: 36 36
      :header-rows: 1

      - 

         - Character
         - Escaped form(s)
      - 

         - @
         - ``\@``
      - 

         - ?
         - ``\?``
      - 

         - New line
         - ``\n``
      - 

         - Tab
         - ``\t``
      - 

         - U+XXXX Unicode character
         - ``\uXXXX``
      - 

         - Single quote (``'``)
         - Any of the following:

            -  ``\'``
            -  Enclose the entire string in double quotes
               (``"This'll work"``, for example)
      - 

         - Double quote (``"``)
         - ``\"``
            Note that surrounding the string with single quotes does not
            work.

   Whitespace collapsing and Android escaping happens after your
   resource file gets parsed as XML. This means that
   ``<string> &#32; &#8200; &#8195;</string>`` (space, punctuation
   space, Unicode Em space) all collapse to a single space (``" "``),
   because they are all Unicode spaces after the file is parsed as an
   XML. To preserve those spaces as they are, you can either quote them
   (``<string>" &#32; &#8200; &#8195;"</string>``) or use Android
   escaping (``<string> \u0032 \u8200 \u8195</string>``).

   **Note:** From XML parser's perspective, there is no difference
   between ``<string>"Test this"</string>`` and
   ``<string>&quot;Test this&quot;</string>`` whatsoever. Both forms
   will not show any quotes but trigger Android whitespace-preserving
   quoting (that will have no practical effect in this case).

   .. rubric:: Formatting strings
      :name: formatting-strings

   If you need to format your strings, then you can do so by putting
   your format arguments in the string resource, as demonstrated by the
   following example resource.

   .. code:: prettyprint

      <string name="welcome_messages">Hello, %1$s! You have %2$d new messages.</string>

   In this example, the format string has two arguments: ``%1$s`` is a
   string and ``%2$d`` is a decimal number. Then, format the string by
   calling
   `getString(int, Object...) <#getString>`__.
   For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               var text = getString(R.string.welcome_messages, username, mailCount)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               String text = getString(R.string.welcome_messages, username, mailCount);

   .. rubric:: Styling with HTML markup
      :name: StylingWithHTML

   You can add styling to your strings with HTML markup. For example:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <resources>
          <string name="welcome">Welcome to <b>Android</b>!</string>
      </resources>

   The following HTML elements are supported:

   -  Bold: <b>
   -  Italic: <i>, <cite>, <dfn>, <em>
   -  25% larger text: <big>
   -  20% smaller text: <small>
   -  Setting font properties: <font face=‚Äùfont_family‚Äú
      color=‚Äùhex_color‚Äù>. Examples of possible font families include
      ``monospace``, ``serif``, and ``sans_serif``.
   -  Setting a monospace font family: <tt>
   -  Strikethrough: <s>, <strike>, <del>
   -  Underline: <u>
   -  Superscript: <sup>
   -  Subscript: <sub>
   -  Bullet points: <ul>, <li>
   -  Line breaks: <br>
   -  Division: <div>
   -  CSS style: <span style=‚Äùcolor|background_color|text-decoration‚Äù>
   -  Paragraphs: <p dir=‚Äùrtl \| ltr‚Äù style=‚Äù‚Ä¶‚Äù>

   If you aren't applying formatting, you can set TextView text directly
   by calling
   `setText(java.lang.CharSequence) <#setText>`__.
   In some cases, however, you may want to create a styled text resource
   that is also used as a format string. Normally, this doesn't work
   because the
   `format(String, Object...) <#format>`__
   and
   `getString(int, Object...) <#getString>`__
   methods strip all the style information from the string. The
   work-around to this is to write the HTML tags with escaped entities,
   which are then recovered with
   `fromHtml(String) <#fromHtml>`__,
   after the formatting takes place. For example:

   #. Store your styled text resource as an HTML-escaped string:

      .. code:: prettyprint

         <resources>
           <string name="welcome_messages">Hello, %1$s! You have &lt;b>%2$d new messages&lt;/b>.</string>
         </resources>

      In this formatted string, a ``<b>`` element is added. Notice that
      the opening bracket is HTML-escaped, using the ``&lt;`` notation.

   #. Then format the string as usual, but also call
      `fromHtml(String) <#fromHtml>`__
      to convert the HTML text into styled text:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val text: String = getString(R.string.welcome_messages, username, mailCount)
                  val styledText: Spanned = Html.fromHtml(text, FROM_HTML_MODE_LEGACY)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  String text = getString(R.string.welcome_messages, username, mailCount);
                  Spanned styledText = Html.fromHtml(text, FROM_HTML_MODE_LEGACY);

   Because the
   `fromHtml(String) <#fromHtml>`__
   method formats all HTML entities, be sure to escape any possible HTML
   characters in the strings you use with the formatted text, using
   `htmlEncode(String) <#htmlEncode>`__.
   For instance, if you are formatting a string that contains characters
   such as "<" or "&", then they must be escaped before formatting, so
   that when the formatted string is passed through
   `fromHtml(String) <#fromHtml>`__,
   the characters come out the way they were originally written. For
   example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val escapedUsername: String = TextUtils.htmlEncode(username)

               val text: String = getString(R.string.welcome_messages, escapedUsername, mailCount)
               val styledText: Spanned = Html.fromHtml(text, FROM_HTML_MODE_LEGACY)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               String escapedUsername = TextUtils.htmlEncode(username);

               String text = getString(R.string.welcome_messages, escapedUsername, mailCount);
               Spanned styledText = Html.fromHtml(text);

   .. rubric:: Styling with spannables
      :name: StylingWithSpannables

   A `Spannable <#>`__ is a text
   object that you can style with typeface properties such as color and
   font weight. You use
   `SpannableStringBuilder <#>`__
   to build your text and then apply styles defined in the
   `android.text.style <#>`__
   package to the text.

   You can use the following helper methods to set up much of the work
   of creating spannable text:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               /**
                * Returns a CharSequence that concatenates the specified array of CharSequence
                * objects and then applies a list of zero or more tags to the entire range.
                *
                * @param content an array of character sequences to apply a style to
                * @param tags the styled span objects to apply to the content
                *        such as android.text.style.StyleSpan
                */
               private fun apply(content: Array<out CharSequence>, vararg tags: Any): CharSequence {
                   return SpannableStringBuilder().apply {
                       openTags(tags)
                       content.forEach { charSequence ->
                           append(charSequence)
                       }
                       closeTags(tags)
                   }
               }

               /**
                * Iterates over an array of tags and applies them to the beginning of the specified
                * Spannable object so that future text appended to the text will have the styling
                * applied to it. Do not call this method directly.
                */
               private fun Spannable.openTags(tags: Array<out Any>) {
                   tags.forEach { tag ->
                       setSpan(tag, 0, 0, Spannable.SPAN_MARK_MARK)
                   }
               }

               /**
                * "Closes" the specified tags on a Spannable by updating the spans to be
                * endpoint-exclusive so that future text appended to the end will not take
                * on the same styling. Do not call this method directly.
                */
               private fun Spannable.closeTags(tags: Array<out Any>) {
                   tags.forEach { tag ->
                   if (length > 0) {
                           setSpan(tag, 0, length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                       } else {
                           removeSpan(tag)
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               /**
                * Returns a CharSequence that concatenates the specified array of CharSequence
                * objects and then applies a list of zero or more tags to the entire range.
                *
                * @param content an array of character sequences to apply a style to
                * @param tags the styled span objects to apply to the content
                *        such as android.text.style.StyleSpan
                *
                */
               private static CharSequence applyStyles(CharSequence[] content, Object[] tags) {
                   SpannableStringBuilder text = new SpannableStringBuilder();
                   openTags(text, tags);
                   for (CharSequence item : content) {
                       text.append(item);
                   }
                   closeTags(text, tags);
                   return text;
               }

               /**
                * Iterates over an array of tags and applies them to the beginning of the specified
                * Spannable object so that future text appended to the text will have the styling
                * applied to it. Do not call this method directly.
                */
               private static void openTags(Spannable text, Object[] tags) {
                   for (Object tag : tags) {
                       text.setSpan(tag, 0, 0, Spannable.SPAN_MARK_MARK);
                   }
               }

               /**
                * "Closes" the specified tags on a Spannable by updating the spans to be
                * endpoint-exclusive so that future text appended to the end will not take
                * on the same styling. Do not call this method directly.
                */
               private static void closeTags(Spannable text, Object[] tags) {
                   int len = text.length();
                   for (Object tag : tags) {
                       if (len > 0) {
                           text.setSpan(tag, 0, len, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                       } else {
                           text.removeSpan(tag);
                       }
                   }
               }

   The following ``bold``, ``italic``, and ``color`` methods wrap the
   helper methods above and demonstrate specific examples of applying
   styles defined in the
   `android.text.style <#>`__
   package. You can create similar methods to do other types of text
   styling.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               /**
                * Returns a CharSequence that applies boldface to the concatenation
                * of the specified CharSequence objects.
                */
               fun bold(vararg content: CharSequence): CharSequence = apply(content, StyleSpan(Typeface.BOLD))

               /**
                * Returns a CharSequence that applies italics to the concatenation
                * of the specified CharSequence objects.
                */
               fun italic(vararg content: CharSequence): CharSequence = apply(content, StyleSpan(Typeface.ITALIC))

               /**
                * Returns a CharSequence that applies a foreground color to the
                * concatenation of the specified CharSequence objects.
                */
               fun color(color: Int, vararg content: CharSequence): CharSequence =
                       apply(content, ForegroundColorSpan(color))

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               /**
                * Returns a CharSequence that applies boldface to the concatenation
                * of the specified CharSequence objects.
                */
               public static CharSequence bold(CharSequence... content) {
                   return apply(content, new StyleSpan(Typeface.BOLD));
               }

               /**
                * Returns a CharSequence that applies italics to the concatenation
                * of the specified CharSequence objects.
                */
               public static CharSequence italic(CharSequence... content) {
                   return apply(content, new StyleSpan(Typeface.ITALIC));
               }

               /**
                * Returns a CharSequence that applies a foreground color to the
                * concatenation of the specified CharSequence objects.
                */
               public static CharSequence color(int color, CharSequence... content) {
                   return apply(content, new ForegroundColorSpan(color));
               }

   Here's an example of how to chain these methods together to apply
   various styles to individual words within a phrase:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Create an italic "hello, " a red "world",
               // and bold the entire sequence.
               val text: CharSequence = bold(italic(getString(R.string.hello)),
                       color(Color.RED, getString(R.string.world)))

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create an italic "hello, " a red "world",
               // and bold the entire sequence.
               CharSequence text = bold(italic(getString(R.string.hello)),
                   color(Color.RED, getString(R.string.world)));

   The core-ktx Kotlin module also contains extension functions that
   make working with spans even easier. You can check out the
   `android.text <http://www.google.com/url?sa=D&q=https%3A%2F%2Fandroid.github.io%2Fandroid-ktx%2Fcore-ktx%2Fandroidx.text%2Findex.html>`__
   package documentation on GitHub to learn more.

   For more information on working with spans, see the following links:

   -  `Spantastic text styling with Spans <https://medium.com/google-developers/spantastic-text-styling-with-spans-17b0c16b4568>`__
   -  `Understanding spans <https://medium.com/google-developers/underspanding-spans-1b91008b97e4>`__

   .. rubric:: Styling with annotations
      :name: StylingWithAnnotations

   You can apply complex or custom styling by using the
   `Annotation <#>`__ class along
   with the ``<annotation>`` tag in your strings.xml resource files. The
   annotation tag allows you to mark parts of the string for custom
   styling by defining custom key-value pairs in the XML that the
   framework then converts into ``Annotation`` spans. You can then
   retrieve these annotations and use the key and value to apply the
   styling.

   When creating annotations, make sure you add the ``<annotation>`` tag
   to all translations of the string in every strings.xml file.

   .. image:: https://developer.android.google.cn/static/guide/topics/resources/images/annotation-example-1.png
   *Applying a custom typeface to the word ‚Äútext‚Äù in all languages*

   .. rubric:: Example - adding a custom typeface
      :name: example---adding-a-custom-typeface

   #. Add the ``<annotation>`` tag, and define the key-value pair. In
      this case, the key is *font*, and the value is the type of font we
      want to use: *title_emphasis*

      .. code:: prettyprint

         // values/strings.xml
         <string name="title">Best practices for <annotation font="title_emphasis">text</annotation> on Android</string>

         // values-es/strings.xml
         <string name="title"><annotation font="title_emphasis">Texto</annotation> en Android: mejores pr√°cticas</string>

   #. Load the string resource and find the annotations with the *font*
      key. Then create a custom span and replace the existing span.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  // get the text as SpannedString so we can get the spans attached to the text
                  val titleText = getText(R.string.title) as SpannedString

                  // get all the annotation spans from the text
                  val annotations = titleText.getSpans(0, titleText.length, Annotation::class.java)

                  // create a copy of the title text as a SpannableString.
                  // the constructor copies both the text and the spans. so we can add and remove spans
                  val spannableString = SpannableString(titleText)

                  // iterate through all the annotation spans
                  for (annotation in annotations) {
                     // look for the span with the key font
                     if (annotation.key == "font") {
                        val fontName = annotation.value
                        // check the value associated to the annotation key
                        if (fontName == "title_emphasis") {
                           // create the typeface
                           val typeface = getFontCompat(R.font.permanent_marker)
                           // set the span at the same indices as the annotation
                           spannableString.setSpan(CustomTypefaceSpan(typeface),
                              titleText.getSpanStart(annotation),
                              titleText.getSpanEnd(annotation),
                              Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
                        }
                     }
                  }

                  // now, the spannableString contains both the annotation spans and the CustomTypefaceSpan
                  styledText.text = spannableString

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  // get the text as SpannedString so we can get the spans attached to the text
                  SpannedString titleText = (SpannedString) getText(R.string.title);

                  // get all the annotation spans from the text
                  Annotation[] annotations = titleText.getSpans(0, titleText.length(), Annotation.class);

                  // create a copy of the title text as a SpannableString.
                  // the constructor copies both the text and the spans. so we can add and remove spans
                  SpannableString spannableString = new SpannableString(titleText);

                  // iterate through all the annotation spans
                  for (Annotation annotation: annotations) {
                    // look for the span with the key font
                    if (annotation.getKey().equals("font")) {
                      String fontName = annotation.getValue();
                      // check the value associated to the annotation key
                      if (fontName.equals("title_emphasis")) {
                      // create the typeface
                      Typeface typeface = ResourcesCompat.getFont(this, R.font.roboto_mono);
                      // set the span at the same indices as the annotation
                      spannableString.setSpan(new CustomTypefaceSpan(typeface),
                        titleText.getSpanStart(annotation),
                        titleText.getSpanEnd(annotation),
                        Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                      }
                    }
                  }

                  // now, the spannableString contains both the annotation spans and the CustomTypefaceSpan
                  styledText.text = spannableString;

   If you‚Äôre using the same text multiple times, you should construct
   the SpannableString object once and reuse it as needed to avoid
   potential performance and memory issues.

   For more examples of annotation usage, see `Styling internationalized text in Android <http://www.google.com/url?sa=D&q=https%3A%2F%2Fmedium.com%2Fgoogle-developers%2Fstyling-internationalized-text-in-android-f99759fb7b8f>`__

   .. rubric:: Annotation spans and text parceling
      :name: annotation-spans-and-text-parceling

   Because ``Annotation`` spans are also ``ParcelableSpans``, the
   key-value pairs are parceled and unparceled. As long as the receiver
   of the parcel knows how to interpret the annotations, you can use
   ``Annotation`` spans to apply custom styling to the parceled text.

   To keep your custom styling when you pass the text to an Intent
   Bundle, you first need to add ``Annotation`` spans to your text. You
   can do this in the XML resources via the <annotation> tag, as shown
   in the example above, or in code by creating a new ``Annotation`` and
   setting it as a span, as shown below:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val spannableString = SpannableString("My spantastic text")
               val annotation = Annotation("font", "title_emphasis")
               spannableString.setSpan(annotation, 3, 7, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)

               // start Activity with text with spans
               val intent = Intent(this, MainActivity::class.java)
               intent.putExtra(TEXT_EXTRA, spannableString)
               startActivity(intent)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               SpannableString spannableString = new SpannableString("My spantastic text");
               Annotation annotation = new Annotation("font", "title_emphasis");
               spannableString.setSpan(annotation, 3, 7, 33);

               // start Activity with text with spans
               Intent intent = new Intent(this, MainActivity.class);
               intent.putExtra(TEXT_EXTRA, spannableString);
               this.startActivity(intent);

   Retrieve the text from the ``Bundle`` as a ``SpannableString`` and
   then parse the annotations attached, as shown in the example above.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // read text with Spans
               val intentCharSequence = intent.getCharSequenceExtra(TEXT_EXTRA) as SpannableString

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // read text with Spans
               SpannableString intentCharSequence = (SpannableString)intent.getCharSequenceExtra(TEXT_EXTRA);

   For more information on text styling, see the following links:

   -  `Google I/O 2018 talk - Best practices for text on Android <https://www.youtube.com/watch?v=x-FcOX6ErdI&t=847s>`__
   -  `Understanding spans <https://medium.com/google-developers/underspanding-spans-1b91008b97e4>`__

.. container:: devsite-steps

Last updated 2024-01-03 UTC.


/Style resource
===============

.. container:: devsite-article-body clearfix

   A style resource defines the format and look for a UI. A style can be
   applied to an individual `View <#>`__
   (from within a layout file) or to an entire
   `Activity <#>`__ or application
   (from within the manifest file).

   For more information about creating and applying styles, please read
   `Styles and Themes <#>`__.

   **Note:** A style is a simple resource that is referenced using the
   value provided in the ``name`` attribute (not the name of the XML
   file). As such, you can combine style resources with other simple
   resources in the one XML file, under one ``<resources>`` element.

   file location:
      ``res/values/``\ *``filename``*\ ``.xml``
      The filename is arbitrary. The element's ``name`` will be used as
      the resource ID.
   resource reference:
      In XML: ``@[package:]style/``\ *``style_name``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <style
                 name="style_name"
                 parent="@[package:]style/style_to_inherit">
                 <item
                     name="[package:]style_property_name"
                     >style_value</item>
             </style>
         </resources>

   elements:
      ``<resources>``
         **Required.** This must be the root node.

         No attributes.

      ``<style>``
         Defines a single style. Contains ``<item>`` elements.

         attributes:

         ``name``
            *String*. **Required**. A name for the style, which is used
            as the resource ID to apply the style to a View, Activity,
            or application.
         ``parent``
            *Style resource*. Reference to a style from which this style
            should inherit style properties.

      ``<item>``
         Defines a single property for the style. Must be a child of a
         ``<style>`` element.

         attributes:

         ``name``
            *Attribute resource*. **Required**. The name of the style
            property to be defined, with a package prefix if necessary
            (for example ``android:textColor``).

   example:
      XML file for the style (saved in ``res/values/``):
         .. code:: prettyprint

            <?xml version="1.0" encoding="utf-8"?>
            <resources>
                <style name="CustomText" parent="@style/Text">
                    <item name="android:textSize">20sp</item>
                    <item name="android:textColor">#008</item>
                </style>
            </resources>

      XML file that applies the style to a `TextView <#>`__ (saved in ``res/layout/``):
         .. code:: prettyprint

            <?xml version="1.0" encoding="utf-8"?>
            <EditText
                style="@style/CustomText"
                android:layout_width="fill_parent"
                android:layout_height="wrap_content"
                android:text="Hello, World!" />

.. container:: devsite-steps

Last updated 2019-12-27 UTC.


/Font resources
===============

.. container:: devsite-article-body clearfix

   A font resource defines a custom font that you can use in your app.
   Fonts can be individual font files or a collection of font files,
   known as a font family and defined in XML.

   Also see how to define `fonts in XML <#>`__ or instead use
   `Downloadable Fonts <#>`__.

   .. rubric:: Bundled font
      :name: bundled-font

   You can bundle fonts as resources in an app. Fonts are compiled in
   the ``R`` file and are automatically available in the system as a
   resource. You can then access these fonts with the help of the
   ``font`` resource type.

   file location:
      ``res/font/``\ *``filename``*\ ``.ttf`` (``.ttf``, ``.ttc``,
      ``.otf``, or ``.xml``)
      The filename is used as the resource ID.
   resource reference:
      In XML: ``@[package:]font/``\ *``font_name``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <font-family>
           <font
             android:font="@[package:]font/font_to_include"
             android:fontStyle=["normal" | "italic"]
             android:fontWeight="weight_value" />
         </font-family>

   elements:
      ``<font-family>``
         **Required.** This must be the root node.

         No attributes.

      ``<font>``
         Defines a single font within a family. Contains no child nodes.

         Attributes:

         ``android:fontStyle``
            *Keyword*. Defines the font style. This attribute is used
            when the font is loaded into the font stack and overrides
            any style information in the font's header tables. If you
            don't specify the attribute, the app uses the value from the
            font's header tables. The constant value is either
            ``normal`` or ``italic``.
         ``android:fontWeight``
            *Integer*. The weight of the font. This attribute is used
            when the font is loaded into the font stack and overrides
            any weight information in the font's header tables. The
            attribute value must be a multiple of 100 between 100 and
            900, inclusive. If you don't specify the attribute, the app
            uses the value from the font's header tables. The most
            common values are 400 for regular weight and 700 for bold
            weight.

   example:
      XML file saved at ``res/font/lobster.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <font-family xmlns:android="http://schemas.android.com/apk/res/android">
             <font
                 android:fontStyle="normal"
                 android:fontWeight="400"
                 android:font="@font/lobster_regular" />
             <font
                 android:fontStyle="italic"
                 android:fontWeight="400"
                 android:font="@font/lobster_italic" />
         </font-family>

      XML file saved in ``res/layout/`` that applies the font to a
      `TextView <#>`__:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <EditText
             android:fontFamily="@font/lobster"
             android:layout_width="fill_parent"
             android:layout_height="wrap_content"
             android:text="Hello, World!" />

   .. rubric:: Downloadable font
      :name: downloadable-font

   A downloadable font resource defines a custom font that you can use
   in an app. This font isn't available in the app itself. Instead, the
   font is retrieved from a font provider.

   file location:
      ``res/font/``\ *``filename``*\ ``.xml`` The filename is the
      resource ID.
   resource reference:
      In XML:``@[package:]font/``\ *``font_name``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <font-family
             android:fontProviderAuthority="authority"
             android:fontProviderPackage="package"
             android:fontProviderQuery="query"
             android:fontProviderCerts="@[package:]array/array_resource" />

   elements:
      ``<font-family>``
         **Required.** This must be the root node.

         attributes:

         ``android:fontProviderAuthority``
            *String*. **Required**. The authority of the font provider
            that defines the font request.
         ``android:fontProviderPackage``
            *String*. **Required**. The package name of the font
            provider to be used for the request. This is used to verify
            the identity of the provider.
         ``android:fontProviderQuery``
            *String*. **Required**. The string query of the font. Refer
            to your font provider's documentation on the format of this
            string.
         ``android:fontProviderCerts``
            *Array resource*. **Required**. Defines the sets of hashes
            for the certificates used to sign this provider. This is
            used to verify the identity of the provider and is only
            required if the provider isn't part of the system image. The
            value can point to a single list (a string array resource)
            or a list of lists (an array resource), where each
            individual list represents one collection of signature
            hashes. Refer to your font provider's documentation for
            these values.

   example:
      XML file saved at ``res/font/lobster.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <font-family xmlns:android="http://schemas.android.com/apk/res/android"
             android:fontProviderAuthority="com.example.fontprovider.authority"
             android:fontProviderPackage="com.example.fontprovider"
             android:fontProviderQuery="Lobster"
             android:fontProviderCerts="@array/certs">
         </font-family>

      XML file saved in ``res/values/`` that defines the cert array:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <string-array name="certs">
               <item>MIIEqDCCA5CgAwIBAgIJA071MA0GCSqGSIb3DQEBBAUAMIGUMQsww...</item>
             </string-array>
         </resources>

      XML file saved in ``res/layout/`` that applies the font to a
      `TextView <#>`__:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <EditText
             android:fontFamily="@font/lobster"
             android:layout_width="fill_parent"
             android:layout_height="wrap_content"
             android:text="Hello, World!" />

.. container:: devsite-steps

Last updated 2023-05-04 UTC.


/More resource types
====================

.. container:: devsite-article-body clearfix

   This page defines the following types of resources that you can
   externalize:

   `Bool <#Bool>`__
      XML resource that carries a boolean value.
   `Color <#Color>`__
      XML resource that carries a color value (a hexadecimal color).
   `Dimension <#Dimension>`__
      XML resource that carries a dimension value (with a unit of
      measure).
   `ID <#Id>`__
      XML resource that provides a unique identifier for application
      resources and components.
   `Integer <#Integer>`__
      XML resource that carries an integer value.
   `Integer array <#IntegerArray>`__
      XML resource that provides an array of integers.
   `Typed array <#TypedArray>`__
      XML resource that provides a
      `TypedArray <#>`__
      (which you can use for an array of drawables).

   .. rubric:: Bool
      :name: Bool

   A boolean value defined in XML.

   **Note:** A bool is a simple resource that is referenced using the
   value provided in the ``name`` attribute, not the name of the XML
   file. As such, you can combine bool resources with other simple
   resources in one XML file, under one ``<resources>`` element.

   file location:
      ``res/values/``\ *``filename``*\ ``.xml``
      The filename is arbitrary. The ``<bool>`` element's ``name`` is
      used as the resource ID.
   resource reference:
      In Java: ``R.bool.``\ *``bool_name``*
      In XML: ``@[``\ *``package``*\ ``:]bool/``\ *``bool_name``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <bool
                 name="bool_name"
                 >[true | false]</bool>
         </resources>

   elements:
      ``<resources>``
         **Required.** This is the root node.

         No attributes.

      ``<bool>``
         A boolean value: ``true`` or ``false``.

         Attributes:

         ``name``
            *String*. A name for the bool value. This is used as the
            resource ID.

   example:
      XML file saved at ``res/values-small/bools.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <bool name="screen_small">true</bool>
             <bool name="adjust_view_bounds">true</bool>
         </resources>

      The following application code retrieves the boolean:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val screenIsSmall: Boolean = resources.getBoolean(R.bool.screen_small)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Resources res = getResources();
               boolean screenIsSmall = res.getBoolean(R.bool.screen_small);

      The following layout XML uses the boolean for an attribute:

      .. code:: prettyprint

         <ImageView
             android:layout_height="fill_parent"
             android:layout_width="fill_parent"
             android:src="@drawable/logo"
             android:adjustViewBounds="@bool/adjust_view_bounds" />

   .. rubric:: Color
      :name: Color

   A color value defined in XML. The color is specified using an RGB
   value and alpha channel. You can use a color resource any place that
   accepts a hexadecimal color value. You can also use a color resource
   when a drawable resource is expected in XML, such as
   ``android:drawable="@color/green"``.

   The value always begins with a pound (#) character, which is followed
   by the Alpha-Red-Green-Blue information in one of the following
   formats:

   -  #\ *RGB*
   -  #\ *ARGB*
   -  #\ *RRGGBB*
   -  #\ *AARRGGBB*

   **Note:** A color is a simple resource that is referenced using the
   value provided in the ``name`` attribute, not the name of the XML
   file. As such, you can combine color resources with other simple
   resources in one XML file, under one ``<resources>`` element.

   file location:
      ``res/values/colors.xml``
      The filename is arbitrary. The ``<color>`` element's ``name`` is
      used as the resource ID.
   resource reference:
      In Java: ``R.color.``\ *``color_name``*
      In XML: ``@[``\ *``package``*\ ``:]color/``\ *``color_name``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <color
                 name="color_name"
                 >hex_color</color>
         </resources>

   elements:
      ``<resources>``
         **Required.** This is the root node.

         No attributes.

      ``<color>``
         A color expressed in hexadecimal.

         Attributes:

         ``name``
            *String*. A name for the color. This is used as the resource
            ID.

   example:
      XML file saved at ``res/values/colors.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
            <color name="opaque_red">#f00</color>
            <color name="translucent_red">#80ff0000</color>
         </resources>

      The following application code retrieves the color resource:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val color: Int = resources.getColor(R.color.opaque_red)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Resources res = getResources();
               int color = res.getColor(R.color.opaque_red);

      The following layout XML applies the color to an attribute:

      .. code:: prettyprint

         <TextView
             android:layout_width="fill_parent"
             android:layout_height="wrap_content"
             android:textColor="@color/translucent_red"
             android:text="Hello"/>

   .. rubric:: Dimension
      :name: Dimension

   A dimension value defined in XML. A dimension is specified with a
   number followed by a unit of measure, such as 10px, 2in, or 5sp. The
   following units of measure are supported by Android:

   ``dp``
      Density-independent pixels: an abstract unit that is based on the
      physical density of the screen. These units are relative to a 160
      dpi (dots per inch) screen, on which 1 dp is roughly equal to
      1 px. When running on a higher density screen, the number of
      pixels used to draw 1 dp is scaled up by a factor appropriate for
      the screen's dpi.

      Likewise, when on a lower-density screen, the number of pixels
      used for 1 dp is scaled down. The ratio of dps to pixels changes
      with the screen density, but not necessarily in direct proportion.
      Using dp units instead of px units is a solution to making the
      view dimensions in your layout resize properly for different
      screen densities. It provides consistency for the real-world sizes
      of your UI elements across different devices.

   ``sp``
      Scale-independent Pixels - This is like the dp unit, but it is
      also scaled by the user's font size preference. It is recommend
      you use this unit when specifying font sizes, so they will be
      adjusted for both the screen density and the user's preference.
   ``pt``
      Points: 1/72 of an inch based on the physical size of the screen,
      assuming a 72 dpi density screen.
   ``px``
      Pixels: corresponds to actual pixels on the screen. We don't
      recommend using this unit, because the actual representation can
      vary across devices. Different devices can have a different number
      of pixels per inch and might have more or fewer total pixels
      available on the screen.
   ``mm``
      Millimeters: based on the physical size of the screen.
   ``in``
      Inches: based on the physical size of the screen.

   **Note:** A dimension is a simple resource that is referenced using
   the value provided in the ``name`` attribute, not the name of the XML
   file. As such, you can combine dimension resources with other simple
   resources in one XML file, under one ``<resources>`` element.

   file location:
      ``res/values/``\ *``filename``*\ ``.xml``
      The filename is arbitrary. The ``<dimen>`` element's ``name`` is
      used as the resource ID.
   resource reference:
      In Java: ``R.dimen.``\ *``dimension_name``*
      In XML: ``@[``\ *``package``*\ ``:]dimen/``\ *``dimension_name``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <dimen
                 name="dimension_name"
                 >dimension</dimen>
         </resources>

   elements:
      ``<resources>``
         **Required.** This is the root node.

         No attributes.

      ``<dimen>``
         A dimension, represented by a float followed by a unit of
         measurement (dp, sp, pt, px, mm, in).

         Attributes:

         ``name``
            *String*. A name for the dimension. This is used as the
            resource ID.

   example:
      XML file saved at ``res/values/dimens.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <dimen name="textview_height">25dp</dimen>
             <dimen name="textview_width">150dp</dimen>
             <dimen name="ball_radius">30dp</dimen>
             <dimen name="font_size">16sp</dimen>
         </resources>

      The following application code retrieves a dimension:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val fontSize: Float = resources.getDimension(R.dimen.font_size)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Resources res = getResources();
               float fontSize = res.getDimension(R.dimen.font_size);

      The following layout XML applies dimensions to attributes:

      .. code:: prettyprint

         <TextView
             android:layout_height="@dimen/textview_height"
             android:layout_width="@dimen/textview_width"
             android:textSize="@dimen/font_size"/>

   .. rubric:: ID
      :name: Id

   A unique resource ID defined in XML. Using the name you provide in
   the ``<item>`` element, the Android developer tools create a unique
   integer in your project's ``R.java`` class, which you can use as an
   identifier for an application resources, such as a
   `View <#>`__ in your UI layout, or a
   unique integer for use in your application code, such as an ID for a
   dialog or a result code.

   **Note:** An ID is a simple resource that is referenced using the
   value provided in the ``name`` attribute, not the name of the XML
   file. As such, you can combine ID resources with other simple
   resources in one XML file, under one ``<resources>`` element. Also,
   an ID resource doesn't reference an actual resource item: it is a
   unique ID that you can attach to other resources or use as a unique
   integer in your application.

   file location:
      ``res/values/``\ *``filename.xml``*
      The filename is arbitrary.
   resource reference:
      In Java: ``R.id.``\ *``name``*
      In XML: ``@[``\ *``package``*\ ``:]id/``\ *``name``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <item
                 type="id"
                 name="id_name" />
         </resources>

   elements:
      ``<resources>``
         **Required.** This is the root node.

         No attributes.

      ``<item>``
         Defines a unique ID. Takes no value, only attributes.

         Attributes:

         ``type``
            Must be ``"id"``.
         ``name``
            *String*. A unique name for the ID.

   example:
      XML file saved at ``res/values/ids.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <item type="id" name="button_ok" />
             <item type="id" name="dialog_exit" />
         </resources>

      The following layout snippet uses the ``"button_ok"`` ID for a
      ``Button`` widget:

      .. code:: prettyprint

         <Button android:id="@id/button_ok"
             style="@style/button_style" />

      The ``android:id`` value here doesn't include the plus sign in the
      ID reference, because the ID already exists, as defined in the
      preceding ``ids.xml`` example. When you specify an ID to an XML
      resource using the plus sign, in the format
      ``android:id="@+id/name"``, that means that the ``"name"`` ID
      doesn't yet exist, and it is created.

      As another example, the following code snippet uses the
      ``"dialog_exit"`` ID as a unique identifier for a dialog:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               showDialog(R.id.dialog_exit)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               showDialog(R.id.dialog_exit);

      In the same application, the ``"dialog_exit"`` ID is compared when
      creating a dialog:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreateDialog(id: Int): Dialog? {
                   return when(id) {
                       R.id.dialog_exit -> {
                           ...
                       }
                       else -> {
                           null
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               protected Dialog onCreateDialog(int id) {
                   Dialog dialog;
                   switch(id) {
                   case R.id.dialog_exit:
                       ...
                       break;
                   default:
                       dialog = null;
                   }
                   return dialog;
               }

   .. rubric:: Integer
      :name: Integer

   An integer defined in XML.

   **Note:** An integer is a simple resource that is referenced using
   the value provided in the ``name`` attribute, not the name of the XML
   file. As such, you can combine integer resources with other simple
   resources in one XML file, under one ``<resources>`` element.

   file location:
      ``res/values/``\ *``filename.xml``*
      The filename is arbitrary. The ``<integer>`` element's ``name`` is
      used as the resource ID.
   resource reference:
      In Java: ``R.integer.``\ *``integer_name``*
      In XML: ``@[``\ *``package``*\ ``:]integer/``\ *``integer_name``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <integer
                 name="integer_name"
                 >integer</integer>
         </resources>

   elements:
      ``<resources>``
         **Required.** This is the root node.

         No attributes.

      ``<integer>``
         An integer.

         Attributes:

         ``name``
            *String*. A name for the integer. This is used as the
            resource ID.

   example:
      XML file saved at ``res/values/integers.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <integer name="max_speed">75</integer>
             <integer name="min_speed">5</integer>
         </resources>

      The following application code retrieves an integer:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val maxSpeed: Int = resources.getInteger(R.integer.max_speed)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Resources res = getResources();
               int maxSpeed = res.getInteger(R.integer.max_speed);

   .. rubric:: Integer array
      :name: IntegerArray

   An array of integers defined in XML.

   **Note:** An integer array is a simple resource that is referenced
   using the value provided in the ``name`` attribute, not the name of
   the XML file. As such, you can combine integer array resources with
   other simple resources in one XML file, under one ``<resources>``
   element.

   file location:
      ``res/values/``\ *``filename``*\ ``.xml``
      The filename is arbitrary. The ``<integer-array>`` element's
      ``name`` is used as the resource ID.
   compiled resource datatype:
      Resource pointer to an array of integers.
   resource reference:
      In Java: ``R.array.``\ *``integer_array_name``*
      In XML:
      ``@[``\ *``package``*\ ``:]array/``\ *``integer_array_name``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <integer-array
                 name="integer_array_name">
                 <item
                     >integer</item>
             </integer-array>
         </resources>

   elements:
      ``<resources>``
         **Required.** This is the root node.

         No attributes.

      ``<integer-array>``
         Defines an array of integers. Contains one or more child
         ``<item>`` elements.

         Attributes:

         ``android:name``
            *String*. A name for the array. This name is used as the
            resource ID to reference the array.

      ``<item>``
         An integer. The value can be a reference to another integer
         resource. Must be a child of an ``<integer-array>`` element.

         No attributes.

   example:
      XML file saved at ``res/values/integers.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <integer-array name="bits">
                 <item>4</item>
                 <item>8</item>
                 <item>16</item>
                 <item>32</item>
             </integer-array>
         </resources>

      The following application code retrieves the integer array:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val bits: IntArray = resources.getIntArray(R.array.bits)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Resources res = getResources();
               int[] bits = res.getIntArray(R.array.bits);

   .. rubric:: Typed array
      :name: TypedArray

   A `TypedArray <#>`__
   defined in XML. You can use this to create an array of other
   resources, such as drawables. The array isn't required to be
   homogeneous, so you can create an array of mixed resource types, but
   be aware of what and where the data types are in the array so that
   you can properly obtain each item with the ``TypedArray`` class's
   ``get...()`` methods.

   **Note:** A typed array is a simple resource that is referenced using
   the value provided in the ``name`` attribute, not the name of the XML
   file. As such, you can combine typed array resources with other
   simple resources in one XML file, under one ``<resources>`` element.

   file location:
      ``res/values/``\ *``filename``*\ ``.xml``
      The filename is arbitrary. The ``<array>`` element's ``name`` is
      used as the resource ID.
   compiled resource datatype:
      Resource pointer to a
      `TypedArray <#>`__.
   resource reference:
      In Java: ``R.array.``\ *``array_name``*
      In XML: ``@[``\ *``package``*\ ``:]array/``\ *``array_name``*
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <array
                 name="integer_array_name">
                 <item>resource</item>
             </array>
         </resources>

   elements:
      ``<resources>``
         **Required.** This is the root node.

         No attributes.

      ``<array>``
         Defines an array. Contains one or more child ``<item>``
         elements.

         Attributes:

         ``android:name``
            *String*. A name for the array. This name is used as the
            resource ID to reference the array.

      ``<item>``
         A generic resource. The value can be a reference to a resource
         or a simple data type. Must be a child of an ``<array>``
         element.

         No attributes.

   example:
      XML file saved at ``res/values/arrays.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <array name="icons">
                 <item>@drawable/home</item>
                 <item>@drawable/settings</item>
                 <item>@drawable/logout</item>
             </array>
             <array name="colors">
                 <item>#FFFF0000</item>
                 <item>#FF00FF00</item>
                 <item>#FF0000FF</item>
             </array>
         </resources>

      The following application code retrieves each array and then
      obtains the first entry in each array:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val icons: TypedArray = resources.obtainTypedArray(R.array.icons)
               val drawable: Drawable = icons.getDrawable(0)

               val colors: TypedArray = resources.obtainTypedArray(R.array.colors)
               val color: Int = colors.getColor(0,0)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Resources res = getResources();
               TypedArray icons = res.obtainTypedArray(R.array.icons);
               Drawable drawable = icons.getDrawable(0);

               TypedArray colors = res.obtainTypedArray(R.array.colors);
               int color = colors.getColor(0,0);

.. container:: devsite-steps

Last updated 2024-01-03 UTC.


/üíõ App manifest file
========================

/Overview: App manifest overview
================================

.. container:: devsite-article-body clearfix

   Every app project must have an ``AndroidManifest.xml`` file, with
   precisely that name, at the root of the `project source set <#sourcesets>`__. The manifest file describes
   essential information about your app to the Android build tools, the
   Android operating system, and Google Play.

   Among many other things, the manifest file is required to declare the
   following:

   -  The components of the app, including all activities, services,
      broadcast receivers, and content providers. Each component must
      define basic properties, such as the name of its Kotlin or Java
      class. It can also declare capabilities, such as which device
      configurations it can handle, and intent filters that describe how
      the component can be started. `Read more about app components <#components>`__ in a following section.
   -  The permissions that the app needs in order to access protected
      parts of the system or other apps. It also declares any
      permissions that other apps must have if they want to access
      content from this app. `Read more about permissions <#perms>`__ in
      a following section.
   -  The hardware and software features the app requires, which affects
      which devices can install the app from Google Play. `Read more about device compatibility <#compatibility>`__ in a following
      section.

   If you're using `Android Studio <#>`__ to build your app, the
   manifest file is created for you and most of the essential manifest
   elements are added as you build your app, especially when using `code templates <#>`__.

   .. rubric:: File features
      :name: filef

   The following sections describe how some of the most important
   characteristics of your app are reflected in the manifest file.

   .. rubric:: App components
      :name: components

   For each `app component <#Components>`__ that you
   create in your app, declare a corresponding XML element in the
   manifest file:

   -  ``<activity>`` for
      each subclass of
      `Activity <#>`__
   -  ``<service>`` for
      each subclass of `Service <#>`__
   -  ``<receiver>`` for
      each subclass of
      `BroadcastReceiver <#>`__
   -  ``<provider>`` for
      each subclass of
      `ContentProvider <#>`__

   If you subclass any of these components without declaring it in the
   manifest file, the system can't start it.

   Specify the name of your subclass with the ``name`` attribute, using
   the full package designation. For example, an ``Activity`` subclass
   is declared as follows:

   .. code:: prettyprint

      <manifest ... >
          <application ... >
              <activity android:name="com.example.myapp.MainActivity" ... >
              </activity>
          </application>
      </manifest>

   However, if the first character in the ``name`` value is a period,
   the app's namespace, from the module-level ``build.gradle`` file's
   `namespace <#namespace>`__
   property, is prefixed to the name. For example, if the namespace is
   ``"com.example.myapp"``, the following activity name resolves to
   ``com.example.myapp.MainActivity``:

   .. code:: prettyprint

      <manifest ... >
          <application ... >
              <activity android:name=".MainActivity" ... >
                  ...
              </activity>
          </application>
      </manifest>

   For more information about setting the package name or namespace, see
   `Set the namespace <#set-namespace>`__.

   If you have app components that reside in sub-packages, such as in
   ``com.example.myapp.purchases``, the ``name`` value must add the
   missing sub-package names, such as ``".purchases.PayActivity"``, or
   use the fully qualified package name.

   .. rubric:: Intent filters
      :name: ifs

   App activities, services, and broadcast receivers are activated by
   *intents*. An intent is a message defined by an
   `Intent <#>`__ object that
   describes an action to perform, including the data to be acted on,
   the category of component that is expected to perform the action, and
   other instructions.

   When an app issues an intent to the system, the system locates an app
   component that can handle the intent based on *intent filter*
   declarations in each app's manifest file. The system launches an
   instance of the matching component and passes the ``Intent`` object
   to that component. If more than one app can handle the intent, then
   the user can select which app to use.

   An app component can have any number of intent filters (defined with
   the
   ``<intent-filter>``
   element), each one describing a different capability of that
   component.

   For more information, see the `Intents and Intent Filters <#>`__ document.

   .. rubric:: Icons and labels
      :name: iconlabel

   A number of manifest elements have ``icon`` and ``label`` attributes
   for displaying a small icon and a text label, respectively, to users
   for the corresponding app component.

   In every case, the icon and label that are set in a parent element
   become the default ``icon`` and ``label`` value for all child
   elements. For example, the icon and label that are set in the
   ``<application>``
   element are the default icon and label for each of the app's
   components, such as all activities.

   The icon and label that are set in a component's
   ``<intent-filter>``
   are shown to the user whenever that component is presented as an
   option to fulfill an intent. By default, this icon is inherited from
   whichever icon is declared for the parent component, either the
   ``<activity>`` or
   ``<application>`` element.

   You might want to change the icon for an intent filter if it provides
   a unique action that you'd like to better indicate in the chooser
   dialog. For more information, see `Allow other apps to start your activity <#>`__.

   .. rubric:: Permissions
      :name: perms

   Android apps must request permission to access sensitive user data,
   such as contacts and SMS, or certain system features, such as the
   camera and internet access. Each permission is identified by a unique
   label. For example, an app that needs to send SMS messages must have
   the following line in the manifest:

   .. code:: prettyprint

      <manifest ... >
          <uses-permission android:name="android.permission.SEND_SMS"/>
          ...
      </manifest>

   Beginning with Android 6.0 (API level 23), the user can approve or
   reject some app permissions at runtime. But no matter which Android
   version your app supports, you must declare all permission requests
   with a
   ``<uses-permission>``
   element in the manifest. If the permission is granted, the app is
   able to use the protected features. If not, its attempts to access
   those features fail.

   Your app can also protect its own components with permissions. It can
   use any of the permissions that are defined by Android, as listed in
   `android.Manifest.permission <#>`__,
   or a permission that's declared in another app. Your app can also
   define its own permissions. A new permission is declared with the
   ``<permission>``
   element.

   For more information, see `Permissions on Android <#>`__.

   .. rubric:: Device compatibility
      :name: compatibility

   The manifest file is also where you can declare what types of
   hardware or software features your app requires and, by extension,
   which types of devices your app is compatible with. Google Play Store
   doesn't let users install your app on devices that don't provide the
   features or system version that your app requires.

   There are several manifest tags that define which devices your app is
   compatible with. The following are some of the most common.

   .. rubric:: <uses-feature>
      :name: uses-feature

   The
   ``<uses-feature>``
   element lets you declare hardware and software features your app
   needs. For example, if your app can't achieve basic functionality on
   a device without a compass sensor, you can declare the compass sensor
   as required with the following manifest tag:

   .. code:: prettyprint

      <manifest ... >
          <uses-feature android:name="android.hardware.sensor.compass"
                        android:required="true" />
          ...
      </manifest>

   **Note**: If you want to make your app available on Chromebooks,
   there are some important hardware and software feature limitations to
   consider. For more information, see `App manifest compatibility for Chromebooks <#>`__.

   .. rubric:: <uses-sdk>
      :name: uses-sdk

   Each successive platform version often adds new APIs not available in
   the previous version. To indicate the minimum version with which your
   app is compatible, your manifest must include the
   ``<uses-sdk>`` tag and
   its
   `minSdkVersion <#min>`__
   attribute.

   However, be aware that attributes in the ``<uses-sdk>`` element are
   overridden by corresponding properties in the
   `build.gradle <#build-files>`__ file. So, if you're
   using Android Studio, specify the ``minSdkVersion`` and
   ``targetSdkVersion`` values there instead:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               android {
                   defaultConfig {
                       applicationId 'com.example.myapp'

                       // Defines the minimum API level required to run the app.
                       minSdkVersion 21

                       // Specifies the API level used to test the app.
                       targetSdkVersion 33
                       ...
                   }
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               android {
                   defaultConfig {
                       applicationId = "com.example.myapp"

                       // Defines the minimum API level required to run the app.
                       minSdkVersion(21)

                       // Specifies the API level used to test the app.
                       targetSdkVersion(33)
                       ...
                   }
               }

   For more information about the ``build.gradle`` file, read about `how to configure your build <#>`__.

   To learn more about how to declare your app's support for different
   devices, see the `Device compatibility overview <#>`__.

   .. rubric:: File conventions
      :name: filec

   This section describes the conventions and rules that generally apply
   to all elements and attributes in the manifest file.

   **Elements**
      Only the
      ``<manifest>`` and
      ``<application>``
      elements are required. They each must occur only once. Most of the
      other elements can occur zero or more times. However, some of them
      must be present to make the manifest file useful.

      All values are set through attributes, not as character data
      within an element.

      Elements at the same level are generally not ordered. For example,
      the ``<activity>``,
      ``<provider>``, and
      ``<service>``
      elements can be placed in any order. There are two key exceptions
      to this rule:

      -  An
         ``<activity-alias>``
         element must follow the ``<activity>`` for which it is an
         alias.
      -  The ``<application>`` element must be the last element inside
         the ``<manifest>`` element.

   **Attributes**
      Technically, all attributes are optional. However, many attributes
      must be specified so that an element can accomplish its purpose.
      For truly optional attributes, the `reference documentation <#reference>`__ indicates the default values.

      Except for some attributes of the root
      ``<manifest>``
      element, all attribute names begin with an ``android:`` prefix,
      such as ``android:alwaysRetainTaskState``. Because the prefix is
      universal, the documentation generally omits it when referring to
      attributes by name.

   **Multiple values**
      If more than one value can be specified, the element is almost
      always repeated, rather than multiple values being listed within a
      single element. For example, an intent filter can list several
      actions:

      .. code:: prettyprint

         <intent-filter ... >
             <action android:name="android.intent.action.EDIT" />
             <action android:name="android.intent.action.INSERT" />
             <action android:name="android.intent.action.DELETE" />
             ...
         </intent-filter>

   **Resource values**
      Some attributes have values that are displayed to users, such as
      the title for an activity or your app icon. The value for these
      attributes might differ based on the user's language or other
      device configurations (such as to provide a different icon size
      based on the device's pixel density), so the values should be set
      from a resource or theme, instead of hardcoded into the manifest
      file. The actual value can then change based on `alternative resources <#>`__ that
      you provide for different device configurations.

      Resources are expressed as values with the following format:

      ``"@[``\ ``package``\ ``:]``\ ``type``\ ``/``\ ``name``\ ``"``

      You can omit the ``package`` name if the resource is provided by
      your app (including if it is provided by a library dependency,
      because `library resources are merged into yours <#resource_merging>`__). The only
      other valid package name is ``android``, when you want to use a
      resource from the Android framework.

      The ``type`` is a type of resource, such as
      `string <#>`__ or
      `drawable <#>`__, and
      the ``name`` is the name that identifies the specific resource.
      Here is an example:

      .. code:: prettyprint

         <activity android:icon="@drawable/smallPic" ... >

      For more information about how to add resources to your project,
      read `App resources overview <#>`__.

      To instead apply a value that's defined in a
      `theme <#>`__, the first
      character must be ``?`` instead of ``@``:

      ``"?[``\ ``package``\ ``:]``\ ``type``\ ``/``\ ``name``\ ``"``

   **String values**
      Where an attribute value is a string, use double backslashes
      (``\\``) to escape characters, such as ``\\n`` for a newline or
      ``\\uxxxx`` for a Unicode character.

   .. rubric:: Manifest elements reference
      :name: reference

   The following table provides links to the reference documents for all
   valid elements in the ``AndroidManifest.xml`` file.

   ``<action>``

Adds an action to an intent filter.

``<activity>``

Declares an activity component.

``<activity-alias>``

Declares an alias for an activity.

``<application>``

Declares the application.

``<category>``

Adds a category name to an intent filter.

``<compatible-screens>``

Specifies each screen configuration the application is compatible with.

``<data>``

Adds a data specification to an intent filter.

``<grant-uri-permission>``

Specifies the subsets of app data that the parent content provider has
permission to access.

``<instrumentation>``

Declares an ``Instrumentation`` class that lets you monitor an
application's interaction with the system.

``<intent-filter>``

Specifies the types of intents that an activity, service, or broadcast
receiver can respond to.

``<manifest>``

The root element of the ``AndroidManifest.xml`` file.

``<meta-data>``

A name-value pair for an item of additional, arbitrary data that can be
supplied to the parent component.

``<path-permission>``

Defines the path and required permissions for a specific subset of data
within a content provider.

``<permission>``

Declares a security permission that can be used to limit access to
specific components or features of this or other applications.

``<permission-group>``

Declares a name for a logical grouping of related permissions.

``<permission-tree>``

Declares the base name for a tree of permissions.

``<provider>``

Declares a content provider component.

``<queries>``

Declares the set of other apps that your app intends to access. Learn
more in the guide about `package visibility filtering <#>`__.

``<receiver>``

Declares a broadcast receiver component.

``<service>``

Declares a service component.

``<supports-gl-texture>``

Declares a single GL texture compression format that the app supports.

``<supports-screens>``

Declares the screen sizes your app supports and enables screen
compatibility mode for screens larger than what your app supports.

``<uses-configuration>``

Indicates specific input features the application requires.

``<uses-feature>``

Declares a single hardware or software feature that is used by the
application.

``<uses-library>``

Specifies a shared library that the application must be linked against.

``<uses-native-library>``

Specifies a vendor-provided native shared library that the app must be
linked against.

``<uses-permission>``

Specifies a system permission that the user must grant in order for the
app to operate correctly.

``<uses-permission-sdk-23>``

Specifies that an app wants a particular permission, but only if the app
is installed on a device running Android 6.0 (API level 23) or higher.

``<uses-sdk>``

Lets you express an application's compatibility with one or more
versions of the Android platform, by means of an API level integer.

.. _example:

Example manifest file
---------------------

The XML below is a simple example ``AndroidManifest.xml`` that declares
two activities for the app.

.. code:: prettyprint

   <?xml version="1.0" encoding="utf-8"?>
   <manifest
       xmlns:android="http://schemas.android.com/apk/res/android"
       android:versionCode="1"
       android:versionName="1.0">

       <!-- Beware that these values are overridden by the build.gradle file -->
       <uses-sdk android:minSdkVersion="15" android:targetSdkVersion="26" />

       <application
           android:allowBackup="true"
           android:icon="@mipmap/ic_launcher"
           android:roundIcon="@mipmap/ic_launcher_round"
           android:label="@string/app_name"
           android:supportsRtl="true"
           android:theme="@style/AppTheme">

           <!-- This name is resolved to com.example.myapp.MainActivity
                based on the namespace property in the build.gradle file -->
           <activity android:name=".MainActivity">
               <intent-filter>
                   <action android:name="android.intent.action.MAIN" />
                   <category android:name="android.intent.category.LAUNCHER" />
               </intent-filter>
           </activity>

           <activity
               android:name=".DisplayMessageActivity"
               android:parentActivityName=".MainActivity" />
       </application>
   </manifest>

Last updated 2024-05-03 UTC.


/manifest action
================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <action android:name="string" />

   contained in:
      ``<intent-filter>``
   description:
      Adds an action to an intent filter. An
      ``<intent-filter>``
      element must contain one or more ``<action>`` elements. If there
      are no ``<action>`` elements in an intent filter, the filter
      doesn't accept any
      `Intent <#>`__ objects. For
      details about intent filters and the role of action specifications
      within a filter, see `Intents and Intent Filters <#>`__.
   attributes:
      ``android:name``
         The name of the action. Some standard actions are defined in
         the
         `Intent <#ACTION_CHOOSER>`__
         class as ``ACTION_``\ *``string``* constants. To assign one of
         these actions to this attribute, prepend
         ``android.intent.action.`` to the *``string``* that follows
         ``ACTION_``. For example, for ``ACTION_MAIN``, use
         ``android.intent.action.MAIN``, and for ``ACTION_WEB_SEARCH``,
         use ``android.intent.action.WEB_SEARCH``.

         For actions you define, it's best to use your app's package
         name as a prefix to help ensure uniqueness. For example, a
         ``TRANSMOGRIFY`` action might be specified as follows:

         .. code:: prettyprint

            <action android:name="com.example.project.TRANSMOGRIFY" />

   introduced in:
      API Level 1
   see also:
      ``<intent-filter>``

Last updated 2023-03-22 UTC.


/manifest activity
==================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <activity android:allowEmbedded=["true" | "false"]
                   android:allowTaskReparenting=["true" | "false"]
                   android:alwaysRetainTaskState=["true" | "false"]
                   android:autoRemoveFromRecents=["true" | "false"]
                   android:banner="drawable resource"
                   android:clearTaskOnLaunch=["true" | "false"]
                   android:colorMode=[ "hdr" | "wideColorGamut"]
                   android:configChanges=["mcc", "mnc", "locale",
                                          "touchscreen", "keyboard", "keyboardHidden",
                                          "navigation", "screenLayout", "fontScale",
                                          "uiMode", "orientation", "density",
                                          "screenSize", "smallestScreenSize"]
                   android:directBootAware=["true" | "false"]
                   android:documentLaunchMode=["intoExisting" | "always" |
                                           "none" | "never"]
                   android:enabled=["true" | "false"]
                   android:enabledOnBackInvokedCallback=["true" | "false"]
                   android:excludeFromRecents=["true" | "false"]
                   android:exported=["true" | "false"]
                   android:finishOnTaskLaunch=["true" | "false"]
                   android:hardwareAccelerated=["true" | "false"]
                   android:icon="drawable resource"
                   android:immersive=["true" | "false"]
                   android:label="string resource"
                   android:launchMode=["standard" | "singleTop" |
                                       "singleTask" | "singleInstance" | "singleInstancePerTask"]
                   android:lockTaskMode=["normal" | "never" |
                                       "if_whitelisted" | "always"]
                   android:maxRecents="integer"
                   android:maxAspectRatio="float"
                   android:multiprocess=["true" | "false"]
                   android:name="string"
                   android:noHistory=["true" | "false"]  
                   android:parentActivityName="string" 
                   android:persistableMode=["persistRootOnly" | 
                                            "persistAcrossReboots" | "persistNever"]
                   android:permission="string"
                   android:process="string"
                   android:relinquishTaskIdentity=["true" | "false"]
                   android:resizeableActivity=["true" | "false"]
                   android:screenOrientation=["unspecified" | "behind" |
                                              "landscape" | "portrait" |
                                              "reverseLandscape" | "reversePortrait" |
                                              "sensorLandscape" | "sensorPortrait" |
                                              "userLandscape" | "userPortrait" |
                                              "sensor" | "fullSensor" | "nosensor" |
                                              "user" | "fullUser" | "locked"]
                   android:showForAllUsers=["true" | "false"]
                   android:stateNotNeeded=["true" | "false"]
                   android:supportsPictureInPicture=["true" | "false"]
                   android:taskAffinity="string"
                   android:theme="resource or theme"
                   android:uiOptions=["none" | "splitActionBarWhenNarrow"]
                   android:windowSoftInputMode=["stateUnspecified",
                                                "stateUnchanged", "stateHidden",
                                                "stateAlwaysHidden", "stateVisible",
                                                "stateAlwaysVisible", "adjustUnspecified",
                                                "adjustResize", "adjustPan"] >   
             ...
         </activity>

   contained in:
      ``<application>``
   can contain:
      ``<intent-filter>``
      ``<meta-data>``
      ``<layout>``
   description:
      Declares an activity (an
      `Activity <#>`__ subclass) that
      implements part of the application's visual user interface. All
      activities must be represented by ``<activity>`` elements in the
      manifest file. Any that aren't declared there aren't seen by the
      system and never run.
   attributes:
      ``android:allowEmbedded``
         Indicates that the activity can be launched as the embedded
         child of another activity, particularly in the case where the
         child lives in a container, such as a ``Display`` owned by
         another activity. For example, activities that are used for
         Wear custom notifications declare this so Wear can display the
         activity in its context stream, which resides in another
         process.

         The default value of this attribute is ``false``.

      ``android:allowTaskReparenting``
         Whether the activity can move from the task that started it to
         the task it has an affinity for when that task is next brought
         to the front. It's ``"true"`` if it can move, and ``"false"``
         if it remains with the task where it started.

         If this attribute isn't set, the value set by the corresponding
         `allowTaskReparenting <#reparent>`__
         attribute of the
         ``<application>``
         element applies to the activity. The default value is
         ``"false"``.

         Normally, when an activity is started it's associated with the
         task of the activity that started it and it stays there for its
         entire lifetime. You can use this attribute to force it to be
         re-parented to the task it has an affinity for when its current
         task is no longer displayed. Typically, this is used to cause
         the activities of an application to move to the main task
         associated with that application.

         For example, if an email message contains a link to a web page,
         clicking the link brings up an activity that can display the
         page. That activity is defined by the browser application but
         is launched as part of the email task. If it's reparented to
         the browser task, it shows when the browser next comes to the
         front and is absent when the email task again comes forward.

         The affinity of an activity is defined by the
         `taskAffinity <#aff>`__ attribute. The affinity of a task
         is determined by reading the affinity of its root activity.
         Therefore, by definition, a root activity is always in a task
         with the same affinity. Since activities with ``"singleTask"``
         or ``"singleInstance"`` launch modes can only be at the root of
         a task, re-parenting is limited to the ``"standard"`` and
         ``"singleTop"`` modes. (See also the
         `launchMode <#lmode>`__ attribute.)

      ``android:alwaysRetainTaskState``
         Whether the state of the task that the activity is in is always
         maintained by the system. ``"true"`` if it is, and ``"false"``
         if the system can reset the task to its initial state in
         certain situations. The default value is ``"false"``. This
         attribute is meaningful only for the root activity of a task.
         It's ignored for all other activities.

         Normally, the system clears a task, removing all activities
         from the stack above the root activity, in certain situations
         when the user re-selects that task from the home screen.
         Typically, this is done if the user hasn't visited the task for
         a certain amount of time, such as 30 minutes.

         However, when this attribute is ``"true"``, users always return
         to the task in its last state, regardless of how they get
         there. This is useful in an application like a web browser
         where there is a lot of state, such as multiple open tabs, that
         users don't want to lose.

      ``android:autoRemoveFromRecents``
         Whether tasks launched by the activity with this attribute
         remain in the `Recents screen <#>`__
         until the last activity in the task completes. If ``true``, the
         task is automatically removed from the Recents screen. This
         overrides the caller's use of
         `FLAG_ACTIVITY_RETAIN_IN_RECENTS <#FLAG_ACTIVITY_RETAIN_IN_RECENTS>`__.
         It must be a boolean value, either ``"true"`` or ``"false"``.
      ``android:banner``
         A `drawable resource <#>`__
         providing an extended graphical banner for its associated item.
         Use with the ``<activity>`` tag to supply a default banner for
         a specific activity or with the
         ``<application>``
         tag to supply a banner for all application activities.

         The system uses the banner to represent an app in the Android
         TV home screen. Since the banner displays only in the home
         screen, it is only specified by applications with an activity
         that handles the
         `CATEGORY_LEANBACK_LAUNCHER <#CATEGORY_LEANBACK_LAUNCHER>`__
         intent.

         This attribute is set as a reference to a drawable resource
         containing the image, such as ``"@drawable/banner"``. There is
         no default banner.

         For more information, see `Provide a home screen banner <#banner>`__ in Get Started with
         TV Apps.

      ``android:clearTaskOnLaunch``
         Whether all activities are removed from the task, except for
         the root activity, when it is re-launched from the home screen.
         ``"true"`` if the task is always stripped down to its root
         activity, and ``"false"`` if not. The default value is
         ``"false"``. This attribute is meaningful only for activities
         that start a new task‚Äîthe root activity. It's ignored for all
         other activities in the task.

         When the value is ``"true"``, every time users start the task,
         they are brought to its root activity regardless of what they
         were last doing in the task and regardless of whether they used
         the Back or Home button to leave it. When the value is
         ``"false"``, the task can be cleared of activities in some
         situations, but not always. For more information, see the
         `alwaysRetainTaskState <#always>`__ attribute.

         Suppose the user launches activity P from the home screen, and
         from there goes to activity Q. The user next taps Home, and
         then returns to activity P. Normally, the user sees activity Q,
         since that is what they were last doing in P's task. However,
         if P set this flag to ``"true"``, all of the activities on top
         of it‚Äîin this case, Q‚Äîare removed when the user launches
         activity P from the home screen. So, the user sees only P when
         returning to the task.

         If this attribute and `allowTaskReparenting <#reparent>`__
         are both ``"true"``, any activities that can be re-parented are
         moved to the task they share an affinity with. The remaining
         activities are then dropped.

         This attribute is ignored if
         `FLAG_ACTIVITY_RESET_TASK_IF_NEEDED <#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED>`__
         isn't set.

      ``android:colorMode``
         Specifies the activity's color mode. If specified, can be
         either ``hdr`` or ``wideColorGamut``.

         If ``hdr``, requests that the activity be displayed in a high
         dynamic range if the device supports it.

         **Note:** For performance reasons, we do not recommend turning
         on HDR in the manifest. Instead, if your app is displaying HDR
         images, you should call
         `setColorMode() <#setColorMode>`__
         to dynamically switch the activity to HDR mode at run time. For
         more information, see `Display Ultra HDR images <#>`__.

         If ``wideColorGamut``, requests that the activity be displayed
         in wide color gamut mode on compatible devices. In wide color
         gamut mode, a window can render outside of the
         `SRGB <#SRGB>`__
         gamut to display more vibrant colors. If the device doesn't
         support wide color gamut rendering, this attribute has no
         effect. For more information about rendering in wide color
         mode, see `Enhance graphics with wide color content <#>`__.

      ``android:configChanges``
         Lists configuration changes that the activity handles itself.
         When a configuration change occurs at runtime, the activity
         shuts down and restarts by default, but declaring a
         configuration with this attribute prevents the activity from
         restarting. Instead, the activity remains running and its
         `onConfigurationChanged() <#onConfigurationChanged>`__
         method is called.

         **Note:** Use this attribute only in special cases to improve
         application performance and responsiveness. For more
         information, see `Handle configuration changes <#>`__.

         The following strings are valid values for this attribute.
         Multiple values are separated by ``|``, such as
         ``"locale|navigation|orientation"``.

         .. list-table::
            :widths: 36 36
            :header-rows: 1

            - 

               - Value
               - Description
            - 

               - ``"density"``
               - A change to the display density, such as when the user
                  specifies a different display scale or a different
                  display is now active.
                  *Added in API level 24*.
            - 

               - ``"fontScale"``
               - A change to the font scaling factor, such as when the
                  user selects a new global font size.
            - 

               - ``"keyboard"``
               - A change to the keyboard type, such as when the user
                  plugs in an external keyboard.
            - 

               - ``"keyboardHidden"``
               - A change to the keyboard accessibility, such as when
                  the user reveals the hardware keyboard.
            - 

               - ``"layoutDirection"``
               - A change to the layout direction, such as from
                  left-to-right (LTR) to right-to-left (RTL).
                  *Added in API level 17*.
            - 

               - ``"locale"``
               - A change to the locale, such as when the user selects a
                  new language that text displays in.
            - 

               - ``"mcc"``
               - A change to the IMSI mobile country code (MCC) when a
                  SIM is detected that updates the MCC.
            - 

               - ``"mnc"``
               - A change to the IMSI mobile network code (MNC) when a
                  SIM is detected that updates the MNC.
            - 

               - ``"navigation"``
               - TA change to the navigation type (trackball or D-pad).
                  Normally, this does not happen.
            - 

               - ``"orientation"``
               - A change to the screen orientation, such as when the
                  user rotates the device.

                  **Note:** If your application targets Android 3.2 (API
                  level 13) or higher, also declare the
                  ``"screenLayout"`` and ``"screenSize"``
                  configurations, because screen layout and screen size
                  can change when a device switches between portrait and
                  landscape orientations.
            - 

               - ``"screenLayout"``
               - A change to the screen layout, such as when a different
                  display becomes active.
            - 

               - ``"screenSize"``
               - A change to the current available screen size.
                  This represents a change in the currently available
                  size, relative to the current aspect ratio, so it
                  changes when the user switches between landscape and
                  portrait.

                  *Added in API level 13*.
            - 

               - ``"smallestScreenSize"``
               - A change to the physical screen size.
                  This represents a change in size regardless of
                  orientation, so it only changes when the actual
                  physical screen size changes, such as switching to an
                  external display. A change to this configuration
                  corresponds to a change in the `smallestWidth``
                  configuration </guide/topics/resources/providing-resources#SmallestScreenWidthQualifier>`__.

                  *Added in API level 13*.
            - 

               - ``"touchscreen"``
               - A change to the touchscreen. Normally, this does not
                  happen.
            - 

               - ``"uiMode"``
               - A change to the user interface mode, such as when the
                  user places the device into a desk or car dock, or the
                  night mode changes. For more information about the
                  different UI modes, see
                  `UiModeManager <#>`__.
                  *Added in API level 8*.

         All these configuration changes can impact the resource values
         seen by the application. Therefore, when
         `onConfigurationChanged() <#onConfigurationChanged>`__
         is called, it is usually necessary to again retrieve all
         resources, including view layouts and drawables, to correctly
         handle the change.

         **Note:** To handle
         `multi-window <#>`__ related
         configuration changes, use both ``"screenLayout"`` and
         ``"smallestScreenSize"``. Multi-window is supported in Android
         7.0 (API level 24) or higher.

      ``android:directBootAware``
         Whether the activity is *Direct-Boot aware*‚Äîthat is, whether it
         can run before the user unlocks the device.

         **Note:** During `Direct Boot <#>`__, an activity in your
         application can only access the data that is stored in *device
         protected* storage.

         The default value is ``"false"``.

      ``android:documentLaunchMode``
         Specifies how a new instance of an activity is added to a task
         each time it is launched. This attribute permits the user to
         have multiple documents from the same application appear in the
         `Recents screen <#>`__.

         This attribute has four values, which produce the following
         effects when the user opens a document with the application:

         .. list-table::
            :header-rows: 1

            - 

               - Value
               - Description
            - 

               - ``"intoExisting"``
               - The system searches for a task whose base intent's
                  ``ComponentName`` and data URI match those of the
                  launching intent. If the system finds such a task, the
                  system clears the task and restarts, with the root
                  activity receiving a call to
                  `onNewIntent(android.content.Intent) <#onNewIntent>`__.
                  If the system doesn't find such a task, the system
                  creates a new task.
            - 

               - ``"always"``
               - The activity creates a new task for the document, even
                  if the document is already opened. This is the same as
                  setting both the
                  `FLAG_ACTIVITY_NEW_DOCUMENT <#FLAG_ACTIVITY_NEW_DOCUMENT>`__
                  and
                  `FLAG_ACTIVITY_MULTIPLE_TASK <#FLAG_ACTIVITY_MULTIPLE_TASK>`__
                  flags.
            - 

               - ``"none"``
               - The activity doesn't create a new task for the
                  activity. This is the default value, which creates a
                  new task only when
                  `FLAG_ACTIVITY_NEW_TASK <#FLAG_ACTIVITY_NEW_TASK>`__
                  is set. The Recents screen treats the activity as it
                  does by default: it displays a single task for the
                  app, which resumes from whatever activity the user
                  last invoked.
            - 

               - ``"never"``
               - The activity isn't launched into a new document even if
                  the intent contains
                  `FLAG_ACTIVITY_NEW_DOCUMENT <#FLAG_ACTIVITY_NEW_DOCUMENT>`__.
                  Setting this overrides the behavior of the
                  ``FLAG_ACTIVITY_NEW_DOCUMENT`` and
                  `FLAG_ACTIVITY_MULTIPLE_TASK <#FLAG_ACTIVITY_MULTIPLE_TASK>`__
                  flags, if either of these are set in the activity, and
                  the Recents screen displays a single task for the app,
                  which resumes from whatever activity the user last
                  invoked.

         **Note:** For values other than ``"none"`` and ``"never"``, the
         activity is defined with ``launchMode="standard"``. If this
         attribute isn't specified, ``documentLaunchMode="none"`` is
         used.

      ``android:enabled``
         Whether the activity can be instantiated by the system. It's
         ``"true"`` if it can be, and ``"false"`` if not. The default
         value is ``"true"``.

         The
         ``<application>``
         element has its own
         `enabled <#enabled>`__
         attribute that applies to all application components, including
         activities. The ``<application>`` and ``<activity>`` attributes
         must both be ``"true"``, as they both are by default, for the
         system to be able to instantiate the activity. If either is
         ``"false"``, it can't be instantiated.

      ``android:enableOnBackInvokedCallback``
         This flag lets you opt in to predictive system animations at
         the activity level. This behavior makes it more manageable to
         migrate large multi-activity apps to predictive back gestures.

         Setting ``android:enableOnBackInvokedCallback=false`` turns off
         predictive back animations either at the activity level or at
         the app level, depending on where you set the tag, and
         instructs the system to ignore calls to the
         ``OnBackInvokedCallback`` platform API.

      ``android:excludeFromRecents``
         Whether the task initiated by this activity is excluded from
         the `Recents screen <#>`__. That is,
         when this activity is the root activity of a new task, this
         attribute determines whether the task appears in the list of
         recent apps. It‚Äôs ``"true"`` if the task is *excluded* from the
         list; ``"false"`` if it is *included*. The default value is
         ``"false"``.
      ``android:exported``
         Whether the activity can be launched by components of other
         applications:

         -  If ``"true"``, the activity is accessible to any app, and is
            launchable by its exact class name.
         -  If ``"false"``, the activity can be launched only by
            components of the same application, applications with the
            same user ID, or privileged system components. This is the
            default value when there are no intent filters.

         If an activity in your app includes intent filters, set this
         element to ``"true"`` to let other apps start it. For example,
         if the activity is the main activity of the app and includes
         the `category <#>`__
         `android.intent.category.LAUNCHER <#CATEGORY_LAUNCHER>`__.

         If this element is set to ``"false"`` and an app tries to start
         the activity, the system throws an
         `ActivityNotFoundException <#>`__.

         This attribute isn't the only way to limit an activity's
         exposure to other applications. Permissions are also used to
         limit the external entities that can invoke the activity. See
         the
         `permission <#prmsn>`__
         attribute.

      ``android:finishOnTaskLaunch``
         Whether an existing instance of the activity is shut down,
         except for the root activity, when the user re-launches its
         task by choosing the task on the home screen. It's ``"true"``
         if it is shut down, and ``"false"`` if not. The default value
         is ``"false"``.

         If this attribute and
         `allowTaskReparenting <#reparent>`__
         are both ``"true"``, this attribute trumps the other. The
         affinity of the activity is ignored. The activity isn't
         re-parented, but destroyed.

         This attribute is ignored if
         `FLAG_ACTIVITY_RESET_TASK_IF_NEEDED <#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED>`__
         isn't set.

      ``android:hardwareAccelerated``
         Whether hardware-accelerated rendering is enabled for this
         activity. ``"true"`` if it is enabled, and ``"false"`` if not.
         The default value is ``"false"``.

         On Android 3.0 and higher, a hardware-accelerated OpenGL
         renderer is available to applications to improve performance
         for many common 2D graphics operations. When the
         hardware-accelerated renderer is enabled, most operations in
         Canvas, Paint, Xfermode, ColorFilter, Shader, and Camera are
         accelerated.

         This results in smoother animations, smoother scrolling, and
         improved responsiveness overall, even for applications that
         don't explicitly make use the framework's OpenGL libraries.
         Because of the increased resources required to enable hardware
         acceleration, your app consumes more RAM.

         Not all of the OpenGL 2D operations are accelerated. If you
         enable the hardware-accelerated renderer, test whether your
         application can use the renderer without errors.

      ``android:icon``
         An icon representing the activity. The icon is displayed to
         users when a representation of the activity is required
         on-screen. For example, icons for activities that initiate
         tasks are displayed in the launcher window. The icon is often
         accompanied by a label; for information about the label, see
         the `android:label <#label>`__ attribute.

         This attribute is set as a reference to a drawable resource
         containing the image definition. If it isn't set, the icon
         specified for the application as a whole is used instead. For
         more information, see the
         ``<application>``
         element's
         `icon <#icon>`__
         attribute.

         The activity's icon, whether set here or by the
         ``<application>`` element, is also the default icon for all the
         activity's intent filters. For more information, see the
         ``<intent-filter>``
         element's
         `icon <#icon>`__
         attribute.

      ``android:immersive``
         Sets the immersive mode setting for the current activity. If
         it‚Äôs ``"true"``, the
         `ActivityInfo.flags <#flags>`__
         member always has its
         `FLAG_IMMERSIVE <#FLAG_IMMERSIVE>`__
         bit set, even if the immersive mode changes at runtime using
         the
         `setImmersive() <#setImmersive>`__
         method.
      ``android:label``
         A user-readable label for the activity. The label displays
         on-screen when the activity is represented to the user. It's
         often displayed along with the activity icon. If this attribute
         isn't set, the label set for the application as a whole is used
         instead. see the
         ``<application>``
         element's
         `label <#label>`__
         attribute.

         The activity's label, whether set here or by the
         ``<application>`` element, is also the default label for all
         the activity's intent filters. For more information, see the
         ``<intent-filter>``
         element's
         `label <#label>`__
         attribute.

         The label is set as a reference to a string resource so that it
         can be localized like other strings in the user interface.
         However, as a convenience while you're developing the
         application, it can also be set as a raw string.

      ``android:launchMode``
         An instruction for how the activity launches. There are five
         modes, which work in conjunction with activity flags
         (``FLAG_ACTIVITY_*`` constants) in
         `Intent <#>`__ objects to
         determine what happens when the activity is called upon to
         handle an intent:

         | ``"standard"``
         | ``"singleTop"``
         | ``"singleTask"``
         | ``"singleInstance"``
         | ``"singleInstancePerTask"``

         The default mode is ``"standard"``.

         As shown in the following table, the modes fall into two main
         groups, with ``"standard"`` and ``"singleTop"`` activities on
         one side, and ``"singleTask"``, ``"singleInstance"``, and
         ``"singleInstancePerTask"`` activities on the other. An
         activity with the ``"standard"`` or ``"singleTop"`` launch mode
         can be instantiated multiple times.

         The instances can belong to any task and can be located
         anywhere in the activity task. Typically, they're launched into
         the task that called
         `startActivity() <#startActivity>`__,
         unless the ``Intent`` object contains a
         `FLAG_ACTIVITY_NEW_TASK <#FLAG_ACTIVITY_NEW_TASK>`__
         instruction, in which case a different task is chosen. For more
         information, see the `taskAffinity <#aff>`__ attribute.

         In contrast, ``"singleTask"``, ``"singleInstance"``, and
         ``"singleInstancePerTask"`` activities have different
         behaviors. ``"singleInstancePerTask"`` is always at the root of
         the activity task. Also, the device can hold only one instance
         of the ``"singleInstance"`` activity at a time, while the
         ``"singleInstancePerTask`` activity can be instantiated
         multiple times in different tasks when
         `FLAG_ACTIVITY_MULTIPLE_TASK <#FLAG_ACTIVITY_MULTIPLE_TASK>`__
         or
         `FLAG_ACTIVITY_NEW_DOCUMENT <#FLAG_ACTIVITY_NEW_DOCUMENT>`__
         is set.

         An activity with the ``"singleTask"`` launch mode combines the
         behaviors of ``"singleInstance"`` and
         ``"singleInstancePerTask"``: the activity can be instantiated
         multiple times and can be located anywhere in a task of the
         same ``taskAffinity``. But the device can only hold one task
         for locating the ``"singleTask"`` activity at the root of the
         activity task.

         The ``"standard"`` and ``"singleTop"`` modes differ from each
         other in one respect: every time there's a new intent for a
         ``"standard"`` activity, a new instance of the class is created
         to respond to that intent. Each instance handles a single
         intent. Similarly, a new instance of a ``"singleTop"`` activity
         can also be created to handle a new intent.

         However, if the target task already has an existing instance of
         the activity at the top of its stack, that instance receives
         the new intent, in an
         `onNewIntent() <#onNewIntent>`__
         call. A new instance isn't created. Otherwise‚Äîif an existing
         instance of the ``"singleTop"`` activity is in the target task
         but not at the top of the stack, or if it's at the top of a
         stack, but not in the target task‚Äîa new instance is created and
         pushed on the stack.

         Similarly, if the user `navigates up <#>`__ to an
         activity on the current stack, the behavior is determined by
         the parent activity's launch mode. If the parent activity has
         launch mode ``singleTop`` (or the ``up`` intent contains
         `FLAG_ACTIVITY_CLEAR_TOP <#FLAG_ACTIVITY_CLEAR_TOP>`__),
         the parent is brought to the top of the stack, and its state is
         preserved.

         The navigation intent is received by the parent activity's
         `onNewIntent() <#onNewIntent>`__
         method. If the parent activity has launch mode ``standard``,
         and the ``up`` intent doesn't contain
         ``FLAG_ACTIVITY_CLEAR_TOP``, the current activity and its
         parent both pop off the stack, and a new instance of the parent
         activity is created to receive the navigation intent.

         The ``"singleInstance"`` mode also differs from
         ``"singleTask"`` and ``"singleInstancePerTask"`` in only one
         respect: an activity with the ``"singleTask"`` or
         ``"singleInstancePerTask"`` launch mode lets other activities,
         necessarily ``"standard"`` and ``"singleTop"`` activities, be
         part of its task.

         A ``"singleInstance"`` activity, on the other hand, permits no
         other activities to be part of its task. It must be the only
         activity in the task. If it starts another activity, that
         activity is assigned to a different task, as if
         ``FLAG_ACTIVITY_NEW_TASK`` were in the intent.

         .. list-table::
            :widths: 18 18 18 18
            :header-rows: 1

            - 

               - Use cases
               - Launch mode
               - Multiple instances?
               - Comments
            - 

               - Normal launches for most activities
               - ``"standard"``
               - Yes
               - Default. The system always creates a new instance of
                  the activity in the target task and routes the intent
                  to it.
            - 

               - 
               - ``"singleTop"``
               - Conditionally
               - If an instance of the activity already exists at the
                  top of the target task, the system routes the intent
                  to that instance through a call to its
                  `onNewIntent() <#onNewIntent>`__
                  method, rather than creating a new instance of the
                  activity.
            - 

               - Specialized launches
                  *(not recommended for general use)*
               - ``"singleTask"``
               - Conditionally
               - The system creates the activity at the root of a new
                  task or locates the activity on an existing task with
                  the same affinity. If an instance of the activity
                  already exists and is at the root of the task, the
                  system routes the intent to existing instance through
                  a call to its
                  `onNewIntent() <#onNewIntent>`__
                  method, rather than creating a new one.
            - 

               - 
               - ``"singleInstance"``
               - No
               - Same as ``"singleTask"``, except that the system
                  doesn't launch any other activities into the task
                  holding the instance. The activity is always the
                  single and only member of its task.
            - 

               - 
               - ``"singleInstancePerTask"``
               - Conditionally
               - The activity can only run as the root activity of the
                  task, the first activity that created the task, and
                  therefore there is only one instance of this activity
                  in a task. However, the activity can be instantiated
                  multiple times in different tasks.

         As shown in the preceding table, ``"standard"`` is the default
         mode and is appropriate for most types of activities.
         ``"singleTop"`` is also a common and useful launch mode for
         many types of activities. The other modes, ``"singleTask"`` ,
         ``"singleInstance"``, and ``"singleInstancePerTask"``, are *not
         appropriate* for most applications. They result in an
         interaction model that is likely to be unfamiliar to users and
         is very different from most other applications.

         Regardless of the launch mode that you choose, make sure to
         test the usability of the activity during launch and when
         navigating back to it from other activities and tasks using the
         Back button.

         For more information about launch modes and their interaction
         with ``Intent`` flags, see `Tasks and the back stack <#>`__.

      ``android:lockTaskMode``
         Determines how the system presents this activity when the
         device is running in `lock task mode <#>`__.

         Android can run tasks in an immersive, kiosk-like fashion
         called lock task mode. When the system runs in lock task mode,
         device users typically can‚Äôt see notifications, access
         non-allowlisted apps, or return to the home screen, unless the
         Home app is allowlisted.

         Only apps that are allowlisted by a device policy controller
         (DPC) can run when the system is in lock task mode. System and
         `privileged apps <https://source.android.google.cn/devices/tech/config/perms-allowlist>`__,
         however, can run in lock task mode without being allowlisted.

         The value can be any one of the following
         `R.attr.lockTaskMode <#lockTaskMode>`__
         string values:

         .. list-table::
            :widths: 36 36
            :header-rows: 1

            - 

               - Value
               - Description
            - 

               - ``"normal"``
               - **Default value.** This is the default value. Tasks
                  don't launch into lock task mode but can be placed
                  there by calling
                  `startLockTask() <#startLockTask>`__.
            - 

               - ``"never"``
               - Tasks don't launch into ``lockTask`` mode, and the
                  device user can't pin these tasks from the Recents
                  screen.

                  **Note:** This mode is only available to system and
                  privileged applications. Non-privileged apps with this
                  value are treated as ``normal``.
            - 

               - ``"if_whitelisted"``
               - If the DPC authorizes this package using
                  `DevicePolicyManager.setLockTaskPackages() <#setLockTaskPackages>`__,
                  then this mode is identical to ``always``, except that
                  the activity needs to call
                  `stopLockTask() <#stopLockTask>`__
                  before being able to finish if it is the last locked
                  task. If the DPC doesn't authorize this package then
                  this mode is identical to ``normal``.
            - 

               - ``"always"``
               - Tasks rooted at this activity always launch into lock
                  task mode. If the system is already in lock task mode
                  when this task is launched, then the new task is
                  launched on top of the current task. Tasks launched in
                  this mode can exit lock task mode by calling
                  `finish() <#finish>`__.

                  **Note:** This mode is only available to system and
                  privileged applications. Non-privileged apps with this
                  value are treated as ``normal``.

         This attribute was introduced in API level 23.

      ``android:maxRecents``
         The maximum number of tasks rooted at this activity in the
         `Recents screen <#>`__. When this
         number of entries is reached, the system removes the
         least-recently used instance from the Recents screen. Valid
         values are integers from 1 through 50, or 1 through 25 on
         low-memory devices. Zero is invalid. The default value is 16.
      ``android:maxAspectRatio``
         The maximum aspect ratio the activity supports. If the app runs
         on a device with a wider aspect ratio, the system automatically
         letterboxes the app, leaving portions of the screen unused so
         the app can run at its specified maximum aspect ratio.

         Maximum aspect ratio is expressed as the decimal form of the
         quotient of the device's longer dimension divided by its
         shorter dimension. For example, if the maximum aspect ratio is
         7:3, set the value of this attribute to 2.33.

         On non-wearable devices, the value of this attribute needs to
         be 1.33 or greater. On wearable devices, it must be 1.0 or
         greater. Otherwise, the system ignores the set value.

         **Note:** This attribute is ignored if the activity has
         `resizeableActivity <#resizeableActivity>`__
         set to true, since that means your activity supports any size.

         For more information about this attribute, see `Declare a maximum aspect ratio <#maxAspectRatio>`__.

      ``android:multiprocess``
         Whether an instance of the activity can be launched into the
         process of the component that started it. It's ``"true"`` if it
         can be, and ``"false"`` if not. The default value is
         ``"false"``.

         Normally, a new instance of an activity is launched into the
         process of the application that defined it, so all instances of
         the activity run in the same process. However, if this flag is
         set to ``"true"``, instances of the activity can run in
         multiple processes, letting the system create instances
         wherever they are used, provided permissions let it‚Äîsomething
         that is almost never necessary or desirable.

      ``android:name``
         The name of the class that implements the activity, a subclass
         of `Activity <#>`__. The
         attribute value is normally a fully qualified class name, such
         as, ``"com.example.project.ExtracurricularActivity"``. However,
         as a shorthand, if the first character of the name is a period,
         such as ``".ExtracurricularActivity"``, it is appended to the
         `namespace <#set-namespace>`__
         specified in the ``build.gradle`` file.

         Once you publish your application, `don't change this name <http://android-developers.blogspot.com/2011/06/things-that-cannot-change.html>`__,
         unless you set
         `android:exported <#exported>`__\ ``="false"``. There is no
         default. The name must be specified.

      ``android:noHistory``
         Whether the activity is removed from the activity stack and
         finished, by calling its
         `finish() <#finish>`__
         method, when the user navigates away from it and it's no longer
         visible on screen. It's\ ``"true"`` if it is finished, and
         ``"false"`` if not. The default value is ``"false"``.

         A value of ``"true"`` means that the activity doesn't leave a
         historical trace. It doesn't remain in the activity stack for
         the task, so the user isn't able to return to it. In this case,
         `onActivityResult() <#onActivityResult>`__
         is never called if you start another activity for a result from
         this activity.

         This attribute was introduced in API level 3.

      ``android:parentActivityName``
         The class name of the logical parent of the activity. The name
         here must match the class name given to the corresponding
         ``<activity>`` element's `android:name <#nm>`__ attribute.

         The system reads this attribute to determine which activity to
         start when the user taps the Up button in the action bar. The
         system can also use this information to synthesize a back stack
         of activities with
         `TaskStackBuilder <#>`__.

         To support API levels 4 - 16, you can also declare the parent
         activity with a ``<meta-data>`` element that specifies a value
         for ``"android.support.PARENT_ACTIVITY"``:

         .. code:: prettyprint

            <activity
                android:name="com.example.app.ChildActivity"
                android:label="@string/title_child_activity"
                android:parentActivityName="com.example.app.MainActivity" >
                <!-- Parent activity meta-data to support API level 4+ -->
                <meta-data
                    android:name="android.support.PARENT_ACTIVITY"
                    android:value="com.example.app.MainActivity" />
            </activity>

         For more information about declaring the parent activity to
         support Up navigation, read `Providing Up Navigation <#>`__.

         This attribute was introduced in API level 16.

      ``android:persistableMode``
         Defines how an instance of an activity is preserved within a
         containing task across device restarts.

         If the root activity of a task sets this attribute's value to
         ``persistRootOnly``, then only the root activity is preserved.
         Otherwise, the activities that are higher up the task's `back stack <#>`__
         are examined; any of these activities that set this attribute's
         value to ``persistAcrossReboots`` are preserved.

         If you use this attribute, you must set its value to one of the
         following:

         .. list-table::
            :widths: 36 36
            :header-rows: 1

            - 

               - Value
               - Description
            - 

               - ``persistRootOnly``
               - **Default value.** When the system restarts, the
                  activity task is preserved, but only the root
                  activity's launching intent is used.
                  When your app's launching intent loads your app's root
                  activity, the activity doesn't receive a
                  `PersistableBundle <#>`__
                  object. Therefore, don't use
                  `onSaveInstanceState() <#onSaveInstanceState>`__
                  to preserve the state of your app's root activity
                  across a device restart.

                  **Note:** This attribute value affects your app's
                  behavior only if it's set on your app's root activity.
            - 

               - ``persistAcrossReboots``
               - This activity's state is preserved, along with the
                  state of each activity higher up the `back stack <#>`__
                  that has its own ``persistableMode`` attribute set to
                  ``persistAcrossReboots``. If an activity doesn't have
                  a ``persistableMode`` attribute that is set to
                  ``persistAcrossReboots``, or if it's launched using
                  the
                  `Intent.FLAG_ACTIVITY_NEW_DOCUMENT <#FLAG_ACTIVITY_NEW_DOCUMENT>`__
                  flag, then that activity, along with all activities
                  higher up the back stack, aren't preserved.

                  When an intent loads an activity whose
                  ``persistableMode`` attribute is set to
                  ``persistAcrossReboots`` in your app, the activity
                  receives a
                  `PersistableBundle <#>`__
                  object in its
                  `onCreate() <#onCreate>`__
                  method. Therefore, you can use
                  `onSaveInstanceState() <#onSaveInstanceState>`__
                  to preserve the state of an activity across a device
                  restart as long as its ``persistableMode`` attribute
                  is set to ``persistAcrossReboots``.

                  **Note:** This attribute value affects your app's
                  behavior even if it's set on an activity other than
                  your app's root activity.
            - 

               - ``persistNever``
               - The activity's state isn't preserved.

                  **Note:** This attribute value affects your app's
                  behavior only if it's set on your app's root activity.

         This attribute was introduced in API level 21.

      ``android:permission``
         The name of a permission that clients must have to launch the
         activity or otherwise get it to respond to an intent. If a
         caller of
         `startActivity() <#startActivity>`__
         or
         `startActivityForResult() <#startActivityForResult>`__
         isn't granted the specified permission, its intent isn't
         delivered to the activity.

         If this attribute isn't set, the permission set by the
         ``<application>``
         element's
         `permission <#prmsn>`__
         attribute applies to the activity. If neither attribute is set,
         the activity isn't protected by a permission.

         For more information on permissions, see the
         `Permissions <#perms>`__
         section of the App manifest overview and `Security tips <#>`__.

      ``android:process``
         The name of the process in which the activity runs. Normally,
         all components of an application run in a default process name
         created for the application, and you don't need to use this
         attribute. But if necessary, you can override the default
         process name with this attribute, letting you spread your app
         components across multiple processes.

         If the name assigned to this attribute begins with a colon
         (``:``), a new process, private to the application, is created
         when it's needed and the activity runs in that process.

         If the process name begins with a lowercase character, the
         activity runs in a global process of that name, provided that
         it has permission to do so. This lets components in different
         applications share a process, reducing resource usage.

         The
         ``<application>``
         element's
         `process <#proc>`__
         attribute can set a different default process name for all
         components.

      ``android:relinquishTaskIdentity``
         Whether the activity relinquishes its task identifiers to an
         activity above it in the task stack. A task whose root activity
         has this attribute set to ``"true"`` replaces the base
         ``Intent`` with that of the next activity in the task.

         If the next activity also has this attribute set to ``"true"``
         then it yields the base ``Intent`` to any activity that it
         launches in the same task. This continues for each activity
         until an activity is encountered which has this attribute set
         to ``"false"``. The default value is ``"false"``.

         This attribute set to ``"true"`` also permits the activity's
         use of the
         `ActivityManager.TaskDescription <#>`__
         to change labels, colors, and icons in the `Recents screen <#>`__.

      ``android:resizeableActivity``
         Specifies whether the app supports `multi-window mode <#>`__. You can set this
         attribute in either the ``<activity>`` or
         ``<application>``
         element.

         If you set this attribute to ``"true"``, the user can launch
         the activity in split-screen and free-form modes. If you set
         the attribute to ``"false"``, the app can't be tested or
         optimized for a multi-window environment. The system can still
         put the activity in multi-window mode with compatibility mode
         applied.

         Setting this attribute to ``"false"`` doesn't guarantee that
         there are no other apps in multi-window mode visible on screen,
         such as in a picture-in-picture, or on other displays.
         Therefore, setting this flag doesn't mean that your app has
         exclusive resource access.

         If your app targets API level 24 or higher and you do not
         specify a value for this attribute, the attribute's value
         defaults to ``"true"``.

         If your app targets API level 31 or higher, this attribute
         works differently on small and large screens:

         -  Large screens (sw >= 600dp): all apps support multi-window
            mode. The attribute indicates whether an app can be resized,
            not whether the app supports multi-window mode. If
            ``resizeableActivity="false"``, the app is put into
            compatibility mode when necessary to conform to display
            dimensions.
         -  Small screens (sw < 600dp): if ``resizeableActivity="true"``
            and the minimum width and minimum height of the activity are
            within the multi-window requirements, the app supports
            multi-window mode. If ``resizeableActivity="false"``, the
            app doesn't support multi-window mode regardless of the
            activity minimum width and height.

         **Note:** Device manufacturers can override the API level 31
         behavior.

         This attribute was added in API level 24.

         **Note:** A task's root activity value is applied to all
         additional activities launched in the task. That is, if the
         root activity of a task is resizable, then the system treats
         all other activities in the task as resizable. If the root
         activity isn't resizable, the other activities in the task
         aren't resizable.

      ``android:screenOrientation``
         The orientation of the activity on the device display.

         On Android 7.0 (API level 24) and higher, the system ignores
         runtime changes to this attribute if the activity is in
         multi‚Äëwindow mode.

         On `Android 12 (API level 31) <#dev-device-orientation-request>`__
         and higher, device manufacturers can configure individual
         device screens (such as the tablet-size screen of a foldable)
         to ignore the orientation specification and force an app
         specified as portrait‚Äëonly to be upright but letterboxed on
         landscape displays, which ensures the app still has a portrait
         aspect ratio but orients the app for better usability.

         The value can be any one of the following strings:

         .. list-table::

            - 

               - ``"unspecified"``
               - The default value. The system chooses the orientation.
                  The policy it uses, and therefore the choices made in
                  specific contexts, might differ from device to device.
            - 

               - ``"behind"``
               - The same orientation as the activity that's immediately
                  beneath it in the activity stack.
            - 

               - ``"landscape"``
               - Landscape orientation (the display is wider than it is
                  tall).
            - 

               - ``"portrait"``
               - Portrait orientation (the display is taller than it is
                  wide).
            - 

               - ``"reverseLandscape"``
               - Landscape orientation in the opposite direction from
                  normal landscape. *Added in API level 9.*
            - 

               - ``"reversePortrait"``
               - Portrait orientation in the opposite direction from
                  normal portrait. *Added in API level 9.*
            - 

               - ``"sensorLandscape"``
               - Landscape orientation, but can be either normal or
                  reverse landscape based on the device sensor. The
                  sensor is used even if the user has locked
                  sensor-based rotation. *Added in API level 9.*
            - 

               - ``"sensorPortrait"``
               - Portrait orientation, but can be either normal or
                  reverse portrait based on the device sensor. The
                  sensor is used even if the user has locked
                  sensor-based rotation. However, depending on the
                  device configuration, upside-down rotation might not
                  be allowed. *Added in API level 9.*
            - 

               - ``"userLandscape"``
               - Landscape orientation, but can be either normal or
                  reverse landscape based on the device sensor and the
                  user's preference. *Added in API level 18.*
            - 

               - ``"userPortrait"``
               - Portrait orientation, but can be either normal or
                  reverse portrait based on the device sensor and the
                  user's preference. However, depending on the device
                  configuration, upside-down rotation might not be
                  allowed. *Added in API level 18.*
            - 

               - ``"sensor"``
               - The device orientation sensor determines the
                  orientation. The orientation of the display depends on
                  how the user is holding the device. It changes when
                  the user rotates the device. Some devices, though,
                  don't rotate to all four possible orientations, by
                  default. To use all four orientations, use
                  ``"fullSensor"``. The sensor is used even if the user
                  locked sensor-based rotation.
            - 

               - ``"fullSensor"``
               - The device orientation sensor determines the
                  orientation for any of the four orientations. This is
                  similar to ``"sensor"``, except this allows for any of
                  the four possible screen orientations regardless of
                  what the device normally supports. For example, some
                  devices don't normally use reverse portrait or reverse
                  landscape, but this enables those orientations. *Added
                  in API level 9.*
            - 

               - ``"nosensor"``
               - The orientation is determined without reference to a
                  physical orientation sensor. The sensor is ignored, so
                  the display doesn't rotate based on how the user moves
                  the device.
            - 

               - ``"user"``
               - The user's current preferred orientation.
            - 

               - ``"fullUser"``
               - If the user has locked sensor-based rotation, this
                  behaves the same as ``user``, otherwise it behaves the
                  same as ``fullSensor`` and allows any of the four
                  possible screen orientations. *Added in API level 18.*
            - 

               - ``"locked"``
               - Locks the orientation to its current rotation, whatever
                  that is. *Added in API level 18.*

         **Note:** When you declare one of the landscape or portrait
         values, it is considered a hard requirement for the orientation
         in which the activity runs. The value you declare enables
         filtering by services such as Google Play, so your application
         is available only to devices that support the orientation
         required by your activities. For example, if you declare either
         ``"landscape"``, ``"reverseLandscape"``, or
         ``"sensorLandscape"``, then your application is available only
         to devices that support landscape orientation.

         Also explicitly declare that your application requires either
         portrait or landscape orientation with the
         ``<uses-feature>``
         Element, such as
         ``<uses-feature android:name="android.hardware.screen.portrait"/>``.
         This is a filtering behavior provided by Google Play and other
         services that support it, and the platform itself doesn't
         control whether your app can install when a device supports
         only certain orientations.

      ``android:showForAllUsers``
         Whether the activity is shown when the device's current user is
         different than the user who launched the activity. You can set
         this attribute to a literal value, like ``"true"`` or
         ``"false"``, or you can set the attribute to a resource or
         theme attribute that contains a boolean value.

         This attribute was added in API level 23.

      ``android:stateNotNeeded``
         Whether the activity can be terminated and successfully
         restarted without having saved its state. It's ``"true"`` if it
         can be restarted without reference to its previous state, and
         ``"false"`` if its previous state is required. The default
         value is ``"false"``.

         Normally, before an activity is temporarily shut down to save
         resources, its
         `onSaveInstanceState() <#onSaveInstanceState>`__
         method is called. This method stores the current state of the
         activity in a `Bundle <#>`__
         object, which is then passed to
         `onCreate() <#onCreate>`__
         when the activity is restarted. If this attribute is set to
         ``"true"``, ``onSaveInstanceState()`` might not be called, and
         ``onCreate()`` is passed ``null`` instead of the ``Bundle``, as
         it is when the activity starts for the first time.

         A ``"true"`` setting means that the activity can be restarted
         without retained state. For example, the activity that displays
         the Home screen uses this setting to make sure that it doesn't
         get removed if it crashes for some reason.

      ``android:supportsPictureInPicture``
         Specifies whether the activity supports
         `picture-in-picture <#>`__
         display.

      ``android:taskAffinity``
         The task that the activity has an affinity for. Activities with
         the same affinity conceptually belong to the same task, to the
         same "application" from the user's perspective. The affinity of
         a task is determined by the affinity of its root activity.

         The affinity determines two things: the task that the activity
         is re-parented to (see the
         `allowTaskReparenting <#reparent>`__
         attribute) and the task that houses the activity when it
         launches with the
         `FLAG_ACTIVITY_NEW_TASK <#FLAG_ACTIVITY_NEW_TASK>`__
         flag.

         By default, all activities in an application have the same
         affinity. You can set this attribute to group them differently,
         and even place activities defined in different applications
         within the same task. To specify that the activity doesn't have
         an affinity for any task, set it to an empty string.

         If this attribute isn't set, the activity inherits the affinity
         set for the application. See the
         ``<application>``
         element's
         `taskAffinity <#aff>`__
         attribute. The name of the default affinity for an application
         is the
         `namespace <#set-namespace>`__
         set in the ``build.gradle`` file.

      ``android:theme``
         A reference to a style resource defining an overall theme for
         the activity. This automatically sets the activity's context to
         use this
         `theme <#setTheme>`__
         and might also cause "starting" animations prior to the
         activity being launched, to better match what the activity
         actually looks like.

         If this attribute isn't set, the activity inherits the theme
         set for the application as a whole, from the
         ``<application>``
         element's
         `theme <#theme>`__
         attribute. If that attribute is also not set, the default
         system theme is used. For more information, see `Styles and themes <#>`__.

      ``android:uiOptions``
         Extra options for an activity's UI. Must be one of the
         following values.

         .. list-table::
            :header-rows: 1

            - 

               - Value
               - Description
            - 

               - ``"none"``
               - No extra UI options. This is the default.
            - 

               - ``"splitActionBarWhenNarrow"``
               - Adds a bar at the bottom of the screen to display
                  action items in the *app bar*, also known as the
                  *action bar*, when constrained for horizontal space,
                  such as when in portrait mode on a handset. Instead of
                  a small number of action items appearing in the app
                  bar at the top of the screen, the app bar is split
                  into the top navigation section and the bottom bar for
                  action items. This means a reasonable amount of space
                  is made available not only for the action items, but
                  also for navigation and title elements at the top.
                  Menu items are not split across the two bars. They
                  always appear together.

         For more information about the app bar, see `Add the app bar <#>`__.

         This attribute was added in API level 14.

      ``android:windowSoftInputMode``
         How the main window of the activity interacts with the window
         containing the on-screen soft keyboard. The setting for this
         attribute affects two things:

         -  Whether the soft keyboard is hidden or visible when the
            activity becomes the focus of user attention.
         -  Whether the activity's main window is resized smaller to
            make room for the soft keyboard or its contents pan to make
            the current focus visible when part of the window is covered
            by the soft keyboard.

         The setting must be one of the values listed in the following
         table or a combination of one ``"state..."`` value plus one
         ``"adjust..."`` value. Setting multiple values in either group,
         such as multiple ``"state..."`` values, has undefined results.
         Individual values are separated by a vertical bar (``|``), as
         shown in the following example:

         .. code:: prettyprint

            <activity android:windowSoftInputMode="stateVisible|adjustResize" ... >

         Values set here (other than ``"stateUnspecified"`` and
         ``"adjustUnspecified"``) override values set in the theme.

         Value

   introduced in:
      API level 1 for all attributes except `noHistory <#nohist>`__
      and `windowSoftInputMode <#wsoft>`__, which were added in API
      level 3.
   see also:
      ``<application>``
      ``<activity-alias>``

Last updated 2024-02-02 UTC.


/manifest activity-alias
========================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <activity-alias android:enabled=["true" | "false"]
                         android:exported=["true" | "false"]
                         android:icon="drawable resource"
                         android:label="string resource"
                         android:name="string"
                         android:permission="string"
                         android:targetActivity="string" >
             ...
         </activity-alias>

   contained in:
      ``<application>``
   can contain:
      ``<intent-filter>``
      ``<meta-data>``
   description:
      An alias for an activity, named by the ``targetActivity``
      attribute. The target must be in the same application as the alias
      and declared before the alias in the manifest.

      The alias presents the target activity as an independent entity,
      and can have its own set of intent filters. They, rather than the
      intent filters on the target activity itself, determine which
      intents can activate the target through the alias and how the
      system treats the alias.

      For example, the intent filters on the alias might specify the
      `"android.intent.action.MAIN" <#ACTION_MAIN>`__
      and
      `"android.intent.category.LAUNCHER" <#CATEGORY_LAUNCHER>`__"
      flags, causing it to be represented in the application launcher,
      even though none of the filters on the target activity itself set
      these flags.

      With the exception of ``targetActivity``, ``<activity-alias>``
      attributes are a subset of
      ``<activity>``
      attributes. For attributes in the subset, none of the values set
      for the target carry over to the alias. However, for attributes
      not in the subset, the values set for the target activity also
      apply to the alias.

   attributes:
      ``android:enabled``
         Whether the target activity can be instantiated by the system
         through this alias. ``"true"`` if it can be, and ``"false"`` if
         not. The default value is ``"true"``.

         The
         ``<application>``
         element has its own
         `enabled <#enabled>`__
         attribute that applies to all application components, including
         activity aliases. The ``<application>`` and
         ``<activity-alias>`` attributes must both be ``"true"`` for the
         system to be able to instantiate the target activity through
         the alias. If either is ``"false"``, the alias doesn't work.

      ``android:exported``
         Whether the components of other applications can launch the
         target activity through this alias. ``"true"`` if they can, and
         ``"false"`` if not. If ``"false"``, the target activity can be
         launched through the alias only by components of the same
         application as the alias or applications with the same user ID.

         The default value depends on whether the alias contains intent
         filters. The absence of any filters means that the activity can
         be invoked through the alias only by specifying the exact name
         of the alias. This implies that the alias is intended only for
         application-internal use, since others don't know its name. So,
         the default value is ``"false"``. On the other hand, the
         presence of at least one filter implies that the alias is
         intended for external use, so the default value is ``"true"``.

      ``android:icon``
         An icon for the target activity when presented to users through
         the alias. For more information, see the
         ``<activity>``
         element's
         `icon <#icon>`__
         attribute.
      ``android:label``
         A user-readable label for the alias when presented to users
         through the alias. For more information, see the
         ``<activity>``
         element's
         `label <#label>`__
         attribute.
      ``android:name``
         A unique name for the alias. The name resembles a fully
         qualified class name. But, unlike the name of the target
         activity, the alias name is arbitrary. It doesn't refer to an
         actual class.
      ``android:permission``
         The name of a permission that clients must have to launch the
         target activity or get it to do something using the alias. If a
         caller of
         `startActivity() <#startActivity>`__
         or
         `startActivityForResult() <#startActivityForResult>`__
         isn't granted the specified permission, the target activity
         isn't activated.

         This attribute supplants any permission set for the target
         activity itself. If it isn't set, a permission isn't needed to
         activate the target through the alias.

         For more information about permissions, see the
         `Permissions <#perms>`__
         section in the app manifest overview.

      ``android:targetActivity``
         The name of the activity that can be activated through the
         alias. This name must match the ``name`` attribute of an
         ``<activity>``
         element that precedes the alias in the manifest.

   introduced in:
      API level 1
   see also:
      ``<activity>``

Last updated 2023-05-04 UTC.


/manifest application
=====================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <application android:allowTaskReparenting=["true" | "false"]
                      android:allowBackup=["true" | "false"]
                      android:allowClearUserData=["true" | "false"]
                      android:allowNativeHeapPointerTagging=["true" | "false"]
                      android:appCategory=["accessibility" | "audio" | "game" |
                      "image" | "maps" | "news" | "productivity" | "social" | "video"]
                      android:backupAgent="string"
                      android:backupInForeground=["true" | "false"]
                      android:banner="drawable resource"
                      android:dataExtractionRules="string resource"
                      android:debuggable=["true" | "false"]
                      android:description="string resource"
                      android:enabled=["true" | "false"]
                      android:extractNativeLibs=["true" | "false"]
                      android:fullBackupContent="string"
                      android:fullBackupOnly=["true" | "false"]
                      android:gwpAsanMode=["always" | "never"]
                      android:hasCode=["true" | "false"]
                      android:hasFragileUserData=["true" | "false"]
                      android:hardwareAccelerated=["true" | "false"]
                      android:icon="drawable resource"
                      android:isGame=["true" | "false"]
                      android:isMonitoringTool=["parental_control" | "enterprise_management" |
                      "other"]
                      android:killAfterRestore=["true" | "false"]
                      android:largeHeap=["true" | "false"]
                      android:label="string resource"
                      android:logo="drawable resource"
                      android:manageSpaceActivity="string"
                      android:name="string"
                      android:networkSecurityConfig="xml resource"
                      android:permission="string"
                      android:persistent=["true" | "false"]
                      android:process="string"
                      android:restoreAnyVersion=["true" | "false"]
                      android:requestLegacyExternalStorage=["true" | "false"]
                      android:requiredAccountType="string"
                      android:resizeableActivity=["true" | "false"]
                      android:restrictedAccountType="string"
                      android:supportsRtl=["true" | "false"]
                      android:taskAffinity="string"
                      android:testOnly=["true" | "false"]
                      android:theme="resource or theme"
                      android:uiOptions=["none" | "splitActionBarWhenNarrow"]
                      android:usesCleartextTraffic=["true" | "false"]
                      android:vmSafeMode=["true" | "false"] >
             . . .
         </application>

   contained in:
      ``<manifest>``
   can contain:
      ``<activity>``
      ``<activity-alias>``
      ``<meta-data>``
      ``<service>``
      ``<receiver>``
      ``<profileable>``
      ``<provider>``
      ``<uses-library>``
      ``<uses-native-library>``
   description:
      The declaration of the application. This element contains
      subelements that declare each of the application's components and
      has attributes that can affect all the components.

      Many of these attributes, such as ``icon``, ``label``,
      ``permission``, ``process``, ``taskAffinity``, and
      ``allowTaskReparenting``, set default values for corresponding
      attributes of the component elements. Others, such as
      ``debuggable``, ``enabled``, ``description``, and
      ``allowClearUserData``, set values for the application as a whole
      and aren't overridden by the components.

   attributes
      ``android:allowTaskReparenting``
         Whether activities that the application defines can move from
         the task that started them to the task they have an affinity
         for when that task is next brought to the front. It's
         ``"true"`` if they can move, and ``"false"`` if they must
         remain with the task where they started. The default value is
         ``"false"``.

         The
         ``<activity>``
         element has its own
         `allowTaskReparenting <#reparent>`__
         attribute that can override the value set here.

      ``android:allowBackup``
         Whether to let the application participate in the backup and
         restore infrastructure. If this attribute is set to
         ``"false"``, no backup or restore of the application is ever
         performed, even by a full-system backup that otherwise causes
         all application data to save using ``adb``. The default value
         of this attribute is ``"true"``.

         .. note::

            **Note:** For apps targeting Android 12 (API level 31) or
            higher, this behavior varies. On devices from some device
            manufacturers, you can't disable device-to-device migration
            of your app's files.

            However, you can disable cloud-based backup and restore of
            your app's files by setting this attribute to ``"false"``,
            even if your app targets Android 12 (API level 31) or
            higher.

            For more information, see the `backup and restore <#backup-restore>`__
            section of the page that describes behavior changes for apps
            targeting Android 12 (API level 31) or higher.

      ``android:allowClearUserData``
         Whether to let the application reset user data. This data
         includes flags, such as whether the user has seen introductory
         tooltips, as well as user-customizable settings and
         preferences. The default value of this attribute is ``"true"``.

         **Note:** Only apps that are part of the system image can
         declare this attribute explicitly. Third-party apps can't
         include this attribute in their manifest files.

         For more information, see `Data backup overview <#>`__.

      ``android:allowNativeHeapPointerTagging``
         Whether the app enables the Heap pointer tagging feature. The
         default value of this attribute is ``"true"``.

         **Note:** Disabling this feature **doesn't** address the
         underlying code health issue. Future hardware devices might not
         support this manifest tag.

         For more information, see `Tagged Pointers <https://source.android.google.cn/devices/tech/debug/tagged-pointers>`__.

      ``android:appCategory``
         Declares the category of this app. Categories are used to
         cluster multiple apps together into meaningful groups, such as
         when summarizing battery, network, or disk usage. Only define
         this value for apps that fit well into one of the specific
         categories.

         Must be one of the following constant values.

         .. list-table::
            :header-rows: 1

            - 

               - Value
               - Description
            - 

               - ``accessibility``
               - Apps that are primarily accessibility apps, such as
                  screen-readers.
            - 

               - ``audio``
               - Apps that primarily work with audio or music, such as
                  music players.
            - 

               - ``game``
               - Apps that are primarily games.
            - 

               - ``image``
               - Apps that primarily work with images or photos, such as
                  camera or gallery apps.
            - 

               - ``maps``
               - Apps that are primarily map apps, such as navigation
                  apps.
            - 

               - ``news``
               - Apps that are primarily news apps, such as newspapers,
                  magazines, or sports apps.
            - 

               - ``productivity``
               - Apps that are primarily productivity apps, such as
                  cloud storage or workplace apps.
            - 

               - ``social``
               - Apps that are primarily social apps, such as messaging,
                  communication, email, or social network apps.
            - 

               - ``video``
               - Apps that primarily work with video or movies, such as
                  streaming video apps.

      ``android:backupAgent``
         The name of the class that implements the application's backup
         agent, a subclass of
         `BackupAgent <#>`__.
         The attribute value is a fully qualified class name, such as
         ``"com.example.project.MyBackupAgent"``. However, as a
         shorthand, if the first character of the name is a period, for
         example, ``".MyBackupAgent"``, it is appended to the package
         name specified in the
         ``<manifest>``
         element.

         There is no default. The name must be specific.

      ``android:backupInForeground``
         Indicates that `Auto Backup <#>`__
         operations can be performed on this app even if the app is in a
         foreground-equivalent state. The system shuts down an app
         during auto backup operation, so use this attribute with
         caution. Setting this flag to ``"true"`` can impact app
         behavior while the app is active.

         The default value is ``"false"``, which means that the OS
         avoids backing up the app while it's running in the foreground,
         such as a music app that is actively playing music using a
         service in the
         `startForeground() <#startForeground>`__
         state.

      ``android:banner``
         A `drawable resource <#>`__
         providing an extended graphical banner for its associated item.
         Use with the ``<application>`` tag to supply a default banner
         for all application activities or with the
         ``<activity>``
         tag to supply a banner for a specific activity.

         The system uses the banner to represent an app in the Android
         TV home screen. Therefore, only specify this for applications
         with an activity that handles the
         `CATEGORY_LEANBACK_LAUNCHER <#CATEGORY_LEANBACK_LAUNCHER>`__
         intent.

         This attribute is set as a reference to a drawable resource
         containing the image, for example ``"@drawable/banner"``. There
         is no default banner.

         For more information, see `Provide a home screen banner <#banner>`__.

      ``android:dataExtractionRules``
         Applications can set this attribute to an XML resource where
         they specify the rules determining which files and directories
         can be copied from the device as part of backup or transfer
         operations.

         For information about the format of the XML file, see `Backup and restore <#backup-restore>`__.

      ``android:debuggable``
         Whether the application can be debugged, even when running on a
         device in user mode. It's ``"true"`` if it can be and
         ``"false"`` if not. The default value is ``"false"``.
      ``android:description``
         User-readable text about the application, which is longer and
         more descriptive than the application label. The value is set
         as a reference to a string resource. Unlike the label, it can't
         be a raw string. There is no default value.
      ``android:enabled``
         Whether the Android system can instantiate components of the
         application. It's ``"true"`` if it can and ``"false"`` if not.
         If the value is ``"true"``, each component's ``enabled``
         attribute determines whether that component is enabled. If the
         value is ``"false"``, it overrides the component-specific
         values, and all components are disabled.

         The default value is ``"true"``.

      ``android:extractNativeLibs``
         This attribute indicates whether the package installer extracts
         native libraries from the APK to the file system. If set to
         ``"false"``, your native libraries are stored uncompressed in
         the APK. Although your APK might be larger, your application
         loads faster because the libraries load directly from the APK
         at runtime.

         The default value of ``extractNativeLibs`` depends on
         ``minSdkVersion`` and the version of AGP you're using. In most
         cases, the default behavior is probably what you want, and you
         don't have to set this attribute explicitly.

      ``android:fullBackupContent``
         This attribute points to an XML file that contains full backup
         rules for `Auto Backup <#>`__.
         These rules determine what files get backed up. For more
         information, see the `XML config syntax <#XMLSyntax>`__ for Auto
         Backup.

         This attribute is optional. If it is not specified, by default,
         Auto Backup includes most of your app's files. For more
         information, see `Files that are backed up <#Files>`__.

      ``android:fullBackupOnly``
         This attribute indicates whether to use `Auto Backup <#>`__ on devices where it
         is available. If set to ``"true"``, then your app performs Auto
         Backup when installed on a device running Android 6.0 (API
         level 23) or higher. On older devices, your app ignores this
         attribute and performs `key/value backups <#>`__.

         The default value is ``"false"``.

      ``android:gwpAsanMode``
         This attribute indicates whether to use
         `GWP-ASan <#>`__, a native memory allocator
         feature that helps find use-after-free and heap-buffer-overflow
         bugs.

         The default value is ``"never"``.

      ``android:hasCode``
         Whether the application contains any DEX code‚Äîthat is, code
         using the Kotlin or Java programming language. It's ``"true"``
         if it does and ``"false"`` if not. When the value is
         ``"false"``, the system doesn't try to load any application
         code when launching components. The default value is
         ``"true"``.

         If the application includes native (C/C++) code, but no DEX
         code, this should be set to ``"false"``. If set to ``"true"``
         when the APK contains no DEX code, the app may fail to load.

         **This property must account for code included in the
         application by dependencies.** If the application depends on an
         AAR that uses Java/Kotlin code, or directly on a JAR,
         ``app:hasCode`` must be ``"true"``, or omitted as that is the
         default.

         For example, your app might support `Play feature delivery <#>`__ and include
         feature modules that don't generate any DEX files, which is
         bytecode optimized for the Android platform. If so, you need to
         set this property to ``"false"`` in the module's manifest file
         to avoid runtime errors.

      ``android:hasFragileUserData``
         Whether to show the user a prompt to keep the app's data when
         the user uninstalls the app. The default value is ``"false"``.
      ``android:hardwareAccelerated``
         Whether hardware-accelerated rendering is enabled for all
         activities and views in this application. It's ``"true"`` if it
         is enabled and ``"false"`` if not. The default value is
         ``"true"`` if you set either
         `minSdkVersion <#min>`__
         or
         `targetSdkVersion <#target>`__
         to ``"14"`` or higher. Otherwise, it's ``"false"``.

         Starting from Android 3.0 (API level 11), a
         hardware-accelerated OpenGL renderer is available to
         applications to improve performance for many common 2D graphics
         operations. When the hardware-accelerated renderer is enabled,
         most operations in Canvas, Paint, Xfermode, ColorFilter,
         Shader, and Camera are accelerated.

         This results in smoother animations, smoother scrolling, and
         improved responsiveness overall, even for applications that
         don't explicitly make use the framework's OpenGL libraries.

         Not all of the OpenGL 2D operations are accelerated. If you
         enable the hardware-accelerated renderer, test your application
         so that it can make use of the renderer without errors.

         For more information, read the `Hardware acceleration <#>`__ guide.

      ``android:icon``
         An icon for the application as whole and the default icon for
         each of the application's components. See the individual
         ``icon`` attributes for the
         ``<activity>``,
         ``<activity-alias>``,
         ``<service>``,
         ``<receiver>``,
         and
         ``<provider>``
         elements.

         This attribute is set as a reference to a drawable resource
         containing the image, such as ``"@drawable/icon"``. There is no
         default icon.

      ``android:isGame``
         Whether the application is a game. The system might group
         together applications classified as games or display them
         separately from other applications. The default is ``"false"``.
      ``android:isMonitoringTool``
         Indicates that this application is designed to monitor other
         individuals.

         **Note:** If an app declares this attribute in its manifest,
         the developer must follow the
         `Stalkerware <https://support.google.com/googleplay/android-developer/answer/9888380#commercial-spyware>`__
         policy to publish the app to Google Play.

         There is no default value. The developer must specify one of
         the following values:

         .. list-table::
            :header-rows: 1

            - 

               - Value
               - Description
            - 

               - ``"parental_control"``
               - App caters to parental control and is specifically
                  targeted at parents who want to keep their kids safe.
            - 

               - ``"enterprise_management"``
               - App caters to enterprises that want to manage and track
                  devices given to employees.
            - 

               - ``"other"``
               - App caters to a use case not otherwise specified in
                  this table.

      ``android:killAfterRestore``
         Whether the application terminates after its settings have been
         restored during a full-system restore operation. Single-package
         restore operations never cause the application to shut down.
         Full-system restore operations typically only occur once, when
         the phone is first set up. Third-party applications don't
         normally need to use this attribute.

         The default is ``"true"``, which means that after the
         application finishes processing its data during a full-system
         restore, it terminates.

      ``android:largeHeap``
         Whether the application's processes are created with a large
         Dalvik heap. This applies to all processes created for the
         application. It only applies to the first application loaded
         into a process. If you're using a shared user ID to let
         multiple applications use a process, they all must use this
         option consistently to avoid unpredictable results.

         Most apps don't need this and instead focus on reducing their
         overall memory usage for improved performance. Enabling this
         also doesn't guarantee a fixed increase in available memory,
         because some devices are constrained by their total available
         memory.

         To query the available memory size at runtime, use the methods
         `getMemoryClass() <#getMemoryClass>`__
         or
         `getLargeMemoryClass() <#getLargeMemoryClass>`__.

      ``android:label``
         A user-readable label for the application as a whole and a
         default label for each of the application's components. See the
         individual ``label`` attributes for the
         ``<activity>``,
         ``<activity-alias>``,
         ``<service>``,
         ``<receiver>``,
         and
         ``<provider>``
         elements.

         The label is set as a reference to a string resource, so that
         it can be localized like other strings in the user interface.
         However, as a convenience while you're developing the
         application, it can also be set as a raw string.

      ``android:logo``
         A logo for the application as whole and the default logo for
         activities. This attribute is set as a reference to a drawable
         resource containing the image, such as ``"@drawable/logo"``.
         There is no default logo.
      ``android:manageSpaceActivity``
         The fully qualified name of an ``Activity`` subclass that the
         system launches to let users manage the memory occupied by the
         application on the device. The activity is also declared with
         an ``<activity>``
         element.
      ``android:name``
         The fully qualified name of an
         `Application <#>`__
         subclass implemented for the application. When the application
         process is started, this class is instantiated before any of
         the application's components.

         The subclass is optional. Most applications don't need one. In
         the absence of a subclass, Android uses an instance of the base
         ``Application`` class.

      ``android:networkSecurityConfig``
         Specifies the name of the XML file that contains your
         application's `Network security configuration <#>`__. The
         value is a reference to the XML resource file containing the
         configuration.

         This attribute was added in API level 24.

      ``android:permission``
         The name of a permission that clients need in order to interact
         with the application. This attribute is a convenient way to set
         a permission that applies to all of the application's
         components. It is overwritten by setting the ``permission``
         attributes of individual components.

         For more information about permissions, see the
         `Permissions <#perms>`__
         section in the app manifest overview and `Security tips <#>`__.

      ``android:persistent``
         Whether the application remains running at all times. It's
         ``"true"`` if it does and ``"false"`` if not. The default value
         is ``"false"``. Applications don't normally set this flag.
         Persistence mode is intended only for certain system
         applications.
      ``android:process``
         The name of a process where all components of the application
         run. Each component can override this default by setting its
         own ``process`` attribute.

         By default, Android creates a process for an application when
         the first of its components needs to run. All components then
         run in that process. The name of the default process matches
         the package name set by the
         ``<manifest>``
         element.

         By setting this attribute to a process name that's shared with
         another application, you can arrange for components of both
         applications to run in the same process, but only if the two
         applications also share a user ID and are signed with the same
         certificate.

         If the name assigned to this attribute begins with a colon
         (``:``), a new process, private to the application, is created
         when it's needed. If the process name begins with a lowercase
         character, a global process of that name is created. A global
         process can be shared with other applications, reducing
         resource usage.

      ``android:restoreAnyVersion``
         Indicates that the application is prepared to attempt a restore
         of any backed-up data set, even if the backup was stored by a
         newer version of the application than is currently installed on
         the device. Setting this attribute to ``"true"`` lets the
         Backup Manager attempt a restore even when a version mismatch
         suggests that the data is incompatible. *Use with caution!*

         The default value of this attribute is ``"false"``.

      ``android:requestLegacyExternalStorage``
         Whether the application wants to opt out of `scoped storage <#>`__.

         **Note:** Depending on changes related to policy or app
         compatibility, the system might not honor this opt-out request.

      ``android:requiredAccountType``
         Specifies the account type required by the application to
         function. If your app requires an
         `Account <#>`__, the
         value for this attribute must correspond to the account
         authenticator type used by your app, as defined by
         `AuthenticatorDescription <#>`__,
         such as ``"com.google"``.

         The default value is null and indicates that the application
         can work *without* any accounts.

         Because restricted profiles can't add accounts, specifying this
         attribute makes your app unavailable from a restricted profile
         unless you also declare
         `android:restrictedAccountType <#restrictedAccountType>`__
         with the same value.

         **Caution:** If the account data might reveal personally
         identifiable information, it's important that you declare this
         attribute and leave
         `android:restrictedAccountType <#restrictedAccountType>`__
         null, so that restricted profiles cannot use your app to access
         personal information that belongs to the owner user.

         This attribute was added in API level 18.

      ``android:resizeableActivity``
         Specifies whether the app supports `multi-window mode <#>`__. You can set this
         attribute in either the
         ``<activity>`` or
         ``<application>`` element.

         If you set this attribute to ``"true"``, the user can launch
         the activity in split-screen and free-form modes. If you set
         the attribute to ``‚Äùfalse‚Äù``, the app can't be tested or
         optimized for a multi-window environment. The system can still
         put the activity in multi-window mode with compatibility mode
         applied.

         Setting this attribute to ``"true"`` doesn't guarantee that
         there are no other apps in multi-window mode visible on screen,
         such as picture-in-picture, or on other displays. Therefore,
         setting this flag doesn't mean that your app has exclusive
         resource access.

         For apps targeting API level 24 or higher, the default is
         ``"true"``.

         If your app targets API level 31 or higher, this attribute
         works differently on small and large screens:

         -  **Large screens (sw >= 600dp):** all apps support
            multi-window mode. The attribute indicates whether an app
            can be resized, not whether the app supports multi-window
            mode. If ``resizeableActivity="false"``, the app is put into
            compatibility mode when necessary to conform to display
            dimensions.
         -  **Small screens (sw < 600dp):** if
            ``resizeableActivity="true"`` and the minimum width and
            minimum height of the main activity are within the
            multi-window requirements, the app supports multi-window
            mode. If ``resizeableActivity="false"``, the app doesn't
            support multi-window mode regardless of the activity minimum
            width and height.

         **Note:** Device manufacturers can override the API level 31
         behavior.

         This attribute was added in API level 24.

         **Note:** A task's root activity value is applied to all
         additional activities launched in the task. That is, if the
         root activity of a task is resizable, then the system treats
         all other activities in the task as resizable. If the root
         activity is not resizable, the other activities in the task are
         not resizable.

      ``android:restrictedAccountType``
         Specifies the account type required by this application and
         indicates that restricted profiles can access such accounts
         that belong to the owner user. If your app requires an
         `Account <#>`__ and
         restricted profiles *can* access the primary user's accounts,
         the value for this attribute must correspond to the account
         authenticator type used by your app, as defined by
         `AuthenticatorDescription <#>`__,
         such as ``"com.google"``.

         The default value is null and indicates that the application
         can work *without* any accounts.

         **Caution:** Specifying this attribute lets restricted profiles
         use your app with accounts that belong to the owner user, which
         might reveal personally identifiable information. If the
         account might reveal personal details, *don‚Äôt* use this
         attribute. Instead, declare the
         `android:requiredAccountType <#requiredAccountType>`__
         attribute to make your app unavailable to restricted profiles.

         This attribute was added in API level 18.

      ``android:supportsRtl``
         Declares whether your application is willing to support
         right-to-left (RTL) layouts.

         If this is set to ``"true"`` and
         `targetSdkVersion <#target>`__
         is set to 17 or higher, various RTL APIs are activated and used
         by the system so your app can display RTL layouts. If this is
         set to ``"false"`` or if ``targetSdkVersion`` is set to 16 or
         lower, the RTL APIs are ignored or have no effect, and your app
         behaves the same regardless of the layout direction associated
         to the user's locale choice. That is, your layouts are always
         left-to-right.

         The default value of this attribute is ``"false"``.

         This attribute was added in API level 17.

      ``android:taskAffinity``
         An affinity name that applies to all activities within the
         application, except for those that set a different affinity
         with their own
         `taskAffinity <#aff>`__
         attributes. See that attribute for more information.

         By default, all activities within an application share the same
         affinity. The name of that affinity is the same as the package
         name set by the
         ``<manifest>``
         element.

      ``android:testOnly``
         Indicates whether this application is only for testing
         purposes. For example, it might expose functionality or data
         outside of itself that can cause a security hole, but be useful
         for testing. This kind of APK only installs through
         `adb <#>`__. You can't publish it to
         Google Play.

         Android Studio automatically adds this attribute when you click
         **Run** |image-toolbar-run|.

      .. |image-toolbar-run| image:: https://developer.android.google.cn/static/studio/images/buttons/toolbar-run.png
         :class: inline-icon

      ``android:theme``
         A reference to a style resource defining a default theme for
         all activities in the application. Individual activities can
         override the default by setting their own
         `theme <#theme>`__
         attributes. For more information, see `Styles and themes <#>`__.
      ``android:uiOptions``
         Extra options for an activity's UI. Must be one of the
         following values:

         .. list-table::
            :header-rows: 1

            - 

               - Value
               - Description
            - 

               - ``"none"``
               - No extra UI options. This is the default.
            - 

               - ``"splitActionBarWhenNarrow"``
               - Adds a bar at the bottom of the screen to display
                  action items in the *app bar*, also known as the
                  *action bar*, when constrained for horizontal space,
                  such as when in portrait mode on a handset. Instead of
                  a small number of action items appearing in the app
                  bar at the top of the screen, the app bar splits into
                  the top navigation section and the bottom bar for
                  action items. This means a reasonable amount of space
                  is available for the action items and for the
                  navigation and title elements at the top. Menu items
                  aren't split across the two bars. They always appear
                  together.

         For more information about the app bar, see `Add the app bar <#>`__.

         This attribute was added in API level 14.

      ``android:usesCleartextTraffic``
         Indicates whether the app intends to use cleartext network
         traffic, such as cleartext HTTP. The default value for apps
         that target API level 27 or lower is ``"true"``. Apps that
         target API level 28 or higher default to ``"false"``.

         When the attribute is set to ``"false"``, platform components,
         for example, HTTP and FTP stacks,
         `DownloadManager <#>`__,
         and `MediaPlayer <#>`__,
         refuse the app's requests to use cleartext traffic.

         Third-party libraries are strongly encouraged to honor this
         setting as well. The key reason for avoiding cleartext traffic
         is the lack of confidentiality, authenticity, and protections
         against tampering. A network attacker can eavesdrop on
         transmitted data and also modify it without being detected.

         This flag is honored on a best-effort basis because it's
         impossible to prevent all cleartext traffic from Android
         applications given the level of access provided to them. For
         example, there's no expectation that the
         `Socket <#>`__ API honors this
         flag, because it can't determine whether its traffic is in
         cleartext.

         However, most network traffic from applications is handled by
         higher-level network stacks and components, which can honor
         this flag by either reading it from
         `ApplicationInfo.flags <#flags>`__
         or
         `NetworkSecurityPolicy.isCleartextTrafficPermitted() <#isCleartextTrafficPermitted>`__.

         **Note:** `WebView <#>`__
         honors this attribute for applications targeting API level 26
         and higher.

         During app development, StrictMode can be used to identify any
         cleartext traffic from the app. For more information, see
         `StrictMode.VmPolicy.Builder.detectCleartextNetwork() <#detectCleartextNetwork>`__.

         This attribute was added in API level 23.

         This flag is ignored on Android 7.0 (API level 24) and above if
         an Android Network Security Config is present.

      ``android:vmSafeMode``
         Indicates whether the app wants the virtual machine (VM) to
         operate in safe mode. The default value is ``"false"``.

         This attribute was added in API level 8, where a value of
         ``"true"`` disabled the Dalvik just-in-time (JIT) compiler.

         This attribute was adapted in API level 22, where a value of
         ``"true"`` disabled the ART ahead-of-time (AOT) compiler.

   introduced in:
      API level 1
   see also:
      ``<activity>``
      ``<service>``
      ``<receiver>``
      ``<provider>``

Last updated 2024-04-19 UTC.


/manifest category
==================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <category android:name="string" />

   contained in:
      ``<intent-filter>``
   description:
      Adds a category name to an intent filter. See `Intents and Intent Filters <#>`__ for details on
      intent filters and the role of category specifications within a
      filter.
   attributes:
      ``android:name``
         The name of the category. Standard categories are defined in
         the `Intent <#>`__ class as
         ``CATEGORY_``\ *``name``* constants. The name assigned here is
         derived from those constants by prefixing
         ``android.intent.category.`` to the *``name``* that follows
         ``CATEGORY_``. For example, the string value for
         ``CATEGORY_LAUNCHER`` is ``android.intent.category.LAUNCHER``.

         **Note:** To receive implicit intents, you must include the
         `CATEGORY_DEFAULT <#CATEGORY_DEFAULT>`__
         category in the intent filter. The methods
         `startActivity() <#startActivity>`__
         and
         `startActivityForResult() <#startActivityForResult>`__
         treat all intents as if they declared the
         `CATEGORY_DEFAULT <#CATEGORY_DEFAULT>`__
         category. If you don't declare it in your intent filter, no
         implicit intents can resolve your activity.

         For custom categories, use the package name as a prefix so that
         they are unique.

   introduced in:
      API Level 1
   see also:
      ``<action>``
      ``<data>``

Last updated 2023-03-22 UTC.


/manifest compatible-screens
============================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <compatible-screens>
             <screen android:screenSize=["small" | "normal" | "large" | "xlarge"]
                     android:screenDensity=["ldpi" | "mdpi" | "hdpi" | "xhdpi"
                                            | "280" | "360" | "420" | "480" | "560" ] />
             ...
         </compatible-screens>

   contained in:
      ``<manifest>``
   description:
      Specifies each screen configuration with which the application is
      compatible. Only one instance of the ``<compatible-screens>``
      element is allowed in the manifest, but it can contain multiple
      ``<screen>`` elements. Each ``<screen>`` element specifies a
      specific screen size-density combination with which the
      application is compatible.

      The Android system *doesn't* read the ``<compatible-screens>``
      manifest element at any point. This element is informational only
      and is used by external services, such as Google Play, to better
      understand the application's compatibility with specific screen
      configurations and to enable filtering for users.

      Any screen configuration that *isn't* declared in this element is
      a screen with which the application *isn't* compatible. External
      services, such as Google Play, don't provide the application to
      devices with such screens.

      **Caution:** Normally, *you don't use this manifest element*.
      Using this element can dramatically reduce the potential user base
      for your application by preventing users from installing your
      application if they have a device with a screen configuration that
      you don't list. Use it only as a last resort, when the application
      absolutely doesn't work with specific screen configurations.
      Instead of using this element, follow the guide to `supporting multiple screens <#>`__ to provide
      scalable support for multiple screens using alternative layouts
      and bitmaps for different screen sizes and densities.

      If you want to set a minimum screen size for your your
      application, use the
      ``<supports-screens>``
      element. For example, if you want your application to be available
      only for large and extra-large screen devices, the
      ``<supports-screens>`` element lets you declare that your
      application doesn't support small and normal screen sizes. Then,
      external services like Google Play filter your application
      accordingly. You can also use the ``<supports-screens>`` element
      to declare whether the system can resize your application for
      different screen sizes.

      For more information about how Google Play filters applications
      using this and other manifest elements, see `Filters on Google Play <#>`__.

   child elements:
      ``<screen>``
         Specifies a single screen configuration with which the
         application is compatible.

         At least one instance of this element must be placed inside the
         ``<compatible-screens>`` element. This element must include
         both the ``android:screenSize`` and ``android:screenDensity``
         attributes. If you don't declare both attributes, then the
         element is ignored.

         Attributes:

         ``android:screenSize``
            **Required.** Specifies the screen size for this screen
            configuration.

            Accepted values:

            -  ``small``
            -  ``normal``
            -  ``large``
            -  ``xlarge``

            For information about the different screen sizes, see
            `Screen compatibility overview <#sizes>`__.

         ``android:screenDensity``
            **Required.** Specifies the screen density for this screen
            configuration.

            Accepted values:

            -  ``"ldpi"`` (approximately 120 dpi)
            -  ``"mdpi"`` (approximately 160 dpi)
            -  ``"hdpi"`` (approximately 240 dpi)
            -  ``"xhdpi"`` (approximately 320 dpi)
            -  ``"280"``
            -  ``"360"``
            -  ``"420"``
            -  ``"480"``
            -  ``"560"``

            For information about the different screen densities, see
            `Screen compatibility overview <#density>`__.

   example
      If your application is compatible with only small and normal
      screens, regardless of screen density, then you must specify 12
      ``<screen>`` elements, because each screen size has six different
      density configurations.

      You must declare each one of these. Any combination of size and
      density that you *don't* specify is considered a screen
      configuration with which your application *isn't* compatible.
      Here's what the manifest entry looks like if your application is
      compatible with only small and normal screens:

      .. code:: prettyprint

         <manifest ... >
             ...
             <compatible-screens>
                 <!-- all small size screens -->
                 <screen android:screenSize="small" android:screenDensity="ldpi" />
                 <screen android:screenSize="small" android:screenDensity="mdpi" />
                 <screen android:screenSize="small" android:screenDensity="hdpi" />
                 <screen android:screenSize="small" android:screenDensity="xhdpi" />
                 <screen android:screenSize="small" android:screenDensity="xxhdpi" />
                 <screen android:screenSize="small" android:screenDensity="xxxhdpi" />
                 <!-- all normal size screens -->
                 <screen android:screenSize="normal" android:screenDensity="ldpi" />
                 <screen android:screenSize="normal" android:screenDensity="mdpi" />
                 <screen android:screenSize="normal" android:screenDensity="hdpi" />
                 <screen android:screenSize="normal" android:screenDensity="xhdpi" />
                 <screen android:screenSize="normal" android:screenDensity="xxhdpi" />
                 <screen android:screenSize="normal" android:screenDensity="xxxhdpi" />
             </compatible-screens>
             <application ... >
                 ...
             <application>
         </manifest>

   introduced in:
      API level 9
   see also:
      `Screen compatibility overview <#>`__
      `Filters on Google Play <#>`__

Last updated 2023-05-04 UTC.


/manifest data
==============

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <data android:scheme="string"
               android:host="string"
               android:port="string"
               android:path="string"
               android:pathPattern="string"
               android:pathPrefix="string"
               android:pathSuffix="string"
               android:pathAdvancedPattern="string"
               android:mimeType="string" />

   contained in:
      ``<intent-filter>``
   description:
      Adds a data specification to an intent filter. The specification
      is a data type, using the
      `mimeType <#mime>`__
      attribute, a URI, or both a data type and a URI. A URI is
      specified by separate attributes for each of its parts:

      ``<scheme>://<host>:<port>[<path>|<pathPrefix>|<pathPattern>|<pathAdvancedPattern>|<pathSuffix>]``

      These attributes that specify the URI format are optional, but
      also mutually dependent:

      -  If a
         `scheme <#scheme>`__
         isn't specified for the intent filter, all the other URI
         attributes are ignored.
      -  If a `host <#host>`__
         isn't specified for the filter, the ``port`` attribute and all
         the path attributes are ignored.

      All the ``<data>`` elements contained within the same
      ``<intent-filter>``
      element contribute to the same filter. So, for example, the
      following filter specification:

      .. code:: prettyprint

         <intent-filter . . . >
             <data android:scheme="something" android:host="project.example.com" />
             ...
         </intent-filter>

      is equivalent to this one:

      .. code:: prettyprint

         <intent-filter . . . >
             <data android:scheme="something" />
             <data android:host="project.example.com" />
             ...
         </intent-filter>

      You can place any number of ``<data>`` elements inside an
      ``<intent-filter>``
      to give it multiple data options. None of its attributes have
      default values.

      For information on how intent filters work, including the rules
      for how intent objects are matched against filters, see `Intents and Intent Filters <#>`__ and the
      `Intent filters <#ifs>`__
      section in the manifest file overview.

   attributes:
      ``android:scheme``
         The scheme part of a URI. This is the minimal essential
         attribute for specifying a URI. At least one ``scheme``
         attribute must be set for the filter, or none of the other URI
         attributes are meaningful.

         A scheme is specified without the trailing colon, such as
         ``http`` rather than ``http:``.

         If the filter has a data type set (using the
         `mimeType <#mime>`__
         attribute) but no scheme, the ``content:`` and ``file:``
         schemes are assumed.

         **Note**: Scheme matching in the Android framework is
         case-sensitive, unlike the RFC. As a result, always specify
         schemes using lowercase letters.

      ``android:host``
         The host part of a URI authority. This attribute is meaningless
         unless a
         `scheme <#scheme>`__
         attribute is also specified for the filter. To match multiple
         subdomains, use an asterisk (``*``) to match zero or more
         characters in the host. For example, the host ``*.google.com``
         matches ``www.google.com``, ``.google.com``, and
         ``developer.google.com``.

         The asterisk must be the first character of the host attribute.
         For example, the host ``google.co.*`` is invalid, because the
         asterisk wildcard isn't the first character.

         **Note**: Host name matching in the Android framework is
         case-sensitive, unlike the formal RFC. As a result, always
         specify host names using lowercase letters.

      ``android:port``
         The port part of a URI authority. This attribute is meaningful
         only if the `scheme <#scheme>`__ and `host <#host>`__
         attributes are also specified for the filter.
      ``android:path``
      ``android:pathPrefix``
      ``android:pathSuffix``
      ``android:pathPattern``
      ``android:pathAdvancedPattern``
         The path part of a URI, which must begin with a ``/``. The
         ``path`` attribute specifies a complete path that is matched
         against the complete path in an ``Intent`` object. The
         ``pathPrefix`` attribute specifies a partial path that is
         matched against only the initial part of the path in the
         ``Intent`` object.

         The ``pathSuffix`` attribute is matched exactly against the
         ending part of the path in the ``Intent`` object, and this
         attribute doesn't have to begin with the ``/`` character. The
         ``pathPattern`` attribute specifies a complete path that is
         matched against the complete path in the ``Intent`` object, but
         it can contain the following wildcards:

         -  An asterisk (``*``) matches a sequence of zero to many
            occurrences of the immediately preceding character.
         -  A period followed by an asterisk (``.*``) matches any
            sequence of zero to many characters.

         The ``pathAdvancedPattern`` attribute specifies a complete
         path, which is matched against the complete path of the
         ``Intent`` object and supports the following regex-like
         patterns:

         -  A period (``.``) matches any character.
         -  A set (``[...]``) matches ranges of characters. For example
            , ``[0-5]`` matches a single digit from 0 through 5 but not
            6 through 9. ``[a-zA-Z]`` matches any letter, regardless of
            case. Sets also support the "not" ``^`` modifier.
         -  The asterisk (``*``) modifier matches the preceding pattern
            zero or more times.
         -  The plus (``+``) modifier matches the preceding pattern one
            or more times.
         -  The range (``{...}``) modifier specifies the number of times
            a pattern can match.

         The ``pathAdvancedPattern`` matcher is an evaluation
         implementation in which matching is done against the pattern in
         real time with no backtracking support.

         Because ``\`` is used as an escape character when the string is
         read from XML, before it is parsed as a pattern, you need to
         double-escape. For example, a literal ``*`` is written as
         ``\\*``, and a literal ``\`` is written as ``\\\``. This is
         like what you write when constructing the string in Java code.

         For more information about these five types of patterns, see
         the descriptions of
         `PATTERN_LITERAL <#PATTERN_LITERAL>`__,
         `PATTERN_PREFIX <#PATTERN_PREFIX>`__,
         `PATTERN_SIMPLE_GLOB <#PATTERN_SIMPLE_GLOB>`__,
         `PATTERN_SUFFIX <#PATTERN_SUFFIX>`__,
         and
         `PATTERN_ADVANCED_GLOB <#PATTERN_ADVANCED_GLOB>`__
         in the
         `PatternMatcher <#>`__
         class.

         These attributes are meaningful only if the
         `scheme <#scheme>`__ and `host <#host>`__ attributes
         are also specified for the filter.

         ``pathSuffix`` and ``pathAdvancePattern`` were introduced in
         API level 31.

      ``android:mimeType``
         A MIME media type, such as ``image/jpeg`` or
         ``audio/mpeg4-generic``. The subtype can be the asterisk
         wildcard (``*``) to indicate that any subtype matches.

         It's common for an intent filter to declare a ``<data>``
         element that includes only the ``android:mimeType`` attribute.

         **Note**: MIME type matching in the Android framework is
         case-sensitive, unlike formal RFC MIME types. As a result,
         always specify MIME types using lowercase letters.

   introduced in:
      API level 1
   see also:
      ``<action>``
      ``<category>``

Last updated 2023-05-04 UTC.


/manifest grant-uri-permission
==============================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <grant-uri-permission android:path="string"
                               android:pathPattern="string"
                               android:pathPrefix="string" />

   contained in:
      ``<provider>``
   description:
      Specifies the subsets of app data that the parent content provider
      has permission to access. Data subsets are indicated by the path
      part of a ``content:`` URI. The authority part of the URI
      identifies the content provider. Granting permission is a way of
      enabling clients of the provider that don't normally have
      permission to access its data to overcome that restriction on a
      one-time basis.

      If a content provider's
      `grantUriPermissions <#gprmsn>`__
      attribute is ``true``, permission can be granted for any of the
      data under the provider's purview. However, if that attribute is
      ``false``, permission is granted only to data subsets that are
      specified by this element. A provider can contain any number of
      ``<grant-uri-permission>`` elements. Each one can specify only one
      path, using one of the three possible attributes.

      For information about how permission is granted, see the
      ``<intent-filter>``
      element's
      `grantUriPermissions <#gprmsn>`__
      attribute.

   attributes:
      ``android:path``
      ``android:pathPrefix``
      ``android:pathPattern``
         A path identifying the data subset or subsets that permission
         can be granted for. The ``path`` attribute specifies a complete
         path. Permission can granted only to the particular data subset
         identified by that path.

         The ``pathPrefix`` attribute specifies the initial part of a
         path. Permission can be granted to all data subsets with paths
         that share that initial part. The ``pathPattern`` attribute
         specifies a complete path, but one that can contain the
         following wildcards:

         -  An asterisk (``*``) matches a sequence of zero to many
            occurrences of the immediately preceding character.

         -  A period followed by an asterisk (``.*``) matches any
            sequence of zero to many characters.

         Because ``\`` is used as an escape character when the string is
         read from XML, before it is parsed as a pattern, you need to
         double-escape. For example, a literal ``*`` is written as
         ``\\*`` and a literal ``\`` is written as ``\\\``.

         For more information about these types of patterns, see the
         descriptions of
         `PATTERN_LITERAL <#PATTERN_LITERAL>`__,
         `PATTERN_PREFIX <#PATTERN_PREFIX>`__,
         and
         `PATTERN_SIMPLE_GLOB <#PATTERN_SIMPLE_GLOB>`__
         in the
         `PatternMatcher <#>`__
         class.

   introduced in:
      API level 1
   see also:
      `grantUriPermissions <#gprmsn>`__
      attribute of the
      ``<provider>``
      element

Last updated 2023-03-29 UTC.


/manifest instrumentation
=========================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <instrumentation android:functionalTest=["true" | "false"]
                          android:handleProfiling=["true" | "false"]
                          android:icon="drawable resource"
                          android:label="string resource"
                          android:name="string"
                          android:targetPackage="string"
                          android:targetProcesses="string" />

   contained in:
      ``<manifest>``
   description:
      Declares an
      `Instrumentation <#>`__
      class that lets you monitor an application's interaction with the
      system. The ``Instrumentation`` object is instantiated before any
      of the application's components.
   attributes:
      ``android:functionalTest``
         Whether the ``Instrumentation`` class runs as a functional
         test. This is ``true`` if it does and ``false`` if not. The
         default value is ``false``.
      ``android:handleProfiling``
         Whether the ``Instrumentation`` object turns profiling on and
         off. This is ``true`` if it determines when profiling starts
         and stops and ``false`` if profiling continues the entire time
         it is running. A value of ``true`` enables the object to target
         profiling at a specific set of operations. The default value is
         ``false``.
      ``android:icon``
         An icon that represents the ``Instrumentation`` class. This
         attribute must be set as a reference to a drawable resource.
      ``android:label``
         A user-readable label for the ``Instrumentation`` class. The
         label can be set as a raw string or a reference to a string
         resource.
      ``android:name``
         The name of the ``Instrumentation`` subclass. Use a fully
         qualified class name, such as
         ``com.example.project.StringInstrumentation``. However, as a
         shorthand, if the first character of the name is a period, it
         is appended to the package name specified in the
         ``<manifest>``
         element.

         There is no default. The name must be specified.

      ``android:targetPackage``
         The application that the ``Instrumentation`` object runs
         against. An application is identified by the package name
         assigned in its manifest file by the ``<manifest>`` element.
      ``android:targetProcesses``
         The processes that the ``Instrumentation`` object runs against.
         A comma-separated list indicates that the instrumentation runs
         against those specific processes. A value of ``"*"`` indicates
         that the instrumentation runs against all processes of the app
         defined in ``android:targetPackage``.

         If this value isn't provided in the manifest, the
         instrumentation runs only against the main process of the app
         defined in ``android:targetPackage``.

         This attribute was added in API level 26.

   introduced in:
      API level 1

Last updated 2023-03-22 UTC.


/manifest intent-filter
=======================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <intent-filter android:icon="drawable resource"
                        android:label="string resource"
                        android:priority="integer" >
             ...
         </intent-filter>

   contained in:
      ``<activity>``
      ``<activity-alias>``
      ``<service>``
      ``<receiver>``
      ``<provider>``
   must contain:
      ``<action>``
   can contain:
      ``<category>``
      ``<data>``
   description:
      Specifies the types of intents that an activity, service, or
      broadcast receiver can respond to. An intent filter declares the
      capabilities of its parent component: what an activity or service
      can do and what types of broadcasts a receiver can handle.

      It opens the component to receiving intents of the advertised type
      while filtering out those that aren't meaningful for the
      component. Most of the contents of the filter are described by its
      ``<action>``,
      ``<category>``, and
      ``<data>`` subelements.

      For a more detailed discussion of filters, see `Intents and Intent Filters <#>`__ and the `Intent filters <#ifs>`__ section in
      the app manifest overview.

   attributes:
      ``android:icon``
         An icon that represents the parent activity, service, or
         broadcast receiver when that component is presented to the user
         as having the capability described by the filter.

         This attribute is set as a reference to a drawable resource
         containing the image definition. The default value is the icon
         set by the parent component's ``icon`` attribute. If the parent
         doesn't specify an icon, the default is the icon set by the
         ``<application>``
         element.

         For more information about intent filter icons, see the `Icons and labels <#iconlabel>`__
         section in the app manifest overview.

      ``android:label``
         A user-readable label for the parent component. This label,
         rather than the one set by the parent component, is used when
         the component is presented to the user as having the capability
         described by the filter.

         The label is set as a reference to a string resource so that it
         can be localized like other strings in the user interface.
         However, as a convenience while you're developing the
         application, it can also be set as a raw string.

         The default value is the label set by the parent component. If
         the parent doesn't specify a label, the default is the label
         set by the
         ``<application>``
         element's
         ``\ `label <#label>`__
         attribute.

         For more information about intent filter labels, see the `Icons and labels <#iconlabel>`__
         section in the app manifest overview.

      ``android:priority``
         The priority given to the parent component with regard to
         handling intents of the type described by the filter. This
         attribute has meaning for both activities and broadcast
         receivers.

         -  It provides information about how able an activity is to
            respond to an intent that matches the filter, relative to
            other activities that can also respond to the intent. When
            an intent can be handled by multiple activities with
            different priorities, Android considers only those with
            higher priority values as potential targets for the intent.

         -  It controls the order in which broadcast receivers are
            executed to receive broadcast messages, with those having
            higher priority values being called before those having
            lower values. The order applies only to synchronous
            messages. It's ignored for asynchronous messages.

         Use this attribute only if you need to impose a specific order
         in which the broadcasts are received or want to force Android
         to prefer one activity over others.

         The value is an integer, such as ``100``. Higher numbers have a
         higher priority. The default value is ``0``.

         In certain circumstances the requested priority is ignored and
         the value is capped to ``0``. This occurs when:

         -  A non-privileged application requests any priority >0.
         -  A privileged application requests a priority >0 for
            `ACTION_VIEW <#ACTION_VIEW>`__,
            `ACTION_SEND <#ACTION_SEND>`__,
            `ACTION_SENDTO <#ACTION_SENDTO>`__
            or
            `ACTION_SEND_MULTIPLE <#ACTION_SEND_MULTIPLE>`__.

         For more information, see
         `setPriority() <#setPriority>`__.

      ``android:order``
         The order in which the filter is processed when multiple
         filters match.

         ``order`` differs from ``priority`` in that ``priority``
         applies across apps, while ``order`` disambiguates multiple
         matching filters in a single app.

         When multiple filters can match, use a directed intent instead.

         The value is an integer, such as ``100``. Higher numbers are
         matched first. The default value is ``0``.

         This attribute was introduced in API level 28.

      ``android:autoVerify``
         Whether Android needs to verify that the Digital Asset Links
         JSON file from the specified host matches this application.

   introduced in:
      API level 1
   see also:
      ``<action>``
      ``<category>``
      ``<data>``

Last updated 2023-05-04 UTC.


/manifest layout
================

.. container:: devsite-article-body clearfix

   syntax:
   .. code:: prettyprint

      <layout android:defaultHeight="integer"
                android:defaultWidth="integer"
                android:gravity=["top" | "end" | ...]
                android:minHeight="integer"
                android:minWidth="integer" />

   contained in:
   ``<activity>``
   description:
   Contains attributes that affect how an activity behaves in
   multi-window mode.
   attributes:

   ``android:defaultHeight``
      Default height of the activity when launched in free-form mode.
   ``android:defaultWidth``
      Default width of the activity when launched in free-form mode.
   ``android:gravity``
      Initial placement of the activity when launched in free-form mode.
      See `Gravity <#>`__ for suitable
      values.
   ``android:minHeight``
      Minimum height for the activity in both split-screen and free-form
      modes. If the user moves the divider in split-screen mode to make
      an activity smaller than the specified minimum, the system crops
      the activity to the height the user requests.
   ``android:minWidth``
      Minimum width for the activity in both split-screen and free-form
      modes. If the user moves the divider in split-screen mode to make
      an activity smaller than the specified minimum, the system crops
      the activity to the width the user requests.
   introduced in:
      API Level 24
   see also:
      ``<activity>``

Last updated 2023-01-06 UTC.


/manifest manifest
==================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <manifest xmlns:android="http://schemas.android.com/apk/res/android"
                   package="string"
                   android:sharedUserId="string"
                   android:sharedUserLabel="string resource" 
                   android:sharedUserMaxSdkVersion="integer"
                   android:versionCode="integer"
                   android:versionName="string"
                   android:installLocation=["auto" | "internalOnly" | "preferExternal"] >
             ...
         </manifest>

   contained in:
      *none*
   must contain:
      ``<application>``
   can contain:
      ``<compatible-screens>``
      ``<instrumentation>``
      ``<permission>``
      ``<permission-group>``
      ``<permission-tree>``
      ``<queries>``
      ``<supports-gl-texture>``
      ``<supports-screens>``
      ``<uses-configuration>``
      ``<uses-feature>``
      ``<uses-permission>``
      ``<uses-permission-sdk-23>``
      ``<uses-sdk>``
   description:
      The root element of the ``AndroidManifest.xml`` file. It must
      contain an
      ``<application>``
      element and specify ``xmlns:android`` and ``package`` attributes.
   attributes:
      ``xmlns:android``
         Defines the Android namespace. This attribute is always set to
         ``"http://schemas.android.com/apk/res/android"``.
      ``package``
         The value of the ``package`` attribute in the APK's manifest
         file represents your app's universally unique application ID.
         It is formatted as a full Java-language-style package name for
         the Android app. The name can contain uppercase or lowercase
         letters, numbers, and underscores ('\_'). However, individual
         package name parts can only start with letters.

         Be careful not to change the ``package`` value, since that
         essentially creates a new app. Users of the previous version of
         your app don't receive an update and can't transfer their data
         between the old and new versions.

         In the Gradle-based build system, starting with AGP 7.3, don't
         set the ``package`` value in the source manifest file directly.
         For more information, see `Set the application ID <#set-application-id>`__.

      ``android:sharedUserId``
         | **This constant is deprecated as of API level 29.**
         | Shared user IDs cause non-deterministic behavior within the
           package manager. As such, their use is strongly discouraged
           and might be removed in a future version of Android. Instead,
           use proper communication mechanisms, such as services and
           content providers, to facilitate interoperability between
           shared components. Existing apps can't remove this value, as
           migrating off a shared user ID isn't supported. In these
           apps, add
           `android:sharedUserMaxSdkVersion="32" <#uidmaxsdk>`__ to
           avoid using shared user ID on new user installs.

         The name of a Linux user ID that is shared with other apps. By
         default, Android assigns each app its own unique user ID.
         However, if this attribute is set to the same value for two or
         more apps, they all share the same ID, provided that their
         certificate sets are identical. Apps with the same user ID can
         access each other's data and, if desired, run in the same
         process.

      ``android:targetSandboxVersion``
         The target sandbox for this app to use. The higher the sandbox
         version number, the higher the level of security. Its default
         value is ``1``; you can also set it to ``2``. Setting this
         attribute to ``2`` switches the app to a different SELinux
         sandbox.

         The following restrictions apply to a level-2 sandbox:

         -  The default value of
            `usesCleartextTraffic <#usesCleartextTraffic>`__
            in the Network Security Config is false.
         -  Uid sharing isn't permitted.

         For Android Instant Apps targeting Android 8.0 (API level 26)
         or higher, this attribute is set to ``2``. You can set the
         sandbox level in the installed version of your app to the less
         restrictive level ``1``. But if you do so, your app doesn't
         persist app data from the instant app to the installed version
         of your app. You must set the installed app's sandbox value to
         ``2`` for the data to persist from the instant app to the
         installed version.

         Once an app is installed, you can only update its target
         sandbox value to a higher value. To downgrade the target
         sandbox value, uninstall the app and replace it with a version
         whose manifest contains a lower value for this attribute.

      ``android:sharedUserLabel``
         | **This constant is deprecated as of API level 29.**
         | Shared user IDs cause non-deterministic behavior within the
           package manager. As such, their use is strongly discouraged
           and might be removed in a future version of Android. Instead,
           use proper communication mechanisms, such as services and
           content providers, to facilitate interoperability between
           shared components. Existing apps can't remove this value, as
           migrating off a shared user ID is not supported.

         A user-readable label for the shared user ID. The label is set
         as a reference to a string resource. It can't be a raw string.

         This attribute was introduced in API level 3. It is meaningful
         only if the `sharedUserId <#uid>`__ attribute is also set.

      ``android:sharedUserMaxSdkVersion``
         Shared user IDs cause non-deterministic behavior within the
         package manager. As such, their use is strongly discouraged and
         might be removed in a future version of Android. Instead, use
         proper communication mechanisms, such as services and content
         providers, to facilitate interoperability between shared
         components.

         The maximum SDK version where the system still uses
         ``android:sharedUserId``. If your app is newly installed on a
         device running an SDK version higher than the specified value,
         your app behaves as if you never defined
         ``android:sharedUserId``.

         This attribute was introduced in API level 33. It is meaningful
         only if the `sharedUserId <#uid>`__ attribute is also set.

      ``android:versionCode``
         An internal version number. This number is used only to
         determine whether one version is more recent than another, with
         higher numbers indicating more recent versions. This isn't the
         version number shown to users, which is set by the
         ``versionName`` attribute.

         The value is set as a positive integer greater than 0. You can
         define it however you want, as long as each successive version
         has a higher number. For example, it can be a build number, or
         you can translate a version number in "x.y" format to an
         integer by encoding the "x" and "y" separately in the lower and
         upper 16 bits. Or you can increase the number by one each time
         a new version is released.

      ``android:versionName``
         The version number shown to users. This attribute is set as a
         raw string or as a reference to a string resource. The string
         has no other purpose than to display to users. The
         ``versionCode`` attribute holds the significant version number
         used internally.
      ``android:installLocation``
         The default install location for the app. The following keyword
         strings are accepted:

         .. list-table::
            :header-rows: 1

            - 

               - Value
               - Description
            - 

               - ``"internalOnly"``
               - The app installs on internal device storage only. If
                  this is set, the app never installs on external
                  storage, such as an SD card. If the internal storage
                  is full, then the system doesn't install the app. This
                  is the default behavior if you don't define
                  ``android:installLocation``.
            - 

               - ``"auto"``
               - The app can install on external storage, but the system
                  installs the app on internal storage by default. If
                  the internal storage is full, then the system installs
                  it on the external storage. Once installed, the user
                  can move the app to either internal or external
                  storage through the system settings.
            - 

               - ``"preferExternal"``
               - The app prefers to be installed on external storage.
                  There is no guarantee that the system honors this
                  request. The app might install on internal storage if
                  the external media is unavailable or full. Once
                  installed, the user can move the app to either
                  internal or external storage through the system
                  settings.

         **Note:** By default, your app installs on internal storage and
         can't install on external storage unless you define this
         attribute to be either ``"auto"`` or ``"preferExternal"``.

         When an app installs on external storage:

         -  The APK file is saved to the external storage, but any app
            data, such as databases, still saves on the internal device
            memory.
         -  The container in which the APK file is saved is encrypted
            with a key that lets the app operate only on the device that
            installed it. The user can't transfer the SD card to another
            device and use apps installed on the card. Multiple SD cards
            can be used with the same device.
         -  At the user's request, the app can be moved to the internal
            storage.

         The user might also request to move an app from the internal
         storage to the external storage. However, the system doesn't
         let the user move the app to external storage if this attribute
         is set to ``"internalOnly"``, which is the default setting.

         For more information about using this attribute, including how
         to maintain backward compatibility, see `App install location <#>`__.

         Introduced in: API level 8.

   introduced in:
      API level 1 for all attributes, unless noted otherwise in the
      attribute description.
   see also:
      ``<application>``

Last updated 2023-06-05 UTC.


/manifest meta-data
===================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <meta-data android:name="string"
                    android:resource="resource specification"
                    android:value="string" />

   contained in:
      ``<activity>``
      ``<activity-alias>``
      ``<application>``
      ``<provider>``
      ``<receiver>``
      ``<service>``
   description:
      A name-value pair for an item of additional, arbitrary data that
      can be supplied to the parent component. A component element can
      contain any number of ``<meta-data>`` subelements. The values from
      all of them are collected in a single
      `Bundle <#>`__ object and made
      available to the component as the
      `PackageItemInfo.metaData <#metaData>`__
      field.

      Specify ordinary values through the
      `value <#val>`__
      attribute. To assign a resource ID as the value, use the
      `resource <#rsrc>`__
      attribute instead. For example, the following code assigns
      whatever value is stored in the ``@string/kangaroo`` resource to
      the ``zoo`` name:

      .. code:: prettyprint

         <meta-data android:name="zoo" android:value="@string/kangaroo" />

      On the other hand, using the ``resource`` attribute assigns
      ``zoo`` the numeric ID of the resource, not the value stored in
      the resource:

      .. code:: prettyprint

         <meta-data android:name="zoo" android:resource="@string/kangaroo" />

      We highly recommend that you avoid supplying related data as
      multiple separate ``<meta-data>`` entries. Instead, if you have
      complex data to associate with a component, store it as a resource
      and use the ``resource`` attribute to inform the component of its
      ID.

   attributes:
      ``android:name``
         A unique name for the item. To keep the name unique, use a
         Java-style naming convention, such as
         "``com.example.project.activity.fred``".
      ``android:resource``
         A reference to a resource. The ID of the resource is the value
         assigned to the item. The ID is retrieved from the meta-data
         ``Bundle`` using the
         `Bundle.getInt() <#getInt>`__
         method.
      ``android:value``
         The value assigned to the item. The data types that can be
         assigned as values and the ``Bundle`` methods that components
         use to retrieve those values are listed in the following table:

         .. list-table::
            :header-rows: 1

            - 

               - Type
               - Bundle method
            - 

               - String: use double backslashes (``\\``) to escape
                  characters, such as ``\\n`` for a new line and
                  ``\\uxxxxx`` for a Unicode character
               - `getString() <#getString>`__
            - 

               - Integer: for example, ``100``
               - `getInt() <#getInt>`__
            - 

               - Boolean: either ``true`` or ``false``
               - `getBoolean() <#getBoolean>`__
            - 

               - Color: in the form ``#rgb``, ``#argb``, ``#rrggbb``, or
                  ``#aarrggbb``
               - `getInt() <#getInt>`__
            - 

               - Float: for example, ``1.23``
               - `getFloat() <#getFloat>`__

   introduced in:
      API level 1

Last updated 2023-03-29 UTC.

/manifest path-permission
=========================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <path-permission android:path="string"
                          android:pathPrefix="string"
                          android:pathPattern="string"
                          android:permission="string"
                          android:readPermission="string"
                          android:writePermission="string" />

   contained in:
      ``<provider>``
   description:
      Defines the path and required permissions for a specific subset of
      data within a content provider. This element can be specified
      multiple times to supply multiple paths.
   attributes:
      ``android:path``
         A complete URI path for a subset of content provider data.
         Permission can be granted only to the particular data
         identified by this path. When used to provide search suggestion
         content, it is appended with ``/search_suggest_query``.
      ``android:pathPrefix``
         The initial part of a URI path for a subset of content provider
         data. Permission can be granted to all data subsets with paths
         that share this initial part.
      ``android:pathPattern``
         A complete URI path for a subset of content provider data, but
         one that can use the following wildcards:

         -  An asterisk (``*``). This matches a sequence of zero to many
            occurrences of the immediately preceding character.
         -  A period followed by an asterisk (``.*``). This matches any
            sequence of zero or more characters.

         Because the backslash (``\``) is used as an escape character
         when the string is read from XML, before it is parsed as a
         pattern, you need to double-escape. For example, a literal
         ``*`` is written as "``\\*``" and a literal ``\`` is written as
         "``\\\``". This is the same as what you write if constructing
         the string in the Java programming language.

         For more information about these types of patterns, see the
         descriptions of
         `PATTERN_LITERAL <#PATTERN_LITERAL>`__,
         `PATTERN_PREFIX <#PATTERN_PREFIX>`__,
         and
         `PATTERN_SIMPLE_GLOB <#PATTERN_SIMPLE_GLOB>`__
         in the
         `PatternMatcher <#>`__
         class.

      ``android:permission``
         The name of a permission that clients need in order to read or
         write the content provider's data. This attribute is a
         convenient way of setting a single permission for both reading
         and writing. However, the ``readPermission`` and
         ``writePermission`` attributes take precedence over this one.
      ``android:readPermission``
         A permission that clients need in order to query the content
         provider.
      ``android:writePermission``
         A permission that clients need in order to make changes to the
         data controlled by the content provider.

   introduced in:
      API level 4
   see also:
      `SearchManager <#>`__
      `Manifest.permission <#>`__
      `Security tips <#>`__

Last updated 2023-03-29 UTC.


/manifest permission
====================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <permission android:description="string resource"
                     android:icon="drawable resource"
                     android:label="string resource"
                     android:name="string"
                     android:permissionGroup="string"
                     android:protectionLevel=["normal" | "dangerous" |
                                              "signature" | ...] />

   contained in:
      ``<manifest>``
   description:
      Declares a security permission used to limit access to specific
      components or features of this or other applications. For more
      information about how permissions work, see the
      `Permissions <#perms>`__
      section in the app manifest overview and `Security tips <#>`__.
   attributes:
      ``android:description``
         A user-readable description of the permission that is longer
         and more informative than the label. It might display, for
         example, to explain the permission to the user when the user is
         asked to grant the permission to another application.

         This attribute is set as a reference to a string resource.
         Unlike the ``label`` attribute, it can't be a raw string.

      ``android:icon``
         A reference to a drawable resource for an icon that represents
         the permission.
      ``android:label``
         A user-readable name for the permission.

         As a convenience, the label can be directly set as a raw string
         while you're developing the application. However, when the
         application is ready to publish, set it as a reference to a
         string resource, so that it can be localized like other strings
         in the user interface.

      ``android:name``
         The name to be used in code to refer to the permission, such as
         in a
         ``<uses-permission>``
         element or the ``permission`` attributes of application
         components.

         .. note::

            **Note:** The system doesn't let multiple packages declare a
            permission with the same name unless all the packages are
            signed with the same certificate. If a package declares a
            permission, the system doesn't permit the user to install
            other packages with the same permission name, unless those
            packages are signed with the same certificate as the first
            package.

            For this reason, Google recommends prefixing permissions
            with the app's package name, using reverse-domain-style
            naming. Follow this prefix with ``.permission.`` and then a
            description of the capability that the permission represents
            in upper SNAKE_CASE. For example:
            ``com.example.myapp.permission.ENGAGE_HYPERSPACE``.

            Following this recommendation avoids naming collisions and
            helps clearly identify the owner and intention of a custom
            permission.
      ``android:permissionGroup``
         Assigns this permission to a group. The value of this attribute
         is the name of the group, which is declared with the
         ``<permission-group>``
         element in this or another application. If this attribute isn't
         set, the permission doesn't belong to a group.
      ``android:protectionLevel``
         Characterizes the potential risk implied in the permission and
         indicates the procedure for the system to follow when
         determining whether to grant the permission to an application
         requesting it.

         Each protection level consists of a base permission type and
         zero or more flags. For example, the ``"dangerous"`` protection
         level has no flags. In contrast, the protection level
         ``"signature|privileged"`` is a combination of the
         ``"signature"`` base permission type and the ``"privileged"``
         flag.

         The following table shows all base permission types. For a list
         of flags, see
         `protectionLevel <#protectionLevel>`__.

         Value

   introduced in:
      API level 1
   see also:
      ``<uses-permission>``
      ``<permission-tree>``
      ``<permission-group>``

Last updated 2023-10-03 UTC.


/manifest permission-group
==========================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <permission-group android:description="string resource"
                           android:icon="drawable resource"
                           android:label="string resource"
                           android:name="string" />

   contained in:
      ``<manifest>``
   description:
      Declares a name for a logical grouping of related permissions.
      Individual permissions join the group through the
      ``permissionGroup`` attribute of the
      ``<permission>``
      element. Members of a group are presented together in the user
      interface.

      This element doesn't declare a permission itself, only a category
      in which permissions can be placed. For information about
      declaring permissions and assigning them to groups, see the
      ``<permission>``
      element.

   attributes:
      ``android:description``
         User-readable text that describes the group. The text is longer
         and more explanatory than the label. This attribute must be set
         as a reference to a string resource. Unlike the ``label``
         attribute, it can't be a raw string.
      ``android:icon``
         An icon representing the permission. This attribute must be set
         as a reference to a drawable resource containing the image
         definition.
      ``android:label``
         A user-readable name for the group. As a convenience, the label
         can be directly set as a raw string while you're developing the
         application. However, when the application is ready to be
         published, set it as a reference to a string resource, so that
         it can be localized like other strings in the user interface.
      ``android:name``
         The name of the group. This is the name that can be assigned to
         a
         ``<permission>``
         element's
         `android:permissionGroup <#pgroup>`__
         attribute.

   introduced in:
      API level 1
   see also:
      ``<permission>``
      ``<permission-tree>``
      ``<uses-permission>``

Last updated 2023-03-22 UTC.


/manifest permission-tree
=========================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <permission-tree android:icon="drawable resource"
                          android:label="string resource"
                          android:name="string" />

   contained in:
      ``<manifest>``
   description:
      Declares the base name for a tree of permissions. The application
      takes ownership of all names within the tree. It can dynamically
      add new permissions to the tree by calling
      `PackageManager.addPermission() <#addPermission>`__.
      Names within the tree are separated by periods ('``.``'). For
      example, if the base name is ``com.example.project.taxes``,
      permissions like the following might be added:

      | ``com.example.project.taxes.CALCULATE``
      | ``com.example.project.taxes.deductions.STORE_RECEIPTS``
      | ``com.example.project.taxes.deductions.ACCESS_RECORDS``

      This element doesn't declare a permission itself, only a namespace
      in which permissions can be placed. For more information about
      declaring permissions, see the
      ``<permission>``
      element.

   attributes:
      ``android:icon``
         An icon representing all the permissions in the tree. This
         attribute must be set as a reference to a drawable resource
         containing the image definition.
      ``android:label``
         A user-readable name for the group. As a convenience, the label
         can be directly set as a raw string during development.
         However, when the application is ready to be published, set it
         as a reference to a string resource, so that it can be
         localized like other strings in the user interface.
      ``android:name``
         The name at the base of the permission tree. It serves as a
         prefix to all permission names in the tree. Use Java-style
         scoping so that the name is unique. The name must have more
         than two period-separated segments in its path. For example,
         ``com.example.base`` is OK, but ``com.example`` isn't.

   introduced in:
      API level 1
   see also:
      ``<permission>``
      ``<permission-group>``
      ``<uses-permission>``

Last updated 2024-03-18 UTC.


/manifest profileable
=====================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <profileable android:shell=["true" | "false"] android:enabled=["true" | "false"] />

   contained in:
      ``<application>``
   description:
      Specifies how profilers can access this application.
   attributes:
      ``android:shell``
         Specifies whether the user of the device can profile this
         application through local debugging tools such as the
         following:

         -  `android.os.Trace <#>`__
            tracing APIs (Android 11 and lower)
         -  `simpleperf <#>`__
         -  `am profile <#am>`__ commands
         -  `perfetto`` profilers </studio/command-line/perfetto>`__
            (native memory, Java memory, CPU)

         If this isn't set, or is set to ``false``, these tools and APIs
         work only when an app is
         `debuggable <#debug>`__.
         Debuggable apps incur significant and varied performance
         degradation and aren't useful for measuring timing accurately.
         This element is strongly recommended for local performance
         measurements, to capture accurate results.

         This element is designed to be usable in release, or
         production, builds to enable local profiling. It incurs minimal
         risk of data exposure: no memory data is readable by the host
         profiling tools and the shell process. Only stack traces are
         readable, which are typically obfuscated or lacking symbols in
         release builds.

      ``android:enabled``
         Specifies whether the application can be profiled by system
         services or shell tools. For the latter, you also set
         `android:shell <#shell>`__. If false, the application can't
         be profiled at all. The default is true. This attribute was
         added in API level 30.

   introduced in:
      API Level 29

Last updated 2023-03-22 UTC.


/manifest property
==================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <property android:name="string"
                    android:resource="resource specification"
                    android:value="string" />

   contained in:
      ``<activity>``
      ``<activity-alias>``
      ``<application>``
      ``<provider>``
      ``<receiver>``
      ``<service>``
   description:
      A name-value pair for an item of additional, arbitrary data that
      can be supplied to the parent component. A component element can
      contain any number of ``<property>`` subelements. Valid names
      include any of the `property constants <#constants_1>`__
      defined in the
      `PackageManager <#>`__
      class,
      `PackageManager.Property <#>`__
      tags defined in classes such as
      `WindowProperties <#>`__,
      and arbitrary constants defined ad hoc. Obtain values individually
      using the
      ``\ `PackageManager.getProperty() <#getProperty>`__
      method.

      Specify ordinary values with the
      `android:value <#val>`__\ ``
      attribute. Specify resource IDs with the
      `android:resource <#rsrc>`__
      attribute. Specifying both ``android:value`` and
      ``android:resource`` is invalid.

      For example, the following code assigns whatever value is stored
      in the ``@string/kangaroo`` resource to the ``zoo`` name:

      .. code:: prettyprint

         <property android:name="zoo" android:value=‚Äù@string/kangaroo‚Äù />

      The code here, however, assigns the numeric ID of the resource,
      not the value stored in the resource, to ``zoo``:

      .. code:: prettyprint

         <property android:name="zoo" android:resource=‚Äù@string/kangaroo‚Äù />

   attributes:
      ``android:name``
         The name of the property. A parsing error results if multiple,
         sibling ``<property>`` tags have the same name.
      ``android:resource``
         A reference to a resource. The ID of the resource is the value
         assigned to the property. The ID can be retrieved from the
         property by
         ``\ `PackageManager.Property.getResourceId() <#getResourceId>`__.
      ``android:value``
         A value assigned to the property. The following table lists
         valid data types and accessor methods for the value attribute:

         .. list-table::
            :header-rows: 1

            - 

               - Type
               - PackageManager.Property accessor
            - 

               - String: Use double backslashes (\\\\) to escape
                  characters; for example, ``\\n`` and ``\\uxxxxx`` for
                  a Unicode character
               - `getString() <#getString>`__
            - 

               - Integer: For example, ``100``
               - `getInteger() <#getInteger>`__
            - 

               - Boolean: Either ``true`` or ``false``
               - `getBoolean() <#getBoolean>`__
            - 

               - Color: In the form ``#rgb``, ``#argb``, ``#rrggbb``, or
                  ``#aarrggbb``
               - `getInteger() <#getInteger>`__
            - 

               - Float: For example, ``1.23``
               - `getFloat() <#getFloat>`__

   introduced in:
      API Level 31

Last updated 2022-11-21 UTC.


/manifest provider
==================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <provider android:authorities="list"
                   android:directBootAware=["true" | "false"]
                   android:enabled=["true" | "false"]
                   android:exported=["true" | "false"]
                   android:grantUriPermissions=["true" | "false"]
                   android:icon="drawable resource"
                   android:initOrder="integer"
                   android:label="string resource"
                   android:multiprocess=["true" | "false"]
                   android:name="string"
                   android:permission="string"
                   android:process="string"
                   android:readPermission="string"
                   android:syncable=["true" | "false"]
                   android:writePermission="string" >
             ...
         </provider>

   contained in:
      ``<application>``
   can contain:
      ``<meta-data>``
      ``<grant-uri-permission>``
      ``<intent-filter>``
      ``<path-permission>``
   description:
      Declares a content provider component. A content provider is a
      subclass of
      `ContentProvider <#>`__
      that supplies structured access to data managed by the
      application. All content providers in your application must be
      defined in a ``<provider>`` element in the manifest file.
      Otherwise, the system is unaware of them and doesn't run them.

      Only declare content providers that are part of your application.
      Don't declare content providers in other applications that you use
      in your application.

      The Android system stores references to content providers
      according to an *authority* string, part of the provider's
      *content URI*. For example, suppose you want to access a content
      provider that stores information about health care professionals.
      To do this, you call the method
      `ContentResolver.query() <#query>`__,
      which takes a URI that identifies the provider, among other
      arguments:

      .. code:: none

         content://com.example.project.healthcareprovider/nurses/rn

      The ``content:`` *scheme* identifies the URI as a content URI
      pointing to an Android content provider. The authority
      ``com.example.project.healthcareprovider`` identifies the provider
      itself. The Android system looks up the authority in its list of
      known providers and their authorities. The substring ``nurses/rn``
      is a *path*, which the content provider uses to identify subsets
      of the provider data.

      When you define your provider in the ``<provider>`` element, you
      don't include the scheme or the path in the ``android:name``
      argument, only the authority.

      For information about using and developing content providers, see
      `Content providers <#>`__.

   attributes:
      ``android:authorities``
         A list of one or more URI authorities that identify data
         offered by the content provider. List multiple authorities by
         separating their names with a semicolon. To avoid conflicts,
         use a Java-style naming convention for authority names, such as
         ``com.example.provider.cartoonprovider``. Typically, it's the
         name of the
         `ContentProvider <#>`__
         subclass that implements the provider

         There is no default. At least one authority must be specified.

      ``android:enabled``
         Whether the content provider can be instantiated by the system.
         It's ``"true"`` if it can be, and ``"false"`` if not. The
         default value is ``"true"``.

         The
         ``<application>``
         element has its own
         `enabled <#enabled>`__
         attribute that applies to all application components, including
         content providers. The ``<application>`` and ``<provider>``
         attributes both have to be ``"true"``, as they both are by
         default, for the content provider to be enabled. If either is
         ``"false"``, the provider is disabled. It can't be
         instantiated.

      ``android:directBootAware``
         Whether the content provider is *Direct-Boot aware*‚Äîthat is,
         whether it can run before the user unlocks the device.

         **Note:** During `Direct Boot <#>`__, a content provider in
         your application can only access the data that is stored in
         *device protected* storage.

         The default value is ``"false"``.

      ``android:exported``
         Whether the content provider is available for other
         applications to use.

         -  ``"true"``: the provider is available to other applications.
            Any application can use the provider's content URI to access
            it, subject to the permissions specified for the provider.
         -  ``"false"``: the provider isn't available to other
            applications. Set ``android:exported="false"`` to limit
            access to the provider to your applications. Only
            applications that have the same user ID (UID) as the
            provider, or applications that are temporarily granted
            access to the provider through the
            `android:grantUriPermissions <#gprmsn>`__
            element, have access to it.

         Because this attribute was introduced in API level 17, all
         devices running API level 16 and lower behave as though this
         attribute is set ``"true"``. If you set
         `android:targetSdkVersion <#target>`__
         to 17 or higher, then the default value is ``"false"`` for
         devices running API level 17 and higher.

         You can set ``android:exported="false"`` and still limit access
         to your provider by setting permissions with the
         `permission <#prmsn>`__
         attribute.

      ``android:grantUriPermissions``
         Whether those who ordinarily don't have permission to access
         the content provider's data can be granted permission to do so,
         temporarily overcoming the restriction imposed by the
         `readPermission <#rprmsn>`__,
         `writePermission <#wprmsn>`__,
         `permission <#prmsn>`__,
         and
         `exported <#exported>`__
         attributes.

         It's ``"true"`` if permission can be granted, and ``"false"``
         if not. If ``"true"``, permission can be granted to any of the
         content provider's data. If ``"false"``, permission can be
         granted only to the data subsets listed in
         ``<grant-uri-permission>``
         subelements, if any. The default value is ``"false"``.

         Granting permission is a way of giving an application component
         one-time access to data protected by a permission. For example,
         when an email message contains an attachment, the mail
         application might call on the appropriate viewer to open it,
         even though the viewer doesn't have general permission to look
         at all the content provider's data.

         In such cases, permission is granted by
         `FLAG_GRANT_READ_URI_PERMISSION <#FLAG_GRANT_READ_URI_PERMISSION>`__
         and
         `FLAG_GRANT_WRITE_URI_PERMISSION <#FLAG_GRANT_WRITE_URI_PERMISSION>`__
         flags in the ``Intent`` object that activates the component.
         For example, the mail application might put
         ``FLAG_GRANT_READ_URI_PERMISSION`` in the ``Intent`` passed to
         ``Context.startActivity()``. The permission is specific to the
         URI in the ``Intent``.

         If you enable this feature, either by setting this attribute to
         ``"true"`` or by defining
         ``<grant-uri-permission>``
         subelements, call
         `Context.revokeUriPermission() <#revokeUriPermission>`__
         when a covered URI is deleted from the provider.

         See also the
         ``<grant-uri-permission>``
         element.

      ``android:icon``
         An icon representing the content provider. This attribute is
         set as a reference to a drawable resource containing the image
         definition. If it isn't set, the icon specified for the
         application as a whole is used instead. For more information,
         see the
         ``<application>``
         element's
         `icon <#icon>`__
         attribute.
      ``android:initOrder``
         The order in which the content provider is instantiated,
         relative to other content providers hosted by the same process.
         When there are dependencies among content providers, setting
         this attribute for each of them makes sure that they are
         created in the order required by those dependencies. The value
         is an integer, with higher numbers being initialized first.
      ``android:label``
         A user-readable label for the content provided. If this
         attribute isn't set, the label set for the application as a
         whole is used instead. For more information, see the
         ``<application>``
         element's
         `label <#label>`__
         attribute.

         The label is usually set as a reference to a string resource,
         so that it can be localized like other strings in the user
         interface. However, as a convenience while you're developing
         the application, it can also be set as a raw string.

      ``android:multiprocess``
         If the app runs in multiple processes, this attribute
         determines whether multiple instances of the content provider
         are created. If ``"true"``, each of the app's processes has its
         own content provider object. If ``"false"``, the app's
         processes share only one content provider object. The default
         value is ``"false"``.

         Setting this flag to ``"true"`` can improve performance by
         reducing the overhead of interprocess communication, but it
         also increases the memory footprint of each process.

      ``android:name``
         The name of the class that implements the content provider, a
         subclass of
         `ContentProvider <#>`__.
         This is usually a fully qualified class name, such as
         ``"com.example.project.TransportationProvider"``. However, as a
         shorthand, if the first character of the name is a period, it
         is appended to the package name specified in the
         ``<manifest>``
         element.

         There is no default. The name must be specified.

      ``android:permission``
         The name of a permission that clients must have to read or
         write the content provider's data. This attribute is a
         convenient way of setting a single permission for both reading
         and writing. However, the `readPermission <#rprmsn>`__,
         `writePermission <#wprmsn>`__, and
         `grantUriPermissions <#gprmsn>`__ attributes take
         precedence over this one.

         If the ``readPermission`` attribute is also set, it controls
         access for querying the content provider. If the
         ``writePermission`` attribute is set, it controls access for
         modifying the provider's data.

         For more information about permissions, see the
         `Permissions <#perms>`__
         section in the app manifest overview and `Security tips <#>`__.

      ``android:process``
         The name of the process in which the content provider runs.
         Normally, all components of an application run in the default
         process created for the application. It has the same name as
         the application package.

         The
         ``<application>``
         element's
         `process <#proc>`__
         attribute can set a different default for all components. But
         each component can override the default with its own
         ``process`` attribute, letting you spread your application
         across multiple processes.

         If the name assigned to this attribute begins with a colon
         (``:``), a new process, private to the application, is created
         when it's needed and the activity runs in that process.

         If the process name begins with a lowercase character, the
         activity runs in a global process of that name, provided that
         it has permission to do so. This lets components in different
         applications share a process, reducing resource usage.

      ``android:readPermission``
         A permission that clients must have to query the content
         provider.

         If the provider sets
         `android:grantUriPermissions <#gprmsn>`__
         to ``"true"``, or if a given client satisfies the conditions of
         a
         ``<grant-uri-permission>``
         subelement, the client can gain temporary read access to the
         content provider's data.

         See also the `permission <#prmsn>`__ and
         `writePermission <#wprmsn>`__ attributes.

      ``android:syncable``
         Whether the data under the content provider's control can be
         synchronized with data on a server. It's ``"true"`` if it can
         be, and ``"false"`` if not.
      ``android:writePermission``
         A permission that clients need to make changes to the data
         controlled by the content provider.

         If the provider sets
         `android:grantUriPermissions <#gprmsn>`__
         to ``"true"``, or if a given client satisfies the conditions of
         a
         ``<grant-uri-permission>``
         subelement, the client can gain temporary write access to
         modify the content provider's data.

         See also the `permission <#prmsn>`__ and
         `readPermission <#rprmsn>`__ attributes.

   introduced in:
      API level 1
   see also:
      `Content providers <#>`__

Last updated 2023-05-04 UTC.


/manifest queries
==================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <queries>
             <package android:name="string" />
             <intent>
                 ...
             </intent>
             <provider android:authorities="list" />
             ...
         </queries>

   contained in:
      ``<manifest>``
   description:
      Specifies the set of other apps that an app intends to interact
      with. These other apps are specified `by package name <#package>`__, `by intent signature <#intent>`__, or `by provider authority <#provider>`__, as described in the following
      sections on this page.

      **Note:** Some packages are `visible automatically <#>`__. Your
      app always sees these packages in its queries for other installed
      apps. To view other packages, declare your app's need for
      increased package visibility using the ``<queries>`` element.

      Learn more about how to use the ``<queries>`` element in `Package visibility filtering on Android <#>`__.

   child elements:
      ``<package>``
         Specifies a single app that your app intends to access. This
         other app might integrate with your app, or your app might use
         services that the other app provides.

         attributes:

         ``android:name``
            **Required.** Specifies the package name of the other app.

      ``<intent>``
         Specifies an `intent filter signature <#>`__. Your app can
         discover other apps that have matching
         ``<intent-filter>``
         elements.

         **Note:** There are some restrictions on the options that you
         can include in this ``<intent>`` element, compared to a typical
         intent filter signature. Learn more about these restrictions in
         `Packages that match an intent filter signature <#intent-filter-signature>`__.

      ``<provider>``
         Specifies one or more `content provider authorities <#ContentURIs>`__.
         Your app can discover other apps whose content providers use
         the specified authorities.

         **Note:** There are some restrictions on the options that you
         can include in this ``<provider>`` element, compared to a
         typical
         ``<provider>``
         manifest element. Usually, you only specify the
         ``android:authorities`` attribute.

   introduced in:
      API level 30
   see also:
      `Package visibility filtering on Android <#>`__

Last updated 2023-03-29 UTC.


/manifest receiver
==================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <receiver android:directBootAware=["true" | "false"]
                   android:enabled=["true" | "false"]
                   android:exported=["true" | "false"]
                   android:icon="drawable resource"
                   android:label="string resource"
                   android:name="string"
                   android:permission="string"
                   android:process="string" >
             ...
         </receiver>

   contained in:
      ``<application>``
   can contain:
      ``<intent-filter>``
      ``<meta-data>``
   description:
      Declares a broadcast receiver, a
      `BroadcastReceiver <#>`__
      subclass, as one of the application's components. Broadcast
      receivers enable applications to receive intents that are
      broadcast by the system or by other applications, even when other
      components of the application aren't running.

      There are two ways to make a broadcast receiver known to the
      system. One is to declare it in the manifest file with this
      element. The other is to create the receiver dynamically in code
      and register it with the
      `Context.registerReceiver() <#registerReceiver>`__
      method or one of its overloaded versions.

      For more information about how to dynamically create receivers,
      see the
      `BroadcastReceiver <#>`__
      class description.

      If this receiver handles non-system broadcasts, specify a value
      for ``android:exported``. Set this value to ``"true"`` if you want
      your receiver to be able to receiver broadcasts from other
      applications or ``"false"`` if you only want your receiver to be
      able to receive broadcasts from your own app.

      You don't have to remove the ``android:permission`` attribute if
      you already declared it.

      **Warning:** Limit how many broadcast receivers you set in your
      app. Having too many broadcast receivers can affect your app's
      performance and the battery life of users' devices. For more
      information about APIs you can use instead of the
      ``BroadcastReceiver`` class for scheduling background work, see
      `Background optimization <#>`__.

   attributes:
      ``android:directBootAware``
         Whether the broadcast receiver is *Direct-Boot aware*, that is,
         whether it can run before the user unlocks the device.

         **Note:** During `Direct Boot <#>`__, a broadcast receiver
         in your application can only access the data that is stored in
         *device protected* storage.

         The default value is ``"false"``.

      ``android:enabled``
         Whether the broadcast receiver can be instantiated by the
         system. It's ``"true"`` if it can be, and ``"false"`` if not.
         The default value is ``"true"``.

         The
         ``<application>``
         element has its own
         `enabled <#enabled>`__
         attribute that applies to all application components, including
         broadcast receivers. The ``<application>`` and ``<receiver>``
         attributes must both be ``"true"`` for the broadcast receiver
         to be enabled. If either is ``"false"``, it's disabled and
         can't be instantiated.

      ``android:exported``
         Whether the broadcast receiver can receive messages from
         non-system sources outside its application. It's ``"true"`` if
         it can, and ``"false"`` if not. If ``"false"``, the only
         messages the broadcast receiver receives are those sent by the
         system, components of the same application, or applications
         with the same user ID.

         If unspecified, the default value depends on whether the
         broadcast receiver contains intent filters. If the receiver
         contains at least one intent filter, then the default value is
         ``"true"``. Otherwise, the default value is ``"false"``.

         This attribute is not the only way to limit a broadcast
         receiver's external exposure. You can also use a permission to
         limit the external entities that can send it messages. See the
         `permission <#prmsn>`__
         attribute.

      ``android:icon``
         An icon representing the broadcast receiver. This attribute is
         set as a reference to a drawable resource containing the image
         definition. If it isn't set, the icon specified for the
         application as a whole is used instead. See the
         ``<application>``
         element's
         `icon <#icon>`__
         attribute.

         The broadcast receiver's icon, whether set here or by the
         ``<application>`` element, is also the default icon for all the
         receiver's intent filters. See the
         ``<intent-filter>``
         element's
         `icon <#icon>`__
         attribute.

      ``android:label``
         A user-readable label for the broadcast receiver. If this
         attribute isn't set, the label set for the application as a
         whole is used instead. See the
         ``<application>``
         element's
         `label <#label>`__
         attribute.

         The broadcast receiver's label, whether set here or by the
         ``<application>`` element, is also the default label for all
         the receiver's intent filters. See the
         ``<intent-filter>``
         element's
         `label <#label>`__
         attribute.

         The label is set as a reference to a string resource, so that
         it can be localized like other strings in the user interface.
         However, as a convenience while you're developing the
         application, it can also be set as a raw string.

      ``android:name``
         The name of the class that implements the broadcast receiver, a
         subclass of
         `BroadcastReceiver <#>`__.
         This is a fully qualified class name, such as
         ``"com.example.project.ReportReceiver"``. However, as a
         shorthand, if the first character of the name is a period, for
         example, ``".ReportReceiver"``, it is appended to the package
         name specified in the
         ``<manifest>``
         element.

         Once you publish your application, `don't change this name <http://android-developers.blogspot.com/2011/06/things-that-cannot-change.html>`__,
         unless you set
         `android:exported <#exported>`__\ ``="false"``.

         There is no default. The name must be specified.

      ``android:permission``
         The name of a permission that broadcasters need in order to
         send a message to the broadcast receiver. If this attribute
         isn't set, the permission set by the
         ``<application>``
         element's
         `permission <#prmsn>`__
         attribute applies to the broadcast receiver. If neither
         attribute is set, the receiver isn't protected by a permission.

         For more information about permissions, see the
         `Permissions <#perms>`__
         section in the app manifest overview and `Security tips <#>`__.

      ``android:process``
         The name of the process in which the broadcast receiver runs.
         Normally, all components of an application run in the default
         process created for the application. It has the same name as
         the application package.

         The
         ``<application>``
         element's
         `process <#proc>`__
         attribute can set a different default for all components. But
         each component can override the default with its own
         ``process`` attribute, letting you spread your application
         across multiple processes.

         If the name assigned to this attribute begins with a colon
         (``:``), a new process, private to the application, is created
         when it's needed, and the broadcast receiver runs in that
         process.

         If the process name begins with a lowercase character, the
         receiver runs in a global process of that name, provided that
         it has permission to do so. This lets components in different
         applications share a process, reducing resource usage.

   introduced in:
      API level 1

Last updated 2023-05-04 UTC.


/manifest service
==================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <service android:description="string resource"
                  android:directBootAware=["true" | "false"]
                  android:enabled=["true" | "false"]
                  android:exported=["true" | "false"]
                  android:foregroundServiceType=["camera" | "connectedDevice" |
                                                 "dataSync" | "health" | "location" |
                                                 "mediaPlayback" | "mediaProjection" |
                                                 "microphone" | "phoneCall" |
                                                 "remoteMessaging" | "shortService" |
                                                 "specialUse" | "systemExempted"]
                  android:icon="drawable resource"
                  android:isolatedProcess=["true" | "false"]
                  android:label="string resource"
                  android:name="string"
                  android:permission="string"
                  android:process="string" >
             ...
         </service>

   contained in:
      ``<application>``
   can contain:
      ``<intent-filter>``
      ``<meta-data>``
   description:
      Declares a service, a
      `Service <#>`__ subclass, as one
      of the application's components. Unlike activities, services lack
      a visual user interface. They're used to implement long-running
      background operations or a rich communications API that can be
      called by other applications.

      All services must be represented by ``<service>`` elements in the
      manifest file. Any that aren't declared there aren't seen by the
      system and never run.

      **Note:** On Android 8.0 (API level 26) and higher, the system
      limits what your app can do while it's running in the background.
      For more information, see the guides that discuss `background execution limits <#>`__ and
      `background location limits <#>`__.

   attributes:
      ``android:description``
         A user-readable string that describes the service. The
         description is set as a reference to a string resource, so that
         it can be localized like other strings in the user interface.
      ``android:directBootAware``
         Whether the service is *Direct-Boot aware*, that is, whether it
         can run before the user unlocks the device.

         **Note:** During `Direct Boot <#>`__, a service in your
         application can only access the data that is stored in *device
         protected* storage.

         The default value is ``"false"``.

      ``android:enabled``
         Whether the service can be instantiated by the system. It's
         ``"true"`` if it can be, and ``"false"`` if not. The default
         value is ``"true"``.

         The
         ``<application>``
         element has its own
         `enabled <#enabled>`__
         attribute that applies to all application components, including
         services. The ``<application>`` and ``<service>`` attributes
         must both be ``"true"``, as they both are by default, for the
         service to be enabled. If either is ``"false"``, the service is
         disabled and can't be instantiated.

      ``android:exported``
         Whether components of other applications can invoke the service
         or interact with it. It's ``"true"`` if they can, and
         ``"false"`` if not. When the value is ``"false"``, only
         components of the same application or applications with the
         same user ID can start the service or bind to it.

         The default value depends on whether the service contains
         intent filters. The absence of any filters means that it can be
         invoked only by specifying its exact class name. This implies
         that the service is intended only for application-internal use,
         since others don't know the class name. So, in this case, the
         default value is ``"false"``. On the other hand, the presence
         of at least one filter implies that the service is intended for
         external use, so the default value is ``"true"``.

         This attribute isn't the only way to limit the exposure of a
         service to other applications. You can also use a permission to
         limit the external entities that can interact with the service.
         See the
         `permission <#prmsn>`__
         attribute.

      ``android:foregroundServiceType``
         Specifies that the service is a `foreground service <#>`__ that satisfies a
         particular use case. For example, a foreground service type of
         ``"location"`` indicates that an app is getting the device's
         current location, usually to `continue a user-initiated action <#continue-user-initiated-action>`__
         related to device location.

         You can assign multiple foreground service types to a
         particular service.

      ``android:icon``
         An icon representing the service. This attribute is set as a
         reference to a drawable resource containing the image
         definition. If it isn't set, the icon specified for the
         application as a whole is used instead. See the
         ``<application>``
         element's
         `icon <#icon>`__
         attribute.

         The service's icon, whether set here or by the
         ``<application>`` element, is also the default icon for all the
         service's intent filters. See the
         ``<intent-filter>``
         element's
         `icon <#icon>`__
         attribute.

      ``android:isolatedProcess``
         If set to ``"true"``, this service runs under a special process
         that is isolated from the rest of the system and has no
         permissions of its own. The only communication with it is
         through the Service API, with binding and starting.
      ``android:label``
         A user-readable name for the service. If this attribute isn't
         set, the label set for the application as a whole is used
         instead. See the
         ``<application>``
         element's
         `label <#label>`__
         attribute.

         The service's label, whether set here or by the
         ``<application>`` element, is also the default label for all
         the service's intent filters. See the
         ``<intent-filter>``
         element's
         `label <#label>`__
         attribute.

         The label is set as a reference to a string resource, so that
         it can be localized like other strings in the user interface.
         However, as a convenience while you're developing the
         application, it can also be set as a raw string.

      ``android:name``
         The name of the
         `Service <#>`__ subclass that
         implements the service. This is a fully qualified class name,
         such as ``"com.example.project.RoomService"``. However, as a
         shorthand, if the first character of the name is a period, such
         as ``".RoomService"``, it is appended to the package name
         specified in the
         ``<manifest>``
         element.

         Once you publish your application, `don't change this name <http://android-developers.blogspot.com/2011/06/things-that-cannot-change.html>`__,
         unless you set
         `android:exported <#exported>`__\ ``="false"``.

         There is no default. The name must be specified.

      ``android:permission``
         The name of a permission that an entity needs in order to
         launch the service or bind to it. If a caller of
         `startService() <#startService>`__,
         `bindService() <#bindService>`__,
         or
         `stopService() <#stopService>`__
         isn't granted this permission, the method doesn't work and the
         ``Intent`` object isn't delivered to the service.

         If this attribute isn't set, the permission set by the
         ``<application>``
         element's
         `permission <#prmsn>`__
         attribute applies to the service. If neither attribute is set,
         the service isn't protected by a permission.

         For more information about permissions, see the
         `Permissions <#perms>`__
         section in the app manifest overview and `Security guidelines <#>`__.

      ``android:process``
         The name of the process where the service runs. Normally, all
         components of an application run in the default process created
         for the application. It has the same name as the application
         package. The
         ``<application>``
         element's
         `process <#proc>`__
         attribute can set a different default for all components. But a
         component can override the default with its own ``process``
         attribute, letting you spread your application across multiple
         processes.

         If the name assigned to this attribute begins with a colon
         (``:``), a new process, private to the application, is created
         when it's needed and the service runs in that process.

         If the process name begins with a lowercase character, the
         service runs in a global process of that name, provided that it
         has permission to do so. This lets components in different
         applications share a process, reducing resource usage.

   see also:
      ``<application>``
      ``<activity>``
   introduced in:
      API level 1

Last updated 2024-01-16 UTC.


/manifest supports-gl-texture
=============================

.. container:: devsite-article-body clearfix

   .. note::

      **Note:** Google Play filters applications according to the
      texture compression formats that they support so that they install
      only on devices that can handle their textures properly. You can
      use texture compression filtering as a way of targeting specific
      device types based on the GPU platform.

      For important information about how Google Play uses
      ``<supports-gl-texture>`` elements as the basis for filtering,
      read the `Google Play and texture compression filtering <#market-texture-filtering>`__ section.

   syntax:
      .. code:: prettyprint

         <supports-gl-texture
           android:name="string" />

   contained in:
      ``<manifest>``
   description:
      Declares a single GL texture compression format that the app
      supports.

      An application "supports" a GL texture compression format if it
      can provide texture assets compressed in that format when the
      application installs on a device.

      The application provides the compressed assets locally, from
      inside the APK, or it can download them from a server at runtime.

      Each ``<supports-gl-texture>`` element declares exactly one
      supported texture compression format, specified as the value of a
      ``android:name`` attribute. If your application supports multiple
      texture compression formats, you can declare multiple
      ``<supports-gl-texture>`` elements:

      .. code:: prettyprint

         <supports-gl-texture android:name="GL_OES_compressed_ETC1_RGB8_texture" />
         <supports-gl-texture android:name="GL_OES_compressed_paletted_texture" />

      ``<supports-gl-texture>`` elements are informational, meaning that
      the Android system itself does not examine the elements at install
      time to ensure matching support on the device.

      However, other services, such as Google Play, or applications can
      check your application's ``<supports-gl-texture>`` declarations as
      part of handling or interacting with your application. For this
      reason, it's very important that you declare all the texture
      compression formats from the following list that your application
      supports.

      Applications and devices typically declare their supported GL
      texture compression formats using the following set of well-known
      strings. The set of format strings might grow over time, as
      needed. Since the values are strings, applications are free to
      declare other formats as needed.

      Assuming that the application is built with SDK Platform Tools r3
      or higher, filtering based on the ``<supports-gl-texture>``
      element is activated for all API levels.

   attributes:
      ``android:name``
         Specifies a single GL texture compression format supported by
         the application as a descriptor string. Common descriptor
         values are listed in the following table.

         .. list-table::
            :header-rows: 1

            - 

               - Texture compression format descriptor
               - Comments
            - 

               - ``GL_OES_compressed_ETC1_RGB8_texture``
               - Ericsson texture compression. Specified in OpenGL ES
                  2.0 and available in all Android-powered devices that
                  support OpenGL ES 2.0.
            - 

               - ``GL_OES_compressed_paletted_texture``
               - Generic paletted texture compression.
            - 

               - ``GL_AMD_compressed_3DC_texture``
               - ATI 3Dc texture compression.
            - 

               - ``GL_AMD_compressed_ATC_texture``
               - ATI texture compression. Available on devices running
                  Adreno GPU, including HTC Nexus One, Droid Incredible,
                  EVO, and others. For widest compatibility, devices may
                  also declare a ``<supports-gl-texture>`` element with
                  the descriptor ``GL_ATI_texture_compression_atitc``.
            - 

               - ``GL_EXT_texture_compression_latc``
               - Luminance alpha texture compression.
            - 

               - ``GL_EXT_texture_compression_dxt1``
               - S3 DXT1 texture compression. Supported on devices
                  running the Nvidia Tegra2 platform, including Motorala
                  Xoom, Motorola Atrix, Droid Bionic, and others.
            - 

               - ``GL_EXT_texture_compression_s3tc``
               - S3 texture compression, nonspecific to DXT variant.
                  Supported on devices running the Nvidia Tegra2
                  platform, including Motorala Xoom, Motorola Atrix,
                  Droid Bionic, and others. If your application requires
                  a specific DXT variant, declare that descriptor
                  instead of this one.
            - 

               - ``GL_IMG_texture_compression_pvrtc``
               - PowerVR texture compression. Available on devices
                  running the PowerVR SGX530/540 GPU, such as Motorola
                  DROID series; Samsung Galaxy S, Nexus S, and Galaxy
                  Tab; and others.

   see also:
      -  `Filters on Google Play <#>`__

Last updated 2023-05-04 UTC.


/manifest supports-screens
==========================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <supports-screens android:resizeable=["true"| "false"]
                           android:smallScreens=["true" | "false"]
                           android:normalScreens=["true" | "false"]
                           android:largeScreens=["true" | "false"]
                           android:xlargeScreens=["true" | "false"]
                           android:anyDensity=["true" | "false"]
                           android:requiresSmallestWidthDp="integer"
                           android:compatibleWidthLimitDp="integer"
                           android:largestWidthLimitDp="integer"/>

   contained in:
      ``<manifest>``
   description:
      Lets you specify the screen sizes your application supports and
      enable screen compatibility mode for screens larger than what your
      application supports. It's important that you always use this
      element in your application to specify the screen sizes your
      application supports.

      **Note:** Screen compatibility mode **isn't** a mode you want your
      application to run in. It causes pixelation and blurring in your
      UI due to zooming. The proper way to make your application work
      well on large screens is to follow the `Screen compatibility overview <#>`__ and provide
      alternative layouts for different screen sizes.

      An application "supports" a given screen size if it resizes
      properly to fill the entire screen. Normal resizing applied by the
      system works well for most applications, and you don't have to do
      any extra work to make your application work on screens larger
      than a handset device.

      However, it's often important that you optimize your application's
      UI for different screen sizes by providing `alternative layout resources <#AlternativeResources>`__.
      For instance, you might want to modify the layout of an activity
      when it is on a tablet compared to when running on a handset
      device.

      However, if your application doesn't work well when resized to fit
      different screen sizes, you can use the attributes of the
      ``<supports-screens>`` element to control whether your application
      is distributed only to smaller screens or has its UI scaled up, or
      "zoomed," to fit larger screens using the system's `screen compatibility mode <#compat-mode>`__.

      If you don't design for larger screen sizes and the normal
      resizing doesn't achieve the appropriate results, screen
      compatibility mode scales your UI by emulating a *normal* size
      screen and medium density. It then zooms in so that it fills the
      entire screen. Be aware that this causes pixelation and blurring
      of your UI, so it's better if you optimize your UI for large
      screens.

      **Note:** Android 3.2 introduced new attributes:
      ``android:requiresSmallestWidthDp``,
      ``android:compatibleWidthLimitDp``, and
      ``android:largestWidthLimitDp``. If you're developing your
      application for Android 3.2 and higher, use these attributes to
      declare your screen size support instead of the attributes based
      on generalized screen sizes.

      .. rubric:: About screen compatibility mode
         :name: compat-mode

      Screen compatibility mode is a last resort for apps that aren't
      properly designed to take advantage of larger screen sizes. This
      is not a mode you want your app to run in, because it can offer a
      poor user experience. There are two versions of screen
      compatibility mode based on the device version the app runs on.

      On Android versions 1.6 to 3.1, the system runs your application
      in a "postage stamp" window. It emulates a 320dp x 480dp screen
      with a black border that fills the remaining area of the screen.

      On Android 3.2 and up, the system draws the layout as it does on a
      320dp x 480dp screen, then scales it up to fill the screen. This
      often causes artifacts such as blurring and pixelation in your UI.

      For more information about how to properly support different
      screen sizes so that you can avoid using screen compatibility mode
      with your application, read `Screen compatibility overview <#>`__.

   attributes:
      ``android:resizeable``
         Indicates whether the application is resizeable for different
         screen sizes. This attribute is ``"true"`` by default. If set
         to ``"false"``, the system runs your application in `screen compatibility mode <#compat-mode>`__ on large screens.

         **This attribute is deprecated**. It was introduced to help
         applications transition from Android 1.5 to 1.6, when support
         for multiple screens was first introduced. Don't use it.

      ``android:smallScreens``
         Indicates whether the application supports "small" screen
         form-factors. A small screen is defined as one with a smaller
         aspect ratio than the "normal" screen, or traditional HVGA
         screen. An application that doesn't support small screens
         *isn't available* for small screen devices from external
         services, such as Google Play, because there is little the
         platform can do to make such an application work on a smaller
         screen. This is ``"true"`` by default.
      ``android:normalScreens``
         Indicates whether an application supports the "normal" screen
         form-factors. Traditionally this is an HVGA medium density
         screen, but WQVGA low density and WVGA high density are also
         considered to be normal. This attribute is ``"true"`` by
         default.
      ``android:largeScreens``
         Indicates whether the application supports "large" screen
         form-factors. A large screen is defined as a screen that is
         significantly larger than a "normal" handset screen. Thus it
         might require some special care on the application's part to
         make good use of it, though it might rely on resizing by the
         system to fill the screen.

         The default value for this varies between some versions, so
         it's better if you explicitly declare this attribute. Beware
         that setting it to ``"false"`` generally enables `screen compatibility mode <#compat-mode>`__.

      ``android:xlargeScreens``
         Indicates whether the application supports "extra-large" screen
         form-factors. An extra-large screen is defined as a screen that
         is significantly larger than a "large" screen, such as a tablet
         or something even larger. It might require special care on the
         application's part to make good use of it, though it might rely
         on resizing by the system to fill the screen.

         The default value for this varies between some versions, so
         it's better if you explicitly declare this attribute. Beware
         that setting it to ``"false"`` generally enables `screen compatibility mode <#compat-mode>`__.

         This attribute was introduced in API level 9.

      ``android:anyDensity``
         Indicates whether the application includes resources to
         accommodate any screen density.

         For applications that support Android 1.6 (API level 4) and
         higher, this is ``"true"`` by default. *Don't* set it to
         ``"false"`` unless you're absolutely certain that it's
         necessary for your application to work. The only time it might
         be necessary to disable this is if your app directly
         manipulates bitmaps. For more information, see the `Screen compatibility overview <#DensityConsiderations>`__.

      ``android:requiresSmallestWidthDp``
         Specifies the minimum ``smallestWidth`` required for the app.
         The ``smallestWidth`` is the shortest dimension of the screen
         space, in ``dp`` units, that must be available to your
         application UI. That is, it is the shortest of the available
         screen's two dimensions.

         For a device to be considered compatible with your application,
         the device's ``smallestWidth`` must be equal to or greater than
         this value. Usually, the value you supply for this is the
         "smallest width" that your layout supports, regardless of the
         screen's current orientation.

         For example, a typical handset screen has a ``smallestWidth``
         of 320dp, a 7-inch tablet has a ``smallestWidth`` of 600dp, and
         a 10-inch tablet has a ``smallestWidth`` of 720dp. These values
         are generally the ``smallestWidth`` because they are the
         shortest dimension of the screen's available space.

         The size against which your value is compared takes into
         account screen decorations and system UI. For example, if the
         device has some persistent UI elements on the display, the
         system declares the device's ``smallestWidth`` as one that is
         smaller than the actual screen size, because those are screen
         pixels not available for your UI.

         If your application properly resizes for smaller screen sizes,
         down to the "small" size or a minimum width of 320dp, you don't
         need to use this attribute. Otherwise, use a value for this
         attribute that matches the smallest value used by your
         application for the `smallest screen width qualifier <#SmallestScreenWidthQualifier>`__
         (``sw<N>dp``).

         **Caution:** The Android system doesn't pay attention to this
         attribute, so it doesn't affect how your application behaves at
         runtime. Instead, it is used to enable filtering for your
         application on services such as Google Play. However, Google
         Play currently doesn't support this attribute for filtering on
         Android 3.2, so continue using the other size attributes if
         your application doesn't support small screens.

         This attribute was introduced in API level 13.

      ``android:compatibleWidthLimitDp``
         This attribute lets you enable `screen compatibility mode <#compat-mode>`__ as a user-optional feature by specifying
         the maximum "smallest screen width" for which your application
         is designed. If the smallest side of a device's available
         screen is greater than your value here, users can still install
         your application but are offered to run it in screen
         compatibility mode.

         By default, screen compatibility mode is disabled, and your
         layout resizes to fit the screen as usual. A button is
         available in the system bar that lets the user toggle screen
         compatibility mode.

         If your application is compatible with all screen sizes and its
         layout properly resizes, you don't need to use this attribute.

         **Note:** Currently, screen compatibility mode emulates only
         handset screens with a 320dp width, so screen compatibility
         mode isn't applied if your value for
         ``android:compatibleWidthLimitDp`` is larger than ``320``.

         This attribute was introduced in API level 13.

      ``android:largestWidthLimitDp``
         This attribute lets you force-enable `screen compatibility mode <#compat-mode>`__ by specifying the maximum "smallest
         screen width" for which your application is designed. If the
         smallest side of a device's available screen is greater than
         your value here, the application runs in screen compatibility
         mode, with no way for the user to disable it.

         If your application is compatible with all screen sizes and its
         layout properly resizes, you don't need to use this attribute.
         Otherwise, first consider using the
         `android:compatibleWidthLimitDp <#compatibleWidth>`__
         attribute. Use the ``android:largestWidthLimitDp`` attribute
         only when your application is functionally broken when resized
         for larger screens, and screen compatibility mode is the only
         way that your application can be used.

         **Note:** Currently, screen compatibility mode emulates only
         handset screens with a 320dp width, so screen compatibility
         mode isn't applied if your value for
         ``android:largestWidthLimitDp`` is larger than ``320``.

         This attribute was introduced in API level 13.

   introduced in:
      API level 4
   see also:
      -  `Screen compatibility overview <#>`__
      -  `DisplayMetrics <#>`__

Last updated 2023-05-04 UTC.


/manifest uses-configuration
============================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <uses-configuration
           android:reqFiveWayNav=["true" | "false"]
           android:reqHardKeyboard=["true" | "false"]
           android:reqKeyboardType=["undefined" | "nokeys" | "qwerty" | "twelvekey"]
           android:reqNavigation=["undefined" | "nonav" | "dpad" | "trackball" | "wheel"]
           android:reqTouchScreen=["undefined" | "notouch" | "stylus" | "finger"] />

   contained in:
      ``<manifest>``
   description:
      Indicates the hardware and software features the application
      requires. For example, an application might specify that it
      requires a physical keyboard or a particular navigation device,
      like a trackball. The specification is used to avoid installing
      the application on devices where it doesn't work.

      **Note:** Most apps don't use this manifest tag. *Always* support
      input with a directional pad (D-pad) to assist sight-impaired
      users and support devices that provide D-pad input in addition to
      or instead of touch.

      For information about how to support D-pad input in your app, read
      `Handle controller actions <#>`__.
      If your app absolutely can't function without a touchscreen, then
      instead use the
      ``<uses-feature>``
      tag to declare the required touchscreen type, ranging from
      ``"android.hardware.faketouch"`` for basic touch-style events to
      more advanced touch types such as
      ``"android.hardware.touchscreen.multitouch.jazzhand"`` for
      distinct input from multiple fingers.

   attributes:
      ``android:reqFiveWayNav``
         Whether the application requires a five-way navigation control.
         It's ``"true"`` if it does, and ``"false"`` if not. A five-way
         control is one that can move the selection up, down, right, or
         left, and also provides a way of invoking the current
         selection. It can be a directional pad (D-pad), trackball, or
         other device.

         If an application requires a directional control, but not a
         control of a particular type, it can set this attribute to
         ``"true"`` and ignore the `reqNavigation <#nav>`__
         attribute. However, if it requires a particular type of
         directional control, it can ignore this attribute and set
         ``reqNavigation`` instead.

      ``android:reqHardKeyboard``
         Whether the application requires a hardware keyboard. It's
         ``"true"`` if it does, and ``"false"`` if not.
      ``android:reqKeyboardType``
         The type of keyboard the application requires, if any. This
         attribute doesn't distinguish between hardware and software
         keyboards. If a hardware keyboard of a certain type is
         required, specify the type here and also set the
         ``reqHardKeyboard`` attribute to ``"true"``.

         The value must be one of the following strings:

         .. list-table::
            :header-rows: 1

            - 

               - Value
               - Description
            - 

               - "``undefined``"
               - The application doesn't require a keyboard. A keyboard
                  requirement isn't defined. This is the default value.
            - 

               - "``nokeys``"
               - The application doesn't require a keyboard.
            - 

               - "``qwerty``"
               - The application requires a standard QWERTY keyboard.
            - 

               - "``twelvekey``"
               - The application requires a twelve-key keypad, like
                  those on most phones, with keys for the digits from
                  ``0`` through ``9``, plus star (``*``) and pound
                  (``#``) keys.

      ``android:reqNavigation``
         The navigation device required by the application, if any. The
         value must be one of the following strings:

         .. list-table::
            :header-rows: 1

            - 

               - Value
               - Description
            - 

               - "``undefined``"
               - The application doesn't require any type of navigation
                  control. The navigation requirement isn't defined.
                  This is the default value.
            - 

               - "``nonav``"
               - The application doesn't require a navigation control.
            - 

               - "``dpad``"
               - The application requires a D-pad for navigation.
            - 

               - "``trackball``"
               - The application requires a trackball for navigation.
            - 

               - "``wheel``"
               - The application requires a navigation wheel.

         If an application requires a navigational control, but the
         exact type of control doesn't matter, it can set the
         `reqFiveWayNav <#five>`__ attribute to ``"true"`` rather
         than setting this one.

      ``android:reqTouchScreen``
         The type of touch screen the application requires, if any. The
         value must be one of the following strings:

         .. list-table::
            :widths: 36 36
            :header-rows: 1

            - 

               - Value
               - Description
            - 

               - "``undefined``"
               - The application doesn't require a touch screen. The
                  touch screen requirement is undefined. This is the
                  default value.
            - 

               - "``notouch``"
               - The application doesn't require a touch screen.
            - 

               - "``stylus``"
               - The application requires a touch screen that is
                  operated with a stylus.
            - 

               - "``finger``"
               - The application requires a touch screen that is
                  operated with a finger.
                  **Note:** If some type of touch input is required for
                  your app, instead use the
                  ``<uses-feature>``
                  tag to declare the required touchscreen type,
                  beginning with ``"android.hardware.faketouch"`` for
                  basic touch-style events.

   introduced in:
      API level 3
   see also:
      -  `configChanges <#config>`__
         attribute of the
         ``<activity>``
         element
      -  `ConfigurationInfo <#>`__

Last updated 2023-05-04 UTC.


/manifest uses-feature
======================

.. container:: devsite-article-body clearfix

   .. note::

      Google Play uses the ``<uses-feature>`` elements declared in your
      app manifest to filter your app from devices that don't meet its
      hardware and software feature requirements.

      By specifying the features that your application requires, you
      enable Google Play to present your application only to users whose
      devices meet the application's feature requirements, rather than
      presenting it to all users.

      For important information about how Google Play uses features as
      the basis for filtering, see the `Google Play and feature-based filtering <#market-feature-filtering>`__ section.

   syntax:
      .. code:: prettyprint

         <uses-feature
           android:name="string"
           android:required=["true" | "false"]
           android:glEsVersion="integer" />

   contained in:
      ``<manifest>``
   description:
      Declares a single hardware or software feature that is used by the
      application.

      The purpose of a ``<uses-feature>`` declaration is to inform any
      external entity of the set of hardware and software features your
      application depends on. The element offers a ``required``
      attribute that lets you specify whether your application requires
      and can't function without the declared feature or prefers to have
      the feature but can function without it.

      Because feature support can vary across Android devices, the
      ``<uses-feature>`` element serves an important role in letting an
      application describe the device-variable features that it uses.

      The set of available features that your application declares
      corresponds to the set of feature constants made available by the
      Android
      `PackageManager <#>`__.
      Feature constants are listed in the `Features reference <#features-reference>`__ section in this document.

      You must specify each feature in a separate ``<uses-feature>``
      element, so if your application requires multiple features, it
      declares multiple ``<uses-feature>`` elements. For example, an
      application that requires both Bluetooth and camera features in
      the device declares these two elements:

      .. code:: prettyprint

         <uses-feature android:name="android.hardware.bluetooth" android:required="true" />
         <uses-feature android:name="android.hardware.camera.any" android:required="true" />

      In general, always declare ``<uses-feature>`` elements for all the
      features that your application requires.

      Declared ``<uses-feature>`` elements are informational only,
      meaning that the Android system itself doesn't check for matching
      feature support on the device before installing an application.

      However, other services, such as Google Play, and applications can
      check your application's ``<uses-feature>`` declarations as part
      of handling or interacting with your application. For this reason,
      it's very important that you declare all of the features that your
      application uses.

      For some features, there might be a specific attribute that lets
      you define a version of the feature, such as the version of Open
      GL used (declared with `glEsVersion <#glEsVersion>`__). Other
      features that either do or don't exist for a device, such as a
      camera, are declared using the `name <#name>`__ attribute.

      Although the ``<uses-feature>`` element is only activated for
      devices running API Level 4 or higher, include these elements for
      all applications, even if the
      `minSdkVersion <#min>`__
      is 3 or lower. Devices running older versions of the platform
      ignore the element.

      **Note:** When declaring a feature, remember that you must also
      request permissions as appropriate. For example, you need to
      request the
      `CAMERA <#CAMERA>`__
      permission before your application can access the camera API.
      Requesting the permission grants your application access to the
      appropriate hardware and software. Declaring the features used by
      your application helps ensure proper device compatibility.

   attributes:
      ``android:name``
         Specifies a single hardware or software feature used by the
         application as a descriptor string. Valid attribute values are
         listed in the `Hardware features <#hw-features>`__ and
         `Software features <#sw-features>`__ sections. These attribute
         values are case-sensitive.
      ``android:required``
         Boolean value that indicates whether the application requires
         the feature specified in ``android:name``.

         -  Declaring ``android:required="true"`` for a feature
            indicates that the application *can't function, or isn't
            designed to function*, when the specified feature isn't
            present on the device.
         -  Declaring ``android:required="false"`` for a feature
            indicates that the application *uses the feature if present*
            on the device, but that it *is designed to function without
            the specified feature* if necessary.

         The default value for ``android:required`` is ``"true"``.

      ``android:glEsVersion``
         The OpenGL ES version required by the application. The higher
         16 bits represent the major number and the lower 16 bits
         represent the minor number. For example, to specify OpenGL ES
         version 2.0, you set the value as "0x00020000", or to specify
         OpenGL ES 3.2, you set the value as "0x00030002".

         An application specifies at most one ``android:glEsVersion``
         attribute in its manifest. If it specifies more than one, the
         ``android:glEsVersion`` with the numerically highest value is
         used and any other values are ignored.

         If an application doesn't specify an ``android:glEsVersion``
         attribute, then it is assumed that the application requires
         only OpenGL ES 1.0, which is supported by all Android-powered
         devices.

         An application can assume that if a platform supports a given
         OpenGL ES version, it also supports all numerically lower
         OpenGL ES versions. Therefore, for an application that requires
         both OpenGL ES 1.0 and OpenGL ES 2.0, specify that it requires
         OpenGL ES 2.0.

         For an application that can work with any of several OpenGL ES
         versions, only specify the numerically lowest version of OpenGL
         ES that it requires. It can check at runtime whether a higher
         level of OpenGL ES is available.

         For more information about using OpenGL ES, including how to
         check the supported OpenGL ES version at runtime, see the
         `OpenGL ES API guide <#>`__.

   introduced in:
      API Level 4
   see also:
      -  `PackageManager <#>`__
      -  `FeatureInfo <#>`__
      -  `ConfigurationInfo <#>`__
      -  ``<uses-permission>``
      -  `Filters on Google Play <#>`__

   .. rubric:: Google Play and feature-based filtering
      :name: market-feature-filtering

   Google Play filters the applications that are visible to users so
   that users can see and download only those applications that are
   compatible with their device. One of the ways it filters applications
   is by feature compatibility.

   To determine an application's feature compatibility with a given
   user's device, Google Play compares:

   -  Features required by the application, as declared in
      ``<uses-feature>`` elements in the application's manifest.
   -  Features available on the device, in hardware or software, as
      reported using read-only system properties.

   To accurately compare features, the Android Package Manager provides
   a shared set of feature constants that both applications and devices
   use to declare feature requirements and support. The available
   feature constants are listed in the `Features reference <#features-reference>`__ section in this document and in
   the class documentation for
   `PackageManager <#>`__.

   When the user launches Google Play, the application queries the
   package manager for the list of features available on the device by
   calling
   `getSystemAvailableFeatures() <#getSystemAvailableFeatures>`__.
   The Store application then passes the features list up to Google Play
   when establishing the session for the user.

   Each time you upload an application to the Google Play Console,
   Google Play scans the application's manifest file. It looks for
   ``<uses-feature>`` elements and evaluates them in combination with
   other elements, in some cases, such as ``<uses-sdk>`` and
   ``<uses-permission>`` elements. After establishing the application's
   set of required features, it stores that list internally as metadata
   associated with the application APK and the application version.

   When a user searches or browses for applications using the Google
   Play application, the service compares the features needed by each
   application with the features available on the user's device. If all
   of an application's required features are present on the device,
   Google Play lets the user see the application and potentially
   download it.

   If any required feature isn't supported by the device, Google Play
   filters the application so that it isn't visible to the user or
   available for download.

   Because the features you declare in ``<uses-feature>`` elements
   directly affect how Google Play filters your application, it's
   important to understand how Google Play evaluates the application's
   manifest and establishes the set of required features. The following
   sections provide more information.

   .. rubric:: Filtering based on explicitly declared features
      :name: declared

   An explicitly declared feature is one that your application declares
   in a ``<uses-feature>`` element. The feature declaration can include
   an ``android:required=["true" | "false"]`` attribute if you are
   compiling against API level 5 or higher.

   This lets you specify whether the application requires the feature
   and can't function properly without it (``"true"``) or uses the
   feature if available, but is designed to run without it
   (``"false"``).

   Google Play handles explicitly declared features in this way:

   -  If a feature is explicitly declared as being required, as shown in
      the following example, Google Play adds the feature to the list of
      required features for the application. It then filters the
      application from users on devices that don't provide that feature.

      .. code:: prettyprint

         <uses-feature android:name="android.hardware.camera.any" android:required="true" />

   -  If a feature is explicitly declared as *not* being required, as
      shown in the following example, Google Play *doesn't* add the
      feature to the list of required features. For that reason, an
      explicitly declared non-required feature is never considered when
      filtering the application. Even if the device doesn't provide the
      declared feature, Google Play still considers the application
      compatible with the device and shows it to the user, unless other
      filtering rules apply.

      .. code:: prettyprint

         <uses-feature android:name="android.hardware.camera" android:required="false" />

   -  If a feature is explicitly declared, but without an
      ``android:required`` attribute, Google Play assumes that the
      feature is required and sets up filtering on it.

   In general, if your application is designed to run on Android 1.6 and
   lower, the ``android:required`` attribute isn't available in the API,
   and Google Play assumes that all ``<uses-feature>`` declarations are
   required.

   **Note:** By declaring a feature explicitly and including an
   ``android:required="false"`` attribute, you can effectively disable
   all filtering on Google Play for the specified feature.

   .. rubric:: Filter based on implicit features
      :name: implicit

   An *implicit* feature is one that an application requires in order to
   function properly, but which is *not* declared in a
   ``<uses-feature>`` element in the manifest file. Strictly speaking,
   it is best for every application to *always* declare all features
   that it uses or requires, and the absence of a declaration for a
   feature used by an application can be considered an error.

   However, as a safeguard for users and developers, Google Play looks
   for implicit features in each application and sets up filters for
   those features, as it does for explicitly declared features.

   An application might require a feature but not declare it for reasons
   like the following:

   -  The application was compiled against an older version of the
      Android library (Android 1.5 or earlier), for which the
      ``<uses-feature>`` element isn't available.
   -  The developer incorrectly assumes that the feature is present on
      all devices and a declaration is unnecessary.
   -  The developer omits the feature declaration accidentally.
   -  The developer declares the feature explicitly, but the declaration
      isn't valid. For example, a spelling error in the
      ``<uses-feature>`` element name or an unrecognized string value
      for the ``android:name`` attribute invalidates the feature
      declaration.

   To account for these cases, Google Play attempts to discover an
   application's implied feature requirements by examining *other
   elements* declared in the manifest file, specifically
   ``<uses-permission>`` elements.

   If an application requests hardware-related permissions, Google Play
   assumes that the application uses the underlying hardware features
   and therefore requires those features, even if there are no
   corresponding ``<uses-feature>`` declarations. For such permissions,
   Google Play adds the underlying hardware features to the metadata
   that it stores for the application and sets up filters for them.

   For example, if an application requests the ``CAMERA`` permission,
   Google Play assumes the application requires a back (world-facing)
   camera even if the app doesn't declare a ``<uses-feature>`` element
   for ``android.hardware.camera``. As a result, Google Play filters
   devices that don't have a back camera.

   If you don't want Google Play to filter based on a specific implied
   feature, explicitly declare the feature in a ``<uses-feature>``
   element and include the ``android:required="false"`` attribute. For
   example, to disable filtering implied by the ``CAMERA`` permission,
   declare the following features:

   .. code:: prettyprint

      <uses-feature android:name="android.hardware.camera" android:required="false" />
      <uses-feature android:name="android.hardware.camera.autofocus" android:required="false" />

   **Caution:** Permissions that you request in ``<uses-permission>``
   elements can directly affect how Google Play filters your
   application. The `Permissions that imply feature requirements <#permissions>`__ section lists the full set of
   permissions that imply feature requirements and therefore trigger
   filtering.

   .. rubric:: Special handling for Bluetooth feature
      :name: bt-permission-handling

   Google Play applies slightly different rules than described in the
   preceding example when determining filtering for Bluetooth.

   If an application declares a Bluetooth permission in a
   ``<uses-permission>`` element but doesn't explicitly declare the
   Bluetooth feature in a ``<uses-feature>`` element, Google Play checks
   the version(s) of the Android platform on which the application is
   designed to run, as specified in the ``<uses-sdk>`` element.

   As shown in the following table, Google Play enables filtering for
   the Bluetooth feature only if the application declares its lowest or
   targeted platform as Android 2.0 (API level 5) or higher. However,
   note that Google Play applies the normal rules for filtering when the
   application explicitly declares the Bluetooth feature in a
   ``<uses-feature>`` element.

   **Table 1.** How Google Play determines the Bluetooth feature
   requirement for an application that requests a Bluetooth permission
   but doesn't declare the Bluetooth feature in a ``<uses-feature>``
   element.

   .. list-table::
      :header-rows: 1

      - 

         - If ``minSdkVersion`` is ...
         - and ``targetSdkVersion`` is
         - Result
      - 

         - <=4, or ``<uses-sdk>`` isn't declared
         - <=4
         - Google Play *doesn't* filter the application from any devices
            based on their reported support for the
            ``android.hardware.bluetooth`` feature.
      - 

         - <=4
         - >=5
         - Google Play filters the application from any devices that
            don't support the ``android.hardware.bluetooth`` feature
            (including older releases).
      - 

         - >=5
         - >=5
         - 

   The following examples illustrate the different filtering effects
   based on how Google Play handles the Bluetooth feature.

   In the first example, an application that is designed to run on older
   API levels declares a Bluetooth permission but doesn't declare the
   Bluetooth feature in a ``<uses-feature>`` element.
   *Result:* Google Play doesn't filter the application from any device.
   .. code:: prettyprint

      <manifest ...>
          <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
          <uses-sdk android:minSdkVersion="3" />
          ...
      </manifest>

   In the second example, the same application also declares a target
   API level of "5".
   *Result:* Google Play now assumes that the feature is required and
   filters the application from all devices that don't report Bluetooth
   support, including devices running older versions of the platform.
   .. code:: prettyprint

      <manifest ...>
          <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
          <uses-sdk android:minSdkVersion="3" android:targetSdkVersion="5" />
          ...
      </manifest>

   Here, the same application now specifically declares the Bluetooth
   feature.
   *Result:* Identical to the previous example: filtering is applied.
   .. code:: prettyprint

      <manifest ...>
          <uses-feature android:name="android.hardware.bluetooth" />
          <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
          <uses-sdk android:minSdkVersion="3" android:targetSdkVersion="5" />
          ...
      </manifest>

   Finally, in the following case, the same application adds an
   ``android:required="false"`` attribute.
   *Result:* Google Play disables filtering based on Bluetooth feature
   support for all devices.
   .. code:: prettyprint

      <manifest ...>
          <uses-feature android:name="android.hardware.bluetooth" android:required="false" />
          <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
          <uses-sdk android:minSdkVersion="3" android:targetSdkVersion="5" />
          ...
      </manifest>

   .. rubric:: Test the features required by your application
      :name: testing

   You can use the ``aapt2`` tool, included in the Android SDK, to
   determine how Google Play filters your application based on its
   declared features and permissions. To do so, run ``aapt2`` with the
   ``dump badging`` command. This causes ``aapt2`` to parse your
   application's manifest and apply the same rules used by Google Play
   to determine the features that your application requires.

   To use the tool, follow these steps:

   #. Build and export your application as an unsigned APK. If you are
      developing in Android Studio, build your application with Gradle,
      as follows:

      a. Open the project and select **Run > Edit Configurations**.
      b. Select the plus sign near the top-left corner of the
         **Run/Debug Configurations** window.
      c. Select **Gradle.**
      d. Enter "Unsigned APK" in **Name**.
      e. Choose your module from the **Gradle project** section.
      f. Enter "assemble" in **Tasks**.
      g. Select **OK** to complete the new configuration.
      h. Make sure the **Unsigned APK** run configuration is selected in
         the toolbar, and then select **Run > Run 'Unsigned APK'**.

      You can find your unsigned APK in the
      ``<``\ *``ProjectName``*\ ``>/app/build/outputs/apk/`` directory.

   #. Locate the ``aapt2`` tool, if it isn't already in your PATH. If
      you are using SDK Tools r8 or higher, you can find ``aapt2`` in
      the
      ``<``\ *``SDK``*\ ``>/build-tools/<``\ *``tools version number``*\ ``>``
      directory.

      **Note:** You must use the version of ``aapt2`` that is provided
      for the latest Build-Tools component available. If you don't have
      the latest Build-Tools component, download it using the `Android SDK Manager <#sdk-manager>`__.

   #. Run ``aapt2`` using this syntax:

   .. code:: none

      $ aapt2 dump badging <path_to_exported_.apk>

   Here's an example of the command output for the second Bluetooth
   example shown previously:

   .. code:: none

      $ ./aapt2 dump badging BTExample.apk
      package: name='com.example.android.btexample' versionCode='' versionName=''
      uses-permission:'android.permission.BLUETOOTH_ADMIN'
      uses-feature:'android.hardware.bluetooth'
      sdkVersion:'3'
      targetSdkVersion:'5'
      application: label='BT Example' icon='res/drawable/app_bt_ex.png'
      launchable activity name='com.example.android.btexample.MyActivity'label='' icon=''
      uses-feature:'android.hardware.touchscreen'
      main
      supports-screens: 'small' 'normal' 'large'
      locales: '--_--'
      densities: '160'

   .. rubric:: Features reference
      :name: features-reference

   The following sections provide reference information about hardware
   features, software features, and sets of permissions that imply
   specific feature requirements.

   .. rubric:: Hardware features
      :name: hw-features

   This section presents the hardware features supported by the most
   current platform release. To indicate that your app uses or requires
   a hardware feature, declare the corresponding value, beginning with
   ``"android.hardware"``, in an ``android:name`` attribute. Each time
   you declare a hardware feature, use a separate ``<uses-feature>``
   element.

   .. rubric:: Audio hardware features
      :name: audio-hw-features

   ``android.hardware.audio.low_latency``
      The app uses the device's low-latency audio pipeline, which
      reduces lag and delays when processing sound input or output.
   ``android.hardware.audio.output``
      The app transmits sound using the device's speakers, audio jack,
      Bluetooth streaming capabilities, or a similar mechanism.
   ``android.hardware.audio.pro``
      The app uses the device's high-end audio functionality and
      performance capabilities.
   ``android.hardware.microphone``
      The app records audio using the device's microphone.

   .. rubric:: Bluetooth hardware features
      :name: bluetooth-hw-features

   ``android.hardware.bluetooth``
      The app uses the device's Bluetooth features, usually to
      communicate with other Bluetooth-enabled devices.
   ``android.hardware.bluetooth_le``
      The app uses the device's Bluetooth Low Energy radio features.

   .. rubric:: Camera hardware features
      :name: camera-hw-features

   **Note:** To prevent unnecessary filtering of your app by Google
   Play, add ``android:required="false"`` to any camera feature your app
   can function without. Otherwise, Google Play assumes the feature is
   required and prevents devices that don't support the feature from
   accessing your app.

   .. rubric:: Large screen support
      :name: large-screen-support

   Some large screen devices don't support all camera features.
   Chromebooks typically don't have back (world-facing) cameras,
   autofocus, or flash. But Chromebooks do have front (user-facing)
   cameras and are often connected to external cameras.

   To provide basic camera support and make your app available to as
   many devices as possible, add the following camera feature settings
   to your app manifest:

   .. code:: prettyprint

      <uses-feature android:name="android.hardware.camera.any" android:required="false" />
      <uses-feature android:name="android.hardware.camera" android:required="false" />
      <uses-feature android:name="android.hardware.camera.autofocus" android:required="false" />
      <uses-feature android:name="android.hardware.camera.flash" android:required="false" />

   Adjust the feature settings to support your app's use cases. But, to
   make your app available to the greatest number of devices, always
   include the ``required`` attribute to explicitly specify whether a
   feature is a must‚Äëhave.

   .. rubric:: Feature list
      :name: feature-list

   ``android.hardware.camera.any``
      The app uses one of the device's cameras or an external camera
      connected to the device. Use this feature instead of
      ``android.hardware.camera`` or ``android.hardware.camera.front``
      if your app doesn't *require* the camera to be back (world) facing
      or front (user) facing, respectively.

      The ``CAMERA`` permission implies that your app also uses
      ``android.hardware.camera``. A back camera is a required feature
      unless ``android.hardware.camera`` is declared with
      ``android:required="false"``.

   ``android.hardware.camera``
      The app uses the device's back (world-facing) camera.

      **Caution:** Devices such as Chromebooks that have only a front
      (user-facing) camera don't support this feature. Use
      ``android.hardware.camera.any`` if your app can use any camera,
      regardless of the direction the camera faces.

      .. note::

         | **Note:** The
           `CAMERA <#CAMERA>`__
           permission implies that a back camera is a required feature.
           To help ensure proper filtering on Google Play when your app
           manifest includes the ``CAMERA`` permission, explicitly
           specify that your app uses the ``camera`` feature and
           indicate whether it's required, such as:
         | ``<uses-feature android:name="android.hardware.camera" android:required="false" />``

   ``android.hardware.camera.front``
      The app uses the device's front (user-facing) camera.

      The ``CAMERA`` permission implies that your app also uses
      ``android.hardware.camera``. A back camera is a required feature
      unless ``android.hardware.camera`` is declared with
      ``android:required="false"``.

      **Caution:** If your app uses ``android.hardware.camera.front``
      but doesn't explicitly declare ``android.hardware.camera`` with
      ``android.required="false"``, devices that don't have a back
      camera (like Chromebooks) are filtered by Google Play. If your app
      supports devices with only front cameras, declare
      ``android.hardware.camera`` with ``android.required="false"`` to
      prevent unnecessary filtering.

   ``android.hardware.camera.external``
      The app communicates with an external camera the user connects to
      the device. This feature doesn't guarantee that an external camera
      is available for your app to use.

      The ``CAMERA`` permission implies that your app also uses
      ``android.hardware.camera``. A back camera is a required feature
      unless ``android.hardware.camera`` is declared with
      ``android:required="false"``.

   ``android.hardware.camera.autofocus``
      The app uses the autofocus feature supported by the device's
      camera.

      | **Note:** The
        `CAMERA <#CAMERA>`__
        permission implies that autofocus is a required feature. To help
        ensure proper filtering on Google Play when your app manifest
        includes the ``CAMERA`` permission, explicitly specify that your
        app uses the autofocus feature and indicate whether it is
        required or not, such as:
      | ``<uses-feature android:name="android.hardware.camera.autofocus" android:required="false" />``.

   ``android.hardware.camera.flash``
      The app uses the flash feature supported by the device's camera.

   ``android.hardware.camera.capability.manual_post_processing``
      The app uses the ``MANUAL_POST_PROCESSING`` feature supported by
      the device's camera.

      This feature lets your app override the camera's auto white
      balance functionality. Use ``android.colorCorrection.transform``,
      ``android.colorCorrection.gains``, and an
      ``android.colorCorrection.mode`` of ``TRANSFORM_MATRIX``.

   ``android.hardware.camera.capability.manual_sensor``
      The app uses the ``MANUAL_SENSOR`` feature supported by the
      device's camera.

      This feature implies support for auto exposure locking
      (``android.control.aeLock``), which enables the camera's exposure
      time and sensitivity to remain fixed at specific values.

   ``android.hardware.camera.capability.raw``
      The app uses the ``RAW`` feature supported by the device's camera.

      This feature implies that the device can save DNG (raw) files. The
      device's camera provides the DNG-related metadata necessary for
      your app to process the raw images directly.

   ``android.hardware.camera.level.full``
      The app uses the ``FULL`` level of image capture support provided
      by at least one of the device's cameras. ``FULL`` support includes
      burst-capture capabilities, per frame control, and manual
      post-processing control. See
      `INFO_SUPPORTED_HARDWARE_LEVEL_FULL <#INFO_SUPPORTED_HARDWARE_LEVEL_FULL>`__.

   .. rubric:: Device UI hardware features
      :name: device-ui-hw-features

   ``android.hardware.type.automotive``
      The app is designed to show its UI on a set of screens inside a
      vehicle. The user interacts with the app using hard buttons,
      touch, rotary controllers, and mouse-like interfaces. The
      vehicle's screens usually appear in the center console or the
      instrument cluster of a vehicle. These screens usually have
      limited size and resolution.

      **Note:** Since the user is driving while using this type of app
      UI, the app must minimize driver distraction.

   ``android.hardware.type.television``
      (Deprecated; use
      `android.software.leanback <#media-sw-features>`__ instead.)

      The app is designed to show its UI on a television. This feature
      defines "television" as a typical living-room television
      experience: the app displaying on a big screen, the user sitting
      far away, and the dominant form of input being something like a
      D-pad, rather than a mouse, pointer, or touch device.

   ``android.hardware.type.watch``
      The app is designed to show its UI on a watch. A watch is worn on
      the body, such as on the wrist. The user is very close to the
      device while interacting with it.
   ``android.hardware.type.pc``
      The app is designed to show its UI on Chromebooks. This feature
      disables input emulation for mouse and touchpad, since Chromebooks
      use mouse and touchpad hardware. See `Mouse input <#disable_input_translation_mode>`__.

      **Note:** Set ``required="false"`` for this element; otherwise,
      Google Play Store makes your app unavailable to devices other than
      Chromebooks.

   .. rubric:: Fingerprint hardware features
      :name: fingerprint-hw-features

   ``android.hardware.fingerprint``
      The app reads fingerprints using the device's biometric hardware.

   .. rubric:: Gamepad hardware features
      :name: gamepad-hw-features

   ``android.hardware.gamepad``
      The app captures game controller input, either from the device
      itself or from a connected gamepad.

   .. rubric:: Infrared hardware features
      :name: infrared-hw-features

   ``android.hardware.consumerir``
      The app uses the device's infrared (IR) capabilities, usually to
      communicate with other consumer IR devices.

   .. rubric:: Location hardware features
      :name: location-hw-features

   ``android.hardware.location``
      The app uses one or more features on the device for determining
      location, such as GPS location, network location, or cell
      location.
   ``android.hardware.location.gps``
      The app uses precise location coordinates obtained from a Global
      Positioning System (GPS) receiver on the device.

      By using this feature, an app implies that it also uses the
      ``android.hardware.location`` feature, unless this parent feature
      is declared with the attribute ``android:required="false"``.

   ``android.hardware.location.network``
      The app uses coarse location coordinates obtained from a
      network-based geolocation system supported on the device.

      By using this feature, an app implies that it also uses the
      ``android.hardware.location`` feature, unless this parent feature
      is declared with the attribute ``android:required="false"``.

   .. rubric:: NFC hardware features
      :name: nfc-hw-features

   ``android.hardware.nfc``
      The app uses the device's Near-Field Communication (NFC) radio
      features.
   ``android.hardware.nfc.hce``
      The app uses NFC card emulation that is hosted on the device.

   .. rubric:: OpenGL ES hardware features
      :name: opengl-es-hw-features

   ``android.hardware.opengles.aep``
      The app uses the `OpenGL ES Android Extension Pack <http://www.khronos.org/registry/gles/extensions/ANDROID/ANDROID_extension_pack_es31a.txt>`__
      that is installed on the device.

   .. rubric:: Sensor hardware features
      :name: sensor-hw-features

   ``android.hardware.sensor.accelerometer``
      The app uses motion readings from the device's accelerometer to
      detect the device's current orientation. For example, an app might
      use accelerometer readings to determine when to switch between
      portrait and landscape orientations.
   ``android.hardware.sensor.ambient_temperature``
      The app uses the device's ambient (environmental) temperature
      sensor. For example, a weather app can report indoor or outdoor
      temperature.
   ``android.hardware.sensor.barometer``
      The app uses the device's barometer. For example, a weather app
      might report air pressure.
   ``android.hardware.sensor.compass``
      The app uses the device's magnetometer (compass). For example, a
      navigation app might show the current direction a user faces.
   ``android.hardware.sensor.gyroscope``
      The app uses the device's gyroscope to detect rotation and twist,
      creating a six-axis orientation system. By using this sensor, an
      app can detect more smoothly when it needs to switch between
      portrait and landscape orientations.
   ``android.hardware.sensor.hifi_sensors``
      The app uses the device's high fidelity (Hi-Fi) sensors. For
      example, a gaming app might detect the user's high-precision
      movements.
   ``android.hardware.sensor.heartrate``
      The app uses the device's heart rate monitor. For example, a
      fitness app might report trends in a user's heart rate over time.
   ``android.hardware.sensor.heartrate.ecg``
      The app uses the device's electrocardiogram (ECG) heart rate
      sensor. For example, a fitness app might report more detailed
      information about a user's heart rate.
   ``android.hardware.sensor.light``
      The app uses the device's light sensor. For example, an app might
      display one of two color schemes based on the ambient lighting
      conditions.
   ``android.hardware.sensor.proximity``
      The app uses the device's proximity sensor. For example, a
      telephony app might turn off the device's screen when the app
      detects that the user is holding the device close to their body.
   ``android.hardware.sensor.relative_humidity``
      The app uses the device's relative humidity sensor. For example, a
      weather app might use the humidity to calculate and report the
      current dewpoint.
   ``android.hardware.sensor.stepcounter``
      The app uses the device's step counter. For example, a fitness app
      might report the number of steps a user needs to take to achieve
      their daily step count goal.
   ``android.hardware.sensor.stepdetector``
      The app uses the device's step detector. For example, a fitness
      app might use the time interval between steps to infer the type of
      exercise that the user is doing.

   .. rubric:: Screen hardware features
      :name: screen-hw-features

   ``android.hardware.screen.landscape``
   ``android.hardware.screen.portrait``
      The app requires the device to use the portrait or landscape
      orientation. If your app supports both orientations, then you
      don't need to declare either feature.

      For example, if your app requires portrait orientation, declare
      the following feature so that only the devices that support
      portrait orientation, always or by user choice, can run your app:

      .. code:: prettyprint

         <uses-feature android:name="android.hardware.screen.portrait" />

      Both orientations are assumed to not be required by default, so
      your app can install on devices that support one or both
      orientations. However, if any of your activities request that they
      run in a specific orientation, using the
      `android:screenOrientation <#screen>`__
      attribute, then this declaration implies that your app requires
      that orientation.

      For example, if you declare ``android:screenOrientation`` with
      either ``"landscape"``, ``"reverseLandscape"``, or
      ``"sensorLandscape"``, then your app is available only on devices
      that support landscape orientation.

      As a best practice, declare your requirement for this orientation
      using a ``<uses-feature>`` element. If you declare an orientation
      for your activity using ``android:screenOrientation`` but don't
      actually require it, you can disable the requirement by declaring
      the orientation with a ``<uses-feature>`` element and include
      ``android:required="false"``.

      For backward compatibility, any device running Android 3.1 (API
      level 12) or lower supports both landscape and portrait
      orientations.

   .. rubric:: Telephony hardware features
      :name: telephony-hw-features

   ``android.hardware.telephony``
      The app uses the device's telephony features, such as telephony
      radio with data communication services.
   ``android.hardware.telephony.cdma``
      The app uses the Code Division Multiple Access (CDMA) telephony
      radio system.

      By using this feature, an app implies that it also uses the
      ``android.hardware.telephony`` feature, unless this parent feature
      is declared with ``android:required="false"``.

   ``android.hardware.telephony.gsm``
      The app uses the Global System for Mobile Communications (GSM)
      telephony radio system.

      By using this feature, an app implies that it also uses the
      ``android.hardware.telephony`` feature, unless this parent feature
      is declared with ``android:required="false"``.

   .. rubric:: Touchscreen hardware features
      :name: touchscreen-hw-features

   ``android.hardware.faketouch``
      The app uses basic touch interaction events, such as tapping and
      dragging.

      When declared as required, this feature indicates that the app is
      compatible with a device only if that device has an emulated "fake
      touch" touchscreen or has an actual touchscreen.

      A device that offers a fake touch interface provides a user input
      system that emulates a subset of a touchscreen's capabilities. For
      example, a mouse or remote control might drive an on-screen
      cursor.

      If your app requires basic point and click interaction and doesn't
      work with only a D-pad controller, declare this feature. Because
      this is the minimum level of touch interaction, you can also use
      an app that declares this feature on devices that offer more
      complex touch interfaces.

      Apps require the ``android.hardware.faketouch`` feature by
      default. If you want your app to be limited to devices that only
      have a touchscreen, you must explicitly declare that touchscreen
      is required as follows:

      .. code:: prettyprint

         <uses-feature android:name="android.hardware.touchscreen"
             android:required="true" />

      All apps that don't explicitly require
      ``android.hardware.touchscreen``, as shown in the following
      example, also work on devices with ``android.hardware.faketouch``.

      .. code:: prettyprint

         <uses-feature android:name="android.hardware.touchscreen" android:required="false" />

   ``android.hardware.faketouch.multitouch.distinct``
      The app tracks two or more distinct "fingers" on a fake touch
      interface. This is a superset of the
      ``android.hardware.faketouch`` feature. When declared as required,
      this feature indicates that the app is compatible with a device
      only if that device emulates distinct tracking of two or more
      fingers or has an actual touchscreen.

      Unlike the distinct multitouch defined by
      ``android.hardware.touchscreen.multitouch.distinct``, input
      devices that support distinct multitouch with a fake touch
      interface don't support all two-finger gestures, because the input
      is transformed to cursor movement on the screen. That is,
      single-finger gestures on such a device move a cursor, two-finger
      swipes cause single-finger touch events to occur, and other
      two-finger gestures trigger the corresponding two-finger touch
      events.

      A device that provides a two-finger touch trackpad for cursor
      movement can support this feature.

   ``android.hardware.faketouch.multitouch.jazzhand``
      The app tracks five or more distinct "fingers" on a fake touch
      interface. This is a superset of the
      ``android.hardware.faketouch`` feature. When declared as required,
      this feature indicates that the app is compatible with a device
      only if that device emulates distinct tracking of five or more
      fingers or has an actual touchscreen.

      Unlike the distinct multitouch defined by
      ``android.hardware.touchscreen.multitouch.jazzhand``, input
      devices that support jazzhand multitouch with a fake touch
      interface don't support all five-finger gestures, because the
      input is transformed to cursor movement on the screen. That is,
      single-finger gestures on such a device move a cursor,
      multi-finger gestures cause single-finger touch events to occur,
      and other multi-finger gestures trigger the corresponding
      multi-finger touch events.

      A device that provides a five-finger touch trackpad for cursor
      movement can support this feature.

   ``android.hardware.touchscreen``
      The app uses the device's touchscreen capabilities for gestures
      that are more interactive than basic touch events, such as a
      fling. This is a superset of the ``android.hardware.faketouch``
      feature.

      By default, all apps require this feature and therefore aren't
      available to devices that provide only an emulated "fake touch"
      interface. You can make your app available on devices that provide
      a fake touch interface, or even on devices that provide only a
      D-pad controller, by explicitly declaring that a touchscreen is
      not required using ``android.hardware.touchscreen`` with
      ``android:required="false"``. Add this declaration if your app
      uses, but doesn't require, a real touchscreen interface. All apps
      that don't explicitly require ``android.hardware.touchscreen``
      also work on devices with ``android.hardware.faketouch``.

      If your app in fact requires a touch interface, such as to perform
      more advanced touch gestures like flings, then you don't need to
      declare any touch interface features, because they're required by
      default. However, it's best if you explicitly declare all features
      that your app uses.

      If you require more complex touch interaction, such as
      multi-finger gestures, declare that your app uses advanced
      touchscreen features.

   ``android.hardware.touchscreen.multitouch``
      The app uses the device's basic two-point multitouch capabilities,
      such as for pinch gestures, but the app doesn't need to track
      touches independently. This is a superset of the
      ``android.hardware.touchscreen`` feature.

      By using this feature, an app implies that it also uses the
      ``android.hardware.touchscreen`` feature, unless this parent
      feature is declared with ``android:required="false"``.

   ``android.hardware.touchscreen.multitouch.distinct``
      The app uses the device's advanced multitouch capabilities for
      tracking two or more points independently. This feature is a
      superset of the ``android.hardware.touchscreen.multitouch``
      feature.

      By using this feature, an app implies that it also uses the
      ``android.hardware.touchscreen.multitouch`` feature, unless this
      parent feature is declared with ``android:required="false"``.

   ``android.hardware.touchscreen.multitouch.jazzhand``
      The app uses the device's advanced multitouch capabilities for
      tracking five or more points independently. This feature is a
      superset of the ``android.hardware.touchscreen.multitouch``
      feature.

      By using this feature, an app implies that it also uses the
      ``android.hardware.touchscreen.multitouch`` feature, unless this
      parent feature is declared with ``android:required="false"``.

   .. rubric:: USB hardware features
      :name: usb-hw-features

   ``android.hardware.usb.accessory``
      The app behaves as a USB device and connects to USB hosts.
   ``android.hardware.usb.host``
      The app uses the USB accessories that are connected to the device.
      The device serves as the USB host.

   .. rubric:: Vulkan hardware features
      :name: vulkan-hw-features

   ``android.hardware.vulkan.compute``
      The app uses Vulkan compute features. This feature indicates that
      the app requires the hardware-accelerated Vulkan implementation.
      The feature version indicates which level of optional compute
      features the app requires beyond the Vulkan 1.0 requirements. For
      example, if your app requires Vulkan compute level 0 support,
      declare the following feature:

      .. code:: prettyprint

         <uses-feature
             android:name="android.hardware.vulkan.compute"
             android:version="0"
             android:required="true" />

      For more details about the feature version, see
      ``\ `FEATURE_VULKAN_HARDWARE_COMPUTE <#FEATURE_VULKAN_HARDWARE_COMPUTE>`__.

   ``android.hardware.vulkan.level``
      The app uses Vulkan level features. This feature indicates that
      the app requires the hardware-accelerated Vulkan implementation.
      The feature version indicates which level of optional hardware
      features the app requires. For example, if your app requires
      Vulkan hardware level 0 support, declare the following feature:

      .. code:: prettyprint

         <uses-feature
             android:name="android.hardware.vulkan.level"
             android:version="0"
             android:required="true" />

      For more information about the feature version, see
      ``\ `FEATURE_VULKAN_HARDWARE_LEVEL <#FEATURE_VULKAN_HARDWARE_LEVEL>`__.

   ``android.hardware.vulkan.version``
      The app uses Vulkan. This feature indicates that the app requires
      the hardware-accelerated Vulkan implementation. The feature
      version indicates the minimum version of Vulkan API support the
      app requires. For example, if your app requires Vulkan 1.0
      support, declare the following feature:

      .. code:: prettyprint

         <uses-feature
             android:name="android.hardware.vulkan.version"
             android:version="0x400003"
             android:required="true" />

      For more details about the feature version, see
      ``\ `FEATURE_VULKAN_HARDWARE_VERSION <#FEATURE_VULKAN_HARDWARE_VERSION>`__.

   .. rubric:: Wi-Fi hardware features
      :name: wi-fi-hw-features

   ``android.hardware.wifi``
      The app uses 802.11 networking (Wi-Fi) features on the device.
   ``android.hardware.wifi.direct``
      The app uses the Wi-Fi Direct networking features on the device.

   .. rubric:: Software features
      :name: sw-features

   This section presents the software features supported by the most
   current platform release. To indicate that your app uses or requires
   a software feature, declare the corresponding value, beginning with
   ``"android.software"``, in an ``android:name`` attribute. Each time
   you declare a software feature, use a separate ``<uses-feature>``
   element.

   .. rubric:: Communication software features
      :name: communication-sw-features

   ``android.software.sip``
      The app uses Session Initiation Protocol (SIP) services. By using
      SIP, the app can support internet telephony operations, such as
      video conferencing and instant messaging.
   ``android.software.sip.voip``
      The app uses SIP-based Voice Over Internet Protocol (VoIP)
      services. By using VoIP, the app can support real-time internet
      telephony operations, such as two-way video conferencing.

      By using this feature, an app implies that it also uses the
      ``android.software.sip`` feature, unless this parent feature is
      declared with ``android:required="false"``.

   ``android.software.webview``
      The app displays content from the internet.

   .. rubric:: Custom input software features
      :name: custom-input-sw-features

   ``android.software.input_methods``
      The app uses a new input method, which the developer defines in an
      `InputMethodService <#>`__.

   .. rubric:: Device management software features
      :name: device-management-sw-features

   ``android.software.backup``
      The app includes logic to handle a backup and restore operation.
   ``android.software.device_admin``
      The app uses device administrators to enforce a device policy.
   ``android.software.managed_users``
      The app supports secondary users and managed profiles.
   ``android.software.securely_removes_users``
      The app can **permanently** remove users and their associated
      data.
   ``android.software.verified_boot``
      The app includes logic to handle results from the device's
      verified boot feature, which detects whether the device's
      configuration changes during a restart operation.

   .. rubric:: Media software features
      :name: media-sw-features

   ``android.software.midi``
      The app connects to musical instruments or outputs sound using the
      Musical Instrument Digital Interface (MIDI) protocol.
   ``android.software.print``
      The app includes commands for printing documents displayed on the
      device.
   ``android.software.leanback``
      The app is designed to run on Android TV devices.
   ``android.software.live_tv``
      The app streams live television programs.

   .. rubric:: Screen interface software features
      :name: screen-interface-sw-features

   ``android.software.app_widgets``
      The app uses or provides App Widgets and is intended only for
      devices that include a Home screen or similar location where users
      can embed App Widgets.
   ``android.software.home_screen``
      The app behaves as a replacement to the device's Home screen.
   ``android.software.live_wallpaper``
      The app uses or provides wallpapers that include animation.

   .. rubric:: Permissions that imply feature requirements
      :name: permissions

   Some hardware and software feature constants are made available to
   applications after the corresponding API. Because of this, some apps
   might *use* the API before they can declare that they *require* the
   API using the ``<uses-feature>`` system.

   To prevent those apps from being made available unintentionally,
   Google Play assumes that certain hardware-related permissions
   indicate that the underlying hardware features are required by
   default. For instance, applications that use Bluetooth must request
   the ``BLUETOOTH`` permission in a ``<uses-permission>`` element.

   For legacy apps, Google Play assumes that the permission declaration
   means that the underlying ``android.hardware.bluetooth`` feature is
   required by the application and sets up filtering based on that
   feature. Table 2 lists permissions that imply feature requirements
   equivalent to those declared in ``<uses-feature>`` elements.

   ``<uses-feature>`` declarations, including any declared
   ``android:required`` attribute, always take precedence over features
   implied by the permissions in table 2. For any of these permissions,
   you can disable filtering based on the implied feature by explicitly
   declaring the feature in a ``<uses-feature>`` element with the
   ``required`` attribute set to ``false``.

   For example, to disable filtering based on the ``CAMERA`` permission,
   add the following ``<uses-feature>`` declarations to the manifest
   file:

   .. code:: prettyprint

      <uses-feature android:name="android.hardware.camera" android:required="false" />
      <uses-feature android:name="android.hardware.camera.autofocus" android:required="false" />

   **Caution:** If your app targets Android 5.0 (API level 21) or higher
   and uses the ``ACCESS_COARSE_LOCATION`` or ``ACCESS_FINE_LOCATION``
   permission to receive location updates from the network or a GPS,
   respectively, you must also explicitly declare that your app uses the
   ``android.hardware.location.network`` or
   ``android.hardware.location.gps`` hardware features.

   **Table 2.** Device permissions that imply device hardware use.

   .. list-table::
      :widths: 24 24 24
      :header-rows: 1

      - 

         - Category
         - Permission
         - Implied feature requirement
      - 

         - Bluetooth
         - ``BLUETOOTH``
         - ``android.hardware.bluetooth``
            See `Special handling for Bluetooth feature <#bt-permission-handling>`__ for details.
      - 

         - 
         - ``BLUETOOTH_ADMIN``
         - ``android.hardware.bluetooth``
      - 

         - Camera
         - ``CAMERA``
         - ``android.hardware.camera``
            ``android.hardware.camera.autofocus``
      - 

         - Location
         - ``ACCESS_MOCK_LOCATION``
         - ``android.hardware.location``
      - 

         - 
         - ``ACCESS_LOCATION_EXTRA_COMMANDS``
         - ``android.hardware.location``
      - 

         - 
         - ``INSTALL_LOCATION_PROVIDER``
         - ``android.hardware.location``
      - 

         - 
         - ``ACCESS_COARSE_LOCATION``
         - ``android.hardware.location``

            ``android.hardware.location.network`` (Only when target API
            level is 20 or lower.)
      - 

         - 
         - ``ACCESS_FINE_LOCATION``
         - ``android.hardware.location``

            ``android.hardware.location.gps`` (Only when target API
            level is 20 or lower.)
      - 

         - Microphone
         - ``RECORD_AUDIO``
         - ``android.hardware.microphone``
      - 

         - Telephony
         - ``CALL_PHONE``
         - ``android.hardware.telephony``
      - 

         - 
         - ``CALL_PRIVILEGED``
         - ``android.hardware.telephony``
      - 

         - 
         - ``MODIFY_PHONE_STATE``
         - ``android.hardware.telephony``
      - 

         - 
         - ``PROCESS_OUTGOING_CALLS``
         - ``android.hardware.telephony``
      - 

         - 
         - ``READ_SMS``
         - ``android.hardware.telephony``
      - 

         - 
         - ``RECEIVE_SMS``
         - ``android.hardware.telephony``
      - 

         - 
         - ``RECEIVE_MMS``
         - ``android.hardware.telephony``
      - 

         - 
         - ``RECEIVE_WAP_PUSH``
         - ``android.hardware.telephony``
      - 

         - 
         - ``SEND_SMS``
         - ``android.hardware.telephony``
      - 

         - 
         - ``WRITE_APN_SETTINGS``
         - ``android.hardware.telephony``
      - 

         - 
         - ``WRITE_SMS``
         - ``android.hardware.telephony``
      - 

         - Wi-Fi
         - ``ACCESS_WIFI_STATE``
         - ``android.hardware.wifi``
      - 

         - 
         - ``CHANGE_WIFI_STATE``
         - ``android.hardware.wifi``
      - 

         - 
         - ``CHANGE_WIFI_MULTICAST_STATE``
         - ``android.hardware.wifi``

Last updated 2023-12-15 UTC.


/manifest uses-library
======================

.. container:: devsite-article-body clearfix

   **Note:** Google Play uses the ``<uses-library>`` elements declared
   in your app manifest to filter your app from devices that don't meet
   its library requirements. For more information about filtering, see
   `Filters on Google Play <#>`__.

   syntax:
      .. code:: prettyprint

         <uses-library
           android:name="string"
           android:required=["true" | "false"] />

   contained in:
      ``\ ``<application>``\ ``
   description:
      Specifies a shared library that the application must be linked
      against. This element tells the system to include the library's
      code in the class loader for the package.

      All the ``android`` packages, such as
      `android.app <#>`__,
      `android.content <#>`__,
      `android.view <#>`__,
      and
      `android.widget <#>`__,
      are in the default library that all applications are automatically
      linked against. However, some packages, such as ``maps``, are in
      separate libraries that aren't automatically linked. Consult the
      documentation for the packages you're using to determine which
      library contains the package code.

      The order of ``<uses-library>`` tags is significant. It affects
      class lookup and resolution order when the application loads. Some
      of the libraries might have duplicate classes, and in that case
      the library that comes first takes priority.

      This element also affects the installation of the application on a
      particular device and the availability of the application on
      Google Play. If this element is present and its
      ``android:required`` attribute is set to ``"true"``, the
      `PackageManager <#>`__
      framework won't let a user install the application unless the
      library is present on the user's device.

      The ``android:required`` attribute is described in detail in the
      following section.

   attributes:
      ``android:name``
         The name of the library. The name is provided by the
         documentation for the package you are using. An example of this
         is ``"android.test.runner"``, a package that contains Android
         test classes.
      ``android:required``
         Boolean value that indicates whether the application requires
         the library specified by ``android:name``.

         -  ``"true"``: the application doesn't function without this
            library. The system doesn't let the application install on a
            device that doesn't have the library.

         -  ``"false"``: the application uses the library if present,
            but is designed to function without it if necessary. The
            system lets the application install, even if the library
            isn't present. If you use ``"false"``, you are responsible
            for checking at runtime that the library is available.

            To check for a library, you can use reflection to determine
            whether a particular class is available.

         The default is ``"true"``.

         Introduced in: API level 7.

   introduced in:
      API Level 1
   see also:
      -  `PackageManager <#>`__

Last updated 2023-03-29 UTC.


/manifest uses-native-library
=============================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <uses-native-library
           android:name="string"
           android:required=["true" | "false"] />

   contained in:
      ``\ ``<application>``\ ``
   description:
      Specifies a `vendor-provided shared native library <https://source.android.google.cn/devices/tech/config/namespaces_libraries#adding-additional-native-libraries>`__
      that the application must be linked against. This element tells
      the system to make the native library accessible for the package.

      NDK libraries are by default accessible and therefore don't
      require the ``<uses-native-library>`` tag.

      Non-NDK native shared libraries that are provided by silicon
      vendors or device manufacturers aren't accessible by default if
      the app targets ``Android 12`` (API ``level 31``) or higher. The libraries
      are accessible only when they are explicitly requested using the
      ``<uses-native-library>`` tag.

      If the app targets ``Android 11`` (API ``level 30``) or lower, the
      ``<uses-native-library>`` tag isn't required. In that case, any
      native shared library is accessible regardless of whether it is an
      NDK library.

      This element also affects the installation of the application on a
      particular device. If this element is present and its
      ``android:required`` attribute is set to ``true``, the
      `PackageManager <#>`__
      framework won't let a user install the application unless the
      library is present on the user's device.

      The ``android:required`` attribute is described in detail in the
      following section.

   attributes:
      ``android:name``
         The name of the library file.
      ``android:required``
         Boolean value that indicates whether the application requires
         the library specified by ``android:name``.

         -  ``"true"``: the application doesn't function without this
            library. The system doesn't let the application install on a
            device that doesn't have the library.
         -  ``"false"``: the application uses the library if present,
            but is designed to function without it if necessary. The
            system lets the application install, even if the library
            isn't present. If you use ``"false"``, you are responsible
            for gracefully handling the absence of the library.

         The default is ``"true"``.

   introduced in:
      API level 31
   see also:
      -  `PackageManager <#>`__
      -  <uses-library>

Last updated 2024-05-03 UTC.


/manifest uses-permission
=========================

.. container:: devsite-article-body clearfix

   .. note::

      **Note:** In some cases, the permissions that you request through
      ``<uses-permission>`` can affect how Google Play filters your
      application. If you request a hardware-related permission, such as
      ``CAMERA``, Google Play assumes that your application requires the
      underlying hardware feature and filters the application from
      devices that don't offer it.

      To control filtering, always explicitly declare hardware features
      in ``<uses-feature>`` elements, rather than relying on Google Play
      to "discover" the requirements in ``<uses-permission>`` elements.
      Then, if you want to disable filtering for a particular feature,
      you can add a ``android:required="false"`` attribute to the
      ``<uses-feature>`` declaration.

      For a list of permissions that imply hardware features, see the
      documentation for the
      `<#permissions-features>`__
      element.

   syntax:
      .. code:: prettyprint

         <uses-permission android:name="string"
                 android:maxSdkVersion="integer" />

   contained in:
      ``<manifest>``
   description:
      Specifies a system permission that the user must grant for the app
      to operate correctly. The user grants permissions when the
      application installs, on devices running Android 5.1 and lower, or
      while the app runs, on devices running Android 6.0 and higher.
      For more information on permissions, see the
      `Permissions <#perms>`__
      section in the app manifest overview and the `Permissions on Android <#>`__ guide. A list of
      permissions defined by the base platform is at
      `android.Manifest.permission <#>`__.
   attributes:
      ``android:name``
         The name of the permission. It can be a permission defined by
         the application with the
         ``<permission>``
         element, a permission defined by another application, or one of
         the standard system permissions, such as
         `"android.permission.CAMERA" <#CAMERA>`__
         or
         `"android.permission.READ_CONTACTS" <#READ_CONTACTS>`__.
         As these examples show, a permission name typically includes
         the package name as a prefix.
      ``android:maxSdkVersion``
         The highest API level at which this permission is granted to
         your app. Setting this attribute is useful if the permission
         your app requires is no longer needed beginning at a certain
         API level.

         For example, beginning with Android 4.4 (API level 19) it's no
         longer necessary for your app to request the
         `WRITE_EXTERNAL_STORAGE <#WRITE_EXTERNAL_STORAGE>`__
         permission to write to its own application-specific directories
         on external storage, which are provided by
         `getExternalFilesDir() <#getExternalFilesDir>`__.

         However, the permission *is required* for API level 18 and
         lower. So you can declare that this permission is needed only
         up to API level 18 with a declaration like the following:

         .. code:: prettyprint

            <uses-permission
                 android:name="android.permission.WRITE_EXTERNAL_STORAGE"
                 android:maxSdkVersion="18" />

         This way, beginning with API level 19, the system no longer
         grants your app the ``WRITE_EXTERNAL_STORAGE`` permission.

         Added in API level 19.

   introduced in:
      API level 1
   see also:
      -  ``<permission>``
      -  ``<uses-permission-sdk-23>``
      -  ``<uses-feature>``

Last updated 2023-03-29 UTC.


/manifest uses-permission-sdk-23
================================

.. container:: devsite-article-body clearfix

   syntax:
      .. code:: prettyprint

         <uses-permission-sdk-23 android:name="string"
                 android:maxSdkVersion="integer" />

   contained in:
      ``<manifest>``
   description:
      Specifies that an app wants a particular permission, but only if
      the app is installed on a device running Android 6.0 (API level
      23) or higher. If the device runs API level 22 or lower, the app
      doesn't want the specified permission.

      This element is useful when you update an app to include a new
      feature that requires an additional permission. If a user updates
      an app on a device that is running API level 22 or lower, the
      system prompts the user at install time to grant all new
      permissions that are declared in that update. If a new feature is
      minor enough, you might prefer to disable the feature altogether
      on those devices, so the user doesn't have to grant additional
      permissions to update the app.

      By using the ``<uses-permission-sdk-23>`` element instead of
      ``<uses-permission>``,
      you can request the permission *only* if the app is running on
      platforms that support the `runtime permissions <#>`__ model, in which
      the user grants permissions to the app while it is running.

      For more information on permissions, see the
      `Permissions <#perms>`__ section in the app manifest overview and the
      `Permissions on Android <#>`__ guide. A list of
      permissions defined by the base platform is available at
      `android.Manifest.permission <#>`__.

   attributes:
      ``android:name``
         The name of the permission. This permission can be one defined
         by the app with the
         ``<permission>``
         element, it can be a permission defined by another app, or it
         can be one of the standard system permissions, such as
         `"android.permission.CAMERA" <#CAMERA>`__
         or
         `"android.permission.READ_CONTACTS" <#READ_CONTACTS>`__.
      ``android:maxSdkVersion``
         The highest API level at which this permission is granted to
         your app. If the app installs on a device with a later API
         level, the app isn't granted the permission and can't use any
         related functionality.

   introduced in:
      API level 23
   see also:
      -  ``<permission>``
      -  ``<uses-permission>``
      -  ``<uses-feature>``

Last updated 2024-04-29 UTC.


/manifest uses-sdk
==================

.. container:: devsite-article-body clearfix

   Google Play uses the ``<uses-sdk>`` attributes declared in your app
   manifest to filter your app from devices that don't meet its platform
   version requirements. Before setting these attributes, make sure that
   you understand `Google Play filters <#>`__.

   syntax:
      .. code:: prettyprint

         <uses-sdk android:minSdkVersion="integer"
                   android:targetSdkVersion="integer"
                   android:maxSdkVersion="integer" />

   contained in:
      ``<manifest>``
   description:
      Lets you express an application's compatibility with one or more
      versions of the Android platform by means of an API level integer.
      The API level expressed by an application is compared to the API
      level of a given Android system, which can vary among different
      Android devices.

      Despite its name, this element is used to specify the API level,
      *not* the version number of the software development kit (SDK) or
      Android platform. The API level is always a single integer. You
      can't derive the API level from its associated Android version
      number. For example, it isn't the same as the major version or the
      sum of the major and minor versions.

      Also read the document about `versioning your applications <#>`__.

   attributes:
      ``android:minSdkVersion``
         An integer designating the minimum API level required for the
         application to run. The Android system prevents the user from
         installing the application if the system's API level is lower
         than the value specified in this attribute. Always declare this
         attribute.

         **Caution:** If you don't declare this attribute, the system
         assumes a default value of "1", which indicates that your
         application is compatible with all versions of Android. If it
         *isn't*, and you didn't declare the proper ``minSdkVersion``,
         then when installed on a system with an incompatible API level,
         the application crashes during runtime when attempting to
         access the unavailable APIs. For this reason, be certain to
         declare the appropriate API level in the ``minSdkVersion``
         attribute.

      ``android:targetSdkVersion``
         An integer designating the API level that the application
         targets. If not set, the default value equals that given to
         ``minSdkVersion``.

         This attribute informs the system that you have tested against
         the target version, and the system doesn't enable any
         compatibility behaviors to maintain your app's
         forward-compatibility with the target version. The application
         is still able to run on lower versions (down to
         ``minSdkVersion``).

         As Android evolves with each new version, some behaviors and
         even appearances might change. However, if the API level of the
         platform is higher than the version declared by your app's
         ``targetSdkVersion``, the system can enable compatibility
         behaviors so that your app continues to work the way you
         expect. You can disable such compatibility behaviors by
         specifying ``targetSdkVersion`` to match the API level of the
         platform on which it's running.

         For example, setting this value to "11" or higher lets the
         system apply the Holo default theme to your app when running on
         Android 3.0 or higher and also disables 
         `screen compatibility mode <#>`__ when running on
         larger screens, because support for API level 11 implicitly
         supports larger screens.

         There are many compatibility behaviors that the system can
         enable based on the value you set for this attribute. Several
         of these behaviors are described by the corresponding platform
         versions in the
         `Build.VERSION_CODES <#>`__
         reference.

         To maintain your application along with each Android release,
         increase the value of this attribute to match the latest API
         level, then thoroughly test your application on the
         corresponding platform version.

         *Introduced in: API level 4*

      ``android:maxSdkVersion``
         An integer designating the maximum API level on which the
         application is designed to run.

         In Android 1.5, 1.6, 2.0, and 2.0.1, the system checks the
         value of this attribute when installing an application and when
         re-validating the application after a system update. In either
         case, if the application's ``maxSdkVersion`` attribute is lower
         than the API level used by the system itself, then the system
         doesn't let the application install. In the case of
         re-validation after system update, this effectively removes
         your application from the device.

         To illustrate how this attribute can affect your application
         after system updates, consider the following example:

         An application declaring ``maxSdkVersion="5"`` in its manifest
         is published on Google Play. A user whose device is running
         Android 1.6 (API level 4) downloads and installs the app. After
         a few weeks, the user receives an over-the-air system update to
         Android 2.0 (API level 5). After the update is installed, the
         system checks the application's ``maxSdkVersion`` and
         successfully re-validates it.

         The application functions as normal. However, some time later,
         the device receives another system update, this time to Android
         2.0.1 (API level 6). After the update, the system can no longer
         re-validate the application because the system's own API level
         (6) is now higher than the maximum supported by the application
         (5). The system prevents the application from being visible to
         the user, in effect removing it from the device.

         **Warning:** We don't recommend declaring this attribute.
         First, there is no need to set the attribute as a means of
         blocking deployment of your application onto new versions of
         the Android platform as they are released. By design, new
         versions of the platform are fully backward-compatible. Your
         application works properly on new versions, provided it uses
         only standard APIs and follows development best practices.
         Second, in some cases declaring the attribute can result in
         your application being removed from users' devices after a
         system update to a higher API level. Most devices on which your
         application is likely to be installed receive periodic system
         updates over the air, so consider their effect on your
         application before setting this attribute.

         *Introduced in: API level 4*

         .. container:: special

            Some versions of Android (beyond Android 2.0.1) don't check
            or enforce the ``maxSdkVersion`` attribute during
            installation or re-validation. Google Play continues to use
            the attribute as a filter, however, when presenting users
            with applications available for download.

   introduced in:
      API level 1

   .. rubric:: What is API level?
      :name: ApiLevels

   API level is an integer value that uniquely identifies the framework
   API revision offered by a version of the Android platform.

   The Android platform provides a framework API that applications can
   use to interact with the underlying Android system. The framework API
   consists of:

   -  A core set of packages and classes
   -  A set of XML elements and attributes for declaring a manifest file
   -  A set of XML elements and attributes for declaring and accessing
      resources
   -  A set of intents
   -  A set of permissions that applications can request, as well as
      permission enforcements included in the system

   Each successive version of the Android platform can include updates
   to the Android application framework API that it delivers.

   Updates to the framework API are designed so that the new API remains
   compatible with earlier versions of the API. That is, most changes in
   the API are additive and introduce new or replacement functionality.
   As parts of the API are upgraded, the older replaced parts are
   deprecated but aren't removed, so that existing applications can
   still use them.

   In a very small number of cases, parts of the API are modified or
   removed, although typically such changes are only needed to support
   API robustness and application or system security. All other API
   parts from earlier revisions are carried forward without
   modification.

   The framework API that an Android platform delivers is specified
   using an integer identifier called *API level*. Each Android platform
   version supports exactly one API level, although support is implicit
   for all earlier API levels (down to API level 1). The initial release
   of the Android platform provided API level 1, and subsequent releases
   have incremented the API level.

   The following table specifies the API level supported by each version
   of the Android platform. For information about the relative numbers
   of devices that are running each version, see the `Distribution dashboard <#>`__.

   ==========================  ===============  =======================  =========================
   Platform Version            API level        VERSION_CODE             Notes
   ==========================  ===============  =======================  =========================
   Android 15                  API 34 ‚Üí Beta 1  VANILLA_ICE_CREAM        Platform Highlights
   Android 14                  34               UPSIDE_DOWN_CAKE         Platform Highlights
   Android 13                  33               TIRAMISU                 Platform Highlights
   Android 12                  32               S_V2                     Platform Highlights
   \                           31               S                        Platform Highlights
   Android 11                  30               R                        Platform Highlights
   Android 10                  29               Q                        Platform Highlights
   Android 9                   28               P                        Platform Highlights
   Android 8.1                 27               O_MR1                    Platform Highlights
   Android 8.0                 26               O                        Platform Highlights
   Android 7.1.1, 7.1          25               N_MR1                    Platform Highlights
   Android 7.0                 24               N                        Platform Highlights
   Android 6.0                 23               M                        Platform Highlights
   Android 5.1                 22               LOLLIPOP_MR1             Platform Highlights
   Android 5.0                 21               LOLLIPOP
   Android 4.4W                20               KITKAT_WATCH             KitKat for Wearables Only
   Android 4.4                 19               KITKAT                   Platform Highlights
   Android 4.3                 18               JELLY_BEAN_MR2           Platform Highlights
   Android 4.2, 4.2.2          17               JELLY_BEAN_MR1           Platform Highlights
   Android 4.1, 4.1.1          16               JELLY_BEAN               Platform Highlights
   Android 4.0.3, 4.0.4        15               ICE_CREAM_SANDWICH_MR1   Platform Highlights
   Android 4.0, 4.0.1, 4.0.2   14               ICE_CREAM_SANDWICH
   Android 3.2                 13               HONEYCOMB_MR2
   Android 3.1.x               12               HONEYCOMB_MR1            Platform Highlights
   Android 3.0.x               11               HONEYCOMB                Platform Highlights
   Android 2.3.4, 2.3.3        10               GINGERBREAD_MR1          Platform Highlights
   Android 2.3.2, 2.3.1, 2.3   9                GINGERBREAD
   Android 2.2.x               8                FROYO                    Platform Highlights
   Android 2.1.x               7                ECLAIR_MR1               Platform Highlights
   Android 2.0.1               6                ECLAIR_0_1
   Android 2.0                 5                ECLAIR
   Android 1.6                 4                DONUT                    Platform Highlights
   Android 1.5                 3                CUPCAKE                  Platform Highlights
   Android 1.1                 2                BASE_1_1
   Android 1.0                 1                BASE                     
   ==========================  ===============  =======================  =========================

   .. rubric:: Uses of API level in Android
      :name: uses

   The API level identifier serves a key role in helping ensure the best
   possible experience for users and application developers:

   -  It lets the Android platform describe the maximum framework API
      revision that it supports.
   -  It lets applications describe the framework API revision that they
      require.
   -  It lets the system negotiate the installation of applications on
      the user's device so that version-incompatible applications aren't
      installed.

   Each Android platform version stores its API level identifier
   internally, in the Android system itself.

   Applications can use a manifest element provided by the framework
   API‚Äî``<uses-sdk>``‚Äîto describe the minimum and maximum API levels
   under which they are able to run as well as the preferred API level
   that they are designed to support. The element offers three key
   attributes:

   -  ``android:minSdkVersion``: the minimum API level on which the
      application is able to run. The default value is "1".
   -  ``android:targetSdkVersion``: the API level on which the
      application is designed to run. In some cases, this lets the
      application use manifest elements or behaviors defined in the
      target API level, rather than being restricted to using only those
      defined for the minimum API level.
   -  ``android:maxSdkVersion``: the maximum API level on which the
      application is able to run. **Important:** Read the 
      `information about this attribute <#maxsdk>`__ on this page before using it.

   For example, to specify the minimum system API level that an
   application requires in order to run, the application includes in its
   manifest a ``<uses-sdk>`` element with a ``android:minSdkVersion``
   attribute. The value of ``android:minSdkVersion`` is the integer
   corresponding to the API level of the earliest version of the Android
   platform under which the application can run.

   When the user attempts to install an application, or when
   revalidating an application after a system update, the Android system
   first checks the ``<uses-sdk>`` attributes in the application's
   manifest and compares the values against its own internal API level.
   The system lets the installation begin only if these conditions are
   met:

   -  If a ``android:minSdkVersion`` attribute is declared, its value is
      less than or equal to the system's API level integer. If not
      declared, the system assumes that the application requires API
      level 1.
   -  If a ``android:maxSdkVersion`` attribute is declared, its value is
      equal to or greater than the system's API level integer. If not
      declared, the system assumes that the application has no maximum
      API level. Read the `description of this attribute <#maxsdk>`__
      for more information about how the system handles it.

   When declared in an application's manifest, a ``<uses-sdk>`` element
   might look like this:

   .. code:: prettyprint

      <manifest>
        <uses-sdk android:minSdkVersion="5" />
        ...
      </manifest>

   The principal reason that an application declares an API level in
   ``android:minSdkVersion`` is to tell the Android system that it uses
   APIs that were *introduced* in the API level specified.

   If the application somehow installs on a platform with a lower API
   level, then it crashes at runtime when it tries to access APIs that
   don't exist. The system prevents this outcome by not letting the
   application install if the lowest API level it requires is higher
   than that of the platform version on the target device.

   .. rubric:: Development considerations
      :name: considerations

   The following sections provide information related to API level that
   you need to consider when developing your application.

   .. rubric:: Application forward compatibility
      :name: fc

   Android applications are generally forward-compatible with new
   versions of the Android platform.

   Because almost all changes to the framework API are additive, an
   Android application developed using any given version of the API, as
   specified by its API level, is forward-compatible with later versions
   of the Android platform and higher API levels. The application can
   run on all later versions of the Android platform, except in isolated
   cases where the application uses a part of the API that is later
   removed for some reason.

   Forward compatibility is important because many Android-powered
   devices receive over-the-air (OTA) system updates. The user might
   install your application and use it successfully, then later receive
   an OTA update to a new version of the Android platform. Once the
   update is installed, your application runs in a new runtime version
   of the environment, but one that still has the API and system
   capabilities that your application depends on.

   Changes *below* the API, such those in the underlying system itself,
   can affect your application when it is run in the new environment.
   It's important for you, as the application developer, to understand
   how the application looks and behaves in each system environment.

   To help you test your application on various versions of the Android
   platform, the Android SDK includes multiple platforms that you can
   download. Each platform includes a compatible system image that you
   can run in an AVD to test your application.

   .. rubric:: Application backward compatibility
      :name: bc

   Android applications aren't necessarily backward-compatible with
   versions of the Android platform older than the version against which
   they were compiled.

   Each new version of the Android platform can include new framework
   APIs, such as those that give applications access to new platform
   capabilities or replace existing API parts. The new APIs are
   accessible to applications when running on the new platform and also
   when running on later versions of the platform, as specified by API
   level. But because earlier versions of the platform don't include the
   new APIs, applications that use the new APIs can't run on those
   platforms.

   Although an Android-powered device isn't likely to be downgraded to a
   previous version of the platform, it's important to realize that
   there are likely to be many devices in the field that run earlier
   versions of the platform. Even among devices that receive OTA
   updates, some might lag and might not receive an update for a
   significant amount of time.

   .. rubric:: Select a platform version and API level
      :name: platform

   When you are developing your application, you choose the platform
   version against which you compile the application. In general,
   compile your application against the lowest possible version of the
   platform that your application can support.

   You can determine the lowest possible platform version by compiling
   the application against successively lower build targets. After you
   determine the lowest version, create an AVD using the corresponding
   platform version and API level, and fully test your application. Make
   sure to declare a ``android:minSdkVersion`` attribute in the
   application's manifest and set its value to the API level of the
   platform version.

   .. rubric:: Declare a minimum API level
      :name: apilevel

   If you build an application that uses APIs or system features
   introduced in the latest platform version, set the
   ``android:minSdkVersion`` attribute to the API level of the latest
   platform version. This is so that users are only able to install your
   application if their devices are running a compatible version of the
   Android platform. In turn, this helps ensure that your application
   can function properly on their devices.

   If your application uses APIs introduced in the latest platform
   version but does *not* declare a ``android:minSdkVersion`` attribute,
   then it runs properly on devices running the latest version of the
   platform, but *not* on devices running earlier versions of the
   platform. In the latter case, the application crashes at runtime when
   it tries to use APIs that don't exist on the earlier versions.

   .. rubric:: Test against higher API levels
      :name: testing

   After compiling your application, make sure to test it on the
   platform specified in the application's ``android:minSdkVersion``
   attribute. To do so, create an AVD that uses the platform version
   required by your application. Additionally, to check
   forward-compatibility, run and test the application on all platforms
   that use a higher API level than that used by your application.

   The Android SDK includes multiple platform versions that you can use,
   including the latest version, and provides an updater tool that you
   can use to download other platform versions as necessary.

   To access the updater, use the ``android`` command-line tool, located
   in the <sdk>/tools directory. You can launch the SDK updater by
   executing ``android sdk``. You can also double-click the
   ``android.bat`` (Windows) or ``android`` (OS X/Linux) file.

   To run your application against different platform versions in the
   emulator, create an AVD for each platform version that you want to
   test. For more information about AVDs, see `Create and manage virtual devices <#>`__. 
   If you are using a physical device for
   testing, make sure that you know the API level of the Android
   platform it runs. See the table in this document for a list of
   platform versions and their API levels.

   .. rubric:: Filter the reference documentation by API level
      :name: filtering

   Android platform reference documentation pages offer an "API level"
   control in the top-left area of each page. You can use the control to
   show documentation only for parts of the API that are actually
   accessible to your application, based on the API level that it
   specifies in the ``android:minSdkVersion`` attribute of its manifest
   file.

   To use filtering, select the API level specified by your application
   from the menu. APIs introduced in a later API level are then grayed
   out and their content is masked, since they aren't accessible to your
   application.

   Filtering by API level in the documentation doesn't provide a view of
   what is new or introduced in each API level. It provides a way to
   view the entire API associated with a given API level, while
   excluding API elements introduced in later API levels.

   To return to viewing the full documentation, select **REL**, at the
   top of the API level menu. By default, API level filtering is
   disabled, so that you can view the full framework API, regardless of
   API level.

   The reference documentation for individual API elements specifies the
   API level at which each element is introduced. The API level for
   packages and classes is specified as "Added in API level" at the
   top-right corner of the content area on each documentation page. The
   API level for class members is specified in their detailed
   description headers, at the right margin.

Last updated 2024-04-11 UTC.



/üíõ App architecture
=====================

.. container:: devsite-article-body clearfix

   App architecture design is an important consideration for ensuring
   that your apps are robust, testable, and maintainable. Android
   provides a set of libraries and components to help you put together
   your app according to best practices.

   .. container:: video-wrapper-full-width

   .. rubric:: Guides
      :name: guides

   -  Learn the basics of putting together a robust app with the `Guide to app architecture <#>`__.
   -  Improve the user experience by fine-tuning `app navigation <#>`__.
   -  Reduce boilerplate and make your code easier to maintain with the
      `dependency injection guides <#>`__.

   .. container:: section dac-section dac-small
      :name: graphics-cards

      .. container:: wrap

         .. rubric:: Latest news and videos
            :name: latest-news-and-videos
            :class: norule

Last updated 2023-07-12 UTC.


/Overveiw: Guide to app architecture
====================================

.. https://developer.android.google.cn/topic/architecture

.. container:: devsite-article-body clearfix

   This guide encompasses best practices and `recommended architecture <#recommended-app-arch>`__ for building robust,
   high-quality apps.

   **Note:**\  This page assumes a basic familiarity with the Android
   Framework. If you are new to Android app development, check out the
   `Android Basics course <#>`__ to
   get started and learn more about the concepts mentioned in this
   guide.
   
   .. rubric:: Mobile app user experiences
      :name: mobile-app-ux

   A typical Android app contains multiple `app components <#components>`__, including
   `activities <#>`__,
   `fragments <#>`__,
   `services <#>`__, `content providers <#>`__, and
   `broadcast receivers <#>`__. You declare
   most of these app components in your `app manifest <#>`__. The Android OS
   then uses this file to decide how to integrate your app into the
   device's overall user experience. Given that a typical Android app
   might contain multiple components and that users often interact with
   multiple apps in a short period of time, apps need to adapt to
   different kinds of user-driven workflows and tasks.

   Keep in mind that mobile devices are also resource-constrained, so at
   any time, the operating system might kill some app processes to make
   room for new ones.

   Given the conditions of this environment, it's possible for your app
   components to be launched individually and out-of-order, and the
   operating system or user can destroy them at any time. Because these
   events aren't under your control, you shouldn't store or keep in
   memory any application data or state in your app components, and your
   app components shouldn't depend on each other.

   .. rubric:: Common architectural principles
      :name: common-principles

   If you shouldn't use app components to store application data and
   state, how should you design your app instead?

   As Android apps grow in size, it's important to define an
   architecture that allows the app to scale, increases the app's
   robustness, and makes the app easier to test.

   An app architecture defines the boundaries between parts of the app
   and the responsibilities each part should have. In order to meet the
   needs mentioned above, you should design your app architecture to
   follow a few specific principles.

   .. rubric:: Separation of concerns
      :name: separation-of-concerns

   The most important principle to follow is 
   `separation of concerns <https://en.wikipedia.org/wiki/Separation_of_concerns>`__.
   It's a common mistake to write all your code in an
   `Activity <#>`__ or a `Fragment <#>`__. These UI-based
   classes should only contain logic that handles UI and operating
   system interactions. By keeping these classes as lean as possible,
   you can avoid many problems related to the component lifecycle, and
   improve the testability of these classes.

   Keep in mind that you don't own implementations of ``Activity`` and
   ``Fragment``; rather, these are just glue classes that represent the
   contract between the Android OS and your app. The OS can destroy them
   at any time based on user interactions or because of system
   conditions like low memory. To provide a satisfactory user experience
   and a more manageable app maintenance experience, it's best to
   minimize your dependency on them.

   .. rubric:: Drive UI from data models
      :name: drive-ui-from-model

   Another important principle is that you should drive your UI from
   data models, preferably persistent models. Data models represent the
   data of an app. They're independent from the UI elements and other
   components in your app. This means that they are not tied to the UI
   and app component lifecycle, but will still be destroyed when the OS
   decides to remove the app's process from memory.

   Persistent models are ideal for the following reasons:

   -  Your users don't lose data if the Android OS destroys your app to
      free up resources.

   -  Your app continues to work in cases when a network connection is
      flaky or not available.

   If you base your app architecture on data model classes, you make
   your app more testable and robust.

   .. rubric:: Single source of truth
      :name: single-source-of-truth

   When a new data type is defined in your app, you should assign a
   Single Source of Truth (SSOT) to it. The SSOT is the *owner* of that
   data, and only the SSOT can modify or mutate it. To achieve this, the
   SSOT exposes the data using an immutable type, and to modify the
   data, the SSOT exposes functions or receive events that other types
   can call.

   This pattern brings multiple benefits:

   -  It centralizes all the changes to a particular type of data in one
      place.
   -  It protects the data so that other types cannot tamper with it.
   -  It makes changes to the data more traceable. Thus, bugs are easier
      to spot.

   In an offline-first application, the source of truth for application
   data is typically a database. In some other cases, the source of
   truth can be a ViewModel or even the UI.

   .. rubric:: Unidirectional Data Flow
      :name: unidirectional-data-flow

   The `single source of truth principle <#single-source-of-truth>`__ is
   often used in our guides with the Unidirectional Data Flow (UDF)
   pattern. In UDF, **state** flows in only one direction. The
   **events** that modify the data flow in the opposite direction.

   In Android, state or data usually flow from the higher-scoped types
   of the hierarchy to the lower-scoped ones. Events are usually
   triggered from the lower-scoped types until they reach the SSOT for
   the corresponding data type. For example, application data usually
   flows from data sources to the UI. User events such as button presses
   flow from the UI to the SSOT where the application data is modified
   and exposed in an immutable type.

   This pattern better guarantees data consistency, is less prone to
   errors, is easier to debug and brings all the benefits of the SSOT
   pattern.

   .. rubric:: Recommended app architecture
      :name: recommended-app-arch

   This section demonstrates how to structure your app following
   recommended best practices.

   **Note:**\  The recommendations and best practices present in this
   page can be applied to a broad spectrum of apps to allow them to
   scale, improve quality and robustness, and make them easier to test.
   However, you should treat them as guidelines and adapt them to your
   requirements as needed.
   Considering the common architectural principles mentioned in the
   previous section, each application should have at least two layers:

   -  The *UI layer* that displays application data on the screen.
   -  The *data layer* that contains the business logic of your app and
      exposes application data.

   You can add an additional layer called the *domain layer* to simplify
   and reuse the interactions between the UI and data layers.

   .. figure::
https://developer.android.google.cn//topic/libraries/architecture/images/mad-arch-overview.png
      name: arch-overview
      :alt: In a typical app architecture, the UI layer gets the
      application data from the data layer or from the optional domain
      layer, which sits between the UI layer and the data layer.
      :width: 500px

   **Figure 1.** Diagram of a typical app architecture.
   **Note:**\  The arrows in the diagrams in this guide represent
   dependencies between classes. For example, the domain layer depends
   on data layer classes.

   .. rubric:: Modern App Architecture
      :name: modern-app-architecture

   This *Modern App Architecture* encourages using the following
   techniques, among others:

   -  A reactive and layered architecture.
   -  Unidirectional Data Flow (UDF) in all layers of the app.
   -  A UI layer with state holders to manage the complexity of the UI.
   -  Coroutines and flows.
   -  Dependency injection best practices.

   For more information, see the following sections, the other
   Architecture pages in the table of contents, and the `recommendations page <#>`__ that contains a summary
   of the most important best practices.

   .. rubric:: UI layer
      :name: ui-layer

   The role of the UI layer (or *presentation layer*) is to display the
   application data on the screen. Whenever the data changes, either due
   to user interaction (such as pressing a button) or external input
   (such as a network response), the UI should update to reflect the
   changes.

   The UI layer is made up of two things:

   -  UI elements that render the data on the screen. You build these
      elements using Views or `Jetpack Compose <#>`__
      functions.
   -  State holders (such as
      `ViewModel <#>`__ classes)
      that hold data, expose it to the UI, and handle logic.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-overview-ui.png
      name: arch-overview-ui
      :alt: In a typical architecture, the UI layer's UI elements depend
      on state holders, which in turn depend on classes from either the
      data layer or the optional domain layer.
      :width: 500px

   **Figure 2.** The UI layer's role in app architecture.
   To learn more about this layer, see the `UI layer page <#>`__.

   .. rubric:: Data layer
      :name: data-layer

   The data layer of an app contains the *business logic*. The business
   logic is what gives value to your app‚Äîit's made of rules that
   determine how your app creates, stores, and changes data.

   The data layer is made of *repositories* that each can contain zero
   to many *data sources*. You should create a repository class for each
   different type of data you handle in your app. For example, you might
   create a ``MoviesRepository`` class for data related to movies, or a
   ``PaymentsRepository`` class for data related to payments.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-overview-data.png
      name: arch-overview-data
      :alt: In a typical architecture, the data layer's repositories
      provide data to the rest of the app and depend on the data
      sources.
      :width: 500px

   **Figure 3.** The data layer's role in app architecture.
   Repository classes are responsible for the following tasks:

   -  Exposing data to the rest of the app.
   -  Centralizing changes to the data.
   -  Resolving conflicts between multiple data sources.
   -  Abstracting sources of data from the rest of the app.
   -  Containing business logic.

   Each data source class should have the responsibility of working with
   only one source of data, which can be a file, a network source, or a
   local database. Data source classes are the bridge between the
   application and the system for data operations.

   To learn more about this layer, see the `data layer page <#>`__.

   .. rubric:: Domain layer
      :name: domain-layer

   The domain layer is an optional layer that sits between the UI and
   data layers.

   The domain layer is responsible for encapsulating complex business
   logic, or simple business logic that is reused by multiple
   ViewModels. This layer is optional because not all apps will have
   these requirements. You should use it only when needed‚Äîfor example,
   to handle complexity or favor reusability.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-overview-domain.png
      name: arch-overview-domain
      :alt: When it is included, the optional domain layer provides
      dependencies to the UI layer and depends on the data layer.
      :width: 500px

   **Figure 4.** The domain layer's role in app architecture.
   Classes in this layer are commonly called *use cases* or
   *interactors*. Each use case should have responsibility over a
   *single* functionality. For example, your app could have a
   ``GetTimeZoneUseCase`` class if multiple ViewModels rely on time
   zones to display the proper message on the screen.

   To learn more about this layer, see the `domain layer page <#>`__.

   .. rubric:: Manage dependencies between components
      :name: dependencies

   Classes in your app depend on other classes in order to function
   properly. You can use either of the following design patterns to
   gather the dependencies of a particular class:

   -  `Dependency injection (DI) <#>`__:
      Dependency injection allows classes to define their dependencies
      without constructing them. At runtime, another class is
      responsible for providing these dependencies.
   -  `Service locator <https://en.wikipedia.org/wiki/Service_locator_pattern>`__:
      The service locator pattern provides a registry where classes can
      obtain their dependencies instead of constructing them.

   These patterns allow you to scale your code because they provide
   clear patterns for managing dependencies without duplicating code or
   adding complexity. Furthermore, these patterns allow you to quickly
   switch between test and production implementations.

   **We recommend following dependency injection patterns and using
   the** `Hilt library <#>`__
   **in Android apps.** Hilt automatically constructs objects by walking
   the dependency tree, provides compile-time guarantees on
   dependencies, and creates dependency containers for Android framework
   classes.

   .. rubric:: General best practices
      :name: best-practices

   Programming is a creative field, and building Android apps isn't an
   exception. There are many ways to solve a problem; you might
   communicate data between multiple activities or fragments, retrieve
   remote data and persist it locally for offline mode, or handle any
   number of other common scenarios that nontrivial apps encounter.

   Although the following recommendations aren't mandatory, in most
   cases following them makes your code base more robust, testable, and
   maintainable in the long run:

   **Don't store data in app components.**

   Avoid designating your app's entry points‚Äîsuch as activities,
   services, and broadcast receivers‚Äîas sources of data. Instead, they
   should only coordinate with other components to retrieve the subset
   of data that is relevant to that entry point. Each app component is
   rather short-lived, depending on the user's interaction with their
   device and the overall current health of the system.

   **Reduce dependencies on Android classes.**

   Your app components should be the only classes that rely on Android
   framework SDK APIs such as
   `Context <#>`__, or
   `Toast <#>`__. Abstracting other
   classes in your app away from them helps with testability and reduces
   `coupling <https://en.wikipedia.org/wiki/Coupling_(computer_programming)>`__
   within your app.

   **Create well-defined boundaries of responsibility between various
   modules in your app.**

   For example, don't spread the code that loads data from the network
   across multiple classes or packages in your code base. Similarly,
   don't define multiple unrelated responsibilities‚Äîsuch as data caching
   and data binding‚Äîin the same class. Following the `recommended app architecture <#recommended-app-arch>`__ will help you with this.

   **Expose as little as possible from each module.**

   For example, don't be tempted to create a shortcut that exposes an
   internal implementation detail from a module. You might gain a bit of
   time in the short term, but you are then likely to incur technical
   debt many times over as your codebase evolves.

   **Focus on the unique core of your app so it stands out from other
   apps.**

   Don't reinvent the wheel by writing the same boilerplate code again
   and again. Instead, focus your time and energy on what makes your app
   unique, and let the Jetpack libraries and other recommended libraries
   handle the repetitive boilerplate.

   **Consider how to make each part of your app testable in isolation.**

   For example, having a well-defined API for fetching data from the
   network makes it easier to test the module that persists that data in
   a local database. If instead, you mix the logic from these two
   modules in one place, or distribute your networking code across your
   entire code base, it becomes much more difficult‚Äîif not impossible‚Äîto
   test effectively.

   **Types are responsible for their concurrency policy.**

   If a type is performing long-running blocking work, it should be
   responsible for moving that computation to the right thread. That
   particular type knows the type of computation that it is doing and in
   which thread it should be executed. Types should be main-safe,
   meaning they're safe to call from the main thread without blocking
   it.

   **Persist as much relevant and fresh data as possible.**

   That way, users can enjoy your app's functionality even when their
   device is in offline mode. Remember that not all of your users enjoy
   constant, high-speed connectivity‚Äîand even if they do, they can get
   bad reception in crowded places.

   .. rubric:: Benefits of Architecture
      :name: architecture-benefits

   Having a good Architecture implemented in your app brings a lot of
   benefits to the project and engineering teams:

   -  It improves the maintainability, quality and robustness of the
      overall app.
   -  It allows the app to scale. More people and more teams can
      contribute to the same codebase with minimal code conflicts.
   -  It helps with onboarding. As Architecture brings consistency to
      your project, new members of the team can quickly get up to speed
      and be more efficient in less amount of time.
   -  It is easier to test. A good Architecture encourages simpler types
      which are generally easier to test.
   -  Bugs can be investigated methodically with well defined processes.

   Investing in Architecture also has a direct impact in your users.
   They benefit from a more stable application, and more features due to
   a more productive engineering team. However, Architecture also
   requires an up-front time investment. To help you justify this time
   to the rest of your company, take a look at these `case studies <#>`__ where other companies share their success
   stories when having a good architecture in their app.

   .. rubric:: Samples
      :name: samples

   The following Google samples demonstrate good app architecture. Go
   explore them to see this guidance in practice:

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Data layer <#>`__
   -  `UI layer <#>`__
   -  `UI events <#>`__

Last updated 2023-12-12 UTC.


/Overview: UI layer
===================

.. https://developer.android.google.cn/topic/architecture/ui-layer

.. container:: devsite-article-body clearfix

   The role of the UI is to display the application data on the screen
   and also to serve as the primary point of user interaction. Whenever
   the data changes, either due to user interaction (like pressing a
   button) or external input (like a network response), the UI should
   update to reflect those changes. *Effectively, the UI is a visual
   representation of the application state as retrieved from the data
   layer.*

   However, the application data you get from the data layer is usually
   in a different format than the information you need to display. For
   example, you might only need part of the data for the UI, or you
   might need to merge two different data sources to present information
   that is relevant to the user. Regardless of the logic you apply, you
   need to pass the UI all the information it needs to render fully.
   *The UI layer is the pipeline that converts application data changes
   to a form that the UI can present and then displays it.*

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-ui-overview.png
      name: ui-overview
      :alt: In a typical architecture, the UI layer's UI elements depend
      on state holders, which in turn depend on classes from either the
      data layer or the optional domain layer.
      :width: 500px

   **Figure 1.** The UI layer's role in app architecture.
   **Note:**\  The recommendations and best practices present in this
   page can be applied to a broad spectrum of apps to allow them to
   scale, improve quality and robustness, and make them easier to test.
   However, you should treat them as guidelines and adapt them to your
   requirements as needed.

   .. container:: video-wrapper-full-width

   .. rubric:: A basic case study
      :name: case-study

   Consider an app that fetches news articles for a user to read. The
   app has an articles screen that presents articles available to read,
   and also allows signed-in users to bookmark articles that really
   stand out. Given that there may be a lot of articles at any moment in
   time, the reader should be able to browse articles by category. In
   summary, the app lets users do the following:

   -  View articles available to read.
   -  Browse articles by category.
   -  Sign in and bookmark certain articles.
   -  Access some premium features if eligible.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-ui-basic-case-study.png
      name: ui-basic-case-study
      :width: 300px

   **Figure 2.** A sample news app for a UI case study.
   The following sections use this example as a case study to introduce
   the principles of unidirectional data flow, as well as illustrating
   the problems that these principles help solve in the context of app
   architecture for the UI layer.

   .. rubric:: UI layer architecture
      :name: architecture

   The term *UI* refers to UI elements such as activities and fragments
   that display the data, independent of what APIs they use to do this
   (Views or `Jetpack Compose <#>`__). Because the role
   of the `data layer <#>`__ is to hold, manage,
   and provide access to the app data, the UI layer must perform the
   following steps:

   #. Consume app data and transform it into data the UI can easily
      render.
   #. Consume UI-renderable data and transform it into UI elements for
      presentation to the user.
   #. Consume user input events from those assembled UI elements and
      reflect their effects in the UI data as needed.
   #. Repeat steps 1 through 3 for as long as necessary.

   The rest of this guide demonstrates how to implement a UI layer that
   performs these steps. In particular, this guide covers the following
   tasks and concepts:

   -  How to define the UI state.
   -  Unidirectional data flow (UDF) as a means of producing and
      managing the UI state.
   -  How to expose UI state with observable data types according to UDF
      principles.
   -  How to implement UI that consumes the observable UI state.

   The most fundamental of these is the definition of the UI state.

   .. rubric:: Define UI state
      :name: define-ui-state

   Refer to the `case study <#case-study>`__ outlined earlier. In short,
   the UI shows a list of articles along with some metadata for each
   article. This information that the app presents to the user is the UI
   state.

   In other words: if the UI is what the user sees, the UI state is what
   the app says they should see. Like two sides of the same coin, the UI
   is the visual representation of the UI state. Any changes to the UI
   state are immediately reflected in the UI.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-ui-elements-state.png
      name: ui-elements_state
      :alt: UI is a result of binding UI elements on the screen with the
      UI state.
      :width: 500px

   **Figure 3.** UI is a result of binding UI elements on the screen
   with the UI state.
   Consider the case study; in order to fulfill the News app's
   requirements, the information required to fully render the UI can be
   encapsulated in a ``NewsUiState`` data class defined as follows:

   .. code:: prettyprint

      data class NewsUiState(
          val isSignedIn: Boolean = false,
          val isPremium: Boolean = false,
          val newsItems: List<NewsItemUiState> = listOf(),
          val userMessages: List<Message> = listOf()
      )

      data class NewsItemUiState(
          val title: String,
          val body: String,
          val bookmarked: Boolean = false,
          ...
      )

   .. rubric:: Immutability
      :name: state-immutability

   The UI state definition in the example above is immutable. The key
   benefit of this is that immutable objects provide guarantees
   regarding the state of the application at an instant in time. This
   frees up the UI to focus on a single role: to read the state and
   update its UI elements accordingly. As a result, you should never
   modify the UI state in the UI directly unless the UI itself is the
   sole source of its data. Violating this principle results in multiple
   sources of truth for the same piece of information, leading to data
   inconsistencies and subtle bugs.

   For example, if the ``bookmarked`` flag in a ``NewsItemUiState``
   object from the UI state in the case study were updated in the
   ``Activity`` class, that flag would be competing with the data layer
   as the source of the bookmarked status of an article. Immutable data
   classes are very useful for preventing this kind of antipattern.

   **Key Point:**\  Only sources or owners of data should be responsible
   for updating the data they expose.

   .. rubric:: Naming conventions in this guide
      :name: naming-conventions

   In this guide, UI state classes are named based on the functionality
   of the screen or part of the screen they describe. The convention is
   as follows:

   *functionality* + *UiState*.

   For example, the state of a screen displaying news might be called
   ``NewsUiState``, and the state of a news item in a list of news items
   might be a ``NewsItemUiState``.

   .. rubric:: Manage state with Unidirectional Data Flow
      :name: udf

   The previous section established that the UI state is an immutable
   snapshot of the details needed for the UI to render. However, the
   dynamic nature of data in apps means that state might change over
   time. This might be due to user interaction or other events that
   modify the underlying data that is used to populate the app.

   These interactions may benefit from a mediator to process them,
   defining the logic to be applied to each event and performing the
   requisite transformations to the backing data sources in order to
   create UI state. These interactions and their logic may be housed in
   the UI itself, but this can quickly get unwieldy as the UI starts to
   become more than its name suggests: it becomes data owner, producer,
   transformer, and more. Furthermore, this can affect testability
   because the resulting code is a tightly coupled amalgam with no
   discernable boundaries. Ultimately, the UI stands to benefit from
   reduced burden. Unless the UI state is very simple, the UI's sole
   responsibility should be to consume and display UI state.

   This section discusses Unidirectional Data Flow (UDF), an
   architecture pattern that helps enforce this healthy separation of
   responsibility.

   .. rubric:: State holders
      :name: state-holders

   The classes that are responsible for the production of UI state and
   contain the necessary logic for that task are called *state holders*.
   State holders come in a variety of sizes depending on the scope of
   the corresponding UI elements that they manage, ranging from a single
   widget like a `bottom app bar <https://material.io/components/app-bars-bottom>`__ to a whole
   screen or a navigation destination.

   In the latter case, the typical implementation is an instance of a
   `ViewModel <#>`__, although
   depending on the requirements of the application, a simple class
   might suffice. The News app from the `case study <#case-study>`__,
   for example, uses a ``NewsViewModel`` class as a state holder to
   produce the UI state for the screen displayed in that section.

   **Key Point:**\  The
   `ViewModel <#>`__ type is
   the recommended implementation for the management of screen-level UI
   state with access to the data layer. Furthermore, it survives
   configuration changes automatically. ``ViewModel`` classes define the
   logic to be applied to events in the app and produce updated state as
   a result.
   There are many ways to model the codependency between the UI and its
   state producer. However, because the interaction between the UI and
   its ``ViewModel`` class can largely be understood as event *input*
   and its ensuing state *output*, the relationship can be represented
   as shown in the following diagram:

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-ui-udf.png
      name: ui-udf
      :alt: Application data flows from the data layer to the ViewModel.
      UI state flows from the ViewModel to the UI elements, and events
      flow from the UI elements back to the ViewModel.
      :width: 500px

   **Figure 4.** Diagram of how UDF works in app architecture.
   The pattern where the state flows down and the events flow up is
   called a unidirectional data flow (UDF). The implications of this
   pattern for app architecture are as follows:

   -  The ViewModel holds and exposes the state to be consumed by the
      UI. The UI state is application data transformed by the ViewModel.
   -  The UI notifies the ViewModel of user events.
   -  The ViewModel handles the user actions and updates the state.
   -  The updated state is fed back to the UI to render.
   -  The above is repeated for any event that causes a mutation of
      state.

   For navigation destinations or screens, the ViewModel works with
   repositories or use case classes to get data and transform it into
   the UI state while incorporating the effects of events that may cause
   mutations of the state. The `case study <#case-study>`__ mentioned
   earlier contains a list of articles, each having a title,
   description, source, author name, publication date, and whether it
   was bookmarked. The UI for each article item looks like this:

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-ui-basic-case-study-item.png
      name: ui-basic-case-study-item
      :width: 400px

   **Figure 5.** UI of an article item in the case study app.
   A user requesting to bookmark an article is an example of an event
   that can cause state mutations. As the state producer, it's the
   ViewModel‚Äôs responsibility to define all the logic required in order
   to populate all fields in the UI state and process the events needed
   for the UI to render fully.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-ui-udf-in-action.png
      name: ui-udf-in-action
      :alt: A UI event occurs when the user bookmarks an artcile. The
      ViewModel notifies the data layer of the state change. The data
      layer persists the data change and updates the application data.
      The new app data with the bookmarked article is passed up to the
      ViewModel, which then produces the new UI state and passes it to
      the UI elements for display.
      :width: 600px

   **Figure 6.** Diagram illustrating the cycle of events and data in
   UDF.
   The following sections take a closer look at the events that cause
   state changes and how they can be processed using UDF.

   .. rubric:: Types of logic
      :name: logic-types

   Bookmarking an article is an example of *business logic* because it
   gives value to your app. To learn more about this, see the `data layer <#>`__ page. However, there are
   different types of logic that are important to define:

   -  **Business logic** is the implementation of product requirements
      for app data. As mentioned already, one example is bookmarking an
      article in the case study app. Business logic is usually placed in
      the domain or data layers, but never in the UI layer.
   -  **UI behavior logic** or **UI logic** is *how* to display state
      changes on the screen. Examples include obtaining the right text
      to show on the screen using Android
      `Resources <#>`__,
      navigating to a particular screen when the user clicks a button,
      or displaying a user message on the screen using a
      `toast <#>`__ or a
      `snackbar <#>`__.

   The UI logic, particularly when it involves UI types like
   `Context <#>`__, should live in
   the UI, not in the ViewModel. If the UI grows in complexity and you
   want to delegate the UI logic to another class to favor testability
   and separation of concerns, **you can create a simple class as a
   state holder**. Simple classes created in the UI can take Android SDK
   dependencies because they follow the lifecycle of the UI; ViewModel
   objects have a longer lifespan.

   For more information about state holders and how they fit into the
   context of helping build UI, see the `Jetpack Compose State guide <#managing-state>`__.

   .. rubric:: Why use UDF?
      :name: why-use-udf

   UDF models the cycle of state production as shown in Figure 4. It
   also separates the place where state changes originate, the place
   where they are transformed, and the place where they are finally
   consumed. This separation lets the UI do exactly what its name
   implies: display information by observing state changes, and relay
   user intent by passing those changes on to the ViewModel.

   In other words, UDF allows for the following:

   -  **Data consistency.** There is a single source of truth for the
      UI.
   -  **Testability.** The source of state is isolated and therefore
      testable independent of the UI.
   -  **Maintainability.** Mutation of state follows a well-defined
      pattern where mutations are a result of both user events and the
      sources of data they pull from.

   .. rubric:: Expose UI state
      :name: expose-ui-state

   After you define your UI state and determine how you will manage the
   production of that state, the next step is to present the produced
   state to the UI. Because you're using UDF to manage the production of
   state, you can consider the produced state to be a stream‚Äîin other
   words, multiple versions of the state will be produced over time. As
   a result, you should expose the UI state in an observable data holder
   like ``LiveData`` or ``StateFlow``. The reason for this is so that
   the UI can react to any changes made in the state without having to
   manually pull data directly from the ViewModel. These types also have
   the benefit of always having the latest version of the UI state
   cached, which is useful for quick state restoration after
   configuration changes.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: views

         .. code:: prettyprint

            class NewsViewModel(...) : ViewModel() {

                val uiState: StateFlow<NewsUiState> = ‚Ä¶
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose

         .. code:: prettyprint

            class NewsViewModel(...) : ViewModel() {

                val uiState: NewsUiState = ‚Ä¶
            }

   For an introduction to ``LiveData`` as an observable data holder, see
   `this codelab <#>`__.
   For a similar introduction to Kotlin flows, see `Kotlin flows on Android <#>`__.

   **Note:**\  In Jetpack Compose apps, you can use Compose's observable
   `State APIs <#state-in-composables>`__ such as
   ``mutableStateOf`` or ``snapshotFlow`` for the exposure of UI state.
   Any type of observable data holder such as ``StateFlow`` or
   ``LiveData`` that you see in this guide can be easily consumed in
   Compose using the appropriate
   `extensions <#streams>`__.
   In cases where the data exposed to the UI is relatively simple, it's
   often worth wrapping the data in a UI state type because it conveys
   the relationship between the emission of the state holder and its
   associated screen or UI element. Furthermore, as the UI element grows
   more complex, it‚Äôs always easier to add to the definition of the UI
   state to accommodate the extra information needed to render the UI
   element.

   A common way of creating a stream of ``UiState`` is by exposing a
   backing mutable stream as an immutable stream from the ViewModel‚Äîfor
   example, exposing a ``MutableStateFlow<UiState>`` as a
   ``StateFlow<UiState>``.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: views_1

         .. code:: prettyprint

            class NewsViewModel(...) : ViewModel() {

                private val _uiState = MutableStateFlow(NewsUiState())
                val uiState: StateFlow<NewsUiState> = _uiState.asStateFlow()

                ...

            }

      .. container:: section

         .. rubric:: Compose
            :name: compose_1

         .. code:: prettyprint

            class NewsViewModel(...) : ViewModel() {

                var uiState by mutableStateOf(NewsUiState())
                    private set

                ...
            }

   The ViewModel can then expose methods that internally mutate the
   state, publishing updates for the UI to consume. Take, for example,
   the case where an asynchronous action needs to be performed; a
   coroutine can be launched using the
   `viewModelScope <#viewmodelscope>`__,
   and the mutable state can be updated upon completion.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: views_2

         .. code:: prettyprint

            class NewsViewModel(
                private val repository: NewsRepository,
                ...
            ) : ViewModel() {

                private val _uiState = MutableStateFlow(NewsUiState())
                val uiState: StateFlow<NewsUiState> = _uiState.asStateFlow()

                private var fetchJob: Job? = null

                fun fetchArticles(category: String) {
                    fetchJob?.cancel()
                    fetchJob = viewModelScope.launch {
                        try {
                            val newsItems = repository.newsItemsForCategory(category)
                            _uiState.update {
                                it.copy(newsItems = newsItems)
                            }
                        } catch (ioe: IOException) {
                            // Handle the error and notify the UI when appropriate.
                            _uiState.update {
                                val messages = getMessagesFromThrowable(ioe)
                                it.copy(userMessages = messages)
                             }
                        }
                    }
                }
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose_2

         .. code:: prettyprint

            class NewsViewModel(
                private val repository: NewsRepository,
                ...
            ) : ViewModel() {

               var uiState by mutableStateOf(NewsUiState())
                    private set

                private var fetchJob: Job? = null

                fun fetchArticles(category: String) {
                    fetchJob?.cancel()
                    fetchJob = viewModelScope.launch {
                        try {
                            val newsItems = repository.newsItemsForCategory(category)
                            uiState = uiState.copy(newsItems = newsItems)
                        } catch (ioe: IOException) {
                            // Handle the error and notify the UI when appropriate.
                            val messages = getMessagesFromThrowable(ioe)
                            uiState = uiState.copy(userMessages = messages)
                        }
                    }
                }
            }

   In the above example, the ``NewsViewModel`` class attempts to fetch
   articles for a certain category and then reflects the result of the
   attempt‚Äîwhether success or failure‚Äîin the UI state where the UI can
   react to it appropriately. See the `Show errors on the screen <#show-errors>`__ section to learn more about error handling.

   **Note:**\  The pattern shown in the example above where state is
   mutated through functions on the ViewModel is one of the more popular
   implementations of unidirectional data flow.

   .. rubric:: Additional considerations
      :name: additional-considerations

   In addition to the previous guidance, consider the following when
   exposing UI state:

   -  **A UI state object should handle states that are related to each
      other.** This leads to fewer inconsistencies and it makes the code
      easier to understand. If you expose the list of news items and the
      number of bookmarks in two different streams, you might end up in
      a situation where one was updated and the other was not. When you
      use a single stream, both elements are kept up to date.
      Furthermore, some business logic may require a combination of
      sources. For example, you might need to show a bookmark button
      only if the user is signed in *and* that user is a subscriber to a
      premium news service. You could define a UI state class as
      follows:

      .. code:: prettyprint

         data class NewsUiState(
             val isSignedIn: Boolean = false,
             val isPremium: Boolean = false,
             val newsItems: List<NewsItemUiState> = listOf()
         )

         val NewsUiState.canBookmarkNews: Boolean get() = isSignedIn && isPremium

      In this declaration, the visibility of the bookmark button is a
      derived property of two other properties. As business logic gets
      more complex, having a singular ``UiState`` class where all
      properties are immediately available becomes increasingly
      important.

   -  **UI states: single stream or multiple streams?** The key guiding
      principle for choosing between exposing UI state in a single
      stream or in multiple streams is the previous bullet point: the
      relationship between the items emitted. The biggest advantage to a
      single-stream exposure is convenience and data consistency:
      consumers of state always have the latest information available at
      any instant in time. However, there are instances where separate
      streams of state from the ViewModel might be appropriate:

      -  **Unrelated data types:** Some states that are needed to render
         the UI might be completely independent from each other. In
         cases like these, the costs of bundling these disparate states
         together might outweigh the benefits, especially if one of
         these states is updated more frequently than the other.

      -  **``UiState`` diffing:** The more fields there are in a
         ``UiState`` object, the more likely it is that the stream will
         emit as a result of one of its fields being updated. Because
         views don't have a diffing mechanism to understand whether
         consecutive emissions are different or the same, every emission
         causes an update to the view. This means that mitigation using
         the ``Flow`` APIs or methods like
         `distinctUntilChanged() <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html>`__
         on the ``LiveData`` might be necessary.

   .. rubric:: Consume UI state
      :name: consume-ui-state

   To consume the stream of ``UiState`` objects in the UI, you use the
   terminal operator for the observable data type that you're using. For
   example, for ``LiveData`` you use the ``observe()`` method, and for
   Kotlin flows you use the ``collect()`` method or its variations.

   When consuming observable data holders in the UI, make sure you take
   the lifecycle of the UI into consideration. This is important because
   the UI shouldn‚Äôt be observing the UI state when the view isn‚Äôt being
   displayed to the user. To learn more about this topic, see `this blog post <https://medium.com/androiddevelopers/a-safer-way-to-collect-flows-from-android-uis-23080b1f8bda>`__.
   When using ``LiveData``, the ``LifecycleOwner`` implicitly takes care
   of lifecycle concerns. When using flows, it's best to handle this
   with the appropriate coroutine scope and the ``repeatOnLifecycle``
   API:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: views_3

         .. code:: prettyprint

            class NewsActivity : AppCompatActivity() {

                private val viewModel: NewsViewModel by viewModels()

                override fun onCreate(savedInstanceState: Bundle?) {
                    ...

                    lifecycleScope.launch {
                        repeatOnLifecycle(Lifecycle.State.STARTED) {
                            viewModel.uiState.collect {
                                // Update UI elements
                            }
                        }
                    }
                }
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose_3

         .. code:: prettyprint

            @Composable
            fun LatestNewsScreen(
                viewModel: NewsViewModel = viewModel()
            ) {
                // Show UI elements based on the viewModel.uiState
            }

   **Note:**\  The specific ``StateFlow`` objects used in this example
   don't stop performing work when they have no active collectors, but
   when you're working with flows you might not know how they're
   implemented. Using lifecycle-aware flow collection lets you make
   these kinds of changes to the ViewModel flows later without
   revisiting downstream collector code.

   .. rubric:: Show in-progress operations
      :name: show-operations

   A simple way to represent loading states in a ``UiState`` class is
   with a boolean field:

   .. code:: prettyprint

      data class NewsUiState(
          val isFetchingArticles: Boolean = false,
          ...
      )

   This flag's value represents the presence or absence of a progress
   bar in the UI.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: views_4

         .. code:: prettyprint

            class NewsActivity : AppCompatActivity() {

                private val viewModel: NewsViewModel by viewModels()

                override fun onCreate(savedInstanceState: Bundle?) {
                    ...

                    lifecycleScope.launch {
                        repeatOnLifecycle(Lifecycle.State.STARTED) {
                            // Bind the visibility of the progressBar to the state
                            // of isFetchingArticles.
                            viewModel.uiState
                                .map { it.isFetchingArticles }
                                .distinctUntilChanged()
                                .collect { progressBar.isVisible = it }
                        }
                    }
                }
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose_4

         .. code:: prettyprint

            @Composable
            fun LatestNewsScreen(
                modifier: Modifier = Modifier,
                viewModel: NewsViewModel = viewModel()
            ) {
                Box(modifier.fillMaxSize()) {

                    if (viewModel.uiState.isFetchingArticles) {
                        CircularProgressIndicator(Modifier.align(Alignment.Center))
                    }

                    // Add other UI elements. For example, the list.
                }
            }

   .. rubric:: Show errors on the screen
      :name: show-errors

   Showing errors in the UI is similar to showing in-progress operations
   because they are both easily represented by boolean values that
   denote their presence or absence. However, errors might also include
   an associated message to relay back to the user, or an action
   associated with them that retries the failed operation. Therefore,
   while an in-progress operation is either loading or not loading,
   error states might need to be modeled with data classes that host the
   metadata appropriate for the context of the error.

   For example, consider the example from the previous section which
   showed a progress bar while fetching articles. If this operation
   results in an error, you might want to display one or more messages
   to the user detailing what went wrong.

   .. code:: prettyprint

      data class Message(val id: Long, val message: String)

      data class NewsUiState(
          val userMessages: List<Message> = listOf(),
          ...
      )

   The error messages might then be presented to the user in the form of
   UI elements like
   `snackbars <https://material.io/components/snackbars/android>`__.
   Because this is related to how UI events are produced and consumed,
   see the `UI events <#>`__ page to learn
   more.

   .. rubric:: Threading and concurrency
      :name: threading-concurrency

   Any work performed in a ViewModel should be *main-safe*‚Äîsafe to call
   from the main thread. This is because the data and domain layers are
   responsible for moving work to a different thread.

   If a ViewModel performs long-running operations, then it is also
   responsible for moving that logic to a background thread. Kotlin
   coroutines are a great way to manage concurrent operations, and the
   Jetpack Architecture Components provide built-in support for them. To
   learn more about using coroutines in Android apps, see `Kotlin coroutines on Android <#>`__.

   .. rubric:: Navigation
      :name: navigation

   Changes in app navigation are often driven by event-like emissions.
   For example, after a ``SignInViewModel`` class performs a sign-in,
   the ``UiState`` might have an ``isSignedIn`` field set to ``true``.
   Triggers like these should be consumed just like the ones covered in
   the `Consume UI state <#consume-ui-state>`__ section above, except
   that the consumption implementation should defer to the `Navigation component <#>`__.

   .. rubric:: Paging
      :name: paging

   The `Paging library <#>`__ is
   consumed in the UI with a type called ``PagingData``. Because
   ``PagingData`` represents and contains items that can change over
   time‚Äîin other words, it is not an immutable type‚Äîit should not be
   represented in an immutable UI state. Instead, you should expose it
   from the ViewModel independently in its own stream. See the `Android Paging <#>`__ codelab for a specific example
   of this.

   .. rubric:: Animations
      :name: animations

   In order to provide fluid and smooth top-level navigation
   transitions, you might want to wait for the second screen to load
   data before starting the animation. The Android view framework
   provides hooks to delay transitions between fragment destinations
   with the
   `postponeEnterTransition() <#postponeEnterTransition>`__
   and
   `startPostponedEnterTransition() <#startPostponedEnterTransition>`__
   APIs. These APIs provide a way to ensure that the UI elements on the
   second screen (typically an image fetched from the network) are ready
   to be displayed before the UI animates the transition to that screen.
   For more details and implementation specifics, see the `Android Motion sample <https://github.com/android/animation-samples/tree/main/Motion>`__.

   .. rubric:: Samples
      :name: samples

   The following Google samples demonstrate the use of the UI layer. Go
   explore them to see this guidance in practice:

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `UI State production <#>`__
   -  `State holders and UI State {:#mad-arch} <#>`__
   -  `Guide to app architecture <#>`__

Last updated 2023-07-12 UTC.


/UI events
==========

.. container:: devsite-article-body clearfix

   *UI events* are actions that should be handled in the UI layer,
   either by the UI or by the ViewModel. The most common type of events
   are *user events*. The user produces user events by interacting with
   the app‚Äîfor example, by tapping the screen or by generating gestures.
   The UI then consumes these events using callbacks such as
   ``onClick()`` listeners.

   **Key terms:**

   -  **UI:** View-based or Compose code that handles the user
      interface.
   -  **UI events:** Actions that should be handled in the UI layer.
   -  **User events:** Events that the user produces when interacting
      with the app.

   The ViewModel is normally responsible for handling the business logic
   of a particular user event‚Äîfor example, the user clicking on a button
   to refresh some data. Usually, the ViewModel handles this by exposing
   functions that the UI can call. User events might also have UI
   behavior logic that the UI can handle directly‚Äîfor example,
   navigating to a different screen or showing a
   `Snackbar <#>`__.

   While the *business logic* remains the same for the same app on
   different mobile platforms or form factors, the *UI behavior logic*
   is an implementation detail that might differ between those cases.
   The `UI layer page <#logic-types>`__ defines
   these types of logic as follows:

   -  **Business logic** refers to *what to do* with state changes‚Äîfor
      example, making a payment or storing user preferences. The domain
      and data layers usually handle this logic. Throughout this guide,
      the `Architecture Components ViewModel <#>`__ class is
      used as an opinionated solution for classes that handle business
      logic.
   -  **UI behavior logic** or **UI logic** refers to *how to display*
      state changes‚Äîfor example, navigation logic or how to show
      messages to the user. The UI handles this logic.

   **Note:**\  The recommendations and best practices present in this
   page can be applied to a broad spectrum of apps to allow them to
   scale, improve quality and robustness, and make them easier to test.
   However, you should treat them as guidelines and adapt them to your
   requirements as needed.

   .. container:: video-wrapper-full-width

   .. rubric:: UI event decision tree
      :name: decision-tree

   The following diagram shows a decision tree to find the best approach
   for handling a particular event use case. The rest of this guide
   explains these approaches in detail.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-uievents-tree.png
      name: uievents-tree
      :alt: If the event originated in the ViewModel, then update the UI
      state. If the event originated in the UI and requires business
      logic, then delegate the business logic to the ViewModel. If the
      event originated in the UI and requires UI behavior logic, then
      modify the UI element state directly in the UI.
      :width: 600px

   **Figure 1.** Decision tree for handling events.

   .. rubric:: Handle user events
      :name: handle-user-events

   The UI can handle user events directly if those events relate to
   modifying the state of a UI element‚Äîfor example, the state of an
   expandable item. If the event requires performing business logic,
   such as refreshing the data on the screen, it should be processed by
   the ViewModel.

   The following example shows how different buttons are used to expand
   a UI element (UI logic) and to refresh the data on the screen
   (business logic):

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: views

         .. code:: prettyprint

            class LatestNewsActivity : AppCompatActivity() {

                private lateinit var binding: ActivityLatestNewsBinding
                private val viewModel: LatestNewsViewModel by viewModels()

                override fun onCreate(savedInstanceState: Bundle?) {
                    /* ... */

                    // The expand details event is processed by the UI that
                    // modifies a View's internal state.
                    binding.expandButton.setOnClickListener {
                        binding.expandedSection.visibility = View.VISIBLE
                    }

                    // The refresh event is processed by the ViewModel that is in charge
                    // of the business logic.
                    binding.refreshButton.setOnClickListener {
                        viewModel.refreshNews()
                    }
                }
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose

         .. code:: prettyprint

            @Composable
            fun LatestNewsScreen(viewModel: LatestNewsViewModel = viewModel()) {

                // State of whether more details should be shown
                var expanded by remember { mutableStateOf(false) }

                Column {
                    Text("Some text")
                    if (expanded) {
                        Text("More details")
                    }

                    Button(
                      // The expand details event is processed by the UI that
                      // modifies this composable's internal state.
                      onClick = { expanded = !expanded }
                    ) {
                      val expandText = if (expanded) "Collapse" else "Expand"
                      Text("$expandText details")
                    }

                    // The refresh event is processed by the ViewModel that is in charge
                    // of the UI's business logic.
                    Button(onClick = { viewModel.refreshNews() }) {
                        Text("Refresh data")
                    }
                }
            }

   .. rubric:: User events in RecyclerViews
      :name: recyclerview-events

   If the action is produced further down the UI tree, like in a
   ``RecyclerView`` item or a custom ``View``, the ``ViewModel`` should
   still be the one handling user events.

   For example, suppose that all news items from ``NewsActivity``
   contain a bookmark button. The ``ViewModel`` needs to know the ID of
   the bookmarked news item. When the user bookmarks a news item, the
   ``RecyclerView`` adapter does not call the exposed
   ``addBookmark(newsId)`` function from the ``ViewModel``, which would
   require a dependency on the ``ViewModel``. Instead, the ``ViewModel``
   exposes a state object called ``NewsItemUiState`` which contains the
   implementation for handling the event:

   .. code:: prettyprint

      data class NewsItemUiState(
          val title: String,
          val body: String,
          val bookmarked: Boolean = false,
          val publicationDate: String,
          val onBookmark: () -> Unit
      )

      class LatestNewsViewModel(
          private val formatDateUseCase: FormatDateUseCase,
          private val repository: NewsRepository
      )
          val newsListUiItems = repository.latestNews.map { news ->
              NewsItemUiState(
                  title = news.title,
                  body = news.body,
                  bookmarked = news.bookmarked,
                  publicationDate = formatDateUseCase(news.publicationDate),
                  // Business logic is passed as a lambda function that the
                  // UI calls on click events.
                  onBookmark = {
                      repository.addBookmark(news.id)
                  }
              )
          }
      }

   This way, the ``RecyclerView`` adapter only works with the data that
   it needs: the list of ``NewsItemUiState`` objects. The adapter
   doesn‚Äôt have access to the entire ViewModel, making it less likely to
   abuse the functionality exposed by the ViewModel. When you allow only
   the activity class to work with the ViewModel, you separate
   responsibilities. This ensures that UI-specific objects like views or
   ``RecyclerView`` adapters don't interact directly with the ViewModel.

   **Warning:**\  It's bad practice to pass the ViewModel into the
   ``RecyclerView`` adapter because that tightly couples the adapter
   with the ViewModel class.
   **Note:**\  Another common pattern is for the ``RecyclerView``
   adapter to have a ``Callback`` interface for user actions. In that
   case, the activity or fragment can handle the binding and call the
   ViewModel functions directly from the callback interface.

   .. rubric:: Naming conventions for user event functions
      :name: naming-conventions

   In this guide, the ViewModel functions that handle user events are
   named with a verb based on the action that they handle‚Äîfor example:
   ``addBookmark(id)`` or ``logIn(username, password)``.

   .. rubric:: Handle ViewModel events
      :name: handle-viewmodel-events

   **UI actions that originate from the ViewModel‚ÄîViewModel
   events‚Äîshould always result in a** `UI state <#expose-ui-state>`__ **update.** This
   complies with the principles of `Unidirectional Data Flow <#udf>`__. It makes events reproducible
   after configuration changes and guarantees that UI actions won't be
   lost. Optionally, you can also make events reproducible after process
   death if you use the `saved state module <#>`__.

   Mapping UI actions to UI state is not always a simple process, but it
   does lead to simpler logic. Your thought process shouldn't end with
   determining how to make the UI navigate to a particular screen, for
   example. You need to think further and consider how to represent that
   user flow in your UI state. **In other words: don't think about what
   actions the UI needs to make; think about how those actions affect
   the UI state.**

   **Key Point:**\  ViewModel events should always result in a UI state
   update.
   For example, consider the case of navigating to the home screen when
   the user is logged in on the login screen. You could model this in
   the UI state as follows:

   .. code:: prettyprint

      data class LoginUiState(
          val isLoading: Boolean = false,
          val errorMessage: String? = null,
          val isUserLoggedIn: Boolean = false
      )

   This UI reacts to changes to the ``isUserLoggedIn`` state and
   navigates to the correct destination as needed:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: views_1

         .. code:: prettyprint

            class LoginViewModel : ViewModel() {
                private val _uiState = MutableStateFlow(LoginUiState())
                val uiState: StateFlow<LoginUiState> = _uiState.asStateFlow()
                /* ... */
            }

            class LoginActivity : AppCompatActivity() {
                private val viewModel: LoginViewModel by viewModels()

                override fun onCreate(savedInstanceState: Bundle?) {
                    /* ... */

                    lifecycleScope.launch {
                        repeatOnLifecycle(Lifecycle.State.STARTED) {
                            viewModel.uiState.collect { uiState ->
                                if (uiState.isUserLoggedIn) {
                                    // Navigate to the Home screen.
                                }
                                ...
                            }
                        }
                    }
                }
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose_1

         .. code:: prettyprint

            class LoginViewModel : ViewModel() {
                var uiState by mutableStateOf(LoginUiState())
                    private set
                /* ... */
            }

            @Composable
            fun LoginScreen(
                viewModel: LoginViewModel = viewModel(),
                onUserLogIn: () -> Unit
            ) {
                val currentOnUserLogIn by rememberUpdatedState(onUserLogIn)

                // Whenever the uiState changes, check if the user is logged in.
                LaunchedEffect(viewModel.uiState)  {
                    if (viewModel.uiState.isUserLoggedIn) {
                        currentOnUserLogIn()
                    }
                }

                // Rest of the UI for the login screen.
            }

   **Note:**\  The code examples in this section require an
   understanding of `coroutines <#>`__ and 
   `how to use them with lifecycle-aware components <#>`__.

   .. rubric:: Consuming events can trigger state updates
      :name: consuming-trigger-updates

   Consuming certain ViewModel events in the UI might result in other UI
   state updates. For example, when showing transient messages on the
   screen to let the user know that something happened, the UI needs to
   notify the ViewModel to trigger another state update when the message
   has been shown on the screen. The event that happens when the user
   has consumed the message (by dismissing it or after a timeout) can be
   treated as "user input" and as such, the ViewModel should be aware of
   that. In this situation, the UI state can be modeled as follows:

   .. code:: prettyprint

      // Models the UI state for the Latest news screen.
      data class LatestNewsUiState(
          val news: List<News> = emptyList(),
          val isLoading: Boolean = false,
          val userMessage: String? = null
      )

   The ViewModel would update the UI state as follows when the business
   logic requires showing a new transient message to the user:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: views_2

         .. code:: prettyprint

            class LatestNewsViewModel(/* ... */) : ViewModel() {

                private val _uiState = MutableStateFlow(LatestNewsUiState(isLoading = true))
                val uiState: StateFlow<LatestNewsUiState> = _uiState

                fun refreshNews() {
                    viewModelScope.launch {
                        // If there isn't internet connection, show a new message on the screen.
                        if (!internetConnection()) {
                            _uiState.update { currentUiState ->
                                currentUiState.copy(userMessage = "No Internet connection")
                            }
                            return@launch
                        }

                        // Do something else.
                    }
                }

                fun userMessageShown() {
                    _uiState.update { currentUiState ->
                        currentUiState.copy(userMessage = null)
                    }
                }
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose_2

         .. code:: prettyprint

            class LatestNewsViewModel(/* ... */) : ViewModel() {

                var uiState by mutableStateOf(LatestNewsUiState())
                    private set

                fun refreshNews() {
                    viewModelScope.launch {
                        // If there isn't internet connection, show a new message on the screen.
                        if (!internetConnection()) {
                            uiState = uiState.copy(userMessage = "No Internet connection")
                            return@launch
                        }

                        // Do something else.
                    }
                }

                fun userMessageShown() {
                    uiState = uiState.copy(userMessage = null)
                }
            }

   The ViewModel doesn't need to know how the UI is showing the message
   on the screen; it just knows that there's a user message that needs
   to be shown. Once the transient message has been shown, the UI needs
   to notify the ViewModel of that, causing another UI state update to
   clear the ``userMessage`` property:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: views_3

         .. code:: prettyprint

            class LatestNewsActivity : AppCompatActivity() {
                private val viewModel: LatestNewsViewModel by viewModels()

                override fun onCreate(savedInstanceState: Bundle?) {
                    /* ... */

                    lifecycleScope.launch {
                        repeatOnLifecycle(Lifecycle.State.STARTED) {
                            viewModel.uiState.collect { uiState ->
                                uiState.userMessage?.let {
                                    // TODO: Show Snackbar with userMessage.

                                    // Once the message is displayed and
                                    // dismissed, notify the ViewModel.
                                    viewModel.userMessageShown()
                                }
                                ...
                            }
                        }
                    }
                }
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose_3

         .. code:: prettyprint

            @Composable
            fun LatestNewsScreen(
                snackbarHostState: SnackbarHostState,
                viewModel: LatestNewsViewModel = viewModel(),
            ) {
                // Rest of the UI content.

                // If there are user messages to show on the screen,
                // show it and notify the ViewModel.
                viewModel.uiState.userMessage?.let { userMessage ->
                    LaunchedEffect(userMessage) {
                        snackbarHostState.showSnackbar(userMessage)
                        // Once the message is displayed and dismissed, notify the ViewModel.
                        viewModel.userMessageShown()
                    }
                }
            }

   Even though the message is transient, the UI state is a faithful
   representation of what's displayed on the screen at every single
   point in time. Either the user message is displayed, or it isn't.

   **Note:**\  For a more advanced use case with a list of user messages
   to show on the screen, check out the `Jetsnack Compose sample <https://github.com/android/compose-samples/blob/main/Jetsnack/app/src/main/java/com/example/jetsnack/model/SnackbarManager.kt>`__.
   
   .. rubric:: Navigation events
      :name: navigation-events

   The `Consuming events can trigger state updates <#consuming-trigger-updates>`__ section details how you use
   UI state to display user messages on the screen. Navigation events
   are also a common type of events in an Android app.

   If the event is triggered in the UI because the user tapped on a
   button, the UI takes care of that by calling the navigation
   controller or exposing the event to the caller composable as
   appropriate.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: views_4

         .. code:: prettyprint

            class LoginActivity : AppCompatActivity() {

                private lateinit var binding: ActivityLoginBinding
                private val viewModel: LoginViewModel by viewModels()

                override fun onCreate(savedInstanceState: Bundle?) {
                    /* ... */

                    binding.helpButton.setOnClickListener {
                        navController.navigate(...) // Open help screen
                    }
                }
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose_4

         .. code:: prettyprint

            @Composable
            fun LoginScreen(
                onHelp: () -> Unit, // Caller navigates to the right screen
                viewModel: LoginViewModel = viewModel()
            ) {
                // Rest of the UI

                Button(onClick = onHelp) {
                    Text("Get help")
                }
            }

   If the data input requires some business logic validation before
   navigating, the ViewModel would need to expose that state to the UI.
   The UI would react to that state change and navigate accordingly. The
   `Handle ViewModel events section <#handle-viewmodel-events>`__
   covers this use case. Here's a similar code:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: views_5

         .. code:: prettyprint

            class LoginActivity : AppCompatActivity() {
                private val viewModel: LoginViewModel by viewModels()

                override fun onCreate(savedInstanceState: Bundle?) {
                    /* ... */

                    lifecycleScope.launch {
                        repeatOnLifecycle(Lifecycle.State.STARTED) {
                            viewModel.uiState.collect { uiState ->
                                if (uiState.isUserLoggedIn) {
                                    // Navigate to the Home screen.
                                }
                                ...
                            }
                        }
                    }
                }
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose_5

         .. code:: prettyprint

            @Composable
            fun LoginScreen(
                onUserLogIn: () -> Unit, // Caller navigates to the right screen
                viewModel: LoginViewModel = viewModel()
            ) {
                Button(
                    onClick = {
                        // ViewModel validation is triggered
                        viewModel.login()
                    }
                ) {
                    Text("Log in")
                }
                // Rest of the UI

                val lifecycle = LocalLifecycleOwner.current.lifecycle
                val currentOnUserLogIn by rememberUpdatedState(onUserLogIn)
                LaunchedEffect(viewModel, lifecycle)  {
                    // Whenever the uiState changes, check if the user is logged in and
                    // call the `onUserLogin` event when `lifecycle` is at least STARTED
                    snapshotFlow { viewModel.uiState }
                        .filter { it.isUserLoggedIn }
                        .flowWithLifecycle(lifecycle)
                        .collect {
                            currentOnUserLogIn()
                        }
                }
            }

   In the example above, the app works as expected because the current
   destination, Login, wouldn't be kept in the back stack. Users cannot
   go back to it if they press back. However, in cases where that might
   happen, the solution would require additional logic.

   .. rubric:: Navigation events when the destination is kept in the
      back stack
      :name: navigation-events-destination-back-stack

   When a ViewModel sets some state that produces a navigation event
   from screen A to screen B and screen A is kept in the navigation back
   stack, you might need additional logic to not keep advancing
   automatically to B. To implement this, it's required to have
   additional state that indicates whether or not the UI should consider
   navigating to the other screen. Normally, that state is held in the
   UI because Navigation logic is a concern of the UI, not the
   ViewModel. To illustrate this, let's consider the following use case.

   Let's say that you are in the registration flow of your app. In the
   *date of birth* validation screen, when the user inputs a date, the
   date is validated by the ViewModel when the user taps on the
   "Continue" button. The ViewModel delegates the validation logic to
   the data layer. If the date is valid, the user goes to the next
   screen. As an additional feature, users can go back and forth between
   the different registration screens in case they want to change some
   data. Therefore, all the destinations in the registration flow are
   kept in the same back stack. Given these requirements, you could
   implement this screen as follows:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: views_6

         .. code:: prettyprint

            // Key that identifies the `validationInProgress` state in the Bundle
            private const val DOB_VALIDATION_KEY = "dobValidationKey"

            class DobValidationFragment : Fragment() {

                private var validationInProgress: Boolean = false
                private val viewModel: DobValidationViewModel by viewModels()

                override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                    super.onViewCreated(view, savedInstanceState)
                    val binding = // ...
                    validationInProgress = savedInstanceState?.getBoolean(DOB_VALIDATION_KEY) ?: false

                    binding.continueButton.setOnClickListener {
                        viewModel.validateDob()
                        validationInProgress = true
                    }

                    viewLifecycleOwner.lifecycleScope.launch {
                        viewModel.uiState
                            .flowWithLifecycle(viewLifecycleOwner.lifecycle)
                            .collect { uiState ->
                                // Update other parts of the UI ...

                                // If the input is valid and the user wants
                                // to navigate, navigate to the next screen
                                // and reset `validationInProgress` flag
                                if (uiState.isDobValid && validationInProgress) {
                                    validationInProgress = false
                                    navController.navigate(...) // Navigate to next screen
                                }
                            }
                    }

                    return binding
                }

                override fun onSaveInstanceState(outState: Bundle) {
                    super.onSaveInstanceState(outState)
                    outState.putBoolean(DOB_VALIDATION_KEY, validationInProgress)
                }
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose_6

         .. code:: prettyprint

            class DobValidationViewModel(/* ... */) : ViewModel() {
                var uiState by mutableStateOf(DobValidationUiState())
                    private set
            }

            @Composable
            fun DobValidationScreen(
                onNavigateToNextScreen: () -> Unit, // Caller navigates to the right screen
                viewModel: DobValidationViewModel = viewModel()
            ) {
                // TextField that updates the ViewModel when a date of birth is selected

                var validationInProgress by rememberSaveable { mutableStateOf(false) }

                Button(
                    onClick = {
                        viewModel.validateInput()
                        validationInProgress = true
                    }
                ) {
                    Text("Continue")
                }
                // Rest of the UI

                /*
                 * The following code implements the requirement of advancing automatically
                 * to the next screen when a valid date of birth has been introduced
                 * and the user wanted to continue with the registration process.
                 */

                if (validationInProgress) {
                    val lifecycle = LocalLifecycleOwner.current.lifecycle
                    val currentNavigateToNextScreen by rememberUpdatedState(onNavigateToNextScreen)
                    LaunchedEffect(viewModel, lifecycle) {
                        // If the date of birth is valid and the validation is in progress,
                        // navigate to the next screen when `lifecycle` is at least STARTED,
                        // which is the default Lifecycle.State for the `flowWithLifecycle` operator.
                        snapshotFlow { viewModel.uiState }
                            .filter { it.isDobValid }
                            .flowWithLifecycle(lifecycle)
                            .collect {
                                validationInProgress = false
                                currentNavigateToNextScreen()
                            }
                    }
                }
            }

   The date of birth validation is *business logic* that the ViewModel
   is responsible for. Most of the time, the ViewModel would delegate
   that logic to the data layer. The logic to navigate the user to the
   next screen is *UI logic* because these requirements could change
   depending on the UI configuration. For example, you might not want to
   automatically advance to another screen in a tablet if you're showing
   multiple registration steps at the same time. The
   ``validationInProgress`` variable in the code above implements this
   functionality and handles whether or not the UI should navigate
   automatically whenever the date of birth is valid and the user wanted
   to continue to the following registration step.

   .. rubric:: Other use cases
      :name: other-use-cases

   If you think your UI event use case cannot be solved with UI state
   updates, you might need to reconsider how data flows in your app.
   Consider the following principles:

   -  **Each class should do what they're responsible for, not more.**
      The UI is in charge of screen-specific behavior logic such as
      navigation calls, click events, and obtaining permission requests.
      The ViewModel contains business logic and converts the results
      from lower layers of the hierarchy into UI state.
   -  **Think about where the event originates.** Follow the `decision tree <#decision-tree>`__ presented at the beginning of this guide,
      and make each class handle what they're responsible for. For
      example, if the event originates from the UI and it results in a
      navigation event, then that event has to be handled in the UI.
      Some logic might be delegated to the ViewModel, but handling the
      event can‚Äôt be entirely delegated to the ViewModel.
   -  **If you have multiple consumers and you're worried about the
      event being consumed multiple times, you might need to reconsider
      your app architecture.** Having multiple concurrent consumers
      results in the *delivered exactly once* contract becoming
      extremely difficult to guarantee, so the amount of complexity and
      subtle behavior explodes. If you're having this problem, consider
      pushing those concerns upwards in your UI tree; you might need a
      different entity scoped higher up in the hierarchy.
   -  **Think about when the state needs to be consumed.** In certain
      situations, you might not want to keep consuming state when the
      app is in the background‚Äîfor example, showing a ``Toast``. In
      those cases, consider consuming the state when the UI is in the
      foreground.

   **Note:** In some apps, you might have seen ViewModel events being
   exposed to the UI using `Kotlin Channels <https://kotlinlang.org/docs/channels.html>`__ or other
   reactive streams. When the producer (the ViewModel) outlives the
   consumer (UI‚ÄîCompose or Views), these solutions don't guarantee the
   delivery and processing of those events. This can result in future
   problems for the developer, and it's also an unacceptable user
   experience for most apps because this could leave the app in an
   inconsistent state, it could introduce bugs, or the user might miss
   critical information.

   If you‚Äôre in one of these situations, reconsider what that one-off
   ViewModel event actually means for your UI. Handle them immediately
   and reduce them to UI state. UI state better represents the UI at a
   given point in time, it gives you more delivery and processing
   guarantees, it's usually easier to test, and it integrates
   consistently with the rest of your app.

   To learn more about why you shouldn't use the aforementioned APIs
   with some code examples, read the `ViewModel: One-off event antipatterns <https://medium.com/androiddevelopers/viewmodel-one-off-event-antipatterns-16a1da869b95>`__
   blog post.

   .. rubric:: Samples
      :name: samples

   The following Google samples demonstrate the UI events in the UI
   layer. Go explore them to see this guidance in practice:

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `UI layer <#>`__
   -  `State holders and UI State {:#mad-arch} <#>`__
   -  `Guide to app architecture <#>`__

Last updated 2023-07-12 UTC.



/State holders and UI State
===========================

.. container:: devsite-article-body clearfix

   The `UI layer guide <#>`__ discusses
   unidirectional data flow (UDF) as a means of producing and managing
   the UI State for the UI layer.

   .. figure:: https://developer.android.google.cn/static/images/topic/architecture/ui-layer/udf.png
      name: image-1
      :alt: Data flows unidirectionally from the data layer to the UI.
      :width: 60.0%

      **Figure 1**: Unidirectional data flow

   It also highlights the benefits of delegating UDF management to a
   special class called a state holder. You can implement a state holder
   either through a ``ViewModel`` or a plain class. This document takes
   a closer look at state holders and the role they play in the UI
   layer.

   At the end of this document, you should have an understanding of how
   to manage application state in the UI layer; that is the UI state
   production pipeline. You should be able to understand and know the
   following:

   -  Understand the types of UI state that exist in the UI layer.
   -  Understand the types of logic that operate on those UI states in
      the UI layer.
   -  Know how to choose the appropriate implementation of a state
      holder, such as a ``ViewModel`` or a simple class.

   .. container:: video-wrapper-full-width

   .. rubric:: Elements of the UI state production pipeline
      :name: elements-ui

   The UI state and the logic that produces it defines the UI layer.

   .. rubric:: UI state
      :name: ui-state

   `UI state <#define-ui-state>`__ is the
   property that describes the UI. There are two types of UI state:

   -  **Screen UI state** is *what* you need to display on the screen.
      For example, a ``NewsUiState`` class can contain the news articles
      and other information needed to render the UI. This state is
      usually connected with other layers of the hierarchy because it
      contains app data.
   -  **UI element state** refers to properties intrinsic to UI elements
      that influence how they are rendered. A UI element may be shown or
      hidden and may have a certain font, font size, or font color. In
      Android Views, the View manages this state itself as it is
      inherently stateful, exposing methods to modify or query its
      state. An example of this are the
      `get <#getText>`__ and
      `set <#setText>`__
      methods of the
      `TextView <#>`__ class for
      its text. In Jetpack Compose, the state is external to the
      composable, and you can even hoist it out of the immediate
      vicinity of the composable into the calling composable function or
      a state holder. An example of this is
      `ScaffoldState <#>`__
      for the
      `Scaffold <#Scaffold>`__
      composable.

   .. rubric:: Logic
      :name: logic

   UI state is not a static property, as application data and user
   events cause UI state to change over time. Logic determines the
   specifics of the change, including what parts of the UI state have
   changed, why it's changed, and when it should change.

   .. figure:: https://developer.android.google.cn/static/images/topic/architecture/ui-layer/logic.png
      name: image-2
      :alt: Logic produces UI state
      :width: 50.0%

      **Figure 2**: Logic as the producer of UI state

   Logic in an application can be either business logic or UI logic:

   -  **Business logic** is the implementation of product requirements
      for app data. For example, bookmarking an article in a news reader
      app when the user taps the button. This logic to save a bookmark
      to a file or database is usually placed in the domain or data
      layers. The state holder usually delegates this logic to those
      layers by calling the methods they expose.
   -  **UI logic** is related to *how* to display UI state on the
      screen. For example, obtaining the right search bar hint when the
      user has selected a category, scrolling to a particular item in a
      list, or the navigation logic to a particular screen when the user
      clicks a button.

   .. rubric:: Android lifecycle and the types of UI state and logic
      :name: android-lifecycle

   The UI layer has two parts: one dependent and the other independent
   of the UI lifecycle. This separation determines the data sources
   available to each part, and therefore requires different types of UI
   state and logic.

   -  **UI lifecycle independent**: This part of the UI layer deals with
      the data producing layers of the app (data or domain layers) and
      is defined by business logic. Lifecycle, configuration changes,
      and ``Activity`` recreation in the UI may affect if the UI state
      production pipeline is active, but do not affect the validity of
      the data produced.
   -  **UI lifecycle dependent**: This part of the UI layer deals with
      UI logic, and is directly influenced by lifecycle or configuration
      changes. These changes directly affect the validity of the sources
      of data read within it, and as a result its state can only change
      when its lifecycle is active. Examples of this include runtime
      permissions and getting configuration dependent resources like
      localized strings.

   The above can be summarized with the table below:

   .. list-table::
      :header-rows: 1

      - 

         - UI Lifecycle independent
         - UI Lifecycle dependent
      - 

         - Business logic
         - UI Logic
      - 

         - Screen UI state
         - 

   .. rubric:: The UI state production pipeline
      :name: ui-state

   The UI state production pipeline refers to the steps undertaken to
   produce UI state. These steps comprise the application of the types
   of logic defined earlier, and are completely dependent on the needs
   of your UI. *Some UIs may benefit from both UI Lifecycle independent
   and UI Lifecycle dependent parts of the pipeline, either, or
   neither*.

   That is, the following permutations of the UI layer pipeline are
   valid:

   -  UI state produced and managed by the UI itself. For example, a
      simple, reusable basic counter:

      .. code:: prettyprint

         @Composable
         fun Counter() {
             // The UI state is managed by the UI itself
             var count by remember { mutableStateOf(0) }
             Row {
                 Button(onClick = { ++count }) {
                     Text(text = "Increment")
                 }
                 Button(onClick = { --count }) {
                     Text(text = "Decrement")
                 }
             }
         }

   -  UI logic ‚Üí UI. For example, showing or hiding a button that allows
      a user to jump to the top of a list.

      .. code:: prettyprint

         @Composable
         fun ContactsList(contacts: List<Contact>) {
             val listState = rememberLazyListState()
             val isAtTopOfList by remember {
                 derivedStateOf {
                     listState.firstVisibleItemIndex < 3
                 }
             }

             // Create the LazyColumn with the lazyListState
             ...

             // Show or hide the button (UI logic) based on the list scroll position
             AnimatedVisibility(visible = !isAtTopOfList) {
                 ScrollToTopButton()
             }
         }

   -  Business logic ‚Üí UI. A UI element displaying the current user's
      photo on the screen.

      .. code:: prettyprint

         @Composable
         fun UserProfileScreen(viewModel: UserProfileViewModel = hiltViewModel()) {
             // Read screen UI state from the business logic state holder
             val uiState by viewModel.uiState.collectAsStateWithLifecycle()

             // Call on the UserAvatar Composable to display the photo
             UserAvatar(picture = uiState.profilePicture)
         }

   -  Business logic ‚Üí UI logic ‚Üí UI. A UI element that scrolls to
      display the right information on the screen for a given UI state.

      .. code:: prettyprint

         @Composable
         fun ContactsList(viewModel: ContactsViewModel = hiltViewModel()) {
             // Read screen UI state from the business logic state holder
             val uiState by viewModel.uiState.collectAsStateWithLifecycle()
             val contacts = uiState.contacts
             val deepLinkedContact = uiState.deepLinkedContact

             val listState = rememberLazyListState()

             // Create the LazyColumn with the lazyListState
             ...

             // Perform UI logic that depends on information from business logic
             if (deepLinkedContact != null && contacts.isNotEmpty()) {
                 LaunchedEffect(listState, deepLinkedContact, contacts) {
                     val deepLinkedContactIndex = contacts.indexOf(deepLinkedContact)
                     if (deepLinkedContactIndex >= 0) {
                       // Scroll to deep linked item
                       listState.animateScrollToItem(deepLinkedContactIndex)
                     }
                 }
             }
         }

   In the case where both kinds of logic are applied to the UI state
   production pipeline, **business logic must always be applied before
   UI logic**. Trying to apply business logic after UI logic would imply
   that the business logic depends on UI logic. The following sections
   cover why this is a problem through an in depth look at different
   logic types and their state holders.

   .. figure::
      https://developer.android.google.cn/static/images/topic/architecture/ui-layer/logic-hierarchy.png
      name: image-3
      :alt: Data flows from the data producing layer to the UI
      :width: 50.0%

      **Figure 3**: Application of logic in the UI layer

   .. rubric:: State holders and their responsibilities
      :name: state-holders

   The responsibility of a state holder is to store state so the app can
   read it. In cases where logic is needed, it acts as an intermediary
   and provides access to the data sources that host the required logic.
   In this way, the state holder delegates logic to the appropriate data
   source.

   This produces the following benefits:

   -  **Simple UIs**: The UI just binds its state.
   -  **Maintainability**: The logic defined in the state holder can be
      iterated upon without changing the UI itself.
   -  **Testability**: The UI and its state production logic can be
      tested independently.
   -  **Readability**: Readers of the code can clearly see differences
      between UI presentation code and UI state production code.

   Regardless of its size or scope, every UI element has a 1:1
   relationship with its corresponding state holder. Furthermore, a
   state holder must be able to accept and process any user action that
   might result in a UI state change and must produce the ensuing state
   change.

   **Note:**\  State holders are not strictly necessary. Simple UIs may
   host their logic inline with their presentation code.

   .. rubric:: Types of state holders
      :name: types-state

   Similar to the kinds of UI state and logic, there are two types of
   state holders in the UI layer defined by their relationship to the UI
   lifecycle:

   -  The business logic state holder.
   -  The UI logic state holder.

   The following sections take a closer look at the types of state
   holders, starting with the business logic state holder.

   **Note:**\  If a UI logic state holder depends on information from
   the data or domain layers, you should pass that information to it
   from a business logic state holder. This is because the business
   logic state holder is longer lived than the UI logic state holder
   since it is independent of the UI lifecycle.

   .. rubric:: Business logic and its state holder
      :name: business-logic

   Business logic state holders process user events and transform data
   from the data or domain layers to screen UI state. In order to
   provide an optimal user experience when considering the Android
   lifecycle and app configuration changes, state holders that utilize
   business logic should have the following properties:

   .. list-table::
      :header-rows: 1

      - 

         - Property
         - Detail
      - 

         - Produces UI State
         - Business logic state holders are responsible for producing
            the UI state for their UIs. This UI state is often the
            result of processing user events and reading data from the
            domain and data layers.
      - 

         - Retained through activity recreation
         - Business logic state holders retain their state and state
            processing pipelines across ``Activity`` recreation, helping
            provide a seamless user experience. In the cases where the
            state holder is unable to be retained and is recreated
            (usually after `process death <#>`__),
            the state holder must be able to easily recreate its last
            state to ensure a consistent user experience.
      - 

         - Possess long lived state
         - Business logic state holders are often used to manage state
            for navigation destinations. As a result, they often
            preserve their state across navigation changes until they
            are removed from the navigation graph.
      - 

         - Is unique to its UI and is not reusable
         - Business logic state holders typically produce state for a
            certain app function, for example a ``TaskEditViewModel`` or
            a ``TaskListViewModel``, and therefore only ever applicable
            to that app function. The same state holder can support
            these app functions across different form factors. For
            example, mobile, TV, and tablet versions of the app may
            reuse the same business logic state holder.

   **Note:**\  The business logic state holder is typically implemented
   with a
   `ViewModel <#>`__
   instance because ``ViewModel`` instances support many of the features
   outlined above, particularly surviving ``Activity`` recreation.
   For example consider the author navigation destination in the `"Now in Android <https://github.com/android/nowinandroid>`__" app:

   .. figure:: https://developer.android.google.cn/static/images/topic/architecture/ui-layer/nia-author.png
      name: image-4
      :alt: The Now in Android app demonstrates how a navigation
      destination representing a major app function ought to have its
      own unique business logic state holder.

      **Figure 4**: The Now in Android app

   Acting as the business logic state holder, the
   `AuthorViewModel <https://github.com/android/nowinandroid/blob/main/feature-author/src/main/java/com/google/samples/apps/nowinandroid/feature/author/AuthorViewModel.kt>`__
   produces the UI state in this case:

   .. code:: prettyprint

      @HiltViewModel
      class AuthorViewModel @Inject constructor(
          savedStateHandle: SavedStateHandle,
          private val authorsRepository: AuthorsRepository,
          newsRepository: NewsRepository
      ) : ViewModel() {

          val uiState: StateFlow<AuthorScreenUiState> = ‚Ä¶

          // Business logic
          fun followAuthor(followed: Boolean) {
            ‚Ä¶
          }
      }

   Notice that the ``AuthorViewModel`` has the attributes outlined
   previously:

   .. list-table::
      :header-rows: 1

      - 

         - Property
         - Detail
      - 

         - Produces ``AuthorScreenUiState``
         - The ``AuthorViewModel`` reads data from the
            ``AuthorsRepository`` and ``NewsRepository`` and uses that
            data to produce ``AuthorScreenUiState``. It also applies
            business logic when the user wants to follow or unfollow an
            ``Author`` by delegating to the ``AuthorsRepository``.
      - 

         - Has access to the data layer
         - An instance of ``AuthorsRepository`` and ``NewsRepository``
            are passed to it in its constructor, allowing it to
            implement the business logic of following an ``Author``.
      - 

         - Survives ``Activity`` recreation
         - Because it is implemented with a
            `ViewModel <#>`__,
            it will be retained across quick ``Activity`` recreation. In
            the case of process death, the
            `SavedStateHandle <#>`__
            object can be read from to provide the minimum amount of
            information required to restore the UI state from the data
            layer.
      - 

         - Possesses long lived state
         - The ``ViewModel`` is scoped to the navigation graph,
            therefore unless the author destination is removed from the
            nav graph, the UI state in the ``uiState`` ``StateFlow``
            remains in memory. The use of the ``StateFlow`` also adds
            the benefit of making the application of the business logic
            that produces the state lazy because state is only produced
            if there is a collector of the UI state.
      - 

         - Is unique to its UI
         - The ``AuthorViewModel`` is only applicable to the author
            navigation destination and cannot be reused anywhere else.
            If there is any business logic that is reused across
            navigation destinations, that business logic must be
            encapsulated in a data- or domain-layer-scoped component.

   **Note:**\  You should only use ``ViewModel`` with destination-level
   UIs. You shouldn't use them in reusable pieces of your UI, such as
   search bars or Chip groups. In these cases plain classes are better
   suited.
   **Warning:**\  Don't pass ViewModel instances down to other
   composable functions. Doing so couples the composable function with
   the ViewModel type, making it less reusable and harder to test and
   preview. Also, there would be no clear single source of truth (SSOT)
   that manages the ViewModel instance. Passing the ViewModel down
   allows multiple composables to call ViewModel functions and modify
   its state, making bugs harder to debug. Instead, follow UDF best
   practices and pass down just the necessary state. Likewise, pass the
   propagating events up until they reach the ViewModel's composable
   SSOT. That is the SSOT which handles the event and calls the
   corresponding ViewModel methods.

   .. rubric:: The ViewModel as a business logic state holder
      :name: viewmodel-as

   **The benefits of ViewModels** in Android development make them
   suitable for providing access to the business logic and preparing the
   application data for presentation on the screen. These benefits
   include the following:

   -  Operations triggered by ViewModels survive configuration changes.
   -  Integration with `Navigation <#>`__:

      -  Navigation caches ViewModels while the screen is on the back
         stack. This is important to have your previously loaded data
         instantly available when you return to your destination. This
         is something more difficult to do with a state holder that
         follows the lifecycle of the composable screen.
      -  The ViewModel is also cleared when the destination is popped
         off the back stack, ensuring that your state is automatically
         cleaned up. This is different from listening for the composable
         disposal that can happen for multiple reasons such as going to
         a new screen, due to a configuration change, or other reasons.

   -  Integration with other Jetpack libraries such as
      `Hilt <#compose>`__.

   **Note:**\  If ``ViewModel`` benefits don't apply to your use case or
   you do things in a different way you can move ViewModel's
   responsibilities into plain state holder classes.

   .. rubric:: UI logic and its state holder
      :name: ui-logic

   UI logic is logic that operates on data that the UI itself provides.
   This may be on UI elements' state, or on UI data sources like the
   permissions API or
   `Resources <#>`__. State
   holders that utilize UI logic typically have the following
   properties:

   -  **Produces UI state and manages UI elements state**.
   -  **Does not survive ``Activity`` recreation**: State holders that
      are hosted in UI logic are often dependent on data sources from
      the UI itself, and attempting to retain this information across
      configuration changes more often than not causes a memory leak. If
      state holders need data to persist across configuration changes,
      they need to delegate to another component better suited to
      surviving ``Activity`` recreation. In Jetpack Compose for example,
      Composable UI element states created with ``remembered`` functions
      often delegate to ``rememberSaveable`` to preserve state across
      ``Activity`` recreation. Examples of such functions include
      ``rememberScaffoldState()`` and ``rememberLazyListState()``.
   -  **Has references to UI scoped sources of data**: Sources of data
      like lifecycle APIs and Resources can safely be referenced and
      read as the UI logic state holder has the same lifecycle as the
      UI.
   -  **Is reusable across multiple UIs**: Different instances of the
      same UI logic state holder may be reused in different parts of the
      app. For example, a state holder for managing user input events
      for a chip group may be used on a search page for filter chips,
      and also for the "to" field for receivers of an email.

   The UI logic state holder is typically implemented with a plain
   class. This is because the UI itself is responsible for the creation
   of the UI logic state holder and the UI logic state holder has the
   same lifecycle as the UI itself. In Jetpack Compose for example, the
   state holder is part of the Composition and follows the Composition's
   lifecycle.

   **Note:**\  Plain class state holders are used when UI logic is
   complex enough to be moved out of the UI. Otherwise, UI logic can be
   implemented inline in the UI.
   This above can be illustrated in the following example in the `Now in Android sample <https://github.com/android/nowinandroid>`__:

   .. figure:: https://developer.android.google.cn/static/images/topic/architecture/ui-layer/nia-home.png
      name: image-5
      :alt: Now in Android uses a plain class state holder to manage UI
      logic
      :width: 60.0%

      **Figure 5**: The Now in Android sample app

   The Now in Android sample shows either a bottom app bar or a
   navigation rail for its navigation depending on the device's screen
   size. Smaller screens use the bottom app bar, and larger screens the
   navigation rail.

   Since the logic for deciding the appropriate navigation UI element
   used in the ``NiaApp`` composable function doesn't depend on business
   logic, it can be managed by a plain class state holder called
   `NiaAppState <https://github.com/android/nowinandroid/blob/main/app/src/main/java/com/google/samples/apps/nowinandroid/ui/NiaAppState.kt>`__:

   .. code:: prettyprint

      @Stable
      class NiaAppState(
          val navController: NavHostController,
          val windowSizeClass: WindowSizeClass
      ) {

          // UI logic
          val shouldShowBottomBar: Boolean
              get() = windowSizeClass.widthSizeClass == WindowWidthSizeClass.Compact ||
                  windowSizeClass.heightSizeClass == WindowHeightSizeClass.Compact

          // UI logic
          val shouldShowNavRail: Boolean
              get() = !shouldShowBottomBar

         // UI State
          val currentDestination: NavDestination?
              @Composable get() = navController
                  .currentBackStackEntryAsState().value?.destination

          // UI logic
          fun navigate(destination: NiaNavigationDestination, route: String? = null) { /* ... */ }

           /* ... */
      }

   In the above example, the following details regarding the
   ``NiaAppState`` are notable:

   -  **Does not survive ``Activity`` recreation**: ``NiaAppState`` is
      ``remembered`` in the Composition by creating it with a Composable
      function
      `rememberNiaAppState <https://github.com/android/nowinandroid/blob/main/app/src/main/java/com/google/samples/apps/nowinandroid/ui/NiaAppState.kt#L46>`__
      following Compose naming conventions. After the ``Activity`` is
      recreated, the prior instance is lost and a new instance is
      created with all its dependencies passed in, appropriate for the
      new configuration of the recreated ``Activity``. These
      dependencies may be new or restored from the previous
      configuration. For example, ``rememberNavController()`` is used in
      the ``NiaAppState`` constructor and it delegates to
      ``rememberSaveable`` to preserve state across ``Activity``
      recreation.
   -  **Has references to UI scoped sources of data**: References to the
      ``navigationController``, ``Resources`` and other similar
      lifecycle scoped types can be safely held in ``NiaAppState`` as
      they share the same lifecycle scope.

   **Note:**\  Plain state holder classes are recommended for reusable
   pieces of UI like search bars or chip groups. You shouldn't use
   ViewModels in this case because they are best used for managing state
   for navigation destinations and access to business logic.

   .. rubric:: Choose between a ViewModel and plain class for a state
      holder
      :name: choose-viewmodel

   From the sections above, choosing between a ``ViewModel`` and a plain
   class state holder comes down to the logic applied to the UI state
   and the sources of data the logic operates on.

   **Note:**\  Most applications elect to perform UI logic inline in the
   UI itself that could otherwise be placed in plain class state
   holders. This is fine for simple cases, but for other situations, you
   can improve readability by pulling the logic out to a plain class
   state holder.
   In summary, the diagram below shows the position of state holders in
   the UI State production pipeline:

   .. figure::
      https://developer.android.google.cn/static/images/topic/architecture/ui-layer/stateholder-hierarchy.png
      name: image-6
      :alt: Data flows from the data producing layer to the UI layer
      :width: 60.0%

      **Figure 6**: State holders in the UI State production pipeline.
      Arrows mean data flow.

   **Ultimately, you should produce UI state using state holders closest
   to where it is consumed**. Less formally, you should hold state as
   low as possible while maintaining proper ownership. If you need
   access to business logic and need the UI state to persist as long as
   a screen may be navigated to, even across ``Activity`` recreation, a
   `ViewModel <#>`__
   is a great choice for your business logic state holder
   implementation. For shorter-lived UI state and UI logic, a plain
   class whose lifecycle is dependent solely on the UI should suffice.

   .. rubric:: State holders are compoundable
      :name: dependencies

   State holders can depend on other state holders as long as the
   dependencies have an equal or shorter lifetime. Examples of this are:

   -  a UI logic state holder can depend on another UI logic state
      holder.
   -  a screen level state holder can depend on a UI logic state holder.

   The following code snippet shows how `Compose's ``DrawerState </reference/kotlin/androidx/compose/material/DrawerState>`__
   depends on another internal state holder,
   `SwipeableState <#>`__,
   and how an app's UI logic state holder could depend on
   ``DrawerState``:

   .. code:: prettyprint

      @Stable
      class DrawerState(/* ... */) {
        internal val swipeableState = SwipeableState(/* ... */)
        // ...
      }

      @Stable
      class MyAppState(
        private val drawerState: DrawerState,
        private val navController: NavHostController
      ) { /* ... */ }

      @Composable
      fun rememberMyAppState(
        drawerState: DrawerState = rememberDrawerState(DrawerValue.Closed),
        navController: NavHostController = rememberNavController()
      ): MyAppState = remember(drawerState, navController) {
        MyAppState(drawerState, navController)
      }

   **Caution:**\  Given that screen level state holders manage the
   business logic complexity of a screen or part of it, it wouldn't make
   sense a screen level state holder depends on another screen level
   state holder. If you're in this scenario, reconsider your screens and
   state holders and ensure that's what you need.
   An example of a dependency that outlives a state holder would be a UI
   logic state holder depending on a screen level state holder. That
   would decrease the reusability of the shorter-lived state holder and
   gives it access to more logic and state than it actually needs.

   If the shorter-lived state holder needs certain information from a
   higher-scoped state holder, pass only the information it needs as a
   parameter instead of passing the state holder instance. For example,
   in the following code snippet, the UI logic state holder class
   receives just what it needs as parameters from the ViewModel, instead
   of passing the whole ViewModel instance as a dependency.

   .. code:: prettyprint

      class MyScreenViewModel(/* ... */) {
        val uiState: StateFlow<MyScreenUiState> = /* ... */
        fun doSomething() { /* ... */ }
        fun doAnotherThing() { /* ... */ }
        // ...
      }

      @Stable
      class MyScreenState(
        // DO NOT pass a ViewModel instance to a plain state holder class
        // private val viewModel: MyScreenViewModel,

        // Instead, pass only what it needs as a dependency
        private val someState: StateFlow<SomeState>,
        private val doSomething: () -> Unit,

        // Other UI-scoped types
        private val scaffoldState: ScaffoldState
      ) {
        /* ... */
      }

      @Composable
      fun rememberMyScreenState(
        someState: StateFlow<SomeState>,
        doSomething: () -> Unit,
        scaffoldState: ScaffoldState = rememberScaffoldState()
      ): MyScreenState = remember(someState, doSomething, scaffoldState) {
        MyScreenState(someState, doSomething, scaffoldState)
      }

      @Composable
      fun MyScreen(
        modifier: Modifier = Modifier,
        viewModel: MyScreenViewModel = viewModel(),
        state: MyScreenState = rememberMyScreenState(
          someState = viewModel.uiState.map { it.toSomeState() },
          doSomething = viewModel::doSomething
        ),
        // ...
      ) {
        /* ... */
      }

   The following diagram represents the dependencies between the UI and
   different state holders of the previous code snippet:

   .. figure::
      https://developer.android.google.cn/static/images/topic/architecture/ui-layer/stateholder-dependencies.png
      name: image-7
      :alt: UI depending on both UI logic state holder and screen level
      state holder
      :width: 60.0%

      **Figure 7**: UI depending on different state holders. Arrows mean
      dependencies.

   .. rubric:: Samples
      :name: samples

   The following Google samples demonstrate the use of state holders in
   the UI layer. Go explore them to see this guidance in practice:

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `UI layer <#>`__
   -  `UI State production <#>`__
   -  `Guide to app architecture <#>`__

Last updated 2023-07-12 UTC.


/UI State production
====================

.. container:: devsite-article-body clearfix

   Modern UIs are rarely static. The state of the UI changes when the
   user interacts with the UI or when the app needs to display new data.

   This document prescribes guidelines for the production and management
   of UI state. At the end of it you should:

   -  Know what APIs you should use to produce UI state. This depends on
      the nature of the sources of state change available in your state
      holders, following `unidirectional data flow <#udf>`__ principles.
   -  Know how you should scope the production of UI state to be
      conscious of system resources.
   -  Know how you should expose the UI state for consumption by the UI.

   Fundamentally, state production is the incremental application of
   these changes to the UI state. State always exists, and it changes as
   a result of events. The differences between events and state are
   summarized in the table below:

   .. list-table::
      :header-rows: 1

      - 

         - Events
         - State
      - 

         - Transient, unpredictable, and exist for a finite period.
         - Always exists.
      - 

         - The inputs of state production.
         - The output of state production.
      - 

         - The product of the UI or other sources.
         - Is consumed by the UI.

   A great mnemonic that summarizes the above is **state is; events
   happen**. The diagram below helps visualize changes to state as
   events occur in a timeline. Each event is processed by the
   appropriate `state holder <#>`__ and it results
   in a state change:

   .. figure::
      https://developer.android.google.cn/static/images/topic/architecture/ui-layer/events-vs-state.png
      name: image-1
      :alt: Events vs. state
      :width: 80.0%

      **Figure 1**: Events cause state to change

   Events can come from:

   -  **Users**: As they interact with the app's UI.
   -  **Other sources of state change**: APIs that present app data from
      UI, domain, or data layers like snackbar timeout events, use cases
      or repositories respectively.

   .. rubric:: The UI state production pipeline
      :name: ui-state

   State production in Android apps can be thought of as a processing
   pipeline comprising:

   -  **Inputs**: The sources of state change. They may be:

      -  Local to the UI layer: These could be user events like a user
         entering a title for a "to-do" in a task management app, or
         APIs that provide access to 
         `UI logic <#ui-logic>`__
         that drive changes in UI state. For example, calling the
         `open <#open>`__
         method on
         `DrawerState <#>`__
         in Jetpack Compose.
      -  External to the UI layer: These are sources from the domain or
         data layers that cause changes to UI state. For example news
         that finished loading from a ``NewsRepository`` or other
         events.
      -  A mixture of all the above.

   -  `State holders <#>`__:
      Types that apply `business logic <#business-logic>`__
      and/or `UI logic <#ui-logic>`__ to
      sources of state change and process user events to produce UI
      state.
   -  **Output**: The UI State that the app can render to provide users
      the information they need.

   .. figure::
      https://developer.android.google.cn/static/images/topic/architecture/ui-layer/state-production-pipeline.png
      name: image-2
      :alt: The state production pipeline
      :width: 70.0%

      **Figure 2**: The state production pipeline

   .. rubric:: State production APIs
      :name: state-production

   There are two main APIs used in state production depending on what
   stage of the pipeline you're in:

   .. list-table::
      :header-rows: 1

      - 

         - Pipeline stage
         - API
      - 

         - Input
         - You should use asynchronous APIs to perform work off the UI
            thread to keep the UI jank free. For example, Coroutines or
            Flows in Kotlin, and RxJava or callbacks in the Java
            Programming Language.
      - 

         - Output
         - You should use observable data holder APIs to invalidate and
            rerender the UI when state changes. For example, StateFlow,
            Compose State, or LiveData. Observable data holders
            guarantee the UI always has a UI state to display on the
            screen

   Of the two, the choice of asynchronous API for input has a greater
   influence on the nature of the state production pipeline than the
   choice of observable API for output. This is because the inputs
   **dictate the kind of processing that may be applied to the
   pipeline**.

   .. rubric:: State production pipeline assembly
      :name: state-production

   The next sections cover state production techniques best suited for
   various inputs, and the output APIs that match. Each state production
   pipeline is a combination of inputs and outputs and should be:

   -  **Lifecycle aware**: In the case where the UI is not visible or
      active, the state production pipeline should not consume any
      resources unless explicitly required.
   -  **Easy to consume**: The UI should be able to easily render the
      produced UI state. Considerations for the output of the state
      production pipeline will vary across different View APIs such as
      the View system or Jetpack Compose.

   **Note:**\  In the sections to follow, all APIs discussed use
   idiomatic Kotlin and Jetpack Compose code. However, the guidance is
   applicable to their equivalent analogues in other APIs in the Java
   Programming Language or Kotlin.

   .. rubric:: Inputs in state production pipelines
      :name: inputs-state

   Inputs in a state production pipeline may either provide their
   sources of state change via:

   -  One-shot operations that may be synchronous or asynchronous, for
      example calls to ``suspend`` functions.
   -  Stream APIs, for example ``Flows``.
   -  All of the above.

   The following sections cover how you can assemble a state production
   pipeline for each of the above inputs.

   .. rubric:: One-shot APIs as sources of state change
      :name: one-shot-apis

   Use the
   `MutableStateFlow <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-state-flow/>`__
   API as an observable, mutable container of state. In Jetpack Compose
   apps, you can also consider
   `mutableStateOf <#mutableStateOf>`__
   especially when working with `Compose text APIs <https://medium.com/androiddevelopers/effective-state-management-for-textfield-in-compose-d6e5b070fbe5>`__.
   Both APIs offer methods that allow safe atomic updates to the values
   they host whether or not the updates are synchronous or asynchronous.

   For example, consider state updates in a simple dice rolling app.
   Each roll of the dice from the user invokes the synchronous
   `Random.nextInt() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.random/next-int.html>`__
   method, and the result is written into the UI state.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: StateFlow
            :name: stateflow

         .. code:: prettyprint

            data class DiceUiState(
                val firstDieValue: Int? = null,
                val secondDieValue: Int? = null,
                val numberOfRolls: Int = 0,
            )

            class DiceRollViewModel : ViewModel() {

                private val _uiState = MutableStateFlow(DiceUiState())
                val uiState: StateFlow<DiceUiState> = _uiState.asStateFlow()

                // Called from the UI
                fun rollDice() {
                    _uiState.update { currentState ->
                        currentState.copy(
                        firstDieValue = Random.nextInt(from = 1, until = 7),
                        secondDieValue = Random.nextInt(from = 1, until = 7),
                        numberOfRolls = currentState.numberOfRolls + 1,
                        )
                    }
                }
            }

      .. container:: section

         .. rubric:: Compose State
            :name: compose-state

         .. code:: prettyprint

            @Stable
            interface DiceUiState {
                val firstDieValue: Int?
                val secondDieValue: Int?
                val numberOfRolls: Int?
            }

            private class MutableDiceUiState: DiceUiState {
                override var firstDieValue: Int? by mutableStateOf(null)
                override var secondDieValue: Int? by mutableStateOf(null)
                override var numberOfRolls: Int by mutableStateOf(0)
            }

            class DiceRollViewModel : ViewModel() {

                private val _uiState = MutableDiceUiState()
                val uiState: DiceUiState = _uiState

                // Called from the UI
                fun rollDice() {
                    _uiState.firstDieValue = Random.nextInt(from = 1, until = 7)
                    _uiState.secondDieValue = Random.nextInt(from = 1, until = 7)
                    _uiState.numberOfRolls = _uiState.numberOfRolls + 1
                }
            }

   .. rubric:: Mutating the UI state from asynchronous calls
      :name: mutating_the_ui_state_from_asynchronous_calls

   For state changes that require an asynchronous result, launch a
   Coroutine in the appropriate ``CoroutineScope``. This allows the app
   to discard the work when the ``CoroutineScope`` is canceled. The
   state holder then writes the result of the suspend method call into
   the observable API used to expose the UI state.

   For example, consider the ``AddEditTaskViewModel`` in the
   `Architecture sample <https://github.com/android/architecture-samples>`__. When the
   suspending ``saveTask()`` method saves a task asynchronously, the
   `update <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/update.html>`__
   method on the MutableStateFlow propagates the state change to the UI
   state.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: StateFlow
            :name: stateflow_1

         .. code:: prettyprint

            data class AddEditTaskUiState(
                val title: String = "",
                val description: String = "",
                val isTaskCompleted: Boolean = false,
                val isLoading: Boolean = false,
                val userMessage: String? = null,
                val isTaskSaved: Boolean = false
            )

            class AddEditTaskViewModel(...) : ViewModel() {

               private val _uiState = MutableStateFlow(AddEditTaskUiState())
               val uiState: StateFlow<AddEditTaskUiState> = _uiState.asStateFlow()

               private fun createNewTask() {
                    viewModelScope.launch {
                        val newTask = Task(uiState.value.title, uiState.value.description)
                        try {
                            tasksRepository.saveTask(newTask)
                            // Write data into the UI state.
                            _uiState.update {
                                it.copy(isTaskSaved = true)
                            }
                        }
                        catch(cancellationException: CancellationException) {
                            throw cancellationException
                        }
                        catch(exception: Exception) {
                            _uiState.update {
                                it.copy(userMessage = getErrorMessage(exception))
                            }
                        }
                    }
                }
            }

      .. container:: section

         .. rubric:: Compose State
            :name: compose-state_1

         .. code:: prettyprint

            @Stable
            interface AddEditTaskUiState {
                val title: String
                val description: String
                val isTaskCompleted: Boolean
                val isLoading: Boolean
                val userMessage: String?
                val isTaskSaved: Boolean
            }

            private class MutableAddEditTaskUiState : AddEditTaskUiState() {
                override var title: String by mutableStateOf("")
                override var description: String by mutableStateOf("")
                override var isTaskCompleted: Boolean by mutableStateOf(false)
                override var isLoading: Boolean by mutableStateOf(false)
                override var userMessage: String? by mutableStateOf<String?>(null)
                override var isTaskSaved: Boolean by mutableStateOf(false)
            }

            class AddEditTaskViewModel(...) : ViewModel() {

               private val _uiState = MutableAddEditTaskUiState()
               val uiState: AddEditTaskUiState = _uiState

               private fun createNewTask() {
                    viewModelScope.launch {
                        val newTask = Task(uiState.value.title, uiState.value.description)
                        try {
                            tasksRepository.saveTask(newTask)
                            // Write data into the UI state.
                            _uiState.isTaskSaved = true
                        }
                        catch(cancellationException: CancellationException) {
                            throw cancellationException
                        }
                        catch(exception: Exception) {
                            _uiState.userMessage = getErrorMessage(exception))
                        }
                    }
                }
            }

   **Note:**\  Coroutines launched in the ``viewModelScope`` of an
   `AAC <#>`__
   `ViewModel <#>`__, run to
   completion, exceptionally or otherwise. This occurs whether the UI is
   visible or not, unless the Coroutines are explicitly canceled or the
   ``ViewModel`` is cleared. This is typically fine for most requests as
   they tend to be short lived. You shouldn't use the ``viewModelScope``
   to run requests that last for 5 seconds or more. Instead, you should
   enqueue them as deferred or long running work with WorkManager.

   .. rubric:: Mutating the UI state from background threads
      :name: mutating_the_ui_state_from_background_threads

   It's preferable to launch Coroutines on the main dispatcher for the
   production of UI state. That is, outside the ``withContext`` block in
   the code snippets below. However, if you need to update the UI state
   in a different background context, you can do so using the following
   APIs:

   -  Use the
      `withContext <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html>`__
      method to run Coroutines in a different concurrent context.
   -  When using ``MutableStateFlow``, use the
      `update <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/update.html>`__
      method as usual.
   -  When using Compose State, use the
      `Snapshot.withMutableSnapshot <#withMutableSnapshot>`__
      to guarantee atomic updates to State in the concurrent context.

   For example, assume in the ``DiceRollViewModel`` snippet below, that
   ``SlowRandom.nextInt()`` is a computationally intensive ``suspend``
   function that needs to be called from a CPU bound Coroutine.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: StateFlow
            :name: stateflow_2

         .. code:: prettyprint

            class DiceRollViewModel(
                private val defaultDispatcher: CoroutineScope = Dispatchers.Default
            ) : ViewModel() {

                private val _uiState = MutableStateFlow(DiceUiState())
                val uiState: StateFlow<DiceUiState> = _uiState.asStateFlow()

              // Called from the UI
              fun rollDice() {
                    viewModelScope.launch() {
                        // Other Coroutines that may be called from the current context
                        ‚Ä¶
                        withContext(defaultDispatcher) {
                            _uiState.update { currentState ->
                                currentState.copy(
                                    firstDieValue = SlowRandom.nextInt(from = 1, until = 7),
                                    secondDieValue = SlowRandom.nextInt(from = 1, until = 7),
                                    numberOfRolls = currentState.numberOfRolls + 1,
                                )
                            }
                        }
                    }
                }
            }

      .. container:: section

         .. rubric:: Compose State
            :name: compose-state_2

         .. code:: prettyprint

            class DiceRollViewModel(
                private val defaultDispatcher: CoroutineScope = Dispatchers.Default
            ) : ViewModel() {

                private val _uiState = MutableDiceUiState()
                val uiState: DiceUiState = _uiState

              // Called from the UI
              fun rollDice() {
                    viewModelScope.launch() {
                        // Other Coroutines that may be called from the current context
                        ‚Ä¶
                        withContext(defaultDispatcher) {
                            Snapshot.withMutableSnapshot {
                                _uiState.firstDieValue = SlowRandom.nextInt(from = 1, until = 7)
                                _uiState.secondDieValue = SlowRandom.nextInt(from = 1, until = 7)
                                _uiState.numberOfRolls = _uiState.numberOfRolls + 1
                            }
                        }
                    }
                }
            }

   **Note:**\  If all coroutines launched need to be called from a
   different context, you can call
   ``viewModelScope.launch(defaultDispatcher){ }`` directly.
   **Warning:**\  Updating Compose state from a non UI thread without
   using ``Snapshot.withMutableSnapshot{ }`` may cause inconsistencies
   in the state produced.

   .. rubric:: Stream APIs as sources of state change
      :name: stream-apis

   For sources of state change that produce multiple values over time in
   streams, aggregating the outputs of all the sources into a cohesive
   whole is a straightforward approach to state production.

   When using Kotlin Flows, you can achieve this with the
   `combine <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html>`__
   function. An example of this can be seen in the "Now `in Android" sample <https://github.com/android/nowinandroid>`__ in the
   InterestsViewModel:

   .. code:: prettyprint

      class InterestsViewModel(
          authorsRepository: AuthorsRepository,
          topicsRepository: TopicsRepository
      ) : ViewModel() {

          val uiState = combine(
              authorsRepository.getAuthorsStream(),
              topicsRepository.getTopicsStream(),
          ) { availableAuthors, availableTopics ->
              InterestsUiState.Interests(
                  authors = availableAuthors,
                  topics = availableTopics
              )
          }
              .stateIn(
                  scope = viewModelScope,
                  started = SharingStarted.WhileSubscribed(5_000),
                  initialValue = InterestsUiState.Loading
          )
      }

   **Note:**\  You can use the
   `stateIn <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html>`__
   operator to convert the combined ``Flow`` into a
   `StateFlow <#>`__ as the
   observable API for UI state.
   Use of the ``stateIn`` operator to create ``StateFlows`` gives the UI
   finer grained control over the activity of the state production
   pipeline as it may need to only be active when the UI is visible.

   -  Use ``SharingStarted.WhileSubscribed()`` if the pipeline should
      only be active when the UI is visible while collecting the flow in
      a lifecycle-aware manner.
   -  Use ``SharingStarted.Lazily`` if the pipeline should be active as
      long as the user may return to the UI, that is the UI is on the
      backstack, or in another tab offscreen.

   In cases where aggregating stream based sources of state does not
   apply, stream APIs like Kotlin Flows offer a rich set of
   transformations such as
   `merging <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/merge.html?query=fun%20%3CT%3E%20merge(vararg%20flows:%20Flow%3CT%3E>`__,
   `flattening <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html?query=inline%20fun%20%3CT,%20R%3E%20Flow%3CT%3E.flatMapLatest(crossinline%20transform:%20suspend%20(T>`__
   and so on to help with processing the streams into UI state.

   **Key Point:**\  In most cases, combine is an advisable approach to
   producing state from stream APIs.

   .. rubric:: One-shot and stream APIs as sources of state change
      :name: one-shot-and

   In the case where the state production pipeline depends on both
   one-shot calls and streams as sources of state change, streams are
   the defining constraint. Therefore, convert the one-shot calls into
   streams APIs, or pipe their output into streams and resume processing
   as described in the streams section above.

   With flows, this typically means creating one or more private backing
   ``MutableStateFlow`` instances to propagate state changes. You can
   also `create snapshot flows <#snapshotFlow>`__
   from Compose state.

   Consider the ``TaskDetailViewModel`` from the
   `architecture-samples <https://github.com/android/architecture-samples>`__
   repository below:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: StateFlow
            :name: stateflow_3

         .. code:: prettyprint

            class TaskDetailViewModel @Inject constructor(
                private val tasksRepository: TasksRepository,
                savedStateHandle: SavedStateHandle
            ) : ViewModel() {

                private val _isTaskDeleted = MutableStateFlow(false)
                private val _task = tasksRepository.getTaskStream(taskId)

                val uiState: StateFlow<TaskDetailUiState> = combine(
                    _isTaskDeleted,
                    _task
                ) { isTaskDeleted, task ->
                    TaskDetailUiState(
                        task = taskAsync.data,
                        isTaskDeleted = isTaskDeleted
                    )
                }
                    // Convert the result to the appropriate observable API for the UI
                    .stateIn(
                        scope = viewModelScope,
                        started = SharingStarted.WhileSubscribed(5_000),
                        initialValue = TaskDetailUiState()
                    )

                fun deleteTask() = viewModelScope.launch {
                    tasksRepository.deleteTask(taskId)
                    _isTaskDeleted.update { true }
                }
            }

      .. container:: section

         .. rubric:: Compose State
            :name: compose-state_3

         .. code:: prettyprint

            class TaskDetailViewModel @Inject constructor(
                private val tasksRepository: TasksRepository,
                savedStateHandle: SavedStateHandle
            ) : ViewModel() {

                private var _isTaskDeleted by mutableStateOf(false)
                private val _task = tasksRepository.getTaskStream(taskId)

                val uiState: StateFlow<TaskDetailUiState> = combine(
                    snapshotFlow { _isTaskDeleted },
                    _task
                ) { isTaskDeleted, task ->
                    TaskDetailUiState(
                        task = taskAsync.data,
                        isTaskDeleted = isTaskDeleted
                    )
                }
                    // Convert the result to the appropriate observable API for the UI
                    .stateIn(
                        scope = viewModelScope,
                        started = SharingStarted.WhileSubscribed(5_000),
                        initialValue = TaskDetailUiState()
                    )

                fun deleteTask() = viewModelScope.launch {
                    tasksRepository.deleteTask(taskId)
                    _isTaskDeleted = true
                }
            }

   **Note:**\  Compose ``State`` is converted to a flow using the
   `snapshotFlow { } <#snapshotFlow>`__
   API. See the
   `ForYouViewModel <https://github.com/android/nowinandroid/blob/main/feature-foryou/src/main/java/com/google/samples/apps/nowinandroid/feature/foryou/ForYouViewModel.kt>`__
   in the "Now In Android" sample for another example.

   .. rubric:: Output types in state production pipelines
      :name: output-types

   The choice of the output API for UI state, and the nature of its
   presentation depends largely on the API your app uses to render the
   UI. In Android apps, you can choose to use Views or Jetpack Compose.
   Considerations here include:

   -  Reading state in a `lifecycle aware <https://medium.com/androiddevelopers/consuming-flows-safely-in-jetpack-compose-cde014d0d5a3>`__
      manner.
   -  Whether state should be `exposed in one or multiple fields <#additional-considerations>`__
      from the state holder.

   The following table summarizes what APIs to use for your state
   production pipeline for any given input and consumer:

   =========================  ===========  ================================
   Input                      Consumer     Output
   =========================  ===========  ================================
   One-shot APIs              Views        ``StateFlow`` or ``LiveData``
   One-shot APIs              Compose      ``StateFlow`` or Compose ``State``
   Stream APIs                Views        ``StateFlow`` or ``LiveData``
   Stream APIs                Compose      ``StateFlow``
   One-shot and stream APIs   Views        ``StateFlow`` or ``LiveData``
   One-shot and stream APIs   Compose      ``StateFlow``
   =========================  ===========  ================================

   .. rubric:: State production pipeline initialization
      :name: initializing-state-production

   Initializing state production pipelines involves setting the initial
   conditions for the pipeline to run. This may involve providing
   initial input values critical to the starting of the pipeline, for
   example an ``id`` for the detail view of a news article, or starting
   an asynchronous load.

   You should initialize the state production pipeline lazily when
   possible to conserve system resources. Practically, this often means
   waiting until there is a consumer of the output. ``Flow`` APIs allow
   for this with the `started <#>`__
   argument in the `stateIn <#>`__
   method. In the cases where this is inapplicable, define an
   `idempotent <https://en.wikipedia.org/wiki/Idempotence>`__
   ``initialize()`` function to explicitly start the state production
   pipeline as shown in the following snippet:

   .. code:: prettyprint

      class MyViewModel : ViewModel() {

          private var initializeCalled = false

          // This function is idempotent provided it is only called from the UI thread.
          @MainThread
          fun initialize() {
              if(initializeCalled) return
              initializeCalled = true

              viewModelScope.launch {
                  // seed the state production pipeline
              }
          }
      }

   **Warning:**\  Avoid launching asynchronous operations in the
   ``init`` block or constructor of a ``ViewModel``. Asynchronous
   operations shouldn't be a side effect of creating an object because
   the asynchronous code may read from or write to the object before it
   is fully initialized. This is also referred to as leaking the object
   and it can lead to subtle and hard to diagnose errors. This is
   particularly important when working with Compose State. When the
   ViewModel holds Compose State fields, don't launch a Coroutine in the
   ``init`` block of the ``ViewModel`` that updates the Compose State
   fields, otherwise an ``IllegalStateException`` may occur.

   .. rubric:: Samples
      :name: samples

   The following Google samples demonstrate the production of state in
   the UI layer. Go explore them to see this guidance in practice:

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `UI layer <#>`__
   -  `Build an offline-first app <#>`__
   -  `State holders and UI State {:#mad-arch} <#>`__

Last updated 2023-07-12 UTC.



/Domain layer
=============

.. container:: devsite-article-body clearfix

   The domain layer is an *optional* layer that sits between the UI
   layer and the data layer.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-domain-overview.png
      name: domain-overview
      :alt: When it is included, the optional domain layer provides
      dependencies to the UI layer and depends on the data layer.
      :width: 500px

   **Figure 1.** The domain layer's role in app architecture.
   
   The domain layer is responsible for encapsulating complex business
   logic, or simple business logic that is reused by multiple
   ViewModels. This layer is optional because not all apps will have
   these requirements. You should only use it when needed-for example,
   to handle complexity or favor reusability.

   A domain layer provides the following benefits:

   -  It avoids code duplication.
   -  It improves readability in classes that use domain layer classes.
   -  It improves the testability of the app.
   -  It avoids large classes by allowing you to split responsibilities.

   To keep these classes simple and lightweight, each use case should
   only have responsibility over a single functionality, and they should
   not contain mutable data. You should instead handle mutable data in
   your UI or data layers.

   **Note:**\  The recommendations and best practices present in this
   page can be applied to a broad spectrum of apps to allow them to
   scale, improve quality and robustness, and make them easier to test.
   However, you should treat them as guidelines and adapt them to your
   requirements as needed.

   .. container:: video-wrapper-full-width

   .. rubric:: Naming conventions in this guide
      :name: conventions

   In this guide, use cases are named after the single action they're
   responsible for. The convention is as follows:

   *verb in present tense* + *noun/what (optional)* + *UseCase*.

   For example: ``FormatDateUseCase``, ``LogOutUserUseCase``,
   ``GetLatestNewsWithAuthorsUseCase``, or ``MakeLoginRequestUseCase``.

   .. rubric:: Dependencies
      :name: dependencies

   In a typical app architecture, use case classes fit between
   ViewModels from the UI layer and repositories from the data layer.
   This means that use case classes usually depend on repository
   classes, and they communicate with the UI layer the same way
   repositories do‚Äîusing either callbacks (for Java) or coroutines (for
   Kotlin). To learn more about this, see the `data layer page <#>`__.

   For example, in your app, you might have a use case class that
   fetches data from a news repository and an author repository, and
   combines them:

   .. code:: prettyprint

      class GetLatestNewsWithAuthorsUseCase(
        private val newsRepository: NewsRepository,
        private val authorsRepository: AuthorsRepository
      ) { /* ... */ }

   Because use cases contain reusable logic, they can also be used by
   other use cases. It's normal to have multiple levels of use cases in
   the domain layer. For example, the use case defined in the example
   below can make use of the ``FormatDateUseCase`` use case if multiple
   classes from the UI layer rely on time zones to display the proper
   message on the screen:

   .. code:: prettyprint

      class GetLatestNewsWithAuthorsUseCase(
        private val newsRepository: NewsRepository,
        private val authorsRepository: AuthorsRepository,
        private val formatDateUseCase: FormatDateUseCase
      ) { /* ... */ }

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-domain-usecase-deps.png
      name: domain-usecase-deps
      :alt: GetLatestNewsWithAuthorsUseCase depends on repository
      classes from the data layer, but it also depends on
      FormatDataUseCase, another use case class that is also in the
      domain layer.
      :width: 500px

   **Figure 2.** Example dependency graph for a use case that depends on
   other use cases.

   .. rubric:: Call use cases in Kotlin
      :name: use-cases-kotlin

   In Kotlin, you can make use case class instances callable as
   functions by defining the ``invoke()`` function with the ``operator``
   modifier. See the following example:

   .. code:: prettyprint

      class FormatDateUseCase(userRepository: UserRepository) {

          private val formatter = SimpleDateFormat(
              userRepository.getPreferredDateFormat(),
              userRepository.getPreferredLocale()
          )

          operator fun invoke(date: Date): String {
              return formatter.format(date)
          }
      }

   In this example, the ``invoke()`` method in ``FormatDateUseCase``
   allows you to call instances of the class as if they were functions.
   The ``invoke()`` method is not restricted to any specific
   signature‚Äîit can take any number of parameters and return any type.
   You can also overload ``invoke()`` with different signatures in your
   class. You'd call the use case from the example above as follows:

   .. code:: prettyprint

      class MyViewModel(formatDateUseCase: FormatDateUseCase) : ViewModel() {
          init {
              val today = Calendar.getInstance()
              val todaysDate = formatDateUseCase(today)
              /* ... */
          }
      }

   To learn more about the ``invoke()`` operator, see the `Kotlin docs <https://kotlinlang.org/docs/operator-overloading.html#invoke-operator>`__.

   .. rubric:: Lifecycle
      :name: lifecycle

   Use cases don't have their own lifecycle. Instead, they're scoped to
   the class that uses them. This means that you can call use cases from
   classes in the UI layer, from services, or from the ``Application``
   class itself. Because use cases shouldn't contain mutable data, you
   should create a new instance of a use case class every time you pass
   it as a dependency.

   .. rubric:: Threading
      :name: threading

   Use cases from the domain layer must be *main-safe*; in other words,
   they must be safe to call from the main thread. If use case classes
   perform long-running blocking operations, they are responsible for
   moving that logic to the appropriate thread. However, before doing
   that, check if those blocking operations would be better placed in
   other layers of the hierarchy. Typically, complex computations happen
   in the data layer to encourage reusability or caching. For example, a
   resource-intensive operation on a big list is better placed in the
   data layer than in the domain layer if the result needs to be cached
   to reuse it on multiple screens of the app.

   The following example shows a use case that performs its work on a
   background thread:

   .. code:: prettyprint

      class MyUseCase(
          private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default
      ) {

          suspend operator fun invoke(...) = withContext(defaultDispatcher) {
              // Long-running blocking operations happen on a background thread.
          }
      }

   .. rubric:: Common tasks
      :name: common-tasks

   This section describes how to perform common domain layer tasks.

   .. rubric:: Reusable simple business logic
      :name: reusable-logic

   You should encapsulate repeatable business logic present in the UI
   layer in a use case class. This makes it easier to apply any changes
   everywhere the logic is used. It also allows you to test the logic in
   isolation.

   Consider the ``FormatDateUseCase`` example described earlier. If your
   business requirements regarding date formatting change in the future,
   you only need to change code in one centralized place.

   **Note:**\  In some cases, logic that can exist in use cases could
   instead be part of static methods in ``Util`` classes. However, the
   latter is discouraged because ``Util`` classes are often hard to find
   and their functionality is hard to discover. Furthermore, use cases
   can share common functionality such as threading and error handling
   in base classes that can benefit larger teams at scale.

   .. rubric:: Combine repositories
      :name: combine-repositories

   In a news app, you might have ``NewsRepository`` and
   ``AuthorsRepository`` classes that handle news and author data
   operations respectively. The ``Article`` class that
   ``NewsRepository`` exposes only contains the name of the author, but
   you want to display more information about the author on the screen.
   Author information can be obtained from the ``AuthorsRepository``.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-domain-multiple-repos.png
      name: domain-multiple-repos
      :alt: GetLatestNewsWithAuthorsUseCase depends on two different
      repository classes from the data layer: NewsRepository and
      AuthorsRepository.
      :width: 500px

   **Figure 3.** Dependency graph for a use case that combines data from
   multiple repositories.
   Because the logic involves multiple repositories and can become
   complex, you create a ``GetLatestNewsWithAuthorsUseCase`` class to
   abstract the logic out of the ViewModel and make it more readable.
   This also makes the logic easier to test in isolation, and reusable
   in different parts of the app.

   .. code:: prettyprint

      /**
       * This use case fetches the latest news and the associated author.
       */
      class GetLatestNewsWithAuthorsUseCase(
        private val newsRepository: NewsRepository,
        private val authorsRepository: AuthorsRepository,
        private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default
      ) {
          suspend operator fun invoke(): List<ArticleWithAuthor> =
              withContext(defaultDispatcher) {
                  val news = newsRepository.fetchLatestNews()
                  val result: MutableList<ArticleWithAuthor> = mutableListOf()
                  // This is not parallelized, the use case is linearly slow.
                  for (article in news) {
                      // The repository exposes suspend functions
                      val author = authorsRepository.getAuthor(article.authorId)
                      result.add(ArticleWithAuthor(article, author))
                  }
                  result
              }
      }

   The logic maps all items in the ``news`` list; so even though the
   data layer is main-safe, this work shouldn't block the main thread
   because you don't know how many items it'll process. That's why the
   use case moves the work to a background thread using the default
   dispatcher.

   **Note:**\  The `Room library <#>`__ lets
   you query
   `relationships <#>`__ between
   different entities in a database. If the database is the `source of truth <#source-of-truth>`__, you can create
   a query that does all that work for you. In that case, it's better to
   create a repository class like ``NewsWithAuthorsRepository`` instead
   of a use case.

   .. rubric:: Other consumers
      :name: other-consumers

   Apart from the UI layer, the domain layer can be reused by other
   classes such as services and the ``Application`` class. Furthermore,
   if other platforms such as TV or Wear share codebase with the mobile
   app, their UI layer can also reuse use cases to get all the
   aforementioned benefits of the domain layer.

   .. rubric:: Data layer access restriction
      :name: data-access-restriction

   One other consideration when implementing the domain layer is whether
   you should still allow direct access to the data layer from the UI
   layer, or force everything through the domain layer.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-domain-data-access-restriction.png
      name: domain-data-access-restriction
      :alt: UI layer cannot access data layer directly, it must go
      through the Domain layer
      :width: 400px

      **Figure 4.** Dependency graph showing UI layer being denied
      access to the data layer.

   An advantage of making this restriction is that it stops your UI from
   bypassing domain layer logic, for example, if you are performing
   analytics logging on each access request to the data layer.

   However, the **potentially significant disadvantage** is that it
   forces you to add use cases even when they are just simple function
   calls to the data layer, which can add complexity for little benefit.

   A good approach is to add use cases only when required. If you find
   that your UI layer is accessing data through use cases almost
   exclusively, it may make sense to *only* access data this way.

   Ultimately, the decision to restrict access to the data layer comes
   down to your individual codebase, and whether you prefer strict rules
   or a more flexible approach.

   .. rubric:: Testing
      :name: testing

   `General testing guidance <#>`__ applies when testing
   the domain layer. For other UI tests, developers typically use fake
   repositories, and it's good practice to use fake repositories when
   testing the domain layer as well.

   .. rubric:: Samples
      :name: samples

   The following Google samples demonstrate the use of the domain layer.
   Go explore them to see this guidance in practice:

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Data layer <#>`__
   -  `UI State production <#>`__

Last updated 2023-07-12 UTC.


/Overveiw: Data layer
=====================

.. https://developer.android.google.cn/topic/architecture/data-layer

.. container:: devsite-article-body clearfix

   While the UI layer contains UI-related state and UI logic, the data
   layer contains *application data* and *business logic*. The business
   logic is what gives value to your app‚Äîit's made of real-world
   business rules that determine how application data must be created,
   stored, and changed.

   This separation of concerns allows the data layer to be used on
   multiple screens, share information between different parts of the
   app, and reproduce business logic outside of the UI for unit testing.
   For more information about the benefits of the data layer, check out
   the `Architecture Overview page <#>`__.

   **Note:**\  The recommendations and best practices present in this
   page can be applied to a broad spectrum of apps to allow them to
   scale, improve quality and robustness, and make them easier to test.
   However, you should treat them as guidelines and adapt them to your
   requirements as needed.

   .. container:: video-wrapper-full-width

   .. rubric:: Data layer architecture
      :name: architecture

   The data layer is made of *repositories* that each can contain zero
   to many *data sources*. You should create a repository class for each
   different type of data you handle in your app. For example, you might
   create a ``MoviesRepository`` class for data related to movies, or a
   ``PaymentsRepository`` class for data related to payments.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-data-overview.png
      name: data-overview
      :alt: In a typical architecture, the data layer's repositories
      provide data to the rest of the app and depend on the data
      sources.
      :width: 500px

   **Figure 1.** The UI layer's role in app architecture.
   Repository classes are responsible for the following tasks:

   -  Exposing data to the rest of the app.
   -  Centralizing changes to the data.
   -  Resolving conflicts between multiple data sources.
   -  Abstracting sources of data from the rest of the app.
   -  Containing business logic.

   Each data source class should have the responsibility of working with
   only one source of data, which can be a file, a network source, or a
   local database. Data source classes are the bridge between the
   application and the system for data operations.

   Other layers in the hierarchy should never access data sources
   directly; the entry points to the data layer are always the
   repository classes. State holder classes (see the `UI layer guide <#state-holders>`__) or use case classes
   (see the `domain layer guide <#>`__) should
   never have a data source as a direct dependency. Using repository
   classes as entry points allows the different layers of the
   architecture to scale independently.

   **The data exposed by this layer should be immutable** so that it
   cannot be tampered with by other classes, which would risk putting
   its values in an inconsistent state. Immutable data can also be
   safely handled by multiple threads. See the `threading section <#threading>`__ for more details.

   Following `dependency injection <#>`__
   best practices, the repository takes data sources as dependencies in
   its constructor:

   .. code:: prettyprint

      class ExampleRepository(
          private val exampleRemoteDataSource: ExampleRemoteDataSource, // network
          private val exampleLocalDataSource: ExampleLocalDataSource // database
      ) { /* ... */ }

   **Note:**\  Often, when a repository only contains a single data
   source and doesn't depend on other repositories, developers merge the
   responsibilities of repositories and data sources into the repository
   class. If you do this, don't forget to split functionalities if the
   repository needs to handle data from another source in a later
   version of your app.

   .. rubric:: Expose APIs
      :name: expose-apis

   Classes in the data layer generally expose functions to perform
   one-shot Create, Read, Update and Delete (CRUD) calls or to be
   notified of data changes over time. The data layer should expose the
   following for each of these cases:

   -  **One-shot operations:** The data layer should expose suspend
      functions in Kotlin; and for the Java programming language, the
      data layer should expose functions that provide a callback to
      notify the result of the operation, or RxJava ``Single``,
      ``Maybe``, or ``Completable`` types.
   -  **To be notified of data changes over time:** The data layer
      should expose `flows <#>`__ in Kotlin; and for the Java
      programming language, the data layer should expose a callback that
      emits the new data, or the RxJava ``Observable`` or ``Flowable``
      type.

   .. code:: prettyprint

      class ExampleRepository(
          private val exampleRemoteDataSource: ExampleRemoteDataSource, // network
          private val exampleLocalDataSource: ExampleLocalDataSource // database
      ) {

          val data: Flow<Example> = ...

          suspend fun modifyData(example: Example) { ... }
      }

   .. rubric:: Naming conventions in this guide
      :name: naming-conventions

   In this guide, repository classes are named after the data that
   they're responsible for. The convention is as follows:

   *type of data* + *Repository*.

   For example: ``NewsRepository``, ``MoviesRepository``, or
   ``PaymentsRepository``.

   Data source classes are named after the data they're responsible for
   and the source they use. The convention is as follows:

   *type of data* + *type of source* + *DataSource*.

   For the type of data, use *Remote* or *Local* to be more generic
   because implementations can change. For example:
   ``NewsRemoteDataSource`` or ``NewsLocalDataSource``. To be more
   specific in case the source is important, use the type of the source.
   For example: ``NewsNetworkDataSource`` or ``NewsDiskDataSource``.

   Don't name the data source based on an implementation detail‚Äîfor
   example, ``UserSharedPreferencesDataSource``‚Äîbecause repositories
   that use that data source shouldn't know how the data is saved. If
   you follow this rule, you can change the implementation of the data
   source (for example, migrating from
   `SharedPreferences <#>`__ to
   `DataStore <#>`__) without
   affecting the layer that calls that source.

   **Note:**\  When migrating over to a new implementation of a data
   source, you might create an interface for the data source and have
   two implementations of the data source: one for the old backing
   technology, and one for the new one. In that case, it's fine to use
   the name of the technology for the data source class names (even
   though it's an implementation detail) because the repository only
   sees the interface, not the data source classes themselves. When you
   finish the migration, you can rename the new class to not contain the
   implementation detail in its name.

   .. rubric:: Multiple levels of repositories
      :name: multiple-levels

   In some cases involving more complex business requirements, a
   repository might need to depend on other repositories. This could be
   because the data involved is an aggregation from multiple data
   sources, or because the responsibility needs to be encapsulated in
   another repository class.

   For example, a repository that handles user authentication data,
   ``UserRepository``, could depend on other repositories such as
   ``LoginRepository`` and ``RegistrationRepository`` to fulfill its
   requirements.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-data-multiple-repos.png
      name: data-multiple-repos
      :alt: In the example, UserRepository depends on two other
      repository classes: LoginRepository, which depends on other login
      data sources; and RegistrationRepository, which depends on other
      registration data sources.
      :width: 500px

   **Figure 2.** Dependency graph of a repository that depends on other
   repositories.
   **Note:**\  Traditionally, some developers have called repository
   classes that depend on other repository classes *managers*‚Äîfor
   example, ``UserManager`` instead of ``UserRepository``. You can use
   this naming convention if you prefer.

   .. rubric:: Source of truth
      :name: source-of-truth

   It's important that each repository defines a single source of truth.
   The source of truth always contains data that is consistent, correct,
   and up-to-date. In fact, the data exposed from the repository should
   always be the data coming directly from the source of truth.

   The source of truth can be a data source‚Äîfor example, the database‚Äîor
   even an in-memory cache that the repository might contain.
   Repositories combine different data sources and solve any potential
   conflicts between the data sources to update the single source of
   truth regularly or due to a user input event.

   Different repositories in your app might have different sources of
   truth. For example, the ``LoginRepository`` class might use its cache
   as the source of truth and the ``PaymentsRepository`` class might use
   the network data source.

   In order to provide offline-first support, **a local data source‚Äîsuch
   as a database‚Äîis the recommended source of truth**.

   .. rubric:: Threading
      :name: threading

   Calling data sources and repositories should be *main-safe*‚Äîsafe to
   call from the main thread. These classes are responsible for moving
   the execution of their logic to the appropriate thread when
   performing long-running blocking operations. For example, it should
   be main-safe for a data source to read from a file, or for a
   repository to perform expensive filtering on a big list.

   Note that most data sources already provide main-safe APIs like the
   suspend method calls provided by
   `Room <#>`__,
   `Retrofit <https://square.github.io/retrofit/>`__ or
   `Ktor <https://ktor.io/>`__. Your repository can take advantage of
   these APIs when they are available.

   To learn more about threading, see the `guide to background processing <#>`__. For Kotlin users,
   `coroutines <#>`__ are the recommended option. See
   `Running Android tasks in background threads <#>`__ 
   for recommended options for the Java programming language.

   .. rubric:: Lifecycle
      :name: lifecycle

   Instances of classes in the data layer remain in memory as long as
   they are reachable from a garbage collection root‚Äîusually by being
   referenced from other objects in your app.

   If a class contains in-memory data‚Äîfor example, a cache‚Äîyou might
   want to reuse the same instance of that class for a specific period
   of time. This is also referred to as the *lifecycle* of the class
   instance.

   If the class's responsibility is crucial for the whole application,
   you can *scope* an instance of that class to the ``Application``
   class. This makes it so the instance follows the application's
   lifecycle. Alternatively, if you only need to reuse the same instance
   in a particular flow in your app‚Äîfor example, the registration or
   login flow‚Äîthen you should scope the instance to the class that owns
   the lifecycle of that flow. For example, you could scope a
   ``RegistrationRepository`` that contains in-memory data to the
   ``RegistrationActivity`` or the `navigation graph <#create-nav-graph>`__
   of the registration flow.

   The lifecycle of each instance is a critical factor in deciding how
   to provide dependencies within your app. It's recommended that you
   follow `dependency injection <#>`__ best
   practices where the dependencies are managed and can be scoped to
   dependency containers. To learn more about scoping in Android, see
   the `Scoping in Android and Hilt <https://medium.com/androiddevelopers/scoping-in-android-and-hilt-c2e5222317c0>`__
   blog post.

   .. rubric:: Represent business models
      :name: business-models

   The data models that you want to expose from the data layer might be
   a subset of the information that you get from the different data
   sources. Ideally, the different data sources‚Äîboth network and
   local‚Äîshould return only the information your application needs; but
   that's not often the case.

   For example, imagine a News API server that returns not only the
   article information, but also edit history, user comments, and some
   metadata:

   .. code:: prettyprint

      data class ArticleApiModel(
          val id: Long,
          val title: String,
          val content: String,
          val publicationDate: Date,
          val modifications: Array<ArticleApiModel>,
          val comments: Array<CommentApiModel>,
          val lastModificationDate: Date,
          val authorId: Long,
          val authorName: String,
          val authorDateOfBirth: Date,
          val readTimeMin: Int
      )

   The app doesn't need that much information about the article because
   it only displays the content of the article on the screen, along with
   basic information about its author. It's a good practice to separate
   model classes and have your repositories expose only the data that
   the other layers of the hierarchy require. For example, here is how
   you might trim down the ``ArticleApiModel`` from the network in order
   to expose an ``Article`` model class to the domain and UI layers:

   .. code:: prettyprint

      data class Article(
          val id: Long,
          val title: String,
          val content: String,
          val publicationDate: Date,
          val authorName: String,
          val readTimeMin: Int
      )

   Separating model classes is beneficial in the following ways:

   -  It saves app memory by reducing the data to only what's needed.
   -  It adapts external data types to data types used by your app‚Äîfor
      example, your app might use a different data type to represent
      dates.
   -  It provides better separation of concerns‚Äîfor example, members of
      a large team could work individually on the network and UI layers
      of a feature if the model class is defined beforehand.

   You can extend this practice and define separate model classes in
   other parts of your app architecture as well‚Äîfor example, in data
   source classes and ViewModels. However, this requires you to define
   extra classes and logic that you should properly document and test.
   **At minimum, it's recommended that you create new models in any case
   where a data source receives data that doesn't match with what the
   rest of your app expects.**

   .. rubric:: Types of data operations
      :name: data-operation-types

   The data layer can deal with types of operations that vary based on
   how critical they are: UI-oriented, app-oriented, and
   business-oriented operations.

   .. rubric:: UI-oriented operations
      :name: ui-operations

   UI-oriented operations are only relevant when the user is on a
   specific screen, and they're canceled when the user moves away from
   that screen. An example is displaying some data obtained from the
   database.

   UI-oriented operations are typically triggered by the UI layer and
   follow the caller's lifecycle‚Äîfor example, the lifecycle of the
   ViewModel. See the `Make a network request <#network-request>`__
   section for an example of a UI-oriented operation.

   .. rubric:: App-oriented operations
      :name: app-operations

   App-oriented operations are relevant as long as the app is open. If
   the app is closed or the process is killed, these operations are
   canceled. An example is caching the result of a network request so
   that it can be used later if needed. See the `Implement in-memory data caching <#in-memory-cache>`__ section to learn more.

   These operations typically follow the lifecycle of the
   ``Application`` class or the data layer. For an example, see the
   `Make an operation live longer than the screen <#make_an_operation_live_longer_than_the_screen>`__ section.

   .. rubric:: Business-oriented operations
      :name: business-operations

   Business-oriented operations cannot be canceled. They should survive
   process death. An example is finishing the upload of a photo that the
   user wants to post to their profile.

   The recommendation for business-oriented operations is to use
   WorkManager. See the `Schedule tasks using WorkManager <#workmanager>`__ section to learn more.

   .. rubric:: Expose errors
      :name: expose-errors

   Interactions with repositories and sources of data can either succeed
   or throw an exception when a failure occurs. For coroutines and
   flows, you should use Kotlin's `built-in error-handling mechanism <https://kotlinlang.org/docs/exception-handling.html>`__.
   For errors that could be triggered by suspend functions, use
   ``try/catch`` blocks when appropriate; and in flows, use the
   `catch <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html>`__
   operator. With this approach, the UI layer is expected to handle
   exceptions when calling the data layer.

   The data layer can understand and handle different types of errors
   and expose them using custom exceptions‚Äîfor example, a
   ``UserNotAuthenticatedException``.

   **Note:**\  Another way to model the result of interactions with the
   data layer is by using a ``Result`` class. This pattern models errors
   and other signals that can happen as part of processing the result.
   In this pattern, the data layer returns a ``Result<T>`` type instead
   of ``T``, making the UI aware of *known* errors that could occur in
   certain scenarios. This is necessary for reactive programming APIs
   that don't have proper exception handling, such as
   `LiveData <#>`__.
   To learn more about errors in coroutines, see the `Exceptions in coroutines <https://medium.com/androiddevelopers/exceptions-in-coroutines-ce8da1ec060c>`__
   blog post.

   .. rubric:: Common tasks
      :name: common-tasks

   The following sections present examples of how to use and architect
   the data layer to perform certain tasks that are common in Android
   apps. The examples are based on the typical News app mentioned
   earlier in the guide.

   .. rubric:: Make a network request
      :name: network-request

   Making a network request is one of the most common tasks an Android
   app might perform. The News app needs to present the user with the
   latest news that is fetched from the network. Therefore, the app
   needs a data source class to manage network operations:
   ``NewsRemoteDataSource``. To expose the information to the rest of
   the app, a new repository that handles operations on news data is
   created: ``NewsRepository``.

   The requirement is that the latest news always needs to be updated
   when the user opens the screen. Thus, this is a *UI-oriented
   operation*.

   .. rubric:: Create the data source
      :name: create_the_data_source

   The data source needs to expose a function that returns the latest
   news: a list of ``ArticleHeadline`` instances. The data source needs
   to provide a main-safe way to obtain the latest news from the
   network. For that, it needs to take a dependency on the
   ``CoroutineDispatcher`` or ``Executor`` to run the task on.

   Making a network request is a one-shot call handled by a new
   ``fetchLatestNews()`` method:

   .. code:: prettyprint

      class NewsRemoteDataSource(
        private val newsApi: NewsApi,
        private val ioDispatcher: CoroutineDispatcher
      ) {
          /**
           * Fetches the latest news from the network and returns the result.
           * This executes on an IO-optimized thread pool, the function is main-safe.
           */
          suspend fun fetchLatestNews(): List<ArticleHeadline> =
              // Move the execution to an IO-optimized thread since the ApiService
              // doesn't support coroutines and makes synchronous requests.
              withContext(ioDispatcher) {
                  newsApi.fetchLatestNews()
              }
          }

      // Makes news-related network synchronous requests.
      interface NewsApi {
          fun fetchLatestNews(): List<ArticleHeadline>
      }

   The ``NewsApi`` interface hides the implementation of the network API
   client; it doesn't make a difference whether the interface is backed
   by `Retrofit <https://square.github.io/retrofit/>`__ or
   `HttpURLConnection <#>`__.
   Relying on interfaces makes API implementations swappable in your
   app.

   **Key Point:**\  **Relying on interfaces makes API implementations
   swappable in your app.** In addition to providing scalability and
   allowing you to replace dependencies more easily, it also favors
   testability because you can inject fake data source implementations
   in tests.

   .. rubric:: Create the repository
      :name: create_the_repository

   Because no extra logic is needed in the repository class for this
   task, ``NewsRepository`` acts as a proxy for the network data source.
   The benefits of adding this extra layer of abstraction are explained
   in the `in-memory caching <#in-memory-cache>`__ section.

   .. code:: prettyprint

      // NewsRepository is consumed from other layers of the hierarchy.
      class NewsRepository(
          private val newsRemoteDataSource: NewsRemoteDataSource
      ) {
          suspend fun fetchLatestNews(): List<ArticleHeadline> =
              newsRemoteDataSource.fetchLatestNews()
      }

   To learn how to consume the repository class directly from the UI
   layer, see the `UI layer <#>`__ guide.

   .. rubric:: Implement in-memory data caching
      :name: in-memory-cache

   Suppose a new requirement is introduced for the News app: when the
   user opens the screen, cached news must be presented to the user if a
   request has been made previously. Otherwise, the app should make a
   network request to fetch the latest news.

   Given the new requirement, the app must preserve the latest news in
   memory while the user has the app open. Thus, this is an
   *app-oriented operation*.

   .. rubric:: Caches
      :name: caches

   You can preserve data while the user is in your app by adding
   in-memory data caching. Caches are meant to save some information in
   memory for a specific amount of time‚Äîin this case, as long as the
   user is in the app. Cache implementations can take different forms.
   It can vary from a simple mutable variable to a more sophisticated
   class that protects from read/write operations on multiple threads.
   Depending on the use case, caching can be implemented in the
   repository or in data source classes.

   .. rubric:: Cache the result of the network request
      :name: cache_the_result_of_the_network_request

   For simplicity, ``NewsRepository`` uses a mutable variable to cache
   the latest news. To protect reads and writes from different threads,
   a
   `Mutex <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/>`__
   is used. To learn more about shared mutable state and concurrency,
   see the `Kotlin documentation <https://kotlinlang.org/docs/shared-mutable-state-and-concurrency.html#shared-mutable-state-and-concurrency>`__.

   The following implementation caches the latest news information to a
   variable in the repository that is write-protected with a ``Mutex``.
   If the result of the network request succeeds, the data is assigned
   to the ``latestNews`` variable.

   .. code:: prettyprint

      class NewsRepository(
        private val newsRemoteDataSource: NewsRemoteDataSource
      ) {
          // Mutex to make writes to cached values thread-safe.
          private val latestNewsMutex = Mutex()

          // Cache of the latest news got from the network.
          private var latestNews: List<ArticleHeadline> = emptyList()

          suspend fun getLatestNews(refresh: Boolean = false): List<ArticleHeadline> {
              if (refresh || latestNews.isEmpty()) {
                  val networkResult = newsRemoteDataSource.fetchLatestNews()
                  // Thread-safe write to latestNews
                  latestNewsMutex.withLock {
                      this.latestNews = networkResult
                  }
              }

              return latestNewsMutex.withLock { this.latestNews }
          }
      }

   .. rubric:: Make an operation live longer than the screen
      :name: make_an_operation_live_longer_than_the_screen

   If the user navigates away from the screen while the network request
   is in progress, it'll be canceled and the result won't be cached.
   ``NewsRepository`` shouldn't use the caller's ``CoroutineScope`` to
   perform this logic. Instead, ``NewsRepository`` should use a
   ``CoroutineScope`` that's attached to its lifecycle. **Fetching the
   latest news needs to be an app-oriented operation.**

   To follow dependency injection best practices, ``NewsRepository``
   should receive a scope as a parameter in its constructor instead of
   creating its own ``CoroutineScope``. Because repositories should do
   most of their work in background threads, you should configure the
   ``CoroutineScope`` with either ``Dispatchers.Default`` or with your
   own thread pool.

   .. code:: prettyprint

      class NewsRepository(
          ...,
          // This could be CoroutineScope(SupervisorJob() + Dispatchers.Default).
          private val externalScope: CoroutineScope
      ) { ... }

   Because ``NewsRepository`` is ready to perform app-oriented
   operations with the external ``CoroutineScope``, it must perform the
   call to the data source and save its result with a new coroutine
   started by that scope:

   .. code:: prettyprint

      class NewsRepository(
          private val newsRemoteDataSource: NewsRemoteDataSource,
          private val externalScope: CoroutineScope
      ) {
          /* ... */

          suspend fun getLatestNews(refresh: Boolean = false): List<ArticleHeadline> {
              return if (refresh) {
                  externalScope.async {
                      newsRemoteDataSource.fetchLatestNews().also { networkResult ->
                          // Thread-safe write to latestNews.
                          latestNewsMutex.withLock {
                              latestNews = networkResult
                          }
                      }
                  }.await()
              } else {
                  return latestNewsMutex.withLock { this.latestNews }
              } 
          }
      }

   ``async`` is used to start the coroutine in the external scope.
   ``await`` is called on the new coroutine to suspend until the network
   request comes back and the result is saved to the cache. If by that
   time the user is still on the screen, then they will see the latest
   news; if the user moves away from the screen, ``await`` is canceled
   but the logic inside ``async`` continues to execute.

   See `this blog post <https://medium.com/androiddevelopers/coroutines-patterns-for-work-that-shouldnt-be-cancelled-e26c40f142ad>`__
   to learn more about patterns for ``CoroutineScope``.

   .. rubric:: Save and retrieve data from disk
      :name: save-retrieve-data

   Suppose that you want to save data like bookmarked news and user
   preferences. This type of data needs to survive process death and be
   accessible even if the user is not connected to the network.

   If the data you‚Äôre working with needs to survive process death, then
   you need to store it on disk in one of the following ways:

   -  For *large datasets* that need to be queried, need referential
      integrity, or need partial updates, save the data in a *Room
      database*. In the News app example, the news articles or authors
      could be saved in the database.
   -  For *small datasets* that only need to be retrieved and set (not
      queries or updated partially), use *DataStore*. In the News app
      example, the user's preferred date format or other display
      preferences could be saved in DataStore.
   -  For *chunks of data* like a JSON object, use a *file*.

   As mentioned in the `Source of truth <#source-of-truth>`__ section,
   each data source works with only one source and corresponds to a
   specific data type (for example, ``News``, ``Authors``,
   ``NewsAndAuthors``, or ``UserPreferences``). Classes that use the
   data source shouldn't know how the data is saved‚Äîfor example, in a
   database or in a file.

   .. rubric:: Room as a data source
      :name: room_as_a_data_source

   Because each data source should have the responsibility of working
   with only one source for a specific type of data, a Room data source
   would receive either a `data access object (DAO) <#>`__ or the database
   itself as a parameter. For example, ``NewsLocalDataSource`` might
   take an instance of ``NewsDao`` as a parameter, and
   ``AuthorsLocalDataSource`` might take an instance of ``AuthorsDao``.

   In some cases, if no extra logic is needed, you could inject the DAO
   directly into the repository, because the DAO is an interface that
   you can easily replace in tests.

   To learn more about working with the Room APIs, see the `Room guides <#>`__.

   .. rubric:: DataStore as a data source
      :name: datastore_as_a_data_source

   `DataStore <#>`__ is perfect
   for storing key-value pairs like user settings. Examples might
   include time format, notification preferences, and whether to show or
   hide news items after the user has read them. DataStore can also
   store typed objects with `protocol buffers <https://developers.google.cn/protocol-buffers>`__.

   Like with any other object, a data source backed by DataStore should
   contain data corresponding to a certain type or to a certain part of
   the app. This is even more true with DataStore, because DataStore
   reads are exposed as a flow that emits every time a value is updated.
   For this reason, you should store related preferences in the same
   DataStore.

   For example, you could have a ``NotificationsDataStore`` that only
   handles notification-related preferences and a
   ``NewsPreferencesDataStore`` that only handles preferences related to
   the news screen. That way, you‚Äôre able to scope the updates better,
   because the ``newsScreenPreferencesDataStore.data`` flow only emits
   when a preference related to that screen is changed. It also means
   that the lifecycle of the object can be shorter because it can live
   only as long as the news screen is displayed.

   To learn more about working with the DataStore APIs, see the
   `DataStore guides <#>`__.

   .. rubric:: A file as a data source
      :name: a_file_as_a_data_source

   When working with large objects like a JSON object or a bitmap,
   you'll need to work with a ``File`` object and handle switching
   threads.

   To learn more about working with file storage, see the `Storage overview <#>`__ page.

   .. rubric:: Schedule tasks using WorkManager
      :name: workmanager

   Suppose another new requirement is introduced for the News app: the
   app must give the user the option to fetch the latest news regularly
   and automatically as long as the device is charging and connected to
   an unmetered network. That makes this a *business-oriented*
   operation. This requirement makes it so that even if the device
   doesn't have connectivity when the user opens the app, the user can
   still see recent news.

   `WorkManager <#>`__ makes it
   easy to schedule asynchronous and reliable work and can take care of
   constraint management. It's the recommended library for persistent
   work. To perform the task defined above, a
   `Worker <#>`__
   class is created: ``RefreshLatestNewsWorker``. This class takes
   ``NewsRepository`` as a dependency in order to fetch the latest news
   and cache it to disk.

   .. code:: prettyprint

      class RefreshLatestNewsWorker(
          private val newsRepository: NewsRepository,
          context: Context,
          params: WorkerParameters
      ) : CoroutineWorker(context, params) {

          override suspend fun doWork(): Result = try {
              newsRepository.refreshLatestNews()
              Result.success()
          } catch (error: Throwable) {
              Result.failure()
          }
      }

   The business logic for this type of task should be encapsulated in
   its own class and treated as a separate data source. WorkManager will
   then only be responsible for ensuring the work is executed on a
   background thread when all constraints are met. By adhering to this
   pattern, you can quickly swap implementations on different
   environments as needed.

   In this example, this news-related task must be called from
   ``NewsRepository``, which would take a new data source as a
   dependency: ``NewsTasksDataSource``, implemented as follows:

   .. code:: prettyprint

      private const val REFRESH_RATE_HOURS = 4L
      private const val FETCH_LATEST_NEWS_TASK = "FetchLatestNewsTask"
      private const val TAG_FETCH_LATEST_NEWS = "FetchLatestNewsTaskTag"

      class NewsTasksDataSource(
          private val workManager: WorkManager
      ) {
          fun fetchNewsPeriodically() {
              val fetchNewsRequest = PeriodicWorkRequestBuilder<RefreshLatestNewsWorker>(
                  REFRESH_RATE_HOURS, TimeUnit.HOURS
              ).setConstraints(
                  Constraints.Builder()
                      .setRequiredNetworkType(NetworkType.TEMPORARILY_UNMETERED)
                      .setRequiresCharging(true)
                      .build()
              )
                  .addTag(TAG_FETCH_LATEST_NEWS)

              workManager.enqueueUniquePeriodicWork(
                  FETCH_LATEST_NEWS_TASK,
                  ExistingPeriodicWorkPolicy.KEEP,
                  fetchNewsRequest.build()
              )
          }

          fun cancelFetchingNewsPeriodically() {
              workManager.cancelAllWorkByTag(TAG_FETCH_LATEST_NEWS)
          }
      }

   These types of classes are named after the data they're responsible
   for‚Äîfor example, ``NewsTasksDataSource`` or
   ``PaymentsTasksDataSource``. All tasks related to a particular type
   of data should be encapsulated in the same class.

   If the task needs to be triggered at app startup, it's recommended to
   trigger the WorkManager request using the `App Startup <#>`__ library that calls the
   repository from an
   `Initializer <#>`__.

   To learn more about working with WorkManager APIs, see the
   `WorkManager guides <#>`__.

   .. rubric:: Testing
      :name: testing

   `Dependency injection <#>`__ best
   practices help when testing your app. It's also helpful to rely on
   interfaces for classes that communicate with external resources. When
   you test a unit, you can inject fake versions of its dependencies to
   make the test deterministic and reliable.

   .. rubric:: Unit tests
      :name: unit-tests

   `General testing guidance <#>`__ applies when testing
   the data layer. For unit tests, use real objects when needed and fake
   any dependencies that reach out to external sources such as reading
   from a file or reading from the network.

   .. rubric:: Integration tests
      :name: integration-tests

   Integration tests that access external sources tend to be less
   deterministic because they need to run on a real device. It's
   recommended that you execute those tests under a controlled
   environment to make the integration tests more reliable.

   For databases, Room allows creating an in-memory database that you
   can fully control in your tests. To learn more, see the 
   `Test and debug your database <#android>`__ page.

   For networking, there are popular libraries such as
   `WireMock <http://wiremock.org/>`__ or
   `MockWebServer <https://github.com/square/okhttp/tree/master/mockwebserver>`__
   that let you fake HTTP and HTTPS calls and verify that the requests
   were made as expected.

   .. rubric:: Samples
      :name: samples

   The following Google samples demonstrate the use of the data layer.
   Go explore them to see this guidance in practice:

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Domain layer <#>`__
   -  `Build an offline-first app <#>`__
   -  `UI State production <#>`__

Last updated 2023-07-12 UTC.


/Build an offline-first app
===========================

.. container:: devsite-article-body clearfix

   An offline-first app is an app that is able to perform all, or a
   critical subset of its core functionality without access to the
   internet. That is, it can perform some or all of its business logic
   offline.

   Considerations for building an offline-first app start in the 
   `data layer <#>`__ which offers access to
   application data and business logic. The app may need to refresh this
   data from time to time from sources external to the device. In doing
   so, it may need to call on network resources to stay up to date.

   Network availability is not always guaranteed. Devices commonly have
   periods of spotty or slow network connection. Users may experience
   the following:

   -  Limited internet bandwidth
   -  Transitory connection interruptions, such as when in an elevator
      or a tunnel.
   -  Occasional data access. For example, WiFi-only tablets.

   Regardless of the reason, it is often possible for an app to function
   adequately in these circumstances. To ensure that your app functions
   correctly offline, it should be able to do the following:

   -  Remain usable without a reliable network connection.
   -  Present users with local data immediately instead of waiting for
      the first network call to complete or fail.
   -  Fetch data in a manner that is conscious of battery and data
      status. For example, by only requesting data fetches under optimal
      conditions, such as when charging or on WiFi.

   An app that can satisfy the criteria above is often called an
   offline-first app.

   .. container:: video-wrapper-full-width

   .. rubric:: Design an offline-first app
      :name: design-offline

   When designing an offline-first app you should start in the 
   `data layer <#>`__ and the two main operations
   that you can perform on app data:

   -  **Reads**: Retrieving data for use by other parts of the app like
      displaying information to the user.
   -  **Writes**: Persisting user input for later retrieval.

   `Repositories <#architecture>`__ in the
   data layer are responsible for combining data sources to provide app
   data. In an offline-first app, there must be at least one data source
   that does not need network access to perform its most critical tasks.
   One of these critical tasks is reading data.

   **Note:**\  At a minimum, an offline-first app should be able to
   perform reads without network access.
   
   .. rubric:: Model data in an offline-first app
      :name: modeling-data

   An offline-first app has a minimum of 2 data sources for every
   repository that utilizes network resources:

   -  The local data source
   -  The network data source

   .. figure::
      https://developer.android.google.cn/static/images/topic/architecture/data-layer/data-layer.png
      name: image-1
      :alt: An offline-first data layer is comprised of both local and
      network data sources
      :width: 60.0%

      **Figure 1**: An offline-first repository

   **Note:**\  A repository with network access in an offline-first app
   should always have a local data source.
   
   .. rubric:: The local data source
      :name: local-data

   The local data source is the canonical 
   `source of truth <#source-of-truth>`__ for the
   app. It should be the exclusive source of any data that higher layers
   of the app read. This ensures data consistency in between connection
   states. The local data source is often backed by storage that is
   persisted to disk. Some common means of persisting data to disk are
   the following:

   -  Structured data sources, such as relational databases like
      `Room <#>`__.
   -  Unstructured data sources. For example, protocol buffers with
      Datastore.
   -  Simple files

   .. rubric:: The network data source
      :name: network-data

   The network data source is the actual state of the application. The
   local data source is at best synchronized with the network data
   source. It can also lag behind it, in which case the app needs to be
   updated when back online. Inversely, the network data source may lag
   behind the local data source until the app can update it when
   connectivity returns. The domain and UI layers of the app should
   never liaise with the network layer directly. It is the
   responsibility of the hosting ``repository`` to communicate with it,
   and use it to update the local data source.

   .. rubric:: Exposing resources
      :name: exposing-resources

   The local and network data sources can differ fundamentally in how
   your app can read and write to them. Querying a local data source can
   be fast and flexible, such as when using SQL queries. Conversely,
   network data sources can be slow and constrained, such as when
   incrementally accessing RESTful resources by id. As a result, each
   data source often needs its own representation of the data it
   provides. The local data source and network data source may therefore
   have their own models.

   The directory structure below visualizes this concept. The
   ``AuthorEntity`` is a representation of an author read from the app's
   local database, and the ``NetworkAuthor`` a representation of an
   author serialized over the network:

   .. code:: prettyprint

      data/
      ‚îú‚îÄ local/
      ‚îÇ ‚îú‚îÄ entities/
      ‚îÇ ‚îÇ ‚îú‚îÄ AuthorEntity
      ‚îÇ ‚îú‚îÄ dao/
      ‚îÇ ‚îú‚îÄ NiADatabase
      ‚îú‚îÄ network/
      ‚îÇ ‚îú‚îÄ NiANetwork
      ‚îÇ ‚îú‚îÄ models/
      ‚îÇ ‚îÇ ‚îú‚îÄ NetworkAuthor
      ‚îú‚îÄ model/
      ‚îÇ ‚îú‚îÄ Author
      ‚îú‚îÄ repository/

   The details of the ``AuthorEntity`` and ``NetworkAuthor`` follow:

   .. code:: prettyprint

      /**
       * Network representation of [Author]
       */
      @Serializable
      data class NetworkAuthor(
          val id: String,
          val name: String,
          val imageUrl: String,
          val twitter: String,
          val mediumPage: String,
          val bio: String,
      )

      /**
       * Defines an author for either an [EpisodeEntity] or [NewsResourceEntity].
       * It has a many-to-many relationship with both entities
       */
      @Entity(tableName = "authors")
      data class AuthorEntity(
          @PrimaryKey
          val id: String,
          val name: String,
          @ColumnInfo(name = "image_url")
          val imageUrl: String,
          @ColumnInfo(defaultValue = "")
          val twitter: String,
          @ColumnInfo(name = "medium_page", defaultValue = "")
          val mediumPage: String,
          @ColumnInfo(defaultValue = "")
          val bio: String,
      )

   It is good practice to keep both the ``AuthorEntity`` and the
   ``NetworkAuthor`` internal to the data layer and expose a third type
   for external layers to consume. This protects external layers from
   minor changes in the local and network data sources that don't
   fundamentally change the behavior of the app. This is demonstrated in
   the following snippet:

   .. code:: prettyprint

      /**
       * External data layer representation of a "Now in Android" Author
       */
      data class Author(
          val id: String,
          val name: String,
          val imageUrl: String,
          val twitter: String,
          val mediumPage: String,
          val bio: String,
      )

   The network model can then define an extension method to convert it
   to the local model, and the local model similarly has one to convert
   it to the external representation as shown below:

   .. code:: prettyprint

      /**
       * Converts the network model to the local model for persisting
       * by the local data source
       */
      fun NetworkAuthor.asEntity() = AuthorEntity(
          id = id,
          name = name,
          imageUrl = imageUrl,
          twitter = twitter,
          mediumPage = mediumPage,
          bio = bio,
      )

      /**
       * Converts the local model to the external model for use
       * by layers external to the data layer
       */
      fun AuthorEntity.asExternalModel() = Author(
          id = id,
          name = name,
          imageUrl = imageUrl,
          twitter = twitter,
          mediumPage = mediumPage,
          bio = bio,
      )

   **Note:**\  Mappers like the above often map between models defined
   in different modules. As a result, it's often beneficial to define
   these mappers in the modules where they are used to avoid tightly
   coupled modules. See the `modularization guide <#communication>`__ 
   for more details.
   
   .. rubric:: Reads
      :name: reads

   Reads are the fundamental operation on app data in an offline-first
   app. You must therefore ensure that your app can read the data, and
   that as soon as new data is available the app can display it. An app
   that can do this is a reactive **app** because they expose read APIs
   with observable types.

   In the snippet below, the ``OfflineFirstTopicRepository`` returns
   ``Flows`` for all its read APIs. This allows it to update its readers
   when it receives updates from the network data source. In other
   words, it allows the ``OfflineFirstTopicRepository`` push changes
   when its local data source is invalidated. Therefore, each reader of
   the ``OfflineFirstTopicRepository`` must be prepared to handle data
   changes that can be triggered when network connectivity is restored
   to the app. Furthermore, ``OfflineFirstTopicRepository`` reads data
   directly from the local data source. It can only notify its readers
   of data changes by updating its local data source first.

   .. code:: prettyprint

      class OfflineFirstTopicsRepository(
          private val topicDao: TopicDao,
          private val network: NiaNetworkDataSource,
      ) : TopicsRepository {

          override fun getTopicsStream(): Flow<List<Topic>> =
              topicDao.getTopicEntitiesStream()
                  .map { it.map(TopicEntity::asExternalModel) }
      }

   **Note:**\  Read operations from repositories in an offline-first app
   should read directly from the local data source. Any updates should
   be written to the local data source first, and the local data source
   will update its consumers since it is observable.
   
   .. rubric:: Error handling strategies
      :name: error-handling

   There are unique ways of handling errors in offline-first apps,
   depending on the data sources where they may occur. The following
   subsections outline these strategies.

   .. rubric:: Local data source
      :name: local_data_source

   Errors while reading from the local data source should be rare. To
   protect readers from errors, use the ``catch`` operator on the
   ``Flows`` from which the reader is collecting data.

   Use of the
   `catch <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html>`__
   operator in a ``ViewModel`` is as follows:

   .. code:: prettyprint

      class AuthorViewModel(
          authorsRepository: AuthorsRepository,
          ...
      ) : ViewModel() {
         private val authorId: String = ...

         // Observe author information
          private val authorStream: Flow<Author> =
              authorsRepository.getAuthorStream(
                  id = authorId
              )
              .catch { emit(Author.empty()) }
      }

   **Note:**\  The ``catch`` operator only prevents the exception from
   crashing the app, the backing ``Flow`` still terminates. To resume
   collecting from the flow after the exception, consider the
   `retry <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/retry.html>`__
   method.
   
   .. rubric:: Network data source
      :name: network_data_source

   If errors occur when reading data from a network data source, the app
   will need to employ a heuristic to retry fetching data. Common
   heuristics include:

   .. rubric:: Exponential backoff
      :name: exponential_backoff

   In `exponential backoff <https://en.wikipedia.org/wiki/Exponential_backoff>`__, the
   app keeps attempting to read from the network data source with
   increasing time intervals until it succeeds, or other conditions
   dictate that it should stop.

   .. figure::
      https://developer.android.google.cn/static/images/topic/architecture/data-layer/read-backoff.png
      name: image-2
      :alt: Reading data with exponential backoff
      :width: 60.0%

      **Figure 2**: Reading data with exponential backoff

   Criteria to evaluate if the app should keep backing off include:

   -  The kind of error the network data source indicated. For example,
      you should retry network calls that return an error that indicate
      a lack of connectivity. Conversely, you shouldn't retry HTTP
      requests that are not authorized until proper credentials are
      available.
   -  Maximum allowable retries.

   .. rubric:: Network connectivity monitoring
      :name: network_connectivity_monitoring

   In this approach, read requests are queued until the app is certain
   it can connect to the network data source. Once a connection has been
   established, the read request is then dequeued, the data read and the
   local data source updated. On Android this queue may be maintained
   with a Room database, and drained as persistent work using
   WorkManager.

   .. figure::
      https://developer.android.google.cn/static/images/topic/architecture/data-layer/read-queue.png
      name: image-3
      :alt: Reading data with network monitors and queues
      :width: 100.0%

      **Figure 3**: Read queues with network monitoring

   .. rubric:: Writes
      :name: writes

   While the recommended way to read data in an offline-first app is
   using observable types, the equivalent for write APIs are
   **asynchronous APIs** such as suspend functions. This avoids blocking
   the UI thread, and helps with error handling because writes in
   offline-first apps may fail when crossing a network boundary.

   .. code:: prettyprint

      interface UserDataRepository {
          /**
           * Updates the bookmarked status for a news resource
           */
          suspend fun updateNewsResourceBookmark(newsResourceId: String, bookmarked: Boolean)
      }

   In the snippet above, the asynchronous API of choice is
   `Coroutines <#>`__ as the method above suspends.

   .. rubric:: Write strategies
      :name: write-strategies

   When writing data in offline-first apps, there are three strategies
   to consider. Which you choose depends on the type of data being
   written and the requirements of the app:

   .. rubric:: Online-only writes
      :name: online-only_writes

   Attempt to write the data across the network boundary. If successful,
   update the local data source, otherwise throw an exception and leave
   it to the caller to respond appropriately.

   .. figure::
      https://developer.android.google.cn/static/images/topic/architecture/data-layer/write-online-only.png
      name: image-4
      :alt: Online only writes
      :width: 60.0%

      **Figure 4**: Online only writes

   This strategy is often used for write transactions that must happen
   online in near real time. For example, a bank transfer. Since writes
   may fail, it is often necessary to communicate to the user that the
   write failed, or prevent the user from attempting to write data in
   the first place. Some strategies you can employ in these scenarios
   may include:

   -  If an app requires internet access to write data, it may opt not
      to present a UI to the user that allows the user to write data, or
      at the very least disables it.
   -  You can use a pop-up message the user can‚Äôt dismiss, or a
      transient prompt, to notify the user that they are offline.

   .. rubric:: Queued writes
      :name: queued_writes

   When you have an object you would like to write, insert it into a
   queue. Proceed to drain the queue with exponential back off when the
   app gets back online. On Android, draining an offline queue is
   persistent work that is often delegated to
   `WorkManager <#>`__.

   .. figure::
      https://developer.android.google.cn/static/images/topic/architecture/data-layer/write-backoff.png
      name: image-5
      :alt: Write queues with retries
      :width: 60.0%

      **Figure 5**: Write queues with retries

   This approach is a good choice if:

   -  It's not essential that the data ever be written to the network.
   -  The transaction is not time sensitive.
   -  It's not essential that the user be informed if the operation
      fails.

   Use cases for this approach include analytics events and logging.

   .. rubric:: Lazy writes
      :name: lazy_writes

   Write to the local data source first, then queue the write to notify
   the network at the earliest convenience. This is non trivial as there
   can be conflicts between the network and local data sources when the
   app comes back online. The next section on conflict resolution
   provides more detail.

   .. figure::
      https://developer.android.google.cn/static/images/topic/architecture/data-layer/write-queue.png
      name: image-6
      :alt: Lazy writes with network monitoring
      :width: 60.0%

      **Figure 6**: Lazy writes

   This approach is the correct choice when the data is critical to the
   app. For example, in an offline-first to-do list app, it's essential
   that any tasks the user adds offline are stored locally to avoid the
   risk of data loss.

   **Note:**\  Writing data in offline-first apps often requires more
   consideration than reading data because of potential conflicts.
   Offline-first apps don't need to be able to write data when offline
   to be considered offline-first.
   
   .. rubric:: Synchronization and conflict resolution
      :name: synchronization-and

   When an offline-first app restores its connectivity, it needs to
   reconcile the data in its local data source with that in the network
   data source. This process is called **synchronization**. There are
   two main ways an app can synchronize with its network data source:

   -  Pull-based synchronization
   -  Push-based synchronization

   .. rubric:: Pull-based synchronization
      :name: pull-based-synchronization

   In pull-based synchronization, the app reaches out to the network to
   read the latest application data on demand. A common heuristic for
   this approach is navigation-based, where the app only fetches data
   just before it presents it to the user.

   This approach works best when the app expects brief to intermediate
   periods of no network connectivity. This is because data refresh is
   opportunistic, and long periods of no connectivity increase the
   chance that the user attempts to visit app destinations with a cache
   that is either stale or empty.

   .. figure::
      https://developer.android.google.cn/static/images/topic/architecture/data-layer/pull-sync.png
      name: image-7
      :alt: Pull based synchronization
      :width: 60.0%

      **Figure 7**: Pull-based synchronization: Device A accesses
      resources for screens A and B only, while device B accesses
      resources for screens B, C and D only

   Consider an app where page tokens are used to fetch items in an
   endless scrolling list for a particular screen. The implementation
   may lazily reach out to the network, persist the data to the local
   data source and then read from the local data source to present
   information back to the user. In the case where there is no network
   connectivity, the repository may request data from the local data
   source alone. This is the pattern used by the `Jetpack Paging Library <#>`__ with
   its
   `RemoteMediator <#>`__
   API.

   .. code:: prettyprint

      class FeedRepository(...) {

          fun feedPagingSource(): PagingSource<FeedItem> { ... }
      }

      class FeedViewModel(
          private val repository: FeedRepository
      ) : ViewModel() {
          private val pager = Pager(
              config = PagingConfig(
                  pageSize = NETWORK_PAGE_SIZE,
                  enablePlaceholders = false
              ),
              remoteMediator = FeedRemoteMediator(...),
              pagingSourceFactory = feedRepository::feedPagingSource
          )

          val feedPagingData = pager.flow
      }

   The advantages and disadvantages of pull-based synchronization are
   summarized in the table below:

   .. list-table::
      :header-rows: 1

      - 

         - Advantages
         - Disadvantages
      - 

         - Relatively easy to implement.
         - Prone to heavy data use. This is because repeated visits to a
            navigation destination triggers unnecessary refetching of
            unchanged information. You can mitigate this through proper
            caching. This can be done in the UI layer with the
            `cachedIn <#(kotlinx.coroutines.flow.Flow).cachedIn>`__
            operator, or in the network layer with a HTTP cache.
      - 

         - Data that is not needed will never be fetched.
         - Does not scale well with relational data since the model
            pulled needs to be self sufficient. If the model being
            synchronized depends on other models to be fetched to
            populate itself, the heavy data use problem mentioned
            earlier will be made even more significant. Furthermore, it
            may cause dependencies between repositories of the parent
            model and repositories of the nested model.

   .. rubric:: Push-based synchronization
      :name: push-based-synchronization

   In push-based synchronization, the local data source tries to mimic a
   replica set of the network data source to the best of its ability. It
   proactively fetches an appropriate amount of data on first start-up
   to set a baseline, after which it relies on notifications from the
   server to alert it when that data is stale.

   .. figure::
      https://developer.android.google.cn/static/images/topic/architecture/data-layer/push-sync.png
      name: image-8
      :alt: Push-based synchronization
      :width: 60.0%

      **Figure 8**: Push-based synchronization: The network notifies the
      app when data changes and the app responds by fetching the changed
      data

   Upon receipt of the stale notification, the app reaches out to the
   network to update only the data that was marked as stale. This work
   is delegated to the ``Repository`` which reaches out to the network
   data source, and persists the data fetched to the local data source.
   Since the repository exposes its data with observable types, readers
   will be notified of any changes.

   .. code:: prettyprint

      class UserDataRepository(...) {

          suspend fun synchronize() {
              val userData = networkDataSource.fetchUserData()
              localDataSource.saveUserData(userData)
          }
      }

   In this approach, the app is far less dependent on the network data
   source and can work without it for extended periods of time. It
   offers both read and write access when offline because it is assumed
   that it has the latest information from the network data source
   locally.

   The advantages and disadvantages of push-based synchronization are
   summarized in the table below:

   .. list-table::
      :header-rows: 1

      - 

         - Advantages
         - Disadvantages
      - 

         - The app can remain offline indefinitely.
         - Versioning data for conflict resolution is non-trivial.
      - 

         - Minimum data use. The app only fetches data that has changed.
         - You need to take into consideration write concerns during
            synchronization.
      - 

         - Works well for relational data. Each repository is only
            responsible for fetching data for the model it supports.
         - The network data source needs to support synchronization.

   .. rubric:: Hybrid synchronization
      :name: hybrid-synchronization

   Some apps use a hybrid approach that is pull or push based depending
   on the data. For example, a social media app may use pull-based
   synchronization to fetch the user's following feed on demand due to
   the high frequency of feed updates. The same app may opt to use
   push-based synchronization for data about the signed-in user
   including their username, profile picture and so on.

   Ultimately, offline-first synchronization choice depends on product
   requirements and available technical infrastructure.

   **Note:**\  Your app's synchronization method depends on the needs of
   your app, and the constraints of the infrastructure that support the
   local and network data sources.
   
   .. rubric:: Conflict resolution
      :name: conflict-resolution

   If the app writes data locally when offline that is misaligned with
   the network data source, a conflict has occurred that you must
   resolve before synchronization can take place.

   Conflict resolution often requires versioning. The app will need to
   do some bookkeeping to keep track of when changes occurred. This
   enables it to pass the metadata to the network data source. The
   network data source then has the responsibility of providing the
   absolute source of truth. There are a wide array of strategies to
   consider for conflict resolution, depending on the needs of the
   application. For mobile apps a common approach is "last write wins".

   .. rubric:: Last write wins
      :name: last-write

   In this approach, devices attach timestamp metadata to the data they
   write to the network. When the network data source receives them, it
   discards any data older than its current state while accepting those
   newer than its current state.

   .. figure::
      https://developer.android.google.cn/static/images/topic/architecture/data-layer/last-write-wins.png
      name: image-9
      :alt: Last write wins conflict resolution
      :width: 90.0%

      **Figure 9**: "Last write wins" The source of truth for data is
      determined by the last entity to write data

   In the above, both devices are offline and are initially in sync with
   the network data source. While offline, they both write data locally
   and keep track of the time they wrote their data. When they both come
   back online and synchronize with the network data source, the network
   resolves the conflict by persisting data from device B because it
   wrote its data later.

   .. rubric:: WorkManager in offline-first apps
      :name: workmanager-offline

   In both read and writes strategies covered above, there were two
   common utilities:

   -  Queues

      -  Reads: Used to **defer** reads until network connectivity is
         available.
      -  Writes: Used to **defer** writes until network connectivity is
         available, and to requeue writes for retries.

   -  Network connectivity monitors

      -  Reads: Used as a signal to drain the read queue when the app is
         connected and for synchronization
      -  Writes: Used as a signal to drain the write queue when the app
         is connected and for synchronization

   Both cases are examples of the `persistent work <#types>`__
   that
   `WorkManager <#>`__
   excels at. For example in the `Now in Android <https://github.com/android/nowinandroid>`__ sample app,
   WorkManager is used as both a read queue and network monitor when
   synchronizing the local data source. On start-up, the app performs
   the following actions:

   #. Enqueue read synchronization work to make sure there is parity
      between the local datasource and the network datasource.
   #. Drain the read synchronization queue and start synchronizing when
      the app is online.
   #. Perform a read from the network datasource using exponential
      backoff.
   #. Persist the results of the read into the local datasource
      resolving any conflicts that may occur.
   #. Expose the data from the local datasource for other layers of the
      app to consume.

   The above is illustrated in the diagram below:

   .. figure:: https://developer.android.google.cn/static/images/topic/architecture/data-layer/nia-sync.png
      name: image-10
      :alt: Data synchronization in the Now in Android app
      :width: 90.0%

      **Figure 10**: Data synchronization in the Now in Android app

   The enqueueing of the synchronization work with
   `WorkManager <#>`__
   follows by specifying it as `unique work <#unique-work>`__
   with the ``KEEP``
   `ExistingWorkPolicy <#>`__:

   .. code:: prettyprint

      class SyncInitializer : Initializer<Sync> {
         override fun create(context: Context): Sync {
             WorkManager.getInstance(context).apply {
                 // Queue sync on app startup and ensure only one
                 // sync worker runs at any time
                 enqueueUniqueWork(
                     SyncWorkName,
                     ExistingWorkPolicy.KEEP,
                     SyncWorker.startUpSyncWork()
                 )
             }
             return Sync
         }
      }

   **Note:**\  The read queue in "Now in Android" is simple enough to be
   represented with just the
   `enqueueUniqueWork <#enqueueUniqueWork>`__
   API. For firmer guarantees about the order in which the queue is
   drained, a more robust queue implementation will need to be
   implemented with a data persistence API like Room or Datastore. A
   ``Worker`` can then be set up to sequentially drain this queue.
   Where ``SyncWorker.startupSyncWork()`` is defined as the following:

   .. code:: prettyprint

      /**
       Create a WorkRequest to call the SyncWorker using a DelegatingWorker.
       This allows for dependency injection into the SyncWorker in a different
       module than the app module without having to create a custom WorkManager
       configuration.
      */
      fun startUpSyncWork() = OneTimeWorkRequestBuilder<DelegatingWorker>()
          // Run sync as expedited work if the app is able to.
          // If not, it runs as regular work.
         .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)
         .setConstraints(SyncConstraints)
          // Delegate to the SyncWorker.
         .setInputData(SyncWorker::class.delegatedData())
         .build()

      val SyncConstraints
         get() = Constraints.Builder()
             .setRequiredNetworkType(NetworkType.CONNECTED)
             .build()

   Specifically, the
   `Constraints <#>`__ defined by
   ``SyncConstraints`` require that the
   `NetworkType <#>`__ be
   ``NetworkType.CONNECTED``. That is, it waits until the network is
   available before it runs.

   Once the network is available, the
   `Worker <#>`__ drains the unique work
   queue specified by the ``SyncWorkName`` by delegating to the
   appropriate ``Repository`` instances. If the synchronization fails,
   the ``doWork()`` method returns with ``Result.retry()``. WorkManager
   will automatically retry synchronization with exponential backoff.
   Otherwise, it returns ``Result.success()`` completing
   synchronization.

   .. code:: prettyprint

      class SyncWorker(...) : CoroutineWorker(appContext, workerParams), Synchronizer {

          override suspend fun doWork(): Result = withContext(ioDispatcher) {
              // First sync the repositories in parallel
              val syncedSuccessfully = awaitAll(
                  async { topicRepository.sync() },
                  async { authorsRepository.sync() },
                  async { newsRepository.sync() },
              ).all { it }

              if (syncedSuccessfully) Result.success()
              else Result.retry()
          }
      }

   .. rubric:: Samples
      :name: samples

   The following Google samples demonstrate offline-first apps. Go
   explore them to see this guidance in practice:

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `UI State production <#>`__
   -  `UI layer <#>`__
   -  `Data layer <#>`__

Last updated 2023-07-12 UTC.


/Recommendations for Android architecture
=========================================

.. container:: devsite-article-body clearfix

   This page presents several `Architecture <#>`__
   best practices and recommendations. Adopt them to improve your app‚Äôs
   quality, robustness, and scalability. They also make it easier to
   maintain and test your app.

   **Note:**\  You should treat the recommendations in the document as
   recommendations and not strict requirements. Adapt them to your app
   as needed.
   The best practices below are grouped by topic. Each has a priority
   that reflects how strongly the team recommends it. The list of
   priorities is as follows:

   -  **Strongly recommended:** You should implement this practice
      unless it clashes fundamentally with your approach.
   -  **Recommended:** This practice is likely to improve your app.
   -  **Optional:** This practice can improve your app in certain
      circumstances.

   **Note:**\  In order to understand these recommendations, you should
   be familiar with the `Architecture guidance <#>`__.

   .. rubric:: Layered architecture
      :name: layered-architecture

   Our recommended `layered architecture <#recommended-app-arch>`__
   favors separation of concerns. It drives UI from data models,
   complies with the single source of truth principle, and follows
   `unidirectional data flow <#unidirectional-data-flow>`__
   principles. Here are some best practices for layered architecture:

   .. list-table::
      :widths: 36 36
      :header-rows: 1

      - 

         - Recommendation
         - Description
      - 

         - Use a clearly defined `data layer <#>`__.

               **Strongly recommended**

         - The `data layer <#>`__ exposes
            application data to the rest of the app and contains the
            vast majority of business logic of your app.

            -  You should create
               `repositories <#architecture>`__
               even if they just contain a single data source.
            -  In small apps, you can choose to place data layer types
               in a ``data`` package or module.
      - 

         - Use a clearly defined `UI layer <#>`__.

               **Strongly recommended**

         - The `UI layer <#>`__ displays the
            application data on the screen and serves as the primary
            point of user interaction.

            -  In small apps, you can choose to place data layer types
               in a ``ui`` package or module.

            `More UI layer best practices here <#ui-layer>`__.
      - 

         - The `data layer <#>`__ should expose
            application data using a repository.

               **Strongly recommended**

         - Components in the UI layer such as composables, activities,
            or ViewModels shouldn't interact directly with a data
            source. Examples of data sources are:

            -  Databases, DataStore, SharedPreferences, Firebase APIs.
            -  GPS location providers.
            -  Bluetooth data providers.
            -  Network connectivity status provider.
      - 

         - Use `coroutines and flows <#>`__.

               **Strongly recommended**

         - Use `coroutines and flows <#>`__
            to communicate between layers.
            `More coroutines best practices here <#>`__.
      - 

         - Use a `domain layer <#>`__.
         
               **Recommended in big apps**

         - Use a `domain layer <#>`__, use
            cases, if you need to reuse business logic that interacts
            with the data layer across multiple ViewModels, or you want
            to simplify the business logic complexity of a particular
            ViewModel

   .. rubric:: UI layer
      :name: ui-layer

   The role of the `UI layer <#>`__ is to
   display the application data on the screen and serve as the primary
   point of user interaction. Here are some best practices for the UI
   layer:

   .. list-table::
      :widths: 36 36
      :header-rows: 1

      - 

         - Recommendation
         - Description
      - 

         - Follow `Unidirectional Data Flow (UDF) <#udf>`__.

               **Strongly recommended**

         - Follow `Unidirectional Data Flow (UDF) <#udf>`__ principles,
            where ViewModels expose UI state using the observer pattern
            and receive actions from the UI through method calls.
      - 

         - Use `AAC ViewModels <#>`__ if
            their benefits apply to your app.

               **Strongly recommended**

         - Use `AAC ViewModels <#>`__ to
            `handle business logic <#logic-types>`__, and fetch
            application data to expose UI state to the UI (Compose or
            Android Views).
            See more `ViewModel best practices here. <#viewmodel>`__

            See the `benefits of ViewModels here. <#viewmodel-as>`__
      - 

         - Use lifecycle-aware UI state collection.

               **Strongly recommended**

         - Collect UI state from the UI using the appropriate
            lifecycle-aware coroutine builder:
            `repeatOnLifecycle <#(androidx.lifecycle.Lifecycle).repeatOnLifecycle>`__
            in the View system and
            `collectAsStateWithLifecycle <#(kotlinx.coroutines.flow.StateFlow).collectAsStateWithLifecycle>`__
            in Jetpack Compose.
            Read more about
            `repeatOnLifecycle <https://medium.com/androiddevelopers/a-safer-way-to-collect-flows-from-android-uis-23080b1f8bda>`__.

            Read more about about
            `collectAsStateWithLifecycle <https://medium.com/androiddevelopers/consuming-flows-safely-in-jetpack-compose-cde014d0d5a3>`__.
      - 

         - Do not send events from the ViewModel to the UI.

               **Strongly recommended**

         - Process the event immediately in the ViewModel and cause a
            state update with the result of handling the event. More
            about `UI events here <#handle-viewmodel-events>`__.
      - 

         - Use a single-activity application.

               **Recommended**

         - Use `Navigation Fragments <#>`__ or
            `Navigation Compose <#>`__ to
            navigate between screens and deep link to your app if your
            app has more than one screen.
      - 

         - Use `Jetpack Compose <#>`__.

               **Recommended**

         - Use `Jetpack Compose <#>`__ to build new apps
            for phones, tablets and foldables and Wear OS.

   The following snippet outlines how to collect the UI state in a
   lifecycle-aware manner:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: views

         .. code:: prettyprint

            class MyFragment : Fragment() {

                private val viewModel: MyViewModel by viewModel()

                override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                    super.onViewCreated(view, savedInstanceState)

                    viewLifecycleOwner.lifecycleScope.launch {
                        viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                            viewModel.uiState.collect {
                                // Process item
                            }
                        }
                    }
                }
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose

         .. code:: prettyprint

            @Composable
            fun MyScreen(
                viewModel: MyViewModel = viewModel()
            ) {
                val uiState by viewModel.uiState.collectAsStateWithLifecycle()
            }

   .. rubric:: ViewModel
      :name: viewmodel

   `ViewModels <#business-logic>`__
   are responsible for providing the UI state and access to the data
   layer. Here are some best practices for ViewModels:

   .. list-table::
      :widths: 36 36
      :header-rows: 1

      - 

         - Recommendation
         - Description
      - 

         - ViewModels should be agnostic of the Android lifecycle.

               **Strongly recommended**

         - ViewModels shouldn't hold a reference to any
            Lifecycle-related type. Don't pass
            ``Activity, Fragment, Context`` or ``Resources`` as a
            dependency. If something needs a ``Context`` in the
            ViewModel, you should strongly evaluate if that is in the
            right layer.
      - 

         - Use `coroutines and flows <#>`__.

               **Strongly recommended**

         - The ViewModel interacts with the data or domain layers using:

            -  Kotlin flows for receiving application data,
            -  ``suspend`` functions to perform actions using
               `viewModelScope <#viewmodelscope>`__.
      - 

         - Use ViewModels at screen level.

               **Strongly recommended**

         - Do not use ViewModels in reusable pieces of UI. You should
            use ViewModels in:

            -  Screen-level composables,
            -  Activities/Fragments in Views,
            -  Destinations or graphs when using `Jetpack Navigation <#>`__.
      - 

         - Use `plain state holder classes <#ui-logic>`__
            in reusable UI components.

               **Strongly recommended**

         - Use `plain state holder classes <#ui-logic>`__
            for handling complexity in reusable UI components. By doing
            this, the state can be hoisted and controlled externally.
      - 

         - Do not use
            `AndroidViewModel <#>`__.

            .. container::

               **Recommended**
         - Use the
            `ViewModel <#>`__
            class, not
            `AndroidViewModel <#>`__.
            The ``Application`` class shouldn't be used in the
            ViewModel. Instead, move the dependency to the UI or the
            data layer.
      - 

         - Expose a UI state.

            .. container::

               **Recommended**
         - ViewModels should expose data to the UI through a single
            property called ``uiState``. If the UI shows multiple,
            unrelated pieces of data, the VM can `expose multiple UI state properties <#additional-considerations>`__.

            -  You should make ``uiState`` a ``StateFlow``.
            -  You should create the ``uiState`` using the
               `stateIn <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html>`__
               operator with the
               `WhileSubscribed(5000) <https://medium.com/androiddevelopers/migrating-from-livedata-to-kotlins-flow-379292f419fb>`__
               policy
               `(example) <https://github.com/android/compose-samples/blob/main/JetNews/app/src/main/java/com/example/jetnews/ui/interests/InterestsViewModel.kt#L56>`__
               if the data comes as a stream of data from other layers
               of the hierarchy.
            -  For simpler cases with no streams of data coming from the
               data layer, it's acceptable to use a ``MutableStateFlow``
               exposed as an immutable ``StateFlow``
               `(example) <https://github.com/android/compose-samples/blob/main/Jetcaster/app/src/main/java/com/example/jetcaster/ui/home/category/PodcastCategoryViewModel.kt#L37>`__.
            -  You can choose to have the ``${Screen}UiState`` as a data
               class that can contain data, errors and loading signals.
               This class could also be a sealed class if the different
               states are exclusive.

   The following snippet outlines how to expose UI state from a
   ViewModel:

   .. code:: prettyprint

      @HiltViewModel
      class BookmarksViewModel @Inject constructor(
          newsRepository: NewsRepository
      ) : ViewModel() {

          val feedState: StateFlow<NewsFeedUiState> =
              newsRepository
                  .getNewsResourcesStream()
                  .mapToFeedState(savedNewsResourcesState)
                  .stateIn(
                      scope = viewModelScope,
                      started = SharingStarted.WhileSubscribed(5_000),
                      initialValue = NewsFeedUiState.Loading
                  )

          // ...
      }

   .. rubric:: Lifecycle
      :name: lifecycle

   The following are some best practices for working with the `Android lifecycle <#>`__:

   .. list-table::
      :widths: 36 36
      :header-rows: 1

      - 

         - Recommendation
         - Description
      - 

         - Do not override lifecycle methods in Activities or Fragments.

               **Strongly recommended**

         - Do not override lifecycle methods such as ``onResume`` in
            Activities or Fragments. Use
            `LifecycleObserver <#>`__
            instead. If the app needs to perform work when the lifecycle
            reaches a certain ``Lifecycle.State``, use the
            `repeatOnLifecycle <#(androidx.lifecycle.Lifecycle).repeatOnLifecycle>`__
            API.

   The following snippet outlines how to perform operations given a
   certain Lifecycle state:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: views_1

         .. code:: prettyprint

            class MyFragment: Fragment() {
                override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                    super.onViewCreated(view, savedInstanceState)

                    viewLifecycleOwner.lifecycle.addObserver(object : DefaultLifecycleObserver {
                        override fun onResume(owner: LifecycleOwner) {
                            // ...
                        }
                        override fun onPause(owner: LifecycleOwner) {
                            // ...
                        }
                    }
                }
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose_1

         .. code:: prettyprint

            @Composable
            fun MyApp() {

                val lifecycleOwner = LocalLifecycleOwner.current
                DisposableEffect(lifecycleOwner, ...) {
                    val lifecycleObserver = object : DefaultLifecycleObserver {
                        override fun onStop(owner: LifecycleOwner) {
                            // ...
                        }
                    }

                    lifecycleOwner.lifecycle.addObserver(lifecycleObserver)
                    onDispose {
                        lifecycleOwner.lifecycle.removeObserver(lifecycleObserver)
                    }
                }
            }

   .. rubric:: Handle dependencies
      :name: handle-dependencies

   There are several best practices you should observe when managing
   dependencies between components:

   .. list-table::
      :widths: 36 36
      :header-rows: 1

      - 

         - Recommendation
         - Description
      - 

         - Use `dependency injection <#>`__.

               **Strongly recommended**

         - Use `dependency injection <#>`__
            best practices, mainly `constructor injection <#what-is-di>`__
            when possible.
      - 

         - Scope to a component when necessary.

               **Strongly recommended**

         - Scope to a `dependency container <#dependencies-container>`__
            when the type contains mutable data that needs to be shared
            or the type is expensive to initialize and is widely used in
            the app.
      - 

         - Use `Hilt <#>`__.

            .. container::

               **Recommended**
         - Use `Hilt <#>`__ or
            `manual dependency injection <#>`__ in
            simple apps. Use
            `Hilt <#>`__ if
            your project is complex enough. For example, if you have:

            -  Multiple screens with ViewModels‚Äîintegration
            -  WorkManager usage‚Äîintegration
            -  Advance usage of Navigation, such as ViewModels scoped to
               the nav graph‚Äîintegration.

   .. rubric:: Testing
      :name: testing

   The following are some best practices for
   `testing <#>`__:

   .. list-table::
      :widths: 36 36
      :header-rows: 1

      - 

         - Recommendation
         - Description
      - 

         - `Know what to test <https://developer.android.google.cn/training/testing/fundamentals/what-to-test>`__.

               **Strongly recommended**

         - Unless the project is roughly as simple as a hello world app,
            you should test it, at minimum with:

            -  Unit test ViewModels, including Flows.
            -  Unit test data layer entities. That is, repositories and
               data sources.
            -  UI navigation tests that are useful as regression tests
               in CI.
      - 

         - Prefer fakes to mocks.

               **Strongly recommended**

         - Read more in the `Use test doubles in Android documentation <#>`__.
      - 

         - Test StateFlows.

               **Strongly recommended**

         - When testing ``StateFlow``:

            -  `Assert on the ``value``
               property </kotlin/flow/test#stateflows>`__ whenever
               possible
            -  You should `create a ``collectJob </kotlin/flow/test#statein>`__ if using
               ``WhileSubscribed``

   For more information, check the 
   `What to test in Android DAC guide <#>`__.

   .. rubric:: Models
      :name: models

   You should observe these best practices when developing models in
   your apps:

   .. list-table::
      :widths: 36 36
      :header-rows: 1

      - 

         - Recommendation
         - Description
      - 

         - Create a model per layer in complex apps.

            .. container::

               **Recommended**
         - In complex apps, create new models in different layers or
            components when it makes sense. Consider the following
            examples:

            -  A remote data source can map the model that it receives
               through the network to a simpler class with just the data
               the app needs
            -  Repositories can map DAO models to simpler data classes
               with just the information the UI layer needs.
            -  ViewModel can include data layer models in ``UiState``
               classes.

   .. rubric:: Naming conventions
      :name: naming-conventions

   When naming your codebase, you should be aware of the following best
   practices:

   .. list-table::
      :widths: 36 36
      :header-rows: 1

      - 

         - Recommendation
         - Description
      - 

         - Naming methods.

               **Optional**

         - Methods should be a verb phrase. For example,
            ``makePayment()``.
      - 

         - Naming properties.

               **Optional**

         - Properties should be a noun phrase. For example,
            ``inProgressTopicSelection``.
      - 

         - Naming streams of data.

               **Optional**

         - When a class exposes a Flow stream, LiveData, or any other
            stream, the naming convention is ``get{model}Stream()``. For
            example, ``getAuthorStream(): Flow<Author>`` If the function
            returns a list of models the model name should be in the
            plural: ``getAuthorsStream(): Flow<List<Author>>``
      - 

         - Naming interfaces implementations.

               **Optional**

         - Names for the implementations of interfaces should be
            meaningful. Have ``Default`` as the prefix if a better name
            cannot be found. For example, for a ``NewsRepository``
            interface, you could have an ``OfflineFirstNewsRepository``,
            or ``InMemoryNewsRepository``. If you can find no good name,
            then use ``DefaultNewsRepository``. Fake implementations
            should be prefixed with ``Fake``, as in
            ``FakeAuthorsRepository``.

Last updated 2023-07-12 UTC.


/Overview: Guide to Android app modularization
==============================================

.. https://developer.android.google.cn/topic/modularization

.. container:: devsite-article-body clearfix

   A project with multiple Gradle modules is known as a multi-module
   project. This guide encompasses best practices and recommended
   patterns for developing multi-module Android apps.

   **Note:**\  This page assumes a basic familiarity with the
   `recommended app architecture <#>`__.

   .. rubric:: The growing codebase problem
      :name: growing-codebase

   In an ever-growing codebase, scalability, readability, and overall
   code quality often decrease through time. This comes as a result of
   the codebase increasing in size without its maintainers taking active
   measures to enforce a structure that is easily maintainable.
   Modularization is a means of structuring your codebase in a way that
   improves maintainability and helps avoid these problems.

   .. rubric:: What is modularization?
      :name: what-is-modularization

   Modularization is a practice of organizing a codebase into loosely
   coupled and self contained parts. Each part is a module. Each module
   is independent and serves a clear purpose. By dividing a problem into
   smaller and easier to solve subproblems, you reduce the complexity of
   designing and maintaining a large system.

   .. figure::
      https://developer.android.google.cn/static/topic/modularization/images/1_sample_dep_graph.png
      name: sample_dep_graph
      :width: 100.0%

      **Figure 1**: Dependency graph of a sample multi-module codebase

   .. rubric:: Benefits of modularization
      :name: benefits

   The benefits of modularization are many, though they each center upon
   improving the maintainability and overall quality of a codebase. The
   table below summarizes the key benefits.

   .. list-table::
      :header-rows: 1

      - 

         - Benefit
         - Summary
      - 

         - Reusability
         - Modularization enables opportunities for code sharing and
            building multiple apps from the same foundation. Modules are
            effectively building blocks. Apps should be a sum of their
            features where the features are organized as separate
            modules. The functionality that a certain module provides
            may or may not be enabled in a particular app. For example,
            a ``:feature:news`` can be a part of the full version flavor
            and wear app but not part of the demo version flavor.
      - 

         - Strict visibility control
         - Modules enable you to easily control what you expose to other
            parts of your codebase. You can mark everything but your
            public interface as ``internal`` or ``private`` to prevent
            it from being used outside the module.
      - 

         - Customizable delivery
         - `Play Feature Delivery <#>`__
            uses the advanced capabilities of app bundles, allowing you
            to deliver certain features of your app conditionally or on
            demand.

   The benefits above are only achievable with a modularized codebase.
   The following benefits might be achieved with other techniques but
   modularization can help you enforce them even more.

   .. list-table::
      :header-rows: 1

      - 

         - Benefit
         - Summary
      - 

         - Scalability
         - In a tightly coupled codebase a single change can trigger a
            cascade of alterations in seemingly unrelated parts of code.
            A properly modularized project will embrace the `separation of concerns <https://en.wikipedia.org/wiki/Separation_of_concerns>`__
            principle and therefore limit the coupling. This empowers
            the contributors through greater autonomy.
      - 

         - Ownership
         - In addition to enabling autonomy, modules can also be used to
            enforce accountability. A module can have a dedicated owner
            who is responsible for maintaining the code, fixing bugs,
            adding tests, and reviewing changes.
      - 

         - Encapsulation
         - Encapsulation means that each part of your code should have
            the smallest possible amount of knowledge about other parts.
            Isolated code is easier to read and understand.
      - 

         - Testability
         - Testability characterizes how easy it is to
            `test <#>`__ your code. A testable code is
            one where components can be easily tested in isolation.
      - 

         - Build time
         - Some Gradle functionalities such as incremental build, build
            cache or parallel build, can leverage modularity to `improve build performance <#>`__.

   .. rubric:: Common pitfalls
      :name: common-pitfalls

   The granularity of your codebase is the extent to which it is
   composed of modules. A more granular codebase has more, smaller
   modules. When designing a modularized codebase, you should decide on
   a level of granularity. To do so, take into account the size of your
   codebase and its relative complexity. Going too fine-grained will
   make the overhead a burden, and going too coarse will lessen the
   benefits of modularization.

   Some common pitfalls are as follows:

   -  **Too fine-grained**: Every module brings a certain amount of
      overhead in the form of increased build complexity and
      `boilerplate code <https://en.wikipedia.org/wiki/Boilerplate_code>`__. A
      complex build configuration makes it difficult to 
      `keep configurations consistent <#consistent-configuration>`__
      across modules. Too much boilerplate code results in a cumbersome
      codebase that is difficult to maintain. If overhead counteracts
      scalability improvements, you should consider consolidating some
      modules.
   -  **Too coarse-grained**: Conversely, if your modules are growing
      too large you might end up with yet another monolith and miss the
      benefits that modularity has to offer. For example, in a small
      project it‚Äôs ok to put the data layer inside a single module. But
      as it grows, it might be necessary to separate repositories and
      data sources into standalone modules.
   -  **Too complex**: It doesn't always make sense to modularize your
      project. A dominating factor is the size of the codebase. If you
      don't expect your project to grow beyond a certain threshold, the
      scalability and build time gains won't apply.

   .. rubric:: Is modularization the right technique for me?
      :name: is-modularization-for-me

   If you need the benefits of reusability, strict visibility control or
   to use the `Play Feature Delivery <#>`__, then modularization
   is a necessity for you. If you don't, but still want to benefit from
   improved scalability, ownership, encapsulation, or build times, then
   modularization is something worth considering.

   .. rubric:: Samples
      :name: samples

   -  `Now in Android <https://github.com/android/nowinandroid>`__ -
      fully functional Android app featuring modularization.
   -  `Multi module architecture sample <https://github.com/android/architecture-samples/tree/multimodule>`__

Last updated 2023-07-20 UTC.


/Common modularization patterns
===============================

.. container:: devsite-article-body clearfix

   There is no single `modularization <#>`__
   strategy that fits all projects. Due to the flexible nature of Gradle
   there are few constraints as to how you can organize a project. This
   page gives an overview of some general rules and common patterns that
   you can employ when developing multi module Android apps.

   **Note:**\  The recommendations and best practices present in this
   page can be applied to a broad spectrum of apps to allow them to
   scale, improve quality and robustness, and make them easier to test.
   However, you should treat them as guidelines and adapt them to your
   requirements as needed.

   .. container:: video-wrapper-full-width

   .. rubric:: High cohesion and low coupling principle
      :name: cohesion-coupling

   One way of characterizing a modular codebase would be to use the
   **coupling** and **cohesion** properties. Coupling measures the
   degree to which modules depend on each other. Cohesion, in this
   context, measures how the elements of a single module are
   functionally related. As a general rule, you should strive for low
   coupling and high cohesion:

   -  **Low coupling** means that modules should be as independent as
      possible from one another, so that changes to one module have zero
      or minimal impact on other modules. **Modules shouldn't have
      knowledge of the inner workings of other modules**.
   -  **High cohesion** means that modules should comprise a collection
      of code that acts as a system. They should have clearly defined
      responsibilities and stay within boundaries of certain domain
      knowledge. Consider a sample ebook application. It might be
      inappropriate to mix book and payment related code together in the
      same module as they are two different functional domains.

   **Tip:**\  If two modules heavily rely on knowledge of each other, it
   may be a good sign that they should actually act as one system.
   Conversely, if two parts of a module don‚Äôt interact with each other
   often, they should probably be separate modules.

   .. rubric:: Types of modules
      :name: types-of-modules

   The way you organize your modules mainly depends on your app
   architecture. Below are some common types of modules you could
   introduce in your app while following our 
   `recommended app architecture <#>`__.

   **Note:**\  This section assumes that you are familiar with the
   concepts outlined in our 
   `guide to app architecture <#>`__.

   .. rubric:: Data modules
      :name: data-modules

   A data module usually contains a repository, data sources and model
   classes. The three primary responsibilities of a data module are:

   #. **Encapsulate all data and business logic of a certain domain**:
      Each data module should be responsible for handling data that
      represents a certain domain. It can handle many types of data as
      long as they are related.
   #. **Expose the repository as an external API**: The public API of a
      data module should be a repository as they are responsible for
      exposing the data to the rest of the app.
   #. **Hide all implementation details and data sources from the
      outside**: Data sources should only be accessible by repositories
      from the same module. They remain hidden to the outside. You can
      enforce this by using Kotlin‚Äôs ``private`` or ``internal``
      visibility keyword.

   .. figure:: https://developer.android.google.cn/static/topic/modularization/images/2_data_modules.png
      name: data_modules
      :width: 100.0%

      **Figure 1**. Sample data modules and their content.

   .. rubric:: Feature modules
      :name: feature-modules

   A feature is an isolated part of an app's functionality that usually
   corresponds to a screen or series of closely related screens, like a
   sign up or checkout flow. If your app has a bottom bar navigation,
   it‚Äôs likely that each destination is a feature.

   **Key Term:**\  "Feature module" is a term that is also used in the
   `Play Feature Delivery <#>`__
   describing a module that can be delivered conditionally or downloaded
   on-demand. However, in the context of this guide a feature module is
   a module that encapsulates a distinct part of your application‚Äôs
   functionality.
   .. figure:: https://developer.android.google.cn/static/topic/modularization/images/2_bottom_bar.png
      name: bottom_bar
      :width: 50.0%

      **Figure 2**. Each tab of this application can be defined as a
      feature.

   Features are associated with screens or destinations in your app.
   Therefore, they're likely to have an associated UI and ``ViewModel``
   to `handle their logic and state <#>`__. A single
   feature doesn't have to be limited to a single view or navigation
   destination. **Feature modules depend on data modules.**

   .. figure:: https://developer.android.google.cn/static/topic/modularization/images/2_feature_modules.png
      name: feature_modules
      :width: 100.0%

      **Figure 3**. Sample feature modules and their content.

   .. rubric:: App modules
      :name: app-modules

   App modules are an entry point to the application. They depend on
   feature modules and usually provide root navigation. A single app
   module can be compiled to a number of different binaries thanks to
   `build variants <#>`__.

   .. figure::
      https://developer.android.google.cn/static/topic/modularization/images/2_demo_full_dep_graph.png
      name: demo_full_dep_graph
      :width: 100.0%

      **Figure 4**. \*Demo\* and \*Full\* product flavor modules
      dependency graph.

   If your app targets multiple device types, such as auto, wear or TV,
   define an app module per each. This helps separate platform specific
   dependencies.

   .. figure:: https://developer.android.google.cn/static/topic/modularization/images/2_wear_dep_graph.png
      name: wear_dep_graph
      :width: 70.0%

      **Figure 5**. Wear app dependency graph.

   .. rubric:: Common modules
      :name: common-modules

   Common modules, also known as core modules, contain code that other
   modules frequently use. They reduce redundancy and don't represent
   any specific layer in an app's architecture. The following are
   examples of common modules:

   -  **UI module**: If you use custom UI elements or elaborate branding
      in your app, you should consider encapsulating your widget
      collection into a module for all the features to reuse. This could
      help make your UI consistent across different features. For
      example, if your theming is centralized, you can avoid a painful
      refactor when a rebrand happens.
   -  **Analytics module**: Tracking is often dictated by business
      requirements with little consideration to the software
      architecture. Analytics trackers are often used in many unrelated
      components. If that's the case for you, it might be a good idea to
      have a dedicated analytics module.
   -  **Network module**: When many modules require a network
      connection, you might consider having a module dedicated to
      providing a http client. It is especially useful when your client
      requires custom configuration.
   -  **Utility module**: Utilities, also known as helpers, are usually
      small pieces of code that are reused across the application.
      Examples of utilities include testing helpers, a currency
      formatting function, email validator or a custom operator.

   .. rubric:: Test modules
      :name: test-modules

   `Test modules <#>`__ are Android modules
   that are used for testing purposes only. The modules contain test
   code, test resources, and test dependencies that are only required
   for running tests and are not needed during the application's
   runtime. Test modules are created to separate test-specific code from
   the main application, making the module code easier to manage and
   maintain.

   .. rubric:: Use cases for test modules
      :name: use_cases_for_test_modules

   The following examples showcase situations where implementing test
   modules can be particularly beneficial:

   -  **Shared test code**: If you have multiple modules in your project
      and some of the test code is applicable to more than one module,
      you can create a test module to share the code. This can help
      reduce duplication and make your test code easier to maintain.
      Shared test code can include utility classes or functions, such as
      custom assertions or matchers, as well as test data, such as
      simulated JSON responses.

   -  **Cleaner Build Configurations**: Test modules allow you to have
      cleaner build configurations, as they can have their own
      ``build.gradle`` file. You don't have to clutter your app module's
      ``build.gradle`` file with configurations that are only relevant
      for tests.

   -  **Integration Tests**: Test modules can be used to store
      integration tests that are used to test interactions between
      different parts of your app, including user interface, business
      logic, network requests, and database queries.

   -  **Large-scale applications**: Test modules are particularly useful
      for large-scale applications with complex codebases and multiple
      modules. In such cases, test modules can help improve code
      organization and maintainability.

   .. figure:: https://developer.android.google.cn/static/topic/modularization/images/2_test_modules.png
      name: test_modules
      :width: 100.0%

      **Figure 6**. Test modules can be used to isolate modules that
      would otherwise be dependent on each other.

   .. rubric:: Module to module communication
      :name: communication

   Modules rarely exist in total separation and often rely on other
   modules and communicate with them. It‚Äôs important to keep the
   coupling low even when modules work together and exchange information
   frequently. Sometimes direct communication between two modules is
   either not desirable as in the case of architecture constraints. It
   may also be impossible, such as with cyclic dependencies.

   .. figure:: https://developer.android.google.cn/static/topic/modularization/images/2_mediator.png
      name: mediator
      :width: 80.0%

      **Figure 7**. A direct, two-way communication between modules is
      impossible due to cyclic dependencies. A mediating module is
      necessary to coordinate data flow between two other independent
      modules.

   To overcome this problem you can have a third module
   `mediating <https://en.wikipedia.org/wiki/Mediator_pattern>`__
   between two other modules. The mediator module can listen for
   messages from both of the modules and forward them as needed. In our
   sample app, the checkout screen needs to know which book to purchase
   even though the event originated in a separate screen that is part of
   a different feature. In this case, the mediator is the module that
   owns the navigation graph (usually an app module). In the example, we
   use navigation to pass the data from the home feature to the checkout
   feature using the
   `Navigation <#>`__ component.

   .. code:: prettyprint

      navController.navigate("checkout/$bookId")

   The checkout destination receives a book id as an argument which it
   uses to fetch information about the book. You can use the `saved state handle <#>`__
   to retrieve navigation arguments inside a destination feature‚Äôs
   ``ViewModel``.

   .. code:: prettyprint

      class CheckoutViewModel(savedStateHandle: SavedStateHandle, ‚Ä¶) : ViewModel() {

         val uiState: StateFlow<CheckoutUiState> =
            savedStateHandle.getStateFlow<String>("bookId", "").map { bookId ->
                // produce UI state calling bookRepository.getBook(bookId)
            }
            ‚Ä¶
      }

   You shouldn't pass objects as navigation arguments. Instead, use
   simple ids that features can use to access and load desired resources
   from the data layer. This way, you keep the coupling low and don't
   violate the single source of truth principle.

   In the example below, both feature modules depend on the same data
   module. This makes it possible to minimize the amount of data that
   the mediator module needs to forward and keeps the coupling between
   the modules low. Instead of passing objects, modules should exchange
   primitive IDs and load the resources from a shared data module.

   .. figure:: https://developer.android.google.cn/static/topic/modularization/images/2_shared_data.png
      name: shared_data
      :width: 55.0%

      **Figure 8**. Two feature modules relying on a shared data module.

   .. rubric:: Dependency inversion
      :name: dependency_inversion

   Dependency inversion is when you organize your code such that the
   abstraction is separate from a concrete implementation.

   -  **Abstraction**: A contract that defines how components or modules
      in your application interact with each other. Abstraction modules
      define the API of your system and contain interfaces and models.
   -  **Concrete implementation**: Modules that depend on the
      abstraction module and implement the behavior of an abstraction.

   Modules that rely on the behavior defined in the abstraction module
   should only depend on the abstraction itself, rather than the
   specific implementations.

   .. figure:: https://developer.android.google.cn/static/topic/modularization/images/2_di_concept.png
      name: dependency_inversion_concept
      :width: 60.0%

      **Figure 9**. Instead of high level modules depending on low level
      modules directly, high level and implementation modules depend on
      the abstraction module.

   .. rubric:: Example
      :name: example

   Imagine a feature module that needs a database to work. The feature
   module isn't concerned with how the database is implemented, be it a
   local Room database or a remote Firestore instance. It only needs to
   store and read the application data.

   To achieve this, the feature module depends on the abstraction module
   rather than on a specific database implementation. This abstraction
   defines the app's database API. In other words, it sets the rules for
   how to interact with the database. This allows the feature module to
   use any database without needing to know its underlying
   implementation details.

   The concrete implementation module provides the actual implementation
   of the APIs defined in the abstraction module. In order to do that,
   the implementation module also depends on the abstraction module.

   .. rubric:: Dependency injection
      :name: dependency_injection

   By now you might be wondering how the feature module is connected
   with the implementation module. The answer is `Dependency Injection <#>`__. The feature module
   doesn't directly create the required database instance. Instead, it
   specifies what dependencies it needs. These dependencies are then
   supplied externally, usually in the `app module <#app-modules>`__.

   .. code:: prettyprint

      releaseImplementation(project(":database:impl:firestore"))

      debugImplementation(project(":database:impl:room"))

      androidTestImplementation(project(":database:impl:mock"))

   **Note:**\  You can define varying dependencies for distinct build
   types. For example, the release build could use the Firestore
   implementation, the debug build could rely on a local Room database,
   and instrumented tests could employ a mock implementation.

   .. rubric:: Benefits
      :name: benefits

   The benefits of separating your APIs and their implementations are as
   follows:

   -  **Interchangeability**: With a clear separation of API and
      implementation modules, you can develop multiple implementations
      for the same API, and switch between them without changing the
      code that uses the API. This could be particularly beneficial in
      scenarios where you want to provide different capabilities or
      behavior in different contexts. For example, a mock implementation
      for testing versus a real implementation for production.
   -  **Decoupling**: The separation means that modules using
      abstractions don't depend on any specific technology. If you
      choose to change your database from Room to Firestore later on, it
      would be easier because the changes would only happen in the
      specific module doing the job (implementation module) and wouldn't
      affect other modules using your database's API.
   -  **Testability**: Separating APIs from their implementations can
      greatly facilitate testing. You can write test cases against the
      API contracts. You can also use different implementations to test
      various scenarios and edge cases, including mock implementations.
   -  **Improved build performance**: When you separate an API and its
      implementation into different modules, changes in the
      implementation module don't force the build system to recompile
      the modules depending on the API module. This leads to faster
      build times and increased productivity, particularly in large
      projects where build times can be significant.

   .. rubric:: When to separate
      :name: when_to_separate

   It is beneficial to separate your APIs from their implementations in
   the following cases:

   -  **Diverse capabilities**: If you can implement parts of your
      system in multiple ways, a clear API allows interchangeability of
      different implementations. For example, you may have a rendering
      system that uses OpenGL or Vulkan, or a billing system that works
      with Play or your in-house billing API.
   -  **Multiple applications**: If you're developing multiple
      applications with shared capabilities for different platforms, you
      can define common APIs and develop specific implementations per
      platform.
   -  **Independent teams**: The separation allows different developers
      or teams to work on different parts of the codebase
      simultaneously. Developers should focus on understanding the API
      contracts and using them correctly. They don't need to worry about
      the implementation details of other modules.
   -  **Large codebase**: When the codebase is large or complex,
      separating the API from the implementation makes the code more
      manageable. It lets you break the codebase down into more
      granular, understandable, and maintainable units.

   .. rubric:: How to implement?
      :name: how_to_implement

   To implement dependency inversion, follow these steps:

   #. **Create an abstraction module**: This module should contain APIs
      (interfaces and models) that defines the behavior of your feature.
   #. **Create implementation modules**: Implementation modules should
      rely on the API module and implement the behavior of an
      abstraction.

      .. figure:: https://developer.android.google.cn/static/topic/modularization/images/2_api_impl.png
         name: dependency_inversion_impl_api
         :alt: Instead of high level modules depending on low level
         modules directly, high level and implementation modules depend
         on the abstraction module.
         :width: 50.0%

         **Figure 10**. Implementation modules depend on abstraction
         module.

   #. **Make high level modules dependent on abstraction modules**:
      Instead of directly depending on a specific implementation, make
      your modules dependent on abstraction modules. High level modules
      don't need to know implementation details, they only need the
      contract (API).

      .. figure::
         https://developer.android.google.cn/static/topic/modularization/images/2_api_impl_feature.png
         name: dependency_inversion_impl_api
         :alt: High level modules depend on abstractions, not
         implementation.
         :width: 60.0%

         **Figure 11**. High level modules depend on abstractions, not
         implementation.

   #. **Provide implementation module**: Finally, you need to provide
      the actual implementation for your dependencies. The specific
      implementation depends on your project setup, but the 
      `app module <#app-modules>`__ is usually
      a good place to do this. To provide the implementation specify it
      as a `dependency for your selected build variant or a testing source set <#dependencies>`__.

      .. figure:: https://developer.android.google.cn/static/topic/modularization/images/2_api_impl_app.png
         name: dependency_inversion_impl_api
         :alt: App module provides actual implementation.
         :width: 60.0%

         **Figure 12**. App module provides actual implementation.

   .. rubric:: General best practices
      :name: best-practices

   As mentioned in the beginning there is no single right way of
   developing a multi-module app. Just like there are many software
   architectures, there exist numerous ways to modularize an app.
   Nevertheless, the following general recommendations can help you make
   your code more readable, maintainable and testable.

   .. rubric:: Keep your configuration consistent
      :name: consistent-configuration

   Every module introduces configuration overhead. If the number of your
   modules reaches a certain threshold, managing consistent
   configuration becomes a challenge. For example, it‚Äôs important that
   modules use dependencies of the same version. If you need to update a
   large number of modules just to bump a dependency version, it is not
   only an effort but also a room for potential mistakes. To solve this
   problem, you can use one of the gradle‚Äôs tools to centralize your
   configuration:

   -  `Version catalogs <https://docs.gradle.org/current/userguide/platforms.html>`__
      are a type safe list of dependencies generated by Gradle during
      sync. It‚Äôs a central place to declare all your dependencies and is
      available to all the modules in a project.
   -  Use `convention plugins <https://docs.gradle.org/current/samples/sample_convention_plugins.html>`__
      to share build logic between modules.

   .. rubric:: Expose as little as possible
      :name: expose-little

   The public interface of a module should be minimal and expose only
   the essentials. It shouldn't leak any implementation details outside.
   Scope everything to the smallest extent possible. Use Kotlin‚Äôs
   ``private`` or ``internal`` visibility scope to make the declarations
   module-private. When 
   `declaring dependencies <#dependency_configurations>`__
   in your module, prefer ``implementation`` over ``api``. The latter
   exposes transitive dependencies to the consumers of your module.
   Using implementation may improve build time since it reduces the
   number of modules that need to be rebuilt.

   .. rubric:: Prefer Kotlin & Java modules
      :name: prefer-kotlin

   There are three essential types of modules that Android studio
   supports:

   -  **App modules** are an entry point to your application. They can
      contain source code, resources, assets and an
      ``AndroidManifest.xml``. The output of an app module is an Android
      App Bundle (AAB) or an Android Application Package (APK).
   -  `Library modules <#>`__ have the
      same content as the app modules. They are used by other Android
      modules as a dependency. The output of a library module is an
      Android Archive (AAR) are structurally identical to app modules
      but they are compiled to an Android Archive (AAR) file which can
      later be used by other modules as a
      `dependency <#>`__. A library module
      makes it possible to encapsulate and reuse the same logic and
      resources across many app modules.
   -  **Kotlin and Java libraries** don't contain any Android resources,
      assets, or manifest files.

   Since Android modules come with overhead, preferably, you'd want to
   use the Kotlin or Java kind as much as possible.

Last updated 2023-08-17 UTC.



.. _view_binding:

/Overview: View binding - Part of Android Jetpack
=================================================

.. https://developer.android.google.cn/topic/libraries/view-binding

.. container::

   *View binding* is a feature that makes it easier to write code that
   interacts with views. Once view binding is enabled in a module, it
   generates a *binding class* for each XML layout file present in that
   module. An instance of a binding class contains direct references to all
   views that have an ID in the corresponding layout.

   In most cases, view binding replaces ``findViewById``.

   Setup
   -----

   View binding is enabled on a module-by-module basis. To enable view
   binding in a module, set the ``viewBinding`` build option to ``true`` in
   the module-level ``build.gradle`` file, as shown in the following
   example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               android {
                   ...
                   buildFeatures {
                       viewBinding true
                   }
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               android {
                   ...
                   buildFeatures {
                       viewBinding = true
                   }
               }

   If you want a layout file to be ignored while generating binding
   classes, add the ``tools:viewBindingIgnore="true"`` attribute to the
   root view of that layout file:

   .. code:: prettyprint

      <LinearLayout
              ...
              tools:viewBindingIgnore="true" >
          ...
      </LinearLayout>

   Usage
   -----

   If view binding is enabled for a module, a binding class is generated
   for each XML layout file that the module contains. Each binding class
   contains references to the root view and all views that have an ID. The
   name of the binding class is generated by converting the name of the XML
   file to Pascal case and adding the word "Binding" to the end.

   For example, consider a layout file called ``result_profile.xml`` that
   contains the following:

   .. code:: prettyprint

      <LinearLayout ... >
          <TextView android:id="@+id/name" />
          <ImageView android:cropToPadding="true" />
          <Button android:id="@+id/button"
              android:background="@drawable/rounded_button" />
      </LinearLayout>

   The generated binding class is called ``ResultProfileBinding``. This
   class has two fields: a ``TextView`` called ``name`` and a ``Button``
   called ``button``. The ``ImageView`` in the layout has no ID, so there
   is no reference to it in the binding class.

   Every binding class also includes a ``getRoot()`` method, providing a
   direct reference for the root view of the corresponding layout file. In
   this example, the ``getRoot()`` method in the ``ResultProfileBinding``
   class returns the ``LinearLayout`` root view.

   The following sections demonstrate the use of generated binding classes
   in activities and fragments.

   .. _activities:

   Use view binding in activities
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   To set up an instance of the binding class for use with an activity,
   perform the following steps in the activity's
   `onCreate() <#oncreate>`__
   method:

   #. Call the static ``inflate()`` method included in the generated
      binding class. This creates an instance of the binding class for the
      activity to use.
   #. Get a reference to the root view by either calling the ``getRoot()``
      method or using `Kotlin property syntax <https://kotlinlang.org/docs/reference/properties.html#declaring-properties>`__.
   #. Pass the root view to
      `setContentView() <#setcontentview_1>`__
      to make it the active view on the screen.

   These steps are shown in the following example: 

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private lateinit var binding: ResultProfileBinding

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)
                   binding = ResultProfileBinding.inflate(layoutInflater)
                   val view = binding.root
                   setContentView(view)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private ResultProfileBinding binding;

               @Override
               protected void onCreate(Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);
                   binding = ResultProfileBinding.inflate(getLayoutInflater());
                   View view = binding.getRoot();
                   setContentView(view);
               }

   You can now use the instance of the binding class to reference any of
   the views:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               binding.name.text = viewModel.name
               binding.button.setOnClickListener { viewModel.userClicked() }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               binding.name.setText(viewModel.getName());
               binding.button.setOnClickListener(new View.OnClickListener() {
                   viewModel.userClicked()
               });

   .. _fragments:

   Use view binding in fragments
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   To set up an instance of the binding class for use with a fragment,
   perform the following steps in the fragment's
   `onCreateView() <#oncreateview>`__
   method:

   #. Call the static ``inflate()`` method included in the generated
      binding class. This creates an instance of the binding class for the
      fragment to use.
   #. Get a reference to the root view by either calling the ``getRoot()``
      method or using 
      `Kotlin property syntax <https://kotlinlang.org/docs/reference/properties.html#declaring-properties>`__.
   #. Return the root view from the ``onCreateView()`` method to make it
      the active view on the screen.

   **Note:**\  The ``inflate()`` method requires you to pass in a layout
   inflater. If the layout is already inflated, you can instead call the
   binding class's static ``bind()`` method. To learn more, 
   see `an example from the view binding GitHub sample <https://github.com/android/architecture-components-samples/blob/master/ViewBindingSample/app/src/main/java/com/android/example/viewbindingsample/BindFragment.kt#L36-L41>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private var _binding: ResultProfileBinding? = null
               // This property is only valid between onCreateView and
               // onDestroyView.
               private val binding get() = _binding!!

               override fun onCreateView(
                   inflater: LayoutInflater,
                   container: ViewGroup?,
                   savedInstanceState: Bundle?
               ): View? {
                   _binding = ResultProfileBinding.inflate(inflater, container, false)
                   val view = binding.root
                   return view
               }

               override fun onDestroyView() {
                   super.onDestroyView()
                   _binding = null
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private ResultProfileBinding binding;

               @Override
               public View onCreateView (LayoutInflater inflater,
                                         ViewGroup container,
                                         Bundle savedInstanceState) {
                   binding = ResultProfileBinding.inflate(inflater, container, false);
                   View view = binding.getRoot();
                   return view;
               }

               @Override
               public void onDestroyView() {
                   super.onDestroyView();
                   binding = null;
               }

   You can now use the instance of the binding class to reference any of
   the views:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               binding.name.text = viewModel.name
               binding.button.setOnClickListener { viewModel.userClicked() }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               binding.name.setText(viewModel.getName());
               binding.button.setOnClickListener(new View.OnClickListener() {
                   viewModel.userClicked()
               });

   **Note:**\  Fragments outlive their views. Make sure you clean up any
   references to the binding class instance in the fragment's
   `onDestroyView() <#ondestroyview>`__ method.

   .. _viewbindingtype:

   Provide hints for different configurations
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   When you declare views across multiple configurations, it occasionally
   makes sense to use a different view type depending on the particular
   layout. The following code snippet shows an example of this:

   .. code:: prettyprint

      # in res/layout/example.xml

      <TextView android:id="@+id/user_bio" />

      # in res/layout-land/example.xml

      <EditText android:id="@+id/user_bio" />

   In this case, you might expect the generated class to expose a field
   ``userBio`` of type ``TextView``, because ``TextView`` is the common
   base class. Due to technical limitations, the view binding code
   generator can't determine this and generates a ``View`` field instead.
   This requires casting the field later with
   ``binding.userBio as TextView``.

   To work around this limitation, view binding supports a 
   ``tools:viewBindingType`` attribute, letting you tell the compiler what
   type to use in the generated code. In the previous example, you can use
   this attribute to make the compiler generate the field as a
   ``TextView``:

   .. code:: prettyprint

      # in res/layout/example.xml (unchanged)

      <TextView android:id="@+id/user_bio" />

      # in res/layout-land/example.xml

      <EditText android:id="@+id/user_bio" tools:viewBindingType="TextView" />

   In another example, suppose you have two layouts, one that contains a
   ``BottomNavigationView`` and another that contains a
   ``NavigationRailView``. Both classes extend ``NavigationBarView``, which
   contains most of the implementation details. If your code doesn't need
   to know exactly which subclass is present in the current layout, you can
   use ``tools:viewBindingType`` to set the generated type to
   ``NavigationBarView`` in both layouts:

   .. code:: prettyprint

      # in res/layout/navigation_example.xml

      <BottomNavigationView android:id="@+id/navigation" tools:viewBindingType="NavigationBarView" />

      # in res/layout-w720/navigation_example.xml

      <NavigationRailView android:id="@+id/navigation" tools:viewBindingType="NavigationBarView" />

   View binding can't validate the value of this attribute when generating
   code. To avoid compile-time and runtime errors, the value must meet the
   following conditions:

   -  The value must be a class that inherits from ``android.view.View``.

   -  The value must be a superclass of the tag it is placed on. For
      example, the following values don't work:

      .. code:: prettyprint

           <TextView tools:viewBindingType="ImageView" /> <!-- ImageView is not related to TextView. -->
           <TextView tools:viewBindingType="Button" /> <!-- Button is not a superclass of TextView. -->

   -  The final type must resolve consistently across all configurations.

   .. _findviewbyid:

   Differences from findViewById
   -----------------------------

   View binding has important advantages over using ``findViewById``:

   -  **Null safety:** since view binding creates direct references to
      views, there's no risk of a null pointer exception due to an invalid
      view ID. Additionally, when a view is only present in some
      configurations of a layout, the field containing its reference in the
      binding class is marked with ``@Nullable``.
   -  **Type safety:** the fields in each binding class have types matching
      the views they reference in the XML file. This means there's no risk
      of a class cast exception.

   These differences mean incompatibilities between your layout and your
   code result in your build failing at compile time rather than at
   runtime.

   .. _data-binding:

   Comparison with data binding
   ----------------------------

   View binding and `data binding <#>`__ both 
   generate binding classes that you can use to reference views directly.
   However, view binding is intended to handle simpler use cases and
   provides the following benefits over data binding:

   -  **Faster compilation:** view binding requires no annotation
      processing, so compile times are faster.
   -  **Ease of use:** view binding doesn't require specially tagged XML
      layout files, so it's faster to adopt in your apps. Once you enable
      view binding in a module, it applies to all of that module's layouts
      automatically.

   On the other hand, view binding has the following limitations compared
   to data binding:

   -  View binding doesn't support `layout variables or layout expressions <#>`__, so it
      can't be used to declare dynamic UI content straight from XML layout
      files.
   -  View binding doesn't support `two-way data binding <#>`__.

   Because of these considerations, in some cases it's best to use both
   view binding and data binding in a project. You can use data binding in
   layouts that require advanced features and use view binding in layouts
   that don't.

   Additional resources
   --------------------

   To learn more about view binding, see the following additional
   resources:

   **Samples**


   -  `View binding sample <https://github.com/android/architecture-components-samples/tree/main/ViewBindingSample>`__

   **Blogs**


   -  `Use view binding to replace findViewById <https://medium.com/androiddevelopers/use-view-binding-to-replace-findviewbyid-c83942471fc>`__

   **Videos**


   -  `Android Jetpack: Replace findViewById with view binding <https://www.youtube.com/watch?v=W7uujFrljW0>`__

   .. _recommended_for_you:

   **Recommended for you**

   -  Note: link text is displayed when JavaScript is off
   -  `Migrate from Kotlin synthetics to Jetpack view binding <#>`__
   -  `Layouts and binding expressions <#>`__
   -  `App Architecture: UI Layer - Get Started - Android Developers <#>`__

   Last updated 2024-01-03 UTC.


/Migrate from Kotlin synthetics to Jetpack view binding
=======================================================

.. container:: devsite-article-body clearfix

   Kotlin Android Extensions is deprecated, which means that using
   Kotlin synthetics for view binding is no longer supported. If your
   app uses Kotlin synthetics for view binding, use this guide to
   migrate to Jetpack view binding.

   If your app doesn't already use Kotlin synthetics for view binding,
   see `View binding <#>`__ for basic usage
   information.

   .. rubric:: Update the Gradle file
      :name: gradle

   Like Android Extensions, Jetpack view binding is enabled on a
   module-by-module basis. For each module that uses view binding, set
   the ``viewBinding`` build option to ``true`` in the module-level
   ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               android {
                   ...
                   buildFeatures {
                       viewBinding true
                   }
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               android {
                   ...
                   buildFeatures {
                       viewBinding = true
                   }
               }

   If your app doesn't use
   `Parcelable <#>`__ features,
   remove the line that enables Kotlin Android Extensions:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               plugins {
                 id 'kotlin-android-extensions'
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               plugins {
                   kotlin("android.extensions")
               }

   **Note:**\  If your app uses ``Parcelable`` features, switch to using
   the standalone ``kotlin-parcelize`` Gradle plugin described in
   `Parcelable implementation generator <#>`__.
   To learn more about enabling view binding in a module, see `Setup instructions <#setup>`__.

   .. rubric:: Update activity and fragment classes
      :name: activity-fragment

   With Jetpack view binding, a binding class is generated for each XML
   layout file that the module contains. The name of this binding class
   is the name of the XML file in Pascal case with the word *Binding*
   added at the end. For example, if the name of the layout file is
   ``result_profile.xml``, the name of the generated binding class is
   ``ResultProfileBinding``.

   To use the generated binding classes instead of synthetic properties
   to reference views, change your activity and fragment classes by
   doing the following:

   #. Remove all imports from ``kotlinx.android.synthetic``.

   #. Inflate an instance of the generated binding class for the
      activity or fragment to use.

      -  For activities, follow the instructions in `Use view binding in activities <#activities>`__ to
         inflate an instance in your activity's
         `onCreate() <#oncreate>`__
         method.
      -  For fragments, follow the instructions in `Use view binding in fragments <#fragments>`__ to
         inflate an instance in your fragment's
         `onCreateView() <#oncreateview>`__
         method.

   #. Change all view references to use the binding class instance
      instead of synthetic properties:

   .. code:: prettyprint

      // Reference to "name" TextView using synthetic properties.
      name.text = viewModel.nameString

      // Reference to "name" TextView using the binding class instance.
      binding.name.text = viewModel.nameString

   To learn more, see the
   `Usage <#usage>`__ section in the view
   binding guide.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `View binding <#>`__
   -  `Paging library overview <#>`__
   -  `Test your Paging implementation <#>`__

Last updated 2023-07-12 UTC.



.. _data_binding_library:

/Overview: Data Binding Library - Part of Android Jetpack
=========================================================

.. https://developer.android.google.cn/topic/libraries/data-binding

.. container::

   The Data Binding Library is a support library that allows you to bind UI
   components in your layouts to data sources in your app using a
   declarative format rather than programmatically.

   Layouts are often defined in activities with code that calls UI
   framework methods. For example, the code below calls
   `findViewById() <#findViewById>`__
   to find a `TextView <#>`__ widget
   and bind it to the ``userName`` property of the ``viewModel`` variable:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               findViewById<TextView>(R.id.sample_text).apply {
                   text = viewModel.userName
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               TextView textView = findViewById(R.id.sample_text);
               textView.setText(viewModel.getUserName());

   The following example shows how to use the Data Binding Library to
   assign text to the widget directly in the layout file. This removes the
   need to call any of the Java code shown above. Note the use of ``@{}``
   syntax in the assignment expression:

   .. code:: prettyprint

      <TextView
          android:text="@{viewmodel.userName}" />

   Binding components in the layout file lets you remove many UI framework
   calls in your activities, making them simpler and easier to maintain.
   This can also improve your app's performance and help prevent memory
   leaks and null pointer exceptions.

   **Note:**\  In many cases, `view binding <#>`__ can provide the same benefits
   as data binding with simpler implementation and better performance. If
   you are using data binding primarily to replace ``findViewById()``
   calls, consider using view binding instead.

   .. _using_the_data_binding_library:

   Using the Data Binding Library
   ------------------------------

   Use the following pages to learn how to use the Data Binding Library in
   your Android apps.

   `Get started <#>`__
      Learn how to get your development environment ready to work with the
      Data Binding Library, including support for data binding code in
      Android Studio.

   `Layouts and binding expressions <#>`__

   The expression language allows you to write expressions that connect
   variables to the views in the layout. The Data Binding Library
   automatically generates the classes required to bind the views in the
   layout with your data objects. The library provides features such as
   imports, variables, and includes that you can use in your layouts.

   These features of the library coexist seamlessly with your existing
   layouts. For example, the binding variables that can be used in
   expressions are defined inside a ``data`` element that is a sibling of
   the UI layout's root element. Both elements are wrapped in a ``layout``
   tag, as shown in the following example:

   .. code:: prettyprint

      <layout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:app="http://schemas.android.com/apk/res-auto">
          <data>
              <variable
                  name="viewmodel"
                  type="com.myapp.data.ViewModel" />
          </data>
          <ConstraintLayout... /> <!-- UI layout's root element -->
      </layout>

   `Work with observable data objects <#>`__
      The Data Binding Library provides classes and methods to easily
      observe data for changes. You don't have to worry about refreshing
      the UI when the underlying data source changes. You can make your
      variables or their properties observable. The library allows you to
      make objects, fields, or collections observable.
   `Generated binding classes <#>`__
      The Data Binding Library generates binding classes that are used to
      access the layout's variables and views. This page shows you how to
      use and customize generated binding classes.
   `Binding adapters <#>`__
      For every layout expression, there is a binding adapter that makes
      the framework calls required to set the corresponding properties or
      listeners. For example, the binding adapter can take care of calling
      the ``setText()`` method to set the text property or call the
      ``setOnClickListener()`` method to add a listener to the click event.
      The most common binding adapters, such as the adapters for the
      ``android:text`` property used in the examples in this page, are
      available for you to use in the ``android.databinding.adapters``
      package. For a list of the common binding adapters, see
      `adapters <https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters>`__.
      You can also create custom adapters, as shown in the following
      example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @BindingAdapter("app:goneUnless")
               fun goneUnless(view: View, visible: Boolean) {
                   view.visibility = if (visible) View.VISIBLE else View.GONE
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @BindingAdapter("app:goneUnless")
               public static void goneUnless(View view, Boolean visible) {
                   view.visibility = visible ? View.VISIBLE : View.GONE;
               }

   `Bind layout views to Architecture Components <#>`__
      The Android Support Library includes the `Architecture Components <#>`__, which you can use to
      design robust, testable, and maintainable apps. You can use the
      Architecture Components with the Data Binding Library to further
      simplify the development of your UI.
   `Two-way data binding <#>`__
      The Data Binding Library supports two-way data binding. The notation
      used for this type of binding supports the ability to receive data
      changes to a property and listen to user updates to that property at
      the same time.

   .. container:: section dac-section dac-small

      .. container:: wrap

         .. rubric:: Additional resources
            :name: additional-resources

         To learn more about data binding, consult the following additional
         resources.

         .. rubric:: Samples
            :name: samples

         -  `Android Data Binding Library samples <https://github.com/android/databinding-samples>`__

         .. rubric:: Codelabs
            :name: codelabs

         -  `Android Data Binding codelab <https://developers.google.cn/codelabs/codelabs/android-databinding>`__

         .. rubric:: Blog posts
            :name: blog-posts

         -  `Android Data Binding Library ‚Äî From Observable Fields to LiveData in two steps <https://medium.com/androiddevelopers/android-data-binding-library-from-observable-fields-to-livedata-in-two-steps-690a384218f2>`__
         -  `Data Binding ‚Äî Lessons Learnt <https://medium.com/androiddevelopers/data-binding-lessons-learnt-4fd16576b719>`__

   .. _recommended_for_you:

   **Recommended for you**

   -  Note: link text is displayed when JavaScript is off
   -  `Binding adapters {:#binding-adapters} <#>`__
   -  `Layouts and binding expressions <#>`__
   -  `Generated binding classes {: #binding-classes} <#>`__

   Last updated 2024-01-03 UTC.



.. _get_started:

/Data Binding Library Get started
=================================

Learn how to get your development environment ready to work with the
Data Binding Library, including support for data binding code in Android
Studio.

The Data Binding Library offers both flexibility and broad
compatibility‚Äîit's a support library, so you can use it with devices
running Android 4.0 (API level 14) or higher.

We recommend using the latest Android Gradle plugin in your project.
However, data binding is supported on version 1.5.0 and higher. For more
information, see how to `update the Android Gradle plugin <#updating-plugin>`__.

.. _build_environment:

Build environment
-----------------

To get started with data binding, download the library from the
**Support Repository** in the Android SDK manager. For more information,
see `Update the IDE and SDK Tools <#>`__.

To configure your app to use data binding, enable the ``dataBinding``
build option in your ``build.gradle`` file in the app module, as shown
in the following example:

.. code:: prettyprint

   android {
       ...
       buildFeatures {
           dataBinding true
       }
   }

**Note:**\  You must configure data binding for app modules that depend
on libraries that use data binding, even if the app module doesn't
directly use data binding.

.. _studio_support:

Android Studio support for data binding
---------------------------------------

Android Studio supports many of the editing features for data binding
code. For example, it supports the following features for data binding
expressions:

-  Syntax highlighting
-  Flagging of expression language syntax errors
-  XML code completion
-  References, including
   `navigation <https://www.jetbrains.com/help/idea/2017.1/navigation-in-source-code.html>`__‚Äîsuch
   as navigating to a declaration‚Äîand `quick documentation <https://www.jetbrains.com/help/idea/2017.1/viewing-inline-documentation.html>`__

**Caution:**\  Arrays and a `generic type <https://docs.oracle.com/javase/tutorial/java/generics/types.html>`__,
such as the
`Observable <#>`__
interface, might incorrectly display errors.

The **Preview** pane in the **Layout Editor** displays the default value
of data binding expressions, if provided. For example, the **Preview**
pane displays the ``my_default`` value on the ``TextView`` widget
declared in the following example:

.. code:: prettyprint

   <TextView android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:text="@{user.firstName, default=my_default}"/>

If you need to display a default value only during the design phase of
your project, you can use ``tools`` attributes instead of default
expression values, as described in the `Tools attributes reference <#>`__.

.. container:: section dac-section dac-small

   .. container:: wrap

      .. rubric:: Additional resources
         :name: additional-resources

      To learn more about data binding, consult the following additional
      resources.

      -  `Android Data Binding Library samples <https://github.com/android/databinding-samples>`__

      -  `Data Binding in Android codelab <https://developers.google.cn/codelabs/codelabs/android-databinding>`__

      -  `Data Binding ‚Äî lessons learnt <https://medium.com/androiddevelopers/data-binding-lessons-learnt-4fd16576b719>`__

.. _recommended_for_you:

**Recommended for you**

-  Note: link text is displayed when JavaScript is off
-  `Work with observable data objects <#>`__
-  `View binding <#>`__
-  `Paging 2 library overview <#>`__

Last updated 2023-07-12 UTC.


/Layouts and binding expressions
================================

.. container:: devsite-article-body clearfix

   The expression language lets you write expressions that handle events
   dispatched by views. The Data Binding Library automatically generates
   the classes required to bind the views in the layout with your data
   objects.

   Data binding layout files are slightly different and start with a
   root tag of ``layout``, followed by a ``data`` element and a ``view``
   root element. This view element is what your root is in a non-binding
   layout file. The following code shows a sample layout file:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <layout xmlns:android="http://schemas.android.com/apk/res/android">
         <data>
             <variable name="user" type="com.example.User"/>
         </data>
         <LinearLayout
             android:orientation="vertical"
             android:layout_width="match_parent"
             android:layout_height="match_parent">
             <TextView android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
                 android:text="@{user.firstName}"/>
             <TextView android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
                 android:text="@{user.lastName}"/>
         </LinearLayout>
      </layout>

   The ``user`` variable within ``data`` describes a property that can
   be used within this layout:

   .. code:: prettyprint

      <variable name="user" type="com.example.User" />

   Expressions within the layout are written in the attribute properties
   using the ``@{}`` syntax. In the following example, the
   `TextView <#>`__ text is set to
   the ``firstName`` property of the ``user`` variable:

   .. code:: prettyprint

      <TextView android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@{user.firstName}" />

   **Note:**\  Keep layout expressions small and simple, as they can't
   be unit tested and have limited IDE support. To simplify layout
   expressions, you can use custom `binding adapters <#>`__.

   .. rubric:: Data objects
      :name: data_object

   Suppose you have a plain object to describe the ``User`` entity:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               data class User(val firstName: String, val lastName: String)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               public class User {
                 public final String firstName;
                 public final String lastName;
                 public User(String firstName, String lastName) {
                     this.firstName = firstName;
                     this.lastName = lastName;
                 }
               }

   This type of object has data that never changes. It's common in apps
   to have data that is read once and never changes thereafter. It's
   also possible to use an object that follows a set of conventions,
   such as using accessor methods in the Java programming language, as
   shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Not applicable in Kotlin.
               data class User(val firstName: String, val lastName: String)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class User {
                 private final String firstName;
                 private final String lastName;
                 public User(String firstName, String lastName) {
                     this.firstName = firstName;
                     this.lastName = lastName;
                 }
                 public String getFirstName() {
                     return this.firstName;
                 }
                 public String getLastName() {
                     return this.lastName;
                 }
               }

   From the perspective of data binding, these two classes are
   equivalent. The expression ``@{user.firstName}`` used for the
   `android:text <#attr_android:text>`__
   attribute accesses the ``firstName`` field in the former class and
   the ``getFirstName()`` method in the latter class. It is also
   resolved to ``firstName()``, if that method exists.

   .. rubric:: Binding data
      :name: binding_data

   A binding class is generated for each layout file. By default, the
   name of the class is based on the name of the layout file, converted
   to Pascal case, with the *Binding* suffix added to it. For example,
   the preceding layout filename is ``activity_main.xml``, so the
   corresponding generated binding class is ``ActivityMainBinding``.

   This class holds all the bindings from the layout properties‚Äîfor
   example, the ``user`` variable‚Äîto the layout's views and knows how to
   assign values for the binding expressions. We recommend creating the
   bindings while inflating the layout, as shown in the following
   example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)

                   val binding: ActivityMainBinding = DataBindingUtil.setContentView(
                           this, R.layout.activity_main)

                   binding.user = User("Test", "User")
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);
                  ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
                  User user = new User("Test", "User");
                  binding.setUser(user);
               }

   At runtime, the app displays the **Test** user in the UI.
   Alternatively, you can get the view using a
   `LayoutInflater <#>`__, as
   shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val binding: ActivityMainBinding = ActivityMainBinding.inflate(getLayoutInflater())

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ActivityMainBinding binding = ActivityMainBinding.inflate(getLayoutInflater());

   If you are using data binding items inside a
   `Fragment <#>`__,
   `ListView <#>`__, or
   `RecyclerView <#>`__
   adapter, you might prefer to use the
   `inflate() <#inflate>`__
   methods of the bindings classes or the
   `DataBindingUtil <#>`__
   class, as shown in the following code example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, false)
               // or
               val listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, false);
               // or
               ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false);

   .. rubric:: Expression language
      :name: expression_language

   .. rubric:: Common features
      :name: common_features

   The expression language looks a lot like expressions found in managed
   code. You can use the following operators and keywords in the
   expression language:

   -  Mathematical: ``+ - / * %``
   -  String concatenation: ``+``
   -  Logical: ``&& ||``
   -  Binary: ``& | ^``
   -  Unary: ``+ - ! ~``
   -  Shift: ``>> >>> <<``
   -  Comparison: ``== > < >= <=`` (the ``<`` needs to be escaped as
      ``&lt;``)
   -  ``instanceof``
   -  Grouping: ``()``
   -  Literals, such as character, String, numeric, ``null``
   -  Cast
   -  Method calls
   -  Field access
   -  Array access: ``[]``
   -  Ternary operator: ``?:``

   Here are some examples:

   .. code:: prettyprint

      android:text="@{String.valueOf(index + 1)}"
      android:visibility="@{age > 13 ? View.GONE : View.VISIBLE}"
      android:transitionName='@{"image_" + id}'

   .. rubric:: Missing operations
      :name: missing_operations

   The following operations are missing from the expression syntax that
   you can use in managed code:

   -  ``this``
   -  ``super``
   -  ``new``
   -  Explicit generic invocation

   .. rubric:: Null coalescing operator
      :name: null_coalescing_operator

   The null coalescing operator (``??``) chooses the left operand if it
   isn't ``null`` or the right if the former is ``null``:

   .. code:: prettyprint

      android:text="@{user.displayName ?? user.lastName}"

   This is functionally equivalent to the following:

   .. code:: prettyprint

      android:text="@{user.displayName != null ? user.displayName : user.lastName}"

   .. rubric:: Property references
      :name: property_reference

   An expression can reference a property in a class by using the
   following format, which is the same for fields, getters, and
   `ObservableField <#>`__
   objects:

   .. code:: prettyprint

      android:text="@{user.lastName}"

   .. rubric:: Avoid null pointer exceptions
      :name: avoiding_nullpointerexception

   Generated data binding code automatically checks for ``null`` values
   and avoids null pointer exceptions. For example, in the expression
   ``@{user.name}``, if ``user`` is null, ``user.name`` is assigned its
   default value of ``null``. If you reference ``user.age``, where age
   is of type ``int``, then data binding uses the default value of
   ``0``.

   .. rubric:: View references
      :name: view_references

   An expression can reference other views in the layout by ID, using
   the following syntax:

   .. code:: prettyprint

      android:text="@{exampleText.text}"

   **Note:**\  The binding class converts IDs to camel case.
   In the following example, the ``TextView`` view references an
   ``EditText`` view in the same layout:

   .. code:: prettyprint

      <EditText
          android:id="@+id/example_text"
          android:layout_height="wrap_content"
          android:layout_width="match_parent"/>
      <TextView
          android:id="@+id/example_output"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:text="@{exampleText.text}"/>

   .. rubric:: Collections
      :name: collections

   You can access common collections, such as arrays, lists, sparse
   lists, and maps, using the ``[]`` operator for convenience.

   .. code:: prettyprint

      <data>
          <import type="android.util.SparseArray"/>
          <import type="java.util.Map"/>
          <import type="java.util.List"/>
          <variable name="list" type="List&lt;String>"/>
          <variable name="sparse" type="SparseArray&lt;String>"/>
          <variable name="map" type="Map&lt;String, String>"/>
          <variable name="index" type="int"/>
          <variable name="key" type="String"/>
      </data>
      ...
      android:text="@{list[index]}"
      ...
      android:text="@{sparse[index]}"
      ...
      android:text="@{map[key]}"

   **Note:**\  For the XML to be syntactically correct, escape the ``<``
   characters. For example: instead of ``List<String>``, write
   ``List&lt;String>``.
   You can also refer to a value in the map using the ``object.key``
   notation. For example, you can replace ``@{map[key]}`` in the
   preceding example with ``@{map.key}``.

   .. rubric:: String literals
      :name: string_literals

   You can use single quotes to surround the attribute value, which lets
   you use double quotes in the expression, as shown in the following
   example:

   .. code:: prettyprint

      android:text='@{map["firstName"]}'

   You can also use double quotes to surround the attribute value. When
   doing so, string literals must be surrounded with backticks
   :literal:`\``, as shown here:

   .. code:: prettyprint

      android:text="@{map[`firstName`]}"

   .. rubric:: Resources
      :name: resources

   An expression can reference app resources with the following syntax:

   .. code:: prettyprint

      android:padding="@{large? @dimen/largePadding : @dimen/smallPadding}"

   You can evaluate format strings and plurals by providing parameters:

   .. code:: prettyprint

      android:text="@{@string/nameFormat(firstName, lastName)}"
      android:text="@{@plurals/banana(bananaCount)}"

   You can pass `property references <#property_reference>`__ and `view references <#view_references>`__ as resource parameters:

   .. code:: prettyprint

      android:text="@{@string/example_resource(user.lastName, exampleText.text)}"

   When a plural takes multiple parameters, pass all parameters:

   .. code:: prettyprint

        Have an orange
        Have %d oranges

      android:text="@{@plurals/orange(orangeCount, orangeCount)}"

   Some resources require explicit type evaluation, as shown in the
   following table:

   ===================== ================ ======================
   Type                  Normal reference Expression reference
   ===================== ================ ======================
   ``String[]``          ``@array``       ``@stringArray``
   ``int[]``             ``@array``       ``@intArray``
   ``TypedArray``        ``@array``       ``@typedArray``
   ``Animator``          ``@animator``    ``@animator``
   ``StateListAnimator`` ``@animator``    ``@stateListAnimator``
   ``color int``         ``@color``       ``@color``
   ``ColorStateList``    ``@color``       ``@colorStateList``
   ===================== ================ ======================

   .. rubric:: Event handling
      :name: event_handling

   Data binding lets you write expression handling events that are
   dispatched from the views‚Äîfor example, the
   `onClick() <#onClick>`__
   method. Event attribute names are determined by the name of the
   listener method, with a few exceptions. For example,
   `View.OnClickListener <#>`__
   has a method ``onClick()``, so the attribute for this event is
   ``android:onClick``.

   There are some specialized event handlers for the click event that
   need an attribute other than ``android:onClick`` to avoid a conflict.
   You can use the following attributes to avoid these type of
   conflicts:

   .. list-table::
      :header-rows: 1

      - 

         - Class
         - Listener setter
         - Attribute
      - 

         - `SearchView <#>`__
         - `setOnSearchClickListener(View.OnClickListener) <#setOnSearchClickListener>`__
         - ``android:onSearchClick``
      - 

         - `ZoomControls <#>`__
         - `setOnZoomInClickListener(View.OnClickListener) <#setOnZoomInClickListener>`__
         - ``android:onZoomIn``
      - 

         - `ZoomControls <#>`__
         - `setOnZoomOutClickListener(View.OnClickListener) <#setOnZoomOutClickListener>`__
         - ``android:onZoomOut``

   You can use these two mechanisms, described in detail in the sections
   that follow, to handle an event:

   -  `Method references <#method_references>`__: in your expressions,
      you can reference methods that conform to the signature of the
      listener method. When an expression evaluates to a method
      reference, data binding wraps the method reference and owner
      object in a listener and sets that listener on the target view. If
      the expression evaluates to ``null``, data binding doesn't create
      a listener and sets a ``null`` listener instead.
   -  `Listener bindings <#listener_bindings>`__: these are lambda
      expressions that are evaluated when the event happens. Data
      binding always creates a listener, which it sets on the view. When
      the event is dispatched, the listener evaluates the lambda
      expression.

   .. rubric:: Method references
      :name: method_references

   You can bind events to handler methods directly, similar to the way
   you can assign
   `android:onClick <#attr_android:onClick>`__
   to a method in an activity. One advantage compared to the
   `View <#>`__ ``onClick`` attribute is
   that the expression is processed at compile time. So, if the method
   doesn't exist or its signature is incorrect, you receive a compile
   time error.

   The major difference between method references and listener bindings
   is that the actual listener implementation is created when the data
   is bound, not when the event is triggered. If you prefer to evaluate
   the expression when the event happens, use `listener bindings <#listener_bindings>`__.

   To assign an event to its handler, use a normal binding expression,
   with the value being the method name to call. For example, consider
   the following example layout data object:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyHandlers {
                   fun onClickFriend(view: View) { ... }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyHandlers {
                   public void onClickFriend(View view) { ... }
               }

   The binding expression can assign the click listener for a view to
   the ``onClickFriend()`` method, as follows:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <layout xmlns:android="http://schemas.android.com/apk/res/android">
         <data>
             <variable name="handlers" type="com.example.MyHandlers"/>
             <variable name="user" type="com.example.User"/>
         </data>
         <LinearLayout
             android:orientation="vertical"
             android:layout_width="match_parent"
             android:layout_height="match_parent">
             <TextView android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
                 android:text="@{user.firstName}"
                 android:onClick="@{handlers::onClickFriend}"/>
         </LinearLayout>
      </layout>

   **Note:**\  The signature of the method in the expression must
   exactly match the signature of the method in the listener object.

   .. rubric:: Listener bindings
      :name: listener_bindings

   Listener bindings are binding expressions that run when an event
   happens. They are similar to method references, but they let you run
   arbitrary data binding expressions. This feature is available with
   Android Gradle Plugin for Gradle version 2.0 and later.

   In method references, the parameters of the method must match the
   parameters of the event listener. In listener bindings, only your
   return value must match the expected return value of the listener,
   unless it is expecting ``void``. For example, consider the following
   presenter class that has an ``onSaveClick()`` method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class Presenter {
                   fun onSaveClick(task: Task){}
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class Presenter {
                   public void onSaveClick(Task task){}
               }

   You can bind the click event to the ``onSaveClick()`` method as
   follows:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <layout xmlns:android="http://schemas.android.com/apk/res/android">
          <data>
              <variable name="task" type="com.android.example.Task" />
              <variable name="presenter" type="com.android.example.Presenter" />
          </data>
          <LinearLayout android:layout_width="match_parent" android:layout_height="match_parent">
              <Button android:layout_width="wrap_content" android:layout_height="wrap_content"
              android:onClick="@{() -> presenter.onSaveClick(task)}" />
          </LinearLayout>
      </layout>

   When a callback is used in an expression, data binding automatically
   creates the necessary listener and registers it for the event. When
   the view fires the event, data binding evaluates the given
   expression. As with regular binding expressions, you get the null and
   thread safety of data binding while these listener expressions are
   being evaluated.

   In the preceding example, the ``view`` parameter that is passed to
   ``onClick(View)`` isn't defined. Listener bindings provide two
   choices for listener parameters: you can ignore all parameters to the
   method or name all of them. If you prefer to name the parameters, you
   can use them in your expression. For example, you can write the
   preceding expression as follows:

   .. code:: prettyprint

      android:onClick="@{(view) -> presenter.onSaveClick(task)}"

   If you want to use the parameter in the expression, you can do that
   as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class Presenter {
                   fun onSaveClick(view: View, task: Task){}
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class Presenter {
                   public void onSaveClick(View view, Task task){}
               }

   .. code:: prettyprint

      android:onClick="@{(theView) -> presenter.onSaveClick(theView, task)}"

   And you can use a lambda expression with more than one parameter:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class Presenter {
                   fun onCompletedChanged(task: Task, completed: Boolean){}
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class Presenter {
                   public void onCompletedChanged(Task task, boolean completed){}
               }

   .. code:: prettyprint

      <CheckBox android:layout_width="wrap_content" android:layout_height="wrap_content"
            android:onCheckedChanged="@{(cb, isChecked) -> presenter.completeChanged(task, isChecked)}" />

   If the event you are listening to returns a value whose type isn't
   ``void``, your expressions must return the same type of value as
   well. For example, if you want to listen for the touch & hold (long
   click) event, your expression must return a boolean.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class Presenter {
                   fun onLongClick(view: View, task: Task): Boolean { }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class Presenter {
                   public boolean onLongClick(View view, Task task) { }
               }

   .. code:: prettyprint

      android:onLongClick="@{(theView) -> presenter.onLongClick(theView, task)}"

   If the expression can't be evaluated due to ``null`` objects, data
   binding returns the default value for that type, such as ``null`` for
   reference types, ``0`` for ``int``, or ``false`` for ``boolean``.

   If you need to use an expression with a predicate‚Äîfor example, a
   ternary‚Äîyou can use ``void`` as a symbol:

   .. code:: prettyprint

      android:onClick="@{(v) -> v.isVisible() ? doSomething() : void}"

   .. rubric:: Avoid complex listeners
      :name: complex_listeners

   Listener expressions are powerful and can make your code easier to
   read. On the other hand, listeners containing complex expressions
   make your layouts *harder* to read and maintain. Keep your
   expressions as simple as passing available data from your UI to your
   callback method. Implement any business logic inside the callback
   method that you invoke from the listener expression.

   .. rubric:: Imports, variables, and includes
      :name: imports-variables-includes

   The Data Binding Library provides features such as imports,
   variables, and includes. Imports make easy-to-reference classes
   inside your layout files. Variables let you describe a property that
   can be used in binding expressions. Includes let you reuse complex
   layouts across your app.

   .. rubric:: Imports
      :name: imports

   Imports let you reference classes inside your layout file, like in
   managed code. You can use zero or more ``import`` elements inside the
   ``data`` element. The following code example imports the ``View``
   class to the layout file:

   .. code:: prettyprint

      <data>
          <import type="android.view.View"/>
      </data>

   Importing the ``View`` class lets you reference it from your binding
   expressions. The following example shows how to reference the
   `VISIBLE <#VISIBLE>`__ and
   `GONE <#GONE>`__ constants of the
   ``View`` class:

   .. code:: prettyprint

      <TextView
         android:text="@{user.lastName}"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:visibility="@{user.isAdult ? View.VISIBLE : View.GONE}"/>

   .. rubric:: Type aliases
      :name: type-aliases

   When there are class name conflicts, you can rename one of the
   classes to an alias. The following example renames the ``View`` class
   in the ``com.example.real.estate`` package to ``Vista``:

   .. code:: prettyprint

      <import type="android.view.View"/>
      <import type="com.example.real.estate.View"
              alias="Vista"/>

   You can then use ``Vista`` to reference
   ``com.example.real.estate.View`` and ``View`` to reference
   ``android.view.View`` within the layout file.

   .. rubric:: Import other classes
      :name: import-classes

   You can use imported types as type references in variables and
   expressions. The following example shows ``User`` and ``List`` used
   as the type of a variable:

   .. code:: prettyprint

      <data>
          <import type="com.example.User"/>
          <import type="java.util.List"/>
          <variable name="user" type="User"/>
          <variable name="userList" type="List&lt;User>"/>
      </data>

   **Caution:**\  Android Studio doesn't yet handle imports, so the
   autocomplete for imported variables might not work in your IDE. Your
   app still compiles, and you can work around the IDE issue by using
   fully qualified names in your variable definitions.
   You can use the imported types to cast part of an expression. The
   following example casts the ``connection`` property to a type of
   ``User``:

   .. code:: prettyprint

      <TextView
         android:text="@{((User)(user.connection)).lastName}"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"/>

   You can also use imported types when referencing static fields and
   methods in expressions. The following code imports the
   ``MyStringUtils`` class and references its ``capitalize`` method:

   .. code:: prettyprint

      <data>
          <import type="com.example.MyStringUtils"/>
          <variable name="user" type="com.example.User"/>
      </data>
      ‚Ä¶
      <TextView
         android:text="@{MyStringUtils.capitalize(user.lastName)}"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"/>

   Just as in managed code, ``java.lang.*`` is imported automatically.

   .. rubric:: Variables
      :name: variables

   You can use multiple ``variable`` elements inside the ``data``
   element. Each ``variable`` element describes a property that can be
   set on the layout to be used in binding expressions within the layout
   file. The following example declares the ``user``, ``image``, and
   ``note`` variables:

   .. code:: prettyprint

      <data>
          <import type="android.graphics.drawable.Drawable"/>
          <variable name="user" type="com.example.User"/>
          <variable name="image" type="Drawable"/>
          <variable name="note" type="String"/>
      </data>

   The variable types are inspected at compile time, so if a variable
   implements
   `Observable <#>`__ or is
   an `observable collection <#observable_Collections>`__,
   that must be reflected in the type. If the variable is a base class
   or interface that doesn't implement the ``Observable`` interface, the
   variables *aren't* observed.

   When there are different layout files for various configurations (for
   example, landscape or portrait), the variables are combined. There
   must not be conflicting variable definitions between these layout
   files.

   The generated binding class has a setter and getter for each of the
   described variables. The variables take the default managed code
   values until the setter is called‚Äî``null`` for reference types, ``0``
   for ``int``, ``false`` for ``boolean``, etc.

   A special variable named ``context`` is generated for use in binding
   expressions as needed. The value for ``context`` is the
   `Context <#>`__ object from the
   root view's
   `getContext() <#getContext>`__
   method. The ``context`` variable is overridden by an explicit
   variable declaration with that name.

   .. rubric:: Includes
      :name: includes

   You can pass variables into an included layout's binding from the
   containing layout by using the app namespace and the variable name in
   an attribute. The following example shows included ``user`` variables
   from the ``name.xml`` and ``contact.xml`` layout files:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <layout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:bind="http://schemas.android.com/apk/res-auto">
         <data>
             <variable name="user" type="com.example.User"/>
         </data>
         <LinearLayout
             android:orientation="vertical"
             android:layout_width="match_parent"
             android:layout_height="match_parent">
             <include layout="@layout/name"
                 bind:user="@{user}"/>
             <include layout="@layout/contact"
                 bind:user="@{user}"/>
         </LinearLayout>
      </layout>

   Data binding doesn't support an include as a direct child of a merge
   element. For example, the following layout isn't supported:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <layout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:bind="http://schemas.android.com/apk/res-auto">
         <data>
             <variable name="user" type="com.example.User"/>
         </data>
         <merge><!-- Doesn't work -->
             <include layout="@layout/name"
                 bind:user="@{user}"/>
             <include layout="@layout/contact"
                 bind:user="@{user}"/>
         </merge>
      </layout>

   .. container:: section dac-section dac-small

      .. container:: wrap

         .. rubric:: Additional resources
            :name: additional-resources

         To learn more about data binding, consult the following
         additional resources.

         .. rubric:: Samples
            :name: samples

         -  `Android Data Binding Library samples <https://github.com/android/databinding-samples>`__

         .. rubric:: Codelabs
            :name: codelabs

         -  `Data Binding in Android codelab <https://developers.google.cn/codelabs/codelabs/android-databinding>`__

         .. rubric:: Blog posts
            :name: blogs

         -  `Data Binding ‚Äî lessons learnt <https://medium.com/androiddevelopers/data-binding-lessons-learnt-4fd16576b719>`__

      Content and code samples on this page are subject to the licenses
      described in the `Content License <#>`__. Java and OpenJDK
      are trademarks or registered trademarks of Oracle and/or its
      affiliates.

      Last updated 2024-01-03 UTC.


/Work with observable data objects
==================================

.. container:: devsite-article-body clearfix

   *Observability* refers to the capability of an object to notify
   others about changes in its data. The Data Binding Library lets you
   make objects, fields, or collections observable.

   You can use any object for data binding, but modifying the object
   doesn't automatically cause the UI to update. You can use data
   binding to give your data objects the ability to notify other
   objects‚Äîknown as listeners‚Äîwhen their data changes. There are three
   types of observable classes: `fields <#observable_fields>`__,
   `collections <#observable_collections>`__, and
   `objects <#observable_objects>`__.

   When one of these observable data objects is bound to the UI and a
   property of the data object changes, the UI updates automatically.

   .. rubric:: Observable fields
      :name: observable_fields

   If your classes only have a few properties, it might not be worth the
   effort to create classes that implement the
   `Observable <#>`__
   interface. In this case, you can use the generic ``Observable`` class
   and the following primitive-specific classes to make fields
   observable:

   -  `ObservableBoolean <#>`__
   -  `ObservableByte <#>`__
   -  `ObservableChar <#>`__
   -  `ObservableShort <#>`__
   -  `ObservableInt <#>`__
   -  `ObservableLong <#>`__
   -  `ObservableFloat <#>`__
   -  `ObservableDouble <#>`__
   -  `ObservableParcelable <#>`__

   Observable fields are self-contained observable objects that have a
   single field. The primitive versions avoid boxing and unboxing during
   access operations. To use this mechanism, create a ``public final``
   property in the Java programming language or a read-only property in
   Kotlin, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class User {
                   val firstName = ObservableField<String>()
                   val lastName = ObservableField<String>()
                   val age = ObservableInt()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private static class User {
                   public final ObservableField<String> firstName = new ObservableField<>();
                   public final ObservableField<String> lastName = new ObservableField<>();
                   public final ObservableInt age = new ObservableInt();
               }

   To access the field value, use the
   `set() <#set>`__
   and
   `get() <#get>`__
   accessor methods or use `Kotlin property syntax <https://kotlinlang.org/docs/reference/properties.html#declaring-properties>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               user.firstName = "Google"
               val age = user.age

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               user.firstName.set("Google");
               int age = user.age.get();

   .. rubric:: Observable collections
      :name: observable_collections

   Some apps use dynamic structures to hold data. Observable collections
   allow access to these structures by using a key. The
   `ObservableArrayMap <#>`__
   class is useful when the key is a reference type, such as ``String``,
   as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               ObservableArrayMap<String, Any>().apply {
                   put("firstName", "Google")
                   put("lastName", "Inc.")
                   put("age", 17)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ObservableArrayMap<String, Object> user = new ObservableArrayMap<>();
               user.put("firstName", "Google");
               user.put("lastName", "Inc.");
               user.put("age", 17);

   In the layout, you can find the map using the string keys, as shown
   in the following example:

   .. code:: prettyprint

      <data>
          <import type="android.databinding.ObservableMap"/>
          <variable name="user" type="ObservableMap&lt;String, Object&gt;"/>
      </data>
      ‚Ä¶
      <TextView
          android:text="@{user.lastName}"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"/>
      <TextView
          android:text="@{String.valueOf(1 + (Integer)user.age)}"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"/>

   The
   `ObservableArrayList <#>`__
   class is useful when the key is an integer, as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               ObservableArrayList<Any>().apply {
                   add("Google")
                   add("Inc.")
                   add(17)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ObservableArrayList<Object> user = new ObservableArrayList<>();
               user.add("Google");
               user.add("Inc.");
               user.add(17);

   In the layout, you can access the list through the indexes, as shown
   in the following example:

   .. code:: prettyprint

      <data>
          <import type="android.databinding.ObservableList"/>
          <import type="com.example.my.app.Fields"/>
          <variable name="user" type="ObservableList&lt;Object&gt;"/>
      </data>
      ‚Ä¶
      <TextView
          android:text='@{user[Fields.LAST_NAME]}'
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"/>
      <TextView
          android:text='@{String.valueOf(1 + (Integer)user[Fields.AGE])}'
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"/>

   .. rubric:: Observable objects
      :name: observable_objects

   A class that implements the ``Observable`` interface allows the
   registration of listeners that want to be notified of property
   changes from the observable object.

   The ``Observable`` interface has a mechanism to add and remove
   listeners, but you decide when notifications are sent. To make
   development easier, the Data Binding Library provides the
   `BaseObservable <#>`__
   class, which implements the listener registration mechanism. The data
   class that implements ``BaseObservable`` is responsible for notifying
   when the properties change. To do this, assign a
   `Bindable <#>`__ annotation
   to the getter and call the
   `notifyPropertyChanged() <#notifypropertychanged>`__
   method in the setter, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class User : BaseObservable() {

                   @get:Bindable
                   var firstName: String = ""
                       set(value) {
                           field = value
                           notifyPropertyChanged(BR.firstName)
                       }

                   @get:Bindable
                   var lastName: String = ""
                       set(value) {
                           field = value
                           notifyPropertyChanged(BR.lastName)
                       }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private static class User extends BaseObservable {
                   private String firstName;
                   private String lastName;

                   @Bindable
                   public String getFirstName() {
                       return this.firstName;
                   }

                   @Bindable
                   public String getLastName() {
                       return this.lastName;
                   }

                   public void setFirstName(String firstName) {
                       this.firstName = firstName;
                       notifyPropertyChanged(BR.firstName);
                   }

                   public void setLastName(String lastName) {
                       this.lastName = lastName;
                       notifyPropertyChanged(BR.lastName);
                   }
               }

   Data binding generates a class named ``BR`` in the module package,
   which contains the IDs of the resources used for data binding. The
   ``Bindable`` annotation generates an entry in the ``BR`` class file
   during compilation. If the base class for data classes can't be
   changed, you can implement the ``Observable`` interface using a
   `PropertyChangeRegistry <#>`__
   object to register and notify listeners efficiently.

   .. rubric:: Lifecycle-aware objects
      :name: lifecycle-objects

   The layouts in your app can also bind to data binding sources that
   automatically notify the UI about changes in the data. That way, your
   bindings are lifecycle aware and are only triggered when the UI is
   visible on the screen.

   Data binding supports
   `StateFlow <#>`__ and
   `LiveData <#>`__. For more
   information about using ``LiveData`` in data binding, see `Use LiveData to notify the UI about data changes <#livedata>`__.

   **Note:**\  Consider using ``LiveData`` if your project already
   depends on the ``LiveData`` library. If you don't have an initial
   value to provide, make sure ``StateFlow`` has one. If you don't want
   to manually unregister the consumer, ``LiveData`` automatically
   unregisters when the view goes to the ``STOPPED`` state.

   .. rubric:: Use StateFlow
      :name: stateflow

   If your app uses Kotlin with `coroutines <#>`__, you
   can use ``StateFlow`` objects as the data binding source. To use a
   ``StateFlow`` object with your binding class, specify a lifecycle
   owner to define the scope of the ``StateFlow`` object. The following
   example specifies the activity as the lifecycle owner after the
   binding class is instantiated:

   .. code:: prettyprint

      class ViewModelActivity : AppCompatActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              // Inflate view and obtain an instance of the binding class.
              val binding: UserBinding = DataBindingUtil.setContentView(this, R.layout.user)

              // Specify the current activity as the lifecycle owner.
              binding.lifecycleOwner = this
          }
      }

   As described in `Bind layout views to Architecture Components <#viewmodel>`__,
   data binding works seamlessly with
   `ViewModel <#>`__ objects.
   You can use ``StateFlow`` and ``ViewModel`` together as follows:

   .. code:: prettyprint

      class ScheduleViewModel : ViewModel() {

          private val _username = MutableStateFlow<String>("")
          val username: StateFlow<String> = _username

          init {
              viewModelScope.launch {
                  _username.value = Repository.loadUserName()
              }
          }
      }

   In your layout, assign the properties and methods of your
   ``ViewModel`` object to the corresponding views using binding
   expressions, as shown in the following example:

   .. code:: prettyprint

      <TextView
          android:id="@+id/name"
          android:text="@{viewmodel.username}" />

   The UI automatically updates whenever the user's name value changes.

   **Note:**\  ``StateFlow`` support is a preview feature that requires
   version ``7.0.0-alpha04`` or higher of the `Android Gradle plugin <#>`__.

   .. rubric:: Disable StateFlow support
      :name: disable-stateflow

   For apps that use Kotlin and AndroidX, ``StateFlow`` support is
   automatically included with data binding. This means that the
   coroutines dependency is automatically included in your app if the
   dependency isn't already available.

   You can opt out of this functionality by adding the following to your
   ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               android {
                   ...
                   dataBinding {
                       addKtx = false
                   }
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               android {
                   ...
                   dataBinding {
                       addKtx = false
                   }
               }

   Alternatively, you can disable ``StateFlow`` globally in your project
   by adding the following line to the ``gradle.properties`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               android.defaults.databinding.addKtx = false

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               android.defaults.databinding.addKtx = false

   .. rubric:: Additional resources
      :name: additional-resources

   To learn more about data binding, see the following for additional
   resources:

   .. rubric:: Samples
      :name: samples

   -  `Android Data Binding Library samples <https://github.com/android/databinding-samples>`__

   .. rubric:: Codelabs
      :name: codelabs

   -  `Data Binding in Android <https://developers.google.cn/codelabs/codelabs/android-databinding>`__

   .. rubric:: Blog posts
      :name: blogs

   -  `Data Binding ‚Äî lessons learnt <https://medium.com/androiddevelopers/data-binding-lessons-learnt-4fd16576b719>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Saved State module for ViewModel <#>`__
   -  `Bind layout views to Architecture Components <#>`__
   -  `Paging library overview <#>`__

Last updated 2024-01-03 UTC.


/Generated binding classes
==========================

.. container:: devsite-article-body clearfix

   The Data Binding Library generates binding classes you can use to
   access the layout's variables and views. This documentation shows how
   to create and customize generated binding classes.

   The generated binding class links the layout variables with the views
   within the layout. You can
   `customize <#custom_binding_class_names>`__ the name and package of
   the binding. All generated binding classes inherit from the
   `ViewDataBinding <#>`__
   class.

   A binding class is generated for each layout file. By default, the
   name of the class is the name of the layout file converted to Pascal
   case with the *Binding* suffix added to it. So, for example, if the
   layout filename is ``activity_main.xml``, the corresponding generated
   class is ``ActivityMainBinding``. This class holds all the bindings
   from the layout properties to the layout's views and knows how to
   assign values for the binding expressions.

   .. rubric:: Create a binding object
      :name: create

   The binding object is created immediately after inflating the layout
   to make sure the view hierarchy isn't modified before it binds to the
   views with expressions within the layout. The most common method to
   bind the object to a layout is to use the static methods on the
   binding class. You can inflate the view hierarchy and bind the object
   to it by using the ``inflate()`` method of the binding class, as
   shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)

                   val binding: MyLayoutBinding = MyLayoutBinding.inflate(layoutInflater)

                   setContentView(binding.root)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onCreate(Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);
                   MyLayoutBinding binding = MyLayoutBinding.inflate(getLayoutInflater());

                   setContentView(binding.root);
               }

   There is an alternate version of the ``inflate()`` method that takes
   a `ViewGroup <#>`__ object in
   addition to the
   `LayoutInflater <#>`__
   object , as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val binding: MyLayoutBinding = MyLayoutBinding.inflate(getLayoutInflater(), viewGroup, false)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               MyLayoutBinding binding = MyLayoutBinding.inflate(getLayoutInflater(), viewGroup, false);

   If the layout is inflated using a different mechanism, you can bind
   it separately, as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val binding: MyLayoutBinding = MyLayoutBinding.bind(viewRoot)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               MyLayoutBinding binding = MyLayoutBinding.bind(viewRoot);

   Sometimes you don't know the binding type in advance. In such cases,
   you can create the binding using the
   `DataBindingUtil <#>`__
   class, as demonstrated in the following code snippet:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val viewRoot = LayoutInflater.from(this).inflate(layoutId, parent, attachToParent)
               val binding: ViewDataBinding? = DataBindingUtil.bind(viewRoot)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               View viewRoot = LayoutInflater.from(this).inflate(layoutId, parent, attachToParent);
               ViewDataBinding binding = DataBindingUtil.bind(viewRoot);

   If you are using data binding items inside a
   `Fragment <#>`__,
   `ListView <#>`__, or
   `RecyclerView <#>`__
   adapter, you might prefer to use the
   `inflate() <#inflate>`__
   methods of the bindings classes or the
   `DataBindingUtil <#>`__
   class, as shown in the following code example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, false)
               // or
               val listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, false);
               // or
               ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false);

   .. rubric:: Views with IDs
      :name: views_with_ids

   The Data Binding Library creates an immutable field in the binding
   class for each view that has an ID in the layout. For example, the
   Data Binding Library creates the ``firstName`` and ``lastName``
   fields of type ``TextView`` from the following layout:

   .. code:: prettyprint

      <layout xmlns:android="http://schemas.android.com/apk/res/android">
         <data>
             <variable name="user" type="com.example.User"/>
         </data>
         <LinearLayout
             android:orientation="vertical"
             android:layout_width="match_parent"
             android:layout_height="match_parent">
             <TextView android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
                 android:text="@{user.firstName}"
         android:id="@+id/firstName"/>
             <TextView android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
                 android:text="@{user.lastName}"
        android:id="@+id/lastName"/>
         </LinearLayout>
      </layout>

   The library extracts the views, including the IDs, from the view
   hierarchy in a single pass. This mechanism can be faster than calling
   the
   `findViewById() <#findViewById>`__
   method for every view in the layout.

   IDs aren't as necessary as they are without data binding, but there
   are still some instances where access to views is necessary from
   code.

   .. rubric:: Variables
      :name: variables2

   The Data Binding Library generates accessor methods for each variable
   declared in the layout. For example, the following layout generates
   setter and getter methods in the binding class for the ``user``,
   ``image``, and ``note`` variables:

   .. code:: prettyprint

      <data>
         <import type="android.graphics.drawable.Drawable"/>
         <variable name="user" type="com.example.User"/>
         <variable name="image" type="Drawable"/>
         <variable name="note" type="String"/>
      </data>

   .. rubric:: ViewStubs
      :name: viewstubs

   Unlike normal views,
   `ViewStub <#>`__ objects start as
   invisible views. When they are made visible or are explicitly
   inflated, they replace themselves in the layout by inflating another
   layout.

   Because the ``ViewStub`` disappears from the view hierarchy, the view
   in the binding object must also disappear to let it be claimed by
   garbage collection. Because the views are final, a
   `ViewStubProxy <#>`__
   object takes the place of the ``ViewStub`` in the generated binding
   class, giving you access to the ``ViewStub`` when it exists and
   access to the inflated view hierarchy when the ``ViewStub`` is
   inflated.

   When inflating another layout, a binding must establish for the new
   layout. Therefore, the ``ViewStubProxy`` must listen to the
   ``ViewStub``
   `OnInflateListener <#>`__
   and establish the binding when required. Since only one listener can
   exist at a time, the ``ViewStubProxy`` lets you set an
   ``OnInflateListener``, which it calls after establishing the binding.

   .. rubric:: Immediate binding
      :name: immediate_binding

   When a variable or observable object changes, the binding is
   scheduled to change before the next frame. There are times, however,
   when binding must be executed immediately. To force execution, use
   the
   `executePendingBindings() <#executependingbindings>`__
   method.

   .. rubric:: Dynamic variables
      :name: dynamic_variables

   At times, the specific binding class is unknown. For example, a
   `RecyclerView.Adapter <#>`__
   operating against arbitrary layouts doesn't know the specific binding
   class. It must assign the binding value during the call to the
   `onBindViewHolder() <#onBindViewHolder>`__
   method.

   In the following example, all layouts that the ``RecyclerView`` binds
   to have an ``item`` variable. The ``BindingHolder`` object has a
   ``getBinding()`` method returning the
   `ViewDataBinding <#>`__
   base class.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onBindViewHolder(holder: BindingHolder, position: Int) {
                   item: T = items.get(position)
                   holder.binding.setVariable(BR.item, item);
                   holder.binding.executePendingBindings();
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public void onBindViewHolder(BindingHolder holder, int position) {
                   final T item = items.get(position);
                   holder.getBinding().setVariable(BR.item, item);
                   holder.getBinding().executePendingBindings();
               }

   **Note:**\  The Data Binding Library generates a class named ``BR``
   in the module package that contains the IDs of the resources used for
   data binding. In the preceding example, the library automatically
   generates the ``BR.item`` variable.

   .. rubric:: Background thread
      :name: background_thread

   You can change your data model in a background thread as long as it
   isn't a collection. Data binding localizes each variable or field
   during evaluation to avoid any concurrency issues.

   .. rubric:: Custom binding class names
      :name: custom_binding_class_names

   By default, a binding class is generated based on the name of the
   layout file, starting with an uppercase letter, removing underscores
   ( \_ ), capitalizing the following letter, and suffixing the word
   *Binding*. For example, the layout file ``contact_item.xml``
   generates the ``ContactItemBinding`` class. The class is placed in a
   ``databinding`` package under the module package. For example, if the
   module package is ``com.example.my.app``, then the binding class is
   placed in the ``com.example.my.app.databinding`` package.

   Binding classes can be renamed or placed in different packages by
   adjusting the ``class`` attribute of the ``data`` element. For
   example, the following layout generates the ``ContactItem`` binding
   class in the ``databinding`` package in the current module:

   .. code:: prettyprint

      <data class="ContactItem">
          ...
      </data>

   You can generate the binding class in a different package by
   prefixing the class name with a period. The following example
   generates the binding class in the module package:

   .. code:: prettyprint

      <data class=".ContactItem">
          ...
      </data>

   You can also use the full package name where you want the binding
   class to be generated. The following example creates the
   ``ContactItem`` binding class in the ``com.example`` package:

   .. code:: prettyprint

      <data class="com.example.ContactItem">
          ...
      </data>

   .. rubric:: Additional resources
      :name: resources

   To learn more about data binding, see the following additional
   resources.

   -  `Android Data Binding Library samples <https://github.com/android/databinding-samples>`__
   -  `Data Binding in Android <https://developers.google.cn/codelabs/codelabs/android-databinding>`__
   -  `Data Binding ‚Äî lessons learnt <https://medium.com/androiddevelopers/data-binding-lessons-learnt-4fd16576b719>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Layouts and binding expressions <#>`__
   -  `Data Binding Library <#>`__
   -  `View binding <#>`__

Last updated 2024-01-03 UTC.


/Binding adapters
=================

.. container:: devsite-article-body clearfix

   Binding adapters are responsible for making the appropriate framework
   calls to set values. One example is setting a property value, like
   calling the
   `setText() <#setText>`__
   method. Another example is setting an event listener, like calling
   the
   `setOnClickListener() <#setOnClickListener>`__
   method.

   The Data Binding Library lets you specify the method called to set a
   value, provide your own binding logic, and specify the type of the
   returned object by using adapters.

   .. rubric:: Set attribute values
      :name: set-attribute

   Whenever a bound value changes, the generated binding class must call
   a setter method on the view with the binding expression. You can let
   the Data Binding Library automatically determine the method, or you
   can explicitly declare the method or provide custom logic to select a
   method.

   .. rubric:: Automatic method selection
      :name: automatic-setting

   For an attribute named ``example``, the library automatically finds
   the method ``setExample(arg)`` that accepts compatible types as the
   argument. The namespace of the attribute isn't considered. Only the
   attribute name and type are used when searching for a method.

   For example, given the ``android:text="@{user.name}"`` expression,
   the library looks for a ``setText(arg)`` method that accepts the type
   returned by ``user.getName()``. If the return type of
   ``user.getName()`` is ``String``, the library looks for a
   ``setText()`` method that accepts a ``String`` argument. If the
   expression returns an ``int``, the library searches for a
   ``setText()`` method that accepts an ``int`` argument. The expression
   must return the correct type. You can cast the return value if
   necessary.

   Data binding works even if no attribute exists with the given name.
   You can create attributes for any setter by using data binding. For
   example, the support class
   `DrawerLayout <#>`__
   doesn't have attributes, but it has plenty of setters. The following
   layout automatically uses the
   `setScrimColor(int) <#setScrimColor>`__
   and
   `addDrawerListener(DrawerListener) <#addDrawerListener>`__
   methods as the setter for the ``app:scrimColor`` and
   ``app:drawerListener`` attributes, respectively:

   .. code:: prettyprint

      <androidx.drawerlayout.widget.DrawerLayout
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          app:scrimColor="@{@color/scrim}"
          app:drawerListener="@{fragment.drawerListener}">

   .. rubric:: Specify a custom method name
      :name: specify-method

   Some attributes have setters that don't match by name. In these
   situations, an attribute can be associated with the setter using the
   `BindingMethods <#>`__
   annotation. The annotation is used with a class and can contain
   multiple
   `BindingMethod <#>`__
   annotations, one for each renamed method. Binding methods are
   annotations that you can add to any class in your app.

   In the following example, the ``android:tint`` attribute is
   associated with the
   `setImageTintList(ColorStateList) <#setImageTintList>`__
   method‚Äînot with the ``setTint()`` method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @BindingMethods(value = [
                   BindingMethod(
                       type = android.widget.ImageView::class,
                       attribute = "android:tint",
                       method = "setImageTintList")])

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @BindingMethods({
                      @BindingMethod(type = "android.widget.ImageView",
                                     attribute = "android:tint",
                                     method = "setImageTintList"),
               })

   Typically, you don't need to rename setters in Android framework
   classes. The attributes are already implemented using the name
   convention to automatically find matching methods.

   .. rubric:: Provide custom logic
      :name: custom-logic

   Some attributes need custom binding logic. For example, there is no
   associated setter for the ``android:paddingLeft`` attribute. Instead,
   the ``setPadding(left, top, right, bottom)`` method is provided. A
   static binding adapter method with the
   `BindingAdapter <#>`__
   annotation lets you customize how a setter for an attribute is
   called.

   The attributes of the Android framework classes already have
   ``BindingAdapter`` annotations. The following example shows the
   binding adapter for the ``paddingLeft`` attribute:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @BindingAdapter("android:paddingLeft")
               fun setPaddingLeft(view: View, padding: Int) {
                   view.setPadding(padding,
                               view.getPaddingTop(),
                               view.getPaddingRight(),
                               view.getPaddingBottom())
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @BindingAdapter("android:paddingLeft")
               public static void setPaddingLeft(View view, int padding) {
                 view.setPadding(padding,
                                 view.getPaddingTop(),
                                 view.getPaddingRight(),
                                 view.getPaddingBottom());
               }

   The parameter types are important. The first parameter determines the
   type of the view that is associated with the attribute. The second
   parameter determines the type accepted in the binding expression for
   the given attribute.

   Binding adapters are also useful for other types of customization.
   For example, a custom loader can be called from a worker thread to
   load an image.

   You can also have adapters that receive multiple attributes, as shown
   in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @BindingAdapter("imageUrl", "error")
               fun loadImage(view: ImageView, url: String, error: Drawable) {
                   Picasso.get().load(url).error(error).into(view)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @BindingAdapter({"imageUrl", "error"})
               public static void loadImage(ImageView view, String url, Drawable error) {
                 Picasso.get().load(url).error(error).into(view);
               }

   You can use the adapter in your layout, as shown in the following
   example. Note that ``@drawable/venueError`` refers to a resource in
   your app. Surrounding the resource with ``@{}`` makes it a valid
   binding expression.

   .. code:: prettyprint

      <ImageView app:imageUrl="@{venue.imageUrl}" app:error="@{@drawable/venueError}" />

   **Note:**\  The Data Binding Library ignores custom namespaces for
   matching purposes.
   The adapter is called if ``imageUrl`` and ``error`` are used for an
   `ImageView <#>`__ object,
   ``imageUrl`` is a string, and ``error`` is a
   `Drawable <#>`__. If
   you want the adapter to be called when any of the attributes are set,
   set the optional
   `requireAll <#requireAll>`__
   flag of the adapter to ``false``, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @BindingAdapter(value = ["imageUrl", "placeholder"], requireAll = false)
               fun setImageUrl(imageView: ImageView, url: String?, placeHolder: Drawable?) {
                   if (url == null) {
                       imageView.setImageDrawable(placeholder);
                   } else {
                       MyImageLoader.loadInto(imageView, url, placeholder);
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @BindingAdapter(value={"imageUrl", "placeholder"}, requireAll=false)
               public static void setImageUrl(ImageView imageView, String url, Drawable placeHolder) {
                 if (url == null) {
                   imageView.setImageDrawable(placeholder);
                 } else {
                   MyImageLoader.loadInto(imageView, url, placeholder);
                 }
               }

   **Note:**\  Your binding adapters override the default data binding
   adapters when there is a conflict.
   Binding adapter methods can take the old values in their handlers. A
   method taking old and new values must declare all old values for the
   attributes first, followed by the new values, as shown in the
   following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @BindingAdapter("android:paddingLeft")
               fun setPaddingLeft(view: View, oldPadding: Int, newPadding: Int) {
                   if (oldPadding != newPadding) {
                       view.setPadding(newPadding,
                                   view.getPaddingTop(),
                                   view.getPaddingRight(),
                                   view.getPaddingBottom())
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @BindingAdapter("android:paddingLeft")
               public static void setPaddingLeft(View view, int oldPadding, int newPadding) {
                 if (oldPadding != newPadding) {
                     view.setPadding(newPadding,
                                     view.getPaddingTop(),
                                     view.getPaddingRight(),
                                     view.getPaddingBottom());
                  }
               }

   Event handlers can only be used with interfaces or abstract classes
   with one abstract method, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @BindingAdapter("android:onLayoutChange")
               fun setOnLayoutChangeListener(
                       view: View,
                       oldValue: View.OnLayoutChangeListener?,
                       newValue: View.OnLayoutChangeListener?
               ) {
                   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
                       if (oldValue != null) {
                           view.removeOnLayoutChangeListener(oldValue)
                       }
                       if (newValue != null) {
                           view.addOnLayoutChangeListener(newValue)
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @BindingAdapter("android:onLayoutChange")
               public static void setOnLayoutChangeListener(View view, View.OnLayoutChangeListener oldValue,
                      View.OnLayoutChangeListener newValue) {
                 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
                   if (oldValue != null) {
                     view.removeOnLayoutChangeListener(oldValue);
                   }
                   if (newValue != null) {
                     view.addOnLayoutChangeListener(newValue);
                   }
                 }
               }

   Use this event handler in your layout as follows:

   .. code:: prettyprint

      <View android:onLayoutChange="@{() -> handler.layoutChanged()}"/>

   When a listener has multiple methods, it must be split into multiple
   listeners. For example,
   `View.OnAttachStateChangeListener <#>`__
   has two methods:
   `onViewAttachedToWindow(View) <#onViewAttachedToWindow>`__
   and
   `onViewDetachedFromWindow(View) <#onViewDetachedFromWindow>`__.
   The library provides two interfaces to differentiate the attributes
   and handlers for them:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Translation from provided interfaces in Java:
               @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
               interface OnViewDetachedFromWindow {
                   fun onViewDetachedFromWindow(v: View)
               }

               @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
               interface OnViewAttachedToWindow {
                   fun onViewAttachedToWindow(v: View)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @TargetApi(VERSION_CODES.HONEYCOMB_MR1)
               public interface OnViewDetachedFromWindow {
                 void onViewDetachedFromWindow(View v);
               }

               @TargetApi(VERSION_CODES.HONEYCOMB_MR1)
               public interface OnViewAttachedToWindow {
                 void onViewAttachedToWindow(View v);
               }

   Because changing one listener can affect the other, you need an
   adapter that works for either attribute or for both. You can set
   ``requireAll`` to ``false`` in the annotation to specify that not
   every attribute must be assigned a binding expression, as shown in
   the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @BindingAdapter(
                       "android:onViewDetachedFromWindow",
                       "android:onViewAttachedToWindow",
                       requireAll = false
               )
               fun setListener(view: View, detach: OnViewDetachedFromWindow?, attach: OnViewAttachedToWindow?) {
                   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {
                       val newListener: View.OnAttachStateChangeListener?
                       newListener = if (detach == null && attach == null) {
                           null
                       } else {
                           object : View.OnAttachStateChangeListener {
                               override fun onViewAttachedToWindow(v: View) {
                                   attach.onViewAttachedToWindow(v)
                               }

                               override fun onViewDetachedFromWindow(v: View) {
                                   detach.onViewDetachedFromWindow(v)
                               }
                           }
                       }

                       val oldListener: View.OnAttachStateChangeListener? =
                               ListenerUtil.trackListener(view, newListener, R.id.onAttachStateChangeListener)
                       if (oldListener != null) {
                           view.removeOnAttachStateChangeListener(oldListener)
                       }
                       if (newListener != null) {
                           view.addOnAttachStateChangeListener(newListener)
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @BindingAdapter({"android:onViewDetachedFromWindow", "android:onViewAttachedToWindow"}, requireAll=false)
               public static void setListener(View view, OnViewDetachedFromWindow detach, OnViewAttachedToWindow attach) {
                   if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB_MR1) {
                       OnAttachStateChangeListener newListener;
                       if (detach == null && attach == null) {
                           newListener = null;
                       } else {
                           newListener = new OnAttachStateChangeListener() {
                               @Override
                               public void onViewAttachedToWindow(View v) {
                                   if (attach != null) {
                                       attach.onViewAttachedToWindow(v);
                                   }
                               }
                               @Override
                               public void onViewDetachedFromWindow(View v) {
                                   if (detach != null) {
                                       detach.onViewDetachedFromWindow(v);
                                   }
                               }
                           };
                       }

                       OnAttachStateChangeListener oldListener = ListenerUtil.trackListener(view, newListener,
                               R.id.onAttachStateChangeListener);
                       if (oldListener != null) {
                           view.removeOnAttachStateChangeListener(oldListener);
                       }
                       if (newListener != null) {
                           view.addOnAttachStateChangeListener(newListener);
                       }
                   }
               }

   The above example is slightly complicated because the
   `View <#>`__ class uses the
   `addOnAttachStateChangeListener() <#addOnAttachStateChangeListener>`__
   and
   `removeOnAttachStateChangeListener() <#removeOnAttachStateChangeListener>`__
   methods instead of a setter method for
   `OnAttachStateChangeListener <#>`__.
   The ``android.databinding.adapters.ListenerUtil`` class helps keep
   track of these listeners so that they can be removed in the binding
   adapter.

   .. rubric:: Object conversions
      :name: object-conversions

   .. rubric:: Automatic object conversion
      :name: automatic-conversion

   When an `Object <#>`__ is returned from
   a binding expression, the library selects the method used to set the
   value of the property. The ``Object`` is cast to a parameter type of
   the chosen method. This behavior is convenient in apps using the
   `ObservableMap <#>`__
   class to store data, as shown in the following example:

   .. code:: prettyprint

      <TextView
         android:text='@{userMap["lastName"]}'
         android:layout_width="wrap_content"
         android:layout_height="wrap_content" />

   **Note:**\  You can also refer to a value in the map using the
   ``object.key`` notation. For example, you can replace
   ``@{userMap["lastName"]}`` in the previous example with
   ``@{userMap.lastName}``.
   The ``userMap`` object in the expression returns a value, which is
   automatically cast to the parameter type found in the
   ``setText(CharSequence)`` method used to set the value of the
   ``android:text`` attribute. If the parameter type is ambiguous, cast
   the return type in the expression.

   .. rubric:: Custom conversions
      :name: custom-conversions

   In some situations, a custom conversion is required between specific
   types. For example, the ``android:background`` attribute of a view
   expects a ``Drawable``, but the ``color`` value specified is an
   integer. The following example shows an attribute that expects a
   ``Drawable``, but an integer is provided instead:

   .. code:: prettyprint

      <View
         android:background="@{isError ? @color/red : @color/white}"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"/>

   Whenever a ``Drawable`` is expected and an integer is returned,
   convert the ``int`` to a
   `ColorDrawable <#>`__.
   To perform the conversion, use a static method with a
   `BindingConversion <#>`__
   annotation, as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @BindingConversion
               fun convertColorToDrawable(color: Int) = ColorDrawable(color)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @BindingConversion
               public static ColorDrawable convertColorToDrawable(int color) {
                   return new ColorDrawable(color);
               }

   However, the value types provided in the binding expression must be
   consistent. You can't use different types in the same expression, as
   shown in the following example:

   .. code:: prettyprint

      // The @drawable and @color represent different value types in the same
      // expression, which causes a build error.
      <View
         android:background="@{isError ? @drawable/error : @color/white}"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"/>

   .. container:: section dac-section dac-small

      .. container:: wrap

         .. rubric:: Additional resources
            :name: additional-resources

         To learn more about data binding, see the following resources.

         .. rubric:: Samples
            :name: samples

         -  `Android Data Binding Library samples <https://github.com/android/databinding-samples>`__

         .. rubric:: Codelabs
            :name: codelabs

         -  `Data Binding in Android <https://developers.google.cn/codelabs/codelabs/android-databinding>`__

         .. rubric:: Blog posts
            :name: blog-posts

         -  `Data Binding ‚Äî lessons learnt <https://medium.com/androiddevelopers/data-binding-lessons-learnt-4fd16576b719>`__

         .. rubric:: Recommended for you
            :name: recommended_for_you

         -  Note: link text is displayed when JavaScript is off
         -  `Data Binding Library <#>`__
         -  `Layouts and binding expressions <#>`__
         -  `View binding <#>`__

      Content and code samples on this page are subject to the licenses
      described in the `Content License <#>`__. Java and OpenJDK
      are trademarks or registered trademarks of Oracle and/or its
      affiliates.

      Last updated 2024-03-06 UTC.



/Bind layout views to Architecture Components
=============================================

.. container:: devsite-article-body clearfix

   The AndroidX library includes the 
   `Architecture Components <#>`__, which you 
   can use to design robust, testable, and maintainable apps. The Data Binding
   Library works seamlessly with the Architecture Components to further
   simplify the development of your UI. The layouts in your app can bind
   to the data in the Architecture Components, which help you manage the
   UI controller's lifecycle and notify the UI about changes in the
   data.

   This page shows how to incorporate the Architecture Components into
   your app to get the most from using the Data Binding Library.

   .. rubric:: Use LiveData to notify the UI about data changes
      :name: livedata

   You can use `LiveData <#>`__
   objects as the data binding source to automatically notify the UI
   about changes in the data. For more information about this
   Architecture Component, see the 
   `LiveData overview <#>`__.

   Unlike objects that implement
   `Observable <#>`__‚Äîsuch
   as `observable fields <#observable_fields>`__‚Äî``LiveData``
   objects know about the lifecycle of the observers subscribed to the
   data changes. This knowledge enables many benefits, which are
   explained in `The advantages of using LiveData <#the_advantages_of_using_livedata>`__.
   In Android Studio version 3.1 and higher, you can replace observable
   fields with ``LiveData`` objects in your data binding code.

   To use a ``LiveData`` object with your binding class, you need to
   specify a lifecycle owner to define the scope of the ``LiveData``
   object. The following example specifies the activity as the lifecycle
   owner after the binding class has been instantiated:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ViewModelActivity : AppCompatActivity() {
                   override fun onCreate(savedInstanceState: Bundle?) {
                       // Inflate view and obtain an instance of the binding class.
                       val binding: UserBinding = DataBindingUtil.setContentView(this, R.layout.user)

                       // Specify the current activity as the lifecycle owner.
                       binding.setLifecycleOwner(this)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class ViewModelActivity extends AppCompatActivity {
                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       // Inflate view and obtain an instance of the binding class.
                       UserBinding binding = DataBindingUtil.setContentView(this, R.layout.user);

                       // Specify the current activity as the lifecycle owner.
                       binding.setLifecycleOwner(this);
                   }
               }

   You can use a
   `ViewModel <#>`__
   component, as explained in the following section, to bind the data to
   the layout. In the ``ViewModel`` component, you can use the
   ``LiveData`` object to transform the data or merge multiple data
   sources. The following example shows how to transform the data in the
   ``ViewModel``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ScheduleViewModel : ViewModel() {
                   val userName: LiveData

                   init {
                       val result = Repository.userName
                       userName = Transformations.map(result) { result -> result.value }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class ScheduleViewModel extends ViewModel {
                   LiveData username;

                   public ScheduleViewModel() {
                       String result = Repository.userName;
                       userName = Transformations.map(result, result -> result.value);
                   }
               }

   .. rubric:: Use ViewModel to manage UI-related data
      :name: viewmodel

   The Data Binding Library works seamlessly with
   `ViewModel <#>`__
   components. The ``ViewModel`` exposes the data that the layout
   observes and reacts to its changes. Using ``ViewModel`` components
   with the Data Binding Library lets you move UI logic out of the
   layouts and into the components, which are easier to test. The Data
   Binding Library ensures the views are bound and unbound from the data
   source when needed. Most of the remaining work consists of making
   sure that you're exposing the correct data. For more information
   about this Architecture Component, see the `ViewModel overview <#>`__.

   To use the ``ViewModel`` component with the Data Binding Library, you
   must instantiate your component‚Äîwhich inherits from the ``ViewModel``
   class, obtain an instance of your binding class, and assign your
   ``ViewModel`` component to a property in the binding class. The
   following example shows how to use the component with the library:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ViewModelActivity : AppCompatActivity() {
                   override fun onCreate(savedInstanceState: Bundle?) {
                       // Obtain the ViewModel component.
                       val userModel: UserModel by viewModels()

                       // Inflate view and obtain an instance of the binding class.
                       val binding: UserBinding = DataBindingUtil.setContentView(this, R.layout.user)

                       // Assign the component to a property in the binding class.
                       binding.viewmodel = userModel
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class ViewModelActivity extends AppCompatActivity {
                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       // Obtain the ViewModel component.
                       UserModel userModel = new ViewModelProvider(this).get(UserModel.class);

                       // Inflate view and obtain an instance of the binding class.
                       UserBinding binding = DataBindingUtil.setContentView(this, R.layout.user);

                       // Assign the component to a property in the binding class.
                       binding.viewmodel = userModel;
                   }
               }

   In your layout, assign the properties and methods of your
   ``ViewModel`` component to the corresponding views using binding
   expressions, as shown in the following example:

   .. code:: prettyprint

      <CheckBox
          android:id="@+id/rememberMeCheckBox"
          android:checked="@{viewmodel.rememberMe}"
          android:onCheckedChanged="@{() -> viewmodel.rememberMeChanged()}" />

   .. rubric:: Use an Observable ViewModel for more control over binding
      adapters
      :name: observable-viewmodel

   You can use a
   `ViewModel <#>`__ component
   that implements the
   `Observable <#>`__
   interface to notify other app components about changes in the data,
   similar to how you would use a
   `LiveData <#>`__ object.

   There are situations where you might prefer to use a ``ViewModel``
   component that implements the ``Observable`` interface over using
   ``LiveData`` objects, even if you lose the lifecycle management
   capabilities of ``LiveData``. Using a ``ViewModel`` component that
   implements ``Observable`` gives you more control over the binding
   adapters in your app. For example, this pattern gives you more
   control over the notifications when data changes; it also lets you
   specify a custom method to set the value of an attribute in two-way
   data binding.

   To implement an observable ``ViewModel`` component, you must create a
   class that inherits from the ``ViewModel`` class and implements the
   ``Observable`` interface. You can provide custom logic when an
   observer subscribes or unsubscribes to notifications using the
   `addOnPropertyChangedCallback() <#addOnPropertyChangedCallback>`__
   and
   `removeOnPropertyChangedCallback() <#removeOnPropertyChangedCallback>`__
   methods. You can also provide custom logic that runs when properties
   change in the
   `notifyPropertyChanged() <#notifyPropertyChanged>`__
   method. The following code example shows how to implement an
   observable ``ViewModel``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               /**
                * A ViewModel that is also an Observable,
                * to be used with the Data Binding Library.
                */
               open class ObservableViewModel : ViewModel(), Observable {
                   private val callbacks: PropertyChangeRegistry = PropertyChangeRegistry()

                   override fun addOnPropertyChangedCallback(
                           callback: Observable.OnPropertyChangedCallback) {
                       callbacks.add(callback)
                   }

                   override fun removeOnPropertyChangedCallback(
                           callback: Observable.OnPropertyChangedCallback) {
                       callbacks.remove(callback)
                   }

                   /**
                    * Notifies observers that all properties of this instance have changed.
                    */
                   fun notifyChange() {
                       callbacks.notifyCallbacks(this, 0, null)
                   }

                   /**
                    * Notifies observers that a specific property has changed. The getter for the
                    * property that changes must be marked with the @Bindable annotation to
                    * generate a field in the BR class to be used as the fieldId parameter.
                    *
                    * @param fieldId The generated BR id for the Bindable field.
                    */
                   fun notifyPropertyChanged(fieldId: Int) {
                       callbacks.notifyCallbacks(this, fieldId, null)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               /**
                * A ViewModel that is also an Observable,
                * to be used with the Data Binding Library.
                */
               class ObservableViewModel extends ViewModel implements Observable {
                   private PropertyChangeRegistry callbacks = new PropertyChangeRegistry();

                   @Override
                   protected void addOnPropertyChangedCallback(
                           Observable.OnPropertyChangedCallback callback) {
                       callbacks.add(callback);
                   }

                   @Override
                   protected void removeOnPropertyChangedCallback(
                           Observable.OnPropertyChangedCallback callback) {
                       callbacks.remove(callback);
                   }

                   /**
                    * Notifies observers that all properties of this instance have changed.
                    */
                   void notifyChange() {
                       callbacks.notifyCallbacks(this, 0, null);
                   }

                   /**
                    * Notifies observers that a specific property has changed. The getter for the
                    * property that changes must be marked with the @Bindable annotation to
                    * generate a field in the BR class to be used as the fieldId parameter.
                    *
                    * @param fieldId The generated BR id for the Bindable field.
                    */
                   void notifyPropertyChanged(int fieldId) {
                       callbacks.notifyCallbacks(this, fieldId, null);
                   }
               }

   .. container:: section dac-section dac-small

      .. container:: wrap

         .. rubric:: Additional resources
            :name: additional-resources

         To learn more about data binding, consult the following
         additional resources.

         -  `Android Data Binding Library samples <https://github.com/android/databinding-samples>`__

         -  `Data Binding in Android codelab <https://developers.google.cn/codelabs/codelabs/android-databinding>`__

         -  `Data Binding‚Ää‚Äî‚Äälessons learnt <https://medium.com/androiddevelopers/data-binding-lessons-learnt-4fd16576b719>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Work with observable data objects <#>`__
   -  `Load and display paged data <#>`__
   -  `Use Kotlin coroutines with lifecycle-aware components <#>`__

Last updated 2024-01-03 UTC.



/Two-way data binding
=====================

.. container:: devsite-article-body clearfix

   Using one-way data binding, you can set a value on an attribute and
   set a listener that reacts to a change in that attribute:

   .. code:: prettyprint

      <CheckBox
          android:id="@+id/rememberMeCheckBox"
          android:checked="@{viewmodel.rememberMe}"
          android:onCheckedChanged="@{viewmodel.rememberMeChanged}"
      />

   Two-way data binding provides a shortcut to this process:

   .. code:: prettyprint

      <CheckBox
          android:id="@+id/rememberMeCheckBox"
          android:checked="@={viewmodel.rememberMe}"
      />

   The ``@={}`` notation, which importantly includes the "=" sign,
   receives data changes to the property and listen to user updates at
   the same time.

   In order to react to changes in the backing data, you can make your
   layout variable an implementation of ``Observable``, usually
   `BaseObservable <#>`__,
   and use a
   `@Bindable <#>`__
   annotation, as shown in the following code snippet:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class LoginViewModel : BaseObservable {
                   // val data = ...

                   @Bindable
                   fun getRememberMe(): Boolean {
                       return data.rememberMe
                   }

                   fun setRememberMe(value: Boolean) {
                       // Avoids infinite loops.
                       if (data.rememberMe != value) {
                           data.rememberMe = value

                           // React to the change.
                           saveData()

                           // Notify observers of a new value.
                           notifyPropertyChanged(BR.remember_me)
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class LoginViewModel extends BaseObservable {
                   // private Model data = ...

                   @Bindable
                   public Boolean getRememberMe() {
                       return data.rememberMe;
                   }

                   public void setRememberMe(Boolean value) {
                       // Avoids infinite loops.
                       if (data.rememberMe != value) {
                           data.rememberMe = value;

                           // React to the change.
                           saveData();

                           // Notify observers of a new value.
                           notifyPropertyChanged(BR.remember_me);
                       }
                   }
               }

   Because the bindable property's getter method is called
   ``getRememberMe()``, the property's corresponding setter method
   automatically uses the name ``setRememberMe()``.

   For more information on using ``BaseObservable`` and ``@Bindable``,
   see `Work with observable data objects <#>`__.

   .. rubric:: Two-way data binding using custom attributes
      :name: two-way-custom-attrs

   The platform provides two-way data binding implementations for `the most common two-way attributes <#two-way-attributes>`__ and change
   listeners, which you can use as part of your app. If you want to use
   two-way data binding with custom attributes, you need to work with
   the
   `@InverseBindingAdapter <#>`__
   and
   `@InverseBindingMethod <#>`__
   annotations.

   For example, if you want to enable two-way data binding on a
   ``"time"`` attribute in a custom view called ``MyView``, complete the
   following steps:

   #. Annotate the method that sets the initial value and updates when
      the value changes using ``@BindingAdapter``:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  @BindingAdapter("time")
                  @JvmStatic fun setTime(view: MyView, newValue: Time) {
                      // Important to break potential infinite loops.
                      if (view.time != newValue) {
                          view.time = newValue
                      }
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  @BindingAdapter("time")
                  public static void setTime(MyView view, Time newValue) {
                      // Important to break potential infinite loops.
                      if (view.time != newValue) {
                          view.time = newValue;
                      }
                  }

   #. Annotate the method that reads the value from the view using
      ``@InverseBindingAdapter``:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  @InverseBindingAdapter("time")
                  @JvmStatic fun getTime(view: MyView) : Time {
                      return view.getTime()
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  @InverseBindingAdapter("time")
                  public static Time getTime(MyView view) {
                      return view.getTime();
                  }

   At this point, data binding knows what to do when the data changes
   (it calls the method annotated with
   `@BindingAdapter <#>`__)
   and what to call when the view attribute changes (it calls the
   `InverseBindingListener <#>`__).
   However, it doesn't know when or how the attribute changes.

   For that, you need to set a listener on the view. It can be a custom
   listener associated with your custom view, or it can be a generic
   event, such as a loss of focus or a text change. Add the
   ``@BindingAdapter`` annotation to the method that sets the listener
   for changes on the property:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @BindingAdapter("app:timeAttrChanged")
               @JvmStatic fun setListeners(
                       view: MyView,
                       attrChange: InverseBindingListener
               ) {
                   // Set a listener for click, focus, touch, etc.
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @BindingAdapter("app:timeAttrChanged")
               public static void setListeners(
                       MyView view, final InverseBindingListener attrChange) {
                   // Set a listener for click, focus, touch, etc.
               }

   The listener includes an ``InverseBindingListener`` as a parameter.
   You use the ``InverseBindingListener`` to tell the data binding
   system that the attribute has changed. The system can then start
   calling the method annotated using ``@InverseBindingAdapter``, and so
   on.

   **Note:**\  Every two-way binding generates a *synthetic event
   attribute*. This attribute has the same name as the base attribute,
   but it includes the suffix ``"AttrChanged"``. The synthetic event
   attribute allows the library to create a method annotated using
   ``@BindingAdapter`` to associate the event listener to the
   appropriate instance of ``View``.
   In practice, this listener includes some non-trivial logic, including
   listeners for one-way data binding. For an example, see the adapter
   for the text attribute change,
   `TextViewBindingAdapter <https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/TextViewBindingAdapter.java#352>`__.

   .. rubric:: Converters
      :name: converters

   If the variable that's bound to a
   `View <#>`__ object needs to be
   formatted, translated, or changed somehow before being displayed,
   it's possible to use a ``Converter`` object.

   For example, take an ``EditText`` object that shows a date:

   .. code:: prettyprint

      <EditText
          android:id="@+id/birth_date"
          android:text="@={Converter.dateToString(viewmodel.birthDate)}"
      />

   The ``viewmodel.birthDate`` attribute contains a value of type
   ``Long``, so it needs to be formatted by using a converter.

   Because a two-way expression is being used, there also needs to be an
   *inverse converter* to let the library know how to convert the
   user-provided string back to the backing data type, in this case
   ``Long``. This process is done by adding the
   `@InverseMethod <#>`__
   annotation to one of the converters and have this annotation
   reference the inverse converter. An example of this configuration
   appears in the following code snippet:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               object Converter {
                   @InverseMethod("stringToDate")
                   @JvmStatic fun dateToString(
                       view: EditText, oldValue: Long,
                       value: Long
                   ): String {
                       // Converts long to String.
                   }

                   @JvmStatic fun stringToDate(
                       view: EditText, oldValue: String,
                       value: String
                   ): Long {
                       // Converts String to long.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class Converter {
                   @InverseMethod("stringToDate")
                   public static String dateToString(EditText view, long oldValue,
                           long value) {
                       // Converts long to String.
                   }

                   public static long stringToDate(EditText view, String oldValue,
                           String value) {
                       // Converts String to long.
                   }
               }

   .. rubric:: Infinite loops using two-way data binding
      :name: infinite-loops

   Be careful not to introduce infinite loops when using two-way data
   binding. When the user changes an attribute, the method annotated
   using ``@InverseBindingAdapter`` is called, and the value is assigned
   to the backing property. This, in turn, would call the method
   annotated using ``@BindingAdapter``, which would trigger another call
   to the method annotated using ``@InverseBindingAdapter``, and so on.

   For this reason, it's important to break possible infinite loops by
   comparing new and old values in the methods annotated using
   ``@BindingAdapter``.

   .. rubric:: Two-way attributes
      :name: two-way-attributes

   The platform provides built-in support for two-way data binding when
   you use the attributes in the following table. For details on how the
   platform provides this support, see the implementations for the
   corresponding binding adapters:

   .. list-table::
      :widths: 24 24 24
      :header-rows: 1

      - 

         - Class
         - Attribute(s)
         - Binding adapter
      - 

         - `AdapterView <#>`__
         - ``android:selectedItemPosition``
            ``android:selection``
         - `AdapterViewBindingAdapter <https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/AdapterViewBindingAdapter.java>`__
      - 

         - `CalendarView <#>`__
         - ``android:date``
         - `CalendarViewBindingAdapter <https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/CalendarViewBindingAdapter.java>`__
      - 

         - `CompoundButton <#>`__
         - `android:checked <#checked>`__
         - `CompoundButtonBindingAdapter <https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/CompoundButtonBindingAdapter.java>`__
      - 

         - `DatePicker <#>`__
         - ``android:year``
            ``android:month``
            ``android:day``
         - `DatePickerBindingAdapter <https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/DatePickerBindingAdapter.java>`__
      - 

         - `NumberPicker <#>`__
         - `android:value <#value>`__
         - `NumberPickerBindingAdapter <https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/NumberPickerBindingAdapter.java>`__
      - 

         - `RadioButton <#>`__
         - `android:checkedButton <#checkedButton>`__
         - `RadioGroupBindingAdapter <https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/RadioGroupBindingAdapter.java>`__
      - 

         - `RatingBar <#>`__
         - `android:rating <#rating>`__
         - `RatingBarBindingAdapter <https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/RatingBarBindingAdapter.java>`__
      - 

         - `SeekBar <#>`__
         - `android:progress <#progress>`__
         - `SeekBarBindingAdapter <https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/SeekBarBindingAdapter.java>`__
      - 

         - `TabHost <#>`__
         - ``android:currentTab``
         - `TabHostBindingAdapter <https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/TabHostBindingAdapter.java>`__
      - 

         - `TextView <#>`__
         - `android:text <#text>`__
         - `TextViewBindingAdapter <https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/TextViewBindingAdapter.java>`__
      - 

         - `TimePicker <#>`__
         - ``android:hour``
            ``android:minute``
         - `TimePickerBindingAdapter <https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/TimePickerBindingAdapter.java>`__

   .. container:: section dac-section dac-small

      .. container:: wrap

         .. rubric:: Additional resources
            :name: additional-resources

         To learn more about data binding, consult the following
         additional resources.

         .. rubric:: Samples
            :name: samples

         -  `Android Data Binding Library samples <https://github.com/android/databinding-samples>`__

         .. rubric:: Codelabs
            :name: codelabs

         -  `Android Data Binding codelab <https://developers.google.cn/codelabs/codelabs/android-databinding>`__

         .. rubric:: Blog posts
            :name: blog-posts

         -  `Data Binding ‚Äî Lessons Learnt <https://medium.com/androiddevelopers/data-binding-lessons-learnt-4fd16576b719>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Work with observable data objects <#>`__
   -  `Layouts and binding expressions <#>`__
   -  `Bind layout views to Architecture Components <#>`__

Last updated 2024-01-03 UTC.



.. _using:

/Overview: Handling Lifecycles with Lifecycle-Aware Components Part of `Android Jetpack`
========================================================================================

.. https://developer.android.google.cn/topic/libraries/architecture/lifecycle

Lifecycle-aware components perform actions in response to a change in
the lifecycle status of another component, such as activities and
fragments. These components help you produce better-organized, and often
lighter-weight code, that is easier to maintain.

A common pattern is to implement the actions of the dependent components
in the lifecycle methods of activities and fragments. However, this
pattern leads to a poor organization of the code and to the
proliferation of errors. By using lifecycle-aware components, you can
move the code of dependent components out of the lifecycle methods and
into the components themselves.

The `androidx.lifecycle <#>`__ 
package provides classes and interfaces that let you build
*lifecycle-aware* components‚Äîwhich are components that can automatically
adjust their behavior based on the current lifecycle state of an
activity or fragment.

**Note:**\  To import
`androidx.lifecycle <#>`__
into your Android project, see the instructions for declaring
dependencies in the `Lifecycle release notes <#declaring_dependencies>`__.

Most of the app components that are defined in the Android Framework
have lifecycles attached to them. Lifecycles are managed by the
operating system or the framework code running in your process. They are
core to how Android works and your application must respect them. Not
doing so may trigger memory leaks or even application crashes.

Imagine we have an activity that shows the device location on the
screen. A common implementation might be like the following:

.. container::

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            internal class MyLocationListener(
                    private val context: Context,
                    private val callback: (Location) -> Unit
            ) {

                fun start() {
                    // connect to system location service
                }

                fun stop() {
                    // disconnect from system location service
                }
            }

            class MyActivity : AppCompatActivity() {
                private lateinit var myLocationListener: MyLocationListener

                override fun onCreate(...) {
                    myLocationListener = MyLocationListener(this) { location ->
                        // update UI
                    }
                }

                public override fun onStart() {
                    super.onStart()
                    myLocationListener.start()
                    // manage other components that need to respond
                    // to the activity lifecycle
                }

                public override fun onStop() {
                    super.onStop()
                    myLocationListener.stop()
                    // manage other components that need to respond
                    // to the activity lifecycle
                }
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            class MyLocationListener {
                public MyLocationListener(Context context, Callback callback) {
                    // ...
                }

                void start() {
                    // connect to system location service
                }

                void stop() {
                    // disconnect from system location service
                }
            }

            class MyActivity extends AppCompatActivity {
                private MyLocationListener myLocationListener;

                @Override
                public void onCreate(...) {
                    myLocationListener = new MyLocationListener(this, (location) -> {
                        // update UI
                    });
                }

                @Override
                public void onStart() {
                    super.onStart();
                    myLocationListener.start();
                    // manage other components that need to respond
                    // to the activity lifecycle
                }

                @Override
                public void onStop() {
                    super.onStop();
                    myLocationListener.stop();
                    // manage other components that need to respond
                    // to the activity lifecycle
                }
            }

Even though this sample looks fine, in a real app, you end up having too
many calls that manage the UI and other components in response to the
current state of the lifecycle. Managing multiple components places a
considerable amount of code in lifecycle methods, such as
`onStart() <#onStart>`__ and
`onStop() <#onStop>`__, which makes
them difficult to maintain.

Moreover, there's no guarantee that the component starts before the
activity or fragment is stopped. This is especially true if we need to
perform a long-running operation, such as some configuration check in
`onStart() <#onStart>`__. This can
cause a race condition where the
`onStop() <#onStop>`__ method
finishes before the
`onStart() <#onStart>`__, keeping
the component alive longer than it's needed.

.. container::

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            class MyActivity : AppCompatActivity() {
                private lateinit var myLocationListener: MyLocationListener

                override fun onCreate(...) {
                    myLocationListener = MyLocationListener(this) { location ->
                        // update UI
                    }
                }

                public override fun onStart() {
                    super.onStart()
                    Util.checkUserStatus { result ->
                        // what if this callback is invoked AFTER activity is stopped?
                        if (result) {
                            myLocationListener.start()
                        }
                    }
                }

                public override fun onStop() {
                    super.onStop()
                    myLocationListener.stop()
                }

            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            class MyActivity extends AppCompatActivity {
                private MyLocationListener myLocationListener;

                public void onCreate(...) {
                    myLocationListener = new MyLocationListener(this, location -> {
                        // update UI
                    });
                }

                @Override
                public void onStart() {
                    super.onStart();
                    Util.checkUserStatus(result -> {
                        // what if this callback is invoked AFTER activity is stopped?
                        if (result) {
                            myLocationListener.start();
                        }
                    });
                }

                @Override
                public void onStop() {
                    super.onStop();
                    myLocationListener.stop();
                }
            }

The `androidx.lifecycle <#>`__ 
package provides classes and interfaces that help you tackle these
problems in a resilient and isolated way.

.. _lc:

Lifecycle
---------

`Lifecycle <#>`__ is a class
that holds the information about the lifecycle state of a component
(like an activity or a fragment) and allows other objects to observe
this state.

`Lifecycle <#>`__ uses two
main enumerations to track the lifecycle status for its associated
component:

Event 
   The lifecycle events that are dispatched from the framework and the
   `Lifecycle <#>`__ class.
   These events map to the callback events in activities and fragments.
State 
   The current state of the component tracked by the
   `Lifecycle <#>`__ object.

.. container::

     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ Initialize ‚îÇ ‚îÇ Destoryed ‚îÇ  ‚îÇ Created ‚îÇ   ‚îÇ Started ‚îÇ     ‚îÇ Resumed ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ  onCreate   ‚îÇ             ‚îÇ             ‚îÇ               ‚îÇ    
            ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> ‚îÇ             ‚îÇ               ‚îÇ    
            ‚îÇ             ‚îÇ             ‚îÇ   onStart   ‚îÇ               ‚îÇ    
            ‚îÇ             ‚îÇ             ‚îÇ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ > ‚îÇ               ‚îÇ    
            ‚îÇ             ‚îÇ             ‚îÇ             ‚îÇ   onResume    ‚îÇ    
            ‚îÇ             ‚îÇ             ‚îÇ             ‚îÇ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ>‚îÇ    
            ‚îÇ             ‚îÇ             ‚îÇ             ‚îÇ    onPause    ‚îÇ    
            ‚îÇ             ‚îÇ             ‚îÇ             ‚îÇ<‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÇ    
            ‚îÇ             ‚îÇ             ‚îÇ    onStop   ‚îÇ               ‚îÇ    
            ‚îÇ             ‚îÇ             ‚îÇ<‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÇ               ‚îÇ    
            ‚îÇ             ‚îÇ oonDestroy  ‚îÇ             ‚îÇ               ‚îÇ    
            ‚îÇ             ‚îÇ<‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÇ             ‚îÇ               ‚îÇ    
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ Initialize ‚îÇ ‚îÇ Destoryed ‚îÇ  ‚îÇ Created ‚îÇ   ‚îÇ Started ‚îÇ     ‚îÇ Resumed ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

   @startuml
   participant Initialize
   participant Destoryed
   Initialize -> Created: onCreate
   Created --> Started: onStart
   Started --> Resumed: onResume
   Resumed --> Started: onPause
   Started --> Created: onStop
   Created --> Destoryed: onDestroy
   @enduml

   .. .. figure::
      https://developer.android.google.cn/static/images/topic/libraries/architecture/lifecycle-states.svg
      :alt: Diagram of lifecycle states
      :figclass: screenshot

   **Figure 1.** States and events that comprise the Android activity
   lifecycle

Think of the states as nodes of a graph and events as the edges between
these nodes.

A class can monitor the component's lifecycle status by implementing
`DefaultLifecycleObserver <#>`__
and overriding corresponding methods such as ``onCreate``, ``onStart``,
etc. Then you can add an observer by calling the
`addObserver() <#addObserver>`__ method of the
`Lifecycle <#>`__ class and
passing an instance of your observer, as shown in the following example:

.. container::

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            class MyObserver : DefaultLifecycleObserver {
                override fun onResume(owner: LifecycleOwner) {
                    connect()
                }

                override fun onPause(owner: LifecycleOwner) {
                    disconnect()
                }
            }

            myLifecycleOwner.getLifecycle().addObserver(MyObserver())

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            public class MyObserver implements DefaultLifecycleObserver {
                @Override
                public void onResume(LifecycleOwner owner) {
                    connect()
                }

                @Override
                public void onPause(LifecycleOwner owner) {
                    disconnect()
                }
            }

            myLifecycleOwner.getLifecycle().addObserver(new MyObserver());

In the example above, the ``myLifecycleOwner`` object implements the
`LifecycleOwner <#>`__
interface, which is explained in the following section.

.. _lco:

LifecycleOwner
--------------

`LifecycleOwner <#>`__ is
a single method interface that denotes that the class has a
`Lifecycle <#>`__. It has one
method,
`getLifecycle() <#getLifecycle>`__,
which must be implemented by the class. If you're trying to manage the
lifecycle of a whole application process instead, see
`ProcessLifecycleOwner <#>`__.

This interface abstracts the ownership of a 
`Lifecycle <#>`__ from
individual classes, such as
`Fragment <#>`__ and
`AppCompatActivity <#>`__,
and allows writing components that work with them. Any custom
application class can implement the
`LifecycleOwner <#>`__
interface.

Components that implement 
`DefaultLifecycleObserver <#>`__
work seamlessly with components that implement
`LifecycleOwner <#>`__
because an owner can provide a lifecycle, which an observer can register
to watch.

For the location tracking example, we can make the 
``MyLocationListener`` class implement
`DefaultLifecycleObserver <#>`__
and then initialize it with the activity's
`Lifecycle <#>`__ in the
`onCreate() <#onCreate>`__
method. This allows the ``MyLocationListener`` class to be
self-sufficient, meaning that the logic to react to changes in lifecycle
status is declared in ``MyLocationListener`` instead of the activity.
Having the individual components store their own logic makes the
activities and fragments logic easier to manage.

.. container::

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            class MyActivity : AppCompatActivity() {
                private lateinit var myLocationListener: MyLocationListener

                override fun onCreate(...) {
                    myLocationListener = MyLocationListener(this, lifecycle) { location ->
                        // update UI
                    }
                    Util.checkUserStatus { result ->
                        if (result) {
                            myLocationListener.enable()
                        }
                    }
                }
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            class MyActivity extends AppCompatActivity {
                private MyLocationListener myLocationListener;

                public void onCreate(...) {
                    myLocationListener = new MyLocationListener(this, getLifecycle(), location -> {
                        // update UI
                    });
                    Util.checkUserStatus(result -> {
                        if (result) {
                            myLocationListener.enable();
                        }
                    });
              }
            }

A common use case is to avoid invoking certain callbacks if the
`Lifecycle <#>`__ isn't in a
good state right now. For example, if the callback runs a fragment
transaction after the activity state is saved, it would trigger a crash,
so we would never want to invoke that callback.

To make this use case easy, the 
`Lifecycle <#>`__ class allows
other objects to query the current state.

.. container::

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            internal class MyLocationListener(
                    private val context: Context,
                    private val lifecycle: Lifecycle,
                    private val callback: (Location) -> Unit
            ): DefaultLifecycleObserver {

                private var enabled = false

                override fun onStart(owner: LifecycleOwner) {
                    if (enabled) {
                        // connect
                    }
                }

                fun enable() {
                    enabled = true
                    if (lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) {
                        // connect if not connected
                    }
                }

                override fun onStop(owner: LifecycleOwner) {
                    // disconnect if connected
                }
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            class MyLocationListener implements DefaultLifecycleObserver {
                private boolean enabled = false;
                public MyLocationListener(Context context, Lifecycle lifecycle, Callback callback) {
                   ...
                }

                @Override
                public void onStart(LifecycleOwner owner) {
                    if (enabled) {
                       // connect
                    }
                }

                public void enable() {
                    enabled = true;
                    if (lifecycle.getCurrentState().isAtLeast(STARTED)) {
                        // connect if not connected
                    }
                }

                @Override
                public void onStop(LifecycleOwner owner) {
                    // disconnect if connected
                }
            }

With this implementation, our ``LocationListener`` class is completely
lifecycle-aware. If we need to use our ``LocationListener`` from another
activity or fragment, we just need to initialize it. All of the setup
and teardown operations are managed by the class itself.

If a library provides classes that need to work with the Android
lifecycle, we recommend that you use lifecycle-aware components. Your
library clients can easily integrate those components without manual
lifecycle management on the client side.

.. _implementing-lco:

Implementing a custom LifecycleOwner
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Fragments and Activities in Support Library 26.1.0 and later already
implement the
`LifecycleOwner <#>`__
interface.

If you have a custom class that you would like to make a 
`LifecycleOwner <#>`__,
you can use the
`LifecycleRegistry <#>`__
class, but you need to forward events into that class, as shown in the
following code example:

.. container::

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            class MyActivity : Activity(), LifecycleOwner {

                private lateinit var lifecycleRegistry: LifecycleRegistry

                override fun onCreate(savedInstanceState: Bundle?) {
                    super.onCreate(savedInstanceState)

                    lifecycleRegistry = LifecycleRegistry(this)
                    lifecycleRegistry.markState(Lifecycle.State.CREATED)
                }

                public override fun onStart() {
                    super.onStart()
                    lifecycleRegistry.markState(Lifecycle.State.STARTED)
                }

                override fun getLifecycle(): Lifecycle {
                    return lifecycleRegistry
                }
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            public class MyActivity extends Activity implements LifecycleOwner {
                private LifecycleRegistry lifecycleRegistry;

                @Override
                protected void onCreate(Bundle savedInstanceState) {
                    super.onCreate(savedInstanceState);

                    lifecycleRegistry = new LifecycleRegistry(this);
                    lifecycleRegistry.markState(Lifecycle.State.CREATED);
                }

                @Override
                public void onStart() {
                    super.onStart();
                    lifecycleRegistry.markState(Lifecycle.State.STARTED);
                }

                @NonNull
                @Override
                public Lifecycle getLifecycle() {
                    return lifecycleRegistry;
                }
            }

.. _lc-bp:

Best practices for lifecycle-aware components
---------------------------------------------

-  Keep your UI controllers (activities and fragments) as lean as
   possible. They should not try to acquire their own data; instead, use
   a `ViewModel <#>`__ to do
   that, and observe a
   `LiveData <#>`__ object to
   reflect the changes back to the views.
-  Try to write data-driven UIs where your UI controller‚Äôs
   responsibility is to update the views as data changes, or notify user
   actions back to the
   `ViewModel <#>`__.
-  Put your data logic in your
   `ViewModel <#>`__ class.
   `ViewModel <#>`__ should
   serve as the connector between your UI controller and the rest of
   your app. Be careful though, it isn't
   `ViewModel <#>`__'s
   responsibility to fetch data (for example, from a network). Instead,
   `ViewModel <#>`__ should
   call the appropriate component to fetch the data, then provide the
   result back to the UI controller.
-  Use `Data Binding <#>`__ to maintain a
   clean interface between your views and the UI controller. This allows
   you to make your views more declarative and minimize the update code
   you need to write in your activities and fragments. If you prefer to
   do this in the Java programming language, use a library like `Butter Knife <http://jakewharton.github.io/butterknife/>`__ to avoid
   boilerplate code and have a better abstraction.
-  If your UI is complex, consider creating a
   `presenter <http://www.gwtproject.org/articles/mvp-architecture.html#presenter>`__
   class to handle UI modifications. This might be a laborious task, but
   it can make your UI components easier to test.
-  Avoid referencing a `View <#>`__ or
   `Activity <#>`__ context in your
   `ViewModel <#>`__. If the
   ``ViewModel`` outlives the activity (in case of configuration
   changes), your activity leaks and isn't properly disposed by the
   garbage collector.
-  Use `Kotlin coroutines <#>`__
   to manage long-running tasks and other operations that can run
   asynchronously.

.. _use-cases:

Use cases for lifecycle-aware components
----------------------------------------

Lifecycle-aware components can make it much easier for you to manage
lifecycles in a variety of cases. A few examples are:

-  Switching between coarse and fine-grained location updates. Use
   lifecycle-aware components to enable fine-grained location updates
   while your location app is visible and switch to coarse-grained
   updates when the app is in the background.
   `LiveData <#>`__, a
   lifecycle-aware component, allows your app to automatically update
   the UI when your user changes locations.
-  Stopping and starting video buffering. Use lifecycle-aware components
   to start video buffering as soon as possible, but defer playback
   until app is fully started. You can also use lifecycle-aware
   components to terminate buffering when your app is destroyed.
-  Starting and stopping network connectivity. Use lifecycle-aware
   components to enable live updating (streaming) of network data while
   an app is in the foreground and also to automatically pause when the
   app goes into the background.
-  Pausing and resuming animated drawables. Use lifecycle-aware
   components to handle pausing animated drawables when the app is in
   the background and resume drawables after the app is in the
   foreground.

.. _onStop-and-savedState:

Handling on stop events
-----------------------

When a `Lifecycle <#>`__ belongs to an `AppCompatActivity <#>`__
or `Fragment <#>`__, the `Lifecycle <#>`__'s state
changes to `CREATED <#CREATED>`__ and the `ON_STOP <#ON_STOP>`__
event is dispatched when the `AppCompatActivity <#>`__
or `Fragment <#>`__'s `onSaveInstanceState() <#onSaveInstanceState>`__
is called.

When a `Fragment <#>`__ or `AppCompatActivity <#>`__'s state is saved via
`onSaveInstanceState() <#onSaveInstanceState>`__,
it's UI is considered immutable until `ON_START <#ON_START>`__
is called. Trying to modify the UI after the state is saved is likely to
cause inconsistencies in the navigation state of your application which
is why `FragmentManager <#>`__ throws an exception if the app runs a
`FragmentTransaction <#>`__ after state is saved. See
`commit() <#commit>`__ for details.

`LiveData <#>`__ prevents this
edge case out of the box by refraining from calling its observer if the
observer's associated
`Lifecycle <#>`__ isn't at
least
`STARTED <#STARTED>`__.
Behind the scenes, it calls
`isAtLeast() <#isAtLeast>`__
before deciding to invoke its observer.

Unfortunately, 
`AppCompatActivity <#>`__'s
`onStop() <#onStop>`__
method is called *after*
`onSaveInstanceState() <#onSaveInstanceState>`__,
which leaves a gap where UI state changes are not allowed but the
`Lifecycle <#>`__ has not yet
been moved to the
`CREATED <#CREATED>`__
state.

To prevent this issue, the 
`Lifecycle <#>`__ class in
version ``beta2`` and lower mark the state as
`CREATED <#CREATED>`__
without dispatching the event so that any code that checks the current
state gets the real value even though the event isn't dispatched until
`onStop() <#onStop>`__
is called by the system.

Unfortunately, this solution has two major problems: 

-  On API level 23 and lower, the Android system actually saves the
   state of an activity even if it is *partially* covered by another
   activity. In other words, the Android system calls
   `onSaveInstanceState() <#onSaveInstanceState>`__
   but it doesn't necessarily call
   `onStop() <#onStop>`__.
   This creates a potentially long interval where the observer still
   thinks that the lifecycle is active even though its UI state can't be
   modified.
-  Any class that wants to expose a similar behavior to the
   `LiveData <#>`__ class has
   to implement the workaround provided by
   `Lifecycle <#>`__ version
   ``beta 2`` and lower.

**Note:**\  To make this flow simpler and provide better compatibility
with older versions, starting at version ``1.0.0-rc1``,
`Lifecycle <#>`__ objects are
marked as
`CREATED <#CREATED>`__
and
`ON_STOP <#ON_STOP>`__
is dispatched when
`onSaveInstanceState() <#onSaveInstanceState>`__
is called without waiting for a call to the
`onStop() <#onStop>`__
method. This is unlikely to impact your code but it is something you
need to be aware of as it doesn't match the call order in the
`Activity <#>`__ class in API level 26
and lower.

Additional resources
--------------------

To learn more about handling lifecycles with lifecycle-aware components,
consult the following additional resources.

**Samples**

-  `Android Architecture Components Basic Sample <https://github.com/android/architecture-components-samples/tree/main/BasicSample>`__
-  `Sunflower <https://github.com/android/sunflower>`__, a demo app
   demonstrating best practices with Architecture Components

**Codelabs**

-  `Android Lifecycle-aware components <https://developers.google.cn/codelabs/codelabs/android-lifecycles/index.html?index=..%2F..%2Findex#0>`__

**Blogs**

-  `Introducing Android Sunflower <https://medium.com/androiddevelopers/introducing-android-sunflower-e421b43fe0c2>`__

.. _recommended_for_you:

**Recommended for you**

-  Note: link text is displayed when JavaScript is off
-  `LiveData overview <#>`__
-  `Use Kotlin coroutines with lifecycle-aware components <#>`__
-  `Saved State module for ViewModel <#>`__

Last updated 2024-01-03 UTC.


/Integrate Lifecycle with Compose
=================================

.. container:: devsite-article-body clearfix

   The Lifecycle library offers built-in APIs that let you integrate
   with Jetpack `Compose <#>`__. Key APIs include the
   following:

   -  Flows for the current ``Lifecycle.State``.
   -  ``LifecycleEffects`` that lets you run a block based on a specific
      ``Lifecycle.Event``.

   These integrations provide convenient hooks to manage Lifecycles
   within the Compose hierarchy. This document outlines how you can use
   them in your app.

   **Note:**\  The APIs described in this document were introduced in
   Lifecycle version 2.7.0.

   .. rubric:: Collect lifecycle state with flows
      :name: collect-lifecycle

   Lifecycle exposes a ``currentStateFlow`` property that provides the
   current ``Lifecycle.State`` as a Kotlin ``StateFlow``. You can
   collect this ``Flow`` as ``State``. This allows your app to read
   changes in the Lifecycle during composition.

   .. code:: prettyprint

      val lifecycleOwner = LocalLifecycleOwner.current
      val stateFlow = lifecycleOwner.lifecycle.currentStateFlow
      ‚Ä¶
      val currentLifecycleState by stateFlow.collectAsState()

   The preceding example is accessible using the ``lifecycle-common``
   module. The ``currentStateAsState()`` method is available in the
   ``lifecycle-runtime-compose`` module, which lets you conveniently
   read the current Lifecycle state with a single line. The following
   example demonstrates this:

   .. code:: prettyprint

      val lifecycleOwner = LocalLifecycleOwner.current
      val currentLifecycleState = lifecycleOwner.lifecycle.currentStateAsState()

   .. rubric:: Run code on lifecycle events
      :name: run-code

   There are also ``LifecycleEffects`` that let you run a block when a
   particular ``Lifecycle.Event`` occurs.

   .. code:: prettyprint

      LifecycleEventEffect(Lifecycle.Event.ON_START) {
        // do something here
      }

   **Warning:**\  You cannot use this to listen for
   ``Lifecycle.Event.ON_DESTROY`` since composition ends before this
   signal is sent.
   In addition to the ``LifecycleEventEffect``, you can also use
   ``LifecycleStartEffect`` and ``LifecycleResumeEffect``. These APIs
   are tied to specific events. They also offer an additional block
   within their primary block that helps clean up any code that the
   event might have kicked off.

   .. rubric:: LifecycleStartEffect
      :name: lifecyclestarteffect

   The ``LifecycleStartEffect`` is similar to the ``LifecycleEffect``,
   but it runs only on ``Lifecycle.Event.ON_START`` events. It also
   accepts keys that work like other Compose keys. When the key changes,
   it triggers the block to run again.

   When there is a ``Lifecycle.Event.ON_STOP`` event or the effect exits
   composition, it executes a ``onStopOrDispose`` block. This allows for
   the clean up of any work that was part of the starting block.

   .. code:: prettyprint

      LifecycleStartEffect {
        // ON_START code is executed here

        onStopOrDispose {
          // do any needed clean up here
        }
      }

   **Note:**\  The ``onStopOrDispose`` block is always required and if
   it is not needed, you should use the ``LifecycleEffect``, passing in
   the ``Lifecycle.Event.ON_START`` event instead.

   .. rubric:: LifecycleResumeEffect
      :name: lifecycleresumeeffect

   The ``LifecycleResumeEffect`` works in the same way as the
   ``LifecycleStartedEffect``, but it executes on the
   ``Lifecycle.Event.ON_RESUME`` event instead. It also provides an
   ``onPauseOrDispose`` block that performs the clean up.

   .. code:: prettyprint

      LifecycleResumeEffect {
        // ON_RESUME code is executed here

        onPauseOrDispose {
          // do any needed clean up here
        }
      }

Last updated 2024-01-10 UTC.



.. _viewmodel_overview:

/Overview: ViewModel overview - Part of Android Jetpack
=======================================================

.. https://developer.android.google.cn/topic/libraries/architecture/viewmodel
.. container::

   The `ViewModel <#>`__ class is 
   a `business logic or screen level state holder <#>`__. It exposes state
   to the UI and encapsulates related business logic. Its principal
   advantage is that it caches state and persists it through configuration
   changes. This means that your UI doesn‚Äôt have to fetch data again when
   navigating between activities, or following configuration changes, such
   as when rotating the screen.

   **Objective:**\  This guide explains the basics of ViewModels, how they
   fit into `Modern Android Development <#>`__,
   and how you can implement them in your app.

   For more information on state holders, see the `state holders <#>`__ guidance.
   Similarly, for more information on the UI layer generally, see the `UI layer <#>`__ guidance.

   ViewModel benefits
   ------------------

   The alternative to a ViewModel is a plain class that holds the data you
   display in your UI. This can become a problem when navigating between
   activities or Navigation destinations. Doing so destroys that data if
   you don't store it using the `saving instance state mechanism <#onsaveinstancestate>`__.
   ViewModel provides a convenient API for data persistence that resolves
   this issue.

   The key benefits of the ViewModel class are essentially two:

   -  It allows you to persist UI state.
   -  It provides access to business logic.

   **Note:**\  ViewModel fully supports integration with key Jetpack
   libraries such as `Hilt <#>`__
   and `Navigation <#>`__, as well as
   `Compose <#>`__.

   Persistence
   ~~~~~~~~~~~

   ViewModel allows persistence through both the state that a ViewModel
   holds, and the operations that a ViewModel triggers. This caching means
   that you don‚Äôt have to fetch data again through common configuration
   changes, such as a screen rotation.

   Scope
   ^^^^^

   When you instantiate a ViewModel, you pass it an object that implements
   the
   `ViewModelStoreOwner <#>`__
   interface. This may be a Navigation destination, Navigation graph,
   activity, fragment, or any other type that implements the interface.
   Your ViewModel is then scoped to the
   `Lifecycle <#>`__ of the
   ``ViewModelStoreOwner``. It remains in memory until its
   ``ViewModelStoreOwner`` goes away permanently.

   A range of classes are either direct or indirect subclasses of the
   ``ViewModelStoreOwner`` interface. The direct subclasses are
   `ComponentActivity <#>`__,
   `Fragment <#>`__, and
   `NavBackStackEntry <#>`__.
   For a full list of indirect subclasses, see the `ViewModelStoreOwner``
   reference </reference/kotlin/androidx/lifecycle/ViewModelStoreOwner>`__.

   When the fragment or activity to which the ViewModel is scoped is
   destroyed, asynchronous work continues in the ViewModel that is scoped
   to it. This is the key to persistence.

   For more information, see the section below on `ViewModel lifecycle <#lifecycle>`__.

   SavedStateHandle
   ^^^^^^^^^^^^^^^^

   `SavedStateHandle <#>`__
   allows you to persist data not just through configuration changes, but
   across process recreation. That is, it enables you to keep the UI state
   intact even when the user closes the app and opens it at a later time.

   .. _access-business:

   Access to business logic
   ~~~~~~~~~~~~~~~~~~~~~~~~

   Even though the vast majority of `business logic <#business-logic>`__ is
   present in the data layer, the UI layer can also contain business logic.
   This can be the case when combining data from multiple repositories to
   create the screen UI state, or when a particular type of data doesn't
   require a data layer.

   ViewModel is the right place to handle business logic in the UI layer.
   The ViewModel is also in charge of handling events and delegating them
   to other layers of the hierarchy when business logic needs to be applied
   to modify application data.

   Jetpack Compose
   ---------------

   When using Jetpack Compose, ViewModel is the primary means of exposing
   screen UI state to your composables. In a hybrid app, activities and
   fragments simply host your composable functions. This is a shift from
   past approaches, where it wasn't that simple and intuitive to create
   reusable pieces of UI with activities and fragments, which caused them
   to be much more active as UI controllers.

   The most important thing to keep in mind when using ViewModel with
   Compose is that you cannot scope a ViewModel to a composable. This is
   because a composable is not a ``ViewModelStoreOwner``. Two instances of
   the same composable in the Composition, or two different composables
   accessing the same ViewModel type under the same ``ViewModelStoreOwner``
   would receive the *same* instance of the ViewModel, which often is not
   the expected behavior.

   To get the `benefits <#viewmodel-benefits>`__ of ViewModel in Compose,
   host each screen in a Fragment or Activity, or use Compose Navigation
   and use ViewModels in composable functions as close as possible to the
   Navigation destination. That is because you can scope a ViewModel to
   Navigation destinations, Navigation graphs, Activities, and Fragments.

   For more information, see the guide on 
   `state hoisting <#viewmodels-as-state-owner>`__
   for Jetpack Compose.

   .. _implement-viewmodel:

   Implement a ViewModel
   ---------------------

   The following is an example implementation of a ViewModel for a screen
   that allows the user to roll dice.

   **Important:**\  In this example, the responsibility of acquiring and
   holding the list of users sits with the ViewModel, not an Activity or
   Fragment directly.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            data class DiceUiState(
                val firstDieValue: Int? = null,
                val secondDieValue: Int? = null,
                val numberOfRolls: Int = 0,
            )

            class DiceRollViewModel : ViewModel() {

                // Expose screen UI state
                private val _uiState = MutableStateFlow(DiceUiState())
                val uiState: StateFlow<DiceUiState> = _uiState.asStateFlow()

                // Handle business logic
                fun rollDice() {
                    _uiState.update { currentState ->
                        currentState.copy(
                            firstDieValue = Random.nextInt(from = 1, until = 7),
                            secondDieValue = Random.nextInt(from = 1, until = 7),
                            numberOfRolls = currentState.numberOfRolls + 1,
                        )
                    }
                }
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            public class DiceUiState {
                private final Integer firstDieValue;
                private final Integer secondDieValue;
                private final int numberOfRolls;

                // ...
            }

            public class DiceRollViewModel extends ViewModel {

                private final MutableLiveData<DiceUiState> uiState =
                    new MutableLiveData(new DiceUiState(null, null, 0));
                public LiveData<DiceUiState> getUiState() {
                    return uiState;
                }

                public void rollDice() {
                    Random random = new Random();
                    uiState.setValue(
                        new DiceUiState(
                            random.nextInt(7) + 1,
                            random.nextInt(7) + 1,
                            uiState.getValue().getNumberOfRolls() + 1
                        )
                    );
                }
            }

   You can then access the ViewModel from an activity as follows:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin_1

         .. code:: prettyprint

            import androidx.activity.viewModels

            class DiceRollActivity : AppCompatActivity() {

                override fun onCreate(savedInstanceState: Bundle?) {
                    // Create a ViewModel the first time the system calls an activity's onCreate() method.
                    // Re-created activities receive the same DiceRollViewModel instance created by the first activity.

                    // Use the 'by viewModels()' Kotlin property delegate
                    // from the activity-ktx artifact
                    val viewModel: DiceRollViewModel by viewModels()
                    lifecycleScope.launch {
                        repeatOnLifecycle(Lifecycle.State.STARTED) {
                            viewModel.uiState.collect {
                                // Update UI elements
                            }
                        }
                    }
                }
            }

      .. container:: section

         .. rubric:: Java
            :name: java_1

         .. code:: prettyprint

            public class MyActivity extends AppCompatActivity {
                public void onCreate(Bundle savedInstanceState) {
                    super.onCreate(savedInstanceState);

                    // Create a ViewModel the first time the system calls an activity's onCreate() method.
                    // Re-created activities receive the same MyViewModel instance created by the first activity.
                    DiceRollViewModel model = new ViewModelProvider(this).get(DiceRollViewModel.class);
                    model.getUiState().observe(this, uiState -> {
                        // update UI
                    });
                }
            }

      .. container:: section

         .. rubric:: Jetpack Compose
            :name: jetpack-compose_1

         .. code:: prettyprint

            import androidx.lifecycle.viewmodel.compose.viewModel

            // Use the 'viewModel()' function from the lifecycle-viewmodel-compose artifact
            @Composable
            fun DiceRollScreen(
                viewModel: DiceRollViewModel = viewModel()
            ) {
                val uiState by viewModel.uiState.collectAsStateWithLifecycle()
                // Update UI elements
            }

   **Caution:**\  A
   `ViewModel <#>`__ usually
   shouldn't reference a view,
   `Lifecycle <#>`__, or any
   class that may hold a reference to the activity context. Because the
   ViewModel lifecycle is larger than the UI's, holding a lifecycle-related
   API in the ViewModel could cause memory leaks.

   **Note:**\  To import
   `ViewModel <#>`__ into your
   Android project, see the instructions for declaring dependencies in the
   `Lifecycle release notes <#declaring_dependencies>`__.

   .. _use-coroutines:

   Use coroutines with ViewModel
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``ViewModel`` includes support for Kotlin coroutines. It is able to
   persist asynchronous work in the same manner as it persists UI state.

   For more information, see `Use Kotlin coroutines with Android Architecture Components <#>`__.

   .. _lifecycle:

   The lifecycle of a ViewModel
   ----------------------------

   The lifecycle of a 
   `ViewModel <#>`__ is tied
   directly to its scope. A ``ViewModel`` remains in memory until the
   `ViewModelStoreOwner <#>`__
   to which it is scoped disappears. This may occur in the following
   contexts:

   -  In the case of an activity, when it finishes.
   -  In the case of a fragment, when it detaches.
   -  In the case of a Navigation entry, when it's removed from the back
      stack.

   This makes ViewModels a great solution for storing data that survives
   configuration changes.

   Figure 1 illustrates the various lifecycle states of an activity as it
   undergoes a rotation and then is finished. The illustration also shows
   the lifetime of the
   `ViewModel <#>`__ next to the
   associated activity lifecycle. This particular diagram illustrates the
   states of an activity. The same basic states apply to the lifecycle of a
   fragment.


   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/viewmodel-lifecycle.png
      :alt: Illustrates the lifecycle of a ViewModel as an activity changes state.

   You usually request a 
   `ViewModel <#>`__ the first
   time the system calls an activity object's
   `onCreate() <#onCreate>`__
   method. The system may call
   `onCreate() <#onCreate>`__
   several times throughout the existence of an activity, such as when a
   device screen is rotated. The
   `ViewModel <#>`__ exists from
   when you first request a
   `ViewModel <#>`__ until the
   activity is finished and destroyed.

   .. _clear-dependencies:

   Clearing ViewModel dependencies
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The ViewModel calls the 
   `onCleared <#onCleared>`__
   method when the ``ViewModelStoreOwner`` destroys it in the course of its
   lifecycle. This allows you to clean up any work or dependencies that
   follows the ViewModel's lifecycle.

   The following example shows an alternative to 
   `viewModelScope <#viewmodelscope>`__.
   ``viewModelScope`` is a built-in
   `CoroutineScope <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/>`__
   that automatically follows the ViewModel's lifecycle. The ViewModel uses
   it to trigger business-related operations. If you want to use a custom
   scope instead of ``viewModelScope`` for `easier testing <#>`__, the ViewModel can receive a
   ``CoroutineScope`` as a dependency in its constructor. When the
   ``ViewModelStoreOwner`` clears the ViewModel at the end of its
   lifecycle, the ViewModel also cancels the ``CoroutineScope``.

   .. code:: prettyprint

      class MyViewModel(
          private val coroutineScope: CoroutineScope =
              CoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)
      ) : ViewModel() {

          // Other ViewModel logic ...

          override fun onCleared() {
              coroutineScope.cancel()
          }
      }

   From lifecycle `version 2.5 <#version_25_2>`__ and above,
   you can pass one or more ``Closeable`` objects to the ViewModel's
   constructor that automatically closes when the ViewModel instance is
   cleared.

   .. code:: prettyprint

      class CloseableCoroutineScope(
          context: CoroutineContext = SupervisorJob() + Dispatchers.Main.immediate
      ) : Closeable, CoroutineScope {
          override val coroutineContext: CoroutineContext = context
          override fun close() {
              coroutineContext.cancel()
         }
      }

      class MyViewModel(
          private val coroutineScope: CoroutineScope = CloseableCoroutineScope()
      ) : ViewModel(coroutineScope) {
          // Other ViewModel logic ...
      }

   Best practices
   --------------

   The following are several key best practices you should follow when
   implementing ViewModel:

   -  Because of `their scoping <#lifecycle>`__, use
      ViewModels as implementation details of a screen level state holder.
      Don't use them as state holders of reusable UI components such as
      chip groups or forms. Otherwise, you'd get the same ViewModel
      instance in different usages of the same UI component under the same
      ViewModelStoreOwner.
   -  ViewModels shouldn't know about the UI implementation details. Keep
      the names of the methods the ViewModel API exposes and those of the
      UI state fields as generic as possible. In this way, your ViewModel
      can accommodate any type of UI: a mobile phone, foldable, tablet, or
      even a Chromebook!
   -  As they can potentially live longer than the ``ViewModelStoreOwner``,
      ViewModels shouldn't hold any references of lifecycle-related APIs
      such as the ``Context`` or ``Resources`` to prevent memory leaks.
   -  Don't pass ViewModels to other classes, functions or other UI
      components. Because the platform manages them, you should keep them
      as close to it as you can. Close to your Activity, fragment, or
      screen level composable function. This prevents lower level
      components from accessing more data and logic than they need.

   Further information
   -------------------

   As your data grows more complex, you might choose to have a separate
   class just to load the data. The purpose of
   `ViewModel <#>`__ is to
   encapsulate the data for a UI controller to let the data survive
   configuration changes. For information about how to load, persist, and
   manage data across configuration changes, see `Saved UI States <#>`__.

   The `Guide to Android App Architecture <#fetching_data>`__
   suggests building a repository class to handle these functions.

   **Additional resources**


   For further information about the ``ViewModel`` class, consult the
   following resources.

   **Documentation**


   -  `UI layer <#>`__
   -  `UI Events <#>`__
   -  `State holders and UI State <#>`__
   -  `State production <#>`__
   -  `Data layer <#>`__

   **Samples**


   .. _recommended_for_you:

   **Recommended for you**


   -  Note: link text is displayed when JavaScript is off
   -  `Use Kotlin coroutines with lifecycle-aware components <#>`__
   -  `Save UI states <#>`__
   -  `Load and display paged data <#>`__

   Last updated 2024-01-29 UTC.



.. _create_viewmodels_with_dependencies:

/Create ViewModels with dependencies - Part of Android Jetpack
==============================================================

Following `dependency injection's <#>`__ best 
practices, ViewModels can take dependencies as parameters in their
constructor. These are mostly of types from the
`domain <#>`__ or
`data <#>`__ layers. Because the framework
provides the ViewModels, a special mechanism is required to create
instances of them. That mechanism is the ``ViewModelProvider.Factory``
interface. Only **implementations of this interface can instantiate
ViewModels in the right scope**.

**Note:**\  If the ViewModel takes no dependencies or just the
`SavedStateHandle type as a dependency <#>`__, you
don't need to provide a factory for the framework to instantiate
instances of that ViewModel type.

**Note:**\  When `injecting ViewModels using Hilt <#viewmodels>`__ as a
dependency injection solution, you don't have to define a ViewModel
factory manually. Hilt generates a factory that knows how to create all
ViewModels annotated with ``@HiltViewModel`` for you at compile time.
Classes annotated with ``@AndroidEntryPoint`` can directly access the
Hilt generated factory when calling the regular ViewModel APIs.

.. _creationextras:

ViewModels with CreationExtras
------------------------------

If a ViewModel class receives dependencies in its constructor, provide a
factory that implements the
`ViewModelProvider.Factory <#>`__
interface. Override the
`create(Class<T>, CreationExtras) <#create>`__
function to provide a new instance of the ViewModel.

`CreationExtras <#>`__
allows you to access relevant information that helps instantiate a
ViewModel. Here's a list of keys that can be accessed from extras:

.. list-table::
   :header-rows: 1

   - 

      - Key
      - Functionality
   - 

      - `ViewModelProvider.NewInstanceFactory.VIEW_MODEL_KEY <#VIEW_MODEL_KEY>`__
      - Provides access to the custom key you passed to
         ``ViewModelProvider.get()``.
   - 

      - `ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY <#APPLICATION_KEY>`__
      - Provides access to the instance of the ``Application`` class.
   - 

      - `SavedStateHandleSupport.DEFAULT_ARGS_KEY <#DEFAULT_ARGS_KEY>`__
      - Provides access to the Bundle of arguments you should use to
         construct ``SavedStateHandle``.
   - 

      - `SavedStateHandleSupport.SAVED_STATE_REGISTRY_OWNER_KEY <#SAVED_STATE_REGISTRY_OWNER_KEY>`__
      - Provides access to the ``SavedStateRegistryOwner`` that is being
         used to construct the ``ViewModel``.
   - 

      - `SavedStateHandleSupport.VIEW_MODEL_STORE_OWNER_KEY <#VIEW_MODEL_STORE_OWNER_KEY>`__
      - Provides access to the ``ViewModelStoreOwner`` that is being
         used to construct the ``ViewModel``.

To create a new instance of 
`SavedStateHandle <#>`__,
use the
`CreationExtras.createSavedStateHandle() <#(androidx.lifecycle.viewmodel.CreationExtras>`__.createSavedStateHandle())
function and pass it to the ViewModel.

The following is an example of how to provide an instance of a ViewModel
that takes a
`repository <#architecture>`__ scoped to
the ``Application`` class and ``SavedStateHandle`` as dependencies:

.. container:: ds-selector-tabs

   .. container:: section

      .. rubric:: Kotlin
         :name: kotlin

      .. code:: prettyprint

             import androidx.lifecycle.SavedStateHandle
             import androidx.lifecycle.ViewModel
             import androidx.lifecycle.ViewModelProvider
             import androidx.lifecycle.ViewModelProvider.AndroidViewModelFactory.Companion.APPLICATION_KEY
             import androidx.lifecycle.createSavedStateHandle
             import androidx.lifecycle.viewmodel.CreationExtras

             class MyViewModel(
                 private val myRepository: MyRepository,
                 private val savedStateHandle: SavedStateHandle
             ) : ViewModel() {

                 // ViewModel logic
                 // ...

                 // Define ViewModel factory in a companion object
                 companion object {

                     val Factory: ViewModelProvider.Factory = object : ViewModelProvider.Factory {
                         @Suppress("UNCHECKED_CAST")
                         override fun <T : ViewModel> create(
                             modelClass: Class<T>,
                             extras: CreationExtras
                         ): T {
                             // Get the Application object from extras
                             val application = checkNotNull(extras[APPLICATION_KEY])
                             // Create a SavedStateHandle for this ViewModel from extras
                             val savedStateHandle = extras.createSavedStateHandle()

                             return MyViewModel(
                                 (application as MyApplication).myRepository,
                                 savedStateHandle
                             ) as T
                         }
                     }
                 }
             }

   .. container:: section

      .. rubric:: Java
         :name: java

      .. code:: prettyprint

         import static androidx.lifecycle.SavedStateHandleSupport.createSavedStateHandle;
         import static androidx.lifecycle.ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY;

         import androidx.lifecycle.SavedStateHandle;
         import androidx.lifecycle.ViewModel;
         import androidx.lifecycle.viewmodel.ViewModelInitializer;

         public class MyViewModel extends ViewModel {

             public MyViewModel(
                 MyRepository myRepository,
                 SavedStateHandle savedStateHandle
             ) { /* Init ViewModel here */ }

             static final ViewModelInitializer<MyViewModel> initializer = new ViewModelInitializer<>(
                 MyViewModel.class,
                 creationExtras -> {
                     MyApplication app = (MyApplication) creationExtras.get(APPLICATION_KEY);
                     assert app != null;
                     SavedStateHandle savedStateHandle = createSavedStateHandle(creationExtras);

                     return new MyViewModel(app.getMyRepository(), savedStateHandle);
                 }
             );
         }

**Note:**\  It's a good practice to place ViewModel factories in their
ViewModel file for better context, readability, and easier discovery.
The same ViewModel factory can be used for multiple ViewModels when they
share dependencies, as it's the case for the `Architecture Blueprints <https://github.com/android/architecture-samples/blob/views/app/src/main/java/com/example/android/architecture/blueprints/todoapp/ViewModelFactory.kt>`__
sample.

Then, you can use this factory when retrieving an instance of the
ViewModel:

.. container:: ds-selector-tabs

   .. container:: section

      .. rubric:: Kotlin
         :name: kotlin_1

      .. code:: prettyprint

         import androidx.activity.viewModels

         class MyActivity : AppCompatActivity() {

             private val viewModel: MyViewModel by viewModels { MyViewModel.Factory }

             // Rest of Activity code
         }

   .. container:: section

      .. rubric:: Java
         :name: java_1

      .. code:: prettyprint

         import androidx.appcompat.app.AppCompatActivity;
         import androidx.lifecycle.ViewModelProvider;

         public class MyActivity extends AppCompatActivity {

         MyViewModel myViewModel = new ViewModelProvider(
             this,
             ViewModelProvider.Factory.from(MyViewModel.initializer)
         ).get(MyViewModel.class);

         // Rest of Activity code
         } 

   .. container:: section

      .. rubric:: Jetpack Compose
         :name: jetpack-compose

      .. code:: prettyprint

         import androidx.lifecycle.viewmodel.compose.viewModel

         @Composable
         fun MyScreen(
             modifier: Modifier = Modifier,
             viewModel: MyViewModel = viewModel(factory = MyViewModel.Factory)
         ) {
             // ...
         }

Alternatively, use the ViewModel factory DSL to create factories using a
more idiomatic Kotlin API:

.. code:: prettyprint

   import androidx.lifecycle.SavedStateHandle
   import androidx.lifecycle.ViewModel
   import androidx.lifecycle.ViewModelProvider
   import androidx.lifecycle.ViewModelProvider.AndroidViewModelFactory.Companion.APPLICATION_KEY
   import androidx.lifecycle.createSavedStateHandle
   import androidx.lifecycle.viewmodel.initializer
   import androidx.lifecycle.viewmodel.viewModelFactory

   class MyViewModel(
       private val myRepository: MyRepository,
       private val savedStateHandle: SavedStateHandle
   ) : ViewModel() {
       // ViewModel logic

       // Define ViewModel factory in a companion object
       companion object {
           val Factory: ViewModelProvider.Factory = viewModelFactory {
               initializer {
                   val savedStateHandle = createSavedStateHandle()
                   val myRepository = (this[APPLICATION_KEY] as MyApplication).myRepository
                   MyViewModel(
                       myRepository = myRepository,
                       savedStateHandle = savedStateHandle
                   )
               }
           }
       }
   }

.. _viewmodel-factories-old:

Factories for ViewModel version older than 2.5.0
------------------------------------------------

If you're using a version of ViewModel older than 2.5.0, you need to
provide factories from a subset of classes that extend
`ViewModelProvider.Factory <#>`__
and implement the ``create(Class<T>)`` function. Depending on what
dependencies the ViewModel needs, a different class needs to be extended
from:

-  `AndroidViewModelFactory <#>`__
   if the ``Application`` class is needed.
-  `AbstractSavedStateViewModelFactory <#>`__
   if
   `SavedStateHandle <#getStateFlow>`__
   needs to be passed as a dependency.

If ``Application`` or ``SavedStateHandle`` aren't needed, simply extend
from ``ViewModelProvider.Factory``.

The following example uses an 
`AbstractSavedStateViewModelFactory <#>`__
for a ViewModel that takes a repository and a
`SavedStateHandle <#getStateFlow>`__
type as a dependency:

.. container:: ds-selector-tabs

   .. container:: section

      .. rubric:: Kotlin
         :name: kotlin_2

      .. code:: prettyprint

         class MyViewModel(
         private val myRepository: MyRepository,
         private val savedStateHandle: SavedStateHandle
         ) : ViewModel() {

         // ViewModel logic ...

         // Define ViewModel factory in a companion object
         companion object {
             fun provideFactory(
                 myRepository: MyRepository,
                 owner: SavedStateRegistryOwner,
                 defaultArgs: Bundle? = null,
             ): AbstractSavedStateViewModelFactory =
                 object : AbstractSavedStateViewModelFactory(owner, defaultArgs) {
                     @Suppress("UNCHECKED_CAST")
                     override fun <T : ViewModel> create(
                         key: String,
                         modelClass: Class<T>,
                         handle: SavedStateHandle
                     ): T {
                         return MyViewModel(myRepository, handle) as T
                     }
                 }
             }
         }

   .. container:: section

      .. rubric:: Java
         :name: java_2

      .. code:: prettyprint

         import androidx.annotation.NonNull;
         import androidx.lifecycle.AbstractSavedStateViewModelFactory;
         import androidx.lifecycle.SavedStateHandle;
         import androidx.lifecycle.ViewModel;

         public class MyViewModel extends ViewModel {
             public MyViewModel(
                 MyRepository myRepository,
                 SavedStateHandle savedStateHandle
             ) { /* Init ViewModel here */ }
         }

         public class MyViewModelFactory extends AbstractSavedStateViewModelFactory {

             private final MyRepository myRepository;

             public MyViewModelFactory(
                 MyRepository myRepository
             ) {
                 this.myRepository = myRepository;
             }

             @SuppressWarnings("unchecked")
             @NonNull
             @Override
             protected <T extends ViewModel> T create(
                 @NonNull String key, @NonNull Class<T> modelClass, @NonNull SavedStateHandle handle
             ) {
                 return (T) new MyViewModel(myRepository, handle);
             }
         }

**Warning:**\  if you're using a version of ``ViewModel`` older than
2.5.0, you might have the option to override a create function with
``CreationExtras`` in its signature. Don't override that function.
Instead, override the ``create`` function that has the
``key, modelClass`` and ``savedStateHandle`` parameters.

Then, you can use factory to retrieve your ViewModel: 

.. container:: ds-selector-tabs

   .. container:: section

      .. rubric:: Kotlin
         :name: kotlin_3

      .. code:: prettyprint

         import androidx.activity.viewModels

         class MyActivity : AppCompatActivity() {

             private val viewModel: MyViewModel by viewModels {
                 MyViewModel.provideFactory((application as MyApplication).myRepository, this)
             }

             // Rest of Activity code
         }

   .. container:: section

      .. rubric:: Java
         :name: java_3

      .. code:: prettyprint

         import androidx.appcompat.app.AppCompatActivity;
         import androidx.lifecycle.ViewModelProvider;

         public class MyActivity extends AppCompatActivity {

             MyViewModel myViewModel = new ViewModelProvider(
                 this,
                 ViewModelProvider.Factory.from(MyViewModel.initializer)
             ).get(MyViewModel.class);

             // Rest of Activity code
         }

   .. container:: section

      .. rubric:: Jetpack Compose
         :name: jetpack-compose_1

      .. code:: prettyprint

         import androidx.lifecycle.viewmodel.compose.viewModel

         @Composable
         fun MyScreen(
             modifier: Modifier = Modifier,
             viewModel: MyViewModel = viewModel(
                 factory = MyViewModel.provideFactory(
                     (LocalContext.current.applicationContext as MyApplication).myRepository,
                     owner = LocalSavedStateRegistryOwner.current
                 )
             )
         ) {
             // ...
         }

.. _recommended_for_you:

**Recommended for you**


-  Note: link text is displayed when JavaScript is off
-  `Saved State module for ViewModel <#>`__
-  `Save UI states <#>`__
-  `LiveData overview <#>`__

Last updated 2023-07-12 UTC.



.. _viewmodel_scoping_apis:

/ViewModel Scoping APIs - Part of Android Jetpack
=================================================

Scope is key to using ViewModels effectively. Each ViewModel is scoped
to an object that implements the
`ViewModelStoreOwner <#>`__
interface. There are several APIs that allow you to more easily manage
the scope of your ViewModels. This document outlines some of the key
techniques you should know.

**Note:**\  For more information on scope and ViewModel lifecycle, see
the `ViewModel Overview <#scope>`__.

The ``ViewModelProvider.get()`` method lets you obtain an instance of a
ViewModel scoped to any ``ViewModelStoreOwner``. For Kotlin users, there
are different extension functions available for the most common use
cases. All Kotlin extension function implementations use the
ViewModelProvider API under the hood.

.. _viewmodels-scoped:

ViewModels scoped to the closest ViewModelStoreOwner
----------------------------------------------------

You can scope a ViewModel to an Activity, Fragment, or destination of a
Navigation graph. The
`viewModels() <#(androidx.activity.ComponentActivity)>`__
extension functions provided by the Activity, Fragment and Navigation
libraries, and the ``viewModel()`` function in Compose allows you to get
an instance of the ViewModel scoped to the closest
``ViewModelStoreOwner``.

.. container::

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: kotlin
            :class: two-line-tab

         .. code:: prettyprint

            import androidx.activity.viewModels

            class MyActivity : AppCompatActivity() {
                // ViewModel API available in activity.activity-ktx
                // The ViewModel is scoped to `this` Activity
                val viewModel: MyViewModel by viewModels()
            }

            import androidx.fragment.app.viewModels

            class MyFragment : Fragment() {
                // ViewModel API available in fragment.fragment-ktx
                // The ViewModel is scoped to `this` Fragment
                val viewModel: MyViewModel by viewModels()
            }

      .. container:: section

         .. rubric:: Views
            :name: java
            :class: two-line-tab

         .. code:: prettyprint

            import androidx.lifecycle.ViewModelProvider;

            public class MyActivity extends AppCompatActivity {
                // The ViewModel is scoped to `this` Activity
                MyViewModel viewModel = new ViewModelProvider(this).get(MyViewModel.class);
            }

            public class MyFragment extends Fragment {
                // The ViewModel is scoped to `this` Fragment
                MyViewModel viewModel = new ViewModelProvider(this).get(MyViewModel.class);
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose

         .. code:: prettyprint

            import androidx.lifecycle.viewmodel.compose.viewModel

            @Composable
            fun MyScreen(
                modifier: Modifier = Modifier,
                // ViewModel API available in lifecycle.lifecycle-viewmodel-compose
                // The ViewModel is scoped to the closest ViewModelStoreOwner provided
                // via the LocalViewModelStoreOwner CompositionLocal. In order of proximity,
                // this could be the destination of a Navigation graph, the host Fragment,
                // or the host Activity.
                viewModel: MyViewModel = viewModel()
            ) { /* ... */ }

**Note:**\  If you're using Hilt and Jetpack Compose, replace the
``viewModel()`` calls with ``hiltViewModel()`` as explained in the
`Compose + Hilt documentation <#hilt>`__.

.. _vm-api-any-owner:

ViewModels scoped to any ViewModelStoreOwner
--------------------------------------------

The ``ComponentActivity.viewModels()`` and ``Fragment.viewModels()``
functions in the View system and the ``viewModel()`` function in Compose
take an optional ``ownerProducer`` parameter that you can use to specify
to which ``ViewModelStoreOwner`` the instance of the ViewModel is scoped
to. The following sample shows how to get an instance of a ViewModel
scoped to the parent fragment:

.. container::

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: kotlin
            :class: two-line-tab

         .. code:: prettyprint

            import androidx.fragment.app.viewModels

            class MyFragment : Fragment() {

                // ViewModel API available in fragment.fragment-ktx
                // The ViewModel is scoped to the parent of `this` Fragment
                val viewModel: SharedViewModel by viewModels(
                    ownerProducer = { requireParentFragment() }
                )
            }

      .. container:: section

         .. rubric:: Views
            :name: java
            :class: two-line-tab

         .. code:: prettyprint

            import androidx.lifecycle.ViewModelProvider;

            public class MyFragment extends Fragment {

                SharedViewModel viewModel;

                @Override
                public void onViewCreated(View view, Bundle savedInstanceState) {
                    // The ViewModel is scoped to the parent of `this` Fragment
                    viewModel = new ViewModelProvider(requireParentFragment())
                        .get(SharedViewModel.class);
                }
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose

         .. code:: prettyprint

            import androidx.lifecycle.viewmodel.compose.viewModel

            @Composable
            fun MyScreen(
                context: Context = LocalContext.current,
                // ViewModel API available in lifecycle.lifecycle-viewmodel-compose
                // The ViewModel is scoped to the parent of the host Fragment
                // where this composable function is called
                viewModel: SharedViewModel = viewModel(
                    viewModelStoreOwner = (context as Fragment).requireParentFragment()
                )
            ) { /* ... */ }

Getting an Activity-scoped ViewModel from a Fragment is a common use
case. When doing so, use the
`activityViewModels() <#(androidx.fragment.app.Fragment).activityViewModels>`__
Views extension function is available. If you're not using Views and
Kotlin, you can use the same APIs as above and by passing the right
owner.

.. container::

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: kotlin
            :class: two-line-tab

         .. code:: prettyprint

            import androidx.fragment.app.activityViewModels

            class MyFragment : Fragment() {

                // ViewModel API available in fragment.fragment-ktx
                // The ViewModel is scoped to the host Activity
                val viewModel: SharedViewModel by activityViewModels()
            }

      .. container:: section

         .. rubric:: Views
            :name: java
            :class: two-line-tab

         .. code:: prettyprint

            import androidx.lifecycle.ViewModelProvider;

            public class MyFragment extends Fragment {

                SharedViewModel viewModel;

                @Override
                public void onViewCreated(View view, Bundle savedInstanceState) {
                    // The ViewModel is scoped to the host Activity
                    viewModel = new ViewModelProvider(requireActivity())
                        .get(SharedViewModel.class);
                }
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose

         .. code:: prettyprint

            import androidx.lifecycle.viewmodel.compose.viewModel

            @Composable
            fun MyScreen(
                context: Context = LocalContext.current,
                // ViewModel API available in lifecycle.lifecycle-viewmodel-compose
                // The ViewModel is scoped to the Activity of the host Fragment
                // where this composable function is called
                viewModel: SharedViewModel = viewModel(
                    viewModelStoreOwner = (context as Fragment).requireActivity()
                )
            ) { /* ... */ }

**Note:**\  If you're using Hilt and Jetpack Compose, replace the
``viewModel()`` calls with ``hiltViewModel()`` as explained in the
`Compose + Hilt documentation <#hilt>`__.

.. _vm-api-navgraph:

ViewModels scoped to the Navigation graph
-----------------------------------------

Navigation graphs are also ViewModel store owners. If you're using
`Navigation Fragment <#>`__ or `Navigation Compose <#>`__, you can get an instance of a
ViewModel scoped to a Navigation graph with the
`navGraphViewModels(graphId) <#(androidx.fragment.app.Fragment).navGraphViewModels>`__
Views extension function.

.. container::

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: kotlin
            :class: two-line-tab

         .. code:: prettyprint

            import androidx.navigation.navGraphViewModels

            class MyFragment : Fragment() {

                // ViewModel API available in navigation.navigation-fragment
                // The ViewModel is scoped to the `nav_graph` Navigation graph
                val viewModel: SharedViewModel by navGraphViewModels(R.id.nav_graph)

                // Equivalent navGraphViewModels code using the viewModels API
                val viewModel: SharedViewModel by viewModels(
                    { findNavController().getBackStackEntry(R.id.nav_graph) }
                )
            }

      .. container:: section

         .. rubric:: Views
            :name: java
            :class: two-line-tab

         .. code:: prettyprint

            import androidx.lifecycle.ViewModelProvider;

            public class MyFragment extends Fragment {

                SharedViewModel viewModel;

                @Override
                public void onViewCreated(View view, Bundle savedInstanceState) {
                    NavController navController = NavHostFragment.findNavController(this);
                    NavBackStackEntry backStackEntry = navController.getBackStackEntry(R.id.my_graph);

                    // The ViewModel is scoped to the `nav_graph` Navigation graph
                    viewModel = new ViewModelProvider(backStackEntry).get(SharedViewModel.class);
                }
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose

         .. code:: prettyprint

            import androidx.lifecycle.viewmodel.compose.viewModel

            @Composable
            fun MyAppNavHost() {
                // ...
                composable("myScreen") { backStackEntry ->
                    // Retrieve the NavBackStackEntry of "parentNavigationRoute"
                    val parentEntry = remember(backStackEntry) {
                        navController.getBackStackEntry("parentNavigationRoute")
                    }
                    // Get the ViewModel scoped to the `parentNavigationRoute` Nav graph
                    val parentViewModel: SharedViewModel = viewModel(parentEntry)
                    // ...
                }
            }

If you're using Hilt in addition to Jetpack Navigation, you can use the
`hiltNavGraphViewModels(graphId) <#hiltnavgraphviewmodels>`__
API as follows.

.. container::

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Views
            :name: kotlin
            :class: two-line-tab

         .. code:: prettyprint

            import androidx.hilt.navigation.fragment.hiltNavGraphViewModels

            class MyFragment : Fragment() {

                // ViewModel API available in hilt.hilt-navigation-fragment
                // The ViewModel is scoped to the `nav_graph` Navigation graph
                // and is provided using the Hilt-generated ViewModel factory
                val viewModel: SharedViewModel by hiltNavGraphViewModels(R.id.nav_graph)
            }

      .. container:: section

         .. rubric:: Views
            :name: java
            :class: two-line-tab

         .. code:: prettyprint

            import androidx.hilt.navigation.HiltViewModelFactory;
            import androidx.lifecycle.ViewModelProvider;

            public class MyFragment extends Fragment {

                SharedViewModel viewModel;

                @Override
                public void onViewCreated(View view, Bundle savedInstanceState) {
                    NavController navController = NavHostFragment.findNavController(this);
                    NavBackStackEntry backStackEntry = navController.getBackStackEntry(R.id.my_graph);

                    // The ViewModel is scoped to the `nav_graph` Navigation graph
                    // and is provided using the Hilt-generated ViewModel factory
                    viewModel = new ViewModelProvider(
                        backStackEntry,
                        HiltViewModelFactory.create(getContext(), backStackEntry)
                    ).get(SharedViewModel.class);
                }
            }

      .. container:: section

         .. rubric:: Compose
            :name: compose

         .. code:: prettyprint

            import androidx.hilt.navigation.compose.hiltViewModel

            @Composable
            fun MyAppNavHost() {
                // ...
                composable("myScreen") { backStackEntry ->
                    val parentEntry = remember(backStackEntry) {
                        navController.getBackStackEntry("parentNavigationRoute")
                    }

                    // ViewModel API available in hilt.hilt-navigation-compose
                    // The ViewModel is scoped to the `parentNavigationRoute` Navigation graph
                    // and is provided using the Hilt-generated ViewModel factory
                    val parentViewModel: SharedViewModel = hiltViewModel(parentEntry)
                    // ...
                }
            }

.. _recommended_for_you:

**Recommended for you**

-  Note: link text is displayed when JavaScript is off
-  `Layouts and binding expressions <#>`__
-  `ViewModel overview <#>`__

Last updated 2023-07-12 UTC.



.. _saved_state_module_for_viewmodel:

/Saved State module for ViewModel Part of `Android Jetpack`
===========================================================

.. https://developer.android.google.cn/topic/libraries/architecture/viewmodel/viewmodel-savedstate

.. container::

   As mentioned in `Saving UI States <#use_onsaveinstancestate_as_backup_to_handle_system-initiated_process_death>`__,
   `ViewModel <#>`__ objects can
   handle configuration changes, so you don't need to worry about state in
   rotations or other cases. However, if you need to handle
   system-initiated process death, you might want to use the
   ``SavedStateHandle`` API as backup.

   UI state is usually stored or referenced in ``ViewModel`` objects and
   not activities, so using ``onSaveInstanceState()`` or
   ``rememberSaveable`` requires some boilerplate that the `saved state module <#>`__ can handle for you.

   When using this module, ``ViewModel`` objects receive a 
   `SavedStateHandle <#>`__
   object through its constructor. This object is a key-value map that lets
   you write and retrieve objects to and from the saved state. These values
   persist after the process is killed by the system and remain available
   through the same object.

   Saved state is tied to your task stack. If your task stack goes away, 
   your saved state also goes away. This can occur when force stopping an
   app, removing the app from the recents menu, or rebooting the device. In
   such cases, the task stack disappears and you can't restore the
   information in saved state. In `User-initiated UI state dismissal <#ui-dismissal-system>`__
   scenarios, saved state isn't restored. In
   `system-initiated <#ui-dismissal-system>`__
   scenarios, it is.

   **Key Point:**\  Usually, data stored in saved instance state is
   transient state that depends on user input or navigation. Examples of
   this can be the scroll position of a list, the id of the item the user
   wants more detail about, the in-progress selection of user preferences,
   or input in text fields.

   **Important:**\  the API to use depends on where the state is held and
   the logic that it requires. For state that is used in `business logic <#logic>`__, hold it in a
   ViewModel and save it using ``SavedStateHandle``. For state that is used
   in `UI logic <#logic>`__, use
   the ``onSaveInstanceState`` API in the View system or
   ``rememberSaveable`` in Compose.

   **Note:**\  State must be simple and lightweight. For complex or large
   data, you should use `local persistence <#local>`__.

   Setup
   -----

   Beginning with `Fragment 1.2.0 <#1.2.0>`__ 
   or its transitive
   dependency `Activity 1.1.0 <#1.1.0>`__, 
   you can accept a
   ``SavedStateHandle`` as a constructor argument to your ``ViewModel``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class SavedStateViewModel(private val state: SavedStateHandle) : ViewModel() { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class SavedStateViewModel extends ViewModel {
                   private SavedStateHandle state;

                   public SavedStateViewModel(SavedStateHandle savedStateHandle) {
                       state = savedStateHandle;
                   }

                   ...
               }

   You can then retrieve an instance of your ``ViewModel`` without any
   additional configuration. The default ``ViewModel`` factory provides the
   appropriate ``SavedStateHandle`` to your ``ViewModel``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MainFragment : Fragment() {
                   val vm: SavedStateViewModel by viewModels()

                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class MainFragment extends Fragment {
                   private SavedStateViewModel vm;

                   public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
                       vm = new ViewModelProvider(this).get(SavedStateViewModel.class);

                       ...


                   }

                   ...
               }

   When providing a custom `ViewModelProvider.Factory <#>`__
   instance, you can enable usage of ``SavedStateHandle`` by extending
   `AbstractSavedStateViewModelFactory <#>`__.

   **Note:**\  When using an earlier version of the fragments library,
   follow the instructions for declaring dependencies in the 
   `Lifecycle release notes <#declaring_dependencies>`__
   to add a dependency on ``lifecycle-viewmodel-savedstate`` and use
   `SavedStateViewModelFactory <#>`__
   as your factory.

   .. _savedstatehandle:

   Working with SavedStateHandle
   -----------------------------

   The ``SavedStateHandle`` class is a key-value map that allows you to
   write and retrieve data to and from the saved state through the
   `set() <#set>`__
   and
   `get() <#get>`__
   methods.

   By using ``SavedStateHandle``, the query value is retained across
   process death, ensuring that the user sees the same set of filtered data
   before and after recreation without the activity or fragment needing to
   manually save, restore, and forward that value back to the
   ``ViewModel``.

   **Caution:**\  ``SavedStateHandle`` only saves data written to it when
   the ``Activity`` is stopped. Writes to ``SavedStateHandle`` while the
   ``Activity`` is stopped aren't saved unless the ``Activity`` receives
   ``onStart`` followed by ``onStop`` again.

   ``SavedStateHandle`` also has other methods you might expect when
   interacting with a key-value map:

   -  `contains(String key) <#contains>`__
      - Checks if there is a value for the given key.
   -  `remove(String key) <#remove>`__
      - Removes the value for the given key.
   -  `keys() <#keys>`__
      - Returns all keys contained within the ``SavedStateHandle``.

   Additionally, you can retrieve values from ``SavedStateHandle`` using an
   observable data holder. The list of supported types are:

   -  `LiveData <#>`__.
   -  `StateFlow <#>`__.
   -  `Compose's State APIs <#>`__.

   **Warning:**\  These integrations with observable data holders make it
   more convenient to display UI with state persisted by `saved instance state <#onsaveinstancestate>`__.
   However, these integrations are also saved and restored using the same
   mechanisms as the basic ``get()`` and ``set()`` methods. A
   ``SavedStateHandle`` is saved when the
   `onSaveInstanceState <#onSaveInstanceState>`__
   is called on the connected activity or fragment. This means that while
   you can continue to update observable data holders from a
   ``SavedStateHandle`` while in the app is in the background, all state
   updates might be lost if the app process is killed before becoming
   foregrounded again.

   .. _savedstate-livedata:

   LiveData
   ~~~~~~~~

   Retrieve values from ``SavedStateHandle`` that are wrapped in a
   `LiveData <#>`__ observable
   using
   `getLiveData() <#getLiveData>`__.
   When the key's value is updated, the ``LiveData`` receives the new
   value. Most often, the value is set due to user interactions, such as
   entering a query to filter a list of data. This updated value can then
   be used to `transform ``LiveData </topic/libraries/architecture/livedata#transform_livedata>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class SavedStateViewModel(private val savedStateHandle: SavedStateHandle) : ViewModel() {
                   val filteredData: LiveData<List<String>> =
                       savedStateHandle.getLiveData<String>("query").switchMap { query ->
                       repository.getFilteredData(query)
                   }

                   fun setQuery(query: String) {
                       savedStateHandle["query"] = query
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class SavedStateViewModel extends ViewModel {
                   private SavedStateHandle savedStateHandle;
                   public LiveData<List<String>> filteredData;
                   public SavedStateViewModel(SavedStateHandle savedStateHandle) {
                       this.savedStateHandle = savedStateHandle;
                       LiveData<String> queryLiveData = savedStateHandle.getLiveData("query");
                       filteredData = Transformations.switchMap(queryLiveData, query -> {
                           return repository.getFilteredData(query);
                       });
                   }

                   public void setQuery(String query) {
                       savedStateHandle.set("query", query);
                   }
               }

   .. _savedstate-stateflow:

   StateFlow
   ~~~~~~~~~

   **Note:**\  ``StateFlow`` support was added in lifecycle version 2.5.0

   Retrieve values from ``SavedStateHandle`` that are wrapped in a
   `StateFlow <#>`__ observable
   using
   `getStateFlow() <#getStateFlow>`__.
   When you update the key's value, the ``StateFlow`` receives the new
   value. Most often, you might set the value due to user interactions,
   such as entering a query to filter a list of data. You can then
   transform this updated value using other `Flow operators <#modify>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class SavedStateViewModel(private val savedStateHandle: SavedStateHandle) : ViewModel() {
                   val filteredData: StateFlow<List<String>> =
                       savedStateHandle.getStateFlow<String>("query")
                           .flatMapLatest { query ->
                               repository.getFilteredData(query)
                           }

                   fun setQuery(query: String) {
                       savedStateHandle["query"] = query
                   }
               }

   .. _savedstate-compose-state:

   Experimental Compose's State support
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   **Note:**\  Experimental Compose State support was added in lifecycle
   version 2.5.0

   The ``lifecycle-viewmodel-compose`` artifact provides the experimental
   `saveable <#(androidx.lifecycle.SavedStateHandle).saveable>`__
   APIs that allow interoperability between ``SavedStateHandle`` and
   Compose's `Saver <#restore-ui-state>`__ so
   that any ``State`` that you can save via
   `rememberSaveable <#restore-ui-state>`__ with
   a custom ``Saver`` can also be saved with ``SavedStateHandle``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class SavedStateViewModel(private val savedStateHandle: SavedStateHandle) : ViewModel() {

                   var filteredData: List<String> by savedStateHandle.saveable {
                       mutableStateOf(emptyList())
                   }

                   fun setQuery(query: String) {
                       withMutableSnapshot {
                           filteredData += query
                       }
                   }
               }

   .. _types:

   Supported types
   ---------------

   Data kept within a ``SavedStateHandle`` is saved and restored as a
   `Bundle <#>`__, along with the rest of
   the
   `savedInstanceState <#>`__
   for the activity or fragment.

   .. _direct:

   Directly supported types
   ~~~~~~~~~~~~~~~~~~~~~~~~

   By default, you can call ``set()`` and ``get()`` on a 
   ``SavedStateHandle`` for the same data types as a ``Bundle``, as shown
   below:

   =========================== ==================
   **Type/Class support**      **Array support**
   =========================== ==================
   ``double``                  ``double[]``
   ``int``                     ``int[]``
   ``long``                    ``long[]``
   ``String``                  ``String[]``
   ``byte``                    ``byte[]``
   ``char``                    ``char[]``
   ``CharSequence``            ``CharSequence[]``
   ``float``                   ``float[]``
   ``Parcelable``              ``Parcelable[]``
   ``Serializable``            ``Serializable[]``
   ``short``                   ``short[]``
   ``SparseArray``             
   ``Binder``                  
   ``Bundle``                  
   ``ArrayList``               
   ``Size (only in API 21+)``  
   ``SizeF (only in API 21+)`` 
   =========================== ==================

   If the class does not extend one of those in the above list, consider
   making the class parcelable by adding the
   `@Parcelize <#>`__ Kotlin annotation or implementing
   `Parcelable <#>`__ directly.

   .. _non-parcelable:

   Saving non-parcelable classes
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If a class does not implement ``Parcelable`` or ``Serializable`` and
   cannot be modified to implement one of those interfaces, then it is not
   possible to directly save an instance of that class into a
   ``SavedStateHandle``.

   Beginning with `Lifecycle 2.3.0-alpha03 <#2.3.0-alpha03>`__,
   ``SavedStateHandle`` allows you to save any object by providing your own
   logic for saving and restoring your object as a
   `Bundle <#>`__ using the
   `setSavedStateProvider() <#setSavedStateProvider>`__
   method.
   `SavedStateRegistry.SavedStateProvider <#>`__
   is an interface that defines a single
   `saveState() <#saveState>`__
   method that returns a ``Bundle`` containing the state you want to save.
   When ``SavedStateHandle`` is ready to save its state, it calls
   ``saveState()`` to retrieve the ``Bundle`` from the
   ``SavedStateProvider`` and saves the ``Bundle`` for the associated key.

   Consider an example of an app that requests an image from the camera app
   via the
   `ACTION_IMAGE_CAPTURE <#ACTION_IMAGE_CAPTURE>`__
   intent, passing in a temporary file for where the camera should store
   the image. The ``TempFileViewModel`` encapsulates the logic for creating
   that temporary file.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class TempFileViewModel : ViewModel() {
                   private var tempFile: File? = null

                   fun createOrGetTempFile(): File {
                       return tempFile ?: File.createTempFile("temp", null).also {
                           tempFile = it
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class TempFileViewModel extends ViewModel {
                   private File tempFile = null;

                   public TempFileViewModel() {
                   }


                   @NonNull
                   public File createOrGetTempFile() {
                       if (tempFile == null) {
                           tempFile = File.createTempFile("temp", null);
                       }
                       return tempFile;
                   }
               }

   To ensure the temporary file is not lost if the activity's process is
   killed and later restored, ``TempFileViewModel`` can use the
   ``SavedStateHandle`` to persist its data. To allow ``TempFileViewModel``
   to save its data, implement ``SavedStateProvider`` and set it as a
   provider on the ``SavedStateHandle`` of the ``ViewModel``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private fun File.saveTempFile() = bundleOf("path", absolutePath)

               class TempFileViewModel(savedStateHandle: SavedStateHandle) : ViewModel() {
                   private var tempFile: File? = null
                   init {
                       savedStateHandle.setSavedStateProvider("temp_file") { // saveState()
                           if (tempFile != null) {
                               tempFile.saveTempFile()
                           } else {
                               Bundle()
                           }
                       }
                   }

                   fun createOrGetTempFile(): File {
                       return tempFile ?: File.createTempFile("temp", null).also {
                           tempFile = it
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class TempFileViewModel extends ViewModel {
                   private File tempFile = null;

                   public TempFileViewModel(SavedStateHandle savedStateHandle) {
                       savedStateHandle.setSavedStateProvider("temp_file",
                           new TempFileSavedStateProvider());
                   }
                   @NonNull
                   public File createOrGetTempFile() {
                       if (tempFile == null) {
                           tempFile = File.createTempFile("temp", null);
                       }
                       return tempFile;
                   }

                   private class TempFileSavedStateProvider implements SavedStateRegistry.SavedStateProvider {
                       @NonNull
                       @Override
                       public Bundle saveState() {
                           Bundle bundle = new Bundle();
                           if (tempFile != null) {
                               bundle.putString("path", tempFile.getAbsolutePath());
                           }
                           return bundle;
                       }
                   }
               }

   To restore the ``File`` data when the user returns, retrieve the
   ``temp_file`` ``Bundle`` from the ``SavedStateHandle``. This is the same
   ``Bundle`` provided by ``saveTempFile()`` that contains the absolute
   path. The absolute path can then be used to instantiate a new ``File``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private fun File.saveTempFile() = bundleOf("path", absolutePath)

               private fun Bundle.restoreTempFile() = if (containsKey("path")) {
                   File(getString("path"))
               } else {
                   null
               }

               class TempFileViewModel(savedStateHandle: SavedStateHandle) : ViewModel() {
                   private var tempFile: File? = null
                   init {
                       val tempFileBundle = savedStateHandle.get<Bundle>("temp_file")
                       if (tempFileBundle != null) {
                           tempFile = tempFileBundle.restoreTempFile()
                       }
                       savedStateHandle.setSavedStateProvider("temp_file") { // saveState()
                           if (tempFile != null) {
                               tempFile.saveTempFile()
                           } else {
                               Bundle()
                           }
                       }
                   }

                   fun createOrGetTempFile(): File {
                     return tempFile ?: File.createTempFile("temp", null).also {
                         tempFile = it
                     }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class TempFileViewModel extends ViewModel {
                   private File tempFile = null;

                   public TempFileViewModel(SavedStateHandle savedStateHandle) {
                       Bundle tempFileBundle = savedStateHandle.get("temp_file");
                       if (tempFileBundle != null) {
                           tempFile = TempFileSavedStateProvider.restoreTempFile(tempFileBundle);
                       }
                       savedStateHandle.setSavedStateProvider("temp_file", new TempFileSavedStateProvider());
                   }

                   @NonNull
                   public File createOrGetTempFile() {
                       if (tempFile == null) {
                           tempFile = File.createTempFile("temp", null);
                       }
                       return tempFile;
                   }

                   private class TempFileSavedStateProvider implements SavedStateRegistry.SavedStateProvider {
                       @NonNull
                       @Override
                       public Bundle saveState() {
                           Bundle bundle = new Bundle();
                           if (tempFile != null) {
                               bundle.putString("path", tempFile.getAbsolutePath());
                           }
                           return bundle;
                       }

                       @Nullable
                       private static File restoreTempFile(Bundle bundle) {
                           if (bundle.containsKey("path") {
                               return File(bundle.getString("path"));
                           }
                           return null;
                       }
                   }
               }

   .. _testing:

   SavedStateHandle in tests
   -------------------------

   To test a ``ViewModel`` that takes a ``SavedStateHandle`` as a
   dependency, create a new instance of ``SavedStateHandle`` with the test
   values it requires and pass it to the ``ViewModel`` instance you are
   testing.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyViewModelTest {

                   private lateinit var viewModel: MyViewModel

                   @Before
                   fun setup() {
                       val savedState = SavedStateHandle(mapOf("someIdArg" to testId))
                       viewModel = MyViewModel(savedState = savedState)
                   }
               }

   .. _resources:

   **Additional resources**


   For further information about the Saved State module for ``ViewModel``,
   see the following resources.

   **Codelabs**


   -  `Android lifecycle-aware components codelab <https://developers.google.cn/codelabs/codelabs/android-lifecycles/#6>`__

   .. _recommended_for_you:

   **Recommended for you**


   -  Note: link text is displayed when JavaScript is off
   -  `Save UI states <#>`__
   -  `Work with observable data objects <#>`__
   -  `Create ViewModels with dependencies <#>`__

   Last updated 2024-01-03 UTC.


.. _viewmodel_apis_cheat_sheet:

/ViewModel APIs cheat sheet - Part of Android Jetpack
======================================================

This cheat sheet lets you quickly see the different ViewModel APIs
available in Jetpack including the artifact where they can be found, the
scope of the returned ViewModel instance, and an example of how to use
them.

The cheat sheet is also `downloadable in PDF format <https://developer.android.google.cn/static/images/topic/libraries/architecture/viewmodel-apis-cheatsheet.pdf>`__.

.. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/viewmodel-apis-cheatsheet.png
   :target: https://developer.android.google.cn/static/images/topic/libraries/architecture/viewmodel-apis-cheatsheet.png
   :alt: ViewModel APIs available in Jetpack

Last updated 2023-07-12 UTC.



.. _livedata_overview:

/LiveData overview - Part of Android Jetpack
============================================

.. https://developer.android.google.cn/topic/libraries/view-binding

.. container::

   `LiveData <#>`__ is an
   observable data holder class. Unlike a regular observable, LiveData is
   lifecycle-aware, meaning it respects the lifecycle of other app
   components, such as activities, fragments, or services. This awareness
   ensures LiveData only updates app component observers that are in an
   active lifecycle state.

   **Note:**\  To import LiveData components into your Android project, see
   `Adding Components to your Project <#lifecycle>`__.

   LiveData considers an observer, which is represented by the
   `Observer <#>`__ class, to be
   in an active state if its lifecycle is in the
   `STARTED <#STARTED>`__
   or
   `RESUMED <#RESUMED>`__
   state. LiveData only notifies active observers about updates. Inactive
   observers registered to watch
   `LiveData <#>`__ objects aren't
   notified about changes.

   You can register an observer paired with an object that implements the
   `LifecycleOwner <#>`__
   interface. This relationship allows the observer to be removed when the
   state of the corresponding
   `Lifecycle <#>`__ object
   changes to
   `DESTROYED <#DESTROYED>`__.
   This is especially useful for activities and fragments because they can
   safely observe `LiveData <#>`__
   objects and not worry about leaks‚Äîactivities and fragments are instantly
   unsubscribed when their lifecycles are destroyed.

   For more information about how to use LiveData, see `Work with LiveData objects <#work_livedata>`__.

   .. _the_advantages_of_using_livedata:

   The advantages of using LiveData
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Using LiveData provides the following advantages: 

   **Ensures your UI matches your data state**
      LiveData follows the observer pattern. LiveData notifies
      `Observer <#>`__ objects
      when underlying data changes. You can consolidate your code to update
      the UI in these ``Observer`` objects. That way, you don't need to
      update the UI every time the app data changes because the observer
      does it for you.
   **No memory leaks**
      Observers are bound to
      `Lifecycle <#>`__ objects
      and clean up after themselves when their associated lifecycle is
      destroyed.
   **No crashes due to stopped activities**
      If the observer's lifecycle is inactive, such as in the case of an
      activity in the back stack, then it doesn‚Äôt receive any LiveData
      events.
   **No more manual lifecycle handling**
      UI components just observe relevant data and don‚Äôt stop or resume
      observation. LiveData automatically manages all of this since it‚Äôs
      aware of the relevant lifecycle status changes while observing.
   **Always up to date data**
      If a lifecycle becomes inactive, it receives the latest data upon
      becoming active again. For example, an activity that was in the
      background receives the latest data right after it returns to the
      foreground.
   **Proper configuration changes**
      If an activity or fragment is recreated due to a configuration
      change, like device rotation, it immediately receives the latest
      available data.
   **Sharing resources**
      You can extend a
      `LiveData <#>`__ object
      using the singleton pattern to wrap system services so that they can
      be shared in your app. The ``LiveData`` object connects to the system
      service once, and then any observer that needs the resource can just
      watch the ``LiveData`` object. For more information, see `Extend LiveData <#extend_livedata>`__.

   .. _work_livedata:

   Work with LiveData objects
   --------------------------

   Follow these steps to work with `LiveData <#>`__ objects:

   #. Create an instance of ``LiveData`` to hold a certain type of data.
      This is usually done within your
      `ViewModel <#>`__ class.

   #. Create an `Observer <#>`__
      object that defines the
      `onChanged() <#onChanged>`__
      method, which controls what happens when the ``LiveData`` object's
      held data changes. You usually create an ``Observer`` object in a UI
      controller, such as an activity or fragment.

   #. Attach the ``Observer`` object to the ``LiveData`` object using the
      `observe() <#observe>`__
      method. The ``observe()`` method takes a
      `LifecycleOwner <#>`__
      object. This subscribes the ``Observer`` object to the ``LiveData``
      object so that it is notified of changes. You usually attach the
      ``Observer`` object in a UI controller, such as an activity or
      fragment.

      **Note:**\  You can register an observer without an associated
      `LifecycleOwner <#>`__
      object using the
      `observeForever(Observer) <#observeForever>`__
      method. In this case, the observer is considered to be always active
      and is therefore always notified about modifications. You can remove
      these observers calling the
      `removeObserver(Observer) <#removeObserver>`__
      method.

   When you update the value stored in the ``LiveData`` object, it triggers
   all registered observers as long as the attached ``LifecycleOwner`` is
   in the active state.

   LiveData allows UI controller observers to subscribe to updates. When
   the data held by the ``LiveData`` object changes, the UI automatically
   updates in response.

   .. _create_livedata_objects:

   Create LiveData objects
   ~~~~~~~~~~~~~~~~~~~~~~~

   LiveData is a wrapper that can be used with any data, including objects
   that implement `Collections <#>`__,
   such as `List <#>`__. A
   `LiveData <#>`__ object is
   usually stored within a
   `ViewModel <#>`__ object and
   is accessed via a getter method, as demonstrated in the following
   example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class NameViewModel : ViewModel() {

                   // Create a LiveData with a String
                   val currentName: MutableLiveData<String> by lazy {
                       MutableLiveData<String>()
                   }

                   // Rest of the ViewModel...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class NameViewModel extends ViewModel {

               // Create a LiveData with a String
               private MutableLiveData<String> currentName;

                   public MutableLiveData<String> getCurrentName() {
                       if (currentName == null) {
                           currentName = new MutableLiveData<String>();
                       }
                       return currentName;
                   }

               // Rest of the ViewModel...
               }

   Initially, the data in a ``LiveData`` object is not set.

      **Note:**\  Make sure to store ``LiveData`` objects that update the
      UI in ``ViewModel`` objects, as opposed to an activity or fragment,
      for the following reasons:

      -  To avoid bloated activities and fragments. Now these UI
         controllers are responsible for displaying data but not holding
         data state.
      -  To decouple ``LiveData`` instances from specific activity or
         fragment instances and allow ``LiveData`` objects to survive
         configuration changes.

   You can read more about the benefits and usage of the ``ViewModel``
   class in the `ViewModel guide <#>`__.

   .. _observe_livedata_objects:

   Observe LiveData objects
   ~~~~~~~~~~~~~~~~~~~~~~~~

   In most cases, an app component‚Äôs 
   `onCreate() <#onCreate>`__
   method is the right place to begin observing a
   `LiveData <#>`__ object for the
   following reasons:

   -  To ensure the system doesn‚Äôt make redundant calls from an activity or
      fragment‚Äôs
      `onResume() <#onResume>`__
      method.
   -  To ensure that the activity or fragment has data that it can display
      as soon as it becomes active. As soon as an app component is in the
      `STARTED <#STARTED>`__
      state, it receives the most recent value from the ``LiveData``
      objects it‚Äôs observing. This only occurs if the ``LiveData`` object
      to be observed has been set.

   Generally, LiveData delivers updates only when data changes, and only to
   active observers. An exception to this behavior is that observers also
   receive an update when they change from an inactive to an active state.
   Furthermore, if the observer changes from inactive to active a second
   time, it only receives an update if the value has changed since the last
   time it became active.

   The following sample code illustrates how to start observing a
   ``LiveData`` object:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class NameActivity : AppCompatActivity() {

                   // Use the 'by viewModels()' Kotlin property delegate
                   // from the activity-ktx artifact
                   private val model: NameViewModel by viewModels()

                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)

                       // Other code to setup the activity...

                       // Create the observer which updates the UI.
                       val nameObserver = Observer<String> { newName ->
                           // Update the UI, in this case, a TextView.
                           nameTextView.text = newName
                       }

                       // Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.
                       model.currentName.observe(this, nameObserver)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class NameActivity extends AppCompatActivity {

                   private NameViewModel model;

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);

                       // Other code to setup the activity...

                       // Get the ViewModel.
                       model = new ViewModelProvider(this).get(NameViewModel.class);

                       // Create the observer which updates the UI.
                       final Observer<String> nameObserver = new Observer<String>() {
                           @Override
                           public void onChanged(@Nullable final String newName) {
                               // Update the UI, in this case, a TextView.
                               nameTextView.setText(newName);
                           }
                       };

                       // Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.
                       model.getCurrentName().observe(this, nameObserver);
                   }
               }

   After `observe() <#observe>`__ is called with ``nameObserver`` passed as parameter,
   `onChanged() <#onChanged>`__
   is immediately invoked providing the most recent value stored in
   ``mCurrentName``. If the ``LiveData`` object hasn't set a value in
   ``mCurrentName``, ``onChanged()`` is not called.

   .. _update_livedata_objects:

   Update LiveData objects
   ~~~~~~~~~~~~~~~~~~~~~~~

   LiveData has no publicly available methods to update the stored data.
   The
   `MutableLiveData <#>`__
   class exposes the
   `setValue(T) <#setValue>`__
   and
   `postValue(T) <#postValue>`__
   methods publicly and you must use these if you need to edit the value
   stored in a `LiveData <#>`__
   object. Usually ``MutableLiveData`` is used in the
   `ViewModel <#>`__ and then the
   ``ViewModel`` only exposes immutable ``LiveData`` objects to the
   observers.

   After you have set up the observer relationship, you can then update the
   value of the ``LiveData`` object, as illustrated by the following
   example, which triggers all observers when the user taps a button:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               button.setOnClickListener {
                   val anotherName = "John Doe"
                   model.currentName.setValue(anotherName)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               button.setOnClickListener(new OnClickListener() {
                   @Override
                   public void onClick(View v) {
                       String anotherName = "John Doe";
                       model.getCurrentName().setValue(anotherName);
                   }
               });

   Calling ``setValue(T)`` in the example results in the observers calling
   their
   `onChanged() <#onChanged>`__
   methods with the value ``John Doe``. The example shows a button press,
   but ``setValue()`` or ``postValue()`` could be called to update
   ``mName`` for a variety of reasons, including in response to a network
   request or a database load completing; in all cases, the call to
   ``setValue()`` or ``postValue()`` triggers observers and updates the UI.

   **Note:**\  You must call the
   `setValue(T) <#setValue>`__
   method to update the ``LiveData`` object from the main thread. If the
   code is executed in a worker thread, you can use the
   `postValue(T) <#postValue>`__
   method instead to update the ``LiveData`` object.

   .. _use_livedata_with_room:

   Use LiveData with Room
   ~~~~~~~~~~~~~~~~~~~~~~

   The `Room <#>`__ persistence library supports observable queries, which return
   `LiveData <#>`__ objects.
   Observable queries are written as part of a Database Access Object
   (DAO).

   Room generates all the necessary code to update the ``LiveData`` object
   when a database is updated. The generated code runs the query
   asynchronously on a background thread when needed. This pattern is
   useful for keeping the data displayed in a UI in sync with the data
   stored in a database. You can read more about Room and DAOs in the `Room persistent library guide <#>`__.

   .. _coroutines:

   Use coroutines with LiveData
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``LiveData`` includes support for Kotlin coroutines. For more
   information, see `Use Kotlin coroutines with Android Architecture Components <#>`__.

   .. _livedata-in-architecture:

   LiveData in an app's architecture
   ---------------------------------

   ``LiveData`` is lifecycle-aware, following the lifecycle of entities
   such as activities and fragments. Use ``LiveData`` to communicate
   between these lifecycle owners and other objects with a different
   lifespan, such as ``ViewModel`` objects. The main responsibility of the
   ``ViewModel`` is to load and manage UI-related data, which makes it a
   great candidate for holding ``LiveData`` objects. Create ``LiveData``
   objects in the ``ViewModel`` and use them to expose state to the UI
   layer.

   Activities and fragments should not hold ``LiveData`` instances because
   their role is to display data, not hold state. Also, keeping activities
   and fragments free from holding data makes it easier to write unit
   tests.

   It may be tempting to work ``LiveData`` objects in your data layer
   class, but ``LiveData``\ is not designed to handle asynchronous streams
   of data. Even though you can use ``LiveData`` transformations and
   `MediatorLiveData <#>`__
   to achieve this, this approach has drawbacks: the capability to combine
   streams of data is very limited and all ``LiveData`` objects (including
   ones created through transformations) are observed on the main thread.
   The code below is an example of how holding a ``LiveData`` in the
   ``Repository`` can block the main thread:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class UserRepository {

                   // DON'T DO THIS! LiveData objects should not live in the repository.
                   fun getUsers(): LiveData<List<User>> {
                       ...
                   }

                   fun getNewPremiumUsers(): LiveData<List<User>> {
                       return getUsers().map { users ->
                           // This is an expensive call being made on the main thread and may
                           // cause noticeable jank in the UI!
                           users
                               .filter { user ->
                                 user.isPremium
                               }
                         .filter { user ->
                             val lastSyncedTime = dao.getLastSyncedTime()
                             user.timeCreated > lastSyncedTime
                               }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class UserRepository {

                   // DON'T DO THIS! LiveData objects should not live in the repository.
                   LiveData<List<User>> getUsers() {
                       ...
                   }

                   LiveData<List<User>> getNewPremiumUsers() {
                   return Transformations.map(getUsers(),
                       // This is an expensive call being made on the main thread and may cause
                       // noticeable jank in the UI!
                       users -> users.stream()
                           .filter(User::isPremium)
                           .filter(user ->
                               user.getTimeCreated() > dao.getLastSyncedTime())
                           .collect(Collectors.toList()));
                   }
               }

   If you need to use streams of data in other layers of your app, consider
   using `Kotlin Flows <#>`__ and then converting them to
   ``LiveData`` in the ``ViewModel`` using
   `asLiveData() <#aslivedata>`__.
   Learn more about using Kotlin ``Flow`` with ``LiveData`` in `this codelab <#>`__. For codebases built
   with Java, consider using `Executors <#>`__ in
   conjunction with callbacks or ``RxJava``.

   .. _extend_livedata:

   Extend LiveData
   ---------------

   LiveData considers an observer to be in an active state if the
   observer's lifecycle is in either the
   `STARTED <#STARTED>`__
   or
   `RESUMED <#RESUMED>`__
   states. The following sample code illustrates how to extend the
   `LiveData <#>`__ class:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class StockLiveData(symbol: String) : LiveData<BigDecimal>() {
                   private val stockManager = StockManager(symbol)

                   private val listener = { price: BigDecimal ->
                       value = price
                   }

                   override fun onActive() {
                       stockManager.requestPriceUpdates(listener)
                   }

                   override fun onInactive() {
                       stockManager.removeUpdates(listener)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class StockLiveData extends LiveData<BigDecimal> {
                   private StockManager stockManager;

                   private SimplePriceListener listener = new SimplePriceListener() {
                       @Override
                       public void onPriceChanged(BigDecimal price) {
                           setValue(price);
                       }
                   };

                   public StockLiveData(String symbol) {
                       stockManager = new StockManager(symbol);
                   }

                   @Override
                   protected void onActive() {
                       stockManager.requestPriceUpdates(listener);
                   }

                   @Override
                   protected void onInactive() {
                       stockManager.removeUpdates(listener);
                   }
               }

   The implementation of the price listener in this example includes the
   following important methods:

   -  The
      `onActive() <#onActive>`__
      method is called when the ``LiveData`` object has an active observer.
      This means you need to start observing the stock price updates from
      this method.
   -  The
      `onInactive() <#onInactive>`__
      method is called when the ``LiveData`` object doesn't have any active
      observers. Since no observers are listening, there is no reason to
      stay connected to the ``StockManager`` service.
   -  The
      `setValue(T) <#setValue>`__
      method updates the value of the ``LiveData`` instance and notifies
      any active observers about the change.

   You can use the ``StockLiveData`` class as follows: 

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               public class MyFragment : Fragment() {
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       super.onViewCreated(view, savedInstanceState)
                       val myPriceListener: LiveData<BigDecimal> = ...
                       myPriceListener.observe(viewLifecycleOwner, Observer<BigDecimal> { price: BigDecimal? ->
                           // Update the UI.
                       })
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyFragment extends Fragment {
                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       super.onViewCreated(view, savedInstanceState);
                       LiveData<BigDecimal> myPriceListener = ...;
                       myPriceListener.observe(getViewLifecycleOwner(), price -> {
                           // Update the UI.
                       });
                   }
               }

   The `observe() <#observe>`__ method passes the `LifecycleOwner <#>`__
   associated with the fragment's view as the first argument. Doing so
   denotes that this observer is bound to the
   `Lifecycle <#>`__ object
   associated with the owner, meaning:

   -  If the ``Lifecycle`` object is not in an active state, then the
      observer isn't called even if the value changes.
   -  After the ``Lifecycle`` object is destroyed, the observer is
      automatically removed.

   The fact that ``LiveData`` objects are lifecycle-aware means that you
   can share them between multiple activities, fragments, and services. To
   keep the example simple, you can implement the ``LiveData`` class as a
   singleton as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class StockLiveData(symbol: String) : LiveData<BigDecimal>() {
                   private val stockManager: StockManager = StockManager(symbol)

                   private val listener = { price: BigDecimal ->
                       value = price
                   }

                   override fun onActive() {
                       stockManager.requestPriceUpdates(listener)
                   }

                   override fun onInactive() {
                       stockManager.removeUpdates(listener)
                   }

                   companion object {
                       private lateinit var sInstance: StockLiveData

                       @MainThread
                       fun get(symbol: String): StockLiveData {
                           sInstance = if (::sInstance.isInitialized) sInstance else StockLiveData(symbol)
                           return sInstance
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class StockLiveData extends LiveData<BigDecimal> {
                   private static StockLiveData sInstance;
                   private StockManager stockManager;

                   private SimplePriceListener listener = new SimplePriceListener() {
                       @Override
                       public void onPriceChanged(BigDecimal price) {
                           setValue(price);
                       }
                   };

                   @MainThread
                   public static StockLiveData get(String symbol) {
                       if (sInstance == null) {
                           sInstance = new StockLiveData(symbol);
                       }
                       return sInstance;
                   }

                   private StockLiveData(String symbol) {
                       stockManager = new StockManager(symbol);
                   }

                   @Override
                   protected void onActive() {
                       stockManager.requestPriceUpdates(listener);
                   }

                   @Override
                   protected void onInactive() {
                       stockManager.removeUpdates(listener);
                   }
               }

   And you can use it in the fragment as follows: 

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyFragment : Fragment() {

                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       super.onViewCreated(view, savedInstanceState)
                       StockLiveData.get(symbol).observe(viewLifecycleOwner, Observer<BigDecimal> { price: BigDecimal? ->
                           // Update the UI.
                       })

                   }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyFragment extends Fragment {
                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       super.onViewCreated(view, savedInstanceState);
                       StockLiveData.get(symbol).observe(getViewLifecycleOwner(), price -> {
                           // Update the UI.
                       });
                   }
               }

   Multiple fragments and activities can observe the ``MyPriceListener``
   instance. LiveData only connects to the system service if one or more of
   them is visible and active.

   .. _transform_livedata:

   Transform LiveData
   ------------------

   You may want to make changes to the value stored in a 
   `LiveData <#>`__ object before
   dispatching it to the observers, or you may need to return a different
   ``LiveData`` instance based on the value of another one. The
   `Lifecycle <#>`__
   package provides the
   `Transformations <#>`__
   class which includes helper methods that support these scenarios.

   `Transformations.map() <#map>`__
      Applies a function on the value stored in the ``LiveData`` object,
      and propagates the result downstream.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val userLiveData: LiveData<User> = UserLiveData()
               val userName: LiveData<String> = userLiveData.map {
                   user -> "${user.name} ${user.lastName}"
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               LiveData<User> userLiveData = ...;
               LiveData<String> userName = Transformations.map(userLiveData, user -> {
                   user.name + " " + user.lastName
               });

   `Transformations.switchMap() <#switchMap>`__
      Similar to ``map()``, applies a function to the value stored in the
      ``LiveData`` object and unwraps and dispatches the result downstream.
      The function passed to ``switchMap()`` must return a ``LiveData``
      object, as illustrated by the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private fun getUser(id: String): LiveData<User> {
                 ...
               }
               val userId: LiveData<String> = ...
               val user = userId.switchMap { id -> getUser(id) }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private LiveData<User> getUser(String id) {
                 ...;
               }

               LiveData<String> userId = ...;
               LiveData<User> user = Transformations.switchMap(userId, id -> getUser(id) );

   You can use transformation methods to carry information across the
   observer's lifecycle. The transformations aren't calculated unless an
   observer is watching the returned ``LiveData`` object. Because the
   transformations are calculated lazily, lifecycle-related behavior is
   implicitly passed down without requiring additional explicit calls or
   dependencies.

   If you think you need a ``Lifecycle`` object inside a 
   `ViewModel <#>`__ object, a
   transformation is probably a better solution. For example, assume that
   you have a UI component that accepts an address and returns the postal
   code for that address. You can implement the naive ``ViewModel`` for
   this component as illustrated by the following sample code:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyViewModel(private val repository: PostalCodeRepository) : ViewModel() {

                   private fun getPostalCode(address: String): LiveData<String> {
                       // DON'T DO THIS
                       return repository.getPostCode(address)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class MyViewModel extends ViewModel {
                   private final PostalCodeRepository repository;
                   public MyViewModel(PostalCodeRepository repository) {
                      this.repository = repository;
                   }

                   private LiveData<String> getPostalCode(String address) {
                      // DON'T DO THIS
                      return repository.getPostCode(address);
                   }
               }

   The UI component then needs to unregister from the previous ``LiveData``
   object and register to the new instance each time it calls
   ``getPostalCode()``. In addition, if the UI component is recreated, it
   triggers another call to the ``repository.getPostCode()`` method instead
   of using the previous call‚Äôs result.

   Instead, you can implement the postal code lookup as a transformation of
   the address input, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyViewModel(private val repository: PostalCodeRepository) : ViewModel() {
                   private val addressInput = MutableLiveData<String>()
                   val postalCode: LiveData<String> = addressInput.switchMap {
                           address -> repository.getPostCode(address) }


                   private fun setInput(address: String) {
                       addressInput.value = address
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class MyViewModel extends ViewModel {
                   private final PostalCodeRepository repository;
                   private final MutableLiveData<String> addressInput = new MutableLiveData();
                   public final LiveData<String> postalCode =
                           Transformations.switchMap(addressInput, (address) -> {
                               return repository.getPostCode(address);
                            });

                 public MyViewModel(PostalCodeRepository repository) {
                     this.repository = repository
                 }

                 private void setInput(String address) {
                     addressInput.setValue(address);
                 }
               }

   In this case, the ``postalCode`` field is defined as a transformation of
   the ``addressInput``. As long as your app has an active observer
   associated with the ``postalCode`` field, the field's value is
   recalculated and retrieved whenever ``addressInput`` changes.

   This mechanism allows lower levels of the app to create ``LiveData``
   objects that are lazily calculated on demand. A ``ViewModel`` object can
   easily obtain references to ``LiveData`` objects and then define
   transformation rules on top of them.

   .. _create_new_transformations:

   Create new transformations
   ~~~~~~~~~~~~~~~~~~~~~~~~~~

   There are a dozen different specific transformation that may be useful
   in your app, but they aren‚Äôt provided by default. To implement your own
   transformation you can you use the
   `MediatorLiveData <#>`__
   class, which listens to other
   `LiveData <#>`__ objects and
   processes events emitted by them. ``MediatorLiveData`` correctly
   propagates its state to the source ``LiveData`` object. To learn more
   about this pattern, see the reference documentation of the
   `Transformations <#>`__
   class.

   .. _merge_livedata:

   Merge multiple LiveData sources
   -------------------------------

   `MediatorLiveData <#>`__
   is a subclass of
   `LiveData <#>`__ that allows
   you to merge multiple LiveData sources. Observers of
   ``MediatorLiveData`` objects are then triggered whenever any of the
   original LiveData source objects change.

   For example, if you have a ``LiveData`` object in your UI that can be
   updated from a local database or a network, then you can add the
   following sources to the ``MediatorLiveData`` object:

   -  A ``LiveData`` object associated with the data stored in the
      database.
   -  A ``LiveData`` object associated with the data accessed from the
      network.

   Your activity only needs to observe the ``MediatorLiveData`` object to
   receive updates from both sources. For a detailed example, see the
   `Addendum: exposing network status <#addendum>`__ section of the
   `Guide to App Architecture <#>`__.

   Additional resources
   --------------------

   To learn more about the 
   `LiveData <#>`__ class, consult
   the following resources.

   **Samples**

   -  `Sunflower <https://github.com/android/sunflower>`__, a demo app
      demonstrating best practices with Architecture Components
   -  `Android Architecture Components Basic Sample <https://github.com/android/architecture-components-samples/tree/main/BasicSample>`__

   **Codelabs**

   -  Android Room with a View
      `(Java) <https://developers.google.cn/codelabs/codelabs/android-room-with-a-view>`__
      `(Kotlin) <https://developers.google.cn/codelabs/codelabs/android-room-with-a-view-kotlin>`__
   -  `Learn advanced coroutines with Kotlin Flow and LiveData <#>`__

   **Blogs**

   -  `ViewModels and LiveData: Patterns + AntiPatterns <https://medium.com/androiddevelopers/viewmodels-and-livedata-patterns-antipatterns-21efaef74a54>`__
   -  `LiveData beyond the ViewModel ‚Äî Reactive patterns using Transformations and MediatorLiveData <https://medium.com/androiddevelopers/livedata-beyond-the-viewmodel-reactive-patterns-using-transformations-and-mediatorlivedata-fda520ba00b7>`__
   -  `LiveData with SnackBar, Navigation and other events (the SingleLiveEvent case) <https://medium.com/androiddevelopers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150>`__

   **Videos**

   -  `Jetpack LiveData <https://www.youtube.com/watch?v=OMcDk2_4LSk>`__
   -  `Fun with LiveData (Android Dev Summit '18) <https://www.youtube.com/watch?v=2rO4r-JOQtA>`__

   .. _recommended_for_you:

   **Recommended for you**

   -  Note: link text is displayed when JavaScript is off
   -  `Use Kotlin coroutines with lifecycle-aware components <#>`__
   -  `Handling Lifecycles with Lifecycle-Aware Components <#>`__
   -  `Test your Paging implementation <#>`__

   Last updated 2024-01-03 UTC.



/Save UI states
===============

.. container:: devsite-article-body clearfix

   This guide discusses user expectations about UI state, and the
   options available for preserving state.

   Saving and restoring an activity's UI state quickly after the system
   destroys activities or applications is essential for a good user
   experience. Users expect the UI state to stay the same, but the
   system might destroy the activity and its stored state.

   To bridge the gap between user expectations and system behavior, use
   a combination of the following methods:

   -  `ViewModel <#>`__
      objects.
   -  Saved instance states within the following contexts:

      -  Jetpack Compose:
         `rememberSaveable <#rememberSaveable>`__.
      -  Views:
         `onSaveInstanceState() <#onSaveInstanceState>`__
         API.
      -  ViewModels:
         `SavedStateHandle <#>`__.

   -  Local storage to persist the UI state during app and activity
      transitions.

   The optimal solution depends on your UI data's complexity, your app's
   use cases, and finding a balance between data access speed and memory
   use.

   Make sure your app meets users' expectations and offers a fast,
   responsive interface. Avoid delays when loading data into the UI,
   particularly after common configuration changes like rotation.

   .. rubric:: User expectations and system behavior
      :name: expectations

   Depending upon the action a user takes, they either expect that
   activity state to be cleared or the state to be preserved. In some
   cases the system automatically does what is expected by the user. In
   other cases the system does the opposite of what the user expects.

   .. rubric:: User-initiated UI state dismissal
      :name: ui-dismissal-user

   The user expects that when they start an activity, the transient UI
   state of that activity remains the same until the user completely
   dismisses the activity. The user can completely dismiss an activity
   by doing the following:

   -  Swiping the activity off of the Overview (Recents) screen.
   -  Killing or force-quitting the app from the Settings screen.
   -  Rebooting the device.
   -  Completing some sort of "finishing" action (which is backed by
      ``Activity.finish()``).

   The user's assumption in these complete dismissal cases is that they
   have permanently navigated away from the activity, and if they
   re-open the activity they expect the activity to start from a clean
   state. The underlying system behavior for these dismissal scenarios
   matches the user expectation - the activity instance will get
   destroyed and removed from memory, along with any state stored in it
   and any saved instance state record associated with the activity.

   There are some exceptions to this rule about complete dismissal‚Äîfor
   example a user might expect a browser to take them to the exact
   webpage they were looking at before they exited the browser using the
   back button.

   .. rubric:: System-initiated UI state dismissal
      :name: ui-dismissal-system

   A user expects an activity's UI state to remain the same throughout a
   configuration change, such as rotation or switching into multi-window
   mode. However, by default the system destroys the activity when such
   a configuration change occurs, wiping away any UI state stored in the
   activity instance. To learn more about device configurations, see the
   `Configuration reference page <#lfields>`__. Note,
   it is possible (though not recommended) to override the default
   behavior for configuration changes. 
   See `Handling the configuration change yourself <#HandlingTheChange>`__
   for more details.

   A user also expects your activity's UI state to remain the same if
   they temporarily switch to a different app and then come back to your
   app later. For example, the user performs a search in your search
   activity and then presses the home button or answers a phone call -
   when they return to the search activity they expect to find the
   search keyword and results still there, exactly as before.

   In this scenario, your app is placed in the background the system
   does its best to keep your app process in memory. However, the system
   may destroy the application process while the user is away
   interacting with other apps. In such a case, the activity instance is
   destroyed, along with any state stored in it. When the user
   relaunches the app, the activity is unexpectedly in a clean state. To
   learn more about process death, 
   see `Processes and Application Lifecycle <#>`__.

   .. rubric:: Options for preserving UI state
      :name: options

   When the user's expectations about UI state don't match default
   system behavior, you must save and restore the user's UI state to
   ensure that the system-initiated destruction is transparent to the
   user.

   Each of the options for preserving UI state vary along the following
   dimensions that impact the user experience:

   .. list-table::
      :header-rows: 1

      - 

         - 
         - ViewModel
         - Saved instance state
         - Persistent storage
      - 

         - Storage location
         - in memory
         - in memory
         - on disk or network
      - 

         - Survives configuration change
         - Yes
         - Yes
         - Yes
      - 

         - Survives system-initiated process death
         - No
         - Yes
         - Yes
      - 

         - Survives user complete activity dismissal/onFinish()
         - No
         - No
         - Yes
      - 

         - Data limitations
         - complex objects are fine, but space is limited by available
            memory
         - only for primitive types and simple, small objects such as
            String
         - only limited by disk space or cost / time of retrieval from
            the network resource
      - 

         - Read/write time
         - quick (memory access only)
         - slow (requires serialization/deserialization)
         - slow (requires disk access or network transaction)

   **Note:**\  Saved instance state in the above table includes the
   ``onSaveInstanceState()`` and ``rememberSaveable`` APIs, and
   ``SavedStateHandle`` as part of ViewModels.

   .. rubric:: Use ViewModel to handle configuration changes
      :name: viewmodel

   ViewModel is ideal for storing and managing UI-related data while the
   user is actively using the application. It allows quick access to UI
   data and helps you avoid refetching data from network or disk across
   rotation, window resizing, and other commonly occurring configuration
   changes. To learn how to implement a ViewModel, see the `ViewModel guide <#>`__.

   ViewModel retains the data in memory, which means it is cheaper to
   retrieve than data from the disk or the network. A ViewModel is
   associated with an activity (or some other lifecycle owner) - it
   stays in memory during a configuration change and the system
   automatically associates the ViewModel with the new activity instance
   that results from the configuration change.

   ViewModels are automatically destroyed by the system when your user
   backs out of your activity or fragment or if you call ``finish()``,
   which means the state is cleared as the user expects in these
   scenarios.

   Unlike saved instance state, ViewModels are destroyed during a
   system-initiated process death. To reload data after a
   system-initiated process death in a ViewModel, use the
   `SavedStateHandle``
   API </topic/libraries/architecture/viewmodel/viewmodel-savedstate>`__.
   Alternatively, if the data is related to the UI and doesn't need to
   be held in the ViewModel, use ``onSaveInstanceState()`` in the View
   system or ``rememberSaveable`` in Jetpack Compose. If the data is
   *application data*, then it might be better to persist it to disk.

   If you already have an in-memory solution in place for storing your
   UI state across configuration changes, you may not need to use
   ViewModel.

   .. rubric:: Use Saved instance state as backup to handle
      system-initiated process death
      :name: onsaveinstancestate

   The
   `onSaveInstanceState() <#onSaveInstanceState>`__
   callback in the View system,
   `rememberSaveable <#rememberSaveable>`__
   in Jetpack Compose, and
   `SavedStateHandle <#>`__
   in ViewModels store data needed to reload the state of a UI
   controller, such as an activity or a fragment, if the system destroys
   and later recreates that controller. To learn how to implement saved
   instance state using ``onSaveInstanceState``, see *Saving and
   restoring activity state* in the `Activity Lifecycle guide <#asem>`__.

   Saved instance state bundles persist through both configuration
   changes and process death but are limited by storage and speed,
   because the different APIs serialize data. Serialization can consume
   a lot of memory if the objects being serialized are complicated.
   Because this process happens on the main thread during a
   configuration change, long-running serialization can cause dropped
   frames and visual stutter.

   **Key Point:**\  Saved instance state APIs only save data written to
   it when the ``Activity`` is stopped. Writing into it in between this
   lifecycle state defers the save operation till the next stopped
   lifecycle event.
   Don't use saved instance state to store large amounts of data, such
   as bitmaps, nor complex data structures that require lengthy
   serialization or deserialization. Instead, store only primitive types
   and simple, small objects such as ``String``. As such, use saved
   instance state to store a minimal amount of data necessary, such as
   an ID, to re-create the data necessary to restore the UI back to its
   previous state should the other persistence mechanisms fail. Most
   apps should implement this to handle system-initiated process death.

   **Note:**\  Android keeps a serialized copy of the data in memory,
   outside of your process. Depending on various factors, the system
   might try to optimize this process and leave the same Bundle object
   in memory without serialization for quicker access. These behaviors
   however, may change across Android API versions.
   **Warning:**\  The system can potentially store the data to disk if
   you use
   `PersistableBundle <#>`__
   instead of `Bundle <#>`__. However,
   Fragments, Jetpack Compose, and other AndroidX libraries don't
   support it. Thus, use ``Bundle`` instead.
   Depending on your app's use cases, you might not need to use saved
   instance state at all. For example, a browser might take the user
   back to the exact webpage they were looking at before they exited the
   browser. If your activity behaves this way, you can forego using
   saved instance state and instead persist everything locally.

   **Key Point:**\  Usually, data stored in saved instance state is
   transient state that depends on user input or navigation. Examples of
   this can be the scroll position of a list, the id of the item the
   user wants more detail about, the in-progress selection of user
   preferences, or input in text fields.
   Additionally, when you open an activity from an intent, the bundle of
   extras is delivered to the activity both when the configuration
   changes and when the system restores the activity. If a piece of UI
   state data, such as a search query, were passed in as an intent extra
   when the activity was launched, you could use the extras bundle
   instead of the saved instance state bundle. To learn more about
   intent extras, see `Intent and Intent Filters <#>`__.

   In either of these scenarios, you should still use a
   `ViewModel <#>`__ to avoid
   wasting cycles reloading data from the database during a
   configuration change.

   In cases where the UI data to preserve is simple and lightweight, you
   might use saved instance state APIs alone to preserve your state
   data.

   **Key Point:**\  The API to use depends on where the state is held
   and the logic that it requires. For state that is used in `business logic <#logic>`__, hold it in a
   ViewModel and save it using ``SavedStateHandle``. For state that is
   used in `UI logic <#logic>`__, use
   the ``onSaveInstanceState`` API in the View system or
   ``rememberSaveable`` in Compose.
   **Note:**\  To learn more about ``rememberSaveable``, check out the
   `State and Jetpack Compose <#restore-ui-state>`__ documentation.

   .. rubric:: Hook into saved state using SavedStateRegistry
      :name: savedstateregistry

   Beginning with `Fragment 1.1.0 <#1.1.0>`__ or its
   transitive dependency `Activity 1.0.0 <#version_100_3>`__, UI
   controllers, such as an ``Activity`` or ``Fragment``, implement
   `SavedStateRegistryOwner <#>`__
   and provide a
   `SavedStateRegistry <#>`__
   that is bound to that controller. ``SavedStateRegistry`` allows
   components to hook into your UI controller's saved state to consume
   or contribute to it. For example, the `Saved State module for ViewModel <#>`__
   uses ``SavedStateRegistry`` to create a ``SavedStateHandle`` and
   provide it to your ``ViewModel`` objects. You can retrieve the
   ``SavedStateRegistry`` from within your UI controller by calling
   `getSavedStateRegistry() <#getSavedStateRegistry>`__.

   Components that contribute to saved state must implement
   `SavedStateRegistry.SavedStateProvider <#>`__,
   which defines a single method called
   `saveState() <#saveState>`__.
   The ``saveState()`` method allows your component to return a
   ``Bundle`` containing any state that should be saved from that
   component. ``SavedStateRegistry`` calls this method during the saving
   state phase of the UI controller's lifecycle.

   **Important:**\  The ``SavedStateHandle`` only saves data written to
   it when the ``Activity`` is stopped. Writes to ``SavedStateHandle``
   while the ``Activity`` is stopped aren't saved unless the
   ``Activity`` receives ``onStart`` followed by ``onStop`` again.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class SearchManager : SavedStateRegistry.SavedStateProvider {
                   companion object {
                       private const val QUERY = "query"
                   }

                   private val query: String? = null

                   ...

                   override fun saveState(): Bundle {
                       return bundleOf(QUERY to query)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class SearchManager implements SavedStateRegistry.SavedStateProvider {
                   private static String QUERY = "query";
                   private String query = null;
                   ...

                   @NonNull
                   @Override
                   public Bundle saveState() {
                       Bundle bundle = new Bundle();
                       bundle.putString(QUERY, query);
                       return bundle;
                   }
               }

   To register a ``SavedStateProvider``, call
   `registerSavedStateProvider() <#registerSavedStateProvider>`__
   on the ``SavedStateRegistry``, passing a key to associate with the
   provider's data as well as the provider. The previously saved data
   for the provider can be retrieved from the saved state by calling
   `consumeRestoredStateForKey() <#consumeRestoredStateForKey>`__
   on the ``SavedStateRegistry``, passing in the key associated with the
   provider's data.

   Within an ``Activity`` or ``Fragment``, you can register a
   ``SavedStateProvider`` in ``onCreate()`` after calling
   ``super.onCreate()``. Alternatively, you can set a
   `LifecycleObserver <#>`__
   on a ``SavedStateRegistryOwner``, which implements
   `LifecycleOwner <#>`__,
   and register the ``SavedStateProvider`` once the ``ON_CREATE`` event
   occurs. By using a ``LifecycleObserver``, you can decouple the
   registration and retrieval of the previously saved state from the
   ``SavedStateRegistryOwner`` itself.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class SearchManager(registryOwner: SavedStateRegistryOwner) : SavedStateRegistry.SavedStateProvider {
                   companion object {
                       private const val PROVIDER = "search_manager"
                       private const val QUERY = "query"
                   }

                   private val query: String? = null

                   init {
                       // Register a LifecycleObserver for when the Lifecycle hits ON_CREATE
                       registryOwner.lifecycle.addObserver(LifecycleEventObserver { _, event ->
                           if (event == Lifecycle.Event.ON_CREATE) {
                               val registry = registryOwner.savedStateRegistry

                               // Register this object for future calls to saveState()
                               registry.registerSavedStateProvider(PROVIDER, this)

                               // Get the previously saved state and restore it
                               val state = registry.consumeRestoredStateForKey(PROVIDER)

                               // Apply the previously saved state
                               query = state?.getString(QUERY)
                           }
                       }
                   }

                   override fun saveState(): Bundle {
                       return bundleOf(QUERY to query)
                   }

                   ...
               }

               class SearchFragment : Fragment() {
                   private var searchManager = SearchManager(this)
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class SearchManager implements SavedStateRegistry.SavedStateProvider {
                   private static String PROVIDER = "search_manager";
                   private static String QUERY = "query";
                   private String query = null;

                   public SearchManager(SavedStateRegistryOwner registryOwner) {
                       registryOwner.getLifecycle().addObserver((LifecycleEventObserver) (source, event) -> {
                           if (event == Lifecycle.Event.ON_CREATE) {
                               SavedStateRegistry registry = registryOwner.getSavedStateRegistry();

                               // Register this object for future calls to saveState()
                               registry.registerSavedStateProvider(PROVIDER, this);

                               // Get the previously saved state and restore it
                               Bundle state = registry.consumeRestoredStateForKey(PROVIDER);

                               // Apply the previously saved state
                               if (state != null) {
                                   query = state.getString(QUERY);
                               }
                           }
                       });
                   }

                   @NonNull
                   @Override
                   public Bundle saveState() {
                       Bundle bundle = new Bundle();
                       bundle.putString(QUERY, query);
                       return bundle;
                   }

                   ...
               }

               class SearchFragment extends Fragment {
                   private SearchManager searchManager = new SearchManager(this);
                   ...
               }

   **Note:**\  ``SavedStateRegistry`` stores data in the same ``Bundle``
   as the other saved instance state APIs, therefore the same
   considerations and data limitations apply.

   .. rubric:: Use local persistence to handle process death for complex
      or large data
      :name: local

   Persistent local storage, such as a database or shared preferences,
   will survive for as long as your application is installed on the
   user's device (unless the user clears the data for your app). While
   such local storage survives system-initiated activity and application
   process death, it can be expensive to retrieve because it will have
   to be read from local storage in to memory. Often this persistent
   local storage may already be a part of your application architecture
   to store all data you don't want to lose if you open and close the
   activity.

   Neither ViewModel nor saved instance state are long-term storage
   solutions and thus are not replacements for local storage, such as a
   database. Instead you should use these mechanisms for temporarily
   storing transient UI state only and use persistent storage for other
   app data. See `Guide to App Architecture <#>`__ for more
   details about how to leverage local storage to persist your app model
   data long term (e.g. across restarts of the device).

   .. rubric:: Managing UI state: divide and conquer
      :name: manage

   You can efficiently save and restore UI state by dividing the work
   among the various types of persistence mechanisms. In most cases,
   each of these mechanisms should store a different type of data used
   in the activity, based on the tradeoffs of data complexity, access
   speed, and lifetime:

   -  Local persistence: Stores all the application data you don't want
      to lose if you open and close the activity.

      -  Example: A collection of song objects, which could include
         audio files and metadata.

   -  `ViewModel <#>`__:
      Stores in memory all the data needed to display the associated UI,
      the `screen UI state <#ui-state>`__.

      -  Example: The song objects of the most recent search and the
         most recent search query.

   -  Saved instance state: Stores a small amount of data needed to
      reload UI state if the system stops and then recreates the UI.
      Instead of storing complex objects here, persist the complex
      objects in local storage and store a unique ID for these objects
      in the saved instance state APIs.

      -  Example: Storing the most recent search query.

   As an example, consider an activity that lets you to search through
   your library of songs. Here's how different events should be handled:

   When the user adds a song, the
   `ViewModel <#>`__
   immediately delegates persisting this data locally. If this newly
   added song should be shown in the UI, you should also update the data
   in the ``ViewModel`` object to reflect the addition of the song.
   Remember to do all database inserts off of the main thread.

   When the user searches for a song, whatever complex song data you
   load from the database, it should be immediately stored in the
   ``ViewModel`` object as part of the screen UI state.

   When the activity goes into the background and the system calls the
   saved instance state APIs, the search query should be stored in saved
   instance state, in case the process recreates. Since the information
   is necessary to load application data persisted in this, store the
   search query in the ViewModel ``SavedStateHandle``. This is all the
   information you need to load the data and get the UI back into its
   current state.

   .. rubric:: Restore complex states: reassembling the pieces
      :name: restore

   When it is time for the user to return to the activity, there are two
   possible scenarios for recreating the activity:

   -  The activity is recreated after having been stopped by the system.
      The system has the query saved in an saved instance state bundle,
      and the UI should pass the query to the ``ViewModel`` if
      ``SavedStateHandle`` is not used. The ``ViewModel`` sees that it
      has no search results cached and delegates loading the search
      results using the given search query.
   -  The activity is created after a configuration change. Since the
      ``ViewModel`` instance hasn't been destroyed, the ``ViewModel``
      has all the information cached in memory and it doesn't need to
      re-query the database.

   **Note:**\  When an activity is initially created, the saved instance
   state bundle contains no data, and the ``ViewModel`` object is empty.
   When you create the ``ViewModel`` object, you pass an empty query,
   which tells the ``ViewModel`` object that there's no data to load
   yet. Therefore, the activity starts in an empty state.

   .. rubric:: Additional resources
      :name: resources

   To learn more about saving UI states, see the following resources.

   -  `UI layer documentation <#>`__
   -  `State and Jetpack Compose documentation <#>`__

   .. rubric:: Blogs
      :name: blogs

   -  `ViewModels: A simple example <https://medium.com/androiddevelopers/viewmodels-a-simple-example-ed5ac416317e>`__
   -  `ViewModels: Persistence, ``onSaveInstanceState()``, Restoring UI
      State and
      Loaders <https://medium.com/androiddevelopers/viewmodels-persistence-onsaveinstancestate-restoring-ui-state-and-loaders-fc7cc4a6c090>`__
   -  `Android lifecycle-aware components codelab <https://developers.google.cn/codelabs/codelabs/android-lifecycles>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Saved State module for ViewModel <#>`__
   -  `Handling Lifecycles with Lifecycle-Aware Components <#>`__
   -  `ViewModel overview <#>`__

Last updated 2024-03-12 UTC.



/Use Kotlin coroutines with lifecycle-aware components
======================================================

.. container:: devsite-article-body clearfix

   `Kotlin coroutines <https://developer.android.google.cn/topic/libraries/architecture/coroutines/kotlin/coroutines>`__ 
   provide an API that
   enables you to write asynchronous code. With Kotlin coroutines, you
   can define a
   `CoroutineScope <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/>`__,
   which helps you to manage when your coroutines should run. Each
   asynchronous operation runs within a particular scope.

   `Lifecycle-aware components <#>`__ provide
   first-class support for coroutines for logical scopes in your app
   along with an interoperability layer with
   `LiveData <#>`__. This topic
   explains how to use coroutines effectively with lifecycle-aware
   components.

   .. rubric:: Add KTX dependencies
      :name: dependencies

   The built-in coroutine scopes described in this topic are contained
   in the `KTX extensions <#>`__ for each corresponding
   component. Be sure to add the appropriate dependencies when using
   these scopes.

   -  For `ViewModelScope <#viewmodelscope>`__, use
      ``androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.0`` or higher.
   -  For `LifecycleScope <#lifecyclescope>`__, use
      ``androidx.lifecycle:lifecycle-runtime-ktx:2.4.0`` or higher.
   -  For `liveData <#livedata>`__, use
      ``androidx.lifecycle:lifecycle-livedata-ktx:2.4.0`` or higher.

   .. rubric:: Lifecycle-aware coroutine scopes
      :name: lifecycle-aware

   Lifecycle-aware components define the following built-in scopes that
   you can use in your app.

   .. rubric:: ViewModelScope
      :name: viewmodelscope

   A ``ViewModelScope`` is defined for each
   `ViewModel <#>`__ in your
   app. Any coroutine launched in this scope is automatically canceled
   if the ``ViewModel`` is cleared. Coroutines are useful here for when
   you have work that needs to be done only if the ``ViewModel`` is
   active. For example, if you are computing some data for a layout, you
   should scope the work to the ``ViewModel`` so that if the
   ``ViewModel`` is cleared, the work is canceled automatically to avoid
   consuming resources.

   You can access the ``CoroutineScope`` of a ``ViewModel`` through the
   ``viewModelScope`` property of the ViewModel, as shown in the
   following example:

   .. code:: prettyprint

      class MyViewModel: ViewModel() {
          init {
              viewModelScope.launch {
                  // Coroutine that will be canceled when the ViewModel is cleared.
              }
          }
      }

   .. rubric:: LifecycleScope
      :name: lifecyclescope

   A ``LifecycleScope`` is defined for each
   `Lifecycle <#>`__ object.
   Any coroutine launched in this scope is canceled when the
   ``Lifecycle`` is destroyed. You can access the ``CoroutineScope`` of
   the ``Lifecycle`` either via ``lifecycle.coroutineScope`` or
   ``lifecycleOwner.lifecycleScope`` properties.

   The example below demonstrates how to use
   ``lifecycleOwner.lifecycleScope`` to create precomputed text
   asynchronously:

   .. code:: prettyprint

      class MyFragment: Fragment() {
          override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
              super.onViewCreated(view, savedInstanceState)
              viewLifecycleOwner.lifecycleScope.launch {
                  val params = TextViewCompat.getTextMetricsParams(textView)
                  val precomputedText = withContext(Dispatchers.Default) {
                      PrecomputedTextCompat.create(longTextContent, params)
                  }
                  TextViewCompat.setPrecomputedText(textView, precomputedText)
              }
          }
      }

   .. rubric:: Restartable Lifecycle-aware coroutines
      :name: restart

   Even though the ``lifecycleScope`` provides a proper way to cancel
   long-running operations automatically when the ``Lifecycle`` is
   ``DESTROYED``, you might have other cases where you want to start the
   execution of a code block when the ``Lifecycle`` is in a certain
   state, and cancel when it is in another state. For example, you might
   want to collect a flow when the ``Lifecycle`` is ``STARTED`` and
   cancel the collection when it's ``STOPPED``. This approach processes
   the flow emissions only when the UI is visible on the screen, saving
   resources and potentially avoiding app crashes.

   For these cases, ``Lifecycle`` and ``LifecycleOwner`` provide the
   suspend ``repeatOnLifecycle`` API that does exactly that. The
   following example contains a code block that runs every time the
   associated ``Lifecycle`` is at least in the ``STARTED`` state and
   cancels when the ``Lifecycle`` is ``STOPPED``:

   .. code:: prettyprint

      class MyFragment : Fragment() {

          val viewModel: MyViewModel by viewModel()

          override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
              super.onViewCreated(view, savedInstanceState)

              // Create a new coroutine in the lifecycleScope
              viewLifecycleOwner.lifecycleScope.launch {
                  // repeatOnLifecycle launches the block in a new coroutine every time the
                  // lifecycle is in the STARTED state (or above) and cancels it when it's STOPPED.
                  viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                      // Trigger the flow and start listening for values.
                      // This happens when lifecycle is STARTED and stops
                      // collecting when the lifecycle is STOPPED
                      viewModel.someDataFlow.collect {
                          // Process item
                      }
                  }
              }
          }
      }

   .. rubric:: Lifecycle-aware flow collection
      :name: lifecycle-aware

   If you only need to perform lifecycle-aware collection on a single
   flow, you can use the
   `Flow.flowWithLifecycle() <#flowwithlifecycle>`__
   method to simplify your code:

   .. code:: prettyprint

      viewLifecycleOwner.lifecycleScope.launch {
          exampleProvider.exampleFlow()
              .flowWithLifecycle(viewLifecycleOwner.lifecycle, Lifecycle.State.STARTED)
              .collect {
                  // Process the value.
              }
      }

   However, if you need to perform lifecycle-aware collection on
   multiple flows in parallel, then you must collect each flow in
   different coroutines. In that case, it's more efficient to use
   ``repeatOnLifecycle()`` directly:

   .. code:: prettyprint

      viewLifecycleOwner.lifecycleScope.launch {
          viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
              // Because collect is a suspend function, if you want to
              // collect multiple flows in parallel, you need to do so in
              // different coroutines.
              launch {
                  flow1.collect { /* Process the value. */ }
              }

              launch {
                  flow2.collect { /* Process the value. */ }
              }
          }
      }

   .. rubric:: Suspend Lifecycle-aware coroutines
      :name: suspend

   Even though the ``CoroutineScope`` provides a proper way to cancel
   long-running operations automatically, you might have other cases
   where you want to suspend execution of a code block unless the
   ``Lifecycle`` is in a certain state. For example, to run a
   ``FragmentTransaction``, you must wait until the ``Lifecycle`` is at
   least ``STARTED``. For these cases, ``Lifecycle`` provides additional
   methods: ``lifecycle.whenCreated``, ``lifecycle.whenStarted``, and
   ``lifecycle.whenResumed``. Any coroutine run inside these blocks is
   suspended if the ``Lifecycle`` isn't at least in the minimal desired
   state.

   The example below contains a code block that runs only when the
   associated ``Lifecycle`` is at least in the ``STARTED`` state:

   .. code:: prettyprint

      class MyFragment: Fragment {
          init { // Notice that we can safely launch in the constructor of the Fragment.
              lifecycleScope.launch {
                  whenStarted {
                      // The block inside will run only when Lifecycle is at least STARTED.
                      // It will start executing when fragment is started and
                      // can call other suspend methods.
                      loadingView.visibility = View.VISIBLE
                      val canAccess = withContext(Dispatchers.IO) {
                          checkUserAccess()
                      }

                      // When checkUserAccess returns, the next line is automatically
                      // suspended if the Lifecycle is not *at least* STARTED.
                      // We could safely run fragment transactions because we know the
                      // code won't run unless the lifecycle is at least STARTED.
                      loadingView.visibility = View.GONE
                      if (canAccess == false) {
                          findNavController().popBackStack()
                      } else {
                          showContent()
                      }
                  }

                  // This line runs only after the whenStarted block above has completed.

              }
          }
      }

   If the ``Lifecycle`` is destroyed while a coroutine is active via one
   of the ``when`` methods, the coroutine is automatically canceled. In
   the example below, the ``finally`` block runs once the ``Lifecycle``
   state is ``DESTROYED``:

   .. code:: prettyprint

      class MyFragment: Fragment {
          init {
              lifecycleScope.launchWhenStarted {
                  try {
                      // Call some suspend functions.
                  } finally {
                      // This line might execute after Lifecycle is DESTROYED.
                      if (lifecycle.state >= STARTED) {
                          // Here, since we've checked, it is safe to run any
                          // Fragment transactions.
                      }
                  }
              }
          }
      }

   **Note:**\  Even though these methods provide convenience when
   working with ``Lifecycle``, you should use them only when the
   information is valid within the scope of the ``Lifecycle``
   (precomputed text, for example). Keep in mind that if the activity
   restarts, the coroutine is not restarted.
   **Warning:**\  Prefer collecting flows using the
   ``repeatOnLifecycle`` API instead of collecting inside the
   ``launchWhenX`` APIs. As the latter APIs suspend the coroutine
   instead of cancelling it when the ``Lifecycle`` is ``STOPPED``,
   upstream flows are kept active in the background, potentially
   emitting new items and wasting resources.

   .. rubric:: Use coroutines with LiveData
      :name: livedata

   When using `LiveData <#>`__,
   you might need to calculate values asynchronously. For example, you
   might want to retrieve a user's preferences and serve them to your
   UI. In these cases, you can use the ``liveData`` builder function to
   call a ``suspend`` function, serving the result as a ``LiveData``
   object.

   In the example below, ``loadUser()`` is a suspend function declared
   elsewhere. Use the ``liveData`` builder function to call
   ``loadUser()`` asynchronously, and then use ``emit()`` to emit the
   result:

   .. code:: prettyprint

      val user: LiveData<User> = liveData {
          val data = database.loadUser() // loadUser is a suspend function.
          emit(data)
      }

   The ``liveData`` building block serves as a `structured concurrency primitive <https://medium.com/@elizarov/structured-concurrency-722d765aa952>`__
   between coroutines and ``LiveData``. The code block starts executing
   when ``LiveData`` becomes active and is automatically canceled after
   a configurable timeout when the ``LiveData`` becomes inactive. If it
   is canceled before completion, it is restarted if the ``LiveData``
   becomes active again. If it completed successfully in a previous run,
   it doesn't restart. Note that it is restarted only if canceled
   automatically. If the block is canceled for any other reason (e.g.
   throwing a ``CancellationException``), it is **not** restarted.

   You can also emit multiple values from the block. Each ``emit()``
   call suspends the execution of the block until the ``LiveData`` value
   is set on the main thread.

   .. code:: prettyprint

      val user: LiveData<Result> = liveData {
          emit(Result.loading())
          try {
              emit(Result.success(fetchUser()))
          } catch(ioException: Exception) {
              emit(Result.error(ioException))
          }
      }

   You can also combine ``liveData`` with
   `Transformations <#>`__,
   as shown in the following example:

   .. code:: prettyprint

      class MyViewModel: ViewModel() {
          private val userId: LiveData<String> = MutableLiveData()
          val user = userId.switchMap { id ->
              liveData(context = viewModelScope.coroutineContext + Dispatchers.IO) {
                  emit(database.loadUserById(id))
              }
          }
      }

   You can emit multiple values from a ``LiveData`` by calling the
   ``emitSource()`` function whenever you want to emit a new value. Note
   that each call to ``emit()`` or ``emitSource()`` removes the
   previously-added source.

   .. code:: prettyprint

      class UserDao: Dao {
          @Query("SELECT * FROM User WHERE id = :id")
          fun getUser(id: String): LiveData<User>
      }

      class MyRepository {
          fun getUser(id: String) = liveData<User> {
              val disposable = emitSource(
                  userDao.getUser(id).map {
                      Result.loading(it)
                  }
              )
              try {
                  val user = webservice.fetchUser(id)
                  // Stop the previous emission to avoid dispatching the updated user
                  // as `loading`.
                  disposable.dispose()
                  // Update the database.
                  userDao.insert(user)
                  // Re-establish the emission with success type.
                  emitSource(
                      userDao.getUser(id).map {
                          Result.success(it)
                      }
                  )
              } catch(exception: IOException) {
                  // Any call to `emit` disposes the previous one automatically so we don't
                  // need to dispose it here as we didn't get an updated value.
                  emitSource(
                      userDao.getUser(id).map {
                          Result.error(exception, it)
                      }
                  )
              }
          }
      }

   For more coroutines-related information, see the following links:

   -  `Improve app performance with Kotlin coroutines <#>`__
   -  `Coroutines overview <https://kotlinlang.org/docs/reference/coroutines-overview.html>`__
   -  `Threading in CoroutineWorker <#>`__

   .. rubric:: Additional resources
      :name: additional_resources

   To learn more about using coroutines with lifecycle-aware components,
   consult the following additional resources.

   .. rubric:: Samples
      :name: samples

   .. rubric:: Blogs
      :name: blogs

   -  `Coroutines on Android: Application patterns <https://medium.com/androiddevelopers/coroutines-on-android-part-iii-real-work-2ba8a2ec2f45>`__
   -  `Easy coroutines in Android: viewModelScope <https://medium.com/androiddevelopers/easy-coroutines-in-android-viewmodelscope-25bffb605471>`__
   -  `Testing two consecutive LiveData emissions in coroutines <https://medium.com/androiddevelopers/testing-two-consecutive-livedata-emissions-in-coroutines-5680b693cbf8>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `LiveData overview <#>`__
   -  `Handling Lifecycles with Lifecycle-Aware Components <#>`__
   -  `Load and display paged data <#>`__

Last updated 2023-07-12 UTC.




.. _paging_library_overview:

/Overview: Paging library overview - Part of Android Jetpack
============================================================

.. https://developer.android.google.cn/topic/libraries/architecture/paging/v3-overview

.. container::

   The Paging library helps you load and display pages of data from a
   larger dataset from local storage or over a network. This approach lets
   your app use both network bandwidth and system resources more
   efficiently. The components of the Paging library are designed to fit
   into the recommended `Android app architecture <#>`__,
   integrate cleanly with other `Jetpack <#>`__ components, and
   provide first-class Kotlin support.

   .. _paging:

   Benefits of using the Paging library
   ------------------------------------

   The Paging library includes the following features:

   -  In-memory caching for your paged data. This helps ensure that your
      app uses system resources efficiently while working with paged data.
   -  Built-in request deduplication, which helps ensure that your app uses
      network bandwidth and system resources efficiently.
   -  Configurable
      `RecyclerView <#>`__
      adapters that automatically request data as the user scrolls toward
      the end of the loaded data.
   -  First-class support for Kotlin coroutines and flows as well as
      `LiveData <#>`__ and
      RxJava.
   -  Built-in support for error handling, including refresh and retry
      capabilities.

   .. _feedback:

   Provide feedback
   ----------------

   Your feedback helps make Jetpack better. Let us know if you discover new
   issues or have ideas for improving this library. Check the 
   `existing issues <https://issuetracker.google.com/issues?q=componentid:413106%20status:open>`__
   for this library before you create a new one. You can add your vote to
   an existing issue by clicking the star button.

   `Create a new issue <https://issuetracker.google.com/issues/new?component=413106&template=1096385>`__

   See the `Issue Tracker documentation <https://developers.google.cn/issue-tracker>`__ for more
   information about submitting feedback.

   Setup
   -----

   To import Paging components into your Android app, add the following
   dependencies to your app's ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                 def paging_version = "3.2.1"

                 implementation "androidx.paging:paging-runtime:$paging_version"

                 // alternatively - without Android dependencies for tests
                 testImplementation "androidx.paging:paging-common:$paging_version"

                 // optional - RxJava2 support
                 implementation "androidx.paging:paging-rxjava2:$paging_version"

                 // optional - RxJava3 support
                 implementation "androidx.paging:paging-rxjava3:$paging_version"

                 // optional - Guava ListenableFuture support
                 implementation "androidx.paging:paging-guava:$paging_version"

                 // optional - Jetpack Compose integration
                 implementation "androidx.paging:paging-compose:3.3.0-rc01"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                 val paging_version = "3.2.1"

                 implementation("androidx.paging:paging-runtime:$paging_version")

                 // alternatively - without Android dependencies for tests
                 testImplementation("androidx.paging:paging-common:$paging_version")

                 // optional - RxJava2 support
                 implementation("androidx.paging:paging-rxjava2:$paging_version")

                 // optional - RxJava3 support
                 implementation("androidx.paging:paging-rxjava3:$paging_version")

                 // optional - Guava ListenableFuture support
                 implementation("androidx.paging:paging-guava:$paging_version")

                 // optional - Jetpack Compose integration
                 implementation("androidx.paging:paging-compose:3.3.0-rc01")
               }

   .. _architecture:

   Library architecture
   --------------------

   The Paging library's components operate in three layers of your app:

   -  The repository layer
   -  The ``ViewModel`` layer
   -  The UI layer

   .. figure::
      /static/topic/libraries/architecture/images/paging3-library-architecture.svg
      name: library-architecture
      :alt: An image showing paged data flows from the PagingSource or
      RemoteMediator components in the repository layer to the Pager
      component in the ViewModel layer. Then the Pager component exposes a
      Flow of PagingData to the PagingDataAdapter in the UI layer.
      :width: 100.0%

      **Figure 1.** An example of how the Paging library fits into your app
      architecture.

   This section describes the Paging library components that operate at
   each layer and how they work together to load and display paged data.

   .. _repository:

   Repository layer
   ~~~~~~~~~~~~~~~~

   The primary Paging library component in the repository layer is
   `PagingSource <#>`__.
   Each ``PagingSource`` object defines a source of data and how to
   retrieve data from that source. A ``PagingSource`` object can load data
   from any single source, including network sources and local databases.

   Another Paging library component that you might use is 
   `RemoteMediator <#>`__.
   A ``RemoteMediator`` object handles paging from a layered data source,
   such as a network data source with a local database cache.

   .. _viewmodel:

   ViewModel layer
   ~~~~~~~~~~~~~~~

   The `Pager <#>`__ component 
   provides a public API for constructing instances of ``PagingData`` that
   are exposed in reactive streams, based on a ``PagingSource`` object and
   a `PagingConfig <#>`__
   configuration object.

   The component that connects the ``ViewModel`` layer to the UI is `PagingData <#>`__.
   A ``PagingData`` object is a container for a snapshot of paginated data.
   It queries a `PagingSource <#>`__ object and stores the result.

   .. _ui:

   UI layer
   ~~~~~~~~

   The primary Paging library component in the UI layer is 
   `PagingDataAdapter <#>`__,
   a
   `RecyclerView <#>`__
   adapter that handles paginated data.

   Alternatively, you can use the included 
   `AsyncPagingDataDiffer <#>`__
   component to build your own custom adapter.

   **Note:**\  If your app uses `Compose <#>`__ for its UI,
   use the
   `androidx.paging:paging-compose <#>`__
   artifact to integrate Paging with your UI layer instead. To learn more,
   see the API documentation for
   `collectAsLazyPagingItems() <#collectaslazypagingitems>`__.

   **Additional resources**


   To learn more about the Paging library, see the following additional
   resources:

   **Codelabs**


   -  `Android Paging Basics codelab <https://developer.android.google.cn/codelabs/android-paging-basics>`__
   -  `Android Paging Advanced codelab <https://developers.google.cn/codelabs/codelabs/android-paging>`__

   **Samples**


   -  `Android Architecture Components Paging sample <https://github.com/android/architecture-components-samples/tree/main/PagingSample>`__
   -  `Android Architecture Components Paging with Network sample <https://github.com/android/architecture-components-samples/tree/main/PagingWithNetworkSample>`__

   .. _recommended_for_you:

   **Recommended for you**


   -  Note: link text is displayed when JavaScript is off
   -  `Load and display paged data <#>`__
   -  `Migrate to Paging 3 <#>`__
   -  `Page from network and database <#>`__

   Last updated 2024-05-01 UTC.


/Load and display paged data
============================

.. container:: devsite-article-body clearfix

   The Paging library provides powerful capabilities for loading and
   displaying paged data from a larger dataset. This guide demonstrates
   how to use the Paging library to set up a stream of paged data from a
   network data source and display it in a
   `RecyclerView <#>`__.

   .. rubric:: Define a data source
      :name: data-source

   The first step is to define a
   `PagingSource <#>`__
   implementation to identify the data source. The ``PagingSource`` API
   class includes the
   `load() <#load>`__
   method, which you override to indicate how to retrieve paged data
   from the corresponding data source.

   Use the ``PagingSource`` class directly to use Kotlin coroutines for
   async loading. The Paging library also provides classes to support
   other async frameworks:

   -  To use RxJava, implement
      `RxPagingSource <#>`__
      instead.
   -  To use ``ListenableFuture`` from Guava, implement
      `ListenableFuturePagingSource <#>`__
      instead.

   **Note:**\  To use the Paging library with RxJava or Guava, you must
   include `additional dependencies <#setup>`__.

   .. rubric:: Select key and value types
      :name: key-value

   ``PagingSource<Key, Value>`` has two type parameters: ``Key`` and
   ``Value``. The key defines the identifier used to load the data, and
   the value is the type of the data itself. For example, if you load
   pages of ``User`` objects from the network by passing ``Int`` page
   numbers to `Retrofit <https://square.github.io/retrofit/>`__, select
   ``Int`` as the ``Key`` type and ``User`` as the ``Value`` type.

   .. rubric:: Define the PagingSource
      :name: pagingsource

   The following example implements a
   `PagingSource <#>`__
   that loads pages of items by page number. The ``Key`` type is ``Int``
   and the ``Value`` type is ``User``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               class ExamplePagingSource(
                   val backend: ExampleBackendService,
                   val query: String
               ) : PagingSource<Int, User>() {
                 override suspend fun load(
                   params: LoadParams<Int>
                 ): LoadResult<Int, User> {
                   try {
                     // Start refresh at page 1 if undefined.
                     val nextPageNumber = params.key ?: 1
                     val response = backend.searchUsers(query, nextPageNumber)
                     return LoadResult.Page(
                       data = response.users,
                       prevKey = null, // Only paging forward.
                       nextKey = response.nextPageNumber
                     )
                   } catch (e: Exception) {
                     // Handle errors in this block and return LoadResult.Error for
                     // expected errors (such as a network failure).
                   }
                 }

                 override fun getRefreshKey(state: PagingState<Int, User>): Int? {
                   // Try to find the page key of the closest page to anchorPosition from
                   // either the prevKey or the nextKey; you need to handle nullability
                   // here.
                   //  * prevKey == null -> anchorPage is the first page.
                   //  * nextKey == null -> anchorPage is the last page.
                   //  * both prevKey and nextKey are null -> anchorPage is the
                   //    initial page, so return null.
                   return state.anchorPosition?.let { anchorPosition ->
                     val anchorPage = state.closestPageToPosition(anchorPosition)
                     anchorPage?.prevKey?.plus(1) ?: anchorPage?.nextKey?.minus(1)
                   }
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               class ExamplePagingSource extends RxPagingSource<Integer, User> {
                 @NonNull
                 private ExampleBackendService mBackend;
                 @NonNull
                 private String mQuery;

                 ExamplePagingSource(@NonNull ExampleBackendService backend,
                   @NonNull String query) {
                   mBackend = backend;
                   mQuery = query;
                 }

                 @NotNull
                 @Override
                 public Single<LoadResult<Integer, User>> loadSingle(
                   @NotNull LoadParams<Integer> params) {
                   // Start refresh at page 1 if undefined.
                   Integer nextPageNumber = params.getKey();
                   if (nextPageNumber == null) {
                     nextPageNumber = 1;
                   }

                   return mBackend.searchUsers(mQuery, nextPageNumber)
                     .subscribeOn(Schedulers.io())
                     .map(this::toLoadResult)
                     .onErrorReturn(LoadResult.Error::new);
                 }

                 private LoadResult<Integer, User> toLoadResult(
                   @NonNull SearchUserResponse response) {
                   return new LoadResult.Page<>(
                     response.getUsers(),
                     null, // Only paging forward.
                     response.getNextPageNumber(),
                     LoadResult.Page.COUNT_UNDEFINED,
                     LoadResult.Page.COUNT_UNDEFINED);
                 }

                 @Nullable
                 @Override
                 public Integer getRefreshKey(@NotNull PagingState<Integer, User> state) {
                   // Try to find the page key of the closest page to anchorPosition from
                   // either the prevKey or the nextKey; you need to handle nullability
                   // here.
                   //  * prevKey == null -> anchorPage is the first page.
                   //  * nextKey == null -> anchorPage is the last page.
                   //  * both prevKey and nextKey are null -> anchorPage is the
                   //    initial page, so return null.
                   Integer anchorPosition = state.getAnchorPosition();
                   if (anchorPosition == null) {
                     return null;
                   }

                   LoadResult.Page<Integer, User> anchorPage = state.closestPageToPosition(anchorPosition);
                   if (anchorPage == null) {
                     return null;
                   }

                   Integer prevKey = anchorPage.getPrevKey();
                   if (prevKey != null) {
                     return prevKey + 1;
                   }

                   Integer nextKey = anchorPage.getNextKey();
                   if (nextKey != null) {
                     return nextKey - 1;
                   }

                   return null;
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               class ExamplePagingSource extends ListenableFuturePagingSource<Integer, User> {
                 @NonNull
                 private ExampleBackendService mBackend;
                 @NonNull
                 private String mQuery;
                 @NonNull
                 private Executor mBgExecutor;

                 ExamplePagingSource(
                   @NonNull ExampleBackendService backend,
                   @NonNull String query, @NonNull Executor bgExecutor) {
                   mBackend = backend;
                   mQuery = query;
                   mBgExecutor = bgExecutor;
                 }

                 @NotNull
                 @Override
                 public ListenableFuture<LoadResult<Integer, User>> loadFuture(@NotNull LoadParams<Integer> params) {
                   // Start refresh at page 1 if undefined.
                   Integer nextPageNumber = params.getKey();
                   if (nextPageNumber == null) {
                     nextPageNumber = 1;
                   }

                   ListenableFuture<LoadResult<Integer, User>> pageFuture =
                     Futures.transform(mBackend.searchUsers(mQuery, nextPageNumber),
                     this::toLoadResult, mBgExecutor);

                   ListenableFuture<LoadResult<Integer, User>> partialLoadResultFuture =
                     Futures.catching(pageFuture, HttpException.class,
                     LoadResult.Error::new, mBgExecutor);

                   return Futures.catching(partialLoadResultFuture,
                     IOException.class, LoadResult.Error::new, mBgExecutor);
                 }

                 private LoadResult<Integer, User> toLoadResult(@NonNull SearchUserResponse response) {
                   return new LoadResult.Page<>(response.getUsers(),
                   null, // Only paging forward.
                   response.getNextPageNumber(),
                   LoadResult.Page.COUNT_UNDEFINED,
                   LoadResult.Page.COUNT_UNDEFINED);
                 }

                 @Nullable
                 @Override
                 public Integer getRefreshKey(@NotNull PagingState<Integer, User> state) {
                   // Try to find the page key of the closest page to anchorPosition from
                   // either the prevKey or the nextKey; you need to handle nullability
                   // here.
                   //  * prevKey == null -> anchorPage is the first page.
                   //  * nextKey == null -> anchorPage is the last page.
                   //  * both prevKey and nextKey are null -> anchorPage is the
                   //    initial page, so return null.
                   Integer anchorPosition = state.getAnchorPosition();
                   if (anchorPosition == null) {
                     return null;
                   }

                   LoadResult.Page<Integer, User> anchorPage = state.closestPageToPosition(anchorPosition);
                   if (anchorPage == null) {
                     return null;
                   }

                   Integer prevKey = anchorPage.getPrevKey();
                   if (prevKey != null) {
                     return prevKey + 1;
                   }

                   Integer nextKey = anchorPage.getNextKey();
                   if (nextKey != null) {
                     return nextKey - 1;
                   }

                   return null;
                 }
               }

   A typical ``PagingSource`` implementation passes parameters provided
   in its constructor to the ``load()`` method to load appropriate data
   for a query. In the example above, those parameters are:

   -  ``backend``: an instance of the backend service that provides the
      data
   -  ``query``: the search query to send to the service indicated by
      ``backend``

   The
   `LoadParams <#>`__
   object contains information about the load operation to be performed.
   This includes the key to be loaded and the number of items to be
   loaded.

   The
   `LoadResult <#>`__
   object contains the result of the load operation. ``LoadResult`` is a
   sealed class that takes one of two forms, depending on whether the
   ``load()`` call succeeded:

   -  If the load is successful, return a ``LoadResult.Page`` object.
   -  If the load is not successful, return a ``LoadResult.Error``
      object.

   The following figure illustrates how the ``load()`` function in this
   example receives the key for each load and provides the key for the
   subsequent load.

   .. figure::
      /static/topic/libraries/architecture/images/paging3-source-load.svg
      name: source-load-fig
      :alt: On each load() call, the ExamplePagingSource takes in the
      current key and returns the next key to load.
      :width: 50.0%

      **Figure 1.** Diagram showing how ``load()`` uses and updates the
      key.

   The ``PagingSource`` implementation must also implement a
   `getRefreshKey() <#getrefreshkey>`__
   method that takes a
   `PagingState <#>`__
   object as a parameter. It returns the key to pass into the ``load()``
   method when the data is refreshed or invalidated after the initial
   load. The Paging Library calls this method automatically on
   subsequent refreshes of the data.

   .. rubric:: Handle errors
      :name: handle-errors

   Requests to load data can fail for a number of reasons, especially
   when loading over a network. Report errors encountered during loading
   by returning a ``LoadResult.Error`` object from the ``load()``
   method.

   For example, you can catch and report loading errors in
   ``ExamplePagingSource`` from the previous example by adding the
   following to the ``load()`` method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               catch (e: IOException) {
                 // IOException for network failures.
                 return LoadResult.Error(e)
               } catch (e: HttpException) {
                 // HttpException for any non-2xx HTTP status codes.
                 return LoadResult.Error(e)
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               return backend.searchUsers(searchTerm, nextPageNumber)
                 .subscribeOn(Schedulers.io())
                 .map(this::toLoadResult)
                 .onErrorReturn(LoadResult.Error::new);

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               ListenableFuture<LoadResult<Integer, User>> pageFuture = Futures.transform(
                 backend.searchUsers(query, nextPageNumber), this::toLoadResult,
                 bgExecutor);

               ListenableFuture<LoadResult<Integer, User>> partialLoadResultFuture = Futures.catching(
                 pageFuture, HttpException.class, LoadResult.Error::new,
                 bgExecutor);

               return Futures.catching(partialLoadResultFuture,
                 IOException.class, LoadResult.Error::new, bgExecutor);

   For more information on handling Retrofit errors, see the samples in
   the ``PagingSource`` API reference.

   ``PagingSource`` collects and delivers ``LoadResult.Error`` objects
   to the UI so that you can act on them. For more information on
   exposing the loading state in the UI, see `Manage and present loading states <#>`__.

   .. rubric:: Set up a stream of PagingData
      :name: pagingdata-stream

   Next, you need a stream of paged data from the ``PagingSource``
   implementation. Set up the data stream in your ``ViewModel``. The
   `Pager <#>`__ class
   provides methods that expose a reactive stream of
   `PagingData <#>`__
   objects from a ``PagingSource``. The Paging library supports using
   several stream types, including ``Flow``, ``LiveData``, and the
   ``Flowable`` and ``Observable`` types from RxJava.

   When you create a ``Pager`` instance to set up your reactive stream,
   you must provide the instance with a
   `PagingConfig <#>`__
   configuration object and a function that tells ``Pager`` how to get
   an instance of your ``PagingSource`` implementation:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               val flow = Pager(
                 // Configure how data is loaded by passing additional properties to
                 // PagingConfig, such as prefetchDistance.
                 PagingConfig(pageSize = 20)
               ) {
                 ExamplePagingSource(backend, query)
               }.flow
                 .cachedIn(viewModelScope)

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               // CoroutineScope helper provided by the lifecycle-viewmodel-ktx artifact.
               CoroutineScope viewModelScope = ViewModelKt.getViewModelScope(viewModel);
               Pager<Integer, User> pager = Pager<>(
                 new PagingConfig(/* pageSize = */ 20),
                 () -> ExamplePagingSource(backend, query));

               Flowable<PagingData<User>> flowable = PagingRx.getFlowable(pager);
               PagingRx.cachedIn(flowable, viewModelScope);

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               // CoroutineScope helper provided by the lifecycle-viewmodel-ktx artifact.
               CoroutineScope viewModelScope = ViewModelKt.getViewModelScope(viewModel);
               Pager<Integer, User> pager = Pager<>(
                 new PagingConfig(/* pageSize = */ 20),
                 () -> ExamplePagingSource(backend, query));

               PagingLiveData.cachedIn(PagingLiveData.getLiveData(pager), viewModelScope);

   The ``cachedIn()`` operator makes the data stream shareable and
   caches the loaded data with the provided ``CoroutineScope``. This
   example uses the ``viewModelScope`` provided by the lifecycle
   ``lifecycle-viewmodel-ktx`` artifact.

   The ``Pager`` object calls the ``load()`` method from the
   ``PagingSource`` object, providing it with the
   `LoadParams <#>`__
   object and receiving the
   `LoadResult <#>`__
   object in return.

   .. rubric:: Define a RecyclerView adapter
      :name: recyclerview-adapter

   You also need to set up an adapter to receive the data into your
   ``RecyclerView`` list. The Paging library provides the
   ``PagingDataAdapter`` class for this purpose.

   Define a class that extends ``PagingDataAdapter``. In the example,
   ``UserAdapter`` extends ``PagingDataAdapter`` to provide a
   ``RecyclerView`` adapter for list items of type ``User`` and using
   ``UserViewHolder`` as a `view holder <#>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               class UserAdapter(diffCallback: DiffUtil.ItemCallback<User>) :
                 PagingDataAdapter<User, UserViewHolder>(diffCallback) {
                 override fun onCreateViewHolder(
                   parent: ViewGroup,
                   viewType: Int
                 ): UserViewHolder {
                   return UserViewHolder(parent)
                 }

                 override fun onBindViewHolder(holder: UserViewHolder, position: Int) {
                   val item = getItem(position)
                   // Note that item can be null. ViewHolder must support binding a
                   // null item as a placeholder.
                   holder.bind(item)
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               class UserAdapter extends PagingDataAdapter<User, UserViewHolder> {
                 UserAdapter(@NotNull DiffUtil.ItemCallback<User> diffCallback) {
                   super(diffCallback);
                 }

                 @NonNull
                 @Override
                 public UserViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
                   return new UserViewHolder(parent);
                 }

                 @Override
                 public void onBindViewHolder(@NonNull UserViewHolder holder, int position) {
                   User item = getItem(position);
                   // Note that item can be null. ViewHolder must support binding a
                   // null item as a placeholder.
                   holder.bind(item);
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               class UserAdapter extends PagingDataAdapter<User, UserViewHolder> {
                 UserAdapter(@NotNull DiffUtil.ItemCallback<User> diffCallback) {
                   super(diffCallback);
                 }

                 @NonNull
                 @Override
                 public UserViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
                   return new UserViewHolder(parent);
                 }

                 @Override
                 public void onBindViewHolder(@NonNull UserViewHolder holder, int position) {
                   User item = getItem(position);
                   // Note that item can be null. ViewHolder must support binding a
                   // null item as a placeholder.
                   holder.bind(item);
                 }
               }

   Your adapter must also define the ``onCreateViewHolder()`` and
   ``onBindViewHolder()`` methods and specify a
   `DiffUtil.ItemCallback <#>`__.
   This works the same as it normally does when defining
   ``RecyclerView`` list adapters:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               object UserComparator : DiffUtil.ItemCallback<User>() {
                 override fun areItemsTheSame(oldItem: User, newItem: User): Boolean {
                   // Id is unique.
                   return oldItem.id == newItem.id
                 }

                 override fun areContentsTheSame(oldItem: User, newItem: User): Boolean {
                   return oldItem == newItem
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               class UserComparator extends DiffUtil.ItemCallback<User> {
                 @Override
                 public boolean areItemsTheSame(@NonNull User oldItem,
                   @NonNull User newItem) {
                   // Id is unique.
                   return oldItem.id.equals(newItem.id);
                 }

                 @Override
                 public boolean areContentsTheSame(@NonNull User oldItem,
                   @NonNull User newItem) {
                   return oldItem.equals(newItem);
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               class UserComparator extends DiffUtil.ItemCallback<User> {
                 @Override
                 public boolean areItemsTheSame(@NonNull User oldItem,
                   @NonNull User newItem) {
                   // Id is unique.
                   return oldItem.id.equals(newItem.id);
                 }

                 @Override
                 public boolean areContentsTheSame(@NonNull User oldItem,
                   @NonNull User newItem) {
                   return oldItem.equals(newItem);
                 }
               }

   .. rubric:: Display the paged data in your UI
      :name: display-paged-data

   Now that you have defined a ``PagingSource``, created a way for your
   app to generate a stream of ``PagingData``, and defined a
   ``PagingDataAdapter``, you are ready to connect these elements
   together and display paged data in your activity.

   Perform the following steps in your activity's ``onCreate`` or
   fragment's ``onViewCreated`` method:

   #. Create an instance of your ``PagingDataAdapter`` class.
   #. Pass the ``PagingDataAdapter`` instance to the
      `RecyclerView <#>`__
      list that you want to display your paged data.
   #. Observe the ``PagingData`` stream and pass each generated value to
      your adapter's ``submitData()`` method.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               val viewModel by viewModels<ExampleViewModel>()

               val pagingAdapter = UserAdapter(UserComparator)
               val recyclerView = findViewById<RecyclerView>(R.id.recycler_view)
               recyclerView.adapter = pagingAdapter

               // Activities can use lifecycleScope directly; fragments use
               // viewLifecycleOwner.lifecycleScope.
               lifecycleScope.launch {
                 viewModel.flow.collectLatest { pagingData ->
                   pagingAdapter.submitData(pagingData)
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               ExampleViewModel viewModel = new ViewModelProvider(this)
                 .get(ExampleViewModel.class);

               UserAdapter pagingAdapter = new UserAdapter(new UserComparator());
               RecyclerView recyclerView = findViewById<RecyclerView>(
                 R.id.recycler_view);
               recyclerView.adapter = pagingAdapter

               viewModel.flowable
                 // Using AutoDispose to handle subscription lifecycle.
                 // See: https://github.com/uber/AutoDispose.
                 .to(autoDisposable(AndroidLifecycleScopeProvider.from(this)))
                 .subscribe(pagingData -> pagingAdapter.submitData(lifecycle, pagingData));

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               ExampleViewModel viewModel = new ViewModelProvider(this)
                 .get(ExampleViewModel.class);

               UserAdapter pagingAdapter = new UserAdapter(new UserComparator());
               RecyclerView recyclerView = findViewById<RecyclerView>(
                 R.id.recycler_view);
               recyclerView.adapter = pagingAdapter

               // Activities can use getLifecycle() directly; fragments use
               // getViewLifecycleOwner().getLifecycle().
               viewModel.liveData.observe(this, pagingData ->
                 pagingAdapter.submitData(getLifecycle(), pagingData));

   The ``RecyclerView`` list now displays the paged data from the data
   source and automatically loads another page when necessary.

   **Caution:**\  The ``submitData()`` method suspends and does not
   return until either the ``PagingSource`` is invalidated or the
   adapter's refresh method is called. This means that code after the
   ``submitData()`` call might execute much later than you intend.

   .. rubric:: Additional resources
      :name: additional-resources

   To learn more about the Paging library, see the following additional
   resources:

   .. rubric:: Codelabs
      :name: codelabs

   -  `Android Paging Advanced codelab <https://developers.google.cn/codelabs/codelabs/android-paging>`__

   .. rubric:: Samples
      :name: samples

   -  `Android Architecture Components Paging sample <https://github.com/android/architecture-components-samples/tree/main/PagingSample>`__
   -  `Android Architecture Components Paging with Network sample <https://github.com/android/architecture-components-samples/tree/main/PagingWithNetworkSample>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Page from network and database <#>`__
   -  `Migrate to Paging 3 <#>`__
   -  `Paging library overview <#>`__

Last updated 2023-07-25 UTC.



/Page from network and database
===============================

.. container:: devsite-article-body clearfix

   Provide an improved user experience by making sure that your app can
   be used when network connections are unreliable or when the user is
   offline. One way to do this is to page from the network and from a
   local database at the same time. This way, your app drives the UI
   from a local database cache and only makes requests to the network
   when there is no more data in the database.

   This guide assumes that you are familiar with the `Room persistence library <#>`__ and with `basic usage of the Paging library <#>`__.

   .. rubric:: Coordinate data loads
      :name: coordinate-loads

   The Paging library provides the
   `RemoteMediator <#>`__
   component for this use case. ``RemoteMediator`` acts as a signal from
   the Paging library when the app has run out of cached data. You can
   use this signal to load additional data from the network and store it
   in the local database, where a
   `PagingSource <#>`__
   can load it and provide it to the UI to display.

   When additional data is needed, the Paging library calls the
   `load() <#load>`__
   method from the ``RemoteMediator`` implementation. This is a
   suspending function so it is safe to perform long-running work. This
   function typically fetches the new data from a network source and
   saves it to local storage.

   This process works with new data, but over time the data stored in
   the database requires invalidation, such as when the user manually
   triggers a refresh. This is represented by the
   `LoadType <#>`__
   property passed to the ``load()`` method. The ``LoadType`` informs
   the ``RemoteMediator`` whether it needs to refresh the existing data
   or fetch additional data that needs to be appended or prepended to
   the existing list.

   In this way, the ``RemoteMediator`` ensures that your app loads the
   data that users want to see in the appropriate order.

   .. rubric:: Paging lifecycle
      :name: paging-lifecycle

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/paging3-base-lifecycle.png
      name: base-lifecycle-fig
      :width: 800px

   **Figure 1.** Diagram of the lifecycle of Paging with PagingSource
   and PagingData.
   When paging directly from the network, the ``PagingSource`` loads the
   data and returns a
   `LoadResult <#>`__
   object. The ``PagingSource`` implementation is passed to the
   `Pager <#>`__ through the
   ``pagingSourceFactory`` parameter.

   As new data is required by the UI, the ``Pager`` calls the
   `load() <#load>`__
   method from the ``PagingSource`` and returns a stream of
   `PagingData <#>`__
   objects that encapsulate the new data. Each ``PagingData`` object is
   typically cached in the ``ViewModel`` before being sent to the UI to
   display.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/paging3-layered-lifecycle.png
      name: layered-lifecycle-fig
      :width: 800px

   **Figure 2.** Diagram of the lifecycle of Paging with PagingSource
   and RemoteMediator.
   ``RemoteMediator`` changes this data flow. A ``PagingSource`` still
   loads the data; but when the paged data is exhausted, the Paging
   library triggers the ``RemoteMediator`` to load new data from the
   network source. The ``RemoteMediator`` stores the new data in the
   local database, so an in-memory cache in the ``ViewModel`` is
   unnecessary. Finally, the ``PagingSource`` invalidates itself, and
   the ``Pager`` creates a new instance to load the fresh data from the
   database.

   .. rubric:: Basic usage
      :name: basic-usage

   Suppose you want your app to load pages of ``User`` items from an
   item-keyed network data source into a local cache stored in a Room
   database.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/paging3-layered-architecture.svg
      name: layered-arch-fig
      :alt: The RemoteMediator loads data from the network into the
      database and the PagingSource loads data from the database. A
      Pager uses both the RemoteMediator and the PagingSource to load
      paged data.
      :width: 800px

   **Figure 3.** Diagram of a Paging implementation that uses a layered
   data source.
   A ``RemoteMediator`` implementation helps load paged data from the
   network into the database, but doesn't load data directly into the
   UI. Instead, the app uses the database as the `source of truth <#source-of-truth>`__. In other words,
   the app only displays data that has been cached in the database. A
   ``PagingSource`` implementation (for example, one generated by Room)
   handles loading cached data from the database into the UI.

   .. rubric:: Create Room entities
      :name: room-entities

   The first step is to use the `Room persistence library <#>`__ to define a database
   that holds a local cache of paged data from the network data source.
   Start with an implementation of
   `RoomDatabase <#>`__
   as described in `Save data in a local database using Room <#>`__.

   Next, define a Room entity to represent a table of list items as
   described in `Defining data using Room entities <#>`__. Give it an
   ``id`` field as a primary key, as well as fields for any other
   information that your list items contain.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               @Entity(tableName = "users")
               data class User(val id: String, val label: String)

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               @Entity(tableName = "users")
               public class User {
                 public String id;
                 public String label;
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               @Entity(tableName = "users")
               public class User {
                 public String id;
                 public String label;
               }

   You must also define a data access object (DAO) for this Room entity
   as described in `Accessing data using Room DAOs <#>`__. The DAO for the
   list item entity must include the following methods:

   -  An ``insertAll()`` method that inserts a list of items into the
      table.
   -  A method that takes the query string as a parameter and returns a
      ``PagingSource`` object for the list of results. This way, a
      ``Pager`` object can use this table as a source of paged data.
   -  A ``clearAll()`` method that deletes all of the table's data.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               @Dao
               interface UserDao {
                 @Insert(onConflict = OnConflictStrategy.REPLACE)
                 suspend fun insertAll(users: List<User>)

                 @Query("SELECT * FROM users WHERE label LIKE :query")
                 fun pagingSource(query: String): PagingSource<Int, User>

                 @Query("DELETE FROM users")
                 suspend fun clearAll()
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               @Dao
               interface UserDao {
                 @Insert(onConflict = OnConflictStrategy.REPLACE)
                 void insertAll(List<User> users);

                 @Query("SELECT * FROM users WHERE mLabel LIKE :query")
                 PagingSource<Integer, User> pagingSource(String query);

                 @Query("DELETE FROM users")
                 int clearAll();
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               @Dao
               interface UserDao {
                 @Insert(onConflict = OnConflictStrategy.REPLACE)
                 void insertAll(List<User> users);

                 @Query("SELECT * FROM users WHERE mLabel LIKE :query")
                 PagingSource<Integer, User> pagingSource(String query);

                 @Query("DELETE FROM users")
                 int clearAll();
               }

   .. rubric:: Implement a RemoteMediator
      :name: implement-remotemediator

   The main role of ``RemoteMediator`` is to load more data from the
   network when either the ``Pager`` runs out of data or the existing
   data is invalidated. It includes a ``load()`` method that you must
   override to define the loading behavior.

   A typical ``RemoteMediator`` implementation includes the following
   parameters:

   -  ``query``: A query string defining which data to retrieve from the
      backend service.
   -  ``database``: The Room database that serves as a local cache.
   -  ``networkService``: An API instance for the backend service.

   Create a ``RemoteMediator<Key, Value>`` implementation. The ``Key``
   type and the ``Value`` type should be the same as they would be if
   you were defining a ``PagingSource`` against the same network data
   source. For more information on selecting type parameters, see
   `Select key and value types <#key-value>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               @OptIn(ExperimentalPagingApi::class)
               class ExampleRemoteMediator(
                 private val query: String,
                 private val database: RoomDb,
                 private val networkService: ExampleBackendService
               ) : RemoteMediator<Int, User>() {
                 val userDao = database.userDao()

                 override suspend fun load(
                   loadType: LoadType,
                   state: PagingState<Int, User>
                 ): MediatorResult {
                   // ...
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               @UseExperimental(markerClass = ExperimentalPagingApi.class)
               class ExampleRemoteMediator extends RxRemoteMediator<Integer, User> {
                 private String query;
                 private ExampleBackendService networkService;
                 private RoomDb database;
                 private UserDao userDao;

                 ExampleRemoteMediator(
                   String query,
                   ExampleBackendService networkService, RoomDb database
                 ) {
                   query = query;
                   networkService = networkService;
                   database = database;
                   userDao = database.userDao();
                 }

                 @NotNull
                 @Override
                 public Single<MediatorResult> loadSingle(
                   @NotNull LoadType loadType,
                   @NotNull PagingState<Integer, User> state
                 ) {
                   ...
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               class ExampleRemoteMediator extends ListenableFutureRemoteMediator<Integer, User> {
                 private String query;
                 private ExampleBackendService networkService;
                 private RoomDb database;
                 private UserDao userDao;
                 private Executor bgExecutor;

                 ExampleRemoteMediator(
                   String query,
                   ExampleBackendService networkService,
                   RoomDb database,
                   Executor bgExecutor
                 ) {
                   this.query = query;
                   this.networkService = networkService;
                   this.database = database;
                   this.userDao = database.userDao();
                   this.bgExecutor = bgExecutor;
                 }

                 @NotNull
                 @Override
                 public ListenableFuture<MediatorResult> loadFuture(
                   @NotNull LoadType loadType,
                   @NotNull PagingState<Integer, User> state
                 ) {
                   ...
                 }
               }

   The ``load()`` method is responsible for updating the backing dataset
   and invalidating the ``PagingSource``. Some libraries that support
   paging (like Room) will automatically handle invalidating
   ``PagingSource`` objects that they implement.

   The ``load()`` method takes in two parameters:

   -  `PagingState <#>`__,
      which contains information about the pages loaded so far, the most
      recently accessed index, and the
      `PagingConfig <#>`__
      object that you used to initialize the paging stream.
   -  `LoadType <#>`__,
      which indicates the type of the load:
      `REFRESH <#refresh>`__,
      `APPEND <#append>`__,
      or
      `PREPEND <#prepend>`__.

   The return value of the ``load()`` method is a
   `MediatorResult <#>`__
   object. ``MediatorResult`` can either be
   `MediatorResult.Error <#>`__
   (which includes the error description) or
   `MediatorResult.Success <#>`__
   (which includes a signal stating whether or not there is more data to
   load).

   The ``load()`` method must perform the following steps:

   #. Determine which page to load from the network depending on the
      load type and the data that has been loaded so far.
   #. Trigger the network request.
   #. Perform actions depending on the outcome of the load operation:

      -  If the load is successful and the received list of items is not
         empty, then store the list items in the database and return
         ``MediatorResult.Success(endOfPaginationReached = false)``.
         After the data is stored, invalidate the data source to notify
         the Paging library of the new data.
      -  If the load is successful and either the received list of items
         is empty or it is the last page index, then return
         ``MediatorResult.Success(endOfPaginationReached = true)``.
         After the data is stored, invalidate the data source to notify
         the Paging library of the new data.
      -  If the request causes an error, then return
         ``MediatorResult.Error``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               override suspend fun load(
                 loadType: LoadType,
                 state: PagingState<Int, User>
               ): MediatorResult {
                 return try {
                   // The network load method takes an optional after=<user.id>
                   // parameter. For every page after the first, pass the last user
                   // ID to let it continue from where it left off. For REFRESH,
                   // pass null to load the first page.
                   val loadKey = when (loadType) {
                     LoadType.REFRESH -> null
                     // In this example, you never need to prepend, since REFRESH
                     // will always load the first page in the list. Immediately
                     // return, reporting end of pagination.
                     LoadType.PREPEND ->
                       return MediatorResult.Success(endOfPaginationReached = true)
                     LoadType.APPEND -> {
                       val lastItem = state.lastItemOrNull()

                       // You must explicitly check if the last item is null when
                       // appending, since passing null to networkService is only
                       // valid for initial load. If lastItem is null it means no
                       // items were loaded after the initial REFRESH and there are
                       // no more items to load.
                       if (lastItem == null) {
                         return MediatorResult.Success(
                           endOfPaginationReached = true
                         )
                       }

                       lastItem.id
                     }
                   }

                   // Suspending network load via Retrofit. This doesn't need to be
                   // wrapped in a withContext(Dispatcher.IO) { ... } block since
                   // Retrofit's Coroutine CallAdapter dispatches on a worker
                   // thread.
                   val response = networkService.searchUsers(
                     query = query, after = loadKey
                   )

                   database.withTransaction {
                     if (loadType == LoadType.REFRESH) {
                       userDao.deleteByQuery(query)
                     }

                     // Insert new users into database, which invalidates the
                     // current PagingData, allowing Paging to present the updates
                     // in the DB.
                     userDao.insertAll(response.users)
                   }

                   MediatorResult.Success(
                     endOfPaginationReached = response.nextKey == null
                   )
                 } catch (e: IOException) {
                   MediatorResult.Error(e)
                 } catch (e: HttpException) {
                   MediatorResult.Error(e)
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               @NotNull
               @Override
               public Single<MediatorResult> loadSingle(
                 @NotNull LoadType loadType,
                 @NotNull PagingState<Integer, User> state
               ) {
                 // The network load method takes an optional after=<user.id> parameter. For
                 // every page after the first, pass the last user ID to let it continue from
                 // where it left off. For REFRESH, pass null to load the first page.
                 String loadKey = null;
                 switch (loadType) {
                   case REFRESH:
                     break;
                   case PREPEND:
                     // In this example, you never need to prepend, since REFRESH will always
                     // load the first page in the list. Immediately return, reporting end of
                     // pagination.
                     return Single.just(new MediatorResult.Success(true));
                   case APPEND:
                     User lastItem = state.lastItemOrNull();

                     // You must explicitly check if the last item is null when appending,
                     // since passing null to networkService is only valid for initial load.
                     // If lastItem is null it means no items were loaded after the initial
                     // REFRESH and there are no more items to load.
                     if (lastItem == null) {
                       return Single.just(new MediatorResult.Success(true));
                     }

                     loadKey = lastItem.getId();
                     break;
                 }

                 return networkService.searchUsers(query, loadKey)
                   .subscribeOn(Schedulers.io())
                   .map((Function<SearchUserResponse, MediatorResult>) response -> {
                     database.runInTransaction(() -> {
                       if (loadType == LoadType.REFRESH) {
                         userDao.deleteByQuery(query);
                       }

                       // Insert new users into database, which invalidates the current
                       // PagingData, allowing Paging to present the updates in the DB.
                       userDao.insertAll(response.getUsers());
                     });

                     return new MediatorResult.Success(response.getNextKey() == null);
                   })
                   .onErrorResumeNext(e -> {
                     if (e instanceof IOException || e instanceof HttpException) {
                       return Single.just(new MediatorResult.Error(e));
                     }

                     return Single.error(e);
                   });
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               @NotNull
               @Override
               public ListenableFuture<MediatorResult> loadFuture(
                 @NotNull LoadType loadType,
                 @NotNull PagingState<Integer, User> state
               ) {
                 // The network load method takes an optional after=<user.id> parameter. For
                 // every page after the first, pass the last user ID to let it continue from
                 // where it left off. For REFRESH, pass null to load the first page.
                 String loadKey = null;
                 switch (loadType) {
                   case REFRESH:
                     break;
                   case PREPEND:
                     // In this example, you never need to prepend, since REFRESH will always
                     // load the first page in the list. Immediately return, reporting end of
                     // pagination.
                     return Futures.immediateFuture(new MediatorResult.Success(true));
                   case APPEND:
                     User lastItem = state.lastItemOrNull();

                     // You must explicitly check if the last item is null when appending,
                     // since passing null to networkService is only valid for initial load.
                     // If lastItem is null it means no items were loaded after the initial
                     // REFRESH and there are no more items to load.
                     if (lastItem == null) {
                       return Futures.immediateFuture(new MediatorResult.Success(true));
                     }

                     loadKey = lastItem.getId();
                     break;
                 }

                 ListenableFuture<MediatorResult> networkResult = Futures.transform(
                   networkService.searchUsers(query, loadKey),
                   response -> {
                     database.runInTransaction(() -> {
                       if (loadType == LoadType.REFRESH) {
                         userDao.deleteByQuery(query);
                       }

                       // Insert new users into database, which invalidates the current
                       // PagingData, allowing Paging to present the updates in the DB.
                       userDao.insertAll(response.getUsers());
                     });

                     return new MediatorResult.Success(response.getNextKey() == null);
                   }, bgExecutor);

                 ListenableFuture<MediatorResult> ioCatchingNetworkResult =
                   Futures.catching(
                     networkResult,
                     IOException.class,
                     MediatorResult.Error::new,
                     bgExecutor
                   );

                 return Futures.catching(
                   ioCatchingNetworkResult,
                   HttpException.class,
                   MediatorResult.Error::new,
                   bgExecutor
                 );
               }

   .. rubric:: Define the initialize method
      :name: initialize

   ``RemoteMediator`` implementations can also override the
   `initialize() <#initialize>`__
   method to check whether cached data is out of date and decide whether
   to trigger a remote refresh. This method runs before any loading is
   performed, so you can manipulate the database (for example, to clear
   old data) before triggering any local or remote loads.

   Because ``initialize()`` is an asynchronous function, you can load
   data to determine the relevance of the existing data in the database.
   The most common case is that the cached data is only valid for a
   certain period of time. The ``RemoteMediator`` can check whether this
   expiration time has passed, in which case the Paging library needs to
   fully refresh the data. Implementations of ``initialize()`` should
   return an ``InitializeAction`` as follows:

   -  In cases where the local data needs to be fully refreshed,
      ``initialize()`` should return
      `InitializeAction.LAUNCH_INITIAL_REFRESH <#launch_initial_refresh>`__.
      This causes the ``RemoteMediator`` to perform a remote refresh to
      fully reload the data. Any remote ``APPEND`` or ``PREPEND`` loads
      wait for the ``REFRESH`` load to succeed before proceeding.
   -  In cases where the local data doesn't need to be refreshed,
      ``initialize()`` should return
      `InitializeAction.SKIP_INITIAL_REFRESH <#skip_initial_refresh>`__.
      This causes the ``RemoteMediator`` to skip the remote refresh and
      load the cached data.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               override suspend fun initialize(): InitializeAction {
                 val cacheTimeout = TimeUnit.MILLISECONDS.convert(1, TimeUnit.HOURS)
                 return if (System.currentTimeMillis() - db.lastUpdated() <= cacheTimeout)
                 {
                   // Cached data is up-to-date, so there is no need to re-fetch
                   // from the network.
                   InitializeAction.SKIP_INITIAL_REFRESH
                 } else {
                   // Need to refresh cached data from network; returning
                   // LAUNCH_INITIAL_REFRESH here will also block RemoteMediator's
                   // APPEND and PREPEND from running until REFRESH succeeds.
                   InitializeAction.LAUNCH_INITIAL_REFRESH
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               @NotNull
               @Override
               public Single<InitializeAction> initializeSingle() {
                 long cacheTimeout = TimeUnit.MILLISECONDS.convert(1, TimeUnit.HOURS);
                 return mUserDao.lastUpdatedSingle()
                   .map(lastUpdatedMillis -> {
                     if (System.currentTimeMillis() - lastUpdatedMillis <= cacheTimeout) {
                       // Cached data is up-to-date, so there is no need to re-fetch
                       // from the network.
                       return InitializeAction.SKIP_INITIAL_REFRESH;
                     } else {
                       // Need to refresh cached data from network; returning
                       // LAUNCH_INITIAL_REFRESH here will also block RemoteMediator's
                       // APPEND and PREPEND from running until REFRESH succeeds.
                       return InitializeAction.LAUNCH_INITIAL_REFRESH;
                     }
                   });
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               @NotNull
               @Override
               public ListenableFuture<InitializeAction> initializeFuture() {
                 long cacheTimeout = TimeUnit.MILLISECONDS.convert(1, TimeUnit.HOURS);
                 return Futures.transform(
                   mUserDao.lastUpdated(),
                   lastUpdatedMillis -> {
                     if (System.currentTimeMillis() - lastUpdatedMillis <= cacheTimeout) {
                       // Cached data is up-to-date, so there is no need to re-fetch
                       // from the network.
                       return InitializeAction.SKIP_INITIAL_REFRESH;
                     } else {
                       // Need to refresh cached data from network; returning
                       // LAUNCH_INITIAL_REFRESH here will also block RemoteMediator's
                       // APPEND and PREPEND from running until REFRESH succeeds.
                       return InitializeAction.LAUNCH_INITIAL_REFRESH;
                     }
                   },
                   mBgExecutor);
               }

   .. rubric:: Create a Pager
      :name: create-pager

   Finally, you must create a ``Pager`` instance to set up the stream of
   paged data. This is similar to creating a ``Pager`` from a simple
   network data source, but there are two things you must do
   differently:

   -  Instead of passing a ``PagingSource`` constructor directly, you
      must provide the query method that returns a ``PagingSource``
      object from the DAO.
   -  You must provide an instance of your ``RemoteMediator``
      implementation as the ``remoteMediator`` parameter.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               val userDao = database.userDao()
               val pager = Pager(
                 config = PagingConfig(pageSize = 50)
                 remoteMediator = ExampleRemoteMediator(query, database, networkService)
               ) {
                 userDao.pagingSource(query)
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               UserDao userDao = database.userDao();
               Pager<Integer, User> pager = Pager(
                 new PagingConfig(/* pageSize = */ 20),
                 null, // initialKey,
                 new ExampleRemoteMediator(query, database, networkService)
                 () -> userDao.pagingSource(query));

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               UserDao userDao = database.userDao();
               Pager<Integer, User> pager = Pager(
                 new PagingConfig(/* pageSize = */ 20),
                 null, // initialKey
                 new ExampleRemoteMediator(query, database, networkService, bgExecutor),
                 () -> userDao.pagingSource(query));

   .. rubric:: Handle race conditions
      :name: race-conditions

   One situation that your app needs to handle when loading data from
   multiple sources is the case in which local cached data becomes out
   of sync with the remote data source.

   When the ``initialize()`` method from your ``RemoteMediator``
   implementation returns ``LAUNCH_INITIAL_REFRESH``, the data is
   outdated and must be replaced with fresh data. Any ``PREPEND`` or
   ``APPEND`` load requests are forced to wait for the remote
   ``REFRESH`` load to succeed. Because the ``PREPEND`` or ``APPEND``
   requests were queued before the ``REFRESH`` request, it is possible
   that the ``PagingState`` passed to those load calls will be out of
   date by the time they run.

   Depending on how the data is stored locally, your app can ignore
   redundant requests if changes to the cached data cause invalidation
   and new data fetches. For example, Room invalidates queries on any
   data insertion. That means that new ``PagingSource`` objects with the
   refreshed data are provided to pending load requests when new data is
   inserted into the database.

   Solving this data synchronization problem is essential to ensuring
   that users see the most relevant, up-to-date data. The best solution
   depends mostly on the way that the network data source pages the
   data. In any case, `remote keys <#remote-keys>`__ allow you to save
   information about the most recent page requested from the server. You
   app can use this information to identify and request the correct page
   of data to load next.

   .. rubric:: Manage remote keys
      :name: remote-keys

   *Remote keys* are keys that a ``RemoteMediator`` implementation uses
   to tell the backend service which data to load next. In the simplest
   case, each item of paged data includes a remote key that you can
   easily reference. However, if the remote keys do not correspond to
   individual items, then you must store them separately and manage them
   in your ``load()`` method.

   This section describes how to collect, store, and update remote keys
   that are not stored in individual items.

   .. rubric:: Item keys
      :name: item-keys

   This section describes how to work with remote keys that correspond
   to individual items. Typically, when an API keys off of individual
   items, the item ID is passed as a query parameter. The parameter name
   indicates whether the server should respond with items before or
   after the provided ID. In the example of the ``User`` model class,
   the ``id`` field from the server is used as a remote key when
   requesting additional data.

   When your ``load()`` method needs to manage item-specific remote
   keys, these keys are typically the IDs of the data fetched from the
   server. Refresh operations don't need a load key, because they just
   retrieve the most recent data. Similarly, prepend operations do not
   need to fetch any additional data because refresh always pulls the
   newest data from the server.

   However, append operations do require an ID. This requires you to
   load the last item from the database and use its ID to load the next
   page of data. If there are no items in the database, then
   ``endOfPaginationReached`` is set to true, indicating that a data
   refresh is needed.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               @OptIn(ExperimentalPagingApi::class)
               class ExampleRemoteMediator(
                 private val query: String,
                 private val database: RoomDb,
                 private val networkService: ExampleBackendService
               ) : RemoteMediator<Int, User>() {
                 val userDao = database.userDao()

                 override suspend fun load(
                   loadType: LoadType,
                   state: PagingState<Int, User>
                 ): MediatorResult {
                   return try {
                     // The network load method takes an optional String
                     // parameter. For every page after the first, pass the String
                     // token returned from the previous page to let it continue
                     // from where it left off. For REFRESH, pass null to load the
                     // first page.
                     val loadKey = when (loadType) {
                       LoadType.REFRESH -> null
                       // In this example, you never need to prepend, since REFRESH
                       // will always load the first page in the list. Immediately
                       // return, reporting end of pagination.
                       LoadType.PREPEND -> return MediatorResult.Success(
                         endOfPaginationReached = true
                       )
                       // Get the last User object id for the next RemoteKey.
                       LoadType.APPEND -> {
                         val lastItem = state.lastItemOrNull()

                         // You must explicitly check if the last item is null when
                         // appending, since passing null to networkService is only
                         // valid for initial load. If lastItem is null it means no
                         // items were loaded after the initial REFRESH and there are
                         // no more items to load.
                         if (lastItem == null) {
                           return MediatorResult.Success(
                             endOfPaginationReached = true
                           )
                         }

                         lastItem.id
                       }
                     }

                     // Suspending network load via Retrofit. This doesn't need to
                     // be wrapped in a withContext(Dispatcher.IO) { ... } block
                     // since Retrofit's Coroutine CallAdapter dispatches on a
                     // worker thread.
                     val response = networkService.searchUsers(query, loadKey)

                     // Store loaded data, and next key in transaction, so that
                     // they're always consistent.
                     database.withTransaction {
                       if (loadType == LoadType.REFRESH) {
                         userDao.deleteByQuery(query)
                       }

                       // Insert new users into database, which invalidates the
                       // current PagingData, allowing Paging to present the updates
                       // in the DB.
                       userDao.insertAll(response.users)
                     }

                     // End of pagination has been reached if no users are returned from the
                     // service
                     MediatorResult.Success(
                       endOfPaginationReached = response.users.isEmpty()
                     )
                   } catch (e: IOException) {
                     MediatorResult.Error(e)
                   } catch (e: HttpException) {
                     MediatorResult.Error(e)
                   }
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               @NotNull
               @Override
               public Single>MediatorResult< loadSingle(
                 @NotNull LoadType loadType,
                 @NotNull PagingState>Integer, User< state
               ) {
                 // The network load method takes an optional String parameter. For every page
                 // after the first, pass the String token returned from the previous page to
                 // let it continue from where it left off. For REFRESH, pass null to load the
                 // first page.
                 Single>String< remoteKeySingle = null;
                 switch (loadType) {
                   case REFRESH:
                     // Initial load should use null as the page key, so you can return null
                     // directly.
                     remoteKeySingle = Single.just(null);
                     break;
                   case PREPEND:
                     // In this example, you never need to prepend, since REFRESH will always
                     // load the first page in the list. Immediately return, reporting end of
                     // pagination.
                     return Single.just(new MediatorResult.Success(true));
                   case APPEND:
                     User lastItem = state.lastItemOrNull();

                     // You must explicitly check if the last item is null when
                     // appending, since passing null to networkService is only
                     // valid for initial load. If lastItem is null it means no
                     // items were loaded after the initial REFRESH and there are
                     // no more items to load.
                     if (lastItem == null) {
                       return Single.just(new MediatorResult.Success(true));
                     }
                     remoteKeySingle = Single.just(lastItem.getId());
                     break;
                 }

                 return remoteKeySingle
                   .subscribeOn(Schedulers.io())
                   .flatMap((Function<String, Single<MediatorResult>>) remoteKey -> {
                     return networkService.searchUsers(query, remoteKey)
                       .map(response -> {
                         database.runInTransaction(() -> {
                           if (loadType == LoadType.REFRESH) {
                             userDao.deleteByQuery(query);
                           }
                           // Insert new users into database, which invalidates the current
                           // PagingData, allowing Paging to present the updates in the DB.
                           userDao.insertAll(response.getUsers());
                         });

                         return new MediatorResult.Success(response.getUsers().isEmpty());
                       });
                   })
                   .onErrorResumeNext(e -> {
                     if (e instanceof IOException || e instanceof HttpException) {
                       return Single.just(new MediatorResult.Error(e));
                     }

                     return Single.error(e);
                   });
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               @NotNull
               @Override
               public ListenableFuture<MediatorResult> loadFuture(
                 @NotNull LoadType loadType,
                 @NotNull PagingState<Integer, User> state
               ) {
                 // The network load method takes an optional after=<user.id> parameter.
                 // For every page after the first, pass the last user ID to let it continue
                 // from where it left off. For REFRESH, pass null to load the first page.
                 ResolvableFuture<String> remoteKeyFuture = ResolvableFuture.create();
                 switch (loadType) {
                   case REFRESH:
                     remoteKeyFuture.set(null);
                     break;
                   case PREPEND:
                     // In this example, you never need to prepend, since REFRESH will always
                     // load the first page in the list. Immediately return, reporting end of
                     // pagination.
                     return Futures.immediateFuture(new MediatorResult.Success(true));
                   case APPEND:
                     User lastItem = state.lastItemOrNull();

                     // You must explicitly check if the last item is null when appending,
                     // since passing null to networkService is only valid for initial load.
                     // If lastItem is null it means no items were loaded after the initial
                     // REFRESH and there are no more items to load.
                     if (lastItem == null) {
                       return Futures.immediateFuture(new MediatorResult.Success(true));
                     }

                     remoteKeyFuture.set(lastItem.getId());
                     break;
                 }

                 return Futures.transformAsync(remoteKeyFuture, remoteKey -> {

                   ListenableFuture<MediatorResult> networkResult = Futures.transform(
                     networkService.searchUsers(query, remoteKey),
                     response -> {
                       database.runInTransaction(() -> {
                       if (loadType == LoadType.REFRESH) {
                         userDao.deleteByQuery(query);
                       }

                       // Insert new users into database, which invalidates the current
                       // PagingData, allowing Paging to present the updates in the DB.
                       userDao.insertAll(response.getUsers());
                     });

                     return new MediatorResult.Success(response.getUsers().isEmpty());
                   }, bgExecutor);

                   ListenableFuture<MediatorResult> ioCatchingNetworkResult =
                     Futures.catching(
                       networkResult,
                       IOException.class,
                       MediatorResult.Error::new,
                       bgExecutor
                     );

                   return Futures.catching(
                     ioCatchingNetworkResult,
                     HttpException.class,
                     MediatorResult.Error::new,
                     bgExecutor
                   );
                 }, bgExecutor);
               }

   .. rubric:: Page keys
      :name: page-keys

   This section describes how to work with remote keys that don't
   correspond to individual items.

   .. rubric:: Add remote key table
      :name: add-rk-table

   When remote keys are not directly associated with list items, it is
   best to store them in a separate table in the local database. Define
   a Room entity that represents a table of remote keys:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               @Entity(tableName = "remote_keys")
               data class RemoteKey(val label: String, val nextKey: String?)

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               @Entity(tableName = "remote_keys")
               public class RemoteKey {
                 public String label;
                 public String nextKey;
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               @Entity(tableName = "remote_keys")
               public class RemoteKey {
                 public String label;
                 public String nextKey;
               }

   You must also define a DAO for the ``RemoteKey`` entity:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               @Dao
               interface RemoteKeyDao {
                 @Insert(onConflict = OnConflictStrategy.REPLACE)
                 suspend fun insertOrReplace(remoteKey: RemoteKey)

                 @Query("SELECT * FROM remote_keys WHERE label = :query")
                 suspend fun remoteKeyByQuery(query: String): RemoteKey

                 @Query("DELETE FROM remote_keys WHERE label = :query")
                 suspend fun deleteByQuery(query: String)
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               @Dao
               interface RemoteKeyDao {
                 @Insert(onConflict = OnConflictStrategy.REPLACE)
                 void insertOrReplace(RemoteKey remoteKey);

                 @Query("SELECT * FROM remote_keys WHERE label = :query")
                 Single<RemoteKey> remoteKeyByQuerySingle(String query);

                 @Query("DELETE FROM remote_keys WHERE label = :query")
                 void deleteByQuery(String query);
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               @Dao
               interface RemoteKeyDao {
                 @Insert(onConflict = OnConflictStrategy.REPLACE)
                 void insertOrReplace(RemoteKey remoteKey);

                 @Query("SELECT * FROM remote_keys WHERE label = :query")
                 ListenableFuture<RemoteKey> remoteKeyByQueryFuture(String query);

                 @Query("DELETE FROM remote_keys WHERE label = :query")
                 void deleteByQuery(String query);
               }

   .. rubric:: Load with remote keys
      :name: load-with-rk

   When your ``load()`` method needs to manage remote page keys, you
   must define it differently in the following ways as compared to
   `basic usage <#basic-usage>`__ of ``RemoteMediator``:

   -  Include an additional property that holds a reference to the DAO
      for your remote key table.
   -  Determine which key to load next by querying the remote key table
      instead of using ``PagingState``.
   -  Insert or store the returned remote key from the network data
      source in addition to the paged data itself.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               @OptIn(ExperimentalPagingApi::class)
               class ExampleRemoteMediator(
                 private val query: String,
                 private val database: RoomDb,
                 private val networkService: ExampleBackendService
               ) : RemoteMediator<Int, User>() {
                 val userDao = database.userDao()
                 val remoteKeyDao = database.remoteKeyDao()

                 override suspend fun load(
                   loadType: LoadType,
                   state: PagingState<Int, User>
                 ): MediatorResult {
                   return try {
                     // The network load method takes an optional String
                     // parameter. For every page after the first, pass the String
                     // token returned from the previous page to let it continue
                     // from where it left off. For REFRESH, pass null to load the
                     // first page.
                     val loadKey = when (loadType) {
                       LoadType.REFRESH -> null
                       // In this example, you never need to prepend, since REFRESH
                       // will always load the first page in the list. Immediately
                       // return, reporting end of pagination.
                       LoadType.PREPEND -> return MediatorResult.Success(
                         endOfPaginationReached = true
                       )
                       // Query remoteKeyDao for the next RemoteKey.
                       LoadType.APPEND -> {
                         val remoteKey = database.withTransaction {
                           remoteKeyDao.remoteKeyByQuery(query)
                         }

                         // You must explicitly check if the page key is null when
                         // appending, since null is only valid for initial load.
                         // If you receive null for APPEND, that means you have
                         // reached the end of pagination and there are no more
                         // items to load.
                         if (remoteKey.nextKey == null) {
                           return MediatorResult.Success(
                             endOfPaginationReached = true
                           )
                         }

                         remoteKey.nextKey
                       }
                     }

                     // Suspending network load via Retrofit. This doesn't need to
                     // be wrapped in a withContext(Dispatcher.IO) { ... } block
                     // since Retrofit's Coroutine CallAdapter dispatches on a
                     // worker thread.
                     val response = networkService.searchUsers(query, loadKey)

                     // Store loaded data, and next key in transaction, so that
                     // they're always consistent.
                     database.withTransaction {
                       if (loadType == LoadType.REFRESH) {
                         remoteKeyDao.deleteByQuery(query)
                         userDao.deleteByQuery(query)
                       }

                       // Update RemoteKey for this query.
                       remoteKeyDao.insertOrReplace(
                         RemoteKey(query, response.nextKey)
                       )

                       // Insert new users into database, which invalidates the
                       // current PagingData, allowing Paging to present the updates
                       // in the DB.
                       userDao.insertAll(response.users)
                     }

                     MediatorResult.Success(
                       endOfPaginationReached = response.nextKey == null
                     )
                   } catch (e: IOException) {
                     MediatorResult.Error(e)
                   } catch (e: HttpException) {
                     MediatorResult.Error(e)
                   }
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               @NotNull
               @Override
               public Single<MediatorResult> loadSingle(
                 @NotNull LoadType loadType,
                 @NotNull PagingState<Integer, User> state
               ) {
                 // The network load method takes an optional String parameter. For every page
                 // after the first, pass the String token returned from the previous page to
                 // let it continue from where it left off. For REFRESH, pass null to load the
                 // first page.
                 Single<RemoteKey> remoteKeySingle = null;
                 switch (loadType) {
                   case REFRESH:
                     // Initial load should use null as the page key, so you can return null
                     // directly.
                     remoteKeySingle = Single.just(new RemoteKey(mQuery, null));
                     break;
                   case PREPEND:
                     // In this example, you never need to prepend, since REFRESH will always
                     // load the first page in the list. Immediately return, reporting end of
                     // pagination.
                     return Single.just(new MediatorResult.Success(true));
                   case APPEND:
                     // Query remoteKeyDao for the next RemoteKey.
                     remoteKeySingle = mRemoteKeyDao.remoteKeyByQuerySingle(mQuery);
                     break;
                 }

                 return remoteKeySingle
                   .subscribeOn(Schedulers.io())
                   .flatMap((Function<RemoteKey, Single<MediatorResult>>) remoteKey -> {
                     // You must explicitly check if the page key is null when appending,
                     // since null is only valid for initial load. If you receive null
                     // for APPEND, that means you have reached the end of pagination and
                     // there are no more items to load.
                     if (loadType != REFRESH && remoteKey.getNextKey() == null) {
                       return Single.just(new MediatorResult.Success(true));
                     }

                     return networkService.searchUsers(query, remoteKey.getNextKey())
                       .map(response -> {
                         database.runInTransaction(() -> {
                           if (loadType == LoadType.REFRESH) {
                             userDao.deleteByQuery(query);
                             remoteKeyDao.deleteByQuery(query);
                           }

                           // Update RemoteKey for this query.
                           remoteKeyDao.insertOrReplace(new RemoteKey(query, response.getNextKey()));

                           // Insert new users into database, which invalidates the current
                           // PagingData, allowing Paging to present the updates in the DB.
                           userDao.insertAll(response.getUsers());
                         });

                         return new MediatorResult.Success(response.getNextKey() == null);
                       });
                   })
                   .onErrorResumeNext(e -> {
                     if (e instanceof IOException || e instanceof HttpException) {
                       return Single.just(new MediatorResult.Error(e));
                     }

                     return Single.error(e);
                   });
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               @NotNull
               @Override
               public ListenableFuture<MediatorResult> loadFuture(
                 @NotNull LoadType loadType,
                 @NotNull PagingState<Integer, User> state
               ) {
                 // The network load method takes an optional after=<user.id> parameter. For
                 // every page after the first, pass the last user ID to let it continue from
                 // where it left off. For REFRESH, pass null to load the first page.
                 ResolvableFuture<RemoteKey> remoteKeyFuture = ResolvableFuture.create();
                 switch (loadType) {
                   case REFRESH:
                     remoteKeyFuture.set(new RemoteKey(query, null));
                     break;
                   case PREPEND:
                     // In this example, you never need to prepend, since REFRESH will always
                     // load the first page in the list. Immediately return, reporting end of
                     // pagination.
                     return Futures.immediateFuture(new MediatorResult.Success(true));
                   case APPEND:
                     User lastItem = state.lastItemOrNull();

                     // You must explicitly check if the last item is null when appending,
                     // since passing null to networkService is only valid for initial load.
                     // If lastItem is null it means no items were loaded after the initial
                     // REFRESH and there are no more items to load.
                     if (lastItem == null) {
                       return Futures.immediateFuture(new MediatorResult.Success(true));
                     }

                     // Query remoteKeyDao for the next RemoteKey.
                     remoteKeyFuture.setFuture(
                       remoteKeyDao.remoteKeyByQueryFuture(query));
                     break;
                 }

                 return Futures.transformAsync(remoteKeyFuture, remoteKey -> {
                   // You must explicitly check if the page key is null when appending,
                   // since null is only valid for initial load. If you receive null
                   // for APPEND, that means you have reached the end of pagination and
                   // there are no more items to load.
                   if (loadType != LoadType.REFRESH && remoteKey.getNextKey() == null) {
                     return Futures.immediateFuture(new MediatorResult.Success(true));
                   }

                   ListenableFuture<MediatorResult> networkResult = Futures.transform(
                     networkService.searchUsers(query, remoteKey.getNextKey()),
                     response -> {
                       database.runInTransaction(() -> {
                       if (loadType == LoadType.REFRESH) {
                         userDao.deleteByQuery(query);
                         remoteKeyDao.deleteByQuery(query);
                       }

                       // Update RemoteKey for this query.
                       remoteKeyDao.insertOrReplace(new RemoteKey(query, response.getNextKey()));

                       // Insert new users into database, which invalidates the current
                       // PagingData, allowing Paging to present the updates in the DB.
                       userDao.insertAll(response.getUsers());
                     });

                     return new MediatorResult.Success(response.getNextKey() == null);
                   }, bgExecutor);

                   ListenableFuture<MediatorResult> ioCatchingNetworkResult =
                     Futures.catching(
                       networkResult,
                       IOException.class,
                       MediatorResult.Error::new,
                       bgExecutor
                     );

                   return Futures.catching(
                     ioCatchingNetworkResult,
                     HttpException.class,
                     MediatorResult.Error::new,
                     bgExecutor
                   );
                 }, bgExecutor);
               }

   .. rubric:: Refresh in place
      :name: refresh-in-place

   If your app only needs to support network refreshes from the top of
   the list as in the previous examples, then your ``RemoteMediator``
   does not need to define prepend load behavior.

   However, if your app needs to support loading incrementally from the
   network into the local database, then you must provide support for
   resuming pagination starting at the anchor, the user's scroll
   position. Room's ``PagingSource`` implementation handles this for
   you, but if you're not using Room you can do this by overriding
   `PagingSource.getRefreshKey() <#getrefreshkey>`__.
   For an example implementation of ``getRefreshKey()``, see `Define the PagingSource <#pagingsource>`__.

   Figure 4 illustrates the process of loading data first from the local
   database, and then from the network once the database is out of data.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/paging3-layered-load.svg
      name: layered-load-fig
      :alt: The PagingSource loads from the database into the UI until
      the database is out of data. Then the RemoteMediator loads from
      the network into the database, and afterward the PagingSource
      continues loading.
      :width: 800px

   **Figure 4.** Diagram showing how PagingSource and RemoteMediator
   work together to load data.

   .. rubric:: Additional resources
      :name: additional-resources

   To learn more about the Paging library, see the following additional
   resources:

   .. rubric:: Codelabs
      :name: codelabs

   -  `Android Paging codelab <https://developers.google.cn/codelabs/codelabs/android-paging>`__

   .. rubric:: Samples
      :name: samples

   -  `Android Architecture Components Paging with Database and Network sample <https://github.com/android/architecture-components-samples/tree/main/PagingWithNetworkSample>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Load and display paged data <#>`__
   -  `Test your Paging implementation <#>`__
   -  `Migrate to Paging 3 <#>`__

Last updated 2023-07-12 UTC.


/Transform data streams
=======================

.. container:: devsite-article-body clearfix

   When you `work with paged data <#>`__, you
   often need to transform the data stream as you load it. For example,
   you might need to filter a list of items, or convert items to a
   different type before you present them in the UI. Another common use
   case for data stream transformation is `adding list separators <#separators>`__.

   More generally, applying transformations directly to the data stream
   allows you to keep your repository constructs and UI constructs
   separate.

   This page assumes that you are familiar with `basic use of the Paging library <#>`__.

   .. rubric:: Apply basic transformations
      :name: basic-transformations

   Because
   `PagingData <#>`__ is
   encapsulated in a reactive stream, you can apply transform operations
   on the data incrementally between loading the data and presenting it.

   In order to apply transformations to each ``PagingData`` object in
   the stream, place the transformations inside a
   `map() <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html>`__
   operation on the stream:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               pager.flow // Type is Flow<PagingData<User>>.
                 // Map the outer stream so that the transformations are applied to
                 // each new generation of PagingData.
                 .map { pagingData ->
                   // Transformations in this block are applied to the items
                   // in the paged data.
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               PagingRx.getFlowable(pager) // Type is Flowable<PagingData<User>>.
                 // Map the outer stream so that the transformations are applied to
                 // each new generation of PagingData.
                 .map(pagingData -> {
                   // Transformations in this block are applied to the items
                   // in the paged data.
                 });

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               // Map the outer stream so that the transformations are applied to
               // each new generation of PagingData.
               Transformations.map(
                 // Type is LiveData<PagingData<User>>.
                 PagingLiveData.getLiveData(pager),
                 pagingData -> {
                   // Transformations in this block are applied to the items
                   // in the paged data.
                 });

   .. rubric:: Convert data
      :name: convert-data

   The most basic operation on a stream of data is converting it to a
   different type. Once you have access to the ``PagingData`` object,
   you can perform a ``map()`` operation on each individual item in the
   paged list within the ``PagingData`` object.

   One common use case for this is to map a network or database layer
   object onto an object specifically used in the UI layer. The example
   below demonstrates how to apply this type of map operation:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               pager.flow // Type is Flow<PagingData<User>>.
                 .map { pagingData ->
                   pagingData.map { user -> UiModel(user) }
                 }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               // Type is Flowable<PagingData<User>>.
               PagingRx.getFlowable(pager)
                 .map(pagingData ->
                   pagingData.map(UiModel.UserModel::new)
                 )

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               Transformations.map(
                 // Type is LiveData<PagingData<User>>.
                 PagingLiveData.getLiveData(pager),
                 pagingData ->
                   pagingData.map(UiModel.UserModel::new)
               )

   Another common data conversion is taking an input from the user, such
   as a query string, and converting it to the request output to
   display. Setting this up requires listening for and capturing the
   user's query input, performing the request, and pushing the query
   result back to the UI.

   You can listen for the query input using a stream API. Keep the
   stream reference in your ``ViewModel``. The UI layer should not have
   direct access to it; instead, define a function to notify the
   ViewModel of the user's query.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               private val queryFlow = MutableStateFlow("")

               fun onQueryChanged(query: String) {
                 queryFlow.value = query
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               private BehaviorSubject<String> querySubject = BehaviorSubject.create("");

               public void onQueryChanged(String query) {
                 queryFlow.onNext(query)
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               private MutableLiveData<String> queryLiveData = new MutableLiveData("");

               public void onQueryChanged(String query) {
                 queryFlow.setValue(query)
               }

   When the query value changes in the data stream, you can perform
   operations to convert the query value to the desired data type and
   return the result to the UI layer. The specific conversion function
   depends on the language and framework used, but they all provide
   similar functionality.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               val querySearchResults = queryFlow.flatMapLatest { query ->
                 // The database query returns a Flow which is output through
                 // querySearchResults
                 userDatabase.searchBy(query)
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               Observable<User> querySearchResults =
                 querySubject.switchMap(query -> userDatabase.searchBy(query));

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               LiveData<User> querySearchResults = Transformations.switchMap(
                 queryLiveData,
                 query -> userDatabase.searchBy(query)
               );

   Using operations like ``flatMapLatest`` or ``switchMap`` ensures that
   only the latest results are returned to the UI. If the user changes
   their query input before the database operation completes, these
   operations discard the results from the old query and launch the new
   search immediately.

   .. rubric:: Filter data
      :name: filter-data

   Another common operation is filtering. You can filter data based on
   criteria from the user, or you can remove data from the UI if it
   should be hidden based on other criteria.

   You need to place these filter operations inside the ``map()`` call
   because the filter applies to the ``PagingData`` object. Once the
   data is filtered out of the ``PagingData``, the new ``PagingData``
   instance is passed to the UI layer to display.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               pager.flow // Type is Flow<PagingData<User>>.
                 .map { pagingData ->
                   pagingData.filter { user -> !user.hiddenFromUi }
                 }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               // Type is Flowable<PagingData<User>>.
               PagingRx.getFlowable(pager)
                 .map(pagingData ->
                   pagingData.filter(user -> !user.isHiddenFromUi())
                 )
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               Transformations.map(
                 // Type is LiveData<PagingData<User>>.
                 PagingLiveData.getLiveData(pager),
                 pagingData ->
                   pagingData.filter(user -> !user.isHiddenFromUi())
               )

   .. rubric:: Add list separators
      :name: separators

   The Paging library supports dynamic list separators. You can improve
   list readability by inserting separators directly into the data
   stream as ``RecyclerView`` list items. As a result, separators are
   fully-featured ``ViewHolder`` objects, enabling interactivity,
   accessibility focus, and all of the other features provided by a
   ``View``.

   There are three steps involved in inserting separators into your
   paged list:

   #. Convert the UI model to accommodate the separator items.
   #. Transform the data stream to dynamically add the separators
      between loading the data and presenting the data.
   #. Update the UI to handle separator items.

   **Note:**\  If you don't need your list separators to be interactive
   or implement accessibility focus, it is simpler to use
   `RecyclerView.ItemDecoration <#>`__
   to create static list separators instead.

   .. rubric:: Convert the UI model
      :name: convert-ui-model

   The Paging library inserts list separators into the ``RecyclerView``
   as actual list items, but the separator items must be distinguishable
   from the data items in the list to enable them to bind to a different
   ``ViewHolder`` type with a distinct UI. The solution is to create a
   `Kotlin sealed class <https://kotlinlang.org/docs/reference/sealed-classes.html>`__
   with subclasses to represent your data and your separators.
   Alternatively, you can create a base class that is extended by your
   list item class and your separator class.

   Suppose that you want to add separators to a paged list of ``User``
   items. The following snippet shows how to create a base class where
   the instances can be either a ``UserModel`` or a ``SeparatorModel``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               sealed class UiModel {
                 class UserModel(val id: String, val label: String) : UiModel() {
                   constructor(user: User) : this(user.id, user.label)
                 }

                 class SeparatorModel(val description: String) : UiModel()
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               class UiModel {
                 private UiModel() {}

                 static class UserModel extends UiModel {
                   @NonNull
                   private String mId;
                   @NonNull
                   private String mLabel;

                   UserModel(@NonNull String id, @NonNull String label) {
                     mId = id;
                     mLabel = label;
                   }

                   UserModel(@NonNull User user) {
                     mId = user.id;
                     mLabel = user.label;
                   }

                   @NonNull
                   public String getId() {
                     return mId;
                   }

                   @NonNull
                   public String getLabel() {
                     return mLabel;
                     }
                   }

                   static class SeparatorModel extends UiModel {
                   @NonNull
                   private String mDescription;

                   SeparatorModel(@NonNull String description) {
                     mDescription = description;
                   }

                   @NonNull
                   public String getDescription() {
                     return mDescription;
                   }
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               class UiModel {
                 private UiModel() {}

                 static class UserModel extends UiModel {
                   @NonNull
                   private String mId;
                   @NonNull
                   private String mLabel;

                   UserModel(@NonNull String id, @NonNull String label) {
                     mId = id;
                     mLabel = label;
                   }

                   UserModel(@NonNull User user) {
                     mId = user.id;
                     mLabel = user.label;
                   }

                   @NonNull
                   public String getId() {
                     return mId;
                   }

                   @NonNull
                   public String getLabel() {
                     return mLabel;
                     }
                   }

                   static class SeparatorModel extends UiModel {
                   @NonNull
                   private String mDescription;

                   SeparatorModel(@NonNull String description) {
                     mDescription = description;
                   }

                   @NonNull
                   public String getDescription() {
                     return mDescription;
                   }
                 }
               }

   .. rubric:: Transform the data stream
      :name: transform-data-stream

   You must apply transformations to the data stream after loading it
   and before you present it. The transformations should do the
   following:

   -  Convert the loaded list items to reflect the new base item type.
   -  Use the ``PagingData.insertSeparators()`` method to add the
      separators.

   To learn more about transformation operations, see `Apply basic transformations <#basic-transformations>`__.

   The following example shows transformation operations to update the
   ``PagingData<User>`` stream to a ``PagingData<UiModel>`` stream with
   separators added:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               pager.flow.map { pagingData: PagingData<User> ->
                 // Map outer stream, so you can perform transformations on
                 // each paging generation.
                 pagingData
                 .map { user ->
                   // Convert items in stream to UiModel.UserModel.
                   UiModel.UserModel(user)
                 }
                 .insertSeparators<UiModel.UserModel, UiModel> { before, after ->
                   when {
                     before == null -> UiModel.SeparatorModel("HEADER")
                     after == null -> UiModel.SeparatorModel("FOOTER")
                     shouldSeparate(before, after) -> UiModel.SeparatorModel(
                       "BETWEEN ITEMS $before AND $after"
                     )
                     // Return null to avoid adding a separator between two items.
                     else -> null
                   }
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               // Map outer stream, so you can perform transformations on each
               // paging generation.
               PagingRx.getFlowable(pager).map(pagingData -> {
                 // First convert items in stream to UiModel.UserModel.
                 PagingData<UiModel> uiModelPagingData = pagingData.map(
                   UiModel.UserModel::new);

                 // Insert UiModel.SeparatorModel, which produces PagingData of
                 // generic type UiModel.
                 return PagingData.insertSeparators(uiModelPagingData,
                   (@Nullable UiModel before, @Nullable UiModel after) -> {
                     if (before == null) {
                       return new UiModel.SeparatorModel("HEADER");
                     } else if (after == null) {
                       return new UiModel.SeparatorModel("FOOTER");
                     } else if (shouldSeparate(before, after)) {
                       return new UiModel.SeparatorModel("BETWEEN ITEMS "
                         + before.toString() + " AND " + after.toString());
                     } else {
                       // Return null to avoid adding a separator between two
                       // items.
                       return null;
                     }
                   });
               });

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               // Map outer stream, so you can perform transformations on each
               // paging generation.
               Transformations.map(PagingLiveData.getLiveData(pager),
                 pagingData -> {
                   // First convert items in stream to UiModel.UserModel.
                   PagingData<UiModel> uiModelPagingData = pagingData.map(
                     UiModel.UserModel::new);

                   // Insert UiModel.SeparatorModel, which produces PagingData of
                   // generic type UiModel.
                   return PagingData.insertSeparators(uiModelPagingData,
                     (@Nullable UiModel before, @Nullable UiModel after) -> {
                       if (before == null) {
                         return new UiModel.SeparatorModel("HEADER");
                       } else if (after == null) {
                         return new UiModel.SeparatorModel("FOOTER");
                       } else if (shouldSeparate(before, after)) {
                         return new UiModel.SeparatorModel("BETWEEN ITEMS "
                           + before.toString() + " AND " + after.toString());
                       } else {
                         // Return null to avoid adding a separator between two
                         // items.
                         return null;
                       }
                     });
                 });

   .. rubric:: Handle separators in the UI
      :name: handle-separators-ui

   The final step is to change your UI to accommodate the separator item
   type. Create a layout and a view holder for your separator items and
   change the list adapter to use ``RecyclerView.ViewHolder`` as its
   view holder type so that it can handle more than one type of view
   holder. Alternatively, you can define a common base class that both
   your item and separator view holder classes extend.

   You must also make the following changes to your list adapter:

   -  Add cases to the ``onCreateViewHolder()`` and
      ``onBindViewHolder()`` methods to account for separator list
      items.
   -  Implement a new comparator.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               class UiModelAdapter :
                 PagingDataAdapter<UiModel, RecyclerView.ViewHolder>(UiModelComparator) {

                 override fun onCreateViewHolder(
                   parent: ViewGroup,
                   viewType: Int
                 ) = when (viewType) {
                   R.layout.item -> UserModelViewHolder(parent)
                   else -> SeparatorModelViewHolder(parent)
                 }

                 override fun getItemViewType(position: Int) {
                   // Use peek over getItem to avoid triggering page fetch / drops, since
                   // recycling views is not indicative of the user's current scroll position.
                   return when (peek(position)) {
                     is UiModel.UserModel -> R.layout.item
                     is UiModel.SeparatorModel -> R.layout.separator_item
                     null -> throw IllegalStateException("Unknown view")
                   }
                 }

                 override fun onBindViewHolder(
                   holder: RecyclerView.ViewHolder,
                   position: Int
                 ) {
                   val item = getItem(position)
                   if (holder is UserModelViewHolder) {
                     holder.bind(item as UserModel)
                   } else if (holder is SeparatorModelViewHolder) {
                     holder.bind(item as SeparatorModel)
                   }
                 }
               }

               object UiModelComparator : DiffUtil.ItemCallback<UiModel>() {
                 override fun areItemsTheSame(
                   oldItem: UiModel,
                   newItem: UiModel
                 ): Boolean {
                   val isSameRepoItem = oldItem is UiModel.UserModel
                     && newItem is UiModel.UserModel
                     && oldItem.id == newItem.id

                   val isSameSeparatorItem = oldItem is UiModel.SeparatorModel
                     && newItem is UiModel.SeparatorModel
                     && oldItem.description == newItem.description

                   return isSameRepoItem || isSameSeparatorItem
                 }

                 override fun areContentsTheSame(
                   oldItem: UiModel,
                   newItem: UiModel
                 ) = oldItem == newItem
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               class UiModelAdapter extends PagingDataAdapter<UiModel, RecyclerView.ViewHolder> {
                 UiModelAdapter() {
                   super(new UiModelComparator(), Dispatchers.getMain(),
                     Dispatchers.getDefault());
                 }

                 @NonNull
                 @Override
                 public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent,
                   int viewType) {
                   if (viewType == R.layout.item) {
                     return new UserModelViewHolder(parent);
                   } else {
                     return new SeparatorModelViewHolder(parent);
                   }
                 }

                 @Override
                 public int getItemViewType(int position) {
                   // Use peek over getItem to avoid triggering page fetch / drops, since
                   // recycling views is not indicative of the user's current scroll position.
                   UiModel item = peek(position);
                   if (item instanceof UiModel.UserModel) {
                     return R.layout.item;
                   } else if (item instanceof UiModel.SeparatorModel) {
                     return R.layout.separator_item;
                   } else {
                     throw new IllegalStateException("Unknown view");
                   }
                 }

                 @Override
                 public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder,
                   int position) {
                   if (holder instanceOf UserModelViewHolder) {
                     UserModel userModel = (UserModel) getItem(position);
                     ((UserModelViewHolder) holder).bind(userModel);
                   } else {
                     SeparatorModel separatorModel = (SeparatorModel) getItem(position);
                     ((SeparatorModelViewHolder) holder).bind(separatorModel);
                   }
                 }
               }

               class UiModelComparator extends DiffUtil.ItemCallback<UiModel> {
                 @Override
                 public boolean areItemsTheSame(@NonNull UiModel oldItem,
                   @NonNull UiModel newItem) {
                   boolean isSameRepoItem = oldItem instanceof UserModel
                     && newItem instanceof UserModel
                     && ((UserModel) oldItem).getId().equals(((UserModel) newItem).getId());

                   boolean isSameSeparatorItem = oldItem instanceof SeparatorModel
                     && newItem instanceof SeparatorModel
                     && ((SeparatorModel) oldItem).getDescription().equals(
                     ((SeparatorModel) newItem).getDescription());

                   return isSameRepoItem || isSameSeparatorItem;
                 }

                 @Override
                 public boolean areContentsTheSame(@NonNull UiModel oldItem,
                   @NonNull UiModel newItem) {
                   return oldItem.equals(newItem);
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               class UiModelAdapter extends PagingDataAdapter<UiModel, RecyclerView.ViewHolder> {
                 UiModelAdapter() {
                   super(new UiModelComparator(), Dispatchers.getMain(),
                     Dispatchers.getDefault());
                 }

                 @NonNull
                 @Override
                 public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent,
                   int viewType) {
                   if (viewType == R.layout.item) {
                     return new UserModelViewHolder(parent);
                   } else {
                     return new SeparatorModelViewHolder(parent);
                   }
                 }

                 @Override
                 public int getItemViewType(int position) {
                   // Use peek over getItem to avoid triggering page fetch / drops, since
                   // recycling views is not indicative of the user's current scroll position.
                   UiModel item = peek(position);
                   if (item instanceof UiModel.UserModel) {
                     return R.layout.item;
                   } else if (item instanceof UiModel.SeparatorModel) {
                     return R.layout.separator_item;
                   } else {
                     throw new IllegalStateException("Unknown view");
                   }
                 }

                 @Override
                 public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder,
                   int position) {
                   if (holder instanceOf UserModelViewHolder) {
                     UserModel userModel = (UserModel) getItem(position);
                     ((UserModelViewHolder) holder).bind(userModel);
                   } else {
                     SeparatorModel separatorModel = (SeparatorModel) getItem(position);
                     ((SeparatorModelViewHolder) holder).bind(separatorModel);
                   }
                 }
               }

               class UiModelComparator extends DiffUtil.ItemCallback<UiModel> {
                 @Override
                 public boolean areItemsTheSame(@NonNull UiModel oldItem,
                   @NonNull UiModel newItem) {
                   boolean isSameRepoItem = oldItem instanceof UserModel
                     && newItem instanceof UserModel
                     && ((UserModel) oldItem).getId().equals(((UserModel) newItem).getId());

                   boolean isSameSeparatorItem = oldItem instanceof SeparatorModel
                     && newItem instanceof SeparatorModel
                     && ((SeparatorModel) oldItem).getDescription().equals(
                     ((SeparatorModel) newItem).getDescription());

                   return isSameRepoItem || isSameSeparatorItem;
                 }

                 @Override
                 public boolean areContentsTheSame(@NonNull UiModel oldItem,
                   @NonNull UiModel newItem) {
                   return oldItem.equals(newItem);
                 }
               }

   .. rubric:: Avoid duplicate work
      :name: avoid-duplicate

   One key issue to avoid is having the app do unnecessary work.
   Fetching data is an expensive operation, and data transformations can
   also take up valuable time. Once the data is loaded and prepared for
   display in the UI, it should be saved in case a configuration change
   occurs and the UI needs to be recreated.

   The ``cachedIn()`` operation caches the results of any
   transformations that occur before it. Therefore, ``cachedIn()``
   should be the last call in your ViewModel.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               pager.flow // Type is Flow<PagingData<User>>.
                 .map { pagingData ->
                   pagingData.filter { user -> !user.hiddenFromUi }
                     .map { user -> UiModel.UserModel(user) }
                 }
                 .cachedIn(viewModelScope)

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               // CoroutineScope helper provided by the lifecycle-viewmodel-ktx artifact.
               CoroutineScope viewModelScope = ViewModelKt.getViewModelScope(viewModel);
               PagingRx.cachedIn(
                 // Type is Flowable<PagingData<User>>.
                 PagingRx.getFlowable(pager)
                   .map(pagingData -> pagingData
                     .filter(user -> !user.isHiddenFromUi())
                     .map(UiModel.UserModel::new)),
                 viewModelScope);
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               // CoroutineScope helper provided by the lifecycle-viewmodel-ktx artifact.
               CoroutineScope viewModelScope = ViewModelKt.getViewModelScope(viewModel);
               PagingLiveData.cachedIn(
                 Transformations.map(
                   // Type is LiveData<PagingData<User>>.
                   PagingLiveData.getLiveData(pager),
                   pagingData -> pagingData
                     .filter(user -> !user.isHiddenFromUi())
                     .map(UiModel.UserModel::new)),
                 viewModelScope);

   For more information on using ``cachedIn()`` with a stream of
   ``PagingData``, see `Set up a stream of PagingData <#pagingdata-stream>`__.

   **Note:**\  You can use each instance of ``PagingData`` only once
   within ``submitData()``. To get around this limitation, consider
   using the ``cachedIn()`` operator, which multicasts the stream as
   part of caching the results. This allows subsequent observers to
   receive new valid instances of ``PagingData``. This is especially
   useful when you work with operators that reuse the most recently
   emitted ``PagingData``, such as Flow's ``.combine()`` operator.

   .. rubric:: Additional resources
      :name: additional-resources

   To learn more about the Paging library, see the following additional
   resources:

   .. rubric:: Codelabs
      :name: codelabs

   -  `Android Paging codelab <https://developers.google.cn/codelabs/codelabs/android-paging>`__

   .. rubric:: Samples
      :name: samples

   -  `Android Architecture Components Paging sample <https://github.com/android/architecture-components-samples/tree/main/PagingSample>`__
   -  `Android Architecture Components Paging with Database and Network sample <https://github.com/android/architecture-components-samples/tree/main/PagingWithNetworkSample>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Load and display paged data <#>`__
   -  `Test your Paging implementation <#>`__
   -  `Manage and present loading states <#>`__

Last updated 2023-07-12 UTC.


/Manage and present loading states
==================================

.. container:: devsite-article-body clearfix

   The Paging library tracks the state of load requests for paged data
   and exposes it through the
   `LoadState <#>`__
   class. Your app can register a listener with the
   `PagingDataAdapter <#>`__
   to receive information about the current state and update the UI
   accordingly. These states are provided from the adapter because they
   are synchronous with the UI. This means that your listener receives
   updates when the page load has been applied to the UI.

   A separate ``LoadState`` signal is provided for each
   `LoadType <#>`__ and
   data source type (either
   `PagingSource <#>`__
   or
   `RemoteMediator <#>`__).
   The
   `CombinedLoadStates <#>`__
   object provided by the listener provides information about the
   loading state from all of these signals. You can use this detailed
   information to display the appropriate loading indicators to your
   users.

   .. rubric:: Loading states
      :name: states

   The Paging library exposes the loading state for use in the UI
   through the ``LoadState`` object. ``LoadState`` objects take one of
   three forms depending on the current loading state:

   -  If there is no active load operation and no error, then
      ``LoadState`` is a
      `LoadState.NotLoading <#>`__
      object. This subclass also includes the
      `endOfPaginationReached <#endOfPaginationReached>`__
      property, which indicates whether the end of pagination has been
      reached.
   -  If there is an active load operation, then ``LoadState`` is a
      `LoadState.Loading <#>`__
      object.
   -  If there is an error, then ``LoadState`` is a
      `LoadState.Error <#>`__
      object.

   There are two ways to use ``LoadState`` in your UI: using a listener,
   or using a special list adapter to present the loading state directly
   in the
   `RecyclerView <#>`__
   list.

   .. rubric:: Access the loading state with a listener
      :name: listener

   To get the loading state for general use in your UI, use the
   `loadStateFlow <#loadstateflow>`__
   stream or the
   `addLoadStateListener() <#addloadstatelistener>`__
   method provided by your ``PagingDataAdapter``. These mechanisms
   provide access to a ``CombinedLoadStates`` object that includes
   information about the ``LoadState`` behavior for each load type.

   In the following example, the ``PagingDataAdapter`` displays
   different UI components depending on the current state of the refresh
   load:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               // Activities can use lifecycleScope directly, but Fragments should instead use
               // viewLifecycleOwner.lifecycleScope.
               lifecycleScope.launch {
                 pagingAdapter.loadStateFlow.collectLatest { loadStates ->
                   progressBar.isVisible = loadStates.refresh is LoadState.Loading
                   retry.isVisible = loadState.refresh !is LoadState.Loading
                   errorMsg.isVisible = loadState.refresh is LoadState.Error
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               pagingAdapter.addLoadStateListener(loadStates -> {
                 progressBar.setVisibility(loadStates.refresh instanceof LoadState.Loading
                   ? View.VISIBLE : View.GONE);
                 retry.setVisibility(loadStates.refresh instanceof LoadState.Loading
                   ? View.GONE : View.VISIBLE);
                 errorMsg.setVisibility(loadStates.refresh instanceof LoadState.Error
                   ? View.VISIBLE : View.GONE);
               });

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               pagingAdapter.addLoadStateListener(loadStates -> {
                 progressBar.setVisibility(loadStates.refresh instanceof LoadState.Loading
                   ? View.VISIBLE : View.GONE);
                 retry.setVisibility(loadStates.refresh instanceof LoadState.Loading
                   ? View.GONE : View.VISIBLE);
                 errorMsg.setVisibility(loadStates.refresh instanceof LoadState.Error
                   ? View.VISIBLE : View.GONE);
               });

   **Note:**\  Updates from ``loadStateFlow`` and
   ``addLoadStateListener()`` are guaranteed to be synchronous with
   updates to the UI. This means that if you receive a
   ``LoadState.NotLoading`` object, then you can be sure that loading
   has completed and the UI has been updated accordingly.
   For more information on ``CombinedLoadStates``, see `Access additional loading state information <#additional-info>`__.

   .. rubric:: Present the loading state with an adapter
      :name: adapter

   The Paging library provides another list adapter called
   `LoadStateAdapter <#>`__
   for the purpose of presenting the loading state directly in the
   displayed list of paged data. This adapter provides access to the
   current load state of the list, which you can pass to a custom view
   holder that displays the information.

   First, create a view holder class that keeps references to the
   loading and error views on your screen. Create a ``bind()`` function
   that accepts a ``LoadState`` as a parameter. This function should
   toggle the view visibility based on the load state parameter:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               class LoadStateViewHolder(
                 parent: ViewGroup,
                 retry: () -> Unit
               ) : RecyclerView.ViewHolder(
                 LayoutInflater.from(parent.context)
                   .inflate(R.layout.load_state_item, parent, false)
               ) {
                 private val binding = LoadStateItemBinding.bind(itemView)
                 private val progressBar: ProgressBar = binding.progressBar
                 private val errorMsg: TextView = binding.errorMsg
                 private val retry: Button = binding.retryButton
                   .also {
                     it.setOnClickListener { retry() }
                   }

                 fun bind(loadState: LoadState) {
                   if (loadState is LoadState.Error) {
                     errorMsg.text = loadState.error.localizedMessage
                   }

                   progressBar.isVisible = loadState is LoadState.Loading
                   retry.isVisible = loadState is LoadState.Error
                   errorMsg.isVisible = loadState is LoadState.Error
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               class LoadStateViewHolder extends RecyclerView.ViewHolder {
                 private ProgressBar mProgressBar;
                 private TextView mErrorMsg;
                 private Button mRetry;

                 LoadStateViewHolder(
                   @NonNull ViewGroup parent,
                   @NonNull View.OnClickListener retryCallback) {
                   super(LayoutInflater.from(parent.getContext())
                     .inflate(R.layout.load_state_item, parent, false));

                   LoadStateItemBinding binding = LoadStateItemBinding.bind(itemView);
                   mProgressBar = binding.progressBar;
                   mErrorMsg = binding.errorMsg;
                   mRetry = binding.retryButton;
                 }

                 public void bind(LoadState loadState) {
                   if (loadState instanceof LoadState.Error) {
                     LoadState.Error loadStateError = (LoadState.Error) loadState;
                     mErrorMsg.setText(loadStateError.getError().getLocalizedMessage());
                   }
                   mProgressBar.setVisibility(loadState instanceof LoadState.Loading
                     ? View.VISIBLE : View.GONE);
                   mRetry.setVisibility(loadState instanceof LoadState.Error
                     ? View.VISIBLE : View.GONE);
                   mErrorMsg.setVisibility(loadState instanceof LoadState.Error
                     ? View.VISIBLE : View.GONE);
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               class LoadStateViewHolder extends RecyclerView.ViewHolder {
                 private ProgressBar mProgressBar;
                 private TextView mErrorMsg;
                 private Button mRetry;

                 LoadStateViewHolder(
                   @NonNull ViewGroup parent,
                   @NonNull View.OnClickListener retryCallback) {
                   super(LayoutInflater.from(parent.getContext())
                     .inflate(R.layout.load_state_item, parent, false));

                   LoadStateItemBinding binding = LoadStateItemBinding.bind(itemView);
                   mProgressBar = binding.progressBar;
                   mErrorMsg = binding.errorMsg;
                   mRetry = binding.retryButton;
                 }

                 public void bind(LoadState loadState) {
                   if (loadState instanceof LoadState.Error) {
                     LoadState.Error loadStateError = (LoadState.Error) loadState;
                     mErrorMsg.setText(loadStateError.getError().getLocalizedMessage());
                   }
                   mProgressBar.setVisibility(loadState instanceof LoadState.Loading
                     ? View.VISIBLE : View.GONE);
                   mRetry.setVisibility(loadState instanceof LoadState.Error
                     ? View.VISIBLE : View.GONE);
                   mErrorMsg.setVisibility(loadState instanceof LoadState.Error
                     ? View.VISIBLE : View.GONE);
                 }
               }

   Next, create a class that implements ``LoadStateAdapter``, and define
   the
   `onCreateViewHolder() <#onCreateViewHolder>`__
   and
   `onBindViewHolder() <#onBindViewHolder>`__
   methods. These methods create an instance of your custom view holder
   and bind the associated load state.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               // Adapter that displays a loading spinner when
               // state is LoadState.Loading, and an error message and retry
               // button when state is LoadState.Error.
               class ExampleLoadStateAdapter(
                 private val retry: () -> Unit
               ) : LoadStateAdapter<LoadStateViewHolder>() {

                 override fun onCreateViewHolder(
                   parent: ViewGroup,
                   loadState: LoadState
                 ) = LoadStateViewHolder(parent, retry)

                 override fun onBindViewHolder(
                   holder: LoadStateViewHolder,
                   loadState: LoadState
                 ) = holder.bind(loadState)
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               // Adapter that displays a loading spinner when
               // state is LoadState.Loading, and an error message and retry
               // button when state is LoadState.Error.
               class ExampleLoadStateAdapter extends LoadStateAdapter<LoadStateViewHolder> {
                 private View.OnClickListener mRetryCallback;

                 ExampleLoadStateAdapter(View.OnClickListener retryCallback) {
                   mRetryCallback = retryCallback;
                 }

                 @NotNull
                 @Override
                 public LoadStateViewHolder onCreateViewHolder(@NotNull ViewGroup parent,
                   @NotNull LoadState loadState) {
                   return new LoadStateViewHolder(parent, mRetryCallback);
                 }

                 @Override
                 public void onBindViewHolder(@NotNull LoadStateViewHolder holder,
                   @NotNull LoadState loadState) {
                   holder.bind(loadState);
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               // Adapter that displays a loading spinner when
               // state is LoadState.Loading, and an error message and retry
               // button when state is LoadState.Error.
               class ExampleLoadStateAdapter extends LoadStateAdapter<LoadStateViewHolder> {
                 private View.OnClickListener mRetryCallback;

                 ExampleLoadStateAdapter(View.OnClickListener retryCallback) {
                   mRetryCallback = retryCallback;
                 }

                 @NotNull
                 @Override
                 public LoadStateViewHolder onCreateViewHolder(@NotNull ViewGroup parent,
                   @NotNull LoadState loadState) {
                   return new LoadStateViewHolder(parent, mRetryCallback);
                 }

                 @Override
                 public void onBindViewHolder(@NotNull LoadStateViewHolder holder,
                   @NotNull LoadState loadState) {
                   holder.bind(loadState);
                 }
               }

   .. rubric:: Display the loading state as a header or footer
      :name: header-footer

   To display the loading progress in a header and a footer, call the
   `withLoadStateHeaderAndFooter() <#withloadstateheaderandfooter>`__
   method from your ``PagingDataAdapter`` object:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               pagingAdapter
                 .withLoadStateHeaderAndFooter(
                   header = ExampleLoadStateAdapter(adapter::retry),
                   footer = ExampleLoadStateAdapter(adapter::retry)
                 )

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               pagingAdapter
                 .withLoadStateHeaderAndFooter(
                   new ExampleLoadStateAdapter(pagingAdapter::retry),
                   new ExampleLoadStateAdapter(pagingAdapter::retry));

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               pagingAdapter
                 .withLoadStateHeaderAndFooter(
                   new ExampleLoadStateAdapter(pagingAdapter::retry),
                   new ExampleLoadStateAdapter(pagingAdapter::retry));

   You can instead call
   `withLoadStateHeader() <#withloadstateheader>`__
   or
   `withLoadStateFooter() <#withloadstatefooter>`__
   if you want the ``RecyclerView`` list to display the loading state
   only in the header or only in the footer.

   .. rubric:: Access additional loading state information
      :name: additional-info

   The ``CombinedLoadStates`` object from ``PagingDataAdapter`` provides
   information on the load states for your ``PagingSource``
   implementation and also for your ``RemoteMediator`` implementation,
   if one exists.

   For convenience, you can use the
   `refresh <#refresh>`__,
   `append <#append>`__,
   and
   `prepend <#prepend>`__
   properties from ``CombinedLoadStates`` to access a ``LoadState``
   object for the appropriate load type. These properties generally
   defer to the load state from the ``RemoteMediator`` implementation if
   one exists; otherwise, they contain the appropriate load state from
   the ``PagingSource`` implementation. For more detailed information on
   the underlying logic, see the reference documentation for
   `CombinedLoadStates <#>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               lifecycleScope.launch {
                 pagingAdapter.loadStateFlow.collectLatest { loadStates ->
                   // Observe refresh load state from RemoteMediator if present, or
                   // from PagingSource otherwise.
                   refreshLoadState: LoadState = loadStates.refresh
                   // Observe prepend load state from RemoteMediator if present, or
                   // from PagingSource otherwise.
                   prependLoadState: LoadState = loadStates.prepend
                   // Observe append load state from RemoteMediator if present, or
                   // from PagingSource otherwise.
                   appendLoadState: LoadState = loadStates.append
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               pagingAdapter.addLoadStateListener(loadStates -> {
                 // Observe refresh load state from RemoteMediator if present, or
                 // from PagingSource otherwise.
                 LoadState refreshLoadState = loadStates.refresh;
                 // Observe prepend load state from RemoteMediator if present, or
                 // from PagingSource otherwise.
                 LoadState prependLoadState = loadStates.prepend;
                 // Observe append load state from RemoteMediator if present, or
                 // from PagingSource otherwise.
                 LoadState appendLoadState = loadStates.append;
               });

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               pagingAdapter.addLoadStateListener(loadStates -> {
                 // Observe refresh load state from RemoteMediator if present, or
                 // from PagingSource otherwise.
                 LoadState refreshLoadState = loadStates.refresh;
                 // Observe prepend load state from RemoteMediator if present, or
                 // from PagingSource otherwise.
                 LoadState prependLoadState = loadStates.prepend;
                 // Observe append load state from RemoteMediator if present, or
                 // from PagingSource otherwise.
                 LoadState appendLoadState = loadStates.append;
               });

   However, it is important to remember that only the ``PagingSource``
   load states are guaranteed to be synchronous with UI updates. Because
   the ``refresh``, ``append``, and ``prepend`` properties can
   potentially take the load state from either ``PagingSource`` or
   ``RemoteMediator``, they are not guaranteed to be synchronous with UI
   updates. This can cause UI issues where the loading appears to finish
   before any of the new data has been added to the UI.

   For this reason, the convenience accessors work well for displaying
   the load state in a header or footer, but for other use cases you
   might need to specifically access the load state from either
   ``PagingSource`` or ``RemoteMediator``. ``CombinedLoadStates``
   provides the
   `source <#source>`__
   and
   `mediator <#mediator>`__
   properties for this purpose. These properties each expose a
   `LoadStates <#>`__
   object that contains the ``LoadState`` objects for ``PagingSource``
   or ``RemoteMediator`` respectively:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               lifecycleScope.launch {
                 pagingAdapter.loadStateFlow.collectLatest { loadStates ->
                   // Directly access the RemoteMediator refresh load state.
                   mediatorRefreshLoadState: LoadState? = loadStates.mediator.refresh
                   // Directly access the RemoteMediator append load state.
                   mediatorAppendLoadState: LoadState? = loadStates.mediator.append
                   // Directly access the RemoteMediator prepend load state.
                   mediatorPrependLoadState: LoadState? = loadStates.mediator.prepend
                   // Directly access the PagingSource refresh load state.
                   sourceRefreshLoadState: LoadState = loadStates.source.refresh
                   // Directly access the PagingSource append load state.
                   sourceAppendLoadState: LoadState = loadStates.source.append
                   // Directly access the PagingSource prepend load state.
                   sourcePrependLoadState: LoadState = loadStates.source.prepend
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               pagingAdapter.addLoadStateListener(loadStates -> {
                 // Directly access the RemoteMediator refresh load state.
                 LoadState mediatorRefreshLoadState = loadStates.mediator.refresh;
                 // Directly access the RemoteMediator append load state.
                 LoadState mediatorAppendLoadState = loadStates.mediator.append;
                 // Directly access the RemoteMediator prepend load state.
                 LoadState mediatorPrependLoadState = loadStates.mediator.prepend;
                 // Directly access the PagingSource refresh load state.
                 LoadState sourceRefreshLoadState = loadStates.source.refresh;
                 // Directly access the PagingSource append load state.
                 LoadState sourceAppendLoadState = loadStates.source.append;
                 // Directly access the PagingSource prepend load state.
                 LoadState sourcePrependLoadState = loadStates.source.prepend;
               });

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               pagingAdapter.addLoadStateListener(loadStates -> {
                 // Directly access the RemoteMediator refresh load state.
                 LoadState mediatorRefreshLoadState = loadStates.mediator.refresh;
                 // Directly access the RemoteMediator append load state.
                 LoadState mediatorAppendLoadState = loadStates.mediator.append;
                 // Directly access the RemoteMediator prepend load state.
                 LoadState mediatorPrependLoadState = loadStates.mediator.prepend;
                 // Directly access the PagingSource refresh load state.
                 LoadState sourceRefreshLoadState = loadStates.source.refresh;
                 // Directly access the PagingSource append load state.
                 LoadState sourceAppendLoadState = loadStates.source.append;
                 // Directly access the PagingSource prepend load state.
                 LoadState sourcePrependLoadState = loadStates.source.prepend;
               });

   .. rubric:: Chain operators on LoadState
      :name: chain-operators

   Because the ``CombinedLoadStates`` object provides access to all
   changes in load state, it is important to filter the load state
   stream based on specific events. This ensures that you update your UI
   at the appropriate time to avoid stutters and unnecessary UI updates.

   For example, suppose that you want to display an empty view, but only
   after the initial data load completes. This use case requires that
   you verify that a data refresh load has started, then wait for the
   ``NotLoading`` state to confirm that the refresh has completed. You
   must filter out all signals except for the ones you need:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               lifecycleScope.launchWhenCreated {
                 adapter.loadStateFlow
                   // Only emit when REFRESH LoadState for RemoteMediator changes.
                   .distinctUntilChangedBy { it.refresh }
                   // Only react to cases where REFRESH completes, such as NotLoading.
                   .filter { it.refresh is LoadState.NotLoading }
                   // Scroll to top is synchronous with UI updates, even if remote load was
                   // triggered.
                   .collect { binding.list.scrollToPosition(0) }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               PublishSubject<CombinedLoadStates> subject = PublishSubject.create();
               Disposable disposable =
                 subject.distinctUntilChanged(CombinedLoadStates::getRefresh)
                 .filter(
                   combinedLoadStates -> combinedLoadStates.getRefresh() instanceof LoadState.NotLoading)
                 .subscribe(combinedLoadStates -> binding.list.scrollToPosition(0));

               pagingAdapter.addLoadStateListener(loadStates -> {
                 subject.onNext(loadStates);
               });

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               LiveData<CombinedLoadStates> liveData = new MutableLiveData<>();
               LiveData<LoadState> refreshLiveData =
                 Transformations.map(liveData, CombinedLoadStates::getRefresh);
               LiveData<LoadState> distinctLiveData =
                 Transformations.distinctUntilChanged(refreshLiveData);

               distinctLiveData.observeForever(loadState -> {
                 if (loadState instanceof LoadState.NotLoading) {
                   binding.list.scrollToPosition(0);
                 }
               });

   This example waits until the refresh load state is updated, but only
   triggers when the state is ``NotLoading``. This ensures that the
   remote refresh has fully finished before any UI updates happen.

   Stream APIs make this type of operation possible. Your app can
   specify the load events it needs and handle the new data when the
   appropriate criteria are met.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Load and display paged data <#>`__
   -  `Page from network and database <#>`__
   -  `Paging library overview <#>`__

Last updated 2023-07-12 UTC.


/Test your Paging implementation
================================

.. container:: devsite-article-body clearfix

   Implementing the Paging library in your app should be paired with a
   robust testing strategy. You should test data loading components such
   as
   `PagingSource <#>`__
   and
   `RemoteMediator <#>`__
   to ensure that they work as expected. You should also write
   end-to-end tests to verify that all of the components in your Paging
   implementation work correctly together without unexpected side
   effects.

   This guide explains how to test the Paging library in the different
   `architecture layers <#>`__ of your app as well as
   how to write end-to-end tests for your entire Paging implementation.

   .. rubric:: UI layer tests
      :name: ui-layer-tests

   Data fetched with the Paging library is consumed in the UI as a
   ``Flow<PagingData<Value>>``. To write tests to verify the data in the
   UI is as you expect, include the ``paging-testing`` dependency. It
   contains the ``asSnapshot()`` extension on a
   ``Flow<PagingData<Value>>``. It offers APIs in its lambda receiver
   that allow for mocking scrolling interactions. It returns a standard
   ``List<Value>`` produced by the scrolling interactions mocked, which
   allows you assert the data paged through contains the expected
   elements generated by those interactions. This is illustrated in the
   following snippet:

   .. code:: prettyprint

      fun test_items_contain_one_to_ten() = runTest {
        // Get the Flow of PagingData from the ViewModel under test
        val items: Flow<PagingData<String>> = viewModel.items

        val itemsSnapshot: List<String> = items.asSnapshot {
          // Scroll to the 50th item in the list. This will also suspend till
          // the prefetch requirement is met if there's one.
          // It also suspends until all loading is complete.
          scrollTo(index = 50)
        }

        // With the asSnapshot complete, you can now verify that the snapshot
        // has the expected values
        assertEquals(
          expected = (0..50).map(Int::toString),
          actual = itemsSnapshot
        )
      }

   Alternatively, you can scroll until a given predicate is met as seen
   in the snippet below:

   .. code:: prettyprint

      fun test_footer_is_visible() = runTest {
        // Get the Flow of PagingData from the ViewModel under test
        val items: Flow<PagingData<String>> = viewModel.items

        val itemsSnapshot: List<String> = items.asSnapshot {
          // Scroll till the footer is visible
          appendScrollWhile {  item: String -> item != "Footer" }
        }

   **Note:**\  The ``asSnapshot()`` lambda receiver offers more APIs
   such as ``refresh()`` and ``flingTo`` to test the effects of user
   interactions with the data returned as part of pagination.

   .. rubric:: Testing transformations
      :name: transformation-tests

   You should also write unit tests that cover any transformations you
   apply to the ``PagingData`` stream. Use the ``asPagingSourceFactory``
   extension. This extension is available on the following data types:

   -  ``List<Value>``.
   -  ``Flow<List<Value>>``.

   The choice of which extension to use depends on what you're trying to
   test. Use:

   -  ``List<Value>.asPagingSourceFactory()``: If you want to test
      static transformations like ``map()`` and ``insertSeparators()``
      on data.
   -  ``Flow<List<Value>>.asPagingSourceFactory()``: If you want to test
      how updates to your data, like writing to the backing data source,
      affects your paging pipeline.

   **Note:**\  Each emission of the ``Flow`` used with
   ``asPagingSourceFactory`` is a new generation of ``PagingData``. This
   lets you test ``PagingSource``
   `invalidation <#invalidate>`__
   behavior in your UI.
   To use either of these extensions follow the following pattern:

   -  Create the ``PagingSourceFactory`` using the appropriate extension
      for your needs.
   -  Use the returned ``PagingSourceFactory`` in a
      `fake <#>`__ for your
      `Repository <#>`__.
   -  Pass that ``Repository`` to your ``ViewModel``.

   The ``ViewModel`` can then be tested as in covered in the previous
   section. Consider the following ``ViewModel``:

   .. code:: prettyprint

      class MyViewModel(
        myRepository: myRepository
      ) {
        val items = Pager(
          config: PagingConfig,
          initialKey = null,
          pagingSourceFactory = { myRepository.pagingSource() }
        )
        .flow
        .map { pagingData ->
          pagingData.insertSeparators<String, String> { before, _ ->
            when {
              // Add a dashed String separator if the prior item is a multiple of 10
              before.last() == '0' -> "---------"
              // Return null to avoid adding a separator between two items.
              else -> null
            }
        }
      }

   To test the transformation in ``MyViewModel``, supply a fake instance
   of ``MyRepository`` that delegates to a static ``List`` representing
   the data to be transformed as shown in the following snippet:

   .. code:: prettyprint

      class FakeMyRepository(): MyRepository {
          private val items = (0..100).map(Any::toString)

          private val pagingSourceFactory = items.asPagingSourceFactory()

          val pagingSource = pagingSourceFactory()
      }

   You can then write a test for the separator logic as in the following
   snippet:

   .. code:: prettyprint

      fun test_separators_are_added_every_10_items() = runTest {
        // Create your ViewModel
        val viewModel = MyViewModel(
          myRepository = FakeMyRepository()
        )
        // Get the Flow of PagingData from the ViewModel with the separator transformations applied
        val items: Flow<PagingData<String>> = viewModel.items
                        
        val snapshot: List<String> = items.asSnapshot()

        // With the asSnapshot complete, you can now verify that the snapshot
        // has the expected separators.
      }

   .. rubric:: Data layer tests
      :name: data-layer-tests

   Write unit tests for the components in your data layer to ensure that
   they load the data from your data sources appropriately. Provide
   `fake <#>`__ versions of
   dependencies to verify that the components under test function
   correctly in isolation. The main components that you need to test in
   the repository layer are the ``PagingSource`` and the
   ``RemoteMediator``. The examples in the sections to follow are based
   on the `Paging with Network Sample <https://github.com/android/architecture-components-samples/tree/master/PagingWithNetworkSample>`__.

   .. rubric:: PagingSource tests
      :name: pagingsource-tests

   Unit tests for your ``PagingSource`` implementation involve setting
   up the ``PagingSource`` instance and loading data from it with a
   ``TestPager``.

   To set up the ``PagingSource`` instance for testing, provide fake
   data to the constructor. This gives you control over the data in your
   tests. In following example, the ``RedditApi`` parameter is a
   `Retrofit <https://square.github.io/retrofit/>`__ interface that
   defines the server requests and the response classes. A fake version
   can implement the interface, override any required functions, and
   provide convenience methods to configure how the fake object should
   react in tests.

   After the fakes are in place, set up the dependencies and initialize
   the ``PagingSource`` object in the test. The following example
   demonstrates initializing the ``FakeRedditApi`` object with a list of
   test posts, and testing the ``RedditPagingSource`` instance:

   .. code:: prettyprint

      class SubredditPagingSourceTest {
        private val mockPosts = listOf(
          postFactory.createRedditPost(DEFAULT_SUBREDDIT),
          postFactory.createRedditPost(DEFAULT_SUBREDDIT),
          postFactory.createRedditPost(DEFAULT_SUBREDDIT)
        )
        private val fakeApi = FakeRedditApi().apply {
          mockPosts.forEach { post -> addPost(post) }
        }

        @Test
        fun loadReturnsPageWhenOnSuccessfulLoadOfItemKeyedData() = runTest {
          val pagingSource = RedditPagingSource(
            fakeApi,
            DEFAULT_SUBREDDIT
          )

          val pager = TestPager(CONFIG, pagingSource)

          val result = pager.refresh() as LoadResult.Page

          // Write assertions against the loaded data
          assertThat(result.data)
          .containsExactlyElementsIn(mockPosts)
          .inOrder()
        }
      }

   The ``TestPager`` also lets you do the following:

   -  Test consecutive loads from your ``PagingSource``:

   .. code:: prettyprint

          @Test
          fun test_consecutive_loads() = runTest {

            val page = with(pager) {
              refresh()
              append()
              append()
            } as LoadResult.Page

            assertThat(page.data)
            .containsExactlyElementsIn(testPosts)
            .inOrder()
          }

   -  Test error scenarios in your ``PagingSource``:

   .. code:: prettyprint

          @Test
          fun refresh_returnError() {
              val pagingSource = RedditPagingSource(
                fakeApi,
                DEFAULT_SUBREDDIT
              )
              // Configure your fake to return errors
              fakeApi.setReturnsError()
              val pager = TestPager(CONFIG, source)

              runTest {
                  source.errorNextLoad = true
                  val result = pager.refresh()
                  assertTrue(result is LoadResult.Error)

                  val page = pager.getLastLoadedPage()
                  assertThat(page).isNull()
              }
          }

   .. rubric:: RemoteMediator tests
      :name: remotemediator-tests

   The goal of the ``RemoteMediator`` unit tests is to verify that the
   ``load()`` function returns the correct
   `MediatorResult <#>`__.
   Tests for side effects, such as data being inserted into the
   database, are better suited for `integration tests <#end-to-end>`__.

   The first step is to determine what dependencies your
   ``RemoteMediator`` implementation needs. The following example
   demonstrates a ``RemoteMediator`` implementation that requires a Room
   database, a Retrofit interface, and a search string:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               @OptIn(ExperimentalPagingApi::class)
               class PageKeyedRemoteMediator(
                 private val db: RedditDb,
                 private val redditApi: RedditApi,
                 private val subredditName: String
               ) : RemoteMediator<Int, RedditPost>() {
                 ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               public class PageKeyedRemoteMediator
                 extends RxRemoteMediator<Integer, RedditPost> {

                 @NonNull
                 private RedditDb db;
                 @NonNull
                 private RedditPostDao postDao;
                 @NonNull
                 private SubredditRemoteKeyDao remoteKeyDao;
                 @NonNull
                 private RedditApi redditApi;
                 @NonNull
                 private String subredditName;

                 public PageKeyedRemoteMediator(
                   @NonNull RedditDb db,
                   @NonNull RedditApi redditApi,
                   @NonNull String subredditName
                 ) {
                     this.db = db;
                     this.postDao = db.posts();
                     this.remoteKeyDao = db.remoteKeys();
                     this.redditApi = redditApi;
                     this.subredditName = subredditName;
                     ...
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               public class PageKeyedRemoteMediator
                 extends ListenableFutureRemoteMediator<Integer, RedditPost> {

                 @NonNull
                 private RedditDb db;
                 @NonNull
                 private RedditPostDao postDao;
                 @NonNull
                 private SubredditRemoteKeyDao remoteKeyDao;
                 @NonNull
                 private RedditApi redditApi;
                 @NonNull
                 private String subredditName;
                 @NonNull
                 private Executor bgExecutor;

                 public PageKeyedRemoteMediator(
                   @NonNull RedditDb db,
                   @NonNull RedditApi redditApi,
                   @NonNull String subredditName,
                   @NonNull Executor bgExecutor
                 ) {
                   this.db = db;
                   this.postDao = db.posts();
                   this.remoteKeyDao = db.remoteKeys();
                   this.redditApi = redditApi;
                   this.subredditName = subredditName;
                   this.bgExecutor = bgExecutor;
                   ...
                 }
               }

   You can provide the Retrofit interface and the search string as
   demonstrated in the `PagingSource tests <#pagingsource-tests>`__
   section. Providing a mock version of the Room database is very
   involved, so it can be easier to provide an `in-memory implementation <#android>`__ of
   the database instead of a full mock version. Because creating a Room
   database requires a
   `Context <#>`__ object, you must
   place this ``RemoteMediator`` test in the ``androidTest`` directory
   and execute it with the AndroidJUnit4 test runner so that it has
   access to a test application context. For more information about
   instrumented tests, see `Build instrumented unit tests <#>`__.

   Define tear-down functions to ensure that state does not leak between
   test functions. This ensures consistent results between test runs.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               @ExperimentalPagingApi
               @OptIn(ExperimentalCoroutinesApi::class)
               @RunWith(AndroidJUnit4::class)
               class PageKeyedRemoteMediatorTest {
                 private val postFactory = PostFactory()
                 private val mockPosts = listOf(
                   postFactory.createRedditPost(SubRedditViewModel.DEFAULT_SUBREDDIT),
                   postFactory.createRedditPost(SubRedditViewModel.DEFAULT_SUBREDDIT),
                   postFactory.createRedditPost(SubRedditViewModel.DEFAULT_SUBREDDIT)
                 )
                 private val mockApi = mockRedditApi()

                 private val mockDb = RedditDb.create(
                   ApplicationProvider.getApplicationContext(),
                   useInMemory = true
                 )

                 @After
                 fun tearDown() {
                   mockDb.clearAllTables()
                   // Clear out failure message to default to the successful response.
                   mockApi.failureMsg = null
                   // Clear out posts after each test run.
                   mockApi.clearPosts()
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               @RunWith(AndroidJUnit4.class)
               public class PageKeyedRemoteMediatorTest {
                 static PostFactory postFactory = new PostFactory();
                 static List<RedditPost> mockPosts = new ArrayList<>();
                 static MockRedditApi mockApi = new MockRedditApi();
                 private RedditDb mockDb = RedditDb.Companion.create(
                   ApplicationProvider.getApplicationContext(),
                   true
                 );

                 static {
                   for (int i=0; i<3; i++) {
                     RedditPost post = postFactory.createRedditPost(DEFAULT_SUBREDDIT);
                     mockPosts.add(post);
                   }
                 }

                 @After
                 public void tearDown() {
                   mockDb.clearAllTables();
                   // Clear the failure message after each test run.
                   mockApi.setFailureMsg(null);
                   // Clear out posts after each test run.
                   mockApi.clearPosts();
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               @RunWith(AndroidJUnit4.class)
               public class PageKeyedRemoteMediatorTest {
                 static PostFactory postFactory = new PostFactory();
                 static List<RedditPost> mockPosts = new ArrayList<>();
                 static MockRedditApi mockApi = new MockRedditApi();

                 private RedditDb mockDb = RedditDb.Companion.create(
                   ApplicationProvider.getApplicationContext(),
                   true
                 );

                 static {
                   for (int i=0; i<3; i++) {
                     RedditPost post = postFactory.createRedditPost(DEFAULT_SUBREDDIT);
                     mockPosts.add(post);
                   }
                 }

                 @After
                 public void tearDown() {
                   mockDb.clearAllTables();
                   // Clear the failure message after each test run.
                   mockApi.setFailureMsg(null);
                   // Clear out posts after each test run.
                   mockApi.clearPosts();
                 }
               }

   The next step is to test the ``load()`` function. In this example,
   there are three cases to test:

   -  The first case is when ``mockApi`` returns valid data. The
      ``load()`` function should return ``MediatorResult.Success``, and
      the ``endOfPaginationReached`` property should be ``false``.
   -  The second case is when ``mockApi`` returns a successful response,
      but the returned data is empty. The ``load()`` function should
      return ``MediatorResult.Success``, and the
      ``endOfPaginationReached`` property should be ``true``.
   -  The third case is when ``mockApi`` throws an exception when
      fetching the data. The ``load()`` function should return
      ``MediatorResult.Error``.

   Follow these steps to test the first case:

   #. Set up the ``mockApi`` with the post data to return.
   #. Initialize the ``RemoteMediator`` object.
   #. Test the ``load()`` function.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               @Test
               fun refreshLoadReturnsSuccessResultWhenMoreDataIsPresent() = runTest {
                 // Add mock results for the API to return.
                 mockPosts.forEach { post -> mockApi.addPost(post) }
                 val remoteMediator = PageKeyedRemoteMediator(
                   mockDb,
                   mockApi,
                   SubRedditViewModel.DEFAULT_SUBREDDIT
                 )
                 val pagingState = PagingState<Int, RedditPost>(
                   listOf(),
                   null,
                   PagingConfig(10),
                   10
                 )
                 val result = remoteMediator.load(LoadType.REFRESH, pagingState)
                 assertTrue { result is MediatorResult.Success }
                 assertFalse { (result as MediatorResult.Success).endOfPaginationReached }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               @Test
               public void refreshLoadReturnsSuccessResultWhenMoreDataIsPresent()
                 throws InterruptedException {

                 // Add mock results for the API to return.
                 for (RedditPost post: mockPosts) {
                   mockApi.addPost(post);
                 }

                 PageKeyedRemoteMediator remoteMediator = new PageKeyedRemoteMediator(
                   mockDb,
                   mockApi,
                   SubRedditViewModel.DEFAULT_SUBREDDIT
                 );
                 PagingState<Integer, RedditPost> pagingState = new PagingState<>(
                   new ArrayList(),
                   null,
                   new PagingConfig(10),
                   10
                 );
                 remoteMediator.loadSingle(LoadType.REFRESH, pagingState)
                   .test()
                   .await()
                   .assertValueCount(1)
                   .assertValue(value -> value instanceof RemoteMediator.MediatorResult.Success &&
                     ((RemoteMediator.MediatorResult.Success) value).endOfPaginationReached() == false);
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               @Test
               public void refreshLoadReturnsSuccessResultWhenMoreDataIsPresent()
                 throws InterruptedException, ExecutionException {

                 // Add mock results for the API to return.
                 for (RedditPost post: mockPosts) {
                   mockApi.addPost(post);
                 }

                 PageKeyedRemoteMediator remoteMediator = new PageKeyedRemoteMediator(
                   mockDb,
                   mockApi,
                   SubRedditViewModel.DEFAULT_SUBREDDIT,
                   new CurrentThreadExecutor()
                 );
                 PagingState<Integer, RedditPost> pagingState = new PagingState<>(
                   new ArrayList(),
                   null,
                   new PagingConfig(10),
                   10
                 );

                 RemoteMediator.MediatorResult result =
                   remoteMediator.loadFuture(LoadType.REFRESH, pagingState).get();

                 assertThat(result, instanceOf(RemoteMediator.MediatorResult.Success.class));
                 assertFalse(((RemoteMediator.MediatorResult.Success) result).endOfPaginationReached());
               }

   The second test requires the ``mockApi`` to return an empty result.
   Because you clear the data from the ``mockApi`` after each test run,
   it will return an empty result by default.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               @Test
               fun refreshLoadSuccessAndEndOfPaginationWhenNoMoreData() = runTest {
                 // To test endOfPaginationReached, don't set up the mockApi to return post
                 // data here.
                 val remoteMediator = PageKeyedRemoteMediator(
                   mockDb,
                   mockApi,
                   SubRedditViewModel.DEFAULT_SUBREDDIT
                 )
                 val pagingState = PagingState<Int, RedditPost>(
                   listOf(),
                   null,
                   PagingConfig(10),
                   10
                 )
                 val result = remoteMediator.load(LoadType.REFRESH, pagingState)
                 assertTrue { result is MediatorResult.Success }
                 assertTrue { (result as MediatorResult.Success).endOfPaginationReached }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               @Test
               public void refreshLoadSuccessAndEndOfPaginationWhenNoMoreData()
                 throws InterruptedException() {

                 // To test endOfPaginationReached, don't set up the mockApi to return post
                 // data here.
                 PageKeyedRemoteMediator remoteMediator = new PageKeyedRemoteMediator(
                   mockDb,
                   mockApi,
                   SubRedditViewModel.DEFAULT_SUBREDDIT
                 );
                 PagingState<Integer, RedditPost> pagingState = new PagingState<>(
                   new ArrayList(),
                   null,
                   new PagingConfig(10),
                   10
                 );
                 remoteMediator.loadSingle(LoadType.REFRESH, pagingState)
                   .test()
                   .await()
                   .assertValueCount(1)
                   .assertValue(value -> value instanceof RemoteMediator.MediatorResult.Success &&
                     ((RemoteMediator.MediatorResult.Success) value).endOfPaginationReached() == true);
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               @Test
               public void refreshLoadSuccessAndEndOfPaginationWhenNoMoreData()
                 throws InterruptedException, ExecutionException {

                 // To test endOfPaginationReached, don't set up the mockApi to return post
                 // data here.
                 PageKeyedRemoteMediator remoteMediator = new PageKeyedRemoteMediator(
                   mockDb,
                   mockApi,
                   SubRedditViewModel.DEFAULT_SUBREDDIT,
                   new CurrentThreadExecutor()
                 );
                 PagingState<Integer, RedditPost> pagingState = new PagingState<>(
                   new ArrayList(),
                   null,
                   new PagingConfig(10),
                   10
                 );

                 RemoteMediator.MediatorResult result =
                   remoteMediator.loadFuture(LoadType.REFRESH, pagingState).get();

                 assertThat(result, instanceOf(RemoteMediator.MediatorResult.Success.class));
                 assertTrue(((RemoteMediator.MediatorResult.Success) result).endOfPaginationReached());
               }

   The final test requires the ``mockApi`` to throw an exception so that
   the test can verify that the ``load()`` function correctly returns
   ``MediatorResult.Error``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               @Test
               fun refreshLoadReturnsErrorResultWhenErrorOccurs() = runTest {
                 // Set up failure message to throw exception from the mock API.
                 mockApi.failureMsg = "Throw test failure"
                 val remoteMediator = PageKeyedRemoteMediator(
                   mockDb,
                   mockApi,
                   SubRedditViewModel.DEFAULT_SUBREDDIT
                 )
                 val pagingState = PagingState<Int, RedditPost>(
                   listOf(),
                   null,
                   PagingConfig(10),
                   10
                 )
                 val result = remoteMediator.load(LoadType.REFRESH, pagingState)
                 assertTrue {result is MediatorResult.Error }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               @Test
               public void refreshLoadReturnsErrorResultWhenErrorOccurs()
                 throws InterruptedException {

                 // Set up failure message to throw exception from the mock API.
                 mockApi.setFailureMsg("Throw test failure");
                 PageKeyedRemoteMediator remoteMediator = new PageKeyedRemoteMediator(
                   mockDb,
                   mockApi,
                   SubRedditViewModel.DEFAULT_SUBREDDIT
                 );
                 PagingState<Integer, RedditPost> pagingState = new PagingState<>(
                   new ArrayList(),
                   null,
                   new PagingConfig(10),
                   10
                 );
                 remoteMediator.loadSingle(LoadType.REFRESH, pagingState)
                   .test()
                   .await()
                   .assertValueCount(1)
                   .assertValue(value -> value instanceof RemoteMediator.MediatorResult.Error);
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               @Test
               public void refreshLoadReturnsErrorResultWhenErrorOccurs()
                 throws InterruptedException, ExecutionException {

                 // Set up failure message to throw exception from the mock API.
                 mockApi.setFailureMsg("Throw test failure");
                 PageKeyedRemoteMediator remoteMediator = new PageKeyedRemoteMediator(
                   mockDb,
                   mockApi,
                   SubRedditViewModel.DEFAULT_SUBREDDIT,
                   new CurrentThreadExecutor()
                 );
                 PagingState<Integer, RedditPost> pagingState = new PagingState<>(
                   new ArrayList(),
                   null,
                   new PagingConfig(10),
                   10
                 );
                 RemoteMediator.MediatorResult result =
                   remoteMediator.loadFuture(LoadType.REFRESH, pagingState).get();

                 assertThat(result, instanceOf(RemoteMediator.MediatorResult.Error.class));
               }

   .. rubric:: End-to-end tests
      :name: end-to-end

   Unit tests provide assurance that individual Paging components work
   in isolation, but end-to-end tests provide more confidence that the
   application works as a whole. These tests will still need some mock
   dependencies, but generally they will cover most of your app code.

   The example in this section uses a mock API dependency to avoid using
   the network in tests. The mock API is configured to return a
   consistent set of test data, resulting in repeatable tests. Decide
   which dependencies to swap out for mock implementations based on what
   each dependency does, how consistent its output is, and how much
   fidelity you need from your tests.

   Write your code in a way that allows you to easily swap in mock
   versions of your dependencies. The following example uses a basic
   `service locator implementation <#di-alternatives>`__ to
   provide and change dependencies as needed. In larger apps, using a
   dependency injection library like
   `Hilt <#>`__ can help
   manage more-complex dependency graphs.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               class RedditActivityTest {

                 companion object {
                   private const val TEST_SUBREDDIT = "test"
                 }

                 private val postFactory = PostFactory()
                 private val mockApi = MockRedditApi().apply {
                   addPost(postFactory.createRedditPost(DEFAULT_SUBREDDIT))
                   addPost(postFactory.createRedditPost(TEST_SUBREDDIT))
                   addPost(postFactory.createRedditPost(TEST_SUBREDDIT))
                 }

                 @Before
                 fun init() {
                   val app = ApplicationProvider.getApplicationContext<Application>()
                   // Use a controlled service locator with a mock API.
                   ServiceLocator.swap(
                     object : DefaultServiceLocator(app = app, useInMemoryDb = true) {
                       override fun getRedditApi(): RedditApi = mockApi
                     }
                   )
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               public class RedditActivityTest {

                 public static final String TEST_SUBREDDIT = "test";

                 private static PostFactory postFactory = new PostFactory();
                 private static MockRedditApi mockApi = new MockRedditApi();

                 static {
                   mockApi.addPost(postFactory.createRedditPost(DEFAULT_SUBREDDIT));
                   mockApi.addPost(postFactory.createRedditPost(TEST_SUBREDDIT));
                   mockApi.addPost(postFactory.createRedditPost(TEST_SUBREDDIT));
                 }

                 @Before
                 public void setup() {
                   Application app = ApplicationProvider.getApplicationContext();
                   // Use a controlled service locator with a mock API.
                   ServiceLocator.Companion.swap(
                     new DefaultServiceLocator(app, true) {
                       @NotNull
                       @Override
                       public RedditApi getRedditApi() {
                         return mockApi;
                       }
                     }
                   );
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               public class RedditActivityTest {

                 public static final String TEST_SUBREDDIT = "test";

                 private static PostFactory postFactory = new PostFactory();
                 private static MockRedditApi mockApi = new MockRedditApi();

                 static {
                   mockApi.addPost(postFactory.createRedditPost(DEFAULT_SUBREDDIT));
                   mockApi.addPost(postFactory.createRedditPost(TEST_SUBREDDIT));
                   mockApi.addPost(postFactory.createRedditPost(TEST_SUBREDDIT));
                 }

                 @Before
                 public void setup() {
                   Application app = ApplicationProvider.getApplicationContext();
                   // Use a controlled service locator with a mock API.
                   ServiceLocator.Companion.swap(
                     new DefaultServiceLocator(app, true) {
                       @NotNull
                       @Override
                       public RedditApi getRedditApi() {
                         return mockApi;
                       }
                     }
                   );
                 }
               }

   After you set up the test structure, the next step is to verify that
   the data returned by the ``Pager`` implementation is correct. One
   test should ensure that the ``Pager`` object loads the default data
   when the page first loads, and another test should verify that the
   ``Pager`` object correctly loads additional data based on user input.
   In the following example, the test verifies that the ``Pager`` object
   updates the ``RecyclerView.Adapter`` with the correct number of items
   returned from the API when the user enters a different subreddit to
   search.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               @Test
               fun loadsTheDefaultResults() {
                   ActivityScenario.launch(RedditActivity::class.java)

                   onView(withId(R.id.list)).check { view, noViewFoundException ->
                       if (noViewFoundException != null) {
                           throw noViewFoundException
                       }

                       val recyclerView = view as RecyclerView
                       assertEquals(1, recyclerView.adapter?.itemCount)
                   }
               }

               @Test
               // Verify that the default data is swapped out when the user searches for a
               // different subreddit.
               fun loadsTheTestResultsWhenSearchingForSubreddit() {
                 ActivityScenario.launch(RedditActivity::class.java )

                 onView(withId(R.id.list)).check { view, noViewFoundException ->
                   if (noViewFoundException != null) {
                     throw noViewFoundException
                   }

                   val recyclerView = view as RecyclerView
                   // Verify that it loads the default data first.
                   assertEquals(1, recyclerView.adapter?.itemCount)
                 }

                 // Search for test subreddit instead of default to trigger new data load.
                 onView(withId(R.id.input)).perform(
                   replaceText(TEST_SUBREDDIT),
                   pressKey(KeyEvent.KEYCODE_ENTER)
                 )

                 onView(withId(R.id.list)).check { view, noViewFoundException ->
                   if (noViewFoundException != null) {
                     throw noViewFoundException
                   }

                   val recyclerView = view as RecyclerView
                   assertEquals(2, recyclerView.adapter?.itemCount)
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               @Test
               public void loadsTheDefaultResults() {
                 ActivityScenario.launch(RedditActivity.class);

                 onView(withId(R.id.list)).check((view, noViewFoundException) -> {
                   if (noViewFoundException != null) {
                     throw noViewFoundException;
                   }

                   RecyclerView recyclerView = (RecyclerView) view;
                   assertEquals(1, recyclerView.getAdapter().getItemCount());
                 });
               }

               @Test
               // Verify that the default data is swapped out when the user searches for a
               // different subreddit.
               public void loadsTheTestResultsWhenSearchingForSubreddit() {
                 ActivityScenario.launch(RedditActivity.class);

                 onView(withId(R.id.list)).check((view, noViewFoundException) -> {
                   if (noViewFoundException != null) {
                     throw noViewFoundException;
                   }

                   RecyclerView recyclerView = (RecyclerView) view;
                   // Verify that it loads the default data first.
                   assertEquals(1, recyclerView.getAdapter().getItemCount());
                 });

                 // Search for test subreddit instead of default to trigger new data load.
                 onView(withId(R.id.input)).perform(
                   replaceText(TEST_SUBREDDIT),
                   pressKey(KeyEvent.KEYCODE_ENTER)
                 );

                 onView(withId(R.id.list)).check((view, noViewFoundException) -> {
                   if (noViewFoundException != null) {
                     throw noViewFoundException;
                   }

                   RecyclerView recyclerView = (RecyclerView) view;
                   assertEquals(2, recyclerView.getAdapter().getItemCount());
                 });
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               @Test
               public void loadsTheDefaultResults() {
                 ActivityScenario.launch(RedditActivity.class);

                 onView(withId(R.id.list)).check((view, noViewFoundException) -> {
                   if (noViewFoundException != null) {
                     throw noViewFoundException;
                   }

                   RecyclerView recyclerView = (RecyclerView) view;
                   assertEquals(1, recyclerView.getAdapter().getItemCount());
                 });
               }

               @Test
               // Verify that the default data is swapped out when the user searches for a
               // different subreddit.
               public void loadsTheTestResultsWhenSearchingForSubreddit() {
                 ActivityScenario.launch(RedditActivity.class);

                 onView(withId(R.id.list)).check((view, noViewFoundException) -> {
                   if (noViewFoundException != null) {
                     throw noViewFoundException;
                   }

                   RecyclerView recyclerView = (RecyclerView) view;
                   // Verify that it loads the default data first.
                   assertEquals(1, recyclerView.getAdapter().getItemCount());
                 });

                 // Search for test subreddit instead of default to trigger new data load.
                 onView(withId(R.id.input)).perform(
                   replaceText(TEST_SUBREDDIT),
                   pressKey(KeyEvent.KEYCODE_ENTER)
                 );

                 onView(withId(R.id.list)).check((view, noViewFoundException) -> {
                   if (noViewFoundException != null) {
                     throw noViewFoundException;
                   }

                   RecyclerView recyclerView = (RecyclerView) view;
                   assertEquals(2, recyclerView.getAdapter().getItemCount());
                 });
               }

   Instrumented tests should verify that the data displays correctly in
   the UI. Do this either by verifying that the correct number of items
   exists in the ``RecyclerView.Adapter``, or by iterating through the
   individual row views and verifying that the data is formatted
   correctly.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Page from network and database <#>`__
   -  `Migrate to Paging 3 <#>`__
   -  `Load and display paged data <#>`__

Last updated 2023-07-12 UTC.


/Migrate to Paging 3
====================

.. container:: devsite-article-body clearfix

   Paging 3 is significantly different from earlier versions of the
   Paging library. This version provides enhanced functionality and
   addresses common difficulties with using Paging 2. If your app
   already uses an earlier version of the Paging library, read this page
   to learn more about migrating to Paging 3.

   If Paging 3 is the first version of the Paging library that you are
   using in your app, see `Load and display paged data <#>`__ for
   basic usage information.

   .. rubric:: Benefits of migrating to Paging 3
      :name: benefits

   Paging 3 includes the following features that were not present in
   earlier versions of the library:

   -  First-class support for Kotlin coroutines and Flow.
   -  Support for async loading using RxJava ``Single`` or Guava
      ``ListenableFuture`` primitives.
   -  Built-in load state and error signals for responsive UI design,
      including retry and refresh functionality.
   -  Improvements to the repository layer, including cancellation
      support and a simplified data source interface.
   -  Improvements to the presentation layer, list separators, custom
      page transforms, and loading state headers and footers.

   .. rubric:: Migrate your app to Paging 3
      :name: migrate

   To fully migrate to Paging 3, you must migrate all three of the major
   components from Paging 2:

   -  ``DataSource`` classes
   -  ``PagedList``
   -  ``PagedListAdapter``

   However, some Paging 3 components are backwards-compatible with
   previous versions of Paging. In particular, the
   `PagingSource <#>`__
   API from Paging 3 can be a data source for
   `LivePagedListBuilder <#>`__
   and
   `RxPagedListBuilder <#>`__
   from older versions. Similarly, the ``Pager`` API can use older
   `DataSource <#>`__
   objects with the ``asPagingSourceFactory()`` method. This means that
   you have the following migration options:

   -  You can migrate your ``DataSource`` to ``PagingSource`` but leave
      the rest of your Paging implementation unchanged.
   -  You can migrate your ``PagedList`` and ``PagedListAdapter`` but
      still use the older ``DataSource`` API.
   -  You can migrate the entire Paging implementation to fully migrate
      your app to Paging 3.

   The sections on this page explain how to migrate Paging components on
   each layer of your app.

   .. rubric:: DataSource classes
      :name: datasource

   This section describes all of the necessary changes to migrate an
   older Paging implementation to use ``PagingSource``.

   The ``PageKeyedDataSource``, ``PositionalDataSource``, and
   ``ItemKeyedDataSource`` from Paging 2 are all combined into the
   ``PagingSource`` API in Paging 3. The loading methods from all of the
   old API classes are combined into a single ``load()`` method in
   ``PagingSource``. This reduces code duplication because much of the
   logic across the loading methods in implementations of the old API
   classes is often identical.

   All loading method parameters are replaced in Paging 3 with a
   ``LoadParams`` sealed class, which includes subclasses for each load
   type. If you need to differentiate among load types in your
   ``load()`` method, check which subclass of ``LoadParams`` was passed
   in: ``LoadParams.Refresh``, ``LoadParams.Prepend``, or
   ``LoadParams.Append``.

   To learn more about implementing ``PagingSource``, see `Define a data source <#data-source>`__.

   **Note:**\  If your current Paging implementation includes custom
   error handling, consider using the built-in error handling support in
   ``PagingSource`` instead. To learn more, see `Handle errors <#handle-errors>`__.

   .. rubric:: Refresh keys
      :name: refresh-keys

   Implementations of ``PagingSource`` must define how refreshes resume
   from the middle of the loaded paged data. Do this by implementing
   `getRefreshKey() <#getrefreshkey>`__
   to map the correct initial key using ``state.anchorPosition`` as the
   most recently accessed index.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               // Replaces ItemKeyedDataSource.
               override fun getRefreshKey(state: PagingState): String? {
                 return state.anchorPosition?.let { anchorPosition ->
                   state.getClosestItemToPosition(anchorPosition)?.id
                 }
               }

               // Replacing PositionalDataSource.
               override fun getRefreshKey(state: PagingState): Int? {
                 return state.anchorPosition
               }

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               // Replaces ItemKeyedDataSource.
               @Nullable
               @Override
               String getRefreshKey(state: PagingState) {
                 Integer anchorPosition = state.anchorPosition;
                 if (anchorPosition == null) {
                   return null;
                 }

                 return state.getClosestItemToPosition(anchorPosition);
               }

               // Replaces PositionalDataSource.
               @Nullable
               @Override
               Integer getRefreshKey(state: PagingState) {
                 return state.anchorPosition;
               }

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               // Replacing ItemKeyedDataSource.
               @Nullable
               @Override
               String getRefreshKey(state: PagingState) {
                 Integer anchorPosition = state.anchorPosition;
                 if (anchorPosition == null) {
                   return null;
                 }

                 return state.getClosestItemToPosition(anchorPosition);
               }

               // Replacing PositionalDataSource.
               @Nullable
               @Override
               Integer getRefreshKey(state: PagingState) {
                 return state.anchorPosition;
               }

   .. rubric:: List transformations
      :name: list-transform

   In older versions of the Paging library, transformation of the paged
   data relies on the following methods:

   -  ``DataSource.map()``
   -  ``DataSource.mapByPage()``
   -  ``DataSource.Factory.map()``
   -  ``DataSource.Factory.mapByPage()``

   In Paging 3, all transformations are applied as operators on
   ``PagingData``. If you use any of the methods in the preceding list
   to transform your paged list, you must move your transformation logic
   from the ``DataSource`` to the ``PagingData`` when constructing the
   ``Pager`` using your new ``PagingSource``.

   To learn more about applying transformations to paged data using
   Paging 3, see `Transform data streams <#>`__.

   .. rubric:: PagedList
      :name: pagedlist

   This section describes all of the necessary changes to migrate an
   older Paging implementation to use ``Pager`` and ``PagingData`` in
   Paging 3.

   .. rubric:: PagedListBuilder classes
      :name: pagedlistbuilder

   ``PagingData`` replaces the existing ``PagedList`` from Paging 2. To
   migrate to ``PagingData``, you must update the following:

   -  Paging configuration has moved from ``PagedList.Config`` to
      ``PagingConfig``.
   -  ``LivePagedListBuilder`` and ``RxPagedListBuilder`` have been
      combined into a single ``Pager`` class.
   -  ``Pager`` exposes an observable ``Flow<PagingData>`` with its
      ``.flow`` property. RxJava and LiveData variants are also
      available as extension properties, which are callable from Java
      via static methods and are provided from the ``paging-rxjava*``
      and ``paging-runtime`` modules respectively.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               val flow = Pager(
                 // Configure how data is loaded by passing additional properties to
                 // PagingConfig, such as prefetchDistance.
                 PagingConfig(pageSize = 20)
               ) {
                 ExamplePagingSource(backend, query)
               }.flow
                 .cachedIn(viewModelScope)

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               // CoroutineScope helper provided by the lifecycle-viewmodel-ktx artifact.
               CoroutineScope viewModelScope = ViewModelKt.getViewModelScope(viewModel);
               Pager<Integer, User> pager = Pager<>(
                 new PagingConfig(/* pageSize = */ 20),
                 () -> ExamplePagingSource(backend, query));

               Flowable<PagingData<User>> flowable = PagingRx.getFlowable(pager);
               PagingRx.cachedIn(flowable, viewModelScope);

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               // CoroutineScope helper provided by the lifecycle-viewmodel-ktx artifact.
               CoroutineScope viewModelScope = ViewModelKt.getViewModelScope(viewModel);
               Pager<Integer, User> pager = Pager<>(
                 new PagingConfig(/* pageSize = */ 20),
                 () -> ExamplePagingSource(backend, query));

               PagingLiveData.cachedIn(PagingLiveData.getLiveData(pager), viewModelScope);

   To learn more about setting up a reactive stream of ``PagingData``
   objects using Paging 3, see `Set up a stream of PagingData <#pagingdata-stream>`__.

   .. rubric:: BoundaryCallback for layered sources
      :name: boundarycallback

   In Paging 3,
   `RemoteMediator <#>`__
   replaces ``PagedList.BoundaryCallback`` as a handler for paging from
   network and database.

   To learn more about using ``RemoteMediator`` to page from network and
   database in Paging 3, see the `Android Paging codelab <https://developers.google.cn/codelabs/codelabs/android-paging>`__.

   .. rubric:: PagedListAdapter
      :name: pagedlistadapter

   This section describes all of the necessary changes to migrate an
   older Paging implementation to use the ``PagingDataAdapter`` or
   ``AsyncPagingDataDiffer`` classes from Paging 3.

   Paging 3 provides ``PagingDataAdapter`` to handle the new
   ``PagingData`` reactive streams. Otherwise, ``PagedListAdapter`` and
   ``PagingDataAdapter`` have the same interface. To migrate from
   ``PagedListAdapter`` to ``PagingDataAdapter``, change your
   implementation of ``PagedListAdapter`` to extend
   ``PagingDataAdapter`` instead.

   To learn more about ``PagingDataAdapter``, see `Define a RecyclerView adapter <#recyclerview-adapter>`__.

   .. rubric:: AsyncPagedListDiffer
      :name: asyncpagedlistdiffer

   If you currently use a custom ``RecyclerView.Adapter`` implementation
   with ``AsyncPagedListDiffer``, migrate your implementation to use the
   ``AsyncPagingDataDiffer`` provided in Paging 3 instead:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin
               :class: two-line-tab

            .. code:: prettyprint

               AsyncPagingDataDiffer(diffCallback, listUpdateCallback)

         .. container:: section

            .. rubric:: Java
               :name: java
               :class: two-line-tab

            .. code:: prettyprint

               new AsyncPagingDataDiffer(diffCallback, listUpdateCallback);

         .. container:: section

            .. rubric:: Java
               :name: guava-livedata
               :class: two-line-tab

            .. code:: prettyprint

               new AsyncPagingDataDiffer(diffCallback, listUpdateCallback);

   .. rubric:: Additional resources
      :name: additional-resources

   To learn more about the Paging library, see the following additional
   resources:

   .. rubric:: Codelabs
      :name: codelabs

   -  `Android Paging codelab <https://developers.google.cn/codelabs/codelabs/android-paging>`__

   .. rubric:: Samples
      :name: samples

   -  `Android Architecture Components Paging sample <https://github.com/android/architecture-components-samples/tree/main/PagingSample>`__
   -  `Android Architecture Components Paging with Database and Network sample <https://github.com/android/architecture-components-samples/tree/main/PagingWithNetworkSample>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Load and display paged data <#>`__
   -  `Gather paged data <#>`__
   -  `Page from network and database <#>`__

Last updated 2023-07-12 UTC.



.. _datastore:

/DataStore - Part of Android Jetpack
====================================

.. https://developer.android.google.cn/topic/libraries/architecture/datastore

.. container::

   Jetpack DataStore is a data storage solution that allows you to store
   key-value pairs or typed objects with `protocol buffers <https://developers.google.cn/protocol-buffers>`__. DataStore
   uses Kotlin coroutines and Flow to store data asynchronously,
   consistently, and transactionally.

   If you're currently using `SharedPreferences <#>`__ 
   to store data, consider migrating to DataStore instead.

   **Note:**\  If you need to support large or complex datasets, partial
   updates, or referential integrity, consider using
   `Room <#>`__ instead of DataStore. DataStore
   is ideal for small, simple datasets and does not support partial updates
   or referential integrity.

   .. _prefs-vs-proto:

   Preferences DataStore and Proto DataStore
   -----------------------------------------

   DataStore provides two different implementations: Preferences DataStore
   and Proto DataStore.

   -  **Preferences DataStore** stores and accesses data using keys. This
      implementation does not require a predefined schema, and it does not
      provide type safety.
   -  **Proto DataStore** stores data as instances of a custom data type.
      This implementation requires you to define a schema using `protocol buffers <https://developers.google.cn/protocol-buffers>`__, but it
      provides type safety.

   .. _correct_usage:

   Using DataStore correctly
   -------------------------

   In order to use DataStore correctly always keep in mind the following
   rules:

   #. **Never create more than one instance of ``DataStore`` for a given
      file in the same process.** Doing so can break all DataStore
      functionality. If there are multiple DataStores active for a given
      file in the same process, DataStore will throw
      ``IllegalStateException`` when reading or updating data.

   #. **The generic type of the DataStore must be immutable.** Mutating a
      type used in DataStore invalidates any guarantees that DataStore
      provides and creates potentially serious, hard-to-catch bugs. It is
      strongly recommended that you use protocol buffers which provide
      immutability guarantees, a simple API and efficient serialization.

   #. **Never mix usages of ``SingleProcessDataStore`` and
      ``MultiProcessDataStore``** for the same file. If you intend to
      access the ``DataStore`` from more than one process always use
      `MultiProcessDataStore <#multiprocess>`__.

   Setup
   -----

   To use Jetpack DataStore in your app, add the following to your Gradle
   file depending on which implementation you want to use:

   .. _preferences-datastore-dependencies:

   Preferences DataStore
   ~~~~~~~~~~~~~~~~~~~~~

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

                   // Preferences DataStore (SharedPreferences like APIs)
                   dependencies {
                       implementation "androidx.datastore:datastore-preferences:1.1.1"

                       // optional - RxJava2 support
                       implementation "androidx.datastore:datastore-preferences-rxjava2:1.1.1"

                       // optional - RxJava3 support
                       implementation "androidx.datastore:datastore-preferences-rxjava3:1.1.1"
                   }

                   // Alternatively - use the following artifact without an Android dependency.
                   dependencies {
                       implementation "androidx.datastore:datastore-preferences-core:1.1.1"
                   }
                   

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

                   // Preferences DataStore (SharedPreferences like APIs)
                   dependencies {
                       implementation("androidx.datastore:datastore-preferences:1.1.1")

                       // optional - RxJava2 support
                       implementation("androidx.datastore:datastore-preferences-rxjava2:1.1.1")

                       // optional - RxJava3 support
                       implementation("androidx.datastore:datastore-preferences-rxjava3:1.1.1")
                   }

                   // Alternatively - use the following artifact without an Android dependency.
                   dependencies {
                       implementation("androidx.datastore:datastore-preferences-core:1.1.1")
                   }
                   

   .. _proto-datastore-dependencies:

   Proto DataStore
   ~~~~~~~~~~~~~~~

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

                   // Typed DataStore (Typed API surface, such as Proto)
                   dependencies {
                       implementation "androidx.datastore:datastore:1.1.1"

                       // optional - RxJava2 support
                       implementation "androidx.datastore:datastore-rxjava2:1.1.1"

                       // optional - RxJava3 support
                       implementation "androidx.datastore:datastore-rxjava3:1.1.1"
                   }

                   // Alternatively - use the following artifact without an Android dependency.
                   dependencies {
                       implementation "androidx.datastore:datastore-core:1.1.1"
                   }
                   

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

                   // Typed DataStore (Typed API surface, such as Proto)
                   dependencies {
                       implementation("androidx.datastore:datastore:1.1.1")

                       // optional - RxJava2 support
                       implementation("androidx.datastore:datastore-rxjava2:1.1.1")

                       // optional - RxJava3 support
                       implementation("androidx.datastore:datastore-rxjava3:1.1.1")
                   }

                   // Alternatively - use the following artifact without an Android dependency.
                   dependencies {
                       implementation("androidx.datastore:datastore-core:1.1.1")
                   }
                   

   **Note:**\  If you use the ``datastore-preferences-core`` artifact with
   Proguard, you must manually add Proguard rules to your
   ``proguard-rules.pro`` file to keep your fields from being deleted. You
   can find the necessary rules
   `here <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:datastore/datastore-preferences/proguard-rules.pro>`__.

   .. _preferences-datastore:

   Store key-value pairs with Preferences DataStore
   ------------------------------------------------

   The Preferences DataStore implementation uses the `DataStore <#>`__
   and `Preferences <#>`__
   classes to persist simple key-value pairs to disk.

   .. _preferences-create:

   Create a Preferences DataStore
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Use the property delegate created by `preferencesDataStore <#dataStore>`__
   to create an instance of ``Datastore<Preferences>``. Call it once at the
   top level of your kotlin file, and access it through this property
   throughout the rest of your application. This makes it easier to keep
   your ``DataStore`` as a singleton. Alternatively, use
   `RxPreferenceDataStoreBuilder <#>`__
   if you're using RxJava. The mandatory ``name`` parameter is the name of
   the Preferences DataStore.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // At the top level of your kotlin file:
               val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "settings")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               RxDataStore<Preferences> dataStore =
                 new RxPreferenceDataStoreBuilder(context, /*name=*/ "settings").build();

   .. _preferences-read:

   Read from a Preferences DataStore
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Because Preferences DataStore does not use a predefined schema, you must
   use the corresponding key type function to define a key for each value
   that you need to store in the ``DataStore<Preferences>`` instance. For
   example, to define a key for an int value, use
   `intPreferencesKey() <#intPreferencesKey>`__.
   Then, use the
   `DataStore.data <#data>`__
   property to expose the appropriate stored value using a ``Flow``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val EXAMPLE_COUNTER = intPreferencesKey("example_counter")
               val exampleCounterFlow: Flow<Int> = context.dataStore.data
                 .map { preferences ->
                   // No type safety.
                   preferences[EXAMPLE_COUNTER] ?: 0
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Preferences.Key<Integer> EXAMPLE_COUNTER = PreferencesKeys.int("example_counter");

               Flowable<Integer> exampleCounterFlow =
                 dataStore.data().map(prefs -> prefs.get(EXAMPLE_COUNTER));

   .. _preferences-write:

   Write to a Preferences DataStore
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Preferences DataStore provides an `edit() <#edit>`__ 
   function that transactionally updates the data in a ``DataStore``. The
   function's ``transform`` parameter accepts a block of code where you can
   update the values as needed. All of the code in the transform block is
   treated as a single transaction.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               suspend fun incrementCounter() {
                 context.dataStore.edit { settings ->
                   val currentCounterValue = settings[EXAMPLE_COUNTER] ?: 0
                   settings[EXAMPLE_COUNTER] = currentCounterValue + 1
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Single<Preferences> updateResult =  dataStore.updateDataAsync(prefsIn -> {
                 MutablePreferences mutablePreferences = prefsIn.toMutablePreferences();
                 Integer currentInt = prefsIn.get(INTEGER_KEY);
                 mutablePreferences.set(INTEGER_KEY, currentInt != null ? currentInt + 1 : 1);
                 return Single.just(mutablePreferences);
               });
               // The update is completed once updateResult is completed.

   .. _proto-datastore:

   Store typed objects with Proto DataStore
   ----------------------------------------

   The Proto DataStore implementation uses DataStore and `protocol buffers <https://developers.google.cn/protocol-buffers>`__ to persist
   typed objects to disk.

   .. _proto-schema:

   Define a schema
   ~~~~~~~~~~~~~~~

   Proto DataStore requires a predefined schema in a proto file in the
   ``app/src/main/proto/`` directory. This schema defines the type for the
   objects that you persist in your Proto DataStore. To learn more about
   defining a proto schema, see the `protobuf language guide <https://developers.google.cn/protocol-buffers/docs/proto3>`__.

   .. code:: devsite-click-to-copy

      syntax = "proto3";

      option java_package = "com.example.application";
      option java_multiple_files = true;

      message Settings {
        int32 example_counter = 1;
      }

   **Note:**\  The class for your stored objects is generated at compile
   time from the ``message`` defined in the proto file. Make sure you
   rebuild your project.

   .. _proto-create:

   Create a Proto DataStore
   ~~~~~~~~~~~~~~~~~~~~~~~~

   There are two steps involved in creating a Proto DataStore to store your
   typed objects:

   #. Define a class that implements ``Serializer<T>``, where ``T`` is the
      type defined in the proto file. This serializer class tells DataStore
      how to read and write your data type. Make sure you include a default
      value for the serializer to be used if there is no file created yet.
   #. Use the property delegate created by ``dataStore`` to create an
      instance of ``DataStore<T>``, where ``T`` is the type defined in the
      proto file. Call this once at the top level of your kotlin file and
      access it through this property delegate throughout the rest of your
      app. The ``filename`` parameter tells DataStore which file to use to
      store the data, and the ``serializer`` parameter tells DataStore the
      name of the serializer class defined in step 1.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               object SettingsSerializer : Serializer<Settings> {
                 override val defaultValue: Settings = Settings.getDefaultInstance()

                 override suspend fun readFrom(input: InputStream): Settings {
                   try {
                     return Settings.parseFrom(input)
                   } catch (exception: InvalidProtocolBufferException) {
                     throw CorruptionException("Cannot read proto.", exception)
                   }
                 }

                 override suspend fun writeTo(
                   t: Settings,
                   output: OutputStream) = t.writeTo(output)
               }

               val Context.settingsDataStore: DataStore<Settings> by dataStore(
                 fileName = "settings.pb",
                 serializer = SettingsSerializer
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private static class SettingsSerializer implements Serializer<Settings> {
                 @Override
                 public Settings getDefaultValue() {
                   Settings.getDefaultInstance();
                 }

                 @Override
                 public Settings readFrom(@NotNull InputStream input) {
                   try {
                     return Settings.parseFrom(input);
                   } catch (exception: InvalidProtocolBufferException) {
                     throw CorruptionException(‚ÄúCannot read proto.‚Äù, exception);
                   }
                 }

                 @Override
                 public void writeTo(Settings t, @NotNull OutputStream output) {
                   t.writeTo(output);
                 }
               }

               RxDataStore<Byte> dataStore =
                   new RxDataStoreBuilder<Byte>(context, /* fileName= */ "settings.pb", new SettingsSerializer()).build();

   .. _proto-read:

   Read from a Proto DataStore
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Use ``DataStore.data`` to expose a ``Flow`` of the appropriate property
   from your stored object.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val exampleCounterFlow: Flow<Int> = context.settingsDataStore.data
                 .map { settings ->
                   // The exampleCounter property is generated from the proto schema.
                   settings.exampleCounter
                 }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Flowable<Integer> exampleCounterFlow =
                 dataStore.data().map(settings -> settings.getExampleCounter());

   .. _proto-write:

   Write to a Proto DataStore
   ~~~~~~~~~~~~~~~~~~~~~~~~~~

   Proto DataStore provides an `updateData() <#updatedata>`__
   function that transactionally updates a stored object. ``updateData()``
   gives you the current state of the data as an instance of your data type
   and updates the data transactionally in an atomic read-write-modify
   operation.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               suspend fun incrementCounter() {
                 context.settingsDataStore.updateData { currentSettings ->
                   currentSettings.toBuilder()
                     .setExampleCounter(currentSettings.exampleCounter + 1)
                     .build()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Single<Settings> updateResult =
                 dataStore.updateDataAsync(currentSettings ->
                   Single.just(
                     currentSettings.toBuilder()
                       .setExampleCounter(currentSettings.getExampleCounter() + 1)
                       .build()));

   .. _synchronous:

   Use DataStore in synchronous code
   ---------------------------------

   **Caution:**\  Avoid blocking threads on DataStore data reads whenever
   possible. Blocking the UI thread can cause
   `ANRs <#>`__ or UI jank, and blocking other
   threads can result in
   `deadlock <https://en.wikipedia.org/wiki/Deadlock>`__.

   One of the primary benefits of DataStore is the asynchronous API, but it
   may not always be feasible to change your surrounding code to be
   asynchronous. This might be the case if you're working with an existing
   codebase that uses synchronous disk I/O or if you have a dependency that
   doesn't provide an asynchronous API.

   Kotlin coroutines provide the `runBlocking() <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html>`__
   coroutine builder to help bridge the gap between synchronous and
   asynchronous code. You can use ``runBlocking()`` to read data from
   DataStore synchronously. RxJava offers blocking methods on ``Flowable``.
   The following code blocks the calling thread until DataStore returns
   data:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val exampleData = runBlocking { context.dataStore.data.first() }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Settings settings = dataStore.data().blockingFirst();

   Performing synchronous I/O operations on the UI thread can cause ANRs or
   UI jank. You can mitigate these issues by asynchronously preloading the
   data from DataStore:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   lifecycleScope.launch {
                       context.dataStore.data.first()
                       // You should also handle IOExceptions here.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               dataStore.data().first().subscribe();

   This way, DataStore asynchronously reads the data and caches it in
   memory. Later synchronous reads using ``runBlocking()`` may be faster or
   may avoid a disk I/O operation altogether if the initial read has
   completed.

   .. _multiprocess:

   Use DataStore in multi-process code
   -----------------------------------

   **Note:**\  DataStore multi-process is currently available in the 1.1.0
   release

   You can configure DataStore to access the same data across different
   processes with the same data consistency guarantees as from within a
   single process. In particular, DataStore guarantees:

   -  Reads only return the data that has been persisted to disk.
   -  Read-after-write consistency.
   -  Writes are serialized.
   -  Reads are never blocked by writes.

   Consider a sample application with a service and an activity:

   The service is running in a separate process and periodically updates
   the DataStore

   .. code:: prettyprint

      <service
        android:name=".MyService"
        android:process=":my_process_id" />

   **Important:**\  To run the
   `service <#>`__ in a different
   process, use the android:process attribute. Note that the process id is
   prefixed with a colon (':'). This makes the service run in a new
   process, private to the application.

   .. code:: prettyprint

      override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
            scope.launch {
                while(isActive) {
                    dataStore.updateData {
                        Settings(lastUpdate = System.currentTimeMillis())
                    }
                    delay(1000)
                }
            }
      }

   While the app would collect those changes and update its UI

   .. code:: prettyprint

      val settings: Settings by dataStore.data.collectAsState()
      Text(
        text = "Last updated: $${settings.timestamp}",

   To be able to use DataStore across different processes, you need to construct 
   the DataStore object using the MultiProcessDataStoreFactory.

   .. code:: prettyprint

      val dataStore: DataStore<Settings> = MultiProcessDataStoreFactory.create(
         serializer = SettingsSerializer(),
         produceFile = {
             File("${context.cacheDir.path}/myapp.preferences_pb")
         }
      )

   serializer tells DataStore how to read and write your data type. Make sure you 
   include a default value for the serializer to be used if there is no file created yet. 
   Below is an example implementation using kotlinx.serialization:

   .. code:: prettyprint

      @Serializable
      data class Settings(
         val lastUpdate: Long
      )

      @Singleton
      class SettingsSerializer @Inject constructor() : Serializer<Settings> {

         override val defaultValue = Settings(lastUpdate = 0)

         override suspend fun readFrom(input: InputStream): Timer =
             try {
                 Json.decodeFromString(
                     Settings.serializer(), input.readBytes().decodeToString()
                 )
             } catch (serialization: SerializationException) {
                 throw CorruptionException("Unable to read Settings", serialization)
             }

         override suspend fun writeTo(t: Settings, output: OutputStream) {
             output.write(
                 Json.encodeToString(Settings.serializer(), t)
                     .encodeToByteArray()
             )
         }
      }


   You can use Hilt dependency injection to make sure that your DataStore instance is unique per process:

   .. code:: prettyprint

      @Provides
      @Singleton
      fun provideDataStore(@ApplicationContext context: Context): DataStore<Settings> =
         MultiProcessDataStoreFactory.create(...)



.. _schedule_tasks_with_workmanager:

/Overview: Schedule tasks with WorkManager - Part of Android Jetpack
====================================================================

.. https://developer.android.google.cn/topic/libraries/architecture/workmanager

.. container::

   `WorkManager <#>`__ is the
   recommended solution for persistent work. Work is persistent when it
   remains scheduled through app restarts and system reboots. Because most
   background processing is best accomplished through persistent work,
   WorkManager is the primary recommended API for background processing.

   .. _types:

   Types of persistent work
   ------------------------

   WorkManager handles three types of persistent work:

   -  **Immediate**: Tasks that must begin immediately and complete soon.
      May be expedited.
   -  **Long Running**: Tasks which might run for longer, potentially
      longer than 10 minutes.
   -  **Deferrable**: Scheduled tasks that start at a later time and can
      run periodically.

   Figure 1 outlines how the different types of persistent work relate to
   one another.

   .. figure:: /static/images/guide/background/workmanager_main.svg
      name: overview
      :alt: Persistent work may be immediate, long running, or deferrable
      :width: 100.0%

      **Figure 1**: Types of persistent work.

   Similarly, the following table outlines the various types of work.

      =============  ====================  =====================
      **Type**       **Periodicity**       **How to access**
      =============  ====================  =====================
      Immediate      One time              ``OneTimeWorkRequest`` and ``Worker``.
                                           For expedited work, call ``setExpedited()`` 
                                           on your OneTimeWorkRequest.

      Long Running   One time or periodic  Any ``WorkRequest`` or ``Worker``. 
                                           Call ``setForeground()`` in the
                                           Worker to handle the notification.

      Deferrable     One time or periodic  ``PeriodicWorkRequest`` and ``Worker``.
      =============  ====================  =====================

   For more information regarding how to set up WorkManager, see the
   `Defining your WorkRequests <#work-constraints>`__
   guide.

   Features
   --------

   In addition to providing a simpler and more consistent API, WorkManager
   has a number of other key benefits:

   .. _constraints:

   Work constraints
   ~~~~~~~~~~~~~~~~

   Declaratively define the optimal conditions for your work to run using
   `work constraints <#work-constraints>`__.
   For example, run only when the device is on an unmetered network, when
   the device is idle, or when it has sufficient battery.

   .. _robust:

   Robust scheduling
   ~~~~~~~~~~~~~~~~~

   WorkManager allows you to `schedule work <#>`__ to run `one-time <#>`__ or
   `repeatedly <#>`__ using
   flexible scheduling windows. Work can be tagged and named as well,
   allowing you to schedule unique, replaceable work and monitor or cancel
   groups of work together.

   Scheduled work is stored in an internally managed SQLite database and
   WorkManager takes care of ensuring that this work persists and is
   rescheduled across device reboots.

   In addition, WorkManager adheres to power-saving features and best
   practices like `Doze mode <#>`__, so you don't
   have to worry about it.

   .. _expedited:

   Expedited work
   ~~~~~~~~~~~~~~

   You can use WorkManager to schedule immediate work for execution in the
   background. You should use `Expedited work <#expedited>`__
   for tasks that are important to the user and which complete within a few
   minutes.

   .. _flexible:

   Flexible retry policy
   ~~~~~~~~~~~~~~~~~~~~~

   Sometimes work fails. WorkManager offers `flexible retry policies <#retries_backoff>`__,
   including a configurable `exponential backoff policy <#>`__.

   .. _work:

   Work chaining
   ~~~~~~~~~~~~~

   For complex related work, `chain individual work tasks together <#>`__
   using an intuitive interface that allows you to control which pieces run
   sequentially and which run in parallel.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               val continuation = WorkManager.getInstance(context)
                   .beginUniqueWork(
                       Constants.IMAGE_MANIPULATION_WORK_NAME,
                       ExistingWorkPolicy.REPLACE,
                       OneTimeWorkRequest.from(CleanupWorker::class.java)
                   ).then(OneTimeWorkRequest.from(WaterColorFilterWorker::class.java))
                   .then(OneTimeWorkRequest.from(GrayScaleFilterWorker::class.java))
                   .then(OneTimeWorkRequest.from(BlurEffectFilterWorker::class.java))
                   .then(
                       if (save) {
                           workRequest<SaveImageToGalleryWorker>(tag = Constants.TAG_OUTPUT)
                       } else /* upload */ {
                           workRequest<UploadWorker>(tag = Constants.TAG_OUTPUT)
                       }
                   )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               WorkManager.getInstance(...)
               .beginWith(Arrays.asList(workA, workB))
               .then(workC)
               .enqueue();

   For each work task, you can `define input and output data <#input_output>`__
   for that work. When chaining work together, WorkManager automatically
   passes output data from one work task to the next.

   .. _interop:

   Built-In threading interoperability
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   WorkManager `integrates seamlessly <#>`__ with `Coroutines <#>`__ and `RxJava <#>`__
   and provides the flexibility to `plug in your own asynchronous APIs <#>`__.

   **Note:**\  While Coroutines and WorkManager are recommended for
   different use cases, they are not mutually exclusive. You may use
   coroutines within work scheduled through WorkManager.

   .. _reliable:

   Use WorkManager for reliable work
   ---------------------------------

   WorkManager is intended for work that is required to **run reliably**
   even if the user navigates off a screen, the app exits, or the device
   restarts. For example:

   -  Sending logs or analytics to backend services.
   -  Periodically syncing application data with a server.

   WorkManager is not intended for in-process background work that can
   safely be terminated if the app process goes away. It is also not a
   general solution for all work that requires immediate execution. Please
   review the `background processing guide <#>`__ to see
   which solution meets your needs.

   .. _other-APIs:

   Relationship to other APIs
   --------------------------

   While coroutines are the recommended solution for certain use cases, you
   should not use them for persistent work. It is important to note that
   coroutines is a concurrency framework, whereas WorkManager is a library
   for persistent work. Likewise, you should use AlarmManager for clocks or
   calendars only.

   .. list-table::
      :header-rows: 1

      - 

         - **API**
         - **Recommended for**
         - **Relationship to WorkManager**
      - 

         - **Coroutines**
         - All asynchronous work that doesn't need to be persistent.
         - Coroutines are the standard means of leaving the main thread in
            Kotlin. However, they leave memory once the app closes. For
            persistent work, use WorkManager.
      - 

         - **AlarmManager**
         - Alarms only.
         - Unlike WorkManager, AlarmManager wakes a device from Doze mode.
            It is therefore not efficient in terms of power and resource
            management. Only use it for precise alarms or notifications
            such as calendar events ‚Äî not background work.

   .. _past-APIs:

   Replacing deprecated APIs
   -------------------------

   The WorkManager API is the recommended replacement for all previous
   Android background scheduling APIs, including
   `FirebaseJobDispatcher <#>`__, `GcmNetworkManager <#>`__,
   and `Job Scheduler <#>`__.

   **Note:**\  If your app targets Android 10 (API level 29) or above,
   ``yourFirebaseJobDispatcher`` and ``GcmNetworkManager`` API calls will
   no longer work on devices running Android Marshmallow (6.0) and above.
   Follow the migration guides for `FirebaseJobDispatcher <#>`__
   and `GcmNetworkManager <#>`__
   for guidance on migrating. Also, see the `Unifying Background Task Scheduling on Android <#>`__
   announcement for more information regarding their deprecation.

   Getting started
   ---------------

   Check out the `Getting started guide <#>`__ to start using WorkManager in your app.

   .. _addl-resources:

   **Additional resources**


   For further information about ``WorkManager``, consult the following
   resources.

   **Samples**


   .. _resources-videos:

   **Videos**


   -  `Workmanager - MAD Skills <https://www.youtube.com/playlist?list=PLWz5rJ2EKKc_J88-h0PhCO_aV0HIAs9Qk>`__,
      video series
   -  `Working with WorkManager <https://www.youtube.com/watch?v=83a4rYXsDs0>`__, from
      the 2018 Android Dev Summit
   -  `WorkManager: Beyond the basics <https://www.youtube.com/watch?v=Bz0z694SrEE>`__, from the
      2019 Android Dev Summit

   .. _resources-blogs:

   **Blogs**


   -  `Introducing WorkManager <https://medium.com/androiddevelopers/introducing-workmanager-2083bcfc4712>`__

   .. _recommended_for_you:

   **Recommended for you**


   -  Note: link text is displayed when JavaScript is off
   -  `App Startup <#>`__

   Last updated 2024-01-03 UTC.



.. _persistent_work:

/Overview: Persistent work - Part of Android Jetpack
====================================================

.. https://developer.android.google.cn/develop/background-work/background-tasks/persistent

.. container::

   Work is persistent when it remains scheduled through app restarts and
   system reboots. `WorkManager <#>`__
   is the recommended solution for persistent work. Because most background
   processing is best accomplished through persistent work, WorkManager is
   therefore also the primary recommended API for background processing in
   general.

   .. _types:

   Types of persistent work
   ------------------------

   WorkManager handles three types of persistent work: 

   -  **Immediate**: Tasks that must begin immediately and complete soon.
      May be expedited.
   -  **Long Running**: Tasks which might run for longer, potentially
      longer than 10 minutes.
   -  **Deferrable**: Scheduled tasks that start at a later time and can
      run periodically.

   Figure 1 outlines how the different types of persistent work relate to
   one another.

   .. figure:: https://developer.android.google.cn/static/images/guide/background/workmanager_main.svg
      name: overview
      :alt: Persistent work may be immediate, long running, or deferrable
      :width: 100.0%

      **Figure 1**: Types of persistent work.

   Similarly, the following table outlines the various types of work.

   .. list-table::
      :header-rows: 1

      - 

         - Type
         - Periodicity
         - How to access
      - 

         - Immediate
         - One time
         - ``OneTimeWorkRequest`` and ``Worker``. For expedited work, call
            ``setExpedited()`` on your OneTimeWorkRequest.
      - 

         - Long Running
         - One time or periodic
         - Any ``WorkRequest`` or ``Worker``. Call ``setForeground()`` in
            the Worker to handle the notification.
      - 

         - Deferrable
         - One time or periodic
         - ``PeriodicWorkRequest`` and ``Worker``.

   For more information regarding how to set up WorkManager, see the
   `Defining your WorkRequests <#work-constraints>`__
   guide.

   WorkManager Features
   --------------------

   In addition to providing a simpler and more consistent API, WorkManager
   has a number of other key benefits:

   .. _constraints:

   Work constraints
   ~~~~~~~~~~~~~~~~

   Declaratively define the optimal conditions for your work to run using
   `work constraints <#work-constraints>`__.
   For example, run only when the device is on an unmetered network, when
   the device is idle, or when it has sufficient battery.

   .. _robust:

   Robust scheduling
   ~~~~~~~~~~~~~~~~~

   WorkManager allows you to `schedule work <#>`__ to run `one-time <#>`__ 
   or `repeatedly <#>`__ using
   flexible scheduling windows. Work can be tagged and named as well,
   allowing you to schedule unique, replaceable work and monitor or cancel
   groups of work together.

   Scheduled work is stored in an internally managed SQLite database and
   WorkManager takes care of ensuring that this work persists and is
   rescheduled across device reboots.

   In addition, WorkManager adheres to power-saving features and best
   practices like `Doze mode <#>`__, so you don't
   have to worry about it.

   .. _expedited:

   Expedited work
   ~~~~~~~~~~~~~~

   You can use WorkManager to schedule immediate work for execution in the
   background. You should use `Expedited work <#expedited>`__
   for tasks that are important to the user and which complete within a few
   minutes.

   .. _flexible:

   Flexible retry policy
   ~~~~~~~~~~~~~~~~~~~~~

   Sometimes work fails. WorkManager offers `flexible retry policies <#retries_backoff>`__,
   including a configurable `exponential backoff policy <#>`__.

   .. _work:

   Work chaining
   ~~~~~~~~~~~~~

   For complex related work, `chain individual work tasks together <#>`__
   using an intuitive interface that allows you to control which pieces run
   sequentially and which run in parallel.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               val continuation = WorkManager.getInstance(context)
                   .beginUniqueWork(
                       Constants.IMAGE_MANIPULATION_WORK_NAME,
                       ExistingWorkPolicy.REPLACE,
                       OneTimeWorkRequest.from(CleanupWorker::class.java)
                   ).then(OneTimeWorkRequest.from(WaterColorFilterWorker::class.java))
                   .then(OneTimeWorkRequest.from(GrayScaleFilterWorker::class.java))
                   .then(OneTimeWorkRequest.from(BlurEffectFilterWorker::class.java))
                   .then(
                       if (save) {
                           workRequest<SaveImageToGalleryWorker>(tag = Constants.TAG_OUTPUT)
                       } else /* upload */ {
                           workRequest<UploadWorker>(tag = Constants.TAG_OUTPUT)
                       }
                   )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               WorkManager.getInstance(...)
               .beginWith(Arrays.asList(workA, workB))
               .then(workC)
               .enqueue();

   For each work task, you can `define input and output data <#input_output>`__
   for that work. When chaining work together, WorkManager automatically
   passes output data from one work task to the next.

   .. _interop:

   Built-In threading interoperability
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   WorkManager `integrates seamlessly <#>`__ with `Coroutines <#>`__ and `RxJava <#>`__
   and provides the flexibility to `plug in your own asynchronous APIs <#>`__.

   **Note:**\  While Coroutines and WorkManager are recommended for
   different use cases, they are not mutually exclusive. You may use
   coroutines within work scheduled through WorkManager.

   .. _reliable:

   Use WorkManager for reliable work
   ---------------------------------

   WorkManager is intended for work that is required to **run reliably**
   even if the user navigates off a screen, the app exits, or the device
   restarts. For example:

   -  Sending logs or analytics to backend services.
   -  Periodically syncing application data with a server.

   WorkManager is not intended for in-process background work that can
   safely be terminated if the app process goes away. It is also not a
   general solution for all work that requires immediate execution. Please
   review the `background processing guide <#>`__ to see
   which solution meets your needs.

   .. _other-APIs:

   Relationship to other APIs
   --------------------------

   While coroutines are the recommended solution for certain use cases, you
   shouldn't use them for persistent work. It is important to note that
   coroutines is a concurrency framework, whereas WorkManager is a library
   for persistent work. Likewise, you should use AlarmManager for clocks or
   calendars only.

   .. list-table::
      :header-rows: 1

      - 

         - API
         - Recommended for
         - Relationship to WorkManager
      - 

         - **Coroutines**
         - All asynchronous work that doesn't need to be persistent.
         - Coroutines are the standard means of leaving the main thread in
            Kotlin. However, they leave memory once the app closes. For
            persistent work, use WorkManager.
      - 

         - **AlarmManager**
         - Alarms only.
         - Unlike WorkManager, AlarmManager wakes a device from Doze mode.
            It is therefore not efficient in terms of power and resource
            management. Only use it for precise alarms or notifications
            such as calendar events ‚Äî not background work.

   .. _past-APIs:

   Replace deprecated APIs
   -----------------------

   The WorkManager API is the recommended replacement for all previous
   Android background scheduling APIs, including
   `FirebaseJobDispatcher <#>`__,
   `GcmNetworkManager <#>`__,
   and `JobScheduler <#>`__.

   **Note:**\  ``yourFirebaseJobDispatcher`` and ``GcmNetworkManager`` API
   calls no longer work on devices running Android Marshmallow (6.0) and
   above. Follow the migration guides for
   `FirebaseJobDispatcher <#>`__
   and
   `GcmNetworkManager <#>`__
   for guidance on migrating. Also, see the `Unifying Background Task Scheduling on Android <#>`__
   announcement for more information regarding their deprecation.

   Get started
   -----------

   Check out the `Getting started guide <#>`__ to start using WorkManager in your app.

   .. _addl-resources:

   Additional resources
   ~~~~~~~~~~~~~~~~~~~~

   The following sections provide some additional resources.

   .. _resources-videos:

   Videos
   ^^^^^^

   -  `Workmanager - MAD Skills <https://www.youtube.com/playlist?list=PLWz5rJ2EKKc_J88-h0PhCO_aV0HIAs9Qk>`__,
      video series
   -  `Working with WorkManager <https://www.youtube.com/watch?v=83a4rYXsDs0>`__, from
      the 2018 Android Dev Summit
   -  `WorkManager: Beyond the basics <https://www.youtube.com/watch?v=Bz0z694SrEE>`__, from the
      2019 Android Dev Summit

   .. _resources-blogs:

   Blogs
   ^^^^^

   -  `Introducing WorkManager <https://medium.com/androiddevelopers/introducing-workmanager-2083bcfc4712>`__

   Samples
   ^^^^^^^

   Last updated 2024-01-24 UTC.


   Define work requests
   ====================

   .. container:: devsite-article-body clearfix

      The `getting started guide <#>`__ covered
      how to create a simple
      `WorkRequest <#>`__ and
      enqueue it.

      In this guide you will learn how to define and customize
      ``WorkRequest`` objects to handle common use cases, such as how to:

      -  Schedule one-time and recurring work
      -  Set work constraints like requiring Wi-Fi or charging
      -  Guarantee a minimum delay in work execution
      -  Set retry and back-off strategies
      -  Pass input data to work
      -  Group related work together using tags

      .. rubric:: Overview
         :name: Overview

      Work is defined in WorkManager via a
      `WorkRequest <#>`__. In order
      to schedule any work with WorkManager you must first create a
      ``WorkRequest`` object and then enqueue it.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint


                  val myWorkRequest = ...
                  WorkManager.getInstance(myContext).enqueue(myWorkRequest)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint


                  WorkRequest myWorkRequest = ...
                  WorkManager.getInstance(myContext).enqueue(myWorkRequest);

      The WorkRequest object contains all of the information needed by
      WorkManager to schedule and run your work. It includes constraints
      which must be met for your work to run, scheduling information such
      as delays or repeating intervals, retry configuration, and may
      include input data if your work relies on it.

      `WorkRequest <#>`__ itself is
      an abstract base class. There are two derived implementations of this
      class that you can use to create the request,
      `OneTimeWorkRequest <#>`__
      and
      `PeriodicWorkRequest <#>`__.
      As their names imply, ``OneTimeWorkRequest`` is useful for scheduling
      non-repeating work, whilst ``PeriodicWorkRequest`` is more
      appropriate for scheduling work that repeats on some interval.

      .. rubric:: Schedule one-time work
         :name: schedule_one-time_work

      For simple work, which requires no additional configuration, use the
      static method
      `from <#from>`__:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint


                  val myWorkRequest = OneTimeWorkRequest.from(MyWork::class.java)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint


                  WorkRequest myWorkRequest = OneTimeWorkRequest.from(MyWork.class);

      For more complex work, you can use a builder:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val uploadWorkRequest: WorkRequest =
                     OneTimeWorkRequestBuilder<MyWork>()
                         // Additional configuration
                         .build()

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  WorkRequest uploadWorkRequest =
                     new OneTimeWorkRequest.Builder(MyWork.class)
                         // Additional configuration
                         .build();

      .. rubric:: Schedule expedited work
         :name: expedited

      WorkManager 2.7.0 introduced the concept of expedited work. This
      allows WorkManager to execute important work while giving the system
      better control over access to resources.

      Expedited work is notable for the following characteristics:

      -  **Importance**: Expedited work suits tasks which are important to
         the user or are user-initiated.
      -  **Speed**: Expedited work best fits short tasks that start
         immediately and complete within a few minutes.
      -  **Quotas**: A system-level quota that limits foreground execution
         time determines whether an expedited job can start.
      -  **Power Management**: `Power management restrictions <#>`__, such as
         Battery Saver and Doze, are less likely to affect expedited work.
      -  **Latency**: The system immediately executes expedited work,
         provided that the system's current workload enables it to do so.
         This means they are latency sensitive and can't be scheduled for
         later execution.

      A potential use case for expedited work might be within a chat app
      when the user wants to send a message or an attached image.
      Similarly, an app that handles a payment or subscription flow might
      also want to use expedited work. This is because those tasks are
      important to the user, execute quickly in the background, need to
      begin immediately, and should continue to execute even if the user
      closes the app

      .. rubric:: Quotas
         :name: quotas

      The system must allocate execution time to an expedited job before it
      can run. Execution time is not unlimited. Rather, each app receives a
      quota of execution time. When your app uses its execution time and
      reaches its allocated quota, you can no longer execute expedited work
      until the quota refreshes. This allows Android to more effectively
      balance resources between applications.

      The amount of execution time available to an app is based on the
      `standby bucket <#>`__ and process
      importance.

      You can determine what occurs when the execution quota does not allow
      for an expedited job to run immediately. See the snippets below for
      detail.

      **Note:**\  While your app is in the foreground, quotas won‚Äôt limit
      the execution of expedited work. An execution time quota applies only
      when your app is in the background, or when your app moves to the
      background. As such, you should expedite work that you want to
      continue in the background. You can continue to use
      ``setForeground()`` while your app is in the foreground.

      .. rubric:: Executing expedited work
         :name: expedited

      Starting in WorkManager 2.7, your app can call ``setExpedited()`` to
      declare that a ``WorkRequest`` should run as quickly as possible
      using an expedited job. The following code snippet provides an
      example of how to use ``setExpedited()``:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val request = OneTimeWorkRequestBuilder<SyncWorker>()
                      .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)
                      .build()

                  WorkManager.getInstance(context)
                      .enqueue(request)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  OneTimeWorkRequest request = new OneTimeWorkRequestBuilder<T>()
                      .setInputData(inputData)
                      .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)
                      .build();

      In this example, we initialize an instance of ``OneTimeWorkRequest``
      and call ``setExpedited()`` on it. This request then becomes
      expedited work. If the quota allows, it will begin to run immediately
      in the background. If the quota has been used, the
      ``OutOfQuotaPolicy`` parameter indicates that the request should be
      run as normal, non-expedited work.

      .. rubric:: Backwards compatibility and foreground services
         :name: backwards-compat

      To maintain backwards compatibility for expedited jobs, WorkManager
      might run a foreground service on platform versions older than
      Android 12. Foreground services can display a notification to the
      user.

      The ``getForegroundInfoAsync()`` and ``getForegroundInfo()`` methods
      in your Worker enable WorkManager to display a notification when you
      call ``setExpedited()`` prior to Android 12.

      Any ``ListenableWorker`` must implement the ``getForegroundInfo``
      method if you would like to request that the task run as an expedited
      job.

      **Caution:**\  Failing to implement the corresponding
      ``getForegroundInfo`` method can lead to runtime crashes when calling
      ``setExpedited`` on older platform versions.
      When targeting Android 12 or higher, foreground services remain
      available to you through the corresponding ``setForeground`` method.

      **Caution:**\  ``setForeground()`` can throw runtime exceptions on
      Android 12, and might throw an exception if the `launch was restricted <#background-start-restrictions>`__.

      .. rubric:: Worker
         :name: worker

      Workers don't know whether the work they're doing is expedited or
      not. But workers can display a notification on some versions of
      Android when a ``WorkRequest`` has been expedited.

      To enable this, WorkManager provides the ``getForegroundInfoAsync()``
      method, which you must implement so WorkManager can display a
      notification to start a ``ForegroundService`` for you where
      necessary.

      .. rubric:: CoroutineWorker
         :name: coroutineworker

      If you use a ``CoroutineWorker``, you must implement
      ``getForegroundInfo()``. You then pass it to ``setForeground()``
      within ``doWork()``. Doing so will create the notification in
      versions of Android prior to 12.

      Consider the following example:

      .. code:: prettyprint

           class ExpeditedWorker(appContext: Context, workerParams: WorkerParameters):
            CoroutineWorker(appContext, workerParams) {

            override suspend fun getForegroundInfo(): ForegroundInfo {
                return ForegroundInfo(
                    NOTIFICATION_ID, createNotification()
                )
            }

            override suspend fun doWork(): Result {
                TODO()
            }

             private fun createNotification() : Notification {
                TODO()
             }

         }

      **Note:**\  You should wrap ``setForeground()`` in a ``try/catch``
      block to catch a potential ``IllegalStateException``. These might
      occur when your app is not able to run in the foreground at this
      point. In Android 12 and higher you can use the more detailed
      ``ForegroundServiceStartNotAllowedException``.

      .. rubric:: Quota policies
         :name: quota_policies

      You can control what happens to expedited work when your app reaches
      its execution quota. To continue, you can pass ``setExpedited()``:

      -  ``OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST``, which
         causes the job to run as an ordinary work request. The snippet
         above demonstrates this.
      -  ``OutOfQuotaPolicy.DROP_WORK_REQUEST``, which causes the request
         to cancel if there is not sufficient quota.

      .. rubric:: Sample app
         :name: sample_app

      To see a complete example of how WorkManager 2.7.0 uses expedited
      work, look through the
      `WorkManagerSample <https://github.com/android/architecture-components-samples/blob/android-s/WorkManagerSample/lib/src/main/java/com/example/background/ImageOperations.kt>`__
      on GitHub.

      .. rubric:: Deferred expedited work
         :name: deferred_expedited_work

      The system tries to execute a given expedited job as soon as possible
      after the job is invoked. However, as is the case with other types of
      jobs, the system might defer the start of new expedited work, such as
      in the following cases:

      -  **Load**: The system load is too high, which can occur when too
         many jobs are already running, or when the system doesn't have
         enough memory.
      -  **Quota**: The expedited job quota limit has been exceeded.
         Expedited work uses a quota system that's based on the App Standby
         Buckets and limits the maximum execution time within a rolling
         time window. The quotas used for expedited work are more
         restrictive than the ones used for other types of background jobs.

      .. rubric:: Schedule periodic work
         :name: schedule_periodic_work

      Your app may at times require that certain work runs periodically.
      For example, you may want to periodically backup your data, download
      fresh content in your app, or upload logs to a server.

      Here is how you use the
      `PeriodicWorkRequest <#>`__
      to create a ``WorkRequest`` object which executes periodically:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint


                  val saveRequest =
                         PeriodicWorkRequestBuilder<SaveImageToFileWorker>(1, TimeUnit.HOURS)
                      // Additional configuration
                             .build()

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint


                  PeriodicWorkRequest saveRequest =
                         new PeriodicWorkRequest.Builder(SaveImageToFileWorker.class, 1, TimeUnit.HOURS)
                             // Constraints
                             .build();

      In this example, the work is scheduled with a one hour interval.

      The interval period is defined as the minimum time between
      repetitions. The exact time that the worker is going to be executed
      depends on the constraints that you are using in your WorkRequest
      object and on the optimizations performed by the system.

      **Note:**\  The minimum repeat interval that can be defined is 15
      minutes (same as the `JobScheduler API <#>`__).

      .. rubric:: Flexible run intervals
         :name: flexible_run_intervals

      If the nature of your work makes it sensitive to run timing, you can
      configure your
      `PeriodicWorkRequest <#>`__
      to run within a **flex period** inside each interval period, as shown
      in Figure 1.


      .. figure:: https://developer.android.google.cn/static/images/topic/libraries/architecture/workmanager/how-to/definework-flex-period.png

         You can set a flex interval for a periodic job. You define a repeat
         interval, and a flex interval that specifies a certain amount of time
         at the end of the repeat interval. WorkManager attempts to run your
         job at some point during the flex interval in each cycle.

      **Figure 1.** Diagram shows repeating intervals with the flexible
      period in which the work can run.

      To define periodic work with a flex period, you pass a
      ``flexInterval`` along with the ``repeatInterval`` when creating the
      ``PeriodicWorkRequest``. The flex period begins at
      ``repeatInterval - flexInterval``, and goes to the end of the
      interval.

      The following is an example of periodic work that can run during the
      last 15 minutes of every one hour period.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint


                  val myUploadWork = PeriodicWorkRequestBuilder<SaveImageToFileWorker>(
                         1, TimeUnit.HOURS, // repeatInterval (the period cycle)
                         15, TimeUnit.MINUTES) // flexInterval
                      .build()

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint


                  WorkRequest saveRequest =
                         new PeriodicWorkRequest.Builder(SaveImageToFileWorker.class,
                                 1, TimeUnit.HOURS,
                                 15, TimeUnit.MINUTES)
                             .build();

      The repeat interval must be greater than or equal to
      `PeriodicWorkRequest.MIN_PERIODIC_INTERVAL_MILLIS <#MIN_PERIODIC_INTERVAL_MILLIS>`__
      and the flex interval must be greater than or equal to
      `PeriodicWorkRequest.MIN_PERIODIC_FLEX_MILLIS <#MIN_PERIODIC_FLEX_MILLIS>`__.

      .. rubric:: Effect of Constraints on Periodic Work
         :name: effect_of_constraints_on_periodic_work

      You can apply `constraints <#work-constraints>`__ to periodic work.
      For example, you could add a constraint to your work request such
      that the work only runs when the user‚Äôs device is charging. In this
      case, even if the defined repeat interval passes, the
      ``PeriodicWorkRequest`` will not run until this condition is met.
      This could cause a particular run of your work to be delayed, or even
      skipped if the conditions are not met within the run interval.

      .. rubric:: Work constraints
         :name: work-constraints

      `Constraints <#>`__ ensure that
      work is deferred until optimal conditions are met. The following
      constraints are available to WorkManager.

      .. list-table::

         - 

            - **NetworkType**
            - Constrains the `type of network <#>`__ required
               for your work to run. For example, Wi-Fi
               (`UNMETERED </reference/androidx/work/NetworkType#UNMETERED>`__).
         - 

            - **BatteryNotLow**
            - When set to true, your work will not run if the device is in
               low battery mode.
         - 

            - **RequiresCharging**
            - When set to true, your work will only run when the device is
               charging.
         - 

            - **DeviceIdle**
            - When set to true, this requires the user‚Äôs device to be idle
               before the work will run. This can be useful for running
               batched operations that might otherwise have a negative
               performance impact on other apps running actively on the
               user‚Äôs device.
         - 

            - **StorageNotLow**
            - When set to true, your work will not run if the user‚Äôs
               storage space on the device is too low.

      To create a set of constraints and associate it with some work,
      create a ``Constraints`` instance using the ``Contraints.Builder()``
      and assign it to your ``WorkRequest.Builder()``.

      For example, the following code builds a work request which only runs
      when the user‚Äôs device is both charging and on Wi-Fi:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint


                  val constraints = Constraints.Builder()
                     .setRequiredNetworkType(NetworkType.UNMETERED)
                     .setRequiresCharging(true)
                     .build()

                  val myWorkRequest: WorkRequest =
                     OneTimeWorkRequestBuilder<MyWork>()
                         .setConstraints(constraints)
                         .build()

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint


                  Constraints constraints = new Constraints.Builder()
                         .setRequiredNetworkType(NetworkType.UNMETERED)
                         .setRequiresCharging(true)
                         .build();

                  WorkRequest myWorkRequest =
                         new OneTimeWorkRequest.Builder(MyWork.class)
                                 .setConstraints(constraints)
                                 .build();

      When multiple constraints are specified, your work will run only when
      all the constraints are met.

      In the event that a constraint becomes unmet while your work is
      running, WorkManager will stop your worker. The work will then be
      retried when all the constraints are met.

      .. rubric:: Delayed Work
         :name: delayed_work

      In the event that your work has no constraints or that all the
      constraints are met when your work is enqueued, the system may choose
      to run the work immediately. If you do not want the work to be run
      immediately, you can specify your work to start after a minimum
      initial delay.

      Here is an example of how to set your work to run at least 10 minutes
      after it has been enqueued.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint


                  val myWorkRequest = OneTimeWorkRequestBuilder<MyWork>()
                     .setInitialDelay(10, TimeUnit.MINUTES)
                     .build()

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint


                  WorkRequest myWorkRequest =
                        new OneTimeWorkRequest.Builder(MyWork.class)
                                 .setInitialDelay(10, TimeUnit.MINUTES)
                                 .build();

      While the example illustrates how to set an initial delay for a
      ``OneTimeWorkRequest``, you can also set an initial delay for a
      ``PeriodicWorkRequest``. In that case, only the first run of your
      periodic work would be delayed.

      **Note:**\  The exact time that the worker is going to be executed
      also depends on the constraints that are used in your work request
      and on system optimizations. WorkManager is designed to give the best
      possible behavior under these restrictions.

      .. rubric:: Retry and backoff policy
         :name: retries_backoff

      If you require that WorkManager retry your work, you can return
      `Result.retry() <#retry>`__
      from your worker. Your work is then rescheduled according to a
      `backoff delay <#DEFAULT_BACKOFF_DELAY_MILLIS>`__
      and `backoff policy <#>`__.

      -  *Backoff delay* specifies the minimum amount of time to wait
         before retrying your work after the first attempt. This value can
         be no less than 10 seconds (or
         `MIN_BACKOFF_MILLIS <#MIN_BACKOFF_MILLIS>`__).

      -  *Backoff policy* defines how the backoff delay should increase
         over time for subsequent retry attempts. WorkManager supports 2
         backoff policies,
         `LINEAR <#LINEAR>`__ and
         `EXPONENTIAL <#EXPONENTIAL>`__.

      Every work request has a backoff policy and backoff delay. The
      default policy is ``EXPONENTIAL`` with a delay of 30 seconds, but you
      can override this in your work request configuration.

      Here is an example of customizing the backoff delay and policy.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint


                  val myWorkRequest = OneTimeWorkRequestBuilder<MyWork>()
                     .setBackoffCriteria(
                         BackoffPolicy.LINEAR,
                         OneTimeWorkRequest.MIN_BACKOFF_MILLIS,
                         TimeUnit.MILLISECONDS)
                     .build()

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint


                  WorkRequest myWorkRequest =
                         new OneTimeWorkRequest.Builder(MyWork.class)
                                 .setBackoffCriteria(
                                         BackoffPolicy.LINEAR,
                                         OneTimeWorkRequest.MIN_BACKOFF_MILLIS,
                                         TimeUnit.MILLISECONDS)
                                 .build();

      In this example, the minimum backoff delay is set to the minimum
      allowed value, 10 seconds. Since the policy is ``LINEAR`` the retry
      interval will increase by approximately 10 seconds with each new
      attempt. For instance, the first run finishing with
      ``Result.retry()`` will be attempted again after 10 seconds, followed
      by 20, 30, 40, and so on, if the work continues to return
      ``Result.retry()`` after subsequent attempts. If the backoff policy
      were set to ``EXPONENTIAL``, the retry duration sequence would be
      closer to 20, 40, 80, and so on.

      **Note:**\  Backoff delays are inexact and could vary by several
      seconds between retries but will never be less than the initial
      backoff delay specified in your configuration.

      .. rubric:: Tag work
         :name: tag_work

      Every work request has a `unique identifier <#getId>`__, which
      can be used to identify that work later in order to
      `cancel <#cancelling>`__
      the work or `observe its progress <#observing>`__.

      If you have a group of logically related work, you may also find it
      helpful to tag those work items. Tagging allows you to operate with a
      group of work requests together.

      For example,
      `WorkManager.cancelAllWorkByTag(String) <#cancelAllWorkByTag>`__
      cancels all work requests with a particular tag, and
      `WorkManager.getWorkInfosByTag(String) <#getWorkInfosByTagLiveData>`__
      returns a list of the WorkInfo objects which can be used to determine
      the current work state.

      The following code shows how you can add a "cleanup" tag to your
      work:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint


                  val myWorkRequest = OneTimeWorkRequestBuilder<MyWork>()
                     .addTag("cleanup")
                     .build()

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint


                  WorkRequest myWorkRequest =
                         new OneTimeWorkRequest.Builder(MyWork.class)
                         .addTag("cleanup")
                         .build();

      Finally, multiple tags can be added to a single work request.
      Internally these tags are stored as a set of strings. To get the set
      of tags associated with the ``WorkRequest`` you can use
      `WorkInfo.getTags() <#getTags>`__.

      From your ``Worker`` class, you can retrieve its set of tags via
      `ListenableWorker.getTags() <#getTags>`__.

      .. rubric:: Assign input data
         :name: input_output

      Your work may require input data in order to do its work. For
      example, work that handles uploading an image might require the URI
      of the image to be uploaded as input.

      Input values are stored as key-value pairs in a
      `Data <#>`__ object and can be set on
      the work request. WorkManager will deliver the input ``Data`` to your
      work when it executes the work. The ``Worker`` class can access the
      input arguments by calling
      `Worker.getInputData() <#getInputData>`__.
      The code below shows how you can create a ``Worker`` instance which
      requires input data and how to send it in your work request.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint


                  // Define the Worker requiring input
                  class UploadWork(appContext: Context, workerParams: WorkerParameters)
                     : Worker(appContext, workerParams) {

                     override fun doWork(): Result {
                         val imageUriInput =
                             inputData.getString("IMAGE_URI") ?: return Result.failure()

                         uploadFile(imageUriInput)
                         return Result.success()
                     }
                     ...
                  }

                  // Create a WorkRequest for your Worker and sending it input
                  val myUploadWork = OneTimeWorkRequestBuilder<UploadWork>()
                     .setInputData(workDataOf(
                         "IMAGE_URI" to "http://..."
                     ))
                     .build()

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint


                  // Define the Worker requiring input
                  public class UploadWork extends Worker {

                     public UploadWork(Context appContext, WorkerParameters workerParams) {
                         super(appContext, workerParams);
                     }

                     @NonNull
                     @Override
                     public Result doWork() {
                         String imageUriInput = getInputData().getString("IMAGE_URI");
                         if(imageUriInput == null) {
                             return Result.failure();
                         }

                         uploadFile(imageUriInput);
                         return Result.success();
                     }
                     ...
                  }

                  // Create a WorkRequest for your Worker and sending it input
                  WorkRequest myUploadWork =
                        new OneTimeWorkRequest.Builder(UploadWork.class)
                             .setInputData(
                                 new Data.Builder()
                                     .putString("IMAGE_URI", "http://...")
                                     .build()
                             )
                             .build();

      Similarly, the ``Data`` class can be used to output a return value.
      Input and output data are covered in more detail in the section
      `input parameters and returned values <#params>`__.

      .. rubric:: Next Steps
         :name: next_steps

      In the `States and observation <#>`__
      page, you‚Äôll learn more about work states and how to monitor the
      progress of your work.

   Last updated 2024-05-03 UTC.


/Define work requests
=====================

.. container:: devsite-article-body clearfix

   The `getting started guide <#>`__ covered how to
   create a simple `WorkRequest <#>`__ and enqueue it.

   In this guide you will learn how to define and customize ``WorkRequest``
   objects to handle common use cases, such as how to:

   -  Schedule one-time and recurring work
   -  Set work constraints like requiring Wi-Fi or charging
   -  Guarantee a minimum delay in work execution
   -  Set retry and back-off strategies
   -  Pass input data to work
   -  Group related work together using tags

   .. rubric:: Overview
      :name: Overview

   Work is defined in WorkManager via a `WorkRequest <#>`__. In order to
   schedule any work with WorkManager you must first create a ``WorkRequest``
   object and then enqueue it.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val myWorkRequest = ...
               WorkManager.getInstance(myContext).enqueue(myWorkRequest)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               WorkRequest myWorkRequest = ...
               WorkManager.getInstance(myContext).enqueue(myWorkRequest);

   The WorkRequest object contains all of the information needed by WorkManager
   to schedule and run your work. It includes constraints which must be met for
   your work to run, scheduling information such as delays or repeating
   intervals, retry configuration, and may include input data if your work
   relies on it.

   `WorkRequest <#>`__ itself is an
   abstract base class. There are two derived implementations of this class that
   you can use to create the request,
   `OneTimeWorkRequest <#>`__ and `PeriodicWorkRequest <#>`__.
   As their names imply, ``OneTimeWorkRequest`` is useful for scheduling
   non-repeating work, whilst ``PeriodicWorkRequest`` is more appropriate for
   scheduling work that repeats on some interval.

   .. rubric:: Schedule one-time work
      :name: schedule_one-time_work

   For simple work, which requires no additional configuration, use the static
   method `from <#OneTimeWorkRequest.from>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               val myWorkRequest = OneTimeWorkRequest.from(MyWork::class.java)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               WorkRequest myWorkRequest = OneTimeWorkRequest.from(MyWork.class);

   For more complex work, you can use a builder:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val uploadWorkRequest: WorkRequest =
                  OneTimeWorkRequestBuilder<MyWork>()
                      // Additional configuration
                      .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               WorkRequest uploadWorkRequest =
                  new OneTimeWorkRequest.Builder(MyWork.class)
                      // Additional configuration
                      .build();

   .. rubric:: Schedule expedited work
      :name: expedited

   WorkManager 2.7.0 introduced the concept of expedited work. This allows
   WorkManager to execute important work while giving the system better control
   over access to resources.

   Expedited work is notable for the following characteristics:

   -  **Importance**: Expedited work suits tasks which are important to the user
      or are user-initiated.
   -  **Speed**: Expedited work best fits short tasks that start immediately and
      complete within a few minutes.
   -  **Quotas**: A system-level quota that limits foreground execution time
      determines whether an expedited job can start.
   -  **Power Management**: `Power management restrictions <#>`__, such as Battery
      Saver and Doze, are less likely to affect expedited work.
   -  **Latency**: The system immediately executes expedited work, provided that
      the system's current workload enables it to do so. This means they are
      latency sensitive and can't be scheduled for later execution.

   A potential use case for expedited work might be within a chat app when the
   user wants to send a message or an attached image. Similarly, an app that
   handles a payment or subscription flow might also want to use expedited work.
   This is because those tasks are important to the user, execute quickly in the
   background, need to begin immediately, and should continue to execute even if
   the user closes the app

   .. rubric:: Quotas
      :name: quotas

   The system must allocate execution time to an expedited job before it can
   run. Execution time is not unlimited. Rather, each app receives a quota of
   execution time. When your app uses its execution time and reaches its
   allocated quota, you can no longer execute expedited work until the quota
   refreshes. This allows Android to more effectively balance resources between
   applications.

   The amount of execution time available to an app is based on the 
   `standby bucket <https://developer.android.google.cn/topic/performance/appstandby>`__ 
   and process importance.

   You can determine what occurs when the execution quota does not allow for an
   expedited job to run immediately. See the snippets below for detail.

   **Note:**\  While your app is in the foreground, quotas won‚Äôt limit the
   execution of expedited work. An execution time quota applies only when your
   app is in the background, or when your app moves to the background. As such,
   you should expedite work that you want to continue in the background. You can
   continue to use ``setForeground()`` while your app is in the foreground.
   .. rubric:: Executing expedited work
      :name: expedited

   Starting in WorkManager 2.7, your app can call ``setExpedited()`` to declare
   that a ``WorkRequest`` should run as quickly as possible using an expedited
   job. The following code snippet provides an example of how to use
   ``setExpedited()``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val request = OneTimeWorkRequestBuilder<SyncWorker>()
                   .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)
                   .build()

               WorkManager.getInstance(context)
                   .enqueue(request)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               OneTimeWorkRequest request = new OneTimeWorkRequestBuilder<T>()
                   .setInputData(inputData)
                   .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)
                   .build();

   In this example, we initialize an instance of ``OneTimeWorkRequest`` and call
   ``setExpedited()`` on it. This request then becomes expedited work. If the
   quota allows, it will begin to run immediately in the background. If the
   quota has been used, the ``OutOfQuotaPolicy`` parameter indicates that the
   request should be run as normal, non-expedited work.

   .. rubric:: Backwards compatibility and foreground services
      :name: backwards-compat

   To maintain backwards compatibility for expedited jobs, WorkManager might run
   a foreground service on platform versions older than Android 12. Foreground
   services can display a notification to the user.

   The ``getForegroundInfoAsync()`` and ``getForegroundInfo()`` methods in your
   Worker enable WorkManager to display a notification when you call
   ``setExpedited()`` prior to Android 12.

   Any ``ListenableWorker`` must implement the ``getForegroundInfo`` method if
   you would like to request that the task run as an expedited job.

   **Caution:**\  Failing to implement the corresponding ``getForegroundInfo``
   method can lead to runtime crashes when calling ``setExpedited`` on older
   platform versions.
   When targeting Android 12 or higher, foreground services remain available to
   you through the corresponding ``setForeground`` method.

   **Caution:**\  ``setForeground()`` can throw runtime exceptions on Android
   12, and might throw an exception if the 
   `launch was restricted <#background-start-restrictions>`__.

   .. rubric:: Worker
      :name: worker

   Workers don't know whether the work they're doing is expedited or not. But
   workers can display a notification on some versions of Android when a
   ``WorkRequest`` has been expedited.

   To enable this, WorkManager provides the ``getForegroundInfoAsync()`` method,
   which you must implement so WorkManager can display a notification to start a
   ``ForegroundService`` for you where necessary.

   .. rubric:: CoroutineWorker
      :name: coroutineworker

   If you use a ``CoroutineWorker``, you must implement ``getForegroundInfo()``.
   You then pass it to ``setForeground()`` within ``doWork()``. Doing so will
   create the notification in versions of Android prior to 12.

   Consider the following example:

   .. code:: prettyprint

        class ExpeditedWorker(appContext: Context, workerParams: WorkerParameters):
         CoroutineWorker(appContext, workerParams) {

         override suspend fun getForegroundInfo(): ForegroundInfo {
             return ForegroundInfo(
                 NOTIFICATION_ID, createNotification()
             )
         }

         override suspend fun doWork(): Result {
             TODO()
         }

          private fun createNotification() : Notification {
             TODO()
          }

      }

   **Note:**\  You should wrap ``setForeground()`` in a ``try/catch`` block to
   catch a potential ``IllegalStateException``. These might occur when your app
   is not able to run in the foreground at this point. In Android 12 and higher
   you can use the more detailed ``ForegroundServiceStartNotAllowedException``.
   .. rubric:: Quota policies
      :name: quota_policies

   You can control what happens to expedited work when your app reaches its
   execution quota. To continue, you can pass ``setExpedited()``:

   -  ``OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST``, which causes the
      job to run as an ordinary work request. The snippet above demonstrates
      this.
   -  ``OutOfQuotaPolicy.DROP_WORK_REQUEST``, which causes the request to cancel
      if there is not sufficient quota.

   .. rubric:: Sample app
      :name: sample_app

   To see a complete example of how WorkManager 2.7.0 uses expedited work, look
   through the
   `WorkManagerSample <https://github.com/android/architecture-components-samples/blob/android-s/WorkManagerSample/lib/src/main/java/com/example/background/ImageOperations.kt>`__
   on GitHub.

   .. rubric:: Deferred expedited work
      :name: deferred_expedited_work

   The system tries to execute a given expedited job as soon as possible after
   the job is invoked. However, as is the case with other types of jobs, the
   system might defer the start of new expedited work, such as in the following
   cases:

   -  **Load**: The system load is too high, which can occur when too many jobs
      are already running, or when the system doesn't have enough memory.
   -  **Quota**: The expedited job quota limit has been exceeded. Expedited work
      uses a quota system that's based on the App Standby Buckets and limits the
      maximum execution time within a rolling time window. The quotas used for
      expedited work are more restrictive than the ones used for other types of
      background jobs.

   .. rubric:: Schedule periodic work
      :name: schedule_periodic_work

   Your app may at times require that certain work runs periodically. For
   example, you may want to periodically backup your data, download fresh
   content in your app, or upload logs to a server.

   Here is how you use the `PeriodicWorkRequest <#>`__ to
   create a ``WorkRequest`` object which executes periodically:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               val saveRequest =
                      PeriodicWorkRequestBuilder<SaveImageToFileWorker>(1, TimeUnit.HOURS)
                   // Additional configuration
                          .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               PeriodicWorkRequest saveRequest =
                      new PeriodicWorkRequest.Builder(SaveImageToFileWorker.class, 1, TimeUnit.HOURS)
                          // Constraints
                          .build();

   In this example, the work is scheduled with a one hour interval.

   The interval period is defined as the minimum time between repetitions. The
   exact time that the worker is going to be executed depends on the constraints
   that you are using in your WorkRequest object and on the optimizations
   performed by the system.

   **Note:**\  The minimum repeat interval that can be defined is 15 minutes
   (same as the `JobScheduler API <#>`__).

   .. rubric:: Flexible run intervals
      :name: flexible_run_intervals

   If the nature of your work makes it sensitive to run timing, you can
   configure your `PeriodicWorkRequest <#>`__ to
   run within a **flex period** inside each interval period, as shown in Figure
   1.


   .. figure:: https://developer.android.google.cn/static/images/topic/libraries/architecture/workmanager/how-to/definework-flex-period.png

      You can set a flex interval for a periodic job. You define a repeat
      interval, and a flex interval that specifies a certain amount of time at the
      end of the repeat interval. WorkManager attempts to run your job at some
      point during the flex interval in each cycle.

   **Figure 1.** Diagram shows repeating intervals with the flexible period in
   which the work can run.

   To define periodic work with a flex period, you pass a ``flexInterval`` along
   with the ``repeatInterval`` when creating the ``PeriodicWorkRequest``. The
   flex period begins at ``repeatInterval - flexInterval``, and goes to the end
   of the interval.

   The following is an example of periodic work that can run during the last 15
   minutes of every one hour period.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               val myUploadWork = PeriodicWorkRequestBuilder<SaveImageToFileWorker>(
                      1, TimeUnit.HOURS, // repeatInterval (the period cycle)
                      15, TimeUnit.MINUTES) // flexInterval
                   .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               WorkRequest saveRequest =
                      new PeriodicWorkRequest.Builder(SaveImageToFileWorker.class,
                              1, TimeUnit.HOURS,
                              15, TimeUnit.MINUTES)
                          .build();

   The repeat interval must be greater than or equal to
   `PeriodicWorkRequest.MIN_PERIODIC_INTERVAL_MILLIS <#MIN_PERIODIC_INTERVAL_MILLIS>`__
   and the flex interval must be greater than or equal to
   `PeriodicWorkRequest.MIN_PERIODIC_FLEX_MILLIS <#MIN_PERIODIC_FLEX_MILLIS>`__.

   .. rubric:: Effect of Constraints on Periodic Work
      :name: effect_of_constraints_on_periodic_work

   You can apply `constraints <#work-constraints>`__ to periodic work. For
   example, you could add a constraint to your work request such that the work
   only runs when the user‚Äôs device is charging. In this case, even if the
   defined repeat interval passes, the ``PeriodicWorkRequest`` will not run
   until this condition is met. This could cause a particular run of your work
   to be delayed, or even skipped if the conditions are not met within the run
   interval.

   .. rubric:: Work constraints
      :name: work-constraints

   `Constraints </reference/androidx/work/Constraints>`__ ensure that work is
   deferred until optimal conditions are met. The following constraints are
   available to WorkManager.

   +----------------------+------------------------------------------------------+
   | **NetworkType**      | Constrains the `type of network <#>`__               |
   |                      | required for your work to run. For example, Wi-Fi    |
   |                      | (`UNMETERED <#UNMETERED>`__).                        |
   +----------------------+------------------------------------------------------+
   | **BatteryNotLow**    | When set to true, your work will not run if the      |
   |                      | device is in low battery mode.                       |
   +----------------------+------------------------------------------------------+
   | **RequiresCharging** | When set to true, your work will only run when the   |
   |                      | device is charging.                                  |
   +----------------------+------------------------------------------------------+
   | **DeviceIdle**       | When set to true, this requires the user‚Äôs device to |
   |                      | be idle before the work will run. This can be useful |
   |                      | for running batched operations that might otherwise  |
   |                      | have a negative performance impact on other apps     |
   |                      | running actively on the user‚Äôs device.               |
   +----------------------+------------------------------------------------------+
   | **StorageNotLow**    | When set to true, your work will not run if the      |
   |                      | user‚Äôs storage space on the device is too low.       |
   +----------------------+------------------------------------------------------+

   To create a set of constraints and associate it with some work, create a
   ``Constraints`` instance using the ``Contraints.Builder()`` and assign it to
   your ``WorkRequest.Builder()``.

   For example, the following code builds a work request which only runs when
   the user‚Äôs device is both charging and on Wi-Fi:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               val constraints = Constraints.Builder()
                  .setRequiredNetworkType(NetworkType.UNMETERED)
                  .setRequiresCharging(true)
                  .build()

               val myWorkRequest: WorkRequest =
                  OneTimeWorkRequestBuilder<MyWork>()
                      .setConstraints(constraints)
                      .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               Constraints constraints = new Constraints.Builder()
                      .setRequiredNetworkType(NetworkType.UNMETERED)
                      .setRequiresCharging(true)
                      .build();

               WorkRequest myWorkRequest =
                      new OneTimeWorkRequest.Builder(MyWork.class)
                              .setConstraints(constraints)
                              .build();

   When multiple constraints are specified, your work will run only when all the
   constraints are met.

   In the event that a constraint becomes unmet while your work is running,
   WorkManager will stop your worker. The work will then be retried when all the
   constraints are met.

   .. rubric:: Delayed Work
      :name: delayed_work

   In the event that your work has no constraints or that all the constraints
   are met when your work is enqueued, the system may choose to run the work
   immediately. If you do not want the work to be run immediately, you can
   specify your work to start after a minimum initial delay.

   Here is an example of how to set your work to run at least 10 minutes after
   it has been enqueued.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               val myWorkRequest = OneTimeWorkRequestBuilder<MyWork>()
                  .setInitialDelay(10, TimeUnit.MINUTES)
                  .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               WorkRequest myWorkRequest =
                     new OneTimeWorkRequest.Builder(MyWork.class)
                              .setInitialDelay(10, TimeUnit.MINUTES)
                              .build();

   While the example illustrates how to set an initial delay for a
   ``OneTimeWorkRequest``, you can also set an initial delay for a
   ``PeriodicWorkRequest``. In that case, only the first run of your periodic
   work would be delayed.

   **Note:**\  The exact time that the worker is going to be executed also
   depends on the constraints that are used in your work request and on system
   optimizations. WorkManager is designed to give the best possible behavior
   under these restrictions.
   .. rubric:: Retry and backoff policy
      :name: retries_backoff

   If you require that WorkManager retry your work, you can return
   `Result.retry() <#ListenableWorker.Result>`__
   from your worker. Your work is then rescheduled according to a 
   `backoff delay <#DEFAULT_BACKOFF_DELAY_MILLIS>`__
   and `backoff policy <#androidx.work.BackoffPolicy>`__.

   -  *Backoff delay* specifies the minimum amount of time to wait before
      retrying your work after the first attempt. This value can be no less than
      10 seconds (or `MIN_BACKOFF_MILLIS <#MIN_BACKOFF_MILLIS>`__).

   -  *Backoff policy* defines how the backoff delay should increase over time
      for subsequent retry attempts. WorkManager supports 2 backoff policies,
      `LINEAR <#androidx.work.BackoffPolicy>`__ and
      `EXPONENTIAL <#androidx.work.BackoffPolicy>`__.

   Every work request has a backoff policy and backoff delay. The default policy
   is ``EXPONENTIAL`` with a delay of 30 seconds, but you can override this in
   your work request configuration.

   Here is an example of customizing the backoff delay and policy.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               val myWorkRequest = OneTimeWorkRequestBuilder<MyWork>()
                  .setBackoffCriteria(
                      BackoffPolicy.LINEAR,
                      OneTimeWorkRequest.MIN_BACKOFF_MILLIS,
                      TimeUnit.MILLISECONDS)
                  .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               WorkRequest myWorkRequest =
                      new OneTimeWorkRequest.Builder(MyWork.class)
                              .setBackoffCriteria(
                                      BackoffPolicy.LINEAR,
                                      OneTimeWorkRequest.MIN_BACKOFF_MILLIS,
                                      TimeUnit.MILLISECONDS)
                              .build();

   In this example, the minimum backoff delay is set to the minimum allowed
   value, 10 seconds. Since the policy is ``LINEAR`` the retry interval will
   increase by approximately 10 seconds with each new attempt. For instance, the
   first run finishing with ``Result.retry()`` will be attempted again after 10
   seconds, followed by 20, 30, 40, and so on, if the work continues to return
   ``Result.retry()`` after subsequent attempts. If the backoff policy were set
   to ``EXPONENTIAL``, the retry duration sequence would be closer to 20, 40,
   80, and so on.

   **Note:**\  Backoff delays are inexact and could vary by several seconds
   between retries but will never be less than the initial backoff delay
   specified in your configuration.
   .. rubric:: Tag work
      :name: tag_work

   Every work request has a `unique
   identifier </reference/androidx/work/WorkRequest#getId()>`__, which can be
   used to identify that work later in order to `cancel <#cancelling>`__
   the work or `observe its progress <#observing>`__.

   If you have a group of logically related work, you may also find it helpful
   to tag those work items. Tagging allows you to operate with a group of work
   requests together.

   For example, `WorkManager.cancelAllWorkByTag(String) <#>`__
   cancels all work requests with a particular tag, and
   `WorkManager.getWorkInfosByTag(String) <#>`__
   returns a list of the WorkInfo objects which can be used to determine the
   current work state.

   The following code shows how you can add a "cleanup" tag to your work:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               val myWorkRequest = OneTimeWorkRequestBuilder<MyWork>()
                  .addTag("cleanup")
                  .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               WorkRequest myWorkRequest =
                      new OneTimeWorkRequest.Builder(MyWork.class)
                      .addTag("cleanup")
                      .build();

   Finally, multiple tags can be added to a single work request. Internally
   these tags are stored as a set of strings. To get the set of tags associated
   with the ``WorkRequest`` you can use `WorkInfo.getTags() <#>`__.

   From your ``Worker`` class, you can retrieve its set of tags via
   `ListenableWorker.getTags() <#>`__.

   .. rubric:: Assign input data
      :name: input_output

   Your work may require input data in order to do its work. For example, work
   that handles uploading an image might require the URI of the image to be
   uploaded as input.

   Input values are stored as key-value pairs in a
   `Data <#androidx.work.Data>`__ object and can be set on the
   work request. WorkManager will deliver the input ``Data`` to your work when
   it executes the work. The ``Worker`` class can access the input arguments by
   calling `Worker.getInputData() <#>`__.
   The code below shows how you can create a ``Worker`` instance which requires
   input data and how to send it in your work request.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               // Define the Worker requiring input
               class UploadWork(appContext: Context, workerParams: WorkerParameters)
                  : Worker(appContext, workerParams) {

                  override fun doWork(): Result {
                      val imageUriInput =
                          inputData.getString("IMAGE_URI") ?: return Result.failure()

                      uploadFile(imageUriInput)
                      return Result.success()
                  }
                  ...
               }

               // Create a WorkRequest for your Worker and sending it input
               val myUploadWork = OneTimeWorkRequestBuilder<UploadWork>()
                  .setInputData(workDataOf(
                      "IMAGE_URI" to "http://..."
                  ))
                  .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               // Define the Worker requiring input
               public class UploadWork extends Worker {

                  public UploadWork(Context appContext, WorkerParameters workerParams) {
                      super(appContext, workerParams);
                  }

                  @NonNull
                  @Override
                  public Result doWork() {
                      String imageUriInput = getInputData().getString("IMAGE_URI");
                      if(imageUriInput == null) {
                          return Result.failure();
                      }

                      uploadFile(imageUriInput);
                      return Result.success();
                  }
                  ...
               }

               // Create a WorkRequest for your Worker and sending it input
               WorkRequest myUploadWork =
                     new OneTimeWorkRequest.Builder(UploadWork.class)
                          .setInputData(
                              new Data.Builder()
                                  .putString("IMAGE_URI", "http://...")
                                  .build()
                          )
                          .build();

   Similarly, the ``Data`` class can be used to output a return value. Input and
   output data are covered in more detail in the section 
   `input parameters and returned values <#>`__.

   .. rubric:: Next Steps
      :name: next_steps

   In the `States and observation <#>`__
   page, you‚Äôll learn more about work states and how to monitor the progress of
   your work.

Last updated 2024-05-03 UTC.


/Work states
============

.. container:: devsite-article-body clearfix

   Work goes through a series of
   `State <#>`__ changes over
   its lifetime.

   .. rubric:: One-time work states
      :name: one-time_work_states

   For a
   `one-time <#schedule_one-time_work>`__
   work request, your work begins in an
   `ENQUEUED <#ENQUEUED>`__
   state.

   In the ``ENQUEUED`` state, your work is eligible to run as soon as
   its `Constraints <#>`__ and
   initial delay timing requirements are met. From there it moves to a
   `RUNNING <#RUNNING>`__
   state and then depending on the outcome of the work it may move to
   `SUCCEEDED <#SUCCEEDED>`__,
   `FAILED <#FAILED>`__, or
   possibly back to ``ENQUEUED`` if the result is
   `retry <#retry>`__.
   At any point in the process, work can be cancelled, at which point it
   will move to the
   `CANCELLED <#CANCELLED>`__
   state.

   Figure 1 illustrates the life of one-time work, with the events that
   may take it to another state.


   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/workmanager/how-to/one-time-work-flow.png 
      :width: 500px

   **Figure 1.** State diagram for one-time work.

   ``SUCCEEDED``, ``FAILED`` and ``CANCELLED`` all represent a terminal
   state for this work. If your work is in any of these states,
   `WorkInfo.State.isFinished() <#isFinished>`__
   returns true.

   .. rubric:: Periodic work states
      :name: periodic_work_states

   Success and failed states apply only to one-time and `chained work <#>`__.
   For `periodic work <#schedule_periodic_work>`__,
   there is only one terminal state, ``CANCELLED``. This is because
   periodic work never ends. After each run, it‚Äôs rescheduled,
   regardless of the result. Figure 2 depicts the condensed state
   diagram for periodic work.

   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/workmanager/how-to/periodic-work-states.png 
      :width: 500px


   **Figure 2.** State diagram for periodic work.

   .. rubric:: Blocked state
      :name: blocked_state

   There is one final state we haven‚Äôt mentioned yet, and that is
   ``BLOCKED``. This state applies to work that is orchestrated in a
   series, or chain of work. Work chains, and their state diagram, are
   covered in `Chaining work <#>`__.

   .. rubric:: Next Steps
      :name: next_steps
      :class: page-title

   In `Managing work <#>`__,
   you‚Äôll learn more about how to manage and monitor the progress of
   your work.

Last updated 2024-01-03 UTC.


/Managing work
==============

.. container:: devsite-article-body clearfix

   Once you‚Äôve `defined your ``Worker </topic/libraries/architecture/workmanager/basics#define_the_work>`__
   and `your ``WorkRequest </topic/libraries/architecture/workmanager/how-to/define-work>`__,
   the last step is to enqueue your work. The simplest way to enqueue
   work is to call the WorkManager ``enqueue()`` method, passing the
   ``WorkRequest`` you want to run.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               val myWork: WorkRequest = // ... OneTime or PeriodicWork
               WorkManager.getInstance(requireContext()).enqueue(myWork)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               WorkRequest myWork = // ... OneTime or PeriodicWork
               WorkManager.getInstance(requireContext()).enqueue(myWork);

   Use caution when enqueuing work to avoid duplication. For example, an
   app might try to upload its logs to a backend service every 24 hours.
   If you aren't careful, you might end up enqueuing the same task many
   times, even though the job only needs to run once. To achieve this
   goal, you can schedule the work as `unique work <#unique-work>`__.

   .. rubric:: Unique Work
      :name: unique-work

   Unique work is a powerful concept that guarantees that you only have
   one instance of work with a particular *name* at a time. Unlike IDs,
   unique names are human-readable and specified by the developer
   instead of being auto-generated by WorkManager. Unlike
   `tags <#tag>`__,
   unique names are only associated with a single instance of work.

   Unique work can be applied to both one-time and periodic work. You
   can create a unique work sequence by calling one of these methods,
   depending on whether you‚Äôre scheduling repeating work or one time
   work.

   -  `WorkManager.enqueueUniqueWork() <#enqueueUniqueWork>`__
      for one time work
   -  `WorkManager.enqueueUniquePeriodicWork() <#enqueueUniquePeriodicWork>`__
      for periodic work

   Both of these methods accept 3 arguments:

   -  ``uniqueWorkName`` - A ``String`` used to uniquely identify the
      work request.
   -  ``existingWorkPolicy`` - An ``enum`` which tells WorkManager what
      to do if there's already an unfinished chain of work with that
      unique name. See `conflict resolution policy <#conflict-resolution>`__ for more information.
   -  ``work`` - the ``WorkRequest`` to schedule.

   Using unique work, we can fix our duplicate scheduling issue noted
   earlier.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               val sendLogsWorkRequest =
                      PeriodicWorkRequestBuilder<SendLogsWorker>(24, TimeUnit.HOURS)
                          .setConstraints(Constraints.Builder()
                              .setRequiresCharging(true)
                              .build()
                           )
                          .build()
               WorkManager.getInstance(this).enqueueUniquePeriodicWork(
                          "sendLogs",
                          ExistingPeriodicWorkPolicy.KEEP,
                          sendLogsWorkRequest
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               PeriodicWorkRequest sendLogsWorkRequest = new
                     PeriodicWorkRequest.Builder(SendLogsWorker.class, 24, TimeUnit.HOURS)
                             .setConstraints(new Constraints.Builder()
                             .setRequiresCharging(true)
                         .build()
                     )
                    .build();
               WorkManager.getInstance(this).enqueueUniquePeriodicWork(
                    "sendLogs",
                    ExistingPeriodicWorkPolicy.KEEP,
                    sendLogsWorkRequest);

   Now, if the code runs while a sendLogs job is already in the queue,
   the existing job is kept and no new job is added.

   Unique work sequences can also be useful if you need to gradually
   build up a long chain of tasks. For example, a photo editing app
   might let users undo a long chain of actions. Each of those undo
   operations might take a while, but they have to be performed in the
   correct order. In this case, the app could create an "undo" chain and
   append each undo operation to the chain as needed. See `Chaining work <#>`__
   for more details.

   .. rubric:: Conflict resolution policy
      :name: conflict-resolution

   When scheduling unique work, you must tell WorkManager what action to
   take when there is a conflict. You do this by passing an enum when
   enqueuing the work.

   For one-time work, you provide an
   `ExistingWorkPolicy <#>`__,
   which supports 4 options for handling the conflict.

   -  `REPLACE <#REPLACE>`__
      existing work with the new work. This option cancels the existing
      work.
   -  `KEEP <#KEEP>`__
      existing work and ignore the new work.
   -  `APPEND <#APPEND>`__
      the new work to the end of the existing work. This policy will
      cause your new work to be
      `chained <#>`__
      to the existing work, running after the existing work finishes.

   The existing work becomes a *prerequisite* to the new work. If the
   existing work becomes ``CANCELLED`` or ``FAILED``, the new work is
   also ``CANCELLED`` or ``FAILED``. If you want the new work to run
   regardless of the status of the existing work, use
   ``APPEND_OR_REPLACE`` instead.

   -  `APPEND_OR_REPLACE <#APPEND>`__
      functions similarly to ``APPEND``, except that it is not dependent
      on **prerequisite** work status. If the existing work is
      ``CANCELLED`` or ``FAILED``, the new work still runs.

   For period work, you provide an
   `ExistingPeriodicWorkPolicy <#>`__,
   which supports 2 options, ``REPLACE`` and ``KEEP``. These options
   function the same as their ExistingWorkPolicy counterparts.

   .. rubric:: Observing your work
      :name: observing

   At any point after enqueuing work, you can check its status by
   querying WorkManager by its ``name``, ``id`` or by a ``tag``
   associated with it.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               // by id
               workManager.getWorkInfoById(syncWorker.id) // ListenableFuture<WorkInfo>

               // by name
               workManager.getWorkInfosForUniqueWork("sync") // ListenableFuture<List<WorkInfo>>

               // by tag
               workManager.getWorkInfosByTag("syncTag") // ListenableFuture<List<WorkInfo>>

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               // by id
               workManager.getWorkInfoById(syncWorker.id); // ListenableFuture<WorkInfo>

               // by name
               workManager.getWorkInfosForUniqueWork("sync"); // ListenableFuture<List<WorkInfo>>

               // by tag
               workManager.getWorkInfosByTag("syncTag"); // ListenableFuture<List<WorkInfo>>

   The query returns a
   `ListenableFuture <https://guava.dev/releases/23.1-android/api/docs/com/google/common/util/concurrent/ListenableFuture.html>`__
   of a `WorkInfo <#>`__ object,
   which includes the
   `id <#getId>`__ of the work,
   its tags, its current
   `State <#>`__, and any
   output data set via
   `Result.success(outputData) <#success>`__.

   A `LiveData <#>`__ variant
   of each of the methods allows you to *observe changes to the
   ``WorkInfo``* by registering a listener. For example, if you wanted
   to display a message to the user when some work finishes
   successfully, you could set it up as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               workManager.getWorkInfoByIdLiveData(syncWorker.id)
                              .observe(viewLifecycleOwner) { workInfo ->
                  if(workInfo?.state == WorkInfo.State.SUCCEEDED) {
                      Snackbar.make(requireView(), 
                     R.string.work_completed, Snackbar.LENGTH_SHORT)
                          .show()
                  }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               workManager.getWorkInfoByIdLiveData(syncWorker.id)
                       .observe(getViewLifecycleOwner(), workInfo -> {
                   if (workInfo.getState() != null &&
                           workInfo.getState() == WorkInfo.State.SUCCEEDED) {
                       Snackbar.make(requireView(),
                                   R.string.work_completed, Snackbar.LENGTH_SHORT)
                               .show();
                  }
               });

   .. rubric:: Complex work queries
      :name: complex-queries

   WorkManager 2.4.0 and higher supports complex querying for enqueued
   jobs using `WorkQuery <#>`__
   objects. WorkQuery supports querying for work by a combination of
   it‚Äôs tag(s), state and unique work name.

   The following example shows how you can find all work with the tag,
   *‚ÄúsyncTag‚Äù*, that is in the ``FAILED`` or ``CANCELLED`` state and has
   a unique work name of either ‚Äú\ *preProcess*\ ‚Äù or ‚Äú\ *sync*\ ‚Äù.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               val workQuery = WorkQuery.Builder
                      .fromTags(listOf("syncTag"))
                      .addStates(listOf(WorkInfo.State.FAILED, WorkInfo.State.CANCELLED))
                      .addUniqueWorkNames(listOf("preProcess", "sync")
                   )
                  .build()

               val workInfos: ListenableFuture<List<WorkInfo>> = workManager.getWorkInfos(workQuery)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               WorkQuery workQuery = WorkQuery.Builder
                      .fromTags(Arrays.asList("syncTag"))
                      .addStates(Arrays.asList(WorkInfo.State.FAILED, WorkInfo.State.CANCELLED))
                      .addUniqueWorkNames(Arrays.asList("preProcess", "sync")
                    )
                   .build();

               ListenableFuture<List<WorkInfo>> workInfos = workManager.getWorkInfos(workQuery);

   Each component (tag, state, or name) in a ``WorkQuery`` is ``AND``-ed
   with the others. Each value in a component is ``OR``-ed. For example:
   ``(name1 OR name2 OR ...) AND (tag1 OR tag2 OR ...) AND (state1 OR state2 OR ...)``.

   ``WorkQuery`` also works with the LiveData equivalent,
   `getWorkInfosLiveData() <#getWorkInfosLiveData>`__.

   .. rubric:: Cancelling and stopping work
      :name: cancelling

   If you no longer need your previously enqueued work to run, you can
   ask for it to be cancelled. Work can be cancelled by its ``name``,
   ``id`` or by a ``tag`` associated with it.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               // by id
               workManager.cancelWorkById(syncWorker.id)

               // by name
               workManager.cancelUniqueWork("sync")

               // by tag
               workManager.cancelAllWorkByTag("syncTag")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               // by id
               workManager.cancelWorkById(syncWorker.id);

               // by name
               workManager.cancelUniqueWork("sync");

               // by tag
               workManager.cancelAllWorkByTag("syncTag");

   Under the hood, WorkManager checks the
   `State <#>`__ of the work.
   If the work is already
   `finished <#isFinished>`__,
   nothing happens. Otherwise, the work's state is changed to
   `CANCELLED <#CANCELLED>`__
   and the work will not run in the future. Any
   `WorkRequest <#>`__ jobs that
   are `dependent on this work <#>`__
   will also be ``CANCELLED``.

   Currently
   `RUNNING <#RUNNING>`__
   work receives a call to
   `ListenableWorker.onStopped() <#onStopped>`__.
   Override this method to handle any potential cleanup. See `stop a running worker <#stop-worker>`__ for more information.

   **Note:**\ 
   `cancelAllWorkByTag(String) <#cancelAllWorkByTag>`__
   cancels *all* work with the given tag.

   .. rubric:: Stop a running Worker
      :name: stop-worker

   There are a few different reasons your running ``Worker`` might be
   stopped by WorkManager:

   -  You explicitly asked for it to be cancelled (by calling
      ``WorkManager.cancelWorkById(UUID)``, for example).
   -  In the case of `unique work <#unique-work>`__, you explicitly
      enqueued a new ``WorkRequest`` with an
      `ExistingWorkPolicy <#>`__
      of
      `REPLACE <#REPLACE>`__.
      The old ``WorkRequest`` is immediately considered cancelled.
   -  Your work's constraints are no longer met.
   -  The system instructed your app to stop your work for some reason.
      This can happen if you exceed the execution deadline of 10
      minutes. The work is scheduled for retry at a later time.

   Under these conditions, your Worker is stopped.

   You should cooperatively abort any work you had in progress and
   release any resources your Worker is holding onto. For example, you
   should close open handles to databases and files at this point. There
   are two mechanisms at your disposal to understand when your Worker is
   stopping.

   .. rubric:: onStopped() callback
      :name: onstopped_callback

   WorkManager invokes
   `ListenableWorker.onStopped() <#onStopped>`__
   as soon as your Worker has been stopped. Override this method to
   close any resources you may be holding onto.

   .. rubric:: isStopped() property
      :name: isstopped_property

   You can call the
   `ListenableWorker.isStopped() <#isStopped>`__
   method to check if your worker has already been stopped. If you're
   performing long-running or repetitive operations in your Worker, you
   should check this property frequently and use it as a signal for
   stopping work as soon as possible.

   **Note:** WorkManager ignores the
   `Result <#>`__ set
   by a Worker that has received the onStop signal, because the Worker
   is already considered stopped.

Last updated 2024-01-03 UTC.


/Observe intermediate worker progress
=====================================

.. container:: devsite-article-body clearfix

   WorkManager has first-class support for setting and observing
   intermediate progress for workers. If the worker was running while
   the app was in the foreground, this information can also be shown to
   the user using APIs which return the
   `LiveData <#>`__ of
   `WorkInfo <#>`__.

   `ListenableWorker <#>`__
   now supports the
   `setProgressAsync() <#setProgressAsync>`__
   API, which allows it to persist intermediate progress. These APIs
   allow developers to set intermediate progress that can be observed by
   the UI. Progress is represented by the
   `Data <#>`__ type, which is a
   serializable container of properties (similar to `input`` and
   ``output </topic/libraries/architecture/workmanager/advanced#params>`__,
   and subject to the same restrictions).

   Progress information can only be observed and updated while the
   ``ListenableWorker`` is running. Attempts to set progress on a
   ``ListenableWorker`` after it has completed its execution are
   ignored. You can also observe progress information by using the one
   of the `getWorkInfoBy‚Ä¶()`` or
   ``getWorkInfoBy‚Ä¶LiveData() </reference/androidx/work/WorkManager#getWorkInfoById(java.util.UUID)>`__
   methods. These methods return instances of
   `WorkInfo <#>`__, which has a new
   `getProgress() <#getProgress>`__
   method that returns ``Data``.

   .. rubric:: Update Progress
      :name: update_progress

   For Java developers using a
   `ListenableWorker <#>`__
   or a `Worker <#>`__, the
   `setProgressAsync() <#setProgressAsync>`__
   API returns a ``ListenableFuture<Void>``; updating progress is
   asynchronous, given that the update process involves storing progress
   information in a database. In Kotlin, you can use the
   `CoroutineWorker <#>`__
   object's
   `setProgress() <#setprogress>`__
   extension function to update progress information.

   This example shows a simple ``ProgressWorker``. The ``Worker`` sets
   its progress to 0 when it starts, and upon completion updates the
   progress value to 100.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               import android.content.Context
               import androidx.work.CoroutineWorker
               import androidx.work.Data
               import androidx.work.WorkerParameters
               import kotlinx.coroutines.delay

               class ProgressWorker(context: Context, parameters: WorkerParameters) :
                   CoroutineWorker(context, parameters) {

                   companion object {
                       const val Progress = "Progress"
                       private const val delayDuration = 1L
                   }

                   override suspend fun doWork(): Result {
                       val firstUpdate = workDataOf(Progress to 0)
                       val lastUpdate = workDataOf(Progress to 100)
                       setProgress(firstUpdate)
                       delay(delayDuration)
                       setProgress(lastUpdate)
                       return Result.success()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import android.content.Context;
               import androidx.annotation.NonNull;
               import androidx.work.Data;
               import androidx.work.Worker;
               import androidx.work.WorkerParameters;

               public class ProgressWorker extends Worker {

                   private static final String PROGRESS = "PROGRESS";
                   private static final long DELAY = 1000L;

                   public ProgressWorker(
                       @NonNull Context context,
                       @NonNull WorkerParameters parameters) {
                       super(context, parameters);
                       // Set initial progress to 0
                       setProgressAsync(new Data.Builder().putInt(PROGRESS, 0).build());
                   }

                   @NonNull
                   @Override
                   public Result doWork() {
                       try {
                           // Doing work.
                           Thread.sleep(DELAY);
                       } catch (InterruptedException exception) {
                           // ... handle exception
                       }
                       // Set progress to 100 after you are done doing your work.
                       setProgressAsync(new Data.Builder().putInt(PROGRESS, 100).build());
                       return Result.success();
                   }
               }

   .. rubric:: Observing Progress
      :name: observing_progress

   Observing progress information is also simple. You can use the
   `getWorkInfoBy‚Ä¶()`` or
   ``getWorkInfoBy‚Ä¶LiveData() </reference/androidx/work/WorkManager#getWorkInfoById(java.util.UUID)>`__
   methods, and get a reference to
   `WorkInfo <#>`__.

   Here is an example which uses the ``getWorkInfoByIdLiveData`` API.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               WorkManager.getInstance(applicationContext)
                   // requestId is the WorkRequest id
                   .getWorkInfoByIdLiveData(requestId)
                   .observe(observer, Observer { workInfo: WorkInfo? ->
                           if (workInfo != null) {
                               val progress = workInfo.progress
                               val value = progress.getInt(Progress, 0)
                               // Do something with progress information
                           }
                   })

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               WorkManager.getInstance(getApplicationContext())
                    // requestId is the WorkRequest id
                    .getWorkInfoByIdLiveData(requestId)
                    .observe(lifecycleOwner, new Observer<WorkInfo>() {
                            @Override
                            public void onChanged(@Nullable WorkInfo workInfo) {
                                if (workInfo != null) {
                                    Data progress = workInfo.getProgress();
                                    int value = progress.getInt(PROGRESS, 0)
                                    // Do something with progress
                            }
                     }
               });

   For more documentation on observing ``Worker`` objects, read `Work States and observing work <#>`__.

Last updated 2024-01-03 UTC.



/Chaining work
==============

.. container:: devsite-article-body clearfix

   WorkManager allows you to create and enqueue a chain of work that
   specifies multiple dependent tasks and defines what order they should
   run in. This functionality is particularly useful when you need to
   run several tasks in a particular order.

   To create a chain of work, you can use
   `WorkManager.beginWith(OneTimeWorkRequest) <#beginWith>`__
   or
   `WorkManager.beginWith(List<#beginWith>`__
   , which each return an instance of
   `WorkContinuation <#>`__.

   A ``WorkContinuation`` can then be used to add dependent
   ``OneTimeWorkRequest`` instances using
   `then(OneTimeWorkRequest) <#then>`__
   or
   `then(List<#then>`__
   .

   Every invocation of the ``WorkContinuation.then(...)`` returns a
   *new* instance of ``WorkContinuation``. If you add a ``List`` of
   ``OneTimeWorkRequest`` instances, these requests can potentially run
   in parallel.

   Finally, you can use the
   `WorkContinuation.enqueue() <#enqueue>`__
   method to ``enqueue()`` your chain of ``WorkContinuation``\ s.

   Let's look at an example. In this example, 3 different Worker jobs
   are configured to run (potentially in parallel). The results of these
   Workers are then joined and passed on to a caching Worker job.
   Finally, the output of that job is passed into an upload Worker,
   which uploads the results to a remote server.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               WorkManager.getInstance(myContext)
                  // Candidates to run in parallel
                  .beginWith(listOf(plantName1, plantName2, plantName3))
                  // Dependent work (only runs after all previous work in chain)
                  .then(cache)
                  .then(upload)
                  // Call enqueue to kick things off
                  .enqueue()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               WorkManager.getInstance(myContext)
                  // Candidates to run in parallel
                  .beginWith(Arrays.asList(plantName1, plantName2, plantName3))
                  // Dependent work (only runs after all previous work in chain)
                  .then(cache)
                  .then(upload)
                  // Call enqueue to kick things off
                  .enqueue();

   .. rubric:: Input Mergers
      :name: input-mergers

   When you chain ``OneTimeWorkRequest`` instances, the output of parent
   work requests is passed in as input to the children. So in the above
   example, the outputs of ``plantName1``, ``plantName2``, and
   ``plantName3`` would be passed in as inputs to the ``cache`` request.

   In order to manage inputs from multiple parent work requests,
   WorkManager uses
   `InputMerger <#>`__.

   There are two different types of ``InputMerger`` provided by
   WorkManager:

   -  `OverwritingInputMerger <#>`__
      attempts to add all keys from all inputs to the output. In case of
      conflicts, it overwrites the previously-set keys.

   -  `ArrayCreatingInputMerger <#>`__
      attempts to merge the inputs, creating arrays when necessary.

   If you have a more specific use case, then you can write your own by
   subclassing ``InputMerger``.

   .. rubric:: OverwritingInputMerger
      :name: OverwritingInputMerger

   ``OverwritingInputMerger`` is the default merger method. If there are
   key conflicts in the merger, then the latest value for a key will
   overwrite any previous versions in the resulting output data.

   For example, if the plant inputs each have a key matching their
   respective variable names (``"plantName1"``, ``"plantName2"``, and
   ``"plantName3"``), then the data passed to the ``cache`` worker will
   have three key-value pairs.

   .. figure:: https://developer.android.google.cn/static/images/topic/libraries/architecture/workmanager/how-to/chaining-overwriting-merger-example.png
      :width: 500px

      Diagram showing three jobs passing different outputs to the next job
      in the chain. Since the three outputs all have different keys, the
      next job receives three key/value pairs.

   If there is a conflict, then the last worker to complete ‚Äúwins‚Äù, and
   its value is passed to ``cache``.

   .. figure:: https://developer.android.google.cn/static/images/topic/libraries/architecture/workmanager/how-to/chaining-overwriting-merger-conflict.png
      :width: 500px

      Diagram showing three jobs passing outputs to the next job in the
      chain. In this case, two of those jobs produce outputs with the same
      key. As a result, the next job receives two key/value pairs, with one
      of the conflicting outputs dropped.

   Because your work requests are run in parallel, you do not have
   guarantees for the order in which it runs. In the example above,
   ``plantName1`` could hold a value of either ``"tulip"`` or ``"elm"``,
   depending on which value is written last. If you have a chance of a
   key conflict and you need to preserve all output data in a merger,
   then ``ArrayCreatingInputMerger`` may be a better option.

   .. rubric:: ArrayCreatingInputMerger
      :name: ArrayCreatingInputMerger

   For the above example, given that we want to preserve the outputs
   from all plant name Workers, we should use an
   ``ArrayCreatingInputMerger``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               val cache: OneTimeWorkRequest = OneTimeWorkRequestBuilder<PlantWorker>()
                  .setInputMerger(ArrayCreatingInputMerger::class)
                  .setConstraints(constraints)
                  .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               OneTimeWorkRequest cache = new OneTimeWorkRequest.Builder(PlantWorker.class)
                      .setInputMerger(ArrayCreatingInputMerger.class)
                      .setConstraints(constraints)
                      .build();

   ``ArrayCreatingInputMerger`` pairs each key with an array. If each of
   the keys is unique, then your result is a series of one-element
   arrays.

   .. figure:: https://developer.android.google.cn/static/images/topic/libraries/architecture/workmanager/how-to/chaining-array-merger-example.png
      :width: 500px

      Diagram showing three jobs passing different outputs to the next job
      in the chain. The next job is passed three arrays, one for each of
      the output keys. Each array has a single member.

   If there are any key collisions, then any corresponding values are
   grouped together in an array.

   .. figure:: https://developer.android.google.cn/static/images/topic/libraries/architecture/workmanager/how-to/chaining-array-merger-conflict.png
      :width: 500px

      Diagram showing three jobs passing outputs to the next job in the
      chain. In this case, two of those jobs produce outputs with the same
      key. The next job is passed two arrays, one for each key. One of
      those arrays has two members, since there were two outputs with that
      key.

   .. rubric:: Chaining and Work Statuses
      :name: work-statuses

   Chains of ``OneTimeWorkRequest`` execute sequentially as long as
   their work completes successfully (that is, they return a
   ``Result.success()``). Work requests may fail or be cancelled while
   running, which has downstream effects on dependent work requests.

   When the first ``OneTimeWorkRequest`` is enqueued in a chain of work
   requests, all subsequent work requests are blocked until the work of
   that first work request is completed.

   ..  figure:: https://developer.android.google.cn/static/images/topic/libraries/architecture/workmanager/how-to/chaining-enqueued-all-blocked.png 
      :width: 500px

   Diagram showing a chain of jobs. The first job is enqueued; all
   successive jobs are blocked until the first one finishes.|

   Once enqueued and all work constraints are satisfied, the first work
   request begins running. If work is successfully completed in the root
   ``OneTimeWorkRequest`` or ``List<OneTimeWorkRequest>`` (that is, it
   returns a ``Result.success()``), then the next set of dependent work
   requests will be enqueued.

   ..  figure:: https://developer.android.google.cn/static/images/topic/libraries/architecture/workmanager/how-to/chaining-enqueued-in-progress.png 
      :width: 500px

   Diagram showing a chain of jobs. The first job has succeeded, and
   its two immediate successors are enqueued. The remaining jobs are
   blocked their preceding jobs finish.|

   As long as each work request completes successfully, this same
   pattern propagates through the rest of your chain of work requests
   until all work in the chain is completed. While that is the simplest
   and often preferred case, error states are just as important to
   handle.

   When an error occurs while a worker is processing your work request
   then you can retry that request according to a `backoff policy you define <#retries_backoff>`__.
   Retrying a request that is a part of a chain means that just that
   request will be retried with the input data provided to it. Any work
   running in parallel will be unaffected.

   ..  figure:: https://developer.android.google.cn/static/images/topic/libraries/architecture/workmanager/how-to/chaining-enqueued-retry.png 
      :width: 500px

      Diagram showing a chain of jobs. One of the jobs failed, but had a
      backoff policy defined. That job will rerun after the appropriate
      amount of time has passed. The jobs after it in the chain are blocked
      until it runs successfully.

   For more information on defining custom retry strategies, see `Retry and Backoff Policy <#retries_backoff>`__.

   If that retry policy is undefined or exhausted, or you otherwise
   reach some state in which a ``OneTimeWorkRequest`` returns
   ``Result.failure()``, then that work request and all dependent work
   requests are marked as ``FAILED.``

   ..  figure:: https://developer.android.google.cn/static/images/topic/libraries/architecture/workmanager/how-to/chaining-enqueued-failed.png 
      :width: 500px

      Diagram showing a chain of jobs. One job has failed and cannot be
      retried. As a result, all jobs after it in the chain also fail.

   The same logic applies when a ``OneTimeWorkRequest`` is cancelled.
   Any dependent work requests are also marked ``CANCELLED`` and their
   work will not be executed.

   ..  figure:: https://developer.android.google.cn/static/images/topic/libraries/architecture/workmanager/how-to/chaining-enqueued-cancelled.png 
      :width: 500px

      Diagram showing a chain of jobs. One job has been cancelled. As a
      result, all jobs after it in the chain are also cancelled.

   Note that if you were to append more work requests to a chain that
   has failed or has cancelled work requests, then your newly appended
   work request will also be marked ``FAILED`` or ``CANCELLED``,
   respectively. If you want to extend the work of an existing chain,
   see ``APPEND_OR_REPLACE`` in
   `ExistingWorkPolicy <#>`__.

   When creating chains of work requests, dependent work requests should
   define retry policies to ensure that work is always completed in a
   timely manner. Failed work requests could result in incomplete chains
   and/or unexpected state.

   For more information, see `Cancelling and Stopping Work <#>`__.

Last updated 2024-05-03 UTC.



/Testing Worker implementation
==============================

.. container:: devsite-article-body clearfix

   WorkManager provides APIs for testing
   `Worker <#>`__,
   `ListenableWorker <#>`__,
   and the ``ListenableWorker`` variants
   (`CoroutineWorker </reference/kotlin/androidx/work/CoroutineWorker>`__
   and `RxWorker <#>`__).

   .. rubric:: Testing Workers
      :name: testing-workers

   Let‚Äôs say we have a ``Worker`` which looks like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               class SleepWorker(context: Context, parameters: WorkerParameters) :
                   Worker(context, parameters) {

                   override fun doWork(): Result {
                       // Sleep on a background thread.
                       Thread.sleep(1000)
                       return Result.success()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               public class SleepWorker extends Worker {
                   public SleepWorker(
                           @NonNull Context context,
                           @NonNull WorkerParameters workerParameters) {
                       super(context, workerParameters);
                   }

                   @NonNull
                   @Override
                   public Result doWork() {
                       try {
                           Thread.sleep(1000);
                       } catch (InterruptedException ignore) {
               return Result.success();
                       }
                   }
               }

   To test this ``Worker``, you can use
   `TestWorkerBuilder <#>`__.
   This builder helps build instances of ``Worker`` that can be used for
   the purpose of testing business logic.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               // Kotlin code uses the TestWorkerBuilder extension to build
               // the Worker
               @RunWith(AndroidJUnit4::class)
               class SleepWorkerTest {
                   private lateinit var context: Context
                   private lateinit var executor: Executor

                   @Before
                   fun setUp() {
                       context = ApplicationProvider.getApplicationContext()
                       executor = Executors.newSingleThreadExecutor()
                   }

                   @Test
                   fun testSleepWorker() {
                       val worker = TestWorkerBuilder<SleepWorker>(
                           context = context,
                           executor = executor
                       ).build()

                       val result = worker.doWork()
                       assertThat(result, `is`(Result.success()))
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               @RunWith(AndroidJUnit4.class)
               public class SleepWorkerJavaTest {
                   private Context context;
                   private Executor executor;

                   @Before
                   public void setUp() {
                       context = ApplicationProvider.getApplicationContext();
                       executor = Executors.newSingleThreadExecutor();
                   }

                   @Test
                   public void testSleepWorker() {
                       SleepWorker worker =
                               (SleepWorker) TestWorkerBuilder.from(context,
                                       SleepWorker.class,
                                       executor)
                                       .build();

                       Result result = worker.doWork();
                       assertThat(result, is(Result.success()));
                   }
               }

   ``TestWorkerBuilder`` can also be used to set tags, such as
   ``inputData`` or ``runAttemptCount``, so that you can verify worker
   state in isolation. Consider an example in which ``SleepWorker``
   takes in a sleep duration as input data rather than it being a
   constant defined in the worker:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               class SleepWorker(context: Context, parameters: WorkerParameters) :
                   Worker(context, parameters) {

                   override fun doWork(): Result {
                       // Sleep on a background thread.
                       val sleepDuration = inputData.getLong(SLEEP_DURATION, 1000)
                       Thread.sleep(sleepDuration)
                       return Result.success()
                   }

                   companion object {
                       const val SLEEP_DURATION = "SLEEP_DURATION"
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               public class SleepWorker extends Worker {
                   public static final String SLEEP_DURATION = "SLEEP_DURATION";

                   public SleepWorker(
                           @NonNull Context context,
                           @NonNull WorkerParameters workerParameters) {
                       super(context, workerParameters);
                   }

                   @NonNull
                   @Override
                   public Result doWork() {
                       try {
                           long duration = getInputData().getLong(SLEEP_DURATION, 1000);
                           Thread.sleep(duration);
                       } catch (InterruptedException ignore) {
                      return Result.success();
                       }
                   }
               }

   In ``SleepWorkerTest``, you can provide that input data to your
   ``TestWorkerBuilder`` to satisfy the needs of ``SleepWorker``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               // Kotlin code uses the TestWorkerBuilder extension to build
               // the Worker
               @RunWith(AndroidJUnit4::class)
               class SleepWorkerTest {
                   private lateinit var context: Context
                   private lateinit var executor: Executor

                   @Before
                   fun setUp() {
                       context = ApplicationProvider.getApplicationContext()
                       executor = Executors.newSingleThreadExecutor()
                   }

                   @Test
                   fun testSleepWorker() {
                       val worker = TestWorkerBuilder<SleepWorker>(
                           context = context,
                           executor = executor,
                           inputData = workDataOf("SLEEP_DURATION" to 1000L)
                       ).build()

                       val result = worker.doWork()
                       assertThat(result, `is`(Result.success()))
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               @RunWith(AndroidJUnit4.class)
               public class SleepWorkerJavaTest {
                   private Context context;
                   private Executor executor;

                   @Before
                   public void setUp() {
                       context = ApplicationProvider.getApplicationContext();
                       executor = Executors.newSingleThreadExecutor();
                   }

                   @Test
                   public void testSleepWorker() {
                       Data inputData = new Data.Builder()
                               .putLong("SLEEP_DURATION", 1000L)
                               .build();

                       SleepWorker worker =
                               (SleepWorker) TestWorkerBuilder.from(context,
                                       SleepWorker.class, executor)
                                       .setInputData(inputData)
                                       .build();

                       Result result = worker.doWork();
                       assertThat(result, is(Result.success()));
                   }
               }

   For more details on the ``TestWorkerBuilder`` API, see the reference
   page for
   `TestListenableWorkerBuilder <#>`__,
   the superclass of ``TestWorkerBuilder``.

   .. rubric:: Testing ListenableWorker and its variants
      :name: testing-listenableworker-and-its-variants

   To test a
   `ListenableWorker <#>`__
   or its variants
   (`CoroutineWorker </reference/kotlin/androidx/work/CoroutineWorker>`__
   and `RxWorker <#>`__), use
   `TestListenableWorkerBuilder <#>`__.
   The main difference between ``TestWorkerBuilder`` and a
   `TestListenableWorkerBuilder <#>`__
   is that ``TestWorkerBuilder`` lets you specify the background
   ``Executor`` used to run the ``Worker``, whereas
   ``TestListenableWorkerBuilder`` relies on the threading logic of the
   ``ListenableWorker`` implementation.

   For example, suppose we need to test a ``CoroutineWorker`` which
   looks like this:

   .. code:: prettyprint

      class SleepWorker(context: Context, parameters: WorkerParameters) :
          CoroutineWorker(context, parameters) {
          override suspend fun doWork(): Result {
              delay(1000L) // milliseconds
              return Result.success()
          }
      }

   To test ``SleepWorker``, we first create an instance of the Worker
   using ``TestListenableWorkerBuilder`` and then call its ``doWork``
   function within a coroutine.

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class SleepWorkerTest {
          private lateinit var context: Context

          @Before
          fun setUp() {
              context = ApplicationProvider.getApplicationContext()
          }

          @Test
          fun testSleepWorker() {
              val worker = TestListenableWorkerBuilder<SleepWorker>(context).build()
              runBlocking {
                  val result = worker.doWork()
                  assertThat(result, `is`(Result.success()))
              }
          }
      }

   ``runBlocking`` makes sense as a coroutine builder for your tests so
   that any code that would execute asynchronously is instead run in
   parallel.

   Testing an ``RxWorker`` implementation is similar to testing
   ``CoroutineWorker``, as ``TestListenableWorkerBuilder`` can handle
   any subclass of ``ListenableWorker``. Consider a version of
   ``SleepWorker`` that uses RxJava instead of coroutines.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               class SleepWorker(
                   context: Context,
                   parameters: WorkerParameters
               ) : RxWorker(context, parameters) {
                   override fun createWork(): Single<Result> {
                       return Single.just(Result.success())
                           .delay(1000L, TimeUnit.MILLISECONDS)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               public class SleepWorker extends RxWorker {
                   public SleepWorker(@NonNull Context appContext, 
               @NonNull WorkerParameters workerParams) {
                       super(appContext, workerParams);
                   }

                   @NonNull
                   @Override
                   public Single<Result> createWork() {
                       return Single.just(Result.success())
                               .delay(1000L, TimeUnit.MILLISECONDS);
                   }
               }

   A version of ``SleepWorkerTest`` that tests an ``RxWorker`` may look
   similar to the version that tested a ``CoroutineWorker``. You use the
   same ``TestListenableWorkerBuilder`` but now call into
   ``RxWorker``\ ‚Äôs ``createWork`` function. ``createWork`` returns a
   ``Single`` that you can use to verify the behavior of your worker.
   ``TestListenableWorkerBuilder`` handles any threading complexities
   and executes your worker code in parallel.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               @RunWith(AndroidJUnit4::class)
               class SleepWorkerTest {
                   private lateinit var context: Context

                   @Before
                   fun setUp() {
                       context = ApplicationProvider.getApplicationContext()
                   }

                   @Test
                   fun testSleepWorker() {
                       val worker = TestListenableWorkerBuilder<SleepWorker>(context).build()
                       worker.createWork().subscribe { result ->
                           assertThat(result, `is`(Result.success()))
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               @RunWith(AndroidJUnit4.class)
               public class SleepWorkerTest {
                   private Context context;

                   @Before
                   public void setUp() {
                       context = ApplicationProvider.getApplicationContext();
                   }

                   @Test
                   public void testSleepWorker() {
                       SleepWorker worker = TestListenableWorkerBuilder.from(context, SleepWorker.class)
                               .build();
                       worker.createWork().subscribe(result ->
                               assertThat(result, is(Result.success())));
                       }
               }

Last updated 2024-01-03 UTC.


/Integration tests with WorkManager
===================================

.. container:: devsite-article-body clearfix

   `WorkManager <#>`__ provides
   a ``work-testing`` artifact which helps with testing of your workers.

   .. rubric:: Setup
      :name: intro

   To use the ``work-testing`` artifact, add it as an
   ``androidTestImplementation`` dependency in ``build.gradle``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   def work_version = "2.5.0"

                   ...

                   // optional - Test helpers
                   androidTestImplementation "androidx.work:work-testing:$work_version"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   val work_version = "2.4.0"

                   ...

                   // optional - Test helpers
                   androidTestImplementation("androidx.work:work-testing:$work_version")
               }

   For more information on adding dependencies, look at the Declaring
   dependencies section in the `WorkManager release notes <#declaring_dependencies>`__.

   **Note:**\  Beginning with 2.1.0, WorkManager provides the
   `TestWorkerBuilder <#>`__
   and
   `TestListenableWorkerBuilder <#>`__
   classes, which let you test the business logic in your workers
   without having to initialize ``WorkManager`` with
   ``WorkManagerTestInitHelper``. `Testing Worker implementation <#>`__
   covers these classes. The material in this page is still useful for
   when you need to perform integration tests.
   **Note:**\  It is highly recommended to use
   `TestListenableWorkerBuilder <#>`__
   to test
   `CoroutineWorker <#>`__
   implementations, as the ``work-testing`` artifact uses
   `Dispatchers.Default <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html>`__
   rather than your worker implementation‚Äôs
   `CoroutineDispatcher <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/>`__.
   More information about this API can be found at `Testing Worker implementation <#testing_listenableworker_and_its_variants>`__.

   .. rubric:: Concepts
      :name: concepts

   ``work-testing`` provides a special implementation of WorkManager for
   test mode, which is initialized using
   `WorkManagerTestInitHelper <#>`__.

   The ``work-testing`` artifact also provides a
   `SynchronousExecutor <#>`__
   which makes it easier to write tests in a synchronous manner, without
   having to deal with multiple threads, locks, or latches.

   Here is an example on how to use all these classes together.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               @RunWith(AndroidJUnit4::class)
               class BasicInstrumentationTest {
                   @Before
                   fun setup() {
                       val context = InstrumentationRegistry.getTargetContext()
                       val config = Configuration.Builder()
                           .setMinimumLoggingLevel(Log.DEBUG)
                           .setExecutor(SynchronousExecutor())
                           .build()

                       // Initialize WorkManager for instrumentation tests.
                       WorkManagerTestInitHelper.initializeTestWorkManager(context, config)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               @RunWith(AndroidJUnit4.class)
               public class BasicInstrumentationTest {
                   @Before
                   public void setup() {
                       Context context = InstrumentationRegistry.getTargetContext();
                       Configuration config = new Configuration.Builder()
                               .setMinimumLoggingLevel(Log.DEBUG)
                               .setExecutor(new SynchronousExecutor())
                               .build();

                       // Initialize WorkManager for instrumentation tests.
                       WorkManagerTestInitHelper.initializeTestWorkManager(
                           context, config);
                   }
               }

   .. rubric:: Structuring Tests
      :name: structure

   Now that WorkManager has been initialized in test mode, you are ready
   to test your workers.

   Let‚Äôs say you have an ``EchoWorker`` which expects some
   ``inputData``, and simply copies (echoes) its input to
   ``outputData``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               class EchoWorker(context: Context, parameters: WorkerParameters)
                  : Worker(context, parameters) {
                  override fun doWork(): Result {
                      return when(inputData.size()) {
                          0 -> Result.failure()
                          else -> Result.success(inputData)
                      }
                  }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               public class EchoWorker extends Worker {
                 public EchoWorker(Context context, WorkerParameters parameters) {
                     super(context, parameters);
                 }

                 @NonNull
                 @Override
                 public Result doWork() {
                     Data input = getInputData();
                     if (input.size() == 0) {
                         return Result.failure();
                     } else {
                         return Result.success(input);
                     }
                 }
               }

   .. rubric:: Basic Tests
      :name: basics

   Below is an Android Instrumentation test that tests ``EchoWorker``.
   The main takeaway here is that testing ``EchoWorker`` in test mode is
   very similar to how you would use ``EchoWorker`` in a real
   application.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               @Test
               @Throws(Exception::class)
               fun testSimpleEchoWorker() {
                   // Define input data
                   val input = workDataOf(KEY_1 to 1, KEY_2 to 2)

                   // Create request
                   val request = OneTimeWorkRequestBuilder<EchoWorker>()
                       .setInputData(input)
                       .build()

                   val workManager = WorkManager.getInstance(applicationContext)
                   // Enqueue and wait for result. This also runs the Worker synchronously
                   // because we are using a SynchronousExecutor.
                   workManager.enqueue(request).result.get()
                   // Get WorkInfo and outputData
                   val workInfo = workManager.getWorkInfoById(request.id).get()
                   val outputData = workInfo.outputData

                   // Assert
                   assertThat(workInfo.state, `is`(WorkInfo.State.SUCCEEDED))
                   assertThat(outputData, `is`(input))
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               @Test
               public void testSimpleEchoWorker() throws Exception {
                  // Define input data
                  Data input = new Data.Builder()
                          .put(KEY_1, 1)
                          .put(KEY_2, 2)
                          .build();

                  // Create request
                  OneTimeWorkRequest request =
                      new OneTimeWorkRequest.Builder(EchoWorker.class)
                          .setInputData(input)
                          .build();

                  WorkManager workManager = WorkManager.getInstance(getApplicationContext());
                  // Enqueue and wait for result. This also runs the Worker synchronously
                  // because we are using a SynchronousExecutor.
                  workManager.enqueue(request).getResult().get();
                  // Get WorkInfo and outputData
                  WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
                  Data outputData = workInfo.getOutputData();

                  // Assert
                  assertThat(workInfo.getState(), is(WorkInfo.State.SUCCEEDED));
                  assertThat(outputData, is(input));
               }

   Let‚Äôs write another test which makes sure that when ``EchoWorker``
   gets no input data, the expected ``Result`` is a
   ``Result.failure()``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               @Test
               @Throws(Exception::class)
               fun testEchoWorkerNoInput() {
                  // Create request
                  val request = OneTimeWorkRequestBuilder<EchoWorker>()
                      .build()

                  val workManager = WorkManager.getInstance(applicationContext)
                  // Enqueue and wait for result. This also runs the Worker synchronously
                  // because we are using a SynchronousExecutor.
                  workManager.enqueue(request).result.get()
                  // Get WorkInfo
                  val workInfo = workManager.getWorkInfoById(request.id).get()

                  // Assert
                  assertThat(workInfo.state, `is`(WorkInfo.State.FAILED))
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               @Test
               public void testEchoWorkerNoInput() throws Exception {
                 // Create request
                 OneTimeWorkRequest request =
                     new OneTimeWorkRequest.Builder(EchoWorker.class)
                        .build();

                 WorkManager workManager = WorkManager.getInstance(getApplicationContext());
                 // Enqueue and wait for result. This also runs the Worker synchronously
                 // because we are using a SynchronousExecutor.
                 workManager.enqueue(request).getResult().get();
                 // Get WorkInfo
                 WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();

                 // Assert
                 assertThat(workInfo.getState(), is(WorkInfo.State.FAILED));
               }

   .. rubric:: Simulate constraints, delays, and periodic work
      :name: simulation

   ``WorkManagerTestInitHelper`` provides you with an instance of
   `TestDriver <#>`__
   which can be used to simulate initial delay, conditions where
   constraints are met for ``ListenableWorker`` instances, and,
   intervals for ``PeriodicWorkRequest`` instances.

   .. rubric:: Test Initial Delays
      :name: initial-delays

   Workers can have initial delays. To test ``EchoWorker`` with an
   ``initialDelay``, rather than having to wait for the ``initialDelay``
   in your test, you can use the ``TestDriver`` to mark the work
   request‚Äôs initial delay as met using ``setInitialDelayMet``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               @Test
               @Throws(Exception::class)
               fun testWithInitialDelay() {
                   // Define input data
                   val input = workDataOf(KEY_1 to 1, KEY_2 to 2)

                   // Create request
                   val request = OneTimeWorkRequestBuilder<EchoWorker>()
                       .setInputData(input)
                       .setInitialDelay(10, TimeUnit.SECONDS)
                       .build()

                   val workManager = WorkManager.getInstance(getApplicationContext())
                   // Get the TestDriver
                   val testDriver = WorkManagerTestInitHelper.getTestDriver()
                   // Enqueue
                   workManager.enqueue(request).result.get()
                   // Tells the WorkManager test framework that initial delays are now met.
                   testDriver.setInitialDelayMet(request.id)
                   // Get WorkInfo and outputData
                   val workInfo = workManager.getWorkInfoById(request.id).get()
                   val outputData = workInfo.outputData

                   // Assert
                   assertThat(workInfo.state, `is`(WorkInfo.State.SUCCEEDED))
                   assertThat(outputData, `is`(input))
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               @Test
               public void testWithInitialDelay() throws Exception {
                 // Define input data
                 Data input = new Data.Builder()
                         .put(KEY_1, 1)
                         .put(KEY_2, 2)
                         .build();

                 // Create request
                 OneTimeWorkRequest request = new OneTimeWorkRequest.Builder(EchoWorker.class)
                         .setInputData(input)
                         .setInitialDelay(10, TimeUnit.SECONDS)
                         .build();

                 WorkManager workManager = WorkManager.getInstance(myContext);
                 // Get the TestDriver
                 TestDriver testDriver = WorkManagerTestInitHelper.getTestDriver();
                 // Enqueue
                 workManager.enqueue(request).getResult().get();
                 // Tells the WorkManager test framework that initial delays are now met.
                 testDriver.setInitialDelayMet(request.getId());
                 // Get WorkInfo and outputData
                 WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
                 Data outputData = workInfo.getOutputData();

                 // Assert
                 assertThat(workInfo.getState(), is(WorkInfo.State.SUCCEEDED));
                 assertThat(outputData, is(input));
               }

   .. rubric:: Testing Constraints
      :name: constraints

   ``TestDriver`` can also be used to mark constraints as met using
   ``setAllConstraintsMet``. Here is an example on how you can test a
   ``Worker`` with constraints.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               @Test
               @Throws(Exception::class)
               fun testWithConstraints() {
                   // Define input data
                   val input = workDataOf(KEY_1 to 1, KEY_2 to 2)

                   val constraints = Constraints.Builder()
                       .setRequiredNetworkType(NetworkType.CONNECTED)
                       .build()

                   // Create request
                   val request = OneTimeWorkRequestBuilder<EchoWorker>()
                       .setInputData(input)
                       .setConstraints(constraints)
                       .build()

                   val workManager = WorkManager.getInstance(myContext)
                   val testDriver = WorkManagerTestInitHelper.getTestDriver()
                   // Enqueue
                   workManager.enqueue(request).result.get()
                   // Tells the testing framework that all constraints are met.
                   testDriver.setAllConstraintsMet(request.id)
                   // Get WorkInfo and outputData
                   val workInfo = workManager.getWorkInfoById(request.id).get()
                   val outputData = workInfo.outputData

                   // Assert
                   assertThat(workInfo.state, `is`(WorkInfo.State.SUCCEEDED))
                   assertThat(outputData, `is`(input))
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               @Test
               public void testWithConstraints() throws Exception {
                   // Define input data
                   Data input = new Data.Builder()
                           .put(KEY_1, 1)
                           .put(KEY_2, 2)
                           .build();

                   // Define constraints
                   Constraints constraints = new Constraints.Builder()
                           .setRequiresDeviceIdle(true)
                           .build();

                   // Create request
                   OneTimeWorkRequest request = new OneTimeWorkRequest.Builder(EchoWorker.class)
                           .setInputData(input)
                           .setConstraints(constraints)
                           .build();

                   WorkManager workManager = WorkManager.getInstance(myContext);
                   TestDriver testDriver = WorkManagerTestInitHelper.getTestDriver();
                   // Enqueue
                   workManager.enqueue(request).getResult().get();
                   // Tells the testing framework that all constraints are met.
                   testDriver.setAllConstraintsMet(request.getId());
                   // Get WorkInfo and outputData
                   WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
                   Data outputData = workInfo.getOutputData();

                   // Assert
                   assertThat(workInfo.getState(), is(WorkInfo.State.SUCCEEDED));
                   assertThat(outputData, is(input));
               }

   .. rubric:: Testing Periodic Work
      :name: periodic-work

   The ``TestDriver`` also exposes a ``setPeriodDelayMet`` which can be
   used to indicate that an interval is complete. Here is an example of
   ``setPeriodDelayMet`` being used.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               @Test
               @Throws(Exception::class)
               fun testPeriodicWork() {
                   // Define input data
                   val input = workDataOf(KEY_1 to 1, KEY_2 to 2)

                   // Create request
                   val request = PeriodicWorkRequestBuilder<EchoWorker>(15, MINUTES)
                       .setInputData(input)
                       .build()

                   val workManager = WorkManager.getInstance(myContext)
                   val testDriver = WorkManagerTestInitHelper.getTestDriver()
                   // Enqueue and wait for result.
                   workManager.enqueue(request).result.get()
                   // Tells the testing framework the period delay is met
                   testDriver.setPeriodDelayMet(request.id)
                   // Get WorkInfo and outputData
                   val workInfo = workManager.getWorkInfoById(request.id).get()

                   // Assert
                   assertThat(workInfo.state, `is`(WorkInfo.State.ENQUEUED))
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               @Test
               public void testPeriodicWork() throws Exception {
                   // Define input data
                   Data input = new Data.Builder()
                           .put(KEY_1, 1)
                           .put(KEY_2, 2)
                           .build();

                   // Create request
                   PeriodicWorkRequest request =
                           new PeriodicWorkRequest.Builder(EchoWorker.class, 15, MINUTES)
                           .setInputData(input)
                           .build();

                   WorkManager workManager = WorkManager.getInstance(myContext);
                   TestDriver testDriver = WorkManagerTestInitHelper.getTestDriver();
                   // Enqueue and wait for result.
                   workManager.enqueue(request).getResult().get();
                   // Tells the testing framework the period delay is met
                   testDriver.setPeriodDelayMet(request.getId());
                   // Get WorkInfo and outputData
                   WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();

                   // Assert
                   assertThat(workInfo.getState(), is(WorkInfo.State.ENQUEUED));
               }

Last updated 2024-01-03 UTC.



/Debug WorkManager
==================

.. container:: devsite-article-body clearfix

   If you notice that your workers run too often or not at all, here are
   some debugging steps that can help you discover what is happening.

   .. rubric:: Enable logging
      :name: enable-logging

   To determine why your workers aren't running properly, it can be very
   useful to look at *verbose* WorkManager logs. To enable logging, use
   `custom initialization <#>`__.

   First, disable the default ``WorkManagerInitializer`` in your
   ``AndroidManifest.xml`` file by creating a new WorkManager provider
   with the manifest-merge rule **``remove``** applied:

   .. code:: prettyprint

      <provider
          android:name="androidx.work.impl.WorkManagerInitializer"
          android:authorities="${applicationId}.workmanager-init"
          tools:node="remove"/>

   Now that the default WorkManager initializer is disabled, you can use
   `on-demand initialization <#on-demand>`__.
   To do so, the ``android.app.Application`` class needs to provide an
   implementation for ``androidx.work.Configuration.Provider``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyApplication() : Application(), Configuration.Provider {
                   override fun getWorkManagerConfiguration() =
                       Configuration.Builder()
                           .setMinimumLoggingLevel(android.util.Log.DEBUG)
                           .build()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyApplication extends Application implements Configuration.Provider {
                   @NonNull
                   @Override
                   public Configuration getWorkManagerConfiguration() {
                       return new Configuration.Builder()
                               .setMinimumLoggingLevel(android.util.Log.DEBUG)
                               .build();
                   }
               }

   When you define a custom WorkManager configuration, your WorkManager
   is initialized when you call
   `WorkManager.getInstance(Context) <#getInstance>`__
   rather than automatically at application startup. See `Custom WorkManager Configuration and Initialization <#>`__
   for more information, including support for versions of WorkManager
   before 2.1.0.

   With `DEBUG <#DEBUG>`__ logging
   enabled, you see a lot more logs with the log-tag prefix ``WM-``.

   .. rubric:: Use adb shell dumpsys jobscheduler
      :name: use-alb-shell0dumpsys-jobscheduler

   You can use ``adb`` to get more information about job scheduling on
   Android 6.0 (API level 23) or higher. If you are new to ``adb``, see
   `Command-line tools <https://developer.android.google.cn/studio/command-line>`__
   for more details.

   Once you have ``adb`` installed, run the following command to look at
   the list of jobs that are attributed to your package:

   .. code:: prettyprint

      adb shell dumpsys jobscheduler

   The output looks something like this:

   .. code:: prettyprint

      JOB #u0a172/4: 6412553 com.google.android.youtube/androidx.work.impl.background.systemjob.SystemJobService
        u0a172 tag=*job*/com.google.android.youtube/androidx.work.impl.background.systemjob.SystemJobService
        Source: uid=u0a172 user=0 pkg=com.google.android.youtube
        JobInfo:
          Service: com.google.android.youtube/androidx.work.impl.background.systemjob.SystemJobService
          Requires: charging=false batteryNotLow=false deviceIdle=false
          Extras: mParcelledData.dataSize=180
          Network type: NetworkRequest [ NONE id=0, [ Capabilities: NOT_METERED&INTERNET&NOT_RESTRICTED&TRUSTED&VALIDATED Uid: 10172] ]
          Minimum latency: +1h29m59s687ms
          Backoff: policy=1 initial=+30s0ms
          Has early constraint
        Required constraints: TIMING_DELAY CONNECTIVITY [0x90000000]
        Satisfied constraints: DEVICE_NOT_DOZING BACKGROUND_NOT_RESTRICTED WITHIN_QUOTA [0x3400000]
        Unsatisfied constraints: TIMING_DELAY CONNECTIVITY [0x90000000]
        Tracking: CONNECTIVITY TIME QUOTA
        Implicit constraints:
          readyNotDozing: true
          readyNotRestrictedInBg: true
        Standby bucket: RARE
        Base heartbeat: 0
        Enqueue time: -51m29s853ms
        Run time: earliest=+38m29s834ms, latest=none, original latest=none
        Last run heartbeat: 0
        Ready: false (job=false user=true !pending=true !active=true !backingup=true comp=true)

   When using WorkManager, the component responsible for managing worker
   execution is ``SystemJobService`` on API level 23 or higher. Look for
   instances of jobs that are attributed to your package name and
   ``androidx.work.impl.background.systemjob.SystemJobService``.

   For every job, the output from the command lists **required**,
   **satisfied**, and **unsatisfied** constraints. Check whether your
   worker‚Äôs constraints are fully satisfied.

   The output also includes job history for recently executed jobs, so
   you can use it to check whether ``SystemJobService`` was invoked
   recently.

   .. code:: prettyprint

      Job history:
           -1h35m26s440ms   START: #u0a107/9008 com.google.android.youtube/androidx.work.impl.background.systemjob.SystemJobService
           -1h35m26s362ms  STOP-P: #u0a107/9008 com.google.android.youtube/androidx.work.impl.background.systemjob.SystemJobService app called jobFinished

   .. rubric:: Request diagnostic information from WorkManager 2.4.0+
      :name: request-diagnostic-information-from-workmanager-2.4.0

   On debug builds of your app, you can request diagnostic information
   from WorkManager 2.4.0 and higher using the following command:

   .. code:: prettyprint

      adb shell am broadcast -a "androidx.work.diagnostics.REQUEST_DIAGNOSTICS" -p "<your_app_package_name>"

   This provides information on:

   -  Work requests that completed in the last 24 hours.
   -  Work requests that are currently running.
   -  Work requests that are scheduled.

   Here is what it could look like (the output is visible through
   ``logcat``):

   .. code:: prettyprint

      adb shell am broadcast -a "androidx.work.diagnostics.REQUEST_DIAGNOSTICS" -p "androidx.work.integration.testapp"

      adb logcat
      ...
      2020-02-13 14:21:37.990 29528-29660/androidx.work.integration.testapp I/WM-DiagnosticsWrkr: Recently completed work:
      2020-02-13 14:21:38.083 29528-29660/androidx.work.integration.testapp I/WM-DiagnosticsWrkr: Id  Class Name   State  Unique Name Tags
          08be261c-2def-4bd6-a716-1e4410968dc4     androidx.work.impl.workers.DiagnosticsWorker    SUCCEEDED  null    androidx.work.impl.workers.DiagnosticsWorker
          48ce04f1-8df9-450b-96ec-6eceabb9c690     androidx.work.impl.workers.DiagnosticsWorker    SUCCEEDED  null    androidx.work.impl.workers.DiagnosticsWorker
          c46f4699-c384-440c-a10e-26d56ce02963     androidx.work.impl.workers.DiagnosticsWorker    SUCCEEDED  null    androidx.work.impl.workers.DiagnosticsWorker
          ce125372-046e-484e-949f-9abb35ce62c3     androidx.work.impl.workers.DiagnosticsWorker    SUCCEEDED  null    androidx.work.impl.workers.DiagnosticsWorker
          72887ddd-8ed1-4018-b798-fac218e95e16     androidx.work.impl.workers.DiagnosticsWorker    SUCCEEDED  null    androidx.work.impl.workers.DiagnosticsWorker
          dcff3d61-320d-4996-8644-5d97944bd09c     androidx.work.impl.workers.DiagnosticsWorker    SUCCEEDED  null    androidx.work.impl.workers.DiagnosticsWorker
          acab0bf7-6087-43ad-bdb5-be0df9195acb     androidx.work.impl.workers.DiagnosticsWorker    SUCCEEDED  null    androidx.work.impl.workers.DiagnosticsWorker
          23136bcd-01dd-46eb-b910-0fe8a140c2a4     androidx.work.integration.testapp.ToastWorker   SUCCEEDED  null    androidx.work.integration.testapp.ToastWorker
          245f4879-c6d2-4997-8130-e4e90e1cab4c     androidx.work.integration.testapp.ToastWorker   SUCCEEDED  null    androidx.work.integration.testapp.ToastWorker
          17d05835-bb61-429a-ad11-fe43fc320a54     androidx.work.integration.testapp.ToastWorker   SUCCEEDED  null    androidx.work.integration.testapp.ToastWorker
          e95f12be-4b0c-4e64-88da-8ee07a31e42f     androidx.work.integration.testapp.ToastWorker   SUCCEEDED  null    androidx.work.integration.testapp.ToastWorker
          431c3ec2-4a55-469b-b50b-4072d35f1232     androidx.work.integration.testapp.ToastWorker   SUCCEEDED  null    androidx.work.integration.testapp.ToastWorker
          883a388f-f911-4098-9143-37bd8fbc098a     androidx.work.integration.testapp.ToastWorker   SUCCEEDED  null    androidx.work.integration.testapp.ToastWorker
          b904163c-6822-4299-8d5a-78df49b7e53d     androidx.work.integration.testapp.ToastWorker   SUCCEEDED  null    androidx.work.integration.testapp.ToastWorker
          453fd7b9-2b16-45b9-abc5-3d2ce7b6a4ba     androidx.work.integration.testapp.ToastWorker   SUCCEEDED  null    androidx.work.integration.testapp.ToastWorker
      2020-02-13 14:21:38.083 29528-29660/androidx.work.integration.testapp I/WM-DiagnosticsWrkr: Running work:
      2020-02-13 14:21:38.089 29528-29660/androidx.work.integration.testapp I/WM-DiagnosticsWrkr: Id  Class Name   State  Unique Name Tags
          b87c8a4f-4ac6-4e25-ba3e-4cea53ce468a     androidx.work.impl.workers.DiagnosticsWorker    RUNNING    null    androidx.work.impl.workers.DiagnosticsWorker
      ...

Last updated 2024-01-03 UTC.


/Custom WorkManager Configuration and Initialization
====================================================

.. container:: devsite-article-body clearfix

   By default, WorkManager configures itself automatically when your app
   starts, using reasonable options that are suitable for most apps. If
   you require more control of how WorkManager manages and schedules
   work, you can customize the WorkManager configuration by initializing
   WorkManager yourself.

   .. rubric:: On-Demand Initialization
      :name: on-demand

   On-demand initialization lets you create WorkManager only when that
   component is needed, instead of every time the app starts up. Doing
   so moves WorkManager off your critical startup path, improving app
   startup performance. To use on-demand initialization:

   .. rubric:: Remove the default initializer
      :name: remove-default

   To provide your own configuration, you must first remove the default
   initializer. To do so, update
   `AndroidManifest.xml <#>`__
   using the merge rule ``tools:node="remove"``.

   Since WorkManager 2.6, `App Startup <#>`__
   is used internally within WorkManager. To provide a custom
   initializer you need to remove the ``androidx.startup`` node.

   If you don't use App Startup in your app, you can remove it
   completely.

   .. code:: prettyprint

       <!-- If you want to disable android.startup completely. -->
       <provider
          android:name="androidx.startup.InitializationProvider"
          android:authorities="${applicationId}.androidx-startup"
          tools:node="remove">
       </provider>

   Otherwise, remove only the ``WorkManagerInitializer`` node.

   .. code:: prettyprint

       <provider
          android:name="androidx.startup.InitializationProvider"
          android:authorities="${applicationId}.androidx-startup"
          android:exported="false"
          tools:node="merge">
          <!-- If you are using androidx.startup to initialize other components -->
          <meta-data
              android:name="androidx.work.WorkManagerInitializer"
              android:value="androidx.startup"
              tools:node="remove" />
       </provider>

   While using a version of WorkManager older than 2.6, remove
   ``workmanager-init`` instead:

   .. code:: prettyprint

      <provider
          android:name="androidx.work.impl.WorkManagerInitializer"
          android:authorities="${applicationId}.workmanager-init"
          tools:node="remove" />

   To learn more about using merge rules in your manifest, see the
   documentation on `merging multiple manifest files <#merge-manifests>`__.

   .. rubric:: Implement Configuration.Provider
      :name: implement-configuration-provider

   Have your ``Application`` class implement the
   `Configuration.Provider <#>`__
   interface, and provide your own implementation of
   `Configuration.Provider.getWorkManagerConfiguration <#getWorkManagerConfiguration>`__.
   When you need to use WorkManager, make sure to call the method
   `WorkManager.getInstance(Context) <#getInstance>`__.
   WorkManager calls your app's custom ``getWorkManagerConfiguration()``
   method to discover its ``Configuration``. (You do not need to call
   ``WorkManager.initialize`` yourself.)

   **Note:**\  If you call the deprecated no-parameter
   ``WorkManager.getInstance()`` method before WorkManager has been
   initialized, the method throws an exception. You should always use
   the ``WorkManager.getInstance(Context)`` method, even if you're not
   customizing WorkManager.
   Here's an example of a custom ``getWorkManagerConfiguration()``
   implementation:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               class MyApplication() : Application(), Configuration.Provider {
                    override fun getWorkManagerConfiguration() =
                          Configuration.Builder()
                               .setMinimumLoggingLevel(android.util.Log.INFO)
                               .build()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               class MyApplication extends Application implements Configuration.Provider {
                   @Override
                   public Configuration getWorkManagerConfiguration() {
                       return new Configuration.Builder()
                               .setMinimumLoggingLevel(android.util.Log.INFO)
                               .build();
                   }
               }

   **Note:**\  You must `remove the default initializer <#remove-default>`__
   for a custom ``getWorkManagerConfiguration()`` implementation to take
   effect.

   .. rubric:: Custom initialization before WorkManager 2.1.0
      :name: pre-2.1.0

   For versions of WorkManager before version 2.1.0, there are two
   initialization options. In most cases, the `default initialization <#default>`__
   is all you need. For more precise control of WorkManager, you can
   `specify your own configuration <#custom>`__.

   .. rubric:: Default initialization
      :name: default

   WorkManager uses a custom ``ContentProvider`` to initialize itself
   when your app starts. This code lives in the internal class
   ``androidx.work.impl.WorkManagerInitializer`` and uses the default
   `Configuration <#>`__. The
   default initializer is automatically used unless you `explicitly disable it <#remove-default>`__.
   The default initializer is suitable for most apps.

   .. rubric:: Custom initialization
      :name: custom

   If you want to control the initialization process, you must `disable the default initializer <#remove-default>`__,
   then define your own custom configuration.

   Once the default initializer is removed, you can manually initialize
   WorkManager:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               // provide custom configuration
               val myConfig = Configuration.Builder()
                   .setMinimumLoggingLevel(android.util.Log.INFO)
                   .build()

               // initialize WorkManager
               WorkManager.initialize(this, myConfig)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               // provide custom configuration
               Configuration myConfig = new Configuration.Builder()
                   .setMinimumLoggingLevel(android.util.Log.INFO)
                   .build();

               //initialize WorkManager
               WorkManager.initialize(this, myConfig);

   Make sure the initialization of the
   `WorkManager <#>`__ singleton
   runs either in
   `Application.onCreate() <#onCreate>`__
   or in a
   `ContentProvider.onCreate() <#onCreate>`__.

   For the complete list of customizations available, see the
   `Configuration.Builder() <#>`__
   reference documentation.

Last updated 2024-01-03 UTC.

/Asynchronous work with Java threads
====================================

.. container:: devsite-article-body clearfix

   All Android apps use a main thread to handle UI operations. Calling
   long-running operations from this main thread can lead to freezes and
   unresponsiveness. For example, if your app makes a network request
   from the main thread, your app's UI is frozen until it receives the
   network response. If you use Java, you can create additional
   *background threads* to handle long-running operations while the main
   thread continues to handle UI updates.

   This guide shows how developers using the Java Programming Language
   can use a *thread pool* to set up and use multiple threads in an
   Android app. This guide also shows you how to define code to run on a
   thread and how to communicate between one of these threads and the
   main thread.

   **Important:**\  If you're writing your app in Kotlin, we instead
   recommend `coroutines <#>`__ as a lightweight
   solution for asynchronous background work. Coroutines include
   features such as structured concurrency, built-in cancellation
   support, Jetpack integration, and more.

   .. rubric:: Concurrency libraries
      :name: libraries

   It's important to understand the basics of threading and its
   underlying mechanisms. There are, however, many popular libraries
   that offer higher-level abstractions over these concepts and
   ready-to-use utilities for passing data between threads. These
   libraries include
   `Guava <https://github.com/google/guava/wiki/ListenableFutureExplained>`__
   and `RxJava <https://github.com/ReactiveX/RxJava/wiki>`__ for the
   Java Programming Language users and
   `Coroutines <#>`__, which we recommend for Kotlin
   users.

   In practice, you should pick the one that works best for your app and
   your development team, though the rules of threading remain the same.

   .. rubric:: Examples overview
      :name: examples-overview

   Based on the `Guide to app architecture <#>`__, the
   examples in this topic make a network request and return the result
   to the main thread, where the app then might display that result on
   the screen.

   Specifically, the ``ViewModel`` calls the data layer on the main
   thread to trigger the network request. The data layer is in charge of
   moving the execution of the network request off the main thread and
   posting the result back to the main thread using a callback.

   To move the execution of the network request off the main thread, we
   need to create other threads in our app.

   .. rubric:: Create multiple threads
      :name: create-multiple

   A `thread pool <#>`__ is a
   managed collection of threads that runs tasks in parallel from a
   queue. New tasks are executed on existing threads as those threads
   become idle. To send a task to a thread pool, use the
   `ExecutorService <#>`__
   interface. Note that ``ExecutorService`` has nothing to do with
   `Services <#>`__, the Android application
   component.

   Creating threads is expensive, so you should create a thread pool
   only once as your app initializes. Be sure to save the instance of
   the
   `ExecutorService <#>`__
   either in your ``Application`` class or in a `dependency injection container <#>`__. The following
   example creates a thread pool of four threads that we can use to run
   background tasks.

   .. code:: prettyprint

      public class MyApplication extends Application {
          ExecutorService executorService = Executors.newFixedThreadPool(4);
      }

   There are other ways you can configure a thread pool depending on
   expected workload. See `Configuring a thread pool <#configuring-a-thread-pool>`__ for more information.

   .. rubric:: Execute in a background thread
      :name: execute-background

   Making a network request on the main thread causes the thread to
   wait, or *block*, until it receives a response. Since the thread is
   blocked, the OS can't call ``onDraw()``, and your app freezes,
   potentially leading to an Application Not Responding (ANR) dialog.
   Instead, let's run this operation on a background thread.

   .. rubric:: Make the request
      :name: make-request

   First, let's take a look at our ``LoginRepository`` class and see how
   it's making the network request:

   .. code:: prettyprint

      // Result.java
      public abstract class Result<T> {
          private Result() {}

          public static final class Success<T> extends Result<T> {
              public T data;

              public Success(T data) {
                  this.data = data;
              }
          }

          public static final class Error<T> extends Result<T> {
              public Exception exception;

              public Error(Exception exception) {
                  this.exception = exception;
              }
          }
      }

      // LoginRepository.java
      public class LoginRepository {

          private final String loginUrl = "https://example.com/login";
          private final LoginResponseParser responseParser;

          public LoginRepository(LoginResponseParser responseParser) {
              this.responseParser = responseParser;
          }

          public Result<LoginResponse> makeLoginRequest(String jsonBody) {
              try {
                  URL url = new URL(loginUrl);
                  HttpURLConnection httpConnection = (HttpURLConnection) url.openConnection();
                  httpConnection.setRequestMethod("POST");
                  httpConnection.setRequestProperty("Content-Type", "application/json; charset=utf-8");
                  httpConnection.setRequestProperty("Accept", "application/json");
                  httpConnection.setDoOutput(true);
                  httpConnection.getOutputStream().write(jsonBody.getBytes("utf-8"));

                  LoginResponse loginResponse = responseParser.parse(httpConnection.getInputStream());
                  return new Result.Success<LoginResponse>(loginResponse);
              } catch (Exception e) {
                  return new Result.Error<LoginResponse>(e);
              }
          }
      }

   ``makeLoginRequest()`` is synchronous and blocks the calling thread.
   To model the response of the network request, we have our own
   ``Result`` class.

   .. rubric:: Trigger the request
      :name: trigger-request

   The ``ViewModel`` triggers the network request when the user taps,
   for example, on a button:

   .. code:: prettyprint

      public class LoginViewModel {

          private final LoginRepository loginRepository;

          public LoginViewModel(LoginRepository loginRepository) {
              this.loginRepository = loginRepository;
          }

          public void makeLoginRequest(String username, String token) {
              String jsonBody = "{ username: \"" + username + "\", token: \"" + token + "\" }";
              loginRepository.makeLoginRequest(jsonBody);
          }
      }

   With the previous code, ``LoginViewModel`` is blocking the main
   thread when making the network request. We can use the thread pool
   that we've instantiated to move the execution to a background thread.

   .. rubric:: Handle dependency injection
      :name: handle-dependency

   First, following the `principles of dependency injection <#>`__, ``LoginRepository`` takes an
   instance of `Executor <#>`__
   as opposed to ``ExecutorService`` because it's executing code and not
   managing threads:

   .. code:: prettyprint

      public class LoginRepository {
          ...
          private final Executor executor;

          public LoginRepository(LoginResponseParser responseParser, Executor executor) {
              this.responseParser = responseParser;
              this.executor = executor;
          }
          ...
      }

   The Executor's
   `execute() <#execute>`__
   method takes a `Runnable <#>`__. A
   ``Runnable`` is a Single Abstract Method (SAM) interface with a
   ``run()`` method that is executed in a thread when invoked.

   .. rubric:: Execute in the background
      :name: execute-background

   Let's create another function called ``makeLoginRequest()`` that
   moves the execution to the background thread and ignores the response
   for now:

   .. code:: prettyprint

      public class LoginRepository {
          ...
          public void makeLoginRequest(final String jsonBody) {
              executor.execute(new Runnable() {
                  @Override
                  public void run() {
                      Result<LoginResponse> ignoredResponse = makeSynchronousLoginRequest(jsonBody);
                  }
              });
          }

          public Result<LoginResponse> makeSynchronousLoginRequest(String jsonBody) {
              ... // HttpURLConnection logic
          }
          ...
      }

   Inside the ``execute()`` method, we create a new ``Runnable`` with
   the block of code we want to execute in the background thread‚Äîin our
   case, the synchronous network request method. Internally, the
   ``ExecutorService`` manages the ``Runnable`` and executes it in an
   available thread.

   **Note:**\  In Kotlin, you can use a lambda expression to create an
   anonymous class that implements the SAM interface.

   .. rubric:: Considerations
      :name: considerations

   Any thread in your app can run in parallel to other threads,
   including the main thread, so you should ensure that your code is
   thread-safe. Notice that in our example that we avoid writing to
   variables shared between threads, passing immutable data instead.
   This is a good practice, because each thread works with its own
   instance of data, and we avoid the complexity of synchronization.

   If you need to share state between threads, you must be careful to
   manage access from threads using synchronization mechanisms such as
   locks. This is outside of the scope of this guide. In general you
   should avoid sharing mutable state between threads whenever possible.

   .. rubric:: Communicate with the main thread
      :name: communicate-main

   In the previous step, we ignored the network request response. To
   display the result on the screen, ``LoginViewModel`` needs to know
   about it. We can do that by using *callbacks*.

   The function ``makeLoginRequest()`` should take a callback as a
   parameter so that it can return a value asynchronously. The callback
   with the result is called whenever the network request completes or a
   failure occurs. In Kotlin, we can use a higher-order function.
   However, in Java, we have to create a new callback interface to have
   the same functionality:

   .. code:: prettyprint

      interface RepositoryCallback<T> {
          void onComplete(Result<T> result);
      }

      public class LoginRepository {
          ...
          public void makeLoginRequest(
              final String jsonBody,
              final RepositoryCallback<LoginResponse> callback
          ) {
              executor.execute(new Runnable() {
                  @Override
                  public void run() {
                      try {
                          Result<LoginResponse> result = makeSynchronousLoginRequest(jsonBody);
                          callback.onComplete(result);
                      } catch (Exception e) {
                          Result<LoginResponse> errorResult = new Result.Error<>(e);
                          callback.onComplete(errorResult);
                      }
                  }
              });
          }
        ...
      }

   The ``ViewModel`` needs to implement the callback now. It can perform
   different logic depending on the result:

   .. code:: prettyprint

      public class LoginViewModel {
          ...
          public void makeLoginRequest(String username, String token) {
              String jsonBody = "{ username: \"" + username + "\", token: \"" + token + "\" }";
              loginRepository.makeLoginRequest(jsonBody, new RepositoryCallback<LoginResponse>() {
                  @Override
                  public void onComplete(Result<LoginResponse> result) {
                      if (result instanceof Result.Success) {
                          // Happy path
                      } else {
                          // Show error in UI
                      }
                  }
              });
          }
      }

   In this example, the callback is executed in the calling thread,
   which is a background thread. This means that you cannot modify or
   communicate directly with the UI layer until you switch back to the
   main thread.

   **Note:**\  To communicate with the ``View`` from the ``ViewModel``
   layer, use ``LiveData`` as recommended in the `Guide to app architecture <#>`__. If the code is being executed
   on a background thread, you can call ``MutableLiveData.postValue()``
   to communicate with the UI layer.

   .. rubric:: Use handlers
      :name: use-handlers

   You can use a `Handler <#>`__ to enqueue
   an action to be performed on a different thread. To specify the
   thread on which to run the action, construct the ``Handler`` using a
   `Looper <#>`__ for the thread. A
   ``Looper`` is an object that runs the message loop for an associated
   thread. Once you've created a ``Handler``, you can then use the
   `post(Runnable) <#post>`__
   method to run a block of code in the corresponding thread.

   ``Looper`` includes a helper function,
   `getMainLooper() <#getMainLooper>`__,
   which retrieves the ``Looper`` of the main thread. You can run code
   in the main thread by using this ``Looper`` to create a ``Handler``.
   As this is something you might do quite often, you can also save an
   instance of the ``Handler`` in the same place you saved the
   ``ExecutorService``:

   .. code:: prettyprint

      public class MyApplication extends Application {
          ExecutorService executorService = Executors.newFixedThreadPool(4);
          Handler mainThreadHandler = HandlerCompat.createAsync(Looper.getMainLooper());
      }

   It's a good practice to inject the handler into the repository, as it
   gives you more flexibility. For example, in the future you might want
   to pass in a different ``Handler`` to schedule tasks on a separate
   thread. If you're always communicating back to the same thread, you
   can pass the ``Handler`` into the repository constructor, as shown in
   the following example.

   .. code:: prettyprint

      public class LoginRepository {
          ...
          private final Handler resultHandler;

          public LoginRepository(LoginResponseParser responseParser, Executor executor,
                  Handler resultHandler) {
              this.responseParser = responseParser;
              this.executor = executor;
              this.resultHandler = resultHandler;
          }

          public void makeLoginRequest(
              final String jsonBody,
              final RepositoryCallback<LoginResponse> callback
          ) {
              executor.execute(new Runnable() {
                  @Override
                  public void run() {
                      try {
                          Result<LoginResponse> result = makeSynchronousLoginRequest(jsonBody);
                          notifyResult(result, callback);
                      } catch (Exception e) {
                          Result<LoginResponse> errorResult = new Result.Error<>(e);
                          notifyResult(errorResult, callback);
                      }
                  }
              });
          }

          private void notifyResult(
              final Result<LoginResponse> result,
              final RepositoryCallback<LoginResponse> callback,
          ) {
              resultHandler.post(new Runnable() {
                  @Override
                  public void run() {
                      callback.onComplete(result);
                  }
              });
          }
          ...
      }

   Alternatively, if you want more flexibility, you can pass in a
   ``Handler`` to each function:

   .. code:: prettyprint

      public class LoginRepository {
          ...

          public void makeLoginRequest(
              final String jsonBody,
              final RepositoryCallback<LoginResponse> callback,
              final Handler resultHandler,
          ) {
              executor.execute(new Runnable() {
                  @Override
                  public void run() {
                      try {
                          Result<LoginResponse> result = makeSynchronousLoginRequest(jsonBody);
                          notifyResult(result, callback, resultHandler);
                      } catch (Exception e) {
                          Result<LoginResponse> errorResult = new Result.Error<>(e);
                          notifyResult(errorResult, callback, resultHandler);
                      }
                  }
              });
          }

          private void notifyResult(
              final Result<LoginResponse> result,
              final RepositoryCallback<LoginResponse> callback,
              final Handler resultHandler
          ) {
              resultHandler.post(new Runnable() {
                  @Override
                  public void run() {
                      callback.onComplete(result);
                  }
              });
          }
      }

   In this example, the callback passed into the Repository's
   ``makeLoginRequest`` call is executed on the main thread. That means
   you can directly modify the UI from the callback or use
   ``LiveData.setValue()`` to communicate with the UI.

   .. rubric:: Configure a thread pool
      :name: configure-thread

   You can create a thread pool using one of the
   `Executor <#>`__ helper
   functions with predefined settings, as shown in the previous example
   code. Alternatively, if you want to customize the details of the
   thread pool, you can create an instance using
   `ThreadPoolExecutor <#>`__
   directly. You can configure the following details:

   -  Initial and maximum pool size.
   -  *Keep alive time* and time unit. Keep alive time is the maximum
      duration that a thread can remain idle before it shuts down.
   -  An input queue that holds ``Runnable`` tasks. This queue must
      implement the
      `BlockingQueue <#>`__
      interface. To match the requirements of your app, you can choose
      from the available queue implementations. To learn more, see the
      class overview for
      `ThreadPoolExecutor <#>`__.

   Here's an example that specifies thread pool size based on the total
   number of processor cores, a keep alive time of one second, and an
   input queue.

   .. code:: prettyprint

      public class MyApplication extends Application {
          /*
           * Gets the number of available cores
           * (not always the same as the maximum number of cores)
           */
          private static int NUMBER_OF_CORES = Runtime.getRuntime().availableProcessors();

          // Instantiates the queue of Runnables as a LinkedBlockingQueue
          private final BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<Runnable>();

          // Sets the amount of time an idle thread waits before terminating
          private static final int KEEP_ALIVE_TIME = 1;
          // Sets the Time Unit to seconds
          private static final TimeUnit KEEP_ALIVE_TIME_UNIT = TimeUnit.SECONDS;

          // Creates a thread pool manager
          ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                  NUMBER_OF_CORES,       // Initial pool size
                  NUMBER_OF_CORES,       // Max pool size
                  KEEP_ALIVE_TIME,
                  KEEP_ALIVE_TIME_UNIT,
                  workQueue
          );
          ...
      }

Last updated 2024-01-03 UTC.


/Threading in Worker
====================

.. container:: devsite-article-body clearfix

   When you use a `Worker <#>`__,
   WorkManager automatically calls
   `Worker.doWork() <#doWork>`__ on
   a background thread. The background thread comes from the
   ``Executor`` specified in WorkManager's
   `Configuration <#>`__. By
   default, WorkManager sets up an ``Executor`` for you‚Äîbut you can also
   customize your own. For example, you can share an existing background
   Executor in your app, create a single-threaded ``Executor`` to make
   sure all your background work executes sequentially, or even specify
   a custom ``Executor``. To customize the ``Executor``, make sure you
   initialize WorkManager manually.

   When configuring WorkManager manually, you can specify your
   ``Executor`` as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               WorkManager.initialize(
                   context,
                   Configuration.Builder()
                        // Uses a fixed thread pool of size 8 threads.
                       .setExecutor(Executors.newFixedThreadPool(8))
                       .build())

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               WorkManager.initialize(
                   context,
                   new Configuration.Builder()
                       .setExecutor(Executors.newFixedThreadPool(8))
                       .build());

   Here is an example of a simple ``Worker`` that downloads the contents
   of a webpage 100 times:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class DownloadWorker(context: Context, params: WorkerParameters) : Worker(context, params) {

                   override fun doWork(): ListenableWorker.Result {
                       repeat(100) {
                           try {
                               downloadSynchronously("https://www.google.com")
                           } catch (e: IOException) {
                               return ListenableWorker.Result.failure()
                           }
                       }

                       return ListenableWorker.Result.success()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class DownloadWorker extends Worker {

                   public DownloadWorker(Context context, WorkerParameters params) {
                       super(context, params);
                   }

                   @NonNull
                   @Override
                   public Result doWork() {
                       for (int i = 0; i < 100; i++) {
                           try {
                               downloadSynchronously("https://www.google.com");
                           } catch (IOException e) {
                               return Result.failure();
                           }
                       }

                       return Result.success();
                   }

               }

   Note that
   `Worker.doWork() <#doWork>`__ is
   a synchronous call‚Äîyou are expected to do the entirety of your
   background work in a blocking fashion and finish it by the time the
   method exits. If you call an asynchronous API in ``doWork()`` and
   return a
   `Result <#>`__,
   your callback may not operate properly. If you find yourself in this
   situation, consider using a
   `ListenableWorker <#>`__
   (see `Threading in ListenableWorker <#>`__).

   When a currently running ``Worker`` is `stopped for any reason <#cancelling>`__,
   it receives a call to
   `Worker.onStopped() <#onStopped>`__.
   Override this method or call
   `Worker.isStopped() <#isStopped>`__
   to checkpoint your code and free up resources when necessary. When
   the ``Worker`` in the example above is stopped, it may be in the
   middle of its loop of downloading items and will continue doing so
   even though it has been stopped. To optimize this behavior, you can
   do something like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class DownloadWorker(context: Context, params: WorkerParameters) : Worker(context, params) {

                   override fun doWork(): ListenableWorker.Result {
                       repeat(100) {
                           if (isStopped) {
                               break
                           }

                           try {
                               downloadSynchronously("https://www.google.com")
                           } catch (e: IOException) {
                               return ListenableWorker.Result.failure()
                           }

                       }

                       return ListenableWorker.Result.success()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class DownloadWorker extends Worker {

                   public DownloadWorker(Context context, WorkerParameters params) {
                       super(context, params);
                   }

                   @NonNull
                   @Override
                   public Result doWork() {
                       for (int i = 0; i < 100; ++i) {
                           if (isStopped()) {
                               break;
                           }

                           try {
                               downloadSynchronously("https://www.google.com");
                           } catch (IOException e) {
                               return Result.failure();
                           }
                       }

                       return Result.success();
                   }
               }

   Once a ``Worker`` has been stopped, it doesn't matter what you return
   from ``Worker.doWork()``; the ``Result`` will be ignored.

Last updated 2024-01-03 UTC.


/Threading in CoroutineWorker
=============================

.. container:: devsite-article-body clearfix

   For Kotlin users, WorkManager provides first-class support for
   `coroutines <https://kotlinlang.org/docs/reference/coroutines-overview.html>`__.
   To get started, include `work-runtime-ktx`` in your gradle
   file </jetpack/androidx/releases/work#declaring_dependencies>`__.
   Instead of extending
   `Worker <#>`__, you should extend
   `CoroutineWorker <#>`__,
   which has a suspending version of ``doWork()``. For example, if you
   wanted to build a simple ``CoroutineWorker`` to perform some network
   operations, you would do the following:

   .. code:: prettyprint

      class CoroutineDownloadWorker(
          context: Context,
          params: WorkerParameters
      ) : CoroutineWorker(context, params) {

          override suspend fun doWork(): Result {
              val data = downloadSynchronously("https://www.google.com")
              saveData(data)
              return Result.success()
          }
      }

   Note that
   `CoroutineWorker.doWork() <#doWork>`__
   is a *suspending* function. Unlike ``Worker``, this code does *not*
   run on the ``Executor`` specified in your
   `Configuration <#>`__.
   Instead, it defaults to ``Dispatchers.Default``. You can customize
   this by providing your own ``CoroutineContext``. In the above
   example, you would probably want to do this work on
   ``Dispatchers.IO``, as follows:

   .. code:: prettyprint

      class CoroutineDownloadWorker(
          context: Context,
          params: WorkerParameters
      ) : CoroutineWorker(context, params) {

          override suspend fun doWork(): Result {
              withContext(Dispatchers.IO) {
                  val data = downloadSynchronously("https://www.google.com")
                  saveData(data)
                  return Result.success()
              }
          }
      }

   ``CoroutineWorker`` handles stoppages automatically by cancelling the
   coroutine and propagating the cancellation signals. You don't need to
   do anything special to handle `work stoppages <#cancelling>`__.

   .. rubric:: Running a CoroutineWorker in a different process
      :name: remotecoroutineworker

   You can also bind a worker to a specific process by using
   `RemoteCoroutineWorker <#>`__,
   an implementation of ``ListenableWorker``.

   ``RemoteCoroutineWorker`` binds to a specific process with two extra
   arguments that you provide as part of the input data when building
   the work request: ``ARGUMENT_CLASS_NAME`` and
   ``ARGUMENT_PACKAGE_NAME``.

   The following example demonstrates building a work request that is
   bound to a specific process:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val PACKAGE_NAME = "com.example.background.multiprocess"

               val serviceName = RemoteWorkerService::class.java.name
               val componentName = ComponentName(PACKAGE_NAME, serviceName)

               val data: Data = Data.Builder()
                  .putString(ARGUMENT_PACKAGE_NAME, componentName.packageName)
                  .putString(ARGUMENT_CLASS_NAME, componentName.className)
                  .build()

               return OneTimeWorkRequest.Builder(ExampleRemoteCoroutineWorker::class.java)
                  .setInputData(data)
                  .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               String PACKAGE_NAME = "com.example.background.multiprocess";

               String serviceName = RemoteWorkerService.class.getName();
               ComponentName componentName = new ComponentName(PACKAGE_NAME, serviceName);

               Data data = new Data.Builder()
                       .putString(ARGUMENT_PACKAGE_NAME, componentName.getPackageName())
                       .putString(ARGUMENT_CLASS_NAME, componentName.getClassName())
                       .build();

               return new OneTimeWorkRequest.Builder(ExampleRemoteCoroutineWorker.class)
                       .setInputData(data)
                       .build();

   For each ``RemoteWorkerService``, you also need to add a service
   definition in your ``AndroidManifest.xml`` file:

   .. code:: prettyprint

      <manifest ... >
          <service
                  android:name="androidx.work.multiprocess.RemoteWorkerService"
                  android:exported="false"
                  android:process=":worker1" />

              <service
                  android:name=".RemoteWorkerService2"
                  android:exported="false"
                  android:process=":worker2" />
          ...
      </manifest>

   .. rubric:: Samples
      :name: samples

   -  `WorkManagerMultiProcessSample <https://github.com/android/architecture-components-samples/tree/main/WorkManagerMultiprocessSample>`__

Last updated 2024-01-03 UTC.


/Threading in RxWorker
======================

.. container:: devsite-article-body clearfix

   We provide interoperability between WorkManager and RxJava. To get
   started, include `work-rxjava3`` dependency in addition to
   ``work-runtime </jetpack/androidx/releases/work#declaring_dependencies>`__
   in your gradle file. There is also a ``work-rxjava2`` dependency that
   supports rxjava2 instead.

   Then, instead of extending ``Worker``, you should
   extend\ ``RxWorker``. Finally override the
   `RxWorker.createWork() <#createWork>`__
   method to return a ``Single<Result>`` indicating the
   `Result <#>`__ of
   your execution, as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class RxDownloadWorker(
                       context: Context,
                       params: WorkerParameters
               ) : RxWorker(context, params) {
                   override fun createWork(): Single<Result> {
                       return Observable.range(0, 100)
                               .flatMap { download("https://www.example.com") }
                               .toList()
                               .map { Result.success() }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class RxDownloadWorker extends RxWorker {

                   public RxDownloadWorker(Context context, WorkerParameters params) {
                       super(context, params);
                   }

                   @NonNull
                   @Override
                   public Single<Result> createWork() {
                       return Observable.range(0, 100)
                           .flatMap { download("https://www.example.com") }
                           .toList()
                           .map { Result.success() };
                   }
               }

   Note that ``RxWorker.createWork()`` is *called* on the main thread,
   but the return value is *subscribed* on a background thread by
   default. You can override
   `RxWorker.getBackgroundScheduler() <#getBackgroundScheduler>`__
   to change the subscribing thread.

   When an ``RxWorker`` is ``onStopped()``, the subscription will get
   disposed of, so you don't need to handle `work stoppages <#cancelling>`__
   in any special way.

Last updated 2024-01-03 UTC.



/Threading in ListenableWorker
==============================

.. container:: devsite-article-body clearfix

   In certain situations, you may need to provide a custom threading
   strategy. For example, you may need to handle a callback-based
   asynchronous operation. WorkManager supports this use case with
   `ListenableWorker <#>`__.
   ``ListenableWorker`` is the most basic worker API;
   `Worker <#>`__,
   `CoroutineWorker <#>`__,
   and `RxWorker <#>`__ all derive
   from this class. A ``ListenableWorker`` only signals when the work
   should start and stop and leaves the threading entirely up to you.
   The start work signal is invoked on the main thread, so it is very
   important that you go to a background thread of your choice manually.

   The abstract method
   `ListenableWorker.startWork() <#startWork>`__
   returns a ``ListenableFuture`` of the
   `Result <#>`__. A
   ``ListenableFuture`` is a lightweight interface: it is a ``Future``
   that provides functionality for attaching listeners and propagating
   exceptions. In the ``startWork`` method, you are expected to return a
   ``ListenableFuture``, which you will set with the ``Result`` of the
   operation once it's completed. You can create ``ListenableFuture``
   instances in one of two ways:

   #. If you use Guava, use ``ListeningExecutorService``.
   #. Otherwise, include
      `councurrent-futures <#declaring_dependencies>`__
      in your gradle file and use
      `CallbackToFutureAdapter <#>`__.

   If you wanted to execute some work based on an asynchronous callback,
   you would do something like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CallbackWorker(
                       context: Context,
                       params: WorkerParameters
               ) : ListenableWorker(context, params) {
                   override fun startWork(): ListenableFuture<Result> {
                       return CallbackToFutureAdapter.getFuture { completer ->
                           val callback = object : Callback {
                               var successes = 0

                               override fun onFailure(call: Call, e: IOException) {
                                   completer.setException(e)
                               }

                               override fun onResponse(call: Call, response: Response) {
                                   successes++
                                   if (successes == 100) {
                                       completer.set(Result.success())
                                   }
                               }
                           }

                           repeat(100) {
                               downloadAsynchronously("https://example.com", callback)
                           }

                           callback
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CallbackWorker extends ListenableWorker {

                   public CallbackWorker(Context context, WorkerParameters params) {
                       super(context, params);
                   }

                   @NonNull
                   @Override
                   public ListenableFuture<Result> startWork() {
                       return CallbackToFutureAdapter.getFuture(completer -> {
                           Callback callback = new Callback() {
                               int successes = 0;

                               @Override
                               public void onFailure(Call call, IOException e) {
                                   completer.setException(e);
                               }

                               @Override
                               public void onResponse(Call call, Response response) {
                                   successes++;
                                   if (successes == 100) {
                                       completer.set(Result.success());
                                   }
                               }
                           };

                           for (int i = 0; i < 100; i++) {
                               downloadAsynchronously("https://www.example.com", callback);
                           }
                           return callback;
                       });
                   }
               }

   What happens if your work is
   `stopped <#cancelling>`__?
   A ``ListenableWorker``'s ``ListenableFuture`` is always cancelled
   when the work is expected to stop. Using a
   ``CallbackToFutureAdapter``, you simply have to add a cancellation
   listener, as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CallbackWorker(
                       context: Context,
                       params: WorkerParameters
               ) : ListenableWorker(context, params) {
                   override fun startWork(): ListenableFuture<Result> {
                       return CallbackToFutureAdapter.getFuture { completer ->
                           val callback = object : Callback {
                               var successes = 0

                               override fun onFailure(call: Call, e: IOException) {
                                   completer.setException(e)
                               }

                               override fun onResponse(call: Call, response: Response) {
                                   ++successes
                                   if (successes == 100) {
                                       completer.set(Result.success())
                                   }
                               }
                           }

                completer.addCancellationListener(cancelDownloadsRunnable, executor)

                           repeat(100) {
                               downloadAsynchronously("https://example.com", callback)
                           }

                           callback
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CallbackWorker extends ListenableWorker {

                   public CallbackWorker(Context context, WorkerParameters params) {
                       super(context, params);
                   }

                   @NonNull
                   @Override
                   public ListenableFuture<Result> startWork() {
                       return CallbackToFutureAdapter.getFuture(completer -> {
                           Callback callback = new Callback() {
                               int successes = 0;

                               @Override
                               public void onFailure(Call call, IOException e) {
                                   completer.setException(e);
                               }

                               @Override
                               public void onResponse(Call call, Response response) {
                                   ++successes;
                                   if (successes == 100) {
                                       completer.set(Result.success());
                                   }
                               }
                           };

                           completer.addCancellationListener(cancelDownloadsRunnable, executor);

                           for (int i = 0; i < 100; ++i) {
                               downloadAsynchronously("https://www.example.com", callback);
                           }
                           return callback;
                       });
                   }
               }

   .. rubric:: Running a ListenableWorker in a different process
      :name: remotelistenableworker

   You can also bind a worker to a specific process by using
   `RemoteListenableWorker <#>`__,
   an implementation of ``ListenableWorker``.

   ``RemoteListenableWorker`` binds to a specific process with two extra
   arguments that you provide as part of the input data when building
   the work request: ``ARGUMENT_CLASS_NAME`` and
   ``ARGUMENT_PACKAGE_NAME``.

   The following example demonstrates building a work request that is
   bound to a specific process:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val PACKAGE_NAME = "com.example.background.multiprocess"

               val serviceName = RemoteWorkerService::class.java.name
               val componentName = ComponentName(PACKAGE_NAME, serviceName)

               val data: Data = Data.Builder()
                  .putString(ARGUMENT_PACKAGE_NAME, componentName.packageName)
                  .putString(ARGUMENT_CLASS_NAME, componentName.className)
                  .build()

               return OneTimeWorkRequest.Builder(ExampleRemoteListenableWorker::class.java)
                  .setInputData(data)
                  .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               String PACKAGE_NAME = "com.example.background.multiprocess";

               String serviceName = RemoteWorkerService.class.getName();
               ComponentName componentName = new ComponentName(PACKAGE_NAME, serviceName);

               Data data = new Data.Builder()
                       .putString(ARGUMENT_PACKAGE_NAME, componentName.getPackageName())
                       .putString(ARGUMENT_CLASS_NAME, componentName.getClassName())
                       .build();

               return new OneTimeWorkRequest.Builder(ExampleRemoteListenableWorker.class)
                       .setInputData(data)
                       .build();

   For each ``RemoteWorkerService``, you also need to add a service
   definition in your ``AndroidManifest.xml`` file:

   .. code:: prettyprint

      <manifest ... >
          <service
                  android:name="androidx.work.multiprocess.RemoteWorkerService"
                  android:exported="false"
                  android:process=":worker1" />

              <service
                  android:name=".RemoteWorkerService2"
                  android:exported="false"
                  android:process=":worker2" />
          ...
      </manifest>

   .. rubric:: Samples
      :name: samples

   -  `WorkManagerMultiProcessSample <https://github.com/android/architecture-components-samples/tree/main/WorkManagerMultiprocessSample>`__

Last updated 2024-01-03 UTC.


/Support for long-running workers
=================================

.. container:: devsite-article-body clearfix

   WorkManager has built-in support for long running workers. In such
   cases, WorkManager can provide a signal to the OS that the process
   should be kept alive if possible while this work is executing. These
   Workers can run longer than 10 minutes. Example use-cases for this
   new feature include bulk uploads or downloads (that cannot be
   chunked), crunching on an ML model locally, or a task that's
   *important to the user* of the app.

   Under the hood, WorkManager manages and runs a foreground service on
   your behalf to execute the
   `WorkRequest <#>`__, while
   also showing a configurable notification.

   `ListenableWorker <#>`__
   now supports the
   `setForegroundAsync() <#setProgressAsync>`__
   API, and
   `CoroutineWorker <#>`__
   supports a suspending
   `setForeground() <#setforeground>`__
   API. These APIs allow developers to specify that this ``WorkRequest``
   is *important* (from a user perspective) or *long-running*.

   Starting with ``2.3.0-alpha03``, WorkManager also allows you to
   create a
   `PendingIntent <#>`__, which
   can be used to cancel workers without having to register a new
   Android component using the
   `createCancelPendingIntent() <#createCancelPendingIntent>`__
   API. This approach is especially useful when used with the
   ``setForegroundAsync()`` or ``setForeground()`` APIs, which can be
   used to add a notification action to cancel the ``Worker``.

   .. rubric:: Creating and managing long-running workers
      :name: long-running

   You'll use a slightly different approach depending on whether you are
   coding in Kotlin or Java.

   .. rubric:: Kotlin
      :name: long-running-kotlin

   Kotlin developers should use
   `CoroutineWorker <#>`__.
   Instead of using ``setForegroundAsync()``, you can use the suspending
   version of that method,
   `setForeground() <#setforeground>`__.

   .. code:: prettyprint

      class DownloadWorker(context: Context, parameters: WorkerParameters) :
         CoroutineWorker(context, parameters) {

         private val notificationManager =
             context.getSystemService(Context.NOTIFICATION_SERVICE) as
                     NotificationManager

         override suspend fun doWork(): Result {
             val inputUrl = inputData.getString(KEY_INPUT_URL)
                            ?: return Result.failure()
             val outputFile = inputData.getString(KEY_OUTPUT_FILE_NAME)
                            ?: return Result.failure()
             // Mark the Worker as important
             val progress = "Starting Download"
             setForeground(createForegroundInfo(progress))
             download(inputUrl, outputFile)
             return Result.success()
         }

         private fun download(inputUrl: String, outputFile: String) {
             // Downloads a file and updates bytes read
             // Calls setForeground() periodically when it needs to update
             // the ongoing Notification
         }
         // Creates an instance of ForegroundInfo which can be used to update the
         // ongoing notification.
         private fun createForegroundInfo(progress: String): ForegroundInfo {
             val id = applicationContext.getString(R.string.notification_channel_id)
             val title = applicationContext.getString(R.string.notification_title)
             val cancel = applicationContext.getString(R.string.cancel_download)
             // This PendingIntent can be used to cancel the worker
             val intent = WorkManager.getInstance(applicationContext)
                     .createCancelPendingIntent(getId())

             // Create a Notification channel if necessary
             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                 createChannel()
             }

             val notification = NotificationCompat.Builder(applicationContext, id)
                 .setContentTitle(title)
                 .setTicker(title)
                 .setContentText(progress)
                 .setSmallIcon(R.drawable.ic_work_notification)
                 .setOngoing(true)
                 // Add the cancel action to the notification which can
                 // be used to cancel the worker
                 .addAction(android.R.drawable.ic_delete, cancel, intent)
                 .build()

             return ForegroundInfo(notificationId, notification)
         }

         @RequiresApi(Build.VERSION_CODES.O)
         private fun createChannel() {
             // Create a Notification channel
         }

         companion object {
             const val KEY_INPUT_URL = "KEY_INPUT_URL"
             const val KEY_OUTPUT_FILE_NAME = "KEY_OUTPUT_FILE_NAME"
         }
      }

   .. rubric:: Java
      :name: long-running-java

   Developers using a ``ListenableWorker`` or a ``Worker`` can call the
   `setForegroundAsync() <#setForegroundAsync>`__
   API, which returns a ``ListenableFuture<Void>``. You can also call
   ``setForegroundAsync()`` to update an ongoing ``Notification``.

   Here is a simple example of a long running worker that downloads a
   file. This Worker keeps track of progress to update an ongoing
   ``Notification`` which shows the download progress.

   .. code:: prettyprint

      public class DownloadWorker extends Worker {
         private static final String KEY_INPUT_URL = "KEY_INPUT_URL";
         private static final String KEY_OUTPUT_FILE_NAME = "KEY_OUTPUT_FILE_NAME";

         private NotificationManager notificationManager;

         public DownloadWorker(
             @NonNull Context context,
             @NonNull WorkerParameters parameters) {
                 super(context, parameters);
                 notificationManager = (NotificationManager)
                     context.getSystemService(NOTIFICATION_SERVICE);
         }

         @NonNull
         @Override
         public Result doWork() {
             Data inputData = getInputData();
             String inputUrl = inputData.getString(KEY_INPUT_URL);
             String outputFile = inputData.getString(KEY_OUTPUT_FILE_NAME);
             // Mark the Worker as important
             String progress = "Starting Download";
             setForegroundAsync(createForegroundInfo(progress));
             download(inputUrl, outputFile);
             return Result.success();
         }

         private void download(String inputUrl, String outputFile) {
             // Downloads a file and updates bytes read
             // Calls setForegroundAsync(createForegroundInfo(myProgress))
             // periodically when it needs to update the ongoing Notification.
         }

         @NonNull
         private ForegroundInfo createForegroundInfo(@NonNull String progress) {
             // Build a notification using bytesRead and contentLength

             Context context = getApplicationContext();
             String id = context.getString(R.string.notification_channel_id);
             String title = context.getString(R.string.notification_title);
             String cancel = context.getString(R.string.cancel_download);
             // This PendingIntent can be used to cancel the worker
             PendingIntent intent = WorkManager.getInstance(context)
                     .createCancelPendingIntent(getId());

             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                 createChannel();
             }

             Notification notification = new NotificationCompat.Builder(context, id)
                     .setContentTitle(title)
                     .setTicker(title)
                     .setSmallIcon(R.drawable.ic_work_notification)
                     .setOngoing(true)
                     // Add the cancel action to the notification which can
                     // be used to cancel the worker
                     .addAction(android.R.drawable.ic_delete, cancel, intent)
                     .build();

             return new ForegroundInfo(notificationId, notification);
         }

         @RequiresApi(Build.VERSION_CODES.O)
         private void createChannel() {
             // Create a Notification channel
         }
      }

   .. rubric:: Add a foreground service type to a long-running worker
      :name: foreground-service-type

   **Note:**\  Depending on which API level your app is targeting and
   what kind of work the service is doing, you may be *required* to
   declare a foreground service type. Declaring a foreground service
   type is a best practice no matter what version of Android you're
   targeting. More more details, see `the foreground service documentation <#types>`__.
   If your app targets Android 14 (API level 34) or higher you must
   specify a `foreground service type <#>`__ for all
   long-running workers. If your app targets Android 10 (API level 29)
   or higher and contains a long-running worker that requires access to
   location, indicate that the worker uses a `foreground service type of ``location </develop/background-work/services/fg-service-types#location>`__.

   If your app targets Android 11 (API level 30) or higher and contains
   a long-running worker that requires access to camera or microphone,
   declare the
   `camera <#camera>`__
   or
   `microphone <#microphone>`__
   foreground service types, respectively.

   To add these foreground service types, complete the steps described
   in the following sections.

   .. rubric:: Declare foreground service types in app manifest
      :name: declare-foreground-service-types-manifest

   Declare the worker's foreground service type in your app's manifest.
   In the following example, the worker requires access to location and
   microphone:

   AndroidManifest.xml

   .. code:: prettyprint

      <service
         android:name="androidx.work.impl.foreground.SystemForegroundService"
         android:foregroundServiceType="location|microphone"
         tools:node="merge" />

   **Note:**\  The `manifest merger tool <#merge-manifests>`__ combines the
   ``<service>`` element declaration from the preceding code snippet and
   the declaration that WorkManager's ``SystemForegroundService``
   defines in its own manifest.

   .. rubric:: Specify foreground service types at runtime
      :name: specify-foreground-service-types-runtime

   When you call ``setForeground()`` or ``setForegroundAsync()``, ensure
   you specify a `foreground service type <#>`__.

   **Note:**\  Beginning with Android 14 (API level 34), when you call
   ``setForeground()`` or ``setForegroundAsync()``, the system checks
   for specific prerequisites based on service type. For more
   information refer to the `Foreground Service guide <#fgs-prerequisites>`__.
   MyLocationAndMicrophoneWorker

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private fun createForegroundInfo(progress: String): ForegroundInfo {
                  // ...
                  return ForegroundInfo(NOTIFICATION_ID, notification,
                          FOREGROUND_SERVICE_TYPE_LOCATION or
               FOREGROUND_SERVICE_TYPE_MICROPHONE) }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @NonNull
               private ForegroundInfo createForegroundInfo(@NonNull String progress) {
                  // Build a notification...
                  Notification notification = ...;
                  return new ForegroundInfo(NOTIFICATION_ID, notification,
                          FOREGROUND_SERVICE_TYPE_LOCATION | FOREGROUND_SERVICE_TYPE_MICROPHONE);
               }

Last updated 2024-01-04 UTC.


/Migrating from Firebase JobDispatcher to WorkManager
=====================================================

.. container:: devsite-article-body clearfix

   WorkManager is a library for scheduling and executing deferrable
   background work in Android. It is the recommended replacement for
   Firebase JobDispatcher. The following guide will walk you through the
   process of migrating your Firebase JobDispatcher implementation to
   WorkManager.

   .. rubric:: Gradle setup
      :name: gradle_setup

   To import the WorkManager library into your Android project, add the
   dependencies listed in `Getting started with WorkManager <#>`__.

   .. rubric:: From JobService to workers
      :name: from_jobservice_to_workers

   `FirebaseJobDispatcher <https://github.com/googlearchive/firebase-jobdispatcher-android/blob/e609dabf6cbd0fcc2451b8515f095cfbc3d9450a/jobdispatcher/src/main/java/com/firebase/jobdispatcher/FirebaseJobDispatcher.java>`__
   uses a subclass of
   `JobService <https://github.com/firebase/firebase-jobdispatcher-android/blob/master/jobdispatcher/src/main/java/com/firebase/jobdispatcher/JobService.java>`__
   as an entry point for defining the work which needs to be done. You
   might be using ``JobService`` directly, or using
   `SimpleJobService <https://github.com/firebase/firebase-jobdispatcher-android/blob/master/jobdispatcher/src/main/java/com/firebase/jobdispatcher/SimpleJobService.java>`__.

   A ``JobService`` will look something like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               import com.firebase.jobdispatcher.JobParameters
               import com.firebase.jobdispatcher.JobService

               class MyJobService : JobService() {
                   override fun onStartJob(job: JobParameters): Boolean {
                       // Do some work here
                       return false // Answers the question: "Is there still work going on?"
                   }
                   override fun onStopJob(job: JobParameters): Boolean {
                       return false // Answers the question: "Should this job be retried?"
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import com.firebase.jobdispatcher.JobParameters;
               import com.firebase.jobdispatcher.JobService;

               public class MyJobService extends JobService {
                   @Override
                   public boolean onStartJob(JobParameters job) {
                       // Do some work here

                       return false; // Answers the question: "Is there still work going on?"
                   }

                   @Override
                   public boolean onStopJob(JobParameters job) {
                       return false; // Answers the question: "Should this job be retried?"
                   }
               }

   If you are using ``SimpleJobService`` you will have overridden
   ``onRunJob()``, which returns a ``@JobResult int`` type.

   The key difference is when you are using ``JobService`` directly,
   ``onStartJob()`` is called on the main thread, and it is the app‚Äôs
   responsibility to offload the work to a background thread. On the
   other hand, if you are using ``SimpleJobService``, that service is
   responsible for executing your work on a background thread.

   WorkManager has similar concepts. The fundamental unit of work in
   WorkManager is a
   `ListenableWorker <#>`__.
   There are also other useful subtypes of workers like
   `Worker <#>`__,
   `RxWorker <#>`__, and
   ``CoroutineWorker`` (when using Kotlin coroutines).

   .. rubric:: JobService maps to a ListenableWorker
      :name: jobservice_maps_to_a_listenableworker

   If you are using ``JobService`` directly, then the worker it maps to
   is a ``ListenableWorker``. If you are using ``SimpleJobService`` then
   you should use ``Worker`` instead.

   Let‚Äôs use the above example (``MyJobService``) and look at how we can
   convert it to a ``ListenableWorker``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               import android.content.Context
               import androidx.work.ListenableWorker
               import androidx.work.ListenableWorker.Result
               import androidx.work.WorkerParameters
               import com.google.common.util.concurrent.ListenableFuture

               class MyWorker(appContext: Context, params: WorkerParameters) :
                   ListenableWorker(appContext, params) {

                   override fun startWork(): ListenableFuture<ListenableWorker.Result> {
                       // Do your work here.
                       TODO("Return a ListenableFuture<Result>")
                   }

                   override fun onStopped() {
                       // Cleanup because you are being stopped.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import android.content.Context;
               import androidx.work.ListenableWorker;
               import androidx.work.ListenableWorker.Result;
               import androidx.work.WorkerParameters;
               import com.google.common.util.concurrent.ListenableFuture;

               class MyWorker extends ListenableWorker {

                 public MyWorker(@NonNull Context appContext, @NonNull WorkerParameters params) {
                   super(appContext, params);
                 }

                 @Override
                 public ListenableFuture<ListenableWorker.Result> startWork() {
                   // Do your work here.
                   Data input = getInputData();

                   // Return a ListenableFuture<>
                 }

                 @Override
                 public void onStopped() {
                   // Cleanup because you are being stopped.
                 }
               }

   The basic unit of work in WorkManager is a ``ListenableWorker``. Just
   like ``JobService.onStartJob()``, ``startWork()`` is called on the
   main thread. Here ``MyWorker`` implements ``ListenableWorker`` and
   returns an instance of
   `ListenableFuture <https://google.github.io/guava/releases/21.0-rc1/api/docs/com/google/common/util/concurrent/ListenableFuture.html>`__,
   which is used to signal work completion *asynchronously*. You should
   choose your own threading strategy here.

   The ``ListenableFuture`` here eventually returns a
   ``ListenableWorker.Result`` type which can be one of
   ``Result.success()``, ``Result.success(Data outputData)``,
   ``Result.retry()``, ``Result.failure()``, or
   ``Result.failure(Data outputData)``. For more information, see the
   reference page for
   `ListenableWorker.Result <#>`__.

   ``onStopped()`` is called to signal that the ``ListenableWorker``
   needs to stop, either because the constraints are no longer being met
   (for example, because the network is no longer available), or because
   a ``WorkManager.cancel‚Ä¶()`` method was called. ``onStopped()`` may
   also be called if the OS decides to shut down your work for some
   reason.

   .. rubric:: SimpleJobService maps to a Worker
      :name: simplejobservice_maps_to_a_worker

   When using ``SimpleJobService`` the above worker will look like:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               import android.content.Context;
               import androidx.work.Data;
               import androidx.work.ListenableWorker.Result;
               import androidx.work.Worker;
               import androidx.work.WorkerParameters;


               class MyWorker(context: Context, params: WorkerParameters) : Worker(context, params) {
                   override fun doWork(): Result {
                       TODO("Return a Result")
                   }

                   override fun onStopped() {
                       super.onStopped()
                       TODO("Cleanup, because you are being stopped")
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import android.content.Context;
               import androidx.work.Data;
               import androidx.work.ListenableWorker.Result;
               import androidx.work.Worker;
               import androidx.work.WorkerParameters;

               class MyWorker extends Worker {

                 public MyWorker(@NonNull Context appContext, @NonNull WorkerParameters params) {
                   super(appContext, params);
                 }

                 @Override
                 public Result doWork() {
                   // Do your work here.
                   Data input = getInputData();

                   // Return a ListenableWorker.Result
                   Data outputData = new Data.Builder()
                       .putString(‚ÄúKey‚Äù, ‚Äúvalue‚Äù)
                       .build();
                   return Result.success(outputData);
                 }

                 @Override
                 public void onStopped() {
                   // Cleanup because you are being stopped.
                 }
               }

   Here ``doWork()`` returns an instance of ``ListenableWorker.Result``
   to signal work completion synchronously. This is similar to
   ``SimpleJobService``, which schedules jobs on a background thread.

   .. rubric:: JobBuilder maps to WorkRequest
      :name: jobbuilder_maps_to_workrequests

   FirebaseJobBuilder uses ``Job.Builder`` to represent ``Job``
   metadata. WorkManager uses
   `WorkRequest <#>`__ to fill
   this role.

   WorkManager has two types of ``WorkRequest``\ s:
   `OneTimeWorkRequest <#>`__
   and
   `PeriodicWorkRequest <#>`__.

   If you are currently using ``Job.Builder.setRecurring(true)``, then
   you should create a new ``PeriodicWorkRequest``. Otherwise, you
   should use a ``OneTimeWorkRequest``.

   Let‚Äôs look at what scheduling a complex ``Job`` with
   ``FirebaseJobDispatcher`` might look like:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val input: Bundle = Bundle().apply {
                   putString("some_key", "some_value")
               }

               val job = dispatcher.newJobBuilder()
                   // the JobService that will be called
                   .setService(MyService::class.java)
                   // uniquely identifies the job
                   .setTag("my-unique-tag")
                   // one-off job
                   .setRecurring(false)
                   // don't persist past a device reboot
                   .setLifetime(Lifetime.UNTIL_NEXT_BOOT)
                   // start between 0 and 60 seconds from now
                   .setTrigger(Trigger.executionWindow(0, 60))
                   // don't overwrite an existing job with the same tag
                   .setReplaceCurrent(false)
                   // retry with exponential backoff
                   .setRetryStrategy(RetryStrategy.DEFAULT_EXPONENTIAL)

                   .setConstraints(
                       // only run on an unmetered network
                       Constraint.ON_UNMETERED_NETWORK,
                       // // only run when the device is charging
                       Constraint.DEVICE_CHARGING
                   )
                   .setExtras(input)
                   .build()

               dispatcher.mustSchedule(job)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Bundle input = new Bundle();
               input.putString("some_key", "some_value");

               Job myJob = dispatcher.newJobBuilder()
                   // the JobService that will be called
                   .setService(MyJobService.class)
                   // uniquely identifies the job
                   .setTag("my-unique-tag")
                   // one-off job
                   .setRecurring(false)
                   // don't persist past a device reboot
                   .setLifetime(Lifetime.UNTIL_NEXT_BOOT)
                   // start between 0 and 60 seconds from now
                   .setTrigger(Trigger.executionWindow(0, 60))
                   // don't overwrite an existing job with the same tag
                   .setReplaceCurrent(false)
                   // retry with exponential backoff
                   .setRetryStrategy(RetryStrategy.DEFAULT_EXPONENTIAL)
                   // constraints that need to be satisfied for the job to run
                   .setConstraints(
                       // only run on an unmetered network
                       Constraint.ON_UNMETERED_NETWORK,
                       // only run when the device is charging
                       Constraint.DEVICE_CHARGING
                   )
                   .setExtras(input)
                   .build();

               dispatcher.mustSchedule(myJob);

   To achieve the same with WorkManager you will need to:

   -  Build input data which can be used as input for the ``Worker``.
   -  Build a ``WorkRequest`` with the input data and constraints
      similar to the ones defined above for ``FirebaseJobDispatcher``.
   -  Enqueue the ``WorkRequest``.

   .. rubric:: Setting up inputs for the Worker
      :name: setting_up_inputs_for_the_worker

   ``FirebaseJobDispatcher`` uses a ``Bundle`` to send input data to the
   ``JobService``. WorkManager uses
   `Data <#>`__ instead. So that
   becomes:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               import androidx.work.workDataOf
               val data = workDataOf("some_key" to "some_val")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import androidx.work.Data;
               Data input = new Data.Builder()
                   .putString("some_key", "some_value")
                   .build();

   .. rubric:: Setting up Constraints for the Worker
      :name: setting_up_constraints_for_the_worker

   ``FirebaseJobDispatcher`` uses
   `Job.Builder.setConstaints(...) <https://github.com/firebase/firebase-jobdispatcher-android/blob/master/jobdispatcher/src/main/java/com/firebase/jobdispatcher/Job.java#L287>`__
   to set up constraints on jobs. WorkManager uses
   `Constraints <#>`__ instead.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               import androidx.work.*

               val constraints: Constraints = Constraints.Builder().apply {
                   setRequiredNetworkType(NetworkType.CONNECTED)
                   setRequiresCharging(true)
               }.build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import androidx.work.Constraints;
               import androidx.work.Constraints.Builder;
               import androidx.work.NetworkType;

               Constraints constraints = new Constraints.Builder()
                   // The Worker needs Network connectivity
                   .setRequiredNetworkType(NetworkType.CONNECTED)
                   // Needs the device to be charging
                   .setRequiresCharging(true)
                   .build();

   .. rubric:: Creating the WorkRequest (OneTime or Periodic)
      :name: creating_the_workrequest_onetime_or_periodic

   To create ``OneTimeWorkRequest``\ s and ``PeriodicWorkRequest``\ s
   you should use
   `OneTimeWorkRequest.Builder <#>`__
   and
   `PeriodicWorkRequest.Builder <#>`__.

   To create a ``OneTimeWorkRequest`` which is similar to the above
   ``Job`` you should do the following:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               import androidx.work.*
               import java.util.concurrent.TimeUnit

               val constraints: Constraints = TODO("Define constraints as above")
               val request: OneTimeWorkRequest =
                    // Tell which work to execute
                    OneTimeWorkRequestBuilder<MyWorker>()
                        // Sets the input data for the ListenableWorker
                       .setInputData(input)
                       // If you want to delay the start of work by 60 seconds
                       .setInitialDelay(60, TimeUnit.SECONDS)
                       // Set a backoff criteria to be used when retry-ing
                       .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 30000, TimeUnit.MILLISECONDS)
                       // Set additional constraints
                       .setConstraints(constraints)
                       .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import androidx.work.BackoffCriteria;
               import androidx.work.Constraints;
               import androidx.work.Constraints.Builder;
               import androidx.work.NetworkType;
               import androidx.work.OneTimeWorkRequest;
               import androidx.work.OneTimeWorkRequest.Builder;
               import androidx.work.Data;

               // Define constraints (as above)
               Constraints constraints = ...
               OneTimeWorkRequest request =
                   // Tell which work to execute
                   new OneTimeWorkRequest.Builder(MyWorker.class)
                       // Sets the input data for the ListenableWorker
                       .setInputData(inputData)
                       // If you want to delay the start of work by 60 seconds
                       .setInitialDelay(60, TimeUnit.SECONDS)
                       // Set a backoff criteria to be used when retry-ing
                       .setBackoffCriteria(BackoffCriteria.EXPONENTIAL, 30000, TimeUnit.MILLISECONDS)
                       // Set additional constraints
                       .setConstraints(constraints)
                       .build();

   The key difference here is that WorkManager‚Äôs jobs are always
   persisted across device reboot automatically.

   If you want to create a ``PeriodicWorkRequest`` then you would do
   something like:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val constraints: Constraints = TODO("Define constraints as above")
               val request: PeriodicWorkRequest =
               PeriodicWorkRequestBuilder<MyWorker>(15, TimeUnit.MINUTES)
                   // Sets the input data for the ListenableWorker
                   .setInputData(input)
                   // Other setters
                   .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import androidx.work.BackoffCriteria;
               import androidx.work.Constraints;
               import androidx.work.Constraints.Builder;
               import androidx.work.NetworkType;
               import androidx.work.PeriodicWorkRequest;
               import androidx.work.PeriodicWorkRequest.Builder;
               import androidx.work.Data;

               // Define constraints (as above)
               Constraints constraints = ...

               PeriodicWorkRequest request =
                   // Executes MyWorker every 15 minutes
                   new PeriodicWorkRequest.Builder(MyWorker.class, 15, TimeUnit.MINUTES)
                       // Sets the input data for the ListenableWorker
                       .setInputData(input)
                       . // other setters (as above)
                       .build();

   .. rubric:: Scheduling work
      :name: scheduling_work

   Now that you have defined a ``Worker`` and a ``WorkRequest``, you are
   ready to schedule work.

   Every ``Job`` defined with ``FirebaseJobDispatcher`` had a ``tag``
   which was used to *uniquely identify* a ``Job``. It also provided a
   way for the application to tell the scheduler if this instance of a
   ``Job`` was to replace an existing copy of the ``Job`` by calling
   ``setReplaceCurrent``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val job = dispatcher.newJobBuilder()
                   // the JobService that will be called
                   .setService(MyService::class.java)
                   // uniquely identifies the job
                   .setTag("my-unique-tag")
                   // don't overwrite an existing job with the same tag
                   .setRecurring(false)
                   // Other setters...
                   .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Job myJob = dispatcher.newJobBuilder()
                   // the JobService that will be called
                   .setService(MyJobService.class)
                   // uniquely identifies the job
                   .setTag("my-unique-tag")
                   // don't overwrite an existing job with the same tag
                   .setReplaceCurrent(false)
                   // other setters
                   // ...

               dispatcher.mustSchedule(myJob);

   When using WorkManager, you can achieve the same result by using
   ``enqueueUniqueWork()`` and ``enqueueUniquePeriodicWork()`` APIs
   (when using a ``OneTimeWorkRequest`` and a ``PeriodicWorkRequest``,
   respectively). For more information, see the reference pages for
   `WorkManager.enqueueUniqueWork() <#enqueueUniqueWork>`__
   and
   `WorkManager.enqueueUniquePeriodicWork() <#enqueueUniquePeriodicWork>`__.

   This will look something like:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               import androidx.work.*

               val request: OneTimeWorkRequest = TODO("A WorkRequest")
               WorkManager.getInstance(myContext)
                   .enqueueUniqueWork("my-unique-name", ExistingWorkPolicy.KEEP, request)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import androidx.work.ExistingWorkPolicy;
               import androidx.work.OneTimeWorkRequest;
               import androidx.work.WorkManager;

               OneTimeWorkRequest workRequest = // a WorkRequest;
               WorkManager.getInstance(myContext)
                   // Use ExistingWorkPolicy.REPLACE to cancel and delete any existing pending
                   // (uncompleted) work with the same unique name. Then, insert the newly-specified
                   // work.
                   .enqueueUniqueWork("my-unique-name", ExistingWorkPolicy.KEEP, workRequest);

   **Note:**\  ``Job`` tags in FirebaseJobDispatcher map to the ``name``
   of the ``WorkRequest`` for WorkManager.

   .. rubric:: Cancelling work
      :name: cancelling_work

   With ``FirebaseJobDispatcher`` you could cancel work using:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               dispatcher.cancel("my-unique-tag")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               dispatcher.cancel("my-unique-tag");

   When using WorkManager you can use:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               import androidx.work.WorkManager
               WorkManager.getInstance(myContext).cancelUniqueWork("my-unique-name")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import androidx.work.WorkManager;
               WorkManager.getInstance(myContext).cancelUniqueWork("my-unique-name");

   .. rubric:: Initializing WorkManager
      :name: initializing_workmanager

   WorkManager typically initializes itself by using a
   ``ContentProvider``. If you require more control over how WorkManager
   organizes and schedules work, you can `customize the WorkManager configuration and initialization <#>`__.

Last updated 2024-01-03 UTC.

/Migrating from GCMNetworkManager to WorkManager
================================================

.. container:: devsite-article-body clearfix

   This document explains how to migrate apps to use the WorkManager
   client library to perform background operations instead of the
   GCMNetworkManager library. The preferred way for an app to schedule
   background jobs is to use WorkManager. By also including the
   WorkManager GCM library, you can enable WorkManager to use GCM to
   schedule the tasks when running on Android devices running API level
   22 or lower.

   .. rubric:: Migrate to WorkManager
      :name: migrate-wm

   If your app currently uses GCMNetworkManager to perform background
   operations, follow these steps to migrate to WorkManager.

   For the following steps, we assume you're starting with the following
   GCMNetworkManager code, which defines and schedules your task:

   .. container::
      :name: gcm-before

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val myTask = OneoffTask.Builder()
                   // setService() says what class does the work
                   .setService(MyUploadService::class.java)
                   // Don't run the task unless device is charging
                   .setRequiresCharging(true)
                   // Run the task between 5 & 15 minutes from now
                   .setExecutionWindow(5 * DateUtil.MINUTE_IN_SECONDS,
                           15 * DateUtil.MINUTE_IN_SECONDS)
                   // Define a unique tag for the task
                   .setTag("test-upload")
                   // ...finally, build the task and assign its value to myTask
                   .build()
               GcmNetworkManager.getInstance(this).schedule(myTask)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // In GcmNetworkManager, this call defines the task and its
               // runtime constraints:
               OneoffTask myTask = new OneoffTask.Builder()
                   // setService() says what class does the work
                   .setService(MyUploadService.class)
                   // Don't run the task unless device is charging
                   .setRequiresCharging(true)
                   // Run the task between 5 & 15 minutes from now
                   .setExecutionWindow(
                       5 * DateUtil.MINUTE_IN_SECONDS,
                       15 * DateUtil.MINUTE_IN_SECONDS)
                   // Define a unique tag for the task
                   .setTag("test-upload")
                   // ...finally, build the task and assign its value to myTask
                   .build();
               GcmNetworkManager.getInstance(this).schedule(myTask);

   In this example, we assume ``MyUploadService`` defines the actual
   upload operation:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyUploadService : GcmTaskService() {
                   fun onRunTask(params: TaskParams): Int {
                       // Do some upload work
                       return GcmNetworkManager.RESULT_SUCCESS
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class MyUploadService extends GcmTaskService {
                   @Override
                   public int onRunTask(TaskParams params) {
                       // Do some upload work
                       return GcmNetworkManager.RESULT_SUCCESS;
                   }
               }

   .. rubric:: Include the WorkManager libraries
      :name: include-wm

   To use the WorkManager classes, you need to add the WorkManager
   library to your build dependencies. You also need to add the
   WorkManager GCM library, which enables WorkManager to use GCM for job
   scheduling when your app is running on devices that don't support
   JobScheduler (that is, devices running API level 22 or lower). For
   full details on adding the libraries, see `Getting started with WorkManager <#>`__.

   .. rubric:: Modify your manifest
      :name: manifest

   When you implemented GCMNetworkManager, you added an instance of
   ``GcmTaskService`` to your app manifest, as described in the
   ``GcmNetworkManager`` `reference documentation <https://developers.google.cn/android/reference/com/google/android/gms/gcm/GcmNetworkManager>`__.
   ``GcmTaskService`` looks at the incoming task and delegates it to the
   task handler. WorkManager manages task delegation to your Worker, so
   you no longer need a class that does this; simply remove your
   ``GcmTaskService`` from the manifest.

   **Note:**\  You might have added logic to your ``GcmTaskService`` to
   do some work before dispatching the task to the handler. In that
   case, you need to refactor and move that logic into the
   `Worker <#>`__ class you define in
   the next section.

   .. rubric:: Define the Worker
      :name: define-worker

   Your GCMNetworkManager implementation defines a ``OneoffTask`` or
   ``RecurringTask``, which specifies just what work needs to be done.
   You need to rewrite that as a ``Worker``, as documented in `Defining your work requests <#>`__.

   **Note:**\  In GCMNetworkManager, the task defines both what work you
   want to do, and when the task should run. With the ``WorkManager``
   library, you use two different classes to define these elements. The
   `Worker <#>`__ defines the task you
   want to perform; when you create the
   `WorkRequest <#>`__, you
   specify any constraints on when the job should run.
   The `sample GCMNetworkManager code <#gcm-before>`__ defines a
   ``myTask`` task. The WorkManager equivalent looks like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class UploadWorker(context: Context, params: WorkerParameters)
                                       : Worker(context, params) {
                   override fun doWork() : Result {
                       // Do the upload operation ...
                       myUploadOperation()

                       // Indicate whether the task finished successfully with the Result
                       return Result.success()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class UploadWorker extends Worker {

                   public UploadWorker(
                       @NonNull Context context,
                       @NonNull WorkerParameters params) {
                       super(context, params);
                   }

                   @Override
                   public Result doWork() {
                     // Do the upload operation ...

                     myUploadOperation()

                     // Indicate whether the task finished successfully with the Result
                     return Result.success()
                   }
               }

   There are a few differences between the GCM task and the ``Worker``:

   -  GCM uses a ``TaskParams`` object to pass parameters to the task.
      The ``WorkManager`` uses input data, which you can specify on the
      ``WorkRequest``, as described in the ``WorkManager`` documentation
      for `Defining input/output for your task <#input_output>`__.
      In both cases, you can pass key/value pairs specifying any
      persistable parameters needed by the task.
   -  The ``GcmTaskService`` signals success or failure by returning
      flags like ``GcmNetworkManager.RESULT_SUCCESS``. A WorkManager
      ``Worker`` signals its results by using a
      `ListenableWorker.Result <#>`__
      method, like
      `ListenableWorker.Result.success() <#success>`__,
      and returning that method's return value.
   -  As we mentioned, you do not set the constraints or tags when you
      define the ``Worker``; instead, you do this in the next step, when
      you create the ``WorkRequest``.

   .. rubric:: Schedule the work request
      :name: schedule-work

   Defining a ``Worker`` specifies *what* you need done. To specify when
   the work should be done, you need to define the
   `WorkRequest <#>`__:

   #. Create a
      `OneTimeWorkRequest <#>`__
      or
      `PeriodicWorkRequest <#>`__,
      and set any desired constraints specifying when the task should
      run, as well as any tags to identify your work.
   #. Pass the request to
      `WorkManager.enqueue() <#enqueue>`__
      to have the task queued for execution.

   For example, the `previous section <#define-worker>`__ showed how to
   convert a ``OneoffTask`` to an equivalent ``Worker``. However, that
   ``Worker`` did not include the ``OneoffTask`` object's execution
   constraints and tag. Instead, we set the constraints and task ID when
   we create the ``WorkRequest``. We'll also specify that the task must
   not run unless there's a network connection. You don't need to
   explicitly request a network connection with GCMNetworkManager, since
   GCMNetworkManager requires a network connection by default, but
   WorkManager does not require a network connection unless you
   specifically add that constraint. Once we've defined the
   ``WorkRequest``, we enqueue it with WorkManager.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val uploadConstraints = Constraints.Builder()
                   .setRequiredNetworkType(NetworkType.CONNECTED)
                   .setRequiresCharging(true).build()

               val uploadTask = OneTimeWorkRequestBuilder&lt;UploadWorker>()
                   .setConstraints(uploadConstraints)
                   .build()
               WorkManager.getInstance().enqueue(uploadTask)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Constraints uploadConstraints = new Constraints.Builder()
                   .setRequiredNetworkType(NetworkType.CONNECTED)
                   .setRequiresCharging(true)
                   .build();

               OneTimeWorkRequest uploadTask =
                       new OneTimeWorkRequest.Builder(UploadWorker.class)
                 .setConstraints(uploadConstraints)
                 .build();
               WorkManager.getInstance().enqueue(uploadTask);

   **Note:**\  With GCMNetworkManager, every task must have a unique
   tag. The analogous WorkManager construct is the ``WorkRequest`` ID.
   This ID is automatically set by WorkManager when the request is
   created; you get the ID by calling
   `WorkRequest.getId() <#getId>`__.
   WorkManager also allows you to define tags for your jobs, but these
   are different from GCMNetworkManager tags because they need not be
   unique; you might have several similar WorkManager tasks all enqueued
   at once, and all using the same tag.
   **Note:**\  GCMNetworkManager requires you to define an execution
   window, but WorkManager does not require this. Instead, WorkManager
   runs the job as soon as possible after the constraints are met. In
   this example, we assume you don't actually need to set a specific
   time for the job to run.

   .. rubric:: API mappings
      :name: api-mappings

   This section describes how some GCMNetworkManager features and
   constraints map onto WorkManager equivalents.

   .. rubric:: Constraint mappings
      :name: constraints

   GCMNetworkManager lets you set a number of constraints on when your
   task should run. In most cases, there's a clear equivalent
   WorkManager constraint. This section lists those equivalents.

   Set constraints on GCMNetworkManager tasks by calling the appropriate
   method in the task's Builder object; for example, you can set a
   network requirement by calling
   `Task.Builder.setRequiredNetwork() <https://developer.google.com/android/reference/com/google/android/gms/gcm/Task.Builder.html#setRequiredNetwork(int)>`__.

   In WorkManager, you create a
   `Constraints.Builder <#>`__
   object and call that object's methods to set constraints (for
   example,
   `Constraints.Builder.setRequiredNetworkType()) <#setRequiredNetworkType>`__,
   then use the Builder to create a Constraints object which you can
   attach to the work request. For more information, see `Defining your work requests <#constraints>`__.

   **Note:**\  GCMNetworkManager allows you to specify a specific
   execution window for your task. There is no equivalent functionality
   in WorkManager. If you need to do work at a precise time, we
   recommend using other options, like
   `AlarmManager <#>`__.

   .. list-table::
      :header-rows: 1

      - 

         - GCMNetworkManager constraint
         - WorkManager equivalent
         - Notes
      - 

         - `setPersisted() <https://developers.google.cn/android/reference/com/google/android/gms/gcm/Task.Builder#setPersisted(boolean)>`__
         - *(not required)*
         - All WorkManager jobs are persisted across device reboots
      - 

         - `setRequiredNetwork() <https://developers.google.cn/android/reference/com/google/android/gms/gcm/Task.Builder#public-abstract-task.builder-setrequirednetwork-int-requirednetworkstate>`__
         - `setRequiredNetworkType() <#setRequiredNetworkType>`__
         - By default GCMNetworkManager requires network access.
            WorkManager does not require network access by default. If
            your job requires network access, you must use
            ``setRequiredNetworkType(CONNECTED)``, or set some more
            specific network type.
      - 

         - `setRequiresCharging() <https://developers.google.cn/android/reference/com/google/android/gms/gcm/Task.Builder#public-abstract-task.builder-setrequirescharging-boolean-requirescharging>`__
         - 
         - 

   .. rubric:: Other mappings
      :name: other-mappings

   Besides constraints, there are other settings you can apply to
   GCMNetworkManager tasks. This section lists the corresponding way to
   apply those settings to a WorkManager job.

   .. rubric:: Tags
      :name: tags-wm

   All GCMNetworkManager tasks must have a tag string, which you set by
   calling the Builder's
   `setTag() <https://developers.google.cn/android/reference/com/google/android/gms/gcm/Task.Builder#setTag(java.lang.String)>`__
   method. WorkManager jobs are uniquely identified by an ID, which is
   automatically generated by WorkManager; you can get that ID by
   calling
   `WorkRequest.getId() <#getId>`__.
   In addition, work requests can *optionally* have one or more tags. To
   set a tag for your WorkManager job, call the
   `WorkRequest.Builder.addTag() <#addTag>`__
   method, before you use that Builder to create the ``WorkRequest``.

   In GCMNetworkManager, you can call
   `setUpdateCurrent() <https://developers.google.cn/android/reference/com/google/android/gms/gcm/Task.Builder.html#setUpdateCurrent(boolean)>`__
   to specify whether the task should replace any existing task with the
   same tag. The equivalent WorkManager approach is to enqueue the task
   by calling
   `enqueueUniqueWork() <#enqueueUniqueWork>`__
   or
   `enqueueUniquePeriodicWork() <#enqueueUniquePeriodicWork>`__;
   if you use these methods, you give the job a unique name, and also
   specify how WorkManager should handle the request if there's already
   a pending job with that name. For more information, see `Handling unique work <#unique-work>`__.

   .. rubric:: Task parameters
      :name: task-param

   You can pass parameters to a GCMNetworkManager job by calling
   `Task.Builder.setExtras() <https://developers.google.cn/android/reference/com/google/android/gms/gcm/Task.Builder#setExtras(android.os.Bundle)>`__
   and passing a ``Bundle`` containing the parameters. WorkManager
   allows you to pass a ``Data`` object to the WorkManager job,
   containing the parameters as key/value pairs. For details, see
   `Assign input data <#assign_input_data>`__.

Last updated 2024-01-03 UTC.


/Overview: Introduction to activities
=====================================

.. https://developer.android.google.cn/guide/components/activities/intro-activities

.. container:: devsite-article-body clearfix

   The `Activity <#>`__ class is a
   crucial component of an Android app, and the way activities are
   launched and put together is a fundamental part of the platform's
   application model. Unlike programming paradigms in which apps are
   launched with a ``main()`` method, the Android system initiates code
   in an `Activity <#>`__ instance by
   invoking specific callback methods that correspond to specific stages
   of its lifecycle.

   This document introduces the concept of activities, and then provides
   some lightweight guidance about how to work with them. For additional
   information about best practices in architecting your app, see `Guide to App Architecture <#>`__.

   .. rubric:: The concept of activities
      :name: tcoa

   The mobile-app experience differs from its desktop counterpart in
   that a user's interaction with the app doesn't always begin in the
   same place. Instead, the user journey often begins
   non-deterministically. For instance, if you open an email app from
   your home screen, you might see a list of emails. By contrast, if you
   are using a social media app that then launches your email app, you
   might go directly to the email app's screen for composing an email.

   The `Activity <#>`__ class is
   designed to facilitate this paradigm. When one app invokes another,
   the calling app invokes an activity in the other app, rather than the
   app as an atomic whole. In this way, the activity serves as the entry
   point for an app's interaction with the user. You implement an
   activity as a subclass of the
   `Activity <#>`__ class.

   An activity provides the window in which the app draws its UI. This
   window typically fills the screen, but may be smaller than the screen
   and float on top of other windows. Generally, one activity implements
   one screen in an app. For instance, one of an app‚Äôs activities may
   implement a *Preferences* screen, while another activity implements a
   *Select Photo* screen.

   Most apps contain multiple screens, which means they comprise
   multiple activities. Typically, one activity in an app is specified
   as the *main activity*, which is the first screen to appear when the
   user launches the app. Each activity can then start another activity
   in order to perform different actions. For example, the main activity
   in a simple e-mail app may provide the screen that shows an e-mail
   inbox. From there, the main activity might launch other activities
   that provide screens for tasks like writing e-mails and opening
   individual e-mails.

   Although activities work together to form a cohesive user experience
   in an app, each activity is only loosely bound to the other
   activities; there are usually minimal dependencies among the
   activities in an app. In fact, activities often start up activities
   belonging to other apps. For example, a browser app might launch the
   Share activity of a social-media app.

   To use activities in your app, you must register information about
   them in the app‚Äôs manifest, and you must manage activity lifecycles
   appropriately. The rest of this document introduces these subjects.

   .. rubric:: Configuring the manifest
      :name: ctm

   For your app to be able to use activities, you must declare the
   activities, and certain of their attributes, in the manifest.

   .. rubric:: Declare activities
      :name: da

   To declare your activity, open your manifest file and add an
   ``<activity>`` element as a
   child of the
   ``<application>``
   element. For example:

   .. code:: prettyprint

      <manifest ... >
        <application ... >
            <activity android:name=".ExampleActivity" />
            ...
        </application ... >
        ...
      </manifest >

   The only required attribute for this element is
   `android:name <#nm>`__, which
   specifies the class name of the activity. You can also add attributes
   that define activity characteristics such as label, icon, or UI
   theme. For more information about these and other attributes, see the
   ``<activity>`` element
   reference documentation.

   **Note:** After you publish your app, you should not change activity
   names. If you do, you might break some functionality, such as app
   shortcuts. For more information on changes to avoid after publishing,
   see `Things That Cannot Change <http://android-developers.blogspot.com/2011/06/things-that-cannot-change.html>`__.

   .. rubric:: Declare intent filters
      :name: dif

   `Intent filters <#>`__ are a very
   powerful feature of the Android platform. They provide the ability to
   launch an activity based not only on an *explicit* request, but also
   an *implicit* one. For example, an explicit request might tell the
   system to ‚ÄúStart the Send Email activity in the Gmail app". By
   contrast, an implicit request tells the system to ‚ÄúStart a Send Email
   screen in any activity that can do the job." When the system UI asks
   a user which app to use in performing a task, that‚Äôs an intent filter
   at work.

   You can take advantage of this feature by declaring an
   ``<intent-filter>`` attribute in the
   ``<activity>`` element. The definition of this element includes an
   ``<action>`` element and, optionally, a
   ``<category>`` element and/or a ``<data>`` element.
   These elements combine to specify the type of intent to which your
   activity can respond. For example, the following code snippet shows
   how to configure an activity that sends text data, and receives
   requests from other activities to do so:

   .. code:: prettyprint

      <activity android:name=".ExampleActivity" android:icon="@drawable/app_icon">
          <intent-filter>
              <action android:name="android.intent.action.SEND" />
              <category android:name="android.intent.category.DEFAULT" />
              <data android:mimeType="text/plain" />
          </intent-filter>
      </activity>

   In this example, the
   ``<action>`` element
   specifies that this activity sends data. Declaring the
   ``<category>`` element as
   ``DEFAULT`` enables the activity to receive launch requests. The
   ``<data>`` element specifies
   the type of data that this activity can send. The following code
   snippet shows how to call the activity described above:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val sendIntent = Intent().apply {
                   action = Intent.ACTION_SEND
                   type = "text/plain"
                   putExtra(Intent.EXTRA_TEXT, textMessage)
               }
               startActivity(sendIntent)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create the text message with a string
               Intent sendIntent = new Intent();
               sendIntent.setAction(Intent.ACTION_SEND);
               sendIntent.setType("text/plain");
               sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);
               // Start the activity
               startActivity(sendIntent);

   If you intend for your app to be self-contained and not allow other
   apps to activate its activities, you don't need any other intent
   filters. Activities that you don't want to make available to other
   applications should have no intent filters, and you can start them
   yourself using explicit intents. For more information about how your
   activities can respond to intents, see `Intents and Intent Filters <#>`__.

   .. rubric:: Declare permissions
      :name: dp

   You can use the manifest's
   ``<activity>`` tag to
   control which apps can start a particular activity. A parent activity
   cannot launch a child activity unless both activities have the same
   permissions in their manifest. If you declare a
   ``<uses-permission>``
   element for a parent activity, each child activity must have a
   matching
   ``<uses-permission>``
   element.

   For example, if your app wants to use a hypothetical app named
   SocialApp to share a post on social media, SocialApp itself must
   define the permission that an app calling it must have:

   .. code:: prettyprint

      <manifest>
      <activity android:name="...."
         android:permission=‚Äùcom.google.socialapp.permission.SHARE_POST‚Äù

      />

   Then, to be allowed to call SocialApp, your app must match the
   permission set in SocialApp's manifest:

   .. code:: prettyprint

      <manifest>
         <uses-permission android:name="com.google.socialapp.permission.SHARE_POST" />
      </manifest>

   For more information on permissions and security in general, see
   `Security and Permissions <#>`__.

   .. rubric:: Managing the activity lifecycle
      :name: mtal

   Over the course of its lifetime, an activity goes through a number of
   states. You use a series of callbacks to handle transitions between
   states. The following sections introduce these callbacks.

   .. rubric:: onCreate()
      :name: oncreate

   You must implement this callback, which fires when the system creates
   your activity. Your implementation should initialize the essential
   components of your activity: For example, your app should create
   views and bind data to lists here. Most importantly, this is where
   you must call `setContentView() <#setContentView>`__
   to define the layout for the activity's user interface.

   When `onCreate() <#onCreate>`__ finishes, the next callback is always
   `onStart() <#onStart>`__.

   .. rubric:: onStart()
      :name: onstart

   As `onCreate() <#onCreate>`__
   exits, the activity enters the Started state, and the activity
   becomes visible to the user. This callback contains what amounts to
   the activity‚Äôs final preparations for coming to the foreground and
   becoming interactive.

   .. rubric:: onResume()
      :name: onresume

   The system invokes this callback just before the activity starts
   interacting with the user. At this point, the activity is at the top
   of the activity stack, and captures all user input. Most of an app‚Äôs
   core functionality is implemented in the
   `onResume() <#onResume>`__
   method.

   The `onPause() <#onPause>`__
   callback always follows
   `onResume() <#onResume>`__.

   .. rubric:: onPause()
      :name: onpause

   The system calls `onPause() <#onPause>`__ when
   the activity loses focus and enters a Paused state. This state occurs
   when, for example, the user taps the Back or Recents button. When the
   system calls `onPause() <#onPause>`__ for
   your activity, it technically means your activity is still partially
   visible, but most often is an indication that the user is leaving the
   activity, and the activity will soon enter the Stopped or Resumed
   state.

   An activity in the Paused state may continue to update the UI if the
   user is expecting the UI to update. Examples of such an activity
   include one showing a navigation map screen or a media player
   playing. Even if such activities lose focus, the user expects their
   UI to continue updating.

   You should **not** use `onPause() <#onPause>`__ to save
   application or user data, make network calls, or execute database
   transactions. For information about saving data, see `Saving and restoring activity state <#saras>`__.

   Once `onPause() <#onPause>`__ finishes executing, the next callback is either
   `onStop() <#onStop>`__ or `onResume() <#onResume>`__,
   depending on what happens after the activity enters the Paused state.

   .. rubric:: onStop()
      :name: onstop

   The system calls
   `onStop() <#onStop>`__ when the
   activity is no longer visible to the user. This may happen because
   the activity is being destroyed, a new activity is starting, or an
   existing activity is entering a Resumed state and is covering the
   stopped activity. In all of these cases, the stopped activity is no
   longer visible at all.

   The next callback that the system calls is either
   `onRestart() <#onRestart>`__, if
   the activity is coming back to interact with the user, or by
   `onDestroy() <#onDestroy>`__ if
   this activity is completely terminating.

   .. rubric:: onRestart()
      :name: onrestart

   The system invokes this callback when an activity in the Stopped
   state is about to restart.
   `onRestart() <#onRestart>`__
   restores the state of the activity from the time that it was stopped.

   This callback is always followed by
   `onStart() <#onStart>`__.

   .. rubric:: onDestroy()
      :name: ondestroy

   The system invokes this callback before an activity is destroyed.

   This callback is the final one that the activity receives.
   `onDestroy() <#onDestroy>`__ is
   usually implemented to ensure that all of an activity‚Äôs resources are
   released when the activity, or the process containing it, is
   destroyed.

   This section provides only an introduction to this topic. For a more
   detailed treatment of the activity lifecycle and its callbacks, see
   `The Activity Lifecycle <#>`__.

Last updated 2024-01-03 UTC.


/The activity lifecycle
=======================

.. container:: devsite-article-body clearfix

   As a user navigates through, out of, and back to your app, the
   `Activity <#>`__ instances in your
   app transition through different states in their lifecycle. The
   ``Activity`` class provides a number of callbacks that let the
   activity know when a state changes or that the system is creating,
   stopping, or resuming an activity or destroying the process the
   activity resides in.

   Within the lifecycle callback methods, you can declare how your
   activity behaves when the user leaves and re-enters the activity. For
   example, if you're building a streaming video player, you might pause
   the video and terminate the network connection when the user switches
   to another app. When the user returns, you can reconnect to the
   network and let the user resume the video from the same spot.

   Each callback lets you perform specific work that's appropriate to a
   given change of state. Doing the right work at the right time and
   handling transitions properly make your app more robust and
   performant. For example, good implementation of the lifecycle
   callbacks can help your app avoid the following:

   -  Crashing if the user receives a phone call or switches to another
      app while using your app.
   -  Consuming valuable system resources when the user is not actively
      using it.
   -  Losing the user's progress if they leave your app and return to it
      at a later time.
   -  Crashing or losing the user's progress when the screen rotates
      between landscape and portrait orientation.

   This document explains the activity lifecycle in detail. The document
   begins by describing the lifecycle paradigm. Next, it explains each
   of the callbacks: what happens internally while they execute and what
   you need to implement during them.

   It then briefly introduces the relationship between activity state
   and a process‚Äôs vulnerability to being killed by the system. Finally,
   it discusses several topics related to transitions between activity
   states.

   For information about handling lifecycles, including guidance about
   best practices, see `Handling Lifecycles with Lifecycle-Aware Components <#>`__ and `Save UI states <#>`__. To learn how
   to architect a robust, production-quality app using activities in
   combination with architecture components, see `Guide to app architecture <#>`__.

   .. rubric:: Activity-lifecycle concepts
      :name: alc

   To navigate transitions between stages of the activity lifecycle, the
   ``Activity`` class provides a core set of six callbacks:
   `onCreate() <#onCreate>`__,
   `onStart() <#onStart>`__,
   `onResume() <#onResume>`__,
   `onPause() <#onPause>`__,
   `onStop() <#onStop>`__, and
   `onDestroy() <#onDestroy>`__.
   The system invokes each of these callbacks as the activity enters a
   new state.

   Figure 1 presents a visual representation of this paradigm.

   .. container:: attempt-right

   ::

                           ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ  
                           ‚îÇ   Activity  ‚îÇ  
                           ‚îÇ   Launched  ‚îÇ  
                           ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ  
                                  V        
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
             ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ    onCreate()   ‚îÇ
             ‚îÇ           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ                    V        
             ‚îÇ           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
             ‚îÇ           ‚îÇ     onStart()   ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ   onRestart()   ‚îÇ<‚îÄ‚ïÆ 
             ‚îÇ           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
      User navigates              V                                     ‚îÇ
      to the actiity     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                            ‚îÇ
             ‚îÇ           ‚îÇ    onResume()   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ                   ‚îÇ
             ‚îÇ           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ                   ‚îÇ
             ‚îÇ                    V                 ‚îÇ                   ‚îÇ
      ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ      ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ          ‚îÇ                   ‚îÇ
      ‚îÇ App process ‚îÇ      ‚îÇ   Activity  ‚îÇ    User returns       User navigates 
      ‚îÇ    killed   ‚îÇ      ‚îÇ   Running   ‚îÇ    to the activity   to the activity 
      ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ      ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ          ‚îÇ                   ‚îÇ
             ‚îÇ                    ‚îÇ  Another activity come              ‚îÇ
      Apps with highter priority  V  into the foreground                ‚îÇ
      need memory        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ                   ‚îÇ
             ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ    onPause()    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ                   ‚îÇ
             ‚îÇ           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îÇ
             ‚îÇ                    ‚îÇ   The activity is                   ‚îÇ
             ‚îÇ                    V   nolonger visible                  ‚îÇ
             ‚îÇ           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                            ‚îÇ
             ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ     onStop()    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                  ‚îÇ   The activity is finishing or
                                  V   being destoryed by the system
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  
                         ‚îÇ   onDestory()   ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                  V        
                           ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ  
                           ‚îÇ   Activity  ‚îÇ  
                           ‚îÇ   Shutdown  ‚îÇ  
                           ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ  

      https://developer.android.google.cn/guide/components/images/activity_lifecycle.png

      **Figure 1.** A simplified illustration of the activity lifecycle.

   As the user begins to leave the activity, the system calls methods to
   dismantle the activity. In some cases, the activity is only partially
   dismantled and still resides in memory, such as when the user
   switches to another app. In these cases, the activity can still come
   back to the foreground.

   If the user returns to the activity, it resumes from where the user
   left off. With a few exceptions, apps are 
   `restricted from starting activities when running in the background <#>`__.

   The system‚Äôs likelihood of killing a given process, along with the
   activities in it, depends on the state of the activity at the time.
   For more information on the relationship between state and
   vulnerability to ejection, see the section about 
   `activity state and ejection from memory <#asem>`__.

   Depending on the complexity of your activity, you probably don't need
   to implement all the lifecycle methods. However, it's important that
   you understand each one and implement those that make your app behave
   the way users expect.

   .. rubric:: Lifecycle callbacks
      :name: lc

   This section provides conceptual and implementation information about
   the callback methods used during the activity lifecycle.

   Some actions belong in the activity lifecycle methods. However, place
   code that implements the actions of a dependent component in the
   component, rather than the activity lifecycle method. To achieve
   this, you need to make the dependent component lifecycle-aware. To
   learn how to make your dependent components lifecycle-aware, see
   `Handling Lifecycles with Lifecycle-Aware Components <#>`__.

   .. rubric:: onCreate()
      :name: oncreate

   You must implement this callback, which fires when the system first
   creates the activity. On activity creation, the activity enters the
   *Created* state. In the
   `onCreate() <#onCreate>`__
   method, perform basic application startup logic that happens only
   once for the entire life of the activity.

   For example, your implementation of ``onCreate()`` might bind data to
   lists, associate the activity with a
   `ViewModel <#>`__, and
   instantiate some class-scope variables. This method receives the
   parameter ``savedInstanceState``, which is a
   `Bundle <#>`__ object containing the
   activity's previously saved state. If the activity has never existed
   before, the value of the ``Bundle`` object is null.

   If you have a lifecycle-aware component that is hooked up to the
   lifecycle of your activity, it receives the
   `ON_CREATE <#ON_CREATE>`__
   event. The method annotated with ``@OnLifecycleEvent`` is called so
   your lifecycle-aware component can perform any setup code it needs
   for the created state.

   The following example of the ``onCreate()`` method shows fundamental
   setup for the activity, such as declaring the user interface (defined
   in an XML layout file), defining member variables, and configuring
   some of the UI. In this example, the XML layout file passes the
   file‚Äôs resource ID ``R.layout.main_activity`` to
   `setContentView() <#setContentView>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               lateinit var textView: TextView

               // Some transient state for the activity instance.
               var gameState: String? = null

               override fun onCreate(savedInstanceState: Bundle?) {
                   // Call the superclass onCreate to complete the creation of
                   // the activity, like the view hierarchy.
                   super.onCreate(savedInstanceState)

                   // Recover the instance state.
                   gameState = savedInstanceState?.getString(GAME_STATE_KEY)

                   // Set the user interface layout for this activity.
                   // The layout is defined in the project res/layout/main_activity.xml file.
                   setContentView(R.layout.main_activity)

                   // Initialize member TextView so it is available later.
                   textView = findViewById(R.id.text_view)
               }

               // This callback is called only when there is a saved instance previously saved using
               // onSaveInstanceState(). Some state is restored in onCreate(). Other state can optionally
               // be restored here, possibly usable after onStart() has completed.
               // The savedInstanceState Bundle is same as the one used in onCreate().
               override fun onRestoreInstanceState(savedInstanceState: Bundle?) {
                   textView.text = savedInstanceState?.getString(TEXT_VIEW_KEY)
               }

               // Invoked when the activity might be temporarily destroyed; save the instance state here.
               override fun onSaveInstanceState(outState: Bundle?) {
                   outState?.run {
                       putString(GAME_STATE_KEY, gameState)
                       putString(TEXT_VIEW_KEY, textView.text.toString())
                   }
                   // Call superclass to save any view hierarchy.
                   super.onSaveInstanceState(outState)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               TextView textView;

               // Some transient state for the activity instance.
               String gameState;

               @Override
               public void onCreate(Bundle savedInstanceState) {
                   // Call the superclass onCreate to complete the creation of
                   // the activity, like the view hierarchy.
                   super.onCreate(savedInstanceState);

                   // Recover the instance state.
                   if (savedInstanceState != null) {
                       gameState = savedInstanceState.getString(GAME_STATE_KEY);
                   }

                   // Set the user interface layout for this activity.
                   // The layout is defined in the project res/layout/main_activity.xml file.
                   setContentView(R.layout.main_activity);

                   // Initialize member TextView so it is available later.
                   textView = (TextView) findViewById(R.id.text_view);
               }

               // This callback is called only when there is a saved instance previously saved using
               // onSaveInstanceState(). Some state is restored in onCreate(). Other state can optionally
               // be restored here, possibly usable after onStart() has completed.
               // The savedInstanceState Bundle is same as the one used in onCreate().
               @Override
               public void onRestoreInstanceState(Bundle savedInstanceState) {
                   textView.setText(savedInstanceState.getString(TEXT_VIEW_KEY));
               }

               // Invoked when the activity might be temporarily destroyed; save the instance state here.
               @Override
               public void onSaveInstanceState(Bundle outState) {
                   outState.putString(GAME_STATE_KEY, gameState);
                   outState.putString(TEXT_VIEW_KEY, textView.getText());

                   // Call superclass to save any view hierarchy.
                   super.onSaveInstanceState(outState);
               }

   As an alternative to defining the XML file and passing it to
   `setContentView() <#setContentView>`__,
   you can create new `View <#>`__
   objects in your activity code and build a view hierarchy by inserting
   new ``View`` objects into a
   `ViewGroup <#>`__. You then use
   that layout by passing the root ``ViewGroup`` to
   ``setContentView()``. For more information about creating a user
   interface, see the `user interface <#>`__
   documentation.

   Your activity does not remain in the Created state. After the
   ``onCreate()`` method finishes execution, the activity enters the
   *Started* state and the system calls the
   `onStart() <#onStart>`__ and
   `onResume() <#onResume>`__
   methods in quick succession.

   .. rubric:: onStart()
      :name: onstart

   When the activity enters the Started state, the system invokes
   `onStart() <#onStart>`__. This
   call makes the activity visible to the user as the app prepares for
   the activity to enter the foreground and become interactive. For
   example, this method is where the code that maintains the UI is
   initialized.

   When the activity moves to the Started state, any lifecycle-aware
   component tied to the activity's lifecycle receives the
   `ON_START <#ON_START>`__
   event.

   The ``onStart()`` method completes quickly and, as with the Created
   state, the activity does not remain in the Started state. Once this
   callback finishes, the activity enters the *Resumed* state and the
   system invokes the
   `onResume() <#onResume>`__
   method.

   .. rubric:: onResume()
      :name: onresume

   When the activity enters the Resumed state, it comes to the
   foreground, and the system invokes the
   `onResume() <#onResume>`__
   callback. This is the state in which the app interacts with the user.
   The app stays in this state until something happens to take focus
   away from the app, such as the device receiving a phone call, the
   user navigating to another activity, or the device screen turning
   off.

   When the activity moves to the Resumed state, any lifecycle-aware
   component tied to the activity's lifecycle receives the
   `ON_RESUME <#ON_RESUME>`__
   event. This is where the lifecycle components can enable any
   functionality that needs to run while the component is visible and in
   the foreground, such as starting a camera preview.

   When an interruptive event occurs, the activity enters the *Paused*
   state and the system invokes the
   `onPause() <#onPause>`__
   callback.

   If the activity returns to the Resumed state from the Paused state,
   the system once again calls the ``onResume()`` method. For this
   reason, implement ``onResume()`` to initialize components that you
   release during ``onPause()`` and to perform any other initializations
   that must occur each time the activity enters the Resumed state.

   Here is an example of a lifecycle-aware component that accesses the
   camera when the component receives the ``ON_RESUME`` event:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CameraComponent : LifecycleObserver {
                   ...
                   @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
                   fun initializeCamera() {
                       if (camera == null) {
                           getCamera()
                       }
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CameraComponent implements LifecycleObserver {

                   ...

                   @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
                   public void initializeCamera() {
                       if (camera == null) {
                           getCamera();
                       }
                   }
                   ...
               }

   The preceding code initializes the camera once the
   `LifecycleObserver <#>`__
   receives the ``ON_RESUME`` event. In multi-window mode, however, your
   activity might be fully visible even when it is in the Paused state.
   For example, when the app is in multi-window mode and the user taps
   the window that does not contain your activity, your activity moves
   to the Paused state.

   If you want the camera active only when the app is Resumed (visible
   and active in the foreground), then initialize the camera after the
   ``ON_RESUME`` event demonstrated previously. If you want to keep the
   camera active while the activity is Paused but visible, such as in
   multi-window mode, then initialize the camera after the ``ON_START``
   event.

   However, having the camera active while your activity is Paused might
   deny access to the camera to another Resumed app in multi-window
   mode. Sometimes it is necessary to keep the camera active while your
   activity is Paused, but it might actually degrade the overall user
   experience if you do.

   For this reason, think carefully about where in the lifecycle it is
   most appropriate to take control of shared system resources in the
   context of multi-window mode. To learn more about supporting
   multi-window mode, see `Multi-window support <#>`__.

   Regardless of which build-up event you choose to perform an
   initialization operation in, make sure to use the corresponding
   lifecycle event to release the resource. If you initialize something
   after the ``ON_START`` event, release or terminate it after the
   ``ON_STOP`` event. If you initialize after the ``ON_RESUME`` event,
   release after the ``ON_PAUSE`` event.

   The preceding code snippet places camera initialization code in a
   lifecycle-aware component. You can instead put this code directly
   into the activity lifecycle callbacks, such as ``onStart()`` and
   ``onStop()``, but we don't recommend this. Adding this logic to an
   independent, lifecycle-aware component lets you reuse the component
   across multiple activities without having to duplicate code. To learn
   how to create a lifecycle-aware component, see `Handling Lifecycles with Lifecycle-Aware Components <#>`__.

   .. rubric:: onPause()
      :name: onpause

   The system calls this method as the first indication that the user is
   leaving your activity, though it does not always mean the activity is
   being destroyed. It indicates that the activity is no longer in the
   foreground, but it is still visible if the user is in multi-window
   mode. There are several reasons why an activity might enter this
   state:

   -  An event that interrupts app execution, as described in the
      section about the `onResume() <#onresume>`__ callback, pauses the
      current activity. This is the most common case.
   -  In multi-window mode, only one app has focus at any time, and the
      system pauses all the other apps.
   -  The opening of a new, semi-transparent activity, such as a dialog,
      pauses the activity it covers. As long as the activity is
      partially visible but not in focus, it remains paused.

   When an activity moves to the Paused state, any lifecycle-aware
   component tied to the activity's lifecycle receives the
   `ON_PAUSE <#ON_PAUSE>`__
   event. This is where the lifecycle components can stop any
   functionality that does not need to run while the component is not in
   the foreground, such as stopping a camera preview.

   Use the `onPause() <#onPause>`__
   method to pause or adjust operations that can't continue, or might
   continue in moderation, while the ``Activity`` is in the Paused
   state, and that you expect to resume shortly.

   You can also use the ``onPause()`` method to release system
   resources, handles to sensors (like GPS), or any resources that
   affect battery life while your activity is Paused and the user does
   not need them.

   However, as mentioned in the section about ``onResume()``, a Paused
   activity might still be fully visible if the app is in multi-window
   mode. Consider using ``onStop()`` instead of ``onPause()`` to fully
   release or adjust UI-related resources and operations to better
   support multi-window mode.

   The following example of a
   `LifecycleObserver <#>`__
   reacting to the ``ON_PAUSE`` event is the counterpart to the
   preceding ``ON_RESUME`` event example, releasing the camera that
   initializes after the ``ON_RESUME`` event is received:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CameraComponent : LifecycleObserver {
                   ...
                   @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
                   fun releaseCamera() {
                       camera?.release()
                       camera = null
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class JavaCameraComponent implements LifecycleObserver {
                   ...
                   @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
                   public void releaseCamera() {
                       if (camera != null) {
                           camera.release();
                           camera = null;
                       }
                   }
                   ...
               }

   This example places the camera release code after the ``ON_PAUSE``
   event is received by the ``LifecycleObserver``.

   ``onPause()`` execution is very brief and does not necessarily offer
   enough time to perform save operations. For this reason, **don't**
   use ``onPause()`` to save application or user data, make network
   calls, or execute database transactions. Such work might not complete
   before the method completes.

   Instead, perform heavy-load shutdown operations during
   `onStop() <#onStop>`__. For more
   information about suitable operations to perform during ``onStop()``,
   see the next section. For more information about saving data, see the
   section about `saving and restoring state <#saras>`__.

   Completion of the ``onPause()`` method does not mean that the
   activity leaves the Paused state. Rather, the activity remains in
   this state until either the activity resumes or it becomes completely
   invisible to the user. If the activity resumes, the system once again
   invokes the ``onResume()`` callback.

   If the activity returns from the Paused state to the Resumed state,
   the system keeps the ``Activity`` instance resident in memory,
   recalling that instance when the system invokes ``onResume()``. In
   this scenario, you don‚Äôt need to re-initialize components created
   during any of the callback methods leading up to the Resumed state.
   If the activity becomes completely invisible, the system calls
   ``onStop()``.

   .. rubric:: onStop()
      :name: onstop

   When your activity is no longer visible to the user, it enters the
   *Stopped* state, and the system invokes the
   `onStop() <#onStop>`__ callback.
   This can occur when a newly launched activity covers the entire
   screen. The system also calls ``onStop()`` when the activity finishes
   running and is about to be terminated.

   When the activity moves to the Stopped state, any lifecycle-aware
   component tied to the activity's lifecycle receives the
   `ON_STOP <#ON_STOP>`__
   event. This is where the lifecycle components can stop any
   functionality that does not need to run while the component is not
   visible on the screen.

   In the ``onStop()`` method, release or adjust resources that are not
   needed while the app is not visible to the user. For example, your
   app might pause animations or switch from fine-grained to
   coarse-grained location updates. Using ``onStop()`` instead of
   `onPause() <#onPause>`__ means
   that UI-related work continues, even when the user is viewing your
   activity in multi-window mode.

   Also, use ``onStop()`` to perform relatively CPU-intensive shutdown
   operations. For example, if you can't find a better time to save
   information to a database, you might do so during ``onStop()``. The
   following example shows an implementation of ``onStop()`` that saves
   the contents of a draft note to persistent storage:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onStop() {
                   // Call the superclass method first.
                   super.onStop()

                   // Save the note's current draft, because the activity is stopping
                   // and we want to be sure the current note progress isn't lost.
                   val values = ContentValues().apply {
                       put(NotePad.Notes.COLUMN_NAME_NOTE, getCurrentNoteText())
                       put(NotePad.Notes.COLUMN_NAME_TITLE, getCurrentNoteTitle())
                   }

                   // Do this update in background on an AsyncQueryHandler or equivalent.
                   asyncQueryHandler.startUpdate(
                           token,     // int token to correlate calls
                           null,      // cookie, not used here
                           uri,       // The URI for the note to update.
                           values,    // The map of column names and new values to apply to them.
                           null,      // No SELECT criteria are used.
                           null       // No WHERE columns are used.
                   )
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onStop() {
                   // Call the superclass method first.
                   super.onStop();

                   // Save the note's current draft, because the activity is stopping
                   // and we want to be sure the current note progress isn't lost.
                   ContentValues values = new ContentValues();
                   values.put(NotePad.Notes.COLUMN_NAME_NOTE, getCurrentNoteText());
                   values.put(NotePad.Notes.COLUMN_NAME_TITLE, getCurrentNoteTitle());

                   // Do this update in background on an AsyncQueryHandler or equivalent.
                   asyncQueryHandler.startUpdate (
                           mToken,  // int token to correlate calls
                           null,    // cookie, not used here
                           uri,    // The URI for the note to update.
                           values,  // The map of column names and new values to apply to them.
                           null,    // No SELECT criteria are used.
                           null     // No WHERE columns are used.
                   );
               }

   The preceding code sample uses SQLite directly. However, we recommend
   using Room, a persistence library that provides an abstraction layer
   over SQLite. To learn more about the benefits of using Room and how
   to implement Room in your app, see the `Room Persistence Library <#>`__ guide.

   When your activity enters the Stopped state, the ``Activity`` object
   is kept resident in memory: it maintains all state and member
   information, but is not attached to the window manager. When the
   activity resumes, it recalls this information.

   You don‚Äôt need to re-initialize components created during any of the
   callback methods leading up to the Resumed state. The system also
   keeps track of the current state for each ``View`` object in the
   layout, so if the user enters text into an
   `EditText <#>`__ widget, that
   content is retained so you don't need to save and restore it.

   **Note:** Once your activity is stopped, the system might destroy the
   process that contains the activity if the system needs to recover
   memory. Even if the system destroys the process while the activity is
   stopped, the system still retains the state of the ``View`` objects,
   such as text in an ``EditText`` widget, in a ``Bundle``‚Äîa blob of
   key-value pairs‚Äîand restores them if the user navigates back to the
   activity. For more information about restoring an activity to which a
   user returns, see the section about `saving and restoring state <#saras>`__.

   From the Stopped state, the activity either comes back to interact
   with the user, or the activity is finished running and goes away. If
   the activity comes back, the system invokes
   `onRestart() <#onRestart>`__. If
   the ``Activity`` is finished running, the system calls
   `onDestroy() <#onDestroy>`__.

   .. rubric:: onDestroy()
      :name: ondestroy

   `onDestroy() <#onDestroy>`__ is
   called before the activity is destroyed. The system invokes this
   callback for one of two reasons:

   #. The activity is finishing, due to the user completely dismissing
      the activity or due to
      `finish() <#finish>`__ being
      called on the activity.
   #. The system is temporarily destroying the activity due to a
      configuration change, such as device rotation or entering
      multi-window mode.

   When the activity moves to the destroyed state, any lifecycle-aware
   component tied to the activity's lifecycle receives the
   `ON_DESTROY <#ON_DESTROY>`__
   event. This is where the lifecycle components can clean up anything
   they need to before the ``Activity`` is destroyed.

   Instead of putting logic in your ``Activity`` to determine why it is
   being destroyed, use a
   `ViewModel <#>`__ object to
   contain the relevant view data for your ``Activity``. If the
   ``Activity`` is recreated due to a configuration change, the
   ``ViewModel`` does not have to do anything, since it is preserved and
   given to the next ``Activity`` instance.

   If the ``Activity`` isn't recreated, then the ``ViewModel`` has the
   `onCleared() <#onCleared>`__
   method called, where it can clean up any data it needs to before
   being destroyed. You can distinguish between these two scenarios with
   the
   `isFinishing() <#isFinishing>`__
   method.

   If the activity is finishing, ``onDestroy()`` is the final lifecycle
   callback the activity receives. If ``onDestroy()`` is called as the
   result of a configuration change, the system immediately creates a
   new activity instance and then calls
   `onCreate() <#onCreate>`__
   on that new instance in the new configuration.

   The ``onDestroy()`` callback releases all resources not released by
   earlier callbacks, such as
   `onStop() <#onStop>`__.

   .. rubric:: Activity state and ejection from memory
      :name: asem

   The system kills processes when it needs to free up RAM. The
   likelihood of the system killing a given process depends on the state
   of the process at the time. Process state, in turn, depends on the
   state of the activity running in the process. Table 1 shows the
   correlations among process state, activity state, and the likelihood
   of the system killing the process. This table only applies if a
   process is not running other types of application components.

   .. list-table::
      :header-rows: 1

      - 

         - Likelihood of being killed
         - Process state
         - Final activity state
      - 

         - Lowest
         - Foreground (having or about to get focus)
         - Resumed
      - 

         - Low
         - Visible (no focus)
         - Started/Paused
      - 

         - Higher
         - Background (invisible)
         - Stopped
      - 

         - Highest
         - Empty
         - Destroyed

   **Table 1.** Relationship between process lifecycle and activity
   state.

   The system never kills an activity directly to free up memory.
   Instead, it kills the process the activity runs in, destroying not
   only the activity but everything else running in the process as well.
   To learn how to preserve and restore your activity's UI state when
   system-initiated process death occurs, see the section about `saving and restoring state <#saras>`__.

   The user can also kill a process by using the Application Manager,
   under Settings, to kill the corresponding app.

   For more information about processes, see `Processes and threads overview <#>`__.

   .. rubric:: Saving and restoring transient UI state
      :name: saras

   A user expects an activity‚Äôs UI state to remain the same throughout a
   configuration change, such as rotation or switching into multi-window
   mode. However, the system destroys the activity by default when such
   a configuration change occurs, wiping away any UI state stored in the
   activity instance.

   Similarly, a user expects UI state to remain the same if they
   temporarily switch away from your app to a different app and then
   come back to your app later. However, the system can destroy your
   application‚Äôs process while the user is away and your activity is
   stopped.

   When system constraints destroy the activity, preserve the user‚Äôs
   transient UI state using a combination of
   `ViewModel <#>`__,
   `onSaveInstanceState() <#onSaveInstanceState>`__,
   and/or local storage. To learn more about user expectations compared
   to system behavior and how to best preserve complex UI state data
   across system-initiated activity and process death, see `Save UI states <#>`__.

   This section outlines what instance state is and how to implement the
   ``onSaveInstance()`` method, which is a callback on the activity
   itself. If your UI data is lightweight, you can use
   ``onSaveInstance()`` alone to persist the UI state across both
   configuration changes and system-initiated process death. But because
   ``onSaveInstance()`` incurs serialization/deserialization costs, in
   most cases you use both ``ViewModel`` and ``onSaveInstance()``, as
   outlined in `Save UI states <#>`__.

   **Note:** To learn more about configuration changes, how to restrict
   Activity recreation if needed, and how to react to those
   configuration changes from the View system and Jetpack Compose, check
   out the `Handle configuration changes <#>`__ page.

   .. rubric:: Instance state
      :name: instance-state

   There are a few scenarios in which your activity is destroyed due to
   normal app behavior, such as when the user presses the Back button or
   your activity signals its own destruction by calling the
   `finish() <#finish>`__ method.

   When your activity is destroyed because the user presses Back or the
   activity finishes itself, both the system's and the user's concept of
   that `Activity <#>`__ instance is
   gone forever. In these scenarios, the user's expectation matches the
   system's behavior, and you do not have any extra work to do.

   However, if the system destroys the activity due to system
   constraints (such as a configuration change or memory pressure), then
   although the actual ``Activity`` instance is gone, the system
   remembers that it existed. If the user attempts to navigate back to
   the activity, the system creates a new instance of that activity
   using a set of saved data that describes the state of the activity
   when it was destroyed.

   The saved data that the system uses to restore the previous state is
   called the *instance state*. It's a collection of key-value pairs
   stored in a `Bundle <#>`__ object. By
   default, the system uses the ``Bundle`` instance state to save
   information about each `View <#>`__
   object in your activity layout, such as the text value entered into
   an `EditText <#>`__ widget.

   So, if your activity instance is destroyed and recreated, the state
   of the layout is restored to its previous state with no code required
   by you. However, your activity might have more state information that
   you'd like to restore, such as member variables that track the user's
   progress in the activity.

   **Note:** In order for the Android system to restore the state of the
   views in your activity, each view must have a unique ID, supplied by
   the ``android:id`` attribute.

   A ``Bundle`` object isn't appropriate for preserving more than a
   trivial amount of data, because it requires serialization on the main
   thread and consumes system-process memory. To preserve more than a
   very small amount of data, take a combined approach to preserving
   data, using persistent local storage, the ``onSaveInstanceState()``
   method, and the ``ViewModel`` class, as outlined in `Save UI states <#>`__.

   .. rubric:: Save simple, lightweight UI state using
      onSaveInstanceState()
      :name: save-simple,-lightweight-ui-state-using-onsaveinstancestate

   As your activity begins to stop, the system calls the
   `onSaveInstanceState() <#onSaveInstanceState>`__
   method so your activity can save state information to an instance
   state bundle. The default implementation of this method saves
   transient information about the state of the activity's view
   hierarchy, such as the text in an
   `EditText <#>`__ widget or the
   scroll position of a
   `ListView <#>`__ widget.

   To save additional instance state information for your activity,
   override ``onSaveInstanceState()`` and add key-value pairs to the
   ``Bundle`` object that is saved in the event that your activity is
   destroyed unexpectedly. When you override ``onSaveInstanceState()``,
   you need to call the superclass implementation if you want the
   default implementation to save the state of the view hierarchy. This
   is shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onSaveInstanceState(outState: Bundle?) {
                   // Save the user's current game state.
                   outState?.run {
                       putInt(STATE_SCORE, currentScore)
                       putInt(STATE_LEVEL, currentLevel)
                   }

                   // Always call the superclass so it can save the view hierarchy state.
                   super.onSaveInstanceState(outState)
               }

               companion object {
                   val STATE_SCORE = "playerScore"
                   val STATE_LEVEL = "playerLevel"
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               static final String STATE_SCORE = "playerScore";
               static final String STATE_LEVEL = "playerLevel";
               // ...


               @Override
               public void onSaveInstanceState(Bundle savedInstanceState) {
                   // Save the user's current game state.
                   savedInstanceState.putInt(STATE_SCORE, currentScore);
                   savedInstanceState.putInt(STATE_LEVEL, currentLevel);

                   // Always call the superclass so it can save the view hierarchy state.
                   super.onSaveInstanceState(savedInstanceState);
               }

   **Note:** ``onSaveInstanceState()`` is not called when the user
   explicitly closes the activity or in other cases when ``finish()`` is
   called.

   To save persistent data, such as user preferences or data for a
   database, take appropriate opportunities when your activity is in the
   foreground. If no such opportunity arises, save persistent data
   during the
   `onStop() <#onStop>`__ method.

   .. rubric:: Restore activity UI state using saved instance state
      :name: restore-activity-ui-state-using-saved-instance-state

   When your activity is recreated after it was previously destroyed,
   you can recover your saved instance state from the
   `Bundle <#>`__ that the system passes
   to your activity. Both the
   `onCreate() <#onCreate>`__
   and
   `onRestoreInstanceState() <#onRestoreInstanceState>`__
   callback methods receive the same ``Bundle`` that contains the
   instance state information.

   Because the ``onCreate()`` method is called whether the system is
   creating a new instance of your activity or recreating a previous
   one, you need to check whether the state ``Bundle`` is null before
   you attempt to read it. If it is null, then the system is creating a
   new instance of the activity, instead of restoring a previous one
   that was destroyed.

   The following code snippet shows how you can restore some state data
   in ``onCreate()``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState) // Always call the superclass first

                   // Check whether we're recreating a previously destroyed instance.
                   if (savedInstanceState != null) {
                       with(savedInstanceState) {
                           // Restore value of members from saved state.
                           currentScore = getInt(STATE_SCORE)
                           currentLevel = getInt(STATE_LEVEL)
                       }
                   } else {
                       // Probably initialize members with default values for a new instance.
                   }
                   // ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onCreate(Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState); // Always call the superclass first

                   // Check whether we're recreating a previously destroyed instance.
                   if (savedInstanceState != null) {
                       // Restore value of members from saved state.
                       currentScore = savedInstanceState.getInt(STATE_SCORE);
                       currentLevel = savedInstanceState.getInt(STATE_LEVEL);
                   } else {
                       // Probably initialize members with default values for a new instance.
                   }
                   // ...
               }

   Instead of restoring the state during ``onCreate()``, you can choose
   to implement ``onRestoreInstanceState()``, which the system calls
   after the
   `onStart() <#onStart>`__ method.
   The system calls ``onRestoreInstanceState()`` only if there is a
   saved state to restore, so you do not need to check whether the
   ``Bundle`` is null.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onRestoreInstanceState(savedInstanceState: Bundle?) {
                   // Always call the superclass so it can restore the view hierarchy.
                   super.onRestoreInstanceState(savedInstanceState)

                   // Restore state members from saved instance.
                   savedInstanceState?.run {
                       currentScore = getInt(STATE_SCORE)
                       currentLevel = getInt(STATE_LEVEL)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public void onRestoreInstanceState(Bundle savedInstanceState) {
                   // Always call the superclass so it can restore the view hierarchy.
                   super.onRestoreInstanceState(savedInstanceState);

                   // Restore state members from saved instance.
                   currentScore = savedInstanceState.getInt(STATE_SCORE);
                   currentLevel = savedInstanceState.getInt(STATE_LEVEL);
               }

   Caution: Always call the superclass implementation of
   ``onRestoreInstanceState()`` so the default implementation can
   restore the state of the view hierarchy.

   .. rubric:: Navigating between activities
      :name: tba

   An app is likely to enter and exit an activity, perhaps many times,
   during the app‚Äôs lifetime, such as when the user taps the device‚Äôs
   Back button or the activity launches a different activity.

   This section covers topics you need to know to implement successful
   activity transitions. These topics include starting an activity from
   another activity, saving activity state, and restoring activity
   state.

   .. rubric:: Starting one activity from another
      :name: soafa

   An activity often needs to start another activity at some point. This
   need arises, for instance, when an app needs to move from the current
   screen to a new one.

   Depending on whether or not your activity wants a result back from
   the new activity it‚Äôs about to start, you start the new activity
   using either the
   `startActivity() <#startActivity>`__
   method or the
   `startActivityForResult() <#startActivityForResult>`__
   method. In either case, you pass in an
   `Intent <#>`__ object.

   The ``Intent`` object specifies either the exact activity you want to
   start or describes the type of action you want to perform. The system
   selects the appropriate activity for you, which can even be from a
   different application. An ``Intent`` object can also carry small
   amounts of data to be used by the activity that is started. For more
   information about the ``Intent`` class, see `Intents and Intent Filters <#>`__.

   .. rubric:: startActivity()
      :name: startactivity

   If the newly started activity does not need to return a result, the
   current activity can start it by calling the
   `startActivity() <#startActivity>`__
   method.

   When working within your own application, you often need to simply
   launch a known activity. For example, the following code snippet
   shows how to launch an activity called ``SignInActivity``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val intent = Intent(this, SignInActivity::class.java)
               startActivity(intent)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Intent intent = new Intent(this, SignInActivity.class);
               startActivity(intent);

   Your application might also want to perform some action, such as send
   an email, text message, or status update, using data from your
   activity. In this case, your application might not have its own
   activities to perform such actions, so you can instead leverage the
   activities provided by other applications on the device, which can
   perform the actions for you.

   This is where intents are really valuable. You can create an intent
   that describes an action you want to perform, and the system launches
   the appropriate activity from another application. If there are
   multiple activities that can handle the intent, then the user can
   select which one to use. For example, if you want to let the user
   send an email message, you can create the following intent:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val intent = Intent(Intent.ACTION_SEND).apply {
                   putExtra(Intent.EXTRA_EMAIL, recipientArray)
               }
               startActivity(intent)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Intent intent = new Intent(Intent.ACTION_SEND);
               intent.putExtra(Intent.EXTRA_EMAIL, recipientArray);
               startActivity(intent);

   The ``EXTRA_EMAIL`` extra added to the intent is a string array of
   email addresses the email is to be sent to. When an email application
   responds to this intent, it reads the string array provided in the
   extra and places the addresses in the "to" field of the email
   composition form. In this situation, the email application's activity
   starts, and when the user is done, your activity resumes.

   .. rubric:: startActivityForResult()
      :name: startactivityforresult

   Sometimes you want to get a result back from an activity when it
   ends. For example, you might start an activity that lets the user
   pick a person in a list of contacts. When it ends, it returns the
   person that was selected. To do this, you call the
   `startActivityForResult(Intent, int) <#startActivityForResult>`__
   method, where the integer parameter identifies the call.

   This identifier is meant to distinguish between multiple calls to
   ``startActivityForResult(Intent, int)`` from the same activity. It's
   not a global identifier and is not at risk of conflicting with other
   apps or activities. The result comes back through your
   `onActivityResult(int, int, Intent) <#onActivityResult>`__
   method.

   When a child activity exits, it can call ``setResult(int)`` to return
   data to its parent. The child activity must supply a result code,
   which can be the standard results ``RESULT_CANCELED``, ``RESULT_OK``,
   or any custom values starting at ``RESULT_FIRST_USER``.

   In addition, the child activity can optionally return an ``Intent``
   object containing any additional data it wants. The parent activity
   uses the ``onActivityResult(int, int, Intent)`` method, along with
   the integer identifier the parent activity originally supplied, to
   receive the information.

   If a child activity fails for any reason, such as crashing, the
   parent activity receives a result with the code ``RESULT_CANCELED``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyActivity : Activity() {
                   // ...

                   override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {
                       if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
                           // When the user center presses, let them pick a contact.
                           startActivityForResult(
                                   Intent(Intent.ACTION_PICK,Uri.parse("content://contacts")),
                                   PICK_CONTACT_REQUEST)
                           return true
                       }
                       return false
                   }

                   override fun onActivityResult(requestCode: Int, resultCode: Int, intent: Intent?) {
                       when (requestCode) {
                           PICK_CONTACT_REQUEST ->
                               if (resultCode == RESULT_OK) {
                                   // A contact was picked. Display it to the user.
                                   startActivity(Intent(Intent.ACTION_VIEW, intent?.data))
                               }
                       }
                   }

                   companion object {
                       internal val PICK_CONTACT_REQUEST = 0
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyActivity extends Activity {
                    // ...

                    static final int PICK_CONTACT_REQUEST = 0;

                    public boolean onKeyDown(int keyCode, KeyEvent event) {
                        if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
                            // When the user center presses, let them pick a contact.
                            startActivityForResult(
                                new Intent(Intent.ACTION_PICK,
                                new Uri("content://contacts")),
                                PICK_CONTACT_REQUEST);
                           return true;
                        }
                        return false;
                    }

                    protected void onActivityResult(int requestCode, int resultCode,
                            Intent data) {
                        if (requestCode == PICK_CONTACT_REQUEST) {
                            if (resultCode == RESULT_OK) {
                                // A contact was picked. Display it to the user.
                                startActivity(new Intent(Intent.ACTION_VIEW, data));
                            }
                        }
                    }
                }

   .. rubric:: Coordinating activities
      :name: coordinating-activities

   When one activity starts another, they both experience lifecycle
   transitions. The first activity stops operating and enters the Paused
   or Stopped state, while the other activity is created. In case these
   activities share data saved to disc or elsewhere, it's important to
   understand that the first activity is not completely stopped before
   the second one is created. Rather, the process of starting the second
   one overlaps with the process of stopping the first one.

   The order of lifecycle callbacks is well defined, particularly when
   the two activities are in the same process‚Äîin other words, the same
   app‚Äîand one is starting the other. Here's the order of operations
   that occur when Activity A starts Activity B:

   #. Activity A's
      `onPause() <#onPause>`__
      method executes.
   #. Activity B's
      `onCreate() <#onCreate>`__,
      `onStart() <#onStart>`__, and
      `onResume() <#onResume>`__
      methods execute in sequence. Activity B now has user focus.
   #. If Activity A is no longer visible on screen, its
      `onStop() <#onStop>`__ method
      executes.

   This sequence of lifecycle callbacks lets you manage the transition
   of information from one activity to another.

Last updated 2024-01-03 UTC.


/Activity state changes
=======================

.. container:: devsite-article-body clearfix

   Different events, some user-triggered and some system-triggered, can
   cause an `Activity <#>`__ to
   transition from one state to another. This document describes some
   common cases in which such transitions happen and how to handle those
   transitions.

   For more information about activity states, see `The activity lifecycle <#>`__. To
   learn about how the
   `ViewModel <#>`__ class can
   help you manage the activity lifecycle, see the `ViewModel overview <#>`__.

   .. rubric:: Configuration change occurs
      :name: cco

   There are a number of events that can trigger a configuration change.
   Perhaps the most prominent example is a change between portrait and
   landscape orientations. Other cases that can cause configuration
   changes include changes to language settings or input device.

   When a configuration change occurs, the activity is destroyed and
   recreated. This triggers the following callbacks in the original
   activity instance:

   #. `onPause() <#onPause>`__
   #. `onStop() <#onStop>`__
   #. `onDestroy() <#onDestroy>`__

   A new instance of the activity is created, and the following
   callbacks are triggered:

   #. `onCreate() <#onCreate>`__
   #. `onStart() <#onStart>`__
   #. `onResume() <#onResume>`__

   Use a combination of ``ViewModel`` instances, the
   ``onSaveInstanceState()`` method, or persistent local storage to
   preserve an activity‚Äôs UI state across configuration changes.
   Deciding how to combine these options depends on the complexity of
   your UI data, use cases for your app, and consideration of the speed
   of retrieval versus memory usage. For more information about saving
   your activity UI state, see `Save UI states <#>`__.

   .. rubric:: Handle multi-window cases
      :name: multiwindow

   When an app enters multi-window mode, available in Android 7.0 (API
   level 24)and higher, the system notifies the running activity of a
   configuration change, thus going through the lifecycle transitions
   described previously.

   This behavior also occurs if an app already in multi-window mode gets
   resized. Your activity can handle the configuration change itself, or
   it can allow the system to destroy the activity and recreate it with
   the new dimensions.

   For more information about the multi-window lifecycle, see the
   explanation of the `multi-window lifecycle <#lifecycle>`__ in the
   `Multi-window support <#>`__ page.

   In multi-window mode, although there are two apps that are visible to
   the user, only the one the user is interacting with is in the
   foreground and has focus. That activity is in the Resumed state,
   while the app in the other window is in the Paused state.

   When the user switches from app A to app B, the system calls
   `onPause() <#onPause>`__ on app
   A and `onResume() <#onResume>`__
   on app B. It switches between these two methods each time the user
   toggles between apps.

   For more details about multi-window mode, refer to `Multi-window support <#>`__.

   .. rubric:: Activity or dialog appears in foreground
      :name: covered

   If a new activity or dialog appears in the foreground, taking focus
   and partially covering the activity in progress, the covered activity
   loses focus and enters the Paused state. Then, the system calls
   `onPause() <#onPause>`__ on it.

   When the covered activity returns to the foreground and regains
   focus, the system calls
   `onResume() <#onResume>`__.

   If a new activity or dialog appears in the foreground, taking focus
   and completely covering the activity in progress, the covered
   activity loses focus and enters the Stopped state. The system then,
   in rapid succession, calls ``onPause()`` and
   `onStop() <#onStop>`__.

   When the same instance of the covered activity returns to the
   foreground, the system calls
   `onRestart() <#onRestart>`__,
   `onStart() <#onStart>`__, and
   ``onResume()`` on the activity. If it is a new instance of the
   covered activity that comes to the background, the system does not
   call ``onRestart()``, only ``onStart()`` and ``onResume()``.

   **Note:**\  When the user taps the Overview or Home button, the
   system behaves as if the current activity has been completely
   covered.

   .. rubric:: User taps or gestures Back
      :name: back

   If an activity is in the foreground and the user taps or gestures
   Back, the activity transitions through the
   `onPause() <#onPause>`__,
   `onStop() <#onStop>`__, and
   `onDestroy() <#onDestroy>`__
   callbacks. The activity is destroyed and removed from the back stack.

   **Note:**\  If the activity is a root launcher activity, the system
   handles the event differently depending on the version of Android
   that the device is running. For more information, see `Back tap behavior for root launcher activities <#back-press-behavior>`__.
   By default, the
   `onSaveInstanceState() <#onSaveInstanceState>`__
   callback does not fire in this case. This behavior assumes the user
   taps Back with no expectation of returning to the same instance of
   the activity.

   However, you can override the
   `onBackPressed() <#onBackPressed>`__
   method to implement custom behavior, such as displaying a dialog that
   asks the user to confirm that they want to exit your app.

   If you override the ``onBackPressed()`` method, we highly recommend
   that you still invoke ``super.onBackPressed()`` from your overridden
   method. Otherwise the system Back behavior might be jarring to the
   user.

   .. rubric:: System kills app process
      :name: killed

   If an app is in the background and the system needs to free up memory
   for a foreground app, the system can kill the background app. When
   the system kills an app, there is no guarantee that ``onDestroy()``
   is called in the app.

   To learn more about how the system decides which processes to
   destroy, read `Activity state and ejection from memory <#asem>`__ and
   `Processes and app lifecycle <#>`__.

   To learn how to save your activity UI state when the system kills
   your app process, see `Saving and restoring transient UI state <#saras>`__.

Last updated 2023-03-29 UTC.



/Test your app's activities
===========================

.. container:: devsite-article-body clearfix

   Activities serve as containers for every user interaction within your
   app, so it's important to test how your app's activities behave
   during device-level events such as the following:

   -  Another app, such as the device's phone app, interrupts your app's
      activity.
   -  The system destroys and recreates your activity.
   -  The user places your activity in a new windowing environment, such
      as picture-in-picture (PIP) or multi-window.

   In particular, it's important to ensure that your activity behaves
   correctly in response to the events described in `The activity lifecycle <#>`__.

   This guide describes how to evaluate your app's ability to maintain
   data integrity and a good user experience as your app's activities
   transition through different states in their lifecycles.

   .. rubric:: Drive an activity's state
      :name: drive-activity-state

   One key aspect of testing your app's activities involves placing your
   app's activities in particular states. To define this "given" part of
   your tests, use instances of
   `ActivityScenario <#>`__,
   part of the `AndroidX Test <#>`__ library. Using this
   class, you can place your activity in states that simulate
   device-level events.

   ``ActivityScenario`` is a cross-platform API that you can use in
   local unit tests and on-device integration tests alike. On a real or
   virtual device, ``ActivityScenario`` provides thread safety,
   synchronizing events between your test's instrumentation thread and
   the thread that runs your activity under test.

   The API is particularly well suited for evaluating how an activity
   under test behaves when it's destroyed or created. This section
   presents the most common use cases associated with this API.

   .. rubric:: Create an activity
      :name: create

   To create the activity under test, add the code shown in the
   following snippet:

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class MyTestSuite {
          @Test fun testEvent() {
             launchActivity<MyActivity>().use {
             }
          }
      }

   After creating the activity, ``ActivityScenario`` transitions the
   activity to the ``RESUMED`` state. This state indicates that your
   activity is running and is visible to users. In this state, you're
   free to interact with your activity's ``View`` elements using
   `Espresso UI tests <#>`__.

   Google recommends that you call ``close`` on the activity when the
   test completes. This cleans up the associated resources and improves
   the stability of your tests. ``ActivityScenario`` implements
   ``Closeable``, so you can apply the ``use`` extension, or
   ``try-with-resources`` in the Java programming language, so that the
   activity closes automatically.

   Alternatively, you can use ``ActivityScenarioRule`` to automatically
   call ``ActivityScenario.launch`` before each test and
   ``ActivityScenario.close`` at test teardown. The following example
   shows how to define a rule and get an instance of a scenario from it:

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class MyTestSuite {
          @get:Rule var activityScenarioRule = activityScenarioRule<MyActivity>()

          @Test fun testEvent() {
              val scenario = activityScenarioRule.scenario
          }
      }

   .. rubric:: Drive the activity to a new state
      :name: drive-activity-new-state

   To drive the activity to a different state, such as ``CREATED`` or
   ``STARTED``, call ``moveToState()``. This action simulates a
   situation where your activity is stopped or paused, respectively,
   because it's interrupted by another app or a system action.

   An example usage of ``moveToState()`` appears in the following code
   snippet:

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class MyTestSuite {
          @Test fun testEvent() {
              launchActivity<MyActivity>().use { scenario ->
                  scenario.moveToState(State.CREATED)
              }
          }
      }

   **Caution:**\  If you try to transition your activity under test to
   its current state, ``ActivityScenario`` treats this request as a
   no-op, not an exception.

   .. rubric:: Determine the current activity state
      :name: determine-current-state

   To determine the current state of an activity under test, get the
   value of the ``state`` field within your ``ActivityScenario`` object.
   It's particularly helpful to check the state of an activity under
   test if the activity redirects to another activity or finishes
   itself, as demonstrated in the following code snippet:

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class MyTestSuite {
          @Test fun testEvent() {
              launchActivity<MyActivity>().use { scenario ->
                  scenario.onActivity { activity ->
                    startActivity(Intent(activity, MyOtherActivity::class.java))
                  }

                  val originalActivityState = scenario.state
              }
          }
      }

   .. rubric:: Recreate the activity
      :name: recreate

   When a device is low on resources, the system might destroy an
   activity, requiring your app to recreate that activity when the user
   returns to your app. To simulate these conditions, call
   ``recreate()``:

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class MyTestSuite {
          @Test fun testEvent() {
              launchActivity<MyActivity>().use { scenario ->
                  scenario.recreate()
              }
          }
      }

   The ``ActivityScenario`` class maintains the activity's saved
   instance state and any objects annotated using
   ``@NonConfigurationInstance``. These objects load into the new
   instance of your activity under test.

   .. rubric:: Retrieve activity results
      :name: retrieve-activity-results

   To get the result code or data associated with a finished activity,
   get the value of the ``result`` field within your
   ``ActivityScenario`` object, as shown in the following code snippet:

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class MyTestSuite {
          @Test fun testResult() {
              launchActivity<MyActivity>().use {
                  onView(withId(R.id.finish_button)).perform(click())

                  // Activity under test is now finished.

                  val resultCode = scenario.result.resultCode
                  val resultData = scenario.result.resultData
              }
          }
      }

   .. rubric:: Trigger actions in the activity
      :name: trigger-actions

   All methods within ``ActivityScenario`` are blocking calls, so the
   API requires you to run them in the instrumentation thread.

   To trigger actions in your activity under test, use Espresso view
   matchers to interact with elements in your view:

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class MyTestSuite {
          @Test fun testEvent() {
              launchActivity<MyActivity>().use {
                  onView(withId(R.id.refresh)).perform(click())
              }
          }
      }

   If you need to call a method on the activity itself, however, you can
   do so safely by implementing ``ActivityAction``:

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class MyTestSuite {
          @Test fun testEvent() {
              launchActivity<MyActivity>().use { scenario ->
                  scenario.onActivity { activity ->
                    activity.handleSwipeToRefresh()
                  }
              }
          }
      }

   **Note:**\  In your test class, don't keep references to the objects
   that you pass into ``onActivity()``. These references consume system
   resources, and the references themselves might be stale because the
   framework can recreate an activity that's passed into the callback
   method.

Last updated 2023-03-29 UTC.

/Tasks and the back stack
=========================

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   A *task* is a collection of activities that users interact with when
   trying to do something in your app. These activities are arranged in
   a stack called the *back stack* in the order in which each activity
   is opened.

   For example, an email app might have one activity to show a list of
   new messages. When the user selects a message, a new activity opens
   to view that message. This new activity is added to the back stack.
   Then, when the user taps or gestures Back, that new activity finishes
   and is popped off the stack.

   .. rubric:: Lifecycle of a task and its back stack
      :name: life-cycle

   The device Home screen is the starting place for most tasks. When a
   user touches the icon for an app or shortcut in the app launcher or
   on the Home screen, that app's task comes to the foreground. If no
   task exists for the app, then a new task is created and the `main activity <#tcoa>`__ for
   that app opens as the root activity in the stack.

   When the current activity starts another, the new activity is pushed
   on the top of the stack and takes focus. The previous activity
   remains in the stack, but is stopped. When an activity is stopped,
   the system retains the current state of its user interface. When the
   user performs the back action, the current activity is popped from
   the top of the stack and destroyed. The previous activity resumes,
   and the previous state of its UI is restored.

   Activities in the stack are never rearranged, only pushed onto and
   popped from the stack as they are started by the current activity and
   dismissed by the user through the Back button or gesture. Therefore,
   the back stack operates as a *last in, first out* object structure.
   Figure 1 shows a timeline with activities being pushed onto and
   popped from a back stack.

   ::
                                                  ‚ï≠‚îÄ‚îÄ‚îÄ Navigate ‚îÄ‚îÄ‚ïÆ  
                                                  ‚îÇ      Back     v  
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 
            ‚îÇ Activity1 ‚îÇ   ‚îÇ Activity2 ‚îÇ   ‚îÇ Activity3 ‚îÇ   ‚îÇ Activity2 ‚îÇ 
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò 
      Foreground  ‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>  ‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>  ‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>  ‚îÇ       
       Activity   ‚îÇ     Start     ‚îÇ     Start     ‚îÇ    Destory    ‚îÇ       
                  ‚îÇ   Activity2   ‚îÇ   Activity3   ‚îÇ   Activity3   ‚îÇ       
      ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      Back  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 
      Stack ‚îÇ           ‚îÇ   ‚îÇ Activity1 ‚îÇ   ‚îÇ Activity2 ‚îÇ   ‚îÇ Activity1 ‚îÇ 
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò 
                                            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 
                                            ‚îÇ Activity1 ‚îÇ 
                                            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò 
   
      https://developer.android.google.cn/static/images/fundamentals/diagram_backstack.png

      **Figure 1.** A representation of how each new activity in a task
      adds an item to the back stack. When the user taps or gestures
      Back, the current activity is destroyed and the previous activity
      resumes.

   As the user continues to tap or gesture Back, each activity in the
   stack is popped off to reveal the previous one, until the user
   returns to the Home screen or to whichever activity was running when
   the task began. When all activities are removed from the stack, the
   task no longer exists.

   .. rubric:: Back tap behavior for root launcher activities
      :name: back-press-behavior

   Root launcher activities are activities that declare an `intent filter <#>`__ with both
   `ACTION_MAIN <#ACTION_MAIN>`__
   and
   `CATEGORY_LAUNCHER <#CATEGORY_LAUNCHER>`__.
   These activities are unique because they act as entry points into
   your app from the app launcher and are used to `start a task <#Starting>`__.

   When a user taps or gestures Back from a root launcher activity, the
   system handles the event differently depending on the version of
   Android that the device is running.

   System behavior on Android 11 and lower
      The system finishes the activity.
   System behavior on Android 12 and higher
      The system moves the activity and its task to the background
      instead of finishing the activity. This behavior matches the
      default system behavior when navigating out of an app using the
      Home button or gesture.

      In most cases, this behavior means that users can more quickly
      resume your app from a `warm state <#warm>`__, instead of
      having to completely restart the app from a `cold state <#cold>`__.

      If you need to `provide custom back navigation <#>`__, we
      recommend using the AndroidX Activity APIs rather than overriding
      ``onBackPressed()``. The AndroidX Activity APIs automatically
      defer to the appropriate system behavior if there are no
      components intercepting the system Back tap.

      However, if your app overrides
      `onBackPressed() <#onBackPressed>`__
      to handle Back navigation and finish the activity, update your
      implementation to call through to ``super.onBackPressed()``
      instead of finishing. Calling ``super.onBackPressed()`` moves the
      activity and its task to the background when appropriate and
      provides a more consistent navigation experience for users across
      apps.

   .. rubric:: Background and foreground tasks
      :name: background-foreground

      ::

               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
               ‚îÇ ActivityZ ‚îÇ ‚îÇ ‚îÇ ActivityY ‚îÇ
               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         Foreground  ‚îÇ       ‚îÇ       ‚îÇ  Background 
          Activity   ‚îÇ       ‚îÇ       ‚îÇ   Activity  
         ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                     ‚îÇ       ‚îÇ       ‚îÇ      
               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
               ‚îÇ ActivityY ‚îÇ ‚îÇ ‚îÇ ActivityX ‚îÇ
               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  Task B     ‚îÇ    Task A    
      
      https://developer.android.google.cn/static/images/fundamentals/diagram_multitasking.png

      **Figure 2.** Two tasks: Task B receives user interaction in the
      foreground, while Task A is in the background, waiting to resume.

   A task is a cohesive unit that can move to the *background* when a
   user begins a new task or goes to the Home screen. While in the
   background, all the activities in the task are stopped, but the back
   stack for the task remains intact‚Äîthe task loses focus while another
   task takes place, as shown in figure 2. A task can then return to the
   *foreground* so users can pick up where they left off.

   Consider the following task flow for current Task A that has three
   activities in its stack, including two under the current activity:

   #. The user uses the Home button or gesture, then starts a new app
      from the app launcher.

      When the Home screen appears, Task A goes into the background.
      When the new app starts, the system starts a task for that app
      (Task B) with its own stack of activities.

   #. After interacting with that app, the user returns Home again and
      selects the app that originally started Task A.

      Now, Task A comes to the foreground‚Äîall three activities in its
      stack are intact, and the activity at the top of the stack
      resumes. At this point, the user can also switch back to Task B by
      going Home and selecting the app icon that started that task or by
      selecting the app's task from the `Recents screen <#>`__.

   **Note:**\  Multiple tasks can be held in the background at once.
   However, if the user runs many background tasks at the same time, the
   system might begin destroying background activities to recover
   memory. If this happens, the activity states are lost.

   .. rubric:: Multiple activity instances
      :name: multiple-instances

      ::
         
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
            ‚îÇ   Activity 1  ‚îÇ   ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
            ‚îÇ Home Activity ‚îÇ<‚îÄ‚îÄ‚îÄ‚ïÆ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê Separate
            ‚îÇ   Activity 2  ‚îÇ instance
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
            ‚îÇ Home Activity ‚îÇ<‚îÄ‚îÄ‚îÄ‚ïØ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
                 Back Stack     ‚îÇ

      https://developer.android.google.cn/static/images/fundamentals/diagram_multiple_instances.png

      **Figure 3.** A single activity can be instantiated multiple
      times.

   Because the activities in the back stack are never rearranged, if
   your app lets users start a particular activity from more than one
   activity, a new instance of that activity is created and pushed onto
   the stack, rather than bringing any previous instance of the activity
   to the top. As such, one activity in your app might be instantiated
   multiple times, even from different tasks, as shown in figure 3.

   If the user navigates backward using the Back button or gesture, the
   instances of the activity are revealed in the order they opened, each
   with its own UI state. However, you can modify this behavior if you
   don't want an activity instantiated more than once. Learn more about
   this in the section about `managing tasks <#ManagingTasks>`__.

   .. rubric:: Multi-window environments
      :name: multi-window

   When apps run simultaneously in a `multi-windowed environment <#>`__, supported in Android
   7.0 (API level 24) and higher, the system manages tasks separately
   for each window. Each window can have multiple tasks. The same holds
   true for `Android apps running on Chromebooks <#>`__: the
   system manages tasks, or groups of tasks, on a per-window basis.

   .. rubric:: Lifecycle recap
      :name: recap

   To summarize the default behavior for activities and tasks:

   -  When Activity A starts Activity B, Activity A is stopped but the
      system retains its state, such as its scroll position and any text
      entered into forms. If the user taps or uses the Back gesture
      while in Activity B, Activity A resumes with its state restored.

   -  When the user leaves a task using the Home button or gesture, the
      current activity is stopped and its task goes into the background.
      The system retains the state of every activity in the task. If the
      user later resumes the task by selecting the launcher icon that
      began the task, the task comes to the foreground and resumes the
      activity at the top of the stack.

   -  If the user taps or gestures Back, the current activity is popped
      from the stack and destroyed. The previous activity in the stack
      resumes. When an activity is destroyed, the system *does not*
      retain the activity's state.

      `This behavior is different for root launcher activities <#back-press-behavior>`__ when your app is running on a
      device that runs Android 12 or higher.

   -  Activities can be instantiated multiple times, even from other
      tasks.

   **Note:**\  For more about how to design your app's navigation
   structure for Android, see `Design navigation graphs <#>`__.

   .. rubric:: Manage tasks
      :name: ManagingTasks

   Android manages tasks and the back stack by placing all activities
   started in succession in the same task, in a last in, first out
   stack. This works great for most apps, and you usually don't have to
   worry about how your activities are associated with tasks or how they
   exist in the back stack.

   However, you might decide that you want to interrupt the normal
   behavior. For example, you might want an activity in your app to
   begin a new task when it is started, instead of being placed within
   the current task. Or, when you start an activity, you might want to
   bring forward an existing instance of it, instead of creating a new
   instance on top of the back stack. Or you might want your back stack
   to be cleared of all activities except for the root activity when the
   user leaves the task.

   You can do these things and more using attributes in the
   ``<activity>`` manifest
   element and flags in the intent that you pass to
   `startActivity() <#startActivity>`__.

   **Caution:**\  Most apps don't interrupt the default behavior for
   activities and tasks. If you determine that it's necessary for your
   activity to modify the default behaviors, use caution and test the
   usability of the activity during launch and when navigating back to
   it from other activities and tasks with the Back button or gesture.
   Also, test for navigation behaviors that might conflict with the
   user's expectations.
   These are the principal ``<activity>`` attributes that you can use to
   manage tasks:

   -  `taskAffinity <#aff>`__
   -  `launchMode <#lmode>`__
   -  `allowTaskReparenting <#reparent>`__
   -  `clearTaskOnLaunch <#clear>`__
   -  `alwaysRetainTaskState <#always>`__
   -  `finishOnTaskLaunch <#finish>`__

   And these are the principal intent flags that you can use:

   -  `FLAG_ACTIVITY_NEW_TASK <#FLAG_ACTIVITY_NEW_TASK>`__
   -  `FLAG_ACTIVITY_CLEAR_TOP <#FLAG_ACTIVITY_CLEAR_TOP>`__
   -  `FLAG_ACTIVITY_SINGLE_TOP <#FLAG_ACTIVITY_SINGLE_TOP>`__

   The following sections discuss how to use these manifest attributes
   and intent flags to define how activities associate with tasks and
   how they behave in the back stack.

   Also discussed are the considerations for how tasks and activities
   are represented and managed in the Recents screen. Normally, you let
   the system define how your task and activities are represented in the
   Recents screen, and you don't need to modify this behavior. For more
   information, see `Recents screen <#>`__.

   .. rubric:: Define launch modes
      :name: TaskLaunchModes

   Launch modes let you define how a new instance of an activity is
   associated with the current task. You can define launch modes in two
   ways, described in the sections that follow:

   -  `Using the manifest file <#ManifestForTasks>`__

      When you declare an activity in your manifest file, you can
      specify how the activity associates with tasks when it starts.

   -  `Using intent flags <#IntentFlagsForTasks>`__

      When you call
      `startActivity() <#startActivity>`__,
      you can include a flag in the
      `Intent <#>`__ that declares
      how (or whether) the new activity associates with the current
      task.

   So, if Activity A starts Activity B, Activity B can define in its
   manifest how it associates with the current task, and Activity A can
   use an intent flag to request how Activity B can associate with
   current task.

   If both activities define how Activity B associates with a task, then
   Activity A's request, as defined in the intent, is honored over
   Activity B's request, as defined in its manifest.

   **Note:**\  Some launch modes available for the manifest file aren't
   available as flags for an intent. Likewise, some launch modes
   available as flags for an intent can't be defined in the manifest.

   .. rubric:: Define launch modes using the manifest file
      :name: ManifestForTasks

   When declaring an activity in your manifest file, you can specify how
   the activity associates with a task using the
   ``<activity>``
   element's
   `launchMode <#lmode>`__
   attribute.

   There are five launch modes you can assign to the ``launchMode``
   attribute:

   #. 

      ``"standard"``
         The default mode. The system creates a new instance of the
         activity in the task it was started from and routes the intent
         to it. The activity can be instantiated multiple times, each
         instance can belong to different tasks, and one task can have
         multiple instances.

   #. 

      ``"singleTop"``
         If an instance of the activity already exists at the top of the
         current task, the system routes the intent to that instance
         through a call to its
         `onNewIntent() <#onNewIntent>`__
         method, rather than creating a new instance of the activity.
         The activity is instantiated multiple times, each instance can
         belong to different tasks, and one task can have multiple
         instances (but only if the activity at the top of the back
         stack is *not* an existing instance of the activity).

      For example, suppose a task's back stack consists of root activity
      A with activities B, C, and D on top (so the stack is A-B-C-D,
      with D on top). An intent arrives for an activity of type D. If D
      has the default ``"standard"`` launch mode, a new instance of the
      class is launched, and the stack becomes A-B-C-D-D. However, if
      D's launch mode is ``"singleTop"``, the existing instance of D
      receives the intent through ``onNewIntent()``, because it's at the
      top of the stack, and the stack remains A-B-C-D. If, on the other
      hand, an intent arrives for an activity of type B, then a new
      instance of B is added to the stack even if its launch mode is
      ``"singleTop"``.

      **Note:**\  When a new instance of an activity is created, the
      user can tap or gesture Back to return to the previous activity.
      But when an existing instance of an activity handles a new intent,
      the user can't tap or gesture Back to return to the state of the
      activity before the new intent arrived in ``onNewIntent()``.

   #. 

      ``"singleTask"``
         The system creates the activity at the root of a new task or
         locates the activity on an existing task with the same
         affinity. If an instance of the activity already exists, the
         system routes the intent to the existing instance through a
         call to its
         `onNewIntent() <#onNewIntent>`__
         method, rather than creating a new instance. Meanwhile all of
         the other activities on top of it are destroyed.

      **Note:**\  Although the activity starts in a new task, the Back
      button and gesture still return the user to the previous activity.

   #. 

      ``"singleInstance"``.
         The behavior is the same as for ``"singleTask"``, except that
         the system doesn't launch any other activities into the task
         holding the instance. The activity is always the single and
         only member of its task. Any activities started by this one
         open in a separate task.

   #. 

      ``"singleInstancePerTask"``.
         The activity can only run as the root activity of the task, the
         first activity that created the task, and therefore there can
         only be one instance of this activity in a task. In contrast to
         the ``singleTask`` launch mode, this activity can be started in
         multiple instances in different tasks if the
         `FLAG_ACTIVITY_MULTIPLE_TASK <#FLAG_ACTIVITY_MULTIPLE_TASK>`__
         or
         `FLAG_ACTIVITY_NEW_DOCUMENT <#FLAG_ACTIVITY_NEW_DOCUMENT>`__
         flag is set.

   **Note:**\  ``"singleTask"`` and ``"singleInstancePerTask"`` remove
   all activities that are above the starting activity from the task.
   For example, suppose a task consists of root activity A with
   activities B and C. The task is A-B-C, with C on top. An intent
   arrives for an activity of type A. If A's launch mode is
   ``"singleTask"`` or ``"singleInstancePerTask"``, the existing
   instance of A receives the intent through ``onNewIntent()``. B and C
   are finished, and the task is now A.
   As another example, the Android Browser app declares that the web
   browser activity always opens in its own task by specifying the
   ``singleTask`` launch mode in the ``<activity>`` element. This means
   that if your app issues an intent to open the Android Browser, its
   activity is *not* placed in the same task as your app. Instead,
   either a new task starts for the Browser or, if the Browser already
   has a task running in the background, that task is brought forward to
   handle the new intent.

   Regardless of whether an activity starts in a new task or in the same
   task as the activity that started it, the Back button and gesture
   always take the user to the previous activity. However, if you start
   an activity that specifies the ``singleTask`` launch mode and an
   instance of that activity exists in a background task, then that
   whole task is brought to the foreground. At this point, the back
   stack includes all activities from the task brought forward at the
   top of the stack. Figure 4 shows this type of scenario.

   ::
                  ‚ï≠‚îÄ‚îÄ‚îÄ Start ‚îÄ‚îÄ‚îÄ‚ïÆ ‚ï≠‚îÄ‚îÄ Navigate ‚îÄ‚îÄ‚ïÆ ‚ï≠‚îÄ‚îÄ Navigate ‚îÄ‚îÄ‚ïÆ  
                  ‚îÇ  ActivityY  v ‚îÇ     Back     v ‚îÇ     Back     v  
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 
            ‚îÇ Activity2 ‚îÇ   ‚îÇ ActivityY ‚îÇ   ‚îÇ ActivityX ‚îÇ   ‚îÇ Activity2 ‚îÇ 
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò 
      Foreground  ‚îÇ               ‚îÇ               ‚îÇ               ‚îÇ       
       Activity   ‚îÇ               ‚îÇ               ‚îÇ               ‚îÇ       
      ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      Back  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 
      Stack ‚îÇ Activity1 ‚îÇ   ‚îÇ ActivityX ‚îÇ   ‚îÇ Activity2 ‚îÇ   ‚îÇ Activity1 ‚îÇ 
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò 
                            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 
                            ‚îÇ Activity2 ‚îÇ   ‚îÇ Activity1 ‚îÇ 
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò 
         ‚îÇ ActivityY ‚îÇ<‚îÄ‚ïÆ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ   ‚îÇ Activity1 ‚îÇ 
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò 
         ‚îÇ ActivityX ‚îÇ  ‚îÇ   
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚ï∞‚îÄ‚îÄ Declared wih "singleTask" launch mode
        Background Task

      https://developer.android.google.cn/static/images/fundamentals/diagram_backstack_singletask_multiactivity.png

      **Figure 4.** A representation of how an activity with launch mode
      ``"singleTask"`` is added to the back stack. If the activity is
      already part of a background task with its own back stack, then
      that entire back stack also comes forward, on top of the current
      task.

   For more information about using launch modes in the manifest file,
   see the ``<activity>``
   element documentation.

   **Note:**\  The behaviors that you specify for your activity with the
   ``launchMode`` attribute can be overridden by flags included with the
   intent that start your activity, as discussed in the next section.

   .. rubric:: Define launch modes using Intent flags
      :name: IntentFlagsForTasks

   When starting an activity, you can modify the default association of
   an activity to its task by including flags in the intent that you
   deliver to
   `startActivity() <#startActivity>`__.
   The flags you can use to modify the default behavior are the
   following:

   `FLAG_ACTIVITY_NEW_TASK <#FLAG_ACTIVITY_NEW_TASK>`__
      The system starts the activity in a new task. If a task is already
      running for the activity being started, that task is brought to
      the foreground with its last state restored, and the activity
      receives the new intent in
      `onNewIntent() <#onNewIntent>`__.

      This produces the same behavior as the ``"singleTask"``
      `launchMode <#lmode>`__
      value discussed in the preceding section.

   `FLAG_ACTIVITY_SINGLE_TOP <#FLAG_ACTIVITY_SINGLE_TOP>`__
      If the activity being started is the current activity, at the top
      of the back stack, then the existing instance receives a call to
      ``onNewIntent()`` instead of creating a new instance of the
      activity.

      This produces the same behavior as the ``"singleTop"``
      ``launchMode`` value discussed in the preceding section.

   `FLAG_ACTIVITY_CLEAR_TOP <#FLAG_ACTIVITY_CLEAR_TOP>`__
      If the activity being started is already running in the current
      task, then‚Äîinstead of launching a new instance of that
      activity‚Äîthe system destroys all the other activities on top of
      it. The intent is delivered to the resumed instance of the
      activity, now on top, through ``onNewIntent()``.

      There is no value for the ``launchMode`` attribute that produces
      this behavior.

      ``FLAG_ACTIVITY_CLEAR_TOP`` is most often used in conjunction with
      ``FLAG_ACTIVITY_NEW_TASK``. When used together, these flags locate
      an existing activity in another task and put it in a position
      where it can respond to the intent.

      **Note:**\  If the launch mode of the designated activity is
      ``"standard"``, it too is removed from the stack and a new
      instance is launched in its place to handle the incoming intent.
      That's because a new instance is always created for a new intent
      when the launch mode is ``"standard"``.

   .. rubric:: Handle affinities
      :name: Affinities

   An *affinity* indicates which task an activity "prefers" to belong
   to. By default, all the activities from the same app have an affinity
   for each other: they "prefer" to be in the same task.

   However, you can modify the default affinity for an activity.
   Activities defined in different apps can share an affinity, and
   activities defined in the same app can be assigned different task
   affinities.

   You can modify an activity's affinity using the
   `taskAffinity <#aff>`__
   attribute of the
   ``<activity>`` element.

   The ``taskAffinity`` attribute takes a string value that must be
   different than the default package name declared in the
   ``<manifest>`` element,
   because the system uses that name to identify the default task
   affinity for the app.

   The affinity comes into play in two circumstances:

   #. When the intent that launches an activity contains the
      `FLAG_ACTIVITY_NEW_TASK <#FLAG_ACTIVITY_NEW_TASK>`__
      flag.

      A new activity, by default, is launched into the task of the
      activity that called
      `startActivity() <#startActivity>`__.
      It's pushed onto the same back stack as the caller.

      However, if the intent passed to ``startActivity()`` contains the
      ``FLAG_ACTIVITY_NEW_TASK`` flag, the system looks for a different
      task to house the new activity. Often, this is a new task.
      However, it doesn't have to be. If there's an existing task with
      the same affinity as the new activity, the activity is launched
      into that task. If not, it begins a new task.

      If this flag causes an activity to begin a new task and the user
      uses the Home button or gesture to leave it, there must be some
      way for the user to navigate back to the task. Some entities, such
      as the notification manager, always start activities in an
      external task, never as part of their own, so they always put
      ``FLAG_ACTIVITY_NEW_TASK`` in the intents they pass to
      ``startActivity()``.

      If an external entity that might use this flag can invoke your
      activity, take care that the user has an independent way to get
      back to the task that's started, such as with a launcher icon,
      where the root activity of the task has a
      `CATEGORY_LAUNCHER <#CATEGORY_LAUNCHER>`__
      intent filter. For more information, see the section about
      `starting tasks <#Starting>`__.

   #. When an activity has its
      `allowTaskReparenting <#reparent>`__
      attribute set to ``"true"``.

      In this case, the activity can move from the task it starts in to
      the task it has an affinity for when that task comes to the
      foreground.

      For example, suppose an activity that reports weather conditions
      in selected cities is defined as part of a travel app. It has the
      same affinity as other activities in the same app, the default app
      affinity, and it can be re-parented with this attribute.

      When one of your activities starts the weather reporter activity,
      it initially belongs to the same task as your activity. However,
      when the travel app's task comes to the foreground, the weather
      reporter activity is reassigned to that task and displayed within
      it.

   **Note:**\  If an APK file contains more than one "app" from the
   user's point of view, you probably want to use the
   `taskAffinity <#aff>`__
   attribute to assign different affinities to the activities associated
   with each "app".

   .. rubric:: Clear the back stack
      :name: Clearing

   If the user leaves a task for a long time, the system clears the task
   of all activities except the root activity. When the user returns to
   the task, only the root activity is restored. The system behaves this
   way based on the assumption that after an extended amount of time
   users have abandoned what they were doing before and are returning to
   the task to begin something new.

   There are some activity attributes that you can use to modify this
   behavior:

   `alwaysRetainTaskState <#always>`__
      When this attribute is set to ``"true"`` in the root activity of a
      task, the default behavior just described does not happen. The
      task retains all activities in its stack even after a long period.
   `clearTaskOnLaunch <#clear>`__
      When this attribute is set to ``"true"`` in the root activity of a
      task, the task is cleared down to the root activity whenever the
      user leaves the task and returns to it. In other words, it's the
      opposite of ``alwaysRetainTaskState``. The user always returns to
      the task in its initial state, even after leaving the task for
      only a moment.

      **Note:**\  This attribute is ignored if
      `FLAG_ACTIVITY_RESET_TASK_IF_NEEDED <#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED>`__
      isn't set.

   `finishOnTaskLaunch <#finish>`__
      This attribute is like ``clearTaskOnLaunch``, but it operates on a
      single activity, not an entire task. It can also cause any
      activity to finish except for the root activity. When it's set to
      ``"true"``, the activity remains part of the task only for the
      current session. If the user leaves and then returns to the task,
      it is no longer present.

      **Note:**\  This attribute is ignored if
      `FLAG_ACTIVITY_RESET_TASK_IF_NEEDED <#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED>`__
      isn't set.

   .. rubric:: Start a task
      :name: Starting

   You can set up an activity as the entry point for a task by giving it
   an intent filter with ``"android.intent.action.MAIN"`` as the
   specified action and ``"android.intent.category.LAUNCHER"`` as the
   specified category:

   .. code:: prettyprint

      <activity ... >
          <intent-filter ... >
              <action android:name="android.intent.action.MAIN" />
              <category android:name="android.intent.category.LAUNCHER" />
          </intent-filter>
          ...
      </activity>

   An intent filter of this kind causes an icon and label for the
   activity to display in the app launcher, giving users a way to launch
   the activity and to return to the task it creates any time after it
   launches.

   This second ability is important. Users must be able to leave a task
   and then come back to it later using this activity launcher. For this
   reason, only use the two launch modes that mark activities as always
   initiating a task, ``"singleTask"`` and ``"singleInstance"``, when
   the activity has an
   `ACTION_MAIN <#ACTION_MAIN>`__
   and a
   `CATEGORY_LAUNCHER <#CATEGORY_LAUNCHER>`__
   filter.

   Imagine, for example, what might happen if the filter were missing:
   an intent launches a ``"singleTask"`` activity, initiating a new
   task, and the user spends some time working in that task. The user
   then uses the Home button or gesture. The task is now sent to the
   background and is not visible. Now the user has no way to return to
   the task, because it is not represented in the app launcher.

   For those cases where you don't want the user to be able to return to
   an activity, set the
   ``<activity>``
   element's
   `finishOnTaskLaunch <#finish>`__
   to ``"true"``. For more information, see the section on `clearing the back stack <#Clearing>`__.

   Further information about how tasks and activities are represented
   and managed in the Recents screen is available in `Recents screen <#>`__.

   .. rubric:: More resources
      :name: More

   -  `Design navigation graphs <#>`__
   -  ``<activity>``
   -  `Recents screen <#>`__

Last updated 2024-03-27 UTC.


/Processes and app lifecycle
============================

.. container:: devsite-article-body clearfix

   In most cases, every Android application runs in its own Linux
   process. This process is created for the application when some of its
   code needs to run and remains running until the system needs to
   reclaim its memory for use by other applications and it is no longer
   needed.

   An unusual and fundamental feature of Android is that an application
   process's lifetime *isn't* directly controlled by the application
   itself. Instead, it is determined by the system through a combination
   of the parts of the application that the system knows are running,
   how important these things are to the user, and how much overall
   memory is available in the system.

   It is important that application developers understand how different
   application components (in particular
   `Activity <#>`__,
   `Service <#>`__, and
   `BroadcastReceiver <#>`__)
   impact the lifetime of the application's process. **Not using these
   components correctly can result in the system killing the
   application's process while it is doing important work.**

   A common example of a process lifecycle bug is a
   ``BroadcastReceiver`` that starts a thread when it receives an
   ``Intent`` in its
   `BroadcastReceiver.onReceive() <#onReceive>`__
   method and then returns from the function. Once it returns, the
   system considers the ``BroadcastReceiver`` to no longer be active,
   and its hosting process to no longer be needed, unless other
   application components are active in it.

   So, the system can kill the process at any time to reclaim memory,
   and in doing so, it terminates the spawned thread running in the
   process. The solution to this problem is typically to schedule a
   `JobService <#>`__ from the
   ``BroadcastReceiver`` so the system knows that there is active work
   occurring in the process.

   To determine which processes to kill when low on memory, Android
   places each process into an importance hierarchy based on the
   components running in them and the state of those components. In
   order of importance, these process types are:

   #. A **foreground process** is one that is required for what the user
      is currently doing. Various application components can cause its
      containing process to be considered foreground in different ways.
      A process is considered to be in the foreground if any of the
      following conditions hold:

      -  It is running an
         `Activity <#>`__ at the top
         of the screen that the user is interacting with (its
         `onResume() <#onResume>`__
         method has been called).
      -  It has a
         `BroadcastReceiver <#>`__
         that is currently running (its
         `BroadcastReceiver.onReceive() <#onReceive>`__
         method is executing).
      -  It has a `Service <#>`__ that
         is currently executing code in one of its callbacks
         (`Service.onCreate() </reference/android/app/Service#onCreate()>`__,
         `Service.onStart() <#onStart>`__,
         or
         `Service.onDestroy() <#onDestroy>`__).

   #. A **visible process** is doing work that the user is currently
      aware of, so killing it has a noticeable negative impact on the
      user experience. A process is considered visible in the following
      conditions:

      -  It is running an
         `Activity <#>`__ that is
         visible to the user on-screen but not in the foreground (its
         `onPause() <#onPause>`__
         method has been called). This might occur, for example, if the
         foreground ``Activity`` is displayed as a dialog that lets the
         previous ``Activity`` be seen behind it.
      -  It has a `Service <#>`__ that
         is running as a foreground service, through
         `Service.startForeground() <#startForeground>`__
         (which asks the system to treat the service as something the
         user is aware of, or essentially as if it were visible).
      -  It is hosting a service that the system is using for a
         particular feature that the user is aware of, such as a live
         wallpaper or an input method service.

      The number of these processes running in the system is less
      bounded than foreground processes, but still relatively
      controlled. These processes are considered extremely important and
      aren't killed unless doing so is required to keep all foreground
      processes running.

   #. A **service process** is one holding a
      `Service <#>`__ that has been
      started with the
      `startService() <#startService>`__
      method. Though these processes are not directly visible to the
      user, they are generally doing things that the user cares about
      (such as background network data upload or download), so the
      system always keeps such processes running unless there is not
      enough memory to retain all foreground and visible processes.

      Services that have been running for a long time (such as 30
      minutes or more) might be demoted in importance to let their
      process drop to the cached list.

      Processes that do need to be run over a long period can be created
      with
      `setForeground <#setForeground>`__.
      If it is a periodic process that requires strict time of
      execution, it can be scheduled through the
      `AlarmManager <#>`__. For
      more information, refer to `Support for long-running workers <#>`__.
      This helps avoid situations where long-running services that use
      excessive resources, for example, by leaking memory, prevent the
      system from delivering a good user experience.

   #. A **cached process** is one that is not currently needed, so the
      system is free to kill it as needed when resources like memory are
      needed elsewhere. In a normally behaving system, these are the
      only processes involved in resource management.

      A well-running system has multiple cached processes always
      available, for efficient switching between applications, and
      regularly kills the cached apps as needed. Only in very critical
      situations does the system get to a point where all cached
      processes are killed and it must start killing service processes.

      Since cached processes can be killed by the system at any time,
      apps should cease all work while in the cached state. If
      user-critical work must be performed by the app, it should use of
      the above APIs to run work from an active process state.

      Cached processes often hold one or more
      `Activity <#>`__ instances that
      are not currently visible to the user (their
      `onStop() <#onStop>`__ method
      has been called and has returned). Provided they implement their
      ``Activity`` lifecycle correctly when the system kills such
      processes, it doesn't impact the user's experience when returning
      to that app. It can restore the previously saved state when the
      associated activity recreates in a new process. Be aware that
      `onDestroy() <#ondestroy>`__
      is not guaranteed to be called in the case that a process is
      killed by the system. For more details, see
      `Activity <#>`__.

      Starting in Android 13, an app process may receive limited or no
      execution time until it enters one of the above active lifecycle
      states.

      Cached processes are kept in a list. The exact ordering policy for
      this list is an implementation detail of the platform. Generally,
      it tries to keep more useful processes, such as those hosting the
      user's home application or the last activity the user saw, before
      other types of processes. Other policies for killing processes can
      also be applied, like setting hard limits on the number of
      processes allowed or limiting the amount of time a process can
      stay continually cached.

   When deciding how to classify a process, the system bases its
   decision on the most important level found among all the components
   currently active in the process. See the
   `Activity <#>`__,
   `Service <#>`__, and
   `BroadcastReceiver <#>`__
   documentation for more detail on how each of these components
   contributes to the overall lifecycle of a process and of the
   application.

   A process's priority might also be increased based on other
   dependencies a process has to it. For example, if process A has bound
   to a `Service <#>`__ with the
   `Context.BIND_AUTO_CREATE <#BIND_AUTO_CREATE>`__
   flag or is using a
   `ContentProvider <#>`__
   in process B, then process B's classification is always at least as
   important as process A's.

Last updated 2023-08-09 UTC.


/Parcelables and bundles
========================

.. container:: devsite-article-body clearfix

   `Parcelable <#>`__ and
   `Bundle <#>`__ objects are intended to
   be used across process boundaries such as with IPC/Binder
   transactions, between activities with intents, and to store transient
   state across configuration changes. This page provides
   recommendations and best practices for using
   `Parcelable <#>`__ and
   `Bundle <#>`__ objects.

   **Note:** `Parcel <#>`__ is not a
   general-purpose serialization mechanism, and you should never store
   any `Parcel <#>`__ data on disk or
   send it over the network.

   .. rubric:: Sending data between activities
      :name: sdba

   When an app creates an
   `Intent <#>`__ object to use in
   `startActivity(android.content.Intent) <#startActivity>`__
   in starting a new Activity, the app can pass in parameters using the
   `putExtra(java.lang.String, java.lang.String) <#putExtra>`__
   method.

   The following code snippet shows an example of how to perform this
   operation.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val intent = Intent(this, MyActivity::class.java).apply {
                   putExtra("media_id", "a1b2c3")
                   // ...
               }
               startActivity(intent)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Intent intent = new Intent(this, MyActivity.class);
               intent.putExtra("media_id", "a1b2c3");
               // ...
               startActivity(intent);

   The OS parcels the underlying
   `Bundle <#>`__ of the intent. Then,
   the OS creates the new activity, un-parcels the data, and passes the
   intent to the new activity.

   We recommend that you use the
   `Bundle <#>`__ class to set primitives
   known to the OS on `Intent <#>`__
   objects. The `Bundle <#>`__ class is
   highly optimized for marshalling and unmarshalling using parcels.

   In some cases, you may need a mechanism to send composite or complex
   objects across activities. In such cases, the custom class should
   implement Parcelable, and provide the appropriate
   `writeToParcel(android.os.Parcel, int) <#writeToParcel>`__
   method. It must also provide a non-null field called ``CREATOR`` that
   implements the
   `Parcelable.Creator <#>`__
   interface, whose
   `createFromParcel() <#createFromParcel>`__
   method is used for converting the
   `Parcel <#>`__ back to the current
   object. For more information, see the reference documentation for the
   `Parcelable <#>`__ object.

   When sending data via an intent, you should be careful to limit the
   data size to a few KB. Sending too much data can cause the system to
   throw a
   `TransactionTooLargeException <#>`__
   exception.

   .. rubric:: Sending data between processes
      :name: sdbp

   Sending data between processes is similar to doing so between
   activities. However, when sending between processes, we recommend
   that you do not use custom parcelables. If you send a custom
   `Parcelable <#>`__ object from one
   app to another, you need to be certain that the exact same version of
   the custom class is present on both the sending and receiving apps.
   Typically this could be a common library used across both apps. An
   error can occur if your app tries to send a custom parcelable to the
   system, because the system cannot unmarshal a class that it has no
   knowledge of.

   For example, an app might set an alarm using the
   `AlarmManager <#>`__ class, and
   use a custom `Parcelable <#>`__ on
   the alarm intent. When the alarm goes off, the system modifies the
   intent's `Bundle <#>`__ of extras to
   add a repeat count. This modification can result in the system's
   stripping the custom
   `Parcelable <#>`__ from the
   extras. This stripping, in turn, can result in the app's crashing
   when it receives the modified alarm intent, because the app expects
   to receive extra data that is no longer there.

   The Binder transaction buffer has a limited fixed size, currently
   1MB, which is shared by all transactions in progress for the process.
   Since this limit is at the process level rather than at the per
   activity level, these transactions include all binder transactions in
   the app such as onSaveInstanceState, startActivity and any
   interaction with the system. When the size limit is exceeded, a
   TransactionTooLargeException is thrown.

   For the specific case of savedInstanceState, the amount of data
   should be kept small because the system process needs to hold on to
   the provided data for as long as the user can ever navigate back to
   that activity (even if the activity's process is killed). We
   recommend that you keep saved state to less than 50k of data.

   **Note:** In Android 7.0 (API level 24) and higher, the system throws
   a TransactionTooLargeException as a runtime exception. In lower
   versions of Android, the system only shows a warning in logcat.

Last updated 2024-01-03 UTC.


/Loaders
========

.. container:: devsite-article-body clearfix

   | Loaders are deprecated as of Android 9 (API level 28). The
     recommended option for dealing with loading data while handling the
     ``Activity`` and ``Fragment`` lifecycles is to use a combination of
     `ViewModel <#>`__ objects
     and `LiveData <#>`__. View
     models survive configuration changes, like loaders, but with less
     boilerplate code. ``LiveData`` provides a lifecycle-aware way of
     loading data that you can reuse in multiple view models. You can
     also combine ``LiveData`` using
     `MediatorLiveData <#>`__.
     Any observable queries, such as those from a `Room database <#>`__, can be used to
     observe changes to the data.
   | ``ViewModel`` and ``LiveData`` are also available in situations
     where you don't have access to the
     `LoaderManager <#>`__, such
     as in a `Service <#>`__. Using the
     two in tandem provides an easy way to access the data your app
     needs without having to deal with the UI lifecycle. To learn more
     about ``LiveData``, see the `LiveData``
     overview </topic/libraries/architecture/livedata>`__. To learn more
     about ``ViewModel``, see the `ViewModel``
     overview </topic/libraries/architecture/viewmodel>`__.

   The Loader API lets you load data from a `content provider <#>`__ or other data
   source for display in a
   `FragmentActivity <#>`__
   or `Fragment <#>`__.

   Without loaders, some of the problems you might encounter include the
   following:

   -  If you fetch the data directly in the activity or fragment, your
      users suffer from lack of responsiveness due to performing
      potentially slow queries from the UI thread.
   -  If you fetch the data from another thread, perhaps with
      `AsyncTask <#>`__, then you're
      responsible for managing both that thread and the UI thread
      through various activity or fragment lifecycle events, such as
      `onDestroy() <#onDestroy>`__
      and configuration changes.

   Loaders solve these problems and include other benefits:

   -  Loaders run on separate threads to prevent a slow or unresponsive
      UI.
   -  Loaders simplify thread management by providing callback methods
      when events occur.
   -  Loaders persist and cache results across configuration changes to
      prevent duplicate queries.
   -  Loaders can implement an observer to monitor for changes in the
      underlying data source. For example,
      `CursorLoader <#>`__
      automatically registers a
      `ContentObserver <#>`__
      to trigger a reload when data changes.

   .. rubric:: Loader API summary
      :name: summary

   There are multiple classes and interfaces that might be involved when
   using loaders in an app. They are summarized in the following table:

   .. list-table::
      :widths: 36 36
      :header-rows: 1

      - 

         - Class/Interface
         - Description
      - 

         - `LoaderManager <#>`__
         - An abstract class associated with a
            `FragmentActivity <#>`__
            or
            `Fragment <#>`__
            for managing one or more
            `Loader <#>`__
            instances. There is only one ``LoaderManager`` per activity
            or fragment, but a ``LoaderManager`` can manage multiple
            loaders.
            To get a ``LoaderManager``, call
            `getSupportLoaderManager() <#getSupportLoaderManager>`__
            from the activity or fragment.

            To start loading data from a loader, call either
            `initLoader() <#initLoader>`__
            or
            `restartLoader() <#restartLoader>`__.
            The system automatically determines whether a loader with
            the same integer ID already exists and either creates a new
            loader or reuses an existing loader.
      - 

         - `LoaderManager.LoaderCallbacks <#>`__
         - This interface contains callback methods that are called when
            loader events occur. The interface defines three callback
            methods:

            -  `onCreateLoader(int, Bundle) <#onCreateLoader>`__:
               called when the system needs a new loader to be created.
               In your code, create a
               `Loader <#>`__
               object and return it to the system.
            -  `onLoadFinished(Loader<#onLoadFinished>`__:
               called when a loader has finished loading data. You
               typically display the data to the user in your code.
            -  `onLoaderReset(Loader<#onLoaderReset>`__:
               called when a previously created loader is being reset,
               when you call
               `destroyLoader(int) <#destroyLoader>`__
               or when the activity or fragment is destroyed, making its
               data unavailable. In your code, remove any references to
               the loader's data.

            Your activity or fragment typically implements this
            interface, and it is registered when you call
            `initLoader() <#initLoader>`__
            or
            `restartLoader() <#restartLoader>`__.
      - 

         - `Loader <#>`__
         - Loaders perform the loading of data. This class is abstract
            and serves as the base class for all loaders. You can
            directly subclass ``Loader`` or use one of the following
            built-in subclasses to simplify implementation:

            -  `AsyncTaskLoader <#>`__:
               an abstract loader that provides an
               `AsyncTask <#>`__ to
               perform load operations on a separate thread.
            -  `CursorLoader <#>`__:
               a concrete subclass of
               `AsyncTaskLoader <#>`__
               for asynchronously loading data from a
               `ContentProvider <#>`__.
               It queries a
               `ContentResolver <#>`__
               and returns a
               `Cursor <#>`__.

   The following sections show you how to use these classes and
   interfaces in an application.

   .. rubric:: Use loaders in an application
      :name: app

   This section describes how to use loaders in an Android application.
   An application that uses loaders typically includes the following:

   -  A
      `FragmentActivity <#>`__
      or `Fragment <#>`__.
   -  An instance of the
      `LoaderManager <#>`__.
   -  A
      `CursorLoader <#>`__
      to load data backed by a
      `ContentProvider <#>`__.
      Alternatively, you can implement your own subclass of
      `Loader <#>`__ or
      `AsyncTaskLoader <#>`__
      to load data from some other source.
   -  An implementation for
      `LoaderManager.LoaderCallbacks <#>`__.
      This is where you create new loaders and manage your references to
      existing loaders.
   -  A way of displaying the loader's data, such as a
      `SimpleCursorAdapter <#>`__.
   -  A data source, such as a
      `ContentProvider <#>`__,
      when using a
      `CursorLoader <#>`__.

   .. rubric:: Start a loader
      :name: starting

   The
   `LoaderManager <#>`__
   manages one or more
   `Loader <#>`__ instances
   within a
   `FragmentActivity <#>`__
   or `Fragment <#>`__.
   There is only one ``LoaderManager`` per activity or fragment.

   You typically initialize a ``Loader`` within the activity's
   `onCreate() <#onCreate>`__
   method or the fragment's
   `onCreate() <#onCreate>`__
   method. You do this as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               supportLoaderManager.initLoader(0, null, this)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Prepare the loader.  Either re-connect with an existing one,
               // or start a new one.
               getSupportLoaderManager().initLoader(0, null, this);

   The
   `initLoader() <#initLoader>`__
   method takes the following parameters:

   -  A unique ID that identifies the loader. In this example, the ID is
      ``0``.
   -  Optional arguments to supply to the loader at construction
      (``null`` in this example).
   -  A
      `LoaderManager.LoaderCallbacks <#>`__
      implementation, which the ``LoaderManager`` calls to report loader
      events. In this example, the local class implements the
      ``LoaderManager.LoaderCallbacks`` interface, so it passes a
      reference to itself, ``this``.

   The ``initLoader()`` call ensures that a loader is initialized and
   active. It has two possible outcomes:

   -  If the loader specified by the ID already exists, the last created
      loader is reused.
   -  If the loader specified by the ID does *not* exist,
      ``initLoader()`` triggers the ``LoaderManager.LoaderCallbacks``
      method
      `onCreateLoader() <#onCreateLoader>`__.
      This is where you implement the code to instantiate and return a
      new loader. For more discussion, see the section about
      `onCreateLoader <#onCreateLoader>`__.

   In either case, the given ``LoaderManager.LoaderCallbacks``
   implementation is associated with the loader and is called when the
   loader state changes. If, at the point of this call, the caller is in
   its started state and the requested loader already exists and has
   generated its data, then the system calls
   `onLoadFinished() <#onLoadFinished>`__
   immediately, during ``initLoader()``. You must be prepared for this
   to happen. For more discussion of this callback, see the section
   about `onLoadFinished <#onLoadFinished>`__.

   The ``initLoader()`` method returns the ``Loader`` that is created,
   but you don't need to capture a reference to it. The
   ``LoaderManager`` manages the life of the loader automatically. The
   ``LoaderManager`` starts and stops loading when necessary and
   maintains the state of the loader and its associated content.

   As this implies, you rarely interact with loaders directly. You most
   commonly use the ``LoaderManager.LoaderCallbacks`` methods to
   intervene in the loading process when particular events occur. For
   more discussion of this topic, see the `Using the LoaderManager callbacks <#callback>`__ section.

   .. rubric:: Restart a loader
      :name: restarting

   When you use
   `initLoader() <#initLoader>`__,
   as shown in the preceding section, it uses an existing loader with
   the specified ID if there is one. If there isn't, it creates one. But
   sometimes you want to discard your old data and start over.

   To discard your old data, use
   `restartLoader() <#restartLoader>`__.
   For example, the following implementation of
   `SearchView.OnQueryTextListener <#>`__
   restarts the loader when the user's query changes. The loader needs
   to be restarted so that it can use the revised search filter to do a
   new query.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun onQueryTextChanged(newText: String?): Boolean {
                   // Called when the action bar search text has changed.  Update
                   // the search filter and restart the loader to do a new query
                   // with this filter.
                   curFilter = if (newText?.isNotEmpty() == true) newText else null
                   supportLoaderManager.restartLoader(0, null, this)
                   return true
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public boolean onQueryTextChanged(String newText) {
                   // Called when the action bar search text has changed.  Update
                   // the search filter, and restart the loader to do a new query
                   // with this filter.
                   curFilter = !TextUtils.isEmpty(newText) ? newText : null;
                   getSupportLoaderManager().restartLoader(0, null, this);
                   return true;
               }

   .. rubric:: Use the LoaderManager callbacks
      :name: callback

   `LoaderManager.LoaderCallbacks <#>`__
   is a callback interface that lets a client interact with the
   `LoaderManager <#>`__.

   Loaders, in particular
   `CursorLoader <#>`__,
   are expected to retain their data after being stopped. This lets
   applications keep their data across the activity or fragment's
   `onStop() <#onStop>`__ and
   `onStart() <#onStart>`__
   methods, so that when users return to an application, they don't have
   to wait for the data to reload.

   You use the ``LoaderManager.LoaderCallbacks`` methods to know when to
   create a new loader and to tell the application when it is time to
   stop using a loader's data.

   ``LoaderManager.LoaderCallbacks`` includes these methods:

   -  `onCreateLoader() <#onCreateLoader>`__:
      instantiates and returns a new
      `Loader <#>`__ for the
      given ID.

   -  `onLoadFinished() <#onLoadFinished>`__:
      called when a previously created loader has finished its load.

   -  `onLoaderReset() <#onLoaderReset>`__:
      called when a previously created loader is being reset, thus
      making its data unavailable.

   These methods are described in more detail in the following sections.

   .. rubric:: onCreateLoader
      :name: onCreateLoader

   When you attempt to access a loader, such as through
   `initLoader() <#initLoader>`__,
   it checks to see whether the loader specified by the ID exists. If it
   doesn't, it triggers the
   `LoaderManager.LoaderCallbacks <#>`__
   method
   `onCreateLoader() <#onCreateLoader>`__.
   This is where you create a new loader. Typically this is a
   `CursorLoader <#>`__,
   but you can implement your own
   `Loader <#>`__ subclass.

   In the following example, the ``onCreateLoader()`` callback method
   creates a ``CursorLoader`` using its constructor method, which
   requires the complete set of information needed to perform a query to
   the
   `ContentProvider <#>`__.
   Specifically, it needs the following:

   -  *uri*: the URI for the content to retrieve.
   -  *projection*: a list of which columns to return. Passing ``null``
      returns all columns, which is inefficient.
   -  *selection*: a filter declaring which rows to return, formatted as
      a SQL WHERE clause (excluding the WHERE itself). Passing ``null``
      returns all rows for the given URI.
   -  *selectionArgs*: if you include ?s in the selection, they are
      replaced by the values from *selectionArgs* in the order that they
      appear in the selection. The values are bound as strings.
   -  *sortOrder*: how to order the rows, formatted as a SQL ORDER BY
      clause (excluding the ORDER BY itself). Passing ``null`` uses the
      default sort order, which might be unordered.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // If non-null, this is the current filter the user has provided.
               private var curFilter: String? = null
               ...
               override fun onCreateLoader(id: Int, args: Bundle?): Loader<Cursor> {
                   // This is called when a new Loader needs to be created.  This
                   // sample only has one Loader, so we don't care about the ID.
                   // First, pick the base URI to use depending on whether we are
                   // currently filtering.
                   val baseUri: Uri = if (curFilter != null) {
                       Uri.withAppendedPath(ContactsContract.Contacts.CONTENT_URI, Uri.encode(curFilter))
                   } else {
                       ContactsContract.Contacts.CONTENT_URI
                   }

                   // Now create and return a CursorLoader that will take care of
                   // creating a Cursor for the data being displayed.
                   val select: String = "((${Contacts.DISPLAY_NAME} NOTNULL) AND (" +
                           "${Contacts.HAS_PHONE_NUMBER}=1) AND (" +
                           "${Contacts.DISPLAY_NAME} != ''))"
                   return (activity as? Context)?.let { context ->
                       CursorLoader(
                               context,
                               baseUri,
                               CONTACTS_SUMMARY_PROJECTION,
                               select,
                               null,
                               "${Contacts.DISPLAY_NAME} COLLATE LOCALIZED ASC"
                       )
                   } ?: throw Exception("Activity cannot be null")
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // If non-null, this is the current filter the user has provided.
               String curFilter;
               ...
               public Loader<Cursor> onCreateLoader(int id, Bundle args) {
                   // This is called when a new Loader needs to be created.  This
                   // sample only has one Loader, so we don't care about the ID.
                   // First, pick the base URI to use depending on whether we are
                   // currently filtering.
                   Uri baseUri;
                   if (curFilter != null) {
                       baseUri = Uri.withAppendedPath(Contacts.CONTENT_FILTER_URI,
                                 Uri.encode(curFilter));
                   } else {
                       baseUri = Contacts.CONTENT_URI;
                   }

                   // Now create and return a CursorLoader that will take care of
                   // creating a Cursor for the data being displayed.
                   String select = "((" + Contacts.DISPLAY_NAME + " NOTNULL) AND ("
                           + Contacts.HAS_PHONE_NUMBER + "=1) AND ("
                           + Contacts.DISPLAY_NAME + " != '' ))";
                   return new CursorLoader(getActivity(), baseUri,
                           CONTACTS_SUMMARY_PROJECTION, select, null,
                           Contacts.DISPLAY_NAME + " COLLATE LOCALIZED ASC");
               }

   .. rubric:: onLoadFinished
      :name: onLoadFinished

   This method is called when a previously created loader finishes its
   load. This method is guaranteed to be called prior to the release of
   the last data that is supplied for this loader. At this point, remove
   all use of the old data, since it's going to be released. But don't
   release the data yourself‚Äîthe loader owns it and takes care of that.

   The loader releases the data once it knows the application is no
   longer using it. For example, if the data is a cursor from a
   `CursorLoader <#>`__,
   don‚Äôt call
   `close() <#close>`__ on it
   yourself. If the cursor is being placed in a
   `CursorAdapter <#>`__, use
   the
   `swapCursor() <#swapCursor>`__
   method so that the old
   `Cursor <#>`__ is not closed, as
   shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private lateinit var adapter: SimpleCursorAdapter
               ...
               override fun onLoadFinished(loader: Loader<Cursor>, data: Cursor?) {
                   // Swap the new cursor in. (The framework will take care of closing the
                   // old cursor once we return.)
                   adapter.swapCursor(data)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // This is the Adapter being used to display the list's data.
               SimpleCursorAdapter adapter;
               ...
               public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
                   // Swap the new cursor in. (The framework will take care of closing the
                   // old cursor once we return.)
                   adapter.swapCursor(data);
               }

   .. rubric:: onLoaderReset
      :name: onLoaderReset

   This method is called when a previously created loader is being
   reset, thus making its data unavailable. This callback lets you find
   out when the data is about to be released so you can remove your
   reference to it.

   This implementation calls
   `swapCursor() <#swapCursor>`__
   with a value of ``null``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private lateinit var adapter: SimpleCursorAdapter
               ...
               override fun onLoaderReset(loader: Loader<Cursor>) {
                   // This is called when the last Cursor provided to onLoadFinished()
                   // above is about to be closed.  We need to make sure we are no
                   // longer using it.
                   adapter.swapCursor(null)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // This is the Adapter being used to display the list's data.
               SimpleCursorAdapter adapter;
               ...
               public void onLoaderReset(Loader<Cursor> loader) {
                   // This is called when the last Cursor provided to onLoadFinished()
                   // above is about to be closed.  We need to make sure we are no
                   // longer using it.
                   adapter.swapCursor(null);
               }

   .. rubric:: Example
      :name: example

   As an example, here is the full implementation of a
   `Fragment <#>`__ that
   displays a `ListView <#>`__
   containing the results of a query against the contacts content
   provider. It uses a
   `CursorLoader <#>`__
   to manage the query on the provider.

   Because this example is from an application to access a user's
   contacts, its manifest must include the permission
   `READ_CONTACTS <#READ_CONTACTS>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private val CONTACTS_SUMMARY_PROJECTION: Array<String> = arrayOf(
                       Contacts._ID,
                       Contacts.DISPLAY_NAME,
                       Contacts.CONTACT_STATUS,
                       Contacts.CONTACT_PRESENCE,
                       Contacts.PHOTO_ID,
                       Contacts.LOOKUP_KEY
               )


               class CursorLoaderListFragment :
                       ListFragment(),
                       SearchView.OnQueryTextListener,
                       LoaderManager.LoaderCallbacks<Cursor> {

                   // This is the Adapter being used to display the list's data.
                   private lateinit var mAdapter: SimpleCursorAdapter

                   // If non-null, this is the current filter the user has provided.
                   private var curFilter: String? = null

                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)

                       // Prepare the loader.  Either re-connect with an existing one,
                       // or start a new one.
                       loaderManager.initLoader(0, null, this)
                   }

                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       super.onViewCreated(view, savedInstanceState)

                       // Give some text to display if there is no data.  In a real
                       // application, this would come from a resource.
                       setEmptyText("No phone numbers")

                       // We have a menu item to show in action bar.
                       setHasOptionsMenu(true)

                       // Create an empty adapter we will use to display the loaded data.
                       mAdapter = SimpleCursorAdapter(activity,
                               android.R.layout.simple_list_item_2,
                               null,
                               arrayOf(Contacts.DISPLAY_NAME, Contacts.CONTACT_STATUS),
                               intArrayOf(android.R.id.text1, android.R.id.text2),
                               0
                       )
                       listAdapter = mAdapter
                   }

                   override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
                       // Place an action bar item for searching.
                       menu.add("Search").apply {
                           setIcon(android.R.drawable.ic_menu_search)
                           setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM)
                           actionView = SearchView(activity).apply {
                               setOnQueryTextListener(this@CursorLoaderListFragment)
                           }
                       }
                   }

                   override fun onQueryTextChange(newText: String?): Boolean {
                       // Called when the action bar search text has changed.  Update
                       // the search filter, and restart the loader to do a new query
                       // with this filter.
                       curFilter = if (newText?.isNotEmpty() == true) newText else null
                       loaderManager.restartLoader(0, null, this)
                       return true
                   }

                   override fun onQueryTextSubmit(query: String): Boolean {
                       // Don't care about this.
                       return true
                   }

                   override fun onListItemClick(l: ListView, v: View, position: Int, id: Long) {
                       // Insert desired behavior here.
                       Log.i("FragmentComplexList", "Item clicked: $id")
                   }

                   override fun onCreateLoader(id: Int, args: Bundle?): Loader<Cursor> {
                       // This is called when a new Loader needs to be created.  This
                       // sample only has one Loader, so we don't care about the ID.
                       // First, pick the base URI to use depending on whether we are
                       // currently filtering.
                       val baseUri: Uri = if (curFilter != null) {
                           Uri.withAppendedPath(Contacts.CONTENT_URI, Uri.encode(curFilter))
                       } else {
                           Contacts.CONTENT_URI
                       }

                       // Now create and return a CursorLoader that will take care of
                       // creating a Cursor for the data being displayed.
                       val select: String = "((${Contacts.DISPLAY_NAME} NOTNULL) AND (" +
                               "${Contacts.HAS_PHONE_NUMBER}=1) AND (" +
                               "${Contacts.DISPLAY_NAME} != ''))"
                       return (activity as? Context)?.let { context ->
                           CursorLoader(
                                   context,
                                   baseUri,
                                   CONTACTS_SUMMARY_PROJECTION,
                                   select,
                                   null,
                                   "${Contacts.DISPLAY_NAME} COLLATE LOCALIZED ASC"
                           )
                       } ?: throw Exception("Activity cannot be null")
                   }

                   override fun onLoadFinished(loader: Loader<Cursor>, data: Cursor) {
                       // Swap the new cursor in.  (The framework will take care of closing the
                       // old cursor once we return.)
                       mAdapter.swapCursor(data)
                   }

                   override fun onLoaderReset(loader: Loader<Cursor>) {
                       // This is called when the last Cursor provided to onLoadFinished()
                       // above is about to be closed.  We need to make sure we are no
                       // longer using it.
                       mAdapter.swapCursor(null)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public static class CursorLoaderListFragment extends ListFragment
                       implements OnQueryTextListener, LoaderManager.LoaderCallbacks<Cursor> {

                   // This is the Adapter being used to display the list's data.
                   SimpleCursorAdapter mAdapter;

                   // If non-null, this is the current filter the user has provided.
                   String curFilter;

                   @Override public void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);

                       // Prepare the loader.  Either re-connect with an existing one,
                       // or start a new one.
                       getLoaderManager().initLoader(0, null, this);
                   }

                   @Override public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
                       super.onViewCreated(view, savedInstanceState);

                       // Give some text to display if there is no data.  In a real
                       // application, this would come from a resource.
                       setEmptyText("No phone numbers");

                       // We have a menu item to show in action bar.
                       setHasOptionsMenu(true);

                       // Create an empty adapter we will use to display the loaded data.
                       mAdapter = new SimpleCursorAdapter(getActivity(),
                               android.R.layout.simple_list_item_2, null,
                               new String[] { Contacts.DISPLAY_NAME, Contacts.CONTACT_STATUS },
                               new int[] { android.R.id.text1, android.R.id.text2 }, 0);
                       setListAdapter(mAdapter);
                   }

                   @Override public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
                       // Place an action bar item for searching.
                       MenuItem item = menu.add("Search");
                       item.setIcon(android.R.drawable.ic_menu_search);
                       item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
                       SearchView sv = new SearchView(getActivity());
                       sv.setOnQueryTextListener(this);
                       item.setActionView(sv);
                   }

                   public boolean onQueryTextChange(String newText) {
                       // Called when the action bar search text has changed.  Update
                       // the search filter, and restart the loader to do a new query
                       // with this filter.
                       curFilter = !TextUtils.isEmpty(newText) ? newText : null;
                       getLoaderManager().restartLoader(0, null, this);
                       return true;
                   }

                   @Override public boolean onQueryTextSubmit(String query) {
                       // Don't care about this.
                       return true;
                   }

                   @Override public void onListItemClick(ListView l, View v, int position, long id) {
                       // Insert desired behavior here.
                       Log.i("FragmentComplexList", "Item clicked: " + id);
                   }

                   // These are the Contacts rows that we will retrieve.
                   static final String[] CONTACTS_SUMMARY_PROJECTION = new String[] {
                       Contacts._ID,
                       Contacts.DISPLAY_NAME,
                       Contacts.CONTACT_STATUS,
                       Contacts.CONTACT_PRESENCE,
                       Contacts.PHOTO_ID,
                       Contacts.LOOKUP_KEY,
                   };
                   public Loader<Cursor> onCreateLoader(int id, Bundle args) {
                       // This is called when a new Loader needs to be created.  This
                       // sample only has one Loader, so we don't care about the ID.
                       // First, pick the base URI to use depending on whether we are
                       // currently filtering.
                       Uri baseUri;
                       if (curFilter != null) {
                           baseUri = Uri.withAppendedPath(Contacts.CONTENT_FILTER_URI,
                                   Uri.encode(curFilter));
                       } else {
                           baseUri = Contacts.CONTENT_URI;
                       }

                       // Now create and return a CursorLoader that will take care of
                       // creating a Cursor for the data being displayed.
                       String select = "((" + Contacts.DISPLAY_NAME + " NOTNULL) AND ("
                               + Contacts.HAS_PHONE_NUMBER + "=1) AND ("
                               + Contacts.DISPLAY_NAME + " != '' ))";
                       return new CursorLoader(getActivity(), baseUri,
                               CONTACTS_SUMMARY_PROJECTION, select, null,
                               Contacts.DISPLAY_NAME + " COLLATE LOCALIZED ASC");
                   }

                   public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
                       // Swap the new cursor in.  (The framework will take care of closing the
                       // old cursor once we return.)
                       mAdapter.swapCursor(data);
                   }

                   public void onLoaderReset(Loader<Cursor> loader) {
                       // This is called when the last Cursor provided to onLoadFinished()
                       // above is about to be closed.  We need to make sure we are no
                       // longer using it.
                       mAdapter.swapCursor(null);
                   }
               }

   .. rubric:: More examples
      :name: more_examples

   The following examples illustrate how to use loaders:

   -  `LoaderCursor <https://android.googlesource.com/platform/development/+/master/samples/ApiDemos/src/com/example/android/apis/app/LoaderCursor.java>`__:
      a complete version of the preceding snippet.
   -  `Retrieve a list of contacts <#>`__: a
      walkthrough that uses a
      `CursorLoader <#>`__
      to retrieve data from the contacts provider.
   -  `LoaderThrottle <https://android.googlesource.com/platform/development/+/master/samples/ApiDemos/src/com/example/android/apis/app/LoaderThrottle.java>`__:
      an example of how to use throttling to reduce the number of
      queries a content provider performs when its data changes.

Last updated 2024-01-03 UTC.


/Recents screen
===============

.. container:: devsite-article-body clearfix

   The Recents screen, also called the Overview screen, recent task
   list, or recent apps screen, is a system-level UI that lists recently
   accessed `activities <#>`__ and
   `tasks <#>`__. The
   user can navigate through the list, select a task to resume, or
   remove a task from the list by swiping it away.

   The Recents screen uses a `document-centric model <#Documents>`__‚Äîintroduced in Android
   5.0 (API level 21)‚Äîin which multiple instances of the same activity
   containing different documents can appear as tasks in the Recents
   screen. For example, Google Drive might have a task for each of
   several Google documents. Each document appears as a task in the
   Recents screen:

   https://developer.android.google.cn/static/images/components/recents-tasks.mp4

   .. container:: float

   Another common example is when the user is using their browser and
   they tap **Share** > **Gmail**. The Gmail app's **Compose** screen
   appears. Tapping the Recents button at that time reveals Chrome and
   Gmail running as separate tasks:

   https://developer.android.google.cn/static/images/components/recents-gmail-share.mp4

   .. container:: float

   Normally, you let the system define how your tasks and activities are
   represented in the Recents screen. You don't need to modify this
   behavior. However, your app can determine how and when activities
   appear in the Recents screen.

   The
   `ActivityManager.AppTask <#>`__
   class lets you manage tasks, and the activity flags of the
   `Intent <#>`__ class let you
   specify when an activity is added or removed from the Recents screen.
   Also, the
   ``<activity>``
   attributes let you set the behavior in the manifest.

   .. rubric:: Add tasks to the Recents screen
      :name: adding

   Using the flags of the
   `Intent <#>`__ class to add a
   task gives you greater control over when and how a document gets
   opened or reopened in the Recents screen. When you use the
   ``<activity>``
   attributes, you can choose between always opening the document in a
   new task or reusing an existing task for the document.

   .. rubric:: Use the Intent flag to add a task
      :name: flag-new-doc

   When you create a new document for your activity, you call the
   `startActivity() <#startActivity>`__
   method, passing to it the intent that launches the activity. To
   insert a logical break so that the system treats your activity as a
   new task in the Recents screen, pass the
   `FLAG_ACTIVITY_NEW_DOCUMENT <#FLAG_ACTIVITY_NEW_DOCUMENT>`__
   flag in the
   `addFlags() <#addFlags>`__
   method of the `Intent <#>`__ that
   launches the activity.

   **Note:**\  The
   `FLAG_ACTIVITY_NEW_DOCUMENT <#FLAG_ACTIVITY_NEW_DOCUMENT>`__
   flag replaces the
   `FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET <#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET>`__
   flag, which was deprecated in Android 5.0 (API level 21).
   If you set the
   `FLAG_ACTIVITY_MULTIPLE_TASK <#FLAG_ACTIVITY_MULTIPLE_TASK>`__
   flag when you create the new document, the system always creates a
   new task with the target activity as the root. This setting lets the
   same document be opened in more than one task. The following code
   demonstrates how the main activity does this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun createNewDocument(view: View) {
                   val newDocumentIntent = newDocumentIntent()
                   if (useMultipleTasks) {
                       newDocumentIntent.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK)
                   }
                   startActivity(newDocumentIntent)
               }

               private fun newDocumentIntent(): Intent =
                       Intent(this, NewDocumentActivity::class.java).apply {
                           addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT or
                                   android.content.Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS)
                           putExtra(KEY_EXTRA_NEW_DOCUMENT_COUNTER, documentCounter++)
                       }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public void createNewDocument(View view) {
                     final Intent newDocumentIntent = newDocumentIntent();
                     if (useMultipleTasks) {
                         newDocumentIntent.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
                     }
                     startActivity(newDocumentIntent);
                 }

                 private Intent newDocumentIntent() {
                     boolean useMultipleTasks = checkbox.isChecked();
                     final Intent newDocumentIntent = new Intent(this, NewDocumentActivity.class);
                     newDocumentIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT);
                     newDocumentIntent.putExtra(KEY_EXTRA_NEW_DOCUMENT_COUNTER, documentCounter++);
                     return newDocumentIntent;
                 }

               }

   **Note:**\  Activities launched with the
   ``FLAG_ACTIVITY_NEW_DOCUMENT`` flag must have the
   ``android:launchMode="standard"`` attribute value (the default) set
   in the manifest.
   When the main activity launches a new activity, the system searches
   through existing tasks for one whose intent matches the intent
   component name and the intent data for the activity. If the task is
   not found, or the intent contained the
   ``FLAG_ACTIVITY_MULTIPLE_TASK`` flag, a new task is created with the
   activity as its root.

   If the system finds a task whose intent matches the intent component
   name and the intent data, it brings that task to the front and passes
   the new intent to
   `onNewIntent() <#onNewIntent>`__.
   The new activity gets the intent and creates a new document in the
   Recents screen, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)
                   setContentView(R.layout.activity_new_document)
                   documentCount = intent
                           .getIntExtra(DocumentCentricActivity.KEY_EXTRA_NEW_DOCUMENT_COUNTER, 0)
                   documentCounterTextView = findViewById(R.id.hello_new_document_text_view)
                   setDocumentCounterText(R.string.hello_new_document_counter)
               }

               override fun onNewIntent(newIntent: Intent) {
                   super.onNewIntent(newIntent)
                   /* If FLAG_ACTIVITY_MULTIPLE_TASK has not been used, this Activity
                   will be reused. */
                   setDocumentCounterText(R.string.reusing_document_counter)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onCreate(Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);
                   setContentView(R.layout.activity_new_document);
                   documentCount = getIntent()
                           .getIntExtra(DocumentCentricActivity.KEY_EXTRA_NEW_DOCUMENT_COUNTER, 0);
                   documentCounterTextView = (TextView) findViewById(
                           R.id.hello_new_document_text_view);
                   setDocumentCounterText(R.string.hello_new_document_counter);
               }

               @Override
               protected void onNewIntent(Intent intent) {
                   super.onNewIntent(intent);
                   /* If FLAG_ACTIVITY_MULTIPLE_TASK has not been used, this activity
                   is reused to create a new document.
                    */
                   setDocumentCounterText(R.string.reusing_document_counter);
               }

   .. rubric:: Use the activity attribute to add a task
      :name: attr-doclaunch

   An activity can also specify in its manifest that it always launches
   into a new task by using the
   ``<activity>``
   attribute
   `android:documentLaunchMode <#dlmode>`__.
   This attribute has four values, which produce the following effects
   when the user opens a document with the application:

   ``intoExisting``
      The activity reuses an existing task for the document. This is the
      same as setting the
      `FLAG_ACTIVITY_NEW_DOCUMENT <#FLAG_ACTIVITY_NEW_DOCUMENT>`__
      flag *without* setting the
      `FLAG_ACTIVITY_MULTIPLE_TASK <#FLAG_ACTIVITY_MULTIPLE_TASK>`__
      flag, as described in the `Using the Intent flag to add a task <#flag-new-doc>`__ section.
   ``always``
      The activity creates a new task for the document, even if the
      document is already opened. Using this value is the same as
      setting both the ``FLAG_ACTIVITY_NEW_DOCUMENT`` and
      ``FLAG_ACTIVITY_MULTIPLE_TASK`` flags.
   ``none``
      The activity does not create a new task for the document. The
      Recents screen treats the activity as it would by default. It
      displays a single task for the app, which resumes from whatever
      activity the user last invoked.
   ``never``
      The activity does not create a new task for the document. Setting
      this value overrides the behavior of the
      ``FLAG_ACTIVITY_NEW_DOCUMENT`` and ``FLAG_ACTIVITY_MULTIPLE_TASK``
      flags. If either of these are set in the intent, and the Recents
      screen displays a single task for the app, it resumes from
      whatever activity the user last invoked.

   **Note:**\  For values other than ``none`` and ``never``, the
   activity must be defined with ``launchMode="standard"``. If this
   attribute is not specified, ``documentLaunchMode="none"`` is used.

   .. rubric:: Remove tasks
      :name: removing

   By default, a document task automatically exits from the Recents
   screen when its activity finishes. You can override this behavior
   with the
   `ActivityManager.AppTask <#>`__
   class, with an `Intent <#>`__
   flag, or with an
   ``<activity>``
   attribute.

   You can always exclude a task from the Recents screen entirely by
   setting the ``<activity>`` attribute
   `android:excludeFromRecents <#exclude>`__
   to ``true``.

   You can set the maximum number of tasks that your app can include in
   the Recents screen by setting the ``<activity>`` attribute
   `android:maxRecents <#maxrecents>`__
   to an integer value. When the maximum number of tasks is reached, the
   least recently used task disappears from the Recents screen. The
   default is 16, and the maximum value is 50 (25 on low memory
   devices). Values less than 1 are not valid.

   .. rubric:: Use the AppTask class to remove tasks
      :name: apptask-remove

   In the activity that creates a new task in the Recents screen, you
   can specify when to remove the task and finish all activities
   associated with it by calling the
   `finishAndRemoveTask() <#finishAndRemoveTask>`__
   method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun onRemoveFromOverview(view: View) {
                   // It is good pratice to remove a document from the overview stack if not needed anymore.
                   finishAndRemoveTask()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public void onRemoveFromRecents(View view) {
                   // The document is no longer needed; remove its task.
                   finishAndRemoveTask();
               }

   **Note:**\  Using the
   `finishAndRemoveTask() <#finishAndRemoveTask>`__
   method overrides the use of the
   `FLAG_ACTIVITY_RETAIN_IN_RECENTS <#FLAG_ACTIVITY_RETAIN_IN_RECENTS>`__
   flag discussed in the next section.

   .. rubric:: Retain finished tasks
      :name: retain-finished

   If you want to retain a task in the Recents screen, even if its
   activity has finished, pass the
   `FLAG_ACTIVITY_RETAIN_IN_RECENTS <#FLAG_ACTIVITY_RETAIN_IN_RECENTS>`__
   flag in the
   `addFlags() <#addFlags>`__
   method of the intent that launches the activity.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private fun newDocumentIntent() =
                       Intent(this, NewDocumentActivity::class.java).apply {
                           addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT or
                                   android.content.Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS)
                           putExtra(KEY_EXTRA_NEW_DOCUMENT_COUNTER, getAndIncrement())
                       }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private Intent newDocumentIntent() {
                   final Intent newDocumentIntent = new Intent(this, NewDocumentActivity.class);
                   newDocumentIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT |
                     android.content.Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS);
                   newDocumentIntent.putExtra(KEY_EXTRA_NEW_DOCUMENT_COUNTER, getAndIncrement());
                   return newDocumentIntent;
               }

   To achieve the same effect, set the
   ``<activity>``
   attribute
   `android:autoRemoveFromRecents <#autoremrecents>`__
   to ``false``. The default value is ``true`` for document activities
   and ``false`` for regular activities. Using this attribute overrides
   the ``FLAG_ACTIVITY_RETAIN_IN_RECENTS`` flag.

   .. rubric:: Enable recents URL sharing (Pixel only)
      :name: url-sharing

   On Pixel devices running Android 12 or higher, users can share links
   to recently viewed web content directly from the Recents screen.
   After visiting the content in an app, the user can swipe to the
   Recents screen and find the app where they viewed the content, then
   tap the link button to copy or share the URL.

   .. container:: float

   Any app can enable Recents linking for users by providing a web UI
   and overriding
   `onProvideAssistContent() <#onProvideAssistContent>`__,
   as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MainActivity : AppCompatActivity() {
                   protected fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setContentView(R.layout.activity_main)
                   }

                   fun onProvideAssistContent(outContent: AssistContent) {
                       super.onProvideAssistContent(outContent)
                       outContent.setWebUri(Uri.parse("https://example.com/myCurrentPage"))
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends AppCompatActivity {

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       setContentView(R.layout.activity_main);
                   }

                   @Override
                   public void onProvideAssistContent(AssistContent outContent) {
                       super.onProvideAssistContent(outContent);

                       outContent.setWebUri(Uri.parse("https://example.com/myCurrentPage"));
                   }
               }

Last updated 2024-01-03 UTC.


/Restrictions on starting activities from the background
========================================================

.. container:: devsite-article-body clearfix

   ``Android 10`` (API level 29) and higher place restrictions on when apps
   can start
   `activities <#>`__ when
   the app runs in the background. These restrictions help minimize
   interruptions for the user and keep the user more in control of
   what's shown on their screen.

   **Note:**\  For the purpose of starting activities, an app running a
   foreground service is considered to be in the background. For more
   information, see `foreground services <#>`__.
   This guide presents notifications as an alternative for starting
   activities from the background. It also lists the specific cases
   where the restriction doesn't apply.

   .. rubric:: Display notifications instead
      :name: display-notification

   In nearly all cases, apps in the background must `display time-sensitive notifications <#>`__ to provide
   urgent information to the user instead of directly starting an
   activity. Such notifications include handling an incoming phone call
   or an active alarm clock.

   This notification-based alert and reminder system provides several
   advantages for users:

   -  When using the device, the user sees a heads-up notification that
      lets them respond. The user maintains their current context and
      has control over the content that they see on the screen.
   -  Time-sensitive notifications respect the user's `Do Not Disturb <#dnd-mode>`__ rules. For
      example, users might permit calls only from specific contacts or
      from repeat callers when Do Not Disturb is enabled.
   -  When the device's screen is off, the full-screen intent launches
      immediately.
   -  In the device's **Settings** screen, the user can see which apps
      have recently sent notifications, including from specific
      notification channels. From this screen, the user can control
      their notification preferences.

   .. rubric:: When apps can start activities
      :name: exceptions

   Apps running on ``Android 10`` or higher can start activities when one or
   more of the following conditions are met:

   -  The app has a visible window, such as an activity in the
      foreground.

      -  Starting with ``Android 14``, this requires the app sending the
         ``PendingIntent`` to explicitly opt in by passing in an
         `ActivityOptions <#>`__
         bundle with
         `setPendingIntentBackgroundActivityStartMode (MODE_BACKGROUND_ACTIVITY_START_ALLOWED) <#setPendingIntentBackgroundActivityStartMode>`__.

   -  The app has an activity in the `back stack <#>`__ of
      the foreground task.

   -  The app has an activity in the back stack of an existing task on
      the `Recents screen <#>`__.

      **Note:**\  When such an app attempts to start a new activity, the
      system places that activity on top of the app's existing task but
      doesn't navigate away from the currently visible task. When the
      user later returns to the app's task, the system starts the new
      activity instead of the activity that had previously been on top
      of the app's task.

   -  The app has an activity that started very recently.

   -  The app called
      `finish() <#finish>`__ on an
      activity very recently. This applies only when the app had either
      an activity in the foreground or an activity in the back stack of
      the foreground task at the time ``finish()`` was called.

   -  The app has one of the following services that is bound by the
      system. These services might need to launch a UI.

      -  `AccessibilityService <#>`__
      -  `AutofillService <#>`__
      -  `CallRedirectionService <#>`__
      -  `HostApduService <#>`__
      -  `InCallService <#>`__
      -  `TileService <#>`__
      -  `VoiceInteractionService <#>`__
      -  `VrListenerService <#>`__.

   -  The app has a service that is bound by a different, visible app.
      The app bound to the service must remain visible for the app in
      the background to start activities successfully.

         **Note:**\  Starting from Android 14, if the app bound to the
         service is targeting Android 14 or higher, it no longer allows
         the app that has the service to start a background activity by
         default. The app has to pass the flag
         ``Context.BIND_ALLOW_ACTIVITY_STARTS`` to allow the bound
         service app to start background activities.

   -  The app receives a notification
      `PendingIntent <#>`__ from
      the system. In the case of pending intents for services and
      broadcast receivers, the app can start activities for a few
      seconds after the pending intent is sent.

   -  The app receives a ``PendingIntent`` that is sent from a
      different, visible app.

         **Note:**\  Starting from Android 14, apps targeting Android 14
         or higher must opt in to allow background activity launch when
         sending a ``PendingIntent``. To opt in, the app should pass an
         ``ActivityOptions`` bundle with
         ``setPendingIntentBackgroundActivityStartMode (ActivityOptions.MODE_BACKGROUND_ACTIVITY_START_ALLOWED)``

   -  The app receives a system broadcast where the app is expected to
      launch a UI. Examples include
      `ACTION_NEW_OUTGOING_CALL <#ACTION_NEW_OUTGOING_CALL>`__
      and
      `SECRET_CODE_ACTION <#SECRET_CODE_ACTION>`__.
      The app can start activities for a few seconds after the broadcast
      is sent.

   -  The app is associated with a companion hardware device through the
      `CompanionDeviceManager <#>`__
      API. This API lets the app start activities in response to actions
      that the user performs on a paired device.

   -  The app is a `device policy controller <#>`__
      running in `device owner mode <#>`__.
      Example use cases include `fully managed enterprise devices <https://developers.google.cn/android/work/requirements/fully-managed-device>`__
      as well as `dedicated devices <#>`__
      like digital signage and kiosks.

   -  The app is granted the
      `SYSTEM_ALERT_WINDOW <#SYSTEM_ALERT_WINDOW>`__
      permission by the user.

      **Note:**\  Apps running on ``Android 10`` (Go edition) `cannot receive the ``SYSTEM_ALERT_WINDOW``
      permission </about/versions/10/behavior-changes-all#sysalert-go>`__.

Last updated 2024-05-03 UTC.


/Overview: App shortcuts overview
=================================

.. container:: devsite-article-body clearfix

   As a developer, you can define *shortcuts* to perform specific
   actions in your app. You can display these shortcuts in a supported
   launcher or assistant‚Äîlike Google Assistant‚Äîand help your users
   quickly start common or recommended tasks within your app.

   This documentation shows you how to
   `create <#>`__ and
   `manage <#>`__ app
   shortcuts. You can also learn some `best practices <#>`__ to improve
   your shortcuts.

   .. rubric:: Shortcut types
      :name: shortcut-types

   .. container:: attempt-right

      .. figure:: https://developer.android.google.cn/static/images/guide/topics/ui/shortcuts_2023.png
         name: fig-app-shortcuts
         :alt: app shortcuts
         :width: 250px

         **Figure 1.** Using app shortcuts, you can surface key actions
         and instantly take users deep into your app.

   Each shortcut references one or more
   `intents <#>`__, each of which
   launches a specific action in your app when users select the
   shortcut. The types of shortcuts you create for your app depend on
   the app's use case. Examples of actions you can express as shortcuts
   include the following:

   -  Composing a new email in an email app.
   -  Navigating users to a particular location in a mapping app.
   -  Sending messages to a user's contact in a communication app.
   -  Playing the next episode of a TV show in a media app.
   -  Loading the last save point in a gaming app.
   -  Letting the user order a drink in a delivery app using spoken
      commands.

   **Note:** Only main activities‚Äîactivities that handle the
   `Intent.ACTION_MAIN <#ACTION_MAIN>`__
   action and the
   `Intent.CATEGORY_LAUNCHER <#CATEGORY_LAUNCHER>`__
   category‚Äîcan have shortcuts. If an app has multiple main activities,
   define the set of shortcuts for each activity.
   You can publish the following types of shortcuts for your app:

   -  *Static shortcuts* are defined in a resource file that is packaged
      into an APK or `app bundle <#>`__.
   -  *Dynamic shortcuts* can be pushed, updated, and removed by your
      app only at runtime.
   -  *Pinned shortcuts* can be added to supported launchers at runtime
      if the user grants permission.
      **Note:** Users can also create pinned shortcuts by copying your
      app's static and dynamic shortcuts onto the launcher.

   .. rubric:: Display shortcuts in assistants using capabilities
      :name: shortcut-capabilities

   *Capabilities* in ``shortcuts.xml`` let you declare the types of
   actions users can take to launch your app and jump directly to
   performing a specific task. For example, you can give users voice
   control of your app through Google Assistant by declaring
   ``capability`` elements that extend your in-app functionality to
   Assistant `App Actions <https://developer.android.google.cn/guide/app-actions/overview#app_actions>`__.
   For more details, see the documentation about `adding capabilities <#>`__.

   .. rubric:: Shortcut limitations
      :name: shortcut-limitations

   Most supported launchers display up to four shortcuts at a time,
   including both static and dynamic shortcuts. When pushing dynamic
   shortcuts for display on Google's surfaces, such as Google Assistant,
   use the `Google Shortcuts Integration Library <#gsi-library>`__
   to avoid being subject to the shortcut limit.

   If you choose not to use the Google Shortcuts Integration Library,
   your app is subject to the device's limit for the number of shortcuts
   it supports at a time. Shortcuts published this way only appear
   within the Android launchers and aren't discoverable on Google
   surfaces such as Assistant.

   **Note:** The maximum number of shortcuts a device supports varies.
   Use the
   `getMaxShortcutCountPerActivity() <#getMaxShortcutCountPerActivity>`__
   method to determine how many shortcuts a particular device supports.
   There is no limit to the number of pinned shortcuts users can create
   to your app. Your app can't remove pinned shortcuts, but it can
   `disable <#disable-shortcuts>`__
   them.

   **Note:** Although other apps can't access the metadata within your
   shortcuts, the launcher itself can access this data. Therefore,
   conceal sensitive user information in this metadata.
   To start creating shortcuts for your app, refer to the following
   documentation:

   -  `Create shortcuts <#>`__
   -  `Manage shortcuts <#>`__
   -  `Best practices for shortcuts <#>`__

   For more details about operations you can perform on shortcuts, see
   the
   `ShortcutManager <#>`__
   API reference documentation.

Last updated 2024-04-29 UTC.


/Create shortcuts
=================

.. container:: devsite-article-body clearfix

   Shortcuts deliver specific types of content to your users by helping
   them quickly access parts of your app.

   .. figure::
      https://developer.android.google.cn/static/images/guide/topics/ui/shortcuts/pinned-shortcuts.png
      name: fig-pinned-shortcuts-example
      :alt: An image showing the contrast between app shortcuts and
      pinned shortcuts
      :width: 50.0%

      **Figure 1.** App shortcuts and pinned shortcuts.

   How you deliver content with shortcuts depends on your use case and
   whether the shortcut's context is app-driven or user-driven. Although
   a static shortcut's context doesn't change and a dynamic shortcut's
   context constantly changes, your app drives the context in both
   cases. In cases where a user chooses how your app delivers content to
   them, such as with a pinned shortcut, the context is defined by the
   user. The following scenarios describe a few use cases for each
   shortcut type:

   -  `Static shortcuts <#static>`__
      **are best for apps that link to content using a consistent
      structure throughout the lifetime of a user's interaction with the
      app.** Because most launchers `only display four shortcuts <#>`__ at once,
      static shortcuts are useful for performing a routine task in a
      consistent way, such as if the user wants to view their calendar
      or email in a specific way .
   -  `Dynamic shortcuts <#dynamic>`__
      **are used for actions in apps that are context-sensitive.**
      Context-sensitive shortcuts are tailored to the actions users
      perform in an app. For example, if you build a game that lets the
      user start from their current level on launch, you need to update
      the shortcut frequently. Using a dynamic shortcut lets you update
      the shortcut each time the user clears a level.
   -  `Pinned shortcuts <#pinned>`__
      **are used for specific user-driven actions.** For example, a user
      might want to pin a specific website to the launcher. This is
      beneficial because it lets the user perform a custom action‚Äîlike
      navigating to the website in one step, more quickly than using a
      default instance of a browser.

   .. rubric:: Create static shortcuts
      :name: static

   Static shortcuts provide links to generic actions within your app,
   and these actions must remain consistent over the lifetime of your
   app's current version. Good options for static shortcuts include
   viewing sent messages, setting an alarm, and displaying a user's
   exercise activity for the day.

   To create a static shortcut, do the following:

   #. In your app's ``AndroidManifest.xml`` file, find the activity
      whose intent filters are set to the
      `android.intent.action.MAIN <#ACTION_MAIN>`__
      action and the
      `android.intent.category.LAUNCHER <#CATEGORY_LAUNCHER>`__
      category.

   #. Add a
      ``<meta-data>``
      element to this activity that references the resource file where
      the app's shortcuts are defined:

      .. code:: prettyprint

           <manifest xmlns:android="http://schemas.android.com/apk/res/android"
                     package="com.example.myapplication">
             <application ... >
               <activity android:name="Main">
                 <intent-filter>
                   <action android:name="android.intent.action.MAIN" />
                   <category android:name="android.intent.category.LAUNCHER" />
                 </intent-filter>
                 
                 <meta-data android:name="android.app.shortcuts"
                            android:resource="@xml/shortcuts" /> 
               </activity>
             </application>
           </manifest>
           

      **Note:** If using an
      `activity-alias <#>`__
      define the meta-data in the activity-alias rather than the
      activity it targets using the
      `targetActivity <#trgt>`__
      attribute.

   #. Create a new resource file called ``res/xml/shortcuts.xml``.

   #. In the new resource file, add a ``<shortcuts>`` root element that
      contains a list of ``<shortcut>`` elements. In each ``<shortcut>``
      element, include information about a static shortcut including its
      icon, description labels, and the intents it launches within the
      app:

      .. code:: prettyprint

           <shortcuts xmlns:android="http://schemas.android.com/apk/res/android">
             <shortcut
               android:shortcutId="compose"
               android:enabled="true"
               android:icon="@drawable/compose_icon"
               android:shortcutShortLabel="@string/compose_shortcut_short_label1"
               android:shortcutLongLabel="@string/compose_shortcut_long_label1"
               android:shortcutDisabledMessage="@string/compose_disabled_message1">
               <intent
                 android:action="android.intent.action.VIEW"
                 android:targetPackage="com.example.myapplication"
                 android:targetClass="com.example.myapplication.ComposeActivity" />
               <!-- If your shortcut is associated with multiple intents, include them
                    here. The last intent in the list determines what the user sees when
                    they launch this shortcut. -->
               <categories android:name="android.shortcut.conversation" />
               <capability-binding android:key="actions.intent.CREATE_MESSAGE" />
             </shortcut>
             <!-- Specify more shortcuts here. -->
           </shortcuts>
           

   .. rubric:: Customize attribute values
      :name: attribute-values

   The following list includes descriptions for the different attributes
   within a static shortcut. Provide a value for ``android:shortcutId``
   and ``android:shortcutShortLabel``. All other values are optional.

   ``android:shortcutId``
      A string literal that represents the shortcut when a
      `ShortcutManager <#>`__
      object performs operations on it.

      **Note:** You can't set this attribute's value to a resource
      string, such as ``@string/shortcut_id``.

   ``android:shortcutShortLabel``
      A concise phrase that describes the shortcut's purpose. When
      possible, limit this short description to 10 characters.

      For more information, see
      `setShortLabel() <#setShortLabel>`__.

      **Note:** This attribute's value must be a resource string, such
      as ``@string/shortcut_short_label``.

   ``android:shortcutLongLabel``
      An extended phrase that describes the shortcut's purpose. If
      there's enough space, the launcher displays this value instead of
      ``android:shortcutShortLabel``. When possible, limit this long
      description to 25 characters.

      For more information, see
      `setLongLabel() <#setLongLabel>`__.

      **Note:** This attribute's value must be a resource string, such
      as ``@string/shortcut_long_label``.

   ``android:shortcutDisabledMessage``
      The message that appears in a supported launcher when the user
      attempts to launch a disabled shortcut. The message must explain
      to the user why the shortcut is disabled. This attribute's value
      has no effect if ``android:enabled`` is ``true``.

      **Note:** This attribute's value must be a resource string, such
      as ``@string/shortcut_disabled_message``.

   ``android:enabled``
      Determines whether the user can interact with the shortcut from a
      supported launcher. The default value of ``android:enabled`` is
      ``true``. If you set it to ``false``, set an
      ``android:shortcutDisabledMessage`` that explains why you're
      disabling the shortcut. If you don't think you need to provide
      such a message, remove the shortcut from the XML file entirely.

   ``android:icon``
      The `bitmap <#>`__ or `adaptive icon <#>`__ that
      the launcher uses when displaying the shortcut to the user. This
      value can be the path to an image or the resource file that
      contains the image. Use adaptive icons whenever possible to
      improve performance and consistency.

      **Note:** Shortcut icons can't include
      `tints <#DrawableTint>`__.

   .. rubric:: Configure inner elements
      :name: inner-elements

   The XML file that lists an app's static shortcuts supports the
   following elements inside each ``<shortcut>`` element. You **must**
   include an ``intent`` inner element for each static shortcut that you
   define.

   ``intent``
      The action that the system launches when the user selects the
      shortcut. This intent must provide a value for the
      ``android:action`` attribute.

      **Note:** This ``intent`` element can't include string resources.

      You can provide multiple intents for a single shortcut. See
      `Manage multiple intents and activities <#multiple-intents-activities>`__,
      `Set an intent <#set-an-intent>`__,
      and the
      `TaskStackBuilder <#>`__
      class reference for details.

   ``categories``
      Provides a grouping for the types of actions that your app's
      shortcuts perform, such as creating new chat messages.

      For a list of supported shortcut categories, see the
      `ShortcutInfo <#>`__
      class reference.

   ``capability-binding``
      Declares the
      `capability <#>`__
      linked with the shortcut.

      In the previous example, the shortcut is linked to a capability
      declared for
      `CREATE_MESSAGE <#>`__,
      which is an `App Actions <#>`__ built-in
      intent. This capability binding lets users use spoken commands
      with Google Assistant to invoke a shortcut.

   .. rubric:: Create dynamic shortcuts
      :name: dynamic

   Dynamic shortcuts provide links to specific, context-sensitive
   actions within your app. These actions can change between uses of
   your app and while your app is running. Good uses for dynamic
   shortcuts include calling a specific person, navigating to a specific
   location, and loading a game from the user's last save point. You can
   also use dynamic shortcuts to open a conversation.

   The
   `ShortcutManagerCompat <#>`__
   Jetpack library is a helper for the
   `ShortcutManager <#>`__
   API, which lets you manage dynamic shortcuts in your app. Using the
   ``ShortcutManagerCompat`` library reduces boilerplate code and helps
   ensure that your shortcuts work consistently across Android versions.
   This library is also required for pushing dynamic shortcuts so that
   they are eligible to appear on Google surfaces‚Äîlike Assistant‚Äîwith
   the `Google Shortcuts Integration Library <#gsi-library>`__.

   The ``ShortcutManagerCompat`` API lets your app perform the following
   operations with dynamic shortcuts:

   -  **Push and update:** use
      `pushDynamicShortcut() <#pushDynamicShortcut>`__
      to publish and update your dynamic shortcuts. If there are already
      dynamic or pinned shortcuts with the same ID, each mutable
      shortcut updates.
   -  **Remove:** remove a set of dynamic shortcuts using
      `removeDynamicShortcuts() <#removeDynamicShortcuts>`__.
      Remove all dynamic shortcuts using
      `removeAllDynamicShortcuts() <#removeAllDynamicShortcuts>`__.

   For more information about performing operations on shortcuts, see
   `Manage shortcuts <#>`__
   and the
   `ShortcutManagerCompat <#>`__
   reference.

   Here's an example of creating a dynamic shortcut and associating it
   with your app:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               val shortcut = ShortcutInfoCompat.Builder(context, "id1")
                       .setShortLabel("Website")
                       .setLongLabel("Open the website")
                       .setIcon(IconCompat.createWithResource(context, R.drawable.icon_website))
                       .setIntent(Intent(Intent.ACTION_VIEW,
                               Uri.parse("https://www.mysite.example.com/")))
                       .build()

               ShortcutManagerCompat.pushDynamicShortcut(context, shortcut)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               ShortcutInfoCompat shortcut = new ShortcutInfoCompat.Builder(context, "id1")
                   .setShortLabel("Website")
                   .setLongLabel("Open the website")
                   .setIcon(IconCompat.createWithResource(context, R.drawable.icon_website))
                   .setIntent(new Intent(Intent.ACTION_VIEW,
                                  Uri.parse("https://www.mysite.example.com/")))
                   .build();

               ShortcutManagerCompat.pushDynamicShortcut(context, shortcut);

   .. rubric:: Add the Google Shortcuts Integration Library
      :name: gsi-library

   The Google Shortcuts Integration Library is an optional Jetpack
   library. It lets you push dynamic shortcuts that can be displayed on
   Android surfaces, such as the launcher, and Google surfaces, such as
   Assistant. Using this library helps users discover your shortcuts to
   quickly access specific content or replay actions in your app.

   For example, a messaging app might push a dynamic shortcut for a
   contact named "Alex" after a user messages that person. After the
   dynamic shortcut is pushed, if the user asks Assistant, *"Hey Google,
   message Alex on ExampleApp,"* Assistant can launch ExampleApp and
   automatically configure it to send a message to Alex.

   Dynamic shortcuts pushed with this library aren't subject to the
   `shortcut limits <#shortcut-limitations>`__
   enforced on a per-device basis. This lets your app push a shortcut
   every time a user completes an associated action in your app. Pushing
   frequent shortcuts this way lets Google understand your user's
   patterns of use and suggest contextually relevant shortcuts to them.

   For example, Assistant can learn from shortcuts pushed from your
   fitness-tracking app that a user typically runs each morning and
   proactively suggest a "start a run" shortcut when the user picks up
   their phone in the morning.

   The Google Shortcuts Integration Library doesn't offer any
   addressable functionality itself. Adding this library to your app
   lets Google surfaces take in the shortcuts your app pushes using
   ``ShortcutManagerCompat``.

   To use this library in your app, follow these steps:

   #. Update your ``gradle.properties`` file to support `AndroidX libraries <https://developer.android.google.cn/jetpack/androidx#using_androidx_libraries_in_your_project>`__:

      .. container::

         .. code:: prettyprint

                  
                  android.useAndroidX=true
                  # Automatically convert third-party libraries to use AndroidX
                  android.enableJetifier=true
                  
                  

   #. In ``app/build.gradle``, add dependencies for the Google Shortcuts
      Integration Library and ``ShortcutManagerCompat``:

      .. container::

         .. code:: prettyprint

                  
                  dependencies {
                    implementation "androidx.core:core:1.6.0"
                    implementation 'androidx.core:core-google-shortcuts:1.0.0'
                    ...
                  }
                  
                  

   With the library dependencies added to your Android project, your app
   can use the ``pushDynamicShortcut()`` method from
   ``ShortcutManagerCompat`` to push dynamic shortcuts that are eligible
   for display on the launcher and participating Google surfaces.

   **Note:** We recommend using ``pushDynamicShortcut`` to push dynamic
   shortcuts using the Google Shortcuts Integration Library. Your app
   can use other methods to publish shortcuts, but those might fail if
   they reach the maximum shortcut limit.

   .. rubric:: Create pinned shortcuts
      :name: pinned

   On Android 8.0 (API level 26) and higher, you can create pinned
   shortcuts. Unlike static and dynamic shortcuts, pinned shortcuts
   appear in supported launchers as separate icons. Figure 1 shows the
   distinction between these two types of shortcuts.

   **Note:** When you attempt to pin a shortcut onto a supported
   launcher, the user receives a confirmation dialog asking their
   permission to pin the shortcut. If the user doesn't let the shortcut
   be pinned, the launcher cancels the request.
   To pin a shortcut to a supported launcher using your app, complete
   the following steps:

   #. Use
      `isRequestPinShortcutSupported() <#isRequestPinShortcutSupported>`__
      to verify that the device's default launcher supports in-app
      pinning of shortcuts.

   #. Create a ``ShortcutInfo`` object in one of two ways, depending on
      whether the shortcut exists:

      a. If the shortcut exists, create a ``ShortcutInfo`` object that
         contains only the existing shortcut's ID. The system finds and
         pins all other information related to the shortcut
         automatically.
      b. If you're pinning a new shortcut, create a ``ShortcutInfo``
         object that contains an ID, an intent, and a short label for
         the new shortcut.

      **Note:** Because the system performs `backup and restore <#backup-restore>`__
      on pinned shortcuts automatically, these shortcuts' IDs must
      contain stable, constant strings or server-side identifiers,
      rather than identifiers generated locally that might not make
      sense on other devices.

   #. Pin the shortcut to the device's launcher by calling
      `requestPinShortcut() <#requestPinShortcut>`__.
      During this process, you can pass in a
      `PendingIntent <#>`__
      object, which notifies your app only when the shortcut pins
      successfully.

      **Note:** If the user doesn't let the shortcut be pinned to the
      launcher, your app doesn't receive a callback.

      After a shortcut is pinned, your app can update its contents using
      the
      `updateShortcuts() <#updateShortcuts>`__
      method. For more information, read `Update shortcuts <#update-shortcuts>`__.

   The following code snippet demonstrates how to create a pinned
   shortcut.

   **Note:** Instances of the ``ShortcutManager`` class must be obtained
   using
   `Context.getSystemService(Class) <#getSystemService>`__
   with the argument ``ShortcutManager.class`` or
   `Context.getSystemService(String) <#getSystemService>`__
   with the argument
   `Context.SHORTCUT_SERVICE <#SHORTCUT_SERVICE>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val shortcutManager = getSystemService(ShortcutManager::class.java)

               if (shortcutManager!!.isRequestPinShortcutSupported) {
                   // Enable the existing shortcut with the ID "my-shortcut".
                   val pinShortcutInfo = ShortcutInfo.Builder(context, "my-shortcut").build()

                   // Create the PendingIntent object only if your app needs to be notified
                   // that the user let the shortcut be pinned. If the pinning operation fails,
                   // your app isn't notified. Assume here that the app implements a method
                   // called createShortcutResultIntent() that returns a broadcast intent.
                   val pinnedShortcutCallbackIntent = shortcutManager.createShortcutResultIntent(pinShortcutInfo)

                   // Configure the intent so that your app's broadcast receiver gets the
                   // callback successfully. For details, see PendingIntent.getBroadcast().
                   val successCallback = PendingIntent.getBroadcast(context, /* request code */ 0,
                           pinnedShortcutCallbackIntent, /* flags */ 0)

                   shortcutManager.requestPinShortcut(pinShortcutInfo,
                           successCallback.intentSender)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ShortcutManager shortcutManager =
                       context.getSystemService(ShortcutManager.class);

               if (shortcutManager.isRequestPinShortcutSupported()) {
                   // Enable the existing shortcut with the ID "my-shortcut".
                   ShortcutInfo pinShortcutInfo =
                           new ShortcutInfo.Builder(context, "my-shortcut").build();

                   // Create the PendingIntent object only if your app needs to be notified
                   // that the user let the shortcut be pinned. If the pinning operation fails,
                   // your app isn't notified. Assume here that the app implements a method
                   // called createShortcutResultIntent() that returns a broadcast intent.
                   Intent pinnedShortcutCallbackIntent =
                           shortcutManager.createShortcutResultIntent(pinShortcutInfo);

                   // Configure the intent so that your app's broadcast receiver gets the
                   // callback successfully. For details, see PendingIntent.getBroadcast().
                   PendingIntent successCallback = PendingIntent.getBroadcast(context, /* request code */ 0,
                           pinnedShortcutCallbackIntent, /* flags */ 0);

                   shortcutManager.requestPinShortcut(pinShortcutInfo,
                           successCallback.getIntentSender());
               }

   **Note:** See also the Support Library APIs
   `isRequestPinShortcutSupported() <#isRequestPinShortcutSupported>`__
   and
   `requestPinShortcut() <#requestPinShortcut>`__,
   which work on Android 7.1 (API level 25) and lower. The Support
   Library falls back to the deprecated
   `EXTRA_SHORTCUT_INTENT <#EXTRA_SHORTCUT_INTENT>`__
   extra to attempt the pinning process.

   .. rubric:: Create a custom shortcut activity
      :name: custom-pinned

   .. figure::
      https://developer.android.google.cn/static/images/guide/topics/ui/shortcuts/pinned-shortcuts-dialog.png
      name: fig-pinned-shortcuts-dialog
      :alt: An image showing the custom dialog activity that shows the
      prompt 'Do you want to add the Gmail launcher icon to your home
      screen?' The custom options are 'No thanks' and 'Add icon'.
      :width: 40.0%

      **Figure 2.** Example of a custom app shortcut dialog activity.

   You can also create a specialized activity that helps users create
   shortcuts, complete with custom options and a confirmation button.
   Figure 2 shows an example of this type of activity in the Gmail app.

   In your app's manifest file, add
   `ACTION_CREATE_SHORTCUT <#ACTION_CREATE_SHORTCUT>`__
   to the activity's
   ``<intent-filter>``
   element. This declaration sets up the following behavior when the
   user attempts to create a shortcut:

   #. The system starts your app's specialized activity.
   #. The user sets options for the shortcut.
   #. The user selects the confirmation button.
   #. Your app creates the shortcut using the
      `createShortcutResultIntent() <#createShortcutResultIntent>`__
      method. This method returns an
      `Intent <#>`__, which your app
      relays back to the previously executing activity using
      `setResult() <#setResult>`__.
   #. Your app calls
      `finish() <#finish>`__ on the
      activity used to create the customized shortcut.

   Similarly, your app can prompt users to add pinned shortcuts to the
   home screen after installation or the first time the app is launched.
   This method is effective because it helps your users create a
   shortcut as part of their ordinary workflow.

   .. rubric:: Test shortcuts
      :name: testing

   To test your app's shortcuts, install your app on a device with a
   launcher that supports shortcuts. Then, perform the following
   actions:

   -  Touch & hold your app's launcher icon to view the shortcuts that
      you define for your app.
   -  Drag a shortcut to pin it to the device's launcher.

Last updated 2024-04-19 UTC.


/Add capabilities to shortcuts
==============================

.. container:: devsite-article-body clearfix

   Capabilities in ``shortcuts.xml`` let you declare the types of
   actions users can take to launch your app and directly perform a
   specific task.

   For example, Google Assistant App Actions use capabilities to let
   developers extend in-app features to `built-in intents <#>`__ (BIIs),
   letting users activate and control those features using spoken
   commands. A capability consists of the name of the action and an
   ``intent`` targeting the destination in your app that resolves the
   user intent.

   .. rubric:: Define capabilities in shortcuts.xml
      :name: definition

   You define ``capability`` elements in a ``shortcuts.xml`` resource
   file in your Android app development project. To define a
   ``capability`` element, do the following:

   #. Create a ``shortcuts.xml`` resource by following the instructions
      in `Create static shortcuts <#static>`__.

   #. Include the following required information in your capability:

      -  **Capability name:** the action you want your app to support.
         Refer to the component documentation for the feature that
         requires capability definitions. App Actions voice-enabled
         commands use the BII ``Action ID`` for capability names, which
         you can find in `BII reference <#>`__.
         For example, the
         `GET_THING <#>`__
         BII lists its ``Action ID`` as ``actions.intent.GET_THING``.

      -  **App destination:** the destination in your app the action
         launches to fulfill the user request. Define app destinations
         using ``intent`` elements nested within the ``capability``.

      -  **Parameter mappings:** each ``intent`` might contain
         parameters to be passed as ``extra`` data of the intent. For
         example, each App Actions BII includes fields representing
         information users often provide in queries that trigger the
         BII.

   The following example demonstrates a capability definition in
   ``shortcuts.xml`` for
   `actions.intent.START_EXERCISE <#>`__,
   a BII that lets users use spoken commands with Assistant to begin a
   workout in a fitness app:

   .. code:: prettyprint

      <shortcuts xmlns:android="http://schemas.android.com/apk/res/android">
        <capability android:name="actions.intent.START_EXERCISE">
          <intent
            android:action="android.intent.action.VIEW"
            android:targetPackage="com.example.sampleApp"
            android:targetClass="com.example.sampleApp.ExerciseActivity">
            <parameter
              android:name="exercise.name"
              android:key="exerciseType"/>
          </intent>
        </capability>
      </shortcuts>

   In the preceding example, the ``<capability>`` ``android:name``
   attribute refers to the ``START_EXERCISE`` BII. If a user invokes
   this BII by asking Assistant, *"Hey Google, start a run in
   ExampleApp,"* Assistant fulfills the user request using information
   provided in the nested ``intent`` element. The ``intent`` in this
   sample defines the following details:

   -  The ``android:targetPackage`` sets the target application package
      for this intent.
   -  The ``android:targetClass`` field specifies the destination
      activity: ``com.example.sampleApp.ExerciseActivity``.
   -  The intent ``parameter`` declares support for a BII parameter
      `exercise.name <#recommended-fields>`__
      and how to pass the parameter value‚Äîcollected from the user‚Äîas
      extra data in the ``intent``.

   .. rubric:: Associate shortcuts with a capability
      :name: associate

   Once you define a capability, you can extend its functionality by
   associating static or dynamic shortcuts with it. How shortcuts are
   linked to a ``capability`` depends on the feature being implemented
   and the actual words included in a user's request. For example, when
   a user begins a run in your fitness tracking app by asking Assistant,
   *"Hey Google, start a run in ExampleApp."* Assistant can use a
   shortcut to launch an instance of a ``capability`` that defines a
   valid exercise entity of "run" for the ``exercise.name`` parameter.

   For more information about associating shortcuts to App Actions, see
   `App Actions overview <#>`__.

Last updated 2024-05-03 UTC.


/Manage shortcuts
=================

.. container:: devsite-article-body clearfix

   After creating shortcuts, you might need to manage them over the
   lifetime of your app. For example, you might want to optimize your
   app by determining how often your users complete specific actions
   with your shortcuts. In another case, you might decide to disable a
   pinned shortcut to prevent your app from performing outdated or
   missing actions. For shortcuts referenced in conversations, you might
   want to track usage to provide signals that improve shortcut ranking.

   This page describes these and several other common ways to manage
   your shortcuts.

   .. rubric:: Shortcut behavior
      :name: shortcut-behavior

   The following sections contain general information about shortcut
   behavior, including visibility, display order, and ranks.

   .. rubric:: Shortcut visibility
      :name: shortcut-visibility

   **Important:**\  All shortcut information is stored in `credential encrypted storage <#>`__, so your app
   can't access a user's shortcuts until after they unlock the device.
   Static shortcuts and dynamic shortcuts appear in a supported launcher
   or assistant when the user performs a specific gesture or voice
   command. On supported launchers, the gesture is a touch & hold on the
   app's launcher icon, but the gesture might be different on other
   launcher apps. With Google Assistant, shortcuts can be displayed
   within Assistant or launched from a user voice command.

   The `LauncherApps <#>`__
   class provides APIs for launcher apps to access shortcuts.

   Because pinned shortcuts appear in the launcher itself, they're
   always visible. A pinned shortcut is removed from the launcher only
   in the following situations:

   -  The user removes it.
   -  The app associated with the shortcut is uninstalled.
   -  The user clears an app's data by going to **Settings > Apps &
      notifications**, selecting the app, then tapping **Storage > Clear
      storage**.

   `Share targets <#providing-direct-share-targets>`__
   are a subset of dynamic shortcuts that appear in the direct share row
   of the Android share sheet.

   .. figure:: /static/images/guide/topics/ui/shortcuts/sharesheet.png
      name: indicators
      :alt: A screenshot of Android Sharesheet
      :width: 40.0%

      **Figure 1.** The Android Sharesheet. Direct share targets appear
      in the first row, followed by ranked apps and then the Apps lists.

   .. rubric:: Shortcut display order
      :name: shortcut-display

   When the launcher displays an app's shortcuts, they must appear in
   the following order:

   #. **Static shortcuts**: shortcuts whose
      `isDeclaredInManifest() <#isDeclaredInManifest>`__
      method returns ``true``.
   #. **Dynamic shortcuts**: shortcuts whose
      `ShortcutInfo.isDynamic() <#isDynamic>`__
      method returns ``true``.

   Within each shortcut type‚Äîstatic and dynamic‚Äîshortcuts are sorted in
   order of increasing *rank* according to
   `ShortcutInfo.getRank <#getRank())>`__.
   Google Assistant also considers shortcut rank when determining
   contextual shortcuts to display to users.

   Ranks are non-negative, sequential integers. Static shortcuts are
   ranked from first-to-last in the order they appear in your
   ``shortcuts.xml`` file. For dynamic shortcuts, you can update ranks
   of existing shortcuts when you call
   `updateShortcuts(Context, List) <#updateShortcuts>`__,
   `addDynamicShortcuts(Context, List) <#addDynamicShortcuts>`__,
   `pushDynamicShortcut(Context, ShortcutInfoCompat) <#pushDynamicShortcut>`__,
   or
   `setDynamicShortcuts(Context, List) <#setDynamicShortcuts>`__.

   The order of share targets is based on various factors including past
   user history, recency, frequency, `rank hint <#setRank>`__,
   app usage, and the priority set on the conversation that is
   associated with a sharing shortcut. Share targets created using the
   `Sharing Shortcuts API <#sharing-shortcuts-api>`__ are
   prioritized over the share targets produced by the
   `ChooserTargetService <#>`__
   which was deprecated in Android 11. In Android 12 and higher share
   targets generated by the deprecated ``ChooserTargetService`` will no
   longer appear in the share sheet.

   Most launchers display a maximum of four shortcuts. For any
   combination of static shortcuts and dynamic shortcuts that are
   defined, the launcher displays a maximum of two static shortcuts and
   two dynamic shortcuts. For example, if you define four static
   shortcuts and programmatically create three dynamic shortcuts, the
   launcher displays the first two static shortcuts, and the two most
   highly-ranked dynamic shortcuts.

   **Note:**\  Ranks are auto-adjusted so they're unique for each type
   of shortcut‚Äîstatic or dynamic. For example, if there are three
   dynamic shortcuts with ranks 0, 1, and 2, adding another dynamic
   shortcut with a rank of 1 represents a request to place this shortcut
   in the second position. In response, the ranks of the shortcuts
   previously ranked 1 and 2 change to 2 and 3, respectively.

   .. rubric:: Manage multiple intents and activities
      :name: manage-multiple

   If you want your app to perform multiple operations when your user
   activates a shortcut, you can configure it to trigger successive
   activities. You can accomplish this by assigning multiple intents,
   starting one activity from another, or setting intent flags,
   depending on the shortcut's type.

   .. rubric:: Assign multiple intents
      :name: assign-multiple

   When creating a shortcut with
   `ShortcutInfoCompat.Builder <#>`__,
   you can use
   `setIntents() <#setIntents>`__
   instead of ``setIntent()``. By calling ``setIntents()``, you can
   launch multiple activities within your app when the user selects a
   shortcut, placing all but the last activity in the list on the back
   `stack <#>`__. If the user then
   taps the device's back button, they see another activity in your app
   instead of returning to the device's launcher.

   **Note:**\  When the user selects a shortcut and then taps the back
   button, your app launches the activity corresponding with the
   second-to-last intent listed in the shortcuts resource file. This
   behavior pattern continues as the user continues to tap the back
   button until the user clears the back stack that a shortcut creates.
   Then, if the user taps the back button again, the system navigates
   them back to the launcher.

   .. rubric:: Start one activity from another
      :name: start-one

   Static shortcuts can't have custom intent flags. The first intent of
   a static shortcut always has
   `Intent.FLAG_ACTIVITY_NEW_TASK <#FLAG_ACTIVITY_NEW_TASK>`__
   and ``Intent.FLAG_ACTIVITY_CLEAR_TASK``
   `set <#FLAG_ACTIVITY_CLEAR_TASK>`__.
   This means that when your app is running, all the existing activities
   in the app are destroyed when a static shortcut is launched. If you
   don't want this behavior, you can use a *trampoline activity* ‚Äîan
   invisible activity that starts another activity‚Äîin
   ``Activity.onCreate(Bundle)``
   `that <#onCreate>`__
   calls ``Activity.finish()``:

   #. In the ``AndroidManifest.xml`` file, include the attribute
      assignment ``android:taskAffinity=``"" in the trampoline activity.
   #. In the shortcuts resource file, reference the trampoline activity
      in the intent within the static shortcut.

   For more information about trampoline activities, see `Starting one activity from another <#soafa>`__.

   .. rubric:: Set intent flags
      :name: set-intent

   You can publish dynamic shortcuts with any set of
   `Intent <#addFlags>`__
   flags. Preferably, specify ``Intent.FLAG_ACTIVITY_CLEAR_TASK`` along
   with your other flags. Otherwise, if you attempt to start another
   task while your app is running, the target activity might not appear.

   To learn more about tasks and intent flags, see `Tasks and the back stack <#>`__.

   .. rubric:: Update shortcuts
      :name: update-shortcuts

   Each app's launcher icon can contain, at most, a number of static and
   dynamic shortcuts combined that is equal to the value returned by
   `getMaxShortcutCountPerActivity <#getMaxShortcutCountPerActivity(android.content.Context))>`__.
   There isn't a limit to the number of pinned shortcuts that an app can
   create.

   When a dynamic shortcut is pinned, even when the publisher removes it
   as a dynamic shortcut, the pinned shortcut is still visible and
   launchable. This lets an app have more than
   ``getMaxShortcutCountPerActivity()`` number of shortcuts.

   Consider the following example, which assumes that the value returned
   by ``getMaxShortcutCountPerActivity()`` is ``4``:

   #. A chat app publishes four dynamic shortcuts, representing the four
      most recent conversations: c1, c2, c3, and c4.
   #. The user pins all four of the shortcuts.
   #. Later, the user starts three additional conversations: c5, c6, and
      c7. The publisher app re-publishes its dynamic shortcuts. The new
      dynamic shortcut list is: c4, c5, c6, and c7.

   The app has to remove c1, c2, and c3, because it can't display more
   than four dynamic shortcuts. However, c1, c2, and c3 are still pinned
   shortcuts that the user can access and launch.

   The user can then access a total of seven shortcuts that link to
   activities in the publisher app. This is because the total includes
   the maximum number of shortcuts and the three pinned shortcuts.

   #. The app can use ``updateShortcuts(Context, List)`` to update any
      of the existing seven shortcuts. For example, you might update
      this set of shortcuts when the chat peers' icons change.
   #. You can use the
      `addDynamicShortcuts(Context, List) <#addDynamicShortcuts>`__
      and ``setDynamicShortcuts(Context, List)`` methods to update
      existing shortcuts with the same IDs. However, you can't use them
      for updating non-dynamic, pinned shortcuts, because these two
      methods try to convert the given lists of shortcuts to dynamic
      shortcuts.

   There isn't a limit to the number of shortcuts that can be pushed for
   display on assistant apps such as Google Assistant. Use the
   `pushDynamicShortcut() <#pushDynamicShortcut>`__
   method of the ``ShortcutManagerCompat`` Jetpack library to create and
   update shortcuts for use on assistant apps. Also, add the `Google Shortcuts Integration library <#gsi-library>`__
   to your app to make dynamic links eligible to appear on Google
   Assistant.

   To learn more about guidelines for app shortcuts, including updating
   shortcuts, see `Best practices for shortcuts <#>`__.

   .. rubric:: Handle system locale changes
      :name: handle-system

   Apps must update dynamic and pinned shortcuts when they receive the
   `Intent.ACTION_LOCALE_CHANGED <#ACTION_LOCALE_CHANGED>`__
   broadcast indicating a change to the system locale.

   .. rubric:: Track shortcut usage
      :name: track-shortcut

   To determine the situations during which static and dynamic shortcuts
   appear, the launcher examines the activation history of shortcuts.
   For static shortcuts, you can keep track of when users complete
   specific actions within your app by calling the
   `reportShortcutUsed() <#reportShortcutUsed>`__
   method and passing it the ID of a shortcut when either of the
   following events occurs:

   -  The user selects the shortcut with the given ID.
   -  Within the app, the user manually completes the action
      corresponding to the same shortcut.

   Your app tracks usage for dynamic shortcuts by calling the
   ``pushDynamicShortcut()`` method and passing it the ID of the
   shortcut when a relevant event occurs. Pushing dynamic shortcut usage
   with this method lets assistant apps such as Google Assistant suggest
   relevant shortcuts to users. Because the ``pushDynamicShortcut()``
   method reports usage when called, don't call the
   ``reportShortcutUsed()`` method for the same shortcuts.

   For conversation-related shortcuts, it is important to track usage
   for outgoing and incoming messages. For details, see the `best practices <#best-practices>`__
   for people and conversations.

   **Note:**\  The `Google Shortcuts Integration Library <#gsi-library>`__
   is required to enable the dynamic links your app pushes to be
   eligible to appear on Google surfaces such as Google Assistant. By
   adding this library to your app, you let Assistant take in your
   dynamic links and suggest them to users from the Assistant app.

   .. rubric:: Disable shortcuts
      :name: disable-shortcuts

   Because your app and its users can pin shortcuts to the device's
   launcher, it's possible that these pinned shortcuts can direct users
   to actions within your app that are out of date or no longer exist.
   To manage this situation, you can disable the shortcuts that you
   don't want users to select by calling
   `disableShortcuts <#disableShortcuts>`__,
   which removes the specified shortcuts from the static and dynamic
   shortcuts list and disables pinned copies of these shortcuts. You can
   also use an overloaded version of this method that accepts a
   `CharSequence <#>`__ as a custom
   error message. That error message then appears when users attempt to
   launch any disabled shortcut.

   **Note:**\  If you remove some of your app's static shortcuts when
   you update your app, the system disables these shortcuts
   automatically.

   .. rubric:: Rate limiting
      :name: rate-limiting

   When using the ``setDynamicShortcuts(), addDynamicShortcuts()``, or
   ``updateShortcuts()`` methods, you might only be able to call these
   methods a specific number of times in a *background app* ‚Äîan app with
   no activities or services in the foreground. The limit on the
   specific number of times you can call these methods is called *rate
   limiting*. This feature prevents
   `ShortcutManagerCompat <#>`__
   from over-consuming device resources.

   When rate limiting is active,
   `isRateLimitingActive() <#isratelimitingactive>`__
   returns true. However, rate limiting is reset during certain events,
   so even background apps can call ``ShortcutManager`` methods until
   the rate limit is reached again. These events include the following:

   -  An app comes to the foreground.
   -  The system locale changes.
   -  The user performs the `inline reply <#>`__ action on a
      notification.

   If you encounter rate limiting during development or testing, you can
   select **Developer Options > Reset ShortcutManager rate-limiting**
   from the `device's settings <#>`__, or you
   can enter the following command in ``adb``:

   .. code:: none

      $ adb shell cmd shortcut reset-throttling [ --user your-user-id ]

   .. rubric:: Backup and restore
      :name: backup-and

   You can let users perform backup and restore operations on your app
   when changing devices by including the
   `android:allowBackup="true <#allowbackup>`__"
   attribute assignment in your app's manifest file. If you support
   backup and restore, keep the following points about app shortcuts in
   mind:

   -  Static shortcuts are re-published automatically, but only after
      the user re-installs your app on a new device.
   -  Dynamic shortcuts aren't backed up, so include logic in your app
      to re-publish them when a user opens your app on a new device.
   -  Pinned shortcuts are restored to the device's launcher
      automatically, but the system doesn't back up icons associated
      with pinned shortcuts. Therefore, save your pinned shortcuts'
      images in your app so that it's easy to restore them on a new
      device.

   The following code snippet shows how best to restore your app's
   dynamic shortcuts and how to check whether your app's pinned
   shortcuts were preserved:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyMainActivity : Activity() {
                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       if (ShortcutManagerCompat.dynamicShortcuts.size == 0) {
                           // Application restored. Re-publish dynamic shortcuts.
                           if (ShortcutManagerCompat.pinnedShortcuts.size > 0) {
                               // Pinned shortcuts are restored. Use updateShortcuts() to make
                               // sure they contain up-to-date information.
                           }

                       }
                   }
                   // ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends Activity {
                   public void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);

                       if (ShortcutManagerCompat.getDynamicShortcuts().size() == 0) {
                           // Application restored. Re-publish dynamic shortcuts.
                           if (ShortcutManagerCompat.getPinnedShortcuts().size() > 0) {
                               // Pinned shortcuts are restored. Use pdateShortcuts() to make
                               // sure they contain up-to-date information.
                           }
                       }
                   }
                   // ...
               }

Last updated 2024-02-22 UTC.


/Best practices for shortcuts
=============================

.. container:: devsite-article-body clearfix

   When designing and creating your app's shortcuts, follow these
   guidelines:

   **Follow the design guidelines**
      To make your app's shortcuts visually consistent with the
      shortcuts used for system apps, follow the `App Shortcuts Icon Design Guidelines <#>`__.

   **Publish only four distinct shortcuts**
      Although the API supports a combination of up to 15 static and
      dynamic shortcuts for your app, we recommend that you publish only
      four distinct shortcuts, to improve their visual appearance in the
      launcher.

      In addition to displaying shortcuts on the launcher, use the
      `Google Shortcuts Integration Library <#gsi-library>`__
      to display shortcuts on Google surfaces such as Google Assistant.
      This library supports pushing an unlimited number of dynamic
      shortcuts. If you are using this library to push a large number of
      shortcuts, we recommend setting the ``rank`` of the shortcuts that
      must appear in supported launchers by calling the
      ` <#setRank>`__\ ``setRank()``
      method.

   **Limit shortcut description length**
      The space in the menu that shows your app's shortcuts in the
      launcher is limited. When possible, limit the length of the "short
      description" of a shortcut to 10 characters and limit the length
      of the "long description" to 25 characters.

      For more information about labels for static shortcuts, read
      `Customize attribute values <#attribute-values>`__.
      For dynamic and pinned shortcuts, read the reference documentation
      on
      `setLongLabel() <#setLongLabel>`__
      and
      `setShortLabel() <#setShortLabel>`__.

   **Maintain shortcut and action usage history**
      For each shortcut you create, consider the different ways a user
      can accomplish the same task directly within your app. Call
      `reportShortcutUsed() <#reportShortcutUsed>`__
      in each of these situations so that the launcher maintains an
      accurate history of how frequently a user performs the actions
      representing your shortcuts.

   **Update shortcuts only when their meaning is retained**
      When changing dynamic and pinned shortcuts, only call
      `updateShortcuts() <#updateShortcuts>`__
      when changing the information of a shortcut that retains its
      meaning. Otherwise, use one of the following methods, depending on
      the type of shortcut you're recreating:

      -  Dynamic shortcuts:
         `pushDynamicShortcut() <#pushDynamicShortcut>`__.
      -  Pinned shortcuts:
         `requestPinShortcut() <#requestPinShortcut>`__.

      For example, if you create a shortcut for navigating to a
      supermarket, it is appropriate to update the shortcut if the name
      of the supermarket changes but its location stays the same. If the
      user begins shopping at a different supermarket location, however,
      it's better to create a new shortcut.

   **Check dynamic shortcuts whenever you launch your app**
      Dynamic shortcuts aren't preserved when the user restores their
      data onto a new device. For this reason, we recommend that you
      check the number of objects returned by
      `getDynamicShortcuts() <#getDynamicShortcuts>`__
      each time you launch your app and re-publish dynamic shortcuts as
      needed, as shown in the code snippet in `Backup and restore <#backup-restore>`__.

Last updated 2024-02-22 UTC.


/Principles of navigation
=========================

.. container:: devsite-article-body clearfix

   Navigation between different screens and apps is a core part of the
   user experience. The following principles set a baseline for a
   consistent and intuitive user experience across apps. The `Navigation component <#>`__ is designed
   to implement these principles by default, ensuring that users can
   apply the same heuristics and patterns in navigation as they move
   between apps.

   **Note:**\  Even if you aren't using the Navigation component in your
   project, your app should follow these design principles.

   .. rubric:: Fixed start destination
      :name: fixed_start_destination

   Every app you build has a fixed start destination. This is the first
   screen the user sees when they launch your app from the launcher.
   This destination is also the last screen the user sees when they
   return to the launcher after pressing the Back button. Let‚Äôs take a
   look at the `Sunflower app <https://github.com/android/sunflower/tree/main/app>`__ as an
   example.

   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-principles-start-destination.png

   **Figure 1.** The List Screen is the Sunflower app's start
   destination.

   When launching the Sunflower app from the launcher, the first screen
   that a user sees is the **List Screen**, the list of plants in their
   garden. This is also the last screen they see before exiting the app.
   If they press the Back button from the list screen, they navigate
   back to the launcher.

   **Note:**\  An app might have a one-time setup or series of login
   screens. These `conditional screens <#>`__
   should not be considered start destinations because users see these
   screens only in certain cases.

   .. rubric:: Navigation state is represented as a stack of
      destinations
      :name: navigation_state_is_represented_as_a_stack_of_destinations

   When your app is first launched, a `new task <#>`__ is
   created for the user, and app displays its start destination. This
   becomes the base destination of what is known as the *back stack* and
   is the basis for your app‚Äôs navigation state. The top of the stack is
   the current screen, and the previous destinations in the stack
   represent the history of where you've been. The back stack always has
   the start destination of the app at the bottom of the stack.

   Operations that change the back stack always operate on the top of
   the stack, either by pushing a new destination onto the top of the
   stack or popping the top-most destination off the stack. Navigating
   to a destination pushes that destination on top of the stack.

   The `Navigation component <#>`__ manages all
   of your back stack ordering for you, though you can also choose to
   manage the back stack yourself.

   .. rubric:: Up and Back are identical within your app's task
      :name: up_and_back_are_identical_within_your_apps_task

   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-up-back.png

   **Figure 2.** The Up and Back buttons

   The Back button appears in the system navigation bar at the bottom of
   the screen and is used to navigate in reverse-chronological order
   through the history of screens the user has recently worked with.
   When you press the Back button, the current destination is popped off
   the top of the back stack, and you then navigate to the previous
   destination.

   The Up button appears in the `app bar <#>`__ at the
   top of the screen. Within your app's task, the Up and Back buttons
   behave identically.

   .. rubric:: The Up button never exits your app
      :name: the_up_button_never_exits_your_app

   If a user is at the app's start destination, then the Up button does
   not appear, because the Up button never exits the app. The Back
   button, however, is shown and does exit the app.

   When your app is launched using a `deep link <#>`__ on another app's task, Up
   transitions users back to your app‚Äôs task and through a `simulated back stack <#deep-link>`__ and not to the app that triggered the deep
   link. The Back button, however, does take you back to the other app.

   .. rubric:: Deep linking simulates manual navigation
      :name: deep-link

   Whether `deep linking <#>`__ or
   manually navigating to a specific destination, you can use the Up
   button to navigate through destinations back to the start
   destination.

   When deep linking to a destination within your app‚Äôs task, any
   existing back stack for your app‚Äôs task is removed and replaced with
   the deep-linked back stack.

   Using the Sunflower app again as an example, let‚Äôs assume that the
   user had previously launched the app from the launcher screen and
   navigated to the detail screen for an apple. Looking at the Recents
   screen would indicate that a task exists with the top most screen
   being the detail screen for the Apple.

   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-principles-deep-linking.png

   **Figure 3.** User navigation through the Sunflower app and the
   resulting back stack.

   At this point, the user can tap the Home button to put the app in the
   background. Next, let‚Äôs say this app has a deep link feature that
   allows users to launch directly into a specific plant detail screen
   by name. Opening the app via this deep link completely replaces the
   current Sunflower back stack shown in figure 3 with a new back stack,
   as shown in figure 4:

   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-principles-deep-linking-2.png

   **Figure 4.** Following a deep link replaces the existing back stack
   for the Sunflower app.

   Notice that the Sunflower back stack is replaced by a *synthetic back
   stack* with the avocado detail screen at the top. The *My Garden*
   screen, which is the start destination, was also added to the back
   stack. The original Sunflower back stack is gone, including the app's
   knowledge that the user was on the Apple details screen before. All
   of this is important because the synthetic back stack must be
   realistic. It should match a back stack that could have been achieved
   by organically navigating through the app.

   To meet this need, the synthetic back stack that is created is a
   simplified one based on the ``NavGraph``. For a simple ``NavGraph``
   without nesting, this will consist of the start destination and the
   deep link destination. For more complex, `nested navigation graphs <#>`__, the synthetic
   back stack will also contain the start destinations of any nested
   graphs that are ancestors of the deep link destination.

   The Navigation component `supports deep linking <#>`__
   and recreates a realistic back stack for you when linking to any
   destination in your navigation graph.

Last updated 2024-01-03 UTC.


/Overview: Navigation
=====================

.. https://developer.android.google.cn/guide/navigation

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   Navigation refers to the interactions that let users navigate across,
   into, and back out from the different pieces of content within your
   app.

   Android Jetpack's Navigation component includes the `Navigation library <#>`__, `Safe Args Gradle plug-in <#Safe-args>`__, and
   tooling to help you implement app navigation. The Navigation
   component handles diverse navigation use cases, from straightforward
   button clicks to more complex patterns, such as app bars and the
   navigation drawer.

   **Important:**\  The Navigation component also ensures a consistent
   and predictable user experience by adhering to an established `set of principles <#>`__.

   .. rubric:: Key concepts
      :name: types

   The following table provides an overview of the three key concepts in
   navigation and the main types that you use to implement them.

   .. list-table::
      :widths: 24 24 24
      :header-rows: 1

      - 

         - Concept
         - Purpose
         - Type
      - 

         - Host
         - A UI element that contains the current navigation
            destination. That is, when a user navigates through an app,
            the app essentially swaps destinations in and out of the
            navigation host.
         - 

            -  **Compose**:
               `NavHost <#NavHost>`__
            -  **Fragments**:
               `NavHostFragment <#>`__
      - 

         - Graph
         - A data structure that defines all the navigation destinations
            within the app and how they connect together.
         - `NavGraph <#>`__
      - 

         - Controller
         - The central coordinator for managing navigation between
            destinations. The controller offers methods for navigating
            between destinations, handling deep links, managing the back
            stack, and more.
         - `NavController <#>`__

   **Important:**\  Whether you are using Compose, views, or a custom UI
   framework, these three concepts always apply when implementing
   navigation. However, the specific ways in which you use them can
   differ.

   .. rubric:: Benefits and features
      :name: benefits

   The Navigation component provides a number of other benefits and
   features, including the following:

   -  **Animations and transitions:** Provides standardized resources
      for animations and transitions.
   -  **Deep linking:** Implements and handles deep links that take the
      user directly to a destination.
   -  **UI patterns:** Supports patterns such as navigation drawers and
      bottom navigation with minimal additional work.
   -  **Type safety:** Includes the `Safe Args Gradle plugin <#Safe-args>`__ which
      provides type safety when navigating and passing data between
      destinations.
   -  **ViewModel support:** Enables scoping a ``ViewModel`` to a
      navigation graph to share UI-related data between the graph's
      destinations.
   -  **Fragment transactions:** Fully supports and handles fragment
      transactions.
   -  **Back and up:** Handles back and up actions correctly by default.

   **Note:**\  If you are using XML for your navigation graphs, use
   Android Studio's `Navigation Editor <#>`__ to view and edit your
   graphs.
   **Note:**\  Android 13 introduces predictive back navigation, which
   works with the Navigation component for Android devices. Implement
   predictive back navigation in your app as soon as possible.
   Otherwise, users might experience unexpected behavior in a future
   Android release.

   .. rubric:: Set up your environment
      :name: set-up

   To include navigation support in your project, add the following
   dependencies to your app's ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                 def nav_version = "2.7.7"

                 // Java language implementation
                 implementation "androidx.navigation:navigation-fragment:$nav_version"
                 implementation "androidx.navigation:navigation-ui:$nav_version"

                 // Kotlin
                 implementation "androidx.navigation:navigation-fragment-ktx:$nav_version"
                 implementation "androidx.navigation:navigation-ui-ktx:$nav_version"

                 // Feature module Support
                 implementation "androidx.navigation:navigation-dynamic-features-fragment:$nav_version"

                 // Testing Navigation
                 androidTestImplementation "androidx.navigation:navigation-testing:$nav_version"

                 // Jetpack Compose Integration
                 implementation "androidx.navigation:navigation-compose:$nav_version"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                 val nav_version = "2.7.7"

                 // Java language implementation
                 implementation("androidx.navigation:navigation-fragment:$nav_version")
                 implementation("androidx.navigation:navigation-ui:$nav_version")

                 // Kotlin
                 implementation("androidx.navigation:navigation-fragment-ktx:$nav_version")
                 implementation("androidx.navigation:navigation-ui-ktx:$nav_version")

                 // Feature module Support
                 implementation("androidx.navigation:navigation-dynamic-features-fragment:$nav_version")

                 // Testing Navigation
                 androidTestImplementation("androidx.navigation:navigation-testing:$nav_version")

                 // Jetpack Compose Integration
                 implementation("androidx.navigation:navigation-compose:$nav_version")
               }

   For information on adding other architecture components to your
   project, see `Add components to your project <#navigation>`__.

   .. rubric:: Next steps
      :name: next-steps

   For more documentation and resources related to the Navigation
   component, see the following resources.

   .. rubric:: Detailed guides
      :name: detail

   For more information on how to implement a navigation host and
   ``NavController``, as well as detail on how they interact with
   Compose and other UI frameworks, see the following guides:

   -  `Create a navigation controller <#>`__: Outlines how to
      create a ``NavController``.
   -  `Create your navigation graph <#>`__:
      Details how to create a navigation host and a navigation graph.
   -  `Navigate to a destination <#>`__:
      Demonstrates how to use a ``NavController`` to move between the
      destinations in your graph.

   .. rubric:: Codelabs
      :name: addt-resources-codelabs

   -  `Learn Jetpack Navigation <#>`__
   -  `Fragments and the Navigation Component <#>`__
   -  `Build an adaptive app with dynamic navigation <#0>`__

   .. rubric:: Videos
      :name: addt-resources-videos

   -  `Navigating navigation <https://www.youtube.com/watch?v=09qjn706ITA>`__
   -  `10 best practices for moving to a single activity <https://www.youtube.com/watch?v=9O1D_Ytk0xg>`__
   -  `Single activity: Why, when, and how (Android Dev Summit '18) <https://www.youtube.com/watch?v=2k8x8V77CrU>`__
   -  `Android Jetpack: Manage UI navigation with navigation controller (Google I/O '18) <https://www.youtube.com/watch?v=8GCXtCjtg40>`__

   .. rubric:: Samples
      :name: addt-resources-samples

Last updated 2024-05-01 UTC.


/Create a navigation controller
===============================

.. container:: devsite-article-body clearfix

   The navigation controller is one of the `key concepts <#types>`__ in navigation. It holds the
   navigation graph and exposes methods that allow your app to move
   between the destinations in the graph.

   When using the `Navigation component <#>`__, you
   create a navigation controller using the
   `NavController <#>`__
   class.
   `NavController <#>`__
   is the central navigation API. It tracks which destinations the user
   has visited, and allows the user to move between destinations. This
   guide demonstrates how to create a ``NavController`` in your app.

   For information on how to add a navigation graph to your
   ``NavController``, see `Design your navigation graph <#>`__. ``NavController`` provides a few
   different ways to navigate to the destinations in its graph. For
   more, see `Navigate to a destination <#>`__.

   **Note:**\  Each ``NavHost`` you create has its own corresponding
   ``NavController``. The ``NavController`` provides access to the
   ``NavHost``'s graph.

   .. rubric:: Compose
      :name: compose

   To create a ``NavController`` when using Jetpack Compose, call
   `rememberNavController() <#rememberNavController>`__:

   .. code:: prettyprint

      val navController = rememberNavController()

   You should create the ``NavController`` high in your composable
   hierarchy. It needs to be high enough that all the composables that
   need to reference it can do so.

   Doing so lets you to use the ``NavController`` as the single source
   of truth for updating composables outside of your screens. This
   follows the principles of `state hoisting <#state-hoisting>`__.

   .. rubric:: Views
      :name: views

   If you are using the Views UI framework, you can retrieve your
   NavController using one of the following methods depending on the
   context:

   **Kotlin:**

   -  `Fragment.findNavController() <#(androidx.fragment.app.Fragment).findNavController>`__
   -  `View.findNavController() <#%28android.view.View%29.findNavController%28%29>`__
   -  `Activity.findNavController(viewId: Int) <#(android.app.Activity).findNavController>`__

   **Java:**

   -  `NavHostFragment.findNavController(Fragment) <#findNavController>`__
   -  `Navigation.findNavController(Activity, @IdRes int viewId) <#findNavController>`__
   -  `Navigation.findNavController(View) <#findNavController>`__

   Typically, you first get a ``NavHostFragment``, and then retrieve the
   ``NavController`` from the fragment. The following snippet
   demonstrates this:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            val navHostFragment =
                supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment
            val navController = navHostFragment.navController

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            NavHostFragment navHostFragment =
                (NavHostFragment) getSupportFragmentManager().findFragmentById(R.id.nav_host_fragment);
            NavController navController = navHostFragment.getNavController();

   **Warning:**\  You can encounter problems when creating the
   ``NavHostFragment`` using ``FragmentContainerView`` or when manually
   adding the ``NavHostFragment`` to your activity using a
   ``FragmentTransaction``. If you do so, you can cause
   ``Navigation.findNavController(Activity, @IdRes int)`` to fail if you
   attempt to retrieve the ``NavController`` in ``onCreate()``. You
   should retrieve the ``NavController`` directly from the
   ``NavHostFragment`` instead, as in the preceding example.

   .. rubric:: Further reading
      :name: further_reading

   -  `Design your navigation graph <#>`__\ **:**
      A guide detailing how to add a graph to your ``NavController``
      that contains all the destinations in your app.
   -  `Navigate to a destination <#>`__\ **:** A
      guide detailing how to use the ``NavController`` to move between
      destinations in your navigation graph.

Last updated 2024-02-28 UTC.


/Overview: Design your navigation graph
=======================================

.. https://developer.android.google.cn/guide/navigation/design

.. container:: devsite-article-body clearfix

   The `Navigation component <#>`__ uses a *navigation
   graph* to manage your app's navigation. The navigation graph is a
   data structure that contains each destination within your app and the
   connections between them.

   **Note:**\  The navigation graph is distinct from the `back stack <#>`__, which is a stack within the
   ``NavController`` that holds destinations the user has recently
   visited.

   .. rubric:: Destination types
      :name: destination_types

   There are three general types of destinations: hosted, dialog, and
   activity. The following table outlines these three destination types
   and their purposes.

   .. list-table::
      :widths: 24 24 24
      :header-rows: 1

      - 

         - Type
         - Description
         - Use cases
      - 

         - Hosted
         - Fills the entire navigation host. That is, the size of a
            hosted destination is the same as the size of the navigation
            host and previous destinations are not visible.
         - Main and detail screens.
      - 

         - Dialog
         - Presents overlay UI components. This UI is not tied to the
            location of the navigation host or its size. Previous
            destinations are visible underneath the destination.
         - Alerts, selections, forms.
      - 

         - Activity
         - Represents unique screens or features within the app.
         - Serve as an exit point to the navigation graph that starts a
            new Android activity that is managed separately from the
            Navigation component.

            In modern Android development, an app consists of a single
            activity. Activity destinations are therefore best used when
            interacting with third party activities or as part of `the migration process <#>`__.

   This document contains examples of hosted destinations, which are the
   most common and fundamental destinations. See the following guides
   for information on the other destinations:

   -  `Dialog destinations <#>`__
   -  `Activity destinations <#>`__

   .. rubric:: Frameworks
      :name: frameworks

   Although the same general workflow applies in every case, how exactly
   you create a navigation host and graph depends on the UI framework
   you use.

   -  **Compose:** Use the ``NavHost`` composable. Create a ``NavGraph``
      to it using the `Kotlin DSL <#>`__. You can create
      the graph in two ways:

      -  **As part of the NavHost:** Construct the navigation graph
         directly as part of adding the ``NavHost``.
      -  **Programmatically:** Use the
         `NavController.createGraph() <#(androidx.navigation.NavController).createGraph>`__
         method to create a ``NavGraph`` and pass it to the ``NavHost``
         directly.

   -  **Fragments:** When using fragments with the views UI framework,
      use a a ``NavHostFragment`` as the host. There are several ways to
      create a navigation graph:

      -  **Programmatically:** Use the Kotlin DSL to create a
         ``NavGraph`` and directly apply it on the ``NavHostFragment``.

         -  The ``createGraph()`` function used with the Kotlin DSL for
            both fragments and Compose is the same.

      -  **XML:** Write your navigation host and graph directly in XML.
      -  **Android Studio editor:** Use the GUI editor in Android Studio
         to create and adjust your graph as an XML resource file.

   **Note:**\  How you interact with the graph through the
   ``NavController`` is similar between frameworks. See the `Navigate to a destination <#>`__ guide for
   more details.

   .. rubric:: Compose
      :name: compose

   In Compose, use the ``NavHost`` composable to create your navigation
   graph. Consider the following example:

   .. code:: prettyprint

      val navController = rememberNavController()

      NavHost(navController = navController, startDestination = "profile") {
          composable("profile") { Profile( /* ... */ ) }
          composable("friendslist") { FriendsList( /* ... */ ) }
          // Add more destinations similarly.
      }

   #. The call to the ``NavHost`` composable passes a ``NavController``
      and a ``route`` string that corresponds to the start destination.
   #. The lambda passed to the ``NavHost`` ultimately calls
      `NavController.creatGraph() <#(androidx.navigation.NavController).createGraph>`__
      and returns a ``NavGraph``.
   #. The calls to ``NavGraphBuilder.composable()`` add destinations to
      the resulting ``NavGraph``.
   #. In this case, the destinations are the ``Profile`` and
      ``FriendsList`` composables. The route strings ``"profile"`` and
      ``"friendslist"`` become the keys that identify the two
      destinations.

   To better understand the lambda that creates the ``NavGraph``,
   consider that to build the same graph as in the preceding snippet,
   you could create the ``NavGraph`` separately using
   `NavController.createGraph() <#(androidx.navigation.NavController).createGraph>`__
   and pass it to the ``NavHost`` directly:

   .. code:: prettyprint

      val navGraph by remember(navController) {
        navController.createGraph(startDestination = "profile") {
          composable("profile") { Profile() }
          composable("friendslist") { FriendsList() }
        }
      }
      NavHost(navController, navGraph)

   **Key Term:**\  A **route** is a string that defines the path to your
   composable. You can think of it as a key that corresponds to a
   specific destination. Each destination has a unique route.
   **Important:**\  A
   `NavController <#>`__
   is associated with a single ``NavHost`` composable. The ``NavHost``
   provides the ``NavController`` access to its navigation graph. When
   you use the ``NavController`` to navigate to a destination, you cause
   the ``NavController`` to interact with its associated ``NavHost``.

   .. rubric:: Minimal example
      :name: minimal

   A minimal but complete example of a ``NavController`` and ``NavHost``
   working together:

   .. code:: prettyprint

      // Define the Profile composable.
      @Composable
      fun Profile(onNavigateToFriendsList: () -> Unit) {
        Text("Profile")
        Button(onClick = { onNavigateToFriendsList() }) {
          Text("Go to Friends List")
        }
      }

      // Define the FriendsList composable.
      @Composable
      fun FriendsList(onNavigateToProfile: () -> Unit) {
        Text("Friends List")
        Button(onClick = { onNavigateToProfile() }) {
          Text("Go to Profile")
        }
      }

      // Define the MyApp composable, including the `NavController` and `NavHost`.
      @Composable
      fun MyApp() {
        val navController = rememberNavController()
        NavHost(navController, startDestination = "profile") {
          composable("profile") { Profile(onNavigateToFriendsList = { navController.navigate("friendslist") }) }
          composable("friendslist") { FriendsList(onNavigateToProfile = { navController.navigate("profile") }) }
        }
      }

   As the snippet demonstrates, instead of passing the ``NavController``
   to your composables, expose an event to the ``NavHost``. That is,
   your composables should have a parameter of type ``() -> Unit`` for
   which the ``NavHost`` passes a lambda that calls
   ``NavController.navigate()``.

   **Note:**\  If you would like the lambda to take additional data, you
   could using a parameter type like ``(String) -> Unit``. You can also
   use multiple parameters in the composable.

   .. rubric:: Fragments
      :name: fragments

   As outlined in the preceding sections, when using fragments you have
   the option to create a navigation graph programmatically using the
   Kotlin DSL, XML, or the Android Studio editor.

   The following sections detail these different approaches.

   **Note:**\  The Navigation component is designed for apps that have
   one main activity with multiple fragment destinations. The main
   activity is associated with a navigation graph and contains a
   ``NavHostFragment`` that is responsible for swapping destinations as
   needed. In an app with multiple activity destinations, each activity
   has its own navigation graph.

   .. rubric:: Programmatically
      :name: programmatically

   The Kotlin DSL provides a programmatic way of creating a navigation
   graph with fragments. In many ways this is neater and more modern
   than using an XML resource file.

   Consider the following example, which implements a two-screen
   navigation graph.

   First it is necessary to create the ``NavHostFragment``, which must
   *not* include an ``app:navGraph`` element:

   .. code:: prettyprint

      <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

          <androidx.fragment.app.FragmentContainerView
              android:id="@+id/nav_host_fragment"
              android:name="androidx.navigation.fragment.NavHostFragment"
              android:layout_width="match_parent"
              android:layout_height="match_parent" />
      </FrameLayout>

   Next, pass the ``id`` of the ``NavHostFragment`` to
   `NavController.findNavController() <#findNavController>`__.
   This associates the NavController with the ``NavHostFragment``.

   Subsequently, the call to
   `NavController.createGraph() <#(androidx.navigation.NavController).createGraph>`__
   links the graph to the ``NavController`` and consequently also to the
   ``NavHostFragment``:

   .. code:: prettyprint

      // Retrieve the NavController.
      val navController = findNavController(R.id.nav_host_fragment)

      // Add the graph to the NavController with `createGraph()`.
      navController.graph = navController.createGraph(
          startDestination = "profile"
      ) {
          // Associate each destination with one of the route constants.
          fragment<ProfileFragment>("profile") {
              label = "Profile"
          }

          fragment<FriendsListFragment>("friendsList") {
              label = "Friends List"
          }

          // Add other fragment destinations similarly.
      }

   Using the DSL in this way is very similar to the workflow outlined in
   the preceding section on `Compose <#compose>`__. For example, both
   there and here, the ``NavController.createGraph()`` function
   generates the ``NavGraph``. Likewise, while
   ``NavGraphBuilder.composable()`` adds composable destinations to the
   graph, here
   `NavGraphBuilder.fragment() <#(androidx.navigation.NavGraphBuilder).fragment>`__
   adds a fragment destination.

   For more information on how to use the Kotlin DSL, see `Build a graph with the NavGraphBuilder DSL <#>`__.

   .. rubric:: XML
      :name: xml

   You can directly write the XML yourself. The following example
   mirrors and is equivalent to the two-screen example from the
   preceding section.

   First, create a ``NavHostFragment``. This serves as the navigation
   host which contains the actual navigation graph.

   A minimal implementation of a ``NavHostFragment``:

   .. code:: prettyprint

      <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

          <androidx.fragment.app.FragmentContainerView
              android:id="@+id/nav_host_fragment"
              android:name="androidx.navigation.fragment.NavHostFragment"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              app:navGraph="@navigation/nav_graph" />

      </FrameLayout>

   The ``NavHostFragment`` contains the attribute ``app:navGraph``. Use
   this attribute to connect you navigation graph to the navigation
   host. The following is an example of how you might implement the
   graph:

   .. code:: prettyprint

      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:id="@+id/nav_graph"
          app:startDestination="@id/profile">

          <fragment
              android:id="@+id/profile"
              android:name="com.example.ProfileFragment"
              android:label="Profile">

              <!-- Action to navigate from Profile to Friends List. -->
              <action
                  android:id="@+id/action_profile_to_friendslist"
                  app:destination="@id/friendslist" />
          </fragment>

          <fragment
              android:id="@+id/friendslist"
              android:name="com.example.FriendsListFragment"
              android:label="Friends List" />

          <!-- Add other fragment destinations similarly. -->
      </navigation>

   You use actions to define the connections between different
   destinations. In this example, the ``profile`` fragment contains an
   action that navigates to ``friendslist``. For more information, see
   `Use Navigation actions and fragments <#>`__.

   **Note:**\  The DSL example does not define actions because they
   don't apply in that context. When using the DSL, `use ``NavController.navigate()``
   directly </guide/navigation/design/kotlin-dsl#host>`__.

   .. rubric:: Editor
      :name: editor

   You can manage your app's navigation graph using the Navigation
   Editor in Android Studio. This is essentially a GUI you can use to
   create and edit your ``NavigationFragment`` XML, as seen in the
   preceding section.

   For more information, see `Navigation editor <#>`__.

   .. rubric:: Nested graphs
      :name: nested_graphs

   You can also use nested graphs. This involves using a graph as a
   navigation destination. For more information, see `Nested graphs <#>`__.

   .. rubric:: Further Reading
      :name: further_reading

   For more core navigation concepts, see the following guides:

   -  `Overview <#>`__\ **:** Make sure to read the
      general overview of the Navigation component.
   -  `Activity destinations <#>`__\ **:**
      Examples of how to implement destinations that take the user to
      activities.
   -  `Dialog destinations <#>`__\ **:**
      Examples of how to create destinations that take the user to a
      dialog.
   -  `Navigate to a destination <#>`__\ **:** A
      detailed guide that covers how to navigate from one destination to
      another.
   -  `Nested graphs <#>`__\ **:**
      An in-depth guide on how to nest one navigation graph within
      another.

Last updated 2024-01-03 UTC.


/Dialog destinations
====================

.. container:: devsite-article-body clearfix

   In Android navigation, the term *dialog destination* refers to
   destinations within the app's navigation graph which take the form of
   dialog windows, overlaying app UI elements and content.

   Because dialog destinations appear over `hosted destinations <#>`__ that fill the navigation
   host, there are some important considerations regarding how dialog
   destinations interact with your `NavController``'s back
   stack </guide/navigation/backstack/dialog>`__.

   **Note:**\  Dialog destinations implement the
   `FloatingWindow <#>`__
   interface. Your app treats any destination that implements this
   interface as a dialog destination.

   .. rubric:: Dialog composable
      :name: dialog_composable

   To create a dialog destination in Compose, add a destination to your
   ``NavHost`` using the
   `dialog() <#(androidx.navigation.NavGraphBuilder).dialog>`__
   function. The function behaves essentially the same as
   `composable() <#(androidx.navigation.NavGraphBuilder).composable>`__,
   only it creates a dialog destination rather than a `hosted destination <#>`__.

   Consider the following example:

   .. code:: prettyprint

      @Composable
      fun SettingsDialog(){
          Text("Settings")
          // ...
      }

      @Composable
      fun MyApp() {
          val navController = rememberNavController()
          NavHost(navController, startDestination = "home") {
              composable("home") { Home(onNavigateToHome = { navController.navigate("home") }) }
              dialog("settings") { SettingsDialog(onNavigateToSettingsDialog = { navController.navigate("settings") }) }
          }
      }

   #. The start destination is the ``Home`` composable. Because it uses
      ``composable()``, it is a hosted destination.
   #. The other destination is the ``SettingsDialog`` composable.
      Because the ``dialog()`` function adds it to the graph, it is a
      dialog destination. When the user navigates from ``Home`` to
      ``SettingsDialog``, the latter appears over ``Home``.
   #. Although ``SettingsDialog`` doesn't include a ``Dialog``
      composable itself, because it is a dialog destination, the
      ``NavHost`` displays it within a ``Dialog``.

   Dialog destinations appear over the previous destination in the
   ``NavHost``. Use them when the dialog represents a separate screen in
   your app that needs its own lifecycle and saved state, independent of
   any other destination in your navigation graph. You might prefer to
   use an `AlertDialog <#>`__ or
   related composable if you want a dialog for a less complex prompt,
   such as a confirmation.

   **Note:**\  Because bottom sheets in Compose are not built on
   ``Dialog``, they need their own destination type. See the
   `Accompanist Navigation Material documentation <https://google.github.io/accompanist/navigation-material/>`__
   for an example implementation.

   .. rubric:: Kotlin DSL
      :name: kotlin_dsl

   If you are working with fragments and you are using the `Kotlin DSL <#>`__ to create your graph,
   adding a dialog destination is very similar to when using Compose.

   Consider how in the following snippet also uses the
   `dialog() <#(androidx.navigation.NavGraphBuilder).dialog>`__
   function to add a dialog destination that uses a fragment:

   .. code:: prettyprint

      // Add the graph to the NavController with `createGraph()`.
      navController.graph = navController.createGraph(
          startDestination = "home"
      ) {
          // Associate the "home" destination with the HomeFragment.
          fragment<HomeFragment>("home") {
              label = "Home"
          }

          // Define the "settings" destination as a dialog using DialogFragment.
          dialog<SettingsDialogFragment>("settings") {
              label = "Settings Dialog"
          }
      }

   .. rubric:: XML
      :name: create-dialog

   If you have an existing
   `DialogFragment <#>`__,
   use the ``<dialog>`` element to add the dialog to your navigation
   graph, as shown in the following example:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
                  xmlns:app="http://schemas.android.com/apk/res-auto"
                  android:id="@+id/nav_graph">

      ...

      <dialog
          android:id="@+id/my_dialog_fragment"
          android:name="androidx.navigation.myapp.MyDialogFragment">
          <argument android:name="myarg" android:defaultValue="@null" />
              <action
                  android:id="@+id/myaction"
                  app:destination="@+id/another_destination"/>
      </dialog>

      ...

      </navigation>

Last updated 2024-01-03 UTC.


/Activity destinations
======================

.. container:: devsite-article-body clearfix

   In your navigation graph, a destination can be an activity. While it
   is best practice to have a single activity in your app, apps often
   use separate activities for distinct components or screen within an
   app. Activity destinations can be useful in such cases.

   .. rubric:: Compose and Kotlin DSL
      :name: compose_and_kotlin_dsl

   Adding an activity destination to you navigation graph is essentially
   the same in both Compose and when using the Kotlin DSL with
   fragments. This is because when passing your ``NavGraph`` to your
   ``NavHost`` composable, you use the same ``createGraph()`` lambda.

   For more information, see `Build a graph programmatically using the Kotlin DSL <#activity>`__.

   .. rubric:: XML
      :name: xml-activity

   Creating an `activity <#>`__
   destination is similar to creating a
   `fragment <#>`__ destination.
   However, the nature of an activity destination is quite different.

   By default, the `Navigation library <#>`__ attaches
   the
   `NavController <#>`__
   to an ``Activity`` layout, and the active navigation graph is scoped
   to the active ``Activity``. If a user navigates to a different
   ``Activity``, the current navigation graph is no longer in scope.
   This means that an ``Activity`` destination should be considered an
   endpoint within a navigation graph.

   To add an activity destination, specify the destination ``Activity``
   with its fully qualified class name:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:id="@+id/navigation_graph"
          app:startDestination="@id/simpleFragment">

          <activity
              android:id="@+id/sampleActivityDestination"
              android:name="com.example.android.navigation.activity.DestinationActivity"
              android:label="@string/sampleActivityTitle" />
      </navigation>

   This XML is equivalent to the following call to
   `startActivity() <#startActivity>`__:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            startActivity(Intent(context, DestinationActivity::class.java))

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            startActivity(new Intent(context, DestinationActivity.class));

   You might have cases where this approach is not appropriate. For
   example, you might not have a compile-time dependency on the activity
   class, or you might prefer the level of indirection of going through
   an implicit intent. The
   `intent-filter <#>`__
   in the manifest entry for the destination ``Activity`` dictates how
   you need to structure the ``Activity`` destination.

   For example, consider the following manifest file:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.example.android.navigation.activity">
          <application>
              <activity android:name=".DestinationActivity">
                  <intent-filter>
                      <action android:name="android.intent.action.VIEW" />
                      <data
                          android:host="example.com"
                          android:scheme="https" />
                      <category android:name="android.intent.category.BROWSABLE" />
                      <category android:name="android.intent.category.DEFAULT" />
                  </intent-filter>
              </activity>
          </application>
      </manifest>

   The corresponding ``Activity`` destination needs to be configured
   with
   `action <#setAction>`__
   and
   `data <#setData>`__
   attributes matching those in the manifest entry:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:id="@+id/navigation_graph"
          app:startDestination="@id/simpleFragment">
          <activity
              android:id="@+id/localDestinationActivity"
              android:label="@string/localActivityTitle"
              app:action="android.intent.action.VIEW"
              app:data="https://example.com"
              app:targetPackage="${applicationId}" />
      </navigation>

   Specifying
   `targetPackage <#setTargetPackage>`__
   to the current
   `applicationId <#set_the_application_id>`__
   limits the scope to the current application, which includes the main
   app.

   The same mechanism can be used for cases where you want a specific
   app to be the destination. The following example defines a
   destination to be an app with an ``applicationId`` of
   ``com.example.android.another.app``.

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:id="@+id/navigation_graph"
          app:startDestination="@id/simpleFragment">
          <activity
              android:id="@+id/localDestinationActivity"
              android:label="@string/localActivityTitle"
              app:action="android.intent.action.VIEW"
              app:data="https://example.com"
              app:targetPackage="com.example.android.another.app" />
      </navigation>

   **Caution:**\  An ``ActivityNotFoundException`` is thrown if you
   attempt to navigate to this destination and either the specified app
   is not installed on the device or the destination app does not have
   an ``Activity`` defined in its manifest with a matching
   ``intent-filter``.

   .. rubric:: Dynamic arguments
      :name: dynamic-arguments

   The previous examples used fixed URLs to navigate to destinations.
   You might also need to support dynamic URLs where additional info is
   sent as part of the URL. For example, you might send a user ID in a
   URL with a format similar to
   ``https://example.com?userId=<actual user ID>``.

   In this case, instead of the
   `data <#>`__
   attribute, use
   `dataPattern <#>`__.
   You can then supply arguments to be substituted for named
   placeholders within the ``dataPattern`` value:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:id="@+id/navigation_graph"
          app:startDestination="@id/simpleFragment">
          <activity
              android:id="@+id/localDestinationActivity"
              android:label="@string/localActivityTitle"
              app:action="android.intent.action.VIEW"
              app:dataPattern="https://example.com?userId={userId}"
              app:targetPackage="com.example.android.another.app">
              <argument
                  android:name="userId"
                  app:argType="string" />
          </activity>
      </navigation>

   In this example, you can specify a ``userId`` value using either
   `Safe Args <#Safe-args>`__ or
   with a ``Bundle``:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin_1

         .. code:: prettyprint

            navController.navigate(
                R.id.localDestinationActivity,
                bundleOf("userId" to "someUser")
            )

      .. container:: section

         .. rubric:: Java
            :name: java_1

         .. code:: prettyprint

            Bundle args = new Bundle();
            args.putString("userId", "someUser");
            navController.navigate(R.id.localDestinationActivity, args);

   This example substitutes ``someUser`` for ``{userId}`` and creates a
   URI value of ``https://example.com?userId=someUser``.

   **Caution:**\  An exception is thrown if any required arguments are
   missing from the navigation request.

Last updated 2024-01-03 UTC.



/Nested graphs
==============

.. container:: devsite-article-body clearfix

   Login flows, wizards, or other subflows within your app are usually
   best represented as `nested navigation graphs <#>`__. By nesting
   self-contained subnavigation flows in this way, the main flow of your
   app's UI is easier to comprehend and manage.

   In addition, nested graphs are reusable. They also provide a level of
   encapsulation‚Äîdestinations outside of the nested graph don't have
   direct access to any of the destinations within the nested graph.
   Instead, they should
   `navigate() <#navigate>`__
   to the nested graph itself, where the internal logic can change
   without affecting the rest of the graph.

   .. rubric:: Example
      :name: example

   Your app's *top-level* navigation graph should start with the initial
   destination the user sees when launching the app and should include
   the destinations that they see as they move about your app.

   .. figure::
      https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-design-graph-top-level.png

      **Figure 1.** A top-level navigation graph.

   Using the top-level navigation graph from figure 1 as an example,
   suppose you wanted to require the user to see the **title_screen**
   and **register** screens only when the app is launched for the first
   time. Afterwards, the user information is stored, and in subsequent
   launches of the app, you should take them straight to the **match**
   screen.

   As a best practice, set the **match** screen as the *start
   destination* of the top-level navigation graph and move the title and
   register screens into a nested graph, as shown in figure 1:

   .. figure::
      https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-design-graph-nested.png

      **Figure 2.** The top-level navigation graph now contains a nested
      graph.

   When the match screen launches, check to see if there is a registered
   user. If the user isn't registered, navigate the user to the
   registration screen.

   For more information on conditional navigation scenarios, see
   `Conditional navigation <#>`__.

   .. rubric:: Compose
      :name: compose

   To create a nested navigation graph using Compose, use the
   `NavGraphBuilder.navigation() <#(androidx.navigation.NavGraphBuilder).navigation>`__
   function. You use ``navigation()`` just like
   `NavGraphBuilder.composable() <#(androidx.navigation.NavGraphBuilder).composable>`__
   and
   `NavGraphBuilder.dialog() <#(androidx.navigation.NavGraphBuilder).dialog>`__
   functions when adding destinations to a graph.

   The primary difference is that ``navigation`` creates a nested graph
   rather than a new destination. You then call ``composable`` and
   ``dialog`` within ``navigation``'s lambda to add destinations to the
   nested graph.

   Consider how the following snippet implements the graph in figure 2
   using Compose:

   .. code:: prettyprint

      NavHost(navController, startDestination = "title_screen") {
          composable("title_screen") {
              TitleScreen(
                  onPlayClicked = { navController.navigate("register") },
                  onLeaderboardsClicked = { /* Navigate to leaderboards */ }
              )
          }
          composable("register") {
              RegisterScreen(
                  onSignUpComplete = { navController.navigate("gameInProgress") }
              )
          }
          navigation(startDestination = "match", route = "gameInProgress") {
              composable("match") {
                  MatchScreen(
                      onStartGame = { navController.navigate("in_game") }
                  )
              }
              composable("in_game") {
                  InGameScreen(
                      onGameWin = { navController.navigate("results_winner") },
                      onGameLose = { navController.navigate("game_over") }
                  )
              }
              composable("results_winner") {
                  ResultsWinnerScreen(
                      onNextMatchClicked = {
                          navController.navigate("match") {
                              popUpTo("match") { inclusive = true }
                          }
                      },
                      onLeaderboardsClicked = { /* Navigate to leaderboards */ }
                  )
              }
              composable("game_over") {
                  GameOverScreen(
                      onTryAgainClicked = {
                          navController.navigate("match") {
                              popUpTo("match") { inclusive = true }
                          }
                      }
                  )
              }
          }
      }

   To `navigate <#>`__ directly to a
   nested destination, use the ``route`` as you would to any other
   destination. This is because routes are a global concept that any
   screen can navigate to:

   .. code:: prettyprint

      navController.navigate("match")

   **Note:**\  You can scope which routes are available by controlling
   the method visibility of the type-safe APIs. For more information,
   see `Type safety in Kotlin DSL and Navigation Compose <#type-safety>`__.

   .. rubric:: Extension functions
      :name: extension_functions

   You can add destinations to a graph using an extension function on
   `NavGraphBuilder <https://github.com/android/architecture-components-samples/tree/main/NavigationBasicSample>`__.
   You can use these extension functions alongside the prebuilt
   ``navigation``, ``composable``, and ``dialog`` extension methods.

   For example, you can use an extension function to add the nested
   graph demonstrated in the preceding section:

   .. code:: prettyprint

      fun NavGraphBuilder.addNestedGraph(navController: NavController) {
          navigation(startDestination = "match", route = "gameInProgress") {
              composable("match") {
                  MatchScreen(
                      onStartGame = { navController.navigate("in_game") }
                  )
              }
              composable("in_game") {
                  InGameScreen(
                      onGameWin = { navController.navigate("results_winner") },
                      onGameLose = { navController.navigate("game_over") }
                  )
              }
              composable("results_winner") {
                  ResultsWinnerScreen(
                      onNextMatchClicked = { navController.navigate("match") },
                      onLeaderboardsClicked = { /* Navigate to leaderboards */ }
                  )
              }
              composable("game_over") {
                  GameOverScreen(
                      onTryAgainClicked = { navController.navigate("match") }
                  )
              }
          }
      }

   You could then call this function in the lambda you pass to
   ``NavHost`` instead of calling navigation inline. The following
   example demonstrates this:

   .. code:: prettyprint

      @Composable
      fun MyApp() {
          val navController = rememberNavController()
          NavHost(navController, startDestination = "title_screen") {
              composable("title_screen") {
                  TitleScreen(
                      onPlayClicked = { navController.navigate("register") },
                      onLeaderboardsClicked = { /* Navigate to leaderboards */ }
                  )
              }
              composable("register") {
                  RegisterScreen(
                      onSignUpComplete = { navController.navigate("gameInProgress") }
                  )
              }

              // Add the nested graph using the extension function
              addNestedGraph(navController)
          }
      }

   .. rubric:: XML
      :name: xml

   When using XML, you can use the Navigation Editor to create your
   nested graph. To do so follow these steps:

   #. In the Navigation Editor, press and hold the **Shift** key, and
      click the destinations you want to include in the nested graph.

   #. Right-click to open the context menu, and select **Move to Nested
      Graph** > **New Graph**. The destinations are enclosed in a nested
      graph. Figure 2 shows a nested graph in the **Navigation Editor**:

      .. figure::
         https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-nestedgraph_2x.png
         name: fig-graph
         :figclass: border-img
         :width: 325px

         **Figure 2.** Nested graph in the Navigation Editor

   #. Click the nested graph. The following attributes appear in the
      **Attributes** panel:

      -  **Type**, which contains "Nested Graph"
      -  **ID**, which contains a system-assigned ID for the nested
         graph. This ID is used to reference the nested graph from your
         code.

   #. Double-click on the nested graph to show its destinations.

   #. Click the **Text** tab to toggle to the XML view. A nested
      navigation graph has been added to the graph. This navigation
      graph has its own ``navigation`` elements along with its own ID
      and a ``startDestination`` attribute that points to the first
      destination in the nested graph:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <navigation xmlns:app="http://schemas.android.com/apk/res-auto"
             xmlns:tools="http://schemas.android.com/tools"
             xmlns:android="http://schemas.android.com/apk/res/android"
             app:startDestination="@id/mainFragment">
             <fragment
                 android:id="@+id/mainFragment"
                 android:name="com.example.cashdog.cashdog.MainFragment"
                 android:label="fragment_main"
                 tools:layout="@layout/fragment_main" >
                 <action
                     android:id="@+id/action_mainFragment_to_sendMoneyGraph"
                     app:destination="@id/sendMoneyGraph" />
                 <action
                     android:id="@+id/action_mainFragment_to_viewBalanceFragment"
                     app:destination="@id/viewBalanceFragment" />
             </fragment>
             <fragment
                 android:id="@+id/viewBalanceFragment"
                 android:name="com.example.cashdog.cashdog.ViewBalanceFragment"
                 android:label="fragment_view_balance"
                 tools:layout="@layout/fragment_view_balance" />
             <navigation android:id="@+id/sendMoneyGraph" app:startDestination="@id/chooseRecipient">
                 <fragment
                     android:id="@+id/chooseRecipient"
                     android:name="com.example.cashdog.cashdog.ChooseRecipient"
                     android:label="fragment_choose_recipient"
                     tools:layout="@layout/fragment_choose_recipient">
                     <action
                         android:id="@+id/action_chooseRecipient_to_chooseAmountFragment"
                         app:destination="@id/chooseAmountFragment" />
                 </fragment>
                 <fragment
                     android:id="@+id/chooseAmountFragment"
                     android:name="com.example.cashdog.cashdog.ChooseAmountFragment"
                     android:label="fragment_choose_amount"
                     tools:layout="@layout/fragment_choose_amount" />
             </navigation>
         </navigation>

   #. In your code, pass the resource ID of the action connecting the
      root graph to the nested graph:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: kotlin
               :name: kotlin

            .. code:: prettyprint

               view.findNavController().navigate(R.id.action_mainFragment_to_sendMoneyGraph)

         .. container:: section

            .. rubric:: java
               :name: java

            .. code:: prettyprint

               Navigation.findNavController(view).navigate(R.id.action_mainFragment_to_sendMoneyGraph);

   #. Back in the **Design** tab, return to the root graph by clicking
      **Root**.

   .. rubric:: Reference other navigation graphs with include
      :name: include

   Another way to modularize your graph structure is to `include one graph within another <#include>`__ using
   an ``<include>`` element in the parent navigation graph. This allows
   the included graph to be defined in a separate module or project
   altogether, which maximizes reusability.

   The following snippet demonstrates how you can use ``<include>``:

   .. code:: prettyprint

      <!-- (root) nav_graph.xml -->
      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          android:id="@+id/nav_graph"
          app:startDestination="@id/fragment">

          <strong><include app:graph="@navigation/included_graph" /></strong>

          <fragment
              android:id="@+id/fragment"
              android:name="com.example.myapplication.BlankFragment"
              android:label="Fragment in Root Graph"
              tools:layout="@layout/fragment_blank">
              <strong><action
                  android:id="@+id/action_fragment_to_second_graph"
                  app:destination="@id/second_graph" /></strong>
          </fragment>

          ...
      </navigation>

   .. code:: prettyprint

      <!-- included_graph.xml -->
      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          <strong>android:id="@+id/second_graph"</strong>
          app:startDestination="@id/includedStart">

          <fragment
              android:id="@+id/includedStart"
              android:name="com.example.myapplication.IncludedStart"
              android:label="fragment_included_start"
              tools:layout="@layout/fragment_included_start" />
      </navigation>

   .. rubric:: Additional resources
      :name: additional_resources

   To learn more about navigation, consult the following additional
   resources.

   .. rubric:: Samples
      :name: samples

   -  `NavigationBasicSample <https://github.com/android/architecture-components-samples/tree/main/NavigationBasicSample>`__

   .. rubric:: Codelabs
      :name: codelabs

   -  `Learn Jetpack Navigation <https://developers.google.cn/codelabs/codelabs/android-navigation/index.html?index=..%2F..%2Findex#0>`__

   .. rubric:: Videos
      :name: videos

   -  `Android Jetpack: Manage UI navigation with navigation controller (Google I/O '18) <https://www.youtube.com/watch?v=8GCXtCjtg40>`__

Last updated 2024-01-03 UTC.


/Create a deep link for a destination
=====================================

.. container:: devsite-article-body clearfix

   In Android, a deep link is a link that takes you directly to a
   specific destination within an app.

   The Navigation component lets you create two different types of deep
   links: *explicit* and *implicit*.

   .. rubric:: Create an explicit deep link
      :name: explicit

   An `explicit deep link <#>`__ is a
   single instance of a deep link that uses a
   `PendingIntent <#>`__ to take
   users to a specific location within your app. You might surface an
   explicit deep link as part of a notification or an app widget, for
   example.

   When a user opens your app via an explicit deep link, the task back
   stack is cleared and replaced with the deep link destination. When
   `nesting graphs <#>`__, the
   start destination from each level of nesting‚Äîthat is, the start
   destination from each ``<navigation>`` element in the hierarchy‚Äîis
   also added to the stack. This means that when a user presses the Back
   button from a deep link destination, they navigate back up the
   navigation stack just as though they entered your app from its entry
   point.

   You can use the
   `NavDeepLinkBuilder <#>`__
   class to construct a
   `PendingIntent <#>`__, as
   shown in the example below. Note that if the provided context is not
   an ``Activity``, the constructor uses
   `PackageManager.getLaunchIntentForPackage() <#getLaunchIntentForPackage>`__
   as the default activity to launch, if available.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val pendingIntent = NavDeepLinkBuilder(context)
                   .setGraph(R.navigation.nav_graph)
                   .setDestination(R.id.android)
                   .setArguments(args)
                   .createPendingIntent()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               PendingIntent pendingIntent = new NavDeepLinkBuilder(context)
                   .setGraph(R.navigation.nav_graph)
                   .setDestination(R.id.android)
                   .setArguments(args)
                   .createPendingIntent();

   By default, ``NavDeepLinkBuilder`` launches your explicit deep link
   into the default launch ``Activity`` that is declared in your app's
   manifest. If your ``NavHost`` is in another activity, you must
   specify its component name when creating the deep link builder:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val pendingIntent = NavDeepLinkBuilder(context)
                   .setGraph(R.navigation.nav_graph)
                   .setDestination(R.id.android)
                   .setArguments(args)
                   .setComponentName(DestinationActivity::class.java)
                   .createPendingIntent()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               PendingIntent pendingIntent = new NavDeepLinkBuilder(context)
                       .setGraph(R.navigation.nav_graph)
                       .setDestination(R.id.android)
                       .setArguments(args)
                       .setComponentName(DestinationActivity.class)
                       .createPendingIntent();

   If you have a
   `ComponentName <#>`__, you
   can pass it directly to the builder:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val componentName = ...

               val pendingIntent = NavDeepLinkBuilder(context)
                   .setGraph(R.navigation.nav_graph)
                   .setDestination(R.id.android)
                   .setArguments(args)
                   .setComponentName(componentName)
                   .createPendingIntent()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ComponentName componentName = ...;

               PendingIntent pendingIntent = new NavDeepLinkBuilder(context)
                       .setGraph(R.navigation.nav_graph)
                       .setDestination(R.id.android)
                       .setArguments(args)
                       .setComponentName(componentName)
                       .createPendingIntent();

   If you have an existing
   `NavController <#>`__,
   you can also create a deep link by using
   `NavController.createDeepLink() <#createDeepLink>`__.

   **Caution:**\  This APIs allows deep linking to any screen in your
   app, even if that screen does not support any implicit deep links.
   You should follow the `Conditional Navigation <#>`__ page to
   ensure that screens that require login conditionally redirect users
   to those screens when you reach that screen via a deep link.

   .. rubric:: Create an implicit deep link
      :name: implicit

   An `implicit deep link <#>`__ refers
   to a specific destination in an app. When the deep link is
   invoked‚Äîfor example, when a user clicks a link‚ÄîAndroid can then open
   your app to the corresponding destination.

   Deep links can be matched by URI, intent actions, and MIME types. You
   can specify multiple match types for a single deep link, but note
   that URI argument matching is prioritized first, followed by action,
   and then MIME type.

   Here's an example deep link that contains a URI, an action, and a
   MIME type:

   .. code:: prettyprint

      <fragment android:id="@+id/a"
                android:name="com.example.myapplication.FragmentA"
                tools:layout="@layout/a">
              <deepLink app:uri="www.example.com"
                      app:action="android.intent.action.MY_ACTION"
                      app:mimeType="type/subtype"/>
      </fragment>

   You can also use the Navigation Editor to create an implicit deep
   link to a destination as follows:

   #. In the **Design** tab of the Navigation Editor, select the
      destination for the deep link.

   #. Click **+** in the **Deep Links** section of the **Attributes**
      panel.

   #. In the **Add Deep Link** dialog that appears, enter the info for
      your deep link.

      Note the following:

      -  URIs without a scheme are assumed as either http or https. For
         example, ``www.google.com`` matches both
         ``http://www.google.com`` and ``https://www.google.com``.
      -  Path parameter placeholders in the form of
         ``{placeholder_name}`` match one or more characters. For
         example, ``http://www.example.com/users/{id}`` matches
         ``http://www.example.com/users/4``. The Navigation component
         attempts to parse the placeholder values into appropriate types
         by matching placeholder names to the defined
         `arguments <#define_destination_arguments>`__
         that are defined for the deep link destination. If no argument
         with the same name is defined, a default ``String`` type is
         used for the argument value. You can use the .\* wildcard to
         match 0 or more characters.
      -  Query parameter placeholders can be used instead of or in
         conjunction with path parameters. For example,
         ``http://www.example.com/users/{id}?myarg={myarg}`` matches
         ``http://www.example.com/users/4?myarg=28``.
      -  Query parameter placeholders for variables defined with default
         or nullable values are not required to match. For example,
         ``http://www.example.com/users/{id}?arg1={arg1}&arg2={arg2}``
         matches ``http://www.example.com/users/4?arg2=28`` or
         ``http://www.example.com/users/4?arg1=7``. This is not the case
         with path parameters. For example,
         ``http://www.example.com/users?arg1=7&arg2=28`` does not match
         the above pattern because the required path parameter is not
         supplied.
      -  Extraneous query parameters do not affect deep link URI
         matching. For example, ``http://www.example.com/users/{id}``
         matches ``http://www.example.com/users/4?extraneousParam=7``,
         even though ``extraneousParam`` is not defined in the URI
         pattern.

   #. (optional) Check **Auto Verify** to require Google to verify that
      you are the owner of the URI. For more information, see `Verify Android App Links <#>`__.

   #. Click **Add**. A link icon |image-navigation-deeplink| appears above the selected
      destination to indicate that destination has a deep link.

   #. Click the **Code** tab to toggle to the XML view. A nested
      ``<deepLink>`` element has been added to the destination:

   .. |image-navigation-deeplink| image:: https://developer.android.google.cn/static/studio/images/buttons/navigation-deeplink.png
      :class: inline-icon

      .. code:: prettyprint

         <deepLink app:uri="https://www.google.com" />

   To enable implicit deep linking, you must also make additions to your
   app's ``manifest.xml`` file. Add a single ``<nav-graph>`` element to
   an activity that points to an existing navigation graph, as shown in
   the following example:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.example.myapplication">

          <application ... >

              <activity name=".MainActivity" ...>
                  ...

                  <nav-graph android:value="@navigation/nav_graph" />

                  ...

              </activity>
          </application>
      </manifest>

   When building your project, the Navigation component replaces the
   ``<nav-graph>`` element with generated ``<intent-filter>`` elements
   to match all of the deep links in the navigation graph.

   When triggering an implicit deep link, the state of the back stack
   depends on whether the implicit ``Intent`` was launched with the
   `Intent.FLAG_ACTIVITY_NEW_TASK <#FLAG_ACTIVITY_NEW_TASK>`__
   flag:

   -  If the flag is set, the task back stack is cleared and replaced
      with the deep link destination. As with `explicit deep linking <#explicit>`__, when `nesting graphs <#>`__, the start
      destination from each level of nesting‚Äîthat is, the start
      destination from each ``<navigation>`` element in the hierarchy‚Äîis
      also added to the stack. This means that when a user presses the
      Back button from a deep link destination, they navigate back up
      the navigation stack just as though they entered your app from its
      entry point.
   -  If the flag is not set, you remain on the task stack of the
      previous app where the implicit deep link was triggered. In this
      case, the Back button takes you back to the previous app, while
      the Up button starts your app's task on the hierarchical parent
      destination within your navigation graph.

   .. rubric:: Handling deep links
      :name: handle

   It is strongly recommended to always use the default
   `launchMode <#lmode>`__ of
   ``standard`` when using Navigation. When using ``standard`` launch
   mode, Navigation automatically handles deep links by calling
   `handleDeepLink() <#handleDeepLink>`__
   to process any explicit or implicit deep links within the ``Intent``.
   However, this does not happen automatically if the ``Activity`` is
   re-used when using an alternate ``launchMode`` such as ``singleTop``.
   In this case, it is necessary to manually call ``handleDeepLink()``
   in ``onNewIntent()``, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onNewIntent(intent: Intent?) {
                   super.onNewIntent(intent)
                   navController.handleDeepLink(intent)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onNewIntent(Intent intent) {
                   super.onNewIntent(intent);
                   navController.handleDeepLink(intent);
               }

   .. rubric:: Additional resources
      :name: more

   To learn more about navigation, see the following resources.

   .. rubric:: Samples
      :name: samples

   -  `Android Architecture Components Navigation Basic Sample <https://github.com/android/architecture-components-samples/tree/main/NavigationBasicSample>`__

   .. rubric:: Codelabs
      :name: codelabs

   -  `Navigation codelab <https://developers.google.cn/codelabs/codelabs/android-navigation/index.html?index=..%2F..%2Findex#0>`__

   .. rubric:: Videos
      :name: videos

   -  `Android Jetpack: manage UI navigation with Navigation Controller (Google I/O '18) <https://www.youtube.com/watch?v=8GCXtCjtg40>`__

Last updated 2024-01-03 UTC.


/Add support for new destination types
======================================

.. container:: devsite-article-body clearfix

   The
   `NavController <#>`__
   type relies on one or more
   `Navigator <#>`__ objects
   to perform the navigation operation. By default, ``NavController``
   supports leaving the navigation graph by navigating to another
   activity using the
   `ActivityNavigator <#>`__
   class and its nested
   `ActivityNavigator.Destination <#>`__
   class.

   To navigate to any other type of destination, one or more additional
   ``Navigator`` objects must be added to the ``NavController``. For
   example, when using fragments as destinations, the
   `NavHostFragment <#>`__
   automatically adds the
   `FragmentNavigator <#>`__
   class to its ``NavController``.

   To add a new ``Navigator`` object to a ``NavController``, use the
   `getNavigatorProvider() <#getNavigatorProvider>`__
   method, followed by the
   `addNavigator() <#addNavigator>`__
   method.

   The following code shows an example of adding a ``CustomNavigator``
   object to a ``NavController``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val customNavigator = CustomNavigator()
               navController.navigatorProvider += customNavigator

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               CustomNavigator customNavigator = new CustomNavigator();
               navController.getNavigatorProvider().addNavigator(customNavigator);

   Most ``Navigator`` classes have a nested destination subclass. This
   subclass can be used to specify additional attributes unique to your
   destination. For more information about destination subclasses, see
   the reference documentation for the appropriate
   `Navigator <#>`__ class.

   .. rubric:: Additional resources
      :name: additional-resources

   To learn more about navigation, see the following additional
   resources.

   .. rubric:: Samples
      :name: samples

   -  `Android Architecture Components Navigation Basic sample <https://github.com/android/architecture-components-samples/tree/main/NavigationBasicSample>`__

   .. rubric:: Codelabs
      :name: codelabs

   -  `Learn Jetpack Navigation codelab <https://developers.google.cn/codelabs/codelabs/android-navigation/index.html?index=..%2F..%2Findex#0>`__

   .. rubric:: Videos
      :name: videos

   -  `Android Jetpack: Manage UI navigation with Navigation Controller <https://www.youtube.com/watch?v=8GCXtCjtg40>`__

Last updated 2024-01-03 UTC.


/Type safety in Kotlin DSL and Navigation Compose
=================================================

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   This page contains best practices for providing runtime type safety
   to the `Navigation Kotlin DSL <#>`__ and `Navigation Compose <#>`__. In summary, you should map
   each screen of your app or navigation graph to a Navigation file on a
   per module basis. The resulting files should each contain all the
   Navigation related information for the given destination. These
   navigation files are also where Kotlin visibility modifiers provide
   runtime type safety:

   -  Type safe functions are publicly exposed to the rest of the
      codebase.
   -  Navigation specific concepts for a particular screen or navigation
      graph are co-located and kept private in the same file to make
      them inaccessible to the rest of the codebase.

   .. rubric:: Split your navigation graph
      :name: split-navigation

   You should split your navigation graph by screen. This is essentially
   the same approach as when you split screens to different composable
   functions. Each screen should have a
   `NavGraphBuilder <#>`__
   extension function.

   This extension function is the bridge between a stateless
   screen-level composable function and Navigation-specific logic. This
   layer can also define where the state comes from and how events are
   handled.

   Here's a typical ``ConversationScreen`` that can be ``internal`` to
   its own module, so that other modules cannot access it:

   .. code:: prettyprint

      // ConversationScreen.kt

      @Composable
      internal fun ConversationScreen(
        uiState: ConversationUiState,
        onPinConversation: () -> Unit,
        onNavigateToParticipantList: (conversationId: String) -> Unit
      ) { ... }

   The following
   `NavGraphBuilder <#>`__
   extension function adds the ``ConversationScreen`` composable as a
   destination of that
   `NavGraph <#>`__. It
   also connects the screen with a ViewModel that provides the screen UI
   state and handles the screen-related business logic. Navigation
   events that cannot be handled by the ViewModel are exposed to the
   caller.

   .. code:: prettyprint

      // ConversationNavigation.kt

      private const val conversationIdArg = "conversationId"

      // Adds conversation screen to `this` NavGraphBuilder
      fun NavGraphBuilder.conversationScreen(
        // Navigation events are exposed to the caller to be handled at a higher level
        onNavigateToParticipantList: (conversationId: String) -> Unit
      ) {
        composable("conversation/{$conversationIdArg}") {
          // The ViewModel as a screen level state holder produces the screen
          // UI state and handles business logic for the ConversationScreen
          val viewModel: ConversationViewModel = hiltViewModel()
          val uiState = viewModel.uiState.collectAsStateWithLifecycle()
          ConversationScreen(
            uiState,
            ::viewModel.pinConversation,
            onNavigateToParticipantList
          )
        }
      }

   The ``ConversationNavigation.kt`` file separates code from the
   Navigation library from the destination itself. It also provides
   encapsulation around Navigation concepts such as routes or argument
   IDs that are kept private because they should never leak outside of
   this file. Navigation events that cannot be handled at this layer,
   need to be exposed to the caller so that they're handled at the right
   level. You will find an example of such an event with
   ``onNavigateToParticipantList`` in the code snippet above.

   .. rubric:: Type safe navigation
      :name: type-safe

   The `Navigation Kotlin DSL <#>`__ that Navigation
   Compose is built on doesn't *currently* offer compile-time type
   safety of the kind `Safe Args <#Safe-args>`__ provides
   to navigation graphs built in navigation XML resource files. Safe
   Args generates code that contains type-safe classes and methods for
   Navigation destinations and actions. However, you can structure your
   Navigation code to be type safe at runtime. With it, you can avoid
   crashes and make sure that:

   -  The arguments you provide when navigating to a destination or
      navigation graph are the right types and that all the required
      arguments are present.
   -  The arguments you retrieve from ``SavedStateHandle`` are the right
      types.

   .. rubric:: Navigate to a destination
      :name: navigate-destination

   Each destination should also expose a
   `NavController <#>`__
   extension function to allow other destinations to safely navigate to
   it.

   .. code:: prettyprint

      // ConversationNavigation.kt

      fun NavController.navigateToConversation(conversationId: String) {
          this.navigate("conversation/$conversationId")
      }

   If you want to navigate to a screen of your app with different
   `NavOptions <#>`__, such
   as ``popUpTo, savedState, restoreState``, or ``singleTop`` when
   navigating, pass an optional parameter to the ``NavController``
   extension function.

   .. code:: prettyprint

      // HomeNavigation.kt

      const val HomeRoute = "home"

      fun NavController.navigateToHome(navOptions: NavOptions? = null) {
          this.navigate(HomeRoute, navOptions)
      }

   .. rubric:: Type safe arguments wrapper
      :name: arguments-wrapper

   You can optionally create a type safe wrapper to extract the
   arguments out of a
   `SavedStateHandle <#>`__
   for your ViewModel and out of a
   `NavBackStackEntry <#>`__
   in the content of a destination to get the benefits mentioned in the
   introduction to this section.

   .. code:: prettyprint

      // ConversationNavigation.kt

      private const val conversationIdArg = "conversationId"

      internal class ConversationArgs(val conversationId: String) {
        constructor(savedStateHandle: SavedStateHandle) :
          this(checkNotNull(savedStateHandle[conversationIdArg]) as String)
      }

      // ConversationViewModel.kt

      internal class ConversationViewModel(...,
        savedStateHandle: SavedStateHandle
      ) : ViewModel() {
        private val conversationArgs = ConversationArgs(savedStateHandle)
      }

   .. rubric:: Assemble the navigation graph
      :name: assemble-navigation

   Navigation graphs use the type safe extension functions described
   above to add destinations and to navigate to them.

   In the following example, the *conversation* destination together
   with two other destinations, *home* and *participant list*, is
   included in an app level
   `NavHost <#>`__ as follows:

   .. code:: prettyprint

      // MyApp.kt

      @Composable
      fun MyApp(modifier: Modifier = Modifier) {
        val navController = rememberNavController()
        NavHost(
          navController = navController,
          startDestination = HomeRoute,
          modifier = modifier
        ) {

          homeScreen(
            onNavigateToConversation = { conversationId ->
              navController.navigateToConversation(conversationId)
            }
          )

          conversationScreen(
            onNavigateToParticipantList = { conversationId ->
              navController.navigateToParticipantList(conversationId)
            }
          }

          participantListScreen()
      }

   **Note:**\  The start destination route of a Navigation graph needs
   to be publicly exposed from its module or Navigation file. In the
   example above, ``HomeRoute``, defined in a ``HomeNavigation.kt``
   file, needs to be public.

   .. rubric:: Type safety in nested navigation graphs
      :name: type-safety

   You should choose the right visibility for modules that provide
   multiple screens. This is the same concept as for each method in the
   sections above. However, it may not make sense to expose individual
   screens to other modules at all. In that case, you should instead
   treat them as part of a larger, self contained flow.

   This self-contained set of screens is called a `nested navigation graph <#>`__. This lets you
   include multiple screens into a single ``NavGraphBuilder`` extension
   method. This method uses those ``NavController`` extension methods in
   turn to link the screens within the same module together.

   In the following example, the *conversation* destination described in
   previous sections appears n a nested navigation graph alongside two
   other destinations, *conversation list* and *participant list*:

   .. code:: prettyprint

      // ConversationGraphNavigation.kt

      private val ConversationGraphRoutePattern = "conversation"

      fun NavController.navigateToConversationGraph(navOptions: NavOptions? = null) {
        this.navigate(ConversationGraphRoutePattern, navOptions)
      }

      fun NavGraphBuilder.conversationGraph(navController: NavController) {
        navigation(
          startDestination = ConversationListRoutePattern,
          route = ConversationGraphRoutePattern
        ) {
          conversationListScreen(
            onNavigateToConversation = { conversationId ->
              navController.navigateToConversation(conversationId)
            }
          )
          conversationScreen(
            onNavigateToParticipantList = { conversationId ->
              navController.navigateToParticipantList(conversationId)
            }
          )
          partipantList()
      }

   You can use multiple nested navigation graphs in an app level
   `NavHost <#>`__ as follows:

   .. code:: prettyprint

      // MyApp.kt

      @Composable
      fun MyApp(modifier: Modifier = Modifier) {
        val navController = rememberNavController()
        NavHost(
          navController = navController,
          startDestination = HomeGraphRoutePattern
          modifier = modifier
        ) {
          homeGraph(
            navController,
            onNavigateToConversation = {
              navController.navigateToConversationGraph()
            }
          }
          conversationGraph(navController)
      }

Last updated 2023-05-26 UTC.


/Use Navigation actions and Fragments
=====================================

.. container:: devsite-article-body clearfix

   You can build connections between fragments using navigation actions.
   Evoking a navigation action takes the user from one destination to
   another. This guide explains what actions are and demonstrates how
   you can create and use them.

   **Warning:**\  The navigation actions API is available only when
   using the views UI framework.

   .. rubric:: Overview
      :name: overview

   Each action has a unique ID and can contain additional attributes,
   such as a destination. The destination defines the screen to which
   the app takes the user when they trigger the action. The action can
   also use arguments to carry data from one destination to another.

   -  **Safe Args:** Using actions, you can replace resource IDs with
      `Safe Args-generated operations <#>`__, providing
      additional compile-time safety.
   -  **Animations:** You can also animate transitions between the
      destinations. For more information, see `Animate transitions between destinations <#createNavigateOnClickListener>`__.

   .. rubric:: Examples
      :name: examples

   Define actions in your navigation graph XML file using the
   ``<action>`` tags. The following snippet implements an action that
   represents a transition from ``FragmentA`` to ``FragmentB``.

   .. code:: prettyprint

      <fragment
          android:id="@+id/fragmentA"
          android:name="com.example.FragmentA">
          <action
              android:id="@+id/action_fragmentA_to_fragmentB"
              app:destination="@id/fragmentB" />
      </fragment>

   .. rubric:: Navigate using an action
      :name: navigate-using

   To navigate using this action, you call
   `NavController.navigate() <#navigate>`__
   and pass it the action's ``id``:

   .. code:: prettyprint

      navController.navigate(R.id.action_fragmentA_to_fragmentB)

   **Important:**\  For more information about how to use
   ``NavController.navigate()`` and its various overloads, see the
   `Navigate to a destination <#>`__ guide.

   .. rubric:: Global actions
      :name: global-actions

   You can use global actions to navigate to a destination from
   anywhere.

   For any destination in your app that is accessible through more than
   one path, define a corresponding global action that navigates to that
   destination.

   Consider the following example. The ``results_winner`` and
   ``game_over`` destinations both need to pop up to the home
   destination. The ``action_pop_out_of_game`` action provides the
   ability to do so; ``action_pop_out_of_game``\ is a global action
   outside of any specific fragment. That means you can reference and
   call it anywhere within the ``in_game_nav_graph``.

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
         xmlns:app="http://schemas.android.com/apk/res-auto"
         android:id="@+id/in_game_nav_graph"
         app:startDestination="@id/in_game">

         <!-- Action back to destination which launched into this in_game_nav_graph -->
         <action android:id="@+id/action_pop_out_of_game"
                             app:popUpTo="@id/in_game_nav_graph"
                             app:popUpToInclusive="true" />

         <fragment
             android:id="@+id/in_game"
             android:name="com.example.android.gamemodule.InGame"
             android:label="Game">
             <action
                 android:id="@+id/action_in_game_to_resultsWinner"
                 app:destination="@id/results_winner" />
             <action
                 android:id="@+id/action_in_game_to_gameOver"
                 app:destination="@id/game_over" />
         </fragment>

         <fragment
             android:id="@+id/results_winner"
             android:name="com.example.android.gamemodule.ResultsWinner" />

         <fragment
             android:id="@+id/game_over"
             android:name="com.example.android.gamemodule.GameOver"
             android:label="fragment_game_over"
             tools:layout="@layout/fragment_game_over" />

      </navigation>

Last updated 2024-01-03 UTC.



/Build a graph programmatically using the Kotlin DSL
====================================================

.. container:: devsite-article-body clearfix

   The Navigation component provides a Kotlin-based domain-specific
   language, or DSL, that relies on Kotlin's `type-safe builders <https://kotlinlang.org/docs/reference/type-safe-builders.html>`__.
   This API allows you to declaratively compose your graph in your
   Kotlin code, rather than inside an XML resource. This can be useful
   if you wish to build your app's navigation dynamically. For example,
   your app could download and cache a navigation configuration from an
   external web service and then use that configuration to dynamically
   build a navigation graph in your activity's ``onCreate()`` function.

   .. rubric:: Dependencies
      :name: dependencies

   To use the Kotlin DSL, add the following dependency to your app's
   ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   def nav_version = "2.7.7"

                   api "androidx.navigation:navigation-fragment-ktx:$nav_version"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   val nav_version = "2.7.7"

                   api("androidx.navigation:navigation-fragment-ktx:$nav_version")
               }

   .. rubric:: Building a graph
      :name: build

   Let's start with a basic example based on the `Sunflower app <https://github.com/android/sunflower>`__. For this example, we
   have two destinations: ``home`` and ``plant_detail``. The ``home``
   destination is present when the user first launches the app. This
   destination displays a list of plants from the user's garden. When
   the user selects one of the plants, the app navigates to the
   ``plant_detail`` destination.

   Figure 1 shows these destinations along with the arguments required
   by the ``plant_detail`` destination and an action,
   ``to_plant_detail``, that the app uses to navigate from ``home`` to
   ``plant_detail``.

   .. figure::
      https://developer.android.google.cn/static/images/guide/navigation/navigation-kotlin-dsl-1.png
      :alt: The Sunflower app has two destinations along with an action
      that connects them.
      :width: 600px

      **Figure 1.** The Sunflower app has two destinations, ``home`` and
      ``plant_detail``, along with an action that connects them.

   .. rubric:: Hosting a Kotlin DSL Nav Graph
      :name: host

   Before you can build your app's navigation graph, you need a place to
   host the graph. This example uses fragments, so it hosts the graph in
   a
   `NavHostFragment <#>`__
   inside of a
   `FragmentContainerView <#>`__:

   .. code:: prettyprint

      <!-- activity_garden.xml -->
      <FrameLayout
          xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto">
          android:layout_width="match_parent"
          android:layout_height="match_parent">

          <androidx.fragment.app.FragmentContainerView
              android:id="@+id/nav_host"
              android:name="androidx.navigation.fragment.NavHostFragment"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              app:defaultNavHost="true" />

      </FrameLayout>

   Notice that the ``app:navGraph`` attribute is not set in this
   example. The graph isn't defined as a
   `resource <#>`__ in the
   ``res/navigation`` folder so it needs to be set as part of the
   ``onCreate()`` process in the activity.

   In XML, an action ties together a destination ID with one or more
   arguments. However, when using the Navigation DSL a route can contain
   arguments as part of the route. This means that there is no concept
   of actions when using the DSL.

   The next step is to define some constants that you will use when
   defining your graph.

   .. rubric:: Create constants for your graph
      :name: constants

   `XML-based navigation graphs <#create-nav-graph>`__
   are parsed as part of the Android build process. A numeric constant
   is created for each ``id`` attribute defined in the graph. These
   build time generated static IDs are not available when building your
   navigation graph at runtime so the Navigation DSL uses route strings
   instead of IDs. Each route is represented by a unique string and it
   is good practice to define these as constants to reduce the risk of
   typo-related bugs.

   When dealing with arguments, these are `built into the route string <#nav-with-args>`__. Building this
   logic into the route can, once again, reduce the risk of typo-related
   bugs creeping in.

   .. code:: prettyprint

      object nav_routes {
          const val home = "home"
          const val plant_detail = "plant_detail"
      }

      object nav_arguments {
          const val plant_id = "plant_id"
          const val plant_name = "plant_name"
      }

   .. rubric:: Build a graph with the NavGraphBuilder DSL
      :name: navgraphbuilder

   Once you've defined your constants, you can build the navigation
   graph.

   .. code:: prettyprint

      val navController = findNavController(R.id.nav_host_fragment)
      navController.graph = navController.createGraph(
          startDestination = nav_routes.home
      ) {
          fragment<HomeFragment>(nav_routes.home) {
              label = resources.getString(R.string.home_title)
          }

          fragment<PlantDetailFragment>("${nav_routes.plant_detail}/{${nav_arguments.plant_id}}") {
              label = resources.getString(R.string.plant_detail_title)
              argument(nav_arguments.plant_id) {
                  type = NavType.StringType
              }
          }
      }

   In this example, the trailing lambda defines two fragment
   destinations using the
   `fragment() <#(androidx.navigation.NavGraphBuilder).fragment>`__
   DSL builder function. This function requires a route string for the
   destination which is obtained from the constants. The function also
   accepts an optional lambda for additional configuration, such as the
   destination label, as well as embedded builder functions for
   arguments and deep links.

   The
   `Fragment <#>`__
   class that manages the UI of each destination is passed in as a
   parameterized type inside angle brackets (``<>``). This has the same
   effect as setting the ``android:name`` attribute on fragment
   destinations that are defined using XML.

   .. rubric:: Navigating with your Kotlin DSL graph
      :name: navigate

   Finally, you can navigate from ``home`` to ``plant_detail`` using
   standard
   `NavController.navigate() <#navigate>`__
   calls:

   .. code:: prettyprint

      private fun navigateToPlant(plantId: String) {
         findNavController().navigate("${nav_routes.plant_detail}/$plantId")
      }

   **Note:**\  The Safe Args plugin is incompatible with the Kotlin DSL.
   For more information, see `Limitations <#limitations>`__.
   In ``PlantDetailFragment``, you can obtain the value of the argument
   as shown in the following example:

   .. code:: prettyprint

      val plantId: String? = arguments?.getString(nav_arguments.plant_id)

   Details of how to supply arguments when navigating can be found in
   the `providing destination arguments <#args>`__ section.

   The rest of this guide describes common navigation graph elements,
   destinations, and how to use them when building your graph.

   .. rubric:: Destinations
      :name: destinations

   The Kotlin DSL provides built-in support for three destination types:
   ``Fragment``, ``Activity``, and ``NavGraph`` destinations, each of
   which has its own inline extension function available for building
   and configuring the destination.

   .. rubric:: Fragment destinations
      :name: fragment

   The
   `fragment() <#(androidx.navigation.NavGraphBuilder).fragment>`__
   DSL function can be parameterized to the implementing fragment class
   and takes a unique route string to assign to this destination,
   followed by a lambda where you can provide additional configuration
   as described in the `Navigating with your Kotlin DSL graph <#navigate>`__ section.

   .. code:: prettyprint

      fragment<FragmentDestination>(nav_routes.route_name) {
         label = getString(R.string.fragment_title)
         // arguments, deepLinks
      }

   .. rubric:: Activity destination
      :name: activity

   The
   `activity() <#(androidx.navigation.NavGraphBuilder).activity>`__
   DSL function takes a unique route string to assign to this
   destination but is not parameterized to any implementing activity
   class. Instead, you set an optional ``activityClass`` in a trailing
   lambda. This flexibility allows you to define an activity destination
   for an activity that should be launched using an `implicit intent <#ExampleSend>`__, where an
   explicit activity class would not make sense. As with fragment
   destinations, you can also configure a label, arguments, and deep
   links.

   .. code:: prettyprint

      activity(nav_routes.route_name) {
         label = getString(R.string.activity_title)
         // arguments, deepLinks...

         activityClass = ActivityDestination::class
      }

   .. rubric:: Navigation graph destination
      :name: navgraph

   The
   `navigation() <#(androidx.navigation.NavGraphBuilder).navigation>`__
   DSL function can be used to build a `nested navigation graph <#>`__. This function
   takes three arguments: a route to assign to the graph, the route of
   the starting destination of the graph, and a lambda to further
   configure the graph. Valid elements include other destinations,
   arguments, deep links, and a `descriptive label for the destination <#label>`__.
   This label can be useful for binding the navigation graph to UI
   components using `NavigationUI <#>`__

   .. code:: prettyprint

      navigation("route_to_this_graph", nav_routes.home) {
         // label, other destinations, deep links
      }

   .. rubric:: Supporting custom destinations
      :name: custom

   If you‚Äôre using a `new destination type <#>`__ that does not directly
   support the Kotlin DSL, you can add these destinations to your Kotlin
   DSL using
   `addDestination() <#addDestination>`__:

   .. code:: prettyprint

      // The NavigatorProvider is retrieved from the NavController
      val customDestination = navigatorProvider[CustomNavigator::class].createDestination().apply {
          route = Graph.CustomDestination.route
      }
      addDestination(customDestination)

   As an alternative, you can also use the unary plus operator to add a
   newly constructed destination directly to the graph:

   .. code:: prettyprint

      // The NavigatorProvider is retrieved from the NavController
      +navigatorProvider[CustomNavigator::class].createDestination().apply {
          route = Graph.CustomDestination.route
      }

   .. rubric:: Providing destination arguments
      :name: args

   Any destination can define arguments that are optional or required.
   Actions can be defined using the
   `argument() <#argument>`__
   function on ``NavDestinationBuilder``, which is the base class for
   all destination builder types. This function takes the argument‚Äôs
   name as a string and a lambda that is used to construct and configure
   a
   `NavArgument <#>`__.

   Inside the lambda you can specify the argument data type, a default
   value if applicable, and whether or not it is nullable.

   .. code:: prettyprint

      fragment<PlantDetailFragment>("${nav_routes.plant_detail}/{${nav_arguments.plant_id}}") {
          label = getString(R.string.plant_details_title)
          argument(nav_arguments.plant_id) {
              type = NavType.StringType
              defaultValue = getString(R.string.default_plant_id)
              nullable = true  // default false
          }
      }

   If a ``defaultValue`` is given, the type can be inferred. If both a
   ``defaultValue`` and a ``type`` are given, the types must match. See
   the `NavType <#>`__ reference
   documentation for a complete list of argument types available.

   .. rubric:: Providing custom types
      :name: custom-types

   Certain types, such as
   `ParcelableType <#>`__
   and
   `SerializableType <#>`__,
   do not support parsing values from the strings used by routes or deep
   links. This is because they do not rely on reflection at runtime. By
   providing a custom ``NavType`` class, you can control exactly how
   your type is parsed from a route or deep link. This allows you to use
   `Kotlin Serialization <https://github.com/Kotlin/kotlinx.serialization>`__ or
   other libraries to provide reflectionless encoding and decoding of
   your custom type.

   For example, a data class that represents search parameters being
   passed to your search screen could implement both ``Serializable``
   (to providing the encoding/decoding support) and ``Parcelize`` (to
   support saving to and restoring from a ``Bundle``):

   .. code:: prettyprint

      @Serializable
      @Parcelize
      data class SearchParameters(
        val searchQuery: String,
        val filters: List<String>
      )

   A custom ``NavType`` could be written as:

   .. code:: prettyprint

      val SearchParametersType = object : NavType<SearchParameters>(
        isNullableAllowed = false
      ) {
        override fun put(bundle: Bundle, key: String, value: SearchParameters) {
          bundle.putParcelable(key, value)
        }
        override fun get(bundle: Bundle, key: String): SearchParameters {
          return bundle.getParcelable(key) as SearchParameters
        }

        override fun parseValue(value: String): SearchParameters {
          return Json.decodeFromString<SearchParameters>(value)
        }

        // Only required when using Navigation 2.4.0-alpha07 and lower
        override val name = "SearchParameters"
      }

   This can then be used in your Kotlin DSL like any other type:

   .. code:: prettyprint

      fragment<SearchFragment>(nav_routes.plant_search) {
          label = getString(R.string.plant_search_title)
          argument(nav_arguments.search_parameters) {
              type = SearchParametersType
              defaultValue = SearchParameters("cactus", emptyList())
          }
      }

   This example uses Kotlin Serialization to parse the value from the
   string, which means that Kotlin Serialization must also be used when
   you navigate to the destination to ensure the formats match:

   .. code:: prettyprint

      val params = SearchParameters("rose", listOf("available"))
      val searchArgument = Uri.encode(Json.encodeToString(params))
      navController.navigate("${nav_routes.plant_search}/$searchArgument")

   The parameter can be obtained from the arguments in the destination:

   .. code:: prettyprint

      val params: SearchParameters? = arguments?.getParcelable(nav_arguments.search_parameters)

   .. rubric:: Deep links
      :name: deep

   Deep links can be added to any destination, just as they can with an
   XML driven navigation graph. All of the same procedures defined in
   `Creating a deep link for a destination <#implicit>`__
   apply to the process of creating an `explicit deep link <#explicit>`__ using the
   Kotlin DSL.

   When creating an `implicit deep link <#>`__ however, you don‚Äôt
   have an XML navigation resource that can be analyzed for
   ``<deepLink>`` elements. Therefore, you cannot rely on placing a
   ``<nav-graph>`` element in your ``AndroidManifest.xml`` file and must
   instead add `intent filters <#>`__ to
   your activity manually. The intent filter you supply should match the
   base URL pattern, action, and mimetype of your app's deep links.

   You can supply a more specific ``deeplink`` for each individually
   deep linked destination using the
   `deepLink() <#deepLink>`__
   DSL function. This function accepts a ``NavDeepLink`` that contains a
   ``String`` representing the URI pattern, a ``String`` representing
   the intent actions, and a ``String`` representing the mimeType .

   For example:

   .. code:: prettyprint

      deepLink {
          uriPattern = "http://www.example.com/plants/"
          action = "android.intent.action.MY_ACTION"
          mimeType = "image/*"
      }

   There is no limit to the number of deep links you can add. Each time
   you call
   `deepLink() <#deepLink>`__
   a new deep link is appended to a list that is maintained for that
   destination.

   A more complex implicit deep link scenario that also defines path and
   query-based parameters is shown below:

   .. code:: prettyprint

      val baseUri = "http://www.example.com/plants"

      fragment<PlantDetailFragment>(nav_routes.plant_detail) {
         label = getString(R.string.plant_details_title)
         deepLink(navDeepLink {
          uriPattern = "${baseUri}/{id}"
         })
         deepLink(navDeepLink {
          uriPattern = "${baseUri}/{id}?name={plant_name}"
         })
      }

   You can use `string interpolation <https://kotlinlang.org/docs/reference/idioms.html#string-interpolation>`__
   to simplify the definition.

   .. rubric:: Limitations
      :name: limitations

   The `Safe Args <#Safe-args>`__
   plugin is incompatible with the Kotlin DSL, as the plugin looks for
   XML resource files to generate ``Directions`` and ``Arguments``
   classes.

   .. rubric:: Learn more
      :name: learn-more

   Check out the `Navigation type safety <#>`__ page to learn
   how to provide type safety for your Kotlin DSL and `Navigation Compose <#>`__ code.

Last updated 2024-05-01 UTC.


/Navigation Editor
==================

.. container:: devsite-article-body clearfix

   Android Studio contains a GUI that lets you create and edit a
   navigation graph. This is essentially an editor for the underlying
   XML resource file.

   **Caution:**\  You can't use the Navigation Editor for your app if
   you are using Compose or if you have built your navigation graph
   programmatically using the Kotlin DSL.

   .. rubric:: Overview
      :name: overview

   After you've added an XML graph to your app, Android Studio opens the
   graph in the *Navigation Editor*. In the Navigation Editor, you can
   visually edit navigation graphs or directly edit the underlying XML.

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/nav-editor-2x.png
      name: fig-graph
      :figclass: border-img
      :width: 856px

      **Figure 1.** The Navigation Editor

   #. **Destinations panel**: Lists your navigation host and all
      destinations in the **Graph Editor**.
   #. **Graph Editor**: Contains a visual representation of your
      navigation graph. You can switch between **Design** view and the
      underlying XML representation in the **Text** view.
   #. **Attributes**: Shows attributes for the selected item in the
      navigation graph.

   Click the **Text** tab to see the corresponding XML, which should
   look similar to the following snippet:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
                  xmlns:app="http://schemas.android.com/apk/res-auto"
                  android:id="@+id/nav_graph">

      </navigation>

   The ``<navigation>`` element is the root element of a navigation
   graph. As you add destinations and connecting actions to your graph,
   you can see the corresponding ``<destination>`` and ``<action>``
   elements here as child elements. If you have `nested graphs <#>`__, they appear
   as child ``<navigation>`` elements.

   .. rubric:: Add destinations
      :name: add-destinations

   You can create a destination from an existing fragment or activity.
   You can also use the Navigation Editor to create a new destination or
   create a placeholder to later replace with a fragment or activity.

   This example demonstrates how to create a new destination. To add a
   new destination using the Navigation Editor, do the following:

   #. In the Navigation Editor, click the **New Destination** icon
      |image-navigation-new-destination-icon|, and then click **Create new destination**.
   #. In the **New Android Component** dialog that appears, create your
      fragment. For more information on fragments, see the `fragments overview <#>`__.

   Back in the Navigation Editor, notice that Android Studio has added
   this destination to the graph.

   Figure 2 shows an example of a destination and a `placeholder destination <#placeholders>`__.

   .. figure::
      https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-destination-and-placeholder_2x.png
      name: fig-graph
      :figclass: border-img
      :width: 338px

      **Figure 2.** A destination and a placeholder

   For other ways to add destinations to your navigation graph, see
   `Additional destinations <#>`__.

   .. rubric:: Create a destination from an existing fragment or
      activity
      :name: create-from-existing

   In the Navigation Editor, if you have an existing destination type
   that you'd like to add to your navigation graph, click **New
   Destination** |image-navigation-new-destination-icon|.

   Next, click the corresponding destination in the drop-down that
   appears. You can now see a preview of the destination in the
   **Design** view along with the corresponding XML in the **Text** view
   of your navigation graph.

   .. rubric:: Create a new fragment destination
      :name: create-fragment

   To add a new destination type using the Navigation Editor, do the
   following:

   #. In the Navigation Editor, click the **New Destination** icon
      |image-navigation-new-destination-icon|.

      Next, click **Create new destination**.

   #. In the **New Android Component** dialog that appears, create your
      fragment.

   Back in the Navigation Editor, notice that Android Studio has added
   this destination to the graph.

   Figure 3 shows an example of a destination and a `placeholder destination <#>`__.

   .. figure::
      https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-destination-and-placeholder_2x.png
      name: fig-graph
      :figclass: border-img
      :width: 338px

      **Figure 3.** A destination and a placeholder

   .. rubric:: Anatomy of a destination
      :name: anatomy_of_a_destination

   Click a destination to select it, and note the following attributes
   in the **Attributes** panel:

   -  The **Type** field indicates whether the destination is
      implemented as a fragment, activity, or other custom class in your
      source code.
   -  The **Label** field contains the user-readable name of the
      destination. This might be surfaced to the UI‚Äîfor example, if you
      connect the
      `NavGraph <#>`__ to a
      ``Toolbar`` using
      `setupWithNavController() <#setupWithNavController>`__.
      For this reason, use resource strings for this value.
   -  The **ID** field contains the destination ID, which is used to
      refer to the destination in code.
   -  The **Class** drop-down shows the name of the class that is
      associated with the destination. Click this drop-down to change
      the associated class to another destination type.

   Click the **Text** tab to show the XML view of your navigation graph.
   The XML contains the same ``id``, ``name``, ``label``, and ``layout``
   attributes for the destination, as in the following snippet:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          xmlns:android="http://schemas.android.com/apk/res/android"
          app:startDestination="@id/blankFragment">
          <fragment
              android:id="@+id/blankFragment"
              android:name="com.example.cashdog.cashdog.BlankFragment"
              android:label="@string/label_blank"
              tools:layout="@layout/fragment_blank" />
      </navigation>

   .. rubric:: NavHostFragment
      :name: navhostfragment

   You can also use the `Layout Editor <#>`__
   to add a ``NavHostFragment`` to an activity by doing the following:

   #. In your list of project files, double-click your activity's layout
      XML file to open it in the Layout Editor.
   #. Within the **Palette** pane, choose the **Containers** category;
      alternatively, search for "NavHostFragment".
   #. Drag the ``NavHostFragment`` view onto your activity.
   #. In the **Navigation Graphs** dialog that appears, choose the
      corresponding navigation graph to associate with this
      ``NavHostFragment``, and then click **OK**.

   .. rubric:: Connect destinations
      :name: connect

   An *action* is a logical connection between destinations. Actions are
   represented in the navigation graph as arrows. Actions usually
   connect one destination to another, though you can also create
   `global actions <#>`__ that
   take you to a specific destination from anywhere in your app.

   With actions, you're representing the different paths that users can
   take through your app. Note that to actually navigate to
   destinations, you still need to write the code to perform the
   navigation.

   You can use the Navigation Editor to connect two destinations by
   doing the following:

   #. In the **Design** tab, hold the pointer over the right side of the
      destination that you want users to navigate from. A circle appears
      over the right side of the destination, as shown in figure 4.

      .. figure::
         https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-actioncircle_2x.png
         name: fig-graph
         :figclass: border-img
         :width: 186px

         **Figure 4.** A destination with an action connection circle

   #. Drag your cursor over the destination you want users to navigate
      to, and release. The resulting line between the two destinations
      represents an action, as shown in figure 5.

      .. figure::
         https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-connected_2x.png
         name: fig-graph
         :figclass: border-img
         :width: 464px

         **Figure 5.** Connecting destinations with an action

   #. Click the arrow to highlight the action. The following attributes
      appear in the **Attributes** panel:

      -  The **Type** field contains "Action".
      -  The **ID** field contains the ID for the action.
      -  The **Destination** field contains the ID for the destination
         fragment or activity.

   #. Click the **Text** tab to toggle to the XML view. An action
      element is now added to the source destination. The action has an
      ID and a destination attribute that contains the ID of the next
      destination, as shown in the following example:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <navigation xmlns:app="http://schemas.android.com/apk/res-auto"
            xmlns:tools="http://schemas.android.com/tools"
            xmlns:android="http://schemas.android.com/apk/res/android"
            app:startDestination="@id/blankFragment">
            <fragment
                android:id="@+id/blankFragment"
                android:name="com.example.cashdog.cashdog.BlankFragment"
                android:label="@string/label_blank"
                tools:layout="@layout/fragment_blank" >
                <action
                    android:id="@+id/action_blankFragment_to_blankFragment2"
                    app:destination="@id/blankFragment2" />
            </fragment>
            <fragment
                android:id="@+id/blankFragment2"
                android:name="com.example.cashdog.cashdog.BlankFragment2"
                android:label="@string/label_blank_2"
                tools:layout="@layout/fragment_blank_fragment2" />
         </navigation>

   In your navigation graph, actions are represented by ``<action>``
   elements. At a minimum, an action contains its own ID and the ID of
   the destination to which a user should be taken.

   .. rubric:: Placeholder destinations
      :name: placeholders

   You can use *placeholders* to represent unimplemented destinations. A
   placeholder serves as a visual representation of a destination.
   Within the Navigation Editor, you can use placeholders just as you
   would any other destination.

   **Note:**\  You must change the *Class* attribute of your
   placeholders to existing destinations before running your app.
   Placeholders don't cause compilation errors, and if you attempt to
   navigate to a placeholder destination, the app throws a runtime
   exception.

Last updated 2024-01-03 UTC.

.. |image-navigation-new-destination-icon| image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-new-destination-icon.png
   :class: inline-icon

/Navigate to a destination
==========================

.. container:: devsite-article-body clearfix

   The Navigation component provides a straightforward and generic way
   of navigating to a destination. This interface supports a range of
   contexts and UI frameworks. For example, you can use the Navigation
   component with Compose, views, fragments, activities, and even custom
   UI frameworks.

   This guide describes how you can use the Navigation component to
   navigate to a destination in various contexts.

   .. rubric:: Use a NavController
      :name: use_a_navcontroller

   The key type you use to move between destinations is the
   `NavController <#>`__.
   See `Create a navigation controller <#>`__ for more information
   on the class itself and how to create an instance of it. This guide
   details how to use it.

   .. rubric:: Navigate
      :name: navigate

   Regardless of which UI framework you use, there is a single function
   you can use to navigate to a destination:
   `NavController.navigate() <#navigate>`__.

   There are many overloads available for ``navigate()``. The overload
   you should choose corresponds to your exact context. For example, you
   should use one overload when navigating to a composable and another
   when navigating to a view.

   The following sections outline some of the key ``navigate()``
   overloads you can use.

   .. rubric:: Navigate to a composable
      :name: compose

   To navigate to a composable in the navigation graph, use
   `NavController.navigate(route) <#navigate>`__.
   With this overload, ``navigate()`` takes a single ``String``
   argument. This is the ``route``. It serves as the key to a
   destination.

   .. code:: prettyprint

      navController.navigate("friendslist")

   To navigate using a ``route`` string, you first need to create your
   ``NavGraph`` such that each destination is associated with a
   ``route``. For composables, you do so with the
   `composable() <#(androidx.navigation.NavGraphBuilder).composable>`__
   function.

   For more information, see `Navigate to a destination <#navigate-example>`__.

   .. rubric:: Expose events from your composables
      :name: nav-from-composable

   When a composable function needs to navigate to a new screen, you
   shouldn't pass it a reference to the ``NavController`` so that it can
   call ``navigate()`` directly. According to `Unidirectional Data Flow (UDF) <#udf>`__ principles, the
   composable should instead expose an event that the ``NavController``
   handles.

   More directly put, your composable should have a parameter of type
   ``() -> Unit``. When you add destinations to your ``NavHost`` with
   the
   `composable() <#(androidx.navigation.NavGraphBuilder).composable>`__
   function, pass your composable a call to
   ``NavController.navigate()``.

   See the following subsection for a clear example of this.

   **Warning:**\  Don't pass your ``NavController`` to your composables.
   Expose an event as described here.

   .. rubric:: Example
      :name: navigate-example

   As a demonstration of the preceding section, observe these points in
   the following snippet:

   #. The ``MyAppNavHost`` composable holds the ``NavController``
      instance.
   #. Accordingly, calls to ``navigate()`` should occur there and not in
      a lower composable like ``ProfileScreen``.
   #. ``ProfileScreen`` contains a button that navigates the user to
      ``FriendsList`` when clicked. However, it does not call
      ``navigate()`` itself.
   #. Instead, the button calls a function that is exposed as the
      parameter ``onNavigateToFriends``.
   #. When ``MyAppNavHost`` adds ``ProfileScreen`` to the navigation
      graph, for ``onNavigateToFriends`` it passes a lambda that calls
      ``navigate()``.
   #. This ensures that when the user presses the button
      ``ProfileScreen``, they navigate correctly to ``friendsList``.

   .. code:: prettyprint

      @Composable
      fun MyAppNavHost(
          modifier: Modifier = Modifier,
          navController: NavHostController = rememberNavController(),
          startDestination: String = "profile"
      ) {
          NavHost(
              modifier = modifier,
              navController = navController,
              startDestination = startDestination
          ) {
              composable("profile") {
                  ProfileScreen(
                      onNavigateToFriends = { navController.navigate("friendsList") },
                      /*...*/
                  )
              }
              composable("friendslist") { FriendsListScreen(/*...*/) }
          }
      }

      @Composable
      fun ProfileScreen(
          onNavigateToFriends: () -> Unit,
          /*...*/
      ) {
          /*...*/
          Button(onClick = onNavigateToFriends) {
              Text(text = "See friends list")
          }
      }

   **Warning:**\  You should only call ``navigate()`` as part of a
   callback and not as part of your composable itself. This avoids
   calling ``navigate()`` on every recomposition.

   .. rubric:: Navigate using integer ID
      :name: id

   To navigate to a destination using an integer ID, call the
   `navigate(int) <#navigate>`__
   overload. It takes the resource ID of either an action or a
   destination. The following code snippet shows how you can use this
   overload to navigate to the ``ViewTransactionsFragment``:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            viewTransactionsButton.setOnClickListener { view ->
              view.findNavController().navigate(R.id.viewTransactionsAction)
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            viewTransactionsButton.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View view) {
                  Navigation.findNavController(view).navigate(R.id.viewTransactionsAction);
              }
            });

   When navigating using IDs, you should use
   `actions <#>`__ where possible.
   Actions provide additional information in your navigation graph,
   visually showing how your destinations connect to each other.

   **Note:**\  For buttons, there are three variants of
   `Navigation.createNavigateOnClickListener() <#createNavigateOnClickListener>`__.
   These variants are useful if you're using the Java programming
   language. If you're using Kotlin, ``OnClickListener`` is a SAM
   interface, so you can use a trailing lambda. This approach can be
   shorter and easier to read than calling
   ``createNavigateOnClickListener()`` directly.
   **Note:**\  To handle other common UI components, such as the top app
   bar and bottom navigation, see `Update UI components with NavigationUI <#>`__.

   .. rubric:: Navigate using NavDeepLinkRequest
      :name: uri

   To navigate to an `implicit deep link destination <#>`__, use the
   `navigate(NavDeepLinkRequest) <#navigate>`__
   overload. The follow snippet provides an implementation of this
   method:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin_1

         .. code:: prettyprint

            val request = NavDeepLinkRequest.Builder
              .fromUri("android-app://androidx.navigation.app/profile".toUri())
              .build()
            findNavController().navigate(request)

      .. container:: section

         .. rubric:: Java
            :name: java_1

         .. code:: prettyprint

            NavDeepLinkRequest request = NavDeepLinkRequest.Builder
              .fromUri(Uri.parse("android-app://androidx.navigation.app/profile"))
              .build()
            NavHostFragment.findNavController(this).navigate(request)

   Unlike navigation using action or destination IDs, you can navigate
   to any deep link in your graph, regardless of whether the destination
   is visible. You can navigate to a destination on the current graph or
   a destination on a completely different graph.

   **Caution:**\  When navigating using ``NavDeepLinkRequest``, the back
   stack does *not* reset. This behavior is unlike other forms of `deep link navigation <#>`__. However,
   ``popUpTo()`` and ``popUpToInclusive()`` still remove destinations
   from the back stack just as though you had navigated using an ID.
   **Note:**\  For convenience, you can also use
   `navigate(Uri) <#navigate>`__,
   which wraps a ``Uri`` in a ``DeepLinkRequest``.

   .. rubric:: Actions and MIME types
      :name: actions-and

   In addition to ``Uri``,
   `NavDeepLinkRequest <#>`__
   also supports deep links with actions and MIME types. To add an
   action to the request, use
   `fromAction() <#fromAction>`__
   or
   `setAction() <#setAction>`__.
   To add a MIME type to a request, use
   `fromMimeType() <#fromMimeType>`__
   or
   `setMimeType() <#setMimeType>`__.

   For a ``NavDeepLinkRequest`` to properly match an implicit deep link
   destination, the URI, action, and MIME type must all match the
   ``NavDeepLink`` in the destination. URIs must match the pattern, the
   actions must be an exact match, and the MIME types must be related.
   For example, ``image/jpg`` matches with ``image/\*``

   .. rubric:: Further contexts
      :name: further-contexts

   This document covers how to use
   `NavController.navigate() <#navigate>`__
   in the most common use cases. However, the function has a range of
   overloads that you can use in different contexts, and in tandem with
   any Ui framework. See the reference documentation for more detail on
   these overloads.

   .. rubric:: Further reading
      :name: further-reading

   For more information, see the following pages:

   -  `Create a navigation controller <#>`__
   -  `Navigation and the back stack <#>`__
   -  `Navigate with options <#>`__
   -  `Type safety in Kotlin DSL and Navigation Compose <#type-safe>`__

Last updated 2024-02-13 UTC.


/Navigate with options
======================

.. container:: devsite-article-body clearfix

   When you define an action in the navigation graph using the Kotlin
   DSL, Navigation generates a corresponding
   `NavAction <#>`__ class,
   which contains the configurations defined for that action, including
   the following:

   -  `Destination <#getDestinationId>`__\ **:**
      The resource ID of the target destination.
   -  `Default arguments <#getDefaultArguments>`__\ **:**
      An ``android.os.Bundle`` containing default values for the target
      destination, if supplied.
   -  `Navigation options <#getNavOptions>`__\ **:**
      Navigation options, represented as
      `NavOptions <#>`__.
      This class contains all of the special configuration for
      transitioning to and back from the target destination, including
      animation resource configuration, pop behavior, and whether the
      destination should be launched in single top mode.

   .. rubric:: Options with Compose
      :name: options-compose

   By default, ``navigate()`` adds your new destination to the back
   stack. You can modify the behavior of ``navigate()`` by passing
   additional navigation options to your ``navigate()`` call.

   You can create an instance of ``NavOptions`` using a simple lambda.
   Pass ``navigate()`` the arguments you might otherwise explicitly pass
   to the ``NavOptions.Builder``. Consider the following examples:

   For examples, see the `back stack guide <#compose-examples>`__ for examples
   on how to pass options to ``navigate()`` in context.

   **Note:**\  You cannot use `anim``
   block </reference/kotlin/androidx/navigation/NavAction#getDefaultArguments()>`__
   with Navigation Compose. There is a `feature request <#getNavOptions>`__
   that tracks Transition Animations in Navigation Compose.
   **Note:**\  The user's current location is already in the back stack.
   It appears in the back stack when the user first navigates to the
   destination, not when they navigate away.

   .. rubric:: Options with XML
      :name: options-xml

   The following is an example graph consisting of two screens along
   with an action to navigate from one to the other:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
                  xmlns:app="http://schemas.android.com/apk/res-auto"
                  xmlns:tools="http://schemas.android.com/tools"
                  android:id="@+id/nav_graph"
                  app:startDestination="@id/a">

          <fragment android:id="@+id/a"
                    android:name="com.example.myapplication.FragmentA"
                    android:label="a"
                    tools:layout="@layout/a">
              <action android:id="@+id/action_a_to_b"
                      app:destination="@id/b"
                      app:enterAnim="@anim/nav_default_enter_anim"
                      app:exitAnim="@anim/nav_default_exit_anim"
                      app:popEnterAnim="@anim/nav_default_pop_enter_anim"
                      app:popExitAnim="@anim/nav_default_pop_exit_anim"/>
          </fragment>

          <fragment android:id="@+id/b"
                    android:name="com.example.myapplication.FragmentB"
                    android:label="b"
                    tools:layout="@layout/b">
              <action android:id="@+id/action_b_to_a"
                      app:destination="@id/a"
                      app:enterAnim="@anim/nav_default_enter_anim"
                      app:exitAnim="@anim/nav_default_exit_anim"
                      app:popEnterAnim="@anim/nav_default_pop_enter_anim"
                      app:popExitAnim="@anim/nav_default_pop_exit_anim"
                      app:popUpTo="@+id/a"
                      app:popUpToInclusive="true"/>
          </fragment>
      </navigation>

   When the navigation graph is inflated, these actions are parsed, and
   corresponding ``NavAction`` objects are generated with the
   configurations defined in the graph. For example, ``action_b_to_a``
   is defined as navigating from destination ``b`` to destination ``a``.
   The action includes animations along with ``popTo`` behavior that
   removes all destinations from the backstack. All of these settings
   are captured as ``NavOptions`` and are attached to the ``NavAction``.

   To follow this ``NavAction``, use ``NavController.navigate()``,
   passing the ID of the action, as shown in the following example:

   .. code:: prettyprint

          navController.navigate(R.id.action_b_to_a)

   .. rubric:: Apply options programmatically
      :name: programmatic

   The previous examples show how to specify ``NavOptions`` within the
   navigation graph XML. However, specific options can vary depending on
   constraints that are unknown at build time. In such cases, the
   ``NavOptions`` must be created and set programmatically, as shown in
   the following example:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            findNavController().navigate(
            R.id.action_fragmentOne_to_fragmentTwo,
            null,
            navOptions { // Use the Kotlin DSL for building NavOptions
                anim {
                    enter = android.R.animator.fade_in
                    exit = android.R.animator.fade_out
                }
              }
            )

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            NavController navController = NavHostFragment.findNavController(this);
              navController.navigate(
                R.id.action_fragmentOne_to_fragmentTwo,
                null,
                new NavOptions.Builder()
                  .setEnterAnim(android.R.animator.fade_in)
                  .setExitAnim(android.R.animator.fade_out)
                  .build()
              );

   This example uses an extended form of
   `navigate() <#navigate>`__
   and contains additional ``Bundle`` and ``NavOptions`` arguments. All
   variants of ``navigate()`` have extended versions that accept a
   ``NavOptions`` argument.

   **Note:**\  ``NavOptions`` that are applied programmatically override
   any and all options that have been set in XML.
   You can also programmatically apply ``NavOptions`` when navigating to
   implicit deep links:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin_1

         .. code:: prettyprint

            findNavController().navigate(
                deepLinkUri,
                navOptions { // Use the Kotlin DSL for building NavOptions
                    anim {
                        enter = android.R.animator.fade_in
                        exit = android.R.animator.fade_out
                    }
                }
            )

      .. container:: section

         .. rubric:: Java
            :name: java_1

         .. code:: prettyprint

            NavController navController = NavHostFragment.findNavController(this);
            navController.navigate(
                    deepLinkUri,
                    new NavOptions.Builder()
                            .setEnterAnim(android.R.animator.fade_in)
                            .setExitAnim(android.R.animator.fade_out)
                            .build()
            );

   This variant of
   `navigate() <#navigate>`__
   takes a `Uri <#>`__ for the implicit
   deep link, as well as the ``NavOptions`` instance.


Last updated 2024-01-03 UTC.


/Safe Args
==========

.. container:: devsite-article-body clearfix

   The recommended way to navigate between destinations is to use the
   Safe Args Gradle plugin. This plugin generates object and builder
   classes that enable type-safe navigation between destinations. Use
   Safe Args for navigating and `passing data between destinations <#Safe-args>`__.

   **Note:**\  If you aren't using Gradle, you must use other navigation
   methods.
   **Warning:**\  Safe Args is only available for Android views and
   fragments. If you are using Compose, see the guide on `type safe navigation <#>`__.

   .. rubric:: Enable Safe Args
      :name: enable

   To add `Safe Args <#Safe-args>`__
   to your project, include the following ``classpath`` in your top
   level ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               buildscript {
                   repositories {
                       google()
                   }
                   dependencies {
                       def nav_version = "2.7.7"
                       classpath "androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version"
                   }
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               buildscript {
                   repositories {
                       google()
                   }
                   dependencies {
                       val nav_version = "2.7.7"
                       classpath("androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version")
                   }
               }

   You must also apply one of two available plugins.

   To generate Java language code suitable for Java or mixed Java and
   Kotlin modules, add this line to **your app or module's**
   ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               plugins {
                 id 'androidx.navigation.safeargs'
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               plugins {
                   id("androidx.navigation.safeargs")
               }

   Alternatively, to generate Kotlin code suitable for Kotlin-only
   modules add:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               plugins {
                 id 'androidx.navigation.safeargs.kotlin'
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               plugins {
                   id("androidx.navigation.safeargs.kotlin")
               }

   You must have ``android.useAndroidX=true`` in your
   `gradle.properties`` file </studio/build#properties-files>`__ as
   per `Migrating to AndroidX <#migrate)>`__.

   .. rubric:: Generated code
      :name: generated

   After enabling Safe Args, your generated code contains classes and
   methods for each action you've defined as well as classes that
   correspond to each sending and receiving destination.

   Safe Args generates a class for each destination where an action
   originates. The generated class name adds "Directions" to the
   originating destination class name. For example, if the originating
   destination is named ``SpecifyAmountFragment``, the generated class
   is named ``SpecifyAmountFragmentDirections``.

   The generated class contains a static method for each action defined
   in the originating destination. This method takes any defined `action parameters <#>`__ as arguments
   and returns a
   `NavDirections <#>`__
   object that you can pass directly to
   `navigate() <#navigate>`__.

   .. rubric:: Safe Args example
      :name: example-safeargs

   For example, consider a navigation graph with a single action that
   connects two destinations, ``SpecifyAmountFragment`` and
   ``ConfirmationFragment``. The ``ConfirmationFragment`` takes a single
   ``float`` parameter that you provide as part of the action.

   Safe Args generates a ``SpecifyAmountFragmentDirections`` class with
   a single method,
   ``actionSpecifyAmountFragmentToConfirmationFragment()``, and an inner
   class called ``ActionSpecifyAmountFragmentToConfirmationFragment``.
   The inner class is derived from ``NavDirections`` and stores the
   associated action ID and ``float`` parameter. The returned
   ``NavDirections`` object can then be passed directly to
   ``navigate()``, as shown in the following example:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            override fun onClick(v: View) {
                val amount: Float = ...
                val action =
                    SpecifyAmountFragmentDirections
                        .actionSpecifyAmountFragmentToConfirmationFragment(amount)
                v.findNavController().navigate(action)
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            @Override
            public void onClick(View view) {
                float amount = ...;
                action =
                    SpecifyAmountFragmentDirections
                        .actionSpecifyAmountFragmentToConfirmationFragment(amount);
                Navigation.findNavController(view).navigate(action);
            }

   For more information about passing data between destinations with
   Safe Args, see `Use Safe Args to pass data with type safety <#Safe-args>`__.

   .. rubric:: Ensure type safety by using Safe Args
      :name: ensure_type_safety_by_using_safe_args

   Navigate between destinations using the Safe Args Gradle plugin. This
   plugin generates simple object and builder classes that enable
   type-safe navigation and argument passing between destinations.

   **Note:**\  For other ways to navigate, see `Navigate to a destination <#>`__.
   To add `Safe Args <#Safe-args>`__
   to your project, include the following ``classpath`` in your top
   level ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               buildscript {
                   repositories {
                       google()
                   }
                   dependencies {
                       def nav_version = "2.7.7"
                       classpath "androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version"
                   }
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               buildscript {
                   repositories {
                       google()
                   }
                   dependencies {
                       val nav_version = "2.7.7"
                       classpath("androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version")
                   }
               }

   You must also apply one of two available plugins.

   To generate Java language code suitable for Java or mixed Java and
   Kotlin modules, add this line to **your app or module's**
   ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               plugins {
                 id 'androidx.navigation.safeargs'
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               plugins {
                   id("androidx.navigation.safeargs")
               }

   Alternatively, to generate Kotlin code suitable for Kotlin-only
   modules add:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               plugins {
                 id 'androidx.navigation.safeargs.kotlin'
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               plugins {
                   id("androidx.navigation.safeargs.kotlin")
               }

   You must have ``android.useAndroidX=true`` in your
   `gradle.properties`` file </studio/build#properties-files>`__ as
   per `Migrating to AndroidX <#migrate)>`__.

   After you enable Safe Args, the plugin generates code that contains
   classes and methods for each action you've defined. For each action,
   Safe Args also generates a class for each *originating destination*,
   which is the destination from which the action originates. The
   generated class name is a combination of the originating destination
   class name and the word "Directions". For example, if the destination
   is named ``SpecifyAmountFragment``, the generated class is named
   ``SpecifyAmountFragmentDirections``. The generated class contains a
   static method for each action defined in the originating destination.
   This method takes any defined action parameters as arguments and
   returns a ``NavDirections`` object that you can pass to
   ``navigate()``.

   As an example, assume we have a navigation graph with a single action
   that connects the originating destination, ``SpecifyAmountFragment``,
   to a receiving destination, ``ConfirmationFragment``.

   Safe Args generates a ``SpecifyAmountFragmentDirections`` class with
   a single method,
   ``actionSpecifyAmountFragmentToConfirmationFragment()``, which
   returns a ``NavDirections`` object. This returned ``NavDirections``
   object can then be passed directly to ``navigate()``, as shown in the
   following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onClick(view: View) {
                   val action =
                       SpecifyAmountFragmentDirections
                           .actionSpecifyAmountFragmentToConfirmationFragment()
                   view.findNavController().navigate(action)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onClick(View view) {
                   NavDirections action =
                       SpecifyAmountFragmentDirections
                           .actionSpecifyAmountFragmentToConfirmationFragment();
                   Navigation.findNavController(view).navigate(action);
               }

   For more information on passing data between destinations with Safe
   Args, see `Use Safe Args to pass data with type safety <#Safe-args>`__ in *Pass
   data between destinations*.


Last updated 2024-05-01 UTC.


/Pass data between destinations
===============================

.. container:: devsite-article-body clearfix

   Navigation lets you attach data to a navigation operation by defining
   arguments for a destination. For example, a user profile destination
   might take a user ID argument to determine which user to display.

   In general, you should strongly prefer passing only the minimal
   amount of data between destinations. For example, you should pass a
   key to retrieve an object rather than passing the object itself, as
   the total space for all saved states is limited on Android. If you
   need to pass large amounts of data, use a
   `ViewModel <#>`__ as
   described in `ViewModel overview <#sharing>`__.

   .. rubric:: Define destination arguments
      :name: define_destination_arguments

   To pass data between destinations, first define the argument by
   adding it to the destination that receives it by following these
   steps:

   #. In the `Navigation Editor <#>`__, click the
      destination that receives the argument.

   #. In the **Attributes** panel, click **Add** (**+**).

   #. In the **Add Argument Link** window that appears, enter the
      argument name, argument type, whether the argument is nullable,
      and a default value, if needed.

   #. Click **Add**. Notice that the argument now appears in the
      **Arguments** list in the **Attributes** panel.

   #. Next, click the corresponding action that takes you to this
      destination. In the **Attributes** panel, you should now see your
      newly added argument in the **Argument Default Values** section.

   #. You can also see that the argument was added in XML. Click the
      **Text** tab to toggle to XML view, and notice that your argument
      was added to the destination that receives the argument. An
      example is shown in the following:

      .. code:: prettyprint

          <fragment android:id="@+id/myFragment" >
              <argument
                  android:name="myArg"
                  app:argType="integer"
                  android:defaultValue="0" />
          </fragment>

   .. rubric:: Supported argument types
      :name: supported_argument_types

   The Navigation library supports the following argument types:

   .. list-table::
      :header-rows: 1

      - 

         - Type
         - app:argType syntax
         - Support for default values
         - Handled by routes
         - Nullable
      - 

         - Integer
         - app:argType="integer"
         - Yes
         - Yes
         - No
      - 

         - Float
         - app:argType="float"
         - Yes
         - Yes
         - No
      - 

         - Long
         - app:argType="long"
         - Yes - Default values must always end with an 'L' suffix (e.g.
            "123L").
         - Yes
         - No
      - 

         - Boolean
         - app:argType="boolean"
         - Yes - "true" or "false"
         - Yes
         - No
      - 

         - String
         - app:argType="string"
         - Yes
         - Yes
         - Yes
      - 

         - Resource Reference
         - app:argType="reference"
         - Yes - Default values must be in the form of
            "@resourceType/resourceName" (e.g. "@style/myCustomStyle")
            or "0"
         - Yes
         - No
      - 

         - Custom Parcelable
         - app:argType="<type>", where <type> is the fully-qualified
            class name of the ``Parcelable``
         - Supports a default value of "@null". Does not support other
            default values.
         - No
         - Yes
      - 

         - Custom Serializable
         - app:argType="<type>", where <type> is the fully-qualified
            class name of the ``Serializable``
         - Supports a default value of "@null". Does not support other
            default values.
         - No
         - Yes
      - 

         - Custom Enum
         - app:argType="<type>", where <type> is the fully-qualified
            name of the enum
         - Yes - Default values must match the unqualified name (e.g.
            "SUCCESS" to match MyEnum.SUCCESS).
         - No
         - No

   **Note:**\  References to resources are supported *only* in reference
   types. Using a resource reference in any other type results in an
   exception.
   If an argument type supports null values, you can declare a default
   value of null by using ``android:defaultValue="@null"``.

   Routes, deep links, and URIs with their arguments can be parsed from
   strings. This is not possible using custom data types such as
   Parcelables and Serializables as seen in the preceding table. To pass
   around custom complex data, store the data elsewhere such as a
   ViewModel or database and only pass an identifier while navigating;
   then retrieve the data in the new location after navigation has
   concluded.

   When you choose one of the custom types, the **Select Class** dialog
   appears and prompts you to choose the corresponding class for that
   type. The **Project** tab lets you choose a class from your current
   project.

   You can choose **<inferred type>** to have the Navigation library
   determine the type based on the provided value.

   You can check **Array** to indicate that the argument should be an
   array of the selected **Type** value. Note the following:

   -  Arrays of enums and arrays of resource references are not
      supported.
   -  Arrays support nullable values, regardless of the support for
      nullable values of the underlying type. For example, using
      ``app:argType="integer[]"`` lets you use ``app:nullable="true"``
      to indicate that passing a null array is acceptable.
   -  Arrays support a single default value, "@null". Arrays don't
      support any other default value.

   **Caution:**\  Passing complex data structures over arguments is
   considered an poor practice. Each destination should be responsible
   for loading UI data based on the minimum necessary information, such
   as item IDs. This simplifies process recreation and avoids potential
   data inconsistencies.

   .. rubric:: Override a destination argument in an action
      :name: override_a_destination_argument_in_an_action

   Destination-level arguments and default values are used by all
   actions that navigate to the destination. If needed, you can override
   the default value of an argument (or set one if it doesn't already
   exist) by defining an argument at the action level. This argument
   must be of the same name and type as the argument declared in the
   destination.

   The following XML declares an action with an argument that overrides
   the destination-level argument from the preceding example:

   .. code:: prettyprint

      <action android:id="@+id/startMyFragment"
          app:destination="@+id/myFragment">
          <argument
              android:name="myArg"
              app:argType="integer"
              android:defaultValue="1" />
      </action>

   .. rubric:: Use Safe Args to pass data with type safety
      :name: Safe-args

   The Navigation component has a Gradle plugin called Safe Args that
   generates simple object and builder classes for type-safe navigation
   and access to any associated arguments. Safe Args is strongly
   recommended for navigating and passing data, because it ensures type
   safety.

   If you are not using Gradle, you can't use the Safe Args plugin. In
   these cases, you can `use Bundles <#bundle>`__ to directly pass data.

   To add `Safe Args <#Safe-args>`__
   to your project, include the following ``classpath`` in your top
   level ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               buildscript {
                   repositories {
                       google()
                   }
                   dependencies {
                       def nav_version = "2.7.7"
                       classpath "androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version"
                   }
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               buildscript {
                   repositories {
                       google()
                   }
                   dependencies {
                       val nav_version = "2.7.7"
                       classpath("androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version")
                   }
               }

   You must also apply one of two available plugins.

   To generate Java language code suitable for Java or mixed Java and
   Kotlin modules, add this line to **your app or module's**
   ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               plugins {
                 id 'androidx.navigation.safeargs'
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               plugins {
                   id("androidx.navigation.safeargs")
               }

   Alternatively, to generate Kotlin code suitable for Kotlin-only
   modules add:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               plugins {
                 id 'androidx.navigation.safeargs.kotlin'
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               plugins {
                   id("androidx.navigation.safeargs.kotlin")
               }

   You must have ``android.useAndroidX=true`` in your
   `gradle.properties`` file </studio/build#properties-files>`__ as
   per `Migrating to AndroidX <#migrate)>`__.

   After you've enabled Safe Args, your generated code contains the
   following type safe classes and methods for each action as well as
   with each sending and receiving destination.

   -  A class is created for each destination where an action
      originates. The name of this class is the name of the originating
      destination appended with the word "Directions". For example, if
      the originating destination is a fragment that is named
      ``SpecifyAmountFragment``, the generated class is called
      ``SpecifyAmountFragmentDirections``.

      This class has a method for each action defined in the originating
      destination.

   -  For each action used to pass the argument, an inner class is
      created whose name is based on the action. For example, if the
      action is called ``confirmationAction,`` the class is named
      ``ConfirmationAction``. If your action contains arguments without
      a ``defaultValue``, then you use the associated action class to
      set the value of the arguments.

   -  A class is created for the receiving destination. The name of this
      class is the name of the destination appended with the word
      "Args". For example, if the destination fragment is named
      ``ConfirmationFragment,`` the generated class is called
      ``ConfirmationFragmentArgs``. Use this class's ``fromBundle()``
      method to retrieve the arguments.

   The following example shows you how to use these methods to set an
   argument and pass it to the
   `navigate() <#navigate>`__
   method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onClick(v: View) {
                  val amountTv: EditText = view!!.findViewById(R.id.editTextAmount)
                  val amount = amountTv.text.toString().toInt()
                  val action = SpecifyAmountFragmentDirections.confirmationAction(amount)
                  v.findNavController().navigate(action)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onClick(View view) {
                  EditText amountTv = (EditText) getView().findViewById(R.id.editTextAmount);
                  int amount = Integer.parseInt(amountTv.getText().toString());
                  ConfirmationAction action =
                          SpecifyAmountFragmentDirections.confirmationAction();
                  action.setAmount(amount);
                  Navigation.findNavController(view).navigate(action);
               }

   In the code for the receiving destination, use the
   `getArguments() <#getArguments>`__
   method to retrieve the bundle and use its contents. When using the
   ``-ktx`` dependencies, Kotlin users can also use the ``by navArgs()``
   property delegate to access arguments.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val args: ConfirmationFragmentArgs by navArgs()

               override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                   val tv: TextView = view.findViewById(R.id.textViewAmount)
                   val amount = args.amount
                   tv.text = amount.toString()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
                   TextView tv = view.findViewById(R.id.textViewAmount);
                   int amount = ConfirmationFragmentArgs.fromBundle(getArguments()).getAmount();
                   tv.setText(amount + "");
               }

   .. rubric:: Use Safe Args with a global action
      :name: safe-args-global

   When using Safe Args with a `global action <#>`__,
   you must provide an ``android:id`` value for your root
   ``<navigation>`` element, as shown in the following example:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:app="http://schemas.android.com/apk/res-auto"
                  xmlns:tools="http://schemas.android.com/tools"
                  xmlns:android="http://schemas.android.com/apk/res/android"
                  android:id="@+id/main_nav"
                  app:startDestination="@id/mainFragment">

          ...

      </navigation>

   Navigation generates a ``Directions`` class for the ``<navigation>``
   element that is based on the ``android:id`` value. For example, if
   you have a ``<navigation>`` element with
   ``android:id=@+id/main_nav``, the generated class is called
   ``MainNavDirections``. All destinations within the ``<navigation>``
   element have generated methods for accessing all associated global
   actions using the same methods as described in the previous section.

   .. rubric:: Pass data between destinations with Bundle objects
      :name: bundle

   If you aren't using Gradle, you can still pass arguments between
   destinations by using ``Bundle`` objects. Create a ``Bundle`` object
   and pass it to the destination using
   `navigate() <#navigate>`__,
   as in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val bundle = bundleOf("amount" to amount)
               view.findNavController().navigate(R.id.confirmationAction, bundle)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Bundle bundle = new Bundle();
               bundle.putString("amount", amount);
               Navigation.findNavController(view).navigate(R.id.confirmationAction, bundle);

   In your receiving destination's code, use the
   `getArguments() <#getArguments>`__
   method to retrieve the ``Bundle`` and use its contents:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val tv = view.findViewById<TextView>(R.id.textViewAmount)
               tv.text = arguments?.getString("amount")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               TextView tv = view.findViewById(R.id.textViewAmount);
               tv.setText(getArguments().getString("amount"));

   .. rubric:: Pass data to the start destination
      :name: start

   You can pass data to your app's start destination. First, you must
   explicitly construct a `Bundle <#>`__
   that holds the data. Next, use one of the following approaches to
   pass the ``Bundle`` to the start destination:

   -  If you're creating your ``NavHost`` programmatically, call
      `NavHostFragment.create(R.navigation.graph, args) <#create>`__,
      where ``args`` is the ``Bundle`` that holds your data.
   -  Otherwise, you can set start destination arguments by calling one
      of the following overloads of ``NavController.setGraph()``:

      -  Use the ID of the graph:
         `navController.setGraph(R.navigation.graph, args) <#setGraph>`__
      -  Use the graph itself:
         `navController.setGraph(navGraph, args) <#setGraph>`__

   To retrieve the data in your start destination, call
   `Fragment.getArguments() <#getArguments>`__.

   **Note:**\  when manually calling ``setGraph()`` with arguments, you
   must **not** use the ``app:navGraph`` attribute when creating the
   ``NavHostFragment`` in XML as that internally calls ``setGraph()``
   without any arguments, resulting in your graph and start destination
   being created twice.

   .. rubric:: ProGuard considerations
      :name: proguard_considerations

   If you are `shrinking your code <#>`__, you
   need to prevent your ``Parcelable``, ``Serializable``, and ``Enum``
   class names from being obfuscated as part of the minification
   process. You can do this in one of two ways:

   -  Use @Keep annotations.
   -  Use keepnames rules.

   The following subsections outline these approaches.

   .. rubric:: Use @Keep annotations
      :name: use_keep_annotations

   The following example adds
   `@Keep <#>`__
   annotations to model class definitions:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Keep class ParcelableArg : Parcelable { ... }

               @Keep class SerializableArg : Serializable { ... }

               @Keep enum class EnumArg { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Keep public class ParcelableArg implements Parcelable { ... }

               @Keep public class SerializableArg implements Serializable { ... }

               @Keep public enum EnumArg { ... }

   .. rubric:: Use keepnames rules
      :name: use_keepnames_rules

   You can also add ``keepnames`` rules to your ``proguard-rules.pro``
   file, as shown in the following example:

   *proguard-rules.pro*

   .. code:: devsite-click-to-copy

      ...

      -keepnames class com.path.to.your.ParcelableArg
      -keepnames class com.path.to.your.SerializableArg
      -keepnames class com.path.to.your.EnumArg

      ...

   .. rubric:: Additional resources
      :name: additional_resources

   To learn more about navigation, consult the following additional
   resources.

   .. rubric:: Samples
      :name: samples

   -  `NavigationBasicSample <https://github.com/android/architecture-components-samples/tree/main/NavigationBasicSample>`__

   .. rubric:: Codelabs
      :name: codelabs

   -  `Learn Jetpack Navigation <https://developers.google.cn/codelabs/codelabs/android-navigation/>`__

   .. rubric:: Videos
      :name: videos

   -  `Android Jetpack: Manage UI navigation with navigation controller (Google I/O '18) <https://www.youtube.com/watch?v=8GCXtCjtg40%22>`__


Last updated 2024-05-01 UTC.


/Animate transitions between destinations
=========================================

.. container:: devsite-article-body clearfix

   The Navigation component lets you add both property and view
   animations to actions. To create your own animations, check out
   `Animation resources <#>`__.

   Navigation also includes several default animations to get you
   started. To add animations to an action, do the following:

   #. In the Navigation editor, click on the action where the animation
      should occur.
   #. In the **Animations** section of the **Attributes** panel, click
      the dropdown arrow next to the animation you'd like to add. You
      can choose between the following types:

      -  Entering a destination
      -  Exiting a destination
      -  Entering a destination via a `pop action <#pop>`__, an
         action that pops additional destinations off of the back stack
         when navigating.
      -  Exiting a destination via a pop action

   #. Choose an animation from the list of project animations that
      appears.

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/animation-attributes.png
      :alt: the animations section of the attributes panel

      **Figure 1.** The **Animations** section of the **Attributes**
      panel.

   Once you've added animations, click the **Text** tab to toggle to the
   XML text view. The XML for the animations now appears in the
   corresponding ``<action>`` element. In the following example,
   ``specifyAmountFragment`` is the source destination for the
   ``confirmationAction`` action:

   .. code:: prettyprint

      <fragment
          android:id="@+id/specifyAmountFragment"
          android:name="com.example.buybuddy.buybuddy.SpecifyAmountFragment"
          android:label="fragment_specify_amount"
          tools:layout="@layout/fragment_specify_amount">
          <action
              android:id="@+id/confirmationAction"
              app:destination="@id/confirmationFragment"
              app:enterAnim="@anim/slide_in_right"
              app:exitAnim="@anim/slide_out_left"
              app:popEnterAnim="@anim/slide_in_left"
              app:popExitAnim="@anim/slide_out_right" />
      </fragment>

   .. rubric:: Add shared element transitions between destinations
      :name: shared-element

   When a view is shared between two destinations, you can use a *shared
   element transition* to define how the view transitions when
   navigating from one destination to the other. Shared element
   transitions are part of the Transition Framework.

   **Note:**\  When using shared elements transitions, you should
   **not** use the Animation Framework (``enterAnim``, ``exitAnim``, and
   so on from the previous section). Instead, you should be using only
   the Transition Framework for setting your enter and exit transitions.
   Shared elements are supplied programmatically rather than through
   your navigation XML file. Activity and fragment destinations each
   have a subclass of the
   `Navigator.Extras <#>`__
   interface that accepts additional options for navigation, including
   shared elements. You can pass these ``Extras`` when calling
   `navigate() <#navigate>`__.

   **Note:**\  Be sure to familiarize yourself with shared element
   transitions before continuing. For fragment shared element
   transitions, see `Navigate between fragments using animations <#>`__. For activity
   shared element transitions, see `Start an activity using an animation <#start-with-element>`__.

   .. rubric:: Shared element transitions to a fragment destination
      :name: set-fragment

   The
   `FragmentNavigator.Extras <#>`__
   class allows you to map shared elements from one destination to the
   next by their transition name, similar to using
   `FragmentTransaction.addSharedElement() <#addSharedElement>`__.
   You can then pass the extras to ``navigate()``, as shown in the
   following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val extras = FragmentNavigatorExtras(view1 to "hero_image")

               view.findNavController().navigate(
                   R.id.confirmationAction,
                   null, // Bundle of args
                   null, // NavOptions
                   extras)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               FragmentNavigator.Extras extras = new FragmentNavigator.Extras.Builder()
                   .addSharedElement(view1, "hero_image")
                   .build();

               Navigation.findNavController(view).navigate(
                   R.id.details,
                   null, // Bundle of args
                   null, // NavOptions
                   extras);

   .. rubric:: Shared element transitions to an activity destination
      :name: set-activity

   Activities rely on
   `ActivityOptionsCompat <https://developer.android.google.cn/reference/androidx/core/app/ActivityOptionsCompat>`__
   to control Shared Element Transitions as detailed in the `Start an activity with a shared element <https://developer.android.google.cn/training/transitions/start-activity#start-transition>`__
   documentation and as shown in the example below:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Rename the Pair class from the Android framework to avoid a name clash
               import android.util.Pair as UtilPair
               ...
               val options = ActivityOptionsCompat.makeSceneTransitionAnimation(activity,
                       UtilPair.create(view1, "hero_image"))
               val extras = ActivityNavigatorExtras(options)
               view.findNavController().navigate(
                   R.id.details,
                   null, // Bundle of args
                   null, // NavOptions
                   extras)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(this,
                       Pair.create(view1, "hero_image"));

               ActivityNavigatorExtras extras = new ActivityNavigatorExtras.Builder()
                   .setActivityOptions(options)
                   .build();


               Navigation.findNavController(view).navigate(
                   R.id.details,
                   null, // Bundle of args
                   null, // NavOptions
                   extras);

   .. rubric:: Apply pop animations to activity transitions
      :name: activity

   When you navigate to or from an ``Activity``, pop animations are not
   applied automatically. Instead, you must call
   `ActivityNavigator.applyPopAnimationsToPendingTransition() <#applyPopAnimationsToPendingTransition>`__
   from the target ``Activity`` destination where the animation should
   occur:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun finish() {
                   super.finish()
                   ActivityNavigator.applyPopAnimationsToPendingTransition(this)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void finish() {
                   super.finish();
                   ActivityNavigator.applyPopAnimationsToPendingTransition(this);
               }


Last updated 2024-01-03 UTC.


/Conditional navigation
=======================

.. container:: devsite-article-body clearfix

   When designing navigation for your app, you might want to navigate to
   one destination versus another based on conditional logic. For
   example, a user might follow a deep link to a destination that
   requires the user to be logged in, or you might have different
   destinations in a game for when the player wins or loses.

   .. rubric:: User login
      :name: login

   In this example, a user attempts to navigate to a profile screen that
   requires authentication. Because this action requires authentication,
   the user should be redirected to a login screen if they are not
   already authenticated.

   The navigation graph for this example might look something like this:

   .. figure::
      https://developer.android.google.cn/static/images/guide/navigation/navigation-conditional-login.png
      :alt: a login flow is handled independently from the app's main
      navigation flow.
      :width: 600px

      **Figure 1.** A login flow is handled independently from the app's
      main navigation flow.

   To authenticate, the app must navigate to the ``login_fragment``,
   where the user can enter a username and password to authenticate. If
   accepted, the user is sent back to the ``profile_fragment`` screen.
   If not accepted, the user is informed that their credentials are
   invalid using a
   `Snackbar <#>`__.
   If the user navigates back to the profile screen without logging in,
   they are sent to the ``main_fragment`` screen.

   **Note:**\  The architecture of this app follows the pattern
   described in the `Guide to App Architecture <#>`__.
   It uses a `ViewModel <#>`__
   and
   `LiveData <https://developer.android.google.cn/topic/libraries/architecture/livedata>`__
   and follows a single-activity structure. Be sure that you're familiar
   with these classes before proceeding.
   Here's the navigation graph for this app:

   .. code:: prettyprint

      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:app="http://schemas.android.com/apk/res-auto"
              xmlns:tools="http://schemas.android.com/tools"
              android:id="@+id/nav_graph"
              app:startDestination="@id/main_fragment">
          <fragment
                  android:id="@+id/main_fragment"
                  android:name="com.google.android.conditionalnav.MainFragment"
                  android:label="fragment_main"
                  tools:layout="@layout/fragment_main">
              <action
                      android:id="@+id/navigate_to_profile_fragment"
                      app:destination="@id/profile_fragment"/>
          </fragment>
          <fragment
                  android:id="@+id/login_fragment"
                  android:name="com.google.android.conditionalnav.LoginFragment"
                  android:label="login_fragment"
                  tools:layout="@layout/login_fragment"/>
          <fragment
                  android:id="@+id/profile_fragment"
                  android:name="com.google.android.conditionalnav.ProfileFragment"
                  android:label="fragment_profile"
                  tools:layout="@layout/fragment_profile"/>
      </navigation>

   ``MainFragment`` contains a button that the user can click to view
   their profile. If the user wants to see the profile screen, they must
   first authenticate. This interaction is modeled using two separate
   fragments, but it depends on shared user state. This state
   information is not the responsibility of either of these two
   fragments and is more appropriately held in a shared
   ``UserViewModel``. This ``ViewModel`` is shared between the fragments
   by scoping it to the activity, which implements
   ``ViewModelStoreOwner``. In the following example,
   ``requireActivity()`` resolves to ``MainActivity``, because
   ``MainActivity`` hosts ``ProfileFragment``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ProfileFragment : Fragment() {
                   private val userViewModel: UserViewModel by activityViewModels()
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ProfileFragment extends Fragment {
                   private UserViewModel userViewModel;
                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       super.onViewCreated(view, savedInstanceState);
                       userViewModel = new ViewModelProvider(requireActivity()).get(UserViewModel.class);
                       ...
                   }
                   ...
               }

   The user data in ``UserViewModel`` is exposed via ``LiveData``, so to
   decide where to navigate, you should observe this data. Upon
   navigating to ``ProfileFragment``, the app shows a welcome message if
   the user data is present. If the user data is ``null``, you then
   navigate to ``LoginFragment``, since the user needs to authenticate
   before seeing their profile. Define the deciding logic in your
   ``ProfileFragment``, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ProfileFragment : Fragment() {
                   private val userViewModel: UserViewModel by activityViewModels()

                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       super.onViewCreated(view, savedInstanceState)
                       val navController = findNavController()
                       userViewModel.user.observe(viewLifecycleOwner, Observer { user ->
                           if (user != null) {
                               showWelcomeMessage()
                           } else {
                               navController.navigate(R.id.login_fragment)
                           }
                       })
                   }

                   private fun showWelcomeMessage() {
                       ...
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ProfileFragment extends Fragment {
                   private UserViewModel userViewModel;

                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       super.onViewCreated(view, savedInstanceState);
                       userViewModel = new ViewModelProvider(requireActivity()).get(UserViewModel.class);
                       final NavController navController = Navigation.findNavController(view);
                       userViewModel.user.observe(getViewLifecycleOwner(), (Observer<User>) user -> {
                           if (user != null) {
                               showWelcomeMessage();
                           } else {
                               navController.navigate(R.id.login_fragment);
                           }
                       });
                   }

                   private void showWelcomeMessage() {
                       ...
                   }
               }

   If the user data is ``null`` when they reach the ``ProfileFragment``,
   they are redirected to the ``LoginFragment``.

   You can use
   `NavController.getPreviousBackStackEntry() <#getPreviousBackStackEntry>`__
   to retrieve the
   `NavBackStackEntry <#>`__
   for the previous destination, which encapsulates the
   ``NavController``-specific state for the destination.
   ``LoginFragment`` uses the
   `SavedStateHandle <#>`__
   of the previous ``NavBackStackEntry`` to set an initial value
   indicating whether the user has successfully logged in. This is the
   state we would want to return if the user were to immediately press
   the system back button. Setting this state using ``SavedStateHandle``
   ensures that the state persists through process death.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class LoginFragment : Fragment() {
                   companion object {
                       const val LOGIN_SUCCESSFUL: String = "LOGIN_SUCCESSFUL"
                   }

                   private val userViewModel: UserViewModel by activityViewModels()
                   private lateinit var savedStateHandle: SavedStateHandle

                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       savedStateHandle = findNavController().previousBackStackEntry!!.savedStateHandle
                       savedStateHandle.set(LOGIN_SUCCESSFUL, false)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class LoginFragment extends Fragment {
                   public static String LOGIN_SUCCESSFUL = "LOGIN_SUCCESSFUL"

                   private UserViewModel userViewModel;
                   private SavedStateHandle savedStateHandle;

                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       userViewModel = new ViewModelProvider(requireActivity()).get(UserViewModel.class);

                       savedStateHandle = Navigation.findNavController(view)
                               .getPreviousBackStackEntry()
                               .getSavedStateHandle();
                       savedStateHandle.set(LOGIN_SUCCESSFUL, false);
                   }
               }

   Once the user enters a username and password, they are passed to the
   ``UserViewModel`` for authentication. If authentication is
   successful, the ``UserViewModel`` stores the user data. The
   ``LoginFragment`` then updates the ``LOGIN_SUCCESSFUL`` value on the
   ``SavedStateHandle`` and pops itself off of the back stack.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class LoginFragment : Fragment() {
                   companion object {
                       const val LOGIN_SUCCESSFUL: String = "LOGIN_SUCCESSFUL"
                   }

                   private val userViewModel: UserViewModel by activityViewModels()
                   private lateinit var savedStateHandle: SavedStateHandle

                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       savedStateHandle = findNavController().previousBackStackEntry!!.savedStateHandle
                       savedStateHandle.set(LOGIN_SUCCESSFUL, false)

                       val usernameEditText = view.findViewById(R.id.username_edit_text)
                       val passwordEditText = view.findViewById(R.id.password_edit_text)
                       val loginButton = view.findViewById(R.id.login_button)

                       loginButton.setOnClickListener {
                           val username = usernameEditText.text.toString()
                           val password = passwordEditText.text.toString()
                           login(username, password)
                       }
                   }

                   fun login(username: String, password: String) {
                       userViewModel.login(username, password).observe(viewLifecycleOwner, Observer { result ->
                           if (result.success) {
                               savedStateHandle.set(LOGIN_SUCCESSFUL, true)
                               findNavController().popBackStack()
                           } else {
                               showErrorMessage()
                           }
                       })
                   }

                   fun showErrorMessage() {
                       // Display a snackbar error message
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class LoginFragment extends Fragment {
                   public static String LOGIN_SUCCESSFUL = "LOGIN_SUCCESSFUL"

                   private UserViewModel userViewModel;
                   private SavedStateHandle savedStateHandle;

                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       userViewModel = new ViewModelProvider(requireActivity()).get(UserViewModel.class);

                       savedStateHandle = Navigation.findNavController(view)
                               .getPreviousBackStackEntry()
                               .getSavedStateHandle();
                       savedStateHandle.set(LOGIN_SUCCESSFUL, false);

                       EditText usernameEditText = view.findViewById(R.id.username_edit_text);
                       EditText passwordEditText = view.findViewById(R.id.password_edit_text);
                       Button loginButton = view.findViewById(R.id.login_button);

                       loginButton.setOnClickListener(v -> {
                           String username = usernameEditText.getText().toString();
                           String password = passwordEditText.getText().toString();
                           login(username, password);
                       });
                   }

                   private void login(String username, String password) {
                       userViewModel.login(username, password).observe(viewLifecycleOwner, (Observer<LoginResult>) result -> {
                           if (result.success) {
                               savedStateHandle.set(LOGIN_SUCCESSFUL, true);
                               NavHostFragment.findNavController(this).popBackStack();
                           } else {
                               showErrorMessage();
                           }
                       });
                   }

                   private void showErrorMessage() {
                       // Display a snackbar error message
                   }
               }

   Note that all logic pertaining to authentication is held within
   ``UserViewModel``. This is important, as it is not the responsibility
   of either ``LoginFragment`` or ``ProfileFragment`` to determine how
   users are authenticated. Encapsulating your logic in a ``ViewModel``
   makes it not only easier to share but also easier to test. If your
   navigation logic is complex, you should especially verify this logic
   through testing. See the `Guide to app architecture <#>`__ for more information on
   structuring your app‚Äôs architecture around testable components.

   Back in the ``ProfileFragment``, the ``LOGIN_SUCCESSFUL`` value
   stored in the ``SavedStateHandle`` can be observed in the
   `onCreate() <#onCreate>`__
   method. When the user returns to the ``ProfileFragment``, the
   ``LOGIN_SUCCESSFUL`` value will be checked. If the value is
   ``false``, the user can be redirected back to the ``MainFragment``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ProfileFragment : Fragment() {
                   ...

                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)

                       val navController = findNavController()

                       val currentBackStackEntry = navController.currentBackStackEntry!!
                       val savedStateHandle = currentBackStackEntry.savedStateHandle
                       savedStateHandle.getLiveData<Boolean>(LoginFragment.LOGIN_SUCCESSFUL)
                               .observe(currentBackStackEntry, Observer { success ->
                                   if (!success) {
                                       val startDestination = navController.graph.startDestination
                                       val navOptions = NavOptions.Builder()
                                               .setPopUpTo(startDestination, true)
                                               .build()
                                       navController.navigate(startDestination, null, navOptions)
                                   }
                               })
                   }

                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ProfileFragment extends Fragment {
                   ...

                   @Override
                   public void onCreate(@Nullable Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);

                       NavController navController = NavHostFragment.findNavController(this);

                       NavBackStackEntry navBackStackEntry = navController.getCurrentBackStackEntry();
                       SavedStateHandle savedStateHandle = navBackStackEntry.getSavedStateHandle();
                       savedStateHandle.getLiveData(LoginFragment.LOGIN_SUCCESSFUL)
                               .observe(navBackStackEntry, (Observer<Boolean>) success -> {
                                   if (!success) {
                                       int startDestination = navController.getGraph().getStartDestination();
                                       NavOptions navOptions = new NavOptions.Builder()
                                               .setPopUpTo(startDestination, true)
                                               .build();
                                       navController.navigate(startDestination, null, navOptions);
                                   }
                               });
                   }

                   ...
               }

   If the user successfully logged in, the ``ProfileFragment`` displays
   a welcome message.

   The technique used here of checking the result allows you to
   distinguish between two different cases:

   -  The initial case, where the user is not logged in and should be
      asked to login.
   -  The user is not logged in because **they chose not to login** (a
      result of ``false``).

   By distinguishing these use cases, you can avoid repeatedly asking
   the user to login. The business logic for handling failure cases is
   left to you and might include displaying an overlay that explains why
   the user needs to login, finishing the entire activity, or
   redirecting the user to a destination that does not require login, as
   was the case in the previous code example.


Last updated 2024-01-03 UTC.


/Interact programmatically with the Navigation component
========================================================

.. container:: devsite-article-body clearfix

   The Navigation component provides ways to programmatically create and
   interact with certain navigation elements.

   .. rubric:: Create a NavHostFragment
      :name: create_a_navhostfragment

   You can use
   `NavHostFragment.create() <#create>`__
   to programmatically create a ``NavHostFragment`` with a specific
   graph resource, as shown in the example below:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val finalHost = NavHostFragment.create(R.navigation.example_graph)
               supportFragmentManager.beginTransaction()
                   .replace(R.id.nav_host, finalHost)
                   .setPrimaryNavigationFragment(finalHost) // equivalent to app:defaultNavHost="true"
                   .commit()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               NavHostFragment finalHost = NavHostFragment.create(R.navigation.example_graph);
               getSupportFragmentManager().beginTransaction()
                   .replace(R.id.nav_host, finalHost)
                   .setPrimaryNavigationFragment(finalHost) // equivalent to app:defaultNavHost="true"
                   .commit();

   Note that ``setPrimaryNavigationFragment(finalHost)`` lets your
   ``NavHost`` intercept system Back button presses. You can also
   implement this behavior in your ``NavHost`` XML by adding
   ``app:defaultNavHost="true"``. If you're implementing `custom Back button behavior <#>`__
   and don't want your ``NavHost`` intercepting Back button presses, you
   can pass ``null`` to ``setPrimaryNavigationFragment()``.

   .. rubric:: Reference a destination using NavBackStackEntry
      :name: navbackstackentry

   Starting with Navigation 2.2.0, you can get a reference to the
   `NavBackStackEntry <#>`__
   for any destination on the navigation stack by calling
   `NavController.getBackStackEntry() <#getBackStackEntry>`__,
   passing it a destination ID. If the back stack contains more than one
   instance of the specified destination, ``getBackStackEntry()``
   returns the topmost instance from the stack.

   The returned ``NavBackStackEntry`` provides a
   `Lifecycle <#>`__, a
   `ViewModelStore <#>`__,
   and a
   `SavedStateRegistry <#>`__
   at the destination level. These objects are valid for the lifetime of
   the destination on the back stack. When the associated destination is
   popped off the back stack, the ``Lifecycle`` is destroyed, the state
   is no longer saved, and any ``ViewModel`` objects are cleared.

   These properties give you a ``Lifecycle`` and a store for
   ``ViewModel`` objects and classes that work with `saved state <#>`__ no
   matter what type of destination you use. This is especially useful
   when working with destination types which do not automatically have
   an associated ``Lifecycle``, such as custom destinations.

   For example, you can observe the ``Lifecycle`` of a
   ``NavBackStackEntry`` just as you would observe the ``Lifecycle`` of
   a fragment or activity. In addition, ``NavBackStackEntry`` is a
   ``LifecycleOwner``, which means that you can use it when observing
   ``LiveData`` or with other lifecycle-aware components, as shown in
   the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               myViewModel.liveData.observe(backStackEntry, Observer { myData ->
                   // react to live data update
               })

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               myViewModel.getLiveData().observe(backStackEntry, myData -> {
                   // react to live data update
               });

   Lifecycle state automatically updates whenever you call
   ``navigate()``. Lifecycle states for destinations that are not at the
   top of the back stack move from ``RESUMED`` to ``STARTED`` if the
   destinations are still visible under a ``FloatingWindow``
   destination, such as a dialog destination, or to ``STOPPED``
   otherwise.

   .. rubric:: Returning a result to the previous Destination
      :name: returning_a_result

   In Navigation 2.3 and higher, ``NavBackStackEntry`` gives access to a
   `SavedStateHandle <#>`__.
   A ``SavedStateHandle`` is a key-value map that can be used to store
   and retrieve data. These values persist through process death,
   including configuration changes, and remain available through the
   same object. By using the given ``SavedStateHandle``, you can access
   and pass data between destinations. This is especially useful as a
   mechanism to get data back from a destination after it is popped off
   the stack.

   To pass data back to Destination A from Destination B, first set up
   Destination A to listen for a result on its ``SavedStateHandle``. To
   do so, retrieve the ``NavBackStackEntry`` by using the
   ``getCurrentBackStackEntry()`` API and then ``observe`` the
   ``LiveData`` provided by ``SavedStateHandle``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                   val navController = findNavController();
                   // We use a String here, but any type that can be put in a Bundle is supported
                   navController.currentBackStackEntry?.savedStateHandle?.getLiveData<String>("key")?.observe(
                       viewLifecycleOwner) { result ->
                       // Do something with the result.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                   NavController navController = NavHostFragment.findNavController(this);
                   // We use a String here, but any type that can be put in a Bundle is supported
                   MutableLiveData<String> liveData = navController.getCurrentBackStackEntry()
                           .getSavedStateHandle()
                           .getLiveData("key");
                   liveData.observe(getViewLifecycleOwner(), new Observer<String>() {
                       @Override
                       public void onChanged(String s) {
                           // Do something with the result.
                       }
                   });
               }

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/nav-for-result.png
      name: nav-for-result
      :alt: Destination B can use getPreviousBackStackEntry() to
      retrieve the NavBackStackEntry for the previous destination A
      :width: 750px

      **Figure 1.** Destination B can use getPreviousBackStackEntry() to
      access the NavBackStackEntry for the previous destination A.

   In Destination B, you must ``set`` the result on the
   ``SavedStateHandle`` of Destination A by using the
   ``getPreviousBackStackEntry()`` API.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               navController.previousBackStackEntry?.savedStateHandle?.set("key", result)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               navController.getPreviousBackStackEntry().getSavedStateHandle().set("key", result);

   **Note:**\  Since ``NavBackStackEntry`` uses ``SavedStateHandle``,
   all results must be of a type that you can place in a
   `Bundle <#>`__. To save results of
   custom types that are not ``Parcelable`` or ``Serializable``, create
   a ``ViewModel`` using the ``ViewModelStore`` from the previous
   ``NavBackStackEntry``. For instructions on using ViewModels see the
   `ViewModel guide <#>`__.
   If you‚Äôd only like to handle a result only once, you must call
   `remove() <#remove>`__
   on the ``SavedStateHandle`` to clear the result. If you do not remove
   the result, the ``LiveData`` will continue to return the last result
   to any new ``Observer`` instances.

   .. rubric:: Considerations when using dialog destinations
      :name: additional_considerations

   When you ``navigate`` to a destination that takes the full view of
   the ``NavHost`` (such as a ``<fragment>`` destination), the previous
   destination has its lifecycle stopped, preventing any callbacks to
   the ``LiveData`` provided by ``SavedStateHandle``.

   However, when navigating to a `dialog destination <#create-dialog>`__,
   the previous destination is also visible on the screen and is
   therefore also ``STARTED`` despite not being the current destination.
   This means that calls to ``getCurrentBackStackEntry()`` from within
   lifecycle methods such as ``onViewCreated()`` will return the
   ``NavBackStackEntry`` of the dialog destination after a configuration
   change or process death and recreation (since the dialog is restored
   above the other destination). Therefore you should use
   `getBackStackEntry() <#getBackStackEntry>`__
   with the ID of your destination to ensure that you always use the
   correct ``NavBackStackEntry``.

   This also means that any ``Observer`` you set on the result
   ``LiveData`` will be triggered even while the dialog destinations is
   still on the screen. If you only want to check the result when the
   dialog destination is closed and the underlying destination becomes
   the current destination, you can observe the ``Lifecycle`` associated
   with the ``NavBackStackEntry`` and retrieve the result only when it
   becomes ``RESUMED``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                   super.onViewCreated(view, savedInstanceState)
                   val navController = findNavController();
                   // After a configuration change or process death, the currentBackStackEntry
                   // points to the dialog destination, so you must use getBackStackEntry()
                   // with the specific ID of your destination to ensure we always
                   // get the right NavBackStackEntry
                   val navBackStackEntry = navController.getBackStackEntry(R.id.your_fragment)

                   // Create our observer and add it to the NavBackStackEntry's lifecycle
                   val observer = LifecycleEventObserver { _, event ->
                       if (event == Lifecycle.Event.ON_RESUME
                           && navBackStackEntry.savedStateHandle.contains("key")) {
                           val result = navBackStackEntry.savedStateHandle.get<String>("key");
                           // Do something with the result
                       }
                   }
                   navBackStackEntry.lifecycle.addObserver(observer)

                   // As addObserver() does not automatically remove the observer, we
                   // call removeObserver() manually when the view lifecycle is destroyed
                   viewLifecycleOwner.lifecycle.addObserver(LifecycleEventObserver { _, event ->
                       if (event == Lifecycle.Event.ON_DESTROY) {
                           navBackStackEntry.lifecycle.removeObserver(observer)
                       }
                   })
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                   super.onViewCreated(view, savedInstanceState);
                   NavController navController = NavHostFragment.findNavController(this);
                   // After a configuration change or process death, the currentBackStackEntry
                   // points to the dialog destination, so you must use getBackStackEntry()
                   // with the specific ID of your destination to ensure we always
                   // get the right NavBackStackEntry
                   final NavBackStackEntry navBackStackEntry = navController.getBackStackEntry(R.id.your_fragment);

                   // Create our observer and add it to the NavBackStackEntry's lifecycle
                   final LifecycleEventObserver observer = new LifecycleEventObserver() {
                       @Override
                       public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) {
                           if (event.equals(Lifecycle.Event.ON_RESUME)
                               && navBackStackEntry.getSavedStateHandle().contains("key")) {
                               String result = navBackStackEntry.getSavedStateHandle().get("key");
                               // Do something with the result
                           }
                       }
                   };
                   navBackStackEntry.getLifecycle().addObserver(observer);

                   // As addObserver() does not automatically remove the observer, we
                   // call removeObserver() manually when the view lifecycle is destroyed
                   getViewLifecycleOwner().getLifecycle().addObserver(new LifecycleEventObserver() {
                       @Override
                       public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) {
                           if (event.equals(Lifecycle.Event.ON_DESTROY)) {
                               navBackStackEntry.getLifecycle().removeObserver(observer)
                           }
                       }
                   });
               }

   **Note:**\  it is important that you use the ``Lifecycle`` object
   provided by ``NavBackStackEntry`` rather than the fragment‚Äôs
   lifecycle since only the ``NavBackStackEntry`` lifecycle transitions
   between ``STARTED`` and ``RESUMED`` when a dialog destination
   overlaps your fragment. The fragment lifecycle will always be
   ``RESUMED``.

   .. rubric:: Share UI-related data between destinations with ViewModel
      :name: share_ui-related_data_between_destinations_with_viewmodel

   The Navigation back stack stores a
   `NavBackStackEntry <#>`__
   not only for each individual destination, but also for each parent
   navigation graph that contains the individual destination. This
   allows you to retrieve a ``NavBackStackEntry`` that is scoped to a
   navigation graph. A navigation graph-scoped ``NavBackStackEntry``
   provides a way to create a ``ViewModel`` that's scoped to a
   navigation graph, enabling you to share UI-related data between the
   graph's destinations. Any ``ViewModel`` objects created in this way
   live until the associated ``NavHost`` and its ``ViewModelStore`` are
   cleared or until the navigation graph is popped from the back stack.

   The following example shows how to retrieve a ``ViewModel`` that's
   scoped to a navigation graph:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val viewModel: MyViewModel
                       by navGraphViewModels(R.id.my_graph)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               NavBackStackEntry backStackEntry = navController.getBackStackEntry(R.id.my_graph);
               MyViewModel viewModel = new ViewModelProvider(backStackEntry).get(MyViewModel.class);

   If you're using Navigation 2.2.0 or earlier, you need to provide your
   own factory to use `Saved State with ViewModels <#>`__,
   as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val viewModel: MyViewModel by navGraphViewModels(R.id.my_graph) {
                   SavedStateViewModelFactory(requireActivity().application, requireParentFragment())
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               NavBackStackEntry backStackEntry = navController.getBackStackEntry(R.id.my_graph);

               ViewModelProvider viewModelProvider = new ViewModelProvider(
                       backStackEntry.getViewModelStore(),
                       new SavedStateViewModelFactory(
                               requireActivity().getApplication(), requireParentFragment()));

               MyViewModel myViewModel = provider.get(myViewModel.getClass());

   For more information about ``ViewModel``, see `ViewModel Overview <#>`__.

   .. rubric:: Modifying inflated navigation graphs
      :name: modify_inflated

   You can modify an inflated navigation graph dynamically at runtime.

   As an example, if you have a
   `BottomNavigationView <#>`__
   that is bound to a ``NavGraph``, the default destination of the
   ``NavGraph`` dictates the selected tab on app startup. However, you
   might need to override this behavior, such as when a user preference
   specifies a preferred tab to be loaded on app startup. Alternatively,
   your app might need to change the starting tab based upon past user
   behavior. You can support these cases by dynamically specifying the
   default destination of the ``NavGraph``.

   Consider this ``NavGraph``:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          android:id="@+id/nav_graph"
          app:startDestination="@id/home">
          <fragment
              android:id="@+id/home"
              android:name="com.example.android.navigation.HomeFragment"
              android:label="fragment_home"
              tools:layout="@layout/fragment_home" />
          <fragment
              android:id="@+id/location"
              android:name="com.example.android.navigation.LocationFragment"
              android:label="fragment_location"
              tools:layout="@layout/fragment_location" />
          <fragment
              android:id="@+id/shop"
              android:name="com.example.android.navigation.ShopFragment"
              android:label="fragment_shop"
              tools:layout="@layout/fragment_shop" />
          <fragment
              android:id="@+id/settings"
              android:name="com.example.android.navigation.SettingsFragment"
              android:label="fragment_settings"
              tools:layout="@layout/fragment_settings" />
      </navigation>

   When this graph is loaded, the ``app:startDestination`` attribute
   specifies that ``HomeFragment`` is to be displayed. To override the
   start destination dynamically, do the following:

   #. First, inflate the ``NavGraph`` manually.
   #. Override the start destination.
   #. Finally, manually attach the graph to the ``NavController``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val navHostFragment =
                       supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment

               val navController = navHostFragment.navController
               val navGraph = navController.navInflater.inflate(R.navigation.bottom_nav_graph)
               navGraph.startDestination = R.id.shop
               navController.graph = navGraph
               binding.bottomNavView.setupWithNavController(navController)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               NavHostFragment navHostFragment = (NavHostFragment) getSupportFragmentManager()
                       .findFragmentById(R.id.nav_host_fragment);

               NavController navController = navHostFragment.getNavController();
               NavGraph navGraph = navController.getNavInflater().inflate(R.navigation.bottom_nav_graph);
               navGraph.setStartDestination(R.id.shop);
               navController.setGraph(navGraph);
               NavigationUI.setupWithNavController(binding.bottomNavView, navController);

   Now when your app starts, ``ShopFragment`` is shown instead of
   ``HomeFragment``.

   **Caution:** When manually calling ``setGraph()``, note the
   following:

   -  Don't use the ``app:navGraph`` element when adding the
      ``NavHostFragment`` in XML.
   -  Don't call ``NavHostFragment.create(@NavigationRes int)``.
   -  Don't use any other APIs that rely solely on the ``R.navigation``
      ID to inflate and set your graph.

   Avoiding these cases ensures that ``setGraph()`` is called only once
   for your modified graph rather than multiple times.

   When using deep links, the ``NavController`` constructs a back stack
   automatically for the deep link destination. If the user navigates to
   the deep link and then navigates backward, they will reach the start
   destination at some point. Overriding the start destination using the
   technique in the previous example ensures that the correct start
   destination is added to the constructed back stack.

   Note that this technique also allows for the overriding of other
   aspects of the ``NavGraph`` as required. All modifications to the
   graph must be done *prior* to the call to ``setGraph()`` to ensure
   that the correct structure is used when handling deep links,
   restoring state, and moving to the start destination of your graph.


Last updated 2024-01-03 UTC.


/Overveiw: Navigation and the back stack
========================================

.. https://developer.android.google.cn/guide/navigation/backstack

.. container:: devsite-article-body clearfix

   The ``NavController`` holds a "back stack" that contains the
   destinations the user has visited. As the user navigates to screens
   throughout your app, the ``NavController`` adds and removes
   destinations to and from the back stack.

   In being a stack, the back stack is a "last in, first out" data
   structure. The ``NavController`` therefore pushes items to and pops
   items from the top of the stack.

   **Important:**\  As the back stack is fundamentally a part of the
   ``NavController`` class, its behavior is consistent regardless of
   which UI framework you use.

   .. rubric:: Basic behavior
      :name: basic-behavior

   These are the core facts you should consider regarding the behavior
   of the back stack:

   -  **First destination:** When the user opens the app, the
      ``NavController`` pushes the first destination to the top of the
      back stack.
   -  **Pushing to the stack:** Each call
      `NavController.navigate() <#navigate>`__
      pushes the given destination to the top of the stack.
   -  **Popping top destination:** Tapping **Up** or **Back** calls the
      `NavController.navigateUp() <#navigateUp>`__
      and
      `NavController.popBackStack() <#popBackStack>`__
      methods, respectively. They pop the top destination off the stack.
      See the `Principles of Navigation <#>`__ page for more
      information about the difference between **Up** and **Back**.

   .. rubric:: Pop back
      :name: pop-back

   The
   `NavController.popBackStack() <#popBackStack>`__
   method attempts to pop the current destination off the back stack and
   navigate to the previous destination. This effectively moves the user
   back one step in their navigation history. It returns a boolean
   indicating whether it successfully popped back to the destination.

   .. rubric:: Pop back to a particular destination
      :name: pop-back-destination

   You can also use ``popBackStack()`` to navigate to a particular
   destination. To do so, use one of its overloads. There are several
   that allow you to pass in an identifier, such as an integer ``id`` or
   a string ``route``. These overloads take the user to the destination
   associated with the given identifier. Critically, they pop everything
   on the stack above that destination.

   These overloads also take an ``inclusive`` boolean. It determines
   whether the ``NavController`` should also pop the specified
   destination off the back stack after having navigated to it.

   Consider this brief snippet for an example:

   .. code:: prettyprint

      navController.popBackStack(R.id.destinationId, true)

   Here the ``NavController`` pops back to the destination with the
   integer id ``destinationId``. As the value of the ``inclusive``
   argument is ``true``, the ``NavController`` also pops the given
   destination from the back stack.

   .. rubric:: Handle a failed pop back
      :name: handle-failure

   When the ``popBackStack()`` returns ``false``, a subsequent call to
   ``NavController.getCurrentDestination()`` returns ``null``. This
   means the app has popped the last destination off the back stack. In
   this case, the user sees only a blank screen.

   This can occur in the following cases:

   -  ``popBackStack()`` did not pop anything from the stack.
   -  ``popBackStack()`` did pop a destination off the back stack and
      the stack is now empty.

   To resolve this, you must then navigate to a new destination or call
   ``finish()`` on your activity to end it. The following snippet
   demonstrates this:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: kotlin
            :name: kotlin

         .. code:: prettyprint

            ...

            if (!navController.popBackStack()) {
                // Call finish() on your Activity
                finish()
            }

      .. container:: section

         .. rubric:: java
            :name: java

         .. code:: prettyprint

            ...

            if (!navController.popBackStack()) {
                // Call finish() on your Activity
                finish();
            }

   **Note:**\  The most common case when ``popBackStack()`` returns
   ``false`` is when you have manually popped the start destination off
   the back stack as that should be the last destination left on the
   back stack.

   .. rubric:: Pop up to a destination
      :name: pop

   To remove destinations from the back stack when navigating from one
   destination to another, add a ``popUpTo()`` argument to the
   associated ``navigate()`` function call. ``popUpTo()`` instructs the
   Navigation library to remove some destinations from the back stack as
   part of the call to ``navigate()``. The parameter value is the
   identifier of a destination on the back stack. The identifier can be
   an integer ``id`` or string ``route``.

   You can include an argument for the ``inclusive`` parameter with a
   value of ``true`` to indicate that the destination you have specified
   in ``popUpTo()`` should also pop off back stack.

   To implement this programmatically, pass ``popUpTo()`` to
   ``navigate()`` as part of
   `NavOptions <#>`__ with
   ``inclusive`` set to ``true``. This works in both Compose and Views.

   **Note:**\  In Views, add an ``app:popUpTo`` attribute to the
   associated ``<action>`` element. Set the inclusive parameter with the
   ``app:popUpToInclusive="true"`` attribute.

   .. rubric:: Save state when popping up
      :name: savestate

   When you use ``popUpTo`` to navigate to a destination, you can
   optionally save the states of all destinations popped off of the back
   stack.

   To enable this option, define ``popUpToSaveState`` as ``true`` in the
   associated ``action``, or call to ``NavController.navigate()``.

   When you navigate to a destination, you can also define
   ``restoreSaveState`` as ``true`` to automatically restore the state
   associated with the destination in ``destination`` property.

   .. rubric:: XML example
      :name: xml-example

   Here is an example of ``popUpTo`` in XML, using an action:

   .. code:: prettyprint

      <action
        android:id="@+id/action_a_to_b"
        app:destination="@id/b"
        app:popUpTo="@+id/a"
        app:popUpToInclusive="true"
        app:restoreState=‚Äùtrue‚Äù
        app:popUpToSaveState="true"/>

   .. rubric:: Compose Examples
      :name: compose-examples

   The following is a complete example of the same in Compose:

   .. code:: prettyprint

      @Composable
      fun MyAppNavHost(
          modifier: Modifier = Modifier,
          navController: NavHostController = rememberNavController(),
          startDestination: String = "destination_a"
      ) {
          NavHost(
              modifier = modifier,
              navController = navController,
              startDestination = startDestination
          ) {
              composable("destination_a") {
                  DestinationA(
                      onNavigateToB = {
                      // Pop everything up to the "destination_a" destination off the back stack before
                      // navigating to the "destination_b" destination
                          navController.navigate("destination_b") {
                              popUpTo("destination_a") {
                                  inclusive = true
                                  saveState = true
                              }
                          }
                      },
                  )
              }
              composable("destination_b") { DestinationB(/* ... */) }
          }
      }

      @ Composable
      fun DestinationA(onNavigateToB: () -> Unit) {
          Button(onClick = onNavigateToB) {
              Text("Go to A")
          }
      }

   More granularly, you can change how you call
   ``NavController.navigate()`` in the following ways:

   .. code:: prettyprint

      // Pop everything up to the destination_a destination off the back stack before
      // navigating to the "destination_b" destination
      navController.navigate("destination_b") {
          popUpTo("destination_a")
      }

      // Pop everything up to and including the "destination_a" destination off
      // the back stack before navigating to the "destination_b" destination
      navController.navigate("destination_b") {
          popUpTo("destination_a") { inclusive = true }
      }

      // Navigate to the "search‚Äù destination only if we‚Äôre not already on
      // the "search" destination, avoiding multiple copies on the top of the
      // back stack
      navController.navigate("search") {
          launchSingleTop = true
      }

   For general information about passing options to
   ``NavController.navigate()``, see the `Navigate with options guide <#>`__.

   .. rubric:: Pop using actions
      :name: pop-actions

   When navigating using an action, you can optionally pop additional
   destinations off of the back stack. For example, if your app has an
   initial login flow, once a user has logged in, you should pop all of
   the login-related destinations off of the back stack so that the Back
   button doesn't take users back into the login flow.

   .. rubric:: Additional reading
      :name: additional-reading

   For more information, read the following pages:

   -  `Circular navigation <#>`__:
      Learn how you can avoid an overstuffed back stack in cases where
      navigation flows are circular.
   -  `Dialog destinations <#>`__: Read
      about how dialog destinations introduce unique considerations to
      how you manage your back stack.


Last updated 2024-01-03 UTC.


/Dialog destinations
====================

.. container:: devsite-article-body clearfix

   This document outlines how the use of `dialog destinations <#>`__ can introduce unique
   considerations for how you need to manage your back stack.

   .. rubric:: Overview
      :name: overview

   One or more dialog destinations can only exist on the top of the back
   stack. This is because when the user navigates to a destination that
   is not a dialog destination, the ``NavController`` automatically pops
   all dialog destinations off the top of the stack. This ensures that
   the current destination is always fully visible over other
   destinations on the back stack.

   Destinations can be either `hosted destinations <#>`__, `activity destinations <#>`__, or
   `dialog destination <#>`__.

   **Note:**\  Dialog destinations implement the
   `FloatingWindow <#>`__
   interface. As such, they overlay other destinations on the back
   stack.

   .. rubric:: Example
      :name: example

   If the back stack consists solely of `hosted destinations <#>`__ that fill the navigation
   host, and the user navigates to a dialog destination, then the back
   stack might look similar to figure 2:

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/backstack-1.png
      :alt: a back stack with a dialog destination on top

      **Figure 2.** A back stack with a dialog destination on top.

   If the user then navigates to another dialog destination, it is then
   added to the top of the back stack, as shown in figure 3:

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/backstack-2.png
      :alt: a back stack with two dialog destinations on top

      **Figure 3.** A back stack with two ``Dialog`` destinations on
      top.

   If the user then navigates to a non-floating destination, any dialog
   destinations are first popped from the top of the back stack before
   navigating to the new destination, as shown in figure 4:

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/backstack-3.png
      :alt: the dialog destinations are popped, and the new destination
      is added

      **Figure 4.** The ``Dialog`` destinations are popped, and the new
      destination is added.


Last updated 2024-01-03 UTC.


/Circular navigation
====================

.. container:: devsite-article-body clearfix

   A clear example of where you need to pop back to a destination is
   when your navigation is circular. This document outlines that use
   case.

   .. rubric:: Scenario
      :name: scenario

   Imagine your app has three destinations: A, B, and C. It also has
   actions that lead from A to B, B to C, and C back to A. The
   corresponding navigation graph appears as follows:

   .. figure::
      https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-getting-started-pop.png
      :alt: a demonstration of circular navigation

      **Figure 1.** A circular navigation graph with three destinations:
      A, B, and C.

   With each navigation action, the ``NavController`` adds the new
   destination to the back stack. As such, repeatedly navigating through
   the flow in the diagram would cause your back stack would to contain
   multiple sets of each destination: A, B, C, A, B, C, A, B, C.

   .. rubric:: Solution
      :name: circular-solution

   To avoid repetition in your back stack, specify
   `popUpTo() <#pop>`__ and
   `inclusive <#pop-back-destination>`__
   in your call to ``NavController.navigate()`` or in your navigation
   action.

   Consider a case where after reaching destination C, the back stack
   contains one instance of each destination: A, B, C. You need to
   ensure that you have defined ``popUpTo()`` and ``inclusive`` in the
   action or call to ``navigate()`` that takes the user from destination
   C to destination A.

   In this case, when the user navigates from destination C back to
   destination A, the ``NavController`` also pops up to A. This means
   that it removes B and C from the stack. With ``inclusive = true``, it
   also pops the first A, effectively clearing the stack.

   **Note:**\  This is similar to calling `popBackStack()`` and
   passing
   ``inclusive </guide/navigation/backstack#pop-back-destination>`__.

   .. rubric:: Compose implementation
      :name: compose-implementation

   The following is the implementation of the solution for circular
   ``popUpTo()`` in Compose:

   .. code:: prettyprint

      // When creating your `NavGraph` in your `NavHost`.
      composable("c") {
          DestinationC(
              onNavigateToA = {
                navController.navigate("a") {
                  popUpTo("a") {
                    inclusive = true
                  }
                }
              },
          )
      }

   .. rubric:: Views implementation
      :name: views-implementation

   The following is the implementation of the solution for circular
   ``popUpTo`` in Views:

   .. code:: prettyprint

      <fragment
          android:id="@+id/c"
          android:name="com.example.myapplication.C"
          android:label="fragment_c"
          tools:layout="@layout/fragment_c">

          <action
              android:id="@+id/action_c_to_a"
              app:destination="@id/a"
              app:popUpTo="@+id/a"
              app:popUpToInclusive="true"/>
      </fragment>


Last updated 2024-01-22 UTC.


/Support multiple back stacks
=============================

.. container:: devsite-article-body clearfix

   The Navigation component works with the Android operating system to
   maintain the `back stack <#back-stack>`__ as the
   user navigates in your app. In some cases, it might be helpful to
   maintain *multiple back stacks* at the same time, with the user
   moving back and forth between them. For example, if your app includes
   `bottom navigation <#bottom_navigation>`__ or
   a `navigation drawer <#add_a_navigation_drawer>`__,
   multiple back stack support allows your users to switch freely
   between flows in your app without losing their place in any of them.

   The Navigation component provides APIs that support multiple back
   stacks by saving and restoring the state of destinations in your
   `navigation graph <#>`__. The
   `NavigationUI <#>`__
   class includes methods that handle this automatically, but you can
   also use the underlying APIs manually for a more customized
   implementation.

   **Note:**\  The Navigation component only provides multiple back
   stack support in version 2.4.0 and higher.

   .. rubric:: Implement support automatically with NavigationUI
      :name: automatic

   The
   `NavigationUI <#>`__
   class includes APIs that automatically save and restore the state of
   menu items as the user moves between them. These APIs implement
   multiple back stack support by default in the following cases:

   -  When you use the appropriate overload of
      `setupWithNavController() <#setupWithNavController>`__
      to associate an instance of ``NavigationView`` or
      ``BottomNavigationView`` with a
      `NavController <#>`__
      instance, as described in `Add a navigation drawer <#add_a_navigation_drawer>`__
      or `Bottom navigation <#bottom_navigation>`__.
   -  When you use
      `onNavDestinationSelected() <#onNavDestinationSelected>`__
      to create a `custom navigation menu UI <#Tie-navdrawer>`__ tied to
      destinations hosted by a ``NavController`` instance.

   These APIs require no further code changes to implement multiple back
   stack support, and are the recommended way of supporting multiple
   back stacks in your app.

   .. rubric:: Implement support manually with underlying APIs
      :name: manual

   If the elements provided by ``NavigationUI`` don't satisfy your
   requirements, you can use the underlying APIs for saving and
   restoring back stacks through one of the other API surfaces provided
   by the Navigation component.

   .. rubric:: Navigation XML
      :name: nav-xml

   In Navigation XML, ``<action>`` elements in your navigation graph can
   use the ``app:popUpToSaveState`` attribute to save the state of any
   destinations that the action popped using ``app:popUpTo``. They can
   also use the ``app:restoreState`` attribute to restore any previously
   saved state for the destination defined in the ``app:destination``
   attribute.

   You can use these attributes to support multiple back stacks. When a
   navigation action needs to move the user from one back stack to
   another, set both ``app:popUpToSaveState`` and ``app:restoreState``
   to ``true`` in the corresponding ``<action>`` element. That way, the
   action saves the state of the current back stack while also restoring
   the previously saved state of the destination back stack, if it
   exists.

   The following example shows an action that uses both of these
   attributes:

   .. code:: prettyprint

      <action
        android:id=‚Äù@+id/swap_stack‚Äù
        app:destination=‚Äù@id/second_stack‚Äù
        app:restoreState=‚Äùtrue‚Äù
        app:popUpTo=‚Äù@id/first_stack_start_destination‚Äù
        app:popUpToSaveState=‚Äùtrue‚Äù />

   .. rubric:: NavOptions
      :name: navoptions

   The
   `NavOptions <#>`__
   class allows you to pass special navigation options to save and
   restore back stacks when you navigate using a ``NavController``. This
   is true whether you create your instance of ``NavOptions`` using the
   `Kotlin DSL <#>`__ or using the
   `NavOptions.Builder <#>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Use the navigate() method that takes a navOptions DSL Builder
               navController.navigate(selectedBottomNavRoute) {
                 launchSingleTop = true
                 restoreState = true
                 popUpTo(navController.graph.findStartDestination().id) {
                   saveState = true
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               NavOptions navOptions = new NavOptions.Builder()
                 .setLaunchSingleTop(true)
                 .setRestoreState(true)
                 .setPopUpTo(NavGraph.findStartDestination(navController.getGraph()).getId(),
                   false, // inclusive
                   true) // saveState
                 .build();
               navController.navigate(selectedBottomNavId, null, navOptions);

   To learn more about passing navigation options, see `Apply NavOptions programmatically <#programmatic>`__.

   .. rubric:: Additional resources
      :name: addt-resources

   To learn more about multiple back stack support with the Navigation
   component, see the following additional resources:

   .. rubric:: Blog posts
      :name: blogs

   -  `MAD Skills: Navigation multiple back stacks <https://medium.com/androiddevelopers/navigation-multiple-back-stacks-6c67ba41952f>`__
      on Medium
   -  `Navigation: Multiple Back Stacks deep dive <https://medium.com/androiddevelopers/multiple-back-stacks-b714d974f134>`__
      on Medium

   .. rubric:: Samples
      :name: samples

   -  `Now in Android app <https://github.com/android/nowinandroid/blob/main/app/src/main/java/com/google/samples/apps/nowinandroid/navigation/NiaTopLevelNavigation.kt#L38>`__
      on GitHub
   -  `Jetnews <https://github.com/android/compose-samples/blob/main/JetNews/app/src/main/java/com/example/jetnews/ui/JetnewsNavigation.kt#L30>`__
      on GitHub
   -  `Jetsnack <https://github.com/android/compose-samples/blob/main/Jetsnack/app/src/main/java/com/example/jetsnack/ui/JetsnackAppState.kt#L119>`__
      on GitHub


Last updated 2024-01-03 UTC.


/Navigate with feature modules
==============================

.. container:: devsite-article-body clearfix

   The Dynamic Navigator library extends the functionality of the
   `Jetpack Navigation component <#>`__ to work with
   destinations that are defined in `feature modules <#customize_delivery>`__.
   This library also provides seamless installation of on-demand feature
   modules when navigating to these destinations.

   **Note:**\  If you are not familiar with Play Feature Delivery,
   review the `feature module guide <#customize_delivery>`__ and
   `additional resources <#additional_resources>`__
   before continuing.

   .. rubric:: Setup
      :name: setup

   To support feature modules, use the following dependencies in your
   app module's ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   def nav_version = "2.7.7"

                   api "androidx.navigation:navigation-fragment-ktx:$nav_version"
                   api "androidx.navigation:navigation-ui-ktx:$nav_version"
                   api "androidx.navigation:navigation-dynamic-features-fragment:$nav_version"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   val nav_version = "2.7.7"

                   api("androidx.navigation:navigation-fragment-ktx:$nav_version")
                   api("androidx.navigation:navigation-ui-ktx:$nav_version")
                   api("androidx.navigation:navigation-dynamic-features-fragment:$nav_version")
               }

   Note that the other Navigation dependencies should use `api configurations <https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_separation>`__
   so that they are available to your feature modules.

   .. rubric:: Basic usage
      :name: usage

   To support feature modules, first change all instances of
   ``NavHostFragment`` in your app to
   ``androidx.navigation.dynamicfeatures.fragment.DynamicNavHostFragment``:

   .. code:: prettyprint

      <androidx.fragment.app.FragmentContainerView
          android:id="@+id/nav_host_fragment"
          android:name="androidx.navigation.dynamicfeatures.fragment.DynamicNavHostFragment"
          app:navGraph="@navigation/nav_graph"
          ... />

   Next, add an ``app:moduleName`` attribute to any ``<activity>``,
   ``<fragment>``, or ``<navigation>`` destinations in your
   ``com.android.dynamic-feature`` module's navigation graphs that are
   associated with a ``DynamicNavHostFragment``. This attribute tells
   the Dynamic Navigator library that the destination belongs to a
   feature module with the name that you specify.

   **Note:**\  The ``moduleName`` needs to match your app's
   ``dynamicFeatures`` property as declared in the ``build.gradle``
   file.
   .. code:: prettyprint

      <fragment
          app:moduleName="myDynamicFeature"
          android:id="@+id/featureFragment"
          android:name="com.google.android.samples.feature.FeatureFragment"
          ... />

   When you navigate to one of these destinations, the Dynamic Navigator
   library first checks if the feature module is installed. If the
   feature module is already present, your app navigates to the
   destination as expected. If the module isn't present, your app shows
   an intermediate progress fragment destination as it installs the
   module. The default implementation of the progress fragment shows a
   basic UI with a progress bar and handles any installation errors.

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/dfm-nav-loading.png
      name: dynamic-loading
      :alt: two loading screens that show UI with a progress bar when
      navigating to a feature module for the first time
      :width: 500px

      **Figure 1.** UI showing a progress bar when a user navigates to
      an on-demand feature for the first time. The app displays this
      screen as the corresponding module downloads.

   To customize this UI, or to manually handle installation progress
   from within your own app screen, see the `Customize the progress fragment <#customize>`__ and `Monitor the request state <#monitor>`__
   sections in this topic.

   Destinations that don't specify ``app:moduleName`` continue to work
   without changes and behave as though your app uses a regular
   ``NavHostFragment``.

   .. rubric:: Customize the progress fragment
      :name: customize

   You can override the progress fragment implementation for each
   navigation graph by setting the ``app:progressDestination`` attribute
   to the ID of the destination you want to use for handling
   installation progress. Your custom progress destination should be a
   `Fragment <#>`__
   that derives from
   `AbstractProgressFragment <#>`__.
   You must override the abstract methods for notifications about
   installation progress, errors, and other events. You can then show
   installation progress in a UI of your choice.

   The default implementation's
   `DefaultProgressFragment <https://android.googlesource.com/platform/frameworks/support/+/androidx-main/navigation/navigation-dynamic-features-fragment/src/main/java/androidx/navigation/dynamicfeatures/fragment/ui/DefaultProgressFragment.kt>`__
   class uses this API to show installation progress.

   .. rubric:: Monitor the request state
      :name: monitor

   The Dynamic Navigator library enables you to implement a UX flow
   similar to the one in `UX best practices for on-demand delivery <#>`__, in
   which a user stays in the context of a previous screen while waiting
   for installation to finish. This means that you don't need to show an
   intermediate UI or progress fragment at all.

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/nav-dfm-ui.png
      name: dynamic-previous-screen
      :alt: screen that shows a bottom nav bar with an icon that
      indicates that a feature module is downloading
      :width: 250px

      **Figure 2.** Screen that shows download progress from a bottom
      navigation bar.

   In this scenario, you are responsible for monitoring and handling all
   installation states, progress changes, errors, and so on.

   To initiate this non-blocking navigation flow, pass a
   `DynamicExtras <#>`__
   object that contains a
   `DynamicInstallMonitor <#>`__
   to
   `NavController.navigate() <#navigate>`__,
   as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val navController = ...
               val installMonitor = DynamicInstallMonitor()

               navController.navigate(
                   destinationId,
                   null,
                   null,
                   DynamicExtras(installMonitor)
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               NavController navController = ...
               DynamicInstallMonitor installMonitor = new DynamicInstallMonitor();

               navController.navigate(
                   destinationId,
                   null,
                   null,
                   new DynamicExtras(installMonitor);
               )

   Immediately after calling ``navigate()``, you should check the value
   of ``installMonitor.isInstallRequired`` to see if the attempted
   navigation resulted in a feature module installation.

   -  If the value is ``false``, you're navigating to a normal
      destination and don't need to do anything else.

   -  If the value is ``true``, you should start observing the
      ``LiveData`` object that is now in ``installMonitor.status``. This
      ``LiveData`` object emits
      `SplitInstallSessionState <#>`__
      updates from the Play Core library. These updates contain
      installation progress events that you can use to update the UI.
      Remember to handle all relevant statuses as outlined in the `Play Core guide <#>`__, including `asking for user confirmation <#obtain_confirmation>`__
      if necessary.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val navController = ...
                  val installMonitor = DynamicInstallMonitor()

                  navController.navigate(
                    destinationId,
                    null,
                    null,
                    DynamicExtras(installMonitor)
                  )

                  if (installMonitor.isInstallRequired) {
                    installMonitor.status.observe(this, object : Observer<SplitInstallSessionState> {
                        override fun onChanged(sessionState: SplitInstallSessionState) {
                            when (sessionState.status()) {
                                SplitInstallSessionStatus.INSTALLED -> {
                                    // Call navigate again here or after user taps again in the UI:
                                    // navController.navigate(destinationId, destinationArgs, null, null)
                                }
                                SplitInstallSessionStatus.REQUIRES_USER_CONFIRMATION -> {
                                    SplitInstallManager.startConfirmationDialogForResult(...)
                                }

                                // Handle all remaining states:
                                SplitInstallSessionStatus.FAILED -> {}
                                SplitInstallSessionStatus.CANCELED -> {}
                            }

                            if (sessionState.hasTerminalStatus()) {
                                installMonitor.status.removeObserver(this);
                            }
                        }
                    });
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  NavController navController = ...
                  DynamicInstallMonitor installMonitor = new DynamicInstallMonitor();

                  navController.navigate(
                    destinationId,
                    null,
                    null,
                    new DynamicExtras(installMonitor);
                  )

                  if (installMonitor.isInstallRequired()) {
                    installMonitor.getStatus().observe(this, new Observer<SplitInstallSessionState>() {
                        @Override
                        public void onChanged(SplitInstallSessionState sessionState) {
                            switch (sessionState.status()) {
                                case SplitInstallSessionStatus.INSTALLED:
                                    // Call navigate again here or after user taps again in the UI:
                                    // navController.navigate(mDestinationId, mDestinationArgs, null, null);
                                    break;
                                case SplitInstallSessionStatus.REQUIRES_USER_CONFIRMATION:
                                    SplitInstallManager.startConfirmationDialogForResult(...)
                                    break;

                                // Handle all remaining states:
                                case SplitInstallSessionStatus.FAILED:
                                    break;
                                case SplitInstallSessionStatus.CANCELED:
                                    break;
                            }

                            if (sessionState.hasTerminalStatus()) {
                                installMonitor.getStatus().removeObserver(this);
                            }
                        }
                    });
                  }

   When the installation finishes, the ``LiveData`` object emits a
   ``SplitInstallSessionStatus.INSTALLED`` status. You should then call
   ``NavController.navigate()`` again. Since the module is now
   installed, the call now succeeds, and the app navigates to the
   destination as expected.

   After reaching a terminal state, such as when installation completes
   or when installation fails, you should remove your ``LiveData``
   observer to avoid memory leaks. You can check if the status
   represents a terminal state by using
   ``SplitInstallSessionStatus.hasTerminalStatus()``.

   See
   `AbstractProgressFragment <#>`__
   for an example implementation of this observer.

   .. rubric:: Included graphs
      :name: included

   The Dynamic Navigator library supports including graphs that are
   defined in feature modules. To include a graph that is defined in a
   feature module, do the following:

   #. Use ``<include-dynamic/>`` instead of ``<include/>``, as shown in
      the following example:

      .. code:: prettyprint

         <include-dynamic
             android:id="@+id/includedGraph"
             app:moduleName="includedgraphfeature"
             app:graphResName="included_feature_nav"
             app:graphPackage="com.google.android.samples.dynamic_navigator.included_graph_feature" />

   #. Inside ``<include-dynamic ... />``, you must specify the following
      attributes:

      -  ``app:graphResName``: the name of the navigation graph resource
         file. The name is derived from the graph's file name. For
         example, if the graph is in ``res/navigation/nav_graph.xml``,
         the resource name is ``nav_graph``.
      -  ``android:id`` - the graph destination ID. The Dynamic
         Navigator library ignores any ``android:id`` values that are
         found in the root element of the included graph.
      -  ``app:moduleName``: the package name of the module.

   .. rubric:: Use the correct graphPackage
      :name: graphPackage

   It is important to get the ``app:graphPackage`` correct as the
   Navigation component will not be able to include the specified
   ``navGraph`` from the feature module, otherwise.

   **Caution:**\  The package name of the dynamic feature module is
   generated automatically by the build toolchain, and any values in the
   ``AndroidManifest.xml`` or ``build.gradle`` in your dynamic module
   will be ignored.
   The package name of a dynamic feature module is constructed by
   appending the name of the module to the ``applicationId`` of the base
   app module. So if the base app module has an ``applicationId`` of
   ``com.example.dynamicfeatureapp`` and the dynamic feature module is
   named ``DynamicFeatureModule``, then the package name of the dynamic
   module will be
   ``com.example.dynamicfeatureapp.DynamicFeatureModule``. This package
   name is case-sensitive.

   If you‚Äôre in any doubt, you can confirm the package name of the
   feature module by checking the generated ``AndroidManifest.xml``.
   After building the project go to
   ``<DynamicFeatureModule>/build/intermediates/merged_manifest/debug/AndroidManifest.xml``,
   which should look something like this:

   .. code:: prettyprint

      <manifest xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:dist="http://schemas.android.com/apk/distribution"
          featureSplit="DynamicFeatureModule"
          package="com.example.dynamicfeatureapp"
          android:versionCode="1"
          android:versionName="1.0" >

          <uses-sdk
              android:minSdkVersion="21"
              android:targetSdkVersion="30" />

          <dist:module
              dist:instant="false"
              dist:title="@string/title_dynamicfeaturemodule" >
              <dist:delivery>
                  <dist:install-time />
              </dist:delivery>

              <dist:fusing dist:include="true" />
          </dist:module>

          <application />

      </manifest>

   The ``featureSplit`` value should match the name of the dynamic
   feature module, and the package will match the ``applicationId`` of
   the base app module. The ``app:graphPackage`` is the combination of
   these: ``com.example.dynamicfeatureapp.DynamicFeatureModule``.

   .. rubric:: Navigating to an include-dynamic navigation graph
      :name: navigate-include-dynamic

   It is only possible to navigate to the ``startDestination`` of an
   ``include-dynamic`` navigation graph. The dynamic module is
   responsible for its own navigation graph and the base app has no
   knowledge of that.

   The include-dynamic mechanism enables the base app module to include
   a `nested navigation graph <#>`__ that is defined
   within the dynamic module. This nested navigation graph behaves like
   any nested navigation graph. The root navigation graph (that is, the
   parent of the nested graph) can only define the nested navigation
   graph itself as a destination and not its children. Thus, the
   ``startDestination`` is used when the include-dynamicnavigation graph
   is the destination.

   .. rubric:: Limitations
      :name: limitations

   -  Dynamically-included graphs don't currently support deep links.
   -  Dynamically-loaded nested graphs (that is, a ``<navigation>``
      element with an ``app:moduleName``) don't currently support deep
      links.


Last updated 2024-05-01 UTC.


/Navigation best practices for multi-module projects
====================================================

.. container:: devsite-article-body clearfix

   A navigation graph can consist of any combination of the following:

   -  A singular destination, such as a ``<fragment>`` destination.
   -  A `nested graph <#>`__
      that encapsulates a set of related destinations.
   -  An
      `<#include>`__
      element, which allows you to embed another navigation graph file
      as though it was nested.

   This flexibility allows you to combine smaller navigation graphs
   together to form your app's complete navigation graph, even if those
   smaller navigation graphs are provided by separate
   `modules <#>`__.

   **Note:**\  This page assumes a basic familiarity with the `guide to Android app modularization <#>`__. To learn how
   to provide type safety Navigation in a modularized project for the
   Kotlin DSL and Navigation Compose, check out the `Navigation type safety page <#>`__.
   **Key Term:**\  In the context of this guide a **feature module** is
   a module that encapsulates a distinct part of your application‚Äôs
   functionality. However, **feature module** is a term that is also
   used in the `Play Feature Delivery <#>`__ describing a module
   that can be delivered conditionally or downloaded on-demand.
   Navigation supports `navigating with custom delivered feature modules <#>`__ and provides
   similar functionality for dynamic feature modules through
   `<#included>`__.
   For the examples in this topic, each `feature module <#feature-modules>`__ is focused
   around one
   `feature <#feature-modules>`__ and
   provides a single navigation graph that encapsulates all of the
   destinations needed to implement that feature. In a production app,
   you might have many submodules at a lower level that are
   implementation details of this higher-level feature module. Each of
   these feature modules are included, either directly or indirectly,
   into your `app``
   module </topic/modularization/patterns#app-modules>`__. The example
   `multi-module application <#>`__ used in this doc
   has the following structure:

   .. container:: float

      .. image:: https://developer.android.google.cn/static/images/guide/navigation/multimodule-structure.png
         :alt: dependency graph for a sample multi-module application
         :width: 100.0%

      .. image:: https://developer.android.google.cn/static/images/guide/navigation/multimodule-screen.png
         :alt: the start destination of the example app
         :width: 40.0%


   Each feature module is a self-contained unit with its own navigation
   graph and destinations. The ``app`` module depends on each, adding
   them as implementation details in its ``build.gradle`` file, as
   shown:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   ...
                   implementation project(":feature:home")
                   implementation project(":feature:favorites")
                   implementation project(":feature:settings")

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   ...
                   implementation(project(":feature:home"))
                   implementation(project(":feature:favorites"))
                   implementation(project(":feature:settings"))

   .. rubric:: The role of the ``app`` module
      :name: app-module

   The `app <#app-modules>`__ module
   is responsible for providing the complete graph for your app and
   adding the ``NavHost`` to your UI. Within the ``app`` module's
   navigation graph, you can reference the library graphs by using
   `<#include>`__.
   While using ``<include>`` is functionally the same as using a nested
   graph, ``<include>`` supports graphs from other project modules or
   from library projects, as shown in the following example:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          android:id="@+id/nav_graph"
          app:startDestination="@id/home_nav_graph">

          <include app:graph="@navigation/home_navigation" />
          <include app:graph="@navigation/favorites_navigation" />
          <include app:graph="@navigation/settings_navigation" />
      </navigation>

   **Note:**\  The graph attribute in the ``<include>`` tag references
   the name of the library's graph file (``home_navigation.xml``, for
   example). The ``startDestination`` references the ID of the
   ``<navigation>`` element within that file and specifically does not
   use ``@+id``, instead using ``@id/`` to use the ID that is already
   declared in the feature module.
   Once a library is included in the top-level navigation graph, you can
   `navigate <#navigation_across_library_modules>`__
   to the library graphs as needed. For example, you could create an
   action to navigate to the settings graph from a fragment in your
   navigation graph, as shown:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          android:id="@+id/nav_graph"
          app:startDestination="@id/home_nav_graph">

          <include app:graph="@navigation/home_navigation" />
          <include app:graph="@navigation/favorites_navigation" />
          <include app:graph="@navigation/settings_navigation" />

          <fragment
              android:id="@+id/random_fragment"
              android:name="com.example.android.RandomFragment"
              android:label="@string/fragment_random" >
              <!-- Launch into Settings Navigation Graph -->
              <action
                  android:id="@+id/action_random_fragment_to_settings_nav_graph"
                  app:destination="@id/settings_nav_graph" />
          </fragment>
      </navigation>

   When multiple feature modules need to reference a common set of
   destinations, such as a login graph, you **should not** include those
   common destinations into each feature module's navigation graph.
   Instead, add those common destinations to your ``app`` module's
   navigation graph. Each feature module can then `navigate across feature modules <#across>`__ to navigate to those common
   destinations.

   In the previous example, the action specifies a navigation
   destination of ``@id/settings_nav_graph``. This ID refers to a
   destination that is defined within the included graph
   ``@navigation/settings_navigation.``

   .. rubric:: Top-level navigation in app module
      :name: top

   The Navigation component includes a
   `NavigationUI <#>`__
   class. This class contains static methods that manage navigation with
   the top app bar, the navigation drawer, and bottom navigation. If
   your app's top-level destinations are composed of UI elements
   provided by feature modules, the ``app`` module is a natural place to
   put the top-level navigation and UI elements. Since the app module
   depends on the collaborating feature modules, all of their
   destinations are accessible from code defined within your app module.
   This means that you can use ``NavigationUI`` to `tie destinations to menu items <#Tie-navdrawer>`__ if the
   ID of the item matches the ID of a destination.

   In figure 2, the example ``app`` module defines a
   `BottomNavigationView <#>`__
   in its main activity. The menu item IDs in the menu match the
   navigation graph IDs of the library graphs:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <menu xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto">

          <item
              android:id="@id/home_nav_graph"
              android:icon="@drawable/ic_home"
              android:title="Home"
              app:showAsAction="ifRoom"/>

          <item
              android:id="@id/favorites_nav_graph"
              android:icon="@drawable/ic_favorite"
              android:title="Favorites"
              app:showAsAction="ifRoom"/>

          <item
              android:id="@id/settings_nav_graph"
              android:icon="@drawable/ic_settings"
              android:title="Settings"
              app:showAsAction="ifRoom" />
      </menu>

   To let ``NavigationUI`` handle the `bottom navigation <#bottom_navigation>`__,
   call
   `setupWithNavController() <#setupWithNavController>`__
   from ``onCreate()`` in your main activity class, as shown in the
   following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)
                   setContentView(R.layout.activity_main)
                   val navHostFragment =
                       supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment
                   val navController = navHostFragment.navController

                   findViewById<BottomNavigationView>(R.id.bottom_nav)
                           .setupWithNavController(navController)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onCreate(Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);
                   setContentView(R.layout.activity_main);
                   NavHostFragment navHostFragment =
                           (NavHostFragment) supportFragmentManager.findFragmentById(R.id.nav_host_fragment);
                   NavController navController = navHostFragment.getNavController();
                   BottomNavigationView bottomNav = findViewById(R.id.bottom_nav);

                   NavigationUI.setupWithNavController(bottomNav, navController);
               }

   With this code in place, ``NavigationUI`` navigates to the
   appropriate library graph when the user clicks on a bottom navigation
   item.

   Keep in mind that it's generally bad practice for your app module to
   have a hard dependency on a specific destination embedded deeply
   within your feature modules' navigation graph. In most cases, you
   want your app module to know only about the entry point to any
   embedded or included navigation graphs (this applies outside of
   feature modules too). If you need to link to a destination deep
   within your library's navigation graph, the preferred way to do this
   is by using a `deep link <#uri>`__. Deep linking is
   also the only way for a library to navigate to a destination in
   another library's navigation graph.

   .. rubric:: Navigating across feature modules
      :name: across

   At compile time, independent feature modules cannot see each other,
   so you can't use IDs to navigate to destinations in other modules.
   Instead, `use a deep link <#uri>`__ to navigate
   directly to a destination that is associated with an `implicit deep link <#implicit>`__.

   Continuing the previous example, imagine you need to navigate from a
   button in the ``:feature:home`` module to a destination nested in the
   ``:feature:settings`` module. You can do this by adding a deep link
   to the destination in the settings navigation graph, as shown:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          android:id="@+id/settings_nav_graph"
          app:startDestination="@id/settings_fragment_one">

          ...

          <fragment
              android:id="@+id/settings_fragment_two"
              android:name="com.example.google.login.SettingsFragmentTwo"
              android:label="@string/settings_fragment_two" >

              <deepLink
                  app:uri="android-app://example.google.app/settings_fragment_two" />
          </fragment>
      </navigation>

   Then add the following code to the button's ``onClickListener`` in
   the home fragment:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               button.setOnClickListener {
                   val request = NavDeepLinkRequest.Builder
                       .fromUri("android-app://example.google.app/settings_fragment_two".toUri())
                       .build()
                   findNavController().navigate(request)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               button.setOnClickListener(new View.OnClickListener() {
                   @Override
                   public void onClick(View view) {
                       NavDeepLinkRequest request = NavDeepLinkRequest.Builder
                           .fromUri(Uri.parse("android-app://example.google.app/settings_fragment_two"))
                           .build();
                       NavHostFragment.findNavController(this).navigate(request);
                   }
               });

   Unlike navigating using action or destination IDs, you can navigate
   to any URI in any graph, even across modules.

   When navigating using URI, the back stack is *not* reset. This
   behavior is unlike `explicit deep link navigation <#>`__, where the
   back stack is replaced when navigating.

   **Note:**\  Safe Args don't support cross-module navigation, as there
   isn't direct action to the destination. In the previous example,
   although a ``Directions`` class would be generated for the target
   destination in settings, you aren't able to access the generated
   class from the classpath of the home module.


Last updated 2024-02-28 UTC.




/Connect UI components to NavController using NavigationUI
==========================================================

.. container:: devsite-article-body clearfix

   The Navigation component includes a
   `NavigationUI <#>`__
   class. This class contains static methods that manage navigation with
   the top app bar, the navigation drawer, and bottom navigation.

   .. rubric:: Top app bar
      :name: top_app_bar

   The `top app bar <https://material.io/design/components/app-bars-top.html>`__
   provides a consistent place along the top of your app for displaying
   information and actions from the current screen.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/top-app-bar.png
      :alt: screen displaying a top app bar

      **Figure 1.** A screen displaying a top app bar.

   ``NavigationUI`` contains methods that automatically update content
   in your top app bar as users navigate through your app. For example,
   ``NavigationUI`` uses the destination labels from your navigation
   graph to keep the title of the top app bar up-to-date.

   .. code:: prettyprint

      <navigation>
          <fragment ...
                    android:label="Page title">
            ...
          </fragment>
      </navigation>

   When using ``NavigationUI`` with the top app bar implementations
   discussed below, the label you attach to destinations can be
   automatically populated from the arguments provided to the
   destination by using the format of ``{argName}`` in your label.

   ``NavigationUI`` provides support for the following top app bar
   types:

   -  `Toolbar <#>`__
   -  `CollapsingToolbarLayout <#>`__
   -  `ActionBar <#>`__

   For more information on app bars, see `Set up the app bar <#>`__.

   **Caution:**\  If you pass a ``Toolbar`` as the argument to
   ``setSupportActionBar()``, the ``ActionBar`` assumes complete
   ownership of that ``Toolbar`` and you must not use any ``Toolbar``
   APIs after that call. You can use the `support for the ``ActionBar <#action_bar>`__ to connect the ``ActionBar`` to
   ``NavController``.

   .. rubric:: AppBarConfiguration
      :name: appbarconfiguration

   ``NavigationUI`` uses an
   `AppBarConfiguration <#>`__
   object to manage the behavior of the Navigation button in the
   upper-left corner of your app's display area. The Navigation button‚Äôs
   behavior changes depending on whether the user is at a *top-level
   destination*.

   A top-level destination is the root, or highest level destination, in
   a set of hierarchically-related destinations. Top-level destinations
   do not display an Up button in the top app bar because there is no
   higher level destination. By default, the start destination of your
   app is the only top-level destination.

   When the user is at a top-level destination, the Navigation button
   becomes a drawer icon |image--drawer-icon| if the destination uses a
   ``DrawerLayout``. If the destination doesn't use a ``DrawerLayout``,
   the Navigation button is hidden. When the user is on any other
   destination, the Navigation button appears as an Up button |image--up-button|.
   To configure the Navigation button using only the start destination
   as the top-level destination, create an ``AppBarConfiguration``
   object, and pass in the corresponding navigation graph, as shown
   below:

   .. |image--drawer-icon| image:: https://developer.android.google.cn/static/images/guide/navigation/drawer-icon.png 
      :class: inline-icon

   .. |image--up-button| image:: https://developer.android.google.cn/static/images/guide/navigation/up-button.png 
      :class: inline-icon


   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val appBarConfiguration = AppBarConfiguration(navController.graph)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               AppBarConfiguration appBarConfiguration =
                       new AppBarConfiguration.Builder(navController.getGraph()).build();

   In some cases, you might need to define multiple top-level
   destinations instead of using the default start destination. Using a
   ``BottomNavigationView`` is a common use case for this, where you may
   have sibling screens that are not hierarchically related to each
   other and may each have their own set of related destinations. For
   cases like these, you can instead pass a set of destination IDs to
   the constructor, as shown below:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val appBarConfiguration = AppBarConfiguration(setOf(R.id.main, R.id.profile))

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               AppBarConfiguration appBarConfiguration =
                       new AppBarConfiguration.Builder(R.id.main, R.id.profile).build();

   .. rubric:: Create a Toolbar
      :name: create_a_toolbar

   To create a Toolbar with ``NavigationUI``, first define the bar in
   your main activity, as shown:

   .. code:: prettyprint

      <LinearLayout>
          <androidx.appcompat.widget.Toolbar
              android:id="@+id/toolbar" />
          <androidx.fragment.app.FragmentContainerView
              android:id="@+id/nav_host_fragment"
              ... />
          ...
      </LinearLayout>

   Next, call
   `setupWithNavController() <#setupWithNavController>`__
   from your main activity's ``onCreate()`` method, as shown in the
   following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   setContentView(R.layout.activity_main)

                   ...

                   val navController = findNavController(R.id.nav_host_fragment)
                   val appBarConfiguration = AppBarConfiguration(navController.graph)
                   findViewById<Toolbar>(R.id.toolbar)
                       .setupWithNavController(navController, appBarConfiguration)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onCreate(Bundle savedInstanceState) {
                   setContentView(R.layout.activity_main);

                   ...

                   NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment);
                   AppBarConfiguration appBarConfiguration =
                           new AppBarConfiguration.Builder(navController.getGraph()).build();
                   Toolbar toolbar = findViewById(R.id.toolbar);
                   NavigationUI.setupWithNavController(
                           toolbar, navController, appBarConfiguration);
               }

   **Note:**\  When using a ``Toolbar``, Navigation automatically
   handles click events for the Navigation button, so you do not need to
   override
   `onSupportNavigateUp() <#onSupportNavigateUp>`__.
   To configure the Navigation button to appear as an Up button for all
   destinations, pass an empty set of destination IDs for your top-level
   destinations when building your ``AppBarConfiguration``. This can be
   useful if, for example, you have a second activity that should
   display an Up button in the ``Toolbar`` on all destinations. This
   allows the user to navigate back to the parent activity when there
   are no other destinations on the back stack. You can use
   `setFallbackOnNavigateUpListener() <#setFallbackOnNavigateUpListener>`__
   to control the fallback behavior for when ``navigateUp()`` would
   otherwise do nothing, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   ...

                   val navHostFragment =
                       supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment
                   val navController = navHostFragment.navController
                   val appBarConfiguration = AppBarConfiguration(
                       topLevelDestinationIds = setOf(),
                       fallbackOnNavigateUpListener = ::onSupportNavigateUp
                   )
                   findViewById<Toolbar>(R.id.toolbar)
                       .setupWithNavController(navController, appBarConfiguration)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onCreate(Bundle savedInstanceState) {
                   ...

                   NavHostFragment navHostFragment = (NavHostFragment) supportFragmentManager.findFragmentById(R.id.nav_host_fragment);
                   NavController navController = navHostFragment.getNavController();
                   AppBarConfiguration appBarConfiguration = new AppBarConfiguration.Builder()
                       .setFallbackOnNavigateUpListener(::onSupportNavigateUp)
                       .build();
                   Toolbar toolbar = findViewById(R.id.toolbar);
                   NavigationUI.setupWithNavController(
                           toolbar, navController, appBarConfiguration);
               }

   .. rubric:: Include CollapsingToolbarLayout
      :name: include_collapsingtoolbarlayout

   To include a ``CollapsingToolbarLayout`` with your Toolbar, first
   define the Toolbar and surrounding layout in your activity, as shown
   below:

   .. code:: prettyprint

      <LinearLayout>
          <com.google.android.material.appbar.AppBarLayout
              android:layout_width="match_parent"
              android:layout_height="@dimen/tall_toolbar_height">

              <com.google.android.material.appbar.CollapsingToolbarLayout
                  android:id="@+id/collapsing_toolbar_layout"
                  android:layout_width="match_parent"
                  android:layout_height="match_parent"
                  app:contentScrim="?attr/colorPrimary"
                  app:expandedTitleGravity="top"
                  app:layout_scrollFlags="scroll|exitUntilCollapsed|snap">

                  <androidx.appcompat.widget.Toolbar
                      android:id="@+id/toolbar"
                      android:layout_width="match_parent"
                      android:layout_height="?attr/actionBarSize"
                      app:layout_collapseMode="pin"/>
              </com.google.android.material.appbar.CollapsingToolbarLayout>
          </com.google.android.material.appbar.AppBarLayout>

          <androidx.fragment.app.FragmentContainerView
              android:id="@+id/nav_host_fragment"
              ... />
          ...
      </LinearLayout>

   Next, call
   `setupWithNavController() <#setupWithNavController>`__
   from your main activity's ``onCreate`` method, as shown below:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   setContentView(R.layout.activity_main)

                   ...

                   val layout = findViewById<CollapsingToolbarLayout>(R.id.collapsing_toolbar_layout)
                   val toolbar = findViewById<Toolbar>(R.id.toolbar)
                   val navHostFragment =
                       supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment
                   val navController = navHostFragment.navController
                   val appBarConfiguration = AppBarConfiguration(navController.graph)
                   layout.setupWithNavController(toolbar, navController, appBarConfiguration)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onCreate(Bundle savedInstanceState) {
                   setContentView(R.layout.activity_main);

                   ...

                   CollapsingToolbarLayout layout = findViewById(R.id.collapsing_toolbar_layout);
                   Toolbar toolbar = findViewById(R.id.toolbar);
                   NavHostFragment navHostFragment = supportFragmentManager.findFragmentById(R.id.nav_host_fragment);
                   NavController navController = navHostFragment.getNavController();
                   AppBarConfiguration appBarConfiguration =
                           new AppBarConfiguration.Builder(navController.getGraph()).build();
                   NavigationUI.setupWithNavController(layout, toolbar, navController, appBarConfiguration);
               }

   .. rubric:: Action bar
      :name: action_bar

   To add navigation support to the default action bar, call
   `setupActionBarWithNavController() <#setupActionBarWithNavController>`__
   from your main activity's ``onCreate()`` method, as shown below. Note
   that you need to declare your ``AppBarConfiguration`` outside of
   ``onCreate()``, since you also use it when overriding
   ``onSupportNavigateUp()``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private lateinit var appBarConfiguration: AppBarConfiguration

               ...

               override fun onCreate(savedInstanceState: Bundle?) {
                   ...

                   val navHostFragment =
                       supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment
                   val navController = navHostFragment.navController
                   appBarConfiguration = AppBarConfiguration(navController.graph)
                   setupActionBarWithNavController(navController, appBarConfiguration)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               AppBarConfiguration appBarConfiguration;

               ...

               @Override
               protected void onCreate(Bundle savedInstanceState) {
                   ...

                   NavHostFragment navHostFragment = supportFragmentManager.findFragmentById(R.id.nav_host_fragment);
                   NavController navController = navHostFragment.getNavController();
                   appBarConfiguration = new AppBarConfiguration.Builder(navController.getGraph()).build();
                   NavigationUI.setupActionBarWithNavController(this, navController, appBarConfiguration);
               }

   Next, override ``onSupportNavigateUp()`` to handle Up navigation:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onSupportNavigateUp(): Boolean {
                   val navController = findNavController(R.id.nav_host_fragment)
                   return navController.navigateUp(appBarConfiguration)
                           || super.onSupportNavigateUp()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onSupportNavigateUp() {
                   NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment);
                   return NavigationUI.navigateUp(navController, appBarConfiguration)
                           || super.onSupportNavigateUp();
               }

   .. rubric:: Support app bar variations
      :name: support_app_bar_variations

   Adding the top app bar to your activity works well when the app bar‚Äôs
   layout is similar for each destination in your app. If, however, your
   top app bar changes substantially across destinations, then consider
   removing the top app bar from your activity and defining it in each
   destination fragment, instead.

   As an example, one of your destinations may use a standard
   ``Toolbar``, while another uses an ``AppBarLayout`` to create a more
   complex app bar with tabs, as shown in figure 2.

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/app-bar-variations.png
      :alt: two top app bar variations; a standard toolbar on the left,
      and an appbarlayout with a toolbar and tabs on the right
      :width: 500px

      **Figure 2.** Two app bar variations. On the left, a standard
      ``Toolbar``. On the right, an ``AppBarLayout`` with a ``Toolbar``
      and tabs.

   To implement this example within your destination fragments using
   ``NavigationUI``, first define the app bar in each of your fragment
   layouts, beginning with the destination fragment that uses a standard
   toolbar:

   .. code:: prettyprint

      <LinearLayout>
          <androidx.appcompat.widget.Toolbar
              android:id="@+id/toolbar"
              ... />
          ...
      </LinearLayout>

   Next, define the destination fragment that uses an app bar with tabs:

   .. code:: prettyprint

      <LinearLayout>
          <com.google.android.material.appbar.AppBarLayout
              ... />

              <androidx.appcompat.widget.Toolbar
                  android:id="@+id/toolbar"
                  ... />

              <com.google.android.material.tabs.TabLayout
                  ... />

          </com.google.android.material.appbar.AppBarLayout>
          ...
      </LinearLayout>

   The navigation configuration logic is the same for both of these
   fragments, except that you should call
   `setupWithNavController() <#setupWithNavController>`__
   from within each fragment's ``onViewCreated()`` method, instead of
   initializing them from the activity:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                   val navController = findNavController()
                   val appBarConfiguration = AppBarConfiguration(navController.graph)

                   view.findViewById<Toolbar>(R.id.toolbar)
                           .setupWithNavController(navController, appBarConfiguration)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onViewCreated(@NonNull View view,
                                         @Nullable Bundle savedInstanceState) {
                   NavController navController = Navigation.findNavController(view);
                   AppBarConfiguration appBarConfiguration =
                           new AppBarConfiguration.Builder(navController.getGraph()).build();
                   Toolbar toolbar = view.findViewById(R.id.toolbar);

                   NavigationUI.setupWithNavController(
                           toolbar, navController, appBarConfiguration);
               }

   **Note:**\  Placing the top app bar into the destination fragment
   layout will result in the app bar animating with the rest of the
   layout during fragment transitions when a fragment transition is set.

   .. rubric:: Tie destinations to menu items
      :name: Tie-navdrawer

   ``NavigationUI`` also provides helpers for tying destinations to
   menu-driven UI components. ``NavigationUI`` contains a helper method,
   `onNavDestinationSelected() <#onnavdestinationselected>`__,
   which takes a `MenuItem <#>`__
   along with the
   `NavController <#>`__
   that hosts the associated destination. If the ``id`` of the
   ``MenuItem`` matches the ``id`` of the destination, the
   ``NavController`` can then navigate to that destination.

   As an example, the XML snippets below define a menu item and a
   destination with a common ``id``, ``details_page_fragment``:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          xmlns:android="http://schemas.android.com/apk/res/android"
          ... >

          ...

          <fragment android:id="@+id/details_page_fragment"
               android:label="@string/details"
               android:name="com.example.android.myapp.DetailsFragment" />
      </navigation>

   .. code:: prettyprint

      <menu xmlns:android="http://schemas.android.com/apk/res/android">

          ...

          <item
              android:id="@+id/details_page_fragment"
              android:icon="@drawable/ic_details"
              android:title="@string/details" />
      </menu>

   If your menu was added via the Activity's ``onCreateOptionsMenu()``,
   for example, you can associate the menu items with destinations by
   overriding the Activity's ``onOptionsItemSelected()`` to call
   ``onNavDestinationSelected()``, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onOptionsItemSelected(item: MenuItem): Boolean {
                   val navController = findNavController(R.id.nav_host_fragment)
                   return item.onNavDestinationSelected(navController) || super.onOptionsItemSelected(item)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onOptionsItemSelected(MenuItem item) {
                   NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment);
                   return NavigationUI.onNavDestinationSelected(item, navController)
                           || super.onOptionsItemSelected(item);
               }

   Now, when a user clicks the ``details_page_fragment`` menu item, the
   app automatically navigates to the corresponding destination with the
   same ``id``.

   .. rubric:: Add a navigation drawer
      :name: add_a_navigation_drawer

   The navigation drawer is a UI panel that shows your app's main
   navigation menu. The drawer appears when the user touches the drawer
   icon |image-drawer-icon| in the app bar or when the user swipes a finger from
   the left edge of the screen.

   .. |image-drawer-icon| image:: https://developer.android.google.cn/static/images/guide/navigation/drawer-icon.png 
      :class: inline-icon

   .. figure::
      https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-drawer.png
      :alt: an open drawer displaying a navigation menu
      :width: 337px

      **Figure 3.** An open drawer displaying a navigation menu.

   The drawer icon is displayed on all `top-level destinations <#appbarconfiguration>`__ that use a ``DrawerLayout``.

   To add a navigation drawer, first declare a
   `DrawerLayout <#>`__
   as the root view. Inside the ``DrawerLayout``, add a layout for the
   main UI content and another view that contains the contents of the
   navigation drawer.

   For example, the following layout uses a ``DrawerLayout`` with two
   child views: a
   `NavHostFragment <#>`__
   to contain the main content and a
   `NavigationView <#>`__
   for the contents of the navigation drawer.

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <!-- Use DrawerLayout as root container for activity -->
      <androidx.drawerlayout.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:id="@+id/drawer_layout"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          android:fitsSystemWindows="true">

          <!-- Layout to contain contents of main body of screen (drawer will slide over this) -->
          <androidx.fragment.app.FragmentContainerView
              android:name="androidx.navigation.fragment.NavHostFragment"
              android:id="@+id/nav_host_fragment"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              app:defaultNavHost="true"
              app:navGraph="@navigation/nav_graph" />

          <!-- Container for contents of drawer - use NavigationView to make configuration easier -->
          <com.google.android.material.navigation.NavigationView
              android:id="@+id/nav_view"
              android:layout_width="wrap_content"
              android:layout_height="match_parent"
              android:layout_gravity="start"
              android:fitsSystemWindows="true" />

      </androidx.drawerlayout.widget.DrawerLayout>

   Next, connect the
   `DrawerLayout <#>`__
   to your navigation graph by passing it to ``AppBarConfiguration``, as
   shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val appBarConfiguration = AppBarConfiguration(navController.graph, drawerLayout)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               AppBarConfiguration appBarConfiguration =
                       new AppBarConfiguration.Builder(navController.getGraph())
                           .setDrawerLayout(drawerLayout)
                           .build();

   **Note:**\  When using ``NavigationUI``, the `top app bar <#top-app-bar>`__ helpers automatically transition between the
   drawer icon and the Up icon as the current destination changes. You
   don't need to use
   `ActionBarDrawerToggle <#>`__.
   Next, in your main activity class, call
   `setupWithNavController() <#setupWithNavController>`__
   from your main activity's ``onCreate()`` method, as shown below:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   setContentView(R.layout.activity_main)

                   ...

                   val navHostFragment =
                       supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment
                   val navController = navHostFragment.navController
                   findViewById<NavigationView>(R.id.nav_view)
                       .setupWithNavController(navController)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onCreate(Bundle savedInstanceState) {
                   setContentView(R.layout.activity_main);

                   ...

                   NavHostFragment navHostFragment = supportFragmentManager.findFragmentById(R.id.nav_host_fragment);
                   NavController navController = navHostFragment.getNavController();
                   NavigationView navView = findViewById(R.id.nav_view);
                   NavigationUI.setupWithNavController(navView, navController);
               }

   **Note:**\  Setting up the navigation drawer requires that you also
   set up your navigation graph and menu xml as described in `Tie destinations to menu items <#Tie-navdrawer>`__.
   Starting in `Navigation 2.4.0-alpha01 <#2.4.0-alpha01>`__,
   the state of each menu item is saved and restored when you use
   ``setupWithNavController``.

   .. rubric:: Bottom navigation
      :name: bottom_navigation

   ``NavigationUI`` can also handle bottom navigation. When a user
   selects a menu item, the ``NavController`` calls
   `onNavDestinationSelected() <#onNavDestinationSelected>`__
   and automatically updates the selected item in the bottom navigation
   bar.

   .. figure::
      https://developer.android.google.cn/static/topic/libraries/architecture/images/bottom-navigation.png
      :alt: bottom navigation bar

      **Figure 4.** A bottom navigation bar.

   To create a bottom navigation bar in your app, first define the bar
   in your main activity, as shown below:

   .. code:: prettyprint

      <LinearLayout>
          ...
          <androidx.fragment.app.FragmentContainerView
              android:id="@+id/nav_host_fragment"
              ... />
          <com.google.android.material.bottomnavigation.BottomNavigationView
              android:id="@+id/bottom_nav"
              app:menu="@menu/menu_bottom_nav" />
      </LinearLayout>

   Next, in your main activity class, call
   `setupWithNavController() <#setupWithNavController>`__
   from your main activity's ``onCreate()`` method, as shown below:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   setContentView(R.layout.activity_main)

                   ...

                   val navHostFragment =
                       supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment
                   val navController = navHostFragment.navController
                   findViewById<BottomNavigationView>(R.id.bottom_nav)
                       .setupWithNavController(navController)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onCreate(Bundle savedInstanceState) {
                   setContentView(R.layout.activity_main);

                   ...

                   NavHostFragment navHostFragment = supportFragmentManager.findFragmentById(R.id.nav_host_fragment);
                   NavController navController = navHostFragment.getNavController();
                   BottomNavigationView bottomNav = findViewById(R.id.bottom_nav);
                   NavigationUI.setupWithNavController(bottomNav, navController);
               }

   **Note:**\  Setting up bottom navigation requires that you also set
   up your navigation graph and menu xml as described in `Tie destinations to menu items <#Tie-navdrawer>`__.
   Starting in `Navigation 2.4.0-alpha01 <#2.4.0-alpha01>`__,
   the state of each menu item is saved and restored when you use
   ``setupWithNavController``.

   For a comprehensive example that includes bottom navigation, see the
   `Android Architecture Components Advanced Navigation Sample <https://github.com/android/architecture-components-samples/tree/main/NavigationAdvancedSample>`__
   on GitHub.

   .. rubric:: Listen for navigation events
      :name: listen_for_navigation_events

   Interacting with the
   `NavController <#>`__
   is the primary method for navigating between destinations. The
   ``NavController`` is responsible for replacing the contents of the
   `NavHost <#>`__ with the new
   destination. In many cases, UI elements‚Äîsuch as a top app bar or
   other persistent navigation controls like a
   ``BottomNavigationBar``‚Äîlive outside of the ``NavHost`` and need to
   be updated as you navigate between destinations.

   ``NavController`` offers an ``OnDestinationChangedListener``
   interface that is called when the ``NavController``'s `current destination <#getCurrentDestination%28%29>`__
   or its arguments change. A new listener can be registered via the
   `addOnDestinationChangedListener() <#addOnDestinationChangedListener%28androidx.navigation.NavController.OnDestinationChangedListener%29>`__
   method. Note that when calling ``addOnDestinationChangedListener()``,
   if the current destination exists, it's immediately sent to your
   listener.

   ``NavigationUI`` uses ``OnDestinationChangedListener`` to make these
   common UI components navigation-aware. Note, however, that you can
   also use ``OnDestinationChangedListener`` on its own to make any
   custom UI or business logic aware of navigation events.

   As an example, you might have common UI elements that you intend to
   show in some areas of your app while hiding them in others. Using
   your own ``OnDestinationChangedListener``, you can selectively show
   or hide these UI elements based on the target destination, as shown
   in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               navController.addOnDestinationChangedListener { _, destination, _ ->
                  if(destination.id == R.id.full_screen_destination) {
                      toolbar.visibility = View.GONE
                      bottomNavigationView.visibility = View.GONE
                  } else {
                      toolbar.visibility = View.VISIBLE
                      bottomNavigationView.visibility = View.VISIBLE
                  }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               navController.addOnDestinationChangedListener(new NavController.OnDestinationChangedListener() {
                  @Override
                  public void onDestinationChanged(@NonNull NavController controller,
                          @NonNull NavDestination destination, @Nullable Bundle arguments) {
                      if(destination.getId() == R.id.full_screen_destination) {
                          toolbar.setVisibility(View.GONE);
                          bottomNavigationView.setVisibility(View.GONE);
                      } else {
                          toolbar.setVisibility(View.VISIBLE);
                          bottomNavigationView.setVisibility(View.VISIBLE);
                      }
                  }
               });

   .. rubric:: Argument-based listeners
      :name: argument

   As an alternative, you can also use arguments with default values
   within the navigation graph, which can be used by the appropriate UI
   controller to update its state. For example, rather than base the
   logic in the ``OnDestinationChangedListener`` on the destination ID
   as per the previous example, we can create an argument in the
   ``NavGraph``:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:id="@+id/navigation\_graph"
          app:startDestination="@id/fragmentOne">
          <fragment
              android:id="@+id/fragmentOne"
              android:name="com.example.android.navigation.FragmentOne"
              android:label="FragmentOne">
              <action
                  android:id="@+id/action\_fragmentOne\_to\_fragmentTwo"
                  app:destination="@id/fragmentTwo" />
          </fragment>
          <fragment
              android:id="@+id/fragmentTwo"
              android:name="com.example.android.navigation.FragmentTwo"
              android:label="FragmentTwo">
              <argument
                  android:name="ShowAppBar"
                  android:defaultValue="true" />
          </fragment>
      </navigation>

   This argument isn't used when `navigating to the destination <#>`__, but rather as
   a way to attach additional information to the destination by using
   the ``defaultValue``. In this case, the value indicates whether the
   app bar should be shown when on this destination.

   We can now add an ``OnDestinationChangedListener`` in the
   ``Activity``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               navController.addOnDestinationChangedListener { _, _, arguments ->
                   appBar.isVisible = arguments?.getBoolean("ShowAppBar", false) == true
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               navController.addOnDestinationChangedListener(
                       new NavController.OnDestinationChangedListener() {
                           @Override
                           public void onDestinationChanged(
                                   @NonNull NavController controller,
                                   @NonNull NavDestination destination,
                                   @Nullable Bundle arguments
                           ) {
                               boolean showAppBar = false;
                               if (arguments != null) {
                                   showAppBar = arguments.getBoolean("ShowAppBar", false);
                               }
                               if(showAppBar) {
                                   appBar.setVisibility(View.VISIBLE);
                               } else {
                                   appBar.setVisibility(View.GONE);
                               }
                           }
                       }
               );

   The
   `NavController <#>`__
   invokes this callback whenever the navigation destination changes.
   The ``Activity`` can now update the state or visibility of the UI
   components that it owns based upon the arguments received in the
   callback.

   One advantage of this approach is that the ``Activity`` sees only the
   arguments in the navigation graph and doesn't know individual
   ``Fragment`` roles and responsibilities. Similarly, the individual
   fragments do not know about the containing ``Activity`` and the UI
   components that it owns.

   .. rubric:: Additional resources
      :name: resources

   To learn more about navigation, see the following additional
   resources.

   .. rubric:: Samples
      :name: samples

   -  `Android Architecture Components Basic Navigation Sample <https://github.com/android/architecture-components-samples/tree/main/NavigationBasicSample>`__
   -  `Android Architecture Components Advanced Navigation Sample <https://github.com/android/architecture-components-samples/tree/main/NavigationAdvancedSample>`__

   .. rubric:: Codelabs
      :name: codelabs

   -  `Navigation codelab <https://developers.google.cn/codelabs/codelabs/android-navigation/index.html?index=..%2F..%2Findex#0>`__

   .. rubric:: Blog posts
      :name: blog

   -  `LiveData with SnackBar, Navigation and other events (the SingleLiveEvent case) <https://medium.com/androiddevelopers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150>`__

   .. rubric:: Videos
      :name: videos

   -  `10 Best Practices for Moving to a Single Activity <https://www.youtube.com/watch?v=9O1D_Ytk0xg>`__
   -  `Single Activity: Why, When, and How (Android Dev Summit '18) <https://www.youtube.com/watch?v=2k8x8V77CrU>`__
   -  `Android Jetpack: manage UI navigation with Navigation Controller (Google I/O '18) <https://www.youtube.com/watch?v=8GCXtCjtg40>`__


Last updated 2024-02-20 UTC.



/Migrate to the Navigation component
====================================

.. container:: devsite-article-body clearfix

   The `Navigation component <#>`__ is a library
   that can manage complex navigation, transition animation, deep
   linking, and compile-time checked argument passing between the
   screens in your app.

   This document serves as a general-purpose guide to migrate an
   existing app to use the Navigation component.

   **Note:**\  This documentation uses fragments as examples, as they
   allow for integration with other `Jetpack lifecycle-aware components <#android-jetpack-components>`__. In addition to
   fragments, the Navigation component also supports `custom destinations <#>`__.
   At a high level, migration involves these steps:

   #. `Move screen-specific UI logic out of activities <#move>`__ - Move
      your app‚Äôs UI logic out of activities, ensuring that each activity
      owns only the logic of global navigation UI components, such as a
      ``Toolbar``, while delegating the implementation of each screen to
      a fragment or custom destination.

   #. `Integrate the Navigation component <#integrate>`__ - For each
      activity, build a navigation graph which contains the one or more
      fragments managed by that activity. Replace fragment transactions
      with Navigation component operations.

   #. `Add activity destinations <#add>`__ - Replace ``startActivity()``
      calls with actions using activity destinations.

   #. `Combine activities <#combine>`__ - Combine navigation graphs in
      cases where multiple activities share a common layout.

   **Important:**\  To ensure success, approach migration as an
   iterative process, thoroughly testing your app with each step. While
   a single-activity architecture allows you to take full advantage of
   the Navigation component, you do not need to fully migrate your app
   to benefit from Navigation.

   .. rubric:: Prerequisites
      :name: prerequisites

   This guide assumes that you have already migrated your app to use
   `AndroidX <#>`__ libraries. If you have not done so,
   `migrate your project <#>`__ to use AndroidX
   before continuing.

   .. rubric:: Move screen-specific UI logic out of activities
      :name: move

   **Note:**\  This section contains guidance on introducing fragments
   to an activity-based app. If your app is already using fragments, you
   can skip ahead to the `Integrate the Navigation component <#integrate>`__ section.
   Activities are system-level components that facilitate a graphical
   interaction between your app and Android. Activities are registered
   in your app‚Äôs manifest so that Android knows which activities are
   available to launch. The activity class enables your app to react to
   Android changes as well, such as when your app‚Äôs UI is entering or
   leaving the foreground, rotating, and so on. The activity can also
   serve as a place to `share state between screens <#>`__.

   Within the context of your app, activities should serve as a host for
   navigation and should hold the logic and knowledge of how to
   transition between screens, pass data, and so on. However, managing
   the details of your UI is better left to a smaller, reusable part of
   your UI. The recommended implementation for this pattern is
   `fragments <#>`__. See `Single Activity: Why, When, and How <https://www.youtube.com/watch?v=2k8x8V77CrU>`__
   to learn more about the advantages of using fragments. Navigation
   supports fragments via the *navigation-fragment* dependency.
   Navigation also supports `custom destination types <#>`__.

   If your app is not using fragments, the first thing you need to do is
   migrate each screen in your app to use a fragment. You aren't
   removing the activity at this point. Rather, you're creating a
   fragment to represent the screen and break apart your UI logic by
   responsibility.

   .. rubric:: Introducing fragments
      :name: introducing_fragments

   To illustrate the process of introducing fragments, let‚Äôs start with
   an example of an application that consists of two screens: a *product
   list* screen and a *product details* screen. Clicking on a product in
   the list screen takes the user to a details screen to learn more
   about the product.

   
   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-migrate-product-details.png


   In this example, the list and details screens are currently separate
   activities.

   **Note:**\  As you migrate to a fragment-based architecture, it‚Äôs
   important to focus on one screen at a time. You may find it helpful
   to start from your app‚Äôs launch screen and work your way through your
   app. This example focuses on migrating only the list screen.

   .. rubric:: Create a New Layout to Host the UI
      :name: create_a_new_layout_to_host_the_ui

   To introduce a fragment, start by creating a new layout file for the
   activity to host the fragment. This replaces the activity‚Äôs current
   content view layout.

   For a simple view, you can use a ``FrameLayout``, as shown in the
   following example ``product_list_host``:

   .. code:: prettyprint

      <FrameLayout
         xmlns:app="http://schemas.android.com/apk/res-auto"
         xmlns:android="http://schemas.android.com/apk/res/android"
         android:id="@+id/main_content"
         android:layout_height="match_parent"
         android:layout_width="match_parent" />

   The ``id`` attribute refers to the content section where we later add
   the fragment.

   Next, in your activity's ``onCreate()`` function, modify the layout
   file reference in your activity‚Äôs onCreate function to point to this
   new layout file:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            class ProductListActivity : AppCompatActivity() {
                ...
                override fun onCreate(savedInstanceState: Bundle?) {
                    ...
                    // Replace setContentView(R.layout.product_list) with the line below
                    setContentView(R.layout.product_list_host)
                    ...
                }
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            public class ProductListActivity extends AppCompatActivity {
                ...
                @Override
                public void onCreate(@Nullable Bundle savedInstanceState) {
                    ...
                    // Replace setContentView(R.layout.product_list); with the line below
                    setContentView(R.layout.product_list_host);
                    ...
                }
            }

   The existing layout (``product_list``, in this example) is used as
   the root view for the fragment you are about to create.

   .. rubric:: Create a fragment
      :name: create_a_fragment

   Create a new fragment to manage the UI for your screen. It's a good
   practice to be consistent with your activity host name. The snippet
   below uses ``ProductListFragment``, for example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ProductListFragment : Fragment() {
                   // Leave empty for now.
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ProductListFragment extends Fragment {
                   // Leave empty for now.
               }

   .. rubric:: Move activity logic into a fragment
      :name: move_activity_logic_into_a_fragment

   With the fragment definition in place, the next step is to move the
   UI logic for this screen from the activity into this new fragment. If
   you are coming from an activity-based architecture, you likely have a
   lot of view creation logic happening in your activity's
   ``onCreate()`` function.

   Here's an example activity-based screen with UI logic that we need to
   move:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ProductListActivity : AppCompatActivity() {

                   // Views and/or ViewDataBinding references, Adapters...
                   private lateinit var productAdapter: ProductAdapter
                   private lateinit var binding: ProductListActivityBinding

                   ...

                   // ViewModels, System Services, other Dependencies...
                   private val viewModel: ProductListViewModel by viewModels()

                   ...

                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)

                       // View initialization logic
                       DataBindingUtil.setContentView(this, R.layout.product_list_activity)

                       // Post view initialization logic
                       // Connect adapters
                       productAdapter = ProductAdapter(productClickCallback)
                       binding.productsList.setAdapter(productAdapter)

                       // Initialize view properties, set click listeners, etc.
                       binding.productsSearchBtn.setOnClickListener {...}

                       // Subscribe to state
                       viewModel.products.observe(this, Observer { myProducts ->
                           ...
                       })

                       // ...and so on
                   }
                  ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ProductListActivity extends AppCompatActivity {

                   // Views and/or ViewDataBinding references, adapters...
                   private ProductAdapter productAdapter;
                   private ProductListActivityBinding binding;

                   ...

                   // ViewModels, system services, other dependencies...
                   private ProductListViewModel viewModel;

                   ...

                   @Override
                   protected void onCreate(@Nullable Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);

                       // View initialization logic
                       DataBindingUtil.setContentView(this, R.layout.product_list_activity);

                       // Post view initialization logic
                       // Connect adapters
                       productAdapter = new ProductAdapter(productClickCallback);
                       binding.productsList.setAdapter(productAdapter);

                       // Initialize ViewModels and other dependencies
                       ProductListViewModel viewModel = new ViewModelProvider(this).get(ProductListViewModel.java);

                       // Initialize view properties, set click listeners, etc.
                       binding.productsSearchBtn.setOnClickListener(v -> { ... });

                       // Subscribe to state
                       viewModel.getProducts().observe(this, myProducts ->
                           ...
                      );

                      // ...and so on
                  }

   Your activity might also be controlling when and how the user
   navigates to the next screen, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

                   // Provided to ProductAdapter in ProductListActivity snippet.
                   private val productClickCallback = ProductClickCallback { product ->
                       show(product)
                   }

                   fun show(product: Product) {
                       val intent = Intent(this, ProductActivity::class.java)
                       intent.putExtra(ProductActivity.KEY_PRODUCT_ID, product.id)
                       startActivity(intent)
                   }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Provided to ProductAdapter in ProductListActivity snippet.
               private ProductClickCallback productClickCallback = this::show;

               private void show(Product product) {
                   Intent intent = new Intent(this, ProductActivity.class);
                   intent.putExtra(ProductActivity.KEY_PRODUCT_ID, product.getId());
                   startActivity(intent);
               }

   Inside your fragment, you distribute this work between
   `onCreateView() <#onCreateView>`__
   and
   `onViewCreated() <#onViewCreated>`__,
   with only the navigation logic remaining in the activity:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ProductListFragment : Fragment() {

                   private lateinit var binding: ProductListFragmentBinding
                   private val viewModel: ProductListViewModel by viewModels()

                    // View initialization logic
                   override fun onCreateView(inflater: LayoutInflater,
                           container: ViewGroup?,
                           savedInstanceState: Bundle?): View? {
                       binding = DataBindingUtil.inflate(
                               inflater,
                               R.layout.product_list,
                               container,
                               false
                       )
                       return binding.root
                   }

                   // Post view initialization logic
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       // Connect adapters
                       productAdapter = ProductAdapter(productClickCallback)
                       binding.productsList.setAdapter(productAdapter)

                       // Initialize view properties, set click listeners, etc.
                       binding.productsSearchBtn.setOnClickListener {...}

                       // Subscribe to state
                       viewModel.products.observe(this, Observer { myProducts ->
                           ...
                       })

                       // ...and so on
                   }

                   // Provided to ProductAdapter
                   private val productClickCallback = ProductClickCallback { product ->
                       if (lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) {
                           (requireActivity() as ProductListActivity).show(product)
                       }
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ProductListFragment extends Fragment {

                   private ProductAdapter productAdapter;
                   private ProductListFragmentBinding binding;

                   // View initialization logic
                   @Nullable
                   @Override
                   public View onCreateView(@NonNull LayoutInflater inflater,
                           @Nullable ViewGroup container,
                           @Nullable Bundle savedInstanceState) {
                       binding = DataBindingUtil.inflate(
                               inflater,
                               R.layout.product_list_fragment,
                               container,
                               false);
                       return binding.getRoot();
                   }

                   // Post view initialization logic
                   @Override
                   public void onViewCreated(@NonNull View view,
                           @Nullable Bundle savedInstanceState) {

                       // Connect adapters
                       binding.productsList.setAdapter(productAdapter);

                       // Initialize ViewModels and other dependencies
                       ProductListViewModel viewModel = new ViewModelProvider(this)
                               .get(ProductListViewModel.class);

                       // Initialize view properties, set click listeners, etc.
                       binding.productsSearchBtn.setOnClickListener(...)

                       // Subscribe to state
                       viewModel.getProducts().observe(this, myProducts -> {
                           ...
                      });

                      // ...and so on

                   // Provided to ProductAdapter
                   private ProductClickCallback productClickCallback = new ProductClickCallback() {
                       @Override
                       public void onClick(Product product) {
                           if (getLifecycle().getCurrentState().isAtLeast(Lifecycle.State.STARTED)) {
                               ((ProductListActivity) requireActivity()).show(product);
                           }
                       }
                   };
                   ...
               }

   In ``ProductListFragment``, notice that there is no call to
   `setContentView() <#setContentView>`__
   to inflate and connect the layout. In a fragment, ``onCreateView()``
   initializes the root view. ``onCreateView()`` takes an instance of a
   `LayoutInflater <#>`__ which
   can be used to inflate the root view based on a layout resource file.
   This example reuses the existing ``product_list`` layout which was
   used by the activity because nothing needs to change to the layout
   itself.

   If you have any UI logic residing in your activity‚Äôs ``onStart()``,
   ``onResume()``, ``onPause()`` or ``onStop()`` functions that are not
   related to navigation, you can move those to corresponding functions
   of the same name on the fragment.

   **Note:**\  A fragment‚Äôs lifecycle is managed by its host activity
   and has additional lifecycle callbacks other than the ones used in
   this example. Your app might have a reason to override other
   lifecycle functions, as well. For a complete list of fragment
   lifecycle functions and when to use them, see the `guide to fragments <#Creating>`__.

   .. rubric:: Initialize the fragment in the host activity
      :name: initialize_the_fragment_in_the_host_activity

   Once you have moved all of the UI logic down to the fragment, only
   navigation logic should remain in the activity.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ProductListActivity : AppCompatActivity() {

                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setContentView(R.layout.product_list_host)
                   }

                   fun show(product: Product) {
                       val intent = Intent(this, ProductActivity::class.java)
                       intent.putExtra(ProductActivity.KEY_PRODUCT_ID, product.id)
                       startActivity(intent)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ProductListActivity extends AppCompatActivity {

                   @Override
                   protected void onCreate(@Nullable Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       setContentView(R.layout.product_list_host);
                   }

                   public void show(Product product) {
                       Intent intent = new Intent(this, ProductActivity.class);
                       intent.putExtra(ProductActivity.KEY_PRODUCT_ID, product.getId());
                       startActivity(intent);
                   }
               }

   The last step is to create an instance of the fragment in
   ``onCreate()``, just after setting the content view:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)
                   setContentView(R.layout.product_list_host)

                   if (savedInstanceState == null) {
                       val fragment = ProductListFragment()
                       supportFragmentManager
                               .beginTransaction()
                               .add(R.id.main_content, fragment)
                               .commit()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onCreate(@Nullable Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);
                   setContentView(R.layout.product_list_host);

                   if (savedInstanceState == null) {
                       ProductListFragment fragment = new ProductListFragment();
                       getSupportFragmentManager()
                               .beginTransaction()
                               .add(R.id.main_content, fragment)
                               .commit();
                   }
               }

   As shown in this example, ``FragmentManager`` automatically saves and
   restores fragments over configuration changes, so you only need to
   add the fragment if the ``savedInstanceState`` is null.

   .. rubric:: Pass intent extras to the fragment
      :name: pass_intent_extras_to_the_fragment

   If your activity receives ``Extras`` through an intent, you can pass
   these to the fragment directly as arguments.

   In this example, the ``ProductDetailsFragment`` receives its
   arguments directly from the activity‚Äôs intent extras:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               ...

               if (savedInstanceState == null) {
                   val fragment = ProductDetailsFragment()

                   // Intent extras and Fragment Args are both of type android.os.Bundle.
                   fragment.arguments = intent.extras

                   supportFragmentManager
                           .beginTransaction()
                           .add(R.id.main_content, fragment)
                           .commit()
               }

               ...

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ...

               if (savedInstanceState == null) {
                   ProductDetailsFragment fragment = new ProductDetailsFragment();

                   // Intent extras and fragment Args are both of type android.os.Bundle.
                   fragment.setArguments(getIntent().getExtras());

                   getSupportFragmentManager()
                           .beginTransaction()
                           .add(R.id.main_content, fragment)
                           .commit();
               }

               ...

   At this point, you should be able to test running your app with the
   first screen updated to use a fragment. Continue to migrate the rest
   of your activity-based screens, taking time to test after each
   iteration.

   .. rubric:: Integrate the Navigation component
      :name: integrate

   Once you're using a fragment-based architecture, you are ready to
   start integrating the Navigation component.

   First, add the most recent Navigation dependencies to your project,
   following the instructions in the `Navigation library release notes <#>`__.

   .. rubric:: Create a navigation graph
      :name: create_a_navigation_graph

   The Navigation component represents your app‚Äôs navigation
   configuration in a resource file as a graph, much like your app‚Äôs
   views are represented. This helps keep your app‚Äôs navigation
   organized outside of your codebase and provides a way for you to edit
   your app navigation visually.

   To create a navigation graph, start by creating a new resource folder
   called ``navigation``. To add the graph, right-click on this
   directory, and choose **New > Navigation resource file**.

   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-migrate-new-graph.png
      :width: 400px

   The Navigation component uses an activity as a `host for navigation <#>`__
   and swaps individual fragments into that host as your users navigate
   through your app. Before you can start to layout out your app‚Äôs
   navigation visually, you need to configure a ``NavHost`` inside of
   the activity that is going to host this graph. Since we're using
   fragments, we can use the Navigation component's default ``NavHost``
   implementation,
   `NavHostFragment <#>`__.

   **Note:**\  If your app uses multiple activities, each activity uses
   a separate navigation graph. To take full advantage of the Navigation
   component, your app should use multiple fragments in a single
   activity. However, activities can still benefit from the Navigation
   component. Note, however, that your app‚Äôs UI must be visually broken
   up across several navigation graphs.
   A ``NavHostFragment`` is configured via a
   `FragmentContainerView <#>`__
   placed inside of a host activity, as shown in the following example:

   .. code:: prettyprint

      <androidx.fragment.app.FragmentContainerView
         android:name="androidx.navigation.fragment.NavHostFragment"
         app:navGraph="@navigation/product_list_graph"
         app:defaultNavHost="true"
         android:id="@+id/main_content"
         android:layout_width="match_parent"
         android:layout_height="match_parent" />

   The ``app:NavGraph`` attribute points to the navigation graph
   associated with this navigation host. Setting this property inflates
   the nav graph and sets the graph property on the ``NavHostFragment``.
   The ``app:defaultNavHost`` attribute ensures that your
   ``NavHostFragment`` intercepts the system Back button.

   If you‚Äôre using top-level navigation such as a ``DrawerLayout`` or
   ``BottomNavigationView``, this
   `FragmentContainerView <#>`__
   replaces your main content view element. See `Update UI components with NavigationUI <#>`__
   for examples.

   For a simple layout, you can include this
   `FragmentContainerView <#>`__
   element as a child of the root ``ViewGroup``:

   .. code:: prettyprint

      <FrameLayout
         xmlns:app="http://schemas.android.com/apk/res-auto"
         xmlns:android="http://schemas.android.com/apk/res/android"
         android:layout_height="match_parent"
         android:layout_width="match_parent">

      <androidx.fragment.app.FragmentContainerView
         android:id="@+id/main_content"
         android:name="androidx.navigation.fragment.NavHostFragment"
         app:navGraph="@navigation/product_list_graph"
         app:defaultNavHost="true"
         android:layout_width="match_parent"
         android:layout_height="match_parent" />

      </FrameLayout>

   If you click on the **Design** tab at the bottom, you should see a
   graph similar to the one shown below. In the upper left hand side of
   the graph, under **Destinations**, you can see a reference to the
   ``NavHost`` activity in the form of ``layout_name (resource_id)``.

   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-migrate-nav-editor.png

   Click the plus button |image-navigation-new-destination-icon| near the top 
   to add your fragments to this graph.

   The Navigation component refers to individual screens as
   *destinations*. Destinations can be fragments, activities, or custom
   destinations. You can add any type of destination to your graph, but
   note that activity destinations are considered *terminal
   destinations*, because once you navigate to an activity destination,
   you are operating within a separate navigation host and graph.

   The Navigation component refers to the way in which users get from
   one destination to another as *actions*. Actions can also describe
   transition animations and pop behavior.

   .. rubric:: Remove fragment transactions
      :name: remove_fragment_transactions

   Now that you are using the Navigation component, if you are
   navigating between fragment-based screens under the same activity,
   you can remove
   `FragmentManager <#>`__
   interactions.

   If your app is using multiple fragments under the same activity or
   top-level navigation such as a drawer layout or bottom navigation,
   then you are probably using a ``FragmentManager`` and
   `FragmentTransactions <#>`__
   to add or replace fragments in the main content section of your UI.
   This can now be replaced and simplified using the Navigation
   component by providing actions to link destinations within your graph
   and then navigating using the ``NavController``.

   Here are a few scenarios you might encounter along with how you might
   approach migration for each scenario.

   .. rubric:: Single activity managing multiple fragments
      :name: single_activity_managing_multiple_fragments

   If you have a single activity that manages multiple fragments, your
   activity code might look like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MainActivity : AppCompatActivity() {

                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setContentView(R.layout.activity_main)

                       // Logic to load the starting destination
                       //  when the Activity is first created
                       if (savedInstanceState == null) {
                           val fragment = ProductListFragment()
                           supportFragmentManager.beginTransaction()
                                   .add(R.id.fragment_container, fragment, ProductListFragment.TAG)
                                   .commit()
                       }
                   }

                   // Logic to navigate the user to another destination.
                   // This may include logic to initialize and set arguments on the destination
                   // fragment or even transition animations between the fragments (not shown here).
                   fun navigateToProductDetail(productId: String) {
                       val fragment = new ProductDetailsFragment()
                       val args = Bundle().apply {
                           putInt(KEY_PRODUCT_ID, productId)
                       }
                       fragment.arguments = args

                       supportFragmentManager.beginTransaction()
                               .addToBackStack(ProductDetailsFragment.TAG)
                               .replace(R.id.fragment_container, fragment, ProductDetailsFragment.TAG)
                               .commit()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends AppCompatActivity {

                   @Override
                   protected void onCreate(@Nullable Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       setContentView(R.layout.activity_main);

                       // Logic to load the starting destination when the activity is first created.
                       if (savedInstanceState == null) {
                           val fragment = ProductListFragment()
                           supportFragmentManager.beginTransaction()
                                   .add(R.id.fragment_container, fragment, ProductListFragment.TAG)
                                   .commit();
                       }
                   }

                   // Logic to navigate the user to another destination.
                   // This may include logic to initialize and set arguments on the destination
                   // fragment or even transition animations between the fragments (not shown here).
                   public void navigateToProductDetail(String productId) {
                       Fragment fragment = new ProductDetailsFragment();
                       Bundle args = new Bundle();
                       args.putInt(KEY_PRODUCT_ID, productId);
                       fragment.setArguments(args);

                       getSupportFragmentManager().beginTransaction()
                               .addToBackStack(ProductDetailsFragment.TAG)
                               .replace(R.id.fragment_container, fragment, ProductDetailsFragment.TAG)
                               .commit();
                   }
               }

   Inside of the source destination, you might be invoking a navigation
   function in response to some event, as shown below:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ProductListFragment : Fragment() {
                   ...
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       // In this example a callback is passed to respond to an item clicked
                       //  in a RecyclerView
                       productAdapter = ProductAdapter(productClickCallback)
                       binding.productsList.setAdapter(productAdapter)
                   }
                   ...

                   // The callback makes the call to the activity to make the transition.
                   private val productClickCallback = ProductClickCallback { product ->
                           (requireActivity() as MainActivity).navigateToProductDetail(product.id)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ProductListFragment extends Fragment  {
                   ...
                   @Override
                   public void onViewCreated(@NonNull View view,
                           @Nullable Bundle savedInstanceState) {
                   // In this example a callback is passed to respond to an item clicked in a RecyclerView
                       productAdapter = new ProductAdapter(productClickCallback);
                       binding.productsList.setAdapter(productAdapter);
                   }
                   ...

                   // The callback makes the call to the activity to make the transition.
                   private ProductClickCallback productClickCallback = product -> (
                       ((MainActivity) requireActivity()).navigateToProductDetail(product.getId())
                   );
               }

   This can be replaced by updating your navigation graph to set the
   start destination and actions to link your destinations and define
   arguments where required:

   .. code:: prettyprint

      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          android:id="@+id/product_list_graph"
          app:startDestination="@id/product_list">

          <fragment
              android:id="@+id/product_list"
              android:name="com.example.android.persistence.ui.ProductListFragment"
              android:label="Product List"
              tools:layout="@layout/product_list">
              <action
                  android:id="@+id/navigate_to_product_detail"
                  app:destination="@id/product_detail" />
          </fragment>
          <fragment
              android:id="@+id/product_detail"
              android:name="com.example.android.persistence.ui.ProductDetailFragment"
              android:label="Product Detail"
              tools:layout="@layout/product_detail">
              <argument
                  android:name="product_id"
                  app:argType="integer" />
          </fragment>
      </navigation>

   Then, you can update your activity:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MainActivity : AppCompatActivity() {

                   // No need to load the start destination, handled automatically by the Navigation component
                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setContentView(R.layout.activity_main)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends AppCompatActivity {

                   // No need to load the start destination, handled automatically by the Navigation component
                   @Override
                   protected void onCreate(@Nullable Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       setContentView(R.layout.activity_main);
                   }
               }

   The activity no longer needs a ``navigateToProductDetail()`` method.
   In the next section, we update ``ProductListFragment`` to use the
   ``NavController`` to navigate to the next product detail screen.

   .. rubric:: Pass arguments safely
      :name: pass_arguments_safely

   The Navigation component has a Gradle plugin called `Safe Args <#Safe-args>`__
   that generates simple object and builder classes for type-safe access
   to arguments specified for destinations and actions.

   Once the plugin is applied, any arguments defined on a destination in
   your navigation graph causes the Navigation component framework to
   generate an ``Arguments`` class that provides type safe arguments to
   the target destination. Defining an action causes the plugin to
   generate a ``Directions`` configuration class which can be used to
   tell the ``NavController`` how to navigate the user to the target
   destination. When an action points to a destination that requires
   arguments, the generated ``Directions`` class includes constructor
   methods which require those parameters.

   Inside the fragment, use ``NavController`` and the generated
   ``Directions`` class to provide type-safe arguments to the target
   destination, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ProductListFragment : Fragment() {

                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       // In this example a callback is passed to respond to an item clicked in a RecyclerView
                       productAdapter = ProductAdapter(productClickCallback)
                       binding.productsList.setAdapter(productAdapter)
                   }
                   ...

                   // The callback makes the call to the NavController to make the transition.
                   private val productClickCallback = ProductClickCallback { product ->
                       val directions = ProductListDirections.navigateToProductDetail(product.id)
                       findNavController().navigate(directions)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ProductListFragment extends Fragment  {
                   ...
                   @Override
                   public void onViewCreated(@NonNull View view,
                           @Nullable Bundle savedInstanceState) {
                       // In this example a callback is passed to respond to an item clicked in a RecyclerView
                       productAdapter = new ProductAdapter(productClickCallback);
                       binding.productsList.setAdapter(productAdapter);
                   }
                   ...

                   // The callback makes the call to the activity to make the transition.
                   private ProductClickCallback productClickCallback = product -> {
                       ProductListDirections.ViewProductDetails directions =
                               ProductListDirections.navigateToProductDetail(product.getId());
                       NavHostFragment.findNavController(this).navigate(directions);
                   };
               }

   .. rubric:: Top-Level Navigation
      :name: top-level_navigation

   If your app uses a ``DrawerLayout``, you might have a lot of
   configuration logic in your activity that manages opening and closing
   the drawer and navigating to other destinations.

   Your resulting activity might look something like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MainActivity : AppCompatActivity(),
                   NavigationView.OnNavigationItemSelectedListener {

                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setContentView(R.layout.activity_main)

                       val toolbar: Toolbar = findViewById(R.id.toolbar)
                       setSupportActionBar(toolbar)

                       val drawerLayout: DrawerLayout = findViewById(R.id.drawer_layout)
                       val navView: NavigationView = findViewById(R.id.nav_view)
                       val toggle = ActionBarDrawerToggle(
                               this,
                               drawerLayout,
                               toolbar,
                               R.string.navigation_drawer_open, 
                               R.string.navigation_drawer_close
                       )
                       drawerLayout.addDrawerListener(toggle)
                       toggle.syncState()

                       navView.setNavigationItemSelectedListener(this)
                   }

                   override fun onBackPressed() {
                       val drawerLayout: DrawerLayout = findViewById(R.id.drawer_layout)
                       if (drawerLayout.isDrawerOpen(GravityCompat.START)) {
                           drawerLayout.closeDrawer(GravityCompat.START)
                       } else {
                           super.onBackPressed()
                       }
                   }

                   override fun onNavigationItemSelected(item: MenuItem): Boolean {
                       // Handle navigation view item clicks here.
                       when (item.itemId) {
                           R.id.home -> {
                               val homeFragment = HomeFragment()
                               show(homeFragment)
                           }
                           R.id.gallery -> {
                               val galleryFragment = GalleryFragment()
                               show(galleryFragment)
                           }
                           R.id.slide_show -> {
                               val slideShowFragment = SlideShowFragment()
                               show(slideShowFragment)
                           }
                           R.id.tools -> {
                               val toolsFragment = ToolsFragment()
                               show(toolsFragment)
                           }
                       }
                       val drawerLayout: DrawerLayout = findViewById(R.id.drawer_layout)
                       drawerLayout.closeDrawer(GravityCompat.START)
                       return true
                   }
               }

               private fun show(fragment: Fragment) {

                   val drawerLayout = drawer_layout as DrawerLayout
                   val fragmentManager = supportFragmentManager

                   fragmentManager
                           .beginTransaction()
                           .replace(R.id.main_content, fragment)
                           .commit()

                   drawerLayout.closeDrawer(GravityCompat.START)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends AppCompatActivity
                       implements NavigationView.OnNavigationItemSelectedListener {

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       setContentView(R.layout.activity_main);

                       Toolbar toolbar = findViewById(R.id.toolbar);
                       setSupportActionBar(toolbar);

                       DrawerLayout drawer = findViewById(R.id.drawer_layout);
                       NavigationView navigationView = findViewById(R.id.nav_view);
                       ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(
                               this,
                               drawer,
                               toolbar,
                               R.string.navigation_drawer_open,
                               R.string.navigation_drawer_close);
                       drawer.addDrawerListener(toggle);
                       toggle.syncState();

                       navigationView.setNavigationItemSelectedListener(this);
                   }

                   @Override
                   public void onBackPressed() {
                       DrawerLayout drawer = findViewById(R.id.drawer_layout);
                       if (drawer.isDrawerOpen(GravityCompat.START)) {
                           drawer.closeDrawer(GravityCompat.START);
                       } else {
                           super.onBackPressed();
                       }
                   }

                   @Override
                   public boolean onNavigationItemSelected(MenuItem item) {
                       // Handle navigation view item clicks here.
                       int id = item.getItemId();

                       if (id == R.id.home) {
                           Fragment homeFragment = new HomeFragment();
                           show(homeFragment);
                       } else if (id == R.id.gallery) {
                           Fragment galleryFragment = new GalleryFragment();
                           show(galleryFragment);
                       } else if (id == R.id.slide_show) {
                           Fragment slideShowFragment = new SlideShowFragment();
                           show(slideShowFragment);
                       } else if (id == R.id.tools) {
                           Fragment toolsFragment = new ToolsFragment();
                           show(toolsFragment);
                       }

                       DrawerLayout drawer = findViewById(R.id.drawer_layout);
                       drawer.closeDrawer(GravityCompat.START);
                       return true;
                   }

                   private void show(Fragment fragment) {

                       DrawerLayout drawerLayout = findViewById(R.id.drawer_layout);
                       FragmentManager fragmentManager = getSupportFragmentManager();

                       fragmentManager
                               .beginTransaction()
                               .replace(R.id.main_content, fragment)
                               .commit();

                       drawerLayout.closeDrawer(GravityCompat.START);
                   }
               }

   After you have added the Navigation component to your project and
   created a navigation graph, add each of the content destinations from
   your graph (such as *Home*, *Gallery*, *SlideShow*, and *Tools* from
   the example above). Be sure that your menu item ``id`` values match
   their associated destination ``id`` values, as shown below:

   .. code:: prettyprint

      <!-- activity_main_drawer.xml -->
      <menu xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:tools="http://schemas.android.com/tools"
          tools:showIn="navigation_view">

          <group android:checkableBehavior="single">
              <item
                  android:id="@+id/home"
                  android:icon="@drawable/ic_menu_camera"
                  android:title="@string/menu_home" />
              <item
                  android:id="@+id/gallery"
                  android:icon="@drawable/ic_menu_gallery"
                  android:title="@string/menu_gallery" />
              <item
                  android:id="@+id/slide_show"
                  android:icon="@drawable/ic_menu_slideshow"
                  android:title="@string/menu_slideshow" />
              <item
                  android:id="@+id/tools"
                  android:icon="@drawable/ic_menu_manage"
                  android:title="@string/menu_tools" />
          </group>
      </menu>

   .. code:: prettyprint

      <!-- activity_main_graph.xml -->
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          android:id="@+id/main_graph"
          app:startDestination="@id/home">

          <fragment
              android:id="@+id/home"
              android:name="com.example.HomeFragment"
              android:label="Home"
              tools:layout="@layout/home" />

          <fragment
              android:id="@+id/gallery"
              android:name="com.example.GalleryFragment"
              android:label="Gallery"
              tools:layout="@layout/gallery" />

          <fragment
              android:id="@+id/slide_show"
              android:name="com.example.SlideShowFragment"
              android:label="Slide Show"
              tools:layout="@layout/slide_show" />

          <fragment
              android:id="@+id/tools"
              android:name="com.example.ToolsFragment"
              android:label="Tools"
              tools:layout="@layout/tools" />

      </navigation>

   If you match the ``id`` values from your menu and graph, then you can
   wire up the ``NavController`` for this activity to handle navigation
   automatically based on the menu item. The ``NavController`` also
   handles opening and closing the ``DrawerLayout`` and handling Up and
   Back button behavior appropriately.

   Your ``MainActivity`` can then be updated to wire up the
   ``NavController`` to the ``Toolbar`` and ``NavigationView``.

   See the following snippet for an example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MainActivity : AppCompatActivity()  {

                   val drawerLayout by lazy { findViewById<DrawerLayout>(R.id.drawer_layout) }
                   val navController by lazy {
                     (supportFragmentManager.findFragmentById(R.id.main_content) as NavHostFragment).navController
                   }
                   val navigationView by lazy { findViewById<NavigationView>(R.id.nav_view) }

                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setContentView(R.layout.activity_main)

                       val toolbar = findViewById<Toolbar>(R.id.toolbar)
                       setSupportActionBar(toolbar)

                       // Show and Manage the Drawer and Back Icon
                       setupActionBarWithNavController(navController, drawerLayout)

                       // Handle Navigation item clicks
                       // This works with no further action on your part if the menu and destination id‚Äôs match.
                       navigationView.setupWithNavController(navController)

                   }

                   override fun onSupportNavigateUp(): Boolean {
                       // Allows NavigationUI to support proper up navigation or the drawer layout
                       // drawer menu, depending on the situation
                       return navController.navigateUp(drawerLayout)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends AppCompatActivity {

                   private DrawerLayout drawerLayout;
                   private NavController navController;
                   private NavigationView navigationView;

                   @Override
                   protected void onCreate(@Nullable Bundle savedInstanceState) {

                       super.onCreate(savedInstanceState);
                       setContentView(R.layout.activity_main);

                       drawerLayout = findViewById(R.id.drawer_layout);
                       NavHostFragment navHostFragment = (NavHostFragment)
                           getSupportFragmentManager().findFragmentById(R.id.main_content);
                       navController = navHostFragment.getNavController();
                       navigationView = findViewById(R.id.nav_view);

                       Toolbar toolbar = findViewById(R.id.toolbar);
                       setSupportActionBar(toolbar);

                       // Show and Manage the Drawer and Back Icon
                       NavigationUI.setupActionBarWithNavController(this, navController, drawerLayout);

                       // Handle Navigation item clicks
                       // This works with no further action on your part if the menu and destination id‚Äôs match.
                       NavigationUI.setupWithNavController(navigationView, navController);

                   }

                   @Override
                   public boolean onSupportNavigateUp() {
                       // Allows NavigationUI to support proper up navigation or the drawer layout
                       // drawer menu, depending on the situation.
                       return NavigationUI.navigateUp(navController, drawerLayout);

                   }
               }

   You can use this same technique with both BottomNavigationView-based
   navigation and Menu-based navigation. See `Update UI components with NavigationUI <#>`__
   for more examples.

   .. rubric:: Add activity destinations
      :name: add

   Once each screen in your app is wired up to use the Navigation
   component, and you are no longer using ``FragmentTransactions`` to
   transition between fragment-based destinations, the next step is to
   eliminate ``startActivity`` calls.

   First, identify places in your app where you have two separate
   navigation graphs and are using ``startActivity`` to transition
   between them.

   This example contains two graphs (A and B) and a ``startActivity()``
   call to transition from A to B.

   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-migrate-two-graphs.png

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun navigateToProductDetails(productId: String) {
                   val intent = Intent(this, ProductDetailsActivity::class.java)
                   intent.putExtra(KEY_PRODUCT_ID, productId)
                   startActivity(intent)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private void navigateToProductDetails(String productId) {
                   Intent intent = new Intent(this, ProductDetailsActivity.class);
                   intent.putExtra(KEY_PRODUCT_ID, productId);
                   startActivity(intent);

   Next, replace these with an activity destination in Graph A that
   represents the navigation to the host activity of Graph B. If you
   have arguments to pass to the start destination of Graph B, you can
   designate them in the activity destination definition.

   In the following example, Graph A defines an activity destination
   which takes a ``product_id`` argument along with an action. Graph B
   contains no changes.

   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-migrate-two-graphs-2.png

   The XML representation of Graphs A and B might look like this:

   .. code:: prettyprint

      <!-- Graph A -->
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          android:id="@+id/product_list_graph"
          app:startDestination="@id/product_list">

          <fragment
              android:id="@+id/product_list"
              android:name="com.example.android.persistence.ui.ProductListFragment"
              android:label="Product List"
              tools:layout="@layout/product_list_fragment">
              <action
                  android:id="@+id/navigate_to_product_detail"
                  app:destination="@id/product_details_activity" />
          </fragment>

          <activity
              android:id="@+id/product_details_activity"
              android:name="com.example.android.persistence.ui.ProductDetailsActivity"
              android:label="Product Details"
              tools:layout="@layout/product_details_host">

              <argument
                  android:name="product_id"
                  app:argType="integer" />

          </activity>

      </navigation>

   .. code:: prettyprint

      <!-- Graph B -->
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          app:startDestination="@id/product_details">

          <fragment
              android:id="@+id/product_details"
              android:name="com.example.android.persistence.ui.ProductDetailsFragment"
              android:label="Product Details"
              tools:layout="@layout/product_details_fragment">
              <argument
                  android:name="product_id"
                  app:argType="integer" />
          </fragment>

      </navigation>

   You can navigate to the host activity of Graph B using the same
   mechanisms you use to navigate to fragment destinations:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun navigateToProductDetails(productId: String) {
                   val directions = ProductListDirections.navigateToProductDetail(productId)
                   findNavController().navigate(directions)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private void navigateToProductDetails(String productId) {
                   ProductListDirections.NavigateToProductDetail directions =
                           ProductListDirections.navigateToProductDetail(productId);
                   Navigation.findNavController(getView()).navigate(directions);

   .. rubric:: Pass activity destination args to a start destination
      fragment
      :name: pass_activity_destination_args_to_a_start_destination_fragment

   If the destination activity receives extras, as with the previous
   example, you can pass these to the start destination directly as
   arguments, but you need to manually set your host‚Äôs navigation graph
   inside the host activity‚Äôs ``onCreate()`` method so that you can pass
   the intent extras as arguments to the fragment, as shown below:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ProductDetailsActivity : AppCompatActivity() {

                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setContentView(R.layout.product_details_host)
                       val navHostFragment = supportFragmentManager.findFragmentById(R.id.main_content) as NavHostFragment
                       val navController = navHostFramgent.navController
                       navController
                               .setGraph(R.navigation.product_detail_graph, intent.extras)
                   }

               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ProductDetailsActivity extends AppCompatActivity {

                   @Override
                   protected void onCreate(@Nullable Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);

                       setContentView(R.layout.product_details_host);
                       NavHostFragment navHostFragment = (NavHostFragment)
                           getSupportFragmentManager().findFragmentById(R.id.main_content);
                       NavController navController = navHostFragment.getNavController();
                       navController
                               .setGraph(R.navigation.product_detail_graph, getIntent().getExtras());
                   }

               }

   **Note:**\  In this case, you should avoid setting the
   ``app:NavGraph`` attribute in the ``NavHostFragment`` definition,
   because doing so results in inflating and setting the navigation
   graph twice.
   The data can be pulled out of the fragment arguments ``Bundle`` using
   the generated args class, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ProductDetailsFragment : Fragment() {

                   val args by navArgs<ProductDetailsArgs>()

                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       val productId = args.productId
                       ...
                   }
                   ...

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ProductDetailsFragment extends Fragment {

                   ProductDetailsArgs args;

                   @Override
                   public void onCreate(@Nullable Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       args = ProductDetailsArgs.fromBundle(requireArguments());
                   }

                   @Override
                   public void onViewCreated(@NonNull View view,
                           @Nullable Bundle savedInstanceState) {
                      int productId = args.getProductId();
                      ...
                   }
                   ...

   .. rubric:: Combine activities
      :name: combine

   You can combine navigation graphs in cases where multiple activities
   share the same layout, such as a simple ``FrameLayout`` containing a
   single fragment. In most of these cases, you can just combine all of
   the elements from each navigation graph and updating any activity
   destination elements to fragment destinations.

   The following example combines Graphs A and B from the previous
   section:

   **Before combining:**

   .. code:: prettyprint

      <!-- Graph A -->
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          android:id="@+id/product_list_graph"
          app:startDestination="@id/product_list">

          <fragment
              android:id="@+id/product_list"
              android:name="com.example.android.persistence.ui.ProductListFragment"
              android:label="Product List Fragment"
              tools:layout="@layout/product_list">
              <action
                  android:id="@+id/navigate_to_product_detail"
                  app:destination="@id/product_details_activity" />
          </fragment>
          <activity
              android:id="@+id/product_details_activity"
              android:name="com.example.android.persistence.ui.ProductDetailsActivity"
              android:label="Product Details Host"
              tools:layout="@layout/product_details_host">
              <argument android:name="product_id"
                  app:argType="integer" />
          </activity>

      </navigation>

   .. code:: prettyprint

      <!-- Graph B -->
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          android:id="@+id/product_detail_graph"
          app:startDestination="@id/product_details">

          <fragment
              android:id="@+id/product_details"
              android:name="com.example.android.persistence.ui.ProductDetailsFragment"
              android:label="Product Details"
              tools:layout="@layout/product_details">
              <argument
                  android:name="product_id"
                  app:argType="integer" />
          </fragment>
      </navigation>

   **After combining:**

   .. code:: prettyprint

      <!-- Combined Graph A and B -->
      <navigation xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          android:id="@+id/product_list_graph"
          app:startDestination="@id/product_list">

          <fragment
              android:id="@+id/product_list"
              android:name="com.example.android.persistence.ui.ProductListFragment"
              android:label="Product List Fragment"
              tools:layout="@layout/product_list">
              <action
                  android:id="@+id/navigate_to_product_detail"
                  app:destination="@id/product_details" />
          </fragment>

          <fragment
              android:id="@+id/product_details"
              android:name="com.example.android.persistence.ui.ProductDetailsFragment"
              android:label="Product Details"
              tools:layout="@layout/product_details">
              <argument
                  android:name="product_id"
                  app:argType="integer" />
          </fragment>

      </navigation>

   Keeping your action names the same while merging can make this a
   seamless process, requiring no changes to your existing code base.
   For example, ``navigateToProductDetail`` remains the same here. The
   only difference is that this action now represents navigation to a
   fragment destination within the same ``NavHost`` instead of an
   activity destination:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun navigateToProductDetails(productId: String) {
                   val directions = ProductListDirections.navigateToProductDetail(productId)
                   findNavController().navigate(directions)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private void navigateToProductDetails(String productId) {
                   ProductListDirections.NavigateToProductDetail directions =
                           ProductListDirections.navigateToProductDetail(productId);
                   Navigation.findNavController(getView()).navigate(directions);

   .. rubric:: Additional Resources
      :name: additional_resources

   For more navigation-related information, see the following topics:

   -  `Update UI components with NavigationUI <#>`__
      - Learn how to manage navigation with the top app bar, the
      navigation drawer, and bottom navigation
   -  `Test Navigation <#>`__
      - Learn how to test navigation workflows for your app


Last updated 2024-01-03 UTC.


/Test navigation
================

.. container:: devsite-article-body clearfix

   It is important to test your app's navigation logic before you ship
   in order to verify that your application works as you expect.

   The Navigation component handles all the work of managing navigation
   between destinations, passing arguments, and working with the
   `FragmentManager <#>`__.
   These capabilities are already rigorously tested, so there is no need
   to test them again in your app. What is important to test, however,
   are the interactions between the app specific code in your fragments
   and their
   `NavController <#>`__.
   This guide walks through a few common navigation scenarios and how to
   test them.

   **Note:**\  This guide makes heavy use of
   `FragmentScenario <#>`__
   for testing the contents of your fragments in isolation. This allows
   you to verify a fragment's state and interactions in both unit and
   instrumentation tests. If you are unfamiliar with testing fragments
   using ``FragmentScenario``, you might want to read the `guide to testing your fragments in isolation <#>`__ before continuing.

   .. rubric:: Test fragment navigation
      :name: test_fragment_navigation

   To test fragment interactions with their ``NavController`` in
   isolation, Navigation 2.3 and higher provides a
   `TestNavHostController <#>`__
   that provides APIs for setting the current destination and verify the
   back stack after
   `NavController.navigate() <#navigate>`__
   operations.

   You can add the Navigation Testing artifact to your project by adding
   the following dependency in your app module's ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                 def nav_version = "2.7.7"

                 androidTestImplementation "androidx.navigation:navigation-testing:$nav_version"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                 val nav_version = "2.7.7"

                 androidTestImplementation("androidx.navigation:navigation-testing:$nav_version")
               }

   Let‚Äôs say you are building a trivia game. The game starts with a
   **title_screen** and navigates to an **in_game** screen when the user
   clicks play.

   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-testing-trivia-game.png
      :width: 500px

   The fragment representing the **title_screen** might look something
   like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class TitleScreen : Fragment() {
                   override fun onCreateView(
                       inflater: LayoutInflater,
                       container: ViewGroup?,
                       savedInstanceState: Bundle?
                   ) = inflater.inflate(R.layout.fragment_title_screen, container, false)

                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       view.findViewById<Button>(R.id.play_btn).setOnClickListener {
                           view.findNavController().navigate(R.id.action_title_screen_to_in_game)
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class TitleScreen extends Fragment {

                   @Nullable
                   @Override
                   public View onCreateView(@NonNull LayoutInflater inflater,
                           @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
                       return inflater.inflate(R.layout.fragment_title_screen, container, false);
                   }

                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       view.findViewById(R.id.play_btn).setOnClickListener(v -> {
                           Navigation.findNavController(view).navigate(R.id.action_title_screen_to_in_game);
                       });
                   }
               }

   To test that the app properly navigates the user to the **in_game**
   screen when the user clicks **Play**, your test needs to verify that
   this fragment correctly moves the ``NavController`` to the
   ``R.id.in_game`` screen.

   Using a combination of ``FragmentScenario``,
   `Espresso <#>`__, and
   ``TestNavHostController``, you can recreate the conditions necessary
   to test this scenario, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @RunWith(AndroidJUnit4::class)
               class TitleScreenTest {

                   @Test
                   fun testNavigationToInGameScreen() {
                       // Create a TestNavHostController
                       val navController = TestNavHostController(
                           ApplicationProvider.getApplicationContext())

                       // Create a graphical FragmentScenario for the TitleScreen
                       val titleScenario = launchFragmentInContainer<TitleScreen>()

                       titleScenario.onFragment { fragment ->
                           // Set the graph on the TestNavHostController
                           navController.setGraph(R.navigation.trivia)

                           // Make the NavController available via the findNavController() APIs
                           Navigation.setViewNavController(fragment.requireView(), navController)
                       }

                       // Verify that performing a click changes the NavController‚Äôs state
                       onView(ViewMatchers.withId(R.id.play_btn)).perform(ViewActions.click())
                       assertThat(navController.currentDestination?.id).isEqualTo(R.id.in_game)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @RunWith(AndroidJUnit4.class)
               public class TitleScreenTestJava {

                   @Test
                   public void testNavigationToInGameScreen() {

                       // Create a TestNavHostController
                       TestNavHostController navController = new TestNavHostController(
                           ApplicationProvider.getApplicationContext());

                       // Create a graphical FragmentScenario for the TitleScreen
                       FragmentScenario<TitleScreen> titleScenario = FragmentScenario.launchInContainer(TitleScreen.class);

                       titleScenario.onFragment(fragment ->
                               // Set the graph on the TestNavHostController
                               navController.setGraph(R.navigation.trivia);

                               // Make the NavController available via the findNavController() APIs
                               Navigation.setViewNavController(fragment.requireView(), navController)
                       );

                       // Verify that performing a click changes the NavController‚Äôs state
                       onView(ViewMatchers.withId(R.id.play_btn)).perform(ViewActions.click());
                       assertThat(navController.currentDestination.id).isEqualTo(R.id.in_game);
                   }
               }

   The above example creates an instance of ``TestNavHostController``
   and assigns it to the fragment. It then uses Espresso to drive the UI
   and verifies that the appropriate navigation action is taken.

   Just like a real ``NavController``, you must call ``setGraph`` to
   initialize the ``TestNavHostController``. In this example, the
   fragment being tested was the start destination of our graph.
   ``TestNavHostController`` provides a
   `setCurrentDestination <#setCurrentDestination>`__
   method that allows you to set the current destination (and
   optionally, arguments for that destination) so that the
   ``NavController`` is in the correct state before your test begins.

   Unlike a ``NavHostController`` instance that a ``NavHostFragment``
   would use, ``TestNavHostController`` does **not** trigger the
   underlying ``navigate()`` behavior (such as the
   ``FragmentTransaction`` that ``FragmentNavigator`` does) when you
   call ``navigate()`` - it only updates the state of the
   ``TestNavHostController``.

   **Note:**\  when using Navigation ``2.2.1`` or earlier, it is
   recommended to use a mock ``NavController`` with
   `Mockito <https://site.mockito.org/>`__ and verify that the correct
   actions are taken rather than verify the NavController‚Äôs state.

   .. rubric:: Test NavigationUI with FragmentScenario
      :name: test_navigationui_with_fragmentscenario

   In the previous example, the callback provided to
   ``titleScenario.onFragment()`` is called after the fragment has moved
   through its lifecycle to the
   `RESUMED <#resumed>`__
   state. By this time, the fragment‚Äôs view has already been created and
   attached, so it may be too late in the lifecycle to test properly.
   For example, when using ``NavigationUI`` with views in your fragment,
   such as with a ``Toolbar`` controlled by your fragment, you can call
   setup methods with your ``NavController`` before the fragment reaches
   the ``RESUMED`` state. Thus, you need a way to to set your
   ``TestNavHostController`` earlier in the lifecycle.

   A fragment that owns its own ``Toolbar`` can be written as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class TitleScreen : Fragment(R.layout.fragment_title_screen) {
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       val navController = view.findNavController()
                       view.findViewById<Toolbar>(R.id.toolbar).setupWithNavController(navController)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class TitleScreen extends Fragment {
                   public TitleScreen() {
                       super(R.layout.fragment_title_screen);
                   }

                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       NavController navController = Navigation.findNavController(view);
                       view.findViewById(R.id.toolbar).setupWithNavController(navController);
                   }
               }

   Here we need the ``NavController`` created by the time
   ``onViewCreated()`` is called. Using the previous approach of
   ``onFragment()`` would set our ``TestNavHostController`` too late in
   the lifecycle, causing the ``findNavController()`` call to fail.

   ``FragmentScenario`` offers a
   `FragmentFactory <#>`__
   interface which can be used to register callbacks for lifecycle
   events. This can be combined with
   ``Fragment.getViewLifecycleOwnerLiveData()`` to receive a callback
   that immediately follows ``onCreateView()``, as shown in the
   following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val scenario = launchFragmentInContainer {
                   TitleScreen().also { fragment ->

                       // In addition to returning a new instance of our Fragment,
                       // get a callback whenever the fragment‚Äôs view is created
                       // or destroyed so that we can set the NavController
                       fragment.viewLifecycleOwnerLiveData.observeForever { viewLifecycleOwner ->
                           if (viewLifecycleOwner != null) {
                               // The fragment‚Äôs view has just been created
                               navController.setGraph(R.navigation.trivia)
                               Navigation.setViewNavController(fragment.requireView(), navController)
                           }
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               FragmentScenario<TitleScreen> scenario =
               FragmentScenario.launchInContainer(
                      TitleScreen.class, null, new FragmentFactory() {
                   @NonNull
                   @Override
                   public Fragment instantiate(@NonNull ClassLoader classLoader,
                           @NonNull String className,
                           @Nullable Bundle args) {
                       TitleScreen titleScreen = new TitleScreen();

                       // In addition to returning a new instance of our fragment,
                       // get a callback whenever the fragment‚Äôs view is created
                       // or destroyed so that we can set the NavController
                       titleScreen.getViewLifecycleOwnerLiveData().observeForever(new Observer<LifecycleOwner>() {
                           @Override
                           public void onChanged(LifecycleOwner viewLifecycleOwner) {

                               // The fragment‚Äôs view has just been created
                               if (viewLifecycleOwner != null) {
                                   navController.setGraph(R.navigation.trivia);
                                   Navigation.setViewNavController(titleScreen.requireView(), navController);
                               }

                           }
                       });
                       return titleScreen;
                   }
               });

   By using this technique, the ``NavController`` is available before
   ``onViewCreated()`` is called, allowing the fragment to use
   ``NavigationUI`` methods without crashing.

   .. rubric:: Testing interactions with back stack entries
      :name: testing_interactions_with_back_stack_entries

   When `interacting with the back stack entries <#navbackstackentry>`__,
   the ``TestNavHostController`` allows you to connect the controller to
   your own test ``LifecycleOwner``, ``ViewModelStore``, and
   ``OnBackPressedDispatcher`` by using the APIs it inherits from
   `NavHostController <#>`__.

   For example, when testing a fragment that uses a `navigation scoped ViewModel <#share_ui-related_data_between_destinations_with_viewmodel>`__,
   you must call
   `setViewModelStore <#setViewModelStore>`__
   on the ``TestNavHostController``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val navController = TestNavHostController(ApplicationProvider.getApplicationContext())

               // This allows fragments to use by navGraphViewModels()
               navController.setViewModelStore(ViewModelStore())

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               TestNavHostController navController = new TestNavHostController(ApplicationProvider.getApplicationContext());

               // This allows fragments to use new ViewModelProvider() with a NavBackStackEntry
               navController.setViewModelStore(new ViewModelStore())

   .. rubric:: Related topics
      :name: related_topics

   -  `Build instrumented unit tests <#>`__
      - Learn how to setup your instrumented test suite and run tests on
      an Android device.
   -  `Espresso <#>`__ -
      Test your app's UI with Espresso.
   -  `JUnit4 rules with AndroidX Test <#>`__ - Use JUnit 4 rules with
      the AndroidX Test libraries to provide more flexibility and reduce
      the boilerplate code required in tests.
   -  `Test your app's fragments <https://developer.android.google.cn/training/basics/fragments/testing>`__
      - Learn how to test your apps fragments in isolation with
      ``FragmentScenario``.
   -  `Set up project for AndroidX Test <#>`__ - Learn how to declare
      needed libraries in your app's project files to use AndroidX Test.


Last updated 2024-05-01 UTC.


/Provide custom back navigation
===============================

.. container:: devsite-article-body clearfix

   *Back navigation* is how users move backward through the history of
   screens they previously visited. All Android devices provide a Back
   button for this type of navigation, so you should not add a Back
   button to your app‚Äôs UI. Depending on the user‚Äôs Android device, this
   button might be a physical button or a software button.

   Android maintains a *back stack* of destinations as the user
   navigates throughout your application. This usually allows Android to
   properly navigate to previous destinations when the Back button is
   pressed. However, there are a few cases where your app might need to
   implement its own Back behavior in order to provide the best possible
   user experience. For example, when using a ``WebView``, you might
   want to override the default Back button behavior to allow the user
   to navigate back through their web browsing history instead of the
   previous screens in your app.

   **Note:**\  Android 13 introduces predictive back navigation, which
   works with custom back navigation, for Android devices. We strongly
   recommend that you implement predictive back navigation as soon as
   possible. Otherwise, users might experience unexpected behavior in a
   future Android release. To learn more, see `Add support for the predictive back gesture <#>`__.

   .. rubric:: Implement custom back navigation
      :name: implement

   `ComponentActivity <#>`__,
   the base class for
   `FragmentActivity <#>`__
   and
   `AppCompatActivity <#>`__,
   allows you to control the behavior of the Back button by using its
   `OnBackPressedDispatcher <#>`__,
   which you can retrieve by calling
   `getOnBackPressedDispatcher() <#getOnBackPressedDispatcher>`__.

   **Note:**\  If your app uses Activity 1.5.0 or higher, you can also
   implement custom back navigation for a dialog by using
   `ComponentDialog <#>`__
   and its ``OnBackPressedDispatcher``.
   The ``OnBackPressedDispatcher`` controls how Back button events are
   dispatched to one or more
   `OnBackPressedCallback <#>`__
   objects. The constructor for ``OnBackPressedCallback`` takes a
   boolean for the initial enabled state. Only when a callback is
   enabled (i.e.,
   `isEnabled() <#isEnabled>`__
   returns ``true``) will the dispatcher call the callback's
   `handleOnBackPressed() <#handleOnBackPressed>`__
   to handle the Back button event. You can change the enabled state by
   calling
   `setEnabled() <#setEnabled>`__.

   Callbacks are added via the ``addCallback`` methods. It is strongly
   recommended to use the
   `addCallback() <#addCallback>`__
   method which takes a
   `LifecycleOwner <#>`__.
   This ensures that the ``OnBackPressedCallback`` is only added when
   the ``LifecycleOwner`` is
   `Lifecycle.State.STARTED <#STARTED>`__.
   The activity also removes registered callbacks when their associated
   ``LifecycleOwner`` is destroyed, which prevents memory leaks and
   makes it suitable for use in fragments or other lifecycle owners that
   have a shorter lifetime than the activity.

   Here's an example callback implementation:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyFragment : Fragment() {

                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)

                       // This callback will only be called when MyFragment is at least Started.
                       val callback = requireActivity().onBackPressedDispatcher.addCallback(this) {
                           // Handle the back button event
                       }

                       // The callback can be enabled or disabled here or in the lambda
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyFragment extends Fragment {

                   @Override
                   public void onCreate(@Nullable Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);

                       // This callback will only be called when MyFragment is at least Started.
                       OnBackPressedCallback callback = new OnBackPressedCallback(true /* enabled by default */) {
                           @Override
                           public void handleOnBackPressed() {
                               // Handle the back button event
                           }
                       };
                       requireActivity().getOnBackPressedDispatcher().addCallback(this, callback);

                       // The callback can be enabled or disabled here or in handleOnBackPressed()
                   }
                   ...
               }

   You can provide multiple callbacks via
   `addCallback() <#addCallback>`__.
   When doing so, the callbacks are invoked in the reverse order in
   which they are added - the callback added last is the first given a
   chance to handle the Back button event. For example, if you added
   three callbacks named ``one``, ``two`` and ``three`` in order, they
   would be invoked in the order of ``three``, ``two``, and ``one``,
   respectively.

   Callbacks follow the `Chain of Responsibility <https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern>`__
   pattern. Each callback in the chain is invoked only if the preceding
   callback was not enabled. This means that in the preceding example,
   callback ``two`` would be invoked only if callback ``three`` was not
   enabled. Callback ``one`` would only be invoked if callback ``two``
   was not enabled, and so on.

   Note that when added via
   `addCallback() <#addCallback>`__,
   the callback is not added to the chain of responsibility until the
   ``LifecycleOwner`` enters the
   `Lifecycle.State.STARTED <#STARTED>`__
   state.

   Changing the enabled state on the ``OnBackPressedCallback`` is
   strongly recommended for temporary changes as it maintains the
   ordering described above, which is particularly important if you have
   callbacks registered on multiple different nested lifecycle owners.

   However, in cases where you want to remove the
   ``OnBackPressedCallback`` entirely, you should call
   `remove() <#remove>`__.
   This is usually not necessary, however, because callbacks are
   automatically removed when their associated
   `LifecycleOwner <#>`__
   is
   `destroyed <#DESTROYED>`__.

   .. rubric:: Activity onBackPressed()
      :name: onbackpressed

   If you are using
   `onBackPressed() <#onBackPressed>`__
   to handle Back button events, we recommend using a
   `OnBackPressedCallback <#>`__
   instead. However, if you are unable to make this change, the
   following rules apply:

   -  All callbacks registered via ``addCallback`` are evaluated when
      you call ``super.onBackPressed()``.
   -  In Android 12 (API level 32) and lower, ``onBackPressed`` is
      always called, regardless of any registered instances of
      ``OnBackPressedCallback``.


Last updated 2024-01-03 UTC.


/Add support for the predictive back gesture
============================================

.. container:: devsite-article-body clearfix

   .. figure::
      https://developer.android.google.cn/static/images/about/versions/13/predictive-back-nav-home.gif
      :width: 230px

      **Figure 1.** Mockup of the predictive back gesture look and feel
      on a phone

   Android 14 (API level 34) adds support for additional system
   animations and APIs to create custom animations. For more
   information, see `Add support for built-in and custom predictive back animations <#>`__.

   For example, using a back gesture can display an animated preview of
   the Home screen behind your app, as presented in the mockup in figure
   1. Starting with Android 13, you can `test this back-to-home animation <#dev-option>`__ by enabling a developer option (as
   described on this page).

   Supporting the predictive back gesture requires updating your app,
   using the backward compatible
   `OnBackPressedCallback <#>`__
   `AppCompat 1.6.0-alpha05 <#1.6.0-alpha05>`__
   (AndroidX) or higher API, or using the new
   `OnBackInvokedCallback <#>`__
   platform API. Most apps will use the backward compatible AndroidX
   API.

   This update provides a migration path to properly intercept back
   navigation, which involves replacing back interceptions from
   `KeyEvent.KEYCODE_BACK <#KEYCODE_BACK>`__
   and any classes with ``onBackPressed`` methods such as ``Activity``
   and `Dialog <#onBackPressed>`__
   with the new system Back APIs.

   **Note:**\  Android 13 doesn't make the predictive back gesture
   visible to users, but it does provide an early version of the UI as a
   developer option for testing. We plan to make this UI available to
   users in a future Android release. In the meantime, we strongly
   recommend updating your app to ensure you get the latest updates.
   **Note:**\  ``KeyEvent.KEYCODE_BACK`` is not deprecated as there are
   some supported use cases of ``KeyEvent.KEYCODE_BACK``; however,
   intercepting back events from ``KeyEvent.KEYCODE_BACK`` is no longer
   supported.

   .. rubric:: Codelab and Google I/O video
      :name: codelab

   .. container:: video-wrapper

   In addition to using this documentation on this page, `try out our codelab <https://developers.google.cn/codelabs/handling-gesture-back-navigation>`__.
   It provides a common use-case implementation of a WebView handling
   the predictive back gesture using AndroidX Activity APIs.

   You can also view our Google I/O video, which covers additional
   examples of implementing the AndroidX and platform APIs.

   .. rubric:: Update an app that uses default back navigation
      :name: update-default

   Updating your app to support this feature is straightforward if your
   app doesn't implement any custom back behavior (in other words, it
   leaves back handling up to the system). `Opt-in to this feature <#opt-predictive>`__ as described in this guide.

   If your app uses Fragments or the Navigation Component, also upgrade
   to `AndroidX Activity 1.6.0-alpha05 <#1.6.0-alpha05>`__
   or higher.

   .. rubric:: Update an app that uses custom back navigation
      :name: update-custom

   If your app implements custom back behavior, there are different
   migration paths depending on whether it uses AndroidX and how it
   handles back navigation.

   .. list-table::

      - 

         - **Your app uses AndroidX**
         - **How your app handles back navigation**
         - **Recommended migration path** (link on this page)
      - 

         - Yes
         - AndroidX APIs
         - `Migrate an existing AndroidX back implementation <#migrate-existing>`__
      - 

         - 
         - Unsupported platform APIs
         - `Migrate an AndroidX app containing unsupported back navigation APIs to AndroidX APIs <#migrate-androidx>`__
      - 

         - No
         - Unsupported platform APIs, able to migrate
         - `Migrate an app that uses unsupported back navigation APIs to platform APIs <#migrate-app>`__
      - 

         - 
         - Unsupported platform APIs, but unable to migrate
         - `Defer opt-in <#opt-predictive>`__ until this becomes a
            required feature

   **Important:**\  We strongly recommend that you implement predictive
   back navigation as soon as possible. Otherwise, users might
   experience unexpected behavior in a future release of Android.

   .. rubric:: Migrate an AndroidX back navigation implementation
      :name: migrate-existing

   This use case is the most common (and the most recommended). It
   applies to new or existing apps that implement custom gesture
   navigation handling with
   `OnBackPressedDispatcher <#>`__,
   as described in `Provide custom back navigation <#>`__.

   If your app fits into this category, follow these steps to add
   support for the predictive back gesture:

   #. To ensure that APIs that are already using
      ``OnBackPressedDispatcher`` APIs (such as Fragments and the
      Navigation Component) work seamlessly with the predictive back
      gesture, upgrade to `AndroidX Activity 1.6.0-alpha05 <#1.6.0-alpha05>`__.

      .. code:: prettyprint

         // In your build.gradle file:
         dependencies {

         // Add this in addition to your other dependencies
         implementation "androidx.activity:activity:1.6.0-alpha05"

   #. `Opt-in to the predictive back gesture <#opt-predictive>`__, as
      described on this page.

   .. rubric:: Migrate an AndroidX app containing unsupported back
      navigation APIs to AndroidX APIs
      :name: migrate-androidx

   If your app uses AndroidX libraries but implements or makes reference
   to the unsupported back navigation APIs, you‚Äôll need to migrate to
   using AndroidX APIs to support the new behavior.

   **Note:**\  We strongly recommend using AndroidX libraries. AndroidX
   automatically enables updated system Back navigation in your app when
   you enable the feature, and also provides `many other useful features <#>`__ that automatically update APIs with
   each release to save you work and time.
   To migrate unsupported APIs to AndroidX APIs:

   #. Migrate your system Back handling logic to AndroidX‚Äôs
      `OnBackPressedDispatcher <#>`__
      with an implementation of
      `OnBackPressedCallback <#>`__.
      For detailed guidance, see `Provide custom back navigation <#>`__.

   #. Disable the ``OnBackPressedCallback`` when ready to stop
      intercepting the back gesture.

   #. Stop intercepting back events via ``OnBackPressed`` or
      ``KeyEvent.KEYCODE_BACK``.

   #. Make sure to upgrade to `AndroidX Activity 1.6.0-alpha05 <#1.6.0-alpha05>`__.

      .. code:: prettyprint

         // In your build.gradle file:
         dependencies {

         // Add this in addition to your other dependencies
         implementation "androidx.activity:activity:1.6.0-alpha05"

   #. When you have successfully migrated your app, `opt-in to the predictive back gesture <#opt-predictive>`__ (as described on this
      page) to see the back-to-home system animation.

      **Note:**\  ``OnBackPressedCallback`` is always called regardless
      of the value of ``android:enableOnBackInvokedCallback``. In other
      words, disabling the system animation doesn't affect your app's
      back handling logic if it uses ``OnBackPressedCallback``.

   .. rubric:: Migrate an app that uses unsupported back navigation APIs
      to platform APIs
      :name: migrate-app

   If your app cannot use AndroidX libraries and instead implements or
   makes reference to custom Back navigation using the unsupported APIs,
   you must migrate to the ``OnBackInvokedCallback`` platform API.

   **Note:**\  We strongly recommend using AndroidX libraries. AndroidX
   automatically enables updated system Back navigation in your app when
   you enable the feature, and also provides `many other useful features <#>`__ that automatically update APIs with
   each release to save you work and time.
   Complete the following steps to migrate unsupported APIs to the
   platform API:

   #. Use the new ``OnBackInvokedCallback`` API on devices running
      Android 13 or higher, and rely on the unsupported APIs on devices
      running Android 12 or lower.

   #. Register your custom back logic in ``OnBackInvokedCallback`` with
      ``onBackInvokedDispatcher``. This prevents the current activity
      from being finished, and your callback gets a chance to react to
      the Back action once the user completes the system Back
      navigation.

   #. Unregister the ``OnBackInvokedCallback`` when ready to stop
      intercepting the back gesture. Otherwise, users may see
      undesirable behavior when using a system Back navigation‚Äîfor
      example, "getting stuck" between views and forcing them to force
      quit your app.

      Here‚Äôs an example of how to migrate logic out of
      ``onBackPressed``:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  @Override
                  fun onCreate() {
                      if (BuildCompat.isAtLeastT()) {
                          onBackInvokedDispatcher.registerOnBackInvokedCallback(
                              OnBackInvokedDispatcher.PRIORITY_DEFAULT
                          ) {
                              /**
                               * onBackPressed logic goes here. For instance:
                               * Prevents closing the app to go home screen when in the
                               * middle of entering data to a form
                               * or from accidentally leaving a fragment with a WebView in it
                               *
                               * Unregistering the callback to stop intercepting the back gesture:
                               * When the user transitions to the topmost screen (activity, fragment)
                               * in the BackStack, unregister the callback by using
                               * OnBackInvokeDispatcher.unregisterOnBackInvokedCallback
                               * (https://developer.android.com/reference/kotlin/android/window/OnBackInvokedDispatcher#unregisteronbackinvokedcallback)
                               */
                          }
                      }
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  @Override
                  void onCreate() {
                    if (BuildCompat.isAtLeastT()) {
                      getOnBackInvokedDispatcher().registerOnBackInvokedCallback(
                          OnBackInvokedDispatcher.PRIORITY_DEFAULT,
                          () -> {
                            /**
                             * onBackPressed logic goes here - For instance:
                             * Prevents closing the app to go home screen when in the
                             * middle of entering data to a form
                             * or from accidentally leaving a fragment with a WebView in it
                             *
                             * Unregistering the callback to stop intercepting the back gesture:
                             * When the user transitions to the topmost screen (activity, fragment)
                             * in the BackStack, unregister the callback by using
                             * OnBackInvokeDispatcher.unregisterOnBackInvokedCallback
                             * (https://developer.android.com/reference/kotlin/android/view/OnBackInvokedDispatcher#unregisteronbackinvokedcallback)
                             */
                          }
                      );
                    }
                  }

   #. Stop intercepting back events via ``OnBackPressed`` or
      ``KeyEvent.KEYCODE_BACK`` for Android 13 and above.

   #. When you have successfully migrated your app, `opt-in to the predictive back gesture <#opt-predictive>`__ (as described on this
      page) so that ``OnBackInvokedCallback`` takes effect.

   You can register an ``OnBackInvokedCallback`` with
   ``PRIORITY_DEFAULT`` or ``PRIORITY_OVERLAY``, which is not available
   in the similar AndroidX ``OnBackPressedCallback``. Registering a
   callback with ``PRIORITY_OVERLAY`` is helpful in some instances. A
   case where this could apply is when you migrate from
   ``onKeyPreIme()`` and your callback needs to receive the back gesture
   instead of an open IME. IMEs register callbacks with
   ``PRIORITY_DEFAULT`` when opened. Register your callback with
   ``PRIORITY_OVERLAY`` to ensure ``OnBackInvokedDispatcher`` dispatches
   the back gesture to your callback instead of the open IME.

   .. rubric:: Opt-in to the predictive back gesture
      :name: opt-predictive

   Once you've determined how to update your app based on your case,
   opt-in to supporting the predictive back gesture.

   To opt-in, in ``AndroidManifest.xml``, in the ``<application>`` tag,
   set the ``android:enableOnBackInvokedCallback`` flag to ``true``.

   .. code:: prettyprint

      <application
          ...
          android:enableOnBackInvokedCallback="true"
          ... >
      ...
      </application>

   If you don't provide a value, it defaults to ``false`` and does the
   following:

   -  Disables the predictive back gesture system animation.
   -  Ignores ``OnBackInvokedCallback``, but ``OnBackPressedCallback``
      calls continue to work.

   .. rubric:: Opt-in at an activity level
      :name: opt-activity-level

   Starting with Android 14, the ``android:enableOnBackInvokedCallback``
   flag lets you opt-in to predictive system animations at the activity
   level. This behavior makes it more manageable to migrate large
   multi-activity apps to predictive back gestures.

   The following code shows an example of using
   ``enableOnBackInvokedCallback`` to enable the back-to-home system
   animation from the ``MainActivity``:

   .. code:: prettyprint

      <manifest ...>
          <application . . .

              android:enableOnBackInvokedCallback="false">

              <activity
                  android:name=".MainActivity"
                  android:enableOnBackInvokedCallback="true"
                  ...
              </activity>
              <activity
                  android:name=".SecondActivity"
                  android:enableOnBackInvokedCallback="false"
                  ...
              </activity>
          </application>
      </manifest>

   In the preceding example, setting
   ``android:enableOnBackInvokedCallback=true`` for
   ``".SecondActivity"`` enables the cross-activity system animation.

   Keep in mind the following considerations when using the
   ``android:enableOnBackInvokedCallback`` flag:

   -  Setting ``android:enableOnBackInvokedCallback=false`` turns off
      predictive back animations either at the activity level or at the
      app level, depending on where you set the tag, and instructs the
      system to ignore calls to the ``OnBackInvokedCallback`` platform
      API. However, calls to ``OnBackPressedCallback`` continue to run
      because ``OnBackPressedCallback`` is backward compatible and calls
      the ``onBackPressed`` API, which is unsupported prior to Android
      13.
   -  Setting the ``enableOnBackInvokedCallback`` flag at the app level
      establishes the default value for all activities in the app. You
      can override the default per activity by setting the flag at the
      activity level, as shown in the preceding code example.

   .. rubric:: Callback best practices
      :name: best-practices

   Here are best practices for using the supported system back
   callbacks; ``BackHandler`` (for Compose), ``OnBackPressedCallback``,
   or ``OnBackInvokedCallback``.

   .. rubric:: Determine the UI State that enables and disables each
      callback
      :name: ui-state

   `UI state <#ui-state>`__ is
   a property that describes the UI. We recommend following these
   high-level steps.

   #. Determine the UI state that enables and disables each callback.

   #. Define that state using an `observable data holder type <#expose-ui-state>`__, such as
      ``StateFlow`` or Compose State, and enable or disable the callback
      as the state changes.

   If your app was previously associating back logic with conditional
   statements, this might signify you are reacting to the back event
   after it has already occurred‚Äîa pattern you should avoid with newer
   callbacks. If possible, move the callback outside of the conditional
   statement and instead associate the callback to an observable data
   holder type.

   .. rubric:: Use system back callbacks for UI Logic
      :name: ui-logic

   `UI logic <#logic>`__
   dictates how to display UI. Use system back callbacks to run UI
   logic, such as displaying a pop-up or running an animation.

   If your app enables a system back callback, the predictive animations
   don't run and you must handle the back event. Don't create callbacks
   only to run non-UI logic.

   For example, if you're intercepting back events only to log, log
   within the Activity or Fragment lifecycle instead.

   -  For activity-to-activity cases or fragment-to-activity cases, log
      if ``isFinishing`` within ``onDestroy`` is ``true`` within the
      Activity lifecycle.
   -  For fragment-to-fragment cases, log if ``isRemoving`` within
      ``onDestroy`` is true within the Fragment's view lifecycle; or,
      log using ``onBackStackChangeStarted`` or
      ``onBackStackChangeCommitted`` methods within
      ``FragmentManager.OnBackStackChangedListener``.

   For the Compose case, log within the ``onCleared()`` callback of a
   ``ViewModel`` associated with the Compose destination. This is the
   best signal for knowing when a compose destination has been popped
   off the back stack and destroyed.

   .. rubric:: Create single responsibility callbacks
      :name: single-responsibility

   This is possible because you can add multiple callbacks to the
   dispatcher. The callbacks are added to a stack in which the last
   added enabled callback handles the next back gesture with one
   callback per back gesture.

   .. rubric:: Test the predictive back gesture animation
      :name: dev-option

   **Caution:**\  This animation component of the predictive back
   gesture feature will not be available until the final release of
   Android 13. See `Timeline, milestones, and updates for more details <#timeline>`__.
   Starting with the Android 13 final release, you should be able to
   enable a developer option to test the back-to-home animation shown in
   figure 1.

   To test this animation, complete the following steps:

   #. On your device, go to **Settings > System > Developer options**.

   #. Select **Predictive back animations**.

   #. Launch your updated app, and use the back gesture to see it in
      action.


Last updated 2024-05-03 UTC.


/Add support for predictive back animations
===========================================

.. container:: devsite-article-body clearfix

   When using the system back APIs, you can opt in to receive in-app
   animations and support custom transitions.

   .. container::

      Alas, if your browser doesn't support HTML5 video. That's OK! You can still
      `download the video <https://developer.android.google.cn/static/about/versions/14/images/predictive-back-settings-example.mp4>`__ 
      and watch it with a video player.

      **Video:** Predictive back animations

   After opting in, your app displays animations for back-to-home,
   cross-activity, and cross-task.

   You can also upgrade your material component dependency to v1.10.0 of
   MDC Android to receive material component animations like the
   following:

   -  `Bottom sheets <https://m3.material.io/components/bottom-sheets/guidelines#3d7735e2-73ea-4f3e-bd42-e70161fc1085>`__
   -  `Side sheets <https://m3.material.io/components/side-sheets/guidelines#d77245e3-1013-48f8-a9d7-76f484e1be13>`__
   -  `Search <https://m3.material.io/components/search/guidelines#3f2d4e47-2cf5-4c33-b6e1-5368ceaade55>`__

   See the `material component developer guidance on GitHub <https://github.com/material-components/material-components-android/blob/master/docs/foundations/PredictiveBack.md#predictive-back-material-components>`__
   for more information.

   The video shows a brief example of predictive back animations for
   cross-activity and back-to-home using the Android Settings app.

   #. In the animation, the user swipes back to return to the previous
      settings screen‚Äîan example of a cross-activity animation.
   #. Now on the previous screen, the user begins swiping back a second
      time, showing a preview of the home screen with its wallpaper‚Äîan
      example of the back-to-home animation.
   #. The user continues to swipe right, showing an animation of the
      window shrinking down to the icon on the home screen.
   #. The user has now fully returned to the home screen.

   Learn more about how to `Add support for predictive back gestures <#>`__.

   .. rubric:: Add custom in-app transitions and animations
      :name: design-custom
      :class: clear

   You can create custom in-app property animations and transitions,
   custom cross-activity animations, and custom cross-fragment
   animations with predictive back gestures.

   .. rubric:: Add custom transitions using the Progress API
      :name: progress-api

   With AndroidX Activity 1.8.0-alpha01 or higher, you can use the
   Predictive Back Progress APIs to develop custom animations for the
   predictive back gesture in your app. Progress APIs are helpful in
   animating views but have limitations when animating transitions
   between fragments. Within `OnBackPressedCallback <#>`__
   we've introduced the `handleOnBackProgressed <#handleOnBackPressed>`__,
   `handleOnBackCancelled <#handleOnBackCancelled>`__ and
   `handleOnBackStarted <#handleOnBackStarted>`__
   methods to animate objects while the user swipes back. Use these
   methods if you need to customize more than the default animations
   provided by the system, or the Material Component animations.

   We expect most apps to use the backward compatible AndroidX APIs, but
   there are also similar platform APIs within the `OnBackAnimationCallback <#>`__
   interface available to test in Android 14 Developer Preview 1 and higher.

   **Note:**\  Learn how to `design custom in-app transitions and animations. <#>`__.

   .. rubric:: Use the Progress APIs with AndroidX Transitions
      :name: androidx-transitions

   .. container::

      Alas, if your browser doesn't support HTML5 video. That's OK! You can
      still `download the video <https://developer.android.google.cn/static/about/versions/14/images/predictive-back-settings-example.mp4>`__
      and watch it with a video player.

   The Progress APIs can be used with AndroidX Transitions 1.5.0-alpha01
   or higher on Android 14 and above to create Predictive Back
   transitions.

   #. Use
      `TransitionManager#controlDelayedTransition <#controlDelayedTransition>`__
      instead of ``beginDelayedTransition`` to play transitions as the
      user swipes back.
   #. Create the transition within ``handleOnBackStarted``.
   #. Play the transition with the back event within
      ``handleOnBackProgressed`` by relating ``currentFraction`` to
      ``BackEvent.progress`` which exposes how far the user has swiped
      back.
   #. Finish the transition after the user has committed the back
      gesture in ``handleOnBackPressed``.
   #. Finally, reset the state of the transition within
      ``handleOnBackCancelled``.

   The following video, Kotlin code, and XML demonstrate a custom
   transition between two boxes implemented with
   ``OnBackPressedCallback``:

   .. container::

      .. code:: prettyprint

             class MyFragment : Fragment() {

             val transitionSet = TransitionSet().apply {
                 addTransition(Fade(Fade.MODE_OUT))
                 addTransition(ChangeBounds())
                 addTransition(Fade(Fade.MODE_IN))
             }
             ...
             override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                 super.onViewCreated(view, savedInstanceState)

                 val callback = object : OnBackPressedCallback(enabled = false) {

                     var controller: TransitionSeekController? = null

                     @RequiresApi(34)
                     override fun handleOnBackStarted(backEvent: BackEvent) {
                         // Create the transition
                         controller = TransitionManager.controlDelayedTransition(
                             binding.card,
                             transitionSet
                         )
                         changeTextVisibility(ShowText.SHORT)
                     }

                     @RequiresApi(34)
                     override fun handleOnBackProgressed(backEvent: BackEvent) {
                         // Play the transition as the user swipes back
                         if (controller?.isReady == true) {
                             controller?.currentFraction = backEvent.progress
                         }
                     }

                     override fun handleOnBackPressed() {
                         // Finish playing the transition when the user commits back
                         controller?.animateToEnd()
                         this.isEnabled = false
                     }

                     @RequiresApi(34)
                     override fun handleOnBackCancelled() {
                         // If the user cancels the back gesture, reset the state
                         transition(ShowText.LONG)
                     }
                 }

                 binding.shortText.setOnClickListener {
                     transition(ShowText.LONG)
                     callback.isEnabled = true
                 }

                 this.requireActivity().onBackPressedDispatcher.addCallback(callback)
             }

             private fun transition(showText: ShowText) {
                 TransitionManager.beginDelayedTransition(
                     binding.card,
                     transitionSet
                 )
                 changeTextVisibility(showText)
             }

             enum class ShowText { SHORT, LONG }
             private fun changeTextVisibility(showText: ShowText) {
                 when (showText) {
                     ShowText.SHORT -> {
                         binding.shortText.isVisible = true
                         binding.longText.isVisible = false
                     }
                     ShowText.LONG -> {
                         binding.shortText.isVisible = false
                         binding.longText.isVisible = true
                     }
                 }
             }
         }
           

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      ...
          <androidx.constraintlayout.widget.ConstraintLayout
              android:id="@+id/card"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              ...>

              <TextView
                  android:id="@+id/short_text"
                  android:layout_width="match_parent"
                  android:layout_height="match_parent"
                  ... />

              <TextView
                  android:id="@+id/long_text"
                  android:layout_width="match_parent"
                  android:layout_height="match_parent"
                  android:visibility="gone"
                  .../>

          </androidx.constraintlayout.widget.ConstraintLayout>

   When working with Predictive Back transitions, keep the following in
   mind:

   -  Use ``isSeekingSupported`` to check if the transition supports
      Predictive Back.
   -  Override ``isSeekingSupported`` to return true for your custom
      transitions.
   -  Create one controller per animation.
   -  Predictive Back transitions are supported with AndroidX
      transitions, but not with framework transitions. We recommend
      migrating away from framework transitions.
   -  Predictive Back transitions are supported on devices running
      Android 14 and higher and are not backward compatible.
   -  Transitions created with XML scenes are also supported. In
      ``handleOnBackStarted``, set your ``TransitionSeekController`` to
      the result of
      `TransitionManager.createSeekController <#createSeekController>`__
      instead of the result of ``controlDelayedTransition``.

   .. rubric:: Add custom activity transitions on Android 14 and higher
      :name: custom-activity

   To ensure that custom Activity transitions support Predictive Back on
   Android 14 and higher, you can use
   `overrideActivityTransition <#overrideActivityTransition>`__
   instead of ``overridePendingTransition``. This means that the
   transition animation plays as the user swipes back.

   To provide an example of how this might work, imagine a scenario in
   which Activity B is on top of Activity A in the back stack. You would
   handle custom Activity animations in the following way:

   -  Call either opening or closing transitions within Activity B's
      ``onCreate`` method.

   -  When the user navigates to Activity B, use
      ``OVERRIDE_TRANSITION_OPEN``. When the user swipes to navigate
      back to Activity A, use ``OVERRIDE_TRANSITION_CLOSE``.

   -  When specifying ``OVERRIDE_TRANSITION_CLOSE``, the ``enterAnim``
      is Activity A's enter animation and the ``exitAnim`` is Activity
      B's exit animation.

      **Note:**\  If ``exitAnim`` isn't set or is set to ``0``, the
      default cross-activity predictive animation, shown in the
      preceding video, plays instead.

   .. rubric:: Add support for Predictive Back with fragments
      :name: fragments

   When implementing Predictive Back with fragments, there are two
   approaches.

   .. rubric:: Use existing APIs
      :name: use_existing_apis

   We recommend that you use existing APIs. These APIs allow you to
   swipe from the edge of the screen to manipulate your Animator or
   Androidx transitions with the gesture. Whether you move the gesture
   past a threshold determines whether it is completed and you return to
   the previous fragment, or it is cancelled and you remain on the
   current fragment. For more information, see `Navigate between fragments using animations <#>`__.

   Keep the following factors in mind:

   -  Import `Transitions 1.5.0 <#version_150_2>`__ or
      later and `Fragments 1.7.0 <#version_17_2>`__ or
      later. Much of predictive back support within Fragments relies on
      Transitions being able to seek animations, which is only possible
      in Transitions 1.5.0 or later.
   -  Use Fragments, with either ``FragmentManager`` or the 
      `Navigation Component <#>`__, to handle the back stack.
      Predictive Back is not supported if you manage your own back
      stack.
   -  Some libraries include Predictive Back support. Check the
      documentation to be sure.
   -  The `Animator <#>`__ class and `AndroidX Transition <#>`__ library are supported.
   -  The ``Animation`` class and framework ``Transition`` library are
      not supported.
   -  Predictive animations only work on devices that run Android 14 or
      higher.

   Use predictive back cross-fragments in the following situations:

   -  `Animate the navigation component <#>`__.
   -  Animate with
      `setCustomAnimations <#setCustomAnimations>`__.
   -  Animate enter and exit transitions with
      `setEnterTransition <#setEnterTransition>`__,
      `setExitTransition <#setExitTransition>`__,
      `setReenterTransition <#setReenterTransition>`__
      and
      `setReturnTransition <#setReturnTransition>`__.
   -  Animate shared element transitions with
      `setSharedElementEnterTransition <#setSharedElementEnterTransition>`__,
      and
      `setSharedElementReturnTransition <#setSharedElementReturnTransition>`__.

   Some `material motions <https://m2.material.io/develop/android/theming/motion>`__
   support predictive back as of
   `1.12.02-alpha02 <https://github.com/material-components/material-components-android/releases/tag/1.12.0-alpha02>`__
   or higher, including ``MaterialFadeThrough``, ``MaterialSharedAxis``
   and ``MaterialFade``. Note ``MaterialContainerTransform`` doesn't
   support predictive back.

   .. rubric:: Use callbacks
      :name: use_callbacks

   You can create a cross-fragment transition using callbacks, however
   there is a known limitation when using callbacks where users cannot
   see the previous fragment when swiping back. To create a
   cross-fragment shared element transition that corresponds to the
   predictive back `design guidance <#>`__, do
   the following:

   Create an ``OnBackPressedCallback``. Within
   ``handleOnBackProgressed``, scale and shift the fragment. Then pop
   from the back stack. Next, run the shared element transition using
   ``setSharedElementReturnTransition`` outside the callback.

   For more information, see `the code sample <https://github.com/android/animation-samples/blob/main/Motion/app/src/main/java/com/example/android/motion/demo/containertransform/CheeseArticleFragment.kt>`__
   on GitHub.

   .. rubric:: Requirements
      :name: requirements

   Use the following tables to understand what is controlled by
   developer options, ``targetSdkVersion`` and ``compileSdkVersion``,
   device version, dependencies, manifest flags, and fragment flags. The
   first table refers to code requirements.

   =================== ============================== ========== ========= ========== =========================
   Category            Animation                      compileSdk targetSdk |Callback| Dependency
   =================== ============================== ========== ========= ========== =========================
   System Animations   Back-to-home                   33         Any       TRUE       None
   \                   Cross-activity                 34         Any       TRUE       None
   \                   Cross-task                     34         Any       TRUE       None
   Platform            Custom cross-activity          34         Any       TRUE       None
   \                   Progress API Platform          34         Any       TRUE       None
   Material Components Bottom Sheet                   34         Any       TRUE       Material Component 1.10.0
   \                   Side Sheet                     34         Any       TRUE       Material Component 1.10.0
   \                   Navigation Drawer              34         Any       TRUE       Material Component 1.10.0
   \                   Search                         34         Any       TRUE       Material Component 1.10.0
   Jetpack Animations  Custom AndroidX cross-fragment 34         Any       TRUE       AndroidX Fragment 1.7
   \                   Custom AndroidX Transitions    34         Any       TRUE       AndroidX Transition 1.5
   \                   Progress API Jetpack           34         Any       TRUE       AndroidX Activity 1.8
   =================== ============================== ========== ========= ========== =========================

   .. |Callback| replace:: android:enableOnBackInvokedCallback

   The following table refers to requirements that allow users to see animations.

   =================== ============================== ======================== ==============
   Category            Animation                      Developer Option enabled Device version
   =================== ============================== ======================== ==============
   System Animations   Back-to-home                   TRUE                     33
   \                   Cross-activity                 TRUE                     34
   \                   Cross-task                     TRUE                     34
   Platform            Custom cross-activity          TRUE                     34
   \                   Progress API Platform          FALSE                    34
   Material Components Bottom Sheet                   FALSE                    34
   \                   Side Sheet                     FALSE                    34
   \                   Navigation Drawer              FALSE                    34
   \                   Search                         FALSE                    34
   Jetpack Animations  Custom AndroidX cross-fragment FALSE                    34
   \                   Custom AndroidX Transitions    FALSE                    34
   \                   Progress API Jetpack           FALSE                    34
   =================== ============================== ======================== ==============

   .. rubric:: Additional Resources
      :name: additional_resources

   -  `Predictive back code samples <https://github.com/android/platform-samples/tree/main/samples/user-interface/predictiveback>`__
   -  `Basics for system back video <https://www.youtube.com/watch?v=Elpqr5xpLxQ>`__
   -  `Building for the future of Android video <https://www.youtube.com/watch?v=WMMPXayjP8g&t=335s>`__


Last updated 2024-05-03 UTC.


/Handling configuration changes
===============================

.. container:: devsite-article-body clearfix

   .. rubric:: Responsive UI and navigation
      :name: responsive_ui_and_navigation

   To provide the best possible navigation experience to your users, you
   should provide a navigation UI that is tailored to the width, height,
   and smallest-width of the user‚Äôs device. You may wish to use a
   `bottom app bar <https://material.io/components/app-bars-bottom/>`__,
   an always-present or collapsible `navigation drawer <https://material.io/components/navigation-drawer/>`__, a
   `rail <https://material.io/design/material-studies/reply.html#product-architecture>`__,
   or perhaps something completely new based on the available screen
   space and your app's unique style.

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/nav-ui-elements.png
      :alt: examples of a rail, navigation drawers, and a bottom app bar

      **Figure 1.** Examples of a rail, navigation drawers, and a bottom
      app bar.

   The material design `guide to product architecture <https://material.io/design/material-studies/reply.html#product-architecture>`__
   provides additional context and considerations for building a
   responsive UI‚Äîthat is, a UI that dynamically adapts to environmental
   changes. A few examples of environmental changes include adjustments
   to width, height, orientation, and user language preference. These
   environmental properties are collectively referred to as the device‚Äôs
   *configuration*.

   When one or more of these properties change at runtime, the Android
   OS responds by `destroying and then recreating your app‚Äôs activities and fragments <#>`__.
   Therefore, the best thing you can do to support a responsive UI on
   Android is to ensure that you‚Äôre using `resource configuration qualifiers <#AlternativeResources>`__
   where appropriate and `avoiding the use of hard-coded layout sizes <#TaskUseWrapMatchPar>`__.

   **Note:**\  To learn more about configuration changes, how to
   restrict Activity recreation if needed, and how to react to those
   configuration changes from the View system and Jetpack Compose, check
   out the `Handle configuration changes <#>`__ page.

   .. rubric:: Implementing global navigation in a responsive UI
      :name: implementing_global_navigation_in_a_responsive_ui

   Implementing global navigation as part of a responsive UI starts with
   the activity that is hosting your navigation graph. For a hands-on
   example, check out the `Navigation codelab <https://developers.google.cn/codelabs/codelabs/android-navigation>`__.
   The codelab uses a
   `NavigationView <#>`__
   to display the navigation menu, as shown in figure 2. When running on
   a device that renders at a width of at least 960dp, this
   ``NavigationView`` is always on-screen.

   .. figure::
      https://developer.android.google.cn/static/images/guide/navigation/omnipresent-navigation-view.png
      :alt: the navigation codelab uses a navigation view that is always
      visible when device width is at least 960dp
      :width: 600px

      **Figure 2.** The Navigation codelab uses a ``NavigationView`` to
      display the navigation menu.

   Other device sizes and orientations dynamically switch between
   `DrawerLayout <#>`__
   or
   `BottomNavigationView <#>`__
   as needed.

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/bottom-or-drawer.png
      :alt: a bottomnavigationview and a drawerlayout, used for the
      navigation menu as needed in smaller device layouts
      :width: 600px

      **Figure 3.** The Navigation codelab uses ``BottomNavigationView``
      and ``DrawerLayout``\ to display the navigation menu on smaller
      devices.

   You can implement this behavior by creating three different layouts,
   where each layout defines the desired navigation elements and view
   hierarchy based on the current device configuration.

   The configuration to which each layout applies is determined by the
   directory structure in which the layout file is placed. For example,
   the ``NavigationView`` layout file is found in the
   ``res/layout-w960dp`` directory.

   .. code:: prettyprint

      <!-- res/layout-w960dp/navigation_activity.xml -->
      <RelativeLayout
         xmlns:android="http://schemas.android.com/apk/res/android"
         xmlns:app="http://schemas.android.com/apk/res-auto"
         xmlns:tools="http://schemas.android.com/tools"
         android:layout_width="match_parent"
         android:layout_height="match_parent"
         tools:context="com.example.android.codelabs.navigation.MainActivity">

         <com.google.android.material.navigation.NavigationView
             android:id="@+id/nav_view"
             android:layout_width="wrap_content"
             android:layout_height="match_parent"
             android:layout_alignParentStart="true"
             app:elevation="0dp"
             app:headerLayout="@layout/nav_view_header"
             app:menu="@menu/nav_drawer_menu" />

         <View
             android:layout_width="1dp"
             android:layout_height="match_parent"
             android:layout_toEndOf="@id/nav_view"
             android:background="?android:attr/listDivider" />

         <androidx.appcompat.widget.Toolbar
             android:id="@+id/toolbar"
             android:layout_width="match_parent"
             android:layout_height="wrap_content"
             android:layout_alignParentTop="true"
             android:layout_toEndOf="@id/nav_view"
             android:background="@color/colorPrimary"
             android:theme="@style/ThemeOverlay.MaterialComponents.Dark.ActionBar" />

         <androidx.fragment.app.FragmentContainerView
             android:id="@+id/my_nav_host_fragment"
             android:name="androidx.navigation.fragment.NavHostFragment"
             android:layout_width="match_parent"
             android:layout_height="match_parent"
             android:layout_below="@id/toolbar"
             android:layout_toEndOf="@id/nav_view"
             app:defaultNavHost="true"
             app:navGraph="@navigation/mobile_navigation" />
      </RelativeLayout>

   The bottom navigation view is found in the ``res/layout-h470dp``
   directory:

   .. code:: prettyprint

      <!-- res/layout-h470dp/navigation_activity.xml -->
      <LinearLayout
         xmlns:android="http://schemas.android.com/apk/res/android"
         xmlns:app="http://schemas.android.com/apk/res-auto"
         xmlns:tools="http://schemas.android.com/tools"
         android:layout_width="match_parent"
         android:layout_height="match_parent"
         android:orientation="vertical"
         tools:context="com.example.android.codelabs.navigation.MainActivity">

         <androidx.appcompat.widget.Toolbar
             android:id="@+id/toolbar"
             android:layout_width="match_parent"
             android:layout_height="wrap_content"
             android:background="@color/colorPrimary"
             android:theme="@style/ThemeOverlay.MaterialComponents.Dark.ActionBar" />

         <androidx.fragment.app.FragmentContainerView
             android:id="@+id/my_nav_host_fragment"
             android:name="androidx.navigation.fragment.NavHostFragment"
             android:layout_width="match_parent"
             android:layout_height="0dp"
             android:layout_weight="1"
             app:defaultNavHost="true"
             app:navGraph="@navigation/mobile_navigation" />

         <com.google.android.material.bottomnavigation.BottomNavigationView
             android:id="@+id/bottom_nav_view"
             android:layout_width="match_parent"
             android:layout_height="wrap_content"
             app:menu="@menu/bottom_nav_menu" />
      </LinearLayout>

   The drawer layout is found in the ``res/layout`` directory. Use this
   directory for default layouts with no configuration-specific
   qualifiers:

   .. code:: prettyprint

      <!-- res/layout/navigation_activity.xml -->
      <androidx.drawerlayout.widget.DrawerLayout
         xmlns:android="http://schemas.android.com/apk/res/android"
         xmlns:app="http://schemas.android.com/apk/res-auto"
         xmlns:tools="http://schemas.android.com/tools"
         android:id="@+id/drawer_layout"
         android:layout_width="match_parent"
         android:layout_height="match_parent"
         tools:context="com.example.android.codelabs.navigation.MainActivity">

         <LinearLayout
             android:layout_width="match_parent"
             android:layout_height="match_parent"
             android:orientation="vertical">

             <androidx.appcompat.widget.Toolbar
                 android:id="@+id/toolbar"
                 android:layout_width="match_parent"
                 android:layout_height="wrap_content"
                 android:background="@color/colorPrimary"
                 android:theme="@style/ThemeOverlay.MaterialComponents.Dark.ActionBar" />

             <androidx.fragment.app.FragmentContainerView
                 android:id="@+id/my_nav_host_fragment"
                 android:name="androidx.navigation.fragment.NavHostFragment"
                 android:layout_width="match_parent"
                 android:layout_height="match_parent"
                 app:defaultNavHost="true"
                 app:navGraph="@navigation/mobile_navigation" />
         </LinearLayout>

         <com.google.android.material.navigation.NavigationView
             android:id="@+id/nav_view"
             android:layout_width="wrap_content"
             android:layout_height="match_parent"
             android:layout_gravity="start"
             app:menu="@menu/nav_drawer_menu" />
      </androidx.drawerlayout.widget.DrawerLayout>

   Android follows an `order of precedence <#AlternativeResources>`__
   when determining which resources to apply. Specific to this example,
   ``-w960dp`` (or available width >= 960dp) takes precedence over
   ``-h470dp`` (or available height >= 470). If the device configuration
   doesn't match either of those conditions, then the default layout
   resource (``res/layout/navigation_activity.xml``) is used.

   In handling navigation events, you need to wire up only the events
   that correspond to the widgets that are currently present, as shown
   in the following example.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MainActivity : AppCompatActivity() {

                  private lateinit var appBarConfiguration : AppBarConfiguration

                  override fun onCreate(savedInstanceState: Bundle?) {
                     super.onCreate(savedInstanceState)
                     setContentView(R.layout.navigation_activity)
                     val drawerLayout : DrawerLayout? = findViewById(R.id.drawer_layout)
                     appBarConfiguration = AppBarConfiguration(
                                 setOf(R.id.home_dest, R.id.deeplink_dest),
                                 drawerLayout)

                     ...

                     // Initialize the app bar with the navigation drawer if present.
                     // If the drawerLayout is not null here, a Navigation button will be added
                     // to the app bar whenever the user is on a top-level destination.
                     setupActionBarWithNavController(navController, appBarConfig)

                     // Initialize the NavigationView if it is present,
                     // so that clicking an item takes
                     // the user to the appropriate destination.
                     val sideNavView = findViewById<NavigationView>(R.id.nav_view)
                     sideNavView?.setupWithNavController(navController)

                     // Initialize the BottomNavigationView if it is present,
                     // so that clicking an item takes
                     // the user to the appropriate destination.
                     val bottomNav = findViewById<BottomNavigationView>(R.id.bottom_nav_view)
                     bottomNav?.setupWithNavController(navController)

                     ...
                   }

                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends AppCompatActivity {

                  private AppBarConfiguration appBarConfiguration;

                  @Override
                  protected void onCreate(@Nullable Bundle savedInstanceState) {
                      super.onCreate(savedInstanceState);
                      setContentView(R.layout.navigation_activity);
                      NavHostFragment host = (NavHostFragment) getSupportFragmentManager()
                              .findFragmentById(R.id.my_nav_host_fragment);
                      NavController navController = host.getNavController();

                      DrawerLayout drawerLayout = findViewById(R.id.drawer_layout);
                      appBarConfiguration = new AppBarConfiguration.Builder(
                              R.id.home_dest, R.id.deeplink_dest)
                              .setDrawerLayout(drawerLayout)
                              .build();

                      // Initialize the app bar with the navigation drawer if present.
                      // If the drawerLayout is not null here, a Navigation button will be added to
                      // the app bar whenever the user is on a top-level destination.
                      NavigationUI.setupActionBarWithNavController(
                              this, navController, appBarConfiguration);


                      // Initialize the NavigationView if it is present,
                      // so that clicking an item takes
                      // the user to the appropriate destination.
                      NavigationView sideNavView = findViewById(R.id.nav_view);
                      if(sideNavView != null) {
                          NavigationUI.setupWithNavController(sideNavView, navController);
                      }

                      // Initialize the BottomNavigationView if it is present,
                      // so that clicking an item takes
                      // the user to the appropriate destination.
                      BottomNavigationView bottomNav = findViewById(R.id.bottom_nav_view);
                      if(bottomNav != null) {
                          NavigationUI.setupWithNavController(bottomNav, navController);
                      }

                  }
               }

   If the device configuration changes, unless explicitly `configured otherwise <#HandlingTheChange>`__,
   Android destroys the activity from the previous configuration along
   with its associated views. It then recreates the activity with
   resources designed for the new configuration. The activity, being
   destroyed and recreated, then automatically wires up the proper
   global navigation elements in ``onCreate()``.

   **Note:**\  While the navigation UI might change, the navigation
   graph should not change between configurations. ``NavHostFragment``
   saves and restores the current graph state between configuration
   changes. During the restoration process, all restored destinations
   are assumed to exist on the current graph.

   .. rubric:: Consider alternatives to split-view layouts
      :name: consider_alternatives_to_split-view_layouts

   Split-view layouts, or *master/detail layouts*, were once a very
   popular and recommended way to design for tablets and other large
   screen devices.

   Since the introduction of Android tablets, the ecosystem of devices
   has grown rapidly. One factor that has considerably influenced the
   design space for large screen devices has been the introduction of
   multi-window modes, particularly free-form windows that are fully
   resizable, such as those on ChromeOS devices. This puts a
   significantly higher emphasis on every screen of your app being
   responsive, rather than changing your navigation structure based on
   the screen size.

   While it's possible to implement a split-view layout interface using
   the Navigation library, you should `consider other alternatives <https://medium.com/androiddevelopers/building-a-responsive-ui-in-android-7dc7e4efcbb3>`__.

   .. rubric:: Destination names
      :name: destination_names

   If you provide destination names in your graph using the
   ``android:label`` attribute, be sure to always use resource values so
   that your content can still be localized.

   .. code:: prettyprint

      <navigation ...>
          <fragment
              android:id="@+id/my_dest"
              android:name="com.example.MyFragment"
              android:label="@string/my_dest_label"
              tools:layout="@layout/my_fragment" />
          ...

   With resource values, your destinations automatically have the most
   appropriate resources applied whenever your configuration changes.


Last updated 2024-02-28 UTC.


/Design for different form factors
==================================

.. container:: devsite-article-body clearfix

   The design of your app‚Äôs UI isn't tied to a particular device form
   factor. Android applications need to adapt to a number of different
   types of devices, from 4-inch handsets to 50-inch TVs to ChromeOS
   devices with resizable windows.

   **Note:**\  Designing applications for television sets also requires
   attention to other factors, including interaction methods (i.e.,
   dealing with the lack of a touch screen), legibility of text at large
   reading distances, and more. You can find more information on
   designing for TVs in the `Android TV documentation <#>`__.
   Your app‚Äôs user interface is drawn inside of a window, the size of
   which can change at will. You use resource qualifiers to provide
   different layouts for varying window sizes. These differences can be
   due to constraints in the size of the device‚Äôs screen, or they can be
   driven by the user using multi-window mode to change the window size.

   .. rubric:: Designing responsive content
      :name: designing_responsive_content

   You should provide a rich experience for all of your users, so you
   should have each screen in your app take full advantage of the window
   real estate available to you.

   For example, an app running in a window taking up the full width of a
   phone screen could perhaps hide details for a piece of content when
   entering multi-window mode, and it could expand its user interface to
   provide more content when running in a window taking up the full
   width of a ChromeOS device‚Äôs screen.

   In addition to addressing these user expectations, it's often
   necessary to provide more content on larger devices to avoid leaving
   too much whitespace or unwittingly introducing awkward interactions.
   In the following figure, you can see some of the problems that can
   arise when adapting a user interface design for a larger window:

   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-form-factors-whitespace.png

   **Figure 1.** Not enough content on large-width windows leads to
   awkward whitespace and exceedingly long line lengths.

   **Note:**\  After deciding at which window sizes you will provide
   difference resources, see `Providing Alternate Resources <#AlternativeResources>`__
   for more detail on how to implement your designs.
   To learn more about designing responsive navigation experiences, see
   `Navigation for responsive UIs <#>`__.

   .. rubric:: Providing tailored user experiences
      :name: providing_tailored_user_experiences

   It‚Äôs important to provide unique experiences that go beyond expanding
   your content views to fill available space. You can tailor user
   interfaces to provide the ideal user experience for given window
   sizes, even using entirely different layouts and widgets.

   In figure 2, a
   `BottomNavigationView <#>`__
   is used as top-level navigation when there is adequate vertical space
   to do so. When the size of the window is reduced, as shown on the
   right side of the figure, top-level navigation is instead implemented
   using a
   `DrawerLayout <#>`__.

   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-form-factors-adaptive.png


   **Figure 2.** The bottom nav bar is replaced with a nav drawer when
   vertical space is limited.

   Here are some other examples:

   -  A `Toolbar <#>`__ can show or
      hide action menu items given the amount of available space.
   -  A
      `RecyclerView.LayoutManager <#>`__
      could change its span count to take full advantage of the size of
      a window
   -  You can increase the amount of detail you show for custom views as
      you have more space to do so.

   These are all great ways to make sure that your users have great
   experiences wherever they‚Äôre running your app.

   You can find more examples of responsive design patterns and ideas
   for adaptive layouts on
   `material.io <https://material.io/design/layout/component-behavior.html#responsive-patterns>`__.


Last updated 2024-01-03 UTC.



/Create swipe views with tabs using ViewPager2
==============================================

.. container:: devsite-article-body clearfix

   Swipe views allow you to navigate between sibling screens, such as
   tabs, with a horizontal finger gesture, or *swipe*. This navigation
   pattern is also referred to as *horizontal paging*. This topic
   teaches you how to create a tab layout with swipe views for switching
   between tabs, along with how to show a title strip instead of tabs.

   **Note:**\  If your app already uses
   `ViewPager <#>`__,
   see `Migrate from ViewPager to ViewPager2 <#>`__.

   .. rubric:: Implement Swipe Views
      :name: implement_swipe_views

   You can create swipe views using AndroidX's
   `ViewPager2 <#>`__
   widget. To use ViewPager2 and tabs, you need to add a dependency on
   `ViewPager2 <#androidx-deps>`__
   and on `Material Components <https://material.io/develop/android/docs/getting-started/>`__
   to your project.

   To set up your layout with ``ViewPager2``, add the ``<ViewPager2>``
   element to your XML layout. For example, if each page in the swipe
   view should consume the entire layout, then your layout should look
   like this:

   .. code:: prettyprint

      <androidx.viewpager2.widget.ViewPager2
          xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/pager"
          android:layout_width="match_parent"
          android:layout_height="match_parent" />

   To insert child views that represent each page, you need to hook this
   layout to a
   `FragmentStateAdapter <#>`__.
   Here's how you might use it to swipe across a collection of
   ``Fragment`` objects:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CollectionDemoFragment : Fragment() {
                   // When requested, this adapter returns a DemoObjectFragment,
                   // representing an object in the collection.
                   private lateinit var demoCollectionAdapter: DemoCollectionAdapter
                   private lateinit var viewPager: ViewPager2

                   override fun onCreateView(
                       inflater: LayoutInflater,
                       container: ViewGroup?,
                       savedInstanceState: Bundle?
                   ): View? {
                       return inflater.inflate(R.layout.collection_demo, container, false)
                   }

                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       demoCollectionAdapter = DemoCollectionAdapter(this)
                       viewPager = view.findViewById(R.id.pager)
                       viewPager.adapter = demoCollectionAdapter
                   }
               }

               class DemoCollectionAdapter(fragment: Fragment) : FragmentStateAdapter(fragment) {

                   override fun getItemCount(): Int = 100

                   override fun createFragment(position: Int): Fragment {
                       // Return a NEW fragment instance in createFragment(int)
                       val fragment = DemoObjectFragment()
                       fragment.arguments = Bundle().apply {
                           // Our object is just an integer :-P
                           putInt(ARG_OBJECT, position + 1)
                       }
                       return fragment
                   }
               }

               private const val ARG_OBJECT = "object"

               // Instances of this class are fragments representing a single
               // object in our collection.
               class DemoObjectFragment : Fragment() {

                   override fun onCreateView(
                       inflater: LayoutInflater,
                       container: ViewGroup?,
                       savedInstanceState: Bundle?
                   ): View {
                       return inflater.inflate(R.layout.fragment_collection_object, container, false)
                   }

                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       arguments?.takeIf { it.containsKey(ARG_OBJECT) }?.apply {
                           val textView: TextView = view.findViewById(android.R.id.text1)
                           textView.text = getInt(ARG_OBJECT).toString()
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CollectionDemoFragment extends Fragment {
                   // When requested, this adapter returns a DemoObjectFragment,
                   // representing an object in the collection.
                   DemoCollectionAdapter demoCollectionAdapter;
                   ViewPager2 viewPager;

                   @Nullable
                   @Override
                   public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,
                           @Nullable Bundle savedInstanceState) {
                       return inflater.inflate(R.layout.collection_demo, container, false);
                   }

                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       demoCollectionAdapter = new DemoCollectionAdapter(this);
                       viewPager = view.findViewById(R.id.pager);
                       viewPager.setAdapter(demoCollectionAdapter);
                   }
               }

               public class DemoCollectionAdapter extends FragmentStateAdapter {
                   public DemoCollectionAdapter(Fragment fragment) {
                       super(fragment);
                   }

                   @NonNull
                   @Override
                   public Fragment createFragment(int position) {
                       // Return a NEW fragment instance in createFragment(int)
                       Fragment fragment = new DemoObjectFragment();
                       Bundle args = new Bundle();
                       // Our object is just an integer :-P
                       args.putInt(DemoObjectFragment.ARG_OBJECT, position + 1);
                       fragment.setArguments(args);
                       return fragment;
                   }

                   @Override
                   public int getItemCount() {
                       return 100;
                   }
               }

               // Instances of this class are fragments representing a single
               // object in our collection.
               public class DemoObjectFragment extends Fragment {
                   public static final String ARG_OBJECT = "object";

                   @Nullable
                   @Override
                   public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,
                           @Nullable Bundle savedInstanceState) {
                       return inflater.inflate(R.layout.fragment_collection_object, container, false);
                   }

                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       Bundle args = getArguments();
                       ((TextView) view.findViewById(android.R.id.text1))
                               .setText(Integer.toString(args.getInt(ARG_OBJECT)));
                   }
               }

   The following sections show how you can add tabs to help facilitate
   navigation between pages.

   .. rubric:: Add Tabs Using a TabLayout
      :name: add_tabs_using_a_tablayout

   A
   `TabLayout <#>`__
   provides a way to display tabs horizontally. When used together with
   a ``ViewPager2``, a ``TabLayout`` can provide a familiar interface
   for navigating between pages in a swipe view.


   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-tab-layout.png
      :width: 400px

   **Figure 1:** A ``TabLayout`` with four tabs.

   To include a ``TabLayout`` in a ``ViewPager2``, add a ``<TabLayout>``
   element above the ``<ViewPager2>`` element, as shown below:

   .. code:: prettyprint

      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          android:orientation="vertical">

          <com.google.android.material.tabs.TabLayout
              android:id="@+id/tab_layout"
              android:layout_width="match_parent"
              android:layout_height="wrap_content" />

          <androidx.viewpager2.widget.ViewPager2
              android:id="@+id/pager"
              android:layout_width="match_parent"
              android:layout_height="0dp"
              android:layout_weight="1" />

      </LinearLayout>

   Next, create a
   `TabLayoutMediator <#>`__
   to link the ``TabLayout`` to the ``ViewPager2``, and attach it as
   follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CollectionDemoFragment : Fragment() {
                   ...
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       val tabLayout = view.findViewById(R.id.tab_layout)
                       TabLayoutMediator(tabLayout, viewPager) { tab, position ->
                           tab.text = "OBJECT ${(position + 1)}"
                       }.attach()
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CollectionDemoFragment extends Fragment {
                   ...
                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       TabLayout tabLayout = view.findViewById(R.id.tab_layout);
                       new TabLayoutMediator(tabLayout, viewPager,
                               (tab, position) -> tab.setText("OBJECT " + (position + 1))
                       ).attach();
                   }
                   ...
               }

   **Note:**\  If you have a large or potentially infinite number of
   pages, set the ``android:tabMode`` attribute on your ``TabLayout`` to
   "scrollable". This prevents ``TabLayout`` from trying to fit all tabs
   on the screen at once and allows users to scroll through the list of
   tabs.
   For additional design guidance for tab layouts, see the `Material Design documentation for tabs <https://material.io/design/components/tabs.html>`__.

   .. rubric:: Additional resources
      :name: additional-resources

   To learn more about ``ViewPager2``, see the following additional
   resources.

   .. rubric:: Samples
      :name: samples

   -  `ViewPager2 samples <https://goo.gle/viewpager2-sample>`__ on
      GitHub

   .. rubric:: Videos
      :name: videos

   -  `Turning the Page: Migrating to ViewPager2 <https://www.youtube.com/watch?v=lAP6cz1HSzA>`__
      (Android Dev Summit '19)


Last updated 2024-01-03 UTC.


/Create swipe views with tabs using ViewPager
=============================================

.. container:: devsite-article-body clearfix

   *Swipe views* let you navigate between sibling screens, such as tabs,
   with a horizontal finger gesture (*swipe*). This navigation pattern
   is also referred to as *horizontal paging*. This document shows how
   to create a tab layout with swipe views for switching between tabs,
   along with how to show a title strip instead of tabs.

   **Note:**\  For swiping views, we recommend the
   `ViewPager2 <#>`__
   library. For more information, see `Create swipe views with tabs using ViewPager2 <#>`__ and
   `the ViewPager2 migration guide <#>`__.

   .. rubric:: Implement swipe views
      :name: implement

   You can create swipe views using AndroidX's
   `ViewPager <#>`__
   widget. To use ``ViewPager`` and tabs, add dependencies on
   `Viewpager <#androidx-deps>`__
   and on `Material Components <https://material.io/develop/android/docs/getting-started/>`__
   in your project.

   To set up your layout with ``ViewPager``, add the ``<ViewPager>``
   element to your XML layout. For example, if each page in the swipe
   view needs to consume the entire layout, then your layout looks like
   this:

   .. code:: prettyprint

      <androidx.viewpager.widget.ViewPager
          xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/pager"
          android:layout_width="match_parent"
          android:layout_height="match_parent" />

   To insert child views that represent each page, hook this layout to a
   `PagerAdapter <#>`__.
   You can choose between two kinds of built-in adapters:

   -  `FragmentPagerAdapter <#>`__:
      use this when navigating between a small, fixed number of sibling
      screens.
   -  `FragmentStatePagerAdapter <#>`__:
      use this when paging across an unknown number of pages.
      ``FragmentStatePagerAdapter`` optimizes memory usage by destroying
      fragments as the user navigates away.

   Here's an example of how you can use ``FragmentStatePagerAdapter`` to
   swipe across a collection of ``Fragment`` objects:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CollectionDemoFragment : Fragment() {
                   // When requested, this adapter returns a DemoObjectFragment, representing
                   // an object in the collection.
                   private lateinit var demoCollectionPagerAdapter: DemoCollectionPagerAdapter
                   private lateinit var viewPager: ViewPager

                   override fun onCreateView(inflater: LayoutInflater,
                           container: ViewGroup?,
                           savedInstanceState: Bundle?): View? {
                      return inflater.inflate(R.layout.collection_demo, container, false)
                   }

                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       demoCollectionPagerAdapter = DemoCollectionPagerAdapter(childFragmentManager)
                       viewPager = view.findViewById(R.id.pager)
                       viewPager.adapter = demoCollectionPagerAdapter
                   }
               }

               // Since this is an object collection, use a FragmentStatePagerAdapter, not a
               // FragmentPagerAdapter.
               class DemoCollectionPagerAdapter(fm: FragmentManager) : FragmentStatePagerAdapter(fm) {

                   override fun getCount(): Int  = 100

                   override fun getItem(i: Int): Fragment {
                       val fragment = DemoObjectFragment()
                       fragment.arguments = Bundle().apply {
                           // Our object is just an integer :-P
                           putInt(ARG_OBJECT, i + 1)
                       }
                       return fragment
                   }

                   override fun getPageTitle(position: Int): CharSequence {
                       return "OBJECT ${(position + 1)}"
                   }
               }

               private const val ARG_OBJECT = "object"

               // Instances of this class are fragments representing a single object in your
               // collection.
               class DemoObjectFragment : Fragment() {

                  override fun onCreateView(inflater: LayoutInflater,
                          container: ViewGroup?,
                          savedInstanceState: Bundle?): View {
                      return inflater.inflate(R.layout.fragment_collection_object, container, false)
                  }

                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       arguments?.takeIf { it.containsKey(ARG_OBJECT) }?.apply {
                           val textView: TextView = view.findViewById(android.R.id.text1)
                           textView.text = getInt(ARG_OBJECT).toString()
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CollectionDemoFragment extends Fragment {
                   // When requested, this adapter returns a DemoObjectFragment, representing
                   // an object in the collection.
                   DemoCollectionPagerAdapter demoCollectionPagerAdapter;
                   ViewPager viewPager;

                   @Nullable
                   @Override
                   public View onCreateView(@NonNull LayoutInflater inflater,
                           @Nullable ViewGroup container,
                           @Nullable Bundle savedInstanceState) {
                       return inflater.inflate(R.layout.collection_demo, container, false);
                   }

                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       demoCollectionPagerAdapter = new DemoCollectionPagerAdapter(getChildFragmentManager());
                       viewPager = view.findViewById(R.id.pager);
                       viewPager.setAdapter(demoCollectionPagerAdapter);
                  }
               }

               // Since this is an object collection, use a FragmentStatePagerAdapter, not a
               // FragmentPagerAdapter.
               public class DemoCollectionPagerAdapter extends FragmentStatePagerAdapter {
                   public DemoCollectionPagerAdapter(FragmentManager fm) {
                       super(fm);
                   }

                   @Override
                   public Fragment getItem(int i) {
                       Fragment fragment = new DemoObjectFragment();
                       Bundle args = new Bundle();
                       // Our object is just an integer.
                       args.putInt(DemoObjectFragment.ARG_OBJECT, i + 1);
                       fragment.setArguments(args);
                       return fragment;
                   }

                   @Override
                   public int getCount() {
                       return 100;
                   }

                   @Override
                   public CharSequence getPageTitle(int position) {
                       return "OBJECT " + (position + 1);
                   }
               }

               // Instances of this class are fragments representing a single object in your
               // collection.
               public class DemoObjectFragment extends Fragment {
                   public static final String ARG_OBJECT = "object";

                   @Override
                   public View onCreateView(LayoutInflater inflater,
                           ViewGroup container, Bundle savedInstanceState) {
                      return inflater.inflate(R.layout.fragment_collection_object, container, false);
                   }

                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       Bundle args = getArguments();
                       ((TextView) view.findViewById(android.R.id.text1))
                               .setText(Integer.toString(args.getInt(ARG_OBJECT)));
                   }
               }

   The following section shows how to add tabs to facilitate navigation
   between pages.

   .. rubric:: Add tabs using a TabLayout
      :name: add-tabs

   A
   `TabLayout <#>`__
   provides a way to display tabs horizontally. When used with a
   ``ViewPager``, a ``TabLayout`` provides a familiar interface for
   navigating between pages in a swipe view.


   .. image:: https://developer.android.google.cn/static/images/topic/libraries/architecture/navigation-tab-layout.png
      :width: 400px

   **Figure 1.** A ``TabLayout`` with four tabs.
   To include a ``TabLayout`` in a ``ViewPager``, add a ``<TabLayout>``
   element inside the ``<ViewPager>`` element, as shown in the following
   example:

   .. code:: prettyprint

      <androidx.viewpager.widget.ViewPager
          xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/pager"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

          <com.google.android.material.tabs.TabLayout
              android:id="@+id/tab_layout"
              android:layout_width="match_parent"
              android:layout_height="wrap_content" />

      </androidx.viewpager.widget.ViewPager>

   Use
   `setupWithViewPager() <#setupWithViewPager>`__
   to link the ``TabLayout`` to the ``ViewPager``, as shown in the
   following example. The individual tabs in the ``TabLayout`` are
   automatically populated with the page titles from the
   ``PagerAdapter``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CollectionDemoFragment : Fragment() {
                   ...
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       val tabLayout = view.findViewById(R.id.tab_layout)
                       tabLayout.setupWithViewPager(viewPager)
                   }
                   ...
               }

               class DemoCollectionPagerAdapter(fm: FragmentManager) : FragmentStatePagerAdapter(fm) {

                   override fun getCount(): Int  = 4

                   override fun getPageTitle(position: Int): CharSequence {
                       return "OBJECT ${(position + 1)}"
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CollectionDemoFragment extends Fragment {
                   ...
                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       TabLayout tabLayout = view.findViewById(R.id.tab_layout);
                       tabLayout.setupWithViewPager(viewPager);
                   }
                   ...
               }

               public class DemoCollectionPagerAdapter extends FragmentStatePagerAdapter {
                   ...
                   @Override
                   public int getCount() {
                       return 4;
                   }

                   @Override
                   public CharSequence getPageTitle(int position) {
                       return "OBJECT " + (position + 1);
                   }

                   ...
               }

   **Note:**\  If you have a large or potentially infinite number of
   pages, set the ``android:tabMode`` attribute on your ``TabLayout`` to
   ``"scrollable"``. This prevents ``TabLayout`` from fitting all tabs
   on the screen at once and lets users scroll through the list of tabs.
   For additional design guidance for tab layouts, see the `Material Design documentation for tabs <https://material.io/design/components/tabs.html>`__.


Last updated 2024-01-03 UTC.


/Overview: Fragments
====================

.. https://developer.android.google.cn/guide/fragments

.. container:: devsite-article-body clearfix

   A `Fragment <#>`__
   represents a reusable portion of your app's UI. A fragment defines
   and manages its own layout, has its own lifecycle, and can handle its
   own input events. Fragments can't live on their own. They must be
   *hosted* by an activity or another fragment. The fragment‚Äôs view
   hierarchy becomes part of, or *attaches to*, the host‚Äôs view
   hierarchy.

   **Note:**\  Some `Android Jetpack <#>`__ libraries, such as `Navigation <#>`__,
   `BottomNavigationView <#>`__, and `ViewPager2 <#>`__, are
   designed to work with fragments.

   .. rubric:: Modularity
      :name: modularity

   Fragments introduce modularity and reusability into your activity‚Äôs
   UI by letting you divide the UI into discrete chunks. Activities are
   an ideal place to put global elements around your app's user
   interface, such as a navigation drawer. Conversely, fragments are
   better suited to define and manage the UI of a single screen or
   portion of a screen.

   Consider an app that responds to various screen sizes. On larger
   screens, you might want the app to display a static navigation drawer
   and a list in a grid layout. On smaller screens, you might want the
   app to display a bottom navigation bar and a list in a linear layout.

   Managing these variations in the activity is unwieldy. Separating the
   navigation elements from the content can make this process more
   manageable. The activity is then responsible for displaying the
   correct navigation UI, while the fragment displays the list with the
   proper layout.

   .. figure:: https://developer.android.google.cn/static/images/guide/fragments/fragment-screen-sizes.png
      :alt: Two versions of the same screen on different screen sizes.

      **Figure 1.** Two versions of the same screen on different screen
      sizes. On the left, a large screen contains a navigation drawer
      that is controlled by the activity and a grid list that is
      controlled by the fragment. On the right, a small screen contains
      a bottom navigation bar that is controlled by the activity and a
      linear list that is controlled by the fragment.

   Dividing your UI into fragments makes it easier to modify your
   activity's appearance at runtime. While your activity is in the
   ``STARTED`` `lifecycle state <#>`__ or higher,
   fragments can be added, replaced, or removed. And you can keep a
   record of these changes in a back stack that is managed by the
   activity, so that the changes can be reversed.

   You can use multiple instances of the same fragment class within the
   same activity, in multiple activities, or even as a child of another
   fragment. With this in mind, only provide a fragment with the logic
   necessary to manage its own UI. Avoid depending on or manipulating
   one fragment from another.

   .. rubric:: Next steps
      :name: next

   For more documentation and resources related to fragments, see the
   following.

   .. rubric:: Getting Started
      :name: getting-started

   -  `Create a fragment <#>`__

   .. rubric:: Further topics
      :name: topics

   -  `Fragment manager <#>`__
   -  `Fragment transactions <#>`__
   -  `Navigate between fragments using animations <#>`__
   -  `Fragment lifecycle <#>`__
   -  `Saving state with fragments <#>`__
   -  `Communicate with fragments <#>`__
   -  `Working with the AppBar <#>`__
   -  `Display dialogs with DialogFragment <#>`__
   -  `Debug your fragments <#>`__
   -  `Test your fragments <#>`__

   .. rubric:: Samples
      :name: samples

   .. rubric:: Videos
      :name: videos

   -  `Single Activity: Why, when, and how (Android Dev Summit '18) <https://www.youtube.com/watch?v=2k8x8V77CrU>`__
   -  `Fragments: Past, present, and future (Android Dev Summit '19) <https://www.youtube.com/watch?v=RS1IACnZLy4>`__


Last updated 2023-03-22 UTC.


/Create a fragment
==================

.. container:: devsite-article-body clearfix

   A `fragment <#>`__ represents a modular portion of the
   user interface within an activity. A fragment has its own lifecycle,
   receives its own input events, and you can add or remove fragments
   while the containing activity is running.

   This document describes how to create a fragment and include it in an
   activity.

   .. rubric:: Setup your environment
      :name: setup

   Fragments require a dependency on the `AndroidX Fragment library <#>`__. You need to add the
   `Google Maven repository <#google-maven>`__
   to your project's ``settings.gradle`` file in order to include this
   dependency.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencyResolutionManagement {
                   repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
                   repositories {
                       google()
                       ...
                   }
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencyResolutionManagement {
                   repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
                   repositories {
                       google()
                       ...
                   }
               }

   To include the AndroidX Fragment library to your project, add the
   following dependencies in your app's ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   def fragment_version = "1.7.0"

                   // Java language implementation
                   implementation "androidx.fragment:fragment:$fragment_version"
                   // Kotlin
                   implementation "androidx.fragment:fragment-ktx:$fragment_version"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   val fragment_version = "1.7.0"

                   // Java language implementation
                   implementation("androidx.fragment:fragment:$fragment_version")
                   // Kotlin
                   implementation("androidx.fragment:fragment-ktx:$fragment_version")
               }

   .. rubric:: Create a fragment class
      :name: create

   To create a fragment, extend the AndroidX
   `Fragment <#>`__ class,
   and override its methods to insert your app logic, similar to the way
   you would create an
   `Activity <#>`__ class. To create a
   minimal fragment that defines its own layout, provide your fragment's
   layout resource to the base constructor, as shown in the following
   example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleFragment : Fragment(R.layout.example_fragment)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class ExampleFragment extends Fragment {
                   public ExampleFragment() {
                       super(R.layout.example_fragment);
                   }
               }

   The Fragment library also provides more specialized fragment base
   classes:

   `DialogFragment <#>`__
      Displays a floating dialog. Using this class to create a dialog is
      a good alternative to using the dialog helper methods in the
      `Activity <#>`__ class, as
      fragments automatically handle the creation and cleanup of the
      ``Dialog``. See `Displaying dialogs with ``DialogFragment </guide/fragments/dialogs>`__ for more details.
   `PreferenceFragmentCompat <#>`__
      Displays a hierarchy of
      `Preference <#>`__
      objects as a list. You can use ``PreferenceFragmentCompat`` to
      `create a settings screen <#>`__ for your app.

   .. rubric:: Add a fragment to an activity
      :name: add

   Generally, your fragment must be embedded within an AndroidX
   `FragmentActivity <#>`__
   to contribute a portion of UI to that activity's layout.
   ``FragmentActivity`` is the base class for
   `AppCompatActivity <#>`__,
   so if you're already subclassing ``AppCompatActivity`` to provide
   backward compatibility in your app, then you do not need to change
   your activity base class.

   You can add your fragment to the activity's view hierarchy either by
   defining the fragment in your activity's layout file or by defining a
   fragment container in your activity's layout file and then
   programmatically adding the fragment from within your activity. In
   either case, you need to add a
   `FragmentContainerView <#>`__
   that defines the location where the fragment should be placed within
   the activity's view hierarchy. It is strongly recommended to always
   use a ``FragmentContainerView`` as the container for fragments, as
   ``FragmentContainerView`` includes fixes specific to fragments that
   other view groups such as ``FrameLayout`` do not provide.

   .. rubric:: Add a fragment via XML
      :name: add-xml

   To declaratively add a fragment to your activity layout's XML, use a
   ``FragmentContainerView`` element.

   Here's an example activity layout containing a single
   ``FragmentContainerView``:

   .. code:: prettyprint

      <!-- res/layout/example_activity.xml -->
      <androidx.fragment.app.FragmentContainerView
          xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/fragment_container_view"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          android:name="com.example.ExampleFragment" />

   The ``android:name`` attribute specifies the class name of the
   ``Fragment`` to instantiate. When the activity's layout is inflated,
   the specified fragment is instantiated,
   `onInflate() <#onInflate>`__
   is called on the newly instantiated fragment, and a
   ``FragmentTransaction`` is created to add the fragment to the
   ``FragmentManager``.

   **Note:**\  You can use the ``class`` attribute instead of
   ``android:name`` as an alternative way to specify which ``Fragment``
   to instantiate.

   .. rubric:: Add a fragment programmatically
      :name: add-programmatic

   To programmatically add a fragment to your activity's layout, the
   layout should include a ``FragmentContainerView`` to serve as a
   fragment container, as shown in the following example:

   .. code:: prettyprint

      <!-- res/layout/example_activity.xml -->
      <androidx.fragment.app.FragmentContainerView
          xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/fragment_container_view"
          android:layout_width="match_parent"
          android:layout_height="match_parent" />

   Unlike the XML approach, the ``android:name`` attribute isn't used on
   the ``FragmentContainerView`` here, so no specific fragment is
   automatically instantiated. Instead, a
   `FragmentTransaction <#>`__
   is used to instantiate a fragment and add it to the activity's
   layout.

   While your activity is running, you can make fragment transactions
   such as adding, removing, or replacing a fragment. In your
   ``FragmentActivity``, you can get an instance of the
   `FragmentManager <#>`__,
   which can be used to create a ``FragmentTransaction``. Then, you can
   instantiate your fragment within your activity's ``onCreate()``
   method using
   `FragmentTransaction.add() <#add>`__,
   passing in the ``ViewGroup`` ID of the container in your layout and
   the fragment class you want to add and then commit the transaction,
   as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleActivity : AppCompatActivity(R.layout.example_activity) {
                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       if (savedInstanceState == null) {
                           supportFragmentManager.commit {
                               setReorderingAllowed(true)
                               add<ExampleFragment>(R.id.fragment_container_view)
                           }
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleActivity extends AppCompatActivity {
                   public ExampleActivity() {
                       super(R.layout.example_activity);
                   }
                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       if (savedInstanceState == null) {
                           getSupportFragmentManager().beginTransaction()
                               .setReorderingAllowed(true)
                               .add(R.id.fragment_container_view, ExampleFragment.class, null)
                               .commit();
                       }
                   }
               }

   **Note:**\  You should **always** use ``setReorderingAllowed(true)``
   when performing a ``FragmentTransaction``. For more information on
   reordered transactions, see `Fragment transactions <#reordering>`__.
   In the previous example, note that the fragment transaction is only
   created when ``savedInstanceState`` is ``null``. This is to ensure
   that the fragment is added only once, when the activity is first
   created. When a configuration change occurs and the activity is
   recreated, ``savedInstanceState`` is no longer ``null``, and the
   fragment does not need to be added a second time, as the fragment is
   automatically restored from the ``savedInstanceState``.

   If your fragment requires some initial data, arguments can be passed
   to your fragment by providing a
   `Bundle <https://developer.android.google.cn/reference/android/os/Bundle>`__
   in the call to ``FragmentTransaction.add()``, as shown below:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleActivity : AppCompatActivity(R.layout.example_activity) {
                     override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       if (savedInstanceState == null) {
                           val bundle = bundleOf("some_int" to 0)
                           supportFragmentManager.commit {
                               setReorderingAllowed(true)
                               add<ExampleFragment>(R.id.fragment_container_view, args = bundle)
                           }
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleActivity extends AppCompatActivity {
                   public ExampleActivity() {
                       super(R.layout.example_activity);
                   }
                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       if (savedInstanceState == null) {
                           Bundle bundle = new Bundle();
                           bundle.putInt("some_int", 0);

                           getSupportFragmentManager().beginTransaction()
                               .setReorderingAllowed(true)
                               .add(R.id.fragment_container_view, ExampleFragment.class, bundle)
                               .commit();
                       }
                   }
               }

   The arguments ``Bundle`` can then be retrieved from within your
   fragment by calling
   `requireArguments() <#requireArguments>`__,
   and the appropriate ``Bundle`` getter methods can be used to retrieve
   each argument.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleFragment : Fragment(R.layout.example_fragment) {
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       val someInt = requireArguments().getInt("some_int")
                       ...
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class ExampleFragment extends Fragment {
                   public ExampleFragment() {
                       super(R.layout.example_fragment);
                   }

                   @Override
                   public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
                       int someInt = requireArguments().getInt("some_int");
                       ...
                   }
               }

   .. rubric:: See also
      :name: see-also

   Fragment transactions and the ``FragmentManager`` are covered in more
   detail in the `Fragment manager guide <#>`__.


Last updated 2024-05-01 UTC.


/Fragment manager
=================

.. container:: devsite-article-body clearfix

   **Note:**\  We strongly recommend using the `Navigation library <#>`__ to manage your app's navigation. The
   framework follows best practices for working with fragments, the back
   stack, and the fragment manager. For more information about
   Navigation, see `Get started with the Navigation component <#>`__ and
   `Migrate to the Navigation component <#>`__.
   `FragmentManager <#>`__
   is the class responsible for performing actions on your app's
   fragments, such as adding, removing, or replacing them and adding
   them to the back stack.

   You might never interact with ``FragmentManager`` directly if you're
   using the `Jetpack Navigation <#>`__ library, as it
   works with the ``FragmentManager`` on your behalf. However, any app
   using fragments is using ``FragmentManager`` at some level, so it's
   important to understand what it is and how it works.

   This page covers:

   -  How to access the ``FragmentManager``.
   -  The role of ``FragmentManager`` in relation to your activities and
      fragments.
   -  How to manage the back stack with ``FragmentManager``.
   -  How to provide data and dependencies to your fragments.

   .. rubric:: Access the FragmentManager
      :name: access

   You can access the ``FragmentManager`` from an activity or from a
   fragment.

   `FragmentActivity <#>`__
   and its subclasses, such as
   `AppCompatActivity <#>`__,
   have access to the ``FragmentManager`` through the
   `getSupportFragmentManager() <#getSupportFragmentManager>`__
   method.

   Fragments can host one or more child fragments. Inside a fragment,
   you can get a reference to the ``FragmentManager`` that manages the
   fragment's children through
   `getChildFragmentManager() <#getChildFragmentManager>`__.
   If you need to access its host ``FragmentManager``, you can use
   `getParentFragmentManager() <#getParentFragmentManager>`__.

   Here are a couple of examples to see the relationships between
   fragments, their hosts, and the ``FragmentManager`` instances
   associated with each.

   .. figure:: https://developer.android.google.cn/static/images/guide/fragments/fragment-host.png
      :alt: two ui layout examples showing the relationships between
      fragments and their host activities
      :width: 700px

      **Figure 1.** Two UI layout examples showing the relationships
      between fragments and their host activities.

   Figure 1 shows two examples, each of which has a single activity
   host. The host activity in both of these examples displays top-level
   navigation to the user as a
   `BottomNavigationView <#>`__
   that is responsible for swapping out the host fragment with different
   screens in the app. Each screen is implemented as a separate
   fragment.

   The host fragment in Example 1 hosts two child fragments that make up
   a split-view screen. The host fragment in Example 2 hosts a single
   child fragment that makes up the display fragment of a `swipe view <#implement_swipe_views>`__.

   Given this setup, you can think about each host as having a
   ``FragmentManager`` associated with it that manages its child
   fragments. This is illustrated in figure 2 along with property
   mappings between ``supportFragmentManager``,
   ``parentFragmentManager``, and ``childFragmentManager``.

   .. figure:: https://developer.android.google.cn/static/images/guide/fragments/manager-mappings.png
      :alt: each host has its own FragmentManager associated with it
      that manages its child fragments
      :width: 700px

      **Figure 2.** Each host has its own ``FragmentManager`` associated
      with it that manages its child fragments.

   The appropriate ``FragmentManager`` property to reference depends on
   where the callsite is in the fragment hierarchy along with which
   fragment manager you are trying to access.

   Once you have a reference to the ``FragmentManager``, you can use it
   to manipulate the fragments being displayed to the user.

   .. rubric:: Child fragments
      :name: child

   Generally speaking, your app consists of a single or small number of
   activities in your application project, with each activity
   representing a group of related screens. The activity might provide a
   point to place top-level navigation and a place to scope
   ``ViewModel`` objects and other view-state between fragments. A
   fragment represents an individual destination in your app.

   If you want to show multiple fragments at once, such as in a
   split-view or a dashboard, you can use child fragments that are
   managed by your destination fragment and its child fragment manager.

   Other use cases for child fragments are the following:

   -  `Screen slides <#>`__, using a
      ``ViewPager2`` in a parent fragment to manage a series of child
      fragment views.
   -  Sub-navigation within a set of related screens.
   -  Jetpack Navigation uses child fragments as individual
      destinations. An activity hosts a single parent
      ``NavHostFragment`` and fills its space with different child
      destination fragments as users navigate through your app.

   .. rubric:: Use the FragmentManager
      :name: using

   The ``FragmentManager`` manages the fragment back stack. At runtime,
   the ``FragmentManager`` can perform back stack operations like adding
   or removing fragments in response to user interactions. Each set of
   changes is committed together as a single unit called a
   `FragmentTransaction <#>`__.
   For a more in-depth discussion about fragment transactions, see the
   `fragment transactions guide <#>`__.

   When the user taps the Back button on their device, or when you call
   `FragmentManager.popBackStack() <#popBackStack>`__,
   the top-most fragment transaction pops off of the stack. If there are
   no more fragment transactions on the stack, and if you aren't using
   child fragments, the Back event bubbles up to the activity. If you
   *are* using child fragments, see `special considerations for child and sibling fragments <#considerations>`__.

   When you call
   `addToBackStack() <#addToBackStack>`__
   on a transaction, the transaction can include any number of
   operations, such as adding multiple fragments or replacing fragments
   in multiple containers.

   When the back stack is popped, all these operations reverse as a
   single atomic action. However, if you committed additional
   transactions prior to the ``popBackStack()`` call, and if you
   *didn't* use ``addToBackStack()`` for the transaction, these
   operations *don't* reverse. Therefore, within a single
   ``FragmentTransaction``, avoid interleaving transactions that affect
   the back stack with those that don't.

   .. rubric:: Perform a transaction
      :name: perform

   To display a fragment within a layout container, use the
   ``FragmentManager`` to create a ``FragmentTransaction``. Within the
   transaction, you can then perform an
   `add() <#add>`__
   or
   `replace() <#replace>`__
   operation on the container.

   For example, a simple ``FragmentTransaction`` might look like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               supportFragmentManager.commit {
                  replace<ExampleFragment>(R.id.fragment_container)
                  setReorderingAllowed(true)
                  addToBackStack("name") // Name can be null
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               FragmentManager fragmentManager = getSupportFragmentManager();
               fragmentManager.beginTransaction()
                   .replace(R.id.fragment_container, ExampleFragment.class, null)
                   .setReorderingAllowed(true)
                   .addToBackStack("name") // Name can be null
                   .commit();

   In this example, ``ExampleFragment`` replaces the fragment, if any,
   that is currently in the layout container identified by the
   ``R.id.fragment_container`` ID. Providing the fragment's class to the
   `replace() <#replace>`__
   method lets the ``FragmentManager`` handle instantiation using its
   `FragmentFactory <#>`__.
   For more information, see the `Provide dependencies to your fragments <#dependencies>`__ section.

   `setReorderingAllowed(true) <#setReorderingAllowed>`__
   optimizes the state changes of the fragments involved in the
   transaction so that animations and transitions work correctly. For
   more information on navigating with animations and transitions, see
   `Fragment transactions <#>`__ and
   `Navigate between fragments using animations <#>`__.

   Calling
   `addToBackStack() <#addToBackStack>`__
   commits the transaction to the back stack. The user can later reverse
   the transaction and bring back the previous fragment by tapping the
   Back button. If you added or removed multiple fragments within a
   single transaction, all those operations are undone when the back
   stack is popped. The optional name provided in the
   ``addToBackStack()`` call gives you the ability to pop back to a
   specific transaction using
   `popBackStack() <#popBackStack>`__.

   If you don't call ``addToBackStack()`` when you perform a transaction
   that removes a fragment, then the removed fragment is destroyed when
   the transaction is committed, and the user cannot navigate back to
   it. If you do call ``addToBackStack()`` when removing a fragment,
   then the fragment is only ``STOPPED`` and is later ``RESUMED`` when
   the user navigates back. Its view *is* destroyed in this case. For
   more information, see `Fragment lifecycle <#>`__.

   .. rubric:: Find an existing fragment
      :name: finding

   You can get a reference to the current fragment within a layout
   container by using
   `findFragmentById() <#findFragmentById>`__.
   Use ``findFragmentById()`` to look up a fragment either by the given
   ID when inflated from XML or by the container ID when added in a
   ``FragmentTransaction``. Here's an example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               supportFragmentManager.commit {
                  replace<ExampleFragment>(R.id.fragment_container)
                  setReorderingAllowed(true)
                  addToBackStack(null)
               }
               ...
               val fragment: ExampleFragment =
                       supportFragmentManager.findFragmentById(R.id.fragment_container) as ExampleFragment

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               FragmentManager fragmentManager = getSupportFragmentManager();
               fragmentManager.beginTransaction()
                   .replace(R.id.fragment_container, ExampleFragment.class, null)
                   .setReorderingAllowed(true)
                   .addToBackStack(null)
                   .commit();
               ...
               ExampleFragment fragment =
                       (ExampleFragment) fragmentManager.findFragmentById(R.id.fragment_container);

   Alternatively, you can assign a unique tag to a fragment and get a
   reference using
   `findFragmentByTag() <#findFragmentByTag>`__.
   You can assign a tag using the ``android:tag`` XML attribute on
   fragments that are defined within your layout or during an ``add()``
   or ``replace()`` operation within a ``FragmentTransaction``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               supportFragmentManager.commit {
                  replace<ExampleFragment>(R.id.fragment_container, "tag")
                  setReorderingAllowed(true)
                  addToBackStack(null)
               }
               ...
               val fragment: ExampleFragment =
                       supportFragmentManager.findFragmentByTag("tag") as ExampleFragment

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               FragmentManager fragmentManager = getSupportFragmentManager();
               fragmentManager.beginTransaction()
                   .replace(R.id.fragment_container, ExampleFragment.class, null, "tag")
                   .setReorderingAllowed(true)
                   .addToBackStack(null)
                   .commit();
               ...
               ExampleFragment fragment = (ExampleFragment) fragmentManager.findFragmentByTag("tag");

   .. rubric:: Special considerations for child and sibling fragments
      :name: considerations

   Only one ``FragmentManager`` can control the fragment back stack at
   any given time. If your app shows multiple sibling fragments on the
   screen at the same time, or if your app uses child fragments, then
   one ``FragmentManager`` is designated to handle your app's primary
   navigation.

   To define the primary navigation fragment inside of a fragment
   transaction, call the
   `setPrimaryNavigationFragment() <#setPrimaryNavigationFragment>`__
   method on the transaction, passing in the instance of the fragment
   whose ``childFragmentManager`` has primary control.

   Consider the navigation structure as a series of layers, with the
   activity as the outermost layer, wrapping each layer of child
   fragments underneath. Each layer has a single primary navigation
   fragment.

   When the Back event occurs, the innermost layer controls navigation
   behavior. Once the innermost layer has no more fragment transactions
   from which to pop back, control returns to the next layer out, and
   this process repeats until you reach the activity.

   When two or more fragments are displayed at the same time, only one
   of them is the primary navigation fragment. Setting a fragment as the
   primary navigation fragment removes the designation from the previous
   fragment. Using the preceding example, if you set the detail fragment
   as the primary navigation fragment, the main fragment's designation
   is removed.

   .. rubric:: Support multiple back stacks
      :name: multiple-back-stacks

   In some cases, your app might need to support multiple back stacks. A
   common example is if your app uses a bottom navigation bar.
   ``FragmentManager`` lets you support multiple back stacks with the
   ``saveBackStack()`` and ``restoreBackStack()`` methods. These methods
   let you swap between back stacks by saving one back stack and
   restoring a different one.

   **Note:**\  Alternatively, you can use the
   `NavigationUI <#>`__
   component, which automatically handles multiple back stack support
   for `bottom navigation <#bottom_navigation>`__.
   ``saveBackStack()`` works similarly to calling ``popBackStack()``
   with the optional ``name`` parameter: the specified transaction and
   all transactions after it on the stack are popped. The difference is
   that ``saveBackStack()`` `saves the state <#>`__ of all fragments in the
   popped transactions.

   For example, suppose you previously added a fragment to the back
   stack by committing a ``FragmentTransaction`` using
   ``addToBackStack()``, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               supportFragmentManager.commit {
                 replace<ExampleFragment>(R.id.fragment_container)
                 setReorderingAllowed(true)
                 addToBackStack("replacement")
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               supportFragmentManager.beginTransaction()
                 .replace(R.id.fragment_container, ExampleFragment.class, null)
                 // setReorderingAllowed(true) and the optional string argument for
                 // addToBackStack() are both required if you want to use saveBackStack()
                 .setReorderingAllowed(true)
                 .addToBackStack("replacement")
                 .commit();

   In that case, you can save this fragment transaction and the state of
   ``ExampleFragment`` by calling ``saveBackStack()``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               supportFragmentManager.saveBackStack("replacement")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               supportFragmentManager.saveBackStack("replacement");

   **Note:**\  You can use ``saveBackStack()`` only with transactions
   that call ``setReorderingAllowed(true)`` so that the transactions can
   be restored as a single, atomic operation.
   You can call ``restoreBackStack()`` with the same name parameter to
   restore all of the popped transactions and all of the saved fragment
   states:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               supportFragmentManager.restoreBackStack("replacement")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               supportFragmentManager.restoreBackStack("replacement");

   **Note:**\  You can't use ``saveBackStack()`` and
   ``restoreBackStack()`` unless you pass an optional name for your
   fragment transactions with ``addToBackStack()``.

   .. rubric:: Provide dependencies to your fragments
      :name: dependencies

   When adding a fragment, you can instantiate the fragment manually and
   add it to the ``FragmentTransaction``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fragmentManager.commit {
                   // Instantiate a new instance before adding
                   val myFragment = ExampleFragment()
                   add(R.id.fragment_view_container, myFragment)
                   setReorderingAllowed(true)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Instantiate a new instance before adding
               ExampleFragment myFragment = new ExampleFragment();
               fragmentManager.beginTransaction()
                   .add(R.id.fragment_view_container, myFragment)
                   .setReorderingAllowed(true)
                   .commit();

   When you commit the fragment transaction, the instance of the
   fragment you created is the instance used. However, during a
   `configuration change <#>`__,
   your activity and all of its fragments are destroyed and then
   recreated with the most applicable `Android resources <#BestMatch>`__.
   The ``FragmentManager`` handles all of this for you: it recreates
   instances of your fragments, attaches them to the host, and recreates
   the back stack state.

   By default, the ``FragmentManager`` uses a
   `FragmentFactory <#>`__
   that the framework provides to instantiate a new instance of your
   fragment. This default factory uses reflection to find and invoke a
   no-argument constructor for your fragment. This means that you can't
   use this default factory to provide dependencies to your fragment. It
   also means that any custom constructor you used to create your
   fragment the first time is *not* used during recreation by default.

   To provide dependencies to your fragment, or to use any custom
   constructor, instead create a custom ``FragmentFactory`` subclass and
   then override
   `FragmentFactory.instantiate <#instantiate>`__.
   You can then override the default factory of the ``FragmentManager``
   with your custom factory, which is then used to instantiate your
   fragments.

   Suppose you have a ``DessertsFragment`` that is responsible for
   displaying popular desserts in your hometown, and that
   ``DessertsFragment`` has a dependency on a ``DessertsRepository``
   class that provides it with the information it needs to display the
   correct UI to your user.

   You might define your ``DessertsFragment`` to require a
   ``DessertsRepository`` instance in its constructor.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class DessertsFragment(val dessertsRepository: DessertsRepository) : Fragment() {
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class DessertsFragment extends Fragment {
                   private DessertsRepository dessertsRepository;

                   public DessertsFragment(DessertsRepository dessertsRepository) {
                       super();
                       this.dessertsRepository = dessertsRepository;
                   }

                   // Getter omitted.

                   ...
               }

   A simple implementation of your ``FragmentFactory`` might look
   similar to the following.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyFragmentFactory(val repository: DessertsRepository) : FragmentFactory() {
                   override fun instantiate(classLoader: ClassLoader, className: String): Fragment =
                           when (loadFragmentClass(classLoader, className)) {
                               DessertsFragment::class.java -> DessertsFragment(repository)
                               else -> super.instantiate(classLoader, className)
                           }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyFragmentFactory extends FragmentFactory {
                   private DessertsRepository repository;

                   public MyFragmentFactory(DessertsRepository repository) {
                       super();
                       this.repository = repository;
                   }

                   @NonNull
                   @Override
                   public Fragment instantiate(@NonNull ClassLoader classLoader, @NonNull String className) {
                       Class<? extends Fragment> fragmentClass = loadFragmentClass(classLoader, className);
                       if (fragmentClass == DessertsFragment.class) {
                           return new DessertsFragment(repository);
                       } else {
                           return super.instantiate(classLoader, className);
                       }
                   }
               }

   This example subclasses ``FragmentFactory``, overriding the
   ``instantiate()`` method to provide custom fragment creation logic
   for a ``DessertsFragment``. Other fragment classes are handled by the
   default behavior of ``FragmentFactory`` through
   ``super.instantiate()``.

   You can then designate ``MyFragmentFactory`` as the factory to use
   when constructing your app's fragments by setting a property on the
   ``FragmentManager``. You must set this property prior to your
   activity's ``super.onCreate()`` to ensure that ``MyFragmentFactory``
   is used when recreating your fragments.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MealActivity : AppCompatActivity() {
                   override fun onCreate(savedInstanceState: Bundle?) {
                       supportFragmentManager.fragmentFactory = MyFragmentFactory(DessertsRepository.getInstance())
                       super.onCreate(savedInstanceState)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MealActivity extends AppCompatActivity {
                   @Override
                   protected void onCreate(@Nullable Bundle savedInstanceState) {
                       DessertsRepository repository = DessertsRepository.getInstance();
                       getSupportFragmentManager().setFragmentFactory(new MyFragmentFactory(repository));
                       super.onCreate(savedInstanceState);
                   }
               }

   Setting the ``FragmentFactory`` in the activity overrides fragment
   creation throughout the activity's fragment hierarchy. In other
   words, the ``childFragmentManager`` of any child fragments you add
   uses the custom fragment factory set here unless overridden at a
   lower level.

   .. rubric:: Test with FragmentFactory
      :name: testing

   In a single activity architecture, test your fragments in isolation
   using the
   `FragmentScenario <#>`__
   class. Since you can't rely on the custom ``onCreate`` logic of your
   activity, you can instead pass the ``FragmentFactory`` in as an
   argument to your fragments test, as shown in the following example:

   .. code:: prettyprint

      // Inside your test
      val dessertRepository = mock(DessertsRepository::class.java)
      launchFragment<DessertsFragment>(factory = MyFragmentFactory(dessertRepository)).onFragment {
          // Test Fragment logic
      }

   For detailed information about this testing process and for full
   examples, see `Test your fragments <#>`__.


Last updated 2024-01-03 UTC.


/Fragment transactions
======================

.. container:: devsite-article-body clearfix

   At runtime, a
   `FragmentManager <#>`__
   can add, remove, replace, and perform other actions with fragments in
   response to user interaction. Each set of fragment changes that you
   commit is called a *transaction*, and you can specify what to do
   inside the transaction using the APIs provided by the
   `FragmentTransaction <#>`__
   class. You can group multiple actions into a single transaction‚Äîfor
   example, a transaction can add or replace multiple fragments. This
   grouping can be useful for when you have multiple sibling fragments
   displayed on the same screen, such as with split views.

   You can save each transaction to a back stack managed by the
   ``FragmentManager``, allowing the user to navigate backward through
   the fragment changes‚Äîsimilar to navigating backward through
   activities.

   You can get an instance of ``FragmentTransaction`` from the
   ``FragmentManager`` by calling ``beginTransaction()``, as shown in
   the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val fragmentManager = ...
               val fragmentTransaction = fragmentManager.beginTransaction()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               FragmentManager fragmentManager = ...
               FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();

   The final call on each ``FragmentTransaction`` must commit the
   transaction. The ``commit()`` call signals to the ``FragmentManager``
   that all operations have been added to the transaction.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val fragmentManager = ...
               // The fragment-ktx module provides a commit block that automatically
               // calls beginTransaction and commit for you.
               fragmentManager.commit {
                   // Add operations here
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               FragmentManager fragmentManager = ...
               FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();

               // Add operations here

               fragmentTransaction.commit();

   .. rubric:: Allow reordering of fragment state changes
      :name: reordering

   Each ``FragmentTransaction`` should use
   ``setReorderingAllowed(true)``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               supportFragmentManager.commit {
                   ...
                   setReorderingAllowed(true)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               FragmentManager fragmentManager = ...
               fragmentManager.beginTransaction()
                   ...
                   .setReorderingAllowed(true)
                   .commit();

   For behavior compatibility, the reordering flag is not enabled by
   default. It is required, however, to allow ``FragmentManager`` to
   properly execute your ``FragmentTransaction``, particularly when it
   operates on the back stack and runs animations and transitions.
   Enabling the flag ensures that if multiple transactions are executed
   together, any intermediate fragments (i.e. ones that are added and
   then immediately replaced) do not go through lifecycle changes or
   have their animations or transitions executed. Note that this flag
   affects both the initial execution of the transaction and reversing
   the transaction with ``popBackStack()``.

   .. rubric:: Adding and removing fragments
      :name: add-remove

   To add a fragment to a ``FragmentManager``, call
   `add() <#add>`__
   on the transaction. This method receives the ID of the *container*
   for the fragment, as well as the class name of the fragment you wish
   to add. The added fragment is moved to the ``RESUMED`` state. It is
   strongly recommended that the *container* is a
   `FragmentContainerView <#>`__
   that is part of the view hierarchy.

   To remove a fragment from the host, call
   `remove() <#remove>`__,
   passing in a fragment instance that was retrieved from the fragment
   manager through ``findFragmentById()`` or ``findFragmentByTag()``. If
   the fragment's view was previously added to a container, the view is
   removed from the container at this point. The removed fragment is
   moved to the ``DESTROYED`` state.

   Use
   `replace() <#replace>`__
   to replace an existing fragment in a container with an instance of a
   new fragment class that you provide. Calling ``replace()`` is
   equivalent to calling ``remove()`` with a fragment in a container and
   adding a new fragment to that same container.

   The following code snippet shows how you can replace one fragment
   with another:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Create new fragment
               val fragmentManager = // ...

               // Create and commit a new transaction
               fragmentManager.commit {
                   setReorderingAllowed(true)
                   // Replace whatever is in the fragment_container view with this fragment
                   replace<ExampleFragment>(R.id.fragment_container)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create new fragment and transaction
               FragmentManager fragmentManager = ...
               FragmentTransaction transaction = fragmentManager.beginTransaction();
               transaction.setReorderingAllowed(true);

               // Replace whatever is in the fragment_container view with this fragment
               transaction.replace(R.id.fragment_container, ExampleFragment.class, null);

               // Commit the transaction
               transaction.commit();

   In this example, a new instance of ``ExampleFragment`` replaces the
   fragment, if any, that is currently in the layout container
   identified by ``R.id.fragment_container``.

   **Note:**\  It is strongly recommended to always use fragment
   operations that take a ``Class`` rather than a fragment instance to
   ensure that the same mechanisms for creating the fragment are also
   used for restoring the fragment from a saved state. See `Fragment manager <#>`__ for more details.
   By default, the changes made in a ``FragmentTransaction`` are not
   added to the back stack. To save those changes, you can call
   `addToBackStack() <#addToBackStack>`__
   on the ``FragmentTransaction``. For more information, see `Fragment manager <#>`__.

   .. rubric:: Commit is asynchronous
      :name: async

   Calling
   `commit() <#commit>`__
   doesn't perform the transaction immediately. Rather, the transaction
   is scheduled to run on the main UI thread as soon as it is able to do
   so. If necessary, however, you can call
   `commitNow() <#commit>`__
   to run the fragment transaction on your UI thread immediately.

   Note that ``commitNow`` is incompatible with ``addToBackStack``.
   Alternatively, you can execute all pending ``FragmentTransactions``
   submitted by
   `commit() <#commit>`__
   calls that have not yet run by calling
   `executePendingTransactions() <#executePendingTransactions>`__.
   This approach is compatible with ``addToBackStack``.

   For the vast majority of use cases, ``commit()`` is all you need.

   .. rubric:: Operation ordering is significant
      :name: operation_ordering_is_significant

   The order in which you perform operations within a
   `FragmentTransaction <#>`__
   is significant, particularly when using ``setCustomAnimations()``.
   This method applies the given animations to all fragment operations
   that follow it.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               supportFragmentManager.commit {
                   setCustomAnimations(enter1, exit1, popEnter1, popExit1)
                   add<ExampleFragment>(R.id.container) // gets the first animations
                   setCustomAnimations(enter2, exit2, popEnter2, popExit2)
                   add<ExampleFragment>(R.id.container) // gets the second animations
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               getSupportFragmentManager().beginTransaction()
                       .setCustomAnimations(enter1, exit1, popEnter1, popExit1)
                       .add(R.id.container, ExampleFragment.class, null) // gets the first animations
                       .setCustomAnimations(enter2, exit2, popEnter2, popExit2)
                       .add(R.id.container, ExampleFragment.class, null) // gets the second animations
                       .commit()

   .. rubric:: Limit the fragment's lifecycle
      :name: limit

   ``FragmentTransactions`` can affect the lifecycle state of individual
   fragments added within the scope of the transaction. When creating a
   ``FragmentTransaction``,
   `setMaxLifecycle() <#setMaxLifecycle>`__
   sets a maximum state for the given fragment. For example,
   `ViewPager2 <#>`__
   uses ``setMaxLifecycle()`` to limit the off-screen fragments to the
   ``STARTED`` state.

   .. rubric:: Showing and hiding fragment's views
      :name: views

   Use the ``FragmentTransaction`` methods
   `show() <#show>`__
   and
   `hide() <#hide>`__
   to show and hide the view of fragments that have been added to a
   container. These methods set the visibility of the fragment's views
   *without* affecting the lifecycle of the fragment.

   While you don't need to use a fragment transaction to toggle the
   visibility of the views within a fragment, these methods are useful
   for cases where you want changes to the visibility state to be
   associated with transactions on the back stack.

   .. rubric:: Attaching and detaching fragments
      :name: attach-detach

   The ``FragmentTransaction`` method
   `detach() <#detach>`__
   detaches the fragment from the UI, destroying its view hierarchy. The
   fragment remains in the same state (``STOPPED``) as when it is put on
   the back stack. This means that the fragment was removed from the UI
   but is still managed by the fragment manager.

   The
   `attach() <#attach>`__
   method reattaches a fragment from which it was previously detached.
   This causes its view hierarchy to be recreated, attached to the UI,
   and displayed.

   As a ``FragmentTransaction`` is treated as a single atomic set of
   operations, calls to both ``detach`` and ``attach`` on the same
   fragment instance in the same transaction effectively cancel each
   other out, thus avoiding the destruction and immediate recreation of
   the fragment's UI. Use separate transactions, separated by
   ``executePendingOperations()`` if using ``commit()``, if you want to
   detach and then immediately re-attach a fragment.

   **Note:**\  The ``attach()`` and ``detach()`` methods are not related
   to the ``Fragment`` methods of
   `onAttach() <#onAttach>`__
   and
   `onDetach() <#onDetach>`__.
   For more information about these ``Fragment`` methods, see `Fragment lifecycle <#>`__.


Last updated 2024-01-03 UTC.


/Navigate between fragments using animations
============================================

.. container:: devsite-article-body clearfix

   The Fragment API provides two ways to use motion effects and
   transformations to visually connect fragments during navigation. One
   of these is the Animation Framework, which uses both
   `Animation <#>`__ and
   `Animator <#>`__. The other
   is the `Transition Framework <#>`__, which
   includes shared element transitions.

   **Note:**\  In this topic, we use the term *animation* to describe
   effects in the Animation Framework, and we use the term *transition*
   to describe effects in the Transition Framework. These two frameworks
   are mutually exclusive and should not be used at the same time.
   You can specify custom effects for entering and exiting fragments and
   for transitions of shared elements between fragments.

   -  An *enter* effect determines how a fragment enters the screen. For
      example, you can create an effect to slide the fragment in from
      the edge of the screen when you navigate to it.
   -  An *exit* effect determines how a fragment exits the screen. For
      example, you can create an effect to fade the fragment out when
      navigating away from it.
   -  A *shared element transition* determines how a view that is shared
      between two fragments moves between them. For example, an image
      displayed in an ``ImageView`` in fragment A transitions to
      fragment B once B becomes visible.

   .. rubric:: Set animations
      :name: set-animations

   First, you need to create animations for your enter and exit effects,
   which are run when navigating to a new fragment. You can define
   animations as `tween animation resources <#Tween>`__.
   These resources allow you to define how fragments should rotate,
   stretch, fade, and move during the animation. For example, you might
   want the current fragment to fade out and the new fragment to slide
   in from the right edge of the screen, as shown in figure 1.

   .. figure::
      https://developer.android.google.cn/static/images/training/basics/fragments/enter-exit-animation.gif
      :alt: Enter and exit animations. The current fragment fades out
      while the next fragment slides in from the right.
      :width: 200px

      **Figure 1.** Enter and exit animations. The current fragment
      fades out while the next fragment slides in from the right.

   These animations can be defined in the ``res/anim`` directory:

   .. code:: prettyprint

      <!-- res/anim/fade_out.xml -->
      <?xml version="1.0" encoding="utf-8"?>
      <alpha xmlns:android="http://schemas.android.com/apk/res/android"
          android:duration="@android:integer/config_shortAnimTime"
          android:interpolator="@android:anim/decelerate_interpolator"
          android:fromAlpha="1"
          android:toAlpha="0" />

   .. code:: prettyprint

      <!-- res/anim/slide_in.xml -->
      <?xml version="1.0" encoding="utf-8"?>
      <translate xmlns:android="http://schemas.android.com/apk/res/android"
          android:duration="@android:integer/config_shortAnimTime"
          android:interpolator="@android:anim/decelerate_interpolator"
          android:fromXDelta="100%"
          android:toXDelta="0%" />

   **Note:**\  It is strongly recommended to `use transitions <#set-transitions>`__ for effects that involve more than
   one type of animation as there are known issues with using nested
   `AnimationSet <#>`__
   instances.
   You can also specify animations for the enter and exit effects that
   are run when popping the back stack, which can happen when the user
   taps the Up or Back button. These are called the ``popEnter`` and
   ``popExit`` animations. For example, when a user pops back to a
   previous screen, you might want the current fragment to slide off the
   right edge of the screen and the previous fragment to fade in.

   .. figure::
      https://developer.android.google.cn/static/images/training/basics/fragments/pop-animations.gif
      :alt: popEnter and popExit animations. The current fragment slides
      off the screen to the right while the previous fragment fades in.
      :width: 200px

      **Figure 2.** ``popEnter`` and ``popExit`` animations. The current
      fragment slides off the screen to the right while the previous
      fragment fades in.

   These animations can be defined as follows:

   .. code:: prettyprint

      <!-- res/anim/slide_out.xml -->
      <translate xmlns:android="http://schemas.android.com/apk/res/android"
          android:duration="@android:integer/config_shortAnimTime"
          android:interpolator="@android:anim/decelerate_interpolator"
          android:fromXDelta="0%"
          android:toXDelta="100%" />

   .. code:: prettyprint

      <!-- res/anim/fade_in.xml -->
      <alpha xmlns:android="http://schemas.android.com/apk/res/android"
          android:duration="@android:integer/config_shortAnimTime"
          android:interpolator="@android:anim/decelerate_interpolator"
          android:fromAlpha="0"
          android:toAlpha="1" />

   Once you've defined your animations, use them by calling
   `FragmentTransaction.setCustomAnimations() <#setCustomAnimations>`__,
   passing in your animation resources by their resource ID, as shown in
   the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               supportFragmentManager.commit {
                   setCustomAnimations(
                       R.anim.slide_in, // enter
                       R.anim.fade_out, // exit
                       R.anim.fade_in, // popEnter
                       R.anim.slide_out // popExit
                   )
                   replace(R.id.fragment_container, fragment)
                   addToBackStack(null)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Fragment fragment = new FragmentB();
               getSupportFragmentManager().beginTransaction()
                   .setCustomAnimations(
                       R.anim.slide_in,  // enter
                       R.anim.fade_out,  // exit
                       R.anim.fade_in,   // popEnter
                       R.anim.slide_out  // popExit
                   )
                   .replace(R.id.fragment_container, fragment)
                   .addToBackStack(null)
                   .commit();

   **Note:**\  ``FragmentTransaction.setCustomAnimations()`` applies the
   custom animations to all future fragment operations in the
   ``FragmentTransaction``. Previous operations in the transaction are
   unaffected.

   .. rubric:: Set transitions
      :name: set-transitions

   You can also use transitions to define enter and exit effects. These
   transitions can be defined in XML resource files. For example, you
   might want the current fragment to fade out and the new fragment to
   slide in from the right edge of the screen. These transitions can be
   defined as follows:

   .. code:: prettyprint

      <!-- res/transition/fade.xml -->
      <fade xmlns:android="http://schemas.android.com/apk/res/android"
          android:duration="@android:integer/config_shortAnimTime"/>

   .. code:: prettyprint

      <!-- res/transition/slide_right.xml -->
      <slide xmlns:android="http://schemas.android.com/apk/res/android"
          android:duration="@android:integer/config_shortAnimTime"
          android:slideEdge="right" />

   Once you've defined your transitions, apply them by calling
   `setEnterTransition() <#setEnterTransition>`__
   on the entering fragment and
   `setExitTransition() <#setExitTransition>`__
   on the exiting fragment, passing in your inflated transition
   resources by their resource ID, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class FragmentA : Fragment() {
                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       val inflater = TransitionInflater.from(requireContext())
                       exitTransition = inflater.inflateTransition(R.transition.fade)
                   }
               }

               class FragmentB : Fragment() {
                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       val inflater = TransitionInflater.from(requireContext())
                       enterTransition = inflater.inflateTransition(R.transition.slide_right)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class FragmentA extends Fragment {
                   @Override
                   public void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       TransitionInflater inflater = TransitionInflater.from(requireContext());
                       setExitTransition(inflater.inflateTransition(R.transition.fade));
                   }
               }

               public class FragmentB extends Fragment {
                   @Override
                   public void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       TransitionInflater inflater = TransitionInflater.from(requireContext());
                       setEnterTransition(inflater.inflateTransition(R.transition.slide_right));
                   }
               }

   Fragments support `AndroidX transitions <#>`__.
   While fragments also support `framework transitions <#>`__, we
   strongly recommend using AndroidX transitions, as they are supported
   in API levels 14 and higher and contain bug fixes that are not
   present in older versions of framework transitions.

   .. rubric:: Use shared element transitions
      :name: shared

   Part of the `Transition Framework <#>`__, shared
   element transitions determine how corresponding views move between
   two fragments during a fragment transition. For example, you might
   want an image displayed in an ``ImageView`` on fragment A to
   transition to fragment B once B becomes visible, as shown in figure
   3.

   .. figure::
      https://developer.android.google.cn/static/images/training/basics/fragments/shared-element-transition.gif
      :alt: A fragment transition with a shared element.
      :width: 200px

      **Figure 3.** A fragment transition with a shared element.

   At a high level, here's how to make a fragment transition with shared
   elements:

   #. Assign a unique transition name to each shared element view.
   #. Add shared element views and transition names to the
      `FragmentTransaction <#>`__.
   #. Set a shared element transition animation.

   First, you must assign a unique transition name to each shared
   element view to allow the views to be mapped from one fragment to the
   next. Set a transition name on shared elements in each fragment
   layout using
   `ViewCompat.setTransitionName() <#setTransitionName>`__,
   which provides compatibility for API levels 14 and above. As an
   example, the transition name for an ``ImageView`` in fragments A and
   B can be assigned as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class FragmentA : Fragment() {
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       ...
                       val itemImageView = view.findViewById<ImageView>(R.id.item_image)
                       ViewCompat.setTransitionName(itemImageView, ‚Äúitem_image‚Äù)
                   }
               }

               class FragmentB : Fragment() {
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       ...
                       val heroImageView = view.findViewById<ImageView>(R.id.hero_image)
                       ViewCompat.setTransitionName(heroImageView, ‚Äúhero_image‚Äù)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class FragmentA extends Fragment {
                   @Override
                   public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
                       ...
                       ImageView itemImageView = view.findViewById(R.id.item_image);
                       ViewCompat.setTransitionName(itemImageView, ‚Äúitem_image‚Äù);
                   }
               }

               public class FragmentB extends Fragment {
                   @Override
                   public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
                       ...
                       ImageView heroImageView = view.findViewById(R.id.hero_image);
                       ViewCompat.setTransitionName(heroImageView, ‚Äúhero_image‚Äù);
                   }
               }

   **Note:**\  For apps that support only API levels 21 and higher, you
   can alternatively use the
   `android:transitionName <#attr_android:transitionName>`__
   attribute within your XML layout to assign transition names to
   specific views.
   To include your shared elements in the fragment transition, your
   ``FragmentTransaction`` must know how each shared element's views map
   from one fragment to the next. Add each of your shared elements to
   your ``FragmentTransaction`` by calling
   `FragmentTransaction.addSharedElement() <#addSharedElement>`__,
   passing in the view and the transition name of the corresponding view
   in the next fragment, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val fragment = FragmentB()
               supportFragmentManager.commit {
                   setCustomAnimations(...)
                   addSharedElement(itemImageView, ‚Äúhero_image‚Äù)
                   replace(R.id.fragment_container, fragment)
                   addToBackStack(null)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Fragment fragment = new FragmentB();
               getSupportFragmentManager().beginTransaction()
                   .setCustomAnimations(...)
                   .addSharedElement(itemImageView, ‚Äúhero_image‚Äù)
                   .replace(R.id.fragment_container, fragment)
                   .addToBackStack(null)
                   .commit();

   To specify how your shared elements transition from one fragment to
   the next, you must set an *enter* transition on the fragment being
   navigated to. Call
   `Fragment.setSharedElementEnterTransition() <#setSharedElementEnterTransition>`__
   in the fragment's ``onCreate()`` method, as shown in the following
   example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class FragmentB : Fragment() {
                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       sharedElementEnterTransition = TransitionInflater.from(requireContext())
                            .inflateTransition(R.transition.shared_image)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class FragmentB extends Fragment {
                   @Override
                   public void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       Transition transition = TransitionInflater.from(requireContext())
                           .inflateTransition(R.transition.shared_image);
                       setSharedElementEnterTransition(transition);
                   }
               }

   The ``shared_image`` transition is defined as follows:

   .. code:: prettyprint

      <!-- res/transition/shared_image.xml -->
      <transitionSet>
          <changeImageTransform />
      </transitionSet>

   All subclasses of ``Transition`` are supported as shared element
   transitions. If you want to create a custom ``Transition``, see
   `Create a custom transition animation <#>`__.
   ``changeImageTransform``, used in the previous example, is one of the
   available prebuilt translations that you can use. You can find
   additional ``Transition`` subclasses in the API reference for the
   `Transition <#>`__ class.

   By default, the shared element enter transition is also used as the
   *return* transition for shared elements. The return transition
   determines how shared elements transition back to the previous
   fragment when the fragment transaction is popped off the back stack.
   If you'd like to specify a different return transition, you can do so
   using
   `Fragment.setSharedElementReturnTransition() <#setSharedElementReturnTransition>`__
   in the fragment's ``onCreate()`` method.

   .. rubric:: Predictive back compatibility
      :name: compatibility

   You can use predictive back with many, but not all, cross-fragment
   animations. When implementing predictive back, keep the following
   considerations in mind:

   -  Import
      `Transitions 1.5.0 <#>`__
      or later and
      `Fragments 1.7.0 <#>`__ or
      later.
   -  The ``Animator`` class and subclasses and AndroidX Transition
      library are supported.
   -  The ``Animation`` class and framework ``Transition`` library are
      not supported.
   -  Predictive fragment animations only work on devices that run
      Android 14 or higher.
   -  ``setCustomAnimations``, ``setEnterTransition``,
      ``setExitTransition``, ``setReenterTransition``,
      ``setReturnTransition``, ``setSharedElementEnterTransition``, and
      ``setSharedElementReturnTransition`` are supported with predictive
      back.

   To learn more, see `Add support for predictive back animations <#fragments>`__.

   .. rubric:: Postponing transitions
      :name: postpone

   In some cases, you might need to postpone your fragment transition
   for a short period of time. For example, you might need to wait until
   all views in the entering fragment have been measured and laid out so
   that Android can accurately capture their start and end states for
   the transition.

   Additionally, your transition might need to be postponed until some
   necessary data has been loaded. For example, you might need to wait
   until images have been loaded for shared elements. Otherwise, the
   transition might be jarring if an image finishes loading during or
   after the transition.

   To postpone a transition, you must first ensure that the fragment
   transaction allows reordering of fragment state changes. To allow
   reordering fragment state changes, call
   `FragmentTransaction.setReorderingAllowed() <#setReorderingAllowed>`__,
   as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val fragment = FragmentB()
               supportFragmentManager.commit {
                   setReorderingAllowed(true)
                   setCustomAnimation(...)
                   addSharedElement(view, view.transitionName)
                   replace(R.id.fragment_container, fragment)
                   addToBackStack(null)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Fragment fragment = new FragmentB();
               getSupportFragmentManager().beginTransaction()
                   .setReorderingAllowed(true)
                   .setCustomAnimations(...)
                   .addSharedElement(view, view.getTransitionName())
                   .replace(R.id.fragment_container, fragment)
                   .addToBackStack(null)
                   .commit();

   To postpone the enter transition, call
   `Fragment.postponeEnterTransition() <#postponeEnterTransition>`__
   in the entering fragment's ``onViewCreated()`` method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class FragmentB : Fragment() {
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       ...
                       postponeEnterTransition()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class FragmentB extends Fragment {
                   @Override
                   public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
                       ...
                       postponeEnterTransition();
                   }
               }

   Once you've loaded the data and are ready to start the transition,
   call
   `Fragment.startPostponedEnterTransition() <#startPostponedEnterTransition>`__.
   The following example uses the
   `Glide <https://bumptech.github.io/glide/>`__ library to load an
   image into a shared ``ImageView``, postponing the corresponding
   transition until image loading has completed.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class FragmentB : Fragment() {
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       ...
                       Glide.with(this)
                           .load(url)
                           .listener(object : RequestListener<Drawable> {
                               override fun onLoadFailed(...): Boolean {
                                   startPostponedEnterTransition()
                                   return false
                               }

                               override fun onResourceReady(...): Boolean {
                                   startPostponedEnterTransition()
                                   return false
                               }
                           })
                           .into(headerImage)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class FragmentB extends Fragment {
                   @Override
                   public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
                       ...
                       Glide.with(this)
                           .load(url)
                           .listener(new RequestListener<Drawable>() {
                               @Override
                               public boolean onLoadFailed(...) {
                                   startPostponedEnterTransition();
                                   return false;
                               }

                               @Override
                               public boolean onResourceReady(...) {
                                   startPostponedEnterTransition();
                                   return false;
                               }
                           })
                           .into(headerImage)
                   }
               }

   When dealing with cases such as a user's slow internet connection,
   you might need the postponed transition to start after a certain
   amount of time rather than waiting for all of the data to load. For
   these situations, you can instead call
   `Fragment.postponeEnterTransition(long, TimeUnit) <#postponeEnterTransition>`__
   in the entering fragment's ``onViewCreated()`` method, passing in the
   duration and the unit of time. The postponed then automatically
   starts once the specified time has elapsed.

   .. rubric:: Use shared element transitions with a ``RecyclerView``
      :name: recyclerview

   Postponed enter transitions should not start until all views in the
   entering fragment have been measured and laid out. When using a
   `RecyclerView <#>`__, you must
   wait for any data to load and for the ``RecyclerView`` items to be
   ready to draw before starting the transition. Here's an example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class FragmentA : Fragment() {
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       postponeEnterTransition()

                       // Wait for the data to load
                       viewModel.data.observe(viewLifecycleOwner) {
                           // Set the data on the RecyclerView adapter
                           adapter.setData(it)
                           // Start the transition once all views have been
                           // measured and laid out
                           (view.parent as? ViewGroup)?.doOnPreDraw {
                               startPostponedEnterTransition()
                           }
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class FragmentA extends Fragment {
                   @Override
                   public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
                       postponeEnterTransition();

                       final ViewGroup parentView = (ViewGroup) view.getParent();
                       // Wait for the data to load
                       viewModel.getData()
                           .observe(getViewLifecycleOwner(), new Observer<List<String>>() {
                               @Override
                               public void onChanged(List<String> list) {
                                   // Set the data on the RecyclerView adapter
                                   adapter.setData(it);
                                   // Start the transition once all views have been
                                   // measured and laid out
                                   parentView.getViewTreeObserver()
                                       .addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
                                           @Override
                                           public boolean onPreDraw(){
                                               parentView.getViewTreeObserver()
                                                       .removeOnPreDrawListener(this);
                                               startPostponedEnterTransition();
                                               return true;
                                           }
                                   });
                               }
                       });
                   }
               }

   Notice that a
   `ViewTreeObserver.OnPreDrawListener <#>`__
   is set on the parent of the fragment view. This is to ensure that all
   of the fragment's views have been measured and laid out and are
   therefore ready to be drawn before beginning the postponed enter
   transition.

   **Note:**\  When using a shared element transition from a fragment
   using a ``RecyclerView`` to another fragment, you **must** still
   postpone the fragment using a ``RecyclerView`` to ensure that the
   returning shared element transition functions correctly when popping
   back to the ``RecyclerView``.
   Another point to consider when using shared element transitions with
   a ``RecyclerView`` is that you cannot set the transition name in the
   ``RecyclerView`` item's XML layout because an arbitrary number of
   items share that layout. A unique transition name must be assigned so
   that the transition animation uses the correct view.

   You can give each item's shared element a unique transition name by
   assigning them when the ``ViewHolder`` is bound. For example, if the
   data for each item includes a unique ID, it could be used as the
   transition name, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
                   val image = itemView.findViewById<ImageView>(R.id.item_image)

                   fun bind(id: String) {
                       ViewCompat.setTransitionName(image, id)
                       ...
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleViewHolder extends RecyclerView.ViewHolder {
                   private final ImageView image;

                   ExampleViewHolder(View itemView) {
                       super(itemView);
                       image = itemView.findViewById(R.id.item_image);
                   }

                   public void bind(String id) {
                       ViewCompat.setTransitionName(image, id);
                       ...
                   }
               }

   .. rubric:: Additional resources
      :name: resources

   To learn more about fragment transitions, see the following
   additional resources.

   .. rubric:: Samples
      :name: samples

   -  `Android Fragment Transitions: RecyclerView to ViewPager Sample <https://github.com/android/animation-samples/tree/main/GridToPager>`__

   .. rubric:: Blog posts
      :name: blogs

   -  `Continuous Shared Element Transitions: RecyclerView to ViewPager <https://android-developers.googleblog.com/2018/02/continuous-shared-element-transitions.html>`__
   -  `Fragment Transitions <https://medium.com/androiddevelopers/fragment-transitions-ea2726c3f36f>`__


Last updated 2024-02-16 UTC.


/Fragment lifecycle
===================

.. container:: devsite-article-body clearfix

   Each `Fragment <#>`__
   instance has its own lifecycle. When a user navigates and interacts
   with your app, your fragments transition through various states in
   their lifecycle as they are added, removed, and enter or exit the
   screen.

   To manage lifecycle, ``Fragment`` implements
   `LifecycleOwner <#>`__,
   exposing a
   `Lifecycle <#>`__ object
   that you can access through the
   `getLifecycle() <#getLifecycle>`__
   method.

   Each possible ``Lifecycle`` state is represented in the
   `Lifecycle.State <#>`__
   enum.

   -  `INITIALIZED <#INITIALIZED>`__
   -  `CREATED <#CREATED>`__
   -  `STARTED <#STARTED>`__
   -  `RESUMED <#RESUMED>`__
   -  `DESTROYED <#DESTROYED>`__

   By building ``Fragment`` on top of ``Lifecycle``, you can use the
   techniques and classes available for `Handling Lifecycles with Lifecycle-Aware Components <#>`__. For example,
   you might display the device's location on the screen using a
   lifecycle-aware component. This component could automatically start
   listening when the fragment becomes active and stop when the fragment
   moves to an inactive state.

   As an alternative to using a
   `LifecycleObserver <#>`__,
   the ``Fragment`` class includes callback methods that correspond to
   each of the changes in a fragment's lifecycle. These include
   `onCreate() <#onCreate>`__,
   `onStart() <#onStart>`__,
   `onResume() <#onResume>`__,
   `onPause() <#onPause>`__,
   `onStop() <#onStop>`__,
   and
   `onDestroy() <#onDestroy>`__.

   A fragment's view has a separate ``Lifecycle`` that is managed
   independently from that of the fragment's ``Lifecycle``. Fragments
   maintain a
   `LifecycleOwner <#>`__
   for their view, which can be accessed using
   `getViewLifecycleOwner() <#getViewLifecycleOwner>`__
   or
   `getViewLifecycleOwnerLiveData() <#getViewLifecycleOwnerLiveData>`__.
   Having access to the view's ``Lifecycle`` is useful for situations
   where a Lifecycle-aware component should only perform work while a
   fragment's view exists, such as observing
   `LiveData <#>`__ that is
   only meant to be displayed on the screen.

   This topic discusses the ``Fragment`` lifecycle in detail, explaining
   some of the rules that determine a fragment's lifecycle state and
   showing the relationship between the ``Lifecycle`` states and the
   fragment lifecycle callbacks.

   .. rubric:: Fragments and the fragment manager
      :name: fragmentmanager

   When a fragment is instantiated, it begins in the ``INITIALIZED``
   state. For a fragment to transition through the rest of its
   lifecycle, it must be added to a
   `FragmentManager <#>`__.
   The ``FragmentManager`` is responsible for determining what state its
   fragment should be in and then moving them into that state.

   Beyond the fragment lifecycle, ``FragmentManager`` is also
   responsible for attaching fragments to their host activity and
   detaching them when the fragment is no longer in use. The
   ``Fragment`` class has two callback methods, ``onAttach()`` and
   ``onDetach()``, that you can override to perform work when either of
   these events occur.

   The ``onAttach()`` callback is invoked when the fragment has been
   added to a ``FragmentManager`` and is attached to its host activity.
   At this point, the fragment is active, and the ``FragmentManager`` is
   managing its lifecycle state. At this point, ``FragmentManager``
   methods such as
   `findFragmentById() <#findFragmentById>`__
   return this fragment.

   ``onAttach()`` is always called before any `Lifecycle state changes <#states>`__.

   The ``onDetach()`` callback is invoked when the fragment has been
   removed from a ``FragmentManager`` and is detached from its host
   activity. The fragment is no longer active and can no longer be
   retrieved using
   `findFragmentById() <#findFragmentById>`__.

   ``onDetach()`` is always called after any `Lifecycle state changes <#states>`__.

   Note that these callbacks are unrelated to the
   `FragmentTransaction <#>`__
   methods
   `attach() <#attach>`__
   and
   `detach() <#detach>`__.
   For more information on these methods, see `Fragment transactions <#attach-detach>`__.

   **Caution:**\  Avoid reusing ``Fragment`` instances after they are
   removed from the ``FragmentManager``. While the fragment handles its
   own internal state cleanup, you might inadvertently carry over your
   own state into the reused instance.

   .. rubric:: Fragment lifecycle states and callbacks
      :name: states

   When determining a fragment's lifecycle state, ``FragmentManager``
   considers the following:

   -  A fragment's maximum state is determined by its
      ``FragmentManager``. A fragment cannot progress beyond the state
      of its ``FragmentManager``.
   -  As part of a ``FragmentTransaction``, you can set a maximum
      lifecycle state on a fragment using
      `setMaxLifecycle() <#setMaxLifecycle>`__
      .
   -  A fragment's lifecycle state can never be greater than its parent.
      For example, a parent fragment or activity must be started before
      its child fragments. Likewise, child fragments must be stopped
      before their parent fragment or activity.

   **Caution:**\  Avoid using the ``<fragment>`` tag to add a fragment
   using XML, as the ``<fragment>`` tag allows a fragment to move beyond
   the state of its ``FragmentManager``. Instead, always use
   `FragmentContainerView <#>`__
   for adding a fragment using XML.
   .. figure::
      https://developer.android.google.cn/static/images/guide/fragments/fragment-view-lifecycle.png
      :alt: fragment lifecycle states and their relation both the
      fragment's lifecycle callbacks and the fragment's view lifecycle

      **Figure 1.** Fragment ``Lifecycle`` states and their relation to
      both the fragment's lifecycle callbacks and the fragment's view
      ``Lifecycle``.

   Figure 1 shows each of the fragment's ``Lifecycle`` states and how
   they relate to both the fragment's lifecycle callbacks and the
   fragment's view ``Lifecycle``.

   As a fragment progresses through its lifecycle, it moves upward and
   downward through its states. For example, a fragment that is added to
   the top of the back stack moves upward from ``CREATED`` to
   ``STARTED`` to ``RESUMED``. Conversely, when a fragment is popped off
   of the back stack, it moves downward through those states, going from
   ``RESUMED`` to ``STARTED`` to ``CREATED`` and finally ``DESTROYED``.

   .. rubric:: Upward state transitions
      :name: upward

   When moving upward through its lifecycle states, a fragment first
   calls the associated lifecycle callback for its new state. Once this
   callback is finished, the relevant
   `Lifecycle.Event <#>`__
   is emitted to observers by the fragment's ``Lifecycle``, followed by
   the fragment's view ``Lifecycle``, if it has been instantiated.

   .. rubric:: Fragment CREATED
      :name: fragment_created

   When your fragment reaches the ``CREATED`` state, it has been added
   to a ``FragmentManager`` and the
   `onAttach() <#onAttach>`__
   method has already been called.

   This would be the appropriate place to restore any saved state
   associated with the fragment itself through the fragment's
   `SavedStateRegistry <#>`__.
   Note that the fragment's view has *not* been created at this time,
   and any state associated with the fragment's view should be restored
   only after the view has been created.

   This transition invokes the
   `onCreate() <#onCreate>`__
   callback. The callback also receives a ``savedInstanceState``
   `Bundle <#>`__ argument containing any
   state previously saved by
   `onSaveInstanceState() <#onSaveInstanceState>`__.
   Note that ``savedInstanceState`` has a ``null`` value the first time
   the fragment is created, but it is always non-null for subsequent
   recreations, even if you do not override ``onSaveInstanceState()``.
   See `Saving state with fragments <#>`__
   for more details.

   .. rubric:: Fragment CREATED and View INITIALIZED
      :name: fragment_created_and_view_initialized

   The fragment's view ``Lifecycle`` is created only when your
   ``Fragment`` provides a valid
   `View <#>`__ instance. In most cases,
   you can use the `fragment constructors <#Fragment>`__
   that take a ``@LayoutId``, which automatically inflates the view at
   the appropriate time. You can also override
   `onCreateView() <#onCreateView>`__
   to programmatically inflate or create your fragment's view.

   If and only if your fragment's view is instantiated with a non-null
   ``View``, that ``View`` is set on the fragment and can be retrieved
   using
   `getView() <#getView>`__.
   The
   `getViewLifecycleOwnerLiveData() <#getViewLifecycleOwnerLiveData>`__
   is then updated with the newly ``INITIALIZED``
   `LifecycleOwner <#>`__
   corresponding with the fragment's view. The
   `onViewCreated() <#onViewCreated>`__
   lifecycle callback is also called at this time.

   This is the appropriate place to set up the initial state of your
   view, to start observing
   `LiveData <#>`__ instances
   whose callbacks update the fragment's view, and to set up adapters on
   any
   `RecyclerView <#>`__
   or
   `ViewPager2 <#>`__
   instances in your fragment's view.

   .. rubric:: Fragment and View CREATED
      :name: fragment_and_view_created

   After the fragment's view has been created, the previous view state,
   if any, is restored, and the view's ``Lifecycle`` is then moved into
   the ``CREATED`` state. The view lifecycle owner also emits the
   `ON_CREATE <#ON_CREATE>`__
   event to its observers. Here you should restore any additional state
   associated with the fragment's view.

   This transition also invokes the
   `onViewStateRestored() <#onViewStateRestored>`__
   callback.

   .. rubric:: Fragment and View STARTED
      :name: fragment_and_view_started

   It is strongly recommended to tie `Lifecycle-aware components <#>`__ to the
   ``STARTED`` state of a fragment, as this state guarantees that the
   fragment's view is available, if one was created, and that it is safe
   to perform a ``FragmentTransaction`` on the child ``FragmentManager``
   of the fragment. If the fragment's view is non-null, the fragment's
   view ``Lifecycle`` is moved to ``STARTED`` immediately after the
   fragment's ``Lifecycle`` is moved to ``STARTED``.

   When the fragment becomes ``STARTED``, the
   `onStart() <#onStart>`__
   callback is invoked.

   **Note:**\  Components such as
   `ViewPager2 <#>`__
   set the maximum ``Lifecycle`` of offscreen fragments to ``STARTED``.

   .. rubric:: Fragment and View RESUMED
      :name: fragment_and_view_resumed

   When the fragment is visible, all
   `Animator <#>`__ and
   `Transition <#>`__
   effects have finished, and the fragment is ready for user
   interaction. The fragment's ``Lifecycle`` moves to the ``RESUMED``
   state, and the
   `onResume() <#onResume>`__
   callback is invoked.

   The transition to ``RESUMED`` is the appropriate signal to indicate
   that the user is now able to interact with your fragment. Fragments
   that are not ``RESUMED`` should not manually set focus on their views
   or attempt to `handle input method visibility <#>`__.

   .. rubric:: Downward state transitions
      :name: downward

   When a fragment moves downward to a lower lifecycle state, the
   relevant
   `Lifecycle.Event <#>`__
   is emitted to observers by the fragment's view ``Lifecycle``, if
   instantiated, followed by the fragment's ``Lifecycle``. After a
   fragment's lifecycle event is emitted, the fragment calls the
   associated lifecycle callback.

   .. rubric:: Fragment and View STARTED
      :name: fragment_and_view_started_2

   As the user begins to leave the fragment, and while the fragment is
   still visible, the ``Lifecycle``\ s for the fragment and for its view
   are moved back to the ``STARTED`` state and emit the
   `ON_PAUSE <#ON_PAUSE>`__
   event to their observers. The fragment then invokes its
   `onPause() <#onPause>`__
   callback.

   .. rubric:: Fragment and View CREATED
      :name: fragment_and_view_created_2

   Once the fragment is no longer visible, the ``Lifecycle``\ s for the
   fragment and for its view are moved into the ``CREATED`` state and
   emit the
   `ON_STOP <#ON_STOP>`__
   event to their observers. This state transition is triggered not only
   by the parent activity or fragment being stopped, but also by the
   saving of state by the parent activity or fragment. This behavior
   guarantees that the ``ON_STOP`` event is invoked before the
   fragment's state is saved. This makes the ``ON_STOP`` event the last
   point where it is safe to perform a ``FragmentTransaction`` on the
   child ``FragmentManager``.

   As shown in figure 2, the ordering of the
   `onStop() <#onStop>`__
   callback and the saving of the state with ``onSaveInstanceState()``
   differs based on API level. For all API levels prior to API 28,
   ``onSaveInstanceState()`` is invoked before
   `onStop() <#onStop>`__.
   For API levels 28 and higher, the calling order is reversed.

   .. figure:: https://developer.android.google.cn/static/images/guide/fragments/stop-save-order.png
      :alt: calling order differences for onStop() and
      onSaveInstanceState()
      :width: 600px

      **Figure 2.** Calling order differences for ``onStop()`` and
      ``onSaveInstanceState()``.

   .. rubric:: Fragment CREATED and View DESTROYED
      :name: fragment_created_and_view_destroyed

   After all of the exit `animations and transitions <#>`__ have completed,
   and the fragment's view has been detached from the window, the
   fragment's view ``Lifecycle`` is moved into the ``DESTROYED`` state
   and emits the
   `ON_DESTROY <#ON_DESTROY>`__
   event to its observers. The fragment then invokes its
   `onDestroyView() <#onDestroyView>`__
   callback. At this point, the fragment's view has reached the end of
   its lifecycle and
   `getViewLifecycleOwnerLiveData() <#getViewLifecycleOwnerLiveData>`__
   returns a ``null`` value.

   At this point, all references to the fragment's view should be
   removed, allowing the fragment's view to be garbage collected.

   .. rubric:: Fragment DESTROYED
      :name: fragment_destroyed

   If the fragment is removed, or if the ``FragmentManager`` is
   destroyed, the fragment's ``Lifecycle`` is moved into the
   ``DESTROYED`` state and sends the
   `ON_DESTROY <#ON_DESTROY>`__
   event to its observers. The fragment then invokes its
   `onDestroy() <#onDestroy>`__
   callback. At this point, the fragment has reached the end of its
   lifecycle.

   .. rubric:: Additional resources
      :name: more

   For more information related to the fragment lifecycle, see the
   following additional resources.

   .. rubric:: Guides
      :name: guides

   -  `Handling Lifecycles with Lifecycle-Aware Components <#>`__

   .. rubric:: Blogs
      :name: blogs

   -  `Fragments: Rebuilding the Internals <https://medium.com/androiddevelopers/fragments-rebuilding-the-internals-61913f8bf48e>`__


Last updated 2024-01-03 UTC.


/Saving state with fragments
============================

.. container:: devsite-article-body clearfix

   Various Android system operations can affect the state of your
   fragment. To ensure the user's state is saved, the Android framework
   automatically saves and restores the fragments and the back stack.
   Therefore, you need to ensure that any data in your fragment is saved
   and restored as well.

   The following table outlines the operations that cause your fragment
   to lose state, along with whether the various types of state persist
   through those changes. The state types mentioned in the table are as
   follows:

   -  Variables: local variables in the fragment.
   -  View State: any data that is **owned by one or more views** in the
      fragment.
   -  SavedState: data inherent to this fragment instance that should be
      saved in ``onSaveInstanceState()``.
   -  NonConfig: data pulled from an external source, such as a server
      or local repository, or user-created data that is sent to a server
      once committed.

   Oftentimes *Variables* are treated the same as *SavedState*, but the
   following table distinguishes between the two to demonstrate the
   effect of the various operations on each.

   =============================== ========= ========== ========== =========
   Operation                       Variables View State SavedState NonConfig
   =============================== ========= ========== ========== =========
   Added to back stack             ‚úì         ‚úì          x          ‚úì
   Config Change                   x         ‚úì          ‚úì          ‚úì
   Process Death/Recreation        x         ‚úì          ‚úì          ‚úì\*
   Removed not added to back stack x         x          x          x
   Host finished                   x         x          x          x
   =============================== ========= ========== ========== =========


   *\* NonConfig state can be retained across process death using
   the*\ `Saved State module for ViewModel <#>`__\ *.*

   **Table 1:** Various fragment destructive operations and the effects
   they have on different state types.

   Let's look at a specific example. Consider a screen that generates a
   random string, displays it in a ``TextView``, and provides an option
   to edit the string before sending it to a friend:

   .. figure:: https://developer.android.google.cn/static/images/guide/fragments/text-generator-app.png
      :alt: random text generator app that demonstrates various types of
      state
      :width: 500px

      **Figure 1.** Random text generator app that demonstrates various
      types of state.

   For this example, assume that once the user presses the edit button,
   the app displays an ``EditText`` view where the user can edit the
   message. If the user clicks on **CANCEL**, the ``EditText`` view
   should be cleared and it's visibility set to
   `View.GONE <#GONE>`__. Such a screen
   might require managing four pieces of data to ensure a seamless
   experience:

   .. list-table::
      :header-rows: 1

      - 

         - Data
         - Type
         - State type
         - Description
      - 

         - ``seed``
         - ``Long``
         - NonConfig
         - Seed used for randomly generating a new good deed. Generated
            when the ``ViewModel`` is created.
      - 

         - ``randomGoodDeed``
         - ``String``
         - SavedState + Variable
         - Generated when the fragment is created for the very first
            time. ``randomGoodDeed`` is saved to ensure that users see
            the same random good deed even after process death and
            recreation.
      - 

         - ``isEditing``
         - ``Boolean``
         - SavedState + Variable
         - Boolean flag set to ``true`` when the user begins editing.
            ``isEditing`` is saved to ensure that the editing portion of
            the screen remains visible when the fragment is recreated.
      - 

         - Edited text
         - ``Editable``
         - View State (owned by ``EditText``)
         - The edited text in the ``EditText`` view. The ``EditText``
            view saves this text to ensure that the user's in-progress
            changes are not lost.

   **Table 2:** States that the random text generator app must manage.

   The following sections describe how to properly manage the state of
   your data through destructive operations.

   .. rubric:: View state
      :name: view

   Views are responsible for managing their own state. For example, when
   a view accepts user input, it is the view's responsibility to save
   and restore that input to handle configuration changes. All Android
   framework-provided views have their own implementation of
   ``onSaveInstanceState()`` and ``onRestoreInstanceState()``, so you
   don't have to manage view state within your fragment.

   **Note:**\  To ensure proper handling during configuration changes,
   you should implement ``onSaveInstanceState()`` and
   ``onRestoreInstanceState()`` for any custom views that you create.
   For example, in the previous scenario, the edited string is held in
   an `EditText <#>`__. An
   ``EditText`` knows the value of the text it's displaying, as well as
   other details, such as the beginning and end of any selected text.

   A view needs an ID to retain its state. This ID must be unique within
   the fragment and its view hierarchy. **Views without an ID cannot
   retain their state.**

   .. code:: prettyprint

      <EditText
          android:id="@+id/good_deed_edit_text"
          android:layout_width="match_parent"
          android:layout_height="wrap_content" />

   As mentioned in table 1, views save and restore their ``ViewState``
   through all operations that don't remove the fragment or destroy the
   host.

   .. rubric:: ``SavedState``
      :name: savedstate

   Your fragment is responsible for managing small amounts of dynamic
   state that are integral to how the fragment functions. You can retain
   easily-serialized data using
   `Fragment.onSaveInstanceState(Bundle) <#onsaveinstancestate>`__.
   Similar to
   `Activity.onSaveInstanceState(Bundle) <#onSaveInstanceState>`__,
   the data you place in the bundle is retained through configuration
   changes and process death and recreation and is available in your
   fragment's
   `onCreate(Bundle) <#onCreate>`__,
   `onCreateView(LayoutInflater, ViewGroup, Bundle) <#onCreateView>`__,
   and
   `onViewCreated(View, Bundle) <#onViewCreated>`__
   methods.

   **Caution:**\  ``onSaveInstanceState(Bundle)`` is called only when
   the fragment's host activity calls its own
   ``onSaveInstanceState(Bundle)``.
   **Tip:**\  When using a ``ViewModel``, you can save state directly
   within the ``ViewModel`` using a ``SavedStateHandle``. For more
   information, see `Saved State module for ViewModel <#>`__.
   Continuing with the previous example, ``randomGoodDeed`` is the deed
   that's displayed to the user, and ``isEditing`` is a flag to
   determine whether the fragment shows or hides the ``EditText``. This
   saved state should be persisted using
   ``onSaveInstanceState(Bundle)``, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onSaveInstanceState(outState: Bundle) {
                   super.onSaveInstanceState(outState)
                   outState.putBoolean(IS_EDITING_KEY, isEditing)
                   outState.putString(RANDOM_GOOD_DEED_KEY, randomGoodDeed)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onSaveInstanceState(@NonNull Bundle outState) {
                   super.onSaveInstanceState(outState);
                   outState.putBoolean(IS_EDITING_KEY, isEditing);
                   outState.putString(RANDOM_GOOD_DEED_KEY, randomGoodDeed);
               }

   To restore the state in ``onCreate(Bundle)`` retrieve the stored
   value from the bundle:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)
                   isEditing = savedInstanceState?.getBoolean(IS_EDITING_KEY, false)
                   randomGoodDeed = savedInstanceState?.getString(RANDOM_GOOD_DEED_KEY)
                           ?: viewModel.generateRandomGoodDeed()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onCreate(@Nullable Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);
                   if (savedInstanceState != null) {
                       isEditing = savedInstanceState.getBoolean(IS_EDITING_KEY, false);
                       randomGoodDeed = savedInstanceState.getString(RANDOM_GOOD_DEED_KEY);
                   } else {
                       randomGoodDeed = viewModel.generateRandomGoodDeed();
                   }
               }

   As mentioned in table 1, note that the variables are retained when
   the fragment is placed on the backstack. Treating them as saved state
   ensures they persist through all destructive operations.

   .. rubric:: NonConfig
      :name: nonconfig

   NonConfig data should be placed outside of your fragment, such as in
   a `ViewModel <#>`__. In the
   previous example above, ``seed`` (our NonConfig state) is generated
   in the ``ViewModel``. The logic to maintain its state is owned by the
   ``ViewModel``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               public class RandomGoodDeedViewModel : ViewModel() {
                   private val seed = ... // Generate the seed

                   private fun generateRandomGoodDeed(): String {
                       val goodDeed = ... // Generate a random good deed using the seed
                       return goodDeed
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class RandomGoodDeedViewModel extends ViewModel {
                   private Long seed = ... // Generate the seed

                   private String generateRandomGoodDeed() {
                       String goodDeed = ... // Generate a random good deed using the seed
                       return goodDeed;
                   }
               }

   The ``ViewModel`` class inherently allows data to survive
   configuration changes, such as screen rotations, and remains in
   memory when the fragment is placed on the back stack. After process
   death and recreation, the ``ViewModel`` is recreated, and a new
   ``seed`` is generated. Adding a
   `SavedState <#>`__
   module to your ``ViewModel`` allows the ``ViewModel`` to retain
   simple state through process death and recreation.

   .. rubric:: Additional resources
      :name: more

   For more information about managing fragment state, see the following
   additional resources.

   .. rubric:: Codelabs
      :name: codelabs

   -  `Lifecycle-Aware Components <https://developers.google.cn/codelabs/codelabs/android-lifecycles/#0>`__
      codelab

   .. rubric:: Guides
      :name: guides

   -  `Saved State Module for View Model <#>`__
   -  `Saving UI States <#>`__


Last updated 2024-01-03 UTC.


/Communicate with fragments
===========================

.. container:: devsite-article-body clearfix

   To reuse fragments, build them as completely self-contained
   components that define their own layout and behavior. Once you define
   these reusable fragments, you can associate them with an activity and
   connect them with the application logic to realize the overall
   composite UI.

   To properly react to user events and to share state information, you
   often need to have channels of communication between an activity and
   its fragments or between two or more fragments. To keep fragments
   self-contained, *don't* have fragments communicate directly with
   other fragments or with their host activity.

   The ``Fragment`` library provides two options for communication: a
   shared `ViewModel <#>`__
   and the Fragment Result API. The recommended option depends on the
   use case. To share persistent data with custom APIs, use a
   ``ViewModel``. For a one-time result with data that can be placed in
   a `Bundle <#>`__, use the Fragment
   Result API.

   The following sections show you how to use ``ViewModel`` and the
   Fragment Result API to communicate between your fragments and
   activities.

   .. rubric:: Share data using a ViewModel
      :name: viewmodel

   `ViewModel <#>`__ is an
   ideal choice when you need to share data between multiple fragments
   or between fragments and their host activity. ``ViewModel`` objects
   store and manage UI data. For more information about ``ViewModel``,
   see `ViewModel overview <#>`__.

   .. rubric:: Share data with the host activity
      :name: host-activity

   In some cases, you might need to share data between fragments and
   their host activity. For example, you might want to toggle a global
   UI component based on an interaction within a fragment.

   Consider the following ``ItemViewModel``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ItemViewModel : ViewModel() {
                   private val mutableSelectedItem = MutableLiveData<Item>()
                   val selectedItem: LiveData<Item> get() = mutableSelectedItem

                   fun selectItem(item: Item) {
                       mutableSelectedItem.value = item
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ItemViewModel extends ViewModel {
                   private final MutableLiveData<Item> selectedItem = new MutableLiveData<Item>();
                   public void selectItem(Item item) {
                       selectedItem.setValue(item);
                   }
                   public LiveData<Item> getSelectedItem() {
                       return selectedItem;
                   }
               }

   In this example, the stored data is wrapped in a
   `MutableLiveData <#>`__
   class. `LiveData <#>`__ is a
   lifecycle-aware observable data holder class. ``MutableLiveData``
   lets its value be changed. For more information about ``LiveData``,
   see `LiveData overview <#>`__.

   Both your fragment and its host activity can retrieve a shared
   instance of a ``ViewModel`` with activity scope by passing the
   activity into the
   `ViewModelProvider <#>`__
   constructor. The ``ViewModelProvider`` handles instantiating the
   ``ViewModel`` or retrieving it if it already exists. Both components
   can observe and modify this data.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MainActivity : AppCompatActivity() {
                   // Using the viewModels() Kotlin property delegate from the activity-ktx
                   // artifact to retrieve the ViewModel in the activity scope.
                   private val viewModel: ItemViewModel by viewModels()
                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       viewModel.selectedItem.observe(this, Observer { item ->
                           // Perform an action with the latest item data.
                       })
                   }
               }

               class ListFragment : Fragment() {
                   // Using the activityViewModels() Kotlin property delegate from the
                   // fragment-ktx artifact to retrieve the ViewModel in the activity scope.
                   private val viewModel: ItemViewModel by activityViewModels()

                   // Called when the item is clicked.
                   fun onItemClicked(item: Item) {
                       // Set a new item.
                       viewModel.selectItem(item)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends AppCompatActivity {
                   private ItemViewModel viewModel;

                   @Override
                   public void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       viewModel = new ViewModelProvider(this).get(ItemViewModel.class);
                       viewModel.getSelectedItem().observe(this, item -> {
                           // Perform an action with the latest item data.
                       });
                   }
               }

               public class ListFragment extends Fragment {
                   private ItemViewModel viewModel;

                   @Override
                   public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
                       super.onViewCreated(view, savedInstanceState);
                       viewModel = new ViewModelProvider(requireActivity()).get(ItemViewModel.class);
                       ...
                       items.setOnClickListener(item -> {
                           // Set a new item.
                           viewModel.select(item);
                       });
                   }
               }

   **Caution:**\  Use the appropriate scope with ``ViewModelProvider``.
   In the preceding example, ``MainActivity`` is used as the scope in
   both ``MainActivity`` and ``ListFragment``, so they are both provided
   the same ``ViewModel``. If ``ListFragment`` instead uses itself as
   the scope, it provides a different ``ViewModel`` than
   ``MainActivity``.

   .. rubric:: Share data between fragments
      :name: fragments

   Two or more fragments in the same activity often need to communicate
   with each other. For example, imagine one fragment that displays a
   list and another that lets the user apply various filters to the
   list. Implementing this case isn't trivial without the fragments
   communicating directly, but then they are no longer self-contained.
   Additionally, both fragments must handle the scenario where the other
   fragment is not yet created or visible.

   These fragments can share a ``ViewModel`` using their activity scope
   to handle this communication. By sharing the ``ViewModel`` in this
   way, the fragments don't need to know about each other, and the
   activity doesn't need to do anything to facilitate the communication.

   The following example shows how two fragments can use a shared
   ``ViewModel`` to communicate:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ListViewModel : ViewModel() {
                   val filters = MutableLiveData<Set<Filter>>()

                   private val originalList: LiveData<List<Item>>() = ...
                   val filteredList: LiveData<List<Item>> = ...

                   fun addFilter(filter: Filter) { ... }

                   fun removeFilter(filter: Filter) { ... }
               }

               class ListFragment : Fragment() {
                   // Using the activityViewModels() Kotlin property delegate from the
                   // fragment-ktx artifact to retrieve the ViewModel in the activity scope.
                   private val viewModel: ListViewModel by activityViewModels()
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       viewModel.filteredList.observe(viewLifecycleOwner, Observer { list ->
                           // Update the list UI.
                       }
                   }
               }

               class FilterFragment : Fragment() {
                   private val viewModel: ListViewModel by activityViewModels()
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       viewModel.filters.observe(viewLifecycleOwner, Observer { set ->
                           // Update the selected filters UI.
                       }
                   }

                   fun onFilterSelected(filter: Filter) = viewModel.addFilter(filter)

                   fun onFilterDeselected(filter: Filter) = viewModel.removeFilter(filter)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ListViewModel extends ViewModel {
                   private final MutableLiveData<Set<Filter>> filters = new MutableLiveData<>();

                   private final LiveData<List<Item>> originalList = ...;
                   private final LiveData<List<Item>> filteredList = ...;

                   public LiveData<List<Item>> getFilteredList() {
                       return filteredList;
                   }

                   public LiveData<Set<Filter>> getFilters() {
                       return filters;
                   }

                   public void addFilter(Filter filter) { ... }

                   public void removeFilter(Filter filter) { ... }
               }

               public class ListFragment extends Fragment {
                   private ListViewModel viewModel;

                   @Override
                   public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
                       super.onViewCreated(view, savedInstanceState);
                       viewModel = new ViewModelProvider(requireActivity()).get(ListViewModel.class);
                       viewModel.getFilteredList().observe(getViewLifecycleOwner(), list -> {
                           // Update the list UI.
                       });
                   }
               }

               public class FilterFragment extends Fragment {
                   private ListViewModel viewModel;

                   @Override
                   public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
                       viewModel = new ViewModelProvider(requireActivity()).get(ListViewModel.class);
                       viewModel.getFilters().observe(getViewLifecycleOwner(), set -> {
                           // Update the selected filters UI.
                       });
                   }

                   public void onFilterSelected(Filter filter) {
                       viewModel.addFilter(filter);
                   }

                   public void onFilterDeselected(Filter filter) {
                       viewModel.removeFilter(filter);
                   }
               }

   Both fragments use their host activity as the scope for the
   ``ViewModelProvider``. Because the fragments use the same scope, they
   receive the same instance of the ``ViewModel``, which enables them to
   communicate back and forth.

   **Caution:**\  The ``ViewModel`` remains in memory until the
   `ViewModelStoreOwner <#>`__
   to which it's scoped goes away permanently. In a single activity
   architecture, if the ``ViewModel`` is scoped to the activity, it's
   essentially a singleton. After the ``ViewModel`` is first
   instantiated, subsequent calls to retrieve the ``ViewModel`` using
   the activity scope always returns the same existing ``ViewModel``,
   along with the existing data until the activity's lifecycle has
   permanently ended.

   .. rubric:: Share data between a parent and child fragment
      :name: share_data_between_a_parent_and_child_fragment

   When working with child fragments, your parent fragment and its child
   fragments might need to share data with each other. To share data
   between these fragments, use the parent fragment as the ``ViewModel``
   scope, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ListFragment: Fragment() {
                   // Using the viewModels() Kotlin property delegate from the fragment-ktx
                   // artifact to retrieve the ViewModel.
                   private val viewModel: ListViewModel by viewModels()
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       viewModel.filteredList.observe(viewLifecycleOwner, Observer { list ->
                           // Update the list UI.
                       }
                   }
               }

               class ChildFragment: Fragment() {
                   // Using the viewModels() Kotlin property delegate from the fragment-ktx
                   // artifact to retrieve the ViewModel using the parent fragment's scope
                   private val viewModel: ListViewModel by viewModels({requireParentFragment()})
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ListFragment extends Fragment {
                   private ListViewModel viewModel;

                   @Override
                   public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
                       viewModel = new ViewModelProvider(this).get(ListViewModel.class);
                       viewModel.getFilteredList().observe(getViewLifecycleOwner(), list -> {
                           // Update the list UI.
                       }
                   }
               }

               public class ChildFragment extends Fragment {
                   private ListViewModel viewModel;
                   @Override
                   public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
                       viewModel = new ViewModelProvider(requireParentFragment()).get(ListViewModel.class);
                       ...
                   }
               }

   .. rubric:: Scope a ViewModel to the Navigation Graph
      :name: scope_a_viewmodel_to_the_navigation_graph

   If you're using the `Navigation library <#>`__, you
   can also scope a ``ViewModel`` to the lifecycle of a destination's
   `NavBackStackEntry <#>`__.
   For example, the ``ViewModel`` can be scoped to the
   ``NavBackStackEntry`` for the ``ListFragment``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ListFragment: Fragment() {
                   // Using the navGraphViewModels() Kotlin property delegate from the fragment-ktx
                   // artifact to retrieve the ViewModel using the NavBackStackEntry scope.
                   // R.id.list_fragment == the destination id of the ListFragment destination
                   private val viewModel: ListViewModel by navGraphViewModels(R.id.list_fragment)

                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       viewModel.filteredList.observe(viewLifecycleOwner, Observer { item ->
                           // Update the list UI.
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ListFragment extends Fragment {
                   private ListViewModel viewModel;

                   @Override
                   public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
                   NavController navController = NavHostFragment.findNavController(this);
                       NavBackStackEntry backStackEntry = navController.getBackStackEntry(R.id.list_fragment)

                       viewModel = new ViewModelProvider(backStackEntry).get(ListViewModel.class);
                       viewModel.getFilteredList().observe(getViewLifecycleOwner(), list -> {
                           // Update the list UI.
                       }
                   }
               }

   For more information about scoping a ``ViewModel`` to a
   ``NavBackStackEntry``, see `Interact programmatically with the Navigation component <#>`__.

   .. rubric:: Get results using the Fragment Result API
      :name: fragment-result

   In some cases, you might want to pass a one-time value between two
   fragments or between a fragment and its host activity. For example,
   you might have a fragment that reads QR codes, passing the data back
   to a previous fragment.

   In Fragment version 1.3.0 and higher, each
   `FragmentManager <#>`__
   implements
   `FragmentResultOwner <#>`__.
   This means that a ``FragmentManager`` can act as a central store for
   fragment results. This change lets components communicate with each
   other by setting fragment results and listening for those results,
   without requiring those components to have direct references to each
   other.

   .. rubric:: Pass results between fragments
      :name: pass-between-fragments

   To pass data back to fragment A from fragment B, first set a result
   listener on fragment A, the fragment that receives the result. Call
   `setFragmentResultListener() <#setfragmentresultlistener>`__
   on fragment A's ``FragmentManager``, as shown in the following
   example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)
                   // Use the Kotlin extension in the fragment-ktx artifact.
                   setFragmentResultListener("requestKey") { requestKey, bundle ->
                       // We use a String here, but any type that can be put in a Bundle is supported.
                       val result = bundle.getString("bundleKey")
                       // Do something with the result.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onCreate(@Nullable Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);
                   getParentFragmentManager().setFragmentResultListener("requestKey", this, new FragmentResultListener() {
                       @Override
                       public void onFragmentResult(@NonNull String requestKey, @NonNull Bundle bundle) {
                           // We use a String here, but any type that can be put in a Bundle is supported.
                           String result = bundle.getString("bundleKey");
                           // Do something with the result.
                       }
                   });
               }

   .. figure:: https://developer.android.google.cn/static/images/guide/fragments/fragment-a-to-b.png
      :alt: fragment b sends data to fragment a using a FragmentManager
      :width: 600px

      **Figure 1.** Fragment B sends data to fragment A using a
      ``FragmentManager``.

   In fragment B, the fragment producing the result, set the result on
   the same ``FragmentManager`` by using the same ``requestKey``. You
   can do so by using the
   `setFragmentResult() <#setfragmentresult>`__
   API:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               button.setOnClickListener {
                   val result = "result"
                   // Use the Kotlin extension in the fragment-ktx artifact.
                   setFragmentResult("requestKey", bundleOf("bundleKey" to result))
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               button.setOnClickListener(new View.OnClickListener() {
                   @Override
                   public void onClick(View v) {
                       Bundle result = new Bundle();
                       result.putString("bundleKey", "result");
                       getParentFragmentManager().setFragmentResult("requestKey", result);
                   }
               });

   Fragment A then receives the result and executes the listener
   callback once the fragment is
   `STARTED <#STARTED>`__.

   You can have only a single listener and result for a given key. If
   you call ``setFragmentResult()`` more than once for the same key, and
   if the listener is not ``STARTED``, the system replaces any pending
   results with your updated result.

   If you set a result without a corresponding listener to receive it,
   the result is stored in the ``FragmentManager`` until you set a
   listener with the same key. Once a listener receives a result and
   fires the ``onFragmentResult()`` callback, the result is cleared.
   This behavior has two major implications:

   -  Fragments on the back stack do not receive results until they have
      been popped and are ``STARTED``.
   -  If a fragment listening for a result is ``STARTED`` when the
      result is set, the listener's callback then fires immediately.

   **Note:**\  Because the fragment results are stored at the
   ``FragmentManager`` level, your fragment must be attached to call
   ``setFragmentResultListener()`` or ``setFragmentResult()`` with the
   parent ``FragmentManager``.

   .. rubric:: Test fragment results
      :name: test

   Use
   `FragmentScenario <#>`__
   to test calls to ``setFragmentResult()`` and
   ``setFragmentResultListener()``. Create a scenario for the fragment
   under test by using
   `launchFragmentInContainer <#launchFragmentInContainer>`__
   or
   `launchFragment <#top-level-functions>`__,
   and then manually call the method that isn't being tested.

   To test ``setFragmentResultListener()``, create a scenario with the
   fragment that makes the call to ``setFragmentResultListener()``.
   Next, call ``setFragmentResult()`` directly, and verify the result:

   .. code:: prettyprint

      @Test
      fun testFragmentResultListener() {
          val scenario = launchFragmentInContainer<ResultListenerFragment>()
          scenario.onFragment { fragment ->
              val expectedResult = "result"
              fragment.parentFragmentManager.setFragmentResult("requestKey", bundleOf("bundleKey" to expectedResult))
              assertThat(fragment.result).isEqualTo(expectedResult)
          }
      }

      class ResultListenerFragment : Fragment() {
          var result : String? = null
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              // Use the Kotlin extension in the fragment-ktx artifact.
              setFragmentResultListener("requestKey") { requestKey, bundle ->
                  result = bundle.getString("bundleKey")
              }
          }
      }

   To test ``setFragmentResult()``, create a scenario with the fragment
   that makes the call to ``setFragmentResult()``. Next, call
   ``setFragmentResultListener()`` directly, and verify the result:

   .. code:: prettyprint

      @Test
      fun testFragmentResult() {
          val scenario = launchFragmentInContainer<ResultFragment>()
          lateinit var actualResult: String?
          scenario.onFragment { fragment ->
              fragment.parentFragmentManager
                      .setFragmentResultListener("requestKey") { requestKey, bundle ->
                  actualResult = bundle.getString("bundleKey")
              }
          }
          onView(withId(R.id.result_button)).perform(click())
          assertThat(actualResult).isEqualTo("result")
      }

      class ResultFragment : Fragment(R.layout.fragment_result) {
          override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
              view.findViewById(R.id.result_button).setOnClickListener {
                  val result = "result"
                  // Use the Kotlin extension in the fragment-ktx artifact.
                  setFragmentResult("requestKey", bundleOf("bundleKey" to result))
              }
          }
      }

   .. rubric:: Pass results between parent and child fragments
      :name: pass-parent-child

   To pass a result from a child fragment to a parent, use
   ``getChildFragmentManager()`` from the parent fragment instead of
   ``getParentFragmentManager()`` when calling
   ``setFragmentResultListener()``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)
                   // Set the listener on the child fragmentManager.
                   childFragmentManager.setFragmentResultListener("requestKey") { key, bundle ->
                       val result = bundle.getString("bundleKey")
                       // Do something with the result.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onCreate(@Nullable Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);
                   // Set the listener on the child fragmentManager.
                   getChildFragmentManager()
                       .setFragmentResultListener("requestKey", this, new FragmentResultListener() {
                           @Override
                           public void onFragmentResult(@NonNull String requestKey, @NonNull Bundle bundle) {
                               String result = bundle.getString("bundleKey");
                               // Do something with the result.
                           }
                       });
               }

   .. figure:: https://developer.android.google.cn/static/images/guide/fragments/pass-parent-child.png
      :alt: a child fragment can use FragmentManager to send a result to
      its parent
      :width: 600px

      **Figure 2** A child fragment can use ``FragmentManager`` to send
      a result to its parent.

   The child fragment sets the result on its ``FragmentManager``. The
   parent then receives the result once the fragment is ``STARTED``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               button.setOnClickListener {
                   val result = "result"
                   // Use the Kotlin extension in the fragment-ktx artifact.
                   setFragmentResult("requestKey", bundleOf("bundleKey" to result))
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               button.setOnClickListener(new View.OnClickListener() {
                   @Override
                   public void onClick(View v) {
                       Bundle result = new Bundle();
                       result.putString("bundleKey", "result");
                       // The child fragment needs to still set the result on its parent fragment manager.
                       getParentFragmentManager().setFragmentResult("requestKey", result);
                   }
               });

   .. rubric:: Receive results in the host activity
      :name: receive-host-activity

   To receive a fragment result in the host activity, set a result
   listener on the fragment manager using
   `getSupportFragmentManager() <#getSupportFragmentManager>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MainActivity : AppCompatActivity() {
                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       supportFragmentManager
                               .setFragmentResultListener("requestKey", this) { requestKey, bundle ->
                           // We use a String here, but any type that can be put in a Bundle is supported.
                           val result = bundle.getString("bundleKey")
                           // Do something with the result.
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class MainActivity extends AppCompatActivity {
                   @Override
                   public void onCreate(@Nullable Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       getSupportFragmentManager().setFragmentResultListener("requestKey", this, new FragmentResultListener() {
                           @Override
                           public void onFragmentResult(@NonNull String requestKey, @NonNull Bundle bundle) {
                               // We use a String here, but any type that can be put in a Bundle is supported.
                               String result = bundle.getString("bundleKey");
                               // Do something with the result.
                           }
                       });
                   }
               }


Last updated 2024-01-03 UTC.


/Working with the AppBar
========================

.. container:: devsite-article-body clearfix

   The `top app bar <https://material.io/design/components/app-bars-top.html>`__
   provides a consistent place along the top of your app window for
   displaying information and actions from the current screen.

   .. figure:: https://developer.android.google.cn/static/images/guide/fragments/top-app-bar.png
      :alt: an example top app bar

      **Figure 1.** An example top app bar.

   Ownership of the app bar varies depending on the needs of your app.
   When using fragments, the app bar can be implemented as an
   `ActionBar <#>`__ that
   is owned by the host activity or a toolbar within your fragment's
   layout.

   If all your screens use the same app bar that's always at the top and
   spans the width of the screen, use a theme-provided action bar hosted
   by the activity. Using theme app bars helps to maintain a consistent
   look and provides a place to host option menus and an Up button.

   Use a toolbar hosted by the fragment if you want more control over
   the size, placement, and animation of the app bar across multiple
   screens. For example, you might need a collapsing app bar or one that
   spans only half the width of the screen and is vertically centered.

   Different situations require different approaches for things like
   inflating menus and responding to user interaction. Understanding the
   different approaches and employing the best one for your app saves
   you time and helps ensure that your app functions properly.

   The examples in this topic reference an ``ExampleFragment`` that
   contains an editable profile. The fragment inflates the following
   `XML-defined menu <#xml>`__ in its app bar:

   .. code:: prettyprint

      <!-- sample_menu.xml -->
      <menu
          xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto">

          <item
              android:id="@+id/action_settings"
              android:icon="@drawable/ic_settings"
              android:title="@string/settings"
              app:showAsAction="ifRoom"/>
          <item
              android:id="@+id/action_done"
              android:icon="@drawable/ic_done"
              android:title="@string/done"
              app:showAsAction="ifRoom|withText"/>

      </menu>

   The menu contains two options: one for navigating to a profile screen
   and one to save any profile changes made.

   .. rubric:: Activity-owned app bar
      :name: activity

   The app bar is most commonly owned by the host activity. When the app
   bar is owned by an activity, fragments can interact with the app bar
   by overriding framework methods that are called during fragment
   creation.

   **Note:**\  This guidance applies only when the app bar is owned by
   the activity. If your app bar is a toolbar that's included in a
   fragment layout, see the `Fragment-owned app bar <#fragment>`__
   section.

   .. rubric:: Register with activity
      :name: activity-register

   You must inform the system that your app bar fragment is
   participating in the population of the options menu. To do this, call
   `setHasOptionsMenu(true) <#setHasOptionsMenu>`__
   in your fragment's ``onCreate(Bundle)`` method, as shown in the
   following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleFragment : Fragment() {
                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setHasOptionsMenu(true)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleFragment extends Fragment {
                   @Override
                   public void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       setHasOptionsMenu(true);
                   }
               }

   ``setHasOptionsMenu(true)`` tells the system that your fragment wants
   to receive menu-related callbacks. When a menu-related event occurs,
   like a click, the event-handling method is first called on the
   activity before being called on the fragment.

   However, don't rely on this order in your application logic. If the
   same activity hosts multiple fragments, each fragment can supply menu
   options, in which case the callback order depends on the order in
   which the fragments are added.

   .. rubric:: Inflate the menu
      :name: activity-inflate

   To merge your menu into the app bar's options menu, override
   `onCreateOptionsMenu() <#onCreateOptionsMenu>`__
   in your fragment. This method receives the current app bar menu and a
   `MenuInflater <#>`__ as
   parameters. Use the menu inflater to create an instance of your
   fragment's menu, and then merge it into the current menu, as shown in
   the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleFragment : Fragment() {
                   ...
                   override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
                       inflater.inflate(R.menu.sample_menu, menu)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleFragment extends Fragment {
                   ...
                   @Override
                   public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
                      inflater.inflate(R.menu.sample_menu, menu);
                   }
               }

   Figure 2 shows the updated menu.

   .. figure:: https://developer.android.google.cn/static/images/guide/fragments/app-bar-added.png
      :alt: the options menu now contains your menu fragment

      **Figure 2.** The options menu now contains your menu fragment.

   .. rubric:: Handle click events
      :name: activity-click

   Every activity and fragment that participates in the options menu can
   respond to touches. The fragment's
   `onOptionsItemSelected() <#onOptionsItemSelected>`__
   receives the selected menu item as a parameter and returns a boolean
   to indicate whether the touch is consumed. Once an activity or
   fragment returns ``true`` from ``onOptionsItemSelected()``, no other
   participating fragments receive the callback.

   In your implementation of ``onOptionsItemSelected()``, use a
   ``switch`` statement on the ``itemId`` of the menu item. If the
   selected item is yours, handle the touch appropriately and return
   ``true`` to indicate that the click event is handled. If the selected
   item isn't yours, call the ``super`` implementation. By default, the
   ``super`` implementation returns ``false`` to let menu processing
   continue.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleFragment : Fragment() {
                   ...
                   override fun onOptionsItemSelected(item: MenuItem): Boolean {
                       return when (item.itemId) {
                           R.id.action_settings -> {
                               // Navigate to settings screen.
                               true
                           }
                           R.id.action_done -> {
                               // Save profile changes.
                               true
                           }
                           else -> super.onOptionsItemSelected(item)
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleFragment extends Fragment {
                   ...
                   @Override
                   public boolean onOptionsItemSelected(@NonNull MenuItem item) {
                       switch (item.getItemId()) {
                           case R.id.action_settings:  {
                               // Navigate to settings screen.
                               return true;
                           }
                           case R.id.action_done: {
                               // Save profile changes.
                               return true;
                           }
                           default:
                               return super.onOptionsItemSelected(item);
                       }

                   }

               }

   **Note:**\  In your ``Fragment``, only handle menu items added
   through its ``onCreateOptionsMenu()`` call. When using an
   activity-owned app bar, handle click events in the activity for the
   Up button and for menu items that aren't added by a ``Fragment``.

   .. rubric:: Dynamically modify the menu
      :name: activity-dynamic

   Place the logic to hide or show a button or change the icon in
   `onPrepareOptionsMenu() <#onPrepareOptionsMenu>`__.
   This method is called right before the menu is shown.

   Continuing with the previous example, the **Save** button should be
   invisible until the user begins editing, and it should disappear
   after the user saves. Adding this logic to ``onPrepareOptionsMenu()``
   makes the menu present correctly:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleFragment : Fragment() {
                   ...
                   override fun onPrepareOptionsMenu(menu: Menu){
                       super.onPrepareOptionsMenu(menu)
                       val item = menu.findItem(R.id.action_done)
                       item.isVisible = isEditing
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleFragment extends Fragment {
                   ...
                   @Override
                   public void onPrepareOptionsMenu(@NonNull Menu menu) {
                       super.onPrepareOptionsMenu(menu);
                       MenuItem item = menu.findItem(R.id.action_done);
                       item.setVisible(isEditing);
                   }
               }

   When you need to update the menu, such as when a user presses the
   **Edit** button to edit the profile info, call
   `invalidateOptionsMenu() <#invalidateOptionsMenu>`__
   on the host activity to request that the system call
   ``onCreateOptionsMenu()``. After invalidation, you can make the
   updates in ``onCreateOptionsMenu()``. Once the menu inflates, the
   system calls ``onPrepareOptionsMenu()`` and updates the menu to
   reflect the fragment's current state.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleFragment : Fragment() {
                   ...
                   fun updateOptionsMenu() {
                       isEditing = !isEditing
                       requireActivity().invalidateOptionsMenu()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleFragment extends Fragment {
                   ...
                   public void updateOptionsMenu() {
                       isEditing = !isEditing;
                       requireActivity().invalidateOptionsMenu();
                   }
               }

   .. rubric:: Fragment-owned app bar
      :name: fragment

   If most screens in your app don't need an app bar, or if one screen
   needs a different app bar than the others, you can add a
   `Toolbar <#>`__ to
   your fragment layout. Though you can add a ``Toolbar`` anywhere
   within your fragment's view hierarchy, you generally keep it at the
   top of the screen. To use the ``Toolbar`` in your fragment, provide
   an ID and obtain a reference to it in your fragment, as with any
   other view. You can also consider animating the toolbar using
   `CoordinatorLayout <#>`__
   behaviors.

   .. code:: prettyprint

      <androidx.appcompat.widget.Toolbar
          android:id="@+id/myToolbar"
          ... />

   When using a fragment-owned app bar, Google recommends using the
   ``Toolbar`` APIs directly. Do *not* use
   `setSupportActionBar() <#setsupportactionbar>`__
   and the ``Fragment`` menu APIs, which are appropriate only for
   activity-owned app bars.

   .. rubric:: Inflate the menu
      :name: fragment-inflate

   The ``Toolbar`` convenience method ``inflateMenu(int)`` takes the ID
   of a menu resource as a parameter. To inflate an XML menu resource
   into your toolbar, pass the ``resId`` to this method, as shown in the
   following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleFragment : Fragment() {
                   ...
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       ...
                       viewBinding.myToolbar.inflateMenu(R.menu.sample_menu)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleFragment extends Fragment {
                   ...
                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       ...
                       viewBinding.myToolbar.inflateMenu(R.menu.sample_menu);
                   }

               }

   To inflate another XML menu resource, call the method again with the
   ``resId`` of the new menu. The new menu items are added to the menu,
   and the existing menu items are not modified or removed.

   If you want to replace the existing menu set, clear the menu before
   calling ``inflateMenu(int)`` with the new menu ID, as shown in the
   following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleFragment : Fragment() {
                   ...
                   fun clearToolbarMenu() {
                       viewBinding.myToolbar.menu.clear()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleFragment extends Fragment {
                   ...
                   public void clearToolbarMenu() {

                       viewBinding.myToolbar.getMenu().clear()

                   }

               }

   .. rubric:: Handle click events
      :name: fragment-click

   You can pass an
   `OnMenuItemClickListener <#>`__
   directly to the toolbar using the
   `setOnMenuItemClickListener() <#setOnMenuItemClickListener>`__
   method. This listener is invoked when the user selects a menu item
   from the action buttons presented at the end of the toolbar or the
   associated overflow. The selected
   `MenuItem <#>`__ is passed to the
   listener's
   `onMenuItemClick() <#onMenuItemClick>`__
   method and can be used to consume the action, as shown in the
   following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleFragment : Fragment() {
                   ...
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       ...
                       viewBinding.myToolbar.setOnMenuItemClickListener {
                           when (it.itemId) {
                               R.id.action_settings -> {
                                   // Navigate to settings screen.
                                   true
                               }
                               R.id.action_done -> {
                                   // Save profile changes.
                                   true
                               }
                               else -> false
                           }
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleFragment extends Fragment {
                   ...
                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       ...
                       viewBinding.myToolbar.setOnMenuItemClickListener(item -> {
                           switch (item.getItemId()) {
                               case R.id.action_settings:
                                   // Navigate to settings screen.
                                   return true;
                               case R.id.action_done:
                                   // Save profile changes.
                                   return true;
                               default:
                                   return false;
                           }
                       });
                   }
               }

   .. rubric:: Dynamically modify the menu
      :name: fragment-dynamic

   When your fragment owns the app bar, you can modify the ``Toolbar``
   at runtime exactly like any other view.

   Continuing with the previous example, the **Save** menu option should
   be invisible until the user begins editing, and it should disappear
   again when tapped:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleFragment : Fragment() {
                   ...
                   fun updateToolbar() {
                       isEditing = !isEditing

                       val saveItem = viewBinding.myToolbar.menu.findItem(R.id.action_done)
                       saveItem.isVisible = isEditing

                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleFragment extends Fragment {
                   ...
                   public void updateToolbar() {
                       isEditing = !isEditing;

                       MenuItem saveItem = viewBinding.myToolbar.getMenu().findItem(R.id.action_done);
                       saveItem.setVisible(isEditing);
                   }

               }

   .. rubric:: Add a navigation icon
      :name: nav-icon

   If present, the navigation button appears at the start of the
   toolbar. Setting a navigation icon on the toolbar makes it visible.
   You can also set a navigation-specific ``onClickListener()`` that is
   called whenever the user clicks on the navigation button, as shown in
   the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleFragment : Fragment() {
                   ...
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       ...
                       myToolbar.setNavigationIcon(R.drawable.ic_back)

                       myToolbar.setNavigationOnClickListener { view ->
                           // Navigate somewhere.
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleFragment extends Fragment {
                   ...
                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       ...
                       viewBinding.myToolbar.setNavigationIcon(R.drawable.ic_back);
                       viewBinding.myToolbar.setNavigationOnClickListener(new View.OnClickListener() {
                           @Override
                           public void onClick(View view) {
                               // Navigate somewhere.
                           }
                       });
                   }
               }

   **Note:**\  When handling the navigation icon using the ``Toolbar``
   API, the default activity behavior is not triggered. You can use
   `requireActivity().onSupportNavigateUp() <#onsupportnavigateup>`__
   to trigger the default Up behavior of moving to the `parent activity defined in your manifest <#declare-parent>`__.


Last updated 2024-01-03 UTC.


/Display dialogs with DialogFragment
====================================

.. container:: devsite-article-body clearfix

   A
   `DialogFragment <#>`__
   is a special fragment subclass that is designed for creating and
   hosting `dialogs <#>`__. Although you don't
   need to host your dialog within a fragment, doing so lets the
   `FragmentManager <#>`__ manage the
   state of the dialog and automatically restore the dialog when a
   configuration change occurs.

   **Note:**\  This guide assumes familiarity with creating dialogs. For
   more information, see the `guide to dialogs <#>`__.

   .. rubric:: Create a DialogFragment
      :name: create

   To create a ``DialogFragment``, create a class that extends
   `DialogFragment <#>`__
   and override
   `onCreateDialog() <#onCreateDialog>`__,
   as shown in the following example.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class PurchaseConfirmationDialogFragment : DialogFragment() {
                   override fun onCreateDialog(savedInstanceState: Bundle?): Dialog =
                           AlertDialog.Builder(requireContext())
                               .setMessage(getString(R.string.order_confirmation))
                               .setPositiveButton(getString(R.string.ok)) { _,_ -> }
                               .create()

                   companion object {
                       const val TAG = "PurchaseConfirmationDialog"
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class PurchaseConfirmationDialogFragment extends DialogFragment {
                  @NonNull
                  @Override
                  public Dialog onCreateDialog(@Nullable Bundle savedInstanceState) {
                      return new AlertDialog.Builder(requireContext())
                              .setMessage(getString(R.string.order_confirmation))
                              .setPositiveButton(getString(R.string.ok), (dialog, which) -> {} )
                              .create();
                  }

                  public static String TAG = "PurchaseConfirmationDialog";
               }

   Similar to how
   `onCreateView() <#onCreateView>`__
   creates a root ``View`` in an ordinary fragment, ``onCreateDialog()``
   creates a `Dialog <#>`__ to display
   as part of the ``DialogFragment``. The ``DialogFragment`` handles
   displaying the ``Dialog`` at appropriate states in the fragment's
   lifecycle.

   **Note:**\  ``DialogFragment`` owns the
   `Dialog.setOnCancelListener() <#setOnCancelListener>`__
   and
   `Dialog.setOnDismissListener() <#setOnDismissListener>`__
   callbacks. You must not set them yourself. To find out about these
   events, override
   `onCancel() <#onCancel>`__
   and
   `onDismiss() <#onDismiss>`__.
   As with ``onCreateView()``, you can return any subclass of ``Dialog``
   from ``onCreateDialog()`` and aren't limited to using
   `AlertDialog <#>`__.

   .. rubric:: Show the DialogFragment
      :name: showing

   You don't have to manually create a ``FragmentTransaction`` to
   display your ``DialogFragment``. Instead, use the ``show()`` method
   to display your dialog. You can pass a reference to a
   ``FragmentManager`` and a ``String`` to use as a
   ``FragmentTransaction`` tag.

   When creating a ``DialogFragment`` from within a ``Fragment``, use
   the fragment's child ``FragmentManager`` so that the state properly
   restores after configuration changes. A non-null tag lets you use
   ``findFragmentByTag()`` to retrieve the ``DialogFragment`` at a later
   time.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // From another Fragment or Activity where you wish to show this
               // PurchaseConfirmationDialogFragment.
               PurchaseConfirmationDialogFragment().show(
                    childFragmentManager, PurchaseConfirmationDialog.TAG)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // From another Fragment or Activity where you wish to show this
               // PurchaseConfirmationDialogFragment.
               new PurchaseConfirmationDialogFragment().show(
                      getChildFragmentManager(), PurchaseConfirmationDialog.TAG);

   For more control over the
   `FragmentTransaction <#>`__,
   you can use the
   `show() <#show>`__
   overload that accepts an existing ``FragmentTransaction``.

   **Note:**\  Because the ``DialogFragment`` automatically restores
   after configuration changes, consider only calling ``show()`` based
   on user actions or when ``findFragmentByTag()`` returns ``null``,
   indicating that the dialog is not already present.

   .. rubric:: DialogFragment lifecycle
      :name: lifecycle

   A ``DialogFragment`` follows the standard fragment lifecycle, with a
   few additional lifecycle callbacks. The most common ones are as
   follows:

   -  `onCreateDialog() <#onCreateDialog>`__:
      override this callback to provide a ``Dialog`` for the fragment to
      manage and display.
   -  `onDismiss() <#onDismiss>`__:
      override this callback if you need to perform any custom logic
      when your ``Dialog`` is dismissed, such as releasing resources or
      unsubscribing from observable resources.
   -  `onCancel() <#onCancel>`__:
      override this callback if you need to perform any custom logic
      when your ``Dialog`` is canceled.

   ``DialogFragment`` also contains methods to dismiss or set the
   cancelability of your ``DialogFragment``:

   -  `dismiss() <#dismiss>`__:
      dismiss the fragment and its dialog. If the fragment was added to
      the back stack, all back stack state up to and including this
      entry are popped. Otherwise, a new transaction is committed to
      remove the fragment.
   -  `setCancelable() <#setCancelable>`__:
      control whether the shown ``Dialog`` is cancelable. Use this
      method instead of directly calling
      `Dialog.setCancelable(boolean) <#setCancelable>`__.

   You don't override
   `onCreateView() <#oncreateview>`__
   or
   `onViewCreated() <#onViewCreated>`__
   when using a ``DialogFragment`` with a ``Dialog``. Dialogs aren't
   only views‚Äîthey have their own window. As such, it's not enough to
   override ``onCreateView()``. Moreover, ``onViewCreated()`` is never
   called on a custom ``DialogFragment`` unless you've overridden
   ``onCreateView()`` and provided a non-null view.

   **Note:**\  When subscribing to lifecycle-aware components such as
   ``LiveData``, never use
   `viewLifecycleOwner <#getviewlifecycleowner>`__
   as the
   `LifecycleOwner <#>`__ in
   a ``DialogFragment`` that uses ``Dialog`` objects. Instead, use the
   ``DialogFragment`` itself, or, if you're using `Jetpack Navigation <#>`__, use the
   `NavBackStackEntry <#>`__.

   .. rubric:: Use custom views
      :name: custom

   You can create a ``DialogFragment`` and display a dialog by
   overriding
   `onCreateView() <#onCreateView>`__.
   You can either give it a ``layoutId``, as with a typical fragment, or
   use the `DialogFragment``
   constructor </reference/androidx/fragment/app/DialogFragment#DialogFragment(int)>`__.

   The ``View`` returned by ``onCreateView()`` is automatically added to
   the dialog. In most cases, this means that you don't need to override
   `onCreateDialog() <#onCreateDialog>`__,
   as the default empty dialog is populated with your view.

   Certain subclasses of ``DialogFragment``, such as
   `BottomSheetDialogFragment <#>`__,
   embed your view in a dialog that is styled as a bottom sheet.


Last updated 2024-01-03 UTC.


/Debug your fragments
=====================

.. container:: devsite-article-body clearfix

   This guide covers tools that you can use to debug your
   `fragments <#>`__.

   .. rubric:: FragmentManager logging
      :name: fm-logging

   `FragmentManager <#>`__
   can emit various messages to `Logcat <#>`__.
   This is disabled by default, but sometimes these log messages can
   help you troubleshoot issues with your fragments. ``FragmentManager``
   emits the most meaningful output at the ``DEBUG`` and ``VERBOSE``
   `log levels <#read-logs>`__.

   You can enable logging using the following
   `adb shell <#shellcommands>`__ command:

   .. code:: none

      adb shell setprop log.tag.FragmentManager DEBUG

   Alternatively, you can enable verbose logging as follows:

   .. code:: none

      adb shell setprop log.tag.FragmentManager VERBOSE

   If you enable verbose logging, you can then apply a `log level filter <#key-value-search>`__ in the Logcat
   window. However, this filters all logs, not just the
   ``FragmentManager`` logs. It's usually best to enable
   ``FragmentManager`` logging only at the log level that you need.

   .. rubric:: DEBUG logging
      :name: debug-logging

   At the ``DEBUG`` level, ``FragmentManager`` generally emits log
   messages relating to lifecycle state changes. Each log entry contains
   the
   `toString() <#toString>`__
   dump from the
   `Fragment <#>`__. A log
   entry consists of the following information:

   -  The simple class name of the ``Fragment`` instance.
   -  The `identity hash code <#identityHashCode>`__
      of the ``Fragment`` instance.
   -  The fragment manager's unique ID of the ``Fragment`` instance.
      This is stable across configuration changes and process death and
      recreation.
   -  The ID of the container that the ``Fragment`` is added to, but
      only if set.
   -  The ``Fragment`` tag, but only if set.

   The following is a sample ``DEBUG`` log entry:

   .. code:: none

      D/FragmentManager: moveto ATTACHED: NavHostFragment{92d8f1d} (fd92599e-c349-4660-b2d6-0ece9ec72f7b id=0x7f080116)

   -  The ``Fragment`` class is ``NavHostFragment``.
   -  The identity hash code is ``92d8f1d``.
   -  The unique ID is ``fd92599e-c349-4660-b2d6-0ece9ec72f7b``.
   -  The container ID is ``0x7f080116``.
   -  The tag is omitted because none was set. When present, it follows
      the ID in the format ``tag=tag_value``.

   For brevity and readability, the UUIDs are shortened in the following
   examples.

   Here is a ``NavHostFragment`` being initialized and then the
   ``startDestination`` ``Fragment`` of type ``FirstFragment`` being
   created and transitioning through to the ``RESUMED`` state:

   .. code:: none

      D/FragmentManager: moveto ATTACHED: NavHostFragment{92d8f1d} (<UUID> id=0x7f080116)
      D/FragmentManager:   mName=null mIndex=-1 mCommitted=false
      D/FragmentManager:   Operations:
      D/FragmentManager:     Op #0: SET_PRIMARY_NAV NavHostFragment{92d8f1d} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto CREATED: NavHostFragment{92d8f1d} (<UUID> id=0x7f080116)
      D/FragmentManager:   mName=null mIndex=-1 mCommitted=false
      D/FragmentManager:   Operations:
      D/FragmentManager:     Op #0: REPLACE FirstFragment{ccd2189} (<UUID> id=0x7f080116)
      D/FragmentManager:     Op #1: SET_PRIMARY_NAV FirstFragment{ccd2189} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto ATTACHED: FirstFragment{ccd2189} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto CREATED: FirstFragment{ccd2189} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto CREATE_VIEW: NavHostFragment{92d8f1d} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto CREATE_VIEW: FirstFragment{ccd2189} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto ACTIVITY_CREATED: NavHostFragment{92d8f1d} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto RESTORE_VIEW_STATE: NavHostFragment{92d8f1d} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto ACTIVITY_CREATED: FirstFragment{ccd2189} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto RESTORE_VIEW_STATE: FirstFragment{ccd2189} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto STARTED: NavHostFragment{92d8f1d} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto STARTED: FirstFragment{ccd2189} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto RESUMED: NavHostFragment{92d8f1d} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto RESUMED: FirstFragment{ccd2189} (<UUID> id=0x7f080116)

   Following a user interaction, ``FirstFragment`` transitions out of
   the various lifecycle states. Then ``SecondFragment`` is instantiated
   and transitions through to the ``RESUMED`` state:

   .. code:: none

      D/FragmentManager:   mName=07c8a5e8-54a3-4e21-b2cc-c8efc37c4cf5 mIndex=-1 mCommitted=false
      D/FragmentManager:   Operations:
      D/FragmentManager:     Op #0: REPLACE SecondFragment{84132db} (<UUID> id=0x7f080116)
      D/FragmentManager:     Op #1: SET_PRIMARY_NAV SecondFragment{84132db} (<UUID> id=0x7f080116)
      D/FragmentManager: movefrom RESUMED: FirstFragment{ccd2189} (<UUID> id=0x7f080116)
      D/FragmentManager: movefrom STARTED: FirstFragment{ccd2189} (<UUID> id=0x7f080116)
      D/FragmentManager: movefrom ACTIVITY_CREATED: FirstFragment{ccd2189} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto ATTACHED: SecondFragment{84132db} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto CREATED: SecondFragment{84132db} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto CREATE_VIEW: SecondFragment{84132db} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto ACTIVITY_CREATED: SecondFragment{84132db} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto RESTORE_VIEW_STATE: SecondFragment{84132db} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto STARTED: SecondFragment{84132db} (<UUID> id=0x7f080116)
      D/FragmentManager: movefrom CREATE_VIEW: FirstFragment{ccd2189} (<UUID> id=0x7f080116)
      D/FragmentManager: moveto RESUMED: SecondFragment{84132db} (<UUID> id=0x7f080116)

   All the ``Fragment`` instances are suffixed by an identifier so that
   you can track different instances of the same ``Fragment`` class.

   .. rubric:: VERBOSE logging
      :name: verbose-logging

   At ``VERBOSE`` level, ``FragmentManager`` generally emits log
   messages about its internal state:

   .. code:: none

      V/FragmentManager: Run: BackStackEntry{f9d3ff3}
      V/FragmentManager: add: NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: Added fragment to active set NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 1 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      D/FragmentManager: moveto ATTACHED: NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: Commit: BackStackEntry{5cfd2ae}
      D/FragmentManager:   mName=null mIndex=-1 mCommitted=false
      D/FragmentManager:   Operations:
      D/FragmentManager:     Op #0: SET_PRIMARY_NAV NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 1 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      D/FragmentManager: moveto CREATED: NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: Commit: BackStackEntry{e93833f}
      D/FragmentManager:   mName=null mIndex=-1 mCommitted=false
      D/FragmentManager:   Operations:
      D/FragmentManager:     Op #0: REPLACE FirstFragment{886440c} (<UUID> id=0x7f080130)
      D/FragmentManager:     Op #1: SET_PRIMARY_NAV FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: Run: BackStackEntry{e93833f}
      V/FragmentManager: add: FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: Added fragment to active set FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 1 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      D/FragmentManager: moveto ATTACHED: FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 1 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      D/FragmentManager: moveto CREATED: FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 1 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 1 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 1 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 1 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 1 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 1 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 1 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 4 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      D/FragmentManager: moveto CREATE_VIEW: NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 2 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      D/FragmentManager: moveto CREATE_VIEW: FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 2 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 2 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 4 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      D/FragmentManager: moveto ACTIVITY_CREATED: NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      D/FragmentManager: moveto RESTORE_VIEW_STATE: NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 4 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      D/FragmentManager: moveto ACTIVITY_CREATED: FirstFragment{886440c} (<UUID> id=0x7f080130)
      D/FragmentManager: moveto RESTORE_VIEW_STATE: FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 4 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: SpecialEffectsController: Enqueuing add operation for fragment FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 4 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 4 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: SpecialEffectsController: For fragment FirstFragment{886440c} (<UUID> id=0x7f080130) mFinalState = VISIBLE -> VISIBLE.
      V/FragmentManager: SpecialEffectsController: Container androidx.fragment.app.FragmentContainerView{7578ffa V.E...... ......I. 0,0-0,0 #7f080130 app:id/nav_host_fragment_content_fragment} is not attached to window. Cancelling pending operation Operation {382a9ab} {mFinalState = VISIBLE} {mLifecycleImpact = ADDING} {mFragment = FirstFragment{886440c} (<UUID> id=0x7f080130)}
      V/FragmentManager: SpecialEffectsController: Operation {382a9ab} {mFinalState = VISIBLE} {mLifecycleImpact = ADDING} {mFragment = FirstFragment{886440c} (<UUID> id=0x7f080130)} has called complete.
      V/FragmentManager: SpecialEffectsController: Setting view androidx.constraintlayout.widget.ConstraintLayout{3968808 I.E...... ......I. 0,0-0,0} to VISIBLE
      V/FragmentManager: computeExpectedState() of 4 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 4 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: SpecialEffectsController: Enqueuing add operation for fragment NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 4 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 4 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: SpecialEffectsController: For fragment NavHostFragment{86274b0} (<UUID> id=0x7f080130) mFinalState = VISIBLE -> VISIBLE.
      V/FragmentManager: SpecialEffectsController: Container androidx.fragment.app.FragmentContainerView{2ba8ba1 V.E...... ......I. 0,0-0,0 #7f080130 app:id/nav_host_fragment_content_fragment} is not attached to window. Cancelling pending operation Operation {f7eb1c6} {mFinalState = VISIBLE} {mLifecycleImpact = ADDING} {mFragment = NavHostFragment{86274b0} (<UUID> id=0x7f080130)}
      V/FragmentManager: SpecialEffectsController: Operation {f7eb1c6} {mFinalState = VISIBLE} {mLifecycleImpact = ADDING} {mFragment = NavHostFragment{86274b0} (<UUID> id=0x7f080130)} has called complete.
      V/FragmentManager: SpecialEffectsController: Setting view androidx.fragment.app.FragmentContainerView{7578ffa I.E...... ......I. 0,0-0,0 #7f080130 app:id/nav_host_fragment_content_fragment} to VISIBLE
      V/FragmentManager: computeExpectedState() of 4 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: Run: BackStackEntry{5cfd2ae}
      V/FragmentManager: computeExpectedState() of 4 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 4 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 4 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 5 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      D/FragmentManager: moveto STARTED: NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 5 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      D/FragmentManager: moveto STARTED: FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 5 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 5 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 5 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 5 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 7 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 7 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      D/FragmentManager: moveto RESUMED: NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 7 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 7 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      D/FragmentManager: moveto RESUMED: FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 7 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 7 for FirstFragment{886440c} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 7 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)
      V/FragmentManager: computeExpectedState() of 7 for NavHostFragment{86274b0} (<UUID> id=0x7f080130)

   This example only covers the loading on ``FirstFragment``. Including
   the transition to ``SecondFragment`` increases the log entries
   considerably. Many of the ``VERBOSE`` level log messages are of
   little use to app developers. However, seeing when changes to the
   back stack occur can help in debugging some issues.

   .. rubric:: StrictMode for fragments
      :name: strictmode

   Version 1.4.0 and higher of the `Jetpack Fragment <#>`__ library includes
   StrictMode for fragments. It can catch some common issues that may
   cause your app to behave in unexpected ways. For more information
   about working with ``StrictMode``, see
   `StrictMode <#>`__.

   A custom
   `Policy <#>`__
   defines which violations are detected and specifies what penalty is
   applied when violations are detected.

   **Note:**\  when you enable `FragmentManager`` ``DEBUG``
   logging <#debug-logging>`__, all StrictMode violations are logged, no
   matter what policy you are using.
   To apply a custom StrictMode policy, assign it to the
   `FragmentManager <#>`__.
   Do this as early as possible. In this case, you do it in an ``init``
   block or in the Java constructor:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleActivity : AppCompatActivity() {

                   init {
                       supportFragmentManager.strictModePolicy =
                           FragmentStrictMode.Policy.Builder()
                               .penaltyDeath()
                               .detectFragmentReuse()
                               .allowViolation(FirstFragment::class.java,
                                               FragmentReuseViolation::class.java)
                               .build()
                   }

                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)

                       val binding = ActivityExampleBinding.inflate(layoutInflater)
                       setContentView(binding.root)
                       ...
                  }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class ExampleActivity extends AppCompatActivity() {

                   ExampleActivity() {
                       getSupportFragmentManager().setStrictModePolicy(
                               new FragmentStrictMode.Policy.Builder()
                                       .penaltyDeath()
                                       .detectFragmentReuse()
                                       .allowViolation(FirstFragment.class,
                                                       FragmentReuseViolation.class)
                                       .build()
                       );
                   }

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState)

                       ActivityExampleBinding binding =
                           ActivityExampleBinding.inflate(getLayoutInflater());
                       setContentView(binding.getRoot());
                       ...
                  }
               }

   For cases where you need to know the ``Context`` to determine whether
   to enable StrictMode, such as from the value of a boolean resource,
   you can defer assigning a StrictMode policy to the
   ``FragmentManager`` using an
   `OnContextAvailableListener <#>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleActivity : AppCompatActivity() {

                   init {
                       addOnContextAvailableListener { context ->
                           if(context.resources.getBoolean(R.bool.enable_strict_mode)) {
                               supportFragmentManager.strictModePolicy = FragmentStrictMode.Policy.Builder()
                                   .penaltyDeath()
                                   .detectFragmentReuse()
                                   .allowViolation(FirstFragment::class.java, FragmentReuseViolation::class.java)
                                   .build()
                           }
                       }
                   }

                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)

                       val binding = ActivityExampleBinding.inflate(layoutInflater)
                       setContentView(binding.root)
                       ...
                  }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class ExampleActivity extends AppCompatActivity() {

                   ExampleActivity() {
                       addOnContextAvailableListener((context) -> {
                           if(context.getResources().getBoolean(R.bool.enable_strict_mode)) {
                               getSupportFragmentManager().setStrictModePolicy(
                                       new FragmentStrictMode.Policy.Builder()
                                               .penaltyDeath()
                                               .detectFragmentReuse()
                                               .allowViolation(FirstFragment.class, FragmentReuseViolation.class)
                                               .build()
                               );
                           }
                       }
                   }

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState)

                       ActivityExampleBinding binding = ActivityExampleBinding.inflate(getLayoutInflater());
                       setContentView(binding.getRoot());
                       ...
                  }
               }

   The latest point at which you can configure StrictMode to catch all
   possible violations is in
   `onCreate() <#onCreate>`__,
   before the call to ``super.onCreate()``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleActivity : AppCompatActivity() {

                   override fun onCreate(savedInstanceState: Bundle?) {
                       supportFragmentManager.strictModePolicy = FragmentStrictMode.Policy.Builder()
                           .penaltyDeath()
                           .detectFragmentReuse()
                           .allowViolation(FirstFragment::class.java, FragmentReuseViolation::class.java)
                           .build()

                       super.onCreate(savedInstanceState)

                       val binding = ActivityExampleBinding.inflate(layoutInflater)
                       setContentView(binding.root)
                       ...
                  }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class ExampleActivity extends AppCompatActivity() {

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       getSupportFragmentManager().setStrictModePolicy(
                               new FragmentStrictMode.Policy.Builder()
                                       .penaltyDeath()
                                       .detectFragmentReuse()
                                       .allowViolation(FirstFragment.class, FragmentReuseViolation.class)
                                       .build()
                               );

                       super.onCreate(savedInstanceState)

                       ActivityExampleBinding binding = ActivityExampleBinding.inflate(getLayoutInflater());
                       setContentView(binding.getRoot());
                       ...
                  }
               }

   This policy used in these examples detects only fragment reuse
   violations, and the app terminates whenever one occurs.
   ``penaltyDeath()`` can be helpful in debug builds because it fails
   quickly enough that you can't ignore violations.

   It is also possible to selectively allow certain violations. The
   policy used in the preceding example, however, enforces this
   violation for all other fragment types. This is useful for cases
   where a third-party library component might contain StrictMode
   violations.

   In such cases, you can temporarily add those violations to the
   allowlist of your StrictMode for components that you don‚Äôt own until
   the library fixes their violation.

   For details about how to configure other violations, see the
   documentation for
   `FragmentStrictMode.Policy.Builder <#>`__.

   There are three penalty types.

   -  `penaltyLog() <#penaltylog>`__
      dumps details of violations to Logcat.
   -  `penaltyDeath() <#penaltyDeath>`__
      terminates the app when violations are detected.
   -  `penaltyListener() <#penaltylistener>`__
      lets you add a custom listener that is called whenever violations
      are detected.

   You can apply any combination of penalties in your ``Policy``. If
   your policy does not explicitly specify a penalty, a default of
   ``penaltyLog()`` is applied. If you apply a penalty other than
   ``penaltyLog()`` in your custom ``Policy``, then ``penaltyLog()`` is
   disabled unless you explicitly set it.

   ``penaltyListener()`` can be useful when you have a third-party
   logging library to which you want to log violations. Alternatively,
   you might want to enable non-fatal violation catching in release
   builds and log them to a crash reporting library. This strategy can
   detect violations otherwise missed.

   To set a global StrictMode policy, set a default policy that applies
   to all
   `FragmentManager <#>`__
   instances using the
   `FragmentStrictMode.setDefaultPolicy() <#setDefaultPolicy>`__
   method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyApplication : Application() {

                   override fun onCreate() {
                       super.onCreate()

                       FragmentStrictMode.defaultPolicy =
                           FragmentStrictMode.Policy.Builder()
                               .detectFragmentReuse()
                               .detectFragmentTagUsage()
                               .detectRetainInstanceUsage()
                               .detectSetUserVisibleHint()
                               .detectTargetFragmentUsage()
                               .detectWrongFragmentContainer()
                               .apply {
                                   if (BuildConfig.DEBUG) {
                                       // Fail early on DEBUG builds
                                       penaltyDeath()
                                   } else {
                                       // Log to Crashlytics on RELEASE builds
                                       penaltyListener {
                                           FirebaseCrashlytics.getInstance().recordException(it)
                                       }
                                   }
                               }
                               .build()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyApplication extends Application {

                   @Override
                   public void onCreate() {
                       super.onCreate();

                       FragmentStrictMode.Policy.Builder builder = new FragmentStrictMode.Policy.Builder();
                       builder.detectFragmentReuse()
                               .detectFragmentTagUsage()
                               .detectRetainInstanceUsage()
                               .detectSetUserVisibleHint()
                               .detectTargetFragmentUsage()
                               .detectWrongFragmentContainer();
                       if (BuildConfig.DEBUG) {
                           // Fail early on DEBUG builds
                           builder.penaltyDeath();
                       } else {
                           // Log to Crashlytics on RELEASE builds
                           builder.penaltyListener((exception) ->
                                   FirebaseCrashlytics.getInstance().recordException(exception)
                           );
                       }
                       FragmentStrictMode.setDefaultPolicy(builder.build());
                   }
               }

   The following sections describe types of violations and possible
   workarounds.

   .. rubric:: Fragment reuse
      :name: fragment-reuse

   The fragment reuse violation is enabled using
   `detectFragmentReuse() <#detectFragmentReuse>`__
   and throws a
   `FragmentReuseViolation <#>`__.

   This violation indicates the reuse of a ``Fragment`` instance after
   its removal from ``FragmentManager``. This reuse can cause issues
   because the ``Fragment`` might retain state from its previous use and
   not behave consistently. If you create a new instance each time, it
   is always in the initial state when added to ``FragmentManager``.

   .. rubric:: Fragment tag usage
      :name: fragment-tag-usage

   The fragment tag usage violation is enabled using
   `detectFragmentTagUsage() <#detectFragmentTagUsage>`__
   and throws a
   `FragmentTagUsageViolation <#>`__.

   This violation indicates that a ``Fragment`` is inflated using the
   ``<fragment>`` tag in an XML layout. To resolve this, inflate your
   ``Fragment`` inside ``<androidx.fragment.app.FragmentContainerView>``
   rather than in the ``<fragment>`` tag. Fragments inflated using a
   ``FragmentContainerView`` can reliably handle ``Fragment``
   transactions and configuration changes. These might not work as
   expected if you use the ``<fragment>`` tag instead.

   .. rubric:: Retain instance usage
      :name: retain-instance-usage

   The retain instance usage violation is enabled using
   `detectRetainInstanceUsage() <#detectRetainInstanceUsage>`__
   and throws a
   `RetainInstanceUsageViolation <#>`__.

   This violation indicates the usage of a retained ``Fragment``,
   specifically, if there are calls to
   `setRetainInstance() <#setRetainInstance>`__
   or
   `getRetainInstance() <#getRetainInstance>`__,
   which are both deprecated.

   Instead of using these methods to manage retained ``Fragment``
   instances yourself, store state in a
   `ViewModel <#>`__ that
   handles this for you.

   .. rubric:: Set user visible hint
      :name: set-user-hint

   The set user visible hint violation is enabled using
   `detectSetUserVisibleHint() <#detectSetUserVisibleHint>`__
   and throws a
   `SetUserVisibleHintViolation <#>`__.

   This violation indicates a call to
   `setUserVisibleHint() <#setuservisiblehint>`__,
   which is deprecated.

   If you are manually calling this method, then call
   `setMaxLifecycle() <#setMaxLifecycle>`__
   instead. If you override this method, move the behavior to
   `onResume() <#onResume>`__
   when passing in ``true`` and
   `onPause() <#onPause>`__
   when passing in ``false``.

   .. rubric:: Target fragment usage
      :name: target-fragment-usage

   The target fragment usage violation is enabled using
   `detectTargetFragmentUsage() <#detectTargetFragmentUsage>`__
   and throws a
   `TargetFragmentUsageViolation <#>`__.

   This violation indicates a call to
   `setTargetFragment() <#setTargetFragment>`__,
   `getTargetFragment() <#getTargetFragment>`__,
   or
   `getTargetRequestCode() <#getTargetRequestCode>`__,
   which are all deprecated. Instead of using these methods, register a
   ``FragmentResultListener``. For more information about passing
   results, see `Pass results between fragments <#pass-between-fragments>`__.

   .. rubric:: Wrong fragment container
      :name: wrong-fragment-container

   The wrong fragment container violation is enabled using
   `detectWrongFragmentContainer() <#detectWrongFragmentContainer>`__
   and throws a
   `WrongFragmentContainerViolation <#>`__.

   This violation indicates the addition of a ``Fragment`` to a
   container other than ``FragmentContainerView``. As with `Fragment``
   tag usage <#fragment-tag-usage>`__, fragment transactions might not
   work as expected unless hosted inside a ``FragmentContainerView``.
   Using a container view also helps address an issue in the ``View``
   API that causes fragments using exit animations to be drawn on top of
   all other fragments.


Last updated 2024-01-03 UTC.


/Test your fragments
====================

.. container:: devsite-article-body clearfix

   This topic describes how to include framework-provided APIs in tests
   that evaluate each fragment's behavior.

   Fragments serve as reusable containers within your app, allowing you
   to present the same user interface layout in a variety of activities
   and layout configurations. Given the versatility of fragments, it's
   important to validate that they provide a consistent and
   resource-efficient experience. Note the following:

   -  Your fragment shouldn't be dependent on a specific parent activity
      or fragment.
   -  You shouldn't create a fragment's view hierarchy unless the
      fragment is visible to the user.

   To help set up the conditions for performing these tests, the
   AndroidX ``fragment-testing`` library provides the
   `FragmentScenario <#>`__
   class to create fragments and change their
   `Lifecycle.State <#>`__.

   **Note:**\  To successfully run tests that contain
   ``FragmentScenario`` objects, run each of the API's methods in your
   test's instrumentation thread. To learn more about different threads
   used in Android tests, see `Understand threads in tests <#threads>`__.

   .. rubric:: Declaring dependencies
      :name: declare-dependencies

   To use ``FragmentScenario``, define the ``fragment-testing`` artifact
   in your app's ``build.gradle`` file using ``debugImplementation``, as
   shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   def fragment_version = "1.7.0"

                   debugImplementation "androidx.fragment:fragment-testing:$fragment_version"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   val fragment_version = "1.7.0"

                   debugImplementation("androidx.fragment:fragment-testing:$fragment_version")
               }

   **Note:**\  ``debugImplementation`` is used here so that the empty
   activity that ``FragmentScenario`` relies on is accessible by the
   test target process.
   Testing examples on this page use assertions from the
   `Espresso <#>`__ and
   `Truth <https://truth.dev/>`__ libraries. For information on other
   available testing and assertion libraries, see `Set up project for AndroidX Test <#android-test-dependencies>`__.

   .. rubric:: Create a fragment
      :name: create

   ``FragmentScenario`` includes the following methods for launching
   fragments in tests:

   -  `launchInContainer() <#launchInContainer>`__,
      for testing a fragment's user interface. ``FragmentScenario``
      attaches the fragment to an activity's root view controller. This
      containing activity is otherwise empty.
   -  `launch() <#launch>`__,
      for testing without the fragment's user interface.
      ``FragmentScenario`` attaches this type of fragment to an *empty
      activity*, one that doesn't have a root view.

   After launching one of these fragment types, ``FragmentScenario``
   drives the fragment under test to a specified state. By default this
   state is ``RESUMED``, but you can override this with the
   ``initialState`` argument. The ``RESUMED`` state indicates that the
   fragment is running and visible to the user. You can evaluate
   information about its UI elements using `Espresso UI tests <#>`__.

   The following code examples show how to launch your fragment using
   each method:

   **Note:**\  Your fragment might require a theme that the test
   activity doesn't use by default. You can provide your own theme as an
   additional argument to ``launch()`` and ``launchInContainer()``.
   **launchInContainer() example**

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class MyTestSuite {
          @Test fun testEventFragment() {
              // The "fragmentArgs" argument is optional.
              val fragmentArgs = bundleOf(‚ÄúselectedListItem‚Äù to 0)
              val scenario = launchFragmentInContainer<EventFragment>(fragmentArgs)
              ...
          }
      }

   **launch() example**

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class MyTestSuite {
          @Test fun testEventFragment() {
              // The "fragmentArgs" arguments are optional.
              val fragmentArgs = bundleOf("numElements" to 0)
              val scenario = launchFragment<EventFragment>(fragmentArgs)
              ...
          }
      }

   .. rubric:: Provide dependencies
      :name: provide-dependencies

   If your fragments have dependencies, you can provide test versions of
   these dependencies by providing a custom ``FragmentFactory`` to the
   ``launchInContainer()`` or ``launch()`` methods.

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class MyTestSuite {
          @Test fun testEventFragment() {
              val someDependency = TestDependency()
              launchFragmentInContainer {
                  EventFragment(someDependency)
              }
              ...
          }
      }

   For more information about using ``FragmentFactory`` to provide
   dependencies to fragments, see `Fragment manager <#>`__.

   .. rubric:: Drive the fragment to a new state
      :name: drive-state

   In your app's UI tests, it's usually sufficient to launch the
   fragment under test and start testing it from a ``RESUMED`` state. In
   finer-grained unit tests, however, you might also evaluate the
   fragment's behavior as it transitions from one lifecycle state to
   another. You can specify the initial state by passing the
   ``initialState`` argument to any of the ``launchFragment*()``
   functions.

   To drive the fragment to a different lifecycle state, call
   `moveToState() <#moveToState>`__.
   This method supports the following states as arguments: ``CREATED``,
   ``STARTED``, ``RESUMED``, and ``DESTROYED``. This method simulates a
   situation where the fragment or activity containing your fragment
   changes its state for any reason.

   **Note:**\  If you transition a fragment to the ``DESTROYED`` state,
   you can't drive the fragment to another state, and you can't attach
   the fragment to a different activity.
   The following example launches a test fragment in the ``INITIALIZED``
   state and then moves it to the ``RESUMED`` state:

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class MyTestSuite {
          @Test fun testEventFragment() {
              val scenario = launchFragmentInContainer<EventFragment>(
                  initialState = Lifecycle.State.INITIALIZED
              )
              // EventFragment has gone through onAttach(), but not onCreate().
              // Verify the initial state.
              scenario.moveToState(Lifecycle.State.RESUMED)
              // EventFragment moves to CREATED -> STARTED -> RESUMED.
              ...
          }
      }

   **Caution:**\  If you try to transition your fragment under test to
   its current state, ``FragmentScenario`` ignores the request without
   throwing an exception. In particular, the API allows you to
   transition your fragment to the ``DESTROYED`` state multiple times
   consecutively.

   .. rubric:: Recreate the fragment
      :name: recreate

   If your app is running on a device which is low on resources, the
   system might destroy the activity containing your fragment. This
   situation requires your app to recreate the fragment when the user
   returns to it. To simulate this situation, call ``recreate()``:

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class MyTestSuite {
          @Test fun testEventFragment() {
              val scenario = launchFragmentInContainer<EventFragment>()
              scenario.recreate()
              ...
          }
      }

   `FragmentScenario.recreate() <#recreate>`__
   destroys the fragment and its host and then recreates them. When the
   ``FragmentScenario`` class recreates the fragment under test, the
   fragment returns to the lifecycle state that it was in before it was
   destroyed.

   .. rubric:: Interacting with UI fragments
      :name: interact

   To trigger UI actions in your fragment under test, use `Espresso view matchers <#>`__
   to interact with elements in your view:

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class MyTestSuite {
          @Test fun testEventFragment() {
              val scenario = launchFragmentInContainer<EventFragment>()
              onView(withId(R.id.refresh)).perform(click())
              // Assert some expected behavior
              ...
          }
      }

   If you need to call a method on the fragment itself, such as
   responding to a selection in the options menu, you can do so safely
   by getting a reference to the fragment using
   `FragmentScenario.onFragment() <#onFragment>`__
   and passing in a
   `FragmentAction <#>`__:

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class MyTestSuite {
          @Test fun testEventFragment() {
              val scenario = launchFragmentInContainer<EventFragment>()
              scenario.onFragment { fragment ->
                  fragment.myInstanceMethod()
              }
          }
      }

   **Note:**\  Don't keep references to the fragment that is passed into
   ``onFragment()``. These references consume system resources, and the
   references themselves might be stale, since the framework can
   recreate the fragment.

   .. rubric:: Test dialog actions
      :name: dialog

   ``FragmentScenario`` also supports testing `dialog fragments <#>`__. Though dialog fragments have
   UI elements, their layout is populated in a separate window, rather
   than in the activity itself. For this reason, use
   ``FragmentScenario.launch()`` to test dialog fragments.

   The following example tests the dialog dismissal process:

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class MyTestSuite {
          @Test fun testDismissDialogFragment() {
              // Assumes that "MyDialogFragment" extends the DialogFragment class.
              with(launchFragment<MyDialogFragment>()) {
                  onFragment { fragment ->
                      assertThat(fragment.dialog).isNotNull()
                      assertThat(fragment.requireDialog().isShowing).isTrue()
                      fragment.dismiss()
                      fragment.parentFragmentManager.executePendingTransactions()
                      assertThat(fragment.dialog).isNull()
                  }
              }

              // Assumes that the dialog had a button
              // containing the text "Cancel".
              onView(withText("Cancel")).check(doesNotExist())
          }
      }


Last updated 2024-05-01 UTC.


/Overview: Handling Android App Links
=====================================

.. https://developer.android.google.cn/training/app-links

.. container:: devsite-article-body clearfix

   .. container:: attempt-right

      .. figure::
         https://developer.android.google.cn/static/images/training/app-links/link-types-capabilities.svg
         :alt: Deep links handle content URIs. Web links handle the HTTP
         and HTTPS schemes. Android App Links handle the autoVerify
         attribute.
         :width: 250px

         **Figure 1.** Capabilities of deep links, web links, and
         Android App Links.

   Users following links on devices have one goal in mind: to get to the
   content they want to see. As a developer, you can set up Android App
   Links to take users to a link's specific content directly in your
   app, bypassing the app-selection dialog, also known as the
   disambiguation dialog. Because Android App Links leverage HTTP URLs
   and association with a website, users who don't have your app
   installed go directly to content on your site.

   .. rubric:: Understand the different types of links
      :name: understand-different-types-links

   Before you implement Android App Links, it's important to understand
   the different types of links you can create in your Android app: deep
   links, web links, and Android App Links. Figure 1 shows the
   relationship among these types of links, and the following sections
   describe each type of link in more detail.

   .. rubric:: Deep links
      :name: deep-links

   `Deep links <#>`__ are URIs of any
   scheme that take users directly to a specific part of your app. To
   create deep links, add `intent filters <#>`__ to drive users to the
   right activity in your app, as shown in the following code snippet:

   .. code:: prettyprint

      <activity
          android:name=".MyMapActivity"
          android:exported="true"
          ...>
          <intent-filter>
              <action android:name="android.intent.action.VIEW" />
              <category android:name="android.intent.category.DEFAULT" />
              <category android:name="android.intent.category.BROWSABLE" />
              <data android:scheme="geo" />
          </intent-filter>
      </activity>

   When the user clicks a deep link, a disambiguation dialog might
   appear. This dialog allows the user to select one of multiple apps,
   including your app, that can handle the given deep link. Figure 2
   shows the dialog after the user clicks a map link, asking whether to
   open the link in Maps or Chrome.


   .. image:: https://developer.android.google.cn/static/training/app-links/images/app-disambiguation_2x.png
      :width: 250px

   **Figure 2.** The disambiguation dialog

   .. rubric:: Web links
      :name: web-links

   *Web links* are deep links that use the HTTP and HTTPS schemes. On
   ``Android 12`` and higher, clicking a web link (that is not an `Android App Link <#android-app-links>`__) always shows content in a web
   browser. On devices running previous versions of Android, if your app
   or other apps installed on a user's device can also handle the web
   link, users might not go directly to the browser. Instead, they'll
   see a disambiguation dialog similar to the one that appears in figure
   2.

   The following code snippet shows an example of a web link filter:

   .. code:: prettyprint

      <intent-filter>
          <action android:name="android.intent.action.VIEW" />
          <category android:name="android.intent.category.DEFAULT" />
          <category android:name="android.intent.category.BROWSABLE" />

          <data android:scheme="http" />
          <data android:host="myownpersonaldomain.com" />
      </intent-filter>

   .. rubric:: Android App Links
      :name: android-app-links

   *Android App Links*, available on Android 6.0 (API level 23) and
   higher, are web links that use the HTTP and HTTPS schemes and contain
   the ``autoVerify`` attribute. This attribute allows your app to
   designate itself as the default handler of a given type of link. So
   when the user clicks on an Android App Link, your app opens
   immediately if it's installed‚Äîthe disambiguation dialog doesn't
   appear.

   If the user doesn't want your app to be the default handler, they can
   override this behavior from the app's settings.

   The following code snippet shows an example of an Android App Link
   filter:

   .. code:: prettyprint

      <intent-filter android:autoVerify="true">
          <action android:name="android.intent.action.VIEW" />
          <category android:name="android.intent.category.DEFAULT" />
          <category android:name="android.intent.category.BROWSABLE" />

          <data android:scheme="http" />
          <data android:scheme="https" />

          <data android:host="myownpersonaldomain.com" />
      </intent-filter>

   Android App Links offer the following benefits:

   -  **Secure and specific:** Android App Links use HTTP URLs that link
      to a website domain you own, so no other app can use your links.
      One of the requirements for Android App Links is that you verify
      ownership of your domain through one of our website association
      methods.
   -  **Seamless user experience:** Since Android App Links use a single
      HTTP URL for the same content on your website and in your app,
      users who don‚Äôt have the app installed simply go to your website
      instead of the app ‚Äî no 404s, no errors.
   -  **Android Instant Apps support:** With Android Instant Apps, your
      users can run your Android app without installing it. To add
      Instant App support to your Android app, set up Android App Links
      and visit `g.co/InstantApps <https://g.co/InstantApps>`__.
   -  **Engage users from Google Search:** Users directly open specific
      content in your app by clicking a URL from Google in a mobile
      browser, in the `Google Search app <#>`__, in
      screen search on Android, or through Google Assistant.

   .. rubric:: Add Android App Links
      :name: add-app-links

   The general steps for creating Android App Links are as follows:

   #. **Create deep links to specific content in your app:** In your app
      manifest, create intent filters for your website URIs and
      configure your app to use data from the intents to send users to
      the right content in your app. Learn more in `Create Deep Links to App Content <#>`__.
   #. **Add verification for your deep links:** Configure your app to
      request verification of app links. Then, publish a Digital Asset
      Links JSON file on your websites to verify ownership through
      `Google Search Console <https://support.google.com/webmasters/answer/9008080>`__.
      Learn more in `Verify App Links <#>`__.

   As an alternative to the documentation linked above, the `Android App Links Assistant <#>`__ is a tool in
   Android Studio that guides you through each of the steps required to
   create Android App Links.

   For additional information, see the following resources:

   -  `Add Android App Links in Android Studio <#>`__
   -  `Creating a Statement List <https://developers.google.cn/digital-asset-links/v1/create-statement>`__

   .. rubric:: Manage and verify Android App Links
      :name: manage-verify

   You can manage and verify deep links through the `Play Console <https://play.google.com/console>`__. Once an app has been
   successfully `uploaded <#>`__ the
   dashboard (located under Grow > Deep links) displays an overview of
   deep links and configuration errors.

   .. image:: https://developer.android.google.cn/static/training/app-links/images/play-console-dashboard.png
      :width: 1000px

   **Figure 3.** Deep links Play Console dashboard

   The dashboard offers the following sections:

   -  Highlights of the overall deep links configuration
   -  All the domains declared in the manifest file
   -  Web links which are grouped by path
   -  Links which have custom schemes

   Each one of these sections displays the deep link status and a way to
   fix them in case of an error.
   Please refer to `this guide <https://support.google.com/googleplay/android-developer/answer/12463044>`__
   for more information on the dashboard.


Last updated 2024-05-03 UTC.


/Create Deep Links to App Content
=================================

.. container:: devsite-article-body clearfix

   When a clicked link or programmatic request invokes a web URI intent,
   the Android system tries each of the following actions, in sequential
   order, until the request succeeds:

   #. Open the user's preferred app that can handle the URI, if one is
      designated.
   #. Open the only available app that can handle the URI.
   #. Allow the user to select an app from a dialog.

   Follow the steps below to create and test links to your content. You
   can also use the `App Links Assistant <#>`__ in Android Studio to
   add Android App Links.

   **Note:** Starting in ``Android 12`` (API ``level 31``), a generic web intent
   resolves to an activity in your app only if your app is approved for
   the specific domain contained in that web intent. If your app isn't
   approved for the domain, the web intent resolves to the user's
   default browser app instead.

   .. rubric:: Add intent filters for incoming links
      :name: adding-filters

   To create a link to your app content, add an intent filter that
   contains these elements and attribute values in your manifest:

   ``<action>``
      Specify the
      `ACTION_VIEW <#ACTION_VIEW>`__
      intent action so that the intent filter can be reached from Google
      Search.
   ``<data>``
      Add one or more
      ``<data>`` tags, each of
      which represents a URI format that resolves to the activity. At
      minimum, the ``<data>``
      tag must include the
      `android:scheme <#scheme>`__
      attribute.

      You can add more attributes to further refine the type of URI that
      the activity accepts. For example, you might have multiple
      activities that accept similar URIs, but which differ simply based
      on the path name. In this case, use the
      `android:path <#path>`__
      attribute or its ``pathPattern`` or ``pathPrefix`` variants to
      differentiate which activity the system should open for different
      URI paths.

   ``<category>``
      Include the
      `BROWSABLE <#CATEGORY_BROWSABLE>`__
      category. It is required in order for the intent filter to be
      accessible from a web browser. Without it, clicking a link in a
      browser cannot resolve to your app.

      Also include the
      `DEFAULT <#CATEGORY_DEFAULT>`__
      category. This allows your app to respond to implicit intents.
      Without this, the activity can be started only if the intent
      specifies your app component name.

   The following XML snippet shows how you might specify an intent
   filter in your manifest for deep linking. The URIs
   ``‚Äúexample://gizmos‚Äù`` and ``‚Äúhttp://www.example.com/gizmos‚Äù`` both
   resolve to this activity.

   .. code:: prettyprint

      <activity
          android:name="com.example.android.GizmosActivity"
          android:label="@string/title_gizmos" >
          <intent-filter android:label="@string/filter_view_http_gizmos">
              <action android:name="android.intent.action.VIEW" />
              <category android:name="android.intent.category.DEFAULT" />
              <category android:name="android.intent.category.BROWSABLE" />
              <!-- Accepts URIs that begin with "http://www.example.com/gizmos‚Äù -->
              <data android:scheme="http"
                    android:host="www.example.com"
                    android:pathPrefix="/gizmos" />
              <!-- note that the leading "/" is required for pathPrefix-->
          </intent-filter>
          <intent-filter android:label="@string/filter_view_example_gizmos">
              <action android:name="android.intent.action.VIEW" />
              <category android:name="android.intent.category.DEFAULT" />
              <category android:name="android.intent.category.BROWSABLE" />
              <!-- Accepts URIs that begin with "example://gizmos‚Äù -->
              <data android:scheme="example"
                    android:host="gizmos" />
          </intent-filter>
      </activity>

   Notice that the two intent filters only differ by the ``<data>``
   element. Although it's possible to include multiple ``<data>``
   elements in the same filter, it's important that you create separate
   filters when your intention is to declare unique URLs (such as a
   specific combination of ``scheme`` and ``host``), because multiple
   ``<data>`` elements in the same intent filter are actually merged
   together to account for all variations of their combined attributes.
   For example, consider the following:

   .. code:: prettyprint

      <intent-filter>
        ...
        <data android:scheme="https" android:host="www.example.com" />
        <data android:scheme="app" android:host="open.my.app" />
      </intent-filter>

   It might seem as though this supports only
   ``https://www.example.com`` and ``app://open.my.app``. However, it
   actually supports those two, plus these: ``app://www.example.com``
   and ``https://open.my.app``.

   **Caution:** If multiple activities contain intent filters that
   resolve to the same verified Android App Link, then there's no
   guarantee as to which activity handles the link.

   Once you've added intent filters with URIs for activity content to
   your app manifest, Android is able to route any
   `Intent <#>`__ that has matching
   URIs to your app at runtime.

   To learn more about defining intent filters, see `Allow Other Apps to Start Your Activity <#>`__.

   .. rubric:: Read data from incoming intents
      :name: handling-intents

   Once the system starts your activity through an intent filter, you
   can use data provided by the `Intent <#>`__ to determine what
   you need to render. Call the `getData() <#getData>`__ and
   `getAction() <#getAction>`__
   methods to retrieve the data and action associated with the incoming
   `Intent <#>`__. You can call
   these methods at any time during the lifecycle of the activity, but
   you should generally do so during early callbacks such as
   `onCreate() <#onCreate>`__ or `onStart() <#onStart>`__.

   Here‚Äôs a snippet that shows how to retrieve data from an
   `Intent <#>`__:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            override fun onCreate(savedInstanceState: Bundle?) {
                super.onCreate(savedInstanceState)
                setContentView(R.layout.main)

                val action: String? = intent?.action
                val data: Uri? = intent?.data
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            @Override
            public void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.main);

                Intent intent = getIntent();
                String action = intent.getAction();
                Uri data = intent.getData();
            }

   Follow these best practices to improve the user's experience:

   -  The deep link should take users directly to the content, without
      any prompts, interstitial pages, or logins. Make sure that users
      can see the app content even if they never previously opened the
      application. It is okay to prompt users on subsequent interactions
      or when they open the app from the Launcher.
   -  Follow the design guidance described in `Navigation with Back and Up <#>`__ so that your app
      matches users' expectations for backward navigation after they
      enter your app through a deep link.

   .. rubric:: Test your deep links
      :name: testing-filters

   You can use the `Android Debug Bridge <#>`__ with the
   activity manager (am) tool to test that the intent filter URIs you
   specified for deep linking resolve to the correct app activity. You
   can run the adb command against a device or an emulator.

   The general syntax for testing an intent filter URI with adb is:

   .. code:: none

      $ adb shell am start
              -W -a android.intent.action.VIEW
              -d <URI> <PACKAGE>

   For example, the command below tries to view a target app activity
   that is associated with the specified URI.

   .. code:: none

      $ adb shell am start
              -W -a android.intent.action.VIEW
              -d "example://gizmos" com.example.android

   The manifest declaration and intent handler you set above define the
   connection between your app and a website and what to do with
   incoming links. However, in order to have the system treat your app
   as the default handler for a set of URIs, you must also request that
   the system verify this connection. The `next lesson <#>`__ explains how
   to implement this verification.

   To learn more about intents and app links, see the following
   resources:

   -  `Intents and Intent Filters <#>`__
   -  `Allow Other Apps to Start Your Activity <#>`__
   -  `Add Android App Links with Android Studio <#>`__


Last updated 2024-05-03 UTC.


/Verify Android App Links
=========================

.. container:: devsite-article-body clearfix

   An Android App Link is a special type of deep link that allows your
   website URLs to immediately open the corresponding content in your
   Android app, without requiring the user to select the app. Android
   App Links use the `Digital Asset Links API <https://developers.google.cn/digital-asset-links>`__ to
   establish trust that your app has been approved by the website to
   automatically open links for that domain. If the system successfully
   verifies that you own the URLs, the system automatically routes those
   URL intents to your app.

   To verify that you own both your app and the website URLs, complete
   the following steps:

   #. `Add intent filters <#add-intent-filters>`__ that contain the
      ``autoVerify`` attribute. This attribute signals to the system
      that it should verify whether your app belongs to the URL domains
      used in your intent filters.

      **Note:**\  Starting in ``Android 12`` (API ``level 31``), you can
      `manually verify <#manual-verification>`__ how the system resolves
      your Android App Links.

   #. `Declare the association <#web-assoc>`__ between your website and
      your intent filters by hosting a Digital Asset Links JSON file at
      the following location:

      .. code:: none

         https://domain.name/.well-known/assetlinks.json

   You can find related information in the following resources:

   -  `Supporting URLs and App Indexing in Android Studio <#>`__
   -  `Creating a Statement List <https://developers.google.cn/digital-asset-links/v1/create-statement>`__

   .. rubric:: Add intent filters for app links verification
      :name: add-intent-filters

   To enable link handling verification for your app, add intent filters
   that match the following format:

   .. code:: prettyprint

      <!-- Make sure you explicitly set android:autoVerify to "true". -->
      <intent-filter android:autoVerify="true">
          <action android:name="android.intent.action.VIEW" />
          <category android:name="android.intent.category.DEFAULT" />
          <category android:name="android.intent.category.BROWSABLE" />

          <!-- If a user clicks on a shared link that uses the "http" scheme, your
               app should be able to delegate that traffic to "https". -->
          <data android:scheme="http" />
          <data android:scheme="https" />

          <!-- Include one or more domains that should be verified. -->
          <data android:host="..." />
      </intent-filter>

   Although it's sufficient to include ``autoVerify`` in only one
   ``<intent-filter>`` declaration for each host, even if that host is
   used across other unmarked declarations, it's recommended that you
   add ``autoVerify`` to each ``<intent-filter>`` element for
   consistency. This also ensures that, after your remove or refactor
   elements in your manifest file, your app remains associated with all
   the domains that you still define.

   The domain verification process requires an internet connection and
   could take some time to complete. To help improve the efficiency of
   the process, the system verifies a domain for an app that targets
   ``Android 12`` or higher only if that domain is inside an
   ``<intent-filter>`` element that contains the exact format specified
   in the preceding code snippet.

   **Note:**\  On apps that target ``Android 12``, the system makes several
   changes to how Android App Links are verified. These changes improve
   the reliability of the app-linking experience and provide more
   control to app developers and end users. You can `manually invoke domain verification <#manual-verification>`__ to test the reliability
   of your declarations.

   .. rubric:: Supporting app linking for multiple hosts
      :name: multi-host

   The system must be able to verify the host specified in the app‚Äôs URL
   intent filters‚Äô data elements against the Digital Asset Links files
   hosted on the respective web domains in that intent filter. If the
   verification fails, the system then defaults to its standard behavior
   to resolve the intent, as described in `Create Deep Links to App Content <#>`__. However, the app can
   still be verified as a default handler for any of the URL patterns
   defined in the app's other intent filters.

   **Note:** On ``Android 11`` (API ``level 30``) and lower, the system doesn't
   verify your app as a default handler unless it finds a matching
   Digital Asset Links file for *all* hosts that you define in the
   manifest.

   For example, an app with the following intent filters would pass
   verification only for ``https://www.example.com`` if an
   ``assetlinks.json`` file were found at
   ``https://www.example.com/.well-known/assetlinks.json`` but not
   ``https://www.example.net/.well-known/assetlinks.json``:

   .. code:: prettyprint

      <application>

        <activity android:name=‚ÄùMainActivity‚Äù>
          <intent-filter android:autoVerify="true">
            <action android:name="android.intent.action.VIEW" />
            <category android:name="android.intent.category.DEFAULT" />
            <category android:name="android.intent.category.BROWSABLE" />
            <data android:scheme="http" />
            <data android:scheme="https" />
            <data android:host="www.example.com" />
          </intent-filter>
        </activity>
        <activity android:name=‚ÄùSecondActivity‚Äù>
          <intent-filter>
            <action android:name="android.intent.action.VIEW" />
            <category android:name="android.intent.category.DEFAULT" />
            <category android:name="android.intent.category.BROWSABLE" />
            <data android:scheme="https" />
           <data android:host="www.example.net" />
          </intent-filter>
        </activity>

      </application>

   **Note:** All ``<data>`` elements in the same intent filter are
   merged together to account for all variations of their combined
   attributes. For example, the first intent filter above includes a
   ``<data>`` element that only declares the HTTPS scheme. But it is
   combined with the other ``<data>`` element so that the intent filter
   supports both ``http://www.example.com`` and
   ``https://www.example.com``. As such, you must create separate intent
   filters when you want to define specific combinations of URI schemes
   and domains.

   .. rubric:: Supporting app linking for multiple subdomains
      :name: multi-subdomain

   The Digital Asset Links protocol treats subdomains in your intent
   filters as unique, separate hosts. So if your intent filter lists
   multiple hosts with different subdomains, you must publish a valid
   ``assetlinks.json`` on each domain. For example, the following intent
   filter includes ``www.example.com`` and ``mobile.example.com`` as
   accepted intent URL hosts. So a valid ``assetlinks.json`` must be
   published at both
   ``https://www.example.com/.well-known/assetlinks.json`` and
   ``https://mobile.example.com/.well-known/assetlinks.json``.

   .. code:: prettyprint

      <application>
        <activity android:name=‚ÄùMainActivity‚Äù>
          <intent-filter android:autoVerify="true">
            <action android:name="android.intent.action.VIEW" />
            <category android:name="android.intent.category.DEFAULT" />
            <category android:name="android.intent.category.BROWSABLE" />
            <data android:scheme="https" />
            <data android:scheme="https" />
            <data android:host="www.example.com" />
            <data android:host="mobile.example.com" />
          </intent-filter>
        </activity>
      </application>

   Alternatively, if you declare your hostname with a wildcard (such as
   ``*.example.com``), you must publish your ``assetlinks.json`` file at
   the root hostname (``example.com``). For example, an app with the
   following intent filter will pass verification for any sub-name of
   ``example.com`` (such as ``foo.example.com``) as long as the
   ``assetlinks.json`` file is published at
   ``https://example.com/.well-known/assetlinks.json``:

   .. code:: prettyprint

      <application>
        <activity android:name=‚ÄùMainActivity‚Äù>
          <intent-filter android:autoVerify="true">
            <action android:name="android.intent.action.VIEW" />
            <category android:name="android.intent.category.DEFAULT" />
            <category android:name="android.intent.category.BROWSABLE" />
            <data android:scheme="https" />
            <data android:host="*.example.com" />
          </intent-filter>
        </activity>
      </application>

   .. rubric:: Check for multiple apps associated with the same domain
      :name: multi-app-same-domain

   If you publish multiple apps that are each associated with the same
   domain, they can each be successfully verified. However, if the apps
   can resolve the exact same domain host and path, as might be the case
   with lite and full versions of an app, only the app that was
   installed most recently can resolve web intents for that domain.

   In a case like this, check for possible conflicting apps on the
   user's device, provided that you have the necessary `package visibility <#>`__. Then, in your app, show
   a custom chooser dialog that contains the results from calling
   `queryIntentActivities() <#queryIntentActivities>`__.
   The user can select their preferred app from the list of matching
   apps that appear in the dialog.

   **Note:**\  Consider storing the matching path so that the user
   doesn't have to re-select if a similar web intent is launched later.

   .. rubric:: Declare website associations
      :name: web-assoc

   A `Digital Asset Links <https://developers.google.cn/digital-asset-links/v1/getting-started>`__
   JSON file must be published on your website to indicate the Android
   apps that are associated with the website and verify the app's URL
   intents. The JSON file uses the following fields to identify
   associated apps:

   -  ``package_name``: The `application ID <#set_the_application_id>`__
      declared in the app's ``build.gradle`` file.

   -  ``sha256_cert_fingerprints``: The SHA256 fingerprints of your
      app‚Äôs signing certificate. You can use the following command to
      generate the fingerprint via the Java keytool:

      .. code:: none

         keytool -list -v -keystore my-release-key.keystore

      This field supports multiple fingerprints, which can be used to
      support different versions of your app, such as debug and
      production builds.

      If you're using `Play App Signing <https://support.google.com/googleplay/android-developer/answer/9842756>`__
      for your app, then the certificate fingerprint produced by running
      ``keytool`` locally will usually not match the one on users'
      devices. You can verify whether you're using Play App Signing for
      your app in your `Play Console <https://play.google.com/console/>`__ developer account
      under ``Release > Setup > App signing``; if you do, then you'll
      also find the correct Digital Asset Links JSON snippet for your
      app on the same page.

   The following example ``assetlinks.json`` file grants link-opening
   rights to a ``com.example`` Android app:

   .. code:: prettyprint

      [{
        "relation": ["delegate_permission/common.handle_all_urls"],
        "target": {
          "namespace": "android_app",
          "package_name": "com.example",
          "sha256_cert_fingerprints":
          ["14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5"]
        }
      }]

   .. rubric:: Associating a website with multiple apps
      :name: multiple-apps

   A website can declare associations with multiple apps within the same
   ``assetlinks.json`` file. The following file listing shows an example
   of a statement file that declares association with two apps,
   separately, and resides at
   ``https://www.example.com/.well-known/assetlinks.json``:

   .. code:: prettyprint

      [{
        "relation": ["delegate_permission/common.handle_all_urls"],
        "target": {
          "namespace": "android_app",
          "package_name": "com.example.puppies.app",
          "sha256_cert_fingerprints":
          ["14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5"]
        }
        },
        {
        "relation": ["delegate_permission/common.handle_all_urls"],
        "target": {
          "namespace": "android_app",
          "package_name": "com.example.monkeys.app",
          "sha256_cert_fingerprints":
          ["14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5"]
        }
      }]

   Different apps may handle links for different resources under the
   same web host. For example, app1 may declare an intent filter for
   ``https://example.com/articles``, and app2 may declare an intent
   filter for ``https://example.com/videos``.

   **Note:** Multiple apps associated with a domain may be signed with
   the same or different certificates.

   .. rubric:: Associating multiple websites with a single app
      :name: multi-site

   Multiple websites can declare associations with the same app in their
   respective ``assetlinks.json`` files. The following file listings
   show an example of how to declare the association of example.com and
   example.net with app1. The first listing shows the association of
   example.com with app1:

   https://www.example.com/.well-known/assetlinks.json

   .. code:: prettyprint

      [{
        "relation": ["delegate_permission/common.handle_all_urls"],
        "target": {
          "namespace": "android_app",
          "package_name": "com.mycompany.app1",
          "sha256_cert_fingerprints":
          ["14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5"]
        }
      }]

   The next listing shows the association of example.net with app1. Only
   the location where these files are hosted is different (``.com`` and
   ``.net``):

   https://www.example.net/.well-known/assetlinks.json

   .. code:: prettyprint

      [{
        "relation": ["delegate_permission/common.handle_all_urls"],
        "target": {
          "namespace": "android_app",
          "package_name": "com.mycompany.app1",
          "sha256_cert_fingerprints":
          ["14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5"]
        }
      }]

   .. rubric:: Publishing the JSON verification file
      :name: publish-json

   You must publish your JSON verification file at the following
   location:

   .. code:: none

      https://domain.name/.well-known/assetlinks.json

   Be sure of the following:

   -  The ``assetlinks.json`` file is served with content-type
      ``application/json``.
   -  The ``assetlinks.json`` file must be accessible over an HTTPS
      connection, regardless of whether your app's intent filters
      declare HTTPS as the data scheme.
   -  The ``assetlinks.json`` file must be accessible without any
      redirects (no 301 or 302 redirects).
   -  If your app links support multiple host domains, then you must
      publish the ``assetlinks.json`` file on each domain. See
      `Supporting app linking for multiple hosts <#multi-host>`__.
   -  Do not publish your app with dev/test URLs in the manifest file
      that may not be accessible to the public (such as any that are
      accessible only with a VPN). A work-around in such cases is to
      `configure build variants <#>`__ to
      generate a different manifest file for dev builds.

   .. rubric:: Android App Links verification
      :name: verification

   When ``android:autoVerify="true"`` is present in at least one of your
   app's intent filters, installing your app on a device that runs
   Android 6.0 (API level 23) or higher causes the system to
   automatically verify the hosts associated with the URLs in your app's
   intent filters. On ``Android 12`` and higher, you can also `invoke the verification process manually <#manual-verification>`__ to test the
   verification logic.

   .. rubric:: Auto verification
      :name: auto-verification

   The system's auto-verification involves the following:

   #. The system inspects all intent filters that include any of the
      following:

      -  Action: ``android.intent.action.VIEW``
      -  Categories: ``android.intent.category.BROWSABLE`` and
         ``android.intent.category.DEFAULT``
      -  Data scheme: ``http`` or ``https``

   #. For each unique host name found in the above intent filters,
      Android queries the corresponding websites for the Digital Asset
      Links file at
      ``https://``\ ``hostname``\ ``/.well-known/assetlinks.json``.

   **Note:**\  On ``Android 11`` (API ``level 30``) and lower, the system
   establishes your app as the default handler for the specified URL
   patterns only if it finds a matching Digital Asset Links file for
   *all* hosts in the manifest.
   After you have confirmed the list of websites to associate with your
   app, and you have confirmed that the hosted JSON file is valid,
   install the app on your device. Wait at least 20 seconds for the
   asynchronous verification process to complete. Use the following
   command to check whether the system verified your app and set the
   correct link handling policies:

   .. code:: none

      adb shell am start -a android.intent.action.VIEW \
          -c android.intent.category.BROWSABLE \
          -d "http://domain.name:optional_port"

   .. rubric:: Manual verification
      :name: manual-verification

   Starting in ``Android 12``, you can manually invoke domain verification
   for an app that's installed on a device. You can perform this process
   regardless of whether your app targets ``Android 12``.

   .. rubric:: Establish an internet connection
      :name: establish-internet-connection

   To perform domain verification, your test device must be connected to
   the internet.

   .. rubric:: Support the updated domain verification process
      :name: support-updated-domain-verification

   If your app targets ``Android 12`` or higher, the system uses the updated
   domain verification process automatically.

   Otherwise, you can manually enable the updated verification process.
   To do so, run the following command in a terminal window:

   .. code:: none

      adb shell am compat enable 175408749 PACKAGE_NAME

   .. rubric:: Reset the state of Android App Links on a device
      :name: reset-state

   Before you manually invoke domain verification on a device, you must
   reset the state of Android App Links on the test device. To do so,
   run the following command in a terminal window:

   .. code:: none

      adb shell pm set-app-links --package PACKAGE_NAME 0 all

   This command puts the device in the same state that it's in before
   the user chooses default apps for any domains.

   .. rubric:: Invoke the domain verification process
      :name: invoke-domain-verification

   After you reset the state of Android App Links on a device, you can
   perform the verification itself. To do so, run the following command
   in a terminal window:

   .. code:: none

      adb shell pm verify-app-links --re-verify PACKAGE_NAME

   **Note:**\  Before you review the results of this command, wait a few
   minutes for the verification agent to finish the requests related to
   domain verification.

   .. rubric:: Review the verification results
      :name: review-results

   After allowing some time for the verification agent to finish its
   requests, review the verification results. To do so, run the
   following command:

   .. code:: none

      adb shell pm get-app-links PACKAGE_NAME

   The output of this command is similar to the following:

   .. code:: none

      com.example.pkg:
          ID: 01234567-89ab-cdef-0123-456789abcdef
          Signatures: [***]
          Domain verification state:
            example.com: verified
            sub.example.com: legacy_failure
            example.net: verified
            example.org: 1026

   The domains that successfully pass verification have a domain
   verification state of ``verified``. Any other state indicates that
   the domain verification couldn't be performed. In particular, a state
   of ``none`` indicates that the verification agent might not have
   completed the verification process yet.

   The following list shows the possible return values that domain
   verification can return for a given domain:

   ``none``
      Nothing has been recorded for this domain. Wait a few more minutes
      for the verification agent to finish the requests related to
      domain verification, then `invoke the domain verification process <#invoke-domain-verification>`__ again.
   ``verified``
      The domain is successfully verified for the declaring app.
   ``approved``
      The domain was force-approved, usually by executing a shell
      command.
   ``denied``
      The domain was force-denied, usually by executing a shell command.
   ``migrated``
      The system preserved the result of a previous process that used
      legacy domain verification.
   ``restored``
      The domain was approved after the user performed a data restore.
      It's assumed that the domain was previously verified.
   ``legacy_failure``
      The domain was rejected by a legacy verifier. The specific failure
      reason is unknown.
   ``system_configured``
      The domain was approved automatically by the device configuration.
   Error code of ``1024`` or greater
      Custom error code that's specific to the device's verifier.

      Double-check that you have `established a network connection <#establish-internet-connection>`__, and `invoke the domain verification process <#invoke-domain-verification>`__
      again.

   .. rubric:: Request the user to associate your app with a domain
      :name: request-user-associate-app-with-domain

   Another way for your app to get approved for a domain is to ask the
   user to associate your app with that domain.

   **Note:**\  On a given device, only one app at a time can be
   associated with a particular domain. If another app is already
   verified for the domain, the user must first disassociate that other
   app with the domain before they can associate your app with the
   domain.

   .. rubric:: Check whether your app is already approved for the domain
      :name: check-app-already-approved

   Before you prompt the user, check whether your app is the default
   handler for the domains that you define in your ``<intent-filter>``
   elements. You can query the approval state using one of the following
   methods:

   -  The `DomainVerificationManager <#>`__ API (at runtime).
   -  A command-line program (during testing).

   .. rubric:: DomainVerificationManager
      :name: user-prompt-domain-verification-manager

   The following code snippet demonstrates how to use the
   ``DomainVerificationManager`` API:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val context: Context = TODO("Your activity or fragment's Context")
               val manager = context.getSystemService(DomainVerificationManager::class.java)
               val userState = manager.getDomainVerificationUserState(context.packageName)

               // Domains that have passed Android App Links verification.
               val verifiedDomains = userState?.hostToStateMap
                   ?.filterValues { it == DomainVerificationUserState.DOMAIN_STATE_VERIFIED }

               // Domains that haven't passed Android App Links verification but that the user
               // has associated with an app.
               val selectedDomains = userState?.hostToStateMap
                   ?.filterValues { it == DomainVerificationUserState.DOMAIN_STATE_SELECTED }

               // All other domains.
               val unapprovedDomains = userState?.hostToStateMap
                   ?.filterValues { it == DomainVerificationUserState.DOMAIN_STATE_NONE }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Context context = TODO("Your activity or fragment's Context");
               DomainVerificationManager manager =
                       context.getSystemService(DomainVerificationManager.class);
               DomainVerificationUserState userState =
                       manager.getDomainVerificationUserState(context.getPackageName());

               Map<String, Integer> hostToStateMap = userState.getHostToStateMap();
               List<String> verifiedDomains = new ArrayList<>();
               List<String> selectedDomains = new ArrayList<>();
               List<String> unapprovedDomains = new ArrayList<>();
               for (String key : hostToStateMap.keySet()) {
                   Integer stateValue = hostToStateMap.get(key);
                   if (stateValue == DomainVerificationUserState.DOMAIN_STATE_VERIFIED) {
                       // Domain has passed Android App Links verification.
                       verifiedDomains.add(key);
                   } else if (stateValue == DomainVerificationUserState.DOMAIN_STATE_SELECTED) {
                       // Domain hasn't passed Android App Links verification, but the user has
                       // associated it with an app.
                       selectedDomains.add(key);
                   } else {
                       // All other domains.
                       unapprovedDomains.add(key);
                   }
               }

   .. rubric:: Command-line program
      :name: user-prompt-command-line-program

   When testing your app during development, you can run the following
   command to query the verification state of the domains that your
   organization owns:

   .. code:: none

      adb shell pm get-app-links --user cur PACKAGE_NAME

   In the following example output, even though the app failed
   verification for the "example.org" domain, user 0 has manually
   approved the app in system settings, and no other package is verified
   for that domain.

   .. code:: none

      com.example.pkg:
      ID: ***
      Signatures: [***]
      Domain verification state:
        example.com: verified
        example.net: verified
        example.org: 1026
      User 0:
        Verification link handling allowed: true
        Selection state:
          Enabled:
            example.org
          Disabled:
            example.com
            example.net

   You can also use shell commands to simulate the process where the
   user selects which app is associated with a given domain. A full
   explanation of these commands is available from the output of
   ``adb shell pm``.

   **Note:**\  The system can only associate one app at a time with a
   domain, even when you use shell commands. Some special cases, such as
   `installing two app variants simultaneously <#multi-app-same-domain>`__, require special handling
   to open a given web link in the intended app.

   .. rubric:: Provide context for the request
      :name: provide-context

   Before you make this request for domain approval, provide some
   context for the user. For example, you might show them a splash
   screen, a dialog, or a similar UI element that explains to the user
   why your app should be the default handler for a particular domain.

   .. rubric:: Make the request
      :name: make-request

   After the user understands what your app is asking them to do, make
   the request. To do so, invoke an intent that includes the
   `ACTION_APP_OPEN_BY_DEFAULT_SETTINGS <#ACTION_APP_OPEN_BY_DEFAULT_SETTINGS>`__
   intent action, and a data string matching
   ``package:``\ ``com.example.pkg`` for the target app, as shown in the
   following code snippet:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val context: Context = TODO("Your activity or fragment's Context")
               val intent = Intent(Settings.ACTION_APP_OPEN_BY_DEFAULT_SETTINGS,
                   Uri.parse("package:${context.packageName}"))
               context.startActivity(intent)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Context context = TODO("Your activity or fragment's Context");
               Intent intent = new Intent(Settings.ACTION_APP_OPEN_BY_DEFAULT_SETTINGS,
                   Uri.parse("package:" + context.getPackageName()));
               context.startActivity(intent);

   When the intent is invoked, users see a settings screen called **Open
   by default**. This screen contains a radio button called **Open
   supported links**, as shown in figure 1.

   When the user turns on **Open supported links**, a set of checkboxes
   appear under a section called **Links to open in this app**. From
   here, users can select the domains that they want to associate with
   your app. They can also select **Add link** to add domains, as shown
   in figure 2. When users later select any link within the domains that
   they add, the link opens in your app automatically.

   .. container:: attempt-left

      .. figure:: https://developer.android.google.cn/static/images/training/app-links/choose-domains.svg
         name: choose-domains
         :alt: When the radio button is enabled, a section near the
         bottom includes checkboxes as well as a button called 'Add
         link'
         :width: 250px

      **Figure 1.** System settings screen where users can choose which
      links open in your app by default.

   .. container:: attempt-right

      .. figure:: https://developer.android.google.cn/static/images/training/app-links/add-domains.svg
         name: add-domains
         :alt: Each checkbox represents a domain that you can add. The
         dialog's buttons are 'Cancel' and 'Add.'
         :width: 250px

      **Figure 2.** Dialog where users can choose additional domains to
      associate with your app.

   .. rubric:: Open domains in your app that your app cannot verify
      :name: unverified-apps

   Your app's main function might be to open links as a third party,
   without the ability to verify its handled domains. If this is the
   case, explain to users that, at that time when they select a web
   link, they cannot choose between a first-party app and your
   (third-party) app. Users need to manually associate the domains with
   your third-party app.

   In addition, consider introducing a dialog or trampoline activity
   that allows the user to open the link in the first-party app if the
   user prefers to do so, acting as a proxy. Before setting up such a
   dialog or trampoline activity, set up your app so that it has
   `package visibility <#>`__ into the
   first-party apps that match your app's web intent filter.

   .. rubric:: Test app links
      :name: testing

   When implementing the app linking feature, you should test the
   linking functionality to make sure the system can associate your app
   with your websites, and handle URL requests, as you expect.

   To test an existing statement file, you can use the `Statement List Generator and Tester <https://developers.google.cn/digital-asset-links/tools/generator>`__
   tool.

   .. rubric:: Confirm the list of hosts to verify
      :name: test-hosts

   When testing, you should confirm the list of associated hosts that
   the system should verify for your app. Make a list of all URLs whose
   corresponding intent filters include the following attributes and
   elements:

   -  ``android:scheme`` attribute with a value of ``http`` or ``https``
   -  ``android:host`` attribute with a domain URL pattern
   -  ``android.intent.action.VIEW`` action element
   -  ``android.intent.category.BROWSABLE`` category element

   Use this list to check that a Digital Asset Links JSON file is
   provided on each named host and subdomain.

   .. rubric:: Confirm the Digital Asset Links files
      :name: test-dal-files

   For each website, use the Digital Asset Links API to confirm that the
   Digital Asset Links JSON file is properly hosted and defined:

   .. code:: none

      https://digitalassetlinks.googleapis.com/v1/statements:list?
         source.web.site=https://domain.name:optional_port&
         relation=delegate_permission/common.handle_all_urls

   .. rubric:: Check link policies
      :name: check-link-policies

   As part of your testing process, you can check the current system
   settings for link handling. Use the following command to get a
   listing of existing link-handling policies for all apps on your
   connected device:

   .. code:: none

      adb shell dumpsys package domain-preferred-apps

   Or the following does the same thing:

   .. code:: none

      adb shell dumpsys package d

   **Note:** Make sure you wait at least 20 seconds after installation
   of your app to allow for the system to complete the verification
   process.

   The command returns a listing of each user or profile defined on the
   device, preceded by a header in the following format:

   .. code:: none

      App linkages for user 0:

   Following this header, the output uses the following format to list
   the link-handling settings for that user:

   .. code:: none

      Package: com.android.vending
      Domains: play.google.com market.android.com
      Status: always : 200000002

   This listing indicates which apps are associated with which domains
   for that user:

   -  ``Package`` - Identifies an app by its package name, as declared
      in its manifest.
   -  ``Domains`` - Shows the full list of hosts whose web links this
      app handles, using blank spaces as delimiters.
   -  ``Status`` - Shows the current link-handling setting for this app.
      An app that has passed verification, and whose manifest contains
      ``android:autoVerify="true"``, shows a status of ``always``. The
      hexadecimal number after this status is related to the Android
      system's record of the user‚Äôs app linkage preferences. This value
      does not indicate whether verification succeeded.

   **Note:** If a user changes the app link settings for an app before
   verification is complete, you may see a false positive for a
   successful verification, even though verification has failed. This
   verification failure, however, does not matter if the user explicitly
   enabled the app to open supported links without asking. This is
   because user preferences take precedence over programmatic
   verification (or lack of it). As a result, the link goes directly to
   your app, without showing a dialog, just as if verification had
   succeeded.

   .. rubric:: Test example
      :name: test-example

   For app link verification to succeed, the system must be able to
   verify your app with each of the websites that you specify in a given
   intent filter that meets the criteria for app links. The following
   example shows a manifest configuration with several app links
   defined:

   .. code:: prettyprint

      <application>

          <activity android:name=‚ÄùMainActivity‚Äù>
              <intent-filter android:autoVerify="true">
                  <action android:name="android.intent.action.VIEW" />
                  <category android:name="android.intent.category.DEFAULT" />
                  <category android:name="android.intent.category.BROWSABLE" />
                  <data android:scheme="https" />
                  <data android:scheme="https" />
                  <data android:host="www.example.com" />
                  <data android:host="mobile.example.com" />
              </intent-filter>
              <intent-filter>
                  <action android:name="android.intent.action.VIEW" />
                  <category android:name="android.intent.category.BROWSABLE" />
                  <data android:scheme="https" />
                  <data android:host="www.example2.com" />
              </intent-filter>
          </activity>

          <activity android:name=‚ÄùSecondActivity‚Äù>
              <intent-filter>
                  <action android:name="android.intent.action.VIEW" />
                  <category android:name="android.intent.category.DEFAULT" />
                  <category android:name="android.intent.category.BROWSABLE" />
                  <data android:scheme="https" />
                  <data android:host="account.example.com" />
              </intent-filter>
          </activity>

            <activity android:name=‚ÄùThirdActivity‚Äù>
              <intent-filter>
                  <action android:name="android.intent.action.VIEW" />
                  <category android:name="android.intent.category.DEFAULT" />
                  <data android:scheme="https" />
                  <data android:host="map.example.com" />
              </intent-filter>
              <intent-filter>
                  <action android:name="android.intent.action.VIEW" />
                  <category android:name="android.intent.category.BROWSABLE" />
                  <data android:scheme="market" />
                  <data android:host="example.com" />
              </intent-filter>
            </activity>

      </application>

   The list of hosts that the platform would attempt to verify from the
   above manifest is:

   .. code:: none

      www.example.com
      mobile.example.com
      www.example2.com
      account.example.com

   The list of hosts that the platform would not attempt to verify from
   the above manifest is:

   .. code:: none

      map.example.com (it does not have android.intent.category.BROWSABLE)
      market://example.com (it does not have either an "http" or "https" scheme)

   To learn more about statement lists, see `Creating a Statement List <https://developers.google.cn/digital-asset-links/v1/create-statement>`__.

   .. rubric:: Fix common implementation errors
      :name: fix-errors

   If you can't verify your Android App Links, check for the following
   common errors. This section uses ``example.com`` as a placeholder
   domain name; when performing these checks, substitute ``example.com``
   with your server's actual domain name.

   Incorrect intent filter set up
      Check to see whether you include a URL that your app doesn't own
      in an ``<intent-filter>`` element.
   Incorrect server configuration
      Check to your server's JSON configuration, and make sure the SHA
      value is correct.

      Also, check that ``example.com.`` (with the trailing period)
      serves the same content as ``example.com``.

   Server-side redirects
      The system doesn't verify **any** Android App Links for your app
      if you set up a redirect such as the following:

      -  ``http://example.com`` to ``https://example.com``
      -  ``example.com`` to ``www.example.com``

      This behavior protects your app's security.

   Server robustness
      Check whether your server can connect to your client apps.

   Non-verifiable links
      For testing purposes, you might intentionally add non-verifiable
      links. Keep in mind that, on ``Android 11`` and lower, these links
      cause the system to not verify **all** Android App Links for your
      app.

   Incorrect signature in assetlinks.json
      Verify that your signature is correct and matches the signature
      used to sign your app. Common mistakes include:

      -  Signing the app with a debug certificate and only having the
         release signature in ``assetlinks.json``.
      -  Having a lower case signature in ``assetlinks.json``. The
         signature should be in upper case.
      -  If you are using Play App Signing, make sure you're using the
         signature that Google uses to sign each of your releases. You
         can verify these details, including a complete JSON snippet, by
         following instructions about `declaring website associations <#web-assoc>`__.


Last updated 2024-05-03 UTC.


/Create App Links for Instant Apps
==================================

.. container:: devsite-article-body clearfix

   An Android Instant App is a small version of your app that runs
   without installation. Instead of installing an APK, users launch your
   app simply by clicking a URL. As such, all instant apps need to be
   accessible via a URL declared using Android App Links. This page
   explains how to use Android App Links for your `Android Instant Apps <#>`__.

   **Note:**\  If you're not building an instant app, then you don't
   need to read this guide‚Äîyou should instead create app links for your
   installable app by reading `Create Deep Links to App Content <#>`__.

   .. rubric:: App links overview
      :name: app_links_overview

   First, here's a summary of what you should already understand about
   app links.

   -  When you create an intent filter for activities in your app that
      allow the user to jump straight to a specific screen in your app
      with a URL link, this is known as a "deep link." Other apps can
      declare a similar URL intent filter, though, so the system might
      ask the user which app to open. To create these deep links, read
      `Create Deep Links to App Content <#>`__.
   -  When you publish an ``assetlinks.json`` file on the website that
      corresponds to your app's HTTP deep links, you verify that your
      app is the true owner of those URLs. Thus, you've converted your
      deep links into Android App Links, which ensure that your app
      instantly opens when the user clicks such a URL. To create app
      links, read `Verify Android App Links <#>`__.

   So, Android App Links are simply HTTP deep links that your website is
   verified to own so that the user doesn't need to choose which app to
   open. For a more specific description, see `differences between deep links and app links <#the-difference>`__.

   In both cases, however, the user must already have your app
   installed. If the user clicks one of your web site's links and they
   don't have your app installed (and no other app handles that URL
   intent), the URL is opened in a web browser. So, creating an Instant
   App solves this part‚Äîit allows users to open your app by simply
   clicking a URL, even if they don't have your app installed.

   When end users perform a Google search for your app, Google Search
   displays a URL with the "Instant" badge.

   .. rubric:: How app links for instant apps are different
      :name: how_app_links_for_instant_apps_are_different

   If you've already followed the guides to `Create Deep Links to App Content <#>`__ and `Verify Android App Links <#>`__, then you've
   already done most of the work necessary to make app links work with
   your instant app. There are just a couple extra rules when using app
   links for instant apps:

   -  All intent filters used as app links in your instant app must
      support both HTTP and HTTPS. For example:

      .. code:: prettyprint

         <intent-filter>
             <action android:name="android.intent.action.VIEW" />
             <category android:name="android.intent.category.DEFAULT" />
             <category android:name="android.intent.category.BROWSABLE" />
             <data android:scheme="http" android:host="www.example.com" />
             <data android:scheme="https" />
         </intent-filter>

      Notice that you don't need to include the ``host`` in the second
      ``<data>`` element because, within each ``<intent-filter>``
      element, all combinations of each ``<data>`` attribute are
      considered valid (so this intent filter *does* resolve
      ``https://www.example.com``).

   -  Only one instant app can be declared for each website domain.
      (This is unlike when creating app links for your installable app,
      which allows you to `associate a website with multiple apps <#multiple-apps>`__.)

   .. rubric:: Other reminders when creating app links
      :name: other_reminders_when_creating_app_links

   -  All HTTP URL intent filters in your instant app should be included
      in your installable app. This is important because once the user
      installs your full app, tapping a URL should always open the
      installed app, not the instant app.
   -  You must set ``autoVerify="true"`` in at least one intent filter
      in both the instant and the installable app. (See how to `enable automatic verification <#config-verify>`__.)
   -  You must publish one ``assetlinks.json`` for each domain (and
      subdomain supported by your app links, using the HTTPS protocol.
      (See how to `support app linking for multiple hosts <#multi-host>`__).
   -  The ``assetlinks.json`` file must be valid JSON, be served without
      redirects, and be accessible to bots (your ``robots.txt`` must
      allow crawling ``/.well-known/assetlinks.json``).
   -  Use of wildcards in your intent filter's host attribute is not
      recommended. (See how to `support app linking from multiple subdomains <#multi-subdomain>`__.)
   -  Custom host/scheme URLs should be declared with separate intent
      filters.
   -  Ensure that your app link URLs account for your top search results
      for your key terms.


Last updated 2023-01-11 UTC.


/Oerveiw: Interact with other apps
==================================

.. https://developer.android.google.cn/training/basics/intents

.. container:: devsite-article-body clearfix

   An Android app typically has several `activities <#>`__. Each activity displays
   a user interface that lets the user perform a specific task, such as
   viewing a map or taking a photo. To take the user from one activity
   to another, your app must use an `Intent <#>`__ to define your
   app's "intent" to do something. When you pass an ``Intent`` to the
   system with a method such as `startActivity() <#startActivity>`__,
   the system uses the ``Intent`` to identify and start the appropriate
   app component. Using intents even lets your app start an activity
   that is contained in a separate app.

   An ``Intent`` can be *explicit*, to start a specific
   `Activity <#>`__ instance, or
   *implicit*, to start any component that can handle the intended
   action, such as "capture a photo."

   The topics in this guide show you how to use an ``Intent`` to perform
   some basic interactions with other apps, such as starting another
   app, receiving a result from that app, and making your app able to
   respond to intents from other apps.

   .. rubric:: Topics
      :name: topics

   `Sending the user to another app <#>`__
      Shows you how to create implicit intents to launch other apps that
      can perform an action.
   `Get a result from an activity <#>`__
      Shows you how to start another activity and receive a result from
      the activity.
   `Allow other apps to start your activity <#>`__
      Shows you how to make activities in your app open for use by other
      apps by defining intent filters that declare the implicit intents
      your app accepts.
   `Package visibility filtering on Android <#>`__
      Shows you how to make other apps visible to your app if they
      aren't visible by default. Applies only to apps that target
      Android 11 (API level 30) or higher.
   `Fulfill common use cases while having limited package visibility <#>`__
      Shows several types of app interactions that might require you to
      update your app's manifest file so that other apps are visible to
      your app. Applies only to apps that target Android 11 (API level
      30) or higher.
   `Limit loading in on-device Android containers <#>`__
      Shows you how to limit your Play Store app from loading in a
      simulated Android environment app, also known as an on-device
      Android container.

   For additional information about the topics on this page, see the
   following:

   -  `Sharing simple data <#>`__
   -  `Sharing files <#>`__
   -  `Integrating Application with Intents <http://android-developers.blogspot.com/2009/11/integrating-application-with-intents.html>`__
      blog post
   -  `Intents and Intent Filters <#>`__


Last updated 2023-07-12 UTC.


/Intents and intent filters
===========================

.. container:: devsite-article-body clearfix

   An `Intent <#>`__ is a messaging
   object you can use to request an action from another `app component <#Components>`__. Although
   intents facilitate communication between components in several ways,
   there are three fundamental use cases:

   -  **Starting an activity**

      An `Activity <#>`__ represents a
      single screen in an app. You can start a new instance of an
      `Activity <#>`__ by passing an
      `Intent <#>`__ to
      `startActivity() <#startActivity>`__.
      The `Intent <#>`__ describes
      the activity to start and carries any necessary data.

      If you want to receive a result from the activity when it
      finishes, call
      `startActivityForResult() <#startActivityForResult>`__.
      Your activity receives the result as a separate
      `Intent <#>`__ object in your
      activity's
      `onActivityResult() <#onActivityResult>`__
      callback. For more information, see the
      `Activities <#>`__ guide.

   -  **Starting a service**

      A `Service <#>`__ is a component
      that performs operations in the background without a user
      interface. With Android 5.0 (API level 21) and later, you can
      start a service with
      `JobScheduler <#>`__.
      For more information about
      `JobScheduler <#>`__,
      see its
      `API-reference documentation <#>`__.

      For versions earlier than Android 5.0 (API level 21), you can
      start a service by using methods of the
      `Service <#>`__ class. You can
      start a service to perform a one-time operation (such as
      downloading a file) by passing an
      `Intent <#>`__ to
      `startService() <#startService>`__.
      The `Intent <#>`__ describes
      the service to start and carries any necessary data.

      If the service is designed with a client-server interface, you can
      bind to the service from another component by passing an
      `Intent <#>`__ to
      `bindService() <#bindService>`__.
      For more information, see the
      `Services <#>`__ guide.

   -  **Delivering a broadcast**

      A broadcast is a message that any app can receive. The system
      delivers various broadcasts for system events, such as when the
      system boots up or the device starts charging. You can deliver a
      broadcast to other apps by passing an
      `Intent <#>`__ to
      `sendBroadcast() <#sendBroadcast>`__
      or
      `sendOrderedBroadcast() <#sendOrderedBroadcast>`__.

   The rest of this page explains how intents work and how to use them.
   For related information, see `Interacting with Other Apps <#>`__ and `Sharing Content <#>`__.

   .. rubric:: Intent types
      :name: Types

   There are two types of intents:

   -  **Explicit intents** specify which component of which application
      will satisfy the intent, by specifying a full ``ComponentName``.
      You'll typically use an explicit intent to start a component in
      your own app, because you know the class name of the activity or
      service you want to start. For example, you might start a new
      activity within your app in response to a user action, or start a
      service to download a file in the background.
   -  **Implicit intents** do not name a specific component, but instead
      declare a general action to perform, which allows a component from
      another app to handle it. For example, if you want to show the
      user a location on a map, you can use an implicit intent to
      request that another capable app show a specified location on a
      map.

   Figure 1 shows how an intent is used when starting an activity. When
   the `Intent <#>`__ object names a
   specific activity component explicitly, the system immediately starts
   that component.

   .. container:: attempt-right

      
   .. image:: https://developer.android.google.cn/static/images/components/intent-filters_2x.png
      :class: android-image-dark-theme-background
      :width: 446px

      **Figure 1.** How an implicit intent is delivered through the
      system to start another activity: **[1]** *Activity A* creates an
      `Intent <#>`__ with an action
      description and passes it to
      `startActivity() <#startActivity>`__.
      **[2]** The Android System searches all apps for an intent filter
      that matches the intent. When a match is found, **[3]** the system
      starts the matching activity (*Activity B*) by invoking its
      `onCreate() <#onCreate>`__
      method and passing it the
      `Intent <#>`__.

   When you use an implicit intent, the Android system finds the
   appropriate component to start by comparing the contents of the
   intent to the *intent filters* declared in the `manifest file <#>`__ of other apps on the
   device. If the intent matches an intent filter, the system starts
   that component and delivers it the
   `Intent <#>`__ object. If
   multiple intent filters are compatible, the system displays a dialog
   so the user can pick which app to use.

   An intent filter is an expression in an app's manifest file that
   specifies the type of intents that the component would like to
   receive. For instance, by declaring an intent filter for an activity,
   you make it possible for other apps to directly start your activity
   with a certain kind of intent. Likewise, if you do *not* declare any
   intent filters for an activity, then it can be started only with an
   explicit intent.

   **Caution:** To ensure that your app is secure, always use an
   explicit intent when starting a
   `Service <#>`__ and do not declare
   intent filters for your services. Using an implicit intent to start a
   service is a security hazard because you can't be certain what
   service will respond to the intent, and the user can't see which
   service starts. Beginning with Android 5.0 (API level 21), the system
   throws an exception if you call
   `bindService() <#bindService>`__
   with an implicit intent.

   .. rubric:: Building an intent
      :name: Building

   An `Intent <#>`__ object carries
   information that the Android system uses to determine which component
   to start (such as the exact component name or component category that
   should receive the intent), plus information that the recipient
   component uses in order to properly perform the action (such as the
   action to take and the data to act upon).

   The primary information contained in an
   `Intent <#>`__ is the following:

   **Component name**
      The name of the component to start.

      This is optional, but it's the critical piece of information that
      makes an intent *explicit*, meaning that the intent should be
      delivered only to the app component defined by the component name.
      Without a component name, the intent is *implicit* and the system
      decides which component should receive the intent based on the
      other intent information (such as the action, data, and
      category‚Äîdescribed below). If you need to start a specific
      component in your app, you should specify the component name.

      **Note:** When starting a
      `Service <#>`__, *always specify
      the component name*. Otherwise, you cannot be certain what service
      will respond to the intent, and the user cannot see which service
      starts.

      This field of the
      `Intent <#>`__ is a
      `ComponentName <#>`__
      object, which you can specify using a fully qualified class name
      of the target component, including the package name of the app,
      for example, ``com.example.ExampleActivity``. You can set the
      component name with
      `setComponent() <#setComponent>`__,
      `setClass() <#setClass>`__,
      `setClassName() <#setClassName>`__,
      or with the `Intent <#>`__
      constructor.

   **Action**
      A string that specifies the generic action to perform (such as
      *view* or *pick*).

      In the case of a broadcast intent, this is the action that took
      place and is being reported. The action largely determines how the
      rest of the intent is structured‚Äîparticularly the information that
      is contained in the data and extras.

      You can specify your own actions for use by intents within your
      app (or for use by other apps to invoke components in your app),
      but you usually specify action constants defined by the
      `Intent <#>`__ class or other
      framework classes. Here are some common actions for starting an
      activity:

      `ACTION_VIEW <#ACTION_VIEW>`__
         Use this action in an intent with
         `startActivity() <#startActivity>`__
         when you have some information that an activity can show to the
         user, such as a photo to view in a gallery app, or an address
         to view in a map app.
      `ACTION_SEND <#ACTION_SEND>`__
         Also known as the *share* intent, you should use this in an
         intent with
         `startActivity() <#startActivity>`__
         when you have some data that the user can share through another
         app, such as an email app or social sharing app.

      See the `Intent <#>`__ class
      reference for more constants that define generic actions. Other
      actions are defined elsewhere in the Android framework, such as in
      `Settings <#>`__ for
      actions that open specific screens in the system's Settings app.

      You can specify the action for an intent with
      `setAction() <#setAction>`__
      or with an `Intent <#>`__
      constructor.

      If you define your own actions, be sure to include your app's
      package name as a prefix, as shown in the following example:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  const val ACTION_TIMETRAVEL = "com.example.action.TIMETRAVEL"

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  static final String ACTION_TIMETRAVEL = "com.example.action.TIMETRAVEL";

   **Data**
      The URI (a `Uri <#>`__ object) that
      references the data to be acted on and/or the MIME type of that
      data. The type of data supplied is generally dictated by the
      intent's action. For example, if the action is
      `ACTION_EDIT <#ACTION_EDIT>`__,
      the data should contain the URI of the document to edit.

      When creating an intent, it's often important to specify the type
      of data (its MIME type) in addition to its URI. For example, an
      activity that's able to display images probably won't be able to
      play an audio file, even though the URI formats could be similar.
      Specifying the MIME type of your data helps the Android system
      find the best component to receive your intent. However, the MIME
      type can sometimes be inferred from the URI‚Äîparticularly when the
      data is a ``content:`` URI. A ``content:`` URI indicates the data
      is located on the device and controlled by a
      `ContentProvider <#>`__,
      which makes the data MIME type visible to the system.

      To set only the data URI, call
      `setData() <#setData>`__.
      To set only the MIME type, call
      `setType() <#setType>`__.
      If necessary, you can set both explicitly with
      `setDataAndType() <#setDataAndType>`__.

      **Caution:** If you want to set both the URI and MIME type,
      *don't* call
      `setData() <#setData>`__
      and
      `setType() <#setType>`__
      because they each nullify the value of the other. Always use
      `setDataAndType() <#setDataAndType>`__
      to set both URI and MIME type.

   **Category**
      A string containing additional information about the kind of
      component that should handle the intent. Any number of category
      descriptions can be placed in an intent, but most intents do not
      require a category. Here are some common categories:

      `CATEGORY_BROWSABLE <#CATEGORY_BROWSABLE>`__
         The target activity allows itself to be started by a web
         browser to display data referenced by a link, such as an image
         or an e-mail message.
      `CATEGORY_LAUNCHER <#CATEGORY_LAUNCHER>`__
         The activity is the initial activity of a task and is listed in
         the system's application launcher.

      See the `Intent <#>`__ class
      description for the full list of categories.

      You can specify a category with
      `addCategory() <#addCategory>`__.

   These properties listed above (component name, action, data, and
   category) represent the defining characteristics of an intent. By
   reading these properties, the Android system is able to resolve which
   app component it should start. However, an intent can carry
   additional information that does not affect how it is resolved to an
   app component. An intent can also supply the following information:

   **Extras**
      Key-value pairs that carry additional information required to
      accomplish the requested action. Just as some actions use
      particular kinds of data URIs, some actions also use particular
      extras.

      You can add extra data with various
      `putExtra() <#putExtra>`__
      methods, each accepting two parameters: the key name and the
      value. You can also create a
      `Bundle <#>`__ object with all the
      extra data, then insert the
      `Bundle <#>`__ in the
      `Intent <#>`__ with
      `putExtras() <#putExtras>`__.

      For example, when creating an intent to send an email with
      `ACTION_SEND <#ACTION_SEND>`__,
      you can specify the *to* recipient with the
      `EXTRA_EMAIL <#EXTRA_EMAIL>`__
      key, and specify the *subject* with the
      `EXTRA_SUBJECT <#EXTRA_SUBJECT>`__
      key.

      The `Intent <#>`__ class
      specifies many ``EXTRA_*`` constants for standardized data types.
      If you need to declare your own extra keys (for intents that your
      app receives), be sure to include your app's package name as a
      prefix, as shown in the following example:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  const val EXTRA_GIGAWATTS = "com.example.EXTRA_GIGAWATTS"

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  static final String EXTRA_GIGAWATTS = "com.example.EXTRA_GIGAWATTS";

      **Caution**: Do not use
      `Parcelable <#>`__ or
      `Serializable <#>`__ data when
      sending an intent that you expect another app to receive. If an
      app attempts to access data in a
      `Bundle <#>`__ object but does not
      have access to the parceled or serialized class, the system raises
      a
      `RuntimeException <#>`__.

   **Flags**
      Flags are defined in the
      `Intent <#>`__ class that
      function as metadata for the intent. The flags may instruct the
      Android system how to launch an activity (for example, which
      `task <#>`__ the activity
      should belong to) and how to treat it after it's launched (for
      example, whether it belongs in the list of recent activities).

      For more information, see the
      `setFlags() <#setFlags>`__
      method.

   .. rubric:: Example explicit intent
      :name: ExampleExplicit

   An explicit intent is one that you use to launch a specific app
   component, such as a particular activity or service in your app. To
   create an explicit intent, define the component name for the
   `Intent <#>`__ object‚Äîall other
   intent properties are optional.

   For example, if you built a service in your app, named
   ``DownloadService``, designed to download a file from the web, you
   can start it with the following code:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Executed in an Activity, so 'this' is the Context
               // The fileUrl is a string URL, such as "http://www.example.com/image.png"
               val downloadIntent = Intent(this, DownloadService::class.java).apply {
                   data = Uri.parse(fileUrl)
               }
               startService(downloadIntent)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Executed in an Activity, so 'this' is the Context
               // The fileUrl is a string URL, such as "http://www.example.com/image.png"
               Intent downloadIntent = new Intent(this, DownloadService.class);
               downloadIntent.setData(Uri.parse(fileUrl));
               startService(downloadIntent);

   The `Intent(Context, Class) <#Intent>`__ constructor supplies the app
   `Context <#>`__ and the component a `Class <#>`__ object. As
   such, this intent explicitly starts the ``DownloadService`` class in
   the app.

   For more information about building and starting a service, see the
   `Services <#>`__ guide.

   .. rubric:: Example implicit intent
      :name: ExampleSend

   An implicit intent specifies an action that can invoke any app on the
   device able to perform the action. Using an implicit intent is useful
   when your app cannot perform the action, but other apps probably can
   and you'd like the user to pick which app to use.

   For example, if you have content that you want the user to share with
   other people, create an intent with the `ACTION_SEND <#ACTION_SEND>`__
   action and add extras that specify the content to share. When you
   call `startActivity() <#startActivity>`__
   with that intent, the user can pick an app through which to share the
   content.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Create the text message with a string.
               val sendIntent = Intent().apply {
                   action = Intent.ACTION_SEND
                   putExtra(Intent.EXTRA_TEXT, textMessage)
                   type = "text/plain"
               }

               // Try to invoke the intent.
               try {
                   startActivity(sendIntent)
               } catch (e: ActivityNotFoundException) {
                   // Define what your app should do if no activity can handle the intent.
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create the text message with a string.
               Intent sendIntent = new Intent();
               sendIntent.setAction(Intent.ACTION_SEND);
               sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);
               sendIntent.setType("text/plain");

               // Try to invoke the intent.
               try {
                   startActivity(sendIntent);
               } catch (ActivityNotFoundException e) {
                   // Define what your app should do if no activity can handle the intent.
               }

   When `startActivity() <#startActivity>`__
   is called, the system examines all of the installed apps to determine
   which ones can handle this kind of intent (an intent with the
   `ACTION_SEND <#ACTION_SEND>`__
   action and that carries "text/plain" data). If there's only one app
   that can handle it, that app opens immediately and is given the
   intent. If no other apps can handle it, your app can catch the
   `ActivityNotFoundException <#>`__
   that occurs. If multiple activities accept the intent, the system
   displays a dialog such as the one shown in Figure 2, so the user can
   pick which app to use.

   More information about launching other apps is also provided in the
   guide about `sending the user to another app <#>`__.

   .. container:: attempt-right

      .. image:: https://developer.android.google.cn/static/images/training/basics/intent-chooser.png

      **Figure 2.** A chooser dialog.

   .. rubric:: Forcing an app chooser
      :name: ForceChooser

   When there is more than one app that responds to your implicit
   intent, the user can select which app to use and make that app the
   default choice for the action. The ability to select a default is
   helpful when performing an action for which the user probably wants
   to use the same app every time, such as when opening a web page
   (users often prefer just one web browser).

   However, if multiple apps can respond to the intent and the user
   might want to use a different app each time, you should explicitly
   show a chooser dialog. The chooser dialog asks the user to select
   which app to use for the action (the user cannot select a default app
   for the action). For example, when your app performs "share" with the
   `ACTION_SEND <#ACTION_SEND>`__
   action, users may want to share using a different app depending on
   their current situation, so you should always use the chooser dialog,
   as shown in Figure 2.

   To show the chooser, create an `Intent <#>`__ using
   `createChooser() <#createChooser>`__
   and pass it to `startActivity() <#startActivity>`__,
   as shown in the following example. This example displays a dialog
   with a list of apps that respond to the intent passed to the
   `createChooser() <#createChooser>`__
   method and uses the supplied text as the dialog title.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val sendIntent = Intent(Intent.ACTION_SEND)
               ...

               // Always use string resources for UI text.
               // This says something like "Share this photo with"
               val title: String = resources.getString(R.string.chooser_title)
               // Create intent to show the chooser dialog
               val chooser: Intent = Intent.createChooser(sendIntent, title)

               // Verify the original intent will resolve to at least one activity
               if (sendIntent.resolveActivity(packageManager) != null) {
                   startActivity(chooser)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Intent sendIntent = new Intent(Intent.ACTION_SEND);
               ...

               // Always use string resources for UI text.
               // This says something like "Share this photo with"
               String title = getResources().getString(R.string.chooser_title);
               // Create intent to show the chooser dialog
               Intent chooser = Intent.createChooser(sendIntent, title);

               // Verify the original intent will resolve to at least one activity
               if (sendIntent.resolveActivity(getPackageManager()) != null) {
                   startActivity(chooser);
               }

   .. rubric:: Detect unsafe intent launches
      :name: DetectUnsafeIntentLaunches

   Your app might launch intents to navigate between components inside
   of your app, or to perform an action on behalf of another app. To
   improve platform security, ``Android 12`` (API ``level 31``) and higher
   provide a debugging feature that warns you if your app performs an
   unsafe launch of an intent. For example, your app might perform an
   unsafe launch of a *nested intent*, which is an intent that is passed
   as an extra in another intent.

   If your app performs both of the following actions, the system
   detects an unsafe intent launch, and a
   `StrictMode <#>`__ violation occurs:

   #. Your app unparcels a nested intent from the extras of a delivered
      intent.
   #. Your app immediately starts an `app component <#Components>`__ using
      that nested intent, such as passing the intent into
      `startActivity() <#startActivity>`__,
      `startService() <#startService>`__,
      or
      `bindService() <#bindService>`__.

   For more details on how to identify this situation and make changes
   to your app, read the blog post about `Android Nesting Intents <https://medium.com/androiddevelopers/android-nesting-intents-e472fafc1933>`__
   on Medium.

   .. rubric:: Check for unsafe intent launches
      :name: CheckForUnsafeIntentLaunches

   To check for unsafe intent launches in your app, call
   `detectUnsafeIntentLaunch() <#detectUnsafeIntentLaunch>`__
   when you configure your ``VmPolicy``, as shown in the following code
   snippet. If your app detects a StrictMode violation, you might want
   to stop app execution to protect potentially sensitive information.

   **Note:**\  If your app targets ``Android 12`` and uses the
   `detectAll() <#detectAll>`__
   method in its ``VmPolicy`` definition, the
   ``detectUnsafeIntentLaunch()`` method is called automatically.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun onCreate() {
                   StrictMode.setVmPolicy(VmPolicy.Builder()
                       // Other StrictMode checks that you've previously added.
                       // ...
                       .detectUnsafeIntentLaunch()
                       .penaltyLog()
                       // Consider also adding penaltyDeath()
                       .build())
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               protected void onCreate() {
                   StrictMode.setVmPolicy(new VmPolicy.Builder()
                       // Other StrictMode checks that you've previously added.
                       // ...
                       .detectUnsafeIntentLaunch()
                       .penaltyLog()
                       // Consider also adding penaltyDeath()
                       .build());
               }

   .. rubric:: Use intents more responsibly
      :name: UseIntentsMoreResponsibly

   To minimize the chance of an unsafe intent launch, and a StrictMode
   violation, follow these best practices.

   **Copy only the essential extras within intents, and perform any
   necessary sanitation and validation.** Your app might copy the extras
   from one intent to another intent that is used to launch a new
   component. This occurs when your app calls
   `putExtras(Intent) <#putExtras>`__
   or
   `putExtras(Bundle) <#putExtras>`__.
   If your app performs one of these operations, copy only the extras
   that the receiving component expects. If the other intent (that
   receives the copy) launches a component that isn't
   `exported <#exported>`__,
   sanitize and validate the extras before copying them to the intent
   that launches the component.

   **Don't export your app's components unnecessarily.** For example, if
   you intend to launch an app component using an internal nested
   intent, set that component's ``android:exported`` attribute to
   ``false``.

   **Use a**
   `PendingIntent <#>`__
   **instead of a nested intent.** That way, when another app unparcels
   the ``PendingIntent`` of its containing ``Intent``, the other app can
   launch the ``PendingIntent`` using the identity of your app. This
   configuration allows the other app to safely launch any component,
   including a non-exported component, in your app.

   The diagram in figure 2 shows how the system passes control from your
   (client) app to another (service) app, and back to your app:

   #. Your app creates an intent that invokes an activity in another
      app. Within that intent, you add a ``PendingIntent`` object as an
      extra. This pending intent invokes a component in your app; this
      component isn't exported.
   #. Upon receiving your app's intent, the other app extracts the
      nested ``PendingIntent`` object.
   #. The other app invokes the ``send()`` method on the
      ``PendingIntent`` object.
   #. After passing control back to your app, the system invokes the
      pending intent using your app's context.

   .. image:: https://developer.android.google.cn/static/images/guide/components/nested-pending-intent.svg
      :class: android-image-dark-theme-background
      :width: 800px

   **Figure 2.** Diagram of inter-app communication when using a nested
   pending intent.

   .. rubric:: Receiving an implicit intent
      :name: Receiving

   To advertise which implicit intents your app can receive, declare one
   or more intent filters for each of your app components with an
   ``<intent-filter>``
   element in your `manifest file <#>`__. Each intent filter
   specifies the type of intents it accepts based on the intent's
   action, data, and category. The system delivers an implicit intent to
   your app component only if the intent can pass through one of your
   intent filters.

   **Note:** An explicit intent is always delivered to its target,
   regardless of any intent filters the component declares.

   An app component should declare separate filters for each unique job
   it can do. For example, one activity in an image gallery app may have
   two filters: one filter to view an image, and another filter to edit
   an image. When the activity starts, it inspects the
   `Intent <#>`__ and decides how to
   behave based on the information in the
   `Intent <#>`__ (such as to show
   the editor controls or not).

   Each intent filter is defined by an ``<intent-filter>``
   element in the app's manifest file, nested in the corresponding app
   component (such as an ``<activity>`` element).

   In each app component that includes an ``<intent-filter>`` element,
   explicitly set a value for
   `android:exported <#exported>`__.
   This attribute indicates whether the app component is accessible to
   other apps. In some situations, such as activities whose intent
   filters include the
   `LAUNCHER <#CATEGORY_LAUNCHER>`__
   category, it's useful to set this attribute to ``true``. Otherwise,
   it's safer to set this attribute to ``false``.

   **Warning:** If an activity, service, or broadcast receiver in your
   app uses intent filters and doesn't explicitly set the value for
   ``android:exported``, your app can't be installed on a device that
   runs ``Android 12`` or higher.

   Inside the
   ``<intent-filter>``,
   you can specify the type of intents to accept using one or more of
   these three elements:

   ``<action>``
      Declares the intent action accepted, in the ``name`` attribute.
      The value must be the literal string value of an action, not the
      class constant.
   ``<data>``
      Declares the type of data accepted, using one or more attributes
      that specify various aspects of the data URI (``scheme``,
      ``host``, ``port``, ``path``) and MIME type.
   ``<category>``
      Declares the intent category accepted, in the ``name`` attribute.
      The value must be the literal string value of an action, not the
      class constant.

      **Note:** To receive implicit intents, you *must include* the
      `CATEGORY_DEFAULT <#CATEGORY_DEFAULT>`__
      category in the intent filter. The methods
      `startActivity() <#startActivity>`__
      and
      `startActivityForResult() <#startActivityForResult>`__
      treat all intents as if they declared the
      `CATEGORY_DEFAULT <#CATEGORY_DEFAULT>`__
      category. If you do not declare this category in your intent
      filter, no implicit intents will resolve to your activity.

   For example, here's an activity declaration with an intent filter to
   receive an
   `ACTION_SEND <#ACTION_SEND>`__
   intent when the data type is text:

   .. code:: prettyprint

      <activity android:name="ShareActivity" android:exported="false">
          <intent-filter>
              <action android:name="android.intent.action.SEND"/>
              <category android:name="android.intent.category.DEFAULT"/>
              <data android:mimeType="text/plain"/>
          </intent-filter>
      </activity>

   You can create a filter that includes more than one instance of
   ``<action>``,
   ``<data>``, or
   ``<category>``. If you
   do, you need to be certain that the component can handle any and all
   combinations of those filter elements.

   When you want to handle multiple kinds of intents, but only in
   specific combinations of action, data, and category type, then you
   need to create multiple intent filters.

   An implicit intent is tested against a filter by comparing the intent
   to each of the three elements. To be delivered to the component, the
   intent must pass all three tests. If it fails to match even one of
   them, the Android system won't deliver the intent to the component.
   However, because a component may have multiple intent filters, an
   intent that does not pass through one of a component's filters might
   make it through on another filter. More information about how the
   system resolves intents is provided in the section below about
   `Intent Resolution <#Resolution>`__.

   .. caution::

      **Caution:** Using an intent filter isn't a secure way to prevent
      other apps from starting your components. Although intent filters
      restrict a component to respond to only certain kinds of implicit
      intents, another app can potentially start your app component by
      using an explicit intent if the developer determines your
      component names. If it's important that *only your own app* is
      able to start one of your components, do not declare intent
      filters in your manifest. Instead, set the
      `exported <#exported>`__
      attribute to ``"false"`` for that component.

      Similarly, to avoid inadvertently running a different app's
      `Service <#>`__, always use an
      explicit intent to start your own service.

   **Note:** For all activities, you must declare your intent filters in
   the manifest file. However, filters for broadcast receivers can be
   registered dynamically by calling
   `registerReceiver() <#registerReceiver>`__.
   You can then unregister the receiver with
   `unregisterReceiver() <#unregisterReceiver>`__.
   Doing so allows your app to listen for specific broadcasts during
   only a specified period of time while your app is running.

   .. rubric:: Example filters
      :name: ExampleFilters

   To demonstrate some of the intent filter behaviors, here is an
   example from the manifest file of a social-sharing app:

   .. code:: prettyprint

      <activity android:name="MainActivity" android:exported="true">
          <!-- This activity is the main entry, should appear in app launcher -->
          <intent-filter>
              <action android:name="android.intent.action.MAIN" />
              <category android:name="android.intent.category.LAUNCHER" />
          </intent-filter>
      </activity>

      <activity android:name="ShareActivity" android:exported="false">
          <!-- This activity handles "SEND" actions with text data -->
          <intent-filter>
              <action android:name="android.intent.action.SEND"/>
              <category android:name="android.intent.category.DEFAULT"/>
              <data android:mimeType="text/plain"/>
          </intent-filter>
          <!-- This activity also handles "SEND" and "SEND_MULTIPLE" with media data -->
          <intent-filter>
              <action android:name="android.intent.action.SEND"/>
              <action android:name="android.intent.action.SEND_MULTIPLE"/>
              <category android:name="android.intent.category.DEFAULT"/>
              <data android:mimeType="application/vnd.google.panorama360+jpg"/>
              <data android:mimeType="image/*"/>
              <data android:mimeType="video/*"/>
          </intent-filter>
      </activity>

   The first activity, ``MainActivity``, is the app's main entry
   point‚Äîthe activity that opens when the user initially launches the
   app with the launcher icon:

   -  The
      `ACTION_MAIN <#ACTION_MAIN>`__
      action indicates this is the main entry point and does not expect
      any intent data.
   -  The
      `CATEGORY_LAUNCHER <#CATEGORY_LAUNCHER>`__
      category indicates that this activity's icon should be placed in
      the system's app launcher. If the
      ``<activity>``
      element does not specify an icon with ``icon``, then the system
      uses the icon from the
      ``<application>``
      element.

   These two must be paired together in order for the activity to appear
   in the app launcher.

   The second activity, ``ShareActivity``, is intended to facilitate
   sharing text and media content. Although users might enter this
   activity by navigating to it from ``MainActivity``, they can also
   enter ``ShareActivity`` directly from another app that issues an
   implicit intent matching one of the two intent filters.

   **Note:** The MIME type,
   `application/vnd.google.panorama360+jpg <https://developers.google.cn/panorama/android/>`__,
   is a special data type that specifies panoramic photos, which you can
   handle with the `Google panorama <https://developers.google.cn/android/reference/com/google/android/gms/panorama/package-summary>`__
   APIs.

   .. rubric:: Match intents to other apps' intent filters
      :name: match-intent-filter

   If another app targets ``Android 13`` (API ``level 33``) or higher, it can
   handle your app's intent only if your intent matches the actions and
   categories of an ``<intent-filter>`` element in that other app. If
   the system doesn't find a match, it throws an
   `ActivityNotFoundException <#>`__.
   The sending app must handle this exception.

   Similarly, if you update your app so that it targets ``Android 13`` or
   higher, all intents originating from external apps are delivered to
   an exported component of your app only if that intent matches the
   actions and categories of an ``<intent-filter>`` element that your
   app declares. This behavior occurs regardless of the sending app's
   target SDK version.

   In the following cases, intent matching isn't enforced:

   -  Intents delivered to components that don't declare any intent
      filters.
   -  Intents originating from within the same app.
   -  Intents originating from the system; that is, intents being sent
      from the "system UID" (uid=1000). System apps include
      ``system_server`` and apps that set ``android:sharedUserId`` to
      ``android.uid.system``.
   -  Intents originating from root.

   Learn more about `intent matching <#imatch>`__.

   .. rubric:: Using a pending intent
      :name: PendingIntent

   A `PendingIntent <#>`__ object
   is a wrapper around an
   `Intent <#>`__ object. The
   primary purpose of a
   `PendingIntent <#>`__ is to
   grant permission to a foreign application to use the contained
   `Intent <#>`__ as if it were
   executed from your app's own process.

   Major use cases for a pending intent include the following:

   -  Declaring an intent to be executed when the user performs an
      action with your
      `Notification <#>`__ (the Android
      system's
      `NotificationManager <#>`__
      executes the `Intent <#>`__).
   -  Declaring an intent to be executed when the user performs an
      action with your `App Widget <#>`__ (the
      Home screen app executes the
      `Intent <#>`__).
   -  Declaring an intent to be executed at a specified future time (the
      Android system's
      `AlarmManager <#>`__
      executes the `Intent <#>`__).

   Just as each `Intent <#>`__
   object is designed to be handled by a specific type of app component
   (either an `Activity <#>`__, a
   `Service <#>`__, or a
   `BroadcastReceiver <#>`__),
   so too must a
   `PendingIntent <#>`__ be
   created with the same consideration. When using a pending intent,
   your app doesn't execute the intent with a call such as
   `startActivity() <#startActivity>`__.
   Instead, you must declare the intended component type when you create
   the `PendingIntent <#>`__ by
   calling the respective creator method:

   -  `PendingIntent.getActivity() <#getActivity>`__
      for an `Intent <#>`__ that
      starts an `Activity <#>`__.
   -  `PendingIntent.getService() <#getService>`__
      for an `Intent <#>`__ that
      starts a `Service <#>`__.
   -  `PendingIntent.getBroadcast() <#getBroadcast>`__
      for an `Intent <#>`__ that
      starts a
      `BroadcastReceiver <#>`__.

   Unless your app is *receiving* pending intents from other apps, the
   above methods to create a
   `PendingIntent <#>`__ are
   probably the only
   `PendingIntent <#>`__ methods
   you'll ever need.

   Each method takes the current app
   `Context <#>`__, the
   `Intent <#>`__ you want to wrap,
   and one or more flags that specify how the intent should be used
   (such as whether the intent can be used more than once).

   For more information about using pending intents, see the
   documentation for each of the respective use cases, such as in the
   `Notifications <#>`__ and `App Widgets <#>`__ API guides.

   .. rubric:: Specify mutability
      :name: DeclareMutabilityPendingIntent

   If your app targets ``Android 12`` or higher, you must specify the
   mutability of each ``PendingIntent`` object that your app creates. To
   declare that a given ``PendingIntent`` object is mutable or
   immutable, use the
   `PendingIntent.FLAG_MUTABLE <#FLAG_MUTABLE>`__
   or
   `PendingIntent.FLAG_IMMUTABLE <#FLAG_IMMUTABLE>`__
   flag, respectively.

   If your app attempts to create a ``PendingIntent`` object without
   setting either mutability flag, the system throws an
   `IllegalArgumentException <#>`__,
   and the following message appears in
   `Logcat <#>`__:

   .. code:: devsite-click-to-copy

      PACKAGE_NAME: Targeting S+ (version 31 and above) requires that one of \
      FLAG_IMMUTABLE or FLAG_MUTABLE be specified when creating a PendingIntent.

      Strongly consider using FLAG_IMMUTABLE, only use FLAG_MUTABLE if \
      some functionality depends on the PendingIntent being mutable, e.g. if \
      it needs to be used with inline replies or bubbles.

   .. rubric:: Create immutable pending intents whenever possible
      :name: CreateImmutablePendingIntents

   In most cases, your app should create immutable ``PendingIntent``
   objects, as shown in the following code snippet. If a
   ``PendingIntent`` object is immutable, then other apps cannot modify
   the intent to adjust the result of invoking the intent.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val pendingIntent = PendingIntent.getActivity(applicationContext,
                       REQUEST_CODE, intent,
                       /* flags */ PendingIntent.FLAG_IMMUTABLE)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               PendingIntent pendingIntent = PendingIntent.getActivity(getApplicationContext(),
                       REQUEST_CODE, intent,
                       /* flags */ PendingIntent.FLAG_IMMUTABLE);

   However, certain use cases require mutable ``PendingIntent`` objects
   instead:

   -  Supporting `direct reply actions in notifications <#reply-action>`__.
      The direct reply requires a change to the clip data in the
      PendingIntent object that's associated with the reply. Usually,
      you request this change by passing ``FILL_IN_CLIP_DATA`` as a flag
      to the
      `fillIn() <#fillIn>`__
      method.
   -  Associating notifications with the Android Auto framework, using
      instances of
      `CarAppExtender <#>`__.
   -  Placing conversations in `bubbles <#>`__
      using instances of ``PendingIntent``. A mutable ``PendingIntent``
      object allows the system to apply the correct flags, such as
      `FLAG_ACTIVITY_MULTIPLE_TASK <#FLAG_ACTIVITY_MULTIPLE_TASK>`__
      and
      `FLAG_ACTIVITY_NEW_DOCUMENT <#FLAG_ACTIVITY_NEW_DOCUMENT>`__.
   -  Requesting device location information by calling
      `requestLocationUpdates() <#requestLocationUpdates>`__
      or similar APIs. The mutable ``PendingIntent`` object allows the
      system to add intent extras that represent location lifecycle
      events. These events include a change in location and a provider
      becoming available.
   -  Scheduling alarms using
      `AlarmManager <#>`__. The
      mutable ``PendingIntent`` object allows the system to add the
      `EXTRA_ALARM_COUNT <#EXTRA_ALARM_COUNT>`__
      intent extra. This extra represents the number of times that a
      repeating alarm has been triggered. By containing this extra, the
      intent can accurately notify an app as to whether a repeating
      alarm was triggered multiple times, such as when the device was
      asleep.

   If your app creates a mutable ``PendingIntent`` object, it's strongly
   recommended that you use an `explicit intent <#ExampleExplicit>`__
   and fill in the
   `ComponentName <#>`__.
   That way, whenever another app invokes the ``PendingIntent`` and
   passes control back to your app, the same component in your app
   always starts.

   .. rubric:: Use explicit intents within pending intents
      :name: UseExplicitWithinPendingIntent

   To better define how other apps can use your app's pending intents,
   always wrap a pending intent around an `explicit intent <#ExampleExplicit>`__. To help follow this best practice, do
   the following:

   #. Check that the action, package, and component fields of the base
      intent are set.

   #. Use
      `FLAG_IMMUTABLE <#FLAG_IMMUTABLE>`__,
      added in Android 6.0 (API level 23), to create pending intents.
      This flag prevents apps that receive a ``PendingIntent`` from
      filling in unpopulated properties. If your app's ``minSdkVersion``
      is ``22`` or lower, you can provide safety and compatibility
      together using the following code:

      .. code:: prettyprint

         if (Build.VERSION.SDK_INT >= 23) {
           // Create a PendingIntent using FLAG_IMMUTABLE.
         } else {
           // Existing code that creates a PendingIntent.
         }

   .. rubric:: Intent resolution
      :name: Resolution

   When the system receives an implicit intent to start an activity, it
   searches for the best activity for the intent by comparing it to
   intent filters based on three aspects:

   -  Action.
   -  Data (both URI and data type).
   -  Category.

   The following sections describe how intents are matched to the
   appropriate components according to the intent filter declaration in
   an app's manifest file.

   .. rubric:: Action test
      :name: ActionTest

   To specify accepted intent actions, an intent filter can declare zero
   or more ``<action>``
   elements, as shown in the following example:

   .. code:: prettyprint

      <intent-filter>
          <action android:name="android.intent.action.EDIT" />
          <action android:name="android.intent.action.VIEW" />
          ...
      </intent-filter>

   To pass this filter, the action specified in the
   `Intent <#>`__ must match one of
   the actions listed in the filter.

   If the filter does not list any actions, there is nothing for an
   intent to match, so all intents fail the test. However, if an
   `Intent <#>`__ does not specify
   an action, it passes the test as long as the filter contains at least
   one action.

   .. rubric:: Category test
      :name: CategoryTest

   To specify accepted intent categories, an intent filter can declare
   zero or more
   ``<category>``
   elements, as shown in the following example:

   .. code:: prettyprint

      <intent-filter>
          <category android:name="android.intent.category.DEFAULT" />
          <category android:name="android.intent.category.BROWSABLE" />
          ...
      </intent-filter>

   For an intent to pass the category test, every category in the
   `Intent <#>`__ must match a
   category in the filter. The reverse is not necessary‚Äîthe intent
   filter may declare more categories than are specified in the
   `Intent <#>`__ and the
   `Intent <#>`__ still passes.
   Therefore, an intent with no categories always passes this test,
   regardless of what categories are declared in the filter.

   **Note:** Android automatically applies the
   `CATEGORY_DEFAULT <#CATEGORY_DEFAULT>`__
   category to all implicit intents passed to
   `startActivity() <#startActivity>`__
   and
   `startActivityForResult() <#startActivityForResult>`__.
   If you want your activity to receive implicit intents, it must
   include a category for ``"android.intent.category.DEFAULT"`` in its
   intent filters, as shown in the previous ``<intent-filter>`` example.

   .. rubric:: Data test
      :name: DataTest

   To specify accepted intent data, an intent filter can declare zero or
   more ``<data>`` elements,
   as shown in the following example:

   .. code:: prettyprint

      <intent-filter>
          <data android:mimeType="video/mpeg" android:scheme="http" ... />
          <data android:mimeType="audio/mpeg" android:scheme="http" ... />
          ...
      </intent-filter>

   Each ``<data>`` element can
   specify a URI structure and a data type (MIME media type). Each part
   of the URI is a separate attribute: ``scheme``, ``host``, ``port``,
   and ``path``:

   ``<scheme>://<host>:<port>/<path>``

   The following example shows possible values for these attributes:

   ``content://com.example.project:200/folder/subfolder/etc``

   In this URI, the scheme is ``content``, the host is
   ``com.example.project``, the port is ``200``, and the path is
   ``folder/subfolder/etc``.

   Each of these attributes is optional in a
   ``<data>`` element, but
   there are linear dependencies:

   -  If a scheme is not specified, the host is ignored.
   -  If a host is not specified, the port is ignored.
   -  If both the scheme and host are not specified, the path is
      ignored.

   When the URI in an intent is compared to a URI specification in a
   filter, it's compared only to the parts of the URI included in the
   filter. For example:

   -  If a filter specifies only a scheme, all URIs with that scheme
      match the filter.
   -  If a filter specifies a scheme and an authority but no path, all
      URIs with the same scheme and authority pass the filter,
      regardless of their paths.
   -  If a filter specifies a scheme, an authority, and a path, only
      URIs with the same scheme, authority, and path pass the filter.

   **Note:** A path specification can contain a wildcard asterisk (\*)
   to require only a partial match of the path name.

   The data test compares both the URI and the MIME type in the intent
   to a URI and MIME type specified in the filter. The rules are as
   follows:

   a. An intent that contains neither a URI nor a MIME type passes the
      test only if the filter does not specify any URIs or MIME types.
   b. An intent that contains a URI but no MIME type (neither explicit
      nor inferable from the URI) passes the test only if its URI
      matches the filter's URI format and the filter likewise does not
      specify a MIME type.
   c. An intent that contains a MIME type but not a URI passes the test
      only if the filter lists the same MIME type and does not specify a
      URI format.
   d. An intent that contains both a URI and a MIME type (either
      explicit or inferable from the URI) passes the MIME type part of
      the test only if that type matches a type listed in the filter. It
      passes the URI part of the test either if its URI matches a URI in
      the filter or if it has a ``content:`` or ``file:`` URI and the
      filter does not specify a URI. In other words, a component is
      presumed to support ``content:`` and ``file:`` data if its filter
      lists *only* a MIME type.

   **Note:** If an intent specifies a URI or MIME type, the data test
   will fail if there are no ``<data>`` elements in the
   ``<intent-filter>``.

   This last rule, rule (d), reflects the expectation that components
   are able to get local data from a file or content provider.
   Therefore, their filters can list just a data type and don't need to
   explicitly name the ``content:`` and ``file:`` schemes. The following
   example shows a typical case in which a
   ``<data>`` element tells
   Android that the component can get image data from a content provider
   and display it:

   .. code:: prettyprint

      <intent-filter>
          <data android:mimeType="image/*" />
          ...
      </intent-filter>

   Filters that specify a data type but not a URI are perhaps the most
   common because most available data is dispensed by content providers.

   Another common configuration is a filter with a scheme and a data
   type. For example, a
   ``<data>`` element like the
   following tells Android that the component can retrieve video data
   from the network in order to perform the action:

   .. code:: prettyprint

      <intent-filter>
          <data android:scheme="http" android:mimeType="video/*" />
          ...
      </intent-filter>

   .. rubric:: Intent matching
      :name: imatch

   Intents are matched against intent filters not only to discover a
   target component to activate, but also to discover something about
   the set of components on the device. For example, the Home app
   populates the app launcher by finding all the activities with intent
   filters that specify the
   `ACTION_MAIN <#ACTION_MAIN>`__
   action and
   `CATEGORY_LAUNCHER <#CATEGORY_LAUNCHER>`__
   category. A match is only successful if the actions and categories in
   the Intent match against the filter, as described in the
   documentation for the
   `IntentFilter <#>`__ class.

   Your application can use intent matching in a manner similar to what
   the Home app does. The
   `PackageManager <#>`__
   has a set of ``query...()`` methods that return all components that
   can accept a particular intent and a similar series of
   ``resolve...()`` methods that determine the best component to respond
   to an intent. For example,
   `queryIntentActivities() <#queryIntentActivities>`__
   returns a list of all activities that can perform the intent passed
   as an argument, and
   `queryIntentServices() <#queryIntentServices>`__
   returns a similar list of services. Neither method activates the
   components; they just list the ones that can respond. There's a
   similar method,
   `queryBroadcastReceivers() <#queryBroadcastReceivers>`__,
   for broadcast receivers.


Last updated 2024-05-03 UTC.



/Common intents
===============

.. container:: devsite-article-body clearfix

   An intent lets you start an activity in another app by describing an
   action you'd like to perform, such as "view a map" or "take a
   picture," in an `Intent <#>`__
   object. This type of intent is called an *implicit* intent because it
   doesn't specify the app component to start, but instead specifies an
   *action* and provides some *data* with which to perform the action.

   When you call
   `startActivity() <#startActivity>`__
   or
   `startActivityForResult() <#startActivityForResult>`__
   and pass it an implicit intent, the system `resolves the intent <#Resolution>`__ to an app
   that can handle the intent and starts its corresponding
   `Activity <#>`__. If there's more
   than one app that can handle the intent, the system presents the user
   with a dialog to pick which app to use.

   This page describes several implicit intents that you can use to
   perform common actions, organized by the type of app that handles the
   intent. Each section also shows how you can create an `intent filter <#Receiving>`__ to advertise
   your app's ability to perform the action.

   **Caution:** If there are no apps on the device that can receive an
   implicit intent, an app crashes when it calls
   `startActivity() <#startActivity>`__.
   To first verify that an app exists to receive the intent, call
   `resolveActivity() <#resolveActivity>`__
   on your `Intent <#>`__ object. If
   the result is non-null, there is at least one app that can handle the
   intent, and it's safe to call ``startActivity()``. If the result is
   null, don't use the intent and, if possible, disable the feature that
   invokes the intent.

   If you're not familiar with how to create intents or intent filters,
   first read `Intents and Intent Filters <#>`__.

   To learn how to fire the intents listed on this page from your
   development host, see the `Verify intents with the Android Debug Bridge <#AdbIntents>`__ section.

   .. rubric:: Google Voice Actions
      :name: google-voice-actions

   `Google Voice Actions <https://developers.google.cn/voice-actions/>`__ fires some
   of the intents listed on this page in response to voice commands. For
   more information, see `Get Started with System Voice Actions <https://developers.google.cn/voice-actions/system/#system_actions_reference>`__.

   .. rubric:: Alarm clock
      :name: Clock

   The following are common actions for alarm clock apps, including the
   information you need to create an intent filter to advertise your
   app's ability to perform each action.

   .. rubric:: Create an alarm
      :name: CreateAlarm

   .. container:: voice-box

      .. container:: voice-img-cont

         |image-voice-icon|

      Google Voice Actions

      -  "set an alarm for 7 am"

   To create a new alarm, use the
   `ACTION_SET_ALARM <#ACTION_SET_ALARM>`__
   action and specify alarm details such as the time and message using
   the following extras.

   **Note:** Only the hour, minutes, and message extras are available in
   Android 2.3 (API level 9) and lower. The other extras are available
   in higher versions of the platform.

   **Action**
      `ACTION_SET_ALARM <#ACTION_SET_ALARM>`__
   **Data URI**
      None
   **MIME Type**
      None
   **Extras**
      `EXTRA_HOUR <#EXTRA_HOUR>`__
         The hour for the alarm.
      `EXTRA_MINUTES <#EXTRA_MINUTES>`__
         The minutes for the alarm.
      `EXTRA_MESSAGE <#EXTRA_MESSAGE>`__
         A custom message to identify the alarm.
      `EXTRA_DAYS <#EXTRA_DAYS>`__
         An `ArrayList <#>`__ including
         each week day on which this alarm repeats. Each day must be
         declared with an integer from the
         `Calendar <#>`__ class, such as
         `MONDAY <#MONDAY>`__.

         For a one-time alarm, don't specify this extra.

      `EXTRA_RINGTONE <#EXTRA_RINGTONE>`__
         A ``content:`` URI specifying a ringtone to use with the alarm,
         or
         `VALUE_RINGTONE_SILENT <#VALUE_RINGTONE_SILENT>`__
         for no ringtone.

         To use the default ringtone, don't specify this extra.

      `EXTRA_VIBRATE <#EXTRA_VIBRATE>`__
         A boolean specifying whether to vibrate for this alarm.
      `EXTRA_SKIP_UI <#EXTRA_SKIP_UI>`__
         A boolean specifying whether the responding app must skip its
         UI when setting the alarm. If true, the app must bypass any
         confirmation UI and set the specified alarm.

   **Example intent:**

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun createAlarm(message: String, hour: Int, minutes: Int) {
                   val intent = Intent(AlarmClock.ACTION_SET_ALARM).apply {
                       putExtra(AlarmClock.EXTRA_MESSAGE, message)
                       putExtra(AlarmClock.EXTRA_HOUR, hour)
                       putExtra(AlarmClock.EXTRA_MINUTES, minutes)
                   }
                   if (intent.resolveActivity(packageManager) != null) {
                       startActivity(intent)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public void createAlarm(String message, int hour, int minutes) {
                   Intent intent = new Intent(AlarmClock.ACTION_SET_ALARM)
                           .putExtra(AlarmClock.EXTRA_MESSAGE, message)
                           .putExtra(AlarmClock.EXTRA_HOUR, hour)
                           .putExtra(AlarmClock.EXTRA_MINUTES, minutes);
                   if (intent.resolveActivity(getPackageManager()) != null) {
                       startActivity(intent);
                   }
               }

   .. note::

      **Note:**
      To invoke the
      `ACTION_SET_ALARM <#ACTION_SET_ALARM>`__
      intent, your app must have the
      `SET_ALARM <#SET_ALARM>`__
      permission:

      .. code:: prettyprint

         <uses-permission android:name="com.android.alarm.permission.SET_ALARM" />

   **Example intent filter:**

   .. code:: prettyprint

      <activity ...>
          <intent-filter>
              <action android:name="android.intent.action.SET_ALARM" />
              <category android:name="android.intent.category.DEFAULT" />
          </intent-filter>
      </activity>

   .. rubric:: Create a timer
      :name: CreateTimer

   .. container:: voice-box

      .. container:: voice-img-cont

         |image-voice-icon|

      Google Voice Actions

      -  "set timer for 5 minutes"

   To create a countdown timer, use the
   `ACTION_SET_TIMER <#ACTION_SET_TIMER>`__
   action and specify timer details such as the duration using the
   following extras.

   **Note:** This intent is available in Android 4.4 (API level 19) and
   higher.

   **Action**
      `ACTION_SET_TIMER <#ACTION_SET_TIMER>`__
   **Data URI**
      None
   **MIME Type**
      None
   **Extras**
      `EXTRA_LENGTH <#EXTRA_LENGTH>`__
         The length of the timer in seconds.
      `EXTRA_MESSAGE <#EXTRA_MESSAGE>`__
         A custom message to identify the timer.
      `EXTRA_SKIP_UI <#EXTRA_SKIP_UI>`__
         A boolean specifying whether the responding app must skip its
         UI when setting the timer. If true, the app must bypass any
         confirmation UI and start the specified timer.

   **Example intent:**

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun startTimer(message: String, seconds: Int) {
                   val intent = Intent(AlarmClock.ACTION_SET_TIMER).apply {
                       putExtra(AlarmClock.EXTRA_MESSAGE, message)
                       putExtra(AlarmClock.EXTRA_LENGTH, seconds)
                       putExtra(AlarmClock.EXTRA_SKIP_UI, true)
                   }
                   if (intent.resolveActivity(packageManager) != null) {
                       startActivity(intent)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public void startTimer(String message, int seconds) {
                   Intent intent = new Intent(AlarmClock.ACTION_SET_TIMER)
                           .putExtra(AlarmClock.EXTRA_MESSAGE, message)
                           .putExtra(AlarmClock.EXTRA_LENGTH, seconds)
                           .putExtra(AlarmClock.EXTRA_SKIP_UI, true);
                   if (intent.resolveActivity(getPackageManager()) != null) {
                       startActivity(intent);
                   }
               }

   .. note::

      **Note:**
      To invoke the
      `ACTION_SET_TIMER <#ACTION_SET_TIMER>`__
      intent, your app must have the
      `SET_ALARM <#SET_ALARM>`__
      permission:

      .. code:: prettyprint

         <uses-permission android:name="com.android.alarm.permission.SET_ALARM" />

   **Example intent filter:**

   .. code:: prettyprint

      <activity ...>
          <intent-filter>
              <action android:name="android.intent.action.SET_TIMER" />
              <category android:name="android.intent.category.DEFAULT" />
          </intent-filter>
      </activity>

   .. rubric:: Show all alarms
      :name: ShowAlarms

   To show the list of alarms, use the
   `ACTION_SHOW_ALARMS <#ACTION_SHOW_ALARMS>`__
   action.

   Although not many apps invoke this intent, as it's primarily used by
   system apps, any app that behaves as an alarm clock can implement
   this intent filter and respond by showing the list of current alarms.

   **Note:** This intent is available in Android 4.4 (API level 19) and
   higher.

   **Action**
      `ACTION_SHOW_ALARMS <#ACTION_SHOW_ALARMS>`__
   **Data URI**
      None
   **MIME Type**
      None

   **Example intent filter:**

   .. code:: prettyprint

      <activity ...>
          <intent-filter>
              <action android:name="android.intent.action.SHOW_ALARMS" />
              <category android:name="android.intent.category.DEFAULT" />
          </intent-filter>
      </activity>

   .. rubric:: Calendar
      :name: Calendar

   Adding an event is a common action for calendar apps. Create an
   intent filter to advertise your app's ability to perform this action
   using the information in the following section.

   .. rubric:: Add a calendar event
      :name: AddEvent

   To add a new event to the user's calendar, use the
   `ACTION_INSERT <#ACTION_INSERT>`__
   action and specify the data URI using
   `Events.CONTENT_URI <#CONTENT_URI>`__.
   You can then specify various event details using the following
   extras.

   **Action**
      `ACTION_INSERT <#ACTION_INSERT>`__
   **Data URI**
      `Events.CONTENT_URI <#CONTENT_URI>`__
   **MIME Type**
      ``"vnd.android.cursor.dir/event"``
   **Extras**
      `EXTRA_EVENT_ALL_DAY <#EXTRA_EVENT_ALL_DAY>`__
         A boolean specifying whether this is an all-day event.
      `EXTRA_EVENT_BEGIN_TIME <#EXTRA_EVENT_BEGIN_TIME>`__
         The start time of the event (milliseconds since epoch).
      `EXTRA_EVENT_END_TIME <#EXTRA_EVENT_END_TIME>`__
         The end time of the event (milliseconds since epoch).
      `TITLE <#TITLE>`__
         The event title.
      `DESCRIPTION <#DESCRIPTION>`__
         The event description.
      `EVENT_LOCATION <#EVENT_LOCATION>`__
         The event location.
      `EXTRA_EMAIL <#EXTRA_EMAIL>`__
         A comma-separated list of email addresses that specify the
         invitees.

      Many more event details can be specified using the constants
      defined in the
      `CalendarContract.EventsColumns <#>`__
      class.

   **Example intent:**

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun addEvent(title: String, location: String, begin: Long, end: Long) {
                   val intent = Intent(Intent.ACTION_INSERT).apply {
                       data = Events.CONTENT_URI
                       putExtra(Events.TITLE, title)
                       putExtra(Events.EVENT_LOCATION, location)
                       putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, begin)
                       putExtra(CalendarContract.EXTRA_EVENT_END_TIME, end)
                   }
                   if (intent.resolveActivity(packageManager) != null) {
                       startActivity(intent)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public void addEvent(String title, String location, long begin, long end) {
                   Intent intent = new Intent(Intent.ACTION_INSERT)
                           .setData(Events.CONTENT_URI)
                           .putExtra(Events.TITLE, title)
                           .putExtra(Events.EVENT_LOCATION, location)
                           .putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, begin)
                           .putExtra(CalendarContract.EXTRA_EVENT_END_TIME, end);
                   if (intent.resolveActivity(getPackageManager()) != null) {
                       startActivity(intent);
                   }
               }

   **Example intent filter:**

   .. code:: prettyprint

      <activity ...>
          <intent-filter>
              <action android:name="android.intent.action.INSERT" />
              <data android:mimeType="vnd.android.cursor.dir/event" />
              <category android:name="android.intent.category.DEFAULT" />
          </intent-filter>
      </activity>

   .. rubric:: Camera
      :name: Camera

   The following are common actions for camera apps, including the
   information you need to create an intent filter to advertise your
   app's ability to perform each action.

   .. rubric:: Capture a picture or video and return it
      :name: ImageCapture

   To open a camera app and receive the resulting photo or video, use
   the
   `ACTION_IMAGE_CAPTURE <#ACTION_IMAGE_CAPTURE>`__
   or
   `ACTION_VIDEO_CAPTURE <#ACTION_VIDEO_CAPTURE>`__
   action. Also specify the URI location where you'd like the camera to
   save the photo or video, in the
   `EXTRA_OUTPUT <#EXTRA_OUTPUT>`__
   extra.

   **Action**
      `ACTION_IMAGE_CAPTURE <#ACTION_IMAGE_CAPTURE>`__
      or
      `ACTION_VIDEO_CAPTURE <#ACTION_VIDEO_CAPTURE>`__
   **Data URI Scheme**
      None
   **MIME Type**
      None
   **Extras**
      `EXTRA_OUTPUT <#EXTRA_OUTPUT>`__
         The URI location where the camera app saves the photo or video
         file (as a `Uri <#>`__ object).

   When the camera app successfully returns focus to your activity‚Äîin
   other words, your app receives the
   `onActivityResult() <#onActivityResult>`__
   callback‚Äîyou can access the photo or video at the URI you specified
   with the
   `EXTRA_OUTPUT <#EXTRA_OUTPUT>`__
   value.

   **Note:** When you use
   `ACTION_IMAGE_CAPTURE <#ACTION_IMAGE_CAPTURE>`__
   to capture a photo, the camera might also return a downscaled copy,
   or thumbnail, of the photo in the result
   `Intent <#>`__, saved as a
   `Bitmap <#>`__ in an extra field
   named ``"data"``.

   **Example intent:**

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               const val REQUEST_IMAGE_CAPTURE = 1
               val locationForPhotos: Uri = ...

               fun capturePhoto(targetFilename: String) {
                   val intent = Intent(MediaStore.ACTION_IMAGE_CAPTURE).apply {
                       putExtra(MediaStore.EXTRA_OUTPUT, Uri.withAppendedPath(locationForPhotos, targetFilename))
                   }
                   if (intent.resolveActivity(packageManager) != null) {
                       startActivityForResult(intent, REQUEST_IMAGE_CAPTURE)
                   }
               }

               override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent) {
                   if (requestCode == REQUEST_IMAGE_CAPTURE && resultCode == Activity.RESULT_OK) {
                       val thumbnail: Bitmap = data.getParcelableExtra("data")
                       // Do other work with full size photo saved in locationForPhotos.
                       ...
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               static final int REQUEST_IMAGE_CAPTURE = 1;
               static final Uri locationForPhotos;

               public void capturePhoto(String targetFilename) {
                   Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
                   intent.putExtra(MediaStore.EXTRA_OUTPUT,
                           Uri.withAppendedPath(locationForPhotos, targetFilename));
                   if (intent.resolveActivity(getPackageManager()) != null) {
                       startActivityForResult(intent, REQUEST_IMAGE_CAPTURE);
                   }
               }

               @Override
               protected void onActivityResult(int requestCode, int resultCode, Intent data) {
                   if (requestCode == REQUEST_IMAGE_CAPTURE && resultCode == RESULT_OK) {
                       Bitmap thumbnail = data.getParcelableExtra("data");
                       // Do other work with full size photo saved in locationForPhotos.
                       ...
                   }
               }

   To do this when working on Android 12 (API level 31) or higher, refer
   to the following intent example.

   **Example intent:**

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val REQUEST_IMAGE_CAPTURE = 1

               private fun dispatchTakePictureIntent() {
                   val takePictureIntent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)
                   try {
                       startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE)
                   } catch (e: ActivityNotFoundException) {
                       // Display error state to the user.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               static final int REQUEST_IMAGE_CAPTURE = 1;

               private void dispatchTakePictureIntent() {
                   Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
                   try {
                       startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE);
                   } catch (ActivityNotFoundException e) {
                       // Display error state to the user.
                   }
               }
               </section></div>

            For more information about how to use this intent to capture
            a photo, including how to create an appropriate
            `Uri <#>`__ for the output
            location, read `Take photos <#>`__ or `Take videos <#>`__.

            **Example intent filter:**

            .. code:: prettyprint

               <activity ...>
                   <intent-filter>
                       <action android:name="android.media.action.IMAGE_CAPTURE" />
                       <category android:name="android.intent.category.DEFAULT" />
                   </intent-filter>
               </activity>

            When handling this intent, have your activity check for the
            `EXTRA_OUTPUT <#EXTRA_OUTPUT>`__
            extra in the incoming
            `Intent <#>`__, then
            save the captured image or video at the location specified
            by that extra and call
            `setResult() <#setResult>`__
            with an ``Intent`` that includes a compressed thumbnail in
            an extra named ``"data"``.

            .. rubric:: Start a camera app in still image mode
               :name: CameraStill

            .. container:: voice-box

               .. container:: voice-img-cont

                  |image-voice-icon|

               Google Voice Actions

               -  "take a picture"

            To open a camera app in still image mode, use the
            `INTENT_ACTION_STILL_IMAGE_CAMERA <#INTENT_ACTION_STILL_IMAGE_CAMERA>`__
            action.

            **Action**
               `INTENT_ACTION_STILL_IMAGE_CAMERA <#INTENT_ACTION_STILL_IMAGE_CAMERA>`__
            **Data URI Scheme**
               None
            **MIME Type**
               None
            **Extras**
               None

            **Example intent:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        private fun dispatchTakePictureIntent() {
                            val takePictureIntent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)
                            try {
                                startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE)
                            } catch (e: ActivityNotFoundException) {
                                // Display error state to the user.
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void capturePhoto(String targetFilename) {
                            Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
                            intent.putExtra(MediaStore.EXTRA_OUTPUT,
                                    Uri.withAppendedPath(locationForPhotos, targetFilename));
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivityForResult(intent, REQUEST_IMAGE_CAPTURE);
                            }
                        }

            **Example intent filter:**

            .. code:: prettyprint

               <activity ...>
                   <intent-filter>
                       <action android:name="android.media.action.STILL_IMAGE_CAMERA" />
                       <category android:name="android.intent.category.DEFAULT" />
                   </intent-filter>
               </activity>

            .. rubric:: Start a camera app in video mode
               :name: CameraVideo

            .. container:: voice-box

               .. container:: voice-img-cont

                  |image-voice-icon|

               Google Voice Actions

               -  "record a video"

            To open a camera app in video mode, use the
            `INTENT_ACTION_VIDEO_CAMERA <#INTENT_ACTION_VIDEO_CAMERA>`__
            action.

            **Action**
               `INTENT_ACTION_VIDEO_CAMERA <#INTENT_ACTION_VIDEO_CAMERA>`__
            **Data URI Scheme**
               None
            **MIME Type**
               None
            **Extras**
               None

            **Example intent:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        fun capturePhoto() {
                            val intent = Intent(MediaStore.INTENT_ACTION_VIDEO_CAMERA)
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivityForResult(intent, REQUEST_IMAGE_CAPTURE)
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void capturePhoto() {
                            Intent intent = new Intent(MediaStore.INTENT_ACTION_VIDEO_CAMERA);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivityForResult(intent, REQUEST_IMAGE_CAPTURE);
                            }
                        }

            **Example intent filter:**

            .. code:: prettyprint

               <activity ...>
                   <intent-filter>
                       <action android:name="android.media.action.VIDEO_CAMERA" />
                       <category android:name="android.intent.category.DEFAULT" />
                   </intent-filter>
               </activity>

            .. rubric:: Contacts/people app
               :name: Contacts

            The following are common actions for contacts management
            apps, including the information you need to create an intent
            filter to advertise your app's ability to perform each
            action.

            .. rubric:: Select a contact
               :name: PickContact

            To have the user select a contact and provide your app
            access to all the contact information, use the
            `ACTION_PICK <#ACTION_PICK>`__
            action and specify the MIME type to
            `Contacts.CONTENT_TYPE <#CONTENT_TYPE>`__.

            The result
            `Intent <#>`__ delivered
            to your
            `onActivityResult() <#onActivityResult>`__
            callback contains the ``content:`` URI pointing to the
            selected contact. The response grants your app temporary
            permissions to read that contact using the `Contacts Provider <#>`__ API,
            even if your app doesn't include the
            `READ_CONTACTS <#READ_CONTACTS>`__
            permission.

            **Tip:** If you need access to only a specific piece of
            contact information, such as a phone number or email
            address, instead see the next section about how to `select specific contact data <#PickContactData>`__.

            **Action**
               `ACTION_PICK <#ACTION_PICK>`__
            **Data URI Scheme**
               None
            **MIME Type**
               `Contacts.CONTENT_TYPE <#CONTENT_TYPE>`__

            **Example intent:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        const val REQUEST_SELECT_CONTACT = 1

                        fun selectContact() {
                            val intent = Intent(Intent.ACTION_PICK).apply {
                                type = ContactsContract.Contacts.CONTENT_TYPE
                            }
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivityForResult(intent, REQUEST_SELECT_CONTACT)
                            }
                        }

                        override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent) {
                            if (requestCode == REQUEST_SELECT_CONTACT && resultCode == RESULT_OK) {
                                val contactUri: Uri = data.data
                                // Do something with the selected contact at contactUri.
                                //...
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        static final int REQUEST_SELECT_CONTACT = 1;

                        public void selectContact() {
                            Intent intent = new Intent(Intent.ACTION_PICK);
                            intent.setType(ContactsContract.Contacts.CONTENT_TYPE);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivityForResult(intent, REQUEST_SELECT_CONTACT);
                            }
                        }

                        @Override
                        protected void onActivityResult(int requestCode, int resultCode, Intent data) {
                            if (requestCode == REQUEST_SELECT_CONTACT && resultCode == RESULT_OK) {
                                Uri contactUri = data.getData();
                                // Do something with the selected contact at contactUri.
                                ...
                            }
                        }

            For information about how to retrieve contact details once
            you have the contact URI, read `Retrieve details for a contact <#>`__.

            When you retrieve the contact URI using this intent, you
            generally don't need the
            `READ_CONTACTS <#READ_CONTACTS>`__
            permission to read basic details for that contact, such as
            display name and whether the contact is starred. However, if
            you're trying to `read more specific data <#PickContactData>`__ about a given contact‚Äîsuch as
            their phone number or email address‚Äîyou need the
            ``READ_CONTACTS`` permission.

            .. rubric:: Select specific contact data
               :name: PickContactData

            To have the user select a specific piece of information from
            a contact, such as a phone number, email address, or other
            data type, use the
            `ACTION_PICK <#ACTION_PICK>`__
            action and specify the MIME type to one of the following
            content types, such as
            `CommonDataKinds.Phone.CONTENT_TYPE <#CONTENT_TYPE>`__
            to get the contact's phone number.

            **Note:** In many cases, your app needs to have the
            `READ_CONTACTS <#READ_CONTACTS>`__
            permission to view specific information about a particular
            contact.

            If you need to retrieve only one type of data from a
            contact, this technique with a ``CONTENT_TYPE`` from the
            `ContactsContract.CommonDataKinds <#>`__
            classes is more efficient than using the
            `Contacts.CONTENT_TYPE <#CONTENT_TYPE>`__,
            as shown in the preceding section. The result provides you
            direct access to the desired data without requiring you to
            perform a more complex query to `Contacts Provider <#>`__.

            The result
            `Intent <#>`__ delivered
            to your
            `onActivityResult() <#onActivityResult>`__
            callback contains the ``content:`` URI pointing to the
            selected contact data. The response grants your app
            temporary permissions to read that contact data even if your
            app doesn't include the
            `READ_CONTACTS <#READ_CONTACTS>`__
            permission.

            **Action**
               `ACTION_PICK <#ACTION_PICK>`__
            **Data URI Scheme**
               None
            **MIME Type**
               `CommonDataKinds.Phone.CONTENT_TYPE <#CONTENT_TYPE>`__
                  Pick from contacts with a phone number.
               `CommonDataKinds.Email.CONTENT_TYPE <#CONTENT_TYPE>`__
                  Pick from contacts with an email address.
               `CommonDataKinds.StructuredPostal.CONTENT_TYPE <#CONTENT_TYPE>`__
                  Pick from contacts with a postal address.

               Or one of many other ``CONTENT_TYPE`` values under
               `ContactsContract <#>`__.

            **Example intent:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        const val REQUEST_SELECT_PHONE_NUMBER = 1

                        fun selectContact() {
                            // Start an activity for the user to pick a phone number from contacts.
                            val intent = Intent(Intent.ACTION_PICK).apply {
                                type = CommonDataKinds.Phone.CONTENT_TYPE
                            }
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivityForResult(intent, REQUEST_SELECT_PHONE_NUMBER)
                            }
                        }

                        override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent) {
                            if (requestCode == REQUEST_SELECT_PHONE_NUMBER && resultCode == Activity.RESULT_OK) {
                                // Get the URI and query the content provider for the phone number.
                                val contactUri: Uri = data.data
                                val projection: Array<String> = arrayOf(CommonDataKinds.Phone.NUMBER)
                                contentResolver.query(contactUri, projection, null, null, null).use { cursor ->
                                    // If the cursor returned is valid, get the phone number.
                                    if (cursor.moveToFirst()) {
                                        val numberIndex = cursor.getColumnIndex(CommonDataKinds.Phone.NUMBER)
                                        val number = cursor.getString(numberIndex)
                                        // Do something with the phone number.
                                        ...
                                    }
                                }
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        static final int REQUEST_SELECT_PHONE_NUMBER = 1;

                        public void selectContact() {
                            // Start an activity for the user to pick a phone number from contacts.
                            Intent intent = new Intent(Intent.ACTION_PICK);
                            intent.setType(CommonDataKinds.Phone.CONTENT_TYPE);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivityForResult(intent, REQUEST_SELECT_PHONE_NUMBER);
                            }
                        }

                        @Override
                        protected void onActivityResult(int requestCode, int resultCode, Intent data) {
                            if (requestCode == REQUEST_SELECT_PHONE_NUMBER && resultCode == RESULT_OK) {
                                // Get the URI and query the content provider for the phone number.
                                Uri contactUri = data.getData();
                                String[] projection = new String[]{CommonDataKinds.Phone.NUMBER};
                                Cursor cursor = getContentResolver().query(contactUri, projection,
                                        null, null, null);
                                // If the cursor returned is valid, get the phone number.
                                if (cursor != null && cursor.moveToFirst()) {
                                    int numberIndex = cursor.getColumnIndex(CommonDataKinds.Phone.NUMBER);
                                    String number = cursor.getString(numberIndex);
                                    // Do something with the phone number.
                                    //...
                                }
                            }
                        }

            .. rubric:: View a contact
               :name: ViewContact

            To display the details for a known contact, use the
            `ACTION_VIEW <#ACTION_VIEW>`__
            action and specify the contact with a ``content:`` URI as
            the intent data.

            There are two primary ways to initially retrieve the
            contact's URI:

            -  Use the contact URI returned by the
               `ACTION_PICK <#ACTION_PICK>`__
               action shown in the preceding section. This approach
               doesn't require any app permissions.
            -  Access the list of all contacts directly, as described in
               `Retrieve a list of contacts <#>`__.
               This approach requires the
               `READ_CONTACTS <#READ_CONTACTS>`__
               permission.

            **Action**
               `ACTION_VIEW <#ACTION_VIEW>`__
            **Data URI Scheme**
               ``content:<URI>``
            **MIME Type**
               None. The type is inferred from the contact URI.

            **Example intent:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        fun viewContact(contactUri: Uri) {
                            val intent = Intent(Intent.ACTION_VIEW, contactUri)
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivity(intent)
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void viewContact(Uri contactUri) {
                            Intent intent = new Intent(Intent.ACTION_VIEW, contactUri);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivity(intent);
                            }
                        }

            .. rubric:: Edit an existing contact
               :name: EditContact

            To edit a known contact, use the
            `ACTION_EDIT <#ACTION_EDIT>`__
            action, specify the contact with a ``content:`` URI as the
            intent data, and include any known contact information in
            extras specified by constants in
            `ContactsContract.Intents.Insert <#>`__.

            There are two primary ways to initially retrieve the contact
            URI:

            -  Use the contact URI returned by the
               `ACTION_PICK <#ACTION_PICK>`__
               action shown in the preceding section. This approach
               doesn't require any app permissions.
            -  Access the list of all contacts directly, as described in
               `Retrieve a list of contacts <#>`__.
               This approach requires the
               `READ_CONTACTS <#READ_CONTACTS>`__
               permission.

            **Action**
               `ACTION_EDIT <#ACTION_EDIT>`__
            **Data URI Scheme**
               ``content:<URI>``
            **MIME Type**
               The type is inferred from the contact URI.
            **Extras**
               One or more of the extras defined in
               `ContactsContract.Intents.Insert <#>`__
               so you can populate fields of the contact details.

            **Example intent:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        fun editContact(contactUri: Uri, email: String) {
                            val intent = Intent(Intent.ACTION_EDIT).apply {
                                data = contactUri
                                putExtra(ContactsContract.Intents.Insert.EMAIL, email)
                            }
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivity(intent)
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void editContact(Uri contactUri, String email) {
                            Intent intent = new Intent(Intent.ACTION_EDIT);
                            intent.setData(contactUri);
                            intent.putExtra(Intents.Insert.EMAIL, email);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivity(intent);
                            }
                        }

            For more information about how to edit a contact, read
            `Modify contacts using intents <#>`__.

            .. rubric:: Insert a contact
               :name: InsertContact

            To insert a new contact, use the
            `ACTION_INSERT <#ACTION_INSERT>`__
            action, specify
            `Contacts.CONTENT_TYPE <#CONTENT_TYPE>`__
            as the MIME type, and include any known contact information
            in extras specified by constants in
            `ContactsContract.Intents.Insert <#>`__.

            **Action**
               `ACTION_INSERT <#ACTION_INSERT>`__
            **Data URI Scheme**
               None
            **MIME Type**
               `Contacts.CONTENT_TYPE <#CONTENT_TYPE>`__
            **Extras**
               One or more of the extras defined in
               `ContactsContract.Intents.Insert <#>`__.

            **Example intent:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        fun insertContact(name: String, email: String) {
                            val intent = Intent(Intent.ACTION_INSERT).apply {
                                type = ContactsContract.Contacts.CONTENT_TYPE
                                putExtra(ContactsContract.Intents.Insert.NAME, name)
                                putExtra(ContactsContract.Intents.Insert.EMAIL, email)
                            }
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivity(intent)
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void insertContact(String name, String email) {
                            Intent intent = new Intent(Intent.ACTION_INSERT);
                            intent.setType(Contacts.CONTENT_TYPE);
                            intent.putExtra(Intents.Insert.NAME, name);
                            intent.putExtra(Intents.Insert.EMAIL, email);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivity(intent);
                            }
                        }

            For more information about how to insert a contact, read
            `Modify contacts using intents <#>`__.

            .. rubric:: Email
               :name: Email

            Composing an email with optional attachments is a common
            action for email apps. Create an intent filter to advertise
            your app's ability to perform this action using the
            information in the following section.

            .. rubric:: Compose an email with optional attachments
               :name: ComposeEmail

            To compose an email, use one of the following actions based
            on whether you'll include attachments or not, and include
            email details such as the recipient and subject using the
            extra keys listed.

            **Action**
            `ACTION_SENDTO <#ACTION_SENDTO>`__
            (for no attachment) or
            `ACTION_SEND <#ACTION_SEND>`__
            (for one attachment) or
            `ACTION_SEND_MULTIPLE <#ACTION_SEND_MULTIPLE>`__
            (for multiple attachments)
            **Data URI Scheme**
            None
            **MIME Type**
            ``"text/plain"``
            ``"*/*"``
            **Extras**

            `Intent.EXTRA_EMAIL <#EXTRA_EMAIL>`__
               A string array of all "To" recipient email addresses.
            `Intent.EXTRA_CC <#EXTRA_CC>`__
               A string array of all "CC" recipient email addresses.
            `Intent.EXTRA_BCC <#EXTRA_BCC>`__
               A string array of all "BCC" recipient email addresses.
            `Intent.EXTRA_SUBJECT <#EXTRA_SUBJECT>`__
               A string with the email subject.
            `Intent.EXTRA_TEXT <#EXTRA_TEXT>`__
               A string with the body of the email.
            `Intent.EXTRA_STREAM <#EXTRA_STREAM>`__
               A `Uri <#>`__ pointing to
               the attachment. If using the
               `ACTION_SEND_MULTIPLE <#ACTION_SEND_MULTIPLE>`__
               action, this instead is an
               `ArrayList <#>`__
               containing multiple ``Uri`` objects.

            **Example intent:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        fun composeEmail(addresses: Array<String>, subject: String, attachment: Uri) {
                            val intent = Intent(Intent.ACTION_SEND).apply {
                                type = "*/*"
                                putExtra(Intent.EXTRA_EMAIL, addresses)
                                putExtra(Intent.EXTRA_SUBJECT, subject)
                                putExtra(Intent.EXTRA_STREAM, attachment)
                            }
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivity(intent)
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void composeEmail(String[] addresses, String subject, Uri attachment) {
                            Intent intent = new Intent(Intent.ACTION_SEND);
                            intent.setType("*/*");
                            intent.putExtra(Intent.EXTRA_EMAIL, addresses);
                            intent.putExtra(Intent.EXTRA_SUBJECT, subject);
                            intent.putExtra(Intent.EXTRA_STREAM, attachment);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivity(intent);
                            }
                        }

            If you want to make sure that your intent is handled only by
            an email app, and not a text messaging or social app, then
            use the
            `ACTION_SENDTO <#ACTION_SENDTO>`__
            action and include the ``"mailto:"`` data scheme as shown in
            the following example:

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        fun composeEmail(addresses: Array<String>, subject: String) {
                            val intent = Intent(Intent.ACTION_SENDTO).apply {
                                data = Uri.parse("mailto:") // Only email apps handle this.
                                putExtra(Intent.EXTRA_EMAIL, addresses)
                                putExtra(Intent.EXTRA_SUBJECT, subject)
                            }
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivity(intent)
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void composeEmail(String[] addresses, String subject) {
                            Intent intent = new Intent(Intent.ACTION_SENDTO);
                            intent.setData(Uri.parse("mailto:")); // Only email apps handle this.
                            intent.putExtra(Intent.EXTRA_EMAIL, addresses);
                            intent.putExtra(Intent.EXTRA_SUBJECT, subject);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivity(intent);
                            }
                        }

            **Example intent filter:**

            .. code:: prettyprint

               <activity ...>
                   <intent-filter>
                       <action android:name="android.intent.action.SEND" />
                       <data android:type="*/*" />
                       <category android:name="android.intent.category.DEFAULT" />
                   </intent-filter>
                   <intent-filter>
                       <action android:name="android.intent.action.SENDTO" />
                       <data android:scheme="mailto" />
                       <category android:name="android.intent.category.DEFAULT" />
                   </intent-filter>
               </activity>

            .. rubric:: File storage
               :name: Storage

            The following are common actions for file storage apps,
            including the information you need to create an intent
            filter to advertise your app's ability to perform each
            action.

            .. rubric:: Retrieve a specific type of file
               :name: GetFile

            To request that the user select a file such as a document or
            photo and return a reference to your app, use the
            `ACTION_GET_CONTENT <#ACTION_GET_CONTENT>`__
            action and specify your desired MIME type. The file
            reference returned to your app is transient to your
            activity's current lifecycle, so if you want to access it
            later you must import a copy that you can read later.

            This intent also lets the user create a new file in the
            process. For example, instead of selecting an existing
            photo, the user can capture a new photo with the camera.

            The result intent delivered to your
            `onActivityResult() <#onActivityResult>`__
            method includes data with a URI pointing to the file. The
            URI can be anything, such as an ``http:`` URI, ``file:``
            URI, or ``content:`` URI. However, if you'd like to restrict
            selectable files to only those that are accessible from a
            content provider (a ``content:`` URI) and that are available
            as a file stream with
            `openFileDescriptor() <#openFileDescriptor>`__,
            add the
            `CATEGORY_OPENABLE <#CATEGORY_OPENABLE>`__
            category to your intent.

            On Android 4.3 (API level 18) and higher, you can also let
            the user select multiple files by adding
            `EXTRA_ALLOW_MULTIPLE <#EXTRA_ALLOW_MULTIPLE>`__
            to the intent, set to ``true``. You can then access each of
            the selected files in a
            `ClipData <#>`__
            object returned by
            `getClipData() <#getClipData>`__.

            **Action**
               `ACTION_GET_CONTENT <#ACTION_GET_CONTENT>`__
            **Data URI Scheme**
               None
            **MIME Type**
               The MIME type corresponding to the file type the user
               needs to select.
            **Extras**
               `EXTRA_ALLOW_MULTIPLE <#EXTRA_ALLOW_MULTIPLE>`__
                  A boolean that declares whether the user can select
                  more than one file at a time.
               `EXTRA_LOCAL_ONLY <#EXTRA_LOCAL_ONLY>`__
                  A boolean that declares whether the returned file must
                  be available directly from the device, rather than
                  requiring a download from a remote service.

            **Category** (optional)
               `CATEGORY_OPENABLE <#CATEGORY_OPENABLE>`__
                  To return only "openable" files that can be
                  represented as a file stream with
                  `openFileDescriptor() <#openFileDescriptor>`__.

            **Example intent to get a photo:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        const val REQUEST_IMAGE_GET = 1

                        fun selectImage() {
                            val intent = Intent(Intent.ACTION_GET_CONTENT).apply {
                                type = "image/*"
                            }
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivityForResult(intent, REQUEST_IMAGE_GET)
                            }
                        }

                        override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent) {
                            if (requestCode == REQUEST_IMAGE_GET && resultCode == Activity.RESULT_OK) {
                                val thumbnail: Bitmap = data.getParcelableExtra("data")
                                val fullPhotoUri: Uri = data.data
                                // Do work with photo saved at fullPhotoUri.
                                ...
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        static final int REQUEST_IMAGE_GET = 1;

                        public void selectImage() {
                            Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
                            intent.setType("image/*");
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivityForResult(intent, REQUEST_IMAGE_GET);
                            }
                        }

                        @Override
                        protected void onActivityResult(int requestCode, int resultCode, Intent data) {
                            if (requestCode == REQUEST_IMAGE_GET && resultCode == RESULT_OK) {
                                Bitmap thumbnail = data.getParcelable("data");
                                Uri fullPhotoUri = data.getData();
                                // Do work with photo saved at fullPhotoUri.
                                ...
                            }
                        }

            **Example intent filter to return a photo:**

            .. code:: prettyprint

               <activity ...>
                   <intent-filter>
                       <action android:name="android.intent.action.GET_CONTENT" />
                       <data android:type="image/*" />
                       <category android:name="android.intent.category.DEFAULT" />
                       <!-- The OPENABLE category declares that the returned file is accessible
                            from a content provider that supports OpenableColumns
                            and ContentResolver.openFileDescriptor(). -->
                       <category android:name="android.intent.category.OPENABLE" />
                   </intent-filter>
               </activity>

            .. rubric:: Open a specific type of file
               :name: OpenFile

            Instead of retrieving a copy of a file that you must import
            to your app, by using the
            `ACTION_GET_CONTENT <#ACTION_GET_CONTENT>`__
            action, when running on Android 4.4 or higher you can
            instead request to *open* a file that's managed by another
            app by using the
            `ACTION_OPEN_DOCUMENT <#ACTION_OPEN_DOCUMENT>`__
            action and specifying a MIME type. To also let the user
            create a new document that your app can write to, use the
            `ACTION_CREATE_DOCUMENT <#ACTION_CREATE_DOCUMENT>`__
            action instead.

            For example, instead of selecting from existing PDF
            documents, the ``ACTION_CREATE_DOCUMENT`` intent lets users
            select where they'd like to create a new document, such as
            within another app that manages the document's storage. Your
            app then receives the URI location of where it can write the
            new document.

            Whereas the intent delivered to your
            `onActivityResult() <#onActivityResult>`__
            method from the ``ACTION_GET_CONTENT`` action might return a
            URI of any type, the result intent from
            ``ACTION_OPEN_DOCUMENT`` and ``ACTION_CREATE_DOCUMENT``
            always specify the chosen file as a ``content:`` URI that's
            backed by a
            `DocumentsProvider <#>`__.
            You can open the file with
            `openFileDescriptor() <#openFileDescriptor>`__
            and query its details using columns from
            `DocumentsContract.Document <#>`__.

            The returned URI grants your app long-term read access to
            the file, also possibly with write access. The
            ``ACTION_OPEN_DOCUMENT`` action is particularly useful when
            you want to read an existing file without making a copy into
            your app or when you want to open and edit a file in place.

            You can also let the user select multiple files by adding
            `EXTRA_ALLOW_MULTIPLE <#EXTRA_ALLOW_MULTIPLE>`__
            to the intent, set to ``true``. If the user selects just one
            item, then you can retrieve the item from
            `getData() <#getData>`__.
            If the user selects more than one item, then ``getData()``
            returns null and you must instead retrieve each item from a
            `ClipData <#>`__
            object that is returned by
            `getClipData() <#getClipData>`__.

            **Note:** Your intent **must** specify a MIME type and
            **must** declare the
            `CATEGORY_OPENABLE <#CATEGORY_OPENABLE>`__
            category. If appropriate, you can specify more than one MIME
            type by adding an array of MIME types with the
            `EXTRA_MIME_TYPES <#EXTRA_MIME_TYPES>`__
            extra‚Äîif you do so, you must set the primary MIME type in
            `setType() <#setType>`__
            to ``"*/*"``.

            **Action**
               `ACTION_OPEN_DOCUMENT <#ACTION_OPEN_DOCUMENT>`__
               or
               `ACTION_CREATE_DOCUMENT <#ACTION_CREATE_DOCUMENT>`__
            **Data URI Scheme**
               None
            **MIME Type**
               The MIME type corresponding to the file type the user
               needs to select.
            **Extras**
               `EXTRA_MIME_TYPES <#EXTRA_MIME_TYPES>`__
                  An array of MIME types corresponding to the types of
                  files your app is requesting. When you use this extra,
                  you must set the primary MIME type in
                  `setType() <#setType>`__
                  to ``"*/*"``.
               `EXTRA_ALLOW_MULTIPLE <#EXTRA_ALLOW_MULTIPLE>`__
                  A boolean that declares whether the user can select
                  more than one file at a time.
               `EXTRA_TITLE <#EXTRA_TITLE>`__
                  For use with
                  `ACTION_CREATE_DOCUMENT <#ACTION_CREATE_DOCUMENT>`__
                  to specify an initial filename.
               `EXTRA_LOCAL_ONLY <#EXTRA_LOCAL_ONLY>`__
                  A boolean that declares whether the returned file must
                  be available directly from the device, rather than
                  requiring a download from a remote service.

            **Category**
               `CATEGORY_OPENABLE <#CATEGORY_OPENABLE>`__
                  To return only "openable" files that can be
                  represented as a file stream with
                  `openFileDescriptor() <#openFileDescriptor>`__.

            **Example intent to get a photo:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        const val REQUEST_IMAGE_OPEN = 1

                        fun selectImage2() {
                            val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
                                type = "image/*"
                                addCategory(Intent.CATEGORY_OPENABLE)
                            }
                            // Only the system receives the ACTION_OPEN_DOCUMENT, so no need to test.
                            startActivityForResult(intent, REQUEST_IMAGE_OPEN)
                        }

                        override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent) {
                            if (requestCode == REQUEST_IMAGE_OPEN && resultCode == Activity.RESULT_OK) {
                                val fullPhotoUri: Uri = data.data
                                // Do work with full size photo saved at fullPhotoUri.
                                ...
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        static final int REQUEST_IMAGE_OPEN = 1;

                        public void selectImage() {
                            Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
                            intent.setType("image/*");
                            intent.addCategory(Intent.CATEGORY_OPENABLE);
                            // Only the system receives the ACTION_OPEN_DOCUMENT, so no need to test.
                            startActivityForResult(intent, REQUEST_IMAGE_OPEN);
                        }

                        @Override
                        protected void onActivityResult(int requestCode, int resultCode, Intent data) {
                            if (requestCode == REQUEST_IMAGE_OPEN && resultCode == RESULT_OK) {
                                Uri fullPhotoUri = data.getData();
                                // Do work with full size photo saved at fullPhotoUri.
                                ...
                            }
                        }

            Third-party apps can't respond to an intent with the
            `ACTION_OPEN_DOCUMENT <#ACTION_OPEN_DOCUMENT>`__
            action. Instead, the system receives this intent and
            displays all the files available from various apps in a
            unified user interface.

            To provide your app's files in this UI and let other apps
            open them, you must implement a
            `DocumentsProvider <#>`__
            and include an intent filter for
            `PROVIDER_INTERFACE <#PROVIDER_INTERFACE>`__
            (``"android.content.action.DOCUMENTS_PROVIDER"``), as shown
            in the following example:

            .. code:: prettyprint

               <provider ...
                   android:grantUriPermissions="true"
                   android:exported="true"
                   android:permission="android.permission.MANAGE_DOCUMENTS">
                   <intent-filter>
                       <action android:name="android.content.action.DOCUMENTS_PROVIDER" />
                   </intent-filter>
               </provider>

            For more information about how to make the files managed by
            your app openable from other apps, read `Open files using storage access framework <#>`__.

            .. rubric:: Local actions
               :name: Local

            Calling a car is a common local action. Create an intent
            filter to advertise your app's ability to perform this
            action using the information in the following section.

            .. rubric:: Call a car
               :name: CallCar

            .. container:: voice-box

               .. container:: voice-img-cont

                  |image-voice-icon|

               Google Voice Actions

               -  "get me a taxi"
               -  "call me a car"

               (Wear OS only)

            To call a taxi, use the
            `ACTION_RESERVE_TAXI_RESERVATION <https://developers.google.cn/android/reference/com/google/android/gms/actions/ReserveIntents#ACTION_RESERVE_TAXI_RESERVATION>`__
            action.

            **Note:** Apps must ask for confirmation from the user
            before completing this action.

            **Action**
               `ACTION_RESERVE_TAXI_RESERVATION <#ACTION_RESERVE_TAXI_RESERVATION>`__
            **Data URI**
               None
            **MIME Type**
               None
            **Extras**
               None

            **Example intent:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        fun callCar() {
                            val intent = Intent(ReserveIntents.ACTION_RESERVE_TAXI_RESERVATION)
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivity(intent)
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void callCar() {
                            Intent intent = new Intent(ReserveIntents.ACTION_RESERVE_TAXI_RESERVATION);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivity(intent);
                            }
                        }

            **Example intent filter:**

            .. code:: prettyprint

               <activity ...>
                   <intent-filter>
                       <action android:name="com.google.android.gms.actions.RESERVE_TAXI_RESERVATION" />
                       <category android:name="android.intent.category.DEFAULT" />
                   </intent-filter>
               </activity>

            .. rubric:: Maps
               :name: Maps

            Showing a location on a map is a common action for map apps.
            Create an intent filter to advertise your app's ability to
            perform this action using the information in the following
            section.

            .. rubric:: Show a location on a map
               :name: ViewMap

            To open a map, use the
            `ACTION_VIEW <#ACTION_VIEW>`__
            action and specify the location information in the intent
            data with one of the following schemes.

            **Action**
               `ACTION_VIEW <#ACTION_VIEW>`__
            **Data URI Scheme**
               ``geo:``\ *``latitude``*\ ``,``\ *``longitude``*
                  Show the map at the given longitude and latitude.

                  Example: ``"geo:47.6,-122.3"``

               ``geo:``\ *``latitude``*\ ``,``\ *``longitude``*\ ``?z=``\ *``zoom``*
                  Show the map at the given longitude and latitude at a
                  certain zoom level. A zoom level of 1 shows the whole
                  Earth, centered at the given *lat*,\ *lng*. The
                  highest (closest) zoom level is 23.

                  Example: ``"geo:47.6,-122.3?z=11"``

               ``geo:0,0?q=lat,lng(label)``
                  Show the map at the given longitude and latitude with
                  a string label.

                  Example: ``"geo:0,0?q=34.99,-106.61(Treasure)"``

               ``geo:0,0?q=my+street+address``
                  Show the location for "my street address", which can
                  be a specific address or location query.

                  Example:
                  ``"geo:0,0?q=1600+Amphitheatre+Parkway%2C+CA"``

                  **Note:** All strings passed in the ``geo`` URI must
                  be encoded. For example, the string
                  ``1st & Pike, Seattle`` becomes
                  ``1st%20%26%20Pike%2C%20Seattle``. Spaces in the
                  string are encoded with ``%20`` or replaced with the
                  plus sign (``+``).

            **MIME Type**
               None

            **Example intent:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        fun showMap(geoLocation: Uri) {
                            val intent = Intent(Intent.ACTION_VIEW).apply {
                                data = geoLocation
                            }
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivity(intent)
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void showMap(Uri geoLocation) {
                            Intent intent = new Intent(Intent.ACTION_VIEW);
                            intent.setData(geoLocation);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivity(intent);
                            }
                        }

            **Example intent filter:**

            .. code:: prettyprint

               <activity ...>
                   <intent-filter>
                       <action android:name="android.intent.action.VIEW" />
                       <data android:scheme="geo" />
                       <category android:name="android.intent.category.DEFAULT" />
                   </intent-filter>
               </activity>

            .. rubric:: Music or video
               :name: Music

            The following are common actions for music and video apps,
            including the information you need to create an intent
            filter to advertise your app's ability to perform each
            action.

            .. rubric:: Play a media file
               :name: PlayMedia

            To play a music file, use the
            `ACTION_VIEW <#ACTION_VIEW>`__
            action and specify the URI location of the file in the
            intent data.

            **Action**
            `ACTION_VIEW <#ACTION_VIEW>`__
            **Data URI Scheme**
            ``file:``\ *``<URI>``*
            ``content:``\ *``<URI>``*
            ``http:``\ *``<URL>``*
            **MIME Type**
            ``"audio/*"``
            ``"application/ogg"``
            ``"application/x-ogg"``
            ``"application/itunes"``
            Or any other that your app requires.
            **Example intent:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        fun playMedia(file: Uri) {
                            val intent = Intent(Intent.ACTION_VIEW).apply {
                                data = file
                            }
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivity(intent)
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void playMedia(Uri file) {
                            Intent intent = new Intent(Intent.ACTION_VIEW);
                            intent.setData(file);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivity(intent);
                            }
                        }

            **Example intent filter:**

            .. code:: prettyprint

               <activity ...>
                   <intent-filter>
                       <action android:name="android.intent.action.VIEW" />
                       <data android:type="audio/*" />
                       <data android:type="application/ogg" />
                       <category android:name="android.intent.category.DEFAULT" />
                   </intent-filter>
               </activity>

            .. rubric:: Play music based on a search query
               :name: PlaySearch

            .. container:: voice-box

               .. container:: voice-img-cont

                  |image-voice-icon|

               Google Voice Actions

               -  "play michael jackson billie jean"

            To play music based on a search query, use the
            `INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH <#INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH>`__
            intent. An app might fire this intent in response to the
            user's voice command to play music. The receiving app for
            this intent performs a search within its inventory to match
            existing content to the given query and starts playing that
            content.

            In this intent, include the
            `EXTRA_MEDIA_FOCUS <#EXTRA_MEDIA_FOCUS>`__
            string extra, which specifies the intended search mode. For
            example, the search mode can specify whether the search is
            for an artist name or song name.

            **Action**
            `INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH <#INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH>`__
            **Data URI Scheme**
            None
            **MIME Type**
            None
            **Extras**
            `MediaStore.EXTRA_MEDIA_FOCUS <#EXTRA_MEDIA_FOCUS>`__
            (required)
            Indicates the search mode: whether the user is looking for a
            particular artist, album, song, or playlist. Most search
            modes take additional extras. For example, if the user is
            interested in listening to a particular song, the intent
            might have three additional extras: the song title, the
            artist, and the album. This intent supports the following
            search modes for each value of
            `EXTRA_MEDIA_FOCUS <#EXTRA_MEDIA_FOCUS>`__:

            *Any* -
            "vnd.android.cursor.item/\*"
            Play any music. The receiving app plays some music based on
            a smart choice, such as the last playlist the user listened
            to.

            Additional extras:

            -  `QUERY <#QUERY>`__
               (required): an empty string. This extra is always
               provided for backward compatibility. Existing apps that
               don't know about search modes can process this intent as
               an unstructured search.

            *Unstructured* - ``"vnd.android.cursor.item/*"``

            Play a particular song, album, or genre from an unstructured
            search query. Apps can generate an intent with this search
            mode when they can't identify the type of content the user
            wants to listen to. Use more specific search modes when
            possible.

            Additional extras:

            -  `QUERY <#QUERY>`__
               (required): a string that contains any combination of the
               artist, the album, the song name, or the genre.

            *Genre* -
            `Audio.Genres.ENTRY_CONTENT_TYPE <#ENTRY_CONTENT_TYPE>`__

            Play music of a particular genre.

            Additional extras:

            -  ``"android.intent.extra.genre"`` (required) - The genre.
            -  `QUERY <#QUERY>`__
               (required): the genre. This extra is always provided for
               backward compatibility. Existing apps that don't know
               about search modes can process this intent as an
               unstructured search.

            *Artist* -
            `Audio.Artists.ENTRY_CONTENT_TYPE <#ENTRY_CONTENT_TYPE>`__

            Play music from a particular artist.

            Additional extras:

            -  `EXTRA_MEDIA_ARTIST <#EXTRA_MEDIA_ARTIST>`__
               (required): the artist.
            -  ``"android.intent.extra.genre"``: the genre.
            -  `QUERY <#QUERY>`__
               (required): a string that contains any combination of the
               artist or the genre. This extra is always provided for
               backward compatibility. Existing apps that don't know
               about search modes can process this intent as an
               unstructured search.

            *Album* -
            `Audio.Albums.ENTRY_CONTENT_TYPE <#ENTRY_CONTENT_TYPE>`__

            Play music from a particular album.

            Additional extras:

            -  `EXTRA_MEDIA_ALBUM <#EXTRA_MEDIA_ALBUM>`__
               (required): the album.
            -  `EXTRA_MEDIA_ARTIST <#EXTRA_MEDIA_ARTIST>`__:
               the artist.
            -  ``"android.intent.extra.genre"``: the genre.
            -  `QUERY <#QUERY>`__
               (required): a string that contains any combination of the
               album or the artist. This extra is always provided for
               backward compatibility. Existing apps that don't know
               about search modes can process this intent as an
               unstructured search.

            *Song* - ``"vnd.android.cursor.item/audio"``

            Play a particular song.

            Additional extras:

            -  `EXTRA_MEDIA_ALBUM <#EXTRA_MEDIA_ALBUM>`__:
               the album.
            -  `EXTRA_MEDIA_ARTIST <#EXTRA_MEDIA_ARTIST>`__:
               the artist.
            -  ``"android.intent.extra.genre"``: the genre.
            -  `EXTRA_MEDIA_TITLE <#EXTRA_MEDIA_TITLE>`__
               (required): the song name.
            -  `QUERY <#QUERY>`__
               (required): a string that contains any combination of the
               album, the artist, the genre, or the title. This extra is
               always provided for backward compatibility. Existing apps
               that don't know about search modes can process this
               intent as an unstructured search.

            *Playlist* -
            `Audio.Playlists.ENTRY_CONTENT_TYPE <#ENTRY_CONTENT_TYPE>`__

            Android playlists are deprecated. The API is no longer
            maintained, but the current functionality remains for
            compatibility.
            Play a particular playlist or a playlist that matches some
            criteria specified by additional extras.

            Additional extras:

            -  `EXTRA_MEDIA_ALBUM <#EXTRA_MEDIA_ALBUM>`__:
               the album.
            -  `EXTRA_MEDIA_ARTIST <#EXTRA_MEDIA_ARTIST>`__:
               the artist.
            -  ``"android.intent.extra.genre"``: the genre.
            -  ``"android.intent.extra.playlist"``: the playlist.
            -  `EXTRA_MEDIA_TITLE <#EXTRA_MEDIA_TITLE>`__:
               the song name that the playlist is based on.
            -  `QUERY <#QUERY>`__
               (required): a string that contains any combination of the
               album, the artist, the genre, the playlist, or the title.
               This extra is always provided for backward compatibility.
               Existing apps that don't know about search modes can
               process this intent as an unstructured search.

            **Example intent:**

            If the user wants to listen to music from a particular
            artist, a search app might generate the following intent:

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        fun playSearchArtist(artist: String) {
                            val intent = Intent(MediaStore.INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH).apply {
                                putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE)
                                putExtra(MediaStore.EXTRA_MEDIA_ARTIST, artist)
                                putExtra(SearchManager.QUERY, artist)
                            }
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivity(intent)
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void playSearchArtist(String artist) {
                            Intent intent = new Intent(MediaStore.INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH);
                            intent.putExtra(MediaStore.EXTRA_MEDIA_FOCUS,
                                            MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE);
                            intent.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, artist);
                            intent.putExtra(SearchManager.QUERY, artist);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivity(intent);
                            }
                        }

            **Example intent filter:**

            .. code:: prettyprint

               <activity ...>
                   <intent-filter>
                       <action android:name="android.media.action.MEDIA_PLAY_FROM_SEARCH" />
                       <category android:name="android.intent.category.DEFAULT" />
                   </intent-filter>
               </activity>

            When handling this intent in your activity, check the value
            of the
            `EXTRA_MEDIA_FOCUS <#EXTRA_MEDIA_FOCUS>`__
            extra in the incoming
            `Intent <#>`__ to
            determine the search mode. Once your activity has identified
            the search mode, read the values of the additional extras
            for that particular search mode. With this information, your
            app can then perform the search within its inventory to play
            the content that matches the search query. This is shown in
            the following example.

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        override fun onCreate(savedInstanceState: Bundle?) {
                            ...
                            if (intent.action.compareTo(MediaStore.INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH) == 0) {

                                val mediaFocus: String? = intent.getStringExtra(MediaStore.EXTRA_MEDIA_FOCUS)
                                val query: String? = intent.getStringExtra(SearchManager.QUERY)

                                // Some of these extras might not be available depending on the search mode.
                                val album: String? = intent.getStringExtra(MediaStore.EXTRA_MEDIA_ALBUM)
                                val artist: String? = intent.getStringExtra(MediaStore.EXTRA_MEDIA_ARTIST)
                                val genre: String? = intent.getStringExtra("android.intent.extra.genre")
                                val playlist: String? = intent.getStringExtra("android.intent.extra.playlist")
                                val title: String? = intent.getStringExtra(MediaStore.EXTRA_MEDIA_TITLE)

                                // Determine the search mode and use the corresponding extras.
                                when {
                                    mediaFocus == null -> {
                                        // 'Unstructured' search mode (backward compatible)
                                        playUnstructuredSearch(query)
                                    }
                                    mediaFocus.compareTo("vnd.android.cursor.item/*") == 0 -> {
                                        if (query?.isNotEmpty() == true) {
                                            // 'Unstructured' search mode.
                                            playUnstructuredSearch(query)
                                        } else {
                                            // 'Any' search mode.
                                            playResumeLastPlaylist()
                                        }
                                    }
                                    mediaFocus.compareTo(MediaStore.Audio.Genres.ENTRY_CONTENT_TYPE) == 0 -> {
                                        // 'Genre' search mode.
                                        playGenre(genre)
                                    }
                                    mediaFocus.compareTo(MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE) == 0 -> {
                                        // 'Artist' search mode.
                                        playArtist(artist, genre)
                                    }
                                    mediaFocus.compareTo(MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE) == 0 -> {
                                        // 'Album' search mode.
                                        playAlbum(album, artist)
                                    }
                                    mediaFocus.compareTo("vnd.android.cursor.item/audio") == 0 -> {
                                        // 'Song' search mode.
                                        playSong(album, artist, genre, title)
                                    }
                                    mediaFocus.compareTo(MediaStore.Audio.Playlists.ENTRY_CONTENT_TYPE) == 0 -> {
                                        // 'Playlist' search mode.
                                        playPlaylist(album, artist, genre, playlist, title)
                                    }
                                }
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        protected void onCreate(Bundle savedInstanceState) {
                            //...
                            Intent intent = this.getIntent();
                            if (intent.getAction().compareTo(MediaStore.INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH) == 0) {

                                String mediaFocus = intent.getStringExtra(MediaStore.EXTRA_MEDIA_FOCUS);
                                String query = intent.getStringExtra(SearchManager.QUERY);

                                // Some of these extras might not be available depending on the search mode.
                                String album = intent.getStringExtra(MediaStore.EXTRA_MEDIA_ALBUM);
                                String artist = intent.getStringExtra(MediaStore.EXTRA_MEDIA_ARTIST);
                                String genre = intent.getStringExtra("android.intent.extra.genre");
                                String playlist = intent.getStringExtra("android.intent.extra.playlist");
                                String title = intent.getStringExtra(MediaStore.EXTRA_MEDIA_TITLE);

                                // Determine the search mode and use the corresponding extras.
                                if (mediaFocus == null) {
                                    // 'Unstructured' search mode (backward compatible).
                                    playUnstructuredSearch(query);

                                } else if (mediaFocus.compareTo("vnd.android.cursor.item/*") == 0) {
                                    if (query.isEmpty()) {
                                        // 'Any' search mode.
                                        playResumeLastPlaylist();
                                    } else {
                                        // 'Unstructured' search mode.
                                        playUnstructuredSearch(query);
                                    }

                                } else if (mediaFocus.compareTo(MediaStore.Audio.Genres.ENTRY_CONTENT_TYPE) == 0) {
                                    // 'Genre' search mode.
                                    playGenre(genre);

                                } else if (mediaFocus.compareTo(MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE) == 0) {
                                    // 'Artist' search mode.
                                    playArtist(artist, genre);

                                } else if (mediaFocus.compareTo(MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE) == 0) {
                                    // 'Album' search mode.
                                    playAlbum(album, artist);

                                } else if (mediaFocus.compareTo("vnd.android.cursor.item/audio") == 0) {
                                    // 'Song' search mode.
                                    playSong(album, artist, genre, title);

                                } else if (mediaFocus.compareTo(MediaStore.Audio.Playlists.ENTRY_CONTENT_TYPE) == 0) {
                                    // 'Playlist' search mode.
                                    playPlaylist(album, artist, genre, playlist, title);
                                }
                            }
                        }

            .. rubric:: New note
               :name: NewNote

            Creating a note is a common action for note-taking apps.
            Create an intent filter to advertise your app's ability to
            perform this action using the information in the following
            section.

            .. rubric:: Create a note
               :name: CreateNote

            To create a new note, use the
            `ACTION_CREATE_NOTE <https://developers.google.cn/android/reference/com/google/android/gms/actions/NoteIntents#ACTION_CREATE_NOTE>`__
            action and specify note details such as the subject and text
            using following extras.

            **Note:** Apps must ask for confirmation from the user
            before completing this action.

            **Action**
               `ACTION_CREATE_NOTE <https://developers.google.cn/android/reference/com/google/android/gms/actions/NoteIntents#ACTION_CREATE_NOTE>`__
            **Data URI Scheme**
               None
            **MIME Type**
               `PLAIN_TEXT_TYPE <https://developer.android.google.cn/reference/org/apache/http/protocol/HTTP.html#PLAIN_TEXT_TYPE>`__
               "\*/\*"
            **Extras**
               `EXTRA_NAME <https://developers.google.cn/android/reference/com/google/android/gms/actions/NoteIntents#EXTRA_NAME>`__
                  A string indicating the title or subject of the note.
               `EXTRA_TEXT <https://developers.google.cn/android/reference/com/google/android/gms/actions/NoteIntents#EXTRA_TEXT>`__
                  A string indicating the text of the note.

            **Action**
               -  `ACTION_DIAL <#ACTION_DIAL>`__
                  - Opens the dialer or phone app.
               -  `ACTION_CALL <#ACTION_CALL>`__
                  - Places a phone call (requires the ``CALL_PHONE``
                  permission)
            **Data URI Scheme**
               -  ``tel:<phone-number>``
               -  ``voicemail:<phone-number>``
            **MIME Type**
               None

            Valid telephone numbers are those defined in `the IETF RFC 3966 <http://tools.ietf.org/html/rfc3966>`__. Valid examples
            include the following:

            -  ``tel:2125551212``
            -  ``tel:(212) 555 1212``

            The Phone app's dialer is good at normalizing schemes, such
            as telephone numbers. So the scheme described isn't strictly
            required in the
            `Uri.parse() <#parse>`__
            method. However, if you haven't tried a scheme or are unsure
            whether it can be handled, use the
            `Uri.fromParts() <#fromParts>`__
            method instead.

            **Example intent:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        fun dialPhoneNumber(phoneNumber: String) {
                            val intent = Intent(Intent.ACTION_DIAL).apply {
                                data = Uri.parse("tel:$phoneNumber")
                            }
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivity(intent)
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void dialPhoneNumber(String phoneNumber) {
                            Intent intent = new Intent(Intent.ACTION_DIAL);
                            intent.setData(Uri.parse("tel:" + phoneNumber));
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivity(intent);
                            }
                        }

            .. rubric:: Search
               :name: Search

            The following are common actions for search apps, including
            the information you need to create an intent filter to
            advertise your app's ability to perform each action.

            .. rubric:: Search using a specific app
               :name: SearchOnApp

            .. container:: voice-box

               .. container:: voice-img-cont

                  |image-voice-icon|

               Google Voice Actions

               -  "search for cat videos on myvideoapp"

            To support search within the context of your app, declare an
            intent filter in your app with the ``SEARCH_ACTION`` action,
            as shown in the following intent filter example.

            **Note:** We don't recommend using ``SEARCH_ACTION`` for app
            search. Instead, implement the
            `GET_THING <https://developers.google.cn/assistant/app/reference/built-in-intents/common/get-thing>`__
            action to leverage Google Assistant's built-in support for
            in-app search. For more information, see the Google
            Assistant `App Actions <https://developers.google.cn/assistant/app/overview>`__
            documentation.

            .. container:: video-wrapper-left

            **Action**

            ``"com.google.android.gms.actions.SEARCH_ACTION"``
               Support search queries from Google Voice Actions.

            **Extras**

            `QUERY <#QUERY>`__
               A string that contains the search query.

            **Example intent filter:**

            .. code:: prettyprint

               <activity android:name=".SearchActivity">
                   <intent-filter>
                       <action android:name="com.google.android.gms.actions.SEARCH_ACTION"/>
                       <category android:name="android.intent.category.DEFAULT"/>
                   </intent-filter>
               </activity>

            .. rubric:: Perform a web search
               :name: SearchWeb

            To initiate a web search, use the
            `ACTION_WEB_SEARCH <#ACTION_WEB_SEARCH>`__
            action and specify the search string in the
            `SearchManager.QUERY <#QUERY>`__
            extra.

            **Action**
               `ACTION_WEB_SEARCH <#ACTION_WEB_SEARCH>`__
            **Data URI Scheme**
               None
            **MIME Type**
               None
            **Extras**
               `SearchManager.QUERY <#QUERY>`__
                  The search string.

            **Example intent:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        fun searchWeb(query: String) {
                            val intent = Intent(Intent.ACTION_WEB_SEARCH).apply {
                                putExtra(SearchManager.QUERY, query)
                            }
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivity(intent)
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void searchWeb(String query) {
                            Intent intent = new Intent(Intent.ACTION_WEB_SEARCH);
                            intent.putExtra(SearchManager.QUERY, query);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivity(intent);
                            }
                        }

            .. rubric:: Settings
               :name: Settings

            To open a screen in the system Settings app when your app
            requires the user to change something, use one of the
            following intent actions:

            **Action**
               | `ACTION_SETTINGS <#ACTION_SETTINGS>`__
               | `ACTION_WIRELESS_SETTINGS <#ACTION_WIRELESS_SETTINGS>`__
               | `ACTION_AIRPLANE_MODE_SETTINGS <#ACTION_AIRPLANE_MODE_SETTINGS>`__
               | `ACTION_WIFI_SETTINGS <#ACTION_WIFI_SETTINGS>`__
               | `ACTION_APN_SETTINGS <#ACTION_APN_SETTINGS>`__
               | `ACTION_BLUETOOTH_SETTINGS <#ACTION_BLUETOOTH_SETTINGS>`__
               | `ACTION_DATE_SETTINGS <#ACTION_DATE_SETTINGS>`__
               | `ACTION_LOCALE_SETTINGS <#ACTION_LOCALE_SETTINGS>`__
               | `ACTION_INPUT_METHOD_SETTINGS <#ACTION_INPUT_METHOD_SETTINGS>`__
               | `ACTION_DISPLAY_SETTINGS <#ACTION_DISPLAY_SETTINGS>`__
               | `ACTION_SECURITY_SETTINGS <#ACTION_SECURITY_SETTINGS>`__
               | `ACTION_LOCATION_SOURCE_SETTINGS <#ACTION_LOCATION_SOURCE_SETTINGS>`__
               | `ACTION_INTERNAL_STORAGE_SETTINGS <#ACTION_INTERNAL_STORAGE_SETTINGS>`__
               | `ACTION_MEMORY_CARD_SETTINGS <#ACTION_MEMORY_CARD_SETTINGS>`__

               For additional settings screens that are available, see
               the
               `Settings <#>`__
               documentation .

            **Data URI Scheme**
               None
            **MIME Type**
               None

            **Example intent:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        fun openWifiSettings() {
                            val intent = Intent(Settings.ACTION_WIFI_SETTINGS)
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivity(intent)
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void openWifiSettings() {
                            Intent intent = new Intent(Settings.ACTION_WIFI_SETTINGS);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivity(intent);
                            }
                        }

            .. rubric:: Text messaging
               :name: Messaging

            Composing an SMS/MMS message with an attachment is a common
            action for text messaging apps. Create an intent filter to
            advertise your app's ability to perform this action using
            the information in the following section.

            .. rubric:: Compose an SMS/MMS message with attachment
               :name: SendMessage

            To initiate an SMS or MMS text message, use one of the
            following intent actions and specify message details such as
            the phone number, subject, and message body using the
            following extra keys.

            **Action**
            `ACTION_SENDTO <#ACTION_SENDTO>`__
            or
            `ACTION_SEND <#ACTION_SEND>`__
            or
            `ACTION_SEND_MULTIPLE <#ACTION_SEND_MULTIPLE>`__
            **Data URI Scheme**
            ``sms:``\ *``<phone_number>``*
            ``smsto:``\ *``<phone_number>``*
            ``mms:``\ *``<phone_number>``*
            ``mmsto:``\ *``<phone_number>``*
            These schemes are all handled the same way.

            **MIME Type**
            ``"text/plain"``
            ``"image/*"``
            ``"video/*"``
            **Extras**

            ``"subject"``
               A string for the message subject (usually for MMS only).
            ``"sms_body"``
               A string for the text message.
            `EXTRA_STREAM <#EXTRA_STREAM>`__
               A `Uri <#>`__ pointing to
               the image or video to attach. If using the
               `ACTION_SEND_MULTIPLE <#ACTION_SEND_MULTIPLE>`__
               action, this extra is an
               `ArrayList <#>`__ of
               ``Uri`` objects pointing to the images or videos to
               attach.

            **Example intent:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        fun composeMmsMessage(message: String, attachment: Uri) {
                            val intent = Intent(Intent.ACTION_SENDTO).apply {
                                type = HTTP.PLAIN_TEXT_TYPE
                                putExtra("sms_body", message)
                                putExtra(Intent.EXTRA_STREAM, attachment)
                            }
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivity(intent)
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void composeMmsMessage(String message, Uri attachment) {
                            Intent intent = new Intent(Intent.ACTION_SENDTO);
                            intent.setType(HTTP.PLAIN_TEXT_TYPE);
                            intent.putExtra("sms_body", message);
                            intent.putExtra(Intent.EXTRA_STREAM, attachment);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivity(intent);
                            }
                        }

            If you want to make sure that your intent is handled only by
            a text messaging app, and not other email or social apps,
            then use the
            `ACTION_SENDTO <#ACTION_SENDTO>`__
            action and include the ``"smsto:"`` data scheme as shown in
            the following example:

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        fun composeMmsMessage(message: String, attachment: Uri) {
                            val intent = Intent(Intent.ACTION_SEND).apply {
                                data = Uri.parse("smsto:")  // Only SMS apps respond to this.
                                putExtra("sms_body", message)
                                putExtra(Intent.EXTRA_STREAM, attachment)
                            }
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivity(intent)
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void composeMmsMessage(String message, Uri attachment) {
                            Intent intent = new Intent(Intent.ACTION_SEND);
                            intent.setData(Uri.parse("smsto:"));  // Only SMS apps respond to this.
                            intent.putExtra("sms_body", message);
                            intent.putExtra(Intent.EXTRA_STREAM, attachment);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivity(intent);
                            }
                        }

            **Example intent filter:**

            .. code:: prettyprint

               <activity ...>
                   <intent-filter>
                       <action android:name="android.intent.action.SEND" />
                       <data android:type="text/plain" />
                       <data android:type="image/*" />
                       <category android:name="android.intent.category.DEFAULT" />
                   </intent-filter>
               </activity>

            **Note:** If you're developing an SMS/MMS messaging app, you
            must implement intent filters for several additional actions
            in order to be available as the *default SMS app* on Android
            4.4 and higher. For more information, see the documentation
            at
            `Telephony <#>`__.

            .. rubric:: Web browser
               :name: Browser

            Loading a web URL is a common action for web browser apps.
            Create an intent filter to advertise your app's ability to
            perform this action using the information in the following
            section.

            .. rubric:: Load a web URL
               :name: ViewUrl

            .. container:: voice-box

               .. container:: voice-img-cont

                  |image-voice-icon|

               Google Voice Actions

               -  "open example.com"

            To open a web page, use the
            `ACTION_VIEW <#ACTION_VIEW>`__
            action and specify the web URL in the intent data.

            **Action**
            `ACTION_VIEW <#ACTION_VIEW>`__
            **Data URI Scheme**
            ``http:``\ *``<URL>``*
            ``https:``\ *``<URL>``*
            **MIME Type**
            ``"text/plain"``
            ``"text/html"``
            ``"application/xhtml+xml"``
            ``"application/vnd.wap.xhtml+xml"``
            **Example intent:**

            .. container::

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Kotlin
                        :name: kotlin

                     .. code:: prettyprint

                        fun openWebPage(url: String) {
                            val webpage: Uri = Uri.parse(url)
                            val intent = Intent(Intent.ACTION_VIEW, webpage)
                            if (intent.resolveActivity(packageManager) != null) {
                                startActivity(intent)
                            }
                        }

                  .. container:: section

                     .. rubric:: Java
                        :name: java

                     .. code:: prettyprint

                        public void openWebPage(String url) {
                            Uri webpage = Uri.parse(url);
                            Intent intent = new Intent(Intent.ACTION_VIEW, webpage);
                            if (intent.resolveActivity(getPackageManager()) != null) {
                                startActivity(intent);
                            }
                        }

            **Example intent filter:**

            .. code:: prettyprint

               <activity ...>
                   <intent-filter>
                       <action android:name="android.intent.action.VIEW" />
                       <!-- Include the host attribute if you want your app to respond
                            only to URLs with your app's domain. -->
                       <data android:scheme="http" android:host="www.example.com" />
                       <category android:name="android.intent.category.DEFAULT" />
                       <!-- The BROWSABLE category is required to get links from web pages. -->
                       <category android:name="android.intent.category.BROWSABLE" />
                   </intent-filter>
               </activity>

            .. note::

               **Tip:** If your Android app provides functionality
               similar to your web site, include an intent filter for
               URLs that point to your web site. Then, if users have
               your app installed, links from emails or other web pages
               pointing to your web site open your Android app instead
               of your web page. Learn more in `Handling Android App Links <#>`__.

               Starting in ``Android 12`` (API ``level 31``), a generic web
               intent resolves to an activity in your app only if your
               app is approved for the specific domain contained in that
               web intent. If your app isn't approved for the domain,
               the web intent resolves to the user's default browser app
               instead.

            .. rubric:: Verify intents with the Android Debug Bridge
               :name: AdbIntents

            To verify that your app responds to the intents that you
            want to support, you can use the
            `adb <#>`__ tool to fire specific intents
            by doing the following:

            #. Set up an Android device for `development <#setting-up>`__ or use a
               `virtual device <#avds>`__.

            #. Install a version of your app that handles the intents
               you want to support.

            #. Fire an intent using ``adb``:

               .. code:: none

                  adb shell am start -a <ACTION> -t <MIME_TYPE> -d <DATA> \
                    -e <EXTRA_NAME> <EXTRA_VALUE> -n <ACTIVITY>

               For example:

               .. code:: none

                  adb shell am start -a android.intent.action.DIAL \
                    -d tel:555-5555 -n org.example.MyApp/.MyActivity

            #. If you define the required intent filters, handle the
               intent.

            For more information, see `Issue shell commands <#am>`__.

            Content and code samples on this page are subject to the
            licenses described in the `Content License <#>`__.
            Java and OpenJDK are trademarks or registered trademarks of
            Oracle and/or its affiliates.

Last updated 2024-05-03 UTC.

.. |image-voice-icon| image:: https://developer.android.google.cn/static/guide/components/images/voice-icon.png
   :class: voice-img
   :width: 30px
   :height: 30px
   :target: https://developers.google.cn/voice-actions/system/#system_actions_reference


/Sending the user to another app
================================

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   One of Android's most important features is an app's ability to send
   the user to another app based on an "action" it would like to
   perform. For example, if your app has the address of a business that
   you'd like to show on a map, you don't have to build an activity in
   your app that shows a map. Instead, you can create a request to view
   the address using an
   `Intent <#>`__. The Android
   system then starts an app that's able to show the address on a map.

   As explained in the first class, `Building Your First App <#>`__, you must use intents to navigate
   between activities in your own app. You generally do so with an
   *explicit intent*, which defines the exact class name of the
   component you want to start. However, when you want to have a
   separate app perform an action, such as "view a map," you must use an
   *implicit intent*.

   This lesson shows you how to create an implicit intent for a
   particular action, and how to use it to start an activity that
   performs the action in another app. Also see the video embedded here
   to understand why it's important that you include runtime checks for
   your implicit intents.

   .. rubric:: Build an implicit intent
      :name: Build

   Implicit intents do not declare the class name of the component to
   start, but instead declare an action to perform. The action specifies
   the thing you want to do, such as *view*, *edit*, *send*, or *get*
   something.

   .. rubric:: Associate intent actions with data
      :name: associate-with-data

   Intents often also include data associated with the action, such as
   the address you want to view, or the email message you want to send.
   Depending on the intent you want to create, the data might be a
   `Uri <#>`__, one of several other data
   types, or the intent might not need data at all.

   If your data is a `Uri <#>`__, there's a
   simple
   `Intent() <#Intent>`__
   constructor you can use to define the action and data.

   For example, here's how to create an intent to initiate a phone call
   using the `Uri <#>`__ data to specify
   the telephone number:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val callIntent: Intent = Uri.parse("tel:5551234").let { number ->
                   Intent(Intent.ACTION_DIAL, number)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Uri number = Uri.parse("tel:5551234");
               Intent callIntent = new Intent(Intent.ACTION_DIAL, number);

   When your app invokes this intent by calling
   `startActivity() <#startActivity>`__,
   the Phone app initiates a call to the given phone number.

   Here are a couple other intents and their action and
   `Uri <#>`__ data pairs:

   .. rubric:: View a map
      :name: view-map

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Map point based on address
               val mapIntent: Intent = Uri.parse(
                       "geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California"
               ).let { location ->
                   // Or map point based on latitude/longitude
                   // val location: Uri = Uri.parse("geo:37.422219,-122.08364?z=14") // z param is zoom level
                   Intent(Intent.ACTION_VIEW, location)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Map point based on address
               Uri location = Uri.parse("geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California");
               // Or map point based on latitude/longitude
               // Uri location = Uri.parse("geo:37.422219,-122.08364?z=14"); // z param is zoom level
               Intent mapIntent = new Intent(Intent.ACTION_VIEW, location);

   .. rubric:: View a web page
      :name: view-web-page

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val webIntent: Intent = Uri.parse("https://www.android.com").let { webpage ->
                   Intent(Intent.ACTION_VIEW, webpage)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Uri webpage = Uri.parse("https://www.android.com");
               Intent webIntent = new Intent(Intent.ACTION_VIEW, webpage);

   .. rubric:: Add extras to an intent
      :name: add-extras

   Other kinds of implicit intents require "extra" data that provide
   different data types, such as a string. You can add one or more
   pieces of extra data using the various
   `putExtra() <#putExtra>`__
   methods.

   By default, the system determines the appropriate MIME type required
   by an intent based on the `Uri <#>`__
   data that's included. If you don't include a
   `Uri <#>`__ in the intent, you should
   usually use
   `setType() <#setType>`__
   to specify the type of data associated with the intent. Setting the
   MIME type further specifies which kinds of activities should receive
   the intent.

   Here are some more intents that add extra data to specify the desired
   action:

   .. rubric:: Send an email with an attachment
      :name: email-with-attachment

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               Intent(Intent.ACTION_SEND).apply {
                   // The intent does not have a URI, so declare the "text/plain" MIME type
                   type = "text/plain"
                   putExtra(Intent.EXTRA_EMAIL, arrayOf("jan@example.com")) // recipients
                   putExtra(Intent.EXTRA_SUBJECT, "Email subject")
                   putExtra(Intent.EXTRA_TEXT, "Email message text")
                   putExtra(Intent.EXTRA_STREAM, Uri.parse("content://path/to/email/attachment"))
                   // You can also attach multiple items by passing an ArrayList of Uris
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Intent emailIntent = new Intent(Intent.ACTION_SEND);
               // The intent does not have a URI, so declare the "text/plain" MIME type
               emailIntent.setType(HTTP.PLAIN_TEXT_TYPE);
               emailIntent.putExtra(Intent.EXTRA_EMAIL, new String[] {"jan@example.com"}); // recipients
               emailIntent.putExtra(Intent.EXTRA_SUBJECT, "Email subject");
               emailIntent.putExtra(Intent.EXTRA_TEXT, "Email message text");
               emailIntent.putExtra(Intent.EXTRA_STREAM, Uri.parse("content://path/to/email/attachment"));
               // You can also attach multiple items by passing an ArrayList of Uris

   .. rubric:: Create a calendar event
      :name: create-calendar-event

   **Note:** This intent for a calendar event is supported only with API
   level 14 and higher.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Event is on January 23, 2021 -- from 7:30 AM to 10:30 AM.
               Intent(Intent.ACTION_INSERT, Events.CONTENT_URI).apply {
                   val beginTime: Calendar = Calendar.getInstance().apply {
                       set(2021, 0, 23, 7, 30)
                   }
                   val endTime = Calendar.getInstance().apply {
                       set(2021, 0, 23, 10, 30)
                   }
                   putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, beginTime.timeInMillis)
                   putExtra(CalendarContract.EXTRA_EVENT_END_TIME, endTime.timeInMillis)
                   putExtra(Events.TITLE, "Ninja class")
                   putExtra(Events.EVENT_LOCATION, "Secret dojo")
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Event is on January 23, 2021 -- from 7:30 AM to 10:30 AM.
               Intent calendarIntent = new Intent(Intent.ACTION_INSERT, Events.CONTENT_URI);
               Calendar beginTime = Calendar.getInstance();
               beginTime.set(2021, 0, 23, 7, 30);
               Calendar endTime = Calendar.getInstance();
               endTime.set(2021, 0, 23, 10, 30);
               calendarIntent.putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, beginTime.getTimeInMillis());
               calendarIntent.putExtra(CalendarContract.EXTRA_EVENT_END_TIME, endTime.getTimeInMillis());
               calendarIntent.putExtra(Events.TITLE, "Ninja class");
               calendarIntent.putExtra(Events.EVENT_LOCATION, "Secret dojo");

   **Note:** It's important that you define your
   `Intent <#>`__ to be as specific
   as possible. For example, if you want to display an image using the
   `ACTION_VIEW <#ACTION_VIEW>`__
   intent, you should specify a MIME type of ``image/*``. This prevents
   apps that can "view" other types of data (like a map app) from being
   triggered by the intent.

   .. rubric:: Start an activity with the intent
      :name: StartActivity

   Once you have created your
   `Intent <#>`__ and set the extra
   info, call
   `startActivity() <#startActivity>`__
   to send it to the system:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               startActivity(intent)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               startActivity(intent);

   .. rubric:: Handle the situation where no app can receive an intent
      :name: no-app-available

   Although many intents are successfully handled by another app that's
   installed on the device‚Äîsuch as a phone, email, or calendar app‚Äîyour
   app should prepare for the situation where no activity can handle
   your app's intent. Whenever you invoke an intent, be ready to catch
   an
   `ActivityNotFoundException <#>`__,
   which occurs if there's no other activity that can handle your app's
   intent:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               try {
                   startActivity(intent)
               } catch (e: ActivityNotFoundException) {
                   // Define what your app should do if no activity can handle the intent.
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               try {
                   startActivity(intent);
               } catch (ActivityNotFoundException e) {
                   // Define what your app should do if no activity can handle the intent.
               }

   After you catch this exception, decide what your app should do next.
   This next step depends on the specific characteristics of the intent
   that you tried to invoke. For example, if you know of a specific app
   that can handle the intent, provide a link for the user to download
   the app. Learn more about how to `link to your product on Google Play <#>`__.

   .. rubric:: Disambiguation dialog
      :name: disambiguation-dialog

   If the system identifies more than one activity that can handle the
   intent, it displays a dialog (sometimes referred to as the
   "disambiguation dialog") for the user to select which app to use, as
   shown in figure 1. If there is only one activity that handles the
   intent, the system immediately starts it.

   .. figure:: https://developer.android.google.cn/static/images/training/basics/intents-choice.png

      A panel appears near the bottom of the screen. This panel lists
      the different apps that could handle the intent.

      **Figure 1.** Example of the selection dialog that appears when
      more than one app can handle an intent.

   .. rubric:: Complete example
      :name: complete-example

   Here's a complete example that shows how to create an intent to view
   a map, verify that an app exists to handle the intent, then start it:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Build the intent.
               val location = Uri.parse("geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California")
               val mapIntent = Intent(Intent.ACTION_VIEW, location)

               // Try to invoke the intent.
               try {
                   startActivity(mapIntent)
               } catch (e: ActivityNotFoundException) {
                   // Define what your app should do if no activity can handle the intent.
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Build the intent.
               Uri location = Uri.parse("geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California");
               Intent mapIntent = new Intent(Intent.ACTION_VIEW, location);

               // Try to invoke the intent.
               try {
                   startActivity(mapIntent);
               } catch (ActivityNotFoundException e) {
                   // Define what your app should do if no activity can handle the intent.
               }

   .. rubric:: Show an app chooser
      :name: AppChooser

   .. container:: attempt-right

      .. figure:: https://developer.android.google.cn/static/images/training/basics/intent-chooser.png

      **Figure 2.** A chooser dialog.

   Notice that when you start an activity by passing your
   `Intent <#>`__ to
   `startActivity() <#startActivity>`__
   and there is more than one app that responds to the intent, the user
   can select which app to use by default (by selecting a checkbox at
   the bottom of the dialog; see figure 1). This is nice when performing
   an action for which the user generally wants to use the same app
   every time, such as when opening a web page (users likely use just
   one web browser) or taking a photo (users likely prefer one camera).

   However, if the action to be performed could be handled by multiple
   apps and the user might prefer a different app each time‚Äîsuch as a
   "share" action, for which users might have several apps through which
   they might share an item‚Äîyou should explicitly show a chooser dialog
   as shown in figure 2. The chooser dialog forces the user to select
   which app to use for the action every time (the user cannot select a
   default app for the action).

   To show the chooser, create an
   `Intent <#>`__ using
   `createChooser() <#createChooser>`__
   and pass it to
   `startActivity() <#startActivity>`__.
   For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val intent = Intent(Intent.ACTION_SEND)

               // Create intent to show chooser
               val chooser = Intent.createChooser(intent, /* title */ null)

               // Try to invoke the intent.
               try {
                   startActivity(chooser)
               } catch (e: ActivityNotFoundException) {
                   // Define what your app should do if no activity can handle the intent.
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Intent intent = new Intent(Intent.ACTION_SEND);

               // Create intent to show chooser
               Intent chooser = Intent.createChooser(intent, /* title */ null);

               // Try to invoke the intent.
               try {
                   startActivity(chooser);
               } catch (ActivityNotFoundException e) {
                   // Define what your app should do if no activity can handle the intent.
               }

   This displays a dialog with a list of apps that respond to the intent
   passed to the
   ``\ `createChooser() <#createChooser>`__
   method. The ``title`` parameter may be supplied if the action is not
   ``\ `ACTION_SEND <#ACTION_SEND>`__
   or
   ``\ `ACTION_SEND_MULTIPLE <#ACTION_SEND_MULTIPLE>`__

.. container:: devsite-steps


Last updated 2024-01-03 UTC.


/Get a result from an activity
==============================

.. container:: devsite-article-body clearfix

   Starting another activity, whether it is one within your app or from
   another app, doesn't need to be a one-way operation. You can also
   start an activity and receive a result back. For example, your app
   can start a camera app and receive the captured photo as a result. Or
   you might start the Contacts app for the user to select a contact,
   and then receive the contact details as a result.

   While the underlying `startActivityForResult() <#startActivityForResult>`__
   and `onActivityResult() <#onActivityResult>`__
   APIs are available on the ``Activity`` class on all API levels,
   Google strongly recommends using the Activity Result APIs introduced
   in AndroidX `Activity <#>`__ and `Fragment <#>`__ classes.

   The Activity Result APIs provide components for registering for a
   result, launching the result, and handling the result once it is
   dispatched by the system.

   .. rubric:: Register a callback for an activity result
      :name: register

   When starting an activity for a result, it is possible‚Äîand, in cases
   of memory-intensive operations such as camera usage, almost
   certain‚Äîthat your process and your activity will be destroyed due to
   low memory.

   For this reason, the Activity Result APIs decouple the result
   callback from the place in your code where you launch the other
   activity. Because the result callback needs to be available when your
   process and activity are recreated, the callback must be
   unconditionally registered every time your activity is created, even
   if the logic of launching the other activity only happens based on
   user input or other business logic.

   When in a `ComponentActivity <#>`__ or a `Fragment <#>`__,
   the Activity Result APIs provide a
   `registerForActivityResult() <#public-methods_1>`__
   API for registering the result callback.
   ``registerForActivityResult()`` takes an
   `ActivityResultContract <#>`__
   and an `ActivityResultCallback <#>`__
   and returns an `ActivityResultLauncher <#>`__,
   which you use to launch the other activity.

   An ``ActivityResultContract`` defines the input type needed to
   produce a result along with the output type of the result. The APIs
   provide `default contracts <#>`__
   for basic intent actions like taking a picture, requesting
   permissions, and so on. You can also `create a custom contract <#custom>`__.

   ``ActivityResultCallback`` is a single method interface with an
   `onActivityResult() <#onActivityResult>`__
   method that takes an object of the output type defined in the
   ``ActivityResultContract``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val getContent = registerForActivityResult(GetContent()) { uri: Uri? ->
                   // Handle the returned Uri
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // GetContent creates an ActivityResultLauncher<String> to let you pass
               // in the mime type you want to let the user select
               ActivityResultLauncher<String> mGetContent = registerForActivityResult(new GetContent(),
                   new ActivityResultCallback<Uri>() {
                       @Override
                       public void onActivityResult(Uri uri) {
                           // Handle the returned Uri
                       }
               });

   If you have multiple activity result calls and you either use
   different contracts or want separate callbacks, you can call
   ``registerForActivityResult()`` multiple times to register multiple
   ``ActivityResultLauncher`` instances. You must call
   ``registerForActivityResult()`` in the same order for each creation
   of your fragment or activity so that the inflight results are
   delivered to the correct callback.

   ``registerForActivityResult()`` is safe to call before your fragment
   or activity is created, letting it be used directly when declaring
   member variables for the returned ``ActivityResultLauncher``
   instances.

   **Note:**\  You must call ``registerForActivityResult()`` before the
   fragment or activity is created, but you can't launch the
   ``ActivityResultLauncher`` until the fragment or activity's
   `Lifecycle <#>`__ has
   reached
   `CREATED <#CREATED>`__.

   .. rubric:: Launch an activity for result
      :name: launch

   While ``registerForActivityResult()`` registers your callback, it
   does *not* launch the other activity and kick off the request for a
   result. Instead, this is the responsibility of the returned
   ``ActivityResultLauncher`` instance.

   If input exists, the launcher takes the input that matches the type
   of the ``ActivityResultContract``. Calling
   `launch() <#launch>`__
   starts the process of producing the result. When the user is done
   with the subsequent activity and returns, the ``onActivityResult()``
   from the ``ActivityResultCallback`` is then executed, as shown in the
   following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val getContent = registerForActivityResult(GetContent()) { uri: Uri? ->
                   // Handle the returned Uri
               }

               override fun onCreate(savedInstanceState: Bundle?) {
                   // ...

                   val selectButton = findViewById<Button>(R.id.select_button)

                   selectButton.setOnClickListener {
                       // Pass in the mime type you want to let the user select
                       // as the input
                       getContent.launch("image/*")
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ActivityResultLauncher<String> mGetContent = registerForActivityResult(new GetContent(),
                   new ActivityResultCallback<Uri>() {
                       @Override
                       public void onActivityResult(Uri uri) {
                           // Handle the returned Uri
                       }
               });

               @Override
               public void onCreate(@Nullable Bundle savedInstanceState) {
                   // ...

                   Button selectButton = findViewById(R.id.select_button);

                   selectButton.setOnClickListener(new OnClickListener() {
                       @Override
                       public void onClick(View view) {
                           // Pass in the mime type you want to let the user select
                           // as the input
                           mGetContent.launch("image/*");
                       }
                   });
               }

   An overloaded version of
   `launch() <#launch>`__
   lets you pass an
   `ActivityOptionsCompat <#>`__
   in addition to the input.

   **Note:**\  Since your process and activity can be destroyed between
   when you call ``launch()`` and when the ``onActivityResult()``
   callback is triggered, any additional state needed to handle the
   result must be saved and restored separately from these APIs.

   .. rubric:: Receive an activity result in a separate class
      :name: separate

   While the ``ComponentActivity`` and ``Fragment`` classes implement
   the
   `ActivityResultCaller <#>`__
   interface to let you use the ``registerForActivityResult()`` APIs,
   you can also receive the activity result in a separate class that
   doesn't implement ``ActivityResultCaller`` by using
   `ActivityResultRegistry <#>`__
   directly.

   For example, you might want to implement a
   `LifecycleObserver <#>`__
   that handles registering a contract along with launching the
   launcher:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyLifecycleObserver(private val registry : ActivityResultRegistry)
                       : DefaultLifecycleObserver {
                   lateinit var getContent : ActivityResultLauncher<String>

                   override fun onCreate(owner: LifecycleOwner) {
                       getContent = registry.register("key", owner, GetContent()) { uri ->
                           // Handle the returned Uri
                       }
                   }

                   fun selectImage() {
                       getContent.launch("image/*")
                   }
               }

               class MyFragment : Fragment() {
                   lateinit var observer : MyLifecycleObserver

                   override fun onCreate(savedInstanceState: Bundle?) {
                       // ...

                       observer = MyLifecycleObserver(requireActivity().activityResultRegistry)
                       lifecycle.addObserver(observer)
                   }

                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       val selectButton = view.findViewById<Button>(R.id.select_button)

                       selectButton.setOnClickListener {
                           // Open the activity to select an image
                           observer.selectImage()
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class MyLifecycleObserver implements DefaultLifecycleObserver {
                   private final ActivityResultRegistry mRegistry;
                   private ActivityResultLauncher<String> mGetContent;

                   MyLifecycleObserver(@NonNull ActivityResultRegistry registry) {
                       mRegistry = registry;
                   }

                   public void onCreate(@NonNull LifecycleOwner owner) {
                       // ...

                       mGetContent = mRegistry.register(‚Äúkey‚Äù, owner, new GetContent(),
                           new ActivityResultCallback<Uri>() {
                               @Override
                               public void onActivityResult(Uri uri) {
                                   // Handle the returned Uri
                               }
                           });
                   }

                   public void selectImage() {
                       // Open the activity to select an image
                       mGetContent.launch("image/*");
                   }
               }

               class MyFragment extends Fragment {
                   private MyLifecycleObserver mObserver;

                   @Override
                   void onCreate(Bundle savedInstanceState) {
                       // ...

                       mObserver = new MyLifecycleObserver(requireActivity().getActivityResultRegistry());
                       getLifecycle().addObserver(mObserver);
                   }

                   @Override
                   void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       Button selectButton = findViewById(R.id.select_button);
                       selectButton.setOnClickListener(new OnClickListener() {
                           @Override
                           public void onClick(View view) {
                               mObserver.selectImage();
                           }
                       });
                   }
               }

   When using the ``ActivityResultRegistry`` APIs, Google strongly
   recommends using the APIs that take a ``LifecycleOwner``, as the
   ``LifecycleOwner`` automatically removes your registered launcher
   when the ``Lifecycle`` is destroyed. However, in cases where a
   ``LifecycleOwner`` isn't available, each ``ActivityResultLauncher``
   class lets you manually call
   `unregister() <#unregister>`__
   as an alternative.

   .. rubric:: Test
      :name: test

   By default, ``registerForActivityResult()`` automatically uses the
   ``ActivityResultRegistry`` provided by the activity. It also provides
   an overload that lets you pass in your own instance of
   ``ActivityResultRegistry`` that you can use to test your activity
   result calls without actually launching another activity.

   When `testing your app‚Äôs fragments <#>`__, you provide a test
   ``ActivityResultRegistry`` using a
   `FragmentFactory <#>`__
   to pass in the ``ActivityResultRegistry`` to the fragment‚Äôs
   constructor.

   **Note:**\  Any mechanism that lets you inject a separate
   ``ActivityResultRegistry`` in tests is enough to enable testing your
   activity result calls.
   For example, a fragment that uses the ``TakePicturePreview`` contract
   to get a thumbnail of the image might be written similar to the
   following:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyFragment(
                   private val registry: ActivityResultRegistry
               ) : Fragment() {
                   val thumbnailLiveData = MutableLiveData<Bitmap?>

                   val takePicture = registerForActivityResult(TakePicturePreview(), registry) {
                       bitmap: Bitmap? -> thumbnailLiveData.setValue(bitmap)
                   }

                   // ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyFragment extends Fragment {
                   private final ActivityResultRegistry mRegistry;
                   private final MutableLiveData<Bitmap> mThumbnailLiveData = new MutableLiveData();
                   private final ActivityResultLauncher<Void> mTakePicture =
                       registerForActivityResult(new TakePicturePreview(), mRegistry, new ActivityResultCallback<Bitmap>() {
                           @Override
                           public void onActivityResult(Bitmap thumbnail) {
                               mThumbnailLiveData.setValue(thumbnail);
                           }
                       });

                   public MyFragment(@NonNull ActivityResultRegistry registry) {
                       super();
                       mRegistry = registry;
                   }

                   @VisibleForTesting
                   @NonNull
                   ActivityResultLauncher<Void> getTakePicture() {
                       return mTakePicture;
                   }

                   @VisibleForTesting
                   @NonNull
                   LiveData<Bitmap> getThumbnailLiveData() {
                       return mThumbnailLiveData;
                   }

                   // ...
               }

   When creating a test-specific ``ActivityResultRegistry``, you must
   implement the
   `onLaunch() <#onLaunch>`__
   method. Instead of calling ``startActivityForResult()``, your test
   implementation can call
   `dispatchResult() <#dispatchResult>`__
   directly, providing the exact results you want to use in your test:

   .. code:: prettyprint

      val testRegistry = object : ActivityResultRegistry() {
          override fun <I, O> onLaunch(
                  requestCode: Int,
                  contract: ActivityResultContract<I, O>,
                  input: I,
                  options: ActivityOptionsCompat?
          ) {
              dispatchResult(requestCode, expectedResult)
          }
      }

   The complete test creates the expected result, constructs a test
   ``ActivityResultRegistry``, passes it to the fragment, triggers the
   launcher either directly or using other test APIs such as Espresso,
   and then verifies the results:

   .. code:: prettyprint

      @Test
      fun activityResultTest {
          // Create an expected result Bitmap
          val expectedResult = Bitmap.createBitmap(1, 1, Bitmap.Config.RGBA_F16)

          // Create the test ActivityResultRegistry
          val testRegistry = object : ActivityResultRegistry() {
                  override fun <I, O> onLaunch(
                  requestCode: Int,
                  contract: ActivityResultContract<I, O>,
                  input: I,
                  options: ActivityOptionsCompat?
              ) {
                  dispatchResult(requestCode, expectedResult)
              }
          }

          // Use the launchFragmentInContainer method that takes a
          // lambda to construct the Fragment with the testRegistry
          with(launchFragmentInContainer { MyFragment(testRegistry) }) {
                  onFragment { fragment ->
                      // Trigger the ActivityResultLauncher
                      fragment.takePicture()
                      // Verify the result is set
                      assertThat(fragment.thumbnailLiveData.value)
                              .isSameInstanceAs(expectedResult)
                  }
          }
      }

   .. rubric:: Create a custom contract
      :name: custom

   While
   `ActivityResultContracts <#>`__
   contains a number of prebuilt ``ActivityResultContract`` classes for
   use, you can provide your own contracts that provide the precise
   type-safe API you need.

   Each ``ActivityResultContract`` requires defined input and output
   classes, using ``Void`` as the input type if you don't require any
   input (in Kotlin, use either ``Void?`` or ``Unit``).

   Each contract must implement the
   `createIntent() <#createIntent>`__
   method, which takes a ``Context`` and the input and constructs the
   ``Intent`` that is used with ``startActivityForResult()``.

   Each contract must also implement
   `parseResult() <#parseResult>`__,
   which produces the output from the given ``resultCode``, such as
   ``Activity.RESULT_OK`` or ``Activity.RESULT_CANCELED``, and the
   ``Intent``.

   Contracts can optionally implement
   `getSynchronousResult() <#getSynchronousResult>`__
   if it is possible to determine the result for a given input without
   needing to call ``createIntent()``, start the other activity, and use
   ``parseResult()`` to build the result.

   The following example shows how to construct an
   ``ActivityResultContract``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class PickRingtone : ActivityResultContract<Int, Uri?>() {
                   override fun createIntent(context: Context, ringtoneType: Int) =
                       Intent(RingtoneManager.ACTION_RINGTONE_PICKER).apply {
                           putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, ringtoneType)
                       }

                   override fun parseResult(resultCode: Int, result: Intent?) : Uri? {
                       if (resultCode != Activity.RESULT_OK) {
                           return null
                       }
                       return result?.getParcelableExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class PickRingtone extends ActivityResultContract<Integer, Uri> {
                   @NonNull
                   @Override
                   public Intent createIntent(@NonNull Context context, @NonNull Integer ringtoneType) {
                       Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
                       intent.putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, ringtoneType.intValue());
                       return intent;
                   }

                   @Override
                   public Uri parseResult(int resultCode, @Nullable Intent result) {
                       if (resultCode != Activity.RESULT_OK || result == null) {
                           return null;
                       }
                       return result.getParcelableExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI);
                   }
               }

   If you don't need a custom contract, you can use the
   `StartActivityForResult <#>`__
   contract. This is a generic contract that takes any ``Intent`` as an
   input and returns an
   `ActivityResult <#>`__,
   letting you extract the ``resultCode`` and ``Intent`` as part of your
   callback, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val startForResult = registerForActivityResult(StartActivityForResult()) { result: ActivityResult ->
                   if (result.resultCode == Activity.RESULT_OK) {
                       val intent = result.data
                       // Handle the Intent
                   }
               }

               override fun onCreate(savedInstanceState: Bundle) {
                   // ...

                   val startButton = findViewById(R.id.start_button)

                   startButton.setOnClickListener {
                       // Use the Kotlin extension in activity-ktx
                       // passing it the Intent you want to start
                       startForResult.launch(Intent(this, ResultProducingActivity::class.java))
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ActivityResultLauncher<Intent> mStartForResult = registerForActivityResult(new StartActivityForResult(),
                       new ActivityResultCallback<ActivityResult>() {
                   @Override
                   public void onActivityResult(ActivityResult result) {
                       if (result.getResultCode() == Activity.RESULT_OK) {
                           Intent intent = result.getData();
                           // Handle the Intent
                       }
                   }
               });

               @Override
               public void onCreate(@Nullable savedInstanceState: Bundle) {
                   // ...

                   Button startButton = findViewById(R.id.start_button);

                   startButton.setOnClickListener(new OnClickListener() {
                       @Override
                       public void onClick(View view) {
                           // The launcher with the Intent you want to start
                           mStartForResult.launch(new Intent(this, ResultProducingActivity.class));
                       }
                   });
               }

.. container:: devsite-steps


Last updated 2024-01-03 UTC.


/Let other apps start your activity
===================================

.. container:: devsite-article-body clearfix

   If your app can perform an action that might be useful to another
   app, prepare it to respond to action requests by specifying the
   appropriate intent filter in your activity.

   For example, if you build a social app that can share messages or
   photos with the user's friends, support the
   `ACTION_SEND <#ACTION_SEND>`__
   intent. Then, when users initiate a "share" action from another app,
   your app appears as an option in the chooser dialog (also known as
   the *disambiguation dialog*), as shown in figure 1.

   |image1|
   **Figure 1.** The chooser dialog.

   To let other apps start your activity in this way, you need to add an
   ``<intent-filter>``
   element in your manifest file for the corresponding
   ``<activity>`` element.

   When your app is installed on a device, the system identifies your
   intent filters and adds the information to an internal catalog of
   intents supported by all installed apps. When an app calls
   `startActivity() <#startActivity>`__
   or
   `startActivityForResult() <#startActivityForResult>`__
   with an implicit intent, the system checks for activities that can
   respond to the intent.

   .. rubric:: Add an intent filter
      :name: AddIntentFilter

   To properly define which intents your activity can handle, make each
   intent filter you add as specific as possible in terms of the type of
   action and data the activity accepts.

   The system might send a given
   `Intent <#>`__ to an activity if
   that activity has an intent filter that fulfills the following
   criteria of the ``Intent`` object:

   Action
      A string naming the action to perform. Usually one of the
      platform-defined values, such as
      `ACTION_SEND <#ACTION_SEND>`__
      or
      `ACTION_VIEW <#ACTION_VIEW>`__.

      Specify this in your intent filter with the
      ``<action>`` element.
      The value you specify in this element must be the full string name
      for the action, instead of the API constant, as shown in the
      examples on this page.

   Data
      A description of the data associated with the intent.

      Specify this in your intent filter with the
      ``<data>`` element.
      Using one or more attributes in this element, you can specify the
      MIME type, a URI prefix, a URI scheme, or a combination of these
      and others that indicate the data type accepted.

      **Note:** If you don't need to declare specifics about the data
      `Uri <#>`__, such as when your
      activity handles other kind of "extra" data, instead of a URI,
      specify only the ``android:mimeType`` attribute to declare the
      type of data your activity handles, such as ``text/plain`` or
      ``image/jpeg``.

   Category
      Provides an additional way to characterize the activity handling
      the intent, usually related to the user gesture or location from
      which it's started. There are several different categories
      supported by the system, but most are rarely used. However, all
      implicit intents are defined with
      `CATEGORY_DEFAULT <#CATEGORY_DEFAULT>`__
      by default.

      Specify this in your intent filter with the
      ``<category>``
      element.

   In your intent filter, you can declare which criteria your activity
   accepts by declaring each of them with corresponding XML elements
   nested in the
   ``<intent-filter>``
   element.

   For example, here's an activity with an intent filter that handles
   the
   `ACTION_SEND <#ACTION_SEND>`__
   intent when the data type is either text or an image:

   .. code:: prettyprint

      <activity android:name="ShareActivity">
          <intent-filter>
              <action android:name="android.intent.action.SEND"/>
              <category android:name="android.intent.category.DEFAULT"/>
              <data android:mimeType="text/plain"/>
              <data android:mimeType="image/*"/>
          </intent-filter>
      </activity>

   **Tip:** If you want the icon in the chooser dialog to be different
   from your activity's default icon, add ``android:icon`` in the
   ``<intent-filter>``
   element.

   Each incoming intent specifies only one action and one data type, but
   it's OK to declare multiple instances of the
   ``<action>``,
   ``<category>``, and
   ``<data>`` elements in each
   ``<intent-filter>``.

   If any two pairs of action and data are mutually exclusive in their
   behaviors, create separate intent filters to specify which actions
   are acceptable when paired with which data types.

   For example, suppose your activity handles both text and images for
   both the
   `ACTION_SEND <#ACTION_SEND>`__
   and
   `ACTION_SENDTO <#ACTION_SENDTO>`__
   intents. In this case, you must define two separate intent filters
   for the two actions, because an ``ACTION_SENDTO`` intent must use the
   data `Uri <#>`__ to specify the
   recipient's address using the ``send`` or ``sendto`` URI scheme. This
   is shown in the following example:

   .. code:: prettyprint

      <activity android:name="ShareActivity">
          <!-- Filter for sending text; accepts SENDTO action with sms URI schemes -->
          <intent-filter>
              <action android:name="android.intent.action.SENDTO"/>
              <category android:name="android.intent.category.DEFAULT"/>
              <data android:scheme="sms" />
              <data android:scheme="smsto" />
          </intent-filter>
          <!-- Filter for sending text or images; accepts SEND action and text or image data -->
          <intent-filter>
              <action android:name="android.intent.action.SEND"/>
              <category android:name="android.intent.category.DEFAULT"/>
              <data android:mimeType="image/*"/>
              <data android:mimeType="text/plain"/>
          </intent-filter>
      </activity>

   **Note:** To receive implicit intents, you must include the
   `CATEGORY_DEFAULT <#CATEGORY_DEFAULT>`__
   category in the intent filter. The methods
   `startActivity() <#startActivity>`__
   and
   `startActivityForResult() <#startActivityForResult>`__
   treat all intents as if they declared the ``CATEGORY_DEFAULT``
   category. If you don't declare it in your intent filter, no implicit
   intents resolve to your activity.

   For more information about sending and receiving
   `ACTION_SEND <#ACTION_SEND>`__
   intents that perform social sharing behaviors, see `Receiving simple data from other apps <#>`__. You can also
   find useful information about sharing data in `Sharing simple data <#>`__ and `Sharing files <#>`__.

   .. rubric:: Handle the intent in your activity
      :name: HandleIntent

   To decide what action to take in your activity, read the
   `Intent <#>`__ that is used to
   start it.

   As your activity starts, call
   `getIntent() <#getIntent>`__ to
   retrieve the ``Intent`` that started the activity. You can do so at
   any time during the lifecycle of the activity, but you generally do
   so during early callbacks, such as
   `onCreate() <#onCreate>`__
   or `onStart() <#onStart>`__.

   This is shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)

                   setContentView(R.layout.main)

                   val data: Uri? = intent?.data

                   // Figure out what to do based on the intent type
                   if (intent?.type?.startsWith("image/") == true) {
                       // Handle intents with image data
                   } else if (intent?.type == "text/plain") {
                       // Handle intents with text
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onCreate(Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);

                   setContentView(R.layout.main);

                   // Get the intent that started this activity
                   Intent intent = getIntent();
                   Uri data = intent.getData();

                   // Figure out what to do based on the intent type
                   if (intent.getType().indexOf("image/") != -1) {
                       // Handle intents with image data
                   } else if (intent.getType().equals("text/plain")) {
                       // Handle intents with text
                   }
               }

   .. rubric:: Return a result
      :name: ReturnResult

   If you want to return a result to the activity that invoked yours,
   call
   `setResult() <#setResult>`__
   to specify the result code and result
   `Intent <#>`__. When your
   operation is done and the user returns to the original activity, call
   `finish() <#finish>`__ to close
   and destroy your activity. This is shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Create intent to deliver some kind of result data
               Intent("com.example.RESULT_ACTION", Uri.parse("content://result_uri")).also { result ->
                   setResult(Activity.RESULT_OK, result)
               }
               finish()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create intent to deliver some kind of result data
               Intent result = new Intent("com.example.RESULT_ACTION", Uri.parse("content://result_uri"));
               setResult(Activity.RESULT_OK, result);
               finish();

   You must always specify a result code with the result. Generally,
   it's either
   `RESULT_OK <#RESULT_OK>`__ or
   `RESULT_CANCELED <#RESULT_CANCELED>`__.
   You can then provide additional data with an
   `Intent <#>`__, as necessary.

   **Note:** The result is set to
   `RESULT_CANCELED <#RESULT_CANCELED>`__
   by default. So, if the user taps the Back button before completing
   the action and before you set the result, the original activity
   receives the "canceled" result.

   If you simply need to return an integer that indicates one of several
   result options, you can set the result code to any value higher than
   0. If you use the result code to deliver an integer and you have no
   need to include the
   `Intent <#>`__, you can call
   `setResult() <#setResult>`__
   and pass only a result code:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               setResult(RESULT_COLOR_RED)
               finish()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               setResult(RESULT_COLOR_RED);
               finish();

   In this case, there might be only a handful of possible results, so
   the result code is a locally defined integer (greater than 0). This
   works well when you're returning a result to an activity in your own
   app, because the activity that receives the result can reference the
   public constant to determine the value of the result code.

   **Note:** There's no need to check whether your activity was started
   with
   `startActivity() <#startActivity>`__
   or
   `startActivityForResult() <#startActivityForResult>`__.
   Simply call
   `setResult() <#setResult>`__
   if the intent that started your activity might expect a result. If
   the originating activity called ``startActivityForResult()``, then
   the system delivers it the result you supply to ``setResult()``;
   otherwise, the result is ignored.

.. container:: devsite-steps


Last updated 2024-01-03 UTC.

.. |image1| image:: https://developer.android.google.cn/static/images/training/basics/intent-chooser.png


/Limit loading in on-device Android containers
==============================================

.. container:: devsite-article-body clearfix

   *On-device Android containers* are apps that simulate the Android OS
   on an Android-powered device. This includes both apps that simulate
   the Android OS in its entirety and apps that only simulate portions
   of the Android OS.

   If you don't want on-device Android container apps to load in or
   proxy your Play Store app, you can add a string to your app manifest
   that declares this restriction.

   Create a `property <#>`__ under
   the
   ``<application>`` in
   your Android manifest with ``android:name`` set to
   ``REQUIRE_SECURE_ENV`` and ``android:value`` set to 1:

   .. code:: prettyprint

      <property android:name="REQUIRE_SECURE_ENV" android:value="1" />

   For this use case, you can use the ``REQUIRE_SECURE_ENV`` property
   regardless of the Android version that your app runs on.

   On-device Android container apps are
   `required <https://support.google.com/googleplay/android-developer/answer/9888379>`__
   to respect this declaration.

   For more information about on-device Android containers, see the
   `Help Center <https://support.google.com/googleplay/android-developer/answer/13609005>`__.

.. container:: devsite-steps


Last updated 2023-07-12 UTC.


/Overview: Package visibility filtering on Android
==================================================

.. https://developer.android.google.cn/training/package-visibility

.. container:: devsite-article-body clearfix

   When an app targets ``Android 11`` (API ``level 30``) or higher and queries
   for information about the other apps that are installed on a device,
   the system filters this information by default. This filtering
   behavior means that your app can‚Äôt detect all the apps installed on a
   device, which helps minimize the potentially sensitive information
   that your app can access but doesn't need to fulfill its use cases.

   Also, filtered package visibility helps app stores like Google Play
   assess the privacy and security that your app provides for users. For
   example, Google Play considers the list of installed apps to be
   `personal and sensitive user data <https://support.google.com/googleplay/android-developer/answer/10144311#zippy=%2Cexamples-of-common-violations>`__.

   Limited app visibility affects the results returned by methods that
   give information about other apps, such as
   `queryIntentActivities() <#queryIntentActivities>`__,
   `getPackageInfo() <#getPackageInfo>`__,
   and
   `getInstalledApplications() <#getInstalledApplications>`__.
   The limited visibility also affects explicit interactions with other
   apps, such as starting another app's service.

   Some packages are `visible automatically <#>`__. Your app
   can always detect these packages in its queries for other installed
   apps. To view other packages, `declare your app's need for increased package visibility <#>`__ using
   the ``<queries>``
   element. The `use cases <#>`__
   page provides examples of how you can selectively expand package
   visibility. The workflows described there allow you to fulfill common
   app interaction scenarios while protecting user privacy.

   In the rare cases where the ``<queries>`` element doesn't provide
   adequate package visibility, you can use the ``QUERY_ALL_PACKAGES``
   permission. If you publish your app on Google Play, your app's use of
   this permission is `subject to approval <https://support.google.com/googleplay/android-developer/answer/10158779>`__.

   The page about `testing package visibility behavior <#>`__ offers suggestions
   for how to test behavior changes based on package visibility when
   your app relies on interactions with other apps.

   .. rubric:: Additional resources
      :name: addt-resources

   To learn more about package visibility on Android, view the following
   materials:

   .. rubric:: Blog posts
      :name: blog-posts

   -  `Package visibility in Android 11 <https://medium.com/androiddevelopers/package-visibility-in-android-11-cc857f221cd9>`__,
      available on Medium.

.. container:: devsite-steps


Last updated 2024-05-03 UTC.


/Know which packages are visible automatically
==============================================

.. container:: devsite-article-body clearfix

   The system automatically makes some apps visible so that your app can
   interact with them without needing to declare the
   ``<queries>`` element.
   This behavior helps support basic functionality and common use cases.

   **Note:**\  You can start another app's activity using either an
   `implicit <#ExampleSend>`__ or
   `explicit <#ExampleExplicit>`__
   intent regardless of whether that app is visible to your app. Also,
   if your app targets ``Android 10`` (API level 29) or lower, **all** apps
   are visible to your app automatically.

   .. rubric:: Types of apps that are visible automatically
      :name: app-types-visible-automatically

   The following types of apps are always visible to your app, even when
   your app targets ``Android 11`` (API ``level 30``) or higher:

   -  Your own app.
   -  `Certain system packages <#system-packages-visible-automatically>`__, such as the
      media provider, that implement core Android functionality.
   -  The app that installed your app.
   -  Any app that launches an activity in your app using the
      `startActivityForResult() <#startactivityforresult>`__
      method, as described in the guide about `getting a result from an activity <#>`__.
   -  Any app that starts or binds to a
      `service <#>`__ in your app.
   -  Any app that accesses a `content provider <#>`__ in your
      app.
   -  Any app that has a content provider that your app has been
      `granted URI permissions <#getting-access-with-temporary-permissions>`__
      to access.
   -  Any app that receives input from your app. This case applies only
      when your app provides input as an `input method editor <#>`__.

   .. rubric:: System packages that are visible automatically
      :name: system-packages-visible-automatically

   Some system packages that implement core Android functionality are
   automatically visible to your app, even when your app targets
   ``Android 11`` or higher. The specific set of packages depends on the
   device that runs your app.

   To view the full list of packages for a specific device, run the
   following command in a terminal on your development machine:

   .. code:: none

      adb shell dumpsys package queries

   In the command output, find the ``forceQueryable`` section. This
   section includes the list of packages that the device has made
   visible to your app automatically.

.. container:: devsite-steps


Last updated 2024-05-03 UTC.


/Declare package visibility needs
=================================

.. container:: devsite-article-body clearfix

   As you create your app, it's important to consider the other apps on
   the device that your app needs to interact with. If your app targets
   ``Android 11`` (API ``level 30``) or higher, the system makes `some apps visible to your app automatically <#>`__, but it
   filters out other apps by default. This guide describes how to make
   those other apps visible to your app.

   If your app targets ``Android 11`` or higher and needs to interact with
   apps other than the ones that are visible automatically, add the
   ``<queries>`` element in
   your app's manifest file. Within the ``<queries>`` element, specify
   the other apps `by package name <#package-name>`__, `by intent signature <#intent-filter-signature>`__, or `by provider authority <#provider-authority>`__, as described in the following
   sections.

   .. rubric:: Specific package names
      :name: package-name

   If you know the specific apps that you want to query or interact
   with, such as apps that integrate with your app or apps whose
   services you use, include their package names in a set of
   ``<package>`` elements
   inside the ``<queries>`` element:

   .. code:: prettyprint

      <manifest package="com.example.game">
          <queries>
              <package android:name="com.example.store" />
              <package android:name="com.example.services" />
          </queries>
          ...
      </manifest>

   **Note:**\  If you declare a ``<package>`` element in your app's
   manifest, then the app associated with that package name appears in
   the results of any query to ``PackageManager`` that matches a
   component from that app.

   .. rubric:: Communicate with a host app in a library
      :name: communicate-host-app

   If you develop an Android library, you can declare your package
   visibility needs by adding a ``<queries>`` element in your `AAR manifest file <#>`__. This
   ``<queries>`` element has the same functionality as the element that
   apps can declare in their own manifests.

   If your library involves communication with a host app, such as using
   a `bound service <#>`__, include a
   ``<package>`` element that specifies the host app's package name:

   .. code:: prettyprint

      <!-- Place inside the <queries> element. -->
      <package android:name=PACKAGE_NAME />

   By including this declaration, you can check if the host app is
   installed and interact with it, such as by calling
   `bindService() <#bindService>`__.
   The calling app that uses your library `automatically becomes visible <#>`__ to the host app
   as a result of this interaction.

   .. rubric:: Packages that match an intent filter signature
      :name: intent-filter-signature

   Your app might need to query or interact with a set of apps that
   serve a particular purpose, but you might not know the specific
   package names to include. In this situation, you can list `intent filter signatures <#>`__ in your
   ``<queries>`` element. Your app can then discover apps that have
   matching
   ``<intent-filter>``
   elements.

   The following code example shows an ``<intent>`` element that would
   allow the app to see other installed apps that support JPEG image
   sharing:

   .. code:: prettyprint

      <manifest package="com.example.game">
          <queries>
              <intent>
                  <action android:name="android.intent.action.SEND" />
                  <data android:mimeType="image/jpeg" />
              </intent>
          </queries>
          ...
      </manifest>

   The ``<intent>`` element has a few restrictions:

   -  You must include exactly one ``<action>`` element.

   -  You cannot use the ``path``, ``pathPrefix``, ``pathPattern``, or
      ``port`` attributes in a ``<data>`` element. The system behaves as
      if you set each attribute's value to the generic wildcard
      character (``*``).

   -  You cannot use the ``mimeGroup`` attribute of a ``<data>``
      element.

   -  Within the ``<data>`` elements of a single ``<intent>`` element,
      you can use each of the following attributes at most once:

      -  ``mimeType``
      -  ``scheme``
      -  ``host``

      You can distribute these attributes across multiple ``<data>``
      elements or use them in a single ``<data>`` element.

   The ``<intent>`` element supports the generic wildcard character
   (``*``) as the value for a few attributes:

   -  The ``name`` attribute of the ``<action>`` element.
   -  The subtype of the ``mimeType`` attribute of a ``<data>`` element
      (``image/*``).
   -  The type and subtype of the ``mimeType`` attribute of a ``<data>``
      element (``*/*``).
   -  The ``scheme`` attribute of a ``<data>`` element.
   -  The ``host`` attribute of a ``<data>`` element.

   Unless otherwise specified in the previous list, the system doesn't
   support a mix of text and wildcard characters, such as ``prefix*``.

   .. rubric:: Packages that use a specific authority
      :name: provider-authority

   If you need to query a `content provider <#ContentURIs>`__
   but don't know the specific package names, you can declare the
   provider authority in a
   ``<provider>`` element,
   as shown in the following snippet:

   .. code:: prettyprint

      <manifest package="com.example.suite.enterprise">
          <queries>
              <provider android:authorities="com.example.settings.files" />
          </queries>
          ...
      </manifest>

   **Note:**\  If your ``<queries>`` element includes a ``<provider>``
   element, you might see an editor warning in Android Studio related to
   the ``<provider>`` element. As long as you're using the latest dot
   release of the Android Gradle plugin, your build is unaffected, so
   you can disregard the warning. Learn more in the blog post about
   `Preparing your Gradle build for package visibility in Android 11 <https://android-developers.googleblog.com/2020/07/preparing-your-build-for-package-visibility-in-android-11.html>`__.
   You can declare provider authorities in a single ``<queries>``
   element. Within the ``<queries>`` element, you can declare one or
   more ``<provider>`` elements. A ``<provider>`` element can include a
   single provider authority or a semicolon-delimited list of provider
   authorities.

   .. rubric:: All apps (not recommended)
      :name: all-apps

   In rare cases, your app might need to query or interact with all
   installed apps on a device, independent of the components they
   contain. To allow your app to see all other installed apps, the
   system provides the
   `QUERY_ALL_PACKAGES <#QUERY_ALL_PACKAGES>`__
   permission.

   Some examples of use cases where the ``QUERY_ALL_PACKAGES``
   permission is appropriate to include are:

   -  Accessibility apps
   -  Browsers
   -  Device management apps
   -  Security apps
   -  Antivirus apps

   However, it's usually possible to fulfill your app's use cases by
   interacting with the set of apps that are `visible automatically <#>`__ and by
   declaring the other apps that your app needs to access in your
   manifest file. To respect user privacy, your app should request the
   smallest amount of package visibility necessary in order for your app
   to work.

   This `policy update from Google Play <https://support.google.com/googleplay/android-developer/answer/10158779>`__
   provides guidelines for apps that need the ``QUERY_ALL_PACKAGES``
   permission.

.. container:: devsite-steps


Last updated 2024-05-03 UTC.


/Fulfill common use cases while having limited package visibility
=================================================================

.. container:: devsite-article-body clearfix

   This document presents several common use cases in which an app
   interacts with other apps. Each section provides guidance on how to
   accomplish the app‚Äôs functionality with limited package visibility,
   which you need to consider if your app targets ``Android 11`` (API
   ``level 30``) or higher.

   When an app that targets ``Android 11`` or higher uses an intent to start
   an activity in another app, the most straightforward approach is to
   invoke the intent and handle the
   `ActivityNotFoundException <#>`__
   exception if no app is available.

   If part of your app depends on knowing whether the call to
   `startActivity() <#startActivity>`__
   can succeed, such as showing a UI, add an element to the
   ``<queries>`` element of
   your app's manifest. Typically, this is an ``<intent>`` element.

   .. rubric:: Open URLs
      :name: open-urls

   This section describes various ways to open URLs in an app that
   targets ``Android 11`` or higher.

   .. rubric:: Open URLs in a browser or other app
      :name: open-urls-browser-or-other-app

   To open a URL, use an intent that contains the
   `ACTION_VIEW <#ACTION_VIEW>`__
   intent action, as described in the guide to `loading a web URL <#ViewUrl>`__. After you call
   ``startActivity()`` using this intent, one of the following happens:

   -  The URL opens in a web browser app.

   -  The URL opens in an app that supports the URL as a `deep link <#>`__.

   -  A disambiguation dialog appears, which lets the user choose which
      app opens the URL.

   -  An ``ActivityNotFoundException`` occurs because there isn't an app
      installed on the device that can open the URL. (This is unusual.)

      It's recommended that your app catch and handle the
      ``ActivityNotFoundException`` if it occurs.

   Because the ``startActivity()`` method doesn't require package
   visibility to start another application‚Äôs activity, you don't need to
   add a ``<queries>`` element to your app's manifest or make any
   changes to an existing ``<queries>`` element. This is true for both
   implicit and explicit intents that open a URL.

   .. rubric:: Check whether a browser is available
      :name: check-browser-available

   In some cases, your app might want to verify that there's at least
   one browser available on the device, or that a specific browser is
   the default browser, before attempting to open a URL. In those cases,
   include the following ``<intent>`` element as part of the
   ``<queries>`` element in your manifest:

   .. code:: prettyprint

      <!-- Place inside the <queries> element. -->
      <intent>
        <action android:name="android.intent.action.VIEW" />
        <category android:name="android.intent.category.BROWSABLE" />
        <data android:scheme="https" />
      </intent>

   When you call ``queryIntentActivities()`` and pass a web intent as an
   argument, the returned list includes the available browser apps in
   some cases. The list doesn't include browser apps if the user has
   configured the URL to open in a non-browser app by default.

   .. rubric:: Open URLs in Custom Tabs
      :name: open-urls-custom-tabs

   `Custom Tabs <https://developers.google.cn/web/android/custom-tabs>`__ let an
   app customize how the browser looks and feels. You can `open a URL in a Custom Tab <https://developers.google.cn/web/android/custom-tabs/implementation-guide#opening_a_custom_tab>`__
   without needing to add or change the ``<queries>`` element in your
   app manifest.

   However, you might want to `check whether the device has a browser that supports Custom Tabs <https://developers.google.cn/web/android/custom-tabs/implementation-guide#opening_a_custom_tab>`__
   or select a specific browser to launch with Custom Tabs using
   `CustomTabsClient.getPackageName() <#getPackageName>`__.
   In those cases, include the following ``<intent>`` element as part of
   the ``<queries>`` element in your manifest:

   .. code:: prettyprint

      <!-- Place inside the <queries> element. -->
      <intent>
        <action android:name="android.support.customtabs.action.CustomTabsService" />
      </intent>

   **Note:**\  The ``<intent>`` element shown in the preceding code
   snippet isn't necessary if your manifest already includes the
   ``<intent>`` element shown in the section about how to `check whether a browser is available <#check-browser-available>`__.

   .. rubric:: Let non-browser apps handle URLs
      :name: let-non-browser-apps-handle-urls

   Even if your app can open URLs using Custom Tabs, it's recommended
   that you let a non-browser app open a URL if possible. To provide
   this capability in your app, attempt a call to ``startActivity()``
   using an intent that sets the
   `FLAG_ACTIVITY_REQUIRE_NON_BROWSER <#FLAG_ACTIVITY_REQUIRE_NON_BROWSER>`__
   intent flag. If the system throws an ``ActivityNotFoundException``,
   your app can then open the URL in a Custom Tab.

   If an intent includes this flag, a call to ``startActivity()`` causes
   an ``ActivityNotFoundException`` to be thrown when either of the
   following conditions occurs:

   -  The call would have launched a browser app directly.
   -  The call would have shown the user a disambiguation dialog where
      the only options are browser apps.

   The following code snippet shows how to update your logic to use the
   ``FLAG_ACTIVITY_REQUIRE_NON_BROWSER`` intent flag:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               try {
                   val intent = Intent(ACTION_VIEW, Uri.parse(url)).apply {
                       // The URL should either launch directly in a non-browser app (if it's
                       // the default) or in the disambiguation dialog.
                       addCategory(CATEGORY_BROWSABLE)
                       flags = FLAG_ACTIVITY_NEW_TASK or FLAG_ACTIVITY_REQUIRE_NON_BROWSER
                   }
                   startActivity(intent)
               } catch (e: ActivityNotFoundException) {
                   // Only browser apps are available, or a browser is the default.
                   // So you can open the URL directly in your app, for example in a
                   // Custom Tab.
                   openInCustomTabs(url)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               try {
                   Intent intent = new Intent(ACTION_VIEW, Uri.parse(url));
                   // The URL should either launch directly in a non-browser app (if it's the
                   // default) or in the disambiguation dialog.
                   intent.addCategory(CATEGORY_BROWSABLE);
                   intent.setFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_REQUIRE_NON_BROWSER);
                   startActivity(intent);
               } catch (ActivityNotFoundException e) {
                   // Only browser apps are available, or a browser is the default.
                   // So you can open the URL directly in your app, for example in a
                   // Custom Tab.
                   openInCustomTabs(url);
               }

   .. rubric:: Avoid a disambiguation dialog
      :name: avoid-a-disambiguation-dialog

   If you want to avoid showing the disambiguation dialog that users
   might see when they open a URL, and instead prefer to handle the URL
   yourself in these situations, you can use an intent that sets the
   `FLAG_ACTIVITY_REQUIRE_DEFAULT <#FLAG_ACTIVITY_REQUIRE_DEFAULT>`__
   intent flag.

   If an intent includes this flag, a call to ``startActivity()`` causes
   an ``ActivityNotFoundException`` to be thrown when the call would
   have shown a disambiguation dialog to the user.

   If an intent includes both this flag and the
   `FLAG_ACTIVITY_REQUIRE_NON_BROWSER <#FLAG_ACTIVITY_REQUIRE_NON_BROWSER>`__
   intent flag, a call to ``startActivity()`` causes an
   ``ActivityNotFoundException`` to be thrown when either of the
   following conditions occurs:

   -  The call would have launched the browser app directly.
   -  The call would have shown a disambiguation dialog to the user.

   The following code snippet shows how to use the
   ``FLAG_ACTIVITY_REQUIRE_NON_BROWSER`` and
   ``FLAG_ACTIVITY_REQUIRE_DEFAULT`` flags together:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val url = URL_TO_LOAD
               try {
                   // For this intent to be invoked, the system must directly launch a
                   // non-browser app.
                   val intent = Intent(ACTION_VIEW, Uri.parse(url)).apply {
                       addCategory(CATEGORY_BROWSABLE)
                       flags = FLAG_ACTIVITY_NEW_TASK or FLAG_ACTIVITY_REQUIRE_NON_BROWSER or
                               FLAG_ACTIVITY_REQUIRE_DEFAULT
                   }
                   startActivity(intent)
               } catch (e: ActivityNotFoundException) {
                   // This code executes in one of the following cases:
                   // 1. Only browser apps can handle the intent.
                   // 2. The user has set a browser app as the default app.
                   // 3. The user hasn't set any app as the default for handling this URL.
                   openInCustomTabs(url)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               String url = URL_TO_LOAD;
               try {
                   // For this intent to be invoked, the system must directly launch a
                   // non-browser app.
                   Intent intent = new Intent(ACTION_VIEW, Uri.parse(url));
                   intent.addCategory(CATEGORY_BROWSABLE);
                   intent.setFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_REQUIRE_NON_BROWSER |
                           FLAG_ACTIVITY_REQUIRE_DEFAULT);
                   startActivity(intent);
               } catch (ActivityNotFoundException e) {
                   // This code executes in one of the following cases:
                   // 1. Only browser apps can handle the intent.
                   // 2. The user has set a browser app as the default app.
                   // 3. The user hasn't set any app as the default for handling this URL.
                   openInCustomTabs(url);
               }

   .. rubric:: Open a file
      :name: open-a-file

   If your app handles files or attachments, such as checking whether a
   device can open a given file, it's usually easiest to try to start an
   activity that can handle the file. To do so, use an intent that
   includes the ``ACTION_VIEW`` intent action and the URI that
   represents the specific file. If no app is available on the device,
   your app can catch the ``ActivityNotFoundException``. In your
   exception-handling logic, you can either show an error or try to
   handle the file yourself.

   If your app must know in advance whether another app can open a given
   file, include the ``<intent>`` element in the following code snippet
   as part of the ``<queries>`` element in your manifest. Include the
   file type if you already know what it is at compile time.

   .. code:: prettyprint

      <!-- Place inside the <queries> element. -->
      <intent>
        <action android:name="android.intent.action.VIEW" />
        <!-- If you don't know the MIME type in advance, set "mimeType" to "*/*". -->
        <data android:mimeType="application/pdf" />
      </intent>

   You can then check whether an app is available by calling
   ``resolveActivity()`` with your intent.

   .. rubric:: Grant URI access
      :name: grant-uri-access

   .. note::

      **Note:** Declaring URI access permissions as described in this
      section is required for apps that target ``Android 11`` (API ``level 30``)
      or higher and recommended for all apps, regardless of their target
      SDK version and whether they
      `export <#exported>`__
      their content providers.

   For apps that target ``Android 11`` or higher to access the content URI,
   your app's intent must declare `URI access permissions <#getting-access-with-temporary-permissions>`__
   by setting one or both of the following intent flags:
   `FLAG_GRANT_READ_URI_PERMISSION <#FLAG_GRANT_READ_URI_PERMISSION>`__
   and
   `FLAG_GRANT_WRITE_URI_PERMISSION <#FLAG_GRANT_WRITE_URI_PERMISSION>`__.

   On ``Android 11`` and higher, the URI access permissions give the
   following capabilities to the app that receives the intent:

   -  Read from, or write to, the data that the content URI represents,
      depending on the given URI permissions.
   -  Gain visibility into the app containing the content provider that
      matches the URI authority. The app that contains the content
      provider might be different from the app that sends the intent.

   The following code snippet demonstrates how to add a URI permissions
   intent flag so that another app that targets ``Android 11`` or higher can
   view the data in the content URI:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val shareIntent = Intent(Intent.ACTION_VIEW).apply {
                   flags = Intent.FLAG_GRANT_READ_URI_PERMISSION
                   data = CONTENT_URI_TO_SHARE_WITH_OTHER_APP
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Intent shareIntent = new Intent(Intent.ACTION_VIEW);
               shareIntent.setFlags(FLAG_GRANT_READ_URI_PERMISSION);
               shareIntent.setData(CONTENT_URI_TO_SHARE_WITH_OTHER_APP);

   .. rubric:: Connect to services
      :name: connect-services

   If your app needs to interact with a service that isn't `visible automatically <#>`__, you can
   declare the appropriate intent action within a ``<queries>`` element.
   The following sections give examples using commonly accessed
   services.

   .. rubric:: Connect to a text-to-speech engine
      :name: tts-engine

   If your app interacts with a text-to-speech (TTS) engine, include the
   following ``<intent>`` element as part of the ``<queries>`` element
   in your manifest:

   .. code:: prettyprint

      <!-- Place inside the <queries> element. -->
      <intent>
        <action android:name="android.intent.action.TTS_SERVICE" />
      </intent>

   .. rubric:: Connect to a speech recognition service
      :name: speech-recognition

   If your app interacts with a speech recognition service, include the
   following ``<intent>`` element as part of the ``<queries>`` element
   in your manifest:

   .. code:: prettyprint

      <!-- Place inside the <queries> element. -->
      <intent>
        <action android:name="android.speech.RecognitionService" />
      </intent>

   .. rubric:: Connect to media browser services
      :name: connect-to-media-browser-services

   If your app is a `client media browser app <#>`__,
   include the following ``<intent>`` element as part of the
   ``<queries>`` element in your manifest:

   .. code:: prettyprint

      <!-- Place inside the <queries> element. -->
      <intent>
        <action android:name="android.media.browse.MediaBrowserService" />
      </intent>

   .. rubric:: Provide custom functionality
      :name: provide-custom-functionality

   If your app needs to perform customizable actions or show
   customizable information based on its interactions with other apps,
   you can represent that custom behavior using `intent filter signatures <#intent-filter-signature>`__
   as part of the ``<queries>`` element in your manifest. The following
   sections provide detailed guidance for several common scenarios.

   .. rubric:: Query for SMS apps
      :name: sms-apps

   If your app needs information about the set of SMS apps that are
   installed on a device, for example to check which app is the device's
   default SMS handler, include the following ``<intent>`` element as
   part of the ``<queries>`` element in your manifest:

   .. code:: prettyprint

      <!-- Place inside the <queries> element. -->
      <intent>
        <action android:name="android.intent.action.SENDTO"/>
        <data android:scheme="smsto" android:host="*" />
      </intent>

   .. rubric:: Create a custom sharesheet
      :name: create-custom-sharesheet

   Whenever possible, use a `system-provided sharesheet <#why-to-use-system-sharesheet>`__.
   Alternatively, include the following ``<intent>`` element as part of
   the ``<queries>`` element in your manifest:

   .. code:: prettyprint

      <!-- Place inside the <queries> element. -->
      <intent>
        <action android:name="android.intent.action.SEND" />
        <!-- Replace with the MIME type that your app works with, if needed. -->
        <data android:mimeType="image/jpeg" />
      </intent>

   The process of building the sharesheet in your app's logic, such as
   the call to ``queryIntentActivities()``, otherwise remains unchanged
   compared to versions of Android earlier than ``Android 11``.

   .. rubric:: Show custom text selection actions
      :name: custom-text-selection-actions

   When users select text in your app, a `text selection toolbar <https://material.io/design/platform-guidance/android-text-selection-toolbar>`__
   shows the set of possible operations to perform on the selected text.
   If this toolbar shows custom actions from other apps, include the
   following ``<intent>`` element as part of the ``<queries>`` element
   in your manifest:

   .. code:: prettyprint

      <!-- Place inside the <queries> element. -->
      <intent>
        <action android:name="android.intent.action.PROCESS_TEXT" />
        <data android:mimeType="text/plain" />
      </intent>

   .. rubric:: Show custom data rows for a contact
      :name: show_custom_data_rows_for_a_contact

   Apps can `add custom data rows <#CustomData>`__ to the
   Contacts Provider. For a contacts app to show this custom data, it
   needs to be able to do the following:

   #. Read the ``contacts.xml`` file from the other apps.
   #. Load an icon corresponding to the custom MIME type.

   If your app is a contacts app, include the following ``<intent>``
   elements as part of the ``<queries>`` element in your manifest:

   .. code:: prettyprint

      <!-- Place inside the <queries> element. -->
      <!-- Lets the app read the contacts.xml file from other apps. -->
      <intent>
        <action android:name="android.accounts.AccountAuthenticator" />
      </intent>
      <!-- Lets the app load an icon corresponding to the custom MIME type. -->
      <intent>
        <action android:name="android.intent.action.VIEW" />
        <data android:scheme="content" android:host="com.android.contacts"
              android:mimeType="vnd.android.cursor.item/*" />
      </intent>

.. container:: devsite-steps


Last updated 2024-05-03 UTC.


/Test package visibility behavior
=================================

.. container:: devsite-article-body clearfix

   If your app relies on interactions with other apps to complete its
   use cases, it's useful to test how `package visibility <#>`__ changes in Android 11
   (API level 30) and higher affect your app.

   This guide also gives some suggestions on how to test the behavior
   changes and helps you configure log messages to determine at a more
   granular level how your app might be affected.

   .. rubric:: Test the behavior changes
      :name: test-behavior-changes

   To test whether this behavior change affects your app, complete the
   following steps:

   #. Install `Android Studio 3.6.1 <#>`__ or higher.
   #. Install the latest version of Gradle that Android Studio supports.
   #. Set your app's ``targetSdkVersion`` to ``30`` or higher.
   #. Don't include the ``<queries>`` element in your app's manifest
      file.
   #. Call
      `getInstalledApplications() <#getInstalledApplications>`__
      or
      `getInstalledPackages() <#getInstalledPackages>`__.
      Both methods return a filtered list when they are successful.
   #. See which features of your app aren't working.
   #. Introduce appropriate
      ``<queries>`` entries
      to fix those features.

   .. rubric:: Configure log messages for package filtering
      :name: configure-log-messages

   To discover more details about how the default visibility of apps
   affects your app, you can enable log messages for package filtering.
   If you're developing a test app or debuggable app in Android Studio,
   the `system log provides this capability <#systemLog>`__
   for you. Otherwise, you can run the following command in a terminal
   window to enable it manually:

   .. code:: none

      adb shell pm log-visibility --enable PACKAGE_NAME

   Then, whenever packages are filtered out of a ``PackageManager``
   object's return values, you see a message similar to the following in
   Logcat:

   .. code:: none

      I/AppsFilter: interaction: PackageSetting{7654321 \
        com.example.myapp/12345} -> PackageSetting{...} BLOCKED

   **Caution:**\  Your app's performance is affected when this flag is
   enabled. Unless you're testing how package visibility affects your
   app, disable the logging of messages related to package visibility.

.. container:: devsite-steps


Last updated 2024-05-03 UTC.


/Dependency injection in Android
================================

.. container:: devsite-article-body clearfix

   Dependency injection (DI) is a technique widely used in programming
   and well suited to Android development. By following the principles
   of DI, you lay the groundwork for good app architecture.

   Implementing dependency injection provides you with the following
   advantages:

   -  Reusability of code
   -  Ease of refactoring
   -  Ease of testing

   .. rubric:: Fundamentals of dependency injection
      :name: fundamentals

   Before covering dependency injection in Android specifically, this
   page provides a more general overview of how dependency injection
   works.

   .. rubric:: What is dependency injection?
      :name: what-is-di

   Classes often require references to other classes. For example, a
   ``Car`` class might need a reference to an ``Engine`` class. These
   required classes are called *dependencies*, and in this example the
   ``Car`` class is dependent on having an instance of the ``Engine``
   class to run.

   There are three ways for a class to get an object it needs:

   A. The class constructs the dependency it needs. In the example
      above, ``Car`` would create and initialize its own instance of
      ``Engine``.
   B. Grab it from somewhere else. Some Android APIs, such as
      ``Context`` getters and ``getSystemService()``, work this way.
   C. Have it supplied as a parameter. The app can provide these
      dependencies when the class is constructed or pass them in to the
      functions that need each dependency. In the example above, the
      ``Car`` constructor would receive ``Engine`` as a parameter.

   The third option is dependency injection! With this approach you take
   the dependencies of a class and provide them rather than having the
   class instance obtain them itself.

   Here's an example. Without dependency injection, representing a
   ``Car`` that creates its own ``Engine`` dependency in code looks like
   this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class Car {

                   private val engine = Engine()

                   fun start() {
                       engine.start()
                   }
               }

               fun main(args: Array) {
                   val car = Car()
                   car.start()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class Car {

                   private Engine engine = new Engine();

                   public void start() {
                       engine.start();
                   }
               }


               class MyApp {
                   public static void main(String[] args) {
                       Car car = new Car();
                       car.start();
                   }
               }

   .. container:: attempt-right

      |Car class without dependency injection|

   This is not an example of dependency injection because the ``Car``
   class is constructing its own ``Engine``. This can be problematic
   because:

   -  ``Car`` and ``Engine`` are tightly coupled - an instance of
      ``Car`` uses one type of ``Engine``, and no subclasses or
      alternative implementations can easily be used. If the ``Car``
      were to construct its own ``Engine``, you would have to create two
      types of ``Car`` instead of just reusing the same ``Car`` for
      engines of type ``Gas`` and ``Electric``.

   -  The hard dependency on ``Engine`` makes testing more difficult.
      ``Car`` uses a real instance of ``Engine``, thus preventing you
      from using a `test double <https://en.wikipedia.org/wiki/Test_double>`__ to modify
      ``Engine`` for different test cases.

   What does the code look like with dependency injection? Instead of
   each instance of ``Car`` constructing its own ``Engine`` object on
   initialization, it receives an ``Engine`` object as a parameter in
   its constructor:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class Car(private val engine: Engine) {
                   fun start() {
                       engine.start()
                   }
               }

               fun main(args: Array) {
                   val engine = Engine()
                   val car = Car(engine)
                   car.start()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class Car {

                   private final Engine engine;

                   public Car(Engine engine) {
                       this.engine = engine;
                   }

                   public void start() {
                       engine.start();
                   }
               }


               class MyApp {
                   public static void main(String[] args) {
                       Engine engine = new Engine();
                       Car car = new Car(engine);
                       car.start();
                   }
               }

   .. container:: attempt-right

      |Car class using dependency injection|

   The ``main`` function uses ``Car``. Because ``Car`` depends on
   ``Engine``, the app creates an instance of ``Engine`` and then uses
   it to construct an instance of ``Car``. The benefits of this DI-based
   approach are:

   -  Reusability of ``Car``. You can pass in different implementations
      of ``Engine`` to ``Car``. For example, you might define a new
      subclass of ``Engine`` called ``ElectricEngine`` that you want
      ``Car`` to use. If you use DI, all you need to do is pass in an
      instance of the updated ``ElectricEngine`` subclass, and ``Car``
      still works without any further changes.

   -  Easy testing of ``Car``. You can pass in test doubles to test your
      different scenarios. For example, you might create a test double
      of ``Engine`` called ``FakeEngine`` and configure it for different
      tests.

   There are two major ways to do dependency injection in Android:

   -  **Constructor Injection**. This is the way described above. You
      pass the dependencies of a class to its constructor.

   -  **Field Injection (or Setter Injection)**. Certain Android
      framework classes such as activities and fragments are
      instantiated by the system, so constructor injection is not
      possible. With field injection, dependencies are instantiated
      after the class is created. The code would look like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class Car {
                   lateinit var engine: Engine

                   fun start() {
                       engine.start()
                   }
               }

               fun main(args: Array) {
                   val car = Car()
                   car.engine = Engine()
                   car.start()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class Car {

                   private Engine engine;

                   public void setEngine(Engine engine) {
                       this.engine = engine;
                   }

                   public void start() {
                       engine.start();
                   }
               }

               class MyApp {
                   public static void main(String[] args) {
                       Car car = new Car();
                       car.setEngine(new Engine());
                       car.start();
                   }
               }

   **Note:**\  Dependency injection is based on the `Inversion of Control <https://en.wikipedia.org/wiki/Inversion_of_control>`__
   principle in which generic code controls the execution of specific
   code.

   .. rubric:: Automated dependency injection
      :name: automated-di

   In the previous example, you created, provided, and managed the
   dependencies of the different classes yourself, without relying on a
   library. This is called *dependency injection by hand*, or *manual
   dependency injection*. In the ``Car`` example, there was only one
   dependency, but more dependencies and classes can make manual
   injection of dependencies more tedious. Manual dependency injection
   also presents several problems:

   -  For big apps, taking all the dependencies and connecting them
      correctly can require a large amount of boilerplate code. In a
      multi-layered architecture, in order to create an object for a top
      layer, you have to provide all the dependencies of the layers
      below it. As a concrete example, to build a real car you might
      need an engine, a transmission, a chassis, and other parts; and an
      engine in turn needs cylinders and spark plugs.

   -  When you're not able to construct dependencies before passing them
      in ‚Äî for example when using lazy initializations or scoping
      objects to flows of your app ‚Äî you need to write and maintain a
      custom container (or graph of dependencies) that manages the
      lifetimes of your dependencies in memory.

   There are libraries that solve this problem by automating the process
   of creating and providing dependencies. They fit into two categories:

   -  Reflection-based solutions that connect dependencies at runtime.

   -  Static solutions that generate the code to connect dependencies at
      compile time.

   `Dagger <https://dagger.dev/>`__ is a popular dependency injection
   library for Java, Kotlin, and Android that is maintained by Google.
   Dagger facilitates using DI in your app by creating and managing the
   graph of dependencies for you. It provides fully static and
   compile-time dependencies addressing many of the development and
   performance issues of reflection-based solutions such as
   `Guice <https://en.wikipedia.org/wiki/Google_Guice>`__.

   .. rubric:: Alternatives to dependency injection
      :name: di-alternatives

   An alternative to dependency injection is using a `service locator <https://en.wikipedia.org/wiki/Service_locator_pattern>`__.
   The service locator design pattern also improves decoupling of
   classes from concrete dependencies. You create a class known as the
   *service locator* that creates and stores dependencies and then
   provides those dependencies on demand.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               object ServiceLocator {
                   fun getEngine(): Engine = Engine()
               }

               class Car {
                   private val engine = ServiceLocator.getEngine()

                   fun start() {
                       engine.start()
                   }
               }

               fun main(args: Array) {
                   val car = Car()
                   car.start()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class ServiceLocator {

                   private static ServiceLocator instance = null;

                   private ServiceLocator() {}

                   public static ServiceLocator getInstance() {
                       if (instance == null) {
                           synchronized(ServiceLocator.class) {
                               instance = new ServiceLocator();
                           }
                       }
                       return instance;
                   }

                   public Engine getEngine() {
                       return new Engine();
                   }
               }

               class Car {

                   private Engine engine = ServiceLocator.getInstance().getEngine();

                   public void start() {
                       engine.start();
                   }
               }

               class MyApp {
                   public static void main(String[] args) {
                       Car car = new Car();
                       car.start();
                   }
               }

   The service locator pattern is different from dependency injection in
   the way the elements are consumed. With the service locator pattern,
   classes have control and ask for objects to be injected; with
   dependency injection, the app has control and proactively injects the
   required objects.

   Compared to dependency injection:

   -  The collection of dependencies required by a service locator makes
      code harder to test because all the tests have to interact with
      the same global service locator.

   -  Dependencies are encoded in the class implementation, not in the
      API surface. As a result, it's harder to know what a class needs
      from the outside. As a result, changes to ``Car`` or the
      dependencies available in the service locator might result in
      runtime or test failures by causing references to fail.

   -  Managing lifetimes of objects is more difficult if you want to
      scope to anything other than the lifetime of the entire app.

   .. rubric:: Use Hilt in your Android app
      :name: hilt

   `Hilt <#>`__ is Jetpack's
   recommended library for dependency injection in Android. Hilt defines
   a standard way to do DI in your application by providing containers
   for every Android class in your project and managing their lifecycles
   automatically for you.

   Hilt is built on top of the popular DI library
   `Dagger <#>`__ to benefit
   from the compile time correctness, runtime performance, scalability,
   and Android Studio support that Dagger provides.

   To learn more about Hilt see `Dependency Injection with Hilt <#>`__.

   .. rubric:: Conclusion
      :name: conclusion

   Dependency injection provides your app with the following advantages:

   -  Reusability of classes and decoupling of dependencies: It's easier
      to swap out implementations of a dependency. Code reuse is
      improved because of inversion of control, and classes no longer
      control how their dependencies are created, but instead work with
      any configuration.

   -  Ease of refactoring: The dependencies become a verifiable part of
      the API surface, so they can be checked at object-creation time or
      at compile time rather than being hidden as implementation
      details.

   -  Ease of testing: A class doesn't manage its dependencies, so when
      you're testing it, you can pass in different implementations to
      test all of your different cases.

   To fully understand the benefits of dependency injection, you should
   try it manually in your app as shown in `Manual dependency injection <#>`__.

   .. rubric:: Additional resources
      :name: additional_resources

   To learn more about dependency injection, see the following
   additional resources.

   .. rubric:: Samples
      :name: samples


Last updated 2024-01-03 UTC.

.. |Car class without dependency injection| image:: https://developer.android.google.cn/static/images/training/dependency-injection/1-car-engine-no-di.png
   :width: 500px
.. |Car class using dependency injection| image:: https://developer.android.google.cn/static/images/training/dependency-injection/1-car-engine-di.png
   :width: 500px


/Manual dependency injection
============================

.. container:: devsite-article-body clearfix

   `Android's recommended app architecture <#recommended-app-arch>`__ encourages
   dividing your code into classes to benefit from separation of
   concerns, a principle where each class of the hierarchy has a single
   defined responsibility. This leads to more, smaller classes that need
   to be connected together to fulfill each other's dependencies.

   .. container::

      .. container:: float
         :name: final-architecture

         |Android apps are usually made up of many classes, and some of
         them depend on each other.|
         The dependencies between classes can be represented as a graph,
         in which each class is connected to the classes it depends on.
         The representation of all your classes and their dependencies
         makes up the *application graph*. In figure 1, you can see an
         abstraction of the application graph. When class A
         (``ViewModel``) depends on class B (``Repository``), there's a
         line that points from A to B representing that dependency.

         Dependency injection helps make these connections and enables
         you to swap out implementations for testing. For example, when
         testing a ``ViewModel`` that depends on a repository, you can
         pass different implementations of ``Repository`` with either
         fakes or mocks to test the different cases.

         .. rubric:: Basics of manual dependency injection
            :name: basics-manual-di

         This section covers how to apply manual dependency injection in
         a real Android app scenario. It walks through an iterated
         approach of how you might start using dependency injection in
         your app. The approach improves until it reaches a point that
         is very similar to what Dagger would automatically generate for
         you. For more information about Dagger, read `Dagger basics <#>`__.

         Consider a **flow** to be a group of screens in your app that
         correspond to a feature. Login, registration, and checkout are
         all examples of flows.

         When covering a login flow for a typical Android app, the
         ``LoginActivity`` depends on ``LoginViewModel``, which in turn
         depends on ``UserRepository``. Then ``UserRepository`` depends
         on a ``UserLocalDataSource`` and a ``UserRemoteDataSource``,
         which in turn depends on a
         `Retrofit <https://square.github.io/retrofit/>`__ service.

         .. container::

            |image1|

         ``LoginActivity`` is the entry point to the login flow and the
         user interacts with the activity. Thus, ``LoginActivity`` needs
         to create the ``LoginViewModel`` with all its dependencies.

         The ``Repository`` and ``DataSource`` classes of the flow look
         like this:

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                     class UserRepository(
                         private val localDataSource: UserLocalDataSource,
                         private val remoteDataSource: UserRemoteDataSource
                     ) { ... }

                     class UserLocalDataSource { ... }
                     class UserRemoteDataSource(
                         private val loginService: LoginRetrofitService
                     ) { ... }

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                     class UserLocalDataSource {
                         public UserLocalDataSource() { }
                         ...
                     }

                     class UserRemoteDataSource {

                         private final Retrofit retrofit;

                         public UserRemoteDataSource(Retrofit retrofit) {
                             this.retrofit = retrofit;
                         }

                         ...
                     }

                     class UserRepository {

                         private final UserLocalDataSource userLocalDataSource;
                         private final UserRemoteDataSource userRemoteDataSource;

                         public UserRepository(UserLocalDataSource userLocalDataSource, UserRemoteDataSource userRemoteDataSource) {
                             this.userLocalDataSource = userLocalDataSource;
                             this.userRemoteDataSource = userRemoteDataSource;
                         }

                         ...
                     }

         Here's what ``LoginActivity`` looks like:

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                     class LoginActivity: Activity() {

                         private lateinit var loginViewModel: LoginViewModel

                         override fun onCreate(savedInstanceState: Bundle?) {
                             super.onCreate(savedInstanceState)

                             // In order to satisfy the dependencies of LoginViewModel, you have to also
                             // satisfy the dependencies of all of its dependencies recursively.
                             // First, create retrofit which is the dependency of UserRemoteDataSource
                             val retrofit = Retrofit.Builder()
                                 .baseUrl("https://example.com")
                                 .build()
                                 .create(LoginService::class.java)

                             // Then, satisfy the dependencies of UserRepository
                             val remoteDataSource = UserRemoteDataSource(retrofit)
                             val localDataSource = UserLocalDataSource()

                             // Now you can create an instance of UserRepository that LoginViewModel needs
                             val userRepository = UserRepository(localDataSource, remoteDataSource)

                             // Lastly, create an instance of LoginViewModel with userRepository
                             loginViewModel = LoginViewModel(userRepository)
                         }
                     }

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                     public class MainActivity extends Activity {

                         private LoginViewModel loginViewModel;

                         @Override
                         protected void onCreate(Bundle savedInstanceState) {
                             super.onCreate(savedInstanceState);
                             setContentView(R.layout.activity_main);

                             // In order to satisfy the dependencies of LoginViewModel, you have to also
                             // satisfy the dependencies of all of its dependencies recursively.
                             // First, create retrofit which is the dependency of UserRemoteDataSource
                             Retrofit retrofit = new Retrofit.Builder()
                                     .baseUrl("https://example.com")
                                     .build()
                                     .create(LoginService.class);

                             // Then, satisfy the dependencies of UserRepository
                             UserRemoteDataSource remoteDataSource = new UserRemoteDataSource(retrofit);
                             UserLocalDataSource localDataSource = new UserLocalDataSource();

                             // Now you can create an instance of UserRepository that LoginViewModel needs
                             UserRepository userRepository = new UserRepository(localDataSource, remoteDataSource);

                             // Lastly, create an instance of LoginViewModel with userRepository
                             loginViewModel = new LoginViewModel(userRepository);
                         }
                     }

         There are issues with this approach:

         #. There's a lot of boilerplate code. If you wanted to create
            another instance of ``LoginViewModel`` in another part of
            the code, you'd have code duplication.

         #. Dependencies have to be declared in order. You have to
            instantiate ``UserRepository`` before ``LoginViewModel`` in
            order to create it.

         #. It's difficult to reuse objects. If you wanted to reuse
            ``UserRepository`` across multiple features, you'd have to
            make it follow the `singleton pattern <https://en.wikipedia.org/wiki/Singleton_pattern>`__.
            The singleton pattern makes testing more difficult because
            all tests share the same singleton instance.

         .. rubric:: Managing dependencies with a container
            :name: dependencies-container

         To solve the issue of reusing objects, you can create your own
         *dependencies container* class that you use to get
         dependencies. All instances provided by this container can be
         public. In the example, because you only need an instance of
         ``UserRepository``, you can make its dependencies private with
         the option of making them public in the future if they need to
         be provided:

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                     // Container of objects shared across the whole app
                     class AppContainer {

                         // Since you want to expose userRepository out of the container, you need to satisfy
                         // its dependencies as you did before
                         private val retrofit = Retrofit.Builder()
                                                 .baseUrl("https://example.com")
                                                 .build()
                                                 .create(LoginService::class.java)

                         private val remoteDataSource = UserRemoteDataSource(retrofit)
                         private val localDataSource = UserLocalDataSource()

                         // userRepository is not private; it'll be exposed
                         val userRepository = UserRepository(localDataSource, remoteDataSource)
                     }

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                     // Container of objects shared across the whole app
                     public class AppContainer {

                         // Since you want to expose userRepository out of the container, you need to satisfy
                         // its dependencies as you did before
                         private Retrofit retrofit = new Retrofit.Builder()
                                 .baseUrl("https://example.com")
                                 .build()
                                 .create(LoginService.class);

                         private UserRemoteDataSource remoteDataSource = new UserRemoteDataSource(retrofit);
                         private UserLocalDataSource localDataSource = new UserLocalDataSource();

                         // userRepository is not private; it'll be exposed
                         public UserRepository userRepository = new UserRepository(localDataSource, remoteDataSource);
                     }

         Because these dependencies are used across the whole
         application, they need to be placed in a common place all
         activities can use: the
         `Application <#>`__ class.
         Create a custom ``Application`` class that contains an
         ``AppContainer`` instance.

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                     // Custom Application class that needs to be specified
                     // in the AndroidManifest.xml file
                     class MyApplication : Application() {

                         // Instance of AppContainer that will be used by all the Activities of the app
                         val appContainer = AppContainer()
                     }

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                     // Custom Application class that needs to be specified
                     // in the AndroidManifest.xml file
                     public class MyApplication extends Application {

                         // Instance of AppContainer that will be used by all the Activities of the app
                         public AppContainer appContainer = new AppContainer();
                     }

         **Note:**\  ``AppContainer`` is just a regular class with a
         unique instance shared across the app placed in your
         ``Application`` class. However, ``AppContainer`` is not
         following the
         `singleton <https://en.wikipedia.org/wiki/Singleton_pattern>`__
         pattern; in Kotlin, it's not an ``object``, and in Java, it's
         not accessed with the typical ``Singleton.getInstance()``
         method.
         Now you can get the instance of the ``AppContainer`` from the
         application and obtain the shared of ``UserRepository``
         instance:

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                     class LoginActivity: Activity() {

                         private lateinit var loginViewModel: LoginViewModel

                         override fun onCreate(savedInstanceState: Bundle?) {
                             super.onCreate(savedInstanceState)

                             // Gets userRepository from the instance of AppContainer in Application
                             val appContainer = (application as MyApplication).appContainer
                             loginViewModel = LoginViewModel(appContainer.userRepository)
                         }
                     }

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                     public class MainActivity extends Activity {

                         private LoginViewModel loginViewModel;

                         @Override
                         protected void onCreate(Bundle savedInstanceState) {
                             super.onCreate(savedInstanceState);
                             setContentView(R.layout.activity_main);

                             // Gets userRepository from the instance of AppContainer in Application
                             AppContainer appContainer = ((MyApplication) getApplication()).appContainer;
                             loginViewModel = new LoginViewModel(appContainer.userRepository);
                         }
                     }

         In this way, you don't have a singleton ``UserRepository``.
         Instead, you have an ``AppContainer`` shared across all
         activities that contains objects from the graph and creates
         instances of those objects that other classes can consume.

         If ``LoginViewModel`` is needed in more places in the
         application, having a centralized place where you create
         instances of ``LoginViewModel`` makes sense. You can move the
         creation of ``LoginViewModel`` to the container and provide new
         objects of that type with a factory. The code for a
         ``LoginViewModelFactory`` looks like this:

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                     // Definition of a Factory interface with a function to create objects of a type
                     interface Factory<T> {
                         fun create(): T
                     }

                     // Factory for LoginViewModel.
                     // Since LoginViewModel depends on UserRepository, in order to create instances of
                     // LoginViewModel, you need an instance of UserRepository that you pass as a parameter.
                     class LoginViewModelFactory(private val userRepository: UserRepository) : Factory {
                         override fun create(): LoginViewModel {
                             return LoginViewModel(userRepository)
                         }
                     }

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                     // Definition of a Factory interface with a function to create objects of a type
                     public interface Factory<T> {
                         T create();
                     }

                     // Factory for LoginViewModel.
                     // Since LoginViewModel depends on UserRepository, in order to create instances of
                     // LoginViewModel, you need an instance of UserRepository that you pass as a parameter.
                     class LoginViewModelFactory implements Factory {

                         private final UserRepository userRepository;

                         public LoginViewModelFactory(UserRepository userRepository) {
                             this.userRepository = userRepository;
                         }

                         @Override
                         public LoginViewModel create() {
                             return new LoginViewModel(userRepository);
                         }
                     }

         You can include the ``LoginViewModelFactory`` in the
         ``AppContainer`` and make the ``LoginActivity`` consume it:

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                     // AppContainer can now provide instances of LoginViewModel with LoginViewModelFactory
                     class AppContainer {
                         ...
                         val userRepository = UserRepository(localDataSource, remoteDataSource)

                         val loginViewModelFactory = LoginViewModelFactory(userRepository)
                     }

                     class LoginActivity: Activity() {

                         private lateinit var loginViewModel: LoginViewModel

                         override fun onCreate(savedInstanceState: Bundle?) {
                             super.onCreate(savedInstanceState)

                             // Gets LoginViewModelFactory from the application instance of AppContainer
                             // to create a new LoginViewModel instance
                             val appContainer = (application as MyApplication).appContainer
                             loginViewModel = appContainer.loginViewModelFactory.create()
                         }
                     }

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                     // AppContainer can now provide instances of LoginViewModel with LoginViewModelFactory
                     public class AppContainer {
                         ...

                         public UserRepository userRepository = new UserRepository(localDataSource, remoteDataSource);

                         public LoginViewModelFactory loginViewModelFactory = new LoginViewModelFactory(userRepository);
                     }

                     public class MainActivity extends Activity {

                         private LoginViewModel loginViewModel;

                         @Override
                         protected void onCreate(Bundle savedInstanceState) {
                             super.onCreate(savedInstanceState);
                             setContentView(R.layout.activity_main);

                             // Gets LoginViewModelFactory from the application instance of AppContainer
                             // to create a new LoginViewModel instance
                             AppContainer appContainer = ((MyApplication) getApplication()).appContainer;
                             loginViewModel = appContainer.loginViewModelFactory.create();
                         }
                     }

         This approach is better than the previous one, but there are
         still some challenges to consider:

         #. You have to manage ``AppContainer`` yourself, creating
            instances for all dependencies by hand.

         #. There is still a lot of boilerplate code. You need to create
            factories or parameters by hand depending on whether you
            want to reuse an object or not.

         .. rubric:: Managing dependencies in application flows
            :name: dependencies-flows

         ``AppContainer`` gets complicated when you want to include more
         functionality in the project. When your app becomes larger and
         you start introducing different feature flows, there are even
         more problems that arise:

         #. When you have different flows, you might want objects to
            just live in the scope of that flow. For example, when
            creating ``LoginUserData`` (that might consist of the
            username and password used only in the login flow) you don't
            want to persist data from an old login flow from a different
            user. You want a new instance for every new flow. You can
            achieve that by creating ``FlowContainer`` objects inside
            the ``AppContainer`` as demonstrated in the next code
            example.

         #. Optimizing the application graph and flow containers can
            also be difficult. You need to remember to delete instances
            that you don't need, depending on the flow you're in.

         Imagine you have a login flow that consists of one activity
         (``LoginActivity``) and multiple fragments
         (``LoginUsernameFragment`` and ``LoginPasswordFragment``).
         These views want to:

         #. Access the same ``LoginUserData`` instance that needs to be
            shared until the login flow finishes.

         #. Create a new instance of ``LoginUserData`` when the flow
            starts again.

         You can achieve that with a login flow container. This
         container needs to be created when the login flow starts and
         removed from memory when the flow ends.

         Let's add a ``LoginContainer`` to the example code. You want to
         be able to create multiple instances of ``LoginContainer`` in
         the app, so instead of making it a singleton, make it a class
         with the dependencies the login flow needs from the
         ``AppContainer``.

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                     class LoginContainer(val userRepository: UserRepository) {

                         val loginData = LoginUserData()

                         val loginViewModelFactory = LoginViewModelFactory(userRepository)
                     }

                     // AppContainer contains LoginContainer now
                     class AppContainer {
                         ...
                         val userRepository = UserRepository(localDataSource, remoteDataSource)

                         // LoginContainer will be null when the user is NOT in the login flow
                         var loginContainer: LoginContainer? = null
                     }

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                     // Container with Login-specific dependencies
                     class LoginContainer {

                         private final UserRepository userRepository;

                         public LoginContainer(UserRepository userRepository) {
                             this.userRepository = userRepository;
                             loginViewModelFactory = new LoginViewModelFactory(userRepository);
                         }

                         public LoginUserData loginData = new LoginUserData();

                         public LoginViewModelFactory loginViewModelFactory;
                     }

                     // AppContainer contains LoginContainer now
                     public class AppContainer {
                         ...
                         public UserRepository userRepository = new UserRepository(localDataSource, remoteDataSource);

                         // LoginContainer will be null when the user is NOT in the login flow
                         public LoginContainer loginContainer;
                     }

         Once you have a container specific to a flow, you have to
         decide when to create and delete the container instance.
         Because your login flow is self-contained in an activity
         (``LoginActivity``), the activity is the one managing the
         lifecycle of that container. ``LoginActivity`` can create the
         instance in ``onCreate()`` and delete it in ``onDestroy()``.

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                     class LoginActivity: Activity() {

                         private lateinit var loginViewModel: LoginViewModel
                         private lateinit var loginData: LoginUserData
                         private lateinit var appContainer: AppContainer


                         override fun onCreate(savedInstanceState: Bundle?) {
                             super.onCreate(savedInstanceState)
                             appContainer = (application as MyApplication).appContainer

                             // Login flow has started. Populate loginContainer in AppContainer
                             appContainer.loginContainer = LoginContainer(appContainer.userRepository)

                             loginViewModel = appContainer.loginContainer.loginViewModelFactory.create()
                             loginData = appContainer.loginContainer.loginData
                         }

                         override fun onDestroy() {
                             // Login flow is finishing
                             // Removing the instance of loginContainer in the AppContainer
                             appContainer.loginContainer = null
                             super.onDestroy()
                         }
                     }

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                     public class LoginActivity extends Activity {

                         private LoginViewModel loginViewModel;
                         private LoginData loginData;
                         private AppContainer appContainer;

                         @Override
                         protected void onCreate(Bundle savedInstanceState) {
                             super.onCreate(savedInstanceState);
                             setContentView(R.layout.activity_main);

                             appContainer = ((MyApplication) getApplication()).appContainer;

                             // Login flow has started. Populate loginContainer in AppContainer
                             appContainer.loginContainer = new LoginContainer(appContainer.userRepository);

                             loginViewModel = appContainer.loginContainer.loginViewModelFactory.create();
                             loginData = appContainer.loginContainer.loginData;
                         }

                         @Override
                         protected void onDestroy() {
                             // Login flow is finishing
                             // Removing the instance of loginContainer in the AppContainer
                             appContainer.loginContainer = null;

                             super.onDestroy();
                         }
                     }

         Like ``LoginActivity``, login fragments can access the
         ``LoginContainer`` from ``AppContainer`` and use the shared
         ``LoginUserData`` instance.

         Because in this case you're dealing with view lifecycle logic,
         using `lifecycle observation <#>`__ makes
         sense.

         **Note:**\  If you need the container to survive configuration
         changes, follow the `Saving UI States guide <#>`__. You
         need to handle it the same way you handle process death;
         otherwise, your app might lose state on devices with less
         memory.
         .. rubric:: Conclusion
            :name: conclusion

         Dependency injection is a good technique for creating scalable
         and testable Android apps. Use containers as a way to share
         instances of classes in different parts of your app and as a
         centralized place to create instances of classes using
         factories.

         When your application gets larger, you will start seeing that
         you write a lot of boilerplate code (such as factories), which
         can be error-prone. You also have to manage the scope and
         lifecycle of the containers yourself, optimizing and discarding
         containers that are no longer needed in order to free up
         memory. Doing this incorrectly can lead to subtle bugs and
         memory leaks in your app.

         In the `Dagger section <#>`__,
         you'll learn how you can use Dagger to automate this process
         and generate the same code you would have written by hand
         otherwise.

         Content and code samples on this page are subject to the
         licenses described in the `Content License <#>`__. Java
         and OpenJDK are trademarks or registered trademarks of Oracle
         and/or its affiliates.

         Last updated 2024-04-10 UTC.

.. |Android apps are usually made up of many classes, and some of them depend on each other.| image:: https://developer.android.google.cn/static/topic/libraries/architecture/images/final-architecture.png
   :class: android-image-dark-theme-background
.. |image1| image:: https://developer.android.google.cn/static/images/training/dependency-injection/2-application-graph.png
   :class: android-image-dark-theme-background


/Overview: Dependency injection with Hilt
=========================================

.. https://developer.android.google.cn/training/dependency-injection

.. container:: devsite-article-body clearfix

   Hilt is a dependency injection library for Android that reduces the
   boilerplate of doing manual dependency injection in your project.
   Doing `manual dependency injection <#>`__ requires you to
   construct every class and its dependencies by hand, and to use
   containers to reuse and manage dependencies.

   Hilt provides a standard way to use DI in your application by
   providing containers for every Android class in your project and
   managing their lifecycles automatically. Hilt is built on top of the
   popular DI library
   `Dagger <#>`__ to benefit
   from the compile-time correctness, runtime performance, scalability,
   and `Android Studio support <https://medium.com/androiddevelopers/dagger-navigation-support-in-android-studio-49aa5d149ec9>`__
   that Dagger provides. For more information, see `Hilt and Dagger <#hilt-and-dagger>`__.

   This guide explains the basic concepts of Hilt and its generated
   containers. It also includes a demonstration of how to bootstrap an
   existing app to use Hilt.

   .. rubric:: Adding dependencies
      :name: setup

   First, add the ``hilt-android-gradle-plugin`` plugin to your
   project's root ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               plugins {
                 ...
                 id 'com.google.dagger.hilt.android' version '2.44' apply false
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               plugins {
                 ...
                 id("com.google.dagger.hilt.android") version "2.44" apply false
               }

   Then, apply the Gradle plugin and add these dependencies in your
   ``app/build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               ...
               plugins {
                 id 'kotlin-kapt'
                 id 'com.google.dagger.hilt.android'
               }

               android {
                 ...
               }

               dependencies {
                 implementation "com.google.dagger:hilt-android:2.44"
                 kapt "com.google.dagger:hilt-compiler:2.44"
               }

               // Allow references to generated code
               kapt {
                 correctErrorTypes true
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               plugins {
                 id 'kotlin-kapt'
                 id("com.google.dagger.hilt.android")
               }

               android {
                 ...
               }

               dependencies {
                 implementation("com.google.dagger:hilt-android:2.44")
                 kapt("com.google.dagger:hilt-android-compiler:2.44")
               }

               // Allow references to generated code
               kapt {
                 correctErrorTypes = true
               }

   **Note:**\  Projects that use both Hilt and `data binding <#>`__ require Android Studio 4.0
   or higher.
   Hilt uses `Java 8 features <#>`__. To
   enable Java 8 in your project, add the following to the
   ``app/build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               android {
                 ...
                 compileOptions {
                   sourceCompatibility JavaVersion.VERSION_1_8
                   targetCompatibility JavaVersion.VERSION_1_8
                 }
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               android {
                 ...
                 compileOptions {
                   sourceCompatibility = JavaVersion.VERSION_1_8
                   targetCompatibility = JavaVersion.VERSION_1_8
                 }
               }

   .. rubric:: Hilt application class
      :name: application-class

   All apps that use Hilt must contain an
   `Application <#>`__ class that
   is annotated with ``@HiltAndroidApp``.

   ``@HiltAndroidApp`` triggers Hilt's code generation, including a base
   class for your application that serves as the application-level
   dependency container.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @HiltAndroidApp
               class ExampleApplication : Application() { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @HiltAndroidApp
               public class ExampleApplication extends Application { ... }

   This generated Hilt component is attached to the ``Application``
   object's lifecycle and provides dependencies to it. Additionally, it
   is the parent component of the app, which means that other components
   can access the dependencies that it provides.

   .. rubric:: Inject dependencies into Android classes
      :name: android-classes

   Once Hilt is set up in your ``Application`` class and an
   application-level component is available, Hilt can provide
   dependencies to other Android classes that have the
   ``@AndroidEntryPoint`` annotation:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @AndroidEntryPoint
               class ExampleActivity : AppCompatActivity() { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @AndroidEntryPoint
               public class ExampleActivity extends AppCompatActivity { ... }

   Hilt currently supports the following Android classes:

   -  ``Application`` (by using ``@HiltAndroidApp``)
   -  ``ViewModel`` (by using ``@HiltViewModel``)
   -  ``Activity``
   -  ``Fragment``
   -  ``View``
   -  ``Service``
   -  ``BroadcastReceiver``

   If you annotate an Android class with ``@AndroidEntryPoint``, then
   you also must annotate Android classes that depend on it. For
   example, if you annotate a fragment, then you must also annotate any
   activities where you use that fragment.

   **Note:** The following exceptions apply to Hilt support for Android
   classes:

   -  Hilt only supports activities that extend
      `ComponentActivity <#>`__,
      such as
      `AppCompatActivity <#>`__.
   -  Hilt only supports fragments that extend ``androidx.Fragment``.
   -  Hilt does not support retained fragments.

   ``@AndroidEntryPoint`` generates an individual Hilt component for
   each Android class in your project. These components can receive
   dependencies from their respective parent classes as described in
   `Component hierarchy <#component-hierarchy>`__.

   To obtain dependencies from a component, use the ``@Inject``
   annotation to perform field injection:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @AndroidEntryPoint
               class ExampleActivity : AppCompatActivity() {

                 @Inject lateinit var analytics: AnalyticsAdapter
                 ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @AndroidEntryPoint
               public class ExampleActivity extends AppCompatActivity {

                 @Inject
                 AnalyticsAdapter analytics;
                 ...
               }

   **Note:**\  Fields injected by Hilt cannot be private. Attempting to
   inject a private field with Hilt results in a compilation error.
   Classes that Hilt injects can have other base classes that also use
   injection. Those classes don't need the ``@AndroidEntryPoint``
   annotation if they're abstract.

   To learn more about which lifecycle callback an Android class gets
   injected in, see `Component lifetimes <#component-lifetimes>`__.

   .. rubric:: Define Hilt bindings
      :name: define-bindings

   To perform field injection, Hilt needs to know how to provide
   instances of the necessary dependencies from the corresponding
   component. A *binding* contains the information necessary to provide
   instances of a type as a dependency.

   One way to provide binding information to Hilt is *constructor
   injection*. Use the ``@Inject`` annotation on the constructor of a
   class to tell Hilt how to provide instances of that class:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class AnalyticsAdapter @Inject constructor(
                 private val service: AnalyticsService
               ) { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class AnalyticsAdapter {

                 private final AnalyticsService service;

                 @Inject
                 AnalyticsAdapter(AnalyticsService service) {
                   this.service = service;
                 }
                 ...
               }

   The parameters of an annotated constructor of a class are the
   dependencies of that class. In the example, ``AnalyticsAdapter`` has
   ``AnalyticsService`` as a dependency. Therefore, Hilt must also know
   how to provide instances of ``AnalyticsService``.

   **Note:** At build time, Hilt generates
   `Dagger <#>`__ components
   for Android classes. Then, Dagger walks through your code and
   performs the following steps:

   -  Builds and validates dependency graphs, ensuring that there are no
      unsatisfied dependencies and no dependency cycles.
   -  Generates the classes that it uses at runtime to create the actual
      objects and their dependencies.

   .. rubric:: Hilt modules
      :name: hilt-modules

   Sometimes a type cannot be constructor-injected. This can happen for
   multiple reasons. For example, you cannot constructor-inject an
   interface. You also cannot constructor-inject a type that you do not
   own, such as a class from an external library. In these cases, you
   can provide Hilt with binding information by using *Hilt modules*.

   A Hilt module is a class that is annotated with ``@Module``. Like a
   `Dagger module <#dagger-modules>`__,
   it informs Hilt how to provide instances of certain types. Unlike
   Dagger modules, you must annotate Hilt modules with ``@InstallIn`` to
   tell Hilt which Android class each module will be used or installed
   in.

   **Note:**\  Hilt modules are different from `Gradle modules <#ApplicationModules>`__.
   Dependencies that you provide in Hilt modules are available in all
   generated components that are associated with the Android class where
   you install the Hilt module.

   **Note:**\  Because Hilt's code generation needs access to all of the
   Gradle modules that use Hilt, the Gradle module that compiles your
   ``Application`` class also needs to have all of your Hilt modules and
   constructor-injected classes in its transitive dependencies.

   .. rubric:: Inject interface instances with @Binds
      :name: inject-interfaces

   Consider the ``AnalyticsService`` example. If ``AnalyticsService`` is
   an interface, then you cannot constructor-inject it. Instead, provide
   Hilt with the binding information by creating an abstract function
   annotated with ``@Binds`` inside a Hilt module.

   The ``@Binds`` annotation tells Hilt which implementation to use when
   it needs to provide an instance of an interface.

   The annotated function provides the following information to Hilt:

   -  The function return type tells Hilt what interface the function
      provides instances of.
   -  The function parameter tells Hilt which implementation to provide.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               interface AnalyticsService {
                 fun analyticsMethods()
               }

               // Constructor-injected, because Hilt needs to know how to
               // provide instances of AnalyticsServiceImpl, too.
               class AnalyticsServiceImpl @Inject constructor(
                 ...
               ) : AnalyticsService { ... }

               @Module
               @InstallIn(ActivityComponent::class)
               abstract class AnalyticsModule {

                 @Binds
                 abstract fun bindAnalyticsService(
                   analyticsServiceImpl: AnalyticsServiceImpl
                 ): AnalyticsService
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public interface AnalyticsService {
                 void analyticsMethods();
               }

               // Constructor-injected, because Hilt needs to know how to
               // provide instances of AnalyticsServiceImpl, too.
               public class AnalyticsServiceImpl implements AnalyticsService {
                 ...
                 @Inject
                 AnalyticsServiceImpl(...) {
                   ...
                 }
               }

               @Module
               @InstallIn(ActivityComponent.class)
               public abstract class AnalyticsModule {

                 @Binds
                 public abstract AnalyticsService bindAnalyticsService(
                   AnalyticsServiceImpl analyticsServiceImpl
                 );
               }

   The Hilt module ``AnalyticsModule`` is annotated with
   ``@InstallIn(ActivityComponent.class)`` because you want Hilt to
   inject that dependency into ``ExampleActivity``. This annotation
   means that all of the dependencies in ``AnalyticsModule`` are
   available in all of the app's activities.

   .. rubric:: Inject instances with @Provides
      :name: inject-provides

   Interfaces are not the only case where you cannot constructor-inject
   a type. Constructor injection is also not possible if you don't own
   the class because it comes from an external library (classes like
   `Retrofit <https://square.github.io/retrofit/>`__,
   `OkHttpClient <https://square.github.io/okhttp/>`__, or `Room databases <#>`__), or if instances
   must be created with the `builder pattern <https://en.wikipedia.org/wiki/Builder_pattern>`__.

   Consider the previous example. If you don't directly own the
   ``AnalyticsService`` class, you can tell Hilt how to provide
   instances of this type by creating a function inside a Hilt module
   and annotating that function with ``@Provides``.

   The annotated function supplies the following information to Hilt:

   -  The function return type tells Hilt what type the function
      provides instances of.
   -  The function parameters tell Hilt the dependencies of the
      corresponding type.
   -  The function body tells Hilt how to provide an instance of the
      corresponding type. Hilt executes the function body every time it
      needs to provide an instance of that type.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Module
               @InstallIn(ActivityComponent::class)
               object AnalyticsModule {

                 @Provides
                 fun provideAnalyticsService(
                   // Potential dependencies of this type
                 ): AnalyticsService {
                     return Retrofit.Builder()
                              .baseUrl("https://example.com")
                              .build()
                              .create(AnalyticsService::class.java)
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Module
               @InstallIn(ActivityComponent.class)
               public class AnalyticsModule {

                 @Provides
                 public static AnalyticsService provideAnalyticsService(
                   // Potential dependencies of this type
                 ) {
                     return new Retrofit.Builder()
                              .baseUrl("https://example.com")
                              .build()
                              .create(AnalyticsService.class);
                 }
               }

   .. rubric:: Provide multiple bindings for the same type
      :name: multiple-bindings

   In cases where you need Hilt to provide different implementations of
   the same type as dependencies, you must provide Hilt with multiple
   bindings. You can define multiple bindings for the same type with
   *qualifiers*.

   A qualifier is an annotation that you use to identify a specific
   binding for a type when that type has multiple bindings defined.

   Consider the example. If you need to intercept calls to
   ``AnalyticsService``, you could use an ``OkHttpClient`` object with
   an `interceptor <https://square.github.io/okhttp/interceptors/>`__.
   For other services, you might need to intercept calls in a different
   way. In that case, you need to tell Hilt how to provide two different
   implementations of ``OkHttpClient``.

   First, define the qualifiers that you will use to annotate the
   ``@Binds`` or ``@Provides`` methods:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Qualifier
               @Retention(AnnotationRetention.BINARY)
               annotation class AuthInterceptorOkHttpClient

               @Qualifier
               @Retention(AnnotationRetention.BINARY)
               annotation class OtherInterceptorOkHttpClient

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Qualifier
               @Retention(RetentionPolicy.RUNTIME)
               private @interface AuthInterceptorOkHttpClient {}

               @Qualifier
               @Retention(RetentionPolicy.RUNTIME)
               private @interface OtherInterceptorOkHttpClient {}

   Then, Hilt needs to know how to provide an instance of the type that
   corresponds with each qualifier. In this case, you could use a Hilt
   module with ``@Provides``. Both methods have the same return type,
   but the qualifiers label them as two different bindings:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Module
               @InstallIn(SingletonComponent::class)
               object NetworkModule {

                 @AuthInterceptorOkHttpClient
                 @Provides
                 fun provideAuthInterceptorOkHttpClient(
                   authInterceptor: AuthInterceptor
                 ): OkHttpClient {
                     return OkHttpClient.Builder()
                              .addInterceptor(authInterceptor)
                              .build()
                 }

                 @OtherInterceptorOkHttpClient
                 @Provides
                 fun provideOtherInterceptorOkHttpClient(
                   otherInterceptor: OtherInterceptor
                 ): OkHttpClient {
                     return OkHttpClient.Builder()
                              .addInterceptor(otherInterceptor)
                              .build()
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Module
               @InstallIn(ActivityComponent.class)
               public class NetworkModule {

                 @AuthInterceptorOkHttpClient
                 @Provides
                 public static OkHttpClient provideAuthInterceptorOkHttpClient(
                   AuthInterceptor authInterceptor
                 ) {
                     return new OkHttpClient.Builder()
                                  .addInterceptor(authInterceptor)
                                  .build();
                 }

                 @OtherInterceptorOkHttpClient
                 @Provides
                 public static OkHttpClient provideOtherInterceptorOkHttpClient(
                   OtherInterceptor otherInterceptor
                 ) {
                     return new OkHttpClient.Builder()
                                  .addInterceptor(otherInterceptor)
                                  .build();
                 }
               }

   You can inject the specific type that you need by annotating the
   field or parameter with the corresponding qualifier:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // As a dependency of another class.
               @Module
               @InstallIn(ActivityComponent::class)
               object AnalyticsModule {

                 @Provides
                 fun provideAnalyticsService(
                   @AuthInterceptorOkHttpClient okHttpClient: OkHttpClient
                 ): AnalyticsService {
                     return Retrofit.Builder()
                              .baseUrl("https://example.com")
                              .client(okHttpClient)
                              .build()
                              .create(AnalyticsService::class.java)
                 }
               }

               // As a dependency of a constructor-injected class.
               class ExampleServiceImpl @Inject constructor(
                 @AuthInterceptorOkHttpClient private val okHttpClient: OkHttpClient
               ) : ...

               // At field injection.
               @AndroidEntryPoint
               class ExampleActivity: AppCompatActivity() {

                 @AuthInterceptorOkHttpClient
                 @Inject lateinit var okHttpClient: OkHttpClient
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // As a dependency of another class.
               @Module
               @InstallIn(ActivityComponent.class)
               public class AnalyticsModule {

                 @Provides
                 public static AnalyticsService provideAnalyticsService(
                   @AuthInterceptorOkHttpClient OkHttpClient okHttpClient
                 ) {
                     return new Retrofit.Builder()
                                 .baseUrl("https://example.com")
                                 .client(okHttpClient)
                                 .build()
                                 .create(AnalyticsService.class);
                 }
               }

               // As a dependency of a constructor-injected class.
               public class ExampleServiceImpl ... {

                 private final OkHttpClient okHttpClient;

                 @Inject
                 ExampleServiceImpl(@AuthInterceptorOkHttpClient OkHttpClient okHttpClient) {
                   this.okHttpClient = okHttpClient;
                 }
               }

               // At field injection.
               @AndroidEntryPoint
               public class ExampleActivity extends AppCompatActivity {

                 @AuthInterceptorOkHttpClient
                 @Inject
                 OkHttpClient okHttpClient;
                 ...
               }

   As a best practice, if you add a qualifier to a type, add qualifiers
   to all the possible ways to provide that dependency. Leaving the base
   or common implementation without a qualifier is error-prone and could
   result in Hilt injecting the wrong dependency.

   .. rubric:: Predefined qualifiers in Hilt
      :name: predefined-qualifiers

   Hilt provides some predefined qualifiers. For example, as you might
   need the ``Context`` class from either the application or the
   activity, Hilt provides the ``@ApplicationContext`` and
   ``@ActivityContext`` qualifiers.

   Suppose that the ``AnalyticsAdapter`` class from the example needs
   the context of the activity. The following code demonstrates how to
   provide the activity context to ``AnalyticsAdapter``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class AnalyticsAdapter @Inject constructor(
                   @ActivityContext private val context: Context,
                   private val service: AnalyticsService
               ) { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class AnalyticsAdapter {

                 private final Context context;
                 private final AnalyticsService service;

                 @Inject
                 AnalyticsAdapter(
                   @ActivityContext Context context,
                   AnalyticsService service
                 ) {
                   this.context = context;
                   this.service = service;
                 }
               }

   For other predefined bindings available in Hilt, see `Component default bindings <#component-default>`__.

   .. rubric:: Generated components for Android classes
      :name: generated-components

   For each Android class in which you can perform field injection,
   there's an associated Hilt component that you can refer to in the
   ``@InstallIn`` annotation. Each Hilt component is responsible for
   injecting its bindings into the corresponding Android class.

   The previous examples demonstrated the use of ``ActivityComponent``
   in Hilt modules.

   Hilt provides the following components:

   .. list-table::
      :header-rows: 1

      - 

         - Hilt component
         - Injector for
      - 

         - ``SingletonComponent``
         - ``Application``
      - 

         - ``ActivityRetainedComponent``
         - N/A
      - 

         - ``ViewModelComponent``
         - ``ViewModel``
      - 

         - ``ActivityComponent``
         - ``Activity``
      - 

         - ``FragmentComponent``
         - ``Fragment``
      - 

         - ``ViewComponent``
         - ``View``
      - 

         - ``ViewWithFragmentComponent``
         - ``View`` annotated with ``@WithFragmentBindings``
      - 

         - ``ServiceComponent``
         - ``Service``

   **Note:**\  Hilt doesn't generate a component for broadcast receivers
   because Hilt injects broadcast receivers directly from
   ``SingletonComponent``.

   .. rubric:: Component lifetimes
      :name: component-lifetimes

   Hilt automatically creates and destroys instances of generated
   component classes following the lifecycle of the corresponding
   Android classes.

   .. list-table::
      :header-rows: 1

      - 

         - Generated component
         - Created at
         - Destroyed at
      - 

         - ``SingletonComponent``
         - ``Application#onCreate()``
         - ``Application`` destroyed
      - 

         - ``ActivityRetainedComponent``
         - ``Activity#onCreate()``
         - ``Activity#onDestroy()``
      - 

         - ``ViewModelComponent``
         - ``ViewModel`` created
         - ``ViewModel`` destroyed
      - 

         - ``ActivityComponent``
         - ``Activity#onCreate()``
         - ``Activity#onDestroy()``
      - 

         - ``FragmentComponent``
         - ``Fragment#onAttach()``
         - ``Fragment#onDestroy()``
      - 

         - ``ViewComponent``
         - ``View#super()``
         - ``View`` destroyed
      - 

         - ``ViewWithFragmentComponent``
         - ``View#super()``
         - ``View`` destroyed
      - 

         - ``ServiceComponent``
         - ``Service#onCreate()``
         - ``Service#onDestroy()``

   **Note:**\  ``ActivityRetainedComponent`` lives across configuration
   changes, so it is created at the first ``Activity#onCreate()`` and
   destroyed at the last ``Activity#onDestroy()``.

   .. rubric:: Component scopes
      :name: component-scopes

   By default, all bindings in Hilt are *unscoped*. This means that each
   time your app requests the binding, Hilt creates a new instance of
   the needed type.

   In the example, every time Hilt provides ``AnalyticsAdapter`` as a
   dependency to another type or through field injection (as in
   ``ExampleActivity``), Hilt provides a new instance of
   ``AnalyticsAdapter``.

   However, Hilt also allows a binding to be scoped to a particular
   component. Hilt only creates a scoped binding once per instance of
   the component that the binding is scoped to, and all requests for
   that binding share the same instance.

   The table below lists scope annotations for each generated component:

   .. list-table::
      :header-rows: 1

      - 

         - Android class
         - Generated component
         - Scope
      - 

         - ``Application``
         - ``SingletonComponent``
         - ``@Singleton``
      - 

         - ``Activity``
         - ``ActivityRetainedComponent``
         - ``@ActivityRetainedScoped``
      - 

         - ``ViewModel``
         - ``ViewModelComponent``
         - ``@ViewModelScoped``
      - 

         - ``Activity``
         - ``ActivityComponent``
         - ``@ActivityScoped``
      - 

         - ``Fragment``
         - ``FragmentComponent``
         - ``@FragmentScoped``
      - 

         - ``View``
         - ``ViewComponent``
         - ``@ViewScoped``
      - 

         - ``View`` annotated with ``@WithFragmentBindings``
         - ``ViewWithFragmentComponent``
         - ``@ViewScoped``
      - 

         - ``Service``
         - ``ServiceComponent``
         - ``@ServiceScoped``

   In the example, if you scope ``AnalyticsAdapter`` to the
   ``ActivityComponent`` using ``@ActivityScoped``, Hilt provides the
   same instance of ``AnalyticsAdapter`` throughout the life of the
   corresponding activity:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @ActivityScoped
               class AnalyticsAdapter @Inject constructor(
                 private val service: AnalyticsService
               ) { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @ActivityScoped
               public class AnalyticsAdapter {

                 private final AnalyticsService service;

                 @Inject
                 AnalyticsAdapter(AnalyticsService service) {
                   this.service = service;
                 }
                 ...
               }

   **Note:**\  Scoping a binding to a component can be costly because
   the provided object stays in memory until that component is
   destroyed. Minimize the use of scoped bindings in your application.
   It is appropriate to use component-scoped bindings for bindings with
   an internal state that requires that same instance to be used within
   a certain scope, for bindings that need synchronization, or for
   bindings that you have measured to be expensive to create.
   Suppose that ``AnalyticsService`` has an internal state that requires
   the same instance to be used every time‚Äînot only in
   ``ExampleActivity``, but anywhere in the app. In this case, it is
   appropriate to scope ``AnalyticsService`` to the
   ``SingletonComponent``. The result is that whenever the component
   needs to provide an instance of ``AnalyticsService``, it provides the
   same instance every time.

   The following example demonstrates how to scope a binding to a
   component in a Hilt module. A binding's scope must match the scope of
   the component where it is installed, so in this example you must
   install ``AnalyticsService`` in ``SingletonComponent`` instead of
   ``ActivityComponent``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // If AnalyticsService is an interface.
               @Module
               @InstallIn(SingletonComponent::class)
               abstract class AnalyticsModule {

                 @Singleton
                 @Binds
                 abstract fun bindAnalyticsService(
                   analyticsServiceImpl: AnalyticsServiceImpl
                 ): AnalyticsService
               }

               // If you don't own AnalyticsService.
               @Module
               @InstallIn(SingletonComponent::class)
               object AnalyticsModule {

                 @Singleton
                 @Provides
                 fun provideAnalyticsService(): AnalyticsService {
                     return Retrofit.Builder()
                              .baseUrl("https://example.com")
                              .build()
                              .create(AnalyticsService::class.java)
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // If AnalyticsService is an interface.
               @Module
               @InstallIn(SingletonComponent.class)
               public abstract class AnalyticsModule {

                 @Singleton
                 @Binds
                 public abstract AnalyticsService bindAnalyticsService(
                   AnalyticsServiceImpl analyticsServiceImpl
                 );
               }

               // If you don't own AnalyticsService.
               @Module
               @InstallIn(SingletonComponent.class)
               public class AnalyticsModule {

                 @Singleton
                 @Provides
                 public static AnalyticsService provideAnalyticsService() {
                     return new Retrofit.Builder()
                              .baseUrl("https://example.com")
                              .build()
                              .create(AnalyticsService.class);
                 }
               }

   To learn more about Hilt component scopes, see `Scoping in Android and Hilt <https://medium.com/androiddevelopers/scoping-in-android-and-hilt-c2e5222317c0>`__.

   **Note:**\  For more information about the differences between
   scoping with ``@ActivityRetainedScoped`` or ``@ViewModelScoped``, see
   the ``@ViewModelScoped`` section in the `Hilt and Jetpack integrations doc <#viewmodelscoped>`__.

   .. rubric:: Component hierarchy
      :name: component-hierarchy

   Installing a module into a component allows its bindings to be
   accessed as a dependency of other bindings in that component or in
   any child component below it in the component hierarchy:

   .. container::

      .. figure::
         https://developer.android.google.cn/static/images/training/dependency-injection/hilt-hierarchy.svg
         name: component-hierarchy-image
         :alt: ViewWithFragmentComponent is under FragmentComponent.
         FragmentComponent and ViewComponent are under
         ActivityComponent. ActivityComponent is under
         ActivityRetainedComponent. ViewModelComponent is under
         ActivityRetainedComponent. ActivityRetainedComponent and
         ServiceComponent are under SingletonComponent.

         **Figure 1.** Hierarchy of the components that Hilt generates.

   **Note:**\  By default, if you perform field injection in a view,
   ``ViewComponent`` can use bindings that are defined in the
   ``ActivityComponent``. If you also need to use bindings that are
   defined in ``FragmentComponent`` and the view is part of a fragment,
   use the ``@WithFragmentBindings`` annotation with
   ``@AndroidEntryPoint``.

   .. rubric:: Component default bindings
      :name: component-default

   Each Hilt component comes with a set of default bindings that Hilt
   can inject as dependencies into your own custom bindings. Note that
   these bindings correspond to the general activity and fragment types
   and not to any specific subclass. This is because Hilt uses a single
   activity component definition to inject all activities. Each activity
   has a different instance of this component.

   .. list-table::
      :header-rows: 1

      - 

         - Android component
         - Default bindings
      - 

         - ``SingletonComponent``
         - ``Application``
      - 

         - ``ActivityRetainedComponent``
         - ``Application``
      - 

         - ``ViewModelComponent``
         - ``SavedStateHandle``
      - 

         - ``ActivityComponent``
         - ``Application``, ``Activity``
      - 

         - ``FragmentComponent``
         - ``Application``, ``Activity``, ``Fragment``
      - 

         - ``ViewComponent``
         - ``Application``, ``Activity``, ``View``
      - 

         - ``ViewWithFragmentComponent``
         - ``Application``, ``Activity``, ``Fragment``, ``View``
      - 

         - ``ServiceComponent``
         - ``Application``, ``Service``

   The application context binding is also available using
   ``@ApplicationContext``. For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class AnalyticsServiceImpl @Inject constructor(
                 @ApplicationContext context: Context
               ) : AnalyticsService { ... }

               // The Application binding is available without qualifiers.
               class AnalyticsServiceImpl @Inject constructor(
                 application: Application
               ) : AnalyticsService { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class AnalyticsServiceImpl implements AnalyticsService {

                 private final Context context;

                 @Inject
                 AnalyticsAdapter(@ApplicationContext Context context) {
                   this.context = context;
                 }
               }

               // The Application binding is available without qualifiers.
               public class AnalyticsServiceImpl implements AnalyticsService {

                 private final Application application;

                 @Inject
                 AnalyticsAdapter(Application application) {
                   this.application = application;
                 }
               }

   The activity context binding is also available using
   ``@ActivityContext``. For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class AnalyticsAdapter @Inject constructor(
                 @ActivityContext context: Context
               ) { ... }

               // The Activity binding is available without qualifiers.
               class AnalyticsAdapter @Inject constructor(
                 activity: FragmentActivity
               ) { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class AnalyticsAdapter {

                 private final Context context;

                 @Inject
                 AnalyticsAdapter(@ActivityContext Context context) {
                   this.context = context;
                 }
               }

               // The Activity binding is available without qualifiers.
               public class AnalyticsAdapter {

                 private final FragmentActivity activity;

                 @Inject
                 AnalyticsAdapter(FragmentActivity activity) {
                   this.activity = activity;
                 }
               }

   .. rubric:: Inject dependencies in classes not supported by Hilt
      :name: not-supported

   Hilt comes with support for the most common Android classes. However,
   you might need to perform field injection in classes that Hilt
   doesn't support.

   In those cases, you can create an entry point using the
   ``@EntryPoint`` annotation. An entry point is the boundary between
   code that is managed by Hilt and code that is not. It is the point
   where code first enters into the graph of objects that Hilt manages.
   Entry points allow Hilt to use code that Hilt does not manage to
   provide dependencies within the dependency graph.

   For example, Hilt doesn't directly support `content providers <#>`__. If you want
   a content provider to use Hilt to get some dependencies, you need to
   define an interface that is annotated with ``@EntryPoint`` for each
   binding type that you want and include qualifiers. Then add
   ``@InstallIn`` to specify the component in which to install the entry
   point as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleContentProvider : ContentProvider() {

                 @EntryPoint
                 @InstallIn(SingletonComponent::class)
                 interface ExampleContentProviderEntryPoint {
                   fun analyticsService(): AnalyticsService
                 }

                 ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleContentProvider extends ContentProvider {

                 @EntryPoint
                 @InstallIn(SingletonComponent.class)
                 interface ExampleContentProviderEntryPoint {
                   public AnalyticsService analyticsService();
                 }
                 ...
               }

   To access an entry point, use the appropriate static method from
   ``EntryPointAccessors``. The parameter should be either the component
   instance or the ``@AndroidEntryPoint`` object that acts as the
   component holder. Make sure that the component you pass as a
   parameter and the ``EntryPointAccessors`` static method both match
   the Android class in the ``@InstallIn`` annotation on the
   ``@EntryPoint`` interface:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleContentProvider: ContentProvider() {
                   ...

                 override fun query(...): Cursor {
                   val appContext = context?.applicationContext ?: throw IllegalStateException()
                   val hiltEntryPoint =
                     EntryPointAccessors.fromApplication(appContext, ExampleContentProviderEntryPoint::class.java)

                   val analyticsService = hiltEntryPoint.analyticsService()
                   ...
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleContentProvider extends ContentProvider {

                 @Override
                 public Cursor query(...) {
                   Context appContext = getContext().getApplicationContext();
                   ExampleContentProviderEntryPoint hiltEntryPoint =
                     EntryPointAccessors.fromApplication(appContext, ExampleContentProviderEntryPoint.class);
                   AnalyticsService analyticsService = hiltEntryPoint.analyticsService();
                 }
               }

   In this example, you must use the ``ApplicationContext`` to retrieve
   the entry point because the entry point is installed in
   ``SingletonComponent``. If the binding that you wanted to retrieve
   were in the ``ActivityComponent``, you would instead use the
   ``ActivityContext``.

   .. rubric:: Hilt and Dagger
      :name: hilt-and-dagger

   Hilt is built on top of the `Dagger <https://dagger.dev/>`__
   dependency injection library, providing a standard way to incorporate
   Dagger into an Android application.

   With respect to Dagger, the goals of Hilt are as follows:

   -  To simplify Dagger-related infrastructure for Android apps.
   -  To create a standard set of components and scopes to ease setup,
      readability, and code sharing between apps.
   -  To provide an easy way to provision different bindings to various
      build types, such as testing, debug, or release.

   Because the Android operating system instantiates many of its own
   framework classes, using Dagger in an Android app requires you to
   write a substantial amount of boilerplate. Hilt reduces the
   boilerplate code that is involved in using Dagger in an Android
   application. Hilt automatically generates and provides the following:

   -  **Components for integrating Android framework classes** with
      Dagger that you would otherwise need to create by hand.
   -  **Scope annotations** to use with the components that Hilt
      generates automatically.
   -  **Predefined bindings** to represent Android classes such as
      ``Application`` or ``Activity``.
   -  **Predefined qualifiers** to represent ``@ApplicationContext`` and
      ``@ActivityContext``.

   Dagger and Hilt code can coexist in the same codebase. However, in
   most cases it is best to use Hilt to manage all of your usage of
   Dagger on Android. To migrate a project that uses Dagger to Hilt, see
   the `migration guide <https://dagger.dev/hilt/migration-guide>`__ and
   the `Migrating your Dagger app to Hilt codelab <https://developers.google.cn/codelabs/codelabs/android-dagger-to-hilt>`__.

   .. rubric:: Additional resources
      :name: additional-resources

   To learn more about Hilt, see the following additional resources.

   .. rubric:: Samples
      :name: samples

   .. rubric:: Codelabs
      :name: codelabs

   -  `Using Hilt in your Android app <https://developers.google.cn/codelabs/codelabs/android-hilt/>`__
   -  `Migrating your Dagger app to Hilt <https://developers.google.cn/codelabs/codelabs/android-dagger-to-hilt/>`__

   .. rubric:: Blogs
      :name: blogs

   -  `Dependency Injection on Android with Hilt <https://medium.com/androiddevelopers/dependency-injection-on-android-with-hilt-67b6031e62d>`__
   -  `Scoping in Android and Hilt <https://medium.com/androiddevelopers/scoping-in-android-and-hilt-c2e5222317c0>`__
   -  `Adding components to the Hilt hierarchy <https://medium.com/androiddevelopers/hilt-adding-components-to-the-hierarchy-96f207d6d92d>`__
   -  `Migrating the Google I/O app to Hilt <https://medium.com/androiddevelopers/migrating-the-google-i-o-app-to-hilt-f3edf03affe5>`__


Last updated 2024-05-03 UTC.


/Hilt in multi-module apps
==========================

.. container:: devsite-article-body clearfix

   Hilt code generation needs access to all the Gradle modules that use
   Hilt. The Gradle module that compiles your
   `Application <#>`__ class needs
   to have all Hilt modules and constructor-injected classes in its
   transitive dependencies.

   If your multi-module project is composed of regular Gradle modules,
   then you can use Hilt as described in `Dependency injection with Hilt <#>`__. However, this
   is not the case with apps that include `feature modules <#customize_delivery>`__.

   **Note:**\  For deep multi-module projects, consider enabling the
   ``enableExperimentalClasspathAggregation`` flag in your
   ``build.gradle`` file. Read more about it in the `Hilt documentation <https://dagger.dev/hilt/gradle-setup#classpath-aggregation>`__.

   .. rubric:: Hilt in feature modules
      :name: dfm

   In feature modules, the way that modules usually depend on each other
   is inverted. Therefore, Hilt cannot process annotations in feature
   modules. You must use
   `Dagger <#>`__ to perform
   dependency injection in your feature modules.

   You must use component dependencies to solve this problem with
   feature modules. Follow these steps:

   #. Declare an `@EntryPoint``
      interface </training/dependency-injection/hilt-android#not-supported>`__
      in the ``app`` module (or in any other module that can be
      processed by Hilt) with the dependencies that the feature module
      needs.
   #. Create a Dagger component that depends on the ``@EntryPoint``
      interface.
   #. Use Dagger as usual in the feature module.

   Consider the example from the `Dependency injection with Hilt <#>`__ page. Suppose
   you add a ``login`` feature module to your project. You implement the
   login feature with an activity called ``LoginActivity``. This means
   that you can get bindings only from the application component.

   For this feature, you need an ``OkHttpClient`` with the
   ``authInterceptor`` binding.

   First, create an ``@EntryPoint`` interface installed in the
   ``SingletonComponent`` with the bindings that the ``login`` module
   needs:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // LoginModuleDependencies.kt - File in the app module.

               @EntryPoint
               @InstallIn(SingletonComponent::class)
               interface LoginModuleDependencies {

                 @AuthInterceptorOkHttpClient
                 fun okHttpClient(): OkHttpClient
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // LoginModuleDependencies.java - File in the app module.

               @EntryPoint
               @InstallIn(SingletonComponent.class)
               public interface LoginModuleDependencies {

                 @AuthInterceptorOkHttpClient
                 OkHttpClient okHttpClient();
               }

   To perform field injection in the ``LoginActivity``, create a Dagger
   component that depends on the ``@EntryPoint`` interface:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // LoginComponent.kt - File in the login module.

               @Component(dependencies = [LoginModuleDependencies::class])
               interface LoginComponent {

                 fun inject(activity: LoginActivity)

                 @Component.Builder
                 interface Builder {
                   fun context(@BindsInstance context: Context): Builder
                   fun appDependencies(loginModuleDependencies: LoginModuleDependencies): Builder
                   fun build(): LoginComponent
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // LoginComponent.java - File in the login module.

               @Component(dependencies = LoginModuleDependencies.class)
               public interface LoginComponent {

                 void inject(LoginActivity loginActivity);

                 @Component.Builder
                 interface Builder {
                   Builder context(@BindsInstance Context context);
                   Builder appDependencies(LoginModuleDependencies loginModuleDependencies);
                   LoginComponent build();
                 }
               }

   Once those steps are complete, use Dagger as usual in your feature
   module. For example, you can use the bindings from the
   ``SingletonComponent`` as a dependency of a class:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // LoginAnalyticsAdapter.kt - File in the login module.

               class LoginAnalyticsAdapter @Inject constructor(
                 @AuthInterceptorOkHttpClient okHttpClient: OkHttpClient
               ) { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // LoginAnalyticsAdapter.java - File in the login module.

               public class LoginAnalyticsAdapter {

                 private final OkHttpClient okHttpClient;

                 @Inject
                 LoginAnalyticsAdapter(
                   @AuthInterceptorOkHttpClient OkHttpClient okHttpClient
                 ) {
                   this.okHttpClient = okHttpClient;
                 }
                 ...
               }

   To perform field injection, create an instance of the Dagger
   component using the ``applicationContext`` to get the
   ``SingletonComponent`` dependencies:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // LoginActivity.kt - File in the login module.

               class LoginActivity : AppCompatActivity() {

                 @Inject
                 lateinit var loginAnalyticsAdapter: LoginAnalyticsAdapter

                 override fun onCreate(savedInstanceState: Bundle?) {
                   DaggerLoginComponent.builder()
                       .context(this)
                       .appDependencies(
                         EntryPointAccessors.fromApplication(
                           applicationContext,
                           LoginModuleDependencies::class.java
                         )
                       )
                       .build()
                       .inject(this)

                   super.onCreate(savedInstanceState)
                   ...
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // LoginActivity.java - File in the login module.

               public class LoginActivity extends AppCompatActivity {

                 @Inject
                 LoginAnalyticsAdapter loginAnalyticsAdapter;

                 @Override
                 protected void onCreate(Bundle savedInstanceState) {
                   DaggerLoginComponent.builder()
                       .context(this)
                       .appDependencies(
                         EntryPointAccessors.fromApplication(
                           getApplicationContext(),
                           LoginModuleDependencies.class
                         )
                       )
                       .build()
                       .inject(this);

                   super.onCreate(savedInstanceState);
                   ...
                 }
               }

   For more context on module dependencies in feature modules, see
   `Component dependencies with feature modules <#dagger-dfm>`__.

   For more information about Dagger on Android, see `Using Dagger in Android apps <#>`__.


Last updated 2024-01-03 UTC.


/Use Hilt with other Jetpack libraries
======================================

.. container:: devsite-article-body clearfix

   Hilt includes extensions for providing classes from other Jetpack
   libraries. Hilt currently supports the following Jetpack components:

   -  ``ViewModel``
   -  Navigation
   -  Compose
   -  WorkManager

   You must add the Hilt dependencies to take advantage of these
   integrations. For more information about adding dependencies, see
   `Dependency injection with Hilt <#setup>`__.

   .. rubric:: Inject ViewModel objects with Hilt
      :name: viewmodels

   Provide a `ViewModel <#>`__
   by annotating it with ``@HiltViewModel`` and using the ``@Inject``
   annotation in the ``ViewModel`` object's constructor.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @HiltViewModel
               class ExampleViewModel @Inject constructor(
                 private val savedStateHandle: SavedStateHandle,
                 private val repository: ExampleRepository
               ) : ViewModel() {
                 ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @HiltViewModel
               public class ExampleViewModel extends ViewModel {

                 private final ExampleRepository repository;
                 private final SavedStateHandle savedStateHandle;

                 @Inject
                 ExampleViewModel(
                     SavedStateHandle savedStateHandle,
                     ExampleRepository repository)
                   {
                   this.savedStateHandle = savedStateHandle;
                   this.repository = repository;
                 }
                 ...
               }

   Then, an activity or a fragment that is annotated with
   ``@AndroidEntryPoint`` can get the ``ViewModel`` instance as normal
   using ``ViewModelProvider`` or the ``by viewModels()`` `KTX extensions <#>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @AndroidEntryPoint
               class ExampleActivity : AppCompatActivity() {
                 private val exampleViewModel: ExampleViewModel by viewModels()
                 ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @AndroidEntryPoint
               public class ExampleActivity extends AppCompatActivity {

                 private ExampleViewModel exampleViewModel;

                 @Override
                 protected void onCreate(Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);
                   exampleViewModel = new ViewModelProvider(this).get(ExampleViewModel.class);
                 }
                 ...
               }

   **Note:**\  To use Dagger's assisted injection with ViewModels, see
   the following `Github issue <https://github.com/google/dagger/issues/2287>`__.

   .. rubric:: @ViewModelScoped
      :name: viewmodelscoped

   All Hilt ViewModels are provided by the ``ViewModelComponent`` which
   follows the same lifecycle as a ``ViewModel``, and as such, can
   survive configuration changes. To scope a dependency to a
   ``ViewModel`` use the ``@ViewModelScoped`` annotation.

   A ``@ViewModelScoped`` type will make it so that a single instance of
   the scoped type is provided across all dependencies injected into the
   ``ViewModel``. Other instances of a ViewModel that request the scoped
   instance will receive a different instance.

   If a single instance needs to be shared across various ViewModels,
   then it should be scoped using either ``@ActivityRetainedScoped`` or
   ``@Singleton``.

   .. rubric:: Integration with the Jetpack navigation library
      :name: viewmodel-navigation

   Add the following additional dependencies to your Gradle file:

   app/build.gradle

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   ...
                   implementation 'androidx.hilt:hilt-navigation-fragment:1.0.0'
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   ...
                   implementation("androidx.hilt:hilt-navigation-fragment:1.0.0")
               }

   If your ``ViewModel`` is `scoped to the navigation graph <#share_ui-related_data_between_destinations_with_viewmodel>`__,
   use the ``hiltNavGraphViewModels`` function that works with fragments
   that are annotated with ``@AndroidEntryPoint``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val viewModel: ExampleViewModel by hiltNavGraphViewModels(R.id.my_graph)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               NavBackStackEntry backStackEntry = navController.getBackStackEntry(R.id.my_graph);

               ExampleViewModel exampleViewModel = new ViewModelProvider(
                 backStackEntry,
                 HiltViewModelFactory.create(context, backStackEntry)
               ).get(ExampleViewModel.class)

   .. rubric:: Integration with Jetpack Compose
      :name: compose

   To see how Hilt integrates with Jetpack Compose, see the Hilt section
   of `Compose and other libraries <#hilt>`__.

   .. rubric:: Inject WorkManager with Hilt
      :name: workmanager

   Add the following additional dependencies to your Gradle file. Note
   that in addition to the library, you need to include an additional
   annotation processor that works on top of the Hilt annotation
   processor:

   app/build.gradle

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                 ...
                 implementation 'androidx.hilt:hilt-work:1.0.0'
                 // When using Kotlin.
                 kapt 'androidx.hilt:hilt-compiler:1.0.0'
                 // When using Java.
                 annotationProcessor 'androidx.hilt:hilt-compiler:1.0.0'
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   implementation("androidx.hilt:hilt-work:1.0.0")
                   // When using Kotlin.
                   kapt("androidx.hilt:hilt-compiler:1.0.0")
                   // When using Java.
                   annotationProcessor("androidx.hilt:hilt-compiler:1.0.0")
               }

   Inject a `Worker <#>`__
   using the ``@HiltWorker`` annotation in the class and
   ``@AssistedInject`` in the ``Worker`` object's constructor. You can
   use only ``@Singleton`` or unscoped bindings in ``Worker`` objects.
   You must also annotate the ``Context`` and ``WorkerParameters``
   dependencies with ``@Assisted``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @HiltWorker
               class ExampleWorker @AssistedInject constructor(
                 @Assisted appContext: Context,
                 @Assisted workerParams: WorkerParameters,
                 workerDependency: WorkerDependency
               ) : Worker(appContext, workerParams) { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @HiltWorker
               public class ExampleWorker extends Worker {

                 private final WorkerDependency workerDependency;

                 @AssistedInject
                 ExampleWorker(
                   @Assisted @NonNull Context context,
                   @Assisted @NonNull WorkerParameters params,
                   WorkerDependency workerDependency
                 ) {
                   super(context, params);
                   this.workerDependency = workerDependency;
                 }
                 ...
               }

   Then, have your
   `Application <#>`__ class
   implement the ``Configuration.Provider`` interface, inject an
   instance of ``HiltWorkFactory``, and pass it into the ``WorkManager``
   configuration as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @HiltAndroidApp
               class ExampleApplication : Application(), Configuration.Provider {

                 @Inject lateinit var workerFactory: HiltWorkerFactory

                 override fun getWorkManagerConfiguration() =
                     Configuration.Builder()
                           .setWorkerFactory(workerFactory)
                           .build()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @HiltAndroidApp
               public class ExampleApplication extends Application implements Configuration.Provider {

                 @Inject HiltWorkerFactory workerFactory;

                 @Override
                 public Configuration getWorkManagerConfiguration() {
                   return new Configuration.Builder()
                            .setWorkerFactory(workerFactory)
                            .build();
                 }
               }

   **Note:**\  Because this customizes the ``WorkManager``
   configuration, you also must remove the default initializer from the
   ``AndroidManifest.xml`` file as specified in the `WorkManager docs <https://developer.android.google.cn/topic/libraries/architecture/workmanager/advanced/custom-configuration>`__.
   **Warning:**\  ``WorkManager`` version ``2.6.0-alpha01`` or higher
   uses the ``androidx.startup`` initializer. To properly configure
   ``WorkManager`` in this version with Hilt, check out the
   `WorkManager`` release
   notes <https://developer.android.google.cn/jetpack/androidx/releases/work#2.6.0-alpha01>`__.


Last updated 2024-01-03 UTC.


/Hilt testing guide
===================

.. container:: devsite-article-body clearfix

   One of the benefits of using dependency injection frameworks like
   Hilt is that it makes testing your code easier.

   .. rubric:: Unit tests
      :name: unit-tests

   Hilt isn't necessary for unit tests, since when testing a class that
   uses constructor injection, you don't need to use Hilt to instantiate
   that class. Instead, you can directly call a class constructor by
   passing in fake or mock dependencies, just as you would if the
   constructor weren't annotated:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @ActivityScoped
               class AnalyticsAdapter @Inject constructor(
                 private val service: AnalyticsService
               ) { ... }

               class AnalyticsAdapterTest {

                 @Test
                 fun `Happy path`() {
                   // You don't need Hilt to create an instance of AnalyticsAdapter.
                   // You can pass a fake or mock AnalyticsService.
                   val adapter = AnalyticsAdapter(fakeAnalyticsService)
                   assertEquals(...)
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @ActivityScope
               public class AnalyticsAdapter {

                 private final AnalyticsService analyticsService;

                 @Inject
                 AnalyticsAdapter(AnalyticsService analyticsService) {
                   this.analyticsService = analyticsService;
                 }
               }

               public final class AnalyticsAdapterTest {

                 @Test
                 public void happyPath() {
                   // You don't need Hilt to create an instance of AnalyticsAdapter.
                   // You can pass a fake or mock AnalyticsService.
                   AnalyticsAdapter adapter = new AnalyticsAdapter(fakeAnalyticsService);
                   assertEquals(...);
                 }
               }

   .. rubric:: End-to-end tests
      :name: end-to-end

   For integration tests, Hilt injects dependencies as it would in your
   production code. Testing with Hilt requires no maintenance because
   Hilt automatically generates a new set of components for each test.

   .. rubric:: Adding testing dependencies
      :name: testing-dependencies

   To use Hilt in your tests, include the ``hilt-android-testing``
   dependency in your project:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   // For Robolectric tests.
                   testImplementation 'com.google.dagger:hilt-android-testing:2.44'
                   // ...with Kotlin.
                   kaptTest 'com.google.dagger:hilt-android-compiler:2.44'
                   // ...with Java.
                   testAnnotationProcessor 'com.google.dagger:hilt-android-compiler:2.44'


                   // For instrumented tests.
                   androidTestImplementation 'com.google.dagger:hilt-android-testing:2.44'
                   // ...with Kotlin.
                   kaptAndroidTest 'com.google.dagger:hilt-android-compiler:2.44'
                   // ...with Java.
                   androidTestAnnotationProcessor 'com.google.dagger:hilt-android-compiler:2.44'
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   // For Robolectric tests.
                   testImplementation("com.google.dagger:hilt-android-testing:2.44")
                   // ...with Kotlin.
                   kaptTest("com.google.dagger:hilt-android-compiler:2.44")
                   // ...with Java.
                   testAnnotationProcessor("com.google.dagger:hilt-android-compiler:2.44")


                   // For instrumented tests.
                   androidTestImplementation("com.google.dagger:hilt-android-testing:2.44")
                   // ...with Kotlin.
                   kaptAndroidTest("com.google.dagger:hilt-android-compiler:2.44")
                   // ...with Java.
                   androidTestAnnotationProcessor("com.google.dagger:hilt-android-compiler:2.44")
               }

   **Note:**\  If you use `Jetpack integrations <#>`__, you
   must also include the annotation processors for the integrated
   libraries with ``kaptTest`` or ``kaptAndroidTest`` for Kotlin, or
   with ``testAnnotationProcessor`` or
   ``androidTestAnnotationProcessor`` for Java.

   .. rubric:: UI test setup
      :name: ui-test

   You must annotate any UI test that uses Hilt with
   ``@HiltAndroidTest``. This annotation is responsible for generating
   the Hilt components for each test.

   Also, you need to add the ``HiltAndroidRule`` to the test class. It
   manages the components' state and is used to perform injection on
   your test:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @HiltAndroidTest
               class SettingsActivityTest {

                 @get:Rule
                 var hiltRule = HiltAndroidRule(this)

                 // UI tests here.
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @HiltAndroidTest
               public final class SettingsActivityTest {

                 @Rule
                 public HiltAndroidRule hiltRule = new HiltAndroidRule(this);

                 // UI tests here.
               }

   **Note:**\  If you have other rules in your test, see `Multiple TestRule objects in your instrumented test <#multiple-testrules>`__.
   Next, your test needs to know about the ``Application`` class that
   Hilt automatically generates for you.

   .. rubric:: Test application
      :name: test-application

   You must execute instrumented tests that use Hilt in an
   ``Application`` object that supports Hilt. The library provides
   ``HiltTestApplication`` for use in tests. If your tests need a
   different base application, see `Custom application for tests <#custom-application>`__.

   You must set your test application to run in your `instrumented tests <#>`__ or `Robolectric tests <http://robolectric.org/>`__. The following instructions aren't
   specific to Hilt, but are general guidelines on how to specify a
   custom application to run in tests.

   .. rubric:: Set the test application in instrumented tests
      :name: instrumented-tests

   To use the Hilt test application in `instrumented tests <#>`__, you need to configure a new
   test runner. This makes Hilt work for all of the instrumented tests
   in your project. Perform the following steps:

   #. Create a custom class that extends
      `AndroidJUnitRunner <#>`__
      in the ``androidTest`` folder.
   #. Override the ``newApplication`` function and pass in the name of
      the generated Hilt test application.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // A custom runner to set up the instrumented application class for tests.
               class CustomTestRunner : AndroidJUnitRunner() {

                   override fun newApplication(cl: ClassLoader?, name: String?, context: Context?): Application {
                       return super.newApplication(cl, HiltTestApplication::class.java.name, context)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // A custom runner to set up the instrumented application class for tests.
               public final class CustomTestRunner extends AndroidJUnitRunner {

                 @Override
                 public Application newApplication(ClassLoader cl, String className, Context context)
                     throws ClassNotFoundException, IllegalAccessException, InstantiationException {
                   return super.newApplication(cl, HiltTestApplication.class.getName(), context);
                 }
               }

   Next, configure this test runner in your Gradle file as described in
   the `instrumented unit test guide <#setup>`__.
   Make sure you use the full classpath:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               android {
                   defaultConfig {
                       // Replace com.example.android.dagger with your class path.
                       testInstrumentationRunner "com.example.android.dagger.CustomTestRunner"
                   }
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               android {
                   defaultConfig {
                       // Replace com.example.android.dagger with your class path.
                       testInstrumentationRunner = "com.example.android.dagger.CustomTestRunner"
                   }
               }

   .. rubric:: Set the test application in Robolectric tests
      :name: robolectric-tests

   If you use Robolectric to test your UI layer, you can specify which
   application to use in the ``robolectric.properties`` file:

   ``application = dagger.hilt.android.testing.HiltTestApplication``

   Alternatively, you can configure the application on each test
   individually by using Robolectric's ``@Config`` annotation:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @HiltAndroidTest
               @Config(application = HiltTestApplication::class)
               class SettingsActivityTest {

                 @get:Rule
                 var hiltRule = HiltAndroidRule(this)

                 // Robolectric tests here.
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @HiltAndroidTest
               @Config(application = HiltTestApplication.class)
               class SettingsActivityTest {

                 @Rule public HiltAndroidRule hiltRule = new HiltAndroidRule(this);

                 // Robolectric tests here.
               }

   If you use an Android Gradle Plugin version lower than 4.2, enable
   transforming ``@AndroidEntryPoint`` classes in local unit tests by
   applying the following configuration in your module's
   ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               hilt {
                   enableTransformForLocalTests = true
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               hilt {
                   enableTransformForLocalTests = true
               }

   More information about ``enableTransformForLocalTests`` in the `Hilt documentation <https://dagger.dev/hilt/gradle-setup#gradle-plugin-local-tests>`__.

   .. rubric:: Testing features
      :name: testing-features

   Once Hilt is ready to use in your tests, you can use several features
   to customize the testing process.

   .. rubric:: Inject types in tests
      :name: inject-in-tests

   To inject types into a test, use ``@Inject`` for field injection. To
   tell Hilt to populate the ``@Inject`` fields, call
   ``hiltRule.inject()``.

   See the following example of an instrumented test:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @HiltAndroidTest
               class SettingsActivityTest {

                 @get:Rule
                 var hiltRule = HiltAndroidRule(this)

                 @Inject
                 lateinit var analyticsAdapter: AnalyticsAdapter

                 @Before
                 fun init() {
                   hiltRule.inject()
                 }

                 @Test
                 fun `happy path`() {
                   // Can already use analyticsAdapter here.
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @HiltAndroidTest
               public final class SettingsActivityTest {

                 @Rule public HiltAndroidRule hiltRule = new HiltAndroidRule(this);

                 @Inject AnalyticsAdapter analyticsAdapter;

                 @Before
                 public void init() {
                   hiltRule.inject();
                 }

                 @Test
                 public void happyPath() {
                   // Can already use analyticsAdapter here.
                 }
               }

   .. rubric:: Replace a binding
      :name: replace-binding

   If you need to inject a fake or mock instance of a dependency, you
   need to tell Hilt not to use the binding that it used in production
   code and to use a different one instead. To replace a binding, you
   need to replace the module that contains the binding with a test
   module that contains the bindings that you want to use in the test.

   For example, suppose your production code declares a binding for
   ``AnalyticsService`` as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Module
               @InstallIn(SingletonComponent::class)
               abstract class AnalyticsModule {

                 @Singleton
                 @Binds
                 abstract fun bindAnalyticsService(
                   analyticsServiceImpl: AnalyticsServiceImpl
                 ): AnalyticsService
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Module
               @InstallIn(SingletonComponent.class)
               public abstract class AnalyticsModule {

                 @Singleton
                 @Binds
                 public abstract AnalyticsService bindAnalyticsService(
                   AnalyticsServiceImpl analyticsServiceImpl
                 );
               }

   To replace the ``AnalyticsService`` binding in tests, create a new
   Hilt module in the ``test`` or ``androidTest`` folder with the fake
   dependency and annotate it with ``@TestInstallIn``. All the tests in
   that folder are injected with the fake dependency instead.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Module
               @TestInstallIn(
                   components = [SingletonComponent::class],
                   replaces = [AnalyticsModule::class]
               )
               abstract class FakeAnalyticsModule {

                 @Singleton
                 @Binds
                 abstract fun bindAnalyticsService(
                   fakeAnalyticsService: FakeAnalyticsService
                 ): AnalyticsService
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Module
               @TestInstallIn(
                   components = SingletonComponent.class,
                   replaces = AnalyticsModule.class
               )
               public abstract class FakeAnalyticsModule {

                 @Singleton
                 @Binds
                 public abstract AnalyticsService bindAnalyticsService(
                   FakeAnalyticsService fakeAnalyticsService
                 );
               }

   .. rubric:: Replace a binding in a single test
      :name: replace-binding-manually

   To replace a binding in a single test instead of all tests, uninstall
   a Hilt module from a test using the ``@UninstallModules`` annotation
   and create a new test module inside the test.

   Following the ``AnalyticsService`` example from the previous version,
   begin by telling Hilt to ignore the production module by using the
   ``@UninstallModules`` annotation in the test class:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @UninstallModules(AnalyticsModule::class)
               @HiltAndroidTest
               class SettingsActivityTest { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @UninstallModules(AnalyticsModule.class)
               @HiltAndroidTest
               public final class SettingsActivityTest { ... }

   Next, you must replace the binding. Create a new module within the
   test class that defines the test binding:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @UninstallModules(AnalyticsModule::class)
               @HiltAndroidTest
               class SettingsActivityTest {

                 @Module
                 @InstallIn(SingletonComponent::class)
                 abstract class TestModule {

                   @Singleton
                   @Binds
                   abstract fun bindAnalyticsService(
                     fakeAnalyticsService: FakeAnalyticsService
                   ): AnalyticsService
                 }

                 ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @UninstallModules(AnalyticsModule.class)
               @HiltAndroidTest
               public final class SettingsActivityTest {

                 @Module
                 @InstallIn(SingletonComponent.class)
                 public abstract class TestModule {

                   @Singleton
                   @Binds
                   public abstract AnalyticsService bindAnalyticsService(
                     FakeAnalyticsService fakeAnalyticsService
                   );
                 }
                 ...
               }

   This only replaces the binding for a single test class. If you want
   to replace the binding for all test classes, use the
   ``@TestInstallIn`` annotation from the section above. Alternatively,
   you can put the test binding in the ``test`` module for Robolectric
   tests, or in the ``androidTest`` module for instrumented tests. The
   recommendation is to use ``@TestInstallIn`` whenever possible.

   **Warning:**\  You cannot uninstall modules that are not annotated
   with ``@InstallIn``. Attempting to do so causes a compilation error.
   **Warning:**\  ``@UninstallModules`` can only uninstall
   ``@InstallIn`` modules, not ``@TestInstallIn`` modules. Attempting to
   do so causes a compilation error.
   **Note:**\  As Hilt creates new components for tests that use
   ``@UninstallModules``, it can significantly impact unit test build
   times. Use it when necessary and prefer using ``@TestInstallIn`` when
   the bindings need to be replaced in all test classes.

   .. rubric:: Binding new values
      :name: binding-new

   Use the ``@BindValue`` annotation to easily bind fields in your test
   into the Hilt dependency graph. Annotate a field with ``@BindValue``
   and it will be bound under the declared field type with any
   qualifiers that are present for that field.

   In the ``AnalyticsService`` example, you can replace
   ``AnalyticsService`` with a fake by using ``@BindValue``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @UninstallModules(AnalyticsModule::class)
               @HiltAndroidTest
               class SettingsActivityTest {

                 @BindValue @JvmField
                 val analyticsService: AnalyticsService = FakeAnalyticsService()

                 ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @UninstallModules(AnalyticsModule.class)
               @HiltAndroidTest
               class SettingsActivityTest {

                 @BindValue AnalyticsService analyticsService = FakeAnalyticsService();

                 ...
               }

   This simplifies both replacing a binding and referencing a binding in
   your test by allowing you to do both at the same time.

   ``@BindValue`` works with qualifiers and other testing annotations.
   For example, if you use testing libraries such as
   `Mockito <https://site.mockito.org/>`__, you could use it in a
   Robolectric test as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               ...
               class SettingsActivityTest {
                 ...

                 @BindValue @ExampleQualifier @Mock
                 lateinit var qualifiedVariable: ExampleCustomType

                 // Robolectric tests here
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ...
               class SettingsActivityTest {
                 ...
                 @BindValue @ExampleQualifier @Mock ExampleCustomType qualifiedVariable;

                 // Robolectric tests here
               }

   If you need to add a
   `multibinding <https://dagger.dev/dev-guide/multibindings>`__, you
   can use the ``@BindValueIntoSet`` and ``@BindValueIntoMap``
   annotations in place of ``@BindValue``. ``@BindValueIntoMap``
   requires you to also annotate the field with a map key annotation.

   .. rubric:: Special cases
      :name: special-cases

   Hilt also provides features to support nonstandard use cases.

   .. rubric:: Custom application for tests
      :name: custom-application

   If you cannot use ``HiltTestApplication`` because your test
   application needs to extend another application, annotate a new class
   or interface with ``@CustomTestApplication``, passing in the value of
   the base class you want the generated Hilt application to extend.

   ``@CustomTestApplication`` will generate an ``Application`` class
   ready for testing with Hilt that extends the application you passed
   as a parameter.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @CustomTestApplication(BaseApplication::class)
               interface HiltTestApplication

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @CustomTestApplication(BaseApplication.class)
               interface HiltTestApplication { }

   In the example, Hilt generates an ``Application`` named
   ``HiltTestApplication_Application`` that extends the
   ``BaseApplication`` class. In general, the name of the generated
   application is the name of the annotated class appended with
   ``_Application``. You must set the generated Hilt test application to
   run in your `instrumented tests <#>`__ or
   `Robolectric tests <http://robolectric.org/>`__ as described in `Test application <#test-application>`__.

   **Note:**\  Because ``HiltTestApplication_Application`` is code that
   Hilt generates at runtime, the IDE might highlight it in red until
   you run your tests.

   .. rubric:: Multiple TestRule objects in your instrumented test
      :name: multiple-testrules

   If you have other ``TestRule`` objects in your test, there are
   multiple ways to ensure that all of the rules work together.

   You can wrap the rules together as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @HiltAndroidTest
               class SettingsActivityTest {

                 @get:Rule
                 var rule = RuleChain.outerRule(HiltAndroidRule(this)).
                       around(SettingsActivityTestRule(...))

                 // UI tests here.
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @HiltAndroidTest
               public final class SettingsActivityTest {

                 @Rule public RuleChain rule = RuleChain.outerRule(new HiltAndroidRule(this))
                       .around(new SettingsActivityTestRule(...));

                 // UI tests here.
               }

   Alternatively, you can use both rules at the same level as long as
   the ``HiltAndroidRule`` executes first. Specify the execution order
   using the ``order`` attribute in the ``@Rule`` annotation. This only
   works in JUnit version 4.13 or higher:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @HiltAndroidTest
               class SettingsActivityTest {

                 @get:Rule(order = 0)
                 var hiltRule = HiltAndroidRule(this)

                 @get:Rule(order = 1)
                 var settingsActivityTestRule = SettingsActivityTestRule(...)

                 // UI tests here.
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @HiltAndroidTest
               public final class SettingsActivityTest {

                 @Rule(order = 0)
                 public HiltAndroidRule hiltRule = new HiltAndroidRule(this);

                 @Rule(order = 1)
                 public SettingsActivityTestRule settingsActivityTestRule = new SettingsActivityTestRule(...);

                 // UI tests here.
               }

   .. rubric:: launchFragmentInContainer
      :name: launchfragment

   It is not possible to use ``launchFragmentInContainer`` from the
   ``androidx.fragment:fragment-testing`` library with Hilt, because it
   relies on an activity that is not annotated with
   ``@AndroidEntryPoint``.

   Use the
   `launchFragmentInHiltContainer <https://github.com/android/architecture-samples/blob/views-hilt/app/src/androidTest/java/com/example/android/architecture/blueprints/todoapp/HiltExt.kt#L37>`__
   code from the
   `architecture-samples <https://github.com/android/architecture-samples>`__
   GitHub repository instead.

   .. rubric:: Use an entry point before the singleton component is
      available
      :name: early-entry-point

   The ``@EarlyEntryPoint`` annotation provides an escape hatch when a
   Hilt entry point needs to be created before the singleton component
   is available in a Hilt test.

   More information about ``@EarlyEntryPoint`` in the `Hilt documentation <https://dagger.dev/hilt/early-entry-point>`__.


Last updated 2024-05-03 UTC.


/Hilt and Dagger annotations cheat sheet
========================================

.. container:: devsite-article-body clearfix

   This cheat sheet allows you to quickly see *what* the different Hilt
   and Dagger annotations do and *how* to use them. The cheat sheet is
   also `downloadable in PDF format <#>`__.

   |Useful Dagger and Hilt annotations|


Last updated 2024-01-03 UTC.

.. |Useful Dagger and Hilt annotations| image:: https://developer.android.google.cn/static/images/training/dependency-injection/hilt-cheatsheet.png
   :width: 700px
   :target: https://developer.android.google.cn/static/images/training/dependency-injection/hilt-cheatsheet.png


/Dagger basics
==============

.. container:: devsite-article-body clearfix

   Manual dependency injection or service locators in an Android app can
   be problematic depending on the size of your project. You can limit
   your project's complexity as it scales up by using
   `Dagger <https://dagger.dev/>`__ to manage dependencies.

   Dagger automatically generates code that mimics the code you would
   otherwise have hand-written. Because the code is generated at compile
   time, it's traceable and more performant than other reflection-based
   solutions such as
   `Guice <https://en.wikipedia.org/wiki/Google_Guice>`__.

   **Note:**\  Use
   `Hilt <#>`__ for dependency
   injection on Android. Hilt is built on top of Dagger and it provides
   a standard way to incorporate Dagger dependency injection into an
   Android application.

   .. rubric:: Benefits of using Dagger
      :name: benefits

   Dagger frees you from writing tedious and error-prone boilerplate
   code by:

   -  Generating the ``AppContainer`` code (application graph) that you
      manually implemented in the manual DI section.

   -  Creating factories for the classes available in the application
      graph. This is how dependencies are satisfied internally.

   -  Deciding whether to reuse a dependency or create a new instance
      through the use of *scopes*.

   -  Creating containers for specific flows as you did with the login
      flow in the previous section using Dagger *subcomponents*. This
      improves your app's performance by releasing objects in memory
      when they're no longer needed.

   Dagger automatically does all of this at build time as long as you
   declare dependencies of a class and specify how to satisfy them using
   annotations. Dagger generates code similar to what you would have
   written manually. Internally, Dagger creates a graph of objects that
   it can reference to find the way to provide an instance of a class.
   For every class in the graph, Dagger generates a
   `factory-type <https://en.wikipedia.org/wiki/Factory_method_pattern>`__
   class that it uses internally to get instances of that type.

   At build time, Dagger walks through your code and:

   -  Builds and validates dependency graphs, ensuring that:

      -  Every object's dependencies can be satisfied, so there are no
         runtime exceptions.
      -  No dependency cycles exist, so there are no infinite loops.

   -  Generates the classes that are used at runtime to create the
      actual objects and their dependencies.

   .. rubric:: A simple use case in Dagger: Generating a factory
      :name: generating-factory

   To demonstrate how you can work with Dagger, let's create a simple
   `factory <https://en.wikipedia.org/wiki/Factory_method_pattern>`__
   for the ``UserRepository`` class shown in the following diagram:

   |image1|

   Define ``UserRepository`` as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class UserRepository(
                   private val localDataSource: UserLocalDataSource,
                   private val remoteDataSource: UserRemoteDataSource
               ) { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class UserRepository {

                   private final UserLocalDataSource userLocalDataSource;
                   private final UserRemoteDataSource userRemoteDataSource;

                   public UserRepository(UserLocalDataSource userLocalDataSource, UserRemoteDataSource userRemoteDataSource) {
                       this.userLocalDataSource = userLocalDataSource;
                       this.userRemoteDataSource = userRemoteDataSource;
                   }

                   ...
               }

   Add an ``@Inject`` annotation to the ``UserRepository`` constructor
   so Dagger knows how to create a ``UserRepository``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // @Inject lets Dagger know how to create instances of this object
               class UserRepository @Inject constructor(
                   private val localDataSource: UserLocalDataSource,
                   private val remoteDataSource: UserRemoteDataSource
               ) { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class UserRepository {

                   private final UserLocalDataSource userLocalDataSource;
                   private final UserRemoteDataSource userRemoteDataSource;

                   // @Inject lets Dagger know how to create instances of this object
                   @Inject
                   public UserRepository(UserLocalDataSource userLocalDataSource, UserRemoteDataSource userRemoteDataSource) {
                       this.userLocalDataSource = userLocalDataSource;
                       this.userRemoteDataSource = userRemoteDataSource;
                   }
               }

   In the above snippet of code, you're telling Dagger:

   #. How to create a ``UserRepository`` instance with the ``@Inject``
      annotated constructor.

   #. What its dependencies are: ``UserLocalDataSource`` and
      ``UserRemoteDataSource``.

   Now Dagger knows how to create an instance of ``UserRepository``, but
   it doesn't know how to create its dependencies. If you annotate the
   other classes too, Dagger knows how to create them:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // @Inject lets Dagger know how to create instances of these objects
               class UserLocalDataSource @Inject constructor() { ... }
               class UserRemoteDataSource @Inject constructor() { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class UserLocalDataSource {
                   @Inject
                   public UserLocalDataSource() { }
               }

               public class UserRemoteDataSource {
                   @Inject
                   public UserRemoteDataSource() { }
               }

   .. rubric:: Dagger components
      :name: dagger-components

   Dagger can create a graph of the dependencies in your project that it
   can use to find out where it should get those dependencies when they
   are needed. To make Dagger do this, you need to create an interface
   and annotate it with ``@Component``. Dagger creates a container as
   you would have done with manual dependency injection.

   Inside the ``@Component`` interface, you can define functions that
   return instances of the classes you need (i.e. ``UserRepository``).
   ``@Component`` tells Dagger to generate a container with all the
   dependencies required to satisfy the types it exposes. This is called
   a *Dagger component*; it contains a graph that consists of the
   objects that Dagger knows how to provide and their respective
   dependencies.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // @Component makes Dagger create a graph of dependencies
               @Component
               interface ApplicationGraph {
                   // The return type  of functions inside the component interface is
                   // what can be provided from the container
                   fun repository(): UserRepository
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // @Component makes Dagger create a graph of dependencies
               @Component
               public interface ApplicationGraph {
                   // The return type  of functions inside the component interface is
                   // what can be consumed from the graph
                   UserRepository userRepository();
               }

   When you build the project, Dagger generates an implementation of the
   ``ApplicationGraph`` interface for you: ``DaggerApplicationGraph``.
   With its annotation processor, Dagger creates a dependency graph that
   consists of the relationships between the three classes
   (``UserRepository``, ``UserLocalDatasource``, and
   ``UserRemoteDataSource``) with only one entry point: getting a
   ``UserRepository`` instance. You can use it as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Create an instance of the application graph
               val applicationGraph: ApplicationGraph = DaggerApplicationGraph.create()
               // Grab an instance of UserRepository from the application graph
               val userRepository: UserRepository = applicationGraph.repository()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create an instance of the application graph
               ApplicationGraph applicationGraph = DaggerApplicationGraph.create();

               // Grab an instance of UserRepository from the application graph
               UserRepository userRepository = applicationGraph.userRepository();

   Dagger creates a new instance of ``UserRepository`` every time it's
   requested.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val applicationGraph: ApplicationGraph = DaggerApplicationGraph.create()

               val userRepository: UserRepository = applicationGraph.repository()
               val userRepository2: UserRepository = applicationGraph.repository()

               assert(userRepository != userRepository2)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ApplicationGraph applicationGraph = DaggerApplicationGraph.create();

               UserRepository userRepository = applicationGraph.userRepository();
               UserRepository userRepository2 = applicationGraph.userRepository();

               assert(userRepository != userRepository2)

   Sometimes, you need to have a unique instance of a dependency in a
   container. You might want this for several reasons:

   #. You want other types that have this type as a dependency to share
      the same instance, such as multiple ``ViewModel`` objects in the
      login flow using the same ``LoginUserData``.

   #. An object is expensive to create and you don't want to create a
      new instance every time it's declared as a dependency (for
      example, a JSON parser).

   In the example, you might want to have a unique instance of
   ``UserRepository`` available in the graph so that every time you ask
   for a ``UserRepository``, you always get the same instance. This is
   useful in your example because in a real-life application with a more
   complex application graph, you might have multiple ``ViewModel``
   objects depending on ``UserRepository`` and you don't want to create
   new instances of ``UserLocalDataSource`` and ``UserRemoteDataSource``
   every time ``UserRepository`` needs to be provided.

   In manual dependency injection, you do this by passing in the same
   instance of ``UserRepository`` to the constructors of the ViewModel
   classes; but in Dagger, because you are not writing that code
   manually, you have to let Dagger know you want to use the same
   instance. This can be done with *scope annotations*.

   .. rubric:: Scoping with Dagger
      :name: dagger-scopes

   You can use scope annotations to limit the lifetime of an object to
   the lifetime of its component. This means that the same instance of a
   dependency is used every time that type needs to be provided.

   To have a unique instance of a ``UserRepository`` when you ask for
   the repository in ``ApplicationGraph``, use the same scope annotation
   for the ``@Component`` interface and ``UserRepository``. You can use
   the ``@Singleton`` annotation that already comes with the
   ``javax.inject`` package that Dagger uses:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Scope annotations on a @Component interface informs Dagger that classes annotated
               // with this annotation (i.e. @Singleton) are bound to the life of the graph and so
               // the same instance of that type is provided every time the type is requested.
               @Singleton
               @Component
               interface ApplicationGraph {
                   fun repository(): UserRepository
               }

               // Scope this class to a component using @Singleton scope (i.e. ApplicationGraph)
               @Singleton
               class UserRepository @Inject constructor(
                   private val localDataSource: UserLocalDataSource,
                   private val remoteDataSource: UserRemoteDataSource
               ) { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Scope annotations on a @Component interface informs Dagger that classes annotated
               // with this annotation (i.e. @Singleton) are scoped to the graph and the same
               // instance of that type is provided every time the type is requested.
               @Singleton
               @Component
               public interface ApplicationGraph {
                   UserRepository userRepository();
               }

               // Scope this class to a component using @Singleton scope (i.e. ApplicationGraph)
               @Singleton
               public class UserRepository {

                   private final UserLocalDataSource userLocalDataSource;
                   private final UserRemoteDataSource userRemoteDataSource;

                   @Inject
                   public UserRepository(UserLocalDataSource userLocalDataSource, UserRemoteDataSource userRemoteDataSource) {
                       this.userLocalDataSource = userLocalDataSource;
                       this.userRemoteDataSource = userRemoteDataSource;
                   }
               }

   Alternatively, you can create and use a custom scope annotation. You
   can create a scope annotation as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Creates MyCustomScope
               @Scope
               @MustBeDocumented
               @Retention(value = AnnotationRetention.RUNTIME)
               annotation class MyCustomScope

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Creates MyCustomScope
               @Scope
               @Retention(RetentionPolicy.RUNTIME)
               public @interface MyCustomScope {}

   Then, you can use it as before:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @MyCustomScope
               @Component
               interface ApplicationGraph {
                   fun repository(): UserRepository
               }

               @MyCustomScope
               class UserRepository @Inject constructor(
                   private val localDataSource: UserLocalDataSource,
                   private val service: UserService
               ) { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @MyCustomScope
               @Component
               public interface ApplicationGraph {
                   UserRepository userRepository();
               }

               @MyCustomScope
               public class UserRepository {

                   private final UserLocalDataSource userLocalDataSource;
                   private final UserRemoteDataSource userRemoteDataSource;

                   @Inject
                   public UserRepository(UserLocalDataSource userLocalDataSource, UserRemoteDataSource userRemoteDataSource) {
                       this.userLocalDataSource = userLocalDataSource;
                       this.userRemoteDataSource = userRemoteDataSource;
                   }
               }

   In both cases, the object is provided with the same scope used to
   annotate the ``@Component`` interface. Thus, every time you call
   ``applicationGraph.repository()``, you get the same instance of
   ``UserRepository``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val applicationGraph: ApplicationGraph = DaggerApplicationGraph.create()

               val userRepository: UserRepository = applicationGraph.repository()
               val userRepository2: UserRepository = applicationGraph.repository()

               assert(userRepository == userRepository2)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ApplicationGraph applicationGraph = DaggerApplicationGraph.create();

               UserRepository userRepository = applicationGraph.userRepository();
               UserRepository userRepository2 = applicationGraph.userRepository();

               assert(userRepository == userRepository2)

   .. rubric:: Conclusion
      :name: conclusion

   It is important to be aware of Dagger's benefits and the basics of
   how it works before you can use it in more complicated scenarios.

   In the `next page <#>`__,
   you'll learn how to add Dagger to an Android application.


Last updated 2024-01-03 UTC.

.. |image1| image:: https://developer.android.google.cn/static/images/training/dependency-injection/3-factory-diagram.png
   :width: 600px


/Using Dagger in Android apps
=============================

.. container:: devsite-article-body clearfix

   The `Dagger basics <#>`__
   page explained how Dagger can help you automate dependency injection
   in your app. With Dagger, you don't have to write tedious and
   error-prone boilerplate code.

   **Note:**\  Use
   `Hilt <#>`__ for dependency
   injection on Android. Hilt is built on top of Dagger and it provides
   a standard way to incorporate Dagger dependency injection into an
   Android application.

   .. rubric:: Best practices summary
      :name: best-practices

   **Note:**\  If you're already familiar with Dagger, check out these
   best practices. If not, read the content on this page and come back
   to this later.

   -  Use constructor injection with ``@Inject`` to add types to the
      Dagger graph whenever it's possible. When it's not:

      -  Use ``@Binds`` to tell Dagger which implementation an interface
         should have.
      -  Use ``@Provides`` to tell Dagger how to provide classes that
         your project doesn't own.

   -  You should only declare modules once in a component.
   -  Name the scope annotations depending on the lifetime where the
      annotation is used. Examples include ``@ApplicationScope``,
      ``@LoggedUserScope``, and ``@ActivityScope``.

   .. rubric:: Adding dependencies
      :name: dependencies

   To use Dagger in your project, add these dependencies to your
   application in your ``build.gradle`` file. You can find the latest
   version of Dagger `in this GitHub project <https://github.com/google/dagger/releases>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               plugins {
                 id 'kotlin-kapt'
               }

               dependencies {
                   implementation 'com.google.dagger:dagger:2.x'
                   kapt 'com.google.dagger:dagger-compiler:2.x'
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               dependencies {
                   implementation 'com.google.dagger:dagger:2.x'
                   annotationProcessor 'com.google.dagger:dagger-compiler:2.x'
               }

   .. rubric:: Dagger in Android
      :name: dagger-in-android

   Consider an example Android app with the dependency graph from Figure
   1.

   .. container::

      |LoginActivity depends on LoginViewModel, which depends on
      UserRepository, which depends on UserLocalDataSource and
      UserRemoteDataSource, which in turn depends on Retrofit.|
      **Figure 1.** Dependency graph of the example code

   In Android, you usually create a Dagger graph that lives in your
   application class because you want an instance of the graph to be in
   memory as long as the app is running. In this way, the graph is
   attached to the app lifecycle. In some cases, you might also want to
   have the application context available in the graph. For that, you
   would also need the graph to be in the
   `Application <#>`__ class. One
   advantage of this approach is that the graph is available to other
   Android framework classes. Additionally, it simplifies testing by
   allowing you to use a custom ``Application`` class in tests.

   Because the interface that generates the graph is annotated with
   ``@Component``, you can call it ``ApplicationComponent`` or
   ``ApplicationGraph``. You usually keep an instance of that component
   in your custom ``Application`` class and call it every time you need
   the application graph, as shown in the following code snippet:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Definition of the Application graph
               @Component
               interface ApplicationComponent { ... }

               // appComponent lives in the Application class to share its lifecycle
               class MyApplication: Application() {
                   // Reference to the application graph that is used across the whole app
                   val appComponent = DaggerApplicationComponent.create()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Definition of the Application graph
               @Component
               public interface ApplicationComponent {
               }

               // appComponent lives in the Application class to share its lifecycle
               public class MyApplication extends Application {

                   // Reference to the application graph that is used across the whole app
                   ApplicationComponent appComponent = DaggerApplicationComponent.create();
               }

   Because certain Android framework classes such as activities and
   fragments are instantiated by the system, Dagger can't create them
   for you. For activities specifically, any initialization code needs
   to go into the ``onCreate()`` method. That means you cannot use the
   ``@Inject`` annotation in the constructor of the class (constructor
   injection) as you did in the previous examples. Instead, you have to
   use field injection.

   **Note:**\  The `Dagger basics <#>`__ page covers
   how to use the Dagger ``@Inject`` annotation in constructors. This
   annotation tells Dagger how to create instances of a class.
   Instead of creating the dependencies an activity requires in the
   ``onCreate()`` method, you want Dagger to populate those dependencies
   for you. For field injection, you instead apply the ``@Inject``
   annotation to the fields that you want to get from the Dagger graph.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class LoginActivity: Activity() {
                   // You want Dagger to provide an instance of LoginViewModel from the graph
                   @Inject lateinit var loginViewModel: LoginViewModel
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class LoginActivity extends Activity {

                   // You want Dagger to provide an instance of LoginViewModel from the graph
                   @Inject
                   LoginViewModel loginViewModel;
               }

   For simplicity, ``LoginViewModel`` is not an `Android Architecture Components ViewModel <https://developer.android.google.cn/topic/libraries/architecture/viewmodel>`__;
   it's just a regular class that acts as a ViewModel. For more
   information about how to inject these classes, check out the code in
   the official `Android Blueprints Dagger implementation <https://github.com/android/architecture-samples/tree/dev-dagger>`__,
   in the
   `dev-dagger <https://github.com/android/architecture-samples/tree/dev-dagger>`__
   branch.

   One of the considerations with Dagger is that injected fields cannot
   be private. They need to have at least package-private visibility
   like in the preceding code.

   **Note:**\  Field injection should only be used in Android framework
   classes where constructor injection cannot be used.

   .. rubric:: Injecting activities
      :name: injecting-activities

   Dagger needs to know that ``LoginActivity`` has to access the graph
   in order to provide the ``ViewModel`` it requires. In the `Dagger basics <#>`__ page, you
   used the ``@Component`` interface to get objects from the graph by
   exposing functions with the return type of what you want to get from
   the graph. In this case, you need to tell Dagger about an object
   (``LoginActivity`` in this case) that requires a dependency to be
   injected. For that, you expose a function that takes as a parameter
   the object that requests injection.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Component
               interface ApplicationComponent {
                   // This tells Dagger that LoginActivity requests injection so the graph needs to
                   // satisfy all the dependencies of the fields that LoginActivity is requesting.
                   fun inject(activity: LoginActivity)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Component
               public interface ApplicationComponent {
                   // This tells Dagger that LoginActivity requests injection so the graph needs to
                   // satisfy all the dependencies of the fields that LoginActivity is injecting.
                   void inject(LoginActivity loginActivity);
               }

   This function tells Dagger that ``LoginActivity`` wants to access the
   graph and requests injection. Dagger needs to satisfy all the
   dependencies that ``LoginActivity`` requires (``LoginViewModel`` with
   its own dependencies). If you have multiple classes that request
   injection, you have to specifically declare them all in the component
   with their exact type. For example, if you had ``LoginActivity`` and
   ``RegistrationActivity`` requesting injection, you'd have two
   ``inject()`` methods instead of a generic one covering both cases. A
   generic ``inject()`` method doesn't tell Dagger what needs to be
   provided. The functions in the interface can have any name, but
   calling them ``inject()`` when they receive the object to inject as a
   parameter is a convention in Dagger.

   To inject an object in the activity, you'd use the ``appComponent``
   defined in your ``Application`` class and call the ``inject()``
   method, passing in an instance of the activity that requests
   injection.

   When using activities, inject Dagger in the activity's ``onCreate()``
   method before calling ``super.onCreate()`` to avoid issues with
   fragment restoration. During the restore phase in
   ``super.onCreate()``, an activity attaches fragments that might want
   to access activity bindings.

   When using fragments, inject Dagger in the fragment's ``onAttach()``
   method. In this case, it can be done before or after calling
   ``super.onAttach()``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class LoginActivity: Activity() {
                   // You want Dagger to provide an instance of LoginViewModel from the graph
                   @Inject lateinit var loginViewModel: LoginViewModel

                   override fun onCreate(savedInstanceState: Bundle?) {
                       // Make Dagger instantiate @Inject fields in LoginActivity
                       (applicationContext as MyApplication).appComponent.inject(this)
                       // Now loginViewModel is available

                       super.onCreate(savedInstanceState)
                   }
               }

               // @Inject tells Dagger how to create instances of LoginViewModel
               class LoginViewModel @Inject constructor(
                   private val userRepository: UserRepository
               ) { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class LoginActivity extends Activity {

                   // You want Dagger to provide an instance of LoginViewModel from the graph
                   @Inject
                   LoginViewModel loginViewModel;

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       // Make Dagger instantiate @Inject fields in LoginActivity
                       ((MyApplication) getApplicationContext()).appComponent.inject(this);
                       // Now loginViewModel is available

                       super.onCreate(savedInstanceState);
                   }
               }

               public class LoginViewModel {

                   private final UserRepository userRepository;

                   // @Inject tells Dagger how to create instances of LoginViewModel
                   @Inject
                   public LoginViewModel(UserRepository userRepository) {
                       this.userRepository = userRepository;
                   }
               }

   Let's tell Dagger how to provide the rest of the dependencies to
   build the graph:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class UserRepository @Inject constructor(
                   private val localDataSource: UserLocalDataSource,
                   private val remoteDataSource: UserRemoteDataSource
               ) { ... }

               class UserLocalDataSource @Inject constructor() { ... }
               class UserRemoteDataSource @Inject constructor(
                   private val loginService: LoginRetrofitService
               ) { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class UserRepository {

                   private final UserLocalDataSource userLocalDataSource;
                   private final UserRemoteDataSource userRemoteDataSource;

                   @Inject
                   public UserRepository(UserLocalDataSource userLocalDataSource, UserRemoteDataSource userRemoteDataSource) {
                       this.userLocalDataSource = userLocalDataSource;
                       this.userRemoteDataSource = userRemoteDataSource;
                   }
               }

               public class UserLocalDataSource {

                   @Inject
                   public UserLocalDataSource() {}
               }

               public class UserRemoteDataSource {

                   private final LoginRetrofitService loginRetrofitService;

                   @Inject
                   public UserRemoteDataSource(LoginRetrofitService loginRetrofitService) {
                       this.loginRetrofitService = loginRetrofitService;
                   }
               }

   .. rubric:: Dagger modules
      :name: dagger-modules

   For this example, you're using the
   `Retrofit <https://square.github.io/retrofit/>`__ networking library.
   ``UserRemoteDataSource`` has a dependency on
   ``LoginRetrofitService``. However, the way to create an instance of
   ``LoginRetrofitService`` is different from what you've been doing
   until now. It's not a class instantiation; it's the result of calling
   ``Retrofit.Builder()`` and passing in different parameters to
   configure the login service.

   Apart from the ``@Inject`` annotation, there's another way to tell
   Dagger how to provide an instance of a class: the information inside
   Dagger modules. A Dagger module is a class that is annotated with
   ``@Module``. There, you can define dependencies with the
   ``@Provides`` annotation.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // @Module informs Dagger that this class is a Dagger Module
               @Module
               class NetworkModule {

                   // @Provides tell Dagger how to create instances of the type that this function
                   // returns (i.e. LoginRetrofitService).
                   // Function parameters are the dependencies of this type.
                   @Provides
                   fun provideLoginRetrofitService(): LoginRetrofitService {
                       // Whenever Dagger needs to provide an instance of type LoginRetrofitService,
                       // this code (the one inside the @Provides method) is run.
                       return Retrofit.Builder()
                               .baseUrl("https://example.com")
                               .build()
                               .create(LoginService::class.java)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // @Module informs Dagger that this class is a Dagger Module
               @Module
               public class NetworkModule {

                   // @Provides tell Dagger how to create instances of the type that this function
                   // returns (i.e. LoginRetrofitService).
                   // Function parameters are the dependencies of this type.
                   @Provides
                   public LoginRetrofitService provideLoginRetrofitService() {
                       // Whenever Dagger needs to provide an instance of type LoginRetrofitService,
                       // this code (the one inside the @Provides method) is run.
                       return new Retrofit.Builder()
                               .baseUrl("https://example.com")
                               .build()
                               .create(LoginService.class);
                   }
               }

   **Note:**\  You can use the ``@Provides`` annotation in Dagger
   modules to tell Dagger how to provide classes that your project
   doesn't own (e.g. an instance of ``Retrofit``).
   For implementation of interfaces, the best practice is using
   `@Binds <https://dagger.dev/faq.html#binds>`__, as you can see in
   the `Using Dagger in an Android app codelab <https://developers.google.cn/codelabs/codelabs/android-dagger/>`__.
   Modules are a way to semantically encapsulate information on how to
   provide objects. As you can see, you called the class
   ``NetworkModule`` to group the logic of providing objects related to
   networking. If the application expands, you can also add how to
   provide an `OkHttpClient <https://square.github.io/okhttp/>`__
   here, or how to configure `Gson <https://github.com/google/gson>`__
   or `Moshi <https://github.com/square/moshi>`__.

   The dependencies of a ``@Provides`` method are the parameters of that
   method. For the previous method, ``LoginRetrofitService`` can be
   provided with no dependencies because the method has no parameters.
   If you had declared an ``OkHttpClient`` as a parameter, Dagger would
   need to provide an ``OkHttpClient`` instance from the graph to
   satisfy the dependencies of ``LoginRetrofitService``. For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Module
               class NetworkModule {
                   // Hypothetical dependency on LoginRetrofitService
                   @Provides
                   fun provideLoginRetrofitService(
                       okHttpClient: OkHttpClient
                   ): LoginRetrofitService { ... }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Module
               public class NetworkModule {

                   @Provides
                   public LoginRetrofitService provideLoginRetrofitService(OkHttpClient okHttpClient) {
                       ...
                   }
               }

   In order for the Dagger graph to know about this module, you have to
   add it to the ``@Component`` interface as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // The "modules" attribute in the @Component annotation tells Dagger what Modules
               // to include when building the graph
               @Component(modules = [NetworkModule::class])
               interface ApplicationComponent {
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // The "modules" attribute in the @Component annotation tells Dagger what Modules
               // to include when building the graph
               @Component(modules = NetworkModule.class)
               public interface ApplicationComponent {
                   ...
               }

   The recommended way to add types to the Dagger graph is by using
   constructor injection (i.e. with the ``@Inject`` annotation on the
   constructor of the class). Sometimes, this is not possible and you
   have to use Dagger modules. One example is when you want Dagger to
   use the result of a computation to determine how to create an
   instance of an object. Whenever it has to provide an instance of that
   type, Dagger runs the code inside the ``@Provides`` method.

   This is how the Dagger graph in the example looks right now:

   .. container::

      |Diagram of LoginActivity dependency graph|
      **Figure 2.** Representation of the graph with ``LoginActivity``
      being injected by Dagger

   The entry point to the graph is ``LoginActivity``. Because
   ``LoginActivity`` injects ``LoginViewModel``, Dagger builds a graph
   that knows how to provide an instance of ``LoginViewModel``, and
   recursively, of its dependencies. Dagger knows how to do this because
   of the ``@Inject`` annotation on the classes' constructor.

   Inside the ``ApplicationComponent`` generated by Dagger, there's a
   factory-type method to get instances of all the classes it knows how
   to provide. In this example, Dagger delegates to the
   ``NetworkModule`` included in ``ApplicationComponent`` to get an
   instance of ``LoginRetrofitService``.

   .. rubric:: Dagger scopes
      :name: dagger-scopes

   Scopes were mentioned on the `Dagger basics <#>`__ page as a
   way to have a unique instance of a type in a component. This is what
   is meant by *scoping a type to the component's lifecycle*.

   Because you might want to use ``UserRepository`` in other features of
   the app and might not want to create a new object every time you need
   it, you can designate it as a unique instance for the whole app. It
   is the same for ``LoginRetrofitService``: it can be expensive to
   create, and you also want a unique instance of that object to be
   reused. Creating an instance of ``UserRemoteDataSource`` is not that
   expensive, so scoping it to the component's lifecycle is not
   necessary.

   `@Singleton <https://docs.oracle.com/javaee/7/api/javax/inject/Singleton.html>`__
   is the only scope annotation that comes with the ``javax.inject``
   package. You can use it to annotate ``ApplicationComponent`` and the
   objects you want to reuse across the whole application.

   **Note:**\  You can use **any** scope annotation to have a unique
   instance of a type in a component as long as the component and the
   type are annotated with it. ``@Singleton`` comes with the Dagger
   library and is usually used to annotate the application component,
   but you can create a custom one with a different name (e.g.
   ``@ApplicationScope``).

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Singleton
               @Component(modules = [NetworkModule::class])
               interface ApplicationComponent {
                   fun inject(activity: LoginActivity)
               }

               @Singleton
               class UserRepository @Inject constructor(
                   private val localDataSource: UserLocalDataSource,
                   private val remoteDataSource: UserRemoteDataSource
               ) { ... }

               @Module
               class NetworkModule {
                   // Way to scope types inside a Dagger Module
                   @Singleton
                   @Provides
                   fun provideLoginRetrofitService(): LoginRetrofitService { ... }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Singleton
               @Component(modules = NetworkModule.class)
               public interface ApplicationComponent {
                   void inject(LoginActivity loginActivity);
               }

               @Singleton
               public class UserRepository {

                   private final UserLocalDataSource userLocalDataSource;
                   private final UserRemoteDataSource userRemoteDataSource;

                   @Inject
                   public UserRepository(UserLocalDataSource userLocalDataSource, UserRemoteDataSource userRemoteDataSource) {
                       this.userLocalDataSource = userLocalDataSource;
                       this.userRemoteDataSource = userRemoteDataSource;
                   }
               }

               @Module
               public class NetworkModule {

                   @Singleton
                   @Provides
                   public LoginRetrofitService provideLoginRetrofitService() { ... }
               }

   **Caution:**\  Modules that use a scope annotation can only be used
   in components that are annotated with the same scope.
   Take care not to introduce memory leaks when applying scopes to
   objects. As long as the scoped component is in memory, the created
   object is in memory too. Because ``ApplicationComponent`` is created
   when the app is launched (in the ``Application`` class), it is
   destroyed when the app gets destroyed. Thus, the unique instance of
   ``UserRepository`` always remains in memory until the application is
   destroyed.

   **Note:**\  Add scope annotations in classes when using constructor
   injection (with ``@Inject``) and add them in ``@Provides`` methods
   when using Dagger modules.

   .. rubric:: Dagger subcomponents
      :name: dagger-subcomponents

   If your login flow (managed by a single ``LoginActivity``) consists
   of multiple fragments, you should reuse the same instance of
   ``LoginViewModel`` in all fragments. ``@Singleton`` cannot annotate
   ``LoginViewModel`` to reuse the instance for the following reasons:

   #. The instance of ``LoginViewModel`` would persist in memory after
      the flow has finished.

   #. You want a different instance of ``LoginViewModel`` for each login
      flow. For example, if the user logs out, you want a different
      instance of ``LoginViewModel``, rather than the same instance as
      when the user logged in for the first time.

   To scope ``LoginViewModel`` to the lifecycle of ``LoginActivity`` you
   need to create a new component (a new subgraph) for the login flow
   and a new scope.

   Let's create a graph specific to the login flow.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Component
               interface LoginComponent {}

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Component
               public interface LoginComponent {
               }

   Now, ``LoginActivity`` should get injections from ``LoginComponent``
   because it has a login-specific configuration. This removes the
   responsibility to inject ``LoginActivity`` from the
   ``ApplicationComponent`` class.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Component
               interface LoginComponent {
                   fun inject(activity: LoginActivity)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Component
               public interface LoginComponent {
                   void inject(LoginActivity loginActivity);
               }

   ``LoginComponent`` must be able to access the objects from
   ``ApplicationComponent`` because ``LoginViewModel`` depends on
   ``UserRepository``. The way to tell Dagger that you want a new
   component to use part of another component is with *Dagger
   subcomponents*. The new component must be a subcomponent of the
   component containing shared resources.

   *Subcomponents* are components that inherit and extend the object
   graph of a parent component. Thus, all objects provided in the parent
   component are provided in the subcomponent too. In this way, an
   object from a subcomponent can depend on an object provided by the
   parent component.

   To create instances of subcomponents, you need an instance of the
   parent component. Therefore, the objects provided by the parent
   component to the subcomponent are still scoped to the parent
   component.

   In the example, you must define ``LoginComponent`` as a subcomponent
   of ``ApplicationComponent``. To do this, annotate ``LoginComponent``
   with ``@Subcomponent``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // @Subcomponent annotation informs Dagger this interface is a Dagger Subcomponent
               @Subcomponent
               interface LoginComponent {

                   // This tells Dagger that LoginActivity requests injection from LoginComponent
                   // so that this subcomponent graph needs to satisfy all the dependencies of the
                   // fields that LoginActivity is injecting
                   fun inject(loginActivity: LoginActivity)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // @Subcomponent annotation informs Dagger this interface is a Dagger Subcomponent
               @Subcomponent
               public interface LoginComponent {

                   // This tells Dagger that LoginActivity requests injection from LoginComponent
                   // so that this subcomponent graph needs to satisfy all the dependencies of the
                   // fields that LoginActivity is injecting
                   void inject(LoginActivity loginActivity);
               }

   You also must define a subcomponent factory inside ``LoginComponent``
   so that ``ApplicationComponent`` knows how to create instances of
   ``LoginComponent``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Subcomponent
               interface LoginComponent {

                   // Factory that is used to create instances of this subcomponent
                   @Subcomponent.Factory
                   interface Factory {
                       fun create(): LoginComponent
                   }

                   fun inject(loginActivity: LoginActivity)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Subcomponent
               public interface LoginComponent {

                   // Factory that is used to create instances of this subcomponent
                   @Subcomponent.Factory
                   interface Factory {
                       LoginComponent create();
                   }

                   void inject(LoginActivity loginActivity);
               }

   To tell Dagger that ``LoginComponent`` is a subcomponent of
   ``ApplicationComponent``, you have to indicate it by:

   #. Creating a new Dagger module (e.g. ``SubcomponentsModule``)
      passing the subcomponent's class to the ``subcomponents``
      attribute of the annotation.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  // The "subcomponents" attribute in the @Module annotation tells Dagger what
                  // Subcomponents are children of the Component this module is included in.
                  @Module(subcomponents = LoginComponent::class)
                  class SubcomponentsModule {}

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  // The "subcomponents" attribute in the @Module annotation tells Dagger what
                  // Subcomponents are children of the Component this module is included in.
                  @Module(subcomponents = LoginComponent.class)
                  public class SubcomponentsModule {
                  }

   #. Adding the new module (i.e. ``SubcomponentsModule``) to
      ``ApplicationComponent``:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  // Including SubcomponentsModule, tell ApplicationComponent that
                  // LoginComponent is its subcomponent.
                  @Singleton
                  @Component(modules = [NetworkModule::class, SubcomponentsModule::class])
                  interface ApplicationComponent {
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  // Including SubcomponentsModule, tell ApplicationComponent that
                  // LoginComponent is its subcomponent.
                  @Singleton
                  @Component(modules = {NetworkModule.class, SubcomponentsModule.class})
                  public interface ApplicationComponent {
                  }

      Note that ``ApplicationComponent`` doesn't need to inject
      ``LoginActivity`` anymore because that responsibility now belongs
      to ``LoginComponent``, so you can remove the ``inject()`` method
      from ``ApplicationComponent``.

      Consumers of ``ApplicationComponent`` need to know how to create
      instances of ``LoginComponent``. The parent component must add a
      method in its interface to let consumers create instances of the
      subcomponent out of an instance of the parent component:

   #. Expose the factory that creates instances of
      ``LoginComponent``\ in the interface:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  @Singleton
                  @Component(modules = [NetworkModule::class, SubcomponentsModule::class])
                  interface ApplicationComponent {
                  // This function exposes the LoginComponent Factory out of the graph so consumers
                  // can use it to obtain new instances of LoginComponent
                  fun loginComponent(): LoginComponent.Factory
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  @Singleton
                  @Component(modules = { NetworkModule.class, SubcomponentsModule.class} )
                  public interface ApplicationComponent {
                  // This function exposes the LoginComponent Factory out of the graph so consumers
                  // can use it to obtain new instances of LoginComponent
                  LoginComponent.Factory loginComponent();
                  }

   .. rubric:: Assigning scopes to subcomponents
      :name: subcomponent-scopes

   If you build the project, you can create instances of both
   ``ApplicationComponent`` and ``LoginComponent``.
   ``ApplicationComponent`` is attached to the lifecycle of the
   application because you want to use the same instance of the graph as
   long as the application is in memory.

   What's the lifecycle of ``LoginComponent``? One of the reasons why
   you needed ``LoginComponent`` is because you needed to share the same
   instance of the ``LoginViewModel`` between Login-related fragments.
   But also, you want different instances of ``LoginViewModel`` whenever
   there's a new login flow. ``LoginActivity`` is the right lifetime for
   ``LoginComponent``: for every new activity, you need a new instance
   of ``LoginComponent`` and fragments that can use that instance of
   ``LoginComponent``.

   Because ``LoginComponent`` is attached to the ``LoginActivity``
   lifecycle, you have to keep a reference to the component in the
   activity in the same way you kept the reference to the
   ``applicationComponent`` in the ``Application`` class. That way,
   fragments can access it.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class LoginActivity: Activity() {
                   // Reference to the Login graph
                   lateinit var loginComponent: LoginComponent
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class LoginActivity extends Activity {

                   // Reference to the Login graph
                   LoginComponent loginComponent;

                   ...
               }

   Notice that the variable ``loginComponent`` is not annotated with
   ``@Inject`` because you're not expecting that variable to be provided
   by Dagger.

   You can use the ``ApplicationComponent`` to get a reference to
   ``LoginComponent`` and then inject ``LoginActivity`` as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class LoginActivity: Activity() {
                   // Reference to the Login graph
                   lateinit var loginComponent: LoginComponent

                   // Fields that need to be injected by the login graph
                   @Inject lateinit var loginViewModel: LoginViewModel

                   override fun onCreate(savedInstanceState: Bundle?) {
                       // Creation of the login graph using the application graph
                       loginComponent = (applicationContext as MyDaggerApplication)
                                           .appComponent.loginComponent().create()

                       // Make Dagger instantiate @Inject fields in LoginActivity
                       loginComponent.inject(this)

                       // Now loginViewModel is available

                       super.onCreate(savedInstanceState)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class LoginActivity extends Activity {

                   // Reference to the Login graph
                   LoginComponent loginComponent;

                   // Fields that need to be injected by the login graph
                   @Inject
                   LoginViewModel loginViewModel;

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       // Creation of the login graph using the application graph
                       loginComponent = ((MyApplication) getApplicationContext())
                                               .appComponent.loginComponent().create();

                       // Make Dagger instantiate @Inject fields in LoginActivity
                       loginComponent.inject(this);

                       // Now loginViewModel is available

                       super.onCreate(savedInstanceState);
                   }
               }

   ``LoginComponent`` is created in the activity's ``onCreate()``
   method, and it'll get implicitly destroyed when the activity gets
   destroyed.

   The ``LoginComponent`` must always provide the same instance of
   ``LoginViewModel`` each time it's requested. You can ensure this by
   creating a custom annotation scope and annotating both
   ``LoginComponent`` and ``LoginViewModel`` with it. Note that you
   cannot use the ``@Singleton`` annotation because it's already been
   used by the parent component and that'd make the object an
   application singleton (unique instance for the whole app). You need
   to create a different annotation scope.

   **Note:**\  The rules for scoping are as follows:

   -  When a type is marked with a scope annotation, it can only be used
      by components that are annotated with the same scope.
   -  When a component is marked with a scope annotation, it can only
      provide types with that annotation or types that have no
      annotation.
   -  A subcomponent cannot use a scope annotation used by one of its
      parent components.

   Components also involve subcomponents in this context.
   In this case, you could have called this scope ``@LoginScope`` but
   it's not a good practice. The scope annotation's name should not be
   explicit to the purpose it fulfills. Instead, it should be named
   depending on its lifetime because annotations can be reused by
   sibling components such as ``RegistrationComponent`` and
   ``SettingsComponent``. That's why you should call it
   ``@ActivityScope`` instead of ``@LoginScope``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Definition of a custom scope called ActivityScope
               @Scope
               @Retention(value = AnnotationRetention.RUNTIME)
               annotation class ActivityScope

               // Classes annotated with @ActivityScope are scoped to the graph and the same
               // instance of that type is provided every time the type is requested.
               @ActivityScope
               @Subcomponent
               interface LoginComponent { ... }

               // A unique instance of LoginViewModel is provided in Components
               // annotated with @ActivityScope
               @ActivityScope
               class LoginViewModel @Inject constructor(
                   private val userRepository: UserRepository
               ) { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Definition of a custom scope called ActivityScope
               @Scope
               @Retention(RetentionPolicy.RUNTIME)
               public @interface ActivityScope {}

               // Classes annotated with @ActivityScope are scoped to the graph and the same
               // instance of that type is provided every time the type is requested.
               @ActivityScope
               @Subcomponent
               public interface LoginComponent { ... }

               // A unique instance of LoginViewModel is provided in Components
               // annotated with @ActivityScope
               @ActivityScope
               public class LoginViewModel {

                   private final UserRepository userRepository;

                   @Inject
                   public LoginViewModel(UserRepository userRepository) {
                       this.userRepository = userRepository;
                   }
               }

   Now, if you had two fragments that need ``LoginViewModel``, both of
   them are provided with the same instance. For example, if you have a
   ``LoginUsernameFragment`` and a ``LoginPasswordFragment`` they need
   to get injected by the ``LoginComponent``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @ActivityScope
               @Subcomponent
               interface LoginComponent {

                   @Subcomponent.Factory
                   interface Factory {
                       fun create(): LoginComponent
                   }

                   // All LoginActivity, LoginUsernameFragment and LoginPasswordFragment
                   // request injection from LoginComponent. The graph needs to satisfy
                   // all the dependencies of the fields those classes are injecting
                   fun inject(loginActivity: LoginActivity)
                   fun inject(usernameFragment: LoginUsernameFragment)
                   fun inject(passwordFragment: LoginPasswordFragment)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @ActivityScope
               @Subcomponent
               public interface LoginComponent {

                   @Subcomponent.Factory
                   interface Factory {
                       LoginComponent create();
                   }

                   // All LoginActivity, LoginUsernameFragment and LoginPasswordFragment
                   // request injection from LoginComponent. The graph needs to satisfy
                   // all the dependencies of the fields those classes are injecting
                   void inject(LoginActivity loginActivity);
                   void inject(LoginUsernameFragment loginUsernameFragment);
                   void inject(LoginPasswordFragment loginPasswordFragment);
               }

   The components access the instance of the component that lives in the
   ``LoginActivity`` object. Example code for ``LoginUserNameFragment``
   appears in the following code snippet:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class LoginUsernameFragment: Fragment() {

                   // Fields that need to be injected by the login graph
                   @Inject lateinit var loginViewModel: LoginViewModel

                   override fun onAttach(context: Context) {
                       super.onAttach(context)

                       // Obtaining the login graph from LoginActivity and instantiate
                       // the @Inject fields with objects from the graph
                       (activity as LoginActivity).loginComponent.inject(this)

                       // Now you can access loginViewModel here and onCreateView too
                       // (shared instance with the Activity and the other Fragment)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class LoginUsernameFragment extends Fragment {

                   // Fields that need to be injected by the login graph
                   @Inject
                   LoginViewModel loginViewModel;

                   @Override
                   public void onAttach(Context context) {
                       super.onAttach(context);

                       // Obtaining the login graph from LoginActivity and instantiate
                       // the @Inject fields with objects from the graph
                       ((LoginActivity) getActivity()).loginComponent.inject(this);

                       // Now you can access loginViewModel here and onCreateView too
                       // (shared instance with the Activity and the other Fragment)
                   }
               }

   And the same for ``LoginPasswordFragment``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class LoginPasswordFragment: Fragment() {

                   // Fields that need to be injected by the login graph
                   @Inject lateinit var loginViewModel: LoginViewModel

                   override fun onAttach(context: Context) {
                       super.onAttach(context)

                       (activity as LoginActivity).loginComponent.inject(this)

                       // Now you can access loginViewModel here and onCreateView too
                       // (shared instance with the Activity and the other Fragment)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class LoginPasswordFragment extends Fragment {

                   // Fields that need to be injected by the login graph
                   @Inject
                   LoginViewModel loginViewModel;

                   @Override
                   public void onAttach(Context context) {
                       super.onAttach(context);

                       ((LoginActivity) getActivity()).loginComponent.inject(this);

                       // Now you can access loginViewModel here and onCreateView too
                       // (shared instance with the Activity and the other Fragment)
                   }
               }

   Figure 3 shows how the Dagger graph looks with the new subcomponent.
   The classes with a white dot (``UserRepository``,
   ``LoginRetrofitService``, and ``LoginViewModel``) are the ones that
   have a unique instance scoped to their respective components.

   .. container::

      |Application graph after adding the last subcomponent|
      **Figure 3.** Representation of the graph you built for the
      Android app example

   Let's break down the parts of the graph:

   #. The ``NetworkModule`` (and therefore ``LoginRetrofitService``) is
      included in ``ApplicationComponent`` because you specified it in
      the component.

   #. ``UserRepository`` remains in ``ApplicationComponent`` because
      it's scoped to the ``ApplicationComponent``. If the project grows,
      you want to share the same instance across different features
      (e.g. Registration).

      Because ``UserRepository`` is part of ``ApplicationComponent``,
      its dependencies (i.e. ``UserLocalDataSource`` and
      ``UserRemoteDataSource``) need to be in this component too in
      order to be able to provide instances of ``UserRepository``.

   #. ``LoginViewModel`` is included in ``LoginComponent`` because it's
      only required by the classes injected by ``LoginComponent``.
      ``LoginViewModel`` is not included in ``ApplicationComponent``
      because no dependency in ``ApplicationComponent`` needs
      ``LoginViewModel``.

      Similarly, if you hadn't had scoped ``UserRepository`` to
      ``ApplicationComponent``, Dagger would automatically have included
      ``UserRepository`` and its dependencies as part of
      ``LoginComponent`` because that is currently the only place
      ``UserRepository`` is used.

   Apart from scoping objects to a different lifecycle, **creating
   subcomponents is a good practice to encapsulate different parts of
   your application from each other**.

   Structuring your app to create different Dagger subgraphs depending
   on the flow of your app helps towards a **more performant and
   scalable application** in terms of memory and startup time.

   **Note:**\  If you need the container to survive configuration
   changes such as device rotation, follow the `Saving UI States guide <https://developer.android.google.cn/topic/libraries/architecture/saving-states>`__.
   You might want to handle configuration changes the same way you
   handle process termination; otherwise your app might lose state on
   low end devices.

   .. rubric:: Best practices when building a Dagger graph
      :name: best-practices-graph

   When building the Dagger graph for your application:

   -  When you create a component, you should consider what element is
      responsible for the lifetime of that component. In this case, the
      ``Application`` class is in charge of ``ApplicationComponent`` and
      ``LoginActivity`` is in charge of ``LoginComponent``.

   -  Use scoping only when it makes sense. Overusing scoping can have a
      negative effect on your app's runtime performance: the object is
      in memory as long as the component is in memory and getting a
      scoped object is more expensive. When Dagger provides the object,
      it uses ``DoubleCheck`` locking instead of a factory-type
      provider.

   .. rubric:: Testing a project that uses Dagger
      :name: dagger-testing

   One of the benefits of using dependency injection frameworks like
   Dagger is that it makes testing your code easier.

   .. rubric:: Unit tests
      :name: dagger-unit-tests

   You don't have to use Dagger for *unit tests*. When testing a class
   that uses constructor injection, you don't need to use Dagger to
   instantiate that class. You can directly call its constructor passing
   in fake or mock dependencies directly just as you would if they
   weren't annotated.

   For example, when testing ``LoginViewModel``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @ActivityScope
               class LoginViewModel @Inject constructor(
                   private val userRepository: UserRepository
               ) { ... }

               class LoginViewModelTest {

                   @Test
                   fun `Happy path`() {
                       // You don't need Dagger to create an instance of LoginViewModel
                       // You can pass a fake or mock UserRepository
                       val viewModel = LoginViewModel(fakeUserRepository)
                       assertEquals(...)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @ActivityScope
               public class LoginViewModel {

                   private final UserRepository userRepository;

                   @Inject
                   public LoginViewModel(UserRepository userRepository) {
                       this.userRepository = userRepository;
                   }
               }

               public class LoginViewModelTest {

                   @Test
                   public void happyPath() {
                       // You don't need Dagger to create an instance of LoginViewModel
                       // You can pass a fake or mock UserRepository
                       LoginViewModel viewModel = new LoginViewModel(fakeUserRepository);
                       assertEquals(...);
                   }
               }

   .. rubric:: End-to-end tests
      :name: dagger-end-to-end-tests

   For *integration tests*, a good practice is to create a
   ``TestApplicationComponent`` meant for testing. *Production and
   testing use a different component configuration*.

   This requires more up-front `design of the modules <https://dagger.dev/testing.html#organize-modules-for-testability>`__
   in your application. The testing component extends the production
   component and installs a different set of modules.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // TestApplicationComponent extends from ApplicationComponent to have them both
               // with the same interface methods. You need to include the modules of the
               // component here as well, and you can replace the ones you want to override.
               // This sample uses FakeNetworkModule instead of NetworkModule
               @Singleton
               @Component(modules = [FakeNetworkModule::class, SubcomponentsModule::class])
               interface TestApplicationComponent : ApplicationComponent {
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // TestApplicationComponent extends from ApplicationComponent to have them both
               // with the same interface methods. You need to include the modules of the
               // Component here as well, and you can replace the ones you want to override.
               // This sample uses FakeNetworkModule instead of NetworkModule
               @Singleton
               @Component(modules = {FakeNetworkModule.class, SubcomponentsModule.class})
               public interface TestApplicationComponent extends ApplicationComponent {
               }

   ``FakeNetworkModule`` has a fake implementation of the original
   ``NetworkModule``. There you can provide fake instances or mocks of
   whatever you want to replace.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // In the FakeNetworkModule, pass a fake implementation of LoginRetrofitService
               // that you can use in your tests.
               @Module
               class FakeNetworkModule {
                   @Provides
                   fun provideLoginRetrofitService(): LoginRetrofitService {
                       return FakeLoginService()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // In the FakeNetworkModule, pass a fake implementation of LoginRetrofitService
               // that you can use in your tests.
               @Module
               public class FakeNetworkModule {

                   @Provides
                   public LoginRetrofitService provideLoginRetrofitService() {
                       return new FakeLoginService();
                   }
               }

   In your integration or end-to-end tests, you'd use a
   ``TestApplication`` that creates the ``TestApplicationComponent``
   instead of an ``ApplicationComponent``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Your test application needs an instance of the test graph
               class MyTestApplication: MyApplication() {
                   override val appComponent = DaggerTestApplicationComponent.create()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Your test application needs an instance of the test graph
               public class MyTestApplication extends MyApplication {
                   ApplicationComponent appComponent = DaggerTestApplicationComponent.create();
               }

   Then, this test application is used in a custom ``TestRunner`` that
   you'll use to run instrumentation tests. For more information about
   this, check out the `Using Dagger in your Android app codelab <https://developers.google.cn/codelabs/codelabs/android-dagger/>`__.

   .. rubric:: Working with Dagger modules
      :name: working-with-modules

   Dagger modules are a way to encapsulate how to provide objects in a
   semantic way. You can include modules in components but you can also
   include modules inside other modules. This is powerful, but can be
   easily misused.

   Once a module has been added to either a component or another module,
   it's already in the Dagger graph; Dagger can provide those objects in
   that component. Before adding a module, check if that module is part
   of the Dagger graph already by checking if it's already added to the
   component or by compiling the project and seeing if Dagger can find
   the required dependencies for that module.

   Good practice dictates that modules should only be declared once in a
   component (outside of specific advanced Dagger use cases).

   Let's say you have your graph configured in this way.
   ``ApplicationComponent`` includes ``Module1`` and ``Module2`` and
   ``Module1`` includes ``ModuleX``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Component(modules = [Module1::class, Module2::class])
               interface ApplicationComponent { ... }

               @Module(includes = [ModuleX::class])
               class Module1 { ... }

               @Module
               class Module2 { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Component(modules = {Module1.class, Module2.class})
               public interface ApplicationComponent { ... }

               @Module(includes = {ModuleX.class})
               public class Module1 { ... }

               @Module
               public class Module2 { ... }

   If now ``Module2`` depends on classes provided by ``ModuleX``. A
   **bad practice** is including ``ModuleX`` in ``Module2`` because
   ``ModuleX`` is included twice in the graph as seen in the following
   code snippet:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Bad practice: ModuleX is declared multiple times in this Dagger graph
               @Component(modules = [Module1::class, Module2::class])
               interface ApplicationComponent { ... }

               @Module(includes = [ModuleX::class])
               class Module1 { ... }

               @Module(includes = [ModuleX::class])
               class Module2 { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Bad practice: ModuleX is declared multiple times in this Dagger graph.
               @Component(modules = {Module1.class, Module2.class})
               public interface ApplicationComponent { ... }

               @Module(includes = ModuleX.class)
               public class Module1 { ... }

               @Module(includes = ModuleX.class)
               public class Module2 { ... }

   Instead, you should do one of the following:

   A. Refactor the modules and extract the common module out to the
      component.
   B. Create a new module with the objects that both modules share and
      extract it out to the component.

   Not refactoring in this way results in a lot of modules including
   each other without a clear sense of organization and making it more
   difficult to see where each dependency is coming from.

   **Good practice (Option 1)**: ModuleX is declared once in the Dagger
   graph.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Component(modules = [Module1::class, Module2::class, ModuleX::class])
               interface ApplicationComponent { ... }

               @Module
               class Module1 { ... }

               @Module
               class Module2 { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Component(modules = {Module1.class, Module2.class, ModuleX.class})
               public interface ApplicationComponent { ... }

               @Module
               public class Module1 { ... }

               @Module
               public class Module2 { ... }

   **Good practice (Option 2)**: Common dependencies from ``Module1``
   and ``Module2`` in ``ModuleX`` are extracted out to a new module
   named ``ModuleXCommon`` that is included in the component. Then two
   other modules named ``ModuleXWithModule1Dependencies`` and
   ``ModuleXWithModule2Dependencies`` are created with the dependencies
   that are specific to each module. All modules are declared once in
   the Dagger graph.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Component(modules = [Module1::class, Module2::class, ModuleXCommon::class])
               interface ApplicationComponent { ... }

               @Module
               class ModuleXCommon { ... }

               @Module
               class ModuleXWithModule1SpecificDependencies { ... }

               @Module
               class ModuleXWithModule2SpecificDependencies { ... }

               @Module(includes = [ModuleXWithModule1SpecificDependencies::class])
               class Module1 { ... }

               @Module(includes = [ModuleXWithModule2SpecificDependencies::class])
               class Module2 { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Component(modules = {Module1.class, Module2.class, ModuleXCommon.class})
               public interface ApplicationComponent { ... }

               @Module
               public class ModuleXCommon { ... }

               @Module
               public class ModuleXWithModule1SpecificDependencies { ... }

               @Module
               public class ModuleXWithModule2SpecificDependencies { ... }

               @Module(includes = ModuleXWithModule1SpecificDependencies.class)
               public class Module1 { ... }

               @Module(includes = ModuleXWithModule2SpecificDependencies.class)
               public class Module2 { ... }

   .. rubric:: Assisted injection
      :name: assisted-injection

   Assisted injection is a DI pattern that is used to construct an
   object where some parameters may be provided by the DI framework and
   others must be passed in at creation time by the user.

   In Android, this pattern is common in *details* screens where the id
   of the element to show is only known at runtime, not at compile time
   when Dagger generates the DI graph. To learn more about assisted
   injection with Dagger, see the `Dagger documentation <https://dagger.dev/dev-guide/assisted-injection>`__.

   .. rubric:: Conclusion
      :name: conclusion

   If you haven't already, review the `best practices section <#best-practices>`__. To see how to use Dagger in an Android
   app, see the `Using Dagger in an Android app codelab <https://developers.google.cn/codelabs/codelabs/android-dagger/>`__.


Last updated 2024-01-03 UTC.

.. |LoginActivity depends on LoginViewModel, which depends on UserRepository, which depends on UserLocalDataSource and UserRemoteDataSource, which in turn depends on Retrofit.| image:: https://developer.android.google.cn/static/images/training/dependency-injection/4-application-graph.png
.. |Diagram of LoginActivity dependency graph| image:: https://developer.android.google.cn/static/images/training/dependency-injection/4-graph-login.png
.. |Application graph after adding the last subcomponent| image:: https://developer.android.google.cn/static/images/training/dependency-injection/4-graph-subcomponent.png


/Using Dagger in multi-module apps
==================================

.. container:: devsite-article-body clearfix

   **Note:**\  In this page, references to modules refer to Gradle
   modules and not to Dagger modules.
   A project with multiple Gradle modules is known as a multi-module
   project. In a multi-module project that ships as a single APK with no
   feature modules, it's common to have an ``app`` module that can
   depend on most modules of your project and a ``base`` or ``core``
   module that the rest of the modules usually depend on. The ``app``
   module typically contains your
   `Application <#>`__ class,
   whereas the ``base`` module contains all common classes shared across
   all modules in your project.

   The ``app`` module is a good place to declare your application
   component (for example, ``ApplicationComponent`` in the image below)
   that can provide objects that other components might need as well as
   the singletons of your app. As an example, classes like
   ``OkHttpClient``, JSON parsers, accessors for your database, or
   ``SharedPreferences`` objects that may be defined in the ``core``
   module, will be provided by the ``ApplicationComponent`` defined in
   the ``app`` module.

   In the ``app`` module, you could also have other components with
   shorter lifespans. An example could be a ``UserComponent`` with
   user-specific configuration (like a ``UserSession``) after a log in.

   In the different modules of your project, you can define at least one
   subcomponent that has logic specific to that module as seen in figure
   1.

   .. container::

      |image1|
      **Figure 1.** Example of a Dagger graph in a multi-module project

   For example, in a ``login`` module, you could have a
   ``LoginComponent`` scoped with a custom ``@ModuleScope`` annotation
   that can provide objects common to that feature such as a
   ``LoginRepository``. Inside that module, you can also have other
   components that depend on a ``LoginComponent`` with a different
   custom scope, for example ``@FeatureScope`` for a
   ``LoginActivityComponent`` or a ``TermsAndConditionsComponent`` where
   you can scope more feature-specific logic such as ``ViewModel``
   objects.

   For other modules such as ``Registration``, you would have a similar
   setup.

   A general rule for a multi-module project is that modules of the same
   level shouldn't depend on each other. If they do, consider whether
   that shared logic (the dependencies between them) should be part of
   the parent module. If so, refactor to move the classes to the parent
   module; if not, create a new module that extends the parent module
   and have both of the original modules extend the new module.

   As a best practice, you would generally create a component in a
   module in the following cases:

   -  You need to perform field injection, as with
      ``LoginActivityComponent``.

   -  You need to scope objects, as with ``LoginComponent``.

   If neither of these casses apply and you need to tell Dagger how to
   provide objects from that module, create and expose a Dagger module
   with ``@Provides`` or ``@Binds`` methods if construction injection is
   not possible for those classes.

   .. rubric:: Implementation with Dagger subcomponents
      :name: implementation_with_dagger_subcomponents

   The `Using Dagger in Android apps <#dagger-subcomponents>`__
   doc page covers how to create and use subcomponents. However, you
   cannot use the same code because feature modules don't know about the
   ``app`` module. As an example, if you think about a typical Login
   flow and the code we have in the previous page, it doesn't compile
   any more:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class LoginActivity: Activity() {
                 ...

                 override fun onCreate(savedInstanceState: Bundle?) {
                   // Creation of the login graph using the application graph
                   loginComponent = (applicationContext as MyDaggerApplication)
                                       .appComponent.loginComponent().create()

                   // Make Dagger instantiate @Inject fields in LoginActivity
                   loginComponent.inject(this)
                   ...
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class LoginActivity extends Activity {
                   ...

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       // Creation of the login graph using the application graph
                       loginComponent = ((MyApplication) getApplicationContext())
                                               .appComponent.loginComponent().create();

                       // Make Dagger instantiate @Inject fields in LoginActivity
                       loginComponent.inject(this);

                       ...
                   }
               }

   The reason is that the ``login`` module doesn't know about
   ``MyApplication`` nor ``appComponent``. To make it work, you need to
   define an interface in the feature module that provides a
   ``FeatureComponent`` that ``MyApplication`` needs to implement.

   In the following example, you can define a ``LoginComponentProvider``
   interface that provides a ``LoginComponent`` in the ``login`` module
   for the Login flow:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               interface LoginComponentProvider {
                   fun provideLoginComponent(): LoginComponent
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public interface LoginComponentProvider {
                  public LoginComponent provideLoginComponent();
               }

   Now, the ``LoginActivity`` will use that interface instead of the
   snippet of code defined above:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class LoginActivity: Activity() {
                 ...

                 override fun onCreate(savedInstanceState: Bundle?) {
                   loginComponent = (applicationContext as LoginComponentProvider)
                                       .provideLoginComponent()

                   loginComponent.inject(this)
                   ...
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class LoginActivity extends Activity {
                   ...

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       loginComponent = ((LoginComponentProvider) getApplicationContext())
                                               .provideLoginComponent();

                       loginComponent.inject(this);

                       ...
                   }
               }

   Now, ``MyApplication`` needs to implement that interface and
   implement the required methods:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyApplication: Application(), LoginComponentProvider {
                 // Reference to the application graph that is used across the whole app
                 val appComponent = DaggerApplicationComponent.create()

                 override fun provideLoginComponent(): LoginComponent {
                   return appComponent.loginComponent().create()
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyApplication extends Application implements LoginComponentProvider {
                 // Reference to the application graph that is used across the whole app
                 ApplicationComponent appComponent = DaggerApplicationComponent.create();

                 @Override
                 public LoginComponent provideLoginComponent() {
                   return appComponent.loginComponent.create();
                 }
               }

   This is how you can use Dagger subcomponents in a multi-module
   project. With feature modules, the solution is different due to the
   way modules depend on each other.

   .. rubric:: Component dependencies with feature modules
      :name: dagger-dfm

   With `feature modules <#customize_delivery>`__,
   the way modules usually depend on each other is inverted. Instead of
   the ``app`` module including feature modules, the feature modules
   depend on the ``app`` module. See figure 2 for a representation of
   how modules are structured.

   .. container::

      |image2|
      **Figure 2.** Example of a Dagger graph in a project with feature
      modules

   In Dagger, components need to know about their subcomponents. This
   information is included in a Dagger module added to the parent
   component (like the ``SubcomponentsModule`` module in `Using Dagger in Android apps <#dagger-subcomponents>`__).

   Unfortunately, with the reversed dependency between the app and the
   feature module, the subcomponent is not visible from the ``app``
   module because it's not in the build path. As an example, a
   ``LoginComponent`` defined in a ``login`` feature module cannot be a
   subcomponent of the ``ApplicationComponent`` defined in the ``app``
   module.

   Dagger has a mechanism called **component dependencies** that you can
   use to solve this issue. Instead of the child component being a
   subcomponent of the parent component, the child component is
   dependent on the parent component. With that, there is no
   parent-child relationship; now **components** depend on others to get
   certain **dependencies**. Components need to expose types from the
   graph for dependent components to consume them.

   **Note:**\  This issue happens whenever you want to create a
   subcomponent of ``ApplicationComponent``. If you need to create a
   regular gradle module that depends on a feature module and needs to
   create a component that depends on a component defined in that
   feature module, you can use subcomponents as usual.
   For example: a feature module called ``login`` wants to build a
   ``LoginComponent`` that depends on the ``AppComponent`` available in
   the ``app`` Gradle module.

   Below are definitions for the classes and the ``AppComponent`` that
   are part of the ``app`` Gradle module:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // UserRepository's dependencies
               class UserLocalDataSource @Inject constructor() { ... }
               class UserRemoteDataSource @Inject constructor() { ... }

               // UserRepository is scoped to AppComponent
               @Singleton
               class UserRepository @Inject constructor(
                   private val localDataSource: UserLocalDataSource,
                   private val remoteDataSource: UserRemoteDataSource
               ) { ... }

               @Singleton
               @Component
               interface AppComponent { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // UserRepository's dependencies
               public class UserLocalDataSource {

                   @Inject
                   public UserLocalDataSource() {}
               }

               public class UserRemoteDataSource {

                   @Inject
                   public UserRemoteDataSource() { }
               }

               // UserRepository is scoped to AppComponent
               @Singleton
               public class UserRepository {

                   private final UserLocalDataSource userLocalDataSource;
                   private final UserRemoteDataSource userRemoteDataSource;

                   @Inject
                   public UserRepository(UserLocalDataSource userLocalDataSource, UserRemoteDataSource userRemoteDataSource) {
                       this.userLocalDataSource = userLocalDataSource;
                       this.userRemoteDataSource = userRemoteDataSource;
                   }
               }

               @Singleton
               @Component
               public interface ApplicationComponent { ... }

   In your ``login`` gradle module that includes the ``app`` gradle
   module, you have a ``LoginActivity`` that needs a ``LoginViewModel``
   instance to be injected:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // LoginViewModel depends on UserRepository that is scoped to AppComponent
               class LoginViewModel @Inject constructor(
                   private val userRepository: UserRepository
               ) { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // LoginViewModel depends on UserRepository that is scoped to AppComponent
               public class LoginViewModel {

                   private final UserRepository userRepository;

                   @Inject
                   public LoginViewModel(UserRepository userRepository) {
                       this.userRepository = userRepository;
                   }
               }

   ``LoginViewModel`` has a dependency on ``UserRepository`` that is
   available and scoped to ``AppComponent``. Let's create a
   ``LoginComponent`` that depends on ``AppComponent`` to inject
   ``LoginActivity``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Use the dependencies attribute in the Component annotation to specify the
               // dependencies of this Component
               @Component(dependencies = [AppComponent::class])
               interface LoginComponent {
                   fun inject(activity: LoginActivity)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Use the dependencies attribute in the Component annotation to specify the
               // dependencies of this Component
               @Component(dependencies = AppComponent.class)
               public interface LoginComponent {

                   void inject(LoginActivity loginActivity);
               }

   ``LoginComponent`` specifies a dependency on ``AppComponent`` by
   adding it to the dependencies parameter of the component annotation.
   Because ``LoginActivity`` will be injected by Dagger, add the
   ``inject()`` method to the interface.

   **Note:**\  ``LoginComponent`` is annotated with ``@Component`` and
   not with ``@Subcomponent`` as you did in the `Using Dagger in an Android app page <#dagger-subcomponents>`__.
   When creating a ``LoginComponent``, an instance of ``AppComponent``
   needs to be passed in. Use the component factory to do it:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Component(dependencies = [AppComponent::class])
               interface LoginComponent {

                   @Component.Factory
                   interface Factory {
                       // Takes an instance of AppComponent when creating
                       // an instance of LoginComponent
                       fun create(appComponent: AppComponent): LoginComponent
                   }

                   fun inject(activity: LoginActivity)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Component(dependencies = AppComponent.class)
               public interface LoginComponent {

                   @Component.Factory
                   interface Factory {
                       // Takes an instance of AppComponent when creating
                       // an instance of LoginComponent
                       LoginComponent create(AppComponent appComponent);
                   }

                   void inject(LoginActivity loginActivity);
               }

   Now, ``LoginActivity`` can create an instance of ``LoginComponent``
   and call the ``inject()`` method.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class LoginActivity: Activity() {

                   // You want Dagger to provide an instance of LoginViewModel from the Login graph
                   @Inject lateinit var loginViewModel: LoginViewModel

                   override fun onCreate(savedInstanceState: Bundle?) {
                       // Gets appComponent from MyApplication available in the base Gradle module
                       val appComponent = (applicationContext as MyApplication).appComponent

                       // Creates a new instance of LoginComponent
                       // Injects the component to populate the @Inject fields
                       DaggerLoginComponent.factory().create(appComponent).inject(this)

                       super.onCreate(savedInstanceState)

                       // Now you can access loginViewModel
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class LoginActivity extends Activity {

                   // You want Dagger to provide an instance of LoginViewModel from the Login graph
                   @Inject
                   LoginViewModel loginViewModel;

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);

                       // Gets appComponent from MyApplication available in the base Gradle module
                       AppComponent appComponent = ((MyApplication) getApplicationContext()).appComponent;

                       // Creates a new instance of LoginComponent
                       // Injects the component to populate the @Inject fields
                       DaggerLoginComponent.factory().create(appComponent).inject(this);

                       // Now you can access loginViewModel
                   }
               }

   ``LoginViewModel`` depends on ``UserRepository``; and for
   ``LoginComponent`` to be able to access it from ``AppComponent``,
   ``AppComponent`` needs to expose it in its interface:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Singleton
               @Component
               interface AppComponent {
                   fun userRepository(): UserRepository
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Singleton
               @Component
               public interface AppComponent {
                   UserRepository userRepository();
               }

   The scoping rules with dependent components work in the same way as
   with subcomponents. Because ``LoginComponent`` uses an instance of
   ``AppComponent``, they cannot use the same scope annotation.

   If you wanted to scope ``LoginViewModel`` to ``LoginComponent``, you
   would do it as you did previously using the custom ``@ActivityScope``
   annotation.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @ActivityScope
               @Component(dependencies = [AppComponent::class])
               interface LoginComponent { ... }

               @ActivityScope
               class LoginViewModel @Inject constructor(
                   private val userRepository: UserRepository
               ) { ... }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @ActivityScope
               @Component(dependencies = AppComponent.class)
               public interface LoginComponent { ... }

               @ActivityScope
               public class LoginViewModel {

                   private final UserRepository userRepository;

                   @Inject
                   public LoginViewModel(UserRepository userRepository) {
                       this.userRepository = userRepository;
                   }
               }

   **Note:**\  Not exposing all the types that a dependent component
   needs from a component will result in a Dagger compile time error
   because it cannot provide certain types for the dependent component.

   .. rubric:: Best practices
      :name: best-practices

   -  The ``ApplicationComponent`` should always be in the ``app``
      module.

   -  Create Dagger components in modules if you need to perform field
      injection in that module or you need to scope objects for a
      specific flow of your application.

   -  For Gradle modules that are meant to be utilities or helpers and
      don't need to build a graph (that's why you'd need a Dagger
      component), create and expose public Dagger modules with @Provides
      and @Binds methods of those classes that don't support constructor
      injection.

   -  To use Dagger in an Android app with feature modules, use
      component dependencies to be able to access dependencies provided
      by the ``ApplicationComponent`` defined in the ``app`` module.


Last updated 2024-01-03 UTC.

.. |image1| image:: https://developer.android.google.cn/static/images/training/dependency-injection/5-graph-modules.png
.. |image2| image:: https://developer.android.google.cn/static/images/training/dependency-injection/5-graph-dynamic-modules.png


.. _app_startup:

/App Startup - Part of Android Jetpack
======================================

The App Startup library provides a straightforward, performant way to
initialize components at application startup. Both library developers
and app developers can use App Startup to streamline startup sequences
and explicitly set the order of initialization.

Instead of defining separate content providers for each component you
need to initialize, App Startup allows you to define component
initializers that share a single content provider. This can
significantly improve app startup time.

Setup
-----

To use Jetpack Startup in your library or app, add the following to your
Gradle file:

.. container::

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Groovy
            :name: groovy

         .. code:: prettyprint

            dependencies {
                implementation "androidx.startup:startup-runtime:1.1.1"
            }

      .. container:: section

         .. rubric:: Kotlin
            :name: kts

         .. code:: prettyprint

            dependencies {
                implementation("androidx.startup:startup-runtime:1.1.1")
            }

.. _startup-initialize:

Initialize components at app startup
------------------------------------

Apps and libraries often rely on having components initialized right
away when the app starts up. You can meet this need by using content
providers to initialize each dependency, but content providers are
expensive to instantiate and can slow down the startup sequence
unnecessarily. Additionally, Android initializes content providers in an
undetermined order. App Startup provides a more performant way to
initialize components at app startup and explicitly define their
dependencies.

To use App Startup to initialize components automatically at startup,
you must define a component initializer for each component that the app
needs to initialize.

.. _implement-initializers:

Implement component initializers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You define each component initializer by creating a class that
implements the
`Initializer<T> <#>`__
interface. This interface defines two important methods:

-  The ``create()`` method, which contains all of the necessary
   operations to initialize the component and returns an instance of
   ``T``.
-  The ``dependencies()`` method, which returns a list of the other
   ``Initializer<T>`` objects that the initializer depends on. You can
   use this method to control the order in which the app runs the
   initializers at startup.

For example, suppose that your app depends on 
`WorkManager <#>`__ and
needs to initialize it at startup. Define a ``WorkManagerInitializer``
class that implements ``Initializer<WorkManager>``:

.. container::

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            // Initializes WorkManager.
            class WorkManagerInitializer : Initializer<WorkManager> {
                override fun create(context: Context): WorkManager {
                    val configuration = Configuration.Builder().build()
                    WorkManager.initialize(context, configuration)
                    return WorkManager.getInstance(context)
                }
                override fun dependencies(): List<Class<out Initializer<*>>> {
                    // No dependencies on other libraries.
                    return emptyList()
                }
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            // Initializes WorkManager.
            class WorkManagerInitializer implements Initializer<WorkManager> {

                @Override
                public WorkManager create(Context context) {
                    Configuration configuration = Configuration.Builder().build();
                    WorkManager.initialize(context, configuration);
                    return WorkManager.getInstance(context);
                }

                @Override
                public List<Class<Initializer<?>>> dependencies() {
                    // No dependencies on other libraries.
                    return emptyList();
                }

            }

The ``dependencies()`` method returns an empty list because
``WorkManager`` does not depend on any other libraries.

Suppose that your app also depends on a library called 
``ExampleLogger``, which in turn depends on ``WorkManager``. This
dependency means that you need to make sure that App Startup initializes
``WorkManager`` first. Define an ``ExampleLoggerInitializer`` class that
implements ``Initializer<ExampleLogger>``:

.. container::

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            // Initializes ExampleLogger.
            class ExampleLoggerInitializer : Initializer<ExampleLogger> {
                override fun create(context: Context): ExampleLogger {
                    // WorkManager.getInstance() is non-null only after
                    // WorkManager is initialized.
                    return ExampleLogger(WorkManager.getInstance(context))
                }

                override fun dependencies(): List<Class<out Initializer<*>>> {
                    // Defines a dependency on WorkManagerInitializer so it can be
                    // initialized after WorkManager is initialized.
                    return listOf(WorkManagerInitializer::class.java)
                }
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            // Initializes ExampleLogger.
            class ExampleLoggerInitializer implements Initializer<ExampleLogger> {

                @Override
                public ExampleLogger create(Context context) {
                    // WorkManager.getInstance() is non-null only after
                    // WorkManager is initialized.
                    return ExampleLogger(WorkManager.getInstance(context));
                }

                @Override
                public List<Class<Initializer<?>>> dependencies() {
                    // Defines a dependency on WorkManagerInitializer so it can be
                    // initialized after WorkManager is initialized.
                    return Arrays.asList(WorkManagerInitializer.class);
                }
            }

Because you include ``WorkManagerInitializer`` in the ``dependencies()``
method, App Startup initializes ``WorkManager`` before
``ExampleLogger``.

**Note:**\  If you previously used content providers to initialize
components in your app, make sure that you remove those content
providers when you use App Startup.

.. _manifest-entries:

Set up manifest entries
~~~~~~~~~~~~~~~~~~~~~~~

App Startup includes a special content provider called 
``InitializationProvider`` that it uses to discover and call your
component initializers. App Startup discovers component initializers by
first checking for a ``<meta-data>`` entry under the
``InitializationProvider`` manifest entry. Then, App Startup calls the
``dependencies()`` methods for any initializers that it has already
discovered.

This means that in order for a component initializer to be discoverable
by App Startup, one of the following conditions must be met:

-  The component initializer has a corresponding ``<meta-data>`` entry
   under the ``InitializationProvider`` manifest entry.
-  The component initializer is listed in the ``dependencies()`` method
   from an initializer that is already discoverable.

Consider again the example with ``WorkManagerInitializer`` and
``ExampleLoggerInitializer``. To make sure App Startup can discover
these initializers, add the following to the manifest file:

.. code:: prettyprint

   <provider
       android:name="androidx.startup.InitializationProvider"
       android:authorities="${applicationId}.androidx-startup"
       android:exported="false"
       tools:node="merge">
       <!-- This entry makes ExampleLoggerInitializer discoverable. -->
       <meta-data  android:name="com.example.ExampleLoggerInitializer"
             android:value="androidx.startup" />
   </provider>

You don't need to add a ``<meta-data>`` entry for 
``WorkManagerInitializer``, because ``WorkManagerInitializer`` is a
dependency of ``ExampleLoggerInitializer``. This means that if
``ExampleLoggerInitializer`` is discoverable, then so is
``WorkManagerInitializer``.

The ``tools:node="merge"`` attribute ensures that the `manifest merger tool <#merge-manifests>`__ properly
resolves any conflicting entries.

.. _lint-checks:

Run lint checks
~~~~~~~~~~~~~~~

The App Startup library includes a set of lint rules that you can use to
check whether you've defined your component initializers correctly. You
can perform these lint checks by running ``./gradlew :app:lintDebug``
from the command line.

.. _manual:

Manually initialize components
------------------------------

Ordinarily when you use App Startup, the ``InitializationProvider``
object uses an entity called
`AppInitializer <#>`__
to automatically discover and run component initializers at application
startup. However, you can also use ``AppInitializer`` directly in order
to manually initialize components that your app doesn't need at startup.
This is called *lazy initialization*, and it can help minimize startup
costs.

You must first disable automatic initialization for any components that
you want to initialize manually.

.. _disable-individual:

Disable automatic initialization for an individual component
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To disable automatic initialization for a single component, remove the
``<meta-data>`` entry for that component's initializer from the
manifest.

For example, adding the following to the manifest file disables
automatic initialization for ``ExampleLogger``:

.. code:: prettyprint

   <provider
       android:name="androidx.startup.InitializationProvider"
       android:authorities="${applicationId}.androidx-startup"
       android:exported="false"
       tools:node="merge">
       <meta-data android:name="com.example.ExampleLoggerInitializer"
                 tools:node="remove" />
   </provider>

You use ``tools:node="remove"`` in the entry instead of simply removing
the entry in order to make sure that the merger tool also removes the
entry from all other merged manifest files.

**Note:**\  Disabling automatic initialization for a component also
disables automatic initialization for that component's dependencies.

.. _disable-all:

Disable automatic initialization for all components
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To disable all automatic initialization, remove the entire entry for
``InitializationProvider`` from the manifest:

.. code:: prettyprint

   <provider
       android:name="androidx.startup.InitializationProvider"
       android:authorities="${applicationId}.androidx-startup"
       tools:node="remove" />

.. _manual-initialization:

Manually call component initializers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If automatic initialization is disabled for a component, you can use
``AppInitializer`` to manually initialize that component and its
dependencies.

For example, the following code calls ``AppInitializer`` and manually
initializes ``ExampleLogger``:

.. container::

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            AppInitializer.getInstance(context)
                .initializeComponent(ExampleLoggerInitializer::class.java)

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            AppInitializer.getInstance(context)
                .initializeComponent(ExampleLoggerInitializer.class);

As a result, App Startup also initializes ``WorkManager`` because
``WorkManager`` is a dependency of ``ExampleLogger``.

.. _feedback:

Provide feedback
----------------

Share your feedback and ideas with us through these resources:

`Issue tracker <https://issuetracker.google.com/issues/new?component=823348&template=1400167>`__ |image-bug-icon|
   Report issues so we can fix bugs.

.. |image-bug-icon| image:: https://developer.android.google.cn/static/topic/libraries/architecture/images/bug.png

.. _recommended_for_you:

Recommended for you
-------------------

-  Note: link text is displayed when JavaScript is off
-  `App Architecture: Data Layer - Schedule Task with WorkManager - Android Developers <#>`__
-  `App Architecture: Data Layer - DataStore - Android Developers <#>`__


Last updated 2024-01-03 UTC.


.. _top:

/TOC üíõ Android-r15 Dev Guide
============================

::

   url=https://devdoc.net/android/Android-r15/guide/topics/fundamentals.html?hl=en
   curl "$url" | sed -n '/h1/,/Go to top/p' | pandoc -r html -t rst --list-table=true > /pl/out.html ; exit

.. container::
   :name: devdoc-nav

   .. image:: https://devdoc.net/android/Android-r15/assets/images/bg_logo.png
      :alt: Android Developers
      :target: https://devdoc.net/android/Android-r15/offline.html

   -   Android Basics

      -  `What Is Android?  <https://devdoc.net/android/Android-r15/guide/basics/what-is-android.html>`__
      -  `Application Fundamentals <https://devdoc.net/android/Android-r15/guide/topics/fundamentals.html>`__

   -   Framework Topics

      - `Activities <https://devdoc.net/android/Android-r15/guide/topics/fundamentals/activities.html>`__

         -  `Fragments <https://devdoc.net/android/Android-r15/guide/topics/fundamentals/fragments.html>`__
         -  `Loaders <https://devdoc.net/android/Android-r15/guide/topics/fundamentals/loaders.html>`__
         -  `Tasks and Back Stack <https://devdoc.net/android/Android-r15/guide/topics/fundamentals/tasks-and-back-stack.html>`__

      - `Services <https://devdoc.net/android/Android-r15/guide/topics/fundamentals/services.html>`__

         -  `Bound Services <https://devdoc.net/android/Android-r15/guide/topics/fundamentals/bound-services.html>`__

      -  `Content Providers <https://devdoc.net/android/Android-r15/guide/topics/providers/content-providers.html>`__

         -  `Content Provider Basics <https://devdoc.net/android/Android-r15/guide/topics/providers/content-provider-basics.html>`__ new!
         -  `Creating a Content Provider <https://devdoc.net/android/Android-r15/guide/topics/providers/content-provider-creating.html>`__ new!
         -  `Calendar Provider <https://devdoc.net/android/Android-r15/guide/topics/providers/calendar-provider.html>`__ new!

      -  `Intents and Intent Filters <https://devdoc.net/android/Android-r15/guide/topics/intents/intents-filters.html>`__
      -  `Processes and Threads <https://devdoc.net/android/Android-r15/guide/topics/fundamentals/processes-and-threads.html>`__

      -  `User Interface <https://devdoc.net/android/Android-r15/guide/topics/ui/index.html>`__
         -  `XML Layouts <https://devdoc.net/android/Android-r15/guide/topics/ui/declaring-layout.html>`__
         -  `Input Events <https://devdoc.net/android/Android-r15/guide/topics/ui/ui-events.html>`__
         -  `Menus <https://devdoc.net/android/Android-r15/guide/topics/ui/menus.html>`__ updated 
         -  `Action Bar <https://devdoc.net/android/Android-r15/guide/topics/ui/actionbar.html>`__
         -  `Dialogs <https://devdoc.net/android/Android-r15/guide/topics/ui/dialogs.html>`__

         -  `Notifications <https://devdoc.net/android/Android-r15/guide/topics/ui/notifiers/index.html>`__

            -  `Toast Notifications <https://devdoc.net/android/Android-r15/guide/topics/ui/notifiers/toasts.html>`__
            -  `Status Bar Notifications <https://devdoc.net/android/Android-r15/guide/topics/ui/notifiers/notifications.html>`__

         -  `Drag and Drop <https://devdoc.net/android/Android-r15/guide/topics/ui/drag-drop.html>`__
         -  `Styles and Themes <https://devdoc.net/android/Android-r15/guide/topics/ui/themes.html>`__
         -  `Custom Components <https://devdoc.net/android/Android-r15/guide/topics/ui/custom-components.html>`__
         -  `Binding to Data with AdapterView <https://devdoc.net/android/Android-r15/guide/topics/ui/binding.html>`__
         -  `Common Layout Objects <https://devdoc.net/android/Android-r15/guide/topics/ui/layout-objects.html>`__
         -  `How Android Draws Views <https://devdoc.net/android/Android-r15/guide/topics/ui/how-android-draws.html>`__

      -  `Application Resources <https://devdoc.net/android/Android-r15/guide/topics/resources/index.html>`__
         -  `Providing Resources <https://devdoc.net/android/Android-r15/guide/topics/resources/providing-resources.html>`__
         -  `Accessing Resources <https://devdoc.net/android/Android-r15/guide/topics/resources/accessing-resources.html>`__
         -  `Handling Runtime Changes <https://devdoc.net/android/Android-r15/guide/topics/resources/runtime-changes.html>`__
         -  `Localization <https://devdoc.net/android/Android-r15/guide/topics/resources/localization.html>`__
         -  `Resource Types <https://devdoc.net/android/Android-r15/guide/topics/resources/available-resources.html>`__

            -  `Animation <https://devdoc.net/android/Android-r15/guide/topics/resources/animation-resource.html>`__
            -  `Color State List <https://devdoc.net/android/Android-r15/guide/topics/resources/color-list-resource.html>`__
            -  `Drawable <https://devdoc.net/android/Android-r15/guide/topics/resources/drawable-resource.html>`__
            -  `Layout <https://devdoc.net/android/Android-r15/guide/topics/resources/layout-resource.html>`__
            -  `Menu <https://devdoc.net/android/Android-r15/guide/topics/resources/menu-resource.html>`__
            -  `String <https://devdoc.net/android/Android-r15/guide/topics/resources/string-resource.html>`__
            -  `Style <https://devdoc.net/android/Android-r15/guide/topics/resources/style-resource.html>`__
            -  `More Types <https://devdoc.net/android/Android-r15/guide/topics/resources/more-resources.html>`__

      -  `Data Storage <https://devdoc.net/android/Android-r15/guide/topics/data/data-storage.html>`__
         -  `Data Backup <https://devdoc.net/android/Android-r15/guide/topics/data/backup.html>`__

      -  `Security and Permissions <https://devdoc.net/android/Android-r15/guide/topics/security/security.html>`__

      -  `The AndroidManifest.xml File <https://devdoc.net/android/Android-r15/guide/topics/manifest/manifest-intro.html>`__

         -  `<action> <https://devdoc.net/android/Android-r15/guide/topics/manifest/action-element.html>`__
         -  `<activity> <https://devdoc.net/android/Android-r15/guide/topics/manifest/activity-element.html>`__
         -  `<activity-alias> <https://devdoc.net/android/Android-r15/guide/topics/manifest/activity-alias-element.html>`__
         -  `<application> <https://devdoc.net/android/Android-r15/guide/topics/manifest/application-element.html>`__
         -  `<category> <https://devdoc.net/android/Android-r15/guide/topics/manifest/category-element.html>`__
         -  `<compatible-screens> <https://devdoc.net/android/Android-r15/guide/topics/manifest/compatible-screens-element.html>`__
         -  `<data> <https://devdoc.net/android/Android-r15/guide/topics/manifest/data-element.html>`__
         -  `<grant-uri-permission> <https://devdoc.net/android/Android-r15/guide/topics/manifest/grant-uri-permission-element.html>`__
         -  `<instrumentation> <https://devdoc.net/android/Android-r15/guide/topics/manifest/instrumentation-element.html>`__
         -  `<intent-filter> <https://devdoc.net/android/Android-r15/guide/topics/manifest/intent-filter-element.html>`__
         -  `<manifest> <https://devdoc.net/android/Android-r15/guide/topics/manifest/manifest-element.html>`__
         -  `<meta-data> <https://devdoc.net/android/Android-r15/guide/topics/manifest/meta-data-element.html>`__
         -  `<path-permission> <https://devdoc.net/android/Android-r15/guide/topics/manifest/path-permission-element.html>`__
         -  `<permission> <https://devdoc.net/android/Android-r15/guide/topics/manifest/permission-element.html>`__
         -  `<permission-group> <https://devdoc.net/android/Android-r15/guide/topics/manifest/permission-group-element.html>`__
         -  `<permission-tree> <https://devdoc.net/android/Android-r15/guide/topics/manifest/permission-tree-element.html>`__
         -  `<provider> <https://devdoc.net/android/Android-r15/guide/topics/manifest/provider-element.html>`__
         -  `<receiver> <https://devdoc.net/android/Android-r15/guide/topics/manifest/receiver-element.html>`__
         -  `<service> <https://devdoc.net/android/Android-r15/guide/topics/manifest/service-element.html>`__
         -  `<supports-gl-texture> <https://devdoc.net/android/Android-r15/guide/topics/manifest/supports-gl-texture-element.html>`__
         -  `<supports-screens> <https://devdoc.net/android/Android-r15/guide/topics/manifest/supports-screens-element.html>`__
         -  `<uses-configuration> <https://devdoc.net/android/Android-r15/guide/topics/manifest/uses-configuration-element.html>`__
         -  `<uses-feature> <https://devdoc.net/android/Android-r15/guide/topics/manifest/uses-feature-element.html>`__
         -  `<uses-library> <https://devdoc.net/android/Android-r15/guide/topics/manifest/uses-library-element.html>`__
         -  `<uses-permission> <https://devdoc.net/android/Android-r15/guide/topics/manifest/uses-permission-element.html>`__
         -  `<uses-sdk> <https://devdoc.net/android/Android-r15/guide/topics/manifest/uses-sdk-element.html>`__

      -  `Graphics <https://devdoc.net/android/Android-r15/guide/topics/graphics/index.html>`__ new!

         -  `Canvas and Drawables <https://devdoc.net/android/Android-r15/guide/topics/graphics/2d-graphics.html>`__
         -  `Hardware Acceleration <https://devdoc.net/android/Android-r15/guide/topics/graphics/hardware-accel.html>`__ new!
         -  `OpenGL <https://devdoc.net/android/Android-r15/guide/topics/graphics/opengl.html>`__

      -  `Animation <https://devdoc.net/android/Android-r15/guide/topics/graphics/animation.html>`__

         -  `Property Animation <https://devdoc.net/android/Android-r15/guide/topics/graphics/prop-animation.html>`__
         -  `View Animation <https://devdoc.net/android/Android-r15/guide/topics/graphics/view-animation.html>`__
         -  `Drawable Animation <https://devdoc.net/android/Android-r15/guide/topics/graphics/drawable-animation.html>`__

      -  `Renderscript <https://devdoc.net/android/Android-r15/guide/topics/renderscript/index.html>`__ updated

         -  `Graphics <https://devdoc.net/android/Android-r15/guide/topics/renderscript/graphics.html>`__
         -  `Compute <https://devdoc.net/android/Android-r15/guide/topics/renderscript/compute.html>`__
         -  `Runtime API Reference <https://devdoc.net/android/Android-r15/guide/topics/renderscript/reference.html>`__

      -  `Multimedia and Camera <https://devdoc.net/android/Android-r15/guide/topics/media/index.html>`__

         -  `Media Playback <https://devdoc.net/android/Android-r15/guide/topics/media/mediaplayer.html>`__
         -  `JetPlayer <https://devdoc.net/android/Android-r15/guide/topics/media/jetplayer.html>`__
         -  `Camera <https://devdoc.net/android/Android-r15/guide/topics/media/camera.html>`__ new!
         -  `Audio Capture <https://devdoc.net/android/Android-r15/guide/topics/media/audio-capture.html>`__

      -  `Copy and Paste <https://devdoc.net/android/Android-r15/guide/topics/clipboard/copy-paste.html>`__

      -  `Sensors <https://devdoc.net/android/Android-r15/guide/topics/sensors/index.html>`__ new!

         -  `Sensors Overview <https://devdoc.net/android/Android-r15/guide/topics/sensors/sensors_overview.html>`__
         -  `Motion Sensors <https://devdoc.net/android/Android-r15/guide/topics/sensors/sensors_motion.html>`__
         -  `Position Sensors <https://devdoc.net/android/Android-r15/guide/topics/sensors/sensors_position.html>`__
         -  `Environment Sensors <https://devdoc.net/android/Android-r15/guide/topics/sensors/sensors_environment.html>`__

      -  `Location and Maps <https://devdoc.net/android/Android-r15/guide/topics/location/index.html>`__

         -  `Obtaining User Location <https://devdoc.net/android/Android-r15/guide/topics/location/obtaining-user-location.html>`__

      -  `App Widgets <https://devdoc.net/android/Android-r15/guide/topics/appwidgets/index.html>`__

      -  `Bluetooth <https://devdoc.net/android/Android-r15/guide/topics/wireless/bluetooth.html>`__

      -  `Near Field Communication <https://devdoc.net/android/Android-r15/guide/topics/nfc/index.html>`__ updated

         -  `NFC Basics <https://devdoc.net/android/Android-r15/guide/topics/nfc/nfc.html>`__
         -  `Advanced NFC <https://devdoc.net/android/Android-r15/guide/topics/nfc/advanced-nfc.html>`__

      -  `Wi-Fi Direct <https://devdoc.net/android/Android-r15/guide/topics/wireless/wifip2p.html>`__ new!

      -  `USB <https://devdoc.net/android/Android-r15/guide/topics/usb/index.html>`__

         -  `Accessory <https://devdoc.net/android/Android-r15/guide/topics/usb/accessory.html>`__
         -  `Host <https://devdoc.net/android/Android-r15/guide/topics/usb/host.html>`__
         -  `Open Accessory Dev Kit <https://devdoc.net/android/Android-r15/guide/topics/usb/adk.html>`__

      -  `Session Initiation Protocol <https://devdoc.net/android/Android-r15/guide/topics/network/sip.html>`__

      -  `Search <https://devdoc.net/android/Android-r15/guide/topics/search/index.html>`__

         -  `Creating a Search Interface <https://devdoc.net/android/Android-r15/guide/topics/search/search-dialog.html>`__
         -  `Adding Recent Query Suggestions <https://devdoc.net/android/Android-r15/guide/topics/search/adding-recent-query-suggestions.html>`__
         -  `Adding Custom Suggestions <https://devdoc.net/android/Android-r15/guide/topics/search/adding-custom-suggestions.html>`__
         -  `Searchable Configuration <https://devdoc.net/android/Android-r15/guide/topics/search/searchable-config.html>`__

      -  `Device Administration <https://devdoc.net/android/Android-r15/guide/topics/admin/device-admin.html>`__

      -  `Testing <https://devdoc.net/android/Android-r15/guide/topics/testing/index.html>`__

         -  `Testing Fundamentals <https://devdoc.net/android/Android-r15/guide/topics/testing/testing_android.html>`__
         -  `Activity Testing <https://devdoc.net/android/Android-r15/guide/topics/testing/activity_testing.html>`__
         -  `Content Provider Testing <https://devdoc.net/android/Android-r15/guide/topics/testing/contentprovider_testing.html>`__
         -  `Service Testing <https://devdoc.net/android/Android-r15/guide/topics/testing/service_testing.html>`__
         -  `What To Test <https://devdoc.net/android/Android-r15/guide/topics/testing/what_to_test.html>`__

   -  .. rubric:: Google Play Topics
         :name: google-play-topics

      -  `Publishing on Google Play <https://devdoc.net/android/Android-r15/guide/publishing/publishing.html>`__

      -  `Application Licensing <https://devdoc.net/android/Android-r15/guide/market/licensing/index.html>`__

         -  `Licensing Overview <https://devdoc.net/android/Android-r15/guide/market/licensing/overview.html>`__
         -  `Setting Up for Licensing <https://devdoc.net/android/Android-r15/guide/market/licensing/setting-up.html>`__
         -  `Adding Licensing to Your App <https://devdoc.net/android/Android-r15/guide/market/licensing/adding-licensing.html>`__
         -  `Licensing Reference <https://devdoc.net/android/Android-r15/guide/market/licensing/licensing-reference.html>`__

      -  `In-app Billing <https://devdoc.net/android/Android-r15/guide/market/billing/index.html>`__

         -  `In-app Billing Overview <https://devdoc.net/android/Android-r15/guide/market/billing/billing_overview.html>`__
         -  `Implementing In-app Billing <https://devdoc.net/android/Android-r15/guide/market/billing/billing_integrate.html>`__
         -  `Security and Design <https://devdoc.net/android/Android-r15/guide/market/billing/billing_best_practices.html>`__
         -  `Testing In-app Billing <https://devdoc.net/android/Android-r15/guide/market/billing/billing_testing.html>`__
         -  `Administering In-app Billing <https://devdoc.net/android/Android-r15/guide/market/billing/billing_admin.html>`__
         -  `In-app Billing Reference <https://devdoc.net/android/Android-r15/guide/market/billing/billing_reference.html>`__

      -  `Filters on Google Play <https://devdoc.net/android/Android-r15/guide/appendix/market-filters.html>`__

      -  `Multiple APK Support <https://devdoc.net/android/Android-r15/guide/market/publishing/multiple-apks.html>`__

      -  `APK Expansion Files <https://devdoc.net/android/Android-r15/guide/market/expansion-files.html>`__ new!

   -   Developing

      -  `Introduction <https://devdoc.net/android/Android-r15/guide/developing/index.html>`__
      -  `Managing Virtual Devices <https://devdoc.net/android/Android-r15/guide/developing/devices/index.html>`__

         -  `With AVD Manager <https://devdoc.net/android/Android-r15/guide/developing/devices/managing-avds.html>`__
         -  `From the Command Line <https://devdoc.net/android/Android-r15/guide/developing/devices/managing-avds-cmdline.html>`__
         -  `Using the Android Emulator <https://devdoc.net/android/Android-r15/guide/developing/devices/emulator.html>`__

      -  `Using Hardware Devices <https://devdoc.net/android/Android-r15/guide/developing/device.html>`__
      -  `Managing Projects <https://devdoc.net/android/Android-r15/guide/developing/projects/index.html>`__

         -  `From Eclipse with ADT <https://devdoc.net/android/Android-r15/guide/developing/projects/projects-eclipse.html>`__
         -  `From the Command Line <https://devdoc.net/android/Android-r15/guide/developing/projects/projects-cmdline.html>`__

      -  `Building and Running <https://devdoc.net/android/Android-r15/guide/developing/building/index.html>`__

         -  `From Eclipse with ADT <https://devdoc.net/android/Android-r15/guide/developing/building/building-eclipse.html>`__
         -  `From the Command Line <https://devdoc.net/android/Android-r15/guide/developing/building/building-cmdline.html>`__

      -  `Debugging <https://devdoc.net/android/Android-r15/guide/developing/debugging/index.html>`__

         -  `From Eclipse with ADT <https://devdoc.net/android/Android-r15/guide/developing/debugging/debugging-projects.html>`__
         -  `From Other IDEs <https://devdoc.net/android/Android-r15/guide/developing/debugging/debugging-projects-cmdline.html>`__
         -  `Using DDMS <https://devdoc.net/android/Android-r15/guide/developing/debugging/ddms.html>`__
         -  `Reading and Writing Logs <https://devdoc.net/android/Android-r15/guide/developing/debugging/debugging-log.html>`__
         -  `Debugging and Profiling UIs <https://devdoc.net/android/Android-r15/guide/developing/debugging/debugging-ui.html>`__
         -  `Profiling with Traceview and dmtracedump <https://devdoc.net/android/Android-r15/guide/developing/debugging/debugging-tracing.html>`__
         -  `Using the Dev Tools App <https://devdoc.net/android/Android-r15/guide/developing/debugging/debugging-devtools.html>`__

      -  `Testing <https://devdoc.net/android/Android-r15/guide/developing/testing/index.html>`__

         -  `From Eclipse with ADT <https://devdoc.net/android/Android-r15/guide/developing/testing/testing_eclipse.html>`__
         -  `From Other IDEs <https://devdoc.net/android/Android-r15/guide/developing/testing/testing_otheride.html>`__

      -  `Tools <https://devdoc.net/android/Android-r15/guide/developing/tools/index.html>`__

         -  `adb <https://devdoc.net/android/Android-r15/guide/developing/tools/adb.html>`__
         -  `ADT <https://devdoc.net/android/Android-r15/guide/developing/tools/adt.html>`__
         -  `android <https://devdoc.net/android/Android-r15/guide/developing/tools/android.html>`__
         -  `bmgr <https://devdoc.net/android/Android-r15/guide/developing/tools/bmgr.html>`__
         -  `dmtracedump <https://devdoc.net/android/Android-r15/guide/developing/tools/dmtracedump.html>`__
         -  `Draw 9-Patch <https://devdoc.net/android/Android-r15/guide/developing/tools/draw9patch.html>`__
         -  `Emulator <https://devdoc.net/android/Android-r15/guide/developing/tools/emulator.html>`__
         -  `etc1tool <https://devdoc.net/android/Android-r15/guide/developing/tools/etc1tool.html>`__
         -  `Hierarchy Viewer <https://devdoc.net/android/Android-r15/guide/developing/tools/hierarchy-viewer.html>`__
         -  `hprof-conv <https://devdoc.net/android/Android-r15/guide/developing/tools/hprof-conv.html>`__
         -  `layoutopt <https://devdoc.net/android/Android-r15/guide/developing/tools/layoutopt.html>`__
         -  `logcat <https://devdoc.net/android/Android-r15/guide/developing/tools/logcat.html>`__
         -  `mksdcard <https://devdoc.net/android/Android-r15/guide/developing/tools/mksdcard.html>`__
         -  `Monkey <https://devdoc.net/android/Android-r15/guide/developing/tools/monkey.html>`__
         -  `monkeyrunner <https://devdoc.net/android/Android-r15/guide/developing/tools/monkeyrunner_concepts.html>`__

            -  `MonkeyDevice <https://devdoc.net/android/Android-r15/guide/developing/tools/MonkeyDevice.html>`__
            -  `MonkeyImage <https://devdoc.net/android/Android-r15/guide/developing/tools/MonkeyImage.html>`__
            -  `MonkeyRunner <https://devdoc.net/android/Android-r15/guide/developing/tools/MonkeyRunner.html>`__

         -  `ProGuard <https://devdoc.net/android/Android-r15/guide/developing/tools/proguard.html>`__
         -  `sqlite3 <https://devdoc.net/android/Android-r15/guide/developing/tools/adb.html#sqlite>`__
         -  `Traceview <https://devdoc.net/android/Android-r15/guide/developing/tools/traceview.html>`__
         -  `zipalign <https://devdoc.net/android/Android-r15/guide/developing/tools/zipalign.html>`__

   -   Publishing

      -  `Publishing Overview <https://devdoc.net/android/Android-r15/guide/publishing/publishing_overview.html>`__
      -  `Preparing for Release <https://devdoc.net/android/Android-r15/guide/publishing/preparing.html>`__
      -  `Signing Your Applications <https://devdoc.net/android/Android-r15/guide/publishing/app-signing.html>`__
      -  `Versioning Your Applications <https://devdoc.net/android/Android-r15/guide/publishing/versioning.html>`__

   -   Best Practices

      -  `Compatibility <https://devdoc.net/android/Android-r15/guide/practices/compatibility.html>`__
      -  `Supporting Multiple Screens <https://devdoc.net/android/Android-r15/guide/practices/screens_support.html>`__

         -  `Distributing to Specific Screens <https://devdoc.net/android/Android-r15/guide/practices/screens-distribution.html>`__
         -  `Screen Compatibility Mode <https://devdoc.net/android/Android-r15/guide/practices/screen-compat-mode.html>`__
         -  `Strategies for Android 1.5 <https://devdoc.net/android/Android-r15/guide/practices/screens-support-1.5.html>`__

      -  `Supporting Tablets and Handsets <https://devdoc.net/android/Android-r15/guide/practices/tablets-and-handsets.html>`__ new!

      -  `UI Guidelines <https://devdoc.net/android/Android-r15/guide/practices/ui_guidelines/index.html>`__

         -  `Icon Design <https://devdoc.net/android/Android-r15/guide/practices/ui_guidelines/icon_design.html>`__

            -  `Launcher Icons <https://devdoc.net/android/Android-r15/guide/practices/ui_guidelines/icon_design_launcher.html>`__
            -  `Menu Icons <https://devdoc.net/android/Android-r15/guide/practices/ui_guidelines/icon_design_menu.html>`__
            -  `Action Bar Icons <https://devdoc.net/android/Android-r15/guide/practices/ui_guidelines/icon_design_action_bar.html>`__
            -  `Status Bar Icons <https://devdoc.net/android/Android-r15/guide/practices/ui_guidelines/icon_design_status_bar.html>`__
            -  `Tab Icons <https://devdoc.net/android/Android-r15/guide/practices/ui_guidelines/icon_design_tab.html>`__
            -  `Dialog Icons <https://devdoc.net/android/Android-r15/guide/practices/ui_guidelines/icon_design_dialog.html>`__
            -  `List View Icons <https://devdoc.net/android/Android-r15/guide/practices/ui_guidelines/icon_design_list.html>`__

         -  `App Widget Design <https://devdoc.net/android/Android-r15/guide/practices/ui_guidelines/widget_design.html>`__

         -  `Activity and Task Design <https://devdoc.net/android/Android-r15/guide/practices/ui_guidelines/activity_task_design.html>`__

         -  `Menu Design <https://devdoc.net/android/Android-r15/guide/practices/ui_guidelines/menu_design.html>`__

      -  `Designing for Accessibility <https://devdoc.net/android/Android-r15/guide/practices/design/accessibility.html>`__

      -  `Designing for Performance <https://devdoc.net/android/Android-r15/guide/practices/design/performance.html>`__

         -  `JNI Tips <https://devdoc.net/android/Android-r15/guide/practices/design/jni.html>`__

      -  `Designing for Responsiveness <https://devdoc.net/android/Android-r15/guide/practices/design/responsiveness.html>`__

      -  `Designing for Seamlessness <https://devdoc.net/android/Android-r15/guide/practices/design/seamlessness.html>`__

      -  `Designing for Security <https://devdoc.net/android/Android-r15/guide/practices/security.html>`__

   -   Web Applications

      -  `Web Apps Overview <https://devdoc.net/android/Android-r15/guide/webapps/index.html>`__
      -  `Targeting Screens from Web Apps <https://devdoc.net/android/Android-r15/guide/webapps/targeting.html>`__
      -  `Building Web Apps in WebView <https://devdoc.net/android/Android-r15/guide/webapps/webview.html>`__
      -  `Debugging Web Apps <https://devdoc.net/android/Android-r15/guide/webapps/debugging.html>`__
      -  `Best Practices for Web Apps <https://devdoc.net/android/Android-r15/guide/webapps/best-practices.html>`__

   -   Appendix Anhang

      -  `Android API Levels <https://devdoc.net/android/Android-r15/guide/appendix/api-levels.html>`__
      -  `App Install Location <https://devdoc.net/android/Android-r15/guide/appendix/install-location.html>`__
      -  `Supported Media Formats <https://devdoc.net/android/Android-r15/guide/appendix/media-formats.html>`__
      -  `Intents List: Google Apps <https://devdoc.net/android/Android-r15/guide/appendix/g-app-intents.html>`__
      -  `AIDL <https://devdoc.net/android/Android-r15/guide/developing/tools/aidl.html>`__
      -  `Glossary <https://devdoc.net/android/Android-r15/guide/appendix/glossary.html>`__


/What is Android?
=================

.. container::
   :name: jd-content

   .. container:: jd-descr

      Android is a software stack for mobile devices that includes
      an operating system, middleware and key applications. The
      `Android SDK <http://developer.android.com/sdk/index.html>`__
      provides the tools and APIs necessary to begin developing
      applications on the Android platform using the Java
      programming language.

      .. rubric:: Features
         :name: features

      -  **Application framework** enabling reuse and replacement
         of components
      -  **Dalvik virtual machine** optimized for mobile devices
      -  **Integrated browser** based on the open source
         `WebKit <http://webkit.org/>`__ engine
      -  **Optimized graphics** powered by a custom 2D graphics
         library; 3D graphics based on the OpenGL ES 1.0
         specification (hardware acceleration optional)
      -  **SQLite** for structured data storage
      -  **Media support** for common audio, video, and still
         image formats (MPEG4, H.264, MP3, AAC, AMR, JPG, PNG,
         GIF)
      -  **GSM Telephony** (hardware dependent)
      -  **Bluetooth, EDGE, 3G, and WiFi** (hardware dependent)
      -  **Camera, GPS, compass, and accelerometer** (hardware
         dependent)
      -  **Rich development environment** including a device
         emulator, tools for debugging, memory and performance
         profiling, and a plugin for the Eclipse IDE

      .. rubric:: Android Architecture
         :name: android-architecture

      The following diagram shows the major components of the
      Android operating system. Each section is described in more
      detail below.

      .. image:: https://devdoc.net/android/Android-r15/images/system-architecture.jpg
         :width: 713px
         :height: 512px
         :alt: Android System Architecture

      .. rubric:: Applications
         :name: applications

      Android will ship with a set of core applications including
      an email client, SMS program, calendar, maps, browser,
      contacts, and others. All applications are written using the
      Java programming language.

      .. rubric:: Application Framework
         :name: application-framework

      By providing an open development platform, Android offers
      developers the ability to build extremely rich and
      innovative applications. Developers are free to take
      advantage of the device hardware, access location
      information, run background services, set alarms, add
      notifications to the status bar, and much, much more.

      Developers have full access to the same framework APIs used
      by the core applications. The application architecture is
      designed to simplify the reuse of components; any
      application can publish its capabilities and any other
      application may then make use of those capabilities (subject
      to security constraints enforced by the framework). This
      same mechanism allows components to be replaced by the user.

      Underlying all applications is a set of services and
      systems, including:

      -  A rich and extensible set of
         `Views <https://devdoc.net/android/Android-r15/resources/tutorials/views/index.html>`__
         that can be used to build an application, including
         lists, grids, text boxes, buttons, and even an embeddable
         web browser
      -  `Content Providers <https://devdoc.net/android/Android-r15/guide/topics/providers/content-providers.html>`__
         that enable applications to access data from other
         applications (such as Contacts), or to share their own
         data
      -  A `Resource Manager <https://devdoc.net/android/Android-r15/guide/topics/resources/resources-i18n.html>`__,
         providing access to non-code resources such as localized
         strings, graphics, and layout files
      -  A
         `Notification Manager <https://devdoc.net/android/Android-r15/reference/android/app/NotificationManager.html>`__
         that enables all applications to display custom alerts in
         the status bar
      -  An
         `Activity Manager <https://devdoc.net/android/Android-r15/reference/android/app/Activity.html>`__
         that manages the lifecycle of applications and provides a
         common navigation backstack

      For more details and a walkthrough of an application, see
      the `Notepad Tutorial <https://devdoc.net/android/Android-r15/resources/tutorials/notepad/index.html>`__.

      .. rubric:: Libraries
         :name: libraries

      Android includes a set of C/C++ libraries used by various
      components of the Android system. These capabilities are
      exposed to developers through the Android application
      framework. Some of the core libraries are listed below:

      -  **System C library** - a BSD-derived implementation of
         the standard C system library (libc), tuned for embedded
         Linux-based devices
      -  **Media Libraries** - based on PacketVideo's OpenCORE;
         the libraries support playback and recording of many
         popular audio and video formats, as well as static image
         files, including MPEG4, H.264, MP3, AAC, AMR, JPG, and
         PNG
      -  **Surface Manager** - manages access to the display
         subsystem and seamlessly composites 2D and 3D graphic
         layers from multiple applications
      -  **LibWebCore** - a modern web browser engine which powers
         both the Android browser and an embeddable web view
      -  **SGL** - the underlying 2D graphics engine
      -  **3D libraries** - an implementation based on OpenGL ES
         1.0 APIs; the libraries use either hardware 3D
         acceleration (where available) or the included, highly
         optimized 3D software rasterizer
      -  **FreeType** - bitmap and vector font rendering
      -  **SQLite** - a powerful and lightweight relational
         database engine available to all applications

      .. rubric:: Android Runtime
         :name: android-runtime

      Android includes a set of core libraries that provides most
      of the functionality available in the core libraries of the
      Java programming language.

      Every Android application runs in its own process, with its
      own instance of the Dalvik virtual machine. Dalvik has been
      written so that a device can run multiple VMs efficiently.
      The Dalvik VM executes files in the Dalvik Executable (.dex)
      format which is optimized for minimal memory footprint. The
      VM is register-based, and runs classes compiled by a Java
      language compiler that have been transformed into the .dex
      format by the included "dx" tool.

      The Dalvik VM relies on the Linux kernel for underlying
      functionality such as threading and low-level memory
      management.

      .. rubric:: Linux Kernel
         :name: linux-kernel

      Android relies on Linux version 2.6 for core system services
      such as security, memory management, process management,
      network stack, and driver model. The kernel also acts as an
      abstraction layer between the hardware and the rest of the
      software stack.

   `‚Üë Go to top <#top>`__

.. container::
   :name: footer

   .. container::
      :name: copyright

      Except as noted, this content is licensed under 
      `Apache 2.0 <http://www.apache.org/licenses/LICENSE-2.0>`__. For
      details and restrictions, see the 
      `Content License <https://devdoc.net/android/Android-r15/license.html>`__.

   .. container::
      :name: build_info

      Android 4.0 r1 - 16 Mar 2012 16:45

   .. container::
      :name: footerlinks

      `Privacy & Terms <http://www.google.com/intl/en/policies/>`__ 
      - `Brand Guidelines <http://www.android.com/branding.html>`__ -
      `Report Document Issues <http://code.google.com/p/android/issues/entry?template=Developer%20Documentation>`__


/Application Fundamentals
=========================

.. container::
   :name: jd-content

   .. container:: jd-descr

      .. container::
         :name: qv-wrapper

         .. container::
            :name: qv

            .. rubric:: Quickview
               :name: quickview

            -  Android applications are composed of one or more
               application components (activities, services, content
               providers, and broadcast receivers)
            -  Each component performs a different role in the overall
               application behavior, and each one can be activated
               individually (even by other applications)
            -  The manifest file must declare all components in the
               application and should also declare all application
               requirements, such as the minimum version of Android
               required and any hardware configurations required
            -  Non-code application resources (images, strings, layout
               files, etc.) should include alternatives for different
               device configurations (such as different strings for
               different languages and different layouts for different
               screen sizes)

            .. rubric:: In this document
               :name: in-this-document

            #. `Application Components <#Components>`__

               #. `Activating components <#ActivatingComponents>`__

            #. `The Manifest File <#Manifest>`__

               #. `Declaring components <#DeclaringComponents>`__
               #. `Declaring application requirements <#DeclaringRequirements>`__

            #. `Application Resources <#Resources>`__

      Android applications are written in the Java programming language.
      The Android SDK tools compile the code‚Äîalong with any data and
      resource files‚Äîinto an *Android package*, an archive file with an
      ``.apk`` suffix. All the code in a single ``.apk`` file is
      considered to be one application and is the file that
      Android-powered devices use to install the application.

      Once installed on a device, each Android application lives in its
      own security sandbox:

      -  The Android operating system is a multi-user Linux system in
         which each application is a different user.
      -  By default, the system assigns each application a unique Linux
         user ID (the ID is used only by the system and is unknown to
         the application). The system sets permissions for all the files
         in an application so that only the user ID assigned to that
         application can access them.
      -  Each process has its own virtual machine (VM), so an
         application's code runs in isolation from other applications.
      -  By default, every application runs in its own Linux process.
         Android starts the process when any of the application's
         components need to be executed, then shuts down the process
         when it's no longer needed or when the system must recover
         memory for other applications.

      In this way, the Android system implements the *principle of least
      privilege*. That is, each application, by default, has access only
      to the components that it requires to do its work and no more.
      This creates a very secure environment in which an application
      cannot access parts of the system for which it is not given
      permission.

      However, there are ways for an application to share data with
      other applications and for an application to access system
      services:

      -  It's possible to arrange for two applications to share the same
         Linux user ID, in which case they are able to access each
         other's files. To conserve system resources, applications with
         the same user ID can also arrange to run in the same Linux
         process and share the same VM (the applications must also be
         signed with the same certificate).
      -  An application can request permission to access device data
         such as the user's contacts, SMS messages, the mountable
         storage (SD card), camera, Bluetooth, and more. All application
         permissions must be granted by the user at install time.

      That covers the basics regarding how an Android application exists
      within the system. The rest of this document introduces you to:

      -  The core framework components that define your application.
      -  The manifest file in which you declare components and required
         device features for your application.
      -  Resources that are separate from the application code and allow
         your application to gracefully optimize its behavior for a
         variety of device configurations.

      .. rubric:: Application Components
         :name: Components

      Application components are the essential building blocks of an
      Android application. Each component is a different point through
      which the system can enter your application. Not all components
      are actual entry points for the user and some depend on each
      other, but each one exists as its own entity and plays a specific
      role‚Äîeach one is a unique building block that helps define your
      application's overall behavior.

      There are four different types of application components. Each
      type serves a distinct purpose and has a distinct lifecycle that
      defines how the component is created and destroyed.

      Here are the four types of application components:

      **Activities**
         An *activity* represents a single screen with a user interface.
         For example, an email application might have one activity that
         shows a list of new emails, another activity to compose an
         email, and another activity for reading emails. Although the
         activities work together to form a cohesive user experience in
         the email application, each one is independent of the others.
         As such, a different application can start any one of these
         activities (if the email application allows it). For example, a
         camera application can start the activity in the email
         application that composes new mail, in order for the user to
         share a picture.

         An activity is implemented as a subclass of
         `Activity <#>`__
         and you can learn more about it in the
         `Activities <#>`__
         developer guide.

      **Services**
         A *service* is a component that runs in the background to
         perform long-running operations or to perform work for remote
         processes. A service does not provide a user interface. For
         example, a service might play music in the background while the
         user is in a different application, or it might fetch data over
         the network without blocking user interaction with an activity.
         Another component, such as an activity, can start the service
         and let it run or bind to it in order to interact with it.

         A service is implemented as a subclass of
         `Service <#>`__ and
         you can learn more about it in the
         `Services <#>`__
         developer guide.

      **Content providers**
         A *content provider* manages a shared set of application data.
         You can store the data in the file system, an SQLite database,
         on the web, or any other persistent storage location your
         application can access. Through the content provider, other
         applications can query or even modify the data (if the content
         provider allows it). For example, the Android system provides a
         content provider that manages the user's contact information.
         As such, any application with the proper permissions can query
         part of the content provider (such as
         `ContactsContract.Data <#>`__)
         to read and write information about a particular person.

         Content providers are also useful for reading and writing data
         that is private to your application and not shared. For
         example, the `Note Pad <#>`__ sample
         application uses a content provider to save notes.

         A content provider is implemented as a subclass of
         `ContentProvider <#>`__
         and must implement a standard set of APIs that enable other
         applications to perform transactions. For more information, see
         the `Content Providers <#>`__
         developer guide.

      **Broadcast receivers**
         A *broadcast receiver* is a component that responds to
         system-wide broadcast announcements. Many broadcasts originate
         from the system‚Äîfor example, a broadcast announcing that the
         screen has turned off, the battery is low, or a picture was
         captured. Applications can also initiate broadcasts‚Äîfor
         example, to let other applications know that some data has been
         downloaded to the device and is available for them to use.
         Although broadcast receivers don't display a user interface,
         they may `create a status bar notification <#>`__
         to alert the user when a broadcast event occurs. More commonly,
         though, a broadcast receiver is just a "gateway" to other
         components and is intended to do a very minimal amount of work.
         For instance, it might initiate a service to perform some work
         based on the event.

         A broadcast receiver is implemented as a subclass of
         `BroadcastReceiver <#>`__ and each broadcast is delivered as an
         `Intent <#>`__ object. For more information, see the
         `BroadcastReceiver <#>`__
         class.

      A unique aspect of the Android system design is that any
      application can start another application‚Äôs component. For
      example, if you want the user to capture a photo with the device
      camera, there's probably another application that does that and
      your application can use it, instead of developing an activity to
      capture a photo yourself. You don't need to incorporate or even
      link to the code from the camera application. Instead, you can
      simply start the activity in the camera application that captures
      a photo. When complete, the photo is even returned to your
      application so you can use it. To the user, it seems as if the
      camera is actually a part of your application.

      When the system starts a component, it starts the process for that
      application (if it's not already running) and instantiates the
      classes needed for the component. For example, if your application
      starts the activity in the camera application that captures a
      photo, that activity runs in the process that belongs to the
      camera application, not in your application's process. Therefore,
      unlike applications on most other systems, Android applications
      don't have a single entry point (there's no ``main()`` function,
      for example).

      Because the system runs each application in a separate process
      with file permissions that restrict access to other applications,
      your application cannot directly activate a component from another
      application. The Android system, however, can. So, to activate a
      component in another application, you must deliver a message to
      the system that specifies your *intent* to start a particular
      component. The system then activates the component for you.

      .. rubric:: Activating Components
         :name: ActivatingComponents

      Three of the four component types‚Äîactivities, services, and
      broadcast receivers‚Äîare activated by an asynchronous message
      called an *intent*. Intents bind individual components to each
      other at runtime (you can think of them as the messengers that
      request an action from other components), whether the component
      belongs to your application or another.

      An intent is created with an `Intent <#>`__
      object, which defines a message to activate either a specific
      component or a specific *type* of component‚Äîan intent can be
      either explicit or implicit, respectively.

      For activities and services, an intent defines the action to
      perform (for example, to "view" or "send" something) and may
      specify the URI of the data to act on (among other things that the
      component being started might need to know). For example, an
      intent might convey a request for an activity to show an image or
      to open a web page. In some cases, you can start an activity to
      receive a result, in which case, the activity also returns the
      result in an `Intent <#>`__ (for
      example, you can issue an intent to let the user pick a personal
      contact and have it returned to you‚Äîthe return intent includes a
      URI pointing to the chosen contact).

      For broadcast receivers, the intent simply defines the
      announcement being broadcast (for example, a broadcast to indicate
      the device battery is low includes only a known action string that
      indicates "battery is low").

      The other component type, content provider, is not activated by
      intents. Rather, it is activated when targeted by a request from a
      `ContentResolver <#>`__.
      The content resolver handles all direct transactions with the
      content provider so that the component that's performing
      transactions with the provider doesn't need to and instead calls
      methods on the
      `ContentResolver <#>`__
      object. This leaves a layer of abstraction between the content
      provider and the component requesting information (for security).

      There are separate methods for activating each type of component:

      -  You can start an activity (or give it something new to do) by
         passing an `Intent <#>`__ to `startActivity() <#startActivity>`__
         or
         `startActivityForResult() <#startActivityForResult>`__
         (when you want the activity to return a result).
      -  You can start a service (or give new instructions to an ongoing
         service) by passing an `Intent <#>`__ to
         `startService() <#startService>`__.
         Or you can bind to the service by passing an
         `Intent <#>`__ to `bindService() <#bindService>`__.
      -  You can initiate a broadcast by passing an
         `Intent <#>`__ to methods like
         `sendBroadcast() <#sendBroadcast>`__,
         `sendOrderedBroadcast() <#sendOrderedBroadcast>`__,
         or
         `sendStickyBroadcast() <#sendStickyBroadcast>`__.
      -  You can perform a query to a content provider by calling
         `query() <#query>`__ on a `ContentResolver <#>`__.

      For more information about using intents, see the `Intents and Intent Filters <#>`__
      document. More information about activating specific components is
      also provided in the following documents:
      `Activities <#>`__, `Services <#>`__, `BroadcastReceiver <#>`__
      and `Content Providers <#>`__.

      .. rubric:: The Manifest File
         :name: Manifest

      Before the Android system can start an application component, the
      system must know that the component exists by reading the
      application's ``AndroidManifest.xml`` file (the "manifest" file).
      Your application must declare all its components in this file,
      which must be at the root of the application project directory.

      The manifest does a number of things in addition to declaring the
      application's components, such as:

      -  Identify any user permissions the application requires, such as
         Internet access or read-access to the user's contacts.
      -  Declare the minimum `API Level <#>`__ required by the
         application, based on which APIs the application uses.
      -  Declare hardware and software features used or required by the
         application, such as a camera, bluetooth services, or a
         multitouch screen.
      -  API libraries the application needs to be linked against (other
         than the Android framework APIs), such as the `Google Maps library <http://code.google.com/android/add-ons/google-apis/maps-overview.html>`__.
      -  And more

      .. rubric:: Declaring components
         :name: DeclaringComponents

      The primary task of the manifest is to inform the system about the
      application's components. For example, a manifest file can declare
      an activity as follows:

      ::

         <?xml version="1.0" encoding="utf-8"?>
         <manifest ... >
             <application android:icon="@drawable/app_icon.png" ... >
                 <activity android:name="com.example.project.ExampleActivity"
                           android:label="@string/example_label" ... >
                 </activity>
                 ...
             </application>
         </manifest>

      In the ``<application>``
      element, the ``android:icon`` attribute points to resources for an
      icon that identifies the application.

      In the ``<activity>``
      element, the ``android:name`` attribute specifies the fully
      qualified class name of the
      `Activity <#>`__
      subclass and the ``android:label`` attributes specifies a string
      to use as the user-visible label for the activity.

      You must declare all application components this way:

      -  ``<activity>`` elements for activities
      -  ``<service>`` elements for services
      -  ``<receiver>`` elements for broadcast receivers
      -  ``<provider>`` elements for content providers

      Activities, services, and content providers that you include in
      your source but do not declare in the manifest are not visible to
      the system and, consequently, can never run. However, broadcast
      receivers can be either declared in the manifest or created
      dynamically in code (as
      `BroadcastReceiver <#>`__
      objects) and registered with the system by calling
      `registerReceiver() <#registerReceiver>`__.

      For more about how to structure the manifest file for your
      application, see the `The AndroidManifest.xml File <#>`__
      documentation.

      .. rubric:: Declaring component capabilities
         :name: DeclaringComponentCapabilities

      As discussed above, in `Activating Components <#ActivatingComponents>`__, you can use an
      `Intent <#>`__ to
      start activities, services, and broadcast receivers. You can do so
      by explicitly naming the target component (using the component
      class name) in the intent. However, the real power of intents lies
      in the concept of intent actions. With intent actions, you simply
      describe the type of action you want to perform (and optionally,
      the data upon which you‚Äôd like to perform the action) and allow
      the system to find a component on the device that can perform the
      action and start it. If there are multiple components that can
      perform the action described by the intent, then the user selects
      which one to use.

      The way the system identifies the components that can respond to
      an intent is by comparing the intent received to the *intent
      filters* provided in the manifest file of other applications on
      the device.

      When you declare a component in your application's manifest, you
      can optionally include intent filters that declare the
      capabilities of the component so it can respond to intents from
      other applications. You can declare an intent filter for your
      component by adding an
      ``<intent-filter>``
      element as a child of the component's declaration element.

      For example, an email application with an activity for composing a
      new email might declare an intent filter in its manifest entry to
      respond to "send" intents (in order to send email). An activity in
      your application can then create an intent with the ‚Äúsend‚Äù action
      (`ACTION_SEND <#ACTION_SEND>`__),
      which the system matches to the email application‚Äôs ‚Äúsend‚Äù
      activity and launches it when you invoke the intent with
      `startActivity() <#startActivity>`__.

      For more about creating intent filters, see the `Intents and Intent Filters <#>`__
      document.

      .. rubric:: Declaring application requirements
         :name: DeclaringRequirements

      There are a variety of devices powered by Android and not all of
      them provide the same features and capabilities. In order to
      prevent your application from being installed on devices that lack
      features needed by your application, it's important that you
      clearly define a profile for the types of devices your application
      supports by declaring device and software requirements in your
      manifest file. Most of these declarations are informational only
      and the system does not read them, but external services such as
      Google Play do read them in order to provide filtering for users
      when they search for applications from their device.

      For example, if your application requires a camera and uses APIs
      introduced in Android 2.1 (`API Level <https://developer.android.google.cn/guide/appendix/api-levels.html>`__ 7), you should
      declare these as requirements in your manifest file. That way,
      devices that do *not* have a camera and have an Android version
      *lower* than 2.1 cannot install your application from Google Play.

      However, you can also declare that your application uses the
      camera, but does not *require* it. In that case, your application
      must perform a check at runtime to determine if the device has a
      camera and disable any features that use the camera if one is not
      available.

      Here are some of the important device characteristics that you
      should consider as you design and develop your application:

      Screen size and density
         In order to categorize devices by their screen type, Android
         defines two characteristics for each device: screen size (the
         physical dimensions of the screen) and screen density (the
         physical density of the pixels on the screen, or dpi‚Äîdots per
         inch). To simplify all the different types of screen
         configurations, the Android system generalizes them into select
         groups that make them easier to target.

         | The screen sizes are: small, normal, large, and extra large.
         | The screen densities are: low density, medium density, high
           density, and extra high density.

         By default, your application is compatible with all screen
         sizes and densities, because the Android system makes the
         appropriate adjustments to your UI layout and image resources.
         However, you should create specialized layouts for certain
         screen sizes and provide specialized images for certain
         densities, using alternative layout resources, and by declaring
         in your manifest exactly which screen sizes your application
         supports with the
         ``<supports-screens>``
         element.

         For more information, see the `Supporting Multiple Screens <#>`__
         document.

      Input configurations
         Many devices provide a different type of user input mechanism,
         such as a hardware keyboard, a trackball, or a five-way
         navigation pad. If your application requires a particular kind
         of input hardware, then you should declare it in your manifest
         with the
         ``<uses-configuration>``
         element. However, it is rare that an application should require
         a certain input configuration.
      Device features
         There are many hardware and software features that may or may
         not exist on a given Android-powered device, such as a camera,
         a light sensor, bluetooth, a certain version of OpenGL, or the
         fidelity of the touchscreen. You should never assume that a
         certain feature is available on all Android-powered devices
         (other than the availability of the standard Android library),
         so you should declare any features used by your application
         with the
         ``<uses-feature>``
         element.
      Platform Version
         Different Android-powered devices often run different versions
         of the Android platform, such as Android 1.6 or Android 2.3.
         Each successive version often includes additional APIs not
         available in the previous version. In order to indicate which
         set of APIs are available, each platform version specifies an
         `API Level <#>`__ (for
         example, Android 1.0 is API Level 1 and Android 2.3 is API
         Level 9). If you use any APIs that were added to the platform
         after version 1.0, you should declare the minimum API Level in
         which those APIs were introduced using the
         ``<uses-sdk>``
         element.

      It's important that you declare all such requirements for your
      application, because, when you distribute your application on
      Google Play, the store uses these declarations to filter which
      applications are available on each device. As such, your
      application should be available only to devices that meet all your
      application requirements.

      For more information about how Google Play filters applications
      based on these (and other) requirements, see the `Filters on Google Play <#>`__
      document.

      .. rubric:: Application Resources
         :name: Resources

      An Android application is composed of more than just code‚Äîit
      requires resources that are separate from the source code, such as
      images, audio files, and anything relating to the visual
      presentation of the application. For example, you should define
      animations, menus, styles, colors, and the layout of activity user
      interfaces with XML files. Using application resources makes it
      easy to update various characteristics of your application without
      modifying code and‚Äîby providing sets of alternative
      resources‚Äîenables you to optimize your application for a variety
      of device configurations (such as different languages and screen
      sizes).

      For every resource that you include in your Android project, the
      SDK build tools define a unique integer ID, which you can use to
      reference the resource from your application code or from other
      resources defined in XML. For example, if your application
      contains an image file named ``logo.png`` (saved in the
      ``res/drawable/`` directory), the SDK tools generate a resource ID
      named ``R.drawable.logo``, which you can use to reference the
      image and insert it in your user interface.

      One of the most important aspects of providing resources separate
      from your source code is the ability for you to provide
      alternative resources for different device configurations. For
      example, by defining UI strings in XML, you can translate the
      strings into other languages and save those strings in separate
      files. Then, based on a language *qualifier* that you append to
      the resource directory's name (such as ``res/values-fr/`` for
      French string values) and the user's language setting, the Android
      system applies the appropriate language strings to your UI.

      Android supports many different *qualifiers* for your alternative
      resources. The qualifier is a short string that you include in the
      name of your resource directories in order to define the device
      configuration for which those resources should be used. As another
      example, you should often create different layouts for your
      activities, depending on the device's screen orientation and size.
      For example, when the device screen is in portrait orientation
      (tall), you might want a layout with buttons to be vertical, but
      when the screen is in landscape orientation (wide), the buttons
      should be aligned horizontally. To change the layout depending on
      the orientation, you can define two different layouts and apply
      the appropriate qualifier to each layout's directory name. Then,
      the system automatically applies the appropriate layout depending
      on the current device orientation.

      For more about the different kinds of resources you can include in
      your application and how to create alternative resources for
      various device configurations, see the `Application Resources <#>`__ developer
      guide.

   `‚Üë Go to top <#top>`__


/Activities
===========

.. container::
   :name: jd-content

   .. container:: jd-descr

      .. container::
         :name: qv-wrapper

         .. container::
            :name: qv

            .. rubric:: Quickview
               :name: quickview

            -  An activity provides a user interface for a single screen
               in your application
            -  Activities can move into the background and then be
               resumed with their state restored

            .. rubric:: In this document
               :name: in-this-document

            #. `Creating an Activity <#Creating>`__

               #. `Implementing a user interface <#UI>`__
               #. `Declaring the activity in the manifest <#Declaring>`__

            #. `Starting an Activity <#StartingAnActivity>`__

               #. `Starting an activity for a result <#StartingAnActivityForResult>`__

            #. `Shutting Down an Activity <#ShuttingDown>`__
            #. `Managing the Activity Lifecycle <#Lifecycle>`__

               #. `Implementing the lifecycle callbacks <#ImplementingLifecycleCallbacks>`__
               #. `Saving activity state <#SavingActivityState>`__
               #. `Handling configuration changes <#ConfigurationChanges>`__
               #. `Coordinating activities <#CoordinatingActivities>`__

            .. rubric:: Key classes
               :name: key-classes

            #. `Activity <#>`__

            .. rubric:: See also
               :name: see-also

            #. `Hello World Tutorial <#>`__
            #. `Tasks and Back Stack <#>`__

      An `Activity <#>`__
      is an application component that provides a screen with which
      users can interact in order to do something, such as dial the
      phone, take a photo, send an email, or view a map. Each activity
      is given a window in which to draw its user interface. The window
      typically fills the screen, but may be smaller than the screen and
      float on top of other windows.

      An application usually consists of multiple activities that are
      loosely bound to each other. Typically, one activity in an
      application is specified as the "main" activity, which is
      presented to the user when launching the application for the first
      time. Each activity can then start another activity in order to
      perform different actions. Each time a new activity starts, the
      previous activity is stopped, but the system preserves the
      activity in a stack (the "back stack"). When a new activity
      starts, it is pushed onto the back stack and takes user focus. The
      back stack abides to the basic "last in, first out" stack
      mechanism, so, when the user is done with the current activity and
      presses the *Back* button, it is popped from the stack (and
      destroyed) and the previous activity resumes. (The back stack is
      discussed more in the `Tasks and Back Stack <#>`__
      document.)

      When an activity is stopped because a new activity starts, it is
      notified of this change in state through the activity's lifecycle
      callback methods. There are several callback methods that an
      activity might receive, due to a change in its state‚Äîwhether the
      system is creating it, stopping it, resuming it, or destroying
      it‚Äîand each callback provides you the opportunity to perform
      specific work that's appropriate to that state change. For
      instance, when stopped, your activity should release any large
      objects, such as network or database connections. When the
      activity resumes, you can reacquire the necessary resources and
      resume actions that were interrupted. These state transitions are
      all part of the activity lifecycle.

      The rest of this document discusses the basics of how to build and
      use an activity, including a complete discussion of how the
      activity lifecycle works, so you can properly manage the
      transition between various activity states.

      .. rubric:: Creating an Activity
         :name: Creating

      To create an activity, you must create a subclass of
      `Activity <#>`__
      (or an existing subclass of it). In your subclass, you need to
      implement callback methods that the system calls when the activity
      transitions between various states of its lifecycle, such as when
      the activity is being created, stopped, resumed, or destroyed. The
      two most important callback methods are:

      `onCreate() <#onCreate>`__
         You must implement this method. The system calls this when
         creating your activity. Within your implementation, you should
         initialize the essential components of your activity. Most
         importantly, this is where you must call
         `setContentView() <#setContentView>`__
         to define the layout for the activity's user interface.
      `onPause() <#onPause>`__
         The system calls this method as the first indication that the
         user is leaving your activity (though it does not always mean
         the activity is being destroyed). This is usually where you
         should commit any changes that should be persisted beyond the
         current user session (because the user might not come back).

      There are several other lifecycle callback methods that you should
      use in order to provide a fluid user experience between activities
      and handle unexpected interuptions that cause your activity to be
      stopped and even destroyed. All of the lifecycle callback methods
      are discussed later, in the section about `Managing the Activity Lifecycle <#Lifecycle>`__.

      .. rubric:: Implementing a user interface
         :name: UI

      The user interface for an activity is provided by a hierarchy of
      views‚Äîobjects derived from the
      `View <#>`__ class.
      Each view controls a particular rectangular space within the
      activity's window and can respond to user interaction. For
      example, a view might be a button that initiates an action when
      the user touches it.

      Android provides a number of ready-made views that you can use to
      design and organize your layout. "Widgets" are views that provide
      a visual (and interactive) elements for the screen, such as a
      button, text field, checkbox, or just an image. "Layouts" are
      views derived from
      `ViewGroup <#>`__
      that provide a unique layout model for its child views, such as a
      linear layout, a grid layout, or relative layout. You can also
      subclass the
      `View <#>`__ and
      `ViewGroup <#>`__
      classes (or existing subclasses) to create your own widgets and
      layouts and apply them to your activity layout.

      The most common way to define a layout using views is with an XML
      layout file saved in your application resources. This way, you can
      maintain the design of your user interface separately from the
      source code that defines the activity's behavior. You can set the
      layout as the UI for your activity with
      `setContentView() <#setContentView>`__,
      passing the resource ID for the layout. However, you can also
      create new
      `View <#>`__\ s in
      your activity code and build a view hierarchy by inserting new
      `View <#>`__\ s into a
      `ViewGroup <#>`__,
      then use that layout by passing the root
      `ViewGroup <#>`__
      to
      `setContentView() <#setContentView>`__.

      For information about creating a user interface, see the `User Interface <#>`__ documentation.

      .. rubric:: Declaring the activity in the manifest
         :name: Declaring

      You must declare your activity in the manifest file in order for
      it to be accessible to the system. To declare your activity, open
      your manifest file and add an
      ``<activity>``
      element as a child of the
      ``<application>``
      element. For example:

      ::

         <manifest ... >
           <application ... >
               <activity android:name=".ExampleActivity" />
               ...
           </application ... >
           ...
         </manifest >

      There are several other attributes that you can include in this
      element, to define properties such as the label for the activity,
      an icon for the activity, or a theme to style the activity's UI.
      The
      `android:name <#nm>`__
      attribute is the only required attribute‚Äîit specifies the class
      name of the activity. Once you publish your application, you
      should not change this name, because if you do, you might break
      some functionality, such as application shortcuts (read the blog
      post, `Things That Cannot Change <http://android-developers.blogspot.com/2011/06/things-that-cannot-change.html>`__).

      See the
      ``<activity>``
      element reference for more information about declaring your
      activity in the manifest.

      .. rubric:: Using intent filters
         :name: using-intent-filters

      An
      ``<activity>``
      element can also specify various intent filters‚Äîusing the
      ``<intent-filter>``
      element‚Äîin order to declare how other application components may
      activate it.

      When you create a new application using the Android SDK tools, the
      stub activity that's created for you automatically includes an
      intent filter that declares the activity responds to the "main"
      action and should be placed in the "launcher" category. The intent
      filter looks like this:

      ::

         <activity android:name=".ExampleActivity" android:icon="@drawable/app_icon">
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
                 <category android:name="android.intent.category.LAUNCHER" />
             </intent-filter>
         </activity>

      The
      ``<action>``
      element specifies that this is the "main" entry point to the
      application. The
      ``<category>``
      element specifies that this activity should be listed in the
      system's application launcher (to allow users to launch this
      activity).

      If you intend for your application to be self-contained and not
      allow other applications to activate its activities, then you
      don't need any other intent filters. Only one activity should have
      the "main" action and "launcher" category, as in the previous
      example. Activities that you don't want to make available to other
      applications should have no intent filters and you can start them
      yourself using explicit intents (as discussed in the following
      section).

      However, if you want your activity to respond to implicit intents
      that are delivered from other applications (and your own), then
      you must define additional intent filters for your activity. For
      each type of intent to which you want to respond, you must include
      an
      ``<intent-filter>``
      that includes an
      ``<action>``
      element and, optionally, a
      ``<category>``
      element and/or a
      ``<data>``
      element. These elements specify the type of intent to which your
      activity can respond.

      For more information about how your activities can respond to
      intents, see the `Intents and Intent Filters <#>`__
      document.

      .. rubric:: Starting an Activity
         :name: StartingAnActivity

      You can start another activity by calling
      `startActivity() <#startActivity>`__,
      passing it an
      `Intent <#>`__
      that describes the activity you want to start. The intent
      specifies either the exact activity you want to start or describes
      the type of action you want to perform (and the system selects the
      appropriate activity for you, which can even be from a different
      application). An intent can also carry small amounts of data to be
      used by the activity that is started.

      When working within your own application, you'll often need to
      simply launch a known activity. You can do so by creating an
      intent that explicitly defines the activity you want to start,
      using the class name. For example, here's how one activity starts
      another activity named ``SignInActivity``:

      ::

         Intent intent = new Intent(this, SignInActivity.class);
         startActivity(intent);

      However, your application might also want to perform some action,
      such as send an email, text message, or status update, using data
      from your activity. In this case, your application might not have
      its own activities to perform such actions, so you can instead
      leverage the activities provided by other applications on the
      device, which can perform the actions for you. This is where
      intents are really valuable‚Äîyou can create an intent that
      describes an action you want to perform and the system launches
      the appropriate activity from another application. If there are
      multiple activities that can handle the intent, then the user can
      select which one to use. For example, if you want to allow the
      user to send an email message, you can create the following
      intent:

      ::

         Intent intent = new Intent(Intent.ACTION_SEND);
         intent.putExtra(Intent.EXTRA_EMAIL, recipientArray);
         startActivity(intent);

      The
      `EXTRA_EMAIL <#EXTRA_EMAIL>`__
      extra added to the intent is a string array of email addresses to
      which the email should be sent. When an email application responds
      to this intent, it reads the string array provided in the extra
      and places them in the "to" field of the email composition form.
      In this situation, the email application's activity starts and
      when the user is done, your activity resumes.

      .. rubric:: Starting an activity for a result
         :name: StartingAnActivityForResult

      Sometimes, you might want to receive a result from the activity
      that you start. In that case, start the activity by calling
      `startActivityForResult() <#startActivityForResult>`__
      (instead of
      `startActivity() <#startActivity>`__).
      To then receive the result from the subsequent activity, implement
      the
      `onActivityResult() <#onActivityResult>`__
      callback method. When the subsequent activity is done, it returns
      a result in an
      `Intent <#>`__ to
      your
      `onActivityResult() <#onActivityResult>`__
      method.

      For example, perhaps you want the user to pick one of their
      contacts, so your activity can do something with the information
      in that contact. Here's how you can create such an intent and
      handle the result:

      ::

         private void pickContact() {
             // Create an intent to "pick" a contact, as defined by the content provider URI
             Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);
             startActivityForResult(intent, PICK_CONTACT_REQUEST);
         }
         @Override
         protected void onActivityResult(int requestCode, int resultCode, Intent data) {
             // If the request went well (OK) and the request was PICK_CONTACT_REQUEST
             if (resultCode == Activity.RESULT_OK && requestCode == PICK_CONTACT_REQUEST) {
                 // Perform a query to the contact's content provider for the contact's name
                 Cursor cursor = getContentResolver().query(data.getData(),
                 new String[] {Contacts.DISPLAY_NAME}, null, null, null);
                 if (cursor.moveToFirst()) { // True if the cursor is not empty
                     int columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);
                     String name = cursor.getString(columnIndex);
                     // Do something with the selected contact's name...
                 }
             }
         }

      This example shows the basic logic you should use in your
      `onActivityResult() <#onActivityResult>`__
      method in order to handle an activity result. The first condition
      checks whether the request was successful‚Äîif it was, then the
      ``resultCode`` will be
      `RESULT_OK <#RESULT_OK>`__‚Äîand
      whether the request to which this result is responding is known‚Äîin
      this case, the ``requestCode`` matches the second parameter sent
      with
      `startActivityForResult() <#startActivityForResult>`__.
      From there, the code handles the activity result by querying the
      data returned in an
      `Intent <#>`__
      (the ``data`` parameter).

      What happens is, a
      `ContentResolver <#>`__
      performs a query against a content provider, which returns a
      `Cursor <#>`__
      that allows the queried data to be read. For more information, see
      the `Content Providers <#>`__
      document.

      For more information about using intents, see the `Intents and Intent Filters <#>`__
      document.

      .. rubric:: Shutting Down an Activity
         :name: ShuttingDown

      You can shut down an activity by calling its
      `finish() <#finish>`__
      method. You can also shut down a separate activity that you
      previously started by calling
      `finishActivity() <#finishActivity>`__.

      **Note:** In most cases, you should not explicitly finish an
      activity using these methods. As discussed in the following
      section about the activity lifecycle, the Android system manages
      the life of an activity for you, so you do not need to finish your
      own activities. Calling these methods could adversely affect the
      expected user experience and should only be used when you
      absolutely do not want the user to return to this instance of the
      activity.

      .. rubric:: Managing the Activity Lifecycle
         :name: Lifecycle

      Managing the lifecycle of your activities by implementing callback
      methods is crucial to developing a strong and flexible
      application. The lifecycle of an activity is directly affected by
      its association with other activities, its task and back stack.

      An activity can exist in essentially three states:

      *Resumed*
         The activity is in the foreground of the screen and has user
         focus. (This state is also sometimes referred to as "running".)
      *Paused*
         Another activity is in the foreground and has focus, but this
         one is still visible. That is, another activity is visible on
         top of this one and that activity is partially transparent or
         doesn't cover the entire screen. A paused activity is
         completely alive (the
         `Activity <#>`__
         object is retained in memory, it maintains all state and member
         information, and remains attached to the window manager), but
         can be killed by the system in extremely low memory situations.
      *Stopped*
         The activity is completely obscured by another activity (the
         activity is now in the "background"). A stopped activity is
         also still alive (the
         `Activity <#>`__
         object is retained in memory, it maintains all state and member
         information, but is *not* attached to the window manager).
         However, it is no longer visible to the user and it can be
         killed by the system when memory is needed elsewhere.

      If an activity is paused or stopped, the system can drop it from
      memory either by asking it to finish (calling its
      `finish() <#finish>`__
      method), or simply killing its process. When the activity is
      opened again (after being finished or killed), it must be created
      all over.

      .. rubric:: Implementing the lifecycle callbacks
         :name: ImplementingLifecycleCallbacks

      When an activity transitions into and out of the different states
      described above, it is notified through various callback methods.
      All of the callback methods are hooks that you can override to do
      appropriate work when the state of your activity changes. The
      following skeleton activity includes each of the fundamental
      lifecycle methods:

      ::

         public class ExampleActivity extends Activity {
             @Override
             public void onCreate(Bundle savedInstanceState) {
                 super.onCreate(savedInstanceState);
                 // The activity is being created.
             }
             @Override
             protected void onStart() {
                 super.onStart();
                 // The activity is about to become visible.
             }
             @Override
             protected void onResume() {
                 super.onResume();
                 // The activity has become visible (it is now "resumed").
             }
             @Override
             protected void onPause() {
                 super.onPause();
                 // Another activity is taking focus (this activity is about to be "paused").
             }
             @Override
             protected void onStop() {
                 super.onStop();
                 // The activity is no longer visible (it is now "stopped")
             }
             @Override
             protected void onDestroy() {
                 super.onDestroy();
                 // The activity is about to be destroyed.
             }
         }

      **Note:** Your implementation of these lifecycle methods must
      always call the superclass implementation before doing any work,
      as shown in the examples above.

      Taken together, these methods define the entire lifecycle of an
      activity. By implementing these methods, you can monitor three
      nested loops in the activity lifecycle:

      -  The **entire lifetime** of an activity happens between the call
         to
         `onCreate() <#onCreate>`__
         and the call to
         `onDestroy() <#onDestroy>`__.
         Your activity should perform setup of "global" state (such as
         defining layout) in
         `onCreate() <#onCreate>`__,
         and release all remaining resources in
         `onDestroy() <#onDestroy>`__.
         For example, if your activity has a thread running in the
         background to download data from the network, it might create
         that thread in
         `onCreate() <#onCreate>`__
         and then stop the thread in
         `onDestroy() <#onDestroy>`__.

      -  The **visible lifetime** of an activity happens between the
         call to
         `onStart() <#onStart>`__
         and the call to
         `onStop() <#onStop>`__.
         During this time, the user can see the activity on-screen and
         interact with it. For example,
         `onStop() <#onStop>`__
         is called when a new activity starts and this one is no longer
         visible. Between these two methods, you can maintain resources
         that are needed to show the activity to the user. For example,
         you can register a
         `BroadcastReceiver <#>`__
         in
         `onStart() <#onStart>`__
         to monitor changes that impact your UI, and unregister it in
         `onStop() <#onStop>`__
         when the user can no longer see what you are displaying. The
         system might call
         `onStart() <#onStart>`__
         and
         `onStop() <#onStop>`__
         multiple times during the entire lifetime of the activity, as
         the activity alternates between being visible and hidden to the
         user.

      -  The **foreground lifetime** of an activity happens between the
         call to
         `onResume() <#onResume>`__
         and the call to
         `onPause() <#onPause>`__.
         During this time, the activity is in front of all other
         activities on screen and has user input focus. An activity can
         frequently transition in and out of the foreground‚Äîfor example,
         `onPause() <#onPause>`__
         is called when the device goes to sleep or when a dialog
         appears. Because this state can transition often, the code in
         these two methods should be fairly lightweight in order to
         avoid slow transitions that make the user wait.

      Figure 1 illustrates these loops and the paths an activity might
      take between states. The rectangles represent the callback methods
      you can implement to perform operations when the activity
      transitions between states.

      .. image:: https://devdoc.net/android/Android-r15/images/activity_lifecycle.png


      **Figure 1.** The activity lifecycle.

      The same lifecycle callback methods are listed in table 1, which
      describes each of the callback methods in more detail and locates
      each one within the activity's overall lifecycle, including
      whether the system can kill the activity after the callback method
      completes.

      **Table 1.** A summary of the activity lifecycle's callback
      methods.

      .. list-table::
         :widths: 12 12 12 12 12 12
         :header-rows: 1

         - 

            - Method
            - 
            - 
            - Description
            - Killable after?
            - Next
         - 

            - `onCreate() <#onCreate>`__
            - 
            - 
            - Called when the activity is first created. This is where
               you should do all of your normal static set up ‚Äî create
               views, bind data to lists, and so on. This method is
               passed a Bundle object containing the activity's previous
               state, if that state was captured (see `Saving Activity State <#actstate>`__, later).
               Always followed by ``onStart()``.
            - No
            - ``onStart()``
         - 

            -     
            - `onRestart() <#onRestart>`__
            - 
            - Called after the activity has been stopped, just prior to
               it being started again.
               Always followed by ``onStart()``
            - No
            - ``onStart()``
         - 

            - 
            - `onStart() <#onStart>`__
            - 
            - Called just before the activity becomes visible to the
               user.
               Followed by ``onResume()`` if the activity comes to the
               foreground, or ``onStop()`` if it becomes hidden.
            - No
            - ``onResume()``
               or
               ``onStop()``
         - 

            - 
            -     
            - `onResume() <#onResume>`__
            - Called just before the activity starts interacting with
               the user. At this point the activity is at the top of the
               activity stack, with user input going to it.
               Always followed by ``onPause()``.
            - No
            - ``onPause()``
         - 

            - 
            - 
            - `onPause() <#onPause>`__
            - Called when the system is about to start resuming another
               activity. This method is typically used to commit unsaved
               changes to persistent data, stop animations and other
               things that may be consuming CPU, and so on. It should do
               whatever it does very quickly, because the next activity
               will not be resumed until it returns.
               Followed either by ``onResume()`` if the activity returns
               back to the front, or by ``onStop()`` if it becomes
               invisible to the user.
            - **Yes**
            - ``onResume()``
               or
               ``onStop()``
         - 

            - 
            - `onStop() <#onStop>`__
            - 
            - Called when the activity is no longer visible to the user.
               This may happen because it is being destroyed, or because
               another activity (either an existing one or a new one)
               has been resumed and is covering it.
               Followed either by ``onRestart()`` if the activity is
               coming back to interact with the user, or by
               ``onDestroy()`` if this activity is going away.
            - **Yes**
            - ``onRestart()``
               or
               ``onDestroy()``
         - 

            - `onDestroy() <#onDestroy>`__
            - 
            - 
            - Called before the activity is destroyed. This is the final
               call that the activity will receive. It could be called
               either because the activity is finishing (someone called
               `finish() <#finish>`__
               on it), or because the system is temporarily destroying
               this instance of the activity to save space. You can
               distinguish between these two scenarios with the
               `isFinishing() <#isFinishing>`__
               method.
            - **Yes**
            - *nothing*

      The column labeled "Killable after?" indicates whether or not the
      system can kill the process hosting the activity at any time
      *after the method returns*, without executing another line of the
      activity's code. Three methods are marked "yes":
      (`onPause() <#onPause()>`__,
      `onStop() <#onStop>`__,
      and
      `onDestroy() <#onDestroy>`__).
      Because
      `onPause() <#onPause>`__
      is the first of the three, once the activity is created,
      `onPause() <#onPause>`__
      is the last method that's guaranteed to be called before the
      process *can* be killed‚Äîif the system must recover memory in an
      emergency, then
      `onStop() <#onStop>`__
      and
      `onDestroy() <#onDestroy>`__
      might not be called. Therefore, you should use
      `onPause() <#onPause>`__
      to write crucial persistent data (such as user edits) to storage.
      However, you should be selective about what information must be
      retained during
      `onPause() <#onPause>`__,
      because any blocking procedures in this method block the
      transition to the next activity and slow the user experience.

      Methods that are marked "No" in the **Killable** column protect
      the process hosting the activity from being killed from the moment
      they are called. Thus, an activity is killable from the time
      `onPause() <#onPause>`__
      returns to the time
      `onResume() <#onResume>`__
      is called. It will not again be killable until
      `onPause() <#onPause>`__
      is again called and returns.

      **Note:** An activity that's not technically "killable" by this
      definition in table 1 might still be killed by the system‚Äîbut that
      would happen only in extreme circumstances when there is no other
      recourse. When an activity might be killed is discussed more in
      the `Processes and Threading <#>`__
      document.

      .. rubric:: Saving activity state
         :name: SavingActivityState

      The introduction to `Managing the Activity Lifecycle <#Lifecycle>`__ briefly mentions that when an activity
      is paused or stopped, the state of the activity is retained. This
      is true because the
      `Activity <#>`__
      object is still held in memory when it is paused or stopped‚Äîall
      information about its members and current state is still alive.
      Thus, any changes the user made within the activity are retained
      so that when the activity returns to the foreground (when it
      "resumes"), those changes are still there.

      However, when the system destroys an activity in order to recover
      memory, the
      `Activity <#>`__
      object is destroyed, so the system cannot simply resume it with
      its state intact. Instead, the system must recreate the
      `Activity <#>`__
      object if the user navigates back to it. Yet, the user is unaware
      that the system destroyed the activity and recreated it and, thus,
      probably expects the activity to be exactly as it was. In this
      situation, you can ensure that important information about the
      activity state is preserved by implementing an additional callback
      method that allows you to save information about the state of your
      activity:
      `onSaveInstanceState() <#onSaveInstanceState>`__.

      The system calls
      `onSaveInstanceState() <#onSaveInstanceState>`__
      before making the activity vulnerable to destruction. The system
      passes this method a
      `Bundle <#>`__ in
      which you can save state information about the activity as
      name-value pairs, using methods such as
      `putString() <#putString>`__
      and
      `putInt() <#putInt>`__.
      Then, if the system kills your application process and the user
      navigates back to your activity, the system recreates the activity
      and passes the
      `Bundle <#>`__ to both
      `onCreate() <#onCreate>`__
      and
      `onRestoreInstanceState() <#onRestoreInstanceState>`__.
      Using either of these methods, you can extract your saved state
      from the
      `Bundle <#>`__ and
      restore the activity state. If there is no state information to
      restore, then the
      `Bundle <#>`__ passed
      to you is null (which is the case when the activity is created for
      the first time).

      .. image:: https://devdoc.net/android/Android-r15/images/fundamentals/restore_instance.png

      **Figure 2.** The two ways in which an activity returns to user
      focus with its state intact: either the activity is destroyed,
      then recreated and the activity must restore the previously saved
      state, or the activity is stopped, then resumed and the activity
      state remains intact.

      **Note:** There's no guarantee that
      `onSaveInstanceState() <#onSaveInstanceState>`__
      will be called before your activity is destroyed, because there
      are cases in which it won't be necessary to save the state (such
      as when the user leaves your activity using the *Back* button,
      because the user is explicitly closing the activity). If the
      system calls
      `onSaveInstanceState() <#onSaveInstanceState>`__,
      it does so before
      `onStop() <#onStop>`__
      and possibly before
      `onPause() <#onPause>`__.

      However, even if you do nothing and do not implement
      `onSaveInstanceState() <#onSaveInstanceState>`__,
      some of the activity state is restored by the
      `Activity <#>`__
      class's default implementation of
      `onSaveInstanceState() <#onSaveInstanceState>`__.
      Specifically, the default implementation calls the corresponding
      `onSaveInstanceState() <#onSaveInstanceState>`__
      method for every
      `View <#>`__ in the
      layout, which allows each view to provide information about itself
      that should be saved. Almost every widget in the Android framework
      implements this method as appropriate, such that any visible
      changes to the UI are automatically saved and restored when your
      activity is recreated. For example, the
      `EditText <#>`__
      widget saves any text entered by the user and the
      `CheckBox <#>`__
      widget saves whether it's checked or not. The only work required
      by you is to provide a unique ID (with the
      `android:id <#idvalue>`__
      attribute) for each widget you want to save its state. If a widget
      does not have an ID, then the system cannot save its state.

      .. container:: sidebox-wrapper

         .. container:: sidebox

            You can also explicitly stop a view in your layout from
            saving its state by setting the
            `android:saveEnabled <#saveEnabled>`__
            attribute to ``"false"`` or by calling the
            `setSaveEnabled() <#setSaveEnabled>`__
            method. Usually, you should not disable this, but you might
            if you want to restore the state of the activity UI
            differently.

      Although the default implementation of
      `onSaveInstanceState() <#onSaveInstanceState>`__
      saves useful information about your activity's UI, you still might
      need to override it to save additional information. For example,
      you might need to save member values that changed during the
      activity's life (which might correlate to values restored in the
      UI, but the members that hold those UI values are not restored, by
      default).

      Because the default implementation of
      `onSaveInstanceState() <#onSaveInstanceState>`__
      helps save the state of the UI, if you override the method in
      order to save additional state information, you should always call
      the superclass implementation of
      `onSaveInstanceState() <#onSaveInstanceState>`__
      before doing any work. Likewise, you should also call the
      supercall implementation of
      `onRestoreInstanceState() <#onRestoreInstanceState>`__
      if you override it, so the default implementation can restore view
      states.

      **Note:** Because
      `onSaveInstanceState() <#onSaveInstanceState>`__
      is not guaranteed to be called, you should use it only to record
      the transient state of the activity (the state of the UI)‚Äîyou
      should never use it to store persistent data. Instead, you should
      use
      `onPause() <#onPause>`__
      to store persistent data (such as data that should be saved to a
      database) when the user leaves the activity.

      A good way to test your application's ability to restore its state
      is to simply rotate the device so that the screen orientation
      changes. When the screen orientation changes, the system destroys
      and recreates the activity in order to apply alternative resources
      that might be available for the new screen configuration. For this
      reason alone, it's very important that your activity completely
      restores its state when it is recreated, because users regularly
      rotate the screen while using applications.

      .. rubric:: Handling configuration changes
         :name: ConfigurationChanges

      Some device configurations can change during runtime (such as
      screen orientation, keyboard availability, and language). When
      such a change occurs, Android recreates the running activity (the
      system calls
      `onDestroy() <#onDestroy>`__,
      then immediately calls
      `onCreate() <#onCreate>`__).
      This behavior is designed to help your application adapt to new
      configurations by automatically reloading your application with
      alternative resources that you've provided (such as different
      layouts for different screen orientations and sizes).

      If you properly design your activity to handle a restart due to a
      screen orientation change and restore the activity state as
      described above, your application will be more resilient to other
      unexpected events in the activity lifecycle.

      The best way to handle such a restart is to save and restore the
      state of your activity using
      `onSaveInstanceState() <#onSaveInstanceState>`__
      and
      `onRestoreInstanceState() <#onRestoreInstanceState>`__
      (or
      `onCreate() <#onCreate>`__),
      as discussed in the previous section.

      For more information about configuration changes that happen at
      runtime and how you can handle them, read the guide to `Handling Runtime Changes <#>`__.

      .. rubric:: Coordinating activities
         :name: CoordinatingActivities

      When one activity starts another, they both experience lifecycle
      transitions. The first activity pauses and stops (though, it won't
      stop if it's still visible in the background), while the other
      activity is created. In case these activities share data saved to
      disc or elsewhere, it's important to understand that the first
      activity is not completely stopped before the second one is
      created. Rather, the process of starting the second one overlaps
      with the process of stopping the first one.

      The order of lifecycle callbacks is well defined, particularly
      when the two activities are in the same process and one is
      starting the other. Here's the order of operations that occur when
      Activity A starts Acivity B:

      #. Activity A's
         `onPause() <#onPause>`__
         method executes.
      #. Activity B's
         `onCreate() <#onCreate>`__,
         `onStart() <#onStart>`__,
         and
         `onResume() <#onResume>`__
         methods execute in sequence. (Activity B now has user focus.)
      #. Then, if Activity A is no longer visible on screen, its
         `onStop() <#onStop>`__
         method executes.

      This predictable sequence of lifecycle callbacks allows you to
      manage the transition of information from one activity to another.
      For example, if you must write to a database when the first
      activity stops so that the following activity can read it, then
      you should write to the database during
      `onPause() <#onPause>`__
      instead of during
      `onStop() <#onStop>`__.

   `‚Üë Go to top <#top>`__





