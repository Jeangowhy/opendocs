
# package encoding

    import "encoding"

Package encoding defines interfaces shared by other packages that convert data to and from byte-level and textual representations. Packages that check for these interfaces include encoding/gob, encoding/json, and encoding/xml. As a result, implementing an interface once can make a type useful in multiple encodings. Standard types that implement these interfaces include time.Time and net.IP. The interfaces come in pairs that produce and consume encoded data.


## type BinaryMarshaler

    type BinaryMarshaler interface {
        MarshalBinary() (data []byte, err error)
    }

BinaryMarshaler is the interface implemented by an object that can marshal itself into a binary form.

MarshalBinary encodes the receiver into a binary form and returns the result.

## type BinaryUnmarshaler

    type BinaryUnmarshaler interface {
        UnmarshalBinary(data []byte) error
    }

BinaryUnmarshaler is the interface implemented by an object that can unmarshal a binary representation of itself.

UnmarshalBinary must be able to decode the form generated by MarshalBinary. UnmarshalBinary must copy the data if it wishes to retain the data after returning.

## type TextMarshaler

    type TextMarshaler interface {
        MarshalText() (text []byte, err error)
    }

TextMarshaler is the interface implemented by an object that can marshal itself into a textual form.

MarshalText encodes the receiver into UTF-8-encoded text and returns the result.

## type TextUnmarshaler

    type TextUnmarshaler interface {
        UnmarshalText(text []byte) error
    }

TextUnmarshaler is the interface implemented by an object that can unmarshal a textual representation of itself.

UnmarshalText must be able to decode the form generated by MarshalText. UnmarshalText must copy the text if it wishes to retain the text after returning.


    ascii85 Package ascii85 implements the ascii85 data encoding as used in the btoa tool and Adobe's PostScript and PDF document formats.
    asn1    Package asn1 implements parsing of DER-encoded ASN.1 data structures, as defined in ITU-T Rec X.690.
    base32  Package base32 implements base32 encoding as specified by RFC 4648.
    base64  Package base64 implements base64 encoding as specified by RFC 4648.
    binary  Package binary implements simple translation between numbers and byte sequences and encoding and decoding of varints.
    csv Package csv reads and writes comma-separated values (CSV) files.
    gob Package gob manages streams of gobs - binary values exchanged between an Encoder (transmitter) and a Decoder (receiver).
    hex Package hex implements hexadecimal encoding and decoding.
    json    Package json implements encoding and decoding of JSON as defined in RFC 7159.
    pem Package pem implements the PEM data encoding, which originated in Privacy Enhanced Mail.
    xml Package xml implements a simple XML 1.0 parser that understands XML name spaces.

# package sql
[database sql](https://godoc.org/database/sql)

    import "database/sql"

Package sql provides a generic interface around SQL (or SQL-like) databases.

The sql package must be used in conjunction with a database driver. See https://golang.org/s/sqldrivers for a list of drivers.

Drivers that do not support context cancelation will not return until after the query is completed.

For usage examples, see the wiki page at https://golang.org/s/sqlwiki.

Example (OpenDBCLI)

    package main

    import (
        "context"
        "database/sql"
        "flag"
        "log"
        "os"
        "os/signal"
        "time"
    )

    var pool *sql.DB // Database connection pool.

    func main() {
        id := flag.Int64("id", 0, "person ID to find")
        dsn := flag.String("dsn", os.Getenv("DSN"), "connection data source name")
        flag.Parse()

        if len(*dsn) == 0 {
            log.Fatal("missing dsn flag")
        }
        if *id == 0 {
            log.Fatal("missing person ID")
        }
        var err error

        // Opening a driver typically will not attempt to connect to the database.
        pool, err = sql.Open("driver-name", *dsn)
        if err != nil {
            // This will not be a connection error, but a DSN parse error or
            // another initialization error.
            log.Fatal("unable to use data source name", err)
        }
        defer pool.Close()

        pool.SetConnMaxLifetime(0)
        pool.SetMaxIdleConns(3)
        pool.SetMaxOpenConns(3)

        ctx, stop := context.WithCancel(context.Background())
        defer stop()

        appSignal := make(chan os.Signal, 3)
        signal.Notify(appSignal, os.Interrupt)

        go func() {
            select {
            case <-appSignal:
                stop()
            }
        }()

        Ping(ctx)

        Query(ctx, *id)
    }

    // Ping the database to verify DSN provided by the user is valid and the
    // server accessible. If the ping fails exit the program with an error.
    func Ping(ctx context.Context) {
        ctx, cancel := context.WithTimeout(ctx, 1*time.Second)
        defer cancel()

        if err := pool.PingContext(ctx); err != nil {
            log.Fatalf("unable to connect to database: %v", err)
        }
    }

    // Query the database for the information requested and prints the results.
    // If the query fails exit the program with an error.
    func Query(ctx context.Context, id int64) {
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        var name string
        err := pool.QueryRowContext(ctx, "select p.name from people as p where p.id = :id;", sql.Named("id", id)).Scan(&name)
        if err != nil {
            log.Fatal("unable to execute search query", err)
        }
        log.Println("name=", name)
    }

Example (OpenDBService)

    package main

    import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "time"
    )

    func main() {
        // Opening a driver typically will not attempt to connect to the database.
        db, err := sql.Open("driver-name", "database=test1")
        if err != nil {
            // This will not be a connection error, but a DSN parse error or
            // another initialization error.
            log.Fatal(err)
        }
        db.SetConnMaxLifetime(0)
        db.SetMaxIdleConns(50)
        db.SetMaxOpenConns(50)

        s := &Service{db: db}

        http.ListenAndServe(":8080", s)
    }

    type Service struct {
        db *sql.DB
    }

    func (s *Service) ServeHTTP(w http.ResponseWriter, r *http.Request) {
        db := s.db
        switch r.URL.Path {
        default:
            http.Error(w, "not found", http.StatusNotFound)
            return
        case "/healthz":
            ctx, cancel := context.WithTimeout(r.Context(), 1*time.Second)
            defer cancel()

            err := s.db.PingContext(ctx)
            if err != nil {
                http.Error(w, fmt.Sprintf("db down: %v", err), http.StatusFailedDependency)
                return
            }
            w.WriteHeader(http.StatusOK)
            return
        case "/quick-action":
            // This is a short SELECT. Use the request context as the base of
            // the context timeout.
            ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
            defer cancel()

            id := 5
            org := 10
            var name string
            err := db.QueryRowContext(ctx, `
    select
        p.name
    from
        people as p
        join organization as o on p.organization = o.id
    where
        p.id = :id
        and o.id = :org
    ;`,
                sql.Named("id", id),
                sql.Named("org", org),
            ).Scan(&name)
            if err != nil {
                if err == sql.ErrNoRows {
                    http.Error(w, "not found", http.StatusNotFound)
                    return
                }
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
            }
            io.WriteString(w, name)
            return
        case "/long-action":
            // This is a long SELECT. Use the request context as the base of
            // the context timeout, but give it some time to finish. If
            // the client cancels before the query is done the query will also
            // be canceled.
            ctx, cancel := context.WithTimeout(r.Context(), 60*time.Second)
            defer cancel()

            var names []string
            rows, err := db.QueryContext(ctx, "select p.name from people as p where p.active = true;")
            if err != nil {
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
            }

            for rows.Next() {
                var name string
                err = rows.Scan(&name)
                if err != nil {
                    break
                }
                names = append(names, name)
            }
            // Check for errors during rows "Close".
            // This may be more important if multiple statements are executed
            // in a single batch and rows were written as well as read.
            if closeErr := rows.Close(); closeErr != nil {
                http.Error(w, closeErr.Error(), http.StatusInternalServerError)
                return
            }

            // Check for row scan error.
            if err != nil {
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
            }

            // Check for errors during row iteration.
            if err = rows.Err(); err != nil {
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
            }

            json.NewEncoder(w).Encode(names)
            return
        case "/async-action":
            // This action has side effects that we want to preserve
            // even if the client cancels the HTTP request part way through.
            // For this we do not use the http request context as a base for
            // the timeout.
            ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
            defer cancel()

            var orderRef = "ABC123"
            tx, err := db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})
            _, err = tx.ExecContext(ctx, "stored_proc_name", orderRef)

            if err != nil {
                tx.Rollback()
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
            }
            err = tx.Commit()
            if err != nil {
                http.Error(w, "action in unknown state, check state before attempting again", http.StatusInternalServerError)
                return
            }
            w.WriteHeader(http.StatusOK)
            return
        }
    }


## sql.Drivers() []string
## sql.Register(name string, driver driver.Driver)

## type ColumnType
### ColumnType.DatabaseTypeName() string
### ColumnType.DecimalSize() (precision, scale int64, ok bool)
### ColumnType.Length() (length int64, ok bool)
### ColumnType.Name() string
### ColumnType.Nullable() (nullable, ok bool)
### ColumnType.ScanType() reflect.Type

## type Conn
### Conn.BeginTx(ctx context.Context, opts `*TxOptions`) (`*Tx`, error)
### Conn.Close() error
### Conn.ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)
### Conn.PingContext(ctx context.Context) error
### Conn.PrepareContext(ctx context.Context, query string) (`*Stmt`, error)
### Conn.QueryContext(ctx context.Context, query string, args ...interface{}) (`*Rows`, error)
### Conn.QueryRowContext(ctx context.Context, query string, args ...interface{}) `*Row`

## type DB
### sql.Open(driverName, dataSourceName string) (`*DB`, error)
### sql.OpenDB(c driver.Connector) `*DB`
### DB.Begin() (`*Tx`, error)
### DB.BeginTx(ctx context.Context, opts `*TxOptions`) (`*Tx`, error)
### DB.Close() error
### DB.Conn(ctx context.Context) (`*Conn`, error)
### DB.Driver() driver.Driver
### DB.Exec(query string, args ...interface{}) (Result, error)
### DB.ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)
### DB.Ping() error
### DB.PingContext(ctx context.Context) error
### DB.Prepare(query string) (`*Stmt`, error)
### DB.PrepareContext(ctx context.Context, query string) (`*Stmt`, error)
### DB.Query(query string, args ...interface{}) (`*Rows`, error)
### DB.QueryContext(ctx context.Context, query string, args ...interface{}) (`*Rows`, error)
### DB.QueryRow(query string, args ...interface{}) `*Row`
### DB.QueryRowContext(ctx context.Context, query string, args ...interface{}) `*Row`
### DB.SetConnMaxLifetime(d time.Duration)
### DB.SetMaxIdleConns(n int)
### DB.SetMaxOpenConns(n int)
### DB.Stats() DBStats

## type DBStats

## type IsolationLevel
### sql.String() string

## type NamedArg
### sql.Named(name string, value interface{}) NamedArg

## type NullBool
### NullBool. Scan(value interface{}) error
### NullBool.Value() (driver.Value, error)

## type NullFloat64
### NullFloat64.Scan(value interface{}) error
### NullFloat64.Value() (driver.Value, error)

## type NullInt64
### NullInt64.Scan(value interface{}) error
### NullInt64.Value() (driver.Value, error)

## type NullString
### NullString.Scan(value interface{}) error
### NullString.Value() (driver.Value, error)

## type Out

## type RawBytes

## type Result

## type Row
### Row.Scan(dest ...interface{}) error
Scan copies the columns from the matched row into the values pointed at by dest. See the documentation on Rows.Scan for details. If more than one row matches the query, Scan uses the first row and discards the rest. If no row matches the query, Scan returns ErrNoRows.

## type Rows
### Rows.Close() error
### Rows.ColumnTypes() (`[]*ColumnType`, error)
### Rows.Columns() ([]string, error)
### Rows.Err() error
### Rows.Next() bool
### Rows.NextResultSet() bool
### Rows.Scan(dest ...interface{}) error
Scan copies the columns in the current row into the values pointed at by dest. The number of values in dest must be the same as the number of columns in Rows.

Scan converts columns read from the database into the following common Go types and special types provided by the sql package:

    *string
    *[]byte
    *int, *int8, *int16, *int32, *int64
    *uint, *uint8, *uint16, *uint32, *uint64
    *bool
    *float32, *float64
    *interface{}
    *RawBytes
    *Rows (cursor value)

any type implementing Scanner (see Scanner docs)
In the most simple case, if the type of the value from the source column is an integer, bool or string type T and dest is of type `*T`, Scan simply assigns the value through the pointer.

Scan also converts between string and numeric types, as long as no information would be lost. While Scan stringifies all numbers scanned from numeric database columns into `*string`, scans into numeric types are checked for overflow. For example, a float64 with value 300 or a string with value "300" can scan into a uint16, but not into a uint8, though float64(255) or "255" can scan into a uint8. One exception is that scans of some float64 numbers to strings may lose information when stringifying. In general, scan floating point columns into `*float64`.

If a dest argument has type `*[]byte`, Scan saves in that argument a copy of the corresponding data. The copy is owned by the caller and can be modified and held indefinitely. The copy can be avoided by using an argument of type `*RawBytes` instead; see the documentation for RawBytes for restrictions on its use.

If an argument has type `*interface{}`, Scan copies the value provided by the underlying driver without conversion. When scanning from a source value of type `[]byte` to `*interface{}`, a copy of the slice is made and the caller owns the result.

Source values of type time.Time may be scanned into values of type `*time.Time`, `*interface{}`, `*string`, or `*[]byte`. When converting to the latter two, time.RFC3339Nano is used.

Source values of type bool may be scanned into types `*bool`, `*interface{}`, `*string`, `*[]byte`, or `*RawBytes`.

For scanning into `*bool`, the source may be true, false, 1, 0, or string inputs parseable by strconv.ParseBool.

Scan can also convert a cursor returned from a query, such as "select cursor(select * from my_table) from dual", into a `*Rows` value that can itself be scanned from. The parent select query will close any cursor `*Rows` if the parent `*Rows` is closed.

## type Scanner

    type Scanner interface {
        // Scan assigns a value from a database driver.
        //
        // The src value will be of one of the following types:
        //
        //    int64
        //    float64
        //    bool
        //    []byte
        //    string
        //    time.Time
        //    nil - for NULL values
        //
        // An error should be returned if the value cannot be stored
        // without loss of information.
        //
        // Reference types such as []byte are only valid until the next call to Scan
        // and should not be retained. Their underlying memory is owned by the driver.
        // If retention is necessary, copy their values before the next call to Scan.
        Scan(src interface{}) error
    }

Scanner is an interface used by Scan.

## type Stmt
Stmt is a prepared statement. A Stmt is safe for concurrent use by multiple goroutines.

If a Stmt is prepared on a Tx or Conn, it will be bound to a single underlying connection forever. If the Tx or Conn closes, the Stmt will become unusable and all operations will return an error. If a Stmt is prepared on a DB, it will remain usable for the lifetime of the DB. When the Stmt needs to execute on a new underlying connection, it will prepare itself on the new connection automatically.

Example

    // In normal use, create one Stmt when your process starts.
    stmt, err := db.PrepareContext(ctx, "SELECT username FROM users WHERE id = ?")
    if err != nil {
        log.Fatal(err)
    }
    defer stmt.Close()

    // Then reuse it each time you need to issue the query.
    id := 43
    var username string
    err = stmt.QueryRowContext(ctx, id).Scan(&username)
    switch {
    case err == sql.ErrNoRows:
        log.Fatalf("no user with id %d", id)
    case err != nil:
        log.Fatal(err)
    default:
        log.Printf("username is %s\n", username)
    }

### Stmt.Close() error
### Stmt.Exec(args ...interface{}) (Result, error)
### Stmt.ExecContext(ctx context.Context, args ...interface{}) (Result, error)
### Stmt.Query(args ...interface{}) (`*Rows`, error)
### Stmt.QueryContext(ctx context.Context, args ...interface{}) (`*Rows`, error)
### Stmt.QueryRow(args ...interface{}) `*Row`
### Stmt.QueryRowContext(ctx context.Context, args ...interface{}) `*Row`

## type Tx
### Tx.Commit() error
### Tx.Exec(query string, args ...interface{}) (Result, error)
### Tx.ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)
### Tx.Prepare(query string) (`*Stmt`, error)
### Tx.PrepareContext(ctx context.Context, query string) (`*Stmt`, error)
### Tx.Query(query string, args ...interface{}) (`*Rows`, error)
### Tx.QueryContext(ctx context.Context, query string, args ...interface{}) (`*Rows`, error)
### Tx.QueryRow(query string, args ...interface{}) `*Row`
### Tx.QueryRowContext(ctx context.Context, query string, args ...interface{}) `*Row`
### Tx.Rollback() error
### Tx.Stmt(stmt `*Stmt`) `*Stmt`
### Tx.StmtContext(ctx context.Context, stmt `*Stmt`) `*Stmt`

## type TxOptions




# fmt package
[fmt](https://godoc.org/fmt)

## fmt.Errorf(format string, a ...interface{}) error
## fmt.Fprint(w io.Writer, a ...interface{}) (n int, err error)
## fmt.Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
## fmt.Fprintln(w io.Writer, a ...interface{}) (n int, err error)
## fmt.Fscan(r io.Reader, a ...interface{}) (n int, err error)
## fmt.Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
## fmt.Fscanln(r io.Reader, a ...interface{}) (n int, err error)
## fmt.Print(a ...interface{}) (n int, err error)
## fmt.Printf(format string, a ...interface{}) (n int, err error)
## fmt.Println(a ...interface{}) (n int, err error)
## fmt.Scan(a ...interface{}) (n int, err error)
## fmt.Scanf(format string, a ...interface{}) (n int, err error)
## fmt.Scanln(a ...interface{}) (n int, err error)
## fmt.Sprint(a ...interface{}) string
## fmt.Sprintf(format string, a ...interface{}) string
## fmt.Sprintln(a ...interface{}) string
## fmt.Sscan(str string, a ...interface{}) (n int, err error)
## fmt.Sscanf(str string, format string, a ...interface{}) (n int, err error)
## fmt.Sscanln(str string, a ...interface{}) (n int, err error)

仿 C 风格 printf and scanf 的格式化 I/O 模块，简化版。

General:

    %v  the value in a default format when printing structs, the plus flag (%+v) adds field names
    %#v a Go-syntax representation of the value, example %#+v
    %T  a Go-syntax representation of the type of the value
    %%  a literal percent sign; consumes no value

Boolean:

    %t  the word true or false

Integer:

    %b  base 2
    %c  the character represented by the corresponding Unicode code point
    %d  base 10
    %o  base 8
    %q  a single-quoted character literal safely escaped with Go syntax.
    %x  base 16, with lower-case letters for a-f
    %X  base 16, with upper-case letters for A-F
    %U  Unicode format: U+1234; same as "U+%04X"

Floating-point and complex constituents:

    %b  decimalless scientific notation with exponent a power of two,
        in the manner of strconv.FormatFloat with the 'b' format,
        e.g. -123456p-78
    %e  scientific notation, e.g. -1.234456e+78
    %E  scientific notation, e.g. -1.234456E+78
    %f  decimal point but no exponent, e.g. 123.456
    %F  synonym for %f
    %g  %e for large exponents, %f otherwise. Precision is discussed below.
    %G  %E for large exponents, %F otherwise

String and slice of bytes (treated equivalently with these verbs):

    %s  the uninterpreted bytes of the string or slice
    %q  a double-quoted string safely escaped with Go syntax
    %x  base 16, lower-case, two characters per byte
    %X  base 16, upper-case, two characters per byte

Slice:

    %p  address of 0th element in base 16 notation, with leading 0x

Pointer:

    %p  base 16 notation, with leading 0x

The %b, %d, %o, %x and %X verbs also work with pointers,
formatting the value exactly as if it were an integer.
The default format for %v is:

    bool:                    %t
    int, int8 etc.:          %d
    uint, uint8 etc.:        %d, %#x if printed with %#v
    float32, complex64, etc: %g
    string:                  %s
    chan:                    %p
    pointer:                 %p

For compound objects, the elements are printed using these rules, recursively, laid out like this:

    struct:             {field0 field1 ...}
    array, slice:       [elem0 elem1 ...]
    maps:               map[key1:value1 key2:value2 ...]
    pointer to above:   &{}, &[], &map[]

Width is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. Examples:

    %f     default width, default precision
    %9f    width 9, default precision
    %.2f   default width, precision 2
    %9.2f  width 9, precision 2
    %9.f   width 9, precision 0



# package time 时间和日期包
[time](https://godoc.org/time)

## time.Time

time 包为我们提供了一个数据类型 time.Time（作为值使用）以及显示和测量时间和日期的功能函数。

    start := time.Now()
    ... operation that takes 20 milliseconds ...
    t := time.Now()
    elapsed := t.Sub(start)

    timestamp, _ := time.Parse("2006-01-02 15:04:05", "2019-09-04 12:00:00")
    timestamp, _ = time.Parse("2006-01-02", "2019-09-04")

## time.After(d Duration) <-chan Time
## time.Sleep(d Duration)
## time.Tick(d Duration) <-chan Time

## type Duration

### time.ParseDuration(s string) (Duration, error)
### time.Since(t Time) Duration
### time.Until(t Time) Duration
### duration.Hours() float64
### duration.Minutes() float64
### duration.Nanoseconds() int64
### duration.Round(m Duration) Duration
### duration.Seconds() float64
### duration.String() string
### duration.Truncate(m Duration) Duration

## type Location

### time.FixedZone(name string, offset int) `*Location`
### time.LoadLocation(name string) (`*Location`, error)
### time.LoadLocationFromTZData(name string, data []byte) (`*Location`, error)
### Location.String() string

## type Month

### Month.String() string

## type ParseError

### ParseError.Error() string

## type Ticker

## time.NewTicker(d Duration) `*Ticker`
## Ticker.Stop()

## type Time

### time.Date(year int, month Month, day, hour, min, sec, nsec int, loc `*Location`) Time
### time.Now() Time
### time.Parse(layout, value string) (Time, error)
### time.ParseInLocation(layout, value string, loc `*Location`) (Time, error)
### time.Unix(sec int64, nsec int64) Time
### Time.Add(d Duration) Time
### Time.AddDate(years int, months int, days int) Time
### Time.After(u Time) bool
### Time.AppendFormat(b []byte, layout string) []byte
### Time.Before(u Time) bool
### Time.Clock() (hour, min, sec int)
### Time.Date() (year int, month Month, day int)
### Time.Day() int
### Time.Equal(u Time) bool
### Time.Format(layout string) string
### Time.GobDecode(data []byte) error
### Time.GobEncode() ([]byte, error)
### Time.Hour() int
### Time.ISOWeek() (year, week int)
### Time.In(loc `*Location`) Time
### Time.IsZero() bool
### Time.Local() Time
### Time.Location() `*Location`
### Time.MarshalBinary() ([]byte, error)
### Time.MarshalJSON() ([]byte, error)
### Time.MarshalText() ([]byte, error)
### Time.Minute() int
### Time.Month() Month
### Time.Nanosecond() int
### Time.Round(d Duration) Time
### Time.Second() int
### Time.String() string
### Time.Sub(u Time) Duration
### Time.Truncate(d Duration) Time
### Time.UTC() Time
### Time.Unix() int64
### Time.UnixNano() int64
### Time.UnmarshalBinary(data []byte) error
### Time.UnmarshalJSON(data []byte) error
### Time.UnmarshalText(data []byte) error
### Time.Weekday() Weekday
### Time.Year() int
### Time.YearDay() int
### Time.Zone() (name string, offset int)

## type Timer

### time.AfterFunc(d Duration, f func()) `*Timer`
### time.NewTimer(d Duration) `*Timer`
### Timer.Reset(d Duration) bool
### Timer.Stop() bool

## type Weekday

### Weekday.String() string

## Time Constants

    const (
        ANSIC       = "Mon Jan _2 15:04:05 2006"
        UnixDate    = "Mon Jan _2 15:04:05 MST 2006"
        RubyDate    = "Mon Jan 02 15:04:05 -0700 2006"
        RFC822      = "02 Jan 06 15:04 MST"
        RFC822Z     = "02 Jan 06 15:04 -0700" // RFC822 with numeric zone
        RFC850      = "Monday, 02-Jan-06 15:04:05 MST"
        RFC1123     = "Mon, 02 Jan 2006 15:04:05 MST"
        RFC1123Z    = "Mon, 02 Jan 2006 15:04:05 -0700" // RFC1123 with numeric zone
        RFC3339     = "2006-01-02T15:04:05Z07:00"
        RFC3339Nano = "2006-01-02T15:04:05.999999999Z07:00"
        Kitchen     = "3:04PM"
        // Handy time stamps.
        Stamp      = "Jan _2 15:04:05"
        StampMilli = "Jan _2 15:04:05.000"
        StampMicro = "Jan _2 15:04:05.000000"
        StampNano  = "Jan _2 15:04:05.000000000"
    )


当前时间可以使用 time.Now() 获取，或者使用 t.Day()、t.Minute() 等等来获取时间的一部分；你甚至可以自定义时间格式化字符串，例如： 

    fmt.Printf("%02d.%02d.%4d\n", t.Day(), t.Month(), t.Year()) 将会输出 21.07.2011。

Duration 类型表示两个连续时刻所相差的纳秒数，类型为 int64。Location 类型映射某个时区的时间，UTC 表示通用协调世界时间。

包中的一个预定义函数 format 可以根据一个格式化字符串来将一个时间 t 转换为相应格式的字符串，你可以使用一些预定义的格式，如：time.ANSIC 或 time.RFC822。

    func (t Time) Format(layout string) string

    fmt.Println(t.Format("02 Jan 2006 15:04")) 
    // 21 Jul 2011 10:31

一般的格式化设计是通过对于一个标准时间的格式化描述来展现的。

    package main
    import (
        "fmt"
        "time"
    )

    var week time.Duration
    func main() {
        t := time.Now()
        fmt.Println(t) // e.g. Wed Dec 21 09:52:14 +0100 RST 2011
        fmt.Printf("%02d.%02d.%4d\n", t.Day(), t.Month(), t.Year()) // 21.12.2011

        t = time.Now().UTC()
        fmt.Println(t) // Wed Dec 21 08:52:14 +0000 UTC 2011
        fmt.Println(time.Now()) // Wed Dec 21 09:52:14 +0100 RST 2011

        // calculating times:
        week = 60 * 60 * 24 * 7 * 1e9 // must be in nanosec
        week_from_now := t.Add(time.Duration(week))
        fmt.Println(week_from_now) // Wed Dec 28 08:52:14 +0000 UTC 2011
        
        // formatting times:
        fmt.Println(t.Format(time.RFC822)) // 21 Dec 11 0852 UTC
        fmt.Println(t.Format(time.ANSIC)) // Wed Dec 21 08:56:34 2011
        fmt.Println(t.Format("02 Jan 2006 15:04")) // 21 Dec 2011 08:52
        s := t.Format("20060102")
        fmt.Println(t, "=>", s) // Wed Dec 21 08:52:14 +0000 UTC 2011 => 20111221
    }


如果你需要在应用程序在经过一定时间或周期执行某项任务（事件处理的特例），则可以使用 time.After 或者 time.Ticker。 另外，time.Sleep（Duration d） 可以实现对某个进程（实质上是 goroutine）时长为 d 的暂停。



# package strings
[strings](https://godoc.org/strings)

作为一种基本数据结构，每种语言都有一些对于字符串的预定义处理函数。Go 中使用 strings 包来完成对字符串的主要操作。

## strings.Compare(a, b string) int
## strings.Contains(s, substr string) bool
## strings.ContainsAny(s, chars string) bool
## strings.ContainsRune(s string, r rune) bool
## strings.Count(s, substr string) int
## strings.EqualFold(s, t string) bool
## strings.Fields(s string) []string
## strings.FieldsFunc(s string, f func(rune) bool) []string
## strings.HasPrefix(s, prefix string) bool
## strings.HasPrefix(s, prefix string) bool

HasPrefix 判断字符串 s 是否以 prefix 开头：

## strings.HasSuffix(s, suffix string) bool

HasSuffix 判断字符串 s 是否以 suffix 结尾：

    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        var str string = "This is an example of a string"
        fmt.Printf("T/F? Does the string \"%s\" have prefix %s? ", str, "Th")
        fmt.Printf("%t\n", strings.HasPrefix(str, "Th"))
    }

输出：

    T/F? Does the string "This is an example of a string" have prefix Th? true

这个例子同样演示了转义字符 \ 和格式化字符串的使用。

## strings.Index(s, substr string) int
## strings.IndexAny(s, chars string) int
## strings.IndexByte(s string, c byte) int
## strings.IndexFunc(s string, f func(rune) bool) int
## strings.IndexRune(s string, r rune) int
## strings.Join(a []string, sep string) string
## strings.LastIndex(s, substr string) int
## strings.LastIndexAny(s, chars string) int
## strings.LastIndexByte(s string, c byte) int
## strings.LastIndexFunc(s string, f func(rune) bool) int
## strings.Map(mapping func(rune) rune, s string) string
## strings.Repeat(s string, count int) string
## strings.Replace(s, old, new string, n int) string
## strings.ReplaceAll(s, old, new string) string
## strings.Split(s, sep string) []string
## strings.SplitAfter(s, sep string) []string
## strings.SplitAfterN(s, sep string, n int) []string
## strings.SplitN(s, sep string, n int) []string
## strings.Title(s string) string
## strings.ToLower(s string) string
## strings.ToLowerSpecial(c unicode.SpecialCase, s string) string
## strings.ToTitle(s string) string
## strings.ToTitleSpecial(c unicode.SpecialCase, s string) string
## strings.ToUpper(s string) string
## strings.ToUpperSpecial(c unicode.SpecialCase, s string) string
## strings.Trim(s string, cutset string) string
## strings.TrimFunc(s string, f func(rune) bool) string
## strings.TrimLeft(s string, cutset string) string
## strings.TrimLeftFunc(s string, f func(rune) bool) string
## strings.TrimPrefix(s, prefix string) string
## strings.TrimRight(s string, cutset string) string
## strings.TrimRightFunc(s string, f func(rune) bool) string
## strings.TrimSpace(s string) string
## strings.TrimSuffix(s, suffix string) string

## type Builder

### Builder.Cap() int
### Builder.Grow(n int)
### Builder.Len() int
### Builder.Reset()
### Builder.String() string
### Builder.Write(p []byte) (int, error)
### Builder.WriteByte(c byte) error
### Builder.WriteRune(r rune) (int, error)
### Builder.WriteString(s string) (int, error)

## type Reader

### strings.NewReader(s string) `*Reader`
### Reader.Len() int
### Reader.Read(b []byte) (n int, err error)
### Reader.ReadAt(b []byte, off int64) (n int, err error)
### Reader.ReadByte() (byte, error)
### Reader.ReadRune() (ch rune, size int, err error)
### Reader.Reset(s string)
### Reader.Seek(offset int64, whence int) (int64, error)
### Reader.Size() int64
### Reader.UnreadByte() error
### Reader.UnreadRune() error
### Reader.WriteTo(w io.Writer) (n int64, err error)

## type Replacer

### strings.NewReplacer(oldnew ...string) `*Replacer`
### Replacer.Replace(s string) string
### Replacer.WriteString(w io.Writer, s string) (n int, err error)

## strings.Contains(s, substr string) bool

Contains 判断字符串 s 是否包含 substr：

## strings.Index(s, str string) int

判断子字符串或字符在父字符串中出现的位置（索引）

Index 返回字符串 str 在字符串 s 中的索引（str 的第一个字符的索引），-1 表示字符串 s 不包含字符串 str：

## strings.LastIndex(s, str string) int

LastIndex 返回字符串 str 在字符串 s 中最后出现位置的索引（str 的第一个字符的索引），-1 表示字符串 s 不包含字符串 str：


## strings.IndexRune(s string, r rune) int

要查询非 ASCII 编码的字符在父字符串中的位置，使用此函数来对字符进行定位

注: 原文为 "If ch is a non-ASCII character use strings.IndexRune(s string, ch int) int."

该方法在最新版本的 Go 中定义为 func IndexRune(s string, r rune) int

实际使用中的第二个参数 rune 可以是 rune 或 int, 例如 strings.IndexRune("chicken", 99) 或 strings.IndexRune("chicken", rune('k'))

    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        var str string = "Hi, I'm Marc, Hi."

        fmt.Printf("The position of \"Marc\" is: ")
        fmt.Printf("%d\n", strings.Index(str, "Marc"))

        fmt.Printf("The position of the first instance of \"Hi\" is: ")
        fmt.Printf("%d\n", strings.Index(str, "Hi"))
        fmt.Printf("The position of the last instance of \"Hi\" is: ")
        fmt.Printf("%d\n", strings.LastIndex(str, "Hi"))

        fmt.Printf("The position of \"Burger\" is: ")
        fmt.Printf("%d\n", strings.Index(str, "Burger"))
    }

输出：

    The position of "Marc" is: 8
    The position of the first instance of "Hi" is: 0
    The position of the last instance of "Hi" is: 14
    The position of "Burger" is: -1

## strings.Replace(str, old, new, n) string

Replace 用于将字符串 str 中的前 n 个字符串 old 替换为字符串 new，并返回一个新的字符串，如果 n = -1 则替换所有字符串 old 为字符串 new：

## strings.Count(s, str string) int

Count 用于计算字符串 str 在字符串 s 中出现的非重叠次数：

    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        var str string = "Hello, how is it going, Hugo?"
        var manyG = "gggggggggg"

        fmt.Printf("Number of H's in %s is: ", str)
        fmt.Printf("%d\n", strings.Count(str, "H"))

        fmt.Printf("Number of double g's in %s is: ", manyG)
        fmt.Printf("%d\n", strings.Count(manyG, "gg"))
    }

输出：

    Number of H's in Hello, how is it going, Hugo? is: 2
    Number of double g’s in gggggggggg is: 5

##strings.Repeat(s, count int) string

Repeat 用于重复 count 次字符串 s 并返回一个新的字符串：

    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        var origS string = "Hi there! "
        var newS string

        newS = strings.Repeat(origS, 3)
        fmt.Printf("The new repeated string is: %s\n", newS)
    }

输出：

    The new repeated string is: Hi there! Hi there! Hi there!

## strings.ToLower(s) string
## strings.ToUpper(s) string

ToLower 将字符串中的 Unicode 字符全部转换为相应的小写字符：

ToUpper 将字符串中的 Unicode 字符全部转换为相应的大写字符：

    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        var orig string = "Hey, how are you George?"
        var lower string
        var upper string

        fmt.Printf("The original string is: %s\n", orig)
        lower = strings.ToLower(orig)
        fmt.Printf("The lowercase string is: %s\n", lower)
        upper = strings.ToUpper(orig)
        fmt.Printf("The uppercase string is: %s\n", upper)
    }

输出：

    The original string is: Hey, how are you George?
    The lowercase string is: hey, how are you george?
    The uppercase string is: HEY, HOW ARE YOU GEORGE?

## strings.TrimSpace(s)

你可以使用 strings.TrimSpace(s) 来剔除字符串开头和结尾的空白符号；如果你想要剔除指定字符，则可以使用 strings.Trim(s, "cut") 来将开头和结尾的 cut 去除掉。该函数的第二个参数可以包含任何字符，如果你只想剔除开头或者结尾的字符串，则可以使用 TrimLeft 或者 TrimRight 来实现。


## strings.Fields(s) 
## strings.Split(s, sep) 

利用 1 个或多个空白符号来作为动态长度的分隔符将字符串 s 分割成若干小块，并返回一个 slice，如果字符串只包含空白符号，则返回一个长度为 0 的 slice。

用于自定义分割符号 sep 来对指定字符串 s 进行分割，同样返回 slice。

因为这 2 个函数都会返回 slice，所以习惯使用 for-range 循环来对其进行处理。

## strings.Join(sl []string, sep string) string

Join 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串：


    package main

    import (
        "fmt"
        "strings"
    )

    func main() {
        str := "The quick brown fox jumps over the lazy dog"
        sl := strings.Fields(str)
        fmt.Printf("Splitted in slice: %v\n", sl)
        for _, val := range sl {
            fmt.Printf("%s - ", val)
        }
        fmt.Println()
        str2 := "GO1|The ABC of Go|25"
        sl2 := strings.Split(str2, "|")
        fmt.Printf("Splitted in slice: %v\n", sl2)
        for _, val := range sl2 {
            fmt.Printf("%s - ", val)
        }
        fmt.Println()
        str3 := strings.Join(sl2,";")
        fmt.Printf("sl2 joined by ;: %s\n", str3)
    }

输出：

    Splitted in slice: [The quick brown fox jumps over the lazy dog]
    The - quick - brown - fox - jumps - over - the - lazy - dog -
    Splitted in slice: [GO1 The ABC of Go 25]
    GO1 - The ABC of Go - 25 -
    sl2 joined by ;: GO1;The ABC of Go;25

其它有关字符串操作的文档请参阅 官方文档（ 译者注：国内用户可访问 该页面 ）。

## strings.NewReader(str)

用于生成一个 Reader 并读取字符串中的内容，然后返回指向该 Reader 的指针，从其它类型读取内容的函数还有：

Read() 从 []byte 中读取内容。
ReadByte() 和 ReadRune() 从字符串中读取下一个 byte 或者 rune。



# package strconv
[strconv](https://godoc.org/strconv)


### strconv.AppendBool(dst []byte, b bool) []byte
### strconv.AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte
### strconv.AppendInt(dst []byte, i int64, base int) []byte
### strconv.AppendQuote(dst []byte, s string) []byte
### strconv.AppendQuoteRune(dst []byte, r rune) []byte
### strconv.AppendQuoteRuneToASCII(dst []byte, r rune) []byte
### strconv.AppendQuoteRuneToGraphic(dst []byte, r rune) []byte
### strconv.AppendQuoteToASCII(dst []byte, s string) []byte
### strconv.AppendQuoteToGraphic(dst []byte, s string) []byte
### strconv.AppendUint(dst []byte, i uint64, base int) []byte
### strconv.Atoi(s string) (int, error)
### strconv.CanBackquote(s string) bool
### strconv.FormatBool(b bool) string
### strconv.FormatFloat(f float64, fmt byte, prec, bitSize int) string
### strconv.FormatInt(i int64, base int) string
### strconv.FormatUint(i uint64, base int) string
### strconv.IsGraphic(r rune) bool
### strconv.IsPrint(r rune) bool
### strconv.Itoa(i int) string
### strconv.ParseBool(str string) (bool, error)
### strconv.ParseFloat(s string, bitSize int) (float64, error)
### strconv.ParseInt(s string, base int, bitSize int) (i int64, err error)
### strconv.ParseUint(s string, base int, bitSize int) (uint64, error)
### strconv.Quote(s string) string
### strconv.QuoteRune(r rune) string
### strconv.QuoteRuneToASCII(r rune) string
### strconv.QuoteRuneToGraphic(r rune) string
### strconv.QuoteToASCII(s string) string
### strconv.QuoteToGraphic(s string) string
### strconv.Unquote(s string) (string, error)
### strconv.UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error)

## type NumError

### NumError.Error() string


## strconv.Itoa(i int) string

返回数字 i 所表示的字符串类型的十进制数。

与字符串相关的类型转换都是通过 strconv 包实现的。 该包包含了一些变量用于获取程序运行的操作系统平台下 int 类型所占的位数，如：strconv.IntSize。

任何类型 T 转换为字符串总是成功的。

## strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string 

将 64 位浮点型的数字转换为字符串，其中 fmt 表示格式（其值可以是 'b'、'e'、'f' 或 'g'），prec 表示精度，bitSize 则使用 32 表示 float32，用 64 表示 float64。

将字符串转换为其它类型 tp 并不总是可能的，可能会在运行时抛出错误 parsing "…": invalid argument。


## strconv.Atoi(s string) (i int, err error) 

将字符串转换为 int 型。第 2 个是可能出现的错误，因此，我们一般使用以下形式来进行从字符串到其它类型的转换：

    val, err = strconv.Atoi(s)

## strconv.ParseFloat(s string, bitSize int) (f float64, err error) 

将字符串转换为 float64 型。

利用多返回值的特性，这些函数会返回 2 个值，第 1 个是转换后的结果（如果转换成功），

    package main

    import (
        "fmt"
        "strconv"
    )

    func main() {
        var orig string = "666"
        var an int
        var newS string

        fmt.Printf("The size of ints is: %d\n", strconv.IntSize)      

        an, _ = strconv.Atoi(orig)
        fmt.Printf("The integer is: %d\n", an) 
        an = an + 5
        newS = strconv.Itoa(an)
        fmt.Printf("The new string is: %s\n", newS)
    }

输出：

64 位系统：

    The size of ints is: 64

32 位系统：

    The size of ints is: 32
    The integer is: 666
    The new string is: 671


# package sync 
[package sync](https://godoc.org/sync)

package sync
import "sync"

Package sync provides basic synchronization primitives such as mutual exclusion locks. Other than the Once and WaitGroup types, most are intended for use by low-level library routines. Higher-level synchronization is better done via channels and communication.

## type Cond

### func NewCond(l Locker) `*Cond`
### Cond.Broadcast()
### Cond.Signal()
### Cond.Wait()

## type Locker

    type Locker interface {
        Lock()
        Unlock()
    }

## type Map

    type Map struct {
        // contains filtered or unexported fields
    }

### Map.Delete(key interface{})
### Map.Load(key interface{}) (value interface{}, ok bool)
### Map.LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)
### Map.Range(f func(key, value interface{}) bool)
### Map.Store(key, value interface{})

## type Mutex

    type Mutex struct {
        // contains filtered or unexported fields
    }

### Mutex.Lock()
### Mutex.Unlock()

## type Once
### Once.Do(f func())

## type Pool
### Pool.Get() interface{}
### Pool.Put(x interface{})

## type RWMutex

    type RWMutex struct {
        // contains filtered or unexported fields
    }

### RWMutex.Lock()
### RWMutex.RLock()
### RWMutex.RLocker() Locker
### RWMutex.RUnlock()
### RWMutex.Unlock()

## type WaitGroup

### WaitGroup.Add(delta int)
### WaitGroup.Done()
### WaitGroup.Wait()


# package io
[GO DOC - io](https://godoc.org/io)

    import "io"

Package io provides basic interfaces to I/O primitives. Its primary job is to wrap existing implementations of such primitives, such as those in package os, into shared public interfaces that abstract the functionality, plus some other related primitives.

Because these interfaces and primitives wrap lower-level operations with various implementations, unless otherwise informed clients should not assume they are safe for parallel execution.

## Package Files

io.go multi.go pipe.go

## Constants

    const (
        SeekStart   = 0 // seek relative to the origin of the file
        SeekCurrent = 1 // seek relative to the current offset
        SeekEnd     = 2 // seek relative to the end
    )

Seek whence values.


### io.Copy(dst Writer, src Reader) (written int64, err error)
### io.CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)
### io.CopyN(dst Writer, src Reader, n int64) (written int64, err error)
### io.Pipe() (`*PipeReader`, `*PipeWriter`)
### io.ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)
### io.ReadFull(r Reader, buf []byte) (n int, err error)
### io.WriteString(w Writer, s string) (n int, err error)

## type ByteReader

    type ByteReader interface {
        ReadByte() (byte, error)
    }

ByteReader is the interface that wraps the ReadByte method.

ReadByte reads and returns the next byte from the input or any error encountered. If ReadByte returns an error, no input byte was consumed, and the returned byte value is undefined.

## type ByteScanner

    type ByteScanner interface {
        ByteReader
        UnreadByte() error
    }

ByteScanner is the interface that adds the UnreadByte method to the basic ReadByte method.

UnreadByte causes the next call to ReadByte to return the same byte as the previous call to ReadByte. It may be an error to call UnreadByte twice without an intervening call to ReadByte.


## type ByteWriter

    type ByteWriter interface {
        WriteByte(c byte) error
    }

ByteWriter is the interface that wraps the WriteByte method.


## type Closer

    type Closer interface {
        Close() error
    }

Closer is the interface that wraps the basic Close method.

The behavior of Close after the first call is undefined. Specific implementations may document their own behavior.


## type LimitedReader

    type LimitedReader struct {
        R   Reader // underlying reader
        N   int64  // max bytes remaining
    }

A LimitedReader reads from R but limits the amount of data returned to just N bytes. Each call to Read updates N to reflect the new amount remaining. Read returns EOF when N <= 0 or when the underlying R returns EOF.

### LimitedReader.Read(p []byte) (n int, err error)

## type PipeReader

    type PipeReader struct {
        // contains filtered or unexported fields
    }

A PipeReader is the read half of a pipe.

### PipeReader.Close() error
### PipeReader.CloseWithError(err error) error
### PipeReader.Read(data []byte) (n int, err error)

## type PipeWriter

    type PipeWriter struct {
        // contains filtered or unexported fields
    }

A PipeWriter is the write half of a pipe.

### PipeWriter.Close() error
### PipeWriter.CloseWithError(err error) error
### PipeWriter.Write(data []byte) (n int, err error)

## type ReadCloser

    type ReadCloser interface {
        Reader
        Closer
    }

ReadCloser is the interface that groups the basic Read and Close methods.

## type ReadSeeker

    type ReadSeeker interface {
        Reader
        Seeker
    }

ReadSeeker is the interface that groups the basic Read and Seek methods.

## type ReadWriteCloser

    type ReadWriteCloser interface {
        Reader
        Writer
        Closer
    }

ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.

## type ReadWriteSeeker

    type ReadWriteSeeker interface {
        Reader
        Writer
        Seeker
    }

ReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods.

## type ReadWriter

    type ReadWriter interface {
        Reader
        Writer
    }

ReadWriter is the interface that groups the basic Read and Write methods.


## type Reader

    type Reader interface {
        Read(p []byte) (n int, err error)
    }

Reader is the interface that wraps the basic Read method.

Read reads up to len(p) bytes into p. It returns the number of bytes read (0 <= n <= len(p)) and any error encountered. Even if Read returns n < len(p), it may use all of p as scratch space during the call. If some data is available but not len(p) bytes, Read conventionally returns what is available instead of waiting for more.

When Read encounters an error or end-of-file condition after successfully reading n > 0 bytes, it returns the number of bytes read. It may return the (non-nil) error from the same call or return the error (and n == 0) from a subsequent call. An instance of this general case is that a Reader returning a non-zero number of bytes at the end of the input stream may return either err == EOF or err == nil. The next Read should return 0, EOF.

Callers should always process the n > 0 bytes returned before considering the error err. Doing so correctly handles I/O errors that happen after reading some bytes and also both of the allowed EOF behaviors.

Implementations of Read are discouraged from returning a zero byte count with a nil error, except when len(p) == 0. Callers should treat a return of 0 and nil as indicating that nothing happened; in particular it does not indicate EOF.

Implementations must not retain p.

### io.LimitReader(r Reader, n int64) Reader
### io.MultiReader(readers ...Reader) Reader
### io.TeeReader(r Reader, w Writer) Reader

## type ReaderAt

    type ReaderAt interface {
        ReadAt(p []byte, off int64) (n int, err error)
    }

ReaderAt is the interface that wraps the basic ReadAt method.

ReadAt reads len(p) bytes into p starting at offset off in the underlying input source. It returns the number of bytes read (0 <= n <= len(p)) and any error encountered.

When ReadAt returns n < len(p), it returns a non-nil error explaining why more bytes were not returned. In this respect, ReadAt is stricter than Read.

Even if ReadAt returns n < len(p), it may use all of p as scratch space during the call. If some data is available but not len(p) bytes, ReadAt blocks until either all the data is available or an error occurs. In this respect ReadAt is different from Read.

If the n = len(p) bytes returned by ReadAt are at the end of the input source, ReadAt may return either err == EOF or err == nil.

If ReadAt is reading from an input source with a seek offset, ReadAt should not affect nor be affected by the underlying seek offset.

Clients of ReadAt can execute parallel ReadAt calls on the same input source.

Implementations must not retain p.

## type ReaderFrom

    type ReaderFrom interface {
        ReadFrom(r Reader) (n int64, err error)
    }

ReaderFrom is the interface that wraps the ReadFrom method.

ReadFrom reads data from r until EOF or error. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned.

The Copy function uses ReaderFrom if available.

## type RuneReader

    type RuneReader interface {
        ReadRune() (r rune, size int, err error)
    }

RuneReader is the interface that wraps the ReadRune method.

ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If no character is available, err will be set.

## type RuneScanner

    type RuneScanner interface {
        RuneReader
        UnreadRune() error
    }

RuneScanner is the interface that adds the UnreadRune method to the basic ReadRune method.

UnreadRune causes the next call to ReadRune to return the same rune as the previous call to ReadRune. It may be an error to call UnreadRune twice without an intervening call to ReadRune.

## type SectionReader

    type SectionReader struct {
        // contains filtered or unexported fields
    }

SectionReader implements Read, Seek, and ReadAt on a section of an underlying ReaderAt.

Example

    r := strings.NewReader("some io.Reader stream to be read\n")
    s := io.NewSectionReader(r, 5, 17)

    if _, err := io.Copy(os.Stdout, s); err != nil {
        log.Fatal(err)
    }
    Output:

    io.Reader stream

### io.NewSectionReader(r ReaderAt, off int64, n int64) `*SectionReader`
### SectionReader.Read(p []byte) (n int, err error)
### SectionReader.ReadAt(p []byte, off int64) (n int, err error)
### SectionReader.Seek(offset int64, whence int) (int64, error)
### SectionReader.Size() int64

## type Seeker

    type Seeker interface {
        Seek(offset int64, whence int) (int64, error)
    }

Seeker is the interface that wraps the basic Seek method.

Seek sets the offset for the next Read or Write to offset, interpreted according to whence: SeekStart means relative to the start of the file, SeekCurrent means relative to the current offset, and SeekEnd means relative to the end. Seek returns the new offset relative to the start of the file and an error, if any.

Seeking to an offset before the start of the file is an error. Seeking to any positive offset is legal, but the behavior of subsequent I/O operations on the underlying object is implementation-dependent.

## type StringWriter

    type StringWriter interface {
        WriteString(s string) (n int, err error)
    }

StringWriter is the interface that wraps the WriteString method.

## type WriteCloser

    type WriteCloser interface {
        Writer
        Closer
    }

WriteCloser is the interface that groups the basic Write and Close methods.

## type WriteSeeker

    type WriteSeeker interface {
        Writer
        Seeker
    }

WriteSeeker is the interface that groups the basic Write and Seek methods.

## type Writer

    type Writer interface {
        Write(p []byte) (n int, err error)
    }

Writer is the interface that wraps the basic Write method.

Write writes len(p) bytes from p to the underlying data stream. It returns the number of bytes written from p (0 <= n <= len(p)) and any error encountered that caused the write to stop early. Write must return a non-nil error if it returns n < len(p). Write must not modify the slice data, even temporarily.

Implementations must not retain p.

### io.MultiWriter(writers ...Writer) Writer

## type WriterAt

    type WriterAt interface {
        WriteAt(p []byte, off int64) (n int, err error)
    }

WriterAt is the interface that wraps the basic WriteAt method.

WriteAt writes len(p) bytes from p to the underlying data stream at offset off. It returns the number of bytes written from p (0 <= n <= len(p)) and any error encountered that caused the write to stop early. WriteAt must return a non-nil error if it returns n < len(p).

If WriteAt is writing to a destination with a seek offset, WriteAt should not affect nor be affected by the underlying seek offset.

Clients of WriteAt can execute parallel WriteAt calls on the same destination if the ranges do not overlap.

Implementations must not retain p.

## type WriterTo

    type WriterTo interface {
        WriteTo(w Writer) (n int64, err error)
    }

WriterTo is the interface that wraps the WriteTo method.

WriteTo writes data to w until there's no more data to write or when an error occurs. The return value n is the number of bytes written. Any error encountered during the write is also returned.

The Copy function uses WriterTo if available.


## Examples
Copy
CopyBuffer
CopyN
LimitReader
MultiReader
MultiWriter
Pipe
ReadAtLeast
ReadFull
SectionReader
SectionReader.ReadAt
SectionReader.Seek
TeeReader
WriteString


# package ioutil
[Go Doc ioutil](https://godoc.org/io/ioutil)

    import "io/ioutil"

Package ioutil implements some I/O utility functions.

## Package Files

ioutil.go tempfile.go

Variables
var Discard io.Writer = devNull(0)
Discard is an io.Writer on which all Write calls succeed without doing anything.

## ioutil.NopCloser(r io.Reader) io.ReadCloser
NopCloser returns a ReadCloser with a no-op Close method wrapping the provided Reader r.

## ioutil.ReadAll(r io.Reader) ([]byte, error)
ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.

Example

    r := strings.NewReader("Go is a general-purpose language designed with systems programming in mind.")

    b, err := ioutil.ReadAll(r)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("%s", b)

Output:

    Go is a general-purpose language designed with systems programming in mind.

## ioutil.ReadDir(dirname string) ([]os.FileInfo, error)
ReadDir reads the directory named by dirname and returns a list of directory entries sorted by filename.

Example

    files, err := ioutil.ReadDir(".")
    if err != nil {
        log.Fatal(err)
    }

    for _, file := range files {
        fmt.Println(file.Name())
    }

## ioutil.ReadFile(filename string) ([]byte, error)
ReadFile reads the file named by filename and returns the contents. A successful call returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat an EOF from Read as an error to be reported.

Example

    content, err := ioutil.ReadFile("testdata/hello")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("File contents: %s", content)

Output:

    File contents: Hello, Gophers!

## ioutil.TempDir(dir, prefix string) (name string, err error)
TempDir creates a new temporary directory in the directory dir with a name beginning with prefix and returns the path of the new directory. If dir is the empty string, TempDir uses the default directory for temporary files (see os.TempDir). Multiple programs calling TempDir simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when no longer needed.

Example

    content := []byte("temporary file's content")
    dir, err := ioutil.TempDir("", "example")
    if err != nil {
        log.Fatal(err)
    }

    defer os.RemoveAll(dir) // clean up

    tmpfn := filepath.Join(dir, "tmpfile")
    if err := ioutil.WriteFile(tmpfn, content, 0666); err != nil {
        log.Fatal(err)
    }

## ioutil.TempFile(dir, pattern string) (f `*os.File`, err error)
TempFile creates a new temporary file in the directory dir, opens the file for reading and writing, and returns the resulting `*os.File`. The filename is generated by taking pattern and adding a random string to the end. If pattern includes a `*`, the random string replaces the last `*` If dir is the empty string, TempFile uses the default directory for temporary files (see os.TempDir). Multiple programs calling TempFile simultaneously will not choose the same file. The caller can use f.Name() to find the pathname of the file. It is the caller's responsibility to remove the file when no longer needed.

Example

    content := []byte("temporary file's content")
    tmpfile, err := ioutil.TempFile("", "example")
    if err != nil {
        log.Fatal(err)
    }

    defer os.Remove(tmpfile.Name()) // clean up

    if _, err := tmpfile.Write(content); err != nil {
        log.Fatal(err)
    }
    if err := tmpfile.Close(); err != nil {
        log.Fatal(err)
    }

Example (Suffix)

    content := []byte("temporary file's content")
    tmpfile, err := ioutil.TempFile("", "example.*.txt")
    if err != nil {
        log.Fatal(err)
    }

    defer os.Remove(tmpfile.Name()) // clean up

    if _, err := tmpfile.Write(content); err != nil {
        tmpfile.Close()
        log.Fatal(err)
    }
    if err := tmpfile.Close(); err != nil {
        log.Fatal(err)
    }

## ioutil.WriteFile(filename string, data []byte, perm os.FileMode) error
WriteFile writes data to a file named by filename. If the file does not exist, WriteFile creates it with permissions perm; otherwise WriteFile truncates it before writing.

Example

    message := []byte("Hello, Gophers!")
    err := ioutil.WriteFile("testdata/hello", message, 0644)
    if err != nil {
        log.Fatal(err)
    }



# package os
[GO DOC - os](https://godoc.org/os)

    import "os"

Package os provides a platform-independent interface to operating system functionality. The design is Unix-like, although the error handling is Go-like; failing calls return values of type error rather than error numbers. Often, more information is available within the error. For example, if a call that takes a file name fails, such as Open or Stat, the error will include the failing file name when printed and will be of type `*PathError`, which may be unpacked for more information.

The os interface is intended to be uniform across all operating systems. Features not generally available appear in the system-specific package syscall.

Here is a simple example, opening a file and reading some of it.

    file, err := os.Open("file.go") // For read access.
    if err != nil {
        log.Fatal(err)
    }

If the open fails, the error string will be self-explanatory, like

    open file.go: no such file or directory

The file's data can then be read into a slice of bytes. Read and Write take their byte counts from the length of the argument slice.

    data := make([]byte, 100)
    count, err := file.Read(data)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("read %d bytes: %q\n", count, data[:count])

## Constants

    const (
        // Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.
        O_RDONLY int = syscall.O_RDONLY // open the file read-only.
        O_WRONLY int = syscall.O_WRONLY // open the file write-only.
        O_RDWR   int = syscall.O_RDWR   // open the file read-write.
        // The remaining values may be or'ed in to control behavior.
        O_APPEND int = syscall.O_APPEND // append data to the file when writing.
        O_CREATE int = syscall.O_CREAT  // create a new file if none exists.
        O_EXCL   int = syscall.O_EXCL   // used with O_CREATE, file must not exist.
        O_SYNC   int = syscall.O_SYNC   // open for synchronous I/O.
        O_TRUNC  int = syscall.O_TRUNC  // truncate regular writable file when opened.
    )

Flags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system.

    const (
        SEEK_SET int = 0 // seek relative to the origin of the file
        SEEK_CUR int = 1 // seek relative to the current offset
        SEEK_END int = 2 // seek relative to the end
    )

Seek whence values.

Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.

    const (
        PathSeparator     = '/' // OS-specific path separator
        PathListSeparator = ':' // OS-specific path list separator
    )
    const DevNull = "/dev/null"

DevNull is the name of the operating system's “null device.” On Unix-like systems, it is "/dev/null"; on Windows, "NUL".

## os.Chdir(dir string) error
## os.Chmod(name string, mode FileMode) error
## os.Chown(name string, uid, gid int) error
## os.Chtimes(name string, atime time.Time, mtime time.Time) error
## os.Clearenv()
## os.Environ() []string
## os.Executable() (string, error)
## os.Exit(code int)
## os.Expand(s string, mapping func(string) string) string
## os.ExpandEnv(s string) string
## os.Getegid() int
## os.Getenv(key string) string
## os.Geteuid() int
## os.Getgid() int
## os.Getgroups() ([]int, error)
## os.Getpagesize() int
## os.Getpid() int
## os.Getppid() int
## os.Getuid() int
## os.Getwd() (dir string, err error)
## os.Hostname() (name string, err error)
## os.IsExist(err error) bool
## os.IsNotExist(err error) bool
## os.IsPathSeparator(c uint8) bool
## os.IsPermission(err error) bool
## os.IsTimeout(err error) bool
## os.Lchown(name string, uid, gid int) error
## os.Link(oldname, newname string) error
## os.LookupEnv(key string) (string, bool)
## os.Mkdir(name string, perm FileMode) error
## os.MkdirAll(path string, perm FileMode) error
## os.NewSyscallError(syscall string, err error) error
## os.Pipe() (r `*File`, w `*File`, err error)
## os.Readlink(name string) (string, error)
## os.Remove(name string) error
## os.RemoveAll(path string) error
## os.Rename(oldpath, newpath string) error
## os.SameFile(fi1, fi2 FileInfo) bool
## os.Setenv(key, value string) error
## os.Symlink(oldname, newname string) error
## os.TempDir() string
## os.Truncate(name string, size int64) error
## os.Unsetenv(key string) error
## os.UserCacheDir() (string, error)
## os.UserHomeDir() (string, error)

## type File
## os.Create(name string) (`*File`, error)
## os.NewFile(fd uintptr, name string) `*File`
## os.Open(name string) (`*File`, error)
## os.OpenFile(name string, flag int, perm FileMode) (`*File`, error)
## File.Chdir() error
## File.Chmod(mode FileMode) error
## File.Chown(uid, gid int) error
## File.Close() error
## File.Fd() uintptr
## File.Name() string
## File.Read(b []byte) (n int, err error)
## File.ReadAt(b []byte, off int64) (n int, err error)
## File.Readdir(n int) ([]FileInfo, error)
## File.Readdirnames(n int) (names []string, err error)
## File.Seek(offset int64, whence int) (ret int64, err error)
## File.SetDeadline(t time.Time) error
## File.SetReadDeadline(t time.Time) error
## File.SetWriteDeadline(t time.Time) error
## File.Stat() (FileInfo, error)
## File.Sync() error
## File.SyscallConn() (syscall.RawConn, error)
## File.Truncate(size int64) error
## File.Write(b []byte) (n int, err error)
## File.WriteAt(b []byte, off int64) (n int, err error)
## File.WriteString(s string) (n int, err error)

## type FileInfo
## os.Lstat(name string) (FileInfo, error)
## os.Stat(name string) (FileInfo, error)

## type FileMode
## FileMode.IsDir() bool
## FileMode.IsRegular() bool
## FileMode.Perm() FileMode
## FileMode.String() string

## type LinkError
## LinkError.Error() string

## type PathError
## PathError.Error() string
## PathError.Timeout() bool

## type ProcAttr

## type Process
## os.FindProcess(pid int) (`*Process`, error)
## os.StartProcess(name string, argv []string, attr `*ProcAttr`) (`*Process`, error)
## Process.Kill() error
## Process.Release() error
## Process.Signal(sig Signal) error
## Process.Wait() (`*ProcessState`, error)

## type ProcessState
## ProcessState.ExitCode() int
## ProcessState.Exited() bool
## ProcessState.Pid() int
## ProcessState.String() string
## ProcessState.Success() bool
## ProcessState.Sys() interface{}
## ProcessState.SysUsage() interface{}
## ProcessState.SystemTime() time.Duration
## ProcessState.UserTime() time.Duration

## type Signal

## type SyscallError
## SyscallError.Error() string
## SyscallError.Timeout() bool


# package json
[encoding/json](https://godoc.org/encoding/json)

    import "encoding/json"

Package json implements encoding and decoding of JSON as defined in RFC 7159. The mapping between JSON and Go values is described in the documentation for the Marshal and Unmarshal functions.

    bool,                   for JSON booleans
    float64,                for JSON numbers
    string,                 for JSON strings
    []interface{},          for JSON arrays
    map[string]interface{}, for JSON objects
    nil                     for JSON null

See "JSON and Go" for an introduction to this package: https://golang.org/doc/articles/json_and_go.html


Example (CustomMarshalJSON)

    package main

    import (
        "encoding/json"
        "fmt"
        "log"
        "strings"
    )

    type Animal int

    const (
        Unknown Animal = iota
        Gopher
        Zebra
    )

    func (a *Animal) UnmarshalJSON(b []byte) error {
        var s string
        if err := json.Unmarshal(b, &s); err != nil {
            return err
        }
        switch strings.ToLower(s) {
        default:
            *a = Unknown
        case "gopher":
            *a = Gopher
        case "zebra":
            *a = Zebra
        }

        return nil
    }

    func (a Animal) MarshalJSON() ([]byte, error) {
        var s string
        switch a {
        default:
            s = "unknown"
        case Gopher:
            s = "gopher"
        case Zebra:
            s = "zebra"
        }

        return json.Marshal(s)
    }

    func main() {
        blob := `["gopher","armadillo","zebra","unknown","gopher","bee","gopher","zebra"]`
        var zoo []Animal
        if err := json.Unmarshal([]byte(blob), &zoo); err != nil {
            log.Fatal(err)
        }

        census := make(map[Animal]int)
        for _, animal := range zoo {
            census[animal] += 1
        }

        fmt.Printf("Zoo Census:\n* Gophers: %d\n* Zebras:  %d\n* Unknown: %d\n",
            census[Gopher], census[Zebra], census[Unknown])

    }

Example (TextMarshalJSON)

    package main

    import (
        "encoding/json"
        "fmt"
        "log"
        "strings"
    )

    type Size int

    const (
        Unrecognized Size = iota
        Small
        Large
    )

    func (s *Size) UnmarshalText(text []byte) error {
        switch strings.ToLower(string(text)) {
        default:
            *s = Unrecognized
        case "small":
            *s = Small
        case "large":
            *s = Large
        }
        return nil
    }

    func (s Size) MarshalText() ([]byte, error) {
        var name string
        switch s {
        default:
            name = "unrecognized"
        case Small:
            name = "small"
        case Large:
            name = "large"
        }
        return []byte(name), nil
    }

    func main() {
        blob := `["small","regular","large","unrecognized","small","normal","small","large"]`
        var inventory []Size
        if err := json.Unmarshal([]byte(blob), &inventory); err != nil {
            log.Fatal(err)
        }

        counts := make(map[Size]int)
        for _, size := range inventory {
            counts[size] += 1
        }

        fmt.Printf("Inventory Counts:\n* Small:        %d\n* Large:        %d\n* Unrecognized: %d\n",
            counts[Small], counts[Large], counts[Unrecognized])

    }

## Package Files 
decode.go encode.go fold.go indent.go scanner.go stream.go tables.go tags.go

### json.Compact(dst `*bytes`.Buffer, src []byte) error
### json.HTMLEscape(dst `*bytes`.Buffer, src []byte)
### json.Indent(dst `*bytes`.Buffer, src []byte, prefix, indent string) error

Indent appends to dst an indented form of the JSON-encoded src. Each element in a JSON object or array begins on a new, indented line beginning with prefix followed by one or more copies of indent according to the indentation nesting. The data appended to dst does not begin with the prefix nor any indentation, to make it easier to embed inside other formatted JSON data. Although leading space characters (space, tab, carriage return, newline) at the beginning of src are dropped, trailing space characters at the end of src are preserved and copied to dst. For example, if src has no trailing spaces, neither will dst; if src ends in a trailing newline, so will dst.

Example

    type Road struct {
        Name   string
        Number int
    }
    roads := []Road{
        {"Diamond Fork", 29},
        {"Sheep Creek", 51},
    }

    b, err := json.Marshal(roads)
    if err != nil {
        log.Fatal(err)
    }

    var out bytes.Buffer
    json.Indent(&out, b, "=", "\t")
    out.WriteTo(os.Stdout)

Output:

    [
    =   {
    =       "Name": "Diamond Fork",
    =       "Number": 29
    =   },
    =   {
    =       "Name": "Sheep Creek",
    =       "Number": 51
    =   }
    =]

### json.Marshal(v interface{}) ([]byte, error)

Marshal returns the JSON encoding of v.

Marshal traverses the value v recursively. If an encountered value implements the Marshaler interface and is not a nil pointer, Marshal calls its MarshalJSON method to produce JSON. If no MarshalJSON method is present but the value implements encoding.TextMarshaler instead, Marshal calls its MarshalText method and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of UnmarshalJSON.

Otherwise, Marshal uses the following type-dependent default encodings:

Boolean values encode as JSON booleans.

Floating point, integer, and Number values encode as JSON numbers.

String values encode as JSON strings coerced to valid UTF-8, replacing invalid bytes with the Unicode replacement rune. The angle brackets "<" and ">" are escaped to "\u003c" and "\u003e" to keep some browsers from misinterpreting JSON output as HTML. Ampersand "&" is also escaped to "\u0026" for the same reason. This escaping can be disabled using an Encoder that had SetEscapeHTML(false) called on it.

Array and slice values encode as JSON arrays, except that []byte encodes as a base64-encoded string, and a nil slice encodes as the null JSON value.

Struct values encode as JSON objects. Each exported struct field becomes a member of the object, using the field name as the object key, unless the field is omitted for one of the reasons given below.

The encoding of each struct field can be customized by the format string stored under the "json" key in the struct field's tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.

The "omitempty" option specifies that the field should be omitted from the encoding if the field has an empty value, defined as false, 0, a nil pointer, a nil interface value, and any empty array, slice, map, or string.

As a special case, if the field tag is "-", the field is always omitted. Note that a field with name "-" can still be generated using the tag "-,".

Examples of struct field tags and their meanings:

    // Field appears in JSON as key "myName".
    Field int `json:"myName"`

    // Field appears in JSON as key "myName" and
    // the field is omitted from the object if its value is empty,
    // as defined above.
    Field int `json:"myName,omitempty"`

    // Field appears in JSON as key "Field" (the default), but
    // the field is skipped if empty.
    // Note the leading comma.
    Field int `json:",omitempty"`

    // Field is ignored by this package.
    Field int `json:"-"`

    // Field appears in JSON as key "-".
    Field int `json:"-,"`

The "string" option signals that a field is stored as JSON inside a JSON-encoded string. It applies only to fields of string, floating point, integer, or boolean types. This extra level of encoding is sometimes used when communicating with JavaScript programs:

    Int64String int64 `json:",string"`

The key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.

Anonymous struct fields are usually marshaled as if their inner exported fields were fields in the outer struct, subject to the usual Go visibility rules amended as described in the next paragraph. An anonymous struct field with a name given in its JSON tag is treated as having that name, rather than being anonymous. An anonymous struct field of interface type is treated the same as having that type as its name, rather than being anonymous.

The Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply:

1) Of those fields, if any are JSON-tagged, only tagged fields are considered, even if there are multiple untagged fields that would otherwise conflict.

2) If there is exactly one field (tagged or not according to the first rule), that is selected.

3) Otherwise there are multiple fields, and all are ignored; no error occurs.

Handling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of an anonymous struct field in both current and earlier versions, give the field a JSON tag of "-".

Map values encode as JSON objects. The map's key type must either be a string, an integer type, or implement encoding.TextMarshaler. The map keys are sorted and used as JSON object keys by applying the following rules, subject to the UTF-8 coercion described for string values above:

- string keys are used directly
- encoding.TextMarshalers are marshaled
- integer keys are converted to strings

Pointer values encode as the value pointed to. A nil pointer encodes as the null JSON value.

Interface values encode as the value contained in the interface. A nil interface value encodes as the null JSON value.

Channel, complex, and function values cannot be encoded in JSON. Attempting to encode such a value causes Marshal to return an UnsupportedTypeError.

JSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an infinite recursion.

Example

    type ColorGroup struct {
        ID     int
        Name   string
        Colors []string
    }
    group := ColorGroup{
        ID:     1,
        Name:   "Reds",
        Colors: []string{"Crimson", "Red", "Ruby", "Maroon"},
    }
    b, err := json.Marshal(group)
    if err != nil {
        fmt.Println("error:", err)
    }
    os.Stdout.Write(b)

Output:

    {"ID":1,"Name":"Reds","Colors":["Crimson","Red","Ruby","Maroon"]}

### json.MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)
### json.Unmarshal(data []byte, v interface{}) error
### json.Valid(data []byte) bool

## type Decoder

    type Decoder struct {
        // contains filtered or unexported fields
    }
    A Decoder reads and decodes JSON values from an input stream.

This example uses a Decoder to decode a stream of distinct JSON values.

    const jsonStream = `
        {"Name": "Ed", "Text": "Knock knock."}
        {"Name": "Sam", "Text": "Who's there?"}
        {"Name": "Ed", "Text": "Go fmt."}
        {"Name": "Sam", "Text": "Go fmt who?"}
        {"Name": "Ed", "Text": "Go fmt yourself!"}
    `
    type Message struct {
        Name, Text string
    }
    dec := json.NewDecoder(strings.NewReader(jsonStream))
    for {
        var m Message
        if err := dec.Decode(&m); err == io.EOF {
            break
        } else if err != nil {
            log.Fatal(err)
        }
        fmt.Printf("%s: %s\n", m.Name, m.Text)
    }

Output:

    Ed: Knock knock.
    Sam: Who's there?
    Ed: Go fmt.
    Sam: Go fmt who?
    Ed: Go fmt yourself!


### json.NewDecoder(r io.Reader) `*Decoder`
### Decoder.Buffered() io.Reader
### Decoder.Decode(v interface{}) error
### Decoder.DisallowUnknownFields()
### Decoder.More() bool
### Decoder.Token() (Token, error)

Token returns the next JSON token in the input stream. At the end of the input stream, Token returns nil, io.EOF.

Token guarantees that the delimiters [ ] { } it returns are properly nested and matched: if Token encounters an unexpected delimiter in the input, it will return an error.

The input stream consists of basic JSON values—bool, string, number, and null—along with delimiters [ ] { } of type Delim to mark the start and end of arrays and objects. Commas and colons are elided.

Example
This example uses a Decoder to decode a stream of distinct JSON values.

    const jsonStream = `
        {"Message": "Hello", "Array": [1, 2, 3], "Null": null, "Number": 1.234}
    `
    dec := json.NewDecoder(strings.NewReader(jsonStream))
    for {
        t, err := dec.Token()
        if err == io.EOF {
            break
        }
        if err != nil {
            log.Fatal(err)
        }
        fmt.Printf("%T: %v", t, t)
        if dec.More() {
            fmt.Printf(" (more)")
        }
        fmt.Printf("\n")
    }

Output:

    json.Delim: { (more)
    string: Message (more)
    string: Hello (more)
    string: Array (more)
    json.Delim: [ (more)
    float64: 1 (more)
    float64: 2 (more)
    float64: 3
    json.Delim: ] (more)
    string: Null (more)
    <nil>: <nil> (more)
    string: Number (more)
    float64: 1.234
    json.Delim: }

### Decoder.UseNumber()

## type Delim
A Delim is a JSON array or object delimiter, one of [ ] { or }.

### Delim.String() string


## type Encoder

    type Encoder struct {
        // contains filtered or unexported fields
    }

An Encoder writes JSON values to an output stream.

### json.NewEncoder(w io.Writer) `*Encoder`
### Encoder.Encode(v interface{}) error
Encode writes the JSON encoding of v to the stream, followed by a newline character.

See the documentation for Marshal for details about the conversion of Go values to JSON.

### Encoder.SetEscapeHTML(on bool)
SetEscapeHTML specifies whether problematic HTML characters should be escaped inside JSON quoted strings. The default behavior is to escape &, <, and > to \u0026, \u003c, and \u003e to avoid certain safety problems that can arise when embedding JSON in HTML.

In non-HTML settings where the escaping interferes with the readability of the output, SetEscapeHTML(false) disables this behavior.

### Encoder.SetIndent(prefix, indent string)

## type InvalidUTF8Error
### InvalidUTF8Error.Error() string

## type InvalidUnmarshalError
### InvalidUnmarshalError.Error() string

## type Marshaler

## type MarshalerError
### MarshalerError.Error() string

## type Number
### Number.Float64() (float64, error)
### Number.Int64() (int64, error)
### Number.String() string

## type RawMessage

    type RawMessage []byte

RawMessage is a raw encoded JSON value. It implements Marshaler and Unmarshaler and can be used to delay JSON decoding or precompute a JSON encoding.

Example (Marshal)
This example uses RawMessage to use a precomputed JSON during marshal.

    h := json.RawMessage(`{"precomputed": true}`)

    c := struct {
        Header *json.RawMessage `json:"header"`
        Body   string           `json:"body"`
    }{Header: &h, Body: "Hello Gophers!"}

    b, err := json.MarshalIndent(&c, "", "\t")
    if err != nil {
        fmt.Println("error:", err)
    }
    os.Stdout.Write(b)

Output:

    {
        "header": {
            "precomputed": true
        },
        "body": "Hello Gophers!"
    }

Example (Unmarshal)
This example uses RawMessage to delay parsing part of a JSON message.

    Code:play 

    type Color struct {
        Space string
        Point json.RawMessage // delay parsing until we know the color space
    }
    type RGB struct {
        R   uint8
        G   uint8
        B   uint8
    }
    type YCbCr struct {
        Y   uint8
        Cb  int8
        Cr  int8
    }

    var j = []byte(`[
        {"Space": "YCbCr", "Point": {"Y": 255, "Cb": 0, "Cr": -10}},
        {"Space": "RGB",   "Point": {"R": 98, "G": 218, "B": 255}}
    ]`)
    var colors []Color
    err := json.Unmarshal(j, &colors)
    if err != nil {
        log.Fatalln("error:", err)
    }

    for _, c := range colors {
        var dst interface{}
        switch c.Space {
        case "RGB":
            dst = new(RGB)
        case "YCbCr":
            dst = new(YCbCr)
        }
        err := json.Unmarshal(c.Point, dst)
        if err != nil {
            log.Fatalln("error:", err)
        }
        fmt.Println(c.Space, dst)
    }

Output:

    YCbCr &{255 0 -10}
    RGB &{98 218 255}

### RawMessage.MarshalJSON() ([]byte, error)
### RawMessage.UnmarshalJSON(data []byte) error

## type SyntaxError
### SyntaxError.Error() string

## type Token

    type Token interface{}

A Token holds a value of one of these types:

    Delim,    for the four JSON delimiters [ ] { }
    bool,     for JSON booleans
    float64,  for JSON numbers
    Number,   for JSON numbers
    string,   for JSON string literals
    nil,      for JSON null

## type UnmarshalFieldError
### UnmarshalFieldError.Error() string

## type UnmarshalTypeError
### UnmarshalTypeError.Error() string

## type Unmarshaler

## type UnsupportedTypeError
### UnsupportedTypeError.Error() string

## type UnsupportedValueError
### UnsupportedValueError.Error() string



# package net
[GO DOC - net](https://godoc.org/net)

    import "net"

Package net provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets.

Although the package provides access to low-level networking primitives, most clients will need only the basic interface provided by the Dial, Listen, and Accept functions and the associated Conn and Listener interfaces. The crypto/tls package uses the same interfaces and similar Dial and Listen functions.

The Dial function connects to a server:

    conn, err := net.Dial("tcp", "golang.org:80")
    if err != nil {
        // handle error
    }
    fmt.Fprintf(conn, "GET / HTTP/1.0\r\n\r\n")
    status, err := bufio.NewReader(conn).ReadString('\n')
    // ...
    The Listen function creates servers:

    ln, err := net.Listen("tcp", ":8080")
    if err != nil {
        // handle error
    }
    for {
        conn, err := ln.Accept()
        if err != nil {
            // handle error
        }
        go handleConnection(conn)
    }

## Name Resolution
The method for resolving domain names, whether indirectly with functions like Dial or directly with functions like LookupHost and LookupAddr, varies by operating system.

On Unix systems, the resolver has two options for resolving names. It can use a pure Go resolver that sends DNS requests directly to the servers listed in /etc/resolv.conf, or it can use a cgo-based resolver that calls C library routines such as getaddrinfo and getnameinfo.

By default the pure Go resolver is used, because a blocked DNS request consumes only a goroutine, while a blocked C call consumes an operating system thread. When cgo is available, the cgo-based resolver is used instead under a variety of conditions: on systems that do not let programs make direct DNS requests (OS X), when the LOCALDOMAIN environment variable is present (even if empty), when the RES_OPTIONS or HOSTALIASES environment variable is non-empty, when the ASR_CONFIG environment variable is non-empty (OpenBSD only), when /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the Go resolver does not implement, and when the name being looked up ends in .local or is an mDNS name.

The resolver decision can be overridden by setting the netdns value of the GODEBUG environment variable (see package runtime) to go or cgo, as in:

    export GODEBUG=netdns=go    # force pure Go resolver
    export GODEBUG=netdns=cgo   # force cgo resolver
    The decision can also be forced while building the Go source tree by setting the netgo or netcgo build tag.

A numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver to print debugging information about its decisions. To force a particular resolver while also printing debugging information, join the two settings by a plus sign, as in GODEBUG=netdns=go+1.

On Plan 9, the resolver always accesses /net/cs and /net/dns.

On Windows, the resolver always uses C library functions, such as GetAddrInfo and DnsQuery.

### net.JoinHostPort(host, port string) string
### net.LookupAddr(addr string) (names []string, err error)
### net.LookupCNAME(host string) (cname string, err error)
### net.LookupHost(host string) (addrs []string, err error)
### net.LookupPort(network, service string) (port int, err error)
### net.LookupTXT(name string) ([]string, error)
### net.ParseCIDR(s string) (IP, `*IPNet`, error)
### net.Pipe() (Conn, Conn)
### net.SplitHostPort(hostport string) (host, port string, err error)

## type Addr
### net.InterfaceAddrs() ([]Addr, error)

## type AddrError
### AddrError.Error() string
### AddrError.Temporary() bool
### AddrError.Timeout() bool

## type Buffers
### Buffers.Read(p []byte) (n int, err error)
### Buffers.WriteTo(w io.Writer) (n int64, err error)

## type Conn
### net.Dial(network, address string) (Conn, error)
### net.DialTimeout(network, address string, timeout time.Duration) (Conn, error)
### net.FileConn(f `*os.File`) (c Conn, err error)

## type DNSConfigError
### DNSConfigError.Error() string
### DNSConfigError.Temporary() bool
### DNSConfigError.Timeout() bool

## type DNSError
### DNSError.Error() string
### DNSError.Temporary() bool
### DNSError.Timeout() bool

## type Dialer
### Dialer.Dial(network, address string) (Conn, error)
### Dialer.DialContext(ctx context.Context, network, address string) (Conn, error)

## type Error

## type Flags
### Flags.String() string

## type HardwareAddr
### net.ParseMAC(s string) (hw HardwareAddr, err error)
### HardwareAddr.String() string

## type IP
### net.IPv4(a, b, c, d byte) IP
### net.LookupIP(host string) ([]IP, error)
### net.ParseIP(s string) IP
### IP.DefaultMask() IPMask
### IP.Equal(x IP) bool
### IP.IsGlobalUnicast() bool
### IP.IsInterfaceLocalMulticast() bool
### IP.IsLinkLocalMulticast() bool
### IP.IsLinkLocalUnicast() bool
### IP.IsLoopback() bool
### IP.IsMulticast() bool
### IP.IsUnspecified() bool
### IP.MarshalText() ([]byte, error)
### IP.Mask(mask IPMask) IP
### IP.String() string
### IP.To16() IP
### IP.To4() IP
### IP.UnmarshalText(text []byte) error

## type IPAddr
### net.ResolveIPAddr(network, address string) (`*IPAddr`, error)
### IPAddr.Network() string
### IPAddr.String() string

## type IPConn
### net.DialIP(network string, laddr, raddr `*IPAddr`) (`*IPConn`, error)
DialIP acts like Dial for IP networks.

The network must be an IP network name; see func Dial for details.

If laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed.

### net.ListenIP(network string, laddr `*IPAddr`) (`*IPConn`, error)
ListenIP acts like ListenPacket for IP networks.

The network must be an IP network name; see func Dial for details.

If the IP field of laddr is nil or an unspecified IP address, ListenIP listens on all available IP addresses of the local system except multicast IP addresses.


### IPConn.Close() error
### IPConn.File() (f `*os.File`, err error)
### IPConn.LocalAddr() Addr
### IPConn.Read(b []byte) (int, error)
### IPConn.ReadFrom(b []byte) (int, Addr, error)
### IPConn.ReadFromIP(b []byte) (int, `*IPAddr`, error)
### IPConn.ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr `*IPAddr`, err error)
### IPConn.RemoteAddr() Addr
### IPConn.SetDeadline(t time.Time) error
### IPConn.SetReadBuffer(bytes int) error
### IPConn.SetReadDeadline(t time.Time) error
### IPConn.SetWriteBuffer(bytes int) error
### IPConn.SetWriteDeadline(t time.Time) error
### IPConn.SyscallConn() (syscall.RawConn, error)
### IPConn.Write(b []byte) (int, error)
### IPConn.WriteMsgIP(b, oob []byte, addr `*IPAddr`) (n, oobn int, err error)
### IPConn.WriteTo(b []byte, addr Addr) (int, error)
### IPConn.WriteToIP(b []byte, addr `*IPAddr`) (int, error)

## type IPMask
### net.CIDRMask(ones, bits int) IPMask
### net.IPv4Mask(a, b, c, d byte) IPMask
### IPMask.Size() (ones, bits int)
### IPMask.String() string

## type IPNet
### IPNet.Contains(ip IP) bool
### IPNet.Network() string
### IPNet.String() string

## type Interface
### net.InterfaceByIndex(index int) (`*Interface`, error)
### net.InterfaceByName(name string) (`*Interface`, error)
### net.Interfaces() ([]Interface, error)
### Interface.Addrs() ([]Addr, error)
### Interface.MulticastAddrs() ([]Addr, error)

## type InvalidAddrError
### InvalidAddrError.Error() string
### InvalidAddrError.Temporary() bool
### InvalidAddrError.Timeout() bool

## type ListenConfig
### ListenConfig.Listen(ctx context.Context, network, address string) (Listener, error)
### ListenConfig.ListenPacket(ctx context.Context, network, address string) (PacketConn, error)

## type Listener
### net.FileListener(f `*os.File`) (ln Listener, err error)
FileListener returns a copy of the network listener corresponding to the open file f. It is the caller's responsibility to close ln when finished. Closing ln does not affect f, and closing f does not affect ln.


### net.Listen(network, address string) (Listener, error)
Listen announces on the local network address.

The network must be "tcp", "tcp4", "tcp6", "unix" or "unixpacket".

For TCP networks, if the host in the address parameter is empty or a literal unspecified IP address, Listen listens on all available unicast and anycast IP addresses of the local system. To only use IPv4, use network "tcp4". The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or "0", as in "127.0.0.1:" or "[::1]:0", a port number is automatically chosen. The Addr method of Listener can be used to discover the chosen port.

See func Dial for a description of the network and address parameters.


## type MX
### net.LookupMX(name string) (`[]*MX`, error)

## type NS
### net.LookupNS(name string) (`[]*NS`, error)

## type OpError
### OpError.Error() string
### OpError.Temporary() bool
### OpError.Timeout() bool

## type PacketConn
### net.FilePacketConn(f `*os.File`) (c PacketConn, err error)
### net.ListenPacket(network, address string) (PacketConn, error)

## type ParseError
### ParseError.Error() string

## type Resolver
### Resolver.LookupAddr(ctx context.Context, addr string) (names []string, err error)
### Resolver.LookupCNAME(ctx context.Context, host string) (cname string, err error)
### Resolver.LookupHost(ctx context.Context, host string) (addrs []string, err error)
### Resolver.LookupIPAddr(ctx context.Context, host string) ([]IPAddr, error)
### Resolver.LookupMX(ctx context.Context, name string) (`[]*MX`, error)
### Resolver.LookupNS(ctx context.Context, name string) (`[]*NS`, error)
### Resolver.LookupPort(ctx context.Context, network, service string) (port int, err error)
### Resolver.LookupSRV(ctx context.Context, service, proto, name string) (cname string, addrs `[]*SRV`, err error)
### Resolver.LookupTXT(ctx context.Context, name string) ([]string, error)

## type SRV
### net.LookupSRV(service, proto, name string) (cname string, addrs `[]*SRV`, err error)

## type TCPAddr
### net.ResolveTCPAddr(network, address string) (`*TCPAddr`, error)
### TCPAddr.Network() string
### TCPAddr.String() string

## type TCPConn
### net.DialTCP(network string, laddr, raddr `*TCPAddr`) (`*TCPConn`, error)
### TCPConn.Close() error
### TCPConn.CloseRead() error
### TCPConn.CloseWrite() error
### TCPConn.File() (f `*os.File`, err error)
### TCPConn.LocalAddr() Addr
### TCPConn.Read(b []byte) (int, error)
### TCPConn.ReadFrom(r io.Reader) (int64, error)
### TCPConn.RemoteAddr() Addr
### TCPConn.SetDeadline(t time.Time) error
### TCPConn.SetKeepAlive(keepalive bool) error
### TCPConn.SetKeepAlivePeriod(d time.Duration) error
### TCPConn.SetLinger(sec int) error
### TCPConn.SetNoDelay(noDelay bool) error
### TCPConn.SetReadBuffer(bytes int) error
### TCPConn.SetReadDeadline(t time.Time) error
### TCPConn.SetWriteBuffer(bytes int) error
### TCPConn.SetWriteDeadline(t time.Time) error
### TCPConn.SyscallConn() (syscall.RawConn, error)
### TCPConn.Write(b []byte) (int, error)

## type TCPListener
### net.ListenTCP(network string, laddr `*TCPAddr`) (`*TCPListener`, error)
### TCPListener.Accept() (Conn, error)
### TCPListener.AcceptTCP() (`*TCPConn`, error)
### TCPListener.Addr() Addr
### TCPListener.Close() error
### TCPListener.File() (f `*os.File`, err error)
### TCPListener.SetDeadline(t time.Time) error
### TCPListener.SyscallConn() (syscall.RawConn, error)

## type UDPAddr
### net.ResolveUDPAddr(network, address string) (`*UDPAddr`, error)
### UDPAddr.Network() string
### UDPAddr.String() string

## type UDPConn
### net.DialUDP(network string, laddr, raddr `*UDPAddr`) (`*UDPConn`, error)
### net.ListenMulticastUDP(network string, ifi `*Interface`, gaddr `*UDPAddr`) (`*UDPConn`, error)
### net.ListenUDP(network string, laddr `*UDPAddr`) (`*UDPConn`, error)
### UDPConn.Close() error
### UDPConn.File() (f `*os.File`, err error)
### UDPConn.LocalAddr() Addr
### UDPConn.Read(b []byte) (int, error)
### UDPConn.ReadFrom(b []byte) (int, Addr, error)
### UDPConn.ReadFromUDP(b []byte) (int, `*UDPAddr`, error)
### UDPConn.ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr `*UDPAddr`, err error)
### UDPConn.RemoteAddr() Addr
### UDPConn.SetDeadline(t time.Time) error
### UDPConn.SetReadBuffer(bytes int) error
### UDPConn.SetReadDeadline(t time.Time) error
### UDPConn.SetWriteBuffer(bytes int) error
### UDPConn.SetWriteDeadline(t time.Time) error
### UDPConn.SyscallConn() (syscall.RawConn, error)
### UDPConn.Write(b []byte) (int, error)
### UDPConn.WriteMsgUDP(b, oob []byte, addr `*UDPAddr`) (n, oobn int, err error)
### UDPConn.WriteTo(b []byte, addr Addr) (int, error)
### UDPConn.WriteToUDP(b []byte, addr `*UDPAddr`) (int, error)

## type UnixAddr
### net.ResolveUnixAddr(network, address string) (`*UnixAddr`, error)
### UnixAddr.Network() string
### UnixAddr.String() string

## type UnixConn
### net.DialUnix(network string, laddr, raddr `*UnixAddr`) (`*UnixConn`, error)
### net.ListenUnixgram(network string, laddr `*UnixAddr`) (`*UnixConn`, error)
### UnixConn.Close() error
### UnixConn.CloseRead() error
### UnixConn.CloseWrite() error
### UnixConn.File() (f `*os.File`, err error)
### UnixConn.LocalAddr() Addr
### UnixConn.Read(b []byte) (int, error)
### UnixConn.ReadFrom(b []byte) (int, Addr, error)
### UnixConn.ReadFromUnix(b []byte) (int, `*UnixAddr`, error)
### UnixConn.ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr `*UnixAddr`, err error)
### UnixConn.RemoteAddr() Addr
### UnixConn.SetDeadline(t time.Time) error
### UnixConn.SetReadBuffer(bytes int) error
### UnixConn.SetReadDeadline(t time.Time) error
### UnixConn.SetWriteBuffer(bytes int) error
### UnixConn.SetWriteDeadline(t time.Time) error
### UnixConn.SyscallConn() (syscall.RawConn, error)
### UnixConn.Write(b []byte) (int, error)
### UnixConn.WriteMsgUnix(b, oob []byte, addr `*UnixAddr`) (n, oobn int, err error)
### UnixConn.WriteTo(b []byte, addr Addr) (int, error)
### UnixConn.WriteToUnix(b []byte, addr `*UnixAddr`) (int, error)

## type UnixListener
### net.ListenUnix(network string, laddr `*UnixAddr`) (`*UnixListener`, error)
### UnixListener.Accept() (Conn, error)
### UnixListener.AcceptUnix() (`*UnixConn`, error)
### UnixListener.Addr() Addr
### UnixListener.Close() error
### UnixListener.File() (f `*os.File`, err error)
### UnixListener.SetDeadline(t time.Time) error
### UnixListener.SetUnlinkOnClose(unlink bool)
### UnixListener.SyscallConn() (syscall.RawConn, error)

## type UnknownNetworkError
### UnknownNetworkError.Error() string
### UnknownNetworkError.Temporary() bool
### UnknownNetworkError.Timeout() bool


# package http
[net/http](https://godoc.org/net/http)

    import "net/http"

Package http provides HTTP client and server implementations.

Get, Head, Post, and PostForm make HTTP (or HTTPS) requests:

    resp, err := http.Get("http://example.com/")
    ...
    resp, err := http.Post("http://example.com/upload", "image/jpeg", &buf)
    ...
    resp, err := http.PostForm("http://example.com/form",
        url.Values{"key": {"Value"}, "id": {"123"}})

The client must close the response body when finished with it:

    resp, err := http.Get("http://example.com/")
    if err != nil {
        // handle error
    }
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    // ...

For control over HTTP client headers, redirect policy, and other settings, create a Client:

    client := &http.Client{
        CheckRedirect: redirectPolicyFunc,
    }

    resp, err := client.Get("http://example.com")
    // ...

    req, err := http.NewRequest("GET", "http://example.com", nil)
    // ...
    req.Header.Add("If-None-Match", `W/"wyzzy"`)
    resp, err := client.Do(req)
    // ...

For control over proxies, TLS configuration, keep-alives, compression, and other settings, create a Transport:

    tr := &http.Transport{
        MaxIdleConns:       10,
        IdleConnTimeout:    30 * time.Second,
        DisableCompression: true,
    }
    client := &http.Client{Transport: tr}
    resp, err := client.Get("https://example.com")

Clients and Transports are safe for concurrent use by multiple goroutines and for efficiency should only be created once and re-used.

ListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use DefaultServeMux. Handle and HandleFunc add handlers to DefaultServeMux:

    http.Handle("/foo", fooHandler)

    http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))
    })

    log.Fatal(http.ListenAndServe(":8080", nil))

More control over the server's behavior is available by creating a custom Server:

    s := &http.Server{
        Addr:           ":8080",
        Handler:        myHandler,
        ReadTimeout:    10 * time.Second,
        WriteTimeout:   10 * time.Second,
        MaxHeaderBytes: 1 << 20,
    }
    log.Fatal(s.ListenAndServe())

Starting with Go 1.6, the http package has transparent support for the HTTP/2 protocol when using HTTPS. Programs that must disable HTTP/2 can do so by setting Transport.TLSNextProto (for clients) or Server.TLSNextProto (for servers) to a non-nil, empty map. Alternatively, the following GODEBUG environment variables are currently supported:

    GODEBUG=http2client=0  # disable HTTP/2 client support
    GODEBUG=http2server=0  # disable HTTP/2 server support
    GODEBUG=http2debug=1   # enable verbose HTTP/2 debug logs
    GODEBUG=http2debug=2   # ... even more verbose, with frame dumps

The GODEBUG variables are not covered by Go's API compatibility promise. Please report any issues before disabling HTTP/2 support: https://golang.org/s/http2bug

The http package's Transport and Server both automatically enable HTTP/2 support for simple configurations. To enable HTTP/2 for more complex configurations, to use lower-level HTTP/2 features, or to use a newer version of Go's http2 package, import "golang.org/x/net/http2" directly and use its ConfigureTransport and/or ConfigureServer functions. Manually configuring HTTP/2 via the golang.org/x/net/http2 package takes precedence over the net/http package's built-in HTTP/2 support.

### http.CanonicalHeaderKey(s string) string
### http.DetectContentType(data []byte) string
### http.Error(w ResponseWriter, error string, code int)
### http.Handle(pattern string, handler Handler)
Handle registers the handler for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.

Example

    package main

    import (
        "fmt"
        "log"
        "net/http"
        "sync"
    )

    type countHandler struct {
        mu  sync.Mutex // guards n
        n   int
    }

    func (h *countHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
        h.mu.Lock()
        defer h.mu.Unlock()
        h.n++
        fmt.Fprintf(w, "count is %d\n", h.n)
    }

    func main() {
        http.Handle("/count", new(countHandler))
        log.Fatal(http.ListenAndServe(":8080", nil))
    }

### http.HandleFunc(pattern string, handler func(ResponseWriter, `*Request`))
### http.ListenAndServe(addr string, handler Handler) error
### http.ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error
### http.MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser
### http.NotFound(w ResponseWriter, r `*Request`)
### http.ParseHTTPVersion(vers string) (major, minor int, ok bool)
### http.ParseTime(text string) (t time.Time, err error)
### http.ProxyFromEnvironment(req `*Request`) (`*url`.URL, error)
### http.ProxyURL(fixedURL `*url`.URL) func(`*Request`) (`*url`.URL, error)
### http.Redirect(w ResponseWriter, r `*Request`, url string, code int)
### http.Serve(l net.Listener, handler Handler) error
### http.ServeContent(w ResponseWriter, req `*Request`, name string, modtime time.Time, content io.ReadSeeker)
### http.ServeFile(w ResponseWriter, r `*Request`, name string)
### http.ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error
### http.SetCookie(w ResponseWriter, cookie `*Cookie`)
### http.StatusText(code int) string

## type Client
### Client.CloseIdleConnections()
### Client.Do(req `*Request`) (`*Response`, error)
### Client.Get(url string) (resp `*Response`, err error)
### Client.Head(url string) (resp `*Response`, err error)
### Client.Post(url, contentType string, body io.Reader) (resp `*Response`, err error)
### Client.PostForm(url string, data url.Values) (resp `*Response`, err error)

## type CloseNotifier

## type ConnState
### ConnState.String() string

## type Cookie

    type Cookie struct {
        Name  string
        Value string

        Path       string    // optional
        Domain     string    // optional
        Expires    time.Time // optional
        RawExpires string    // for reading cookies only

        // MaxAge=0 means no 'Max-Age' attribute specified.
        // MaxAge<0 means delete cookie now, equivalently 'Max-Age: 0'
        // MaxAge>0 means Max-Age attribute present and given in seconds
        MaxAge   int
        Secure   bool
        HttpOnly bool
        SameSite SameSite
        Raw      string
        Unparsed []string // Raw text of unparsed attribute-value pairs
    }

A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request.

iris session.go code example:

    func (s *Sessions) updateCookie(ctx context.Context, sid string, expires time.Duration) {
        cookie := &http.Cookie{}

        cookie.Name = s.config.Cookie

        cookie.Value = sid
        cookie.Path = "/"
        cookie.Domain = formatCookieDomain(ctx, s.config.DisableSubdomainPersistence)
        cookie.HttpOnly = true
        // MaxAge=0 means no 'Max-Age' attribute specified.
        // MaxAge<0 means delete cookie now, equivalently 'Max-Age: 0'
        // MaxAge>0 means Max-Age attribute present and given in seconds
        if expires >= 0 {
            if expires == 0 { // unlimited life
                cookie.Expires = CookieExpireUnlimited
            } else { // > 0
                cookie.Expires = time.Now().Add(expires)
            }
            cookie.MaxAge = int(cookie.Expires.Sub(time.Now()).Seconds())
        }

        // set the cookie to secure if this is a tls wrapped request
        // and the configuration allows it.
        if ctx.Request().TLS != nil && s.config.CookieSecureTLS {
            cookie.Secure = true
        }

        // encode the session id cookie client value right before send it.
        cookie.Value = s.encodeCookieValue(cookie.Value)
        AddCookie(ctx, cookie, s.config.AllowReclaim)
    }

See https://tools.ietf.org/html/rfc6265 for details.

### Cookie.String() string

## type CookieJar

## type Dir
### Dir.Open(name string) (File, error)

## type File

## type FileSystem

## type Flusher

## type Handler

    type Handler interface {
        ServeHTTP(ResponseWriter, *Request)
    }

A Handler responds to an HTTP request.

ServeHTTP should write reply headers and data to the ResponseWriter and then return. Returning signals that the request is finished; it is not valid to use the ResponseWriter or read from the Request.Body after or concurrently with the completion of the ServeHTTP call.

Depending on the HTTP client software, HTTP protocol version, and any intermediaries between the client and the Go server, it may not be possible to read from the Request.Body after writing to the ResponseWriter. Cautious handlers should read the Request.Body first, and then reply.

Except for reading the body, handlers should not modify the provided Request.

If ServeHTTP panics, the server (the caller of ServeHTTP) assumes that the effect of the panic was isolated to the active request. It recovers the panic, logs a stack trace to the server error log, and either closes the network connection or sends an HTTP/2 RST_STREAM, depending on the HTTP protocol. To abort a handler so the client sees an interrupted response but the server doesn't log an error, panic with the value ErrAbortHandler.

### http.FileServer(root FileSystem) Handler

FileServer returns a handler that serves HTTP requests with the contents of the file system rooted at root.

To use the operating system's file system implementation, use http.Dir:

    http.Handle("/", http.FileServer(http.Dir("/tmp")))

As a special case, the returned file server redirects any request ending in "/index.html" to the same path, without the final "index.html".

### http.NotFoundHandler() Handler
### http.RedirectHandler(url string, code int) Handler
### http.StripPrefix(prefix string, h Handler) Handler
### http.TimeoutHandler(h Handler, dt time.Duration, msg string) Handler

## type HandlerFunc
### HandlerFunc.ServeHTTP(w ResponseWriter, r `*Request`)

## type Header
### Header.Add(key, value string)
### Header.Del(key string)
### Header.Get(key string) string
### Header.Set(key, value string)
### Header.Write(w io.Writer) error
### Header.WriteSubset(w io.Writer, exclude map[string]bool) error

## type Hijacker

## type ProtocolError
### ProtocolError.Error() string

## type PushOptions

## type Pusher

## type Request
### http.NewRequest(method, url string, body io.Reader) (`*Request`, error)
### http.ReadRequest(b `*bufio`.Reader) (`*Request`, error)
### Request.AddCookie(c `*Cookie`)
AddCookie adds a cookie to the request. Per RFC 6265 section 5.4, AddCookie does not attach more than one Cookie header field. That means all cookies, if any, are written into the same line, separated by semicolon.


### Request.BasicAuth() (username, password string, ok bool)
BasicAuth returns the username and password provided in the request's Authorization header, if the request uses HTTP Basic Authentication. See [RFC 2617, Section 2](http://www.rfc-editor.org/rfc/rfc2617#section-2).

### Request.Context() context.Context
### Request.Cookie(name string) (`*Cookie`, error)
### Request.Cookies() `[]*Cookie`
### Request.FormFile(key string) (multipart.File, `*multipart`.FileHeader, error)
### Request.FormValue(key string) string
### Request.MultipartReader() (`*multipart`.Reader, error)
### Request.ParseForm() error
### Request.ParseMultipartForm(maxMemory int64) error
### Request.PostFormValue(key string) string
### Request.ProtoAtLeast(major, minor int) bool
### Request.Referer() string
### Request.SetBasicAuth(username, password string)
### Request.UserAgent() string
### Request.WithContext(ctx context.Context) `*Request`
### Request.Write(w io.Writer) error
### Request.WriteProxy(w io.Writer) error

## type Response
### http.Get(url string) (resp `*Response`, err error)
### http.Head(url string) (resp `*Response`, err error)
### http.Post(url, contentType string, body io.Reader) (resp `*Response`, err error)
### http.PostForm(url string, data url.Values) (resp `*Response`, err error)
### http.ReadResponse(r `*bufio`.Reader, req `*Request`) (`*Response`, error)
### Response.Cookies() `[]*Cookie`
### Response.Location() (`*url`.URL, error)
### Response.ProtoAtLeast(major, minor int) bool
### Response.Write(w io.Writer) error

## type ResponseWriter

## type RoundTripper
### http.NewFileTransport(fs FileSystem) RoundTripper

## type SameSite

## type ServeMux
### http.NewServeMux() `*ServeMux`
### ServeMux.Handle(pattern string, handler Handler)
### ServeMux.HandleFunc(pattern string, handler func(ResponseWriter, `*Request`))
### ServeMux.Handler(r `*Request`) (h Handler, pattern string)
### ServeMux.ServeHTTP(w ResponseWriter, r `*Request`)

## type Server
### Server.Close() error
### Server.ListenAndServe() error
### Server.ListenAndServeTLS(certFile, keyFile string) error
### Server.RegisterOnShutdown(f func())
### Server.Serve(l net.Listener) error
### Server.ServeTLS(l net.Listener, certFile, keyFile string) error
### Server.SetKeepAlivesEnabled(v bool)
### Server.Shutdown(ctx context.Context) error

Shutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners, then closing all idle connections, and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context's error, otherwise it returns any error returned from closing the Server's underlying Listener(s).

When Shutdown is called, Serve, ListenAndServe, and ListenAndServeTLS immediately return ErrServerClosed. Make sure the program doesn't exit and waits instead for Shutdown to return.

Shutdown does not attempt to close nor wait for hijacked connections such as WebSockets. The caller of Shutdown should separately notify such long-lived connections of shutdown and wait for them to close, if desired. See RegisterOnShutdown for a way to register shutdown notification functions.

Once Shutdown has been called on a server, it may not be reused; future calls to methods such as Serve will return ErrServerClosed.

Example

    var srv http.Server

    idleConnsClosed := make(chan struct{})
    go func() {
        sigint := make(chan os.Signal, 1)
        signal.Notify(sigint, os.Interrupt)
        <-sigint

        // We received an interrupt signal, shut down.
        if err := srv.Shutdown(context.Background()); err != nil {
            // Error from closing listeners, or context timeout:
            log.Printf("HTTP server Shutdown: %v", err)
        }
        close(idleConnsClosed)
    }()

    if err := srv.ListenAndServe(); err != http.ErrServerClosed {
        // Error starting or closing listener:
        log.Printf("HTTP server ListenAndServe: %v", err)
    }

    <-idleConnsClosed


## type Transport
### Transport.CancelRequest(req `*Request`)
### Transport.CloseIdleConnections()
### Transport.RegisterProtocol(scheme string, rt RoundTripper)
### Transport.RoundTrip(req `*Request`) (`*Response`, error)

## HTTP Examples
FileServer
FileServer (DotFileHiding)
FileServer (StripPrefix)
Get
Handle
HandleFunc
Hijacker
ListenAndServe
ListenAndServeTLS
NotFoundHandler
ResponseWriter (Trailers)
ServeMux.Handle
Server.Shutdown
StripPrefix

### HTTP Package Files
client.go cookie.go doc.go filetransport.go fs.go h2_bundle.go header.go http.go jar.go method.go request.go response.go roundtrip.go server.go sniff.go socks_bundle.go status.go transfer.go transport.go

## HTTP Constants
Common HTTP methods.

    const (
        MethodGet     = "GET"
        MethodHead    = "HEAD"
        MethodPost    = "POST"
        MethodPut     = "PUT"
        MethodPatch   = "PATCH" // RFC 5789
        MethodDelete  = "DELETE"
        MethodConnect = "CONNECT"
        MethodOptions = "OPTIONS"
        MethodTrace   = "TRACE"
    )

Unless otherwise noted, these are defined in RFC 7231 section 4.3.

    const (
        StatusContinue           = 100 // RFC 7231, 6.2.1
        StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2
        StatusProcessing         = 102 // RFC 2518, 10.1

        StatusOK                   = 200 // RFC 7231, 6.3.1
        StatusCreated              = 201 // RFC 7231, 6.3.2
        StatusAccepted             = 202 // RFC 7231, 6.3.3
        StatusNonAuthoritativeInfo = 203 // RFC 7231, 6.3.4
        StatusNoContent            = 204 // RFC 7231, 6.3.5
        StatusResetContent         = 205 // RFC 7231, 6.3.6
        StatusPartialContent       = 206 // RFC 7233, 4.1
        StatusMultiStatus          = 207 // RFC 4918, 11.1
        StatusAlreadyReported      = 208 // RFC 5842, 7.1
        StatusIMUsed               = 226 // RFC 3229, 10.4.1

        StatusMultipleChoices  = 300 // RFC 7231, 6.4.1
        StatusMovedPermanently = 301 // RFC 7231, 6.4.2
        StatusFound            = 302 // RFC 7231, 6.4.3
        StatusSeeOther         = 303 // RFC 7231, 6.4.4
        StatusNotModified      = 304 // RFC 7232, 4.1
        StatusUseProxy         = 305 // RFC 7231, 6.4.5

        StatusTemporaryRedirect = 307 // RFC 7231, 6.4.7
        StatusPermanentRedirect = 308 // RFC 7538, 3

        StatusBadRequest                   = 400 // RFC 7231, 6.5.1
        StatusUnauthorized                 = 401 // RFC 7235, 3.1
        StatusPaymentRequired              = 402 // RFC 7231, 6.5.2
        StatusForbidden                    = 403 // RFC 7231, 6.5.3
        StatusNotFound                     = 404 // RFC 7231, 6.5.4
        StatusMethodNotAllowed             = 405 // RFC 7231, 6.5.5
        StatusNotAcceptable                = 406 // RFC 7231, 6.5.6
        StatusProxyAuthRequired            = 407 // RFC 7235, 3.2
        StatusRequestTimeout               = 408 // RFC 7231, 6.5.7
        StatusConflict                     = 409 // RFC 7231, 6.5.8
        StatusGone                         = 410 // RFC 7231, 6.5.9
        StatusLengthRequired               = 411 // RFC 7231, 6.5.10
        StatusPreconditionFailed           = 412 // RFC 7232, 4.2
        StatusRequestEntityTooLarge        = 413 // RFC 7231, 6.5.11
        StatusRequestURITooLong            = 414 // RFC 7231, 6.5.12
        StatusUnsupportedMediaType         = 415 // RFC 7231, 6.5.13
        StatusRequestedRangeNotSatisfiable = 416 // RFC 7233, 4.4
        StatusExpectationFailed            = 417 // RFC 7231, 6.5.14
        StatusTeapot                       = 418 // RFC 7168, 2.3.3
        StatusMisdirectedRequest           = 421 // RFC 7540, 9.1.2
        StatusUnprocessableEntity          = 422 // RFC 4918, 11.2
        StatusLocked                       = 423 // RFC 4918, 11.3
        StatusFailedDependency             = 424 // RFC 4918, 11.4
        StatusTooEarly                     = 425 // RFC 8470, 5.2.
        StatusUpgradeRequired              = 426 // RFC 7231, 6.5.15
        StatusPreconditionRequired         = 428 // RFC 6585, 3
        StatusTooManyRequests              = 429 // RFC 6585, 4
        StatusRequestHeaderFieldsTooLarge  = 431 // RFC 6585, 5
        StatusUnavailableForLegalReasons   = 451 // RFC 7725, 3

        StatusInternalServerError           = 500 // RFC 7231, 6.6.1
        StatusNotImplemented                = 501 // RFC 7231, 6.6.2
        StatusBadGateway                    = 502 // RFC 7231, 6.6.3
        StatusServiceUnavailable            = 503 // RFC 7231, 6.6.4
        StatusGatewayTimeout                = 504 // RFC 7231, 6.6.5
        StatusHTTPVersionNotSupported       = 505 // RFC 7231, 6.6.6
        StatusVariantAlsoNegotiates         = 506 // RFC 2295, 8.1
        StatusInsufficientStorage           = 507 // RFC 4918, 11.5
        StatusLoopDetected                  = 508 // RFC 5842, 7.2
        StatusNotExtended                   = 510 // RFC 2774, 7
        StatusNetworkAuthenticationRequired = 511 // RFC 6585, 6
    )




