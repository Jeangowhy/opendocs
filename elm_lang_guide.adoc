:source-highlighter: highlight.js
:icons: font
:online: https://guide.elm-lang.org/
:source: https://github.com/evancz/guide.elm-lang.org

[source,bash]
----
# git clone https://github.com/evancz/guide.elm-lang.org
# cd guide.elm-lang
while read -r it
do
pandoc --wrap=preserve -tasciidoc -rmarkdown $it >> $0
done << EOF
book/README.md
EOF
exit
----

[role="big text-center"]
****
*_An Introduction to Elm_* +
Learn the basics of Elm. Build applications. Learn functional programming. +
by Evan Czaplicki
****

[[toc]]

== TOC

• <<c01, 1 ⿻ An Introduction to Elm>>
• <<c02, 2 ⿻>> https://guide.elm-lang.org/core_language.html
• <<c03, 3 ⿻>> https://guide.elm-lang.org/architecture/
** <<s3.1, 3.1 ▣>> https://guide.elm-lang.org/architecture/buttons.html
** <<s3.2, 3.2 ▣>> https://guide.elm-lang.org/architecture/text_fields.html
** <<s3.3, 3.3 ▣>> https://guide.elm-lang.org/architecture/forms.html
• <<c04, 4 ⿻>> https://guide.elm-lang.org/types/
** <<s4.1, 4.1 ▣>> https://guide.elm-lang.org/types/reading_types.html
** <<s4.2, 4.2 ▣>> https://guide.elm-lang.org/types/type_aliases.html
** <<s4.3, 4.3 ▣>> https://guide.elm-lang.org/types/custom_types.html
** <<s4.4, 4.4 ▣>> https://guide.elm-lang.org/types/pattern_matching.html
• <<c05, 5 ⿻>> https://guide.elm-lang.org/error_handling/
** <<s5.1, 5.1 ▣>> https://guide.elm-lang.org/error_handling/maybe.html
** <<s5.2, 5.2 ▣>> https://guide.elm-lang.org/error_handling/result.html
• <<c06, 6 ⿻>> https://guide.elm-lang.org/effects/
** <<s6.1, 6.1 ▣>> https://guide.elm-lang.org/effects/http.html
** <<s6.2, 6.2 ▣>> https://guide.elm-lang.org/effects/json.html
** <<s6.3, 6.3 ▣>> https://guide.elm-lang.org/effects/random.html
** <<s6.4, 6.4 ▣>> https://guide.elm-lang.org/effects/time.html
• <<c07, 7 ⿻>> https://guide.elm-lang.org/install/
** <<s7.1, 7.1 ▣>> https://guide.elm-lang.org/install/editor.html
** <<s7.2, 7.2 ▣>> https://guide.elm-lang.org/install/elm.html
• <<c08, 8 ⿻>> https://guide.elm-lang.org/interop/
** <<s8.1, 8.1 ▣>> https://guide.elm-lang.org/interop/flags.html
** <<s8.2, 8.2 ▣>> https://guide.elm-lang.org/interop/ports.html
** <<s8.3, 8.3 ▣>> https://guide.elm-lang.org/interop/custom_elements.html
** <<s8.4, 8.4 ▣>> https://guide.elm-lang.org/interop/limits.html
• <<c09, 9 ⿻>> https://guide.elm-lang.org/webapps/
** <<s9.1, 9.1 ▣>> https://guide.elm-lang.org/webapps/navigation.html
** <<s9.2, 9.2 ▣>> https://guide.elm-lang.org/webapps/url_parsing.html
** <<s9.3, 9.3 ▣>> https://guide.elm-lang.org/webapps/modules.html
** <<s9.4, 9.4 ▣>> https://guide.elm-lang.org/webapps/structure.html
• <<c10, 10 ⿻>> https://guide.elm-lang.org/optimization/
** <<s10.1, 10.1 ▣>> https://guide.elm-lang.org/optimization/lazy.html
** <<s10.2, 10.2 ▣>> https://guide.elm-lang.org/optimization/keyed.html
** <<s10.3, 10.3 ▣>> https://guide.elm-lang.org/optimization/asset_size.html
• <<c11, 11 ⿻>> https://guide.elm-lang.org/next_steps.html
• <<c12, 12 Appendix ⿻>>
** <<s12.1, 12.1 ▣>> https://guide.elm-lang.org/appendix/types_as_sets.html
** <<s12.2, 12.2 ▣>> https://guide.elm-lang.org/appendix/types_as_bits.html
** <<s12.3, 12.3 ▣>> https://guide.elm-lang.org/appendix/function_types.html

:api_import: https://github.com/elm/compiler/blob/master/hints/imports.md
:api_html: https://package.elm-lang.org/packages/elm/html/1.0.0/
:Basics_plus: https://package.elm-lang.org/packages/elm/core/latest/Basics#+
:Basics_div: https://package.elm-lang.org/packages/elm/core/latest/Basics#/
:Basics_pp: https://package.elm-lang.org/packages/elm/core/latest/Basics#++
:Basics: https://package.elm-lang.org/packages/elm/core/latest/Basics
:api_List: https://package.elm-lang.org/packages/elm/core/latest/List
:api_List-length: https://package.elm-lang.org/packages/elm/core/latest/List#length
:api_List-reverse: https://package.elm-lang.org/packages/elm/core/latest/List#reverse
:api_Maybe: https://package.elm-lang.org/packages/elm-lang/core/latest/Maybe#Maybe
:api_String-toFloat: https://package.elm-lang.org/packages/elm-lang/core/latest/String#toFloat
:api_Result: https://package.elm-lang.org/packages/elm-lang/core/latest/Result#Result
:api_sandbox: https://package.elm-lang.org/packages/elm/browser/latest/Browser#sandbox
:api_element: https://package.elm-lang.org/packages/elm/browser/latest/Browser#element
:api_http-get: https://package.elm-lang.org/packages/elm/http/latest/Http#get
:api_http-Error: https://package.elm-lang.org/packages/elm/http/latest/Http#Error
:api_decode: https://package.elm-lang.org/packages/elm/json/latest/Json-Decode
:api_field: https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#field
:api_readme: https://package.elm-lang.org/packages/elm/random/latest
:api_Random-gen: https://package.elm-lang.org/packages/elm/random/latest/Random#generate
:api_Random-weighted: https://package.elm-lang.org/packages/elm/random/latest/Random#weighted
:api_Time-toHour: https://package.elm-lang.org/packages/elm/time/latest/Time#toHour
:api_Time-every: https://package.elm-lang.org/packages/elm/time/latest/Time#every
:api_Time-utc: https://package.elm-lang.org/packages/elm/time/latest/Time#utc
:api_task: https://package.elm-lang.org/packages/elm/core/latest/Task
:api_style: https://package.elm-lang.org/packages/elm/html/latest/Html-Attributes#style
:api_url: https://package.elm-lang.org/packages/elm/url/latest/Url#Url
:api_urlreq: https://package.elm-lang.org/packages/elm/browser/latest/Browser#UrlRequest
:api_pipe: https://package.elm-lang.org/packages/elm/core/latest/Basics#|>
:api_String-length: https://package.elm-lang.org/packages/elm/core/latest/String#length
:api_String: https://package.elm-lang.org/packages/elm/core/latest/String
:api_Basics-negate: https://package.elm-lang.org/packages/elm/core/latest/Basics#negate
:api_core: https://package.elm-lang.org/packages/elm/core/latest/
:api_html: https://package.elm-lang.org/packages/elm/html/latest/
:api_http: https://package.elm-lang.org/packages/elm/http/latest/
:api_json: https://package.elm-lang.org/packages/elm/json/latest/
:api_random: https://package.elm-lang.org/packages/elm/random/latest/
:api_time: https://package.elm-lang.org/packages/elm/time/latest/
:api_Json-Decode-map2: https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#map2
:api_Json-Decode-bool: https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#bool
:api_Json-Decode-list: https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#list
:api_Json-Decode-dict: https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#dict
:api_Json-Decode-oneOf: https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#oneOf
:api_Json-Decode-map2: https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#map2
:api_Json-Decode-map4: https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#map4
:api_json-decode-pipeline: https://package.elm-lang.org/packages/NoRedInk/elm-json-decode-pipeline/latest
:api_Random-map3: https://package.elm-lang.org/packages/elm/random/latest/Random#map3
:api_Json-Decode-Value: https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#Value
:api_Json-Encode-Value: https://package.elm-lang.org/packages/elm/json/latest/Json-Encode#Value
:api_Json-Encode: https://package.elm-lang.org/packages/elm/json/latest/Json-Encode
:api_Browser-document: https://package.elm-lang.org/packages/elm/browser/latest/Browser#document
:api_Browser-Document: https://package.elm-lang.org/packages/elm/browser/latest/Browser#Document
:api_elm-css: https://package.elm-lang.org/packages/rtfeldman/elm-css/latest/
:api_Maybe: https://package.elm-lang.org/packages/elm/core/latest/Maybe
:api_Maybe: https://package.elm-lang.org/packages/elm/core/latest/Maybe
:api_Browser-application: https://package.elm-lang.org/packages/elm/browser/latest/Browser#application
:api_Browser-Navigation: https://package.elm-lang.org/packages/elm/browser/latest/Browser-Navigation
:api_Browser-Navigation-load: https://package.elm-lang.org/packages/elm/browser/latest/Browser-Navigation#load
:api_Browser-Navigation-pushUrl: https://package.elm-lang.org/packages/elm/browser/latest/Browser-Navigation#pushUrl
:api_Browser-Navigation-Key: https://package.elm-lang.org/packages/elm/browser/latest/Browser-Navigation#Key
:api_Browser-Dom-getViewport: https://package.elm-lang.org/packages/elm/browser/latest/Browser-Dom#getViewport
:api_Browser-Dom-getViewportOf: https://package.elm-lang.org/packages/elm/browser/latest/Browser-Dom#getViewportOf
:api_url: https://package.elm-lang.org/packages/elm/url/latest/
:api_Url-Parser: https://package.elm-lang.org/packages/elm/url/latest/Url-Parser
:api_Url-Parser-Query: https://package.elm-lang.org/packages/elm/url/latest/Url-Parser-Query
:api_Url-Parser-fragment: https://package.elm-lang.org/packages/elm/url/latest/Url-Parser#fragment
:api_Html-Lazy: https://package.elm-lang.org/packages/elm/html/latest/Html-Lazy/
:api_Html-Keyed: https://package.elm-lang.org/packages/elm/html/latest/Html-Keyed/
:api_Html-Keyed-node: https://package.elm-lang.org/packages/elm/html/latest/Html-Keyed#node
:api_svg: https://package.elm-lang.org/packages/elm/svg/latest
:api_Browser-Events-onKeyDown: https://package.elm-lang.org/packages/elm/browser/latest/Browser-Events#onKeyDown
:api_Browser-Events-onMouseMove: https://package.elm-lang.org/packages/elm/browser/latest/Browser-Events#onMouseMove
:api_Browser-Events-onAnimationFrame: https://package.elm-lang.org/packages/elm/browser/latest/Browser-Events#onAnimationFrame
:api_webgl: https://package.elm-lang.org/packages/elm-explorations/webgl/latest/

:bugs: https://github.com/elm/browser/blob/1.0.0/notes/navigation-in-elements.md
:timezone: https://en.wikipedia.org/wiki/Time_zone
:dst: https://en.wikipedia.org/wiki/Daylight_saving_time
:iana: https://en.wikipedia.org/wiki/IANA_time_zone_database
:samoa: https://en.wikipedia.org/wiki/Time_in_Samoa
:florida: https://www.npr.org/sections/thetwo-way/2018/03/08/591925587/

== README

=== An Introduction to Elm

This is my book about Elm. You can read it online https://guide.elm-lang.org[here]!

I update it like a paper book, with a new edition periodically rather than lots of small changes. Maybe it will be a paper book someday, but I plan to retain ownership of the material such that the complete book is always available for free online.

=== About Suggestions

There are many ways to improve this book. Many of them require structural changes that would present concepts in a better order. Changes like this are quite difficult, especially in a collaborative way. I want the book to come out coherent more than I want it to address every possible concern.

*If you want to make a PR*, the kinds of PRs that are practical to handle include:

* Fixing misspellings
* Fixing broken links
* Fixing typos in code

Make a PR as small as possible. Reviewing a typo is easy. Reviewing 10 typos is hard because 9 may be good. Now there is a bigger coordination overhead.

*If you want to record an issue*, make sure you share:

* Your programming background
* How you found the guide
* Why you want to learn this language
* The thing you found confusing

The answers do not have to be super elaborate. I just need to understand who is confused and why. As I learn more about the readers, it is possible to revamp the book that addresses their concerns in a coherent way. Ultimately I must pick an audience, so it fundamentally cannot work for everyone. Choices must be made!



== Elm 及论文信息

.Elm: Making the Web Functional https://www.infoq.com/presentations/Elm/[🕸]
****

*_Summary_* +
Evan Czaplicki introduces Elm, a functional reacting programming language meant to replace HTML/CSS/JavaScript, optimized for creating web GUIs, supporting complex user input and avoiding callbacks.

*_Bio_* +
Evan Czaplicki has recently graduated from Harvard with a degree in Computer Science, and he’s taking a break before starting as a software engineer at Google. He is interested in making programming more accessible: easier to use and understand. His goals have been influenced both by a formal study of programming languages and practical experiences as an intern at Google and Microsoft.

*_About the conference_* +
As new problems in computing arise, new languages are being created to help tackle those problems. We want to bring together programming language creators, researchers, and enthusiasts to share goals, experiences, and challenges. Our goal is advancing the state of the art in programming language design and implementation.

// [width=100%]
// video::https://videoh.infoq.com/presentations/12-sep-elmmakingtheweb.mp4[]
****


****
[.text-center.big]
*Elm: Concurrent FRP for Functional GUIs* +
Evan Czaplicki +
30 March 2012 +
https://elm-lang.org/assets/papers/concurrent-frp.pdf[PDF]

*Abstract*

Graphical user interfaces (GUIs) mediate almost all of our interactions with computers, whether it is through web pages, phone apps, or desktop applications. Functional Reactive Programming (FRP) is a promising approach to GUI design. This thesis presents Elm, a concurrent FRP language focused on easily creating responsive GUIs. Elm has two major features: (1) purely functional graphical layout and (2) support for Concurrent FRP. Purely functional graphical layout is a high level framework for working with complex visual com- ponents. It makes it quick and easy to create and combine text, images, and video into rich multimedia displays. Concurrent FRP solves some of FRP’s long-standing eﬃciency problems: global delays and needless recomputation. Together, Elm’s two major features simplify the complicated task of creating responsive and usable graphical user interfaces. This thesis also includes a fully functional compiler for Elm, available at elm-lang.org. This site includes an interactive code editor that allows you to write and compile Elm programs online with no download or install.

*Acknowledgments*

Thank you Stephen Chong, my thesis advisor. This thesis would not have been possible without your tireless guidance and encouragement. Thank you Greg Morrisett and Stuart Shieber, my two thesis readers. I am looking forward to your comments and impressions. I am grateful to all three of you, not only for reading and critiquing this thesis, but also for teaching wonderfully thought provoking and fun classes that have greatly inﬂuenced my study of Computer Science. Finally, thank you Natalie and Randi Czaplicki for your love and support.

*Contents*

[opts="autowidth",frame=none,grid=none]
|===
|1 Introduction                                          |1
|2 Background and Related Works                          |4
|2.1 Functional Reactive Programming                     |4
|2.2 Message-Passing Concurrency                         |9
|2.3 Existing FRP GUI Frameworks                         |11
|3 The Core Language                                     |13
|3.1 The Syntax: Manipulating Discrete Signals           |13
|3.2 The Type System: Enforcing the Safe Use of Signals  |16
|3.3 Embedding Arrowized FRP in Elm                      |18
|3.4 Syntax-Directed Initialization Semantics            |19
|4 Concurrent FRP                                        |22
|4.1 An Intuition for Signal Graphs                      |22
|4.2 Signal Graphs and the Global Event Dispatcher       |23
|4.3 Asynchronous Updates                                |25
|4.4 Translation to Concurrent ML                        |27
|4.5 Benefits of Concurrency                             |31
|5 Functional GUIs with Elm                              |32
|5.1 The Elements of Data Display                        |32
|5.2 Irregular Forms and Complex Composition             |34
|5.3 Reactive GUIs                                       |36
|5.4 The Benefits of Functional GUIs                     |38
|6 Implementing Elm                                      |39
|7 Conclusion                                            |41
|===

****


== Helper functions, VirtualDOM and Message Architecture

[NOTE]
******

NOTE: Elm 是 Haskell 编写的 Web 应用开发专用的工具形语言，作者 Evan Czaplicki（埃文•查普利茨基）称之为 FRP 语言，functional reacting programming language。Haskell 是一种广泛使用的纯函数语言，函数可以随意进行柯里化（Currying），也大量使用抽象代数数概念。同样，Elm 也自 Haskell 系统中继承了不少数学历史遗产。

Elm 开发的应用系统采用消息驱动架构，精简模型结构中，消息是整个 Web App 的核心，有了消息就可以更新模型（model），或者说消息驱动 update() 方法更新模型数据，进而刷新视图。消息既可以在初始化函数（init）中设置模型初始值后产生，也可以由 `Http.get` 等编程接口产生。

在这个教程的基础 App 代码结构中，最难理解，或者说难以将 Elm 与 Web 环境融会贯通的代码片段就在 _view_ 函数，它接受一个模型对象（model）返回一个 Html Msg，函数最后一个 -> 符号右侧部分表示返回值类型。注意，这是供人类阅读的类型信息（reading type），参考 4.1 Reading Types, 12.3 Function Types。在没有学习过 Elm 的前提下，这个所谓的 Html Msg 是抽象的，并且它还有有两个单词，这里潜在进一步复杂化的可能。模型对象（model）主要用于存储数据，概念上和其它语言的数据对象区别不大。虽然，稍后解释了此函数“outputs HTML”，显然这是不严谨的，也并不能准确定义或描述视图函数的结构或功能。至少 `div []` 这样的表达是什么含义也没有解释清楚。我想，这种 Guide 文档组织堪称「失败的典型」，因为这种情况下极度容易挫败学习者的信心，甚至是质疑自己的智商水平。然而，这并不是阅读者的问题，真实情况是文档的写作者的创作水平有问题。

当然，每一分文本的阅读理解都是有前提的，Elm 官方教程的前置要求读者有 JavaScript 或类似脚本编程经验，最好理解 Web 平台应用运行环境和 HTML 标签结构。Elm 为 HTML 标签设计了同名的函数，这里的 `div []` 表示给 div 函数传入一个空列表。这种设计基于虚拟节点（VirtualDOM），让 Elm 的类型系统能严格校验 HTML 结构，同时保持代码简洁。

• https://elm-lang.org/news/blazing-fast-html[Blazing Fast HTML - Virtual DOM in Elm]
• https://package.elm-lang.org/packages/elm/virtual-dom/latest/VirtualDom[VirtualDom]

[source,elm]
----
div : List (Attribute msg) -> List (Html msg) -> Html msg
div attributes children =
    node "div" attributes children

-- Virtual DOM
node : String -> List Attribute -> List Html -> Html
node : String -> List (Attribute msg) -> List (Node msg) -> Node msg

type alias Html msg = VirtualDom.Node msg
type alias Attribute msg = VirtualDom.Attribute msg
----

这些函数统称为 helper functions，这里也称之为节点函数。节点函数第一个参数对应当前 HTML 标签的属性（如 class、id、style 等），空列表 [] 就是没有属性。注意，属性需要通过 Html.Attribute 相应的类型来定义，不能直接使用字符串字面量。如果要设置 HTML 标签属性，可以按如下书写方式：

.link:{api_import}[import] - import style: as and exposing
[source,elm]
----
import Html exposing (..)
import Html.Attributes exposing (style)

main : Html msg
main =
  div [ style "color" "red" ] [ text "Hello!" ]

import Html
import Html.Attributes as A

main =
  Html.div [ A.style "color" "red" ] [ Html.text "Hello!" ]
----

第二个参数是子元素列表，可选项。比如 `div [] []` 生成 `<div></div>`。其他节点函数类似，

.link:{api_html}[Html] - Quickly render HTML in Elm.
[source,html]
----
import Html exposing (Html, button, div, text)
import Html.Events exposing (onClick)

type Msg = Increment | Decrement

view : Int -> Html Msg
view count =
  div []
    [ button [ onClick Decrement ] [ text "-" ]
    , div [] [ text (String.fromInt count) ]
    , button [ onClick Increment ] [ text "+" ]
    ]
----

Elm 代码中的 Html msg 是虚拟 DOM 节点，没有内置的方法直接转换为字符串。开发阶段使用 Debug.toString 方法也不能转换这类复杂类型（尤其是涉及模块封装或未暴露内部结构的自定义类型），结果会输出 "<internals>"。这是 Elm 有意设计的封装保护机制，保护抽象边界，防止直接暴露内部实现细节。可以借助外部模块，elm-html-string 完全 Elm 实现，支持基本元素：覆盖常见 HTML 标签和属性的字符串转换，但是有局限性：无法处理动态交互（如事件处理器）。注意，不要和 Elm 内置的基础库混淆（Html 或者 Html.Attributes 等等）。 

[source,elm]
----
-- elm install zwilias/elm-html-string
import Html.String as Html exposing (Html, div, text)
import Html.String.Attributes as Attr exposing(class, classList)
import Html.String.Events as Events

type Msg = Increment | Decrement

view : Html msg
view =
    div [ class "container" ]
        [ text "Hello, Elm!"
        , Html.button [ Events.onClick Increment ] [ Html.text "+" ]
        ]


htmlString : String
htmlString = Html.toString 2 view


{-
Output:
<div class="container">
  Hello, Elm!
  <button>
    +
  </button>
</div>
-}
----

Elm architecture:

• ➊ App 加载，并将初始化的 model 数据发送给 `view` 函数更新视图；
• ➋ 视图函数 `view` 渲染用户界面（HTML）；
• ➌ 用户通过 App 界面交互产生消息 (Message) 并传递到 Elm Runtime (➍)；
• ➎ Elm Runtime 调用程序的 `update` 函数，根据消息类型处理当前 model；
• ➏ 执行完 `update` 并返回更新后的 model；
• ➐ 此时可以执行可选的副作用（side effects）；
• ➑ Elm Runtime 再次调用 `view` 函数渲染用户界面，并重复整个循环。

****
TIP: *副作用，Side Effect*，最常用于医学领域。在医学中，副作用指药物或治疗在达到主要疗效的同时，产生的非预期生理反应。例如：阿司匹林：主要作用是退烧止痛，但可能引发胃部不适（副作用）；化疗：杀死癌细胞的同时，可能导致脱发或免疫力下降。在编程领域，副作用常与函数式编程一起。纯函数（pure function）在同样的输入前提下，保证输出不会有变化，始终是同一个结果。而副作用就是函数式编程中引入用于打破纯函数这中特性的编程工具。比如，某个 Elm 程序输入一个 HTML 视图，只要输入的模块数据不变，那么也就不会出现不同的视图。而副作用可以通过修改 HTML 视图来打破纯函数产生的始终如一的视图。
****

[svgbob]
----
                            .----------.     
                   _.-''''' |   View   | '''''-._        
                 ,'         `----------'         `.      
                /    ➊           ➋          ➌      \     
               .   Model                  Message   .    
               |                                    |    
               |                                    |    
    .-----------------------------------------------------------.
    |          ^                                    |           |
    |          | ➑           Elm Runtime          ➍ |           |
    |          |                                    v           |
    `-----------------------------------------------------------'
               |                                    |    
               |  New model +         Message +     |    
               |  Side efects         Current model |    
                \    ➐           ➏          ➎      /     
                 `._        .----------.        _.'      
                    '-..... |  Update  | .....-'         
                            `----------'    

                          Elm architecture

----

Elm 的消息机制是其“模型-更新-视图”（Model-Update-View）架构的核心，确保状态变化的可预测性。

[svgbob]
----

      ╭──────────── Waiting Input ──────────── Cmd/Sub ────────────╮
      |                                                            |
      v       .-----.                  .-------.                   |
User Input--> | Msg |--> "Update()"--> | Model |--> View Fresh --->╯
              `-----'                  `-------'

----

• 消息类型：通过联合类型（Union Type）定义所有可能的用户行为。实例 `type Msg = T1 | T2 |...`
• 类型安全：Elm 编译器确保所有消息分支均被处理，避免遗漏逻辑。
• 纯函数性：更新函数（Update）接收消息对象和当前模型数据，返回新模型和副作用（Cmd/Sub）。
• 副作用管理：Cmd（命令）表示一次性副作用（如 HTTP 请求）；Sub（订阅）表示持续监听（如键盘事件）。
• 事件循环：Elm 运行时消息调度，监听 DOM 事件，将用户操作（如点击）转换为消息，执行更新。
• 异步处理：Cmd 触发的异步操作（如 HTTP 响应）会生成新消息，重新触发 update() 函数。
• 虚拟 DOM 优化机制：Elm 运行时执行新旧虚拟 DOM 差异比对（Diffing），仅更新变化的部分，实现高效渲染。

.Side Effects: Cmd vs. Sub
[opts="autowidth",frame=ends,grid=rows]
|====
|Commands (`Cmd`)                 |Subscriptions (`Sub`)

|Send an HTTP request (Ajax)      |Mouse movement
|Get the current time             |Time increments
|Generate a random number         |Window resizing
|Access local storage             |Animation frames
|A batch of commands (parallel)   |Messages from JavaScript code
|====


****
Elm 和 TypeScript 一样，作为现代的编程语言，都支持复合类型的概念，声明自定义类型时使用 `|`（Union Types）符号就可以将多个类型并联组合作为用户自定义类型。自定义类型可以只包含字面常量，也可以携带任意数据载荷（Payload）。虽然，两种语言的联合类型在形式上基本一样，但是有本质区别：TypeScript 联合类型作为静态类型检查工具，提供类型约束，不影响运行时行为；Elm 联合类型既是类型系统的一部分，也是数据构造器，支持模式匹配（Pattern Matching）。这两种语言的类型系统哲学差别：Elm 强调代数数据类型（ADT），类型与数据构造紧密绑定，类型系统强制不可变性和纯函数式逻辑；TypeScript 强调结构化类型（Structural Typing），关注形状而非名义，允许更灵活的类型操作（如交叉类型 &、类型断言 as 等等）。Elm 的类型系统基于 Hindley-Milner 类型推断，泛型（Generics）机制天然集成在语言中。类型定义就是一个 Type Constructor，可以给它传递类型参数（Type Arguments），或者称类型变量（Type Variables）。REPL 中查询变量类型时，可以看到给出信息中包含 Data Constructor（冒号左侧，还包含 Payload）和 Type Annotation（冒号右侧）。

    Data Constructor    Payload
    ---------------  -------------
    MyDataStructure ("some string") : MyType
    -------------------------------     ^
                  |                     |
                Value              Type Annotation (Type Constructor)


Hindley-Milner 类型系统（简称 HM 类型系统）是函数式编程语言中广泛使用的类型推断系统，其核心目标是静态类型检查与自动类型推导的结合。它最早由 J. Roger Hindley 提出，并由 Robin Milner 扩展完善，是 ML 家族语言（如 OCaml、Haskell、Elm）的类型系统理论基础。HM 类型系统的实现依赖于 Algorithm W，通过以下步骤推导类型：

• 抽象语法树（AST）遍历：递归分析代码结构。
• 生成约束（Constraints Generation）：记录类型等式（如 a = Int → b）。
• 统一（Unification）：解方程，合并类型约束。
• 泛化（Generalization）：将具体类型提升为泛型类型变量。

.用户自定义类型的使用
[source,elm]
----
type MyType
    = MyConst
    | MoreConstant
    | MyDataStructure String
    | MoreStructure String Float


what mytype =
    case mytype of 
        MyConst                 -> "my constant"
        MoreConstant            -> "my constant"
        MyDataStructure msg     -> ""
        MoreStructure msg value -> msg ++ (String.fromFloat value)


-- Usage of custom type

> MyConst
MyConst : MyType

> MoreConstant
MoreConstant : MyType

> MyDataStructure "some string"
MyDataStructure ("some string") : MyType

> MoreStructure "the PI is " 3.14 
MoreStructure ("the PI is ") 3.14 : MyType

> what MyConst
"my constant" : String

> what (MoreStructure "the PI is " 3.14)
"the PI is 3.14" : String
----
****


https://package.elm-lang.org/packages/elm/browser/latest/[Browser] 模块是 Elm 与浏览器之间的桥梁，为用户提供了以下编程接口：

• *_sandbox_* — react to user input, like buttons and checkboxes
• *_element_* — talk to the outside world, like HTTP and JS interop
• *_document_* — control the <title> and <body>
• *_application_* — create single-page apps

以上四个方法都用户创建程序对象（Program），参数和返回的程序类型有些许区别。除了 sandbox，其它几个方法返回的程序都支持外部传入 flags 参数，这也是沙箱（sangbox）的名称含义：封闭的独立程序空间。所有程序都支持 init、view、update 方法，但是只有 element、document、application 程序支持副作用。并且也只有 application 才支持 onUrlRequest 和 onUrlChange，用于开发但页面应用（SPA）：

[cols="s,3*",opts="autowidth,header",frame=ends,grid=rows]
|====
|Methods     |view                  |update                             |init
|sandbox     |model -> Html msg     |msg -> model -> model              |model
|element     |model -> Html msg     |msg -> model -> ( model, Cmd msg ) |flags -> ( model, Cmd msg )
|document    |model -> Document msg |msg -> model -> ( model, Cmd msg ) |flags -> ( model, Cmd msg )
|application |model -> Document msg |msg -> model -> ( model, Cmd msg ) |flags -> Url -> Key -> ( model, Cmd msg ) 
|====

[cols="s,4*",opts="autowidth,header",frame=ends,grid=rows]
|====
|Methods      |subscriptions    |onUrlRequest      |onUrlChange | Return

|sandbox      |—                |—                 |—           |-> Program () model msg
|element      |model -> Sub msg |—                 |—           |-> Program flags model msg
|document     |model -> Sub msg |—                 |—           |-> Program flags model msg
|application  |model -> Sub msg |UrlRequest -> msg |Url -> msg  |-> Program flags model msg
|====

Elm Editor Online

• https://elm-lang.org/examples/clock[SVG Clock]
• https://ellie-app.com/vg4zxsJ4JLDa1[Temperature Converter]

[source, elm]
----
fetchUser : Cmd Msg
fetchUser =
    Http.get
        { url = "/api/user"
        , expect = Http.expectJson UserFetched decodeUser
        }

subscriptions : Model -> Sub Msg
subscriptions _ =
    Time.every 1000 Tick
----
******

== REPL [TODO]

// [pass]
// ++++++
// <script>
// document.querySelector("#content").className="book without-animation with-summary"
// var gitbook = gitbook || [];
// gitbook.push(function() {
//   gitbook.page.hasChanged({
//     "page": {
//         "title": "Core Language",
//         "level": "1.2",
//         "depth": 1,
//         "next": {
//             "title": "The Elm Architecture",
//             "level": "1.3",
//             "depth": 1,
//             "path": "architecture/README.md",
//             "ref": "architecture/README.md",
//             "articles": [
//                 {
//                     "title": "Buttons",
//                     "level": "1.3.1",
//                     "depth": 2,
//                     "path": "architecture/buttons.md",
//                     "ref": "architecture/buttons.md",
//                     "articles": []
//                 },
//                 {
//                     "title": "Text Fields",
//                     "level": "1.3.2",
//                     "depth": 2,
//                     "path": "architecture/text_fields.md",
//                     "ref": "architecture/text_fields.md",
//                     "articles": []
//                 },
//                 {
//                     "title": "Forms",
//                     "level": "1.3.3",
//                     "depth": 2,
//                     "path": "architecture/forms.md",
//                     "ref": "architecture/forms.md",
//                     "articles": []
//                 }
//             ]
//         },
//         "previous": {
//             "title": "Introduction",
//             "level": "1.1",
//             "depth": 1,
//             "path": "README.md",
//             "ref": "README.md",
//             "articles": []
//         },
//         "dir": "ltr"
//     },
//     "config": {
//         "plugins": [
//             "youtube",
//             "elm-repl",
//             "bulk-redirect",
//             "-sharing"
//         ],
//         "root": "book",
//         "styles": {
//             "website": "https://guide.elm-lang.org/styles/website.css",
//             "pdf": "https://guide.elm-lang.org/styles/pdf.css",
//             "epub": "https://guide.elm-lang.org/styles/epub.css",
//             "mobi": "https://guide.elm-lang.org/styles/mobi.css",
//             "ebook": "https://guide.elm-lang.org/styles/ebook.css",
//             "print": "https://guide.elm-lang.org/styles/print.css"
//         },
//         "pluginsConfig": {
//             "bulk-redirect": {
//                 "basepath": "https://guide.elm-lang.org/",
//                 "redirectsFile": "redirects.json"
//             },
//             //"youtube": {},
//             "elm-repl": {},
//             "highlight": {},
//             //"search": {},
//             //"lunr": {
//             //    "maxIndexSize": 1000000,
//             //    "ignoreSpecialCharacters": false
//             //},
//             "fontsettings": {
//                 "theme": "white",
//                 "family": "sans",
//                 "size": 2
//             },
//             "theme-default": {
//                 "styles": {
//                     "website": "https://guide.elm-lang.org/styles/website.css",
//                     "pdf": "https://guide.elm-lang.org/styles/pdf.css",
//                     "epub": "https://guide.elm-lang.org/styles/epub.css",
//                     "mobi": "https://guide.elm-lang.org/styles/mobi.css",
//                     "ebook": "https://guide.elm-lang.org/styles/ebook.css",
//                     "print": "https://guide.elm-lang.org/styles/print.css"
//                 },
//                 "showLevel": false
//             }
//         },
//         "theme": "default",
//         "author": "Evan Czaplicki",
//         "pdf": {
//             "pageNumbers": true,
//             "fontSize": 12,
//             "fontFamily": "Arial",
//             "paperSize": "a4",
//             "chapterMark": "pagebreak",
//             "pageBreaksBefore": "/",
//             "margin": {
//                 "right": 62,
//                 "left": 62,
//                 "top": 56,
//                 "bottom": 56
//             }
//         },
//         "structure": {
//             "langs": "LANGS.md",
//             "readme": "README.md",
//             "glossary": "GLOSSARY.md",
//             "summary": "SUMMARY.md"
//         },
//         "variables": {},
//         "title": "An Introduction to Elm",
//         "gitbook": "*",
//         "description": "Learn the basics of Elm. Build applications. Learn functional programming."
//     },
//     "file": {
//         "path": "core_language.md",
//         "mtime": "2022-04-05T14:28:26.408Z",
//         "type": "markdown"
//     },
//     "gitbook": {
//         "version": "3.2.3",
//         "time": "2022-04-05T14:29:30.965Z"
//     },
//     "basePath": ".",
//     "book": {
//         "language": ""
//     }
//   });
// });
// </script>
// <link rel="stylesheet" href="https://guide.elm-lang.org/gitbook/style.css">
// <script src="https://guide.elm-lang.org/gitbook/gitbook.js"></script>
// <script src="https://guide.elm-lang.org/gitbook/theme.js"></script>
// <script src="https://guide.elm-lang.org/gitbook/gitbook-plugin-elm-repl/repl.js"></script>
// <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
// <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
// ++++++

[[c01]]

== 1 An Introduction to Elm

**Elm is a functional language that compiles to JavaScript.** It helps you make websites and web apps. It has a strong emphasis on simplicity and quality tooling.

This guide will:

  - Teach you the fundamentals of programming in Elm.
  - Show you how to make interactive apps with **The Elm Architecture**.
  - Emphasize principles and patterns that generalize to programming in any language.

By the end I hope you will not only be able to create great web apps in Elm, but also understand the core ideas and patterns that make Elm nice to use.

If you are on the fence, I can safely guarantee that if you give Elm a shot and actually make a project in it, you will end up writing better JavaScript code. The ideas transfer pretty easily!


=== A Quick Sample

Here is a little program that lets you increment and decrement a number:

```elm
module Main exposing (..)

import Browser
import Html exposing (Html, button, div, text)
import Html.Events exposing (onClick)

main =
  Browser.sandbox { init = 0, update = update, view = view }

type Msg = Increment | Decrement

update msg model =
  case msg of
    Increment ->
      model + 1

    Decrement ->
      model - 1

view model =
  div []
    [ button [ onClick Decrement ] [ text "-" ]
    , div [] [ text (String.fromInt model) ]
    , button [ onClick Increment ] [ text "+" ]
    ]
```

Try it out in the online editor link:https://elm-lang.org/examples/buttons[here].

The code can definitely look unfamiliar at first, so we will get into how this example works soon!


=== Why a functional language?

You can get some benefits from programming in a functional *style*, but there are some things you can only get from a functional *language* like Elm:

  - No runtime errors in practice.
  - Friendly error messages.
  - Reliable refactoring.
  - Automatically enforced semantic versioning for all Elm packages.

No combination of JS libraries can give you all of these guarantees. They come from the design of the language itself! And thanks to these guarantees, it is quite common for Elm programmers to say they never felt so **confident** while programming. Confident to add features quickly. Confident to refactor thousands of lines. But without the background anxiety that you missed something important!

I have put a huge emphasis on making Elm easy to learn and use, so all I ask is that you give Elm a shot and see what you think. I hope you will be pleasantly surprised!


[[c02]][[core_language]]

== 2 Core Language

Let's start by getting a feeling for Elm code!

The goal here is to become familiar with **values** and **functions** so you will be more confident reading Elm code when we get to the larger examples later on.


=== Values

The smallest building block in Elm is called a **value**. This includes things like `42`, `True`, and `"Hello!"`.

Let's start by looking at numbers:

// [pass]
// ++++++
// <p><div class="elm-repl">
// [
// 	{
// 		&quot;input&quot;: &quot;1 + 1&quot;,
// 		&quot;value&quot;: &quot;\u001b[95m2\u001b[0m&quot;,
// 		&quot;type_&quot;: &quot;number&quot;
// 	}
// ]
// </div></p>
// ++++++

[source.elm-repl]
----
// {% repl %}
[
	{
		"input": "1 + 1",
		"value": "\u001b[95m2\u001b[0m",
		"type_": "number"
	}
]
// {% endrepl %}
----

All the examples on this page are interactive, so click on this black box ⬆️ and the cursor should start blinking. Type in `2 + 2` and press the ENTER key. It should print out `4`. You should be able to interact with any of the examples on this page the same way!

Try typing in things like `30 * 60 * 1000` and `2 ^ 4`. It should work just like a calculator!

Doing math is fine and all, but it is surprisingly uncommon in most programs! It is much more common to work with **strings** like this:

[source]
----
{% repl %}
[
	{
		"input": "\"hello\"",
		"value": "\u001b[93m\"hello\"\u001b[0m",
		"type_": "String"
	},
	{
		"input": "\"butter\" ++ \"fly\"",
		"value": "\u001b[93m\"butterfly\"\u001b[0m",
		"type_": "String"
	}
]
{% endrepl %}
----

Try putting some strings together with the `(++)` operator ⬆️

These primitive values get more interesting when we start writing functions to transform them!


NOTE: You can learn more about operators like link:{Basics_plus}[Basics + ] and link:{Basics_div}[Basics /] and link:{Basics_pp}[Basics ++] in the documentation for the link:{Basics}[Basics] module. It is worth reading through all the docs in that package at some point!


=== Functions

A **function** is a way to transform values. Take in one value, and produce another.

For example, here is a `greet` function that takes in a name and says hello:

[source]
----
{% repl %}
[
	{
		"add-decl": "greet",
		"input": "greet name =\n  \"Hello \" ++ name ++ \"!\"\n",
		"value": "\u001b[36m<function>\u001b[0m",
		"type_": "String -> String"
	},
	{
		"input": "greet \"Alice\"",
		"value": "\u001b[93m\"Hello Alice!\"\u001b[0m",
		"type_": "String"
	},
	{
		"input": "greet \"Bob\"",
		"value": "\u001b[93m\"Hello Bob!\"\u001b[0m",
		"type_": "String"
	}
]
{% endrepl %}
----

Try greeting someone else, like `"Stokely"` or `"Kwame"` ⬆️

The values passed in to the function are commonly called **arguments**, so you could say "`greet` is a function that takes one argument."

Okay, now that greetings are out of the way, how about a `madlib` function that takes _two_ arguments?

[source]
----
{% repl %}
[
	{
		"add-decl": "madlib",
		"input": "madlib animal adjective =\n  \"The ostentatious \" ++ animal ++ \" wears \" ++ adjective ++ \" shorts.\"\n",
		"value": "\u001b[36m<function>\u001b[0m",
		"type_": "String -> String -> String"
	},
	{
		"input": "madlib \"cat\" \"ergonomic\"",
		"value": "\u001b[93m\"The ostentatious cat wears ergonomic shorts.\"\u001b[0m",
		"type_": "String"
	},
	{
		"input": "madlib (\"butter\" ++ \"fly\") \"metallic\"",
		"value": "\u001b[93m\"The ostentatious butterfly wears metallic shorts.\"\u001b[0m",
		"type_": "String"
	}
]
{% endrepl %}
----

Try giving two arguments to the `madlib` function ⬆️

Notice how we used parentheses to group `"butter" ++ "fly"` together in the second example. Each argument needs to be a primitive value like `"cat"` or it needs to be in parentheses!

****
NOTE: People coming from languages like JavaScript may be surprised that functions look different here:

[source]
----
madlib "cat" "ergonomic"                  -- Elm
madlib("cat", "ergonomic")                // JavaScript

madlib ("butter" ++ "fly") "metallic"      -- Elm
madlib("butter" + "fly", "metallic")       // JavaScript
----

This can be surprising at first, but this style ends up using fewer parentheses and commas. It makes the language feel really clean and minimal once you get used to it!
****


=== If Expressions

When you want to have conditional behavior in Elm, you use an if-expression.

Let's make a new `greet` function that is appropriately respectful to president Abraham Lincoln:

[source]
----
{% repl %}
[
	{
		"add-decl": "greet",
		"input": "greet name =\n  if name == \"Abraham Lincoln\" then\n    \"Greetings Mr. President!\"\n  else\n    \"Hey!\"\n",
		"value": "\u001b[36m<function>\u001b[0m",
		"type_": "String -> String"
	},
	{
		"input": "greet \"Tom\"",
		"value": "\u001b[93m\"Hey!\"\u001b[0m",
		"type_": "String"
	},
	{
		"input": "greet \"Abraham Lincoln\"",
		"value": "\u001b[93m\"Greetings Mr. President!\"\u001b[0m",
		"type_": "String"
	}
]
{% endrepl %}
----

There are probably other cases to cover, but that will do for now!


=== Lists

Lists are one of the most common data structures in Elm. They hold a sequence of related things, similar to arrays in JavaScript.

Lists can hold many values. Those values must all have the same type. Here are a few examples that use functions from the link:{api_List}[`List`] module:


[source]
----
{% repl %}
[
	{
		"add-decl": "names",
		"input": "names =\n  [ \"Alice\", \"Bob\", \"Chuck\" ]\n",
		"value": "[\u001b[93m\"Alice\"\u001b[0m,\u001b[93m\"Bob\"\u001b[0m,\u001b[93m\"Chuck\"\u001b[0m]",
		"type_": "List String"
	},
	{
		"input": "List.isEmpty names",
		"value": "\u001b[96mFalse\u001b[0m",
		"type_": "Bool"
	},
	{
		"input": "List.length names",
		"value": "\u001b[95m3\u001b[0m",
		"type_": "String"
	},
	{
		"input": "List.reverse names",
		"value": "[\u001b[93m\"Chuck\"\u001b[0m,\u001b[93m\"Bob\"\u001b[0m,\u001b[93m\"Alice\"\u001b[0m]",
		"type_": "List String"
	},
	{
		"add-decl": "numbers",
		"input": "numbers =\n  [4,3,2,1]\n",
		"value": "[\u001b[95m4\u001b[0m,\u001b[95m3\u001b[0m,\u001b[95m2\u001b[0m,\u001b[95m1\u001b[0m]",
		"type_": "List number"
	},
	{
		"input": "List.sort numbers",
		"value": "[\u001b[95m1\u001b[0m,\u001b[95m2\u001b[0m,\u001b[95m3\u001b[0m,\u001b[95m4\u001b[0m]",
		"type_": "List number"
	},
	{
		"add-decl": "increment",
		"input": "increment n =\n  n + 1\n",
		"value": "\u001b[36m<function>\u001b[0m",
		"type_": "number -> number"
	},
	{
		"input": "List.map increment numbers",
		"value": "[\u001b[95m5\u001b[0m,\u001b[95m4\u001b[0m,\u001b[95m3\u001b[0m,\u001b[95m2\u001b[0m]",
		"type_": "List number"
	}
]
{% endrepl %}
----

Try making your own list and using functions like `List.length` ⬆️

And remember, all elements of the list must have the same type!


=== Tuples

Tuples are another useful data structure. A tuple can hold two or three values, and each value can have any type. A common use is if you need to return more than one value from a function. The following function gets a name and gives a message for the user:

****
NOTE: 显然，Elm 与其它编程语言不一样，它不希望元组（tuple）用于保存 2 (pair)、3 (triple) 个元素之外的情形。这两种类型中文称之为“对子”（或者二元组）、“三元组”。元组与列表、数组一样都是 immutable 数据类型，只能通过构造新实例来获得不同的数据结构，而不能修改它本身。

[source,elm]
----
> pair = (1,2)
(1,2) : ( number, number1 )

> pair = (1, 'x')
(1,'x') : ( number, Char )

> Tuple.mapFirst (\_ -> "A") pair
("A",'x') : ( String, Char )

> pair
(1,'x') : ( number, Char )
> 
----
****

[source]
----
{% repl %}
[
	{
		"add-decl": "isGoodName",
		"input": "isGoodName name =\n  if String.length name <= 20 then\n    (True, \"name accepted!\")\n  else\n    (False, \"name was too long; please limit it to 20 characters\")\n",
		"value": "\u001b[36m<function>\u001b[0m",
		"type_": "String -> ( Bool, String )"
	},
	{
		"input": "isGoodName \"Tom\"",
		"value": "(\u001b[96mTrue\u001b[0m, \u001b[93m\"name accepted!\"\u001b[0m)",
		"type_": "( Bool, String )"
	}
]
{% endrepl %}
----

This can be quite handy, but when things start becoming more complicated, it is often best to use records instead of tuples.


=== Records

A **record** can hold many values, and each value is associated with a name.

Here is a record that represents British economist John A. Hobson:

[source]
----
{% repl %}
[
	{
		"add-decl": "john",
		"input": "john =\n  { first = \"John\"\n  , last = \"Hobson\"\n  , age = 81\n  }\n",
		"value": "{ \u001b[37mage\u001b[0m = \u001b[95m81\u001b[0m, \u001b[37mfirst\u001b[0m = \u001b[93m\"John\"\u001b[0m, \u001b[37mlast\u001b[0m = \u001b[93m\"Hobson\"\u001b[0m }",
		"type_": "{ age : number, first : String, last : String }"
	},
	{
		"input": "john.last",
		"value": "\u001b[93m\"Hobson\"\u001b[0m",
		"type_": "String"
	}
]
{% endrepl %}
----

We defined a record with three **fields** containing information about John's name and age.

Try accessing other fields like `john.age` ⬆️

You can also access record fields by using a "field access function" like this:

[source]
----
{% repl %}
[
	{
		"add-decl": "john",
		"input": "john = { first = \"John\", last = \"Hobson\", age = 81 }",
		"value": "{ \u001b[37mage\u001b[0m = \u001b[95m81\u001b[0m, \u001b[37mfirst\u001b[0m = \u001b[93m\"John\"\u001b[0m, \u001b[37mlast\u001b[0m = \u001b[93m\"Hobson\"\u001b[0m }",
		"type_": "{ age : number, first : String, last : String }"
	},
	{
		"input": ".last john",
		"value": "\u001b[93m\"Hobson\"\u001b[0m",
		"type_": "String"
	},
	{
		"input": "List.map .last [john,john,john]",
		"value": "[\u001b[93m\"Hobson\"\u001b[0m,\u001b[93m\"Hobson\"\u001b[0m,\u001b[93m\"Hobson\"\u001b[0m]",
		"type_": "List String"
	}
]
{% endrepl %}
----

It is often useful to **update** values in a record:

[source]
----
{% repl %}
[
	{
		"add-decl": "john",
		"input": "john = { first = \"John\", last = \"Hobson\", age = 81 }",
		"value": "{ \u001b[37mage\u001b[0m = \u001b[95m81\u001b[0m, \u001b[37mfirst\u001b[0m = \u001b[93m\"John\"\u001b[0m, \u001b[37mlast\u001b[0m = \u001b[93m\"Hobson\"\u001b[0m }",
		"type_": "{ age : number, first : String, last : String }"
	},
	{
		"input": "{ john | last = \"Adams\" }",
		"value": "{ \u001b[37mage\u001b[0m = \u001b[95m81\u001b[0m, \u001b[37mfirst\u001b[0m = \u001b[93m\"John\"\u001b[0m, \u001b[37mlast\u001b[0m = \u001b[93m\"Adams\"\u001b[0m }",
		"type_": "{ age : number, first : String, last : String }"
	},
	{
		"input": "{ john | age = 22 }",
		"value": "{ \u001b[37mage\u001b[0m = \u001b[95m22\u001b[0m, \u001b[37mfirst\u001b[0m = \u001b[93m\"John\"\u001b[0m, \u001b[37mlast\u001b[0m = \u001b[93m\"Hobson\"\u001b[0m }",
		"type_": "{ age : number, first : String, last : String }"
	}
]
{% endrepl %}
----

If you wanted to say these expressions out loud, you would say something like, "I want a new version of John where his last name is Adams" or "john where the age is 22".

Notice that when we update some fields of `john` we create a whole new record. It does not overwrite the existing one. Elm makes this efficient by sharing as much content as possible. If you update one of ten fields, the new record will share the nine unchanged values.

So a function to update ages might look like this:

[source]
----
{% repl %}
[
	{
		"add-decl": "celebrateBirthday",
		"input": "celebrateBirthday person =\n  { person | age = person.age + 1 }\n",
		"value": "\u001b[36m<function>\u001b[0m",
		"type_": "{ a | age : number } -> { a | age : number }"
	},
	{
		"add-decl": "john",
		"input": "john = { first = \"John\", last = \"Hobson\", age = 81 }",
		"value": "{ \u001b[37mage\u001b[0m = \u001b[95m81\u001b[0m, \u001b[37mfirst\u001b[0m = \u001b[93m\"John\"\u001b[0m, \u001b[37mlast\u001b[0m = \u001b[93m\"Hobson\"\u001b[0m }",
		"type_": "{ age : number, first : String, last : String }"
	},
	{
		"input": "celebrateBirthday john",
		"value": "{ \u001b[37mage\u001b[0m = \u001b[95m82\u001b[0m, \u001b[37mfirst\u001b[0m = \u001b[93m\"John\"\u001b[0m, \u001b[37mlast\u001b[0m = \u001b[93m\"Hobson\"\u001b[0m }",
		"type_": "{ age : number, first : String, last : String }"
	}
]
{% endrepl %}
----

Updating record fields like this is really common, so we will see a lot more of it in the next section!

[[c03]]

== 3 The Elm Architecture

The Elm Architecture is a pattern for architecting interactive programs, like webapps and games.

This architecture seems to emerge naturally in Elm. Rather than someone inventing it, early Elm programmers kept discovering the same basic patterns in their code. It was kind of spooky to see people ending up with well-architected code without planning ahead!

So The Elm Architecture is easy in Elm, but it is useful in any front-end project. In fact, projects like Redux have been inspired by The Elm Architecture, so you may have already seen derivatives of this pattern. Point is, even if you ultimately cannot use Elm at work yet, you will get a lot out of using Elm and internalizing this pattern.


=== The Basic Pattern

Elm programs always look something like this:

image:https://guide.elm-lang.org/architecture/buttons.svg[Diagram of The Elm Architecture]

The Elm program produces HTML to show on screen, and then the computer sends back messages of what is going on. "They clicked a button!"

What happens within the Elm program though? It always breaks into three parts:

  * **Model** — the state of your application
  * **View** — a way to turn your state into HTML
  * **Update** — a way to update your state based on messages

These three concepts are the core of **The Elm Architecture**.

The next few examples are going to show how to use this pattern for user input, like buttons and text fields. It will make this much more concrete!


=== Follow Along

The examples are all available in the online editor:

link:https://elm-lang.org/try[https://elm-lang.org/try]

This editor shows hints in the top left corner:


video::https://guide.elm-lang.org/architecture/hints.mp4[]

Be sure to try out the hints if you run into something confusing!

[[s3.1]]

=== 3.1 Buttons

Our first example is a counter that can be incremented or decremented.

I included the full program below. Click the blue "Edit" button to mess with it in the online editor. Try changing text on one of the buttons. **Click the blue button now!**

link:https://elm-lang.org/examples/buttons[Edit]

```elm
import Browser
import Html exposing (Html, button, div, text)
import Html.Events exposing (onClick)



-- MAIN


main =
  Browser.sandbox { init = init, update = update, view = view }



-- MODEL

type alias Model = Int

init : Model
init =
  0


-- UPDATE

type Msg = Increment | Decrement

update : Msg -> Model -> Model
update msg model =
  case msg of
    Increment ->
      model + 1

    Decrement ->
      model - 1


-- VIEW

view : Model -> Html Msg
view model =
  div []
    [ button [ onClick Decrement ] [ text "-" ]
    , div [] [ text (String.fromInt model) ]
    , button [ onClick Increment ] [ text "+" ]
    ]
```


Now that you have poked around the code a little bit, you may have some questions. What is the `main` value doing? How do the different parts fit together? Let's go through the code and talk about it.

NOTE: The code here uses <<reading_types, type annotations>>, <<type_aliases, type aliases>>, and <<custom_types, custom types>>. The point of this section is to get a feeling for The Elm Architecture though, so we will not cover them until a bit later. I encourage you to peek ahead if you are getting stuck on these aspects!


==== Main

The `main` value is special in Elm. It describes what gets shown on screen. In this case, we are going to initialize our application with the `init` value, the `view` function is going to show everything on screen, and user input is going to be fed into the `update` function. Think of this as the high-level description of our program.


==== Model

Data modeling is extremely important in Elm. The point of the **model** is to capture all the details about your application as data.

To make a counter, we need to keep track of a number that is going up and down. That means our model is really small this time:

```elm
type alias Model = Int
```

We just need an `Int` value to track the current count. We can see that in our initial value:

```elm
init : Model
init =
  0
```

The initial value is zero, and it will go up and down as people press different buttons.


==== View

We have a model, but how do we show it on screen? That is the role of the `view` function:

```elm
view : Model -> Html Msg
view model =
  div []
    [ button [ onClick Decrement ] [ text "-" ]
    , div [] [ text (String.fromInt model) ]
    , button [ onClick Increment ] [ text "+" ]
    ]
```

This function takes in the `Model` as an argument. It outputs HTML. So we are saying that we want to show a decrement button, the current count, and an increment button.

Notice that we have an `onClick` handler for each button. These are saying: **when someone clicks, generate a message**. So the plus button is generating an `Increment` message. What is that and where does it go? To the `update` function!


==== Update

The `update` function describes how our `Model` will change over time.

We define two messages that it might receive:

```elm
type Msg = Increment | Decrement
```

From there, the `update` function just describes what to do when you receive one of these messages.

```elm
update : Msg -> Model -> Model
update msg model =
  case msg of
    Increment ->
      model + 1

    Decrement ->
      model - 1
```

If you get an `Increment` message, you increment the model. If you get a `Decrement` message, you decrement the model.

So whenever we get a message, we run it through `update` to get a new model. We then call `view` to figure out how to show the new model on screen. Then repeat! User input generates a message, `update` the model, `view` it on screen. Etc.


==== Overview

Now that you have seen all the parts of an Elm program, it may be a bit easier to see how they fit into the diagram we saw earlier:

image:https://guide.elm-lang.org/architecture/buttons.svg[Diagram of The Elm Architecture]

Elm starts by rendering the initial value on screen. From there you enter into this loop:

1. Wait for user input.
2. Send a message to `update`
3. Produce a new `Model`
4. Call `view` to get new HTML
5. Show the new HTML on screen
6. Repeat!

This is the essence of The Elm Architecture. Every example we see from now on will be a slight variation on this basic pattern.

____
**Exercise:** Add a button to reset the counter to zero:

1. Add a `Reset` variant to the `Msg` type
2. Add a `Reset` branch in the `update` function
3. Add a button in the `view` function.

You can edit the example in the online editor link:https://elm-lang.org/examples/buttons[https://elm-lang.org/examples/buttons].

If that goes well, try adding another button to increment by steps of 10.
____



[[s3.2]][[text_fields]]

=== 3.2 Text Fields

We are about to create a simple app that reverses the contents of a text field.

Click the blue button to look at this program in the online editor. Try to check out the hint for the `type` keyword. **Click the blue button now!**

link:https://elm-lang.org/examples/text-fields[Edit]

```elm
import Browser
import Html exposing (Html, Attribute, div, input, text)
import Html.Attributes exposing (..)
import Html.Events exposing (onInput)



-- MAIN


main =
  Browser.sandbox { init = init, update = update, view = view }



-- MODEL


type alias Model =
  { content : String
  }


init : Model
init =
  { content = "" }



-- UPDATE


type Msg
  = Change String


update : Msg -> Model -> Model
update msg model =
  case msg of
    Change newContent ->
      { model | content = newContent }



-- VIEW


view : Model -> Html Msg
view model =
  div []
    [ input [ placeholder "Text to reverse", value model.content, onInput Change ] []
    , div [] [ text (String.reverse model.content) ]
    ]
```

This code is a slight variant of the previous example. You set up a model. You define some messages. You say how to `update`. You make your `view`. The difference is just in how we filled this skeleton in. Let's walk through that!


==== Model

I always start by guessing at what my `Model` should be. We know we have to keep track of whatever the user has typed into the text field. We need that information to know how to render the reversed text. So we go with this:

```elm
type alias Model =
  { content : String
  }
```

This time I chose to represent the model as a record. The record stores the user input in the `content` field.

NOTE: You may be wondering, why bother having a record if it only holds one entry? Couldn't you just use the string directly? Sure! But starting with a record makes it easy to add more fields as our app gets more complicated. When the time comes where we want *two* text inputs, we will have to do much less fiddling around.


==== View

We have our model, so I usually proceed by creating a `view` function:

```elm
view : Model -> Html Msg
view model =
  div []
    [ input [ placeholder "Text to reverse", value model.content, onInput Change ] []
    , div [] [ text (String.reverse model.content) ]
    ]
```

We create a `<div>` with two children. The interesting child is the `<input>` node which has three attributes:

- `placeholder` is the text that shows when there is no content
- `value` is the current content of this `<input>`
- `onInput` sends messages when the user types in this `<input>` node

Typing in "bard" this would produce four messages:

1. `Change "b"`
2. `Change "ba"`
3. `Change "bar"`
4. `Change "bard"`

These would be fed into our `update` function.


==== Update

There is only one kind of message in this program, so our `update` only has to handle one case:

```elm
type Msg
  = Change String

update : Msg -> Model -> Model
update msg model =
  case msg of
    Change newContent ->
      { model | content = newContent }
```

When we receive a message that the `<input>` node has changed, we update the `content` of our model. So if you typed in "bard" the resulting messages would produce the following models:

1. `{ content = "b" }`
2. `{ content = "ba" }`
3. `{ content = "bar" }`
4. `{ content = "bard" }`

We need to track this information explicitly in our model, otherwise there is no way to show the reversed text in our `view` function!

****
**Exercise:** Go to the example in the online editor link:https://elm-lang.org/examples/text-fields[text-fields] and show the length of the `content` in your `view` function. Use the link:{api_String-length}[String.length] function!

NOTE: If you want more info on exactly how the `Change` values are working in this program, jump ahead to the sections on <<custom_types, custom types>> and <<pattern_matching, pattern matching>>.
****


[[s3.3]]

=== 3.3 Forms

Now we will make a rudimentary form. It has a field for your name, a field for your password, and a field to verify that password. We will also do some very simple validation to check if the passwords match.

I included the full program below. Click the blue "Edit" button to mess with it in the online editor. Try introducing a typo to see some error messages. Try misspelling a record field like `password` or a function like `placeholder`. **Click the blue button now!**

link:https://elm-lang.org/examples/forms[Edit]

```elm
import Browser
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onInput)



-- MAIN


main =
  Browser.sandbox { init = init, update = update, view = view }



-- MODEL


type alias Model =
  { name : String
  , password : String
  , passwordAgain : String
  }


init : Model
init =
  Model "" "" ""



-- UPDATE


type Msg
  = Name String
  | Password String
  | PasswordAgain String


update : Msg -> Model -> Model
update msg model =
  case msg of
    Name name ->
      { model | name = name }

    Password password ->
      { model | password = password }

    PasswordAgain password ->
      { model | passwordAgain = password }



-- VIEW


view : Model -> Html Msg
view model =
  div []
    [ viewInput "text" "Name" model.name Name
    , viewInput "password" "Password" model.password Password
    , viewInput "password" "Re-enter Password" model.passwordAgain PasswordAgain
    , viewValidation model
    ]


viewInput : String -> String -> String -> (String -> msg) -> Html msg
viewInput t p v toMsg =
  input [ type_ t, placeholder p, value v, onInput toMsg ] []


viewValidation : Model -> Html msg
viewValidation model =
  if model.password == model.passwordAgain then
    div [ style "color" "green" ] [ text "OK" ]
  else
    div [ style "color" "red" ] [ text "Passwords do not match!" ]
```

This is pretty similar to our <<text_fields, text field example>> but with more fields.



==== Model

I always start out by guessing at the `Model`. We know there are going to be three text fields, so let's just go with that:

```elm
type alias Model =
  { name : String
  , password : String
  , passwordAgain : String
  }
```

I usually try to start with a minimal model, maybe with just one field. I then attempt to write the `view` and `update` functions. That often reveals that I need to add more to my `Model`. Building the model gradually like this means I can have a working program through the development process. It may not have all the features yet, but it is getting there!


==== Update

Sometimes you have a pretty good idea of what the basic update code will look like. We know we need to be able to change our three fields, so we need messages for each case.

```elm
type Msg
  = Name String
  | Password String
  | PasswordAgain String
```

This means our `update` needs a case for all three variations:

```elm
update : Msg -> Model -> Model
update msg model =
  case msg of
    Name name ->
      { model | name = name }

    Password password ->
      { model | password = password }

    PasswordAgain password ->
      { model | passwordAgain = password }
```

Each case uses the record update syntax to make sure the appropriate field is transformed. This is similar to the previous example, except with more cases.

We get a little bit fancier than normal in our `view` though.


==== View

This `view` function is using **helper functions** to make things a bit more organized:

```elm
view : Model -> Html Msg
view model =
  div []
    [ viewInput "text" "Name" model.name Name
    , viewInput "password" "Password" model.password Password
    , viewInput "password" "Re-enter Password" model.passwordAgain PasswordAgain
    , viewValidation model
    ]
```

In previous examples we were using `input` and `div` directly. Why did we stop?

The neat thing about HTML in Elm is that `input` and `div` are just normal functions. They take (1) a list of attributes and (2) a list of child nodes. **Since we are using normal Elm functions, we have the full power of Elm to help us build our views!** We can refactor repetitive code out into customized helper functions. That is exactly what we are doing here!

So our `view` function has three calls to `viewInput`:

```elm
viewInput : String -> String -> String -> (String -> msg) -> Html msg
viewInput t p v toMsg =
  input [ type_ t, placeholder p, value v, onInput toMsg ] []
```

This means that writing `viewInput "text" "Name" "Bill" Name` in Elm would turn into an HTML value like `<input type="text" placeholder="Name" value="Bill">` when shown on screen.

The fourth entry is more interesting. It is a call to `viewValidation`:

```elm
viewValidation : Model -> Html msg
viewValidation model =
  if model.password == model.passwordAgain then
    div [ style "color" "green" ] [ text "OK" ]
  else
    div [ style "color" "red" ] [ text "Passwords do not match!" ]
```

This function first compares the two passwords. If they match, you get green text and a positive message. If they do not match, you get red text and a helpful message.

These helper functions begin to show the benefits of having our HTML library be normal Elm code. We _could_ put all that code into our `view`, but making helper functions is totally normal in Elm, even in view code. "Is this getting hard to understand? Maybe I can break out a helper function!"

****
**Exercises:** Go look at this example in the online editor link:https://elm-lang.org/examples/forms[here]. Try to add the following features to the `viewValidation` helper function:

- Check that the password is longer than 8 characters.
- Make sure the password contains upper case, lower case, and numeric characters.

Use the functions from the link:{api_String}[String] module for these exercises!

WARNING: We need to learn a lot more before we start sending HTTP requests. Keep reading all the way to the section on HTTP before trying it yourself. It will be significantly easier with proper guidance!

NOTE: It seems like efforts to make generic validation libraries have not been too successful. I think the problem is that the checks are usually best captured by normal Elm functions. Take some args, give back a `Bool` or `Maybe`. E.g. Why use a library to check if two strings are equal? So as far as we know, the simplest code comes from writing the logic for your particular scenario without any special extras. So definitely give that a shot before deciding you need something more complex!
****

[[c04]]

== 4 Types

One of Elm's major benefits is that **users do not see runtime errors in practice**. This is possible because the Elm compiler can analyze your source code very quickly to see how values flow through your program. If a value can ever be used in an invalid way, the compiler tells you about it with a friendly error message. This is called *type inference*. The compiler figures out what *type* of values flow in and out of all your functions.

=== An Example of Type Inference

The following code defines a `toFullName` function which extracts a person’s full name as a string:

```elm
toFullName person =
  person.firstName ++ " " ++ person.lastName

fullName =
  toFullName { fistName = "Hermann", lastName = "Hesse" }
```

Like in JavaScript or Python, we just write the code with no extra clutter. Do you see the bug though?

In JavaScript, the equivalent code spits out `"undefined Hesse"`. Not even an error! Hopefully one of your users will tell you about it when they see it in the wild. In contrast, the Elm compiler just looks at the source code and tells you:

```
-- TYPE MISMATCH ---------------------------------------------------------------

The argument to function `toFullName` is causing a mismatch.

6│   toFullName { fistName = "Hermann", lastName = "Hesse" }
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Function `toFullName` is expecting the argument to be:

    { …, firstName : … }

But it is:

    { …, fistName : … }

Hint: I compared the record fields and found some potential typos.

    firstName <-> fistName
```

It sees that `toFullName` is getting the wrong *type* of argument. Like the hint in the error message says, someone accidentally wrote `fist` instead of `first`.

It is great to have an assistant for simple mistakes like this, but it is even more valuable when you have hundreds of files and a bunch of collaborators making changes. No matter how big and complex things get, the Elm compiler checks that *everything* fits together properly just based on the source code.

The better you understand types, the more the compiler feels like a friendly assistant. So let's start learning more!

[[s4.1]]

=== 4.1 Reading Types

In the <<core_language, Core Language>> section of this book, we went through a bunch of interactive examples to get a feeling for the language. Well, we are going to do it again, but with a new question in mind. What **type** of value is that?


==== Primitives and Lists

Let's enter some simple expressions and see what happens:

[source]
----
{% replWithTypes %}
[
	{
		"input": "\"hello\"",
		"value": "\u001b[93m\"hello\"\u001b[0m",
		"type_": "String"
	},
	{
		"input": "not True",
		"value": "\u001b[96mFalse\u001b[0m",
		"type_": "Bool"
	},
	{
		"input": "round 3.1415",
		"value": "\u001b[95m3\u001b[0m",
		"type_": "Int"
	}
]
{% endreplWithTypes %}
----

Click on this black box ⬆️ and the cursor should start blinking. Type in `3.1415` and press the ENTER key. It should print out `3.1415` followed by the type `Float`.

Okay, but what is going on here exactly? Each entry shows value along with what **type** of value it happens to be. You can read these examples out loud like this:

- The value `"hello"` is a `String`.
- The value `False` is a `Bool`.
- The value `3` is an `Int`.
- The value `3.1415` is a `Float`.

Elm is able to figure out the type of any value you enter! Let's see what happens with lists:

[source]
----
{% replWithTypes %}
[
	{
		"input": "[ \"Alice\", \"Bob\" ]",
		"value": "[\u001b[93m\"Alice\"\u001b[0m,\u001b[93m\"Bob\"\u001b[0m]",
		"type_": "List String"
	},
	{
		"input": "[ 1.0, 8.6, 42.1 ]",
		"value": "[\u001b[95m1.0\u001b[0m,\u001b[95m8.6\u001b[0m,\u001b[95m42.1\u001b[0m]",
		"type_": "List Float"
	}
]
{% endreplWithTypes %}
----

You can read these types as:

1. We have a `List` filled with `String` values.
2. We have a `List` filled with `Float` values.

The **type** is a rough description of the particular value we are looking at.


==== Functions

Let's see the type of some functions:

[source]
----
{% replWithTypes %}
[
	{
		"input": "String.length",
		"value": "\u001b[36m<function>\u001b[0m",
		"type_": "String -> Int"
	}
]
{% endreplWithTypes %}
----

Try entering `round` or `sqrt` to see some other function types ⬆️

The `String.length` function has type `String -> Int`. This means it *must* take in a `String` argument, and it will definitely return an `Int` value. So let's try giving it an argument:

[source]
----
{% replWithTypes %}
[
	{
		"input": "String.length \"Supercalifragilisticexpialidocious\"",
		"value": "\u001b[95m34\u001b[0m",
		"type_": "Int"
	}
]
{% endreplWithTypes %}
----

So we start with a `String -> Int` function and give it a `String` argument. This results in an `Int`.

What happens when you do not give a `String` though? Try entering `String.length [1,2,3]` or `String.length True` to see what happens ⬆️

You will find that a `String -> Int` function *must* get a `String` argument!

****
NOTE: Functions that take multiple arguments end up having more and more arrows. For example, here is a function that takes two arguments:

[source]
----
{% replWithTypes %}
[
	{
		"input": "String.repeat",
		"value": "\u001b[36m<function>\u001b[0m",
		"type_": "Int -> String -> String"
	}
]
{% endreplWithTypes %}
----

Giving two arguments like `String.repeat 3 "ha"` will produce `"hahaha"`. It works to think of `->` as a weird way to separate arguments, but I explain the real reasoning <<function_types, here>>. It is pretty neat!
****

[[reading_types]]
==== Type Annotations

So far we have just let Elm figure out the types, but it also lets you write a **type annotation** on the line above a definition. So when you are writing code, you can say things like this:

```elm
half : Float -> Float
half n =
  n / 2

-- half 256 == 128
-- half "3" -- error!

hypotenuse : Float -> Float -> Float
hypotenuse a b =
  sqrt (a^2 + b^2)

-- hypotenuse 3 4  == 5
-- hypotenuse 5 12 == 13

checkPower : Int -> String
checkPower powerLevel =
  if powerLevel > 9000 then "It's over 9000!!!" else "Meh"

-- checkPower 9001 == "It's over 9000!!!"
-- checkPower True -- error!
```

Adding type annotations is not required, but it is definitely recommended! Benefits include:

1. **Error Message Quality** — When you add a type annotation, it tells the compiler what you are _trying_ to do. Your implementation may have mistakes, and now the compiler can compare against your stated intent. “You said argument `powerLevel` was an `Int`, but it is getting used as a `String`!”
2. **Documentation** — When you revisit code later (or when a colleague visits it for the first time) it can be really helpful to see exactly what is going in and out of the function without having to read the implementation super carefully.

People can make mistakes in type annotations though, so what happens if the annotation does not match the implementation? The compiler figures out all the types on its own, and it checks that your annotation matches the real answer. In other words, the compiler will always verify that all the annotations you add are correct. So you get better error messages _and_ documentation always stays up to date!


==== Type Variables

As you look through more Elm code, you will start to see type annotations with lower-case letters in them. A common example is the `List.length` function:

[source]
----
{% replWithTypes %}
[
	{
		"input": "List.length",
		"value": "\u001b[36m<function>\u001b[0m",
		"type_": "List a -> Int"
	}
]
{% endreplWithTypes %}
----

Notice that lower-case `a` in the type? That is called a **type variable**. It can vary depending on how link:{api_List-length}[`List.length`] is used:

[source]
----
{% replWithTypes %}
[
	{
		"input": "List.length [1,1,2,3,5,8]",
		"value": "\u001b[95m6\u001b[0m",
		"type_": "Int"
	},
	{
		"input": "List.length [ \"a\", \"b\", \"c\" ]",
		"value": "\u001b[95m3\u001b[0m",
		"type_": "Int"
	},
	{
		"input": "List.length [ True, False ]",
		"value": "\u001b[95m2\u001b[0m",
		"type_": "Int"
	}
]
{% endreplWithTypes %}
----

We just want the length, so it does not matter what is in the list. So the type variable `a` is saying that we can match any type. Let's look at another common example:

[source]
----
{% replWithTypes %}
[
	{
		"input": "List.reverse",
		"value": "\u001b[36m<function>\u001b[0m",
		"type_": "List a -> List a"
	},
	{
		"input": "List.reverse [ \"a\", \"b\", \"c\" ]",
		"value": "[\u001b[93m\"c\"\u001b[0m,\u001b[93m\"b\"\u001b[0m,\u001b[93m\"a\"\u001b[0m]",
		"type_": "List String"
	},
	{
		"input": "List.reverse [ True, False ]",
		"value": "[\u001b[96mFalse\u001b[0m,\u001b[96mTrue\u001b[0m]",
		"type_": "List Bool"
	}
]
{% endreplWithTypes %}
----

Again, the type variable `a` can vary depending on how link:{reverse}[`List.reverse`] is used. But in this case, we have an `a` in the argument and in the result. This means that if you give a `List Int` you must get a `List Int` as well. Once we decide what `a` is, that’s what it is everywhere.


NOTE: Type variables must start with a lower-case letter, but they can be full words. We could write the type of link:{api_List-length}[`List.length`] as `List value -> Int` and we could write the type of link:{api_List-reverse}[`List.reverse`] as `List element -> List element`. It is fine as long as they start with a lower-case letter. Type variables `a` and `b` are used by convention in many places, but some type annotations benefit from more specific names.



==== Constrained Type Variables

There is a special variant of type variables in Elm called **constrained** type variables. The most common example is the `number` type. The link:{api_Basics-negate}[Basics negate] function uses it:

[source]
----
{% replWithTypes %}
[
	{
		"input": "negate",
		"value": "\u001b[36m<function>\u001b[0m",
		"type_": "number -> number"
	}
]
{% endreplWithTypes %}
----

Try expressions like `negate 3.1415` and `negate (round 3.1415)` and `negate "hi"` ⬆️

Normally type variables can get filled in with anything, but `number` can only be filled in by `Int` and `Float` values. It _constrains_ the possibilities.

The full list of constrained type variables is:

- `number` permits `Int` and `Float`
- `appendable` permits `String` and `List a`
- `comparable` permits `Int`, `Float`, `Char`, `String`, and lists/tuples of `comparable` values
- `compappend` permits `String` and `List comparable`

These constrained type variables exist to make operators like `(+)` and `(<)` a bit more flexible.

By now we have covered types for values and functions pretty well, but what does this look like when we start wanting more complex data structures?


[[s4.2]][[type_aliases]]

=== 4.2 Type Aliases

Type annotations can start to get long. This might be a real problem if you have records with many fields! This is the core motivation for type aliases. A **type alias** is a shorter name for a type. For example, you could create a `User` alias like this:

```elm
type alias User =
  { name : String
  , age : Int
  }
```

Rather than writing the whole record type all the time, we can just say `User` instead. This helps us write type annotations that are easier to read:

```elm
-- WITH ALIAS

isOldEnoughToVote : User -> Bool
isOldEnoughToVote user =
  user.age >= 18


-- WITHOUT ALIAS

isOldEnoughToVote : { name : String, age : Int } -> Bool
isOldEnoughToVote user =
  user.age >= 18
```

These two definitions are equivalent, but the one with a type alias is shorter and easier to read. So all we are doing is making an **alias** for a long type.


==== Models

It is extremely common to use type aliases when designing a model. When we were learning about The Elm Architecture, we saw a model like this:

```
type alias Model =
  { name : String
  , password : String
  , passwordAgain : String
  }
```

The main benefit of using a type alias for this is when we write the type annotations for the `update` and `view` functions. Writing `Msg -> Model -> Model` is so much nicer than the fully expanded version! It has the added benefit that we can add fields to our model without needing to change any type annotations.


==== Record Constructors

When you create a type alias specifically for a record, it also generates a **record constructor**. So if we define a `User` type alias, we can start building records like this:

[source]
----
{% replWithTypes %}
[
	{
		"add-type": "User",
		"input": "type alias User = { name : String, age : Int }"
	},
	{
		"input": "User",
		"value": "\u001b[36m<function>\u001b[0m",
		"type_": "String -> Int -> User"
	},
	{
		"input": "User \"Sue\" 58",
		"value": "{ \u001b[37mname\u001b[0m = \u001b[93m\"Sue\"\u001b[0m, \u001b[37mage\u001b[0m = \u001b[95m58\u001b[0m }",
		"type_": "User"
	},
	{
		"input": "User \"Tom\" 31",
		"value": "{ \u001b[37mname\u001b[0m = \u001b[93m\"Tom\"\u001b[0m, \u001b[37mage\u001b[0m = \u001b[95m31\u001b[0m }",
		"type_": "User"
	}
]
{% endreplWithTypes %}
----

Try creating another user or creating a type alias of your own ⬆️

Note that the order of arguments in the record constructor match the order of fields in the type alias!

And again, **this is only for records.** Making type aliases for other types will not result in a constructor.

NOTE: Custom types used to be referred to as “union types” in Elm. Names from other communities include link:https://en.wikipedia.org/wiki/Tagged_union[Tagged union] and link:https://en.wikipedia.org/wiki/Algebraic_data_type[Algebraic data type].


[[s4.3]]

=== 4.3 Custom Types

So far we have seen a bunch of types like `Bool`, `Int`, and `String`. But how do we define our own?

Say we are making a chat room. Everyone needs a name, but maybe some users do not have a permanent account. They just give a name each time they show up.

We can describe this situation by defining a `UserStatus` type, listing all the possible variations:

```elm
type UserStatus = Regular | Visitor
```

The `UserStatus` type has two **variants**. Someone can be a `Regular` or a `Visitor`. So we could represent a user as a record like this:

```elm
type UserStatus
  = Regular
  | Visitor

type alias User =
  { status : UserStatus
  , name : String
  }

thomas = { status = Regular, name = "Thomas" }
kate95 = { status = Visitor, name = "kate95" }
```

So now we can track if someone is a `Regular` with an account or a `Visitor` who is just passing through. It is not too tough, but we can make it simpler!

Rather than creating a custom type and a type alias, we can represent all this with just a single custom type. The `Regular` and `Visitor` variants each have an associated data. In our case, the associated data is a `String` value:

```elm
type User
  = Regular String
  | Visitor String

thomas = Regular "Thomas"
kate95 = Visitor "kate95"
```

The data is attached directly to the variant, so there is no need for the record anymore.

Another benefit of this approach is that each variant can have different associated data. Say that `Regular` users gave their age when they signed up. There is no nice way to capture that with records, but when you define your own custom type it is no problem. Let's add some associated data to the `Regular` variant in an interactive example:

[source]
----
{% replWithTypes %}
[
  {
    "add-type": "User",
    "input": "type User\n  = Regular String Int\n  | Visitor String\n"
  },
  {
    "input": "Regular",
    "value": "\u001b[36m<function>\u001b[0m",
    "type_": "String -> Int -> User"
  },
  {
    "input": "Visitor",
    "value": "\u001b[36m<function>\u001b[0m",
    "type_": "String -> User"
  },
  {
    "input": "Regular \"Thomas\" 44",
    "value": "\u001b[96mRegular\u001b[0m \u001b[93m\"Thomas\"\u001b[0m \u001b[95m44\u001b[0m",
    "type_": "User"
  },
  {
    "input": "Visitor \"kate95\"",
    "value": "\u001b[96mVisitor\u001b[0m \u001b[93m\"kate95\"\u001b[0m",
    "type_": "User"
  }
]
{% endreplWithTypes %}
----

Try defining a `Regular` visitor with a name and age ⬆️

We only added an age, but variants of a type can diverge quite dramatically. For example, maybe we want to add location for `Regular` users so we can suggest regional chat rooms. Add more associated data! Or maybe we want to have anonymous users. Add a third variant called `Anonymous`. Maybe we end up with:

```elm
type User
  = Regular String Int Location
  | Visitor String
  | Anonymous
```

No problem! Let’s see some other examples now.


==== Messages

In the architecture section, we saw a couple of examples of defining a `Msg` type. This sort of type is extremely common in Elm. In our chat room, we might define a `Msg` type like this:

```elm
type Msg
  = PressedEnter
  | ChangedDraft String
  | ReceivedMessage { user : User, message : String }
  | ClickedExit
```

We have four variants. Some variants have no associated data, others have a bunch. Notice that `ReceivedMessage` actually has a record as associated data. That is totally fine. Any type can be associated data! This allows you to describe interactions in your application very precisely.


==== Modeling

Custom types become extremely powerful when you start modeling situations very precisely. For example, if you are waiting for some data to load, you might want to model it with a custom type like this:

```elm
type Profile
  = Failure
  | Loading
  | Success { name : String, description : String }
```

So you can start in the `Loading` state and then transition to `Failure` or `Success` depending on what happens. This makes it really simple to write a `view` function that always shows something reasonable when data is loading.

Now we know how to create custom types, the next section will show how to use them!


NOTE: **Custom types are the most important feature in Elm.** They have a lot of depth, especially once you get in the habit of trying to model scenarios more precisely. I tried to share some of this depth in <<types_as_sets, Types as Sets>> and <<types_as_bits, Types as Bits>> in the appendix. I hope you find them helpful!

[[s4.4]]

=== 4.4 Pattern Matching

On the previous page, we learned how to create <<custom_types, custom types>> with the `type` keyword. Our primary example was a `User` in a chat room:

```elm
type User
  = Regular String Int
  | Visitor String
```

Regulars have a name and age, whereas visitors only have a name. So we have our custom type, but how do we actually use it?


==== case

Say we want a `toName` function that decides on a name to show for each `User`. We need to use a `case` expression:

```elm
toName : User -> String
toName user =
  case user of
    Regular name age ->
      name

    Visitor name ->
      name

-- toName (Regular "Thomas" 44) == "Thomas"
-- toName (Visitor "kate95")    == "kate95"
```

The `case` expression allows us to branch based on which variant we happen to see, so whether we see Thomas or Kate, we always know how to show their name.

And if we try invalid arguments like `toName (Visitar "kate95")` or `toName Anonymous`, the compiler tells us about it immediately. This means many simple mistakes can be fixed in seconds, rather than making it to users and costing a lot more time overall.


==== Wild Cards

The `toName` function we just defined works great, but notice that the `age` is not used in the implementation? When some of the associated data is unused, it is common to use a “wild card” (`_`) instead of giving it a name:

```elm
toName : User -> String
toName user =
  case user of
    Regular name _ ->
      name

    Visitor name ->
      name
```

The `_` acknowledges the data there, but also saying explicitly that nobody is using it.

[[c05]]

== 5 Error Handling

One of the guarantees of Elm is that you will not see runtime errors in practice. This is partly because **Elm treats errors as data**. Rather than crashing, we model the possibility of failure explicitly with custom types. For example, say you want to turn user input into an age. You might create a custom type like this:

```elm
type MaybeAge
  = Age Int
  | InvalidInput

toAge : String -> MaybeAge
toAge userInput =
  ...

-- toAge "24" == Age 24
-- toAge "99" == Age 99
-- toAge "ZZ" == InvalidInput
```

No matter what input is given to the `toAge` function, it always produces a value. Valid input produces values like `Age 24` and `Age 99`, whereas invalid input produces the `InvalidInput` value. From there, we use pattern matching which will ensure that both possibilities are accounted for. No crashing!

This kind of thing comes up all the time! For example, maybe you want to turn a bunch of user input into a `Post` to share with others. But what happens if they forget to add a title? Or there is no content in the post? We could model all these problems explicitly:

```elm
type MaybePost
  = Post { title : String, content : String }
  | NoTitle
  | NoContent

toPost : String -> String -> MaybePost
toPost title content =
  ...

-- toPost "hi" "sup?" == Post { title = "hi", content = "sup?" }
-- toPost ""   ""     == NoTitle
-- toPost "hi" ""     == NoContent
```

Instead of just saying that the input is invalid, we are describing each of the ways things might have gone wrong. If we have a `viewPreview : MaybePost -> Html msg` function to preview valid posts, now we can give more specific error messages in the preview area when something goes wrong!

These kinds of situations are extremely common. It is often valuable to create a custom type for your exact situation, but in some of the simpler cases, you can use an off-the-shelf type instead. So the rest of this chapter explores the `Maybe` and `Result` types, showing how they can help you treat errors as data!

[[s5.1]]

=== 5.1 Maybe


As you work more with Elm, you will start seeing the link:{api_Maybe}[`Maybe`] type quite frequently. It is defined like this:

```elm
type Maybe a
  = Just a
  | Nothing

-- Just 3.14 : Maybe Float
-- Just "hi" : Maybe String
-- Just True : Maybe Bool
-- Nothing   : Maybe a
```

This is a type with two variants. You either have `Nothing` or you have `Just` a value. The type variable makes it possible to have a `Maybe Float` and `Maybe String` depending on the particular value.

This can be handy in two main scenarios: partial functions and optional fields.


==== Partial Functions

Sometimes you want a function that gives an answer for some inputs, but not others. Many people run into this with link:{api_String-toFloat}[`String.toFloat`] when trying to convert user input into numbers. Let's see it in action:

[source]
----
{% replWithTypes %}
[
  {
    "input": "String.toFloat",
    "value": "\u001b[36m<function>\u001b[0m",
    "type_": "String -> Maybe Float"
  },
  {
    "input": "String.toFloat \"3.1415\"",
    "value": "\u001b[96mJust\u001b[0m \u001b[95m3.1415\u001b[0m",
    "type_": "Maybe Float"
  },
  {
    "input": "String.toFloat \"abc\"",
    "value": "\u001b[96mNothing\u001b[0m",
    "type_": "Maybe Float"
  }
]
{% endreplWithTypes %}
----

Try calling `String.toFloat` with other strings to see what happens ⬆️

Not all strings make sense as numbers, so this function models that explicitly. Can a string be turned into a float? Maybe! From there we can pattern match on the resulting data and continue as appropriate.

****
**Exercise:** I wrote a little program link:https://ellie-app.com/bJSMQz9tydqa1[https://ellie-app.com/bJSMQz9tydqa1] that converts from Celsius to Fahrenheit. Try refactoring the `view` code in different ways. Can you put a red border around invalid input? Can you add more conversions? Fahrenheit to Celsius? Inches to Meters?
****

****
NOTE: This is my answer below. https://ellie-app.com/vg4zxsJ4JLDa1[🕸]. And you explore to see whether Elm support if／case expression in a list?

根据 Elm 语法，列表元素必须是表达式，而 if 和 case 都是合法表达式。因此，在列表中可以直接使用，但是每个分支返回的类型需要一致，这是 Elm 列表类型基本要求。例如，每个条件分支返回 Html Msg 类型，或者都返回文本等。以下代码片段都是合法的，只是没有使用函数来的清晰。

[source,elm]
----
  [ ...
    , case color of
      "red" ->
          span [style "color" color, style "border" "2px solid red"] [ text equivalentTemp ]

      _     ->
          span [style "color" color] [ text equivalentTemp ]
    , if color == "red" then
        span [ style "color" color, style "border" "3px solid red"] [ text equivalentTemp ]
      else
        span [ style "color" color] [ text equivalentTemp ]
  ]
----

[source,html]
----
<html>
<head>
  <style>
    /* you can style your program here */
  </style>
</head>
<body>
  <main></main>
  <script>
    var app = Elm.Main.init({ node: document.querySelector('main') })
    // you can use ports and stuff here
  </script>
</body>
</html>
----

[source,elm]
----
module Main exposing (main)

import Browser
import Html exposing (Html, Attribute, span, input, text)
import Html.Attributes exposing (..)
import Html.Events exposing (onInput)



-- MAIN


main =
  Browser.sandbox { init = init, update = update, view = view }



-- MODEL


type alias Model =
  { input : String
  }


init : Model
init =
  { input = "" }



-- UPDATE


type Msg
  = Change String


update : Msg -> Model -> Model
update msg model =
  case msg of
    Change newInput ->
      { model | input = newInput }



-- VIEW


view : Model -> Html Msg
view model =
  case String.toFloat model.input of
    Just celsius ->
      viewConverter model.input "blue" (String.fromFloat (celsius * 1.8 + 32))

    Nothing ->
      viewConverter model.input "red" "???"


viewConverter : String -> String -> String -> Html Msg
viewConverter userInput color equivalentTemp =
  span []
    [ input [ value userInput, onInput Change, style "width" "40px" ] []
    , text "°C = "
    , valueBox color equivalentTemp
    --, span [ style "color" color] [ text equivalentTemp ]
    , text "°F"
    ]


valueBox: String -> String -> Html Msg
valueBox color equivalentTemp =
  case color of
      "red" ->
          span [style "color" color, style "border" "1px solid red"] [ text equivalentTemp ]

      _     ->
          span [style "color" color] [ text equivalentTemp ]
----
****



==== Optional Fields

Another place you commonly see `Maybe` values is in records with optional fields.

For example, say we are running a social networking website. Connecting people, friendship, etc. You know the spiel. The Onion outlined our real goals best back in 2011: link:https://www.theonion.com/cias-facebook-program-dramatically-cut-agencys-costs-1819594988[https://www.theonion.com/cias-facebook-program-dramatically-cut-agencys-costs-1819594988]. And if we want *all* the data, we need to ease people into it. Let them add it later. Add features that encourage them to share more and more information over time.

So let's start with a simple model of a user. They must have a name, but we are going to make the age optional.

```elm
type alias User =
  { name : String
  , age : Maybe Int
  }
```

Now say Sue creates an account, but decides not to provide her birthday:

```elm
sue : User
sue =
  { name = "Sue", age = Nothing }
```

Sue’s friends cannot wish her a happy birthday though. I wonder if they _really_ care about her... Later Tom creates a profile and *does* give his age:

```elm
tom : User
tom =
  { name = "Tom", age = Just 24 }
```

Great, that will be nice on his birthday. But more importantly, Tom is part of a valuable demographic! The advertisers will be pleased.

Alright, so now that we have some users, how can we market alcohol to them without breaking any laws? People would probably be mad if we market to people under 21, so let's check for that:

```elm
canBuyAlcohol : User -> Bool
canBuyAlcohol user =
  case user.age of
    Nothing ->
      False

    Just age ->
      age >= 21
```

Notice that the `Maybe` type forces us to pattern match on the user's age. It is actually impossible to write code where you forget that users may not have an age. Elm makes sure of it! Now we can advertise alcohol confident that we are not influencing minors directly! Only their older peers.


==== Avoiding Overuse

This `Maybe` type is quite useful, but there are limits. Beginners are particularly prone to getting excited about `Maybe` and using it everywhere, even though a custom type would be more appropriate.

For example, say we have an exercise app where we compete against our friends. You start with a list of your friend’s names, but you can load more fitness information about them later. You might be tempted to model it like this:

```elm
type alias Friend =
  { name : String
  , age : Maybe Int
  , height : Maybe Float
  , weight : Maybe Float
  }
```

All the information is there, but you are not really modeling the way your particular application works. It would be much more precise to model it like this instead:

```elm
type Friend
  = Less String
  | More String Info

type alias Info =
  { age : Int
  , height : Float
  , weight : Float
  }
```

This new model is capturing much more about your application. There are only two real situations. Either you have just the name, or you have the name and a bunch of information. In your view code, you just think about whether you are showing a `Less` or `More` view of the friend. You do not have to answer questions like “what if I have an `age` but not a `weight`?” That is not possible with our more precise type!

Point is, if you find yourself using `Maybe` everywhere, it is worth examining your `type` and `type alias` definitions to see if you can find a more precise representation. This often leads to a lot of nice refactors in your update and view code!

____
*_Connection to `null` references_*

The inventor of `null` references, Tony Hoare, described them like this:

________
I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.
________

That design makes failure **implicit**. Any time you think you have a `String` you just might have a `null` instead. Should you check? Did the person giving you the value check? Maybe it will be fine? Maybe it will crash your server? I guess we will find out later!

Elm avoids these problems by not having `null` references at all. We instead use custom types like `Maybe` to make failure **explicit**. This way there are never any surprises. A `String` is always a `String`, and when you see a `Maybe String`, the compiler will ensure that both variants are accounted for. This way you get the same flexibility, but without the surprise crashes.
____


[[s5.2]]

=== 5.2 Result

The `Maybe` type can help with simple functions that may fail, but it does not tell you _why_ it failed. Imagine if a compiler just said `Nothing` if anything was wrong with your program. Good luck figuring out what went wrong!

This is where the link:{api_Result}[`Result`] type becomes helpful. It is defined like this:

```elm
type Result error value
  = Ok value
  | Err error
```

The point of this type is to give additional information when things go wrong. It is really helpful for error reporting and error recovery!



==== Error Reporting

Perhaps we have a website where people input their age. We could check that the age is reasonable with a function like this:

```elm
isReasonableAge : String -> Result String Int
isReasonableAge input =
  case String.toInt input of
    Nothing ->
      Err "That is not a number!"

    Just age ->
      if age < 0 then
        Err "Please try again after you are born."

      else if age > 135 then
        Err "Are you some kind of turtle?"

      else
        Ok age

-- isReasonableAge "abc" == Err ...
-- isReasonableAge "-13" == Err ...
-- isReasonableAge "24"  == Ok 24
-- isReasonableAge "150" == Err ...
```

Not only can we check the age, but we can also show people error messages depending on the particulars of their input. This kind of feedback is much better than `Nothing`!


==== Error Recovery

The `Result` type can also help you recover from errors. One place you see this is when making HTTP requests. Say we want to show the full text of _Anna Karenina_ by Leo Tolstoy. Our HTTP request results in a `Result Error String` to capture the fact that the request may succeed with the full text, or it may fail in a bunch of different ways:

```elm
type Error
  = BadUrl String
  | Timeout
  | NetworkError
  | BadStatus Int
  | BadBody String

-- Ok "All happy ..." : Result Error String
-- Err Timeout        : Result Error String
-- Err NetworkError   : Result Error String
```

From there we can show nicer error messages as we discussed before, but we can also try to recover from the failure! If we see a `Timeout` it may work to wait a little while and try again. Whereas if we see a `BadStatus 404` then there is no point in trying again.

The next chapter shows how to actually make HTTP requests, so we will run into the `Result` and `Error` types again very soon!

[[c06]]

== 6 Commands and Subscriptions

Earlier in this book we saw The Elm Architecture handle mouse and keyboard interactions, but what about talking to servers? Generating random numbers?

To answer these questions, it helps to learn more about how The Elm Architecture works behind the scenes. This will explain why things work a bit differently than in languages like JavaScript, Python, etc.


=== sandbox

I have not made a big deal about it, but so far all of our programs were created with link:{api_sandbox}[`Browser.sandbox`]. We gave an initial `Model` and describe how to `update` and `view` it.

You can think of `Browser.sandbox` as setting up a system like this:

[tikz]
------
\documentclass[border=3pt,tikz]{standalone}
\pgfdeclarelayer{nodelayer}
\pgfdeclarelayer{edgelayer}
\pgfsetlayers{main,edgelayer,nodelayer}
\begin{document}
\tikzset{ none/.style={ draw=none,fill=none,text=black} }

% TiKZ style file generated by TikZiT. You may edit this file manually,
% but some things (e.g. comments) may be overwritten. To be readable in
% TikZiT, the only non-comment lines must be of the form:
% \tikzstyle{NAME}=[PROPERTY LIST]

% Node styles
\tikzstyle{dot}=[fill=white, draw={rgb,255: red,132; green,132; blue,132}, shape=circle]
\tikzstyle{box}=[inner sep=22pt,fill=blue!10, draw={rgb,255: red,226; green,226; blue,226}, shape=rectangle, minimum height=1.15cm, minimum width=0.5cm]

% Edge styles
\tikzstyle{thin edge arrow}=[fill=none, draw={rgb,255: red,99; green,99; blue,99}, ->]
\tikzstyle{thick edge}=[-, fill={rgb,255: red,191; green,128; blue,64}, draw={rgb,255: red,63; green,59; blue,40}]
\tikzstyle{dashed edge}=[-, fill=none, draw={rgb,255: red,25; green,25; blue,25}, dashed]
\tikzstyle{thin edge}=[-]
\tikzstyle{thick edge arrow}=[->, line width=2pt]
\begin{tikzpicture}
	\begin{pgfonlayer}{nodelayer}
		\node [style=box,align=center] (0) at (-3.5, 2) {{\Huge Elm} \\ Browser.element};
		\node [style=box,align=center] (1) at (3.75, 2) {Runtime \\ System};
		\node [style=none] (2) at (0, 6.5) {HTML};
		\node [style=none] (3) at (0, -2) {Msg};
		\node [style=box] (4) at (8, 2) {DOM};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=thick edge arrow] 
			 (0.north) to [in=-180, out=90] (2.west)
			 (2.east) to [in=90, out=0] (1.north);
		\draw [style=thick edge arrow] 
			 (1.south) to [bend left=45] (3.east)
			 (3.west) to [bend left=45] (0.south);
		\draw [style=thick edge arrow, in=180, out=0] (1) to (4);
	\end{pgfonlayer}
\end{tikzpicture}

\end{document}
------

// [svgbob]
// ----

//             _.-'''' Html ''''-._
//           ,'                    `.
//          /                        \
//         .                          .
//         |                          |
//         |                          |

//         |                          |
// .-----------------.      .---------v---------.       .-----.
// | Elm             |      |       Runtime     |-----> | DOM |
// | Browser.element |      |       System      |       `-----'
// `-------^---------'      `-------------------'
//         |                          |

//         |                          |
//         |                          |
//          \                        /
//           `._                  _.'
//              '-..... Msg ....-'

// ----

// image:https://guide.elm-lang.org/effects/diagrams/sandbox.svg[]


We get to stay in the world of Elm, writing functions and transforming data. This hooks up to Elm's **runtime system**. The runtime system figures out how to render `Html` efficiently. Did anything change? What is the minimal DOM modification needed? It also figures out when someone clicks a button or types into a text field. It turns that into a `Msg` and feeds it into your Elm code.

By cleanly separating out all the DOM manipulation, it becomes possible to use extremely aggressive optimizations. So Elm's runtime system is a big part of why Elm is link:{benchmark}[one of the fastest options available].



=== element

In the next few examples, we are going to use link:{api_element}[`Browser.element`] to create programs. This will introduce the ideas of **commands** and **subscriptions** which allow us to interact with the outside world.

You can think of `Browser.element` as setting up a system like this:


[tikz]
------
\documentclass[border=3pt,tikz]{standalone}
\pgfdeclarelayer{nodelayer}
\pgfdeclarelayer{edgelayer}
\pgfsetlayers{main,edgelayer,nodelayer}
\begin{document}
\tikzset{ none/.style={ draw=none,fill=none,text=black} }

% Node styles
\tikzstyle{dot}=[fill=white, draw={rgb,255: red,132; green,132; blue,132}, shape=circle]
\tikzstyle{box}=[inner sep=22pt,fill=blue!10, draw={rgb,255: red,226; green,226; blue,226}, shape=rectangle, minimum height=1.15cm, minimum width=0.5cm]
\tikzstyle{box small}=[inner sep=2pt,fill=yellow!70!green, draw={rgb,255: red,226; green,226; blue,226}, shape=rectangle, minimum height=1.15cm, minimum width=0.5cm]

% Edge styles
\tikzstyle{thin edge arrow}=[fill=none, draw={rgb,255: red,99; green,99; blue,99}, ->]
\tikzstyle{thick edge}=[-, fill={rgb,255: red,191; green,128; blue,64}, draw={rgb,255: red,63; green,59; blue,40}]
\tikzstyle{dashed edge}=[-, fill=none, draw={rgb,255: red,25; green,25; blue,25}, dashed]
\tikzstyle{thin edge}=[-]
\tikzstyle{thick edge arrow}=[->, line width=2pt]
\begin{tikzpicture}
	\begin{pgfonlayer}{nodelayer}
		\node [style=box,align=center] (0) at (-3.5, 2) {{\Huge Elm} \\ Browser.element};
		\node [style=box,align=center] (1) at (3.75, 2) {\Huge Runtime \\ System};
		\node [style=none,align=center] (2) at (0, 6.5) {{\large HTML} \\ Cmd/Sub};
		\node [style=none] (3) at (0, -2) {Msg};
		\node [style=box small] (4) at (7.25, 3.65) {DOM};
		\node [style=box small] (5) at (8.25, 2.5) {HTTP};
		\node [style=box small] (6) at (9, -0.15) {Randomness};
		\node [style=box small] (7) at (9.75, 1.5) {3:14pm};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=thick edge arrow] 
			 (0.north) to [in=-180, out=90] (2.west)
			 (2.east) to [in=90, out=0] (1.north);
		\draw [style=thick edge arrow] 
			 (1.south) to [bend left=45] (3.east)
			 (3.west) to [bend left=45] (0.south);
		\draw [style=thick edge arrow, in=180, out=0] (1) to (4);
		\draw [style=thick edge arrow, in=180, out=0] (1) to (5);
		\draw [style=thick edge arrow, in=165, out=0, looseness=1.50] (1) to (6);
		\draw [style=thick edge arrow, in=180, out=0, looseness=1.25] (1) to (7);
	\end{pgfonlayer}
\end{tikzpicture}

\end{document}
------

// image:https://guide.elm-lang.org/effects/diagrams/element.svg[]


In addition to producing `Html` values, our programs will also send `Cmd` and `Sub` values to the runtime system. In this world, our programs can **command** the runtime system to make an HTTP request or to generate a random number. They can also **subscribe** to the current time.

I think commands and subscriptions make more sense when you start seeing examples, so let's do that!



****
NOTE: Note 1: Some readers may be worrying about asset size. “A runtime system? That sounds big!” It is not! In fact, Elm assets are link:https://elm-lang.org/blog/small-assets-without-the-headache[https://elm-lang.org/blog/small-assets-without-the-headache] when compared to popular alternatives.

NOTE: Note 2: We are going to use packages from link:https://package.elm-lang.org[https://package.elm-lang.org] in the upcoming examples. We have already been working with a couple:

- link:{api_core}[core]
- link:{api_html}[html]

But now we will start getting into some fancier ones:

- link:{api_http}[http]
- link:{api_json}[json]
- link:{api_random}[random]
- link:{api_time}[time]

There are tons of other packages on `package.elm-lang.org` though! So when you are making your own Elm programs locally, it will probably involve running some commands like this in the terminal:

```bash
elm init
elm install elm/http
elm install elm/random
```

That would set up an `elm.json` file with `elm/http` and `elm/random` as dependencies.

I will be mentioning the packages we are using in the following examples, so I hope this gives some context on what that is all about!
****


[[s6.1]]

=== 6.1 HTTP

It is often helpful to grab information from elsewhere on the internet.

For example, say we want to load the full text of _Public Opinion_ by Walter Lippmann. Published in 1922, this book provides a historical perspective on the rise of mass media and its implications for democracy. For our purposes here, we will focus on how to use the link:{api_http}[`elm/http`] package to get this book into our program!

[NOTE]
******
《Public Opinion》（《舆论》）是沃尔特·李普曼（Walter Lippmann）于1922年出版的经典著作，被誉为传播学、政治学和公共舆论研究领域的奠基之作。书中探讨了现代社会中公众舆论的形成机制、局限性及其对民主政治的影响，提出了许多至今仍具启发性的观点。

*核心观点与理论贡献*

• “拟态环境”（Pseudo-Environment）
** 李普曼指出，人们并非直接感知现实，而是通过媒体、教育和社会化构建的“拟态环境”理解世界。
** 这一环境由刻板印象（Stereotypes）和简化的符号组成，导致公众对复杂问题的认知存在偏差。

• 公众理性的局限性
** 现代社会的复杂性远超普通公民的认知能力，公众无法充分掌握决策所需的信息。
** 舆论易受情感、偏见和外部操控（如政治宣传、媒体议程设置）的影响。

• “制造同意”（Manufacturing Consent）
** 李普曼认为，精英阶层（如政府、企业、媒体）通过控制信息流塑造公众意见，实现社会控制。
** 这一观点后来被诺姆·乔姆斯基（Noam Chomsky）进一步发展，成为批判媒体霸权的重要理论。

• 对民主的批判
** 传统民主理论假设公民能理性参与决策，但李普曼指出这是“乌托邦幻想”。
** 他主张由专家和技术官僚主导决策，公众仅通过选举对权力进行间接监督。
******

Click the blue "Edit" button to look through this program in the online editor. You will probably see the screen say "Loading..." before the full book shows up. **Click the blue button now!**


link:https://elm-lang.org/examples/book[Edit]

```elm
import Browser
import Html exposing (Html, text, pre)
import Http



-- MAIN


main =
  Browser.element
    { init = init
    , update = update
    , subscriptions = subscriptions
    , view = view
    }



-- MODEL


type Model
  = Failure
  | Loading
  | Success String


init : () -> (Model, Cmd Msg)
init _ =
  ( Loading
  , Http.get
      { url = "https://elm-lang.org/assets/public-opinion.txt"
      , expect = Http.expectString GotText
      }
  )



-- UPDATE


type Msg
  = GotText (Result Http.Error String)


update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
  case msg of
    GotText result ->
      case result of
        Ok fullText ->
          (Success fullText, Cmd.none)

        Err _ ->
          (Failure, Cmd.none)



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
  Sub.none



-- VIEW


view : Model -> Html Msg
view model =
  case model of
    Failure ->
      text "I was unable to load your book."

    Loading ->
      text "Loading..."

    Success fullText ->
      pre [] [ text fullText ]
```

Some parts of this should be familiar from previous examples of The Elm Architecture. We still have a `Model` of our application. We still have an `update` that reacts to messages. We still have a `view` function that shows everything on screen.

The new parts extend the core pattern we saw before with some changes in `init` and `update`, and the addition of `subscription`.


==== init

The `init` function describes how to initialize our program:

```elm
init : () -> (Model, Cmd Msg)
init _ =
  ( Loading
  , Http.get
      { url = "https://elm-lang.org/assets/public-opinion.txt"
      , expect = Http.expectString GotText
      }
  )
```

Like always, we have to produce the initial `Model`, but now we are also producing some **command** of what we want to do immediately. That command will eventually produce a `Msg` that gets fed into the `update` function.

Our book website starts in the `Loading` state, and we want to GET the full text of our book. When making a GET request with link:{api_http-get}[`Http.get`], we specify the `url` of the data we want to fetch, and we specify what we `expect` that data to be. So in our case, the `url` is pointing at some data on the Elm website, and we `expect` it to be a big `String` we can show on screen.

The `Http.expectString GotText` line is saying a bit more than that we `expect` a `String` though. It is also saying that when we get a response, it should be turned into a `GotText` message:

```elm
type Msg
  = GotText (Result Http.Error String)

-- GotText (Ok "The Project Gutenberg EBook of ...")
-- GotText (Err Http.NetworkError)
-- GotText (Err (Http.BadStatus 404))
```

Notice that we are using the `Result` type from a couple sections back. This allows us to fully account for the possible failures in our `update` function. Speaking of `update` functions...


NOTE: If you are wondering why `init` is a function (and why we are ignoring the argument) we will talk about it in the upcoming chapter on JavaScript interop! (Preview: the argument lets us get information from JS on initialization.)


==== update

Our `update` function is returning a bit more information as well:

```elm
update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
  case msg of
    GotText result ->
      case result of
        Ok fullText ->
          (Success fullText, Cmd.none)

        Err _ ->
          (Failure, Cmd.none)
```

Looking at the type signature, we see that we are not just returning an updated model. We are _also_ producing a **command** of what we want Elm to do.

Moving on to the implementation, we pattern match on messages like normal. When a `GotText` message comes in, we inspect the `Result` of our HTTP request and update our model depending on whether it was a success or failure. The new part is that we also provide a command.

So in the case that we got the full text successfully, we say `Cmd.none` to indicate that there is no more work to do. We already got the full text!

And in the case that there was some error, we also say `Cmd.none` and just give up. The text of the book did not load. If we wanted to get fancier, we could pattern match on the link:{api_http-Error}[`Http.Error`] and retry the request if we got a timeout or something.

The point here is that however we decide to update our model, we are also free to issue new commands. I need more data! I want a random number! Etc.



==== subscription

The other new thing in this program is the `subscription` function. It lets you look at the `Model` and decide if you want to subscribe to certain information. In our example, we say `Sub.none` to indicate that we do not need to subscribe to anything, but we will soon see an example of a clock where we want to subscribe to the current time!


==== Summary

When we create a program with `Browser.element`, we set up a system like this:

image:https://guide.elm-lang.org/effects/diagrams/element.svg[]

We get the ability to issue **commands** from `init` and `update`. This allows us to do things like make HTTP requests whenever we want. We also get the ability to **subscribe** to interesting information. (We will see an example of subscriptions later!)

[[s6.2]]

=== 6.2 JSON

****
NOTE: Elm 中处理 JSON 数据的关键在于其严格的类型安全和显式的编解码机制。Elm 通过 Json.Decode 和 Json.Encode 模块实现 JSON 与 Elm 类型的双向映射，以下是核心机制：

• 显式性：所有 JSON 映射必须显式声明，Elm 编译器确保类型安全。
• 不可变性：编解码过程不修改原始数据，避免副作用。
• 错误早现：解码失败会在运行时立即暴露，而非静默传递错误数据。

通过这套机制，Elm 实现了 JSON 与类型系统的高度可靠交互，确保数据流始终符合预期。

JSON 数据转换为 Elm 类型的过程，需显式定义解码器（Decoder）。默认定义了 map2 ~ map8 解码类型，后缀数值对应解码对象的字段数量。

.JSON decode example
[source,elm]
----
import Json.Decode exposing (Decoder, int, string, field, list)

decodeAge : Decoder Int
decodeAge = field "age" int

type alias User = { name : String, age : Int }

decodeUser : Decoder User
decodeUser =
    Json.Decode.map2 User
        (field "name" string)
        (field "age" int)
----

简化复杂对象的解码可以利用管道式解码 Json.Decode.Pipeline：

.JSON pipeline decode example
[source,elm]
----
import Json.Decode.Pipeline exposing (required, optional)

decodeUser : Decoder User
decodeUser =
    Json.Decode.succeed User
        |> required "name" string
        |> required "age" int
        |> optional "email" string ""
----
****


We just saw an example that uses HTTP to get the content of a book. That is great, but a ton of servers return data in a special format called JavaScript Object Notation, or JSON for short.

So our next example shows how to fetch some JSON data, allowing us to press a button to show random quotes from a haphazard selection of books. Click the blue "Edit" button and look through the program a bit. Maybe you have read some of these books too? **Click the blue button now!**

link:https://elm-lang.org/examples/quotes[Edit]

```elm
import Browser
import Html exposing (..)
import Html.Attributes exposing (style)
import Html.Events exposing (..)
import Http
import Json.Decode exposing (Decoder, map4, field, int, string)



-- MAIN


main =
  Browser.element
    { init = init
    , update = update
    , subscriptions = subscriptions
    , view = view
    }



-- MODEL


type Model
  = Failure
  | Loading
  | Success Quote


type alias Quote =
  { quote : String
  , source : String
  , author : String
  , year : Int
  }


init : () -> (Model, Cmd Msg)
init _ =
  (Loading, getRandomQuote)



-- UPDATE


type Msg
  = MorePlease
  | GotQuote (Result Http.Error Quote)


update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
  case msg of
    MorePlease ->
      (Loading, getRandomQuote)

    GotQuote result ->
      case result of
        Ok quote ->
          (Success quote, Cmd.none)

        Err _ ->
          (Failure, Cmd.none)



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
  Sub.none



-- VIEW


view : Model -> Html Msg
view model =
  div []
    [ h2 [] [ text "Random Quotes" ]
    , viewQuote model
    ]


viewQuote : Model -> Html Msg
viewQuote model =
  case model of
    Failure ->
      div []
        [ text "I could not load a random quote for some reason. "
        , button [ onClick MorePlease ] [ text "Try Again!" ]
        ]

    Loading ->
      text "Loading..."

    Success quote ->
      div []
        [ button [ onClick MorePlease, style "display" "block" ] [ text "More Please!" ]
        , blockquote [] [ text quote.quote ]
        , p [ style "text-align" "right" ]
            [ text "— "
            , cite [] [ text quote.source ]
            , text (" by " ++ quote.author ++ " (" ++ String.fromInt quote.year ++ ")")
            ]
        ]



-- HTTP


getRandomQuote : Cmd Msg
getRandomQuote =
  Http.get
    { url = "https://elm-lang.org/api/random-quotes"
    , expect = Http.expectJson GotQuote quoteDecoder
    }


quoteDecoder : Decoder Quote
quoteDecoder =
  map4 Quote
    (field "quote" string)
    (field "source" string)
    (field "author" string)
    (field "year" int)
```

This example is pretty similar to the last one:

- `init` starts us off in the `Loading` state, with a command to get a random quote.
- `update` handles the `GotQuote` message for whenever a new quote is available. Whatever happens there, we do not have any additional commands. It also handles the `MorePlease` message when someone presses the button, issuing a command to get more random quotes.
- `view` shows you the quotes!

The main difference is in the `getRandomCatGif` definition. Instead of using `Http.expectString`, we have switched to `Http.expectJson`. What is the deal with that?


==== JSON

When you ask link:https://elm-lang.org/api/random-quotes[https://elm-lang.org/api/random-quotes] for a random quote, the server produces a string of JSON like this:

```json
{
  "quote": "December used to be a month but it is now a year",
  "source": "Letters from a Stoic",
  "author": "Seneca",
  "year": 54
}
```

We have no guarantees about any of the information here. The server can change the names of fields, and the fields may have different types in different situations. It is a wild world!

In JavaScript, the approach is to just turn JSON into JavaScript objects and hope nothing goes wrong. But if there is some typo or unexpected data, you get a runtime exception somewhere in your code. Was the code wrong? Was the data wrong? It is time to start digging around to find out!

In Elm, we validate the JSON before it comes into our program. So if the data has an unexpected structure, we learn about it immediately. There is no way for bad data to sneak through and cause a runtime exception three files over. This is accomplished with JSON decoders.


==== JSON Decoders

Say we have some JSON:

```json
{
	"name": "Tom",
	"age": 42
}
```

We need to run it through a `Decoder` to access specific information. So if we wanted to get the `"age"`, we would run the JSON through a `Decoder Int` that describes exactly how to access that information:

image:https://guide.elm-lang.org/effects/diagrams/int.svg[]

If all goes well, we get an `Int` on the other side! And if we wanted the `"name"` we would run the JSON through a `Decoder String` that describes exactly how to access it:

image:https://guide.elm-lang.org/effects/diagrams/string.svg[]

If all goes well, we get a `String` on the other side!

How do we create decoders like this though?


==== Building Blocks

The link:{api_json}[`elm/json`] package gives us the link:{api_decode}[`Json.Decode`] module. It is filled with tiny decoders that we can snap together.


So to get `"age"` from `{ "name": "Tom", "age": 42 }` we would create a decoder like this:

```elm
import Json.Decode exposing (Decoder, field, int)

ageDecoder : Decoder Int
ageDecoder =
  field "age" int

 -- int : Decoder Int
 -- field : String -> Decoder a -> Decoder a
```

The link:{api_field}[`field`] function takes two arguments:

1. `String` — a field name. So we are demanding an object with an `"age"` field.
2. `Decoder a` — a decoder to try next. So if the `"age"` field exists, we will try this decoder on the value there.

So putting it together, `field "age" int` is asking for an `"age"` field, and if it exists, it runs the `Decoder Int` to try to extract an integer.

We do pretty much exactly the same thing to extract the `"name"` field:

```elm
import Json.Decode exposing (Decoder, field, string)

nameDecoder : Decoder String
nameDecoder =
  field "name" string

-- string : Decoder String
```

In this case we demand an object with a `"name"` field, and if it exists, we want the value there to be a `String`.



==== Combining Decoders

But what if we want to decode _two_ fields? We snap decoders together with link:{api_Json-Decode-map2}[Json-Decode map2]:

```elm
map2 : (a -> b -> value) -> Decoder a -> Decoder b -> Decoder value
```

This function takes in two decoders. It tries them both and combines their results. So now we can put together two different decoders:

```elm
import Json.Decode exposing (Decoder, map2, field, string, int)

type alias Person =
  { name : String
  , age : Int
  }

personDecoder : Decoder Person
personDecoder =
  map2 Person
  	(field "name" string)
  	(field "age" int)
```

So if we used `personDecoder` on `{ "name": "Tom", "age": 42 }` we would get out an Elm value like `Person "Tom" 42`.

If we really wanted to get into the spirit of decoders, we would define `personDecoder` as `map2 Person nameDecoder ageDecoder` using our previous definitions. You always want to be building your decoders up from smaller building blocks!


==== Nesting Decoders

A lot of JSON data is not so nice and flat. Imagine if `/api/random-quotes/v2` was released with richer information about authors:

```json
{
  "quote": "December used to be a month but it is now a year",
  "source": "Letters from a Stoic",
  "author":
  {
    "name": "Seneca",
    "age": 68,
    "origin": "Cordoba"
  },
  "year": 54
}
```

We could handle this new scenario by nesting our nice little decoders:

```elm
import Json.Decode exposing (Decoder, map2, map4, field, int, string)

type alias Quote =
  { quote : String
  , source : String
  , author : Person
  , year : Int
  }

quoteDecoder : Decoder Quote
quoteDecoder =
  map4 Quote
    (field "quote" string)
    (field "source" string)
    (field "author" personDecoder)
    (field "year" int)

type alias Person =
  { name : String
  , age : Int
  }

personDecoder : Decoder Person
personDecoder =
  map2 Person
    (field "name" string)
    (field "age" int)
```

Notice that we do not bother decoding the `"origin"` field of the author. Decoders are fine with skipping over fields, which can be helpful when extracting a small amount of information from very large JSON values.


==== Next Steps

There are a bunch of important functions in `Json.Decode` that we did not cover here:

- link:{api_Json-Decode-bool}[Json-Decode bool] : `Decoder Bool`
- link:{api_Json-Decode-list}[Json-Decode list] : `Decoder a -> Decoder (List a)`
- link:{api_Json-Decode-dict}[Json-Decode dict] : `Decoder a -> Decoder (Dict String a)`
- link:{api_Json-Decode-oneOf}[Json-Decode oneOf] : `List (Decoder a) -> Decoder a`

So there are ways to extract all sorts of data structures. The `oneOf` function is particularly helpful for messy JSON. (e.g. sometimes you get an `Int` and other times you get a `String` containing digits. So annoying!)

We saw link:{api_Json-Decode-map2}[Json-Decode.map2] and link:{api_Json-Decode-map4}[Json-Decode.map4] for handling objects with many fields. But as you start working with larger and larger JSON objects, it is worth checking out link:{api_json-decode-pipeline}[json-decode-pipeline]. The types there are a bit fancier, but some folks find them much easier to read and work with.


****
**Fun Fact:** I have heard a bunch of stories of folks finding bugs in their _server_ code as they switched from JS to Elm. The decoders people write end up working as a validation phase, catching weird stuff in JSON values. So when NoRedInk switched from React to Elm, it revealed a couple bugs in their Ruby code!
****

[[s6.3]]

=== 6.3 Random

So far we have only seen commands to make HTTP requests, but we can command other things as well, like generating random values! So we are going to make an app that rolls dice, producing a random number between 1 and 6.

Click the blue "Edit" button to see this example in action. Generate a couple random numbers, and look through the code to try to figure out how it works. **Click the blue button now!**

link:https://elm-lang.org/examples/numbers[Edit]

```elm
import Browser
import Html exposing (..)
import Html.Events exposing (..)
import Random



-- MAIN


main =
  Browser.element
    { init = init
    , update = update
    , subscriptions = subscriptions
    , view = view
    }



-- MODEL


type alias Model =
  { dieFace : Int
  }


init : () -> (Model, Cmd Msg)
init _ =
  ( Model 1
  , Cmd.none
  )



-- UPDATE


type Msg
  = Roll
  | NewFace Int


update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
  case msg of
    Roll ->
      ( model
      , Random.generate NewFace (Random.int 1 6)
      )

    NewFace newFace ->
      ( Model newFace
      , Cmd.none
      )



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
  Sub.none



-- VIEW


view : Model -> Html Msg
view model =
  div []
    [ h1 [] [ text (String.fromInt model.dieFace) ]
    , button [ onClick Roll ] [ text "Roll" ]
    ]
```

The new thing here is command issued in the `update` function:

```elm
Random.generate NewFace (Random.int 1 6)
```

Generating random values works a bit different than in languages like JavaScript, Python, Java, etc. So let's see how it works in Elm!


==== Random Generators

We are using the link:{api_readme}[`elm/random`] package for this. The link:{api_random}[`Random`] module in particular.


The core idea is that we have random `Generator` that describes _how_ to generate a random value. For example:

```elm
import Random

probability : Random.Generator Float
probability =
  Random.float 0 1

roll : Random.Generator Int
roll =
  Random.int 1 6

usuallyTrue : Random.Generator Bool
usuallyTrue =
  Random.weighted (80, True) [ (20, False) ]
```

So here we have three random generators. The `roll` generator is saying it will produce an `Int`, and more specifically, it will produce an integer between `1` and `6` inclusive. Likewise, the `usuallyTrue` generator is saying it will produce a `Bool`, and more specifically, it will be true 80% of the time.

The point is that we are not actually generating the values yet. We are just describing _how_ to generate them. From there you use the link:{api_Random-gen}[`Random.generate`] to turn it into a command:

```elm
generate : (a -> msg) -> Generator a -> Cmd msg
```

When the command is performed, the `Generator` produces some value, and then that gets turned into a message for your `update` function. So in our example, the `Generator` produces a value between 1 and 6, and then it gets turned into a message like `NewFace 1` or `NewFace 4`. That is all we need to know to get our random dice rolls, but generators can do quite a bit more!



==== Combining Generators

Once we have some simple generators like `probability` and `usuallyTrue`, we can start snapping them together with functions like link:{api_Random-map3}[Random map3]. Imagine we want to make a simple slot machine. We could create a generator like this:

```elm
import Random

type Symbol = Cherry | Seven | Bar | Grapes

symbol : Random.Generator Symbol
symbol =
  Random.uniform Cherry [ Seven, Bar, Grapes ]

type alias Spin =
  { one : Symbol
  , two : Symbol
  , three : Symbol
  }

spin : Random.Generator Spin
spin =
  Random.map3 Spin symbol symbol symbol
```

We first create `Symbol` to describe the pictures that can appear on the slot machine. We then create a random generator that generates each symbol with equal probability.

From there we use `map3` to combine them into a new `spin` generator. It says to generate three symbols and then put them together into a `Spin`.

The point here is that from small building blocks, we can create a `Generator` that describes pretty complex behavior. And then from our application, we just have to say something like `Random.generate NewSpin spin` to get the next random value.

****
**Exercises:** Here are a few ideas to make the example code on this page a bit more interesting!

- Instead of showing a number, show the die face as an image.
- Instead of showing an image of a die face, use link:{api_svg}[`elm/svg`] to draw it yourself.
- Create a weighted die with link:{api_Random-weighted}[`Random.weighted`].
- Add a second die and have them both roll at the same time.
- Have the dice flip around randomly before they settle on a final value.
****


[[s6.4]]

=== 6.4 Time

Now we are going to make a digital clock. (Analog will be an exercise!)

So far we have focused on commands. With the HTTP and randomness examples, we commanded Elm to do specific work immediately, but that is sort of a weird pattern for a clock. We _always_ want to know the current time. This is where **subscriptions** come in!

Start by clicking the blue "Edit" button and looking through the code a bit in the online editor.

link:https://elm-lang.org/examples/time[Edit]

```elm
import Browser
import Html exposing (..)
import Task
import Time



-- MAIN


main =
  Browser.element
    { init = init
    , view = view
    , update = update
    , subscriptions = subscriptions
    }



-- MODEL


type alias Model =
  { zone : Time.Zone
  , time : Time.Posix
  }


init : () -> (Model, Cmd Msg)
init _ =
  ( Model Time.utc (Time.millisToPosix 0)
  , Task.perform AdjustTimeZone Time.here
  )



-- UPDATE


type Msg
  = Tick Time.Posix
  | AdjustTimeZone Time.Zone



update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
  case msg of
    Tick newTime ->
      ( { model | time = newTime }
      , Cmd.none
      )

    AdjustTimeZone newZone ->
      ( { model | zone = newZone }
      , Cmd.none
      )



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
  Time.every 1000 Tick



-- VIEW


view : Model -> Html Msg
view model =
  let
    hour   = String.fromInt (Time.toHour   model.zone model.time)
    minute = String.fromInt (Time.toMinute model.zone model.time)
    second = String.fromInt (Time.toSecond model.zone model.time)
  in
  h1 [] [ text (hour ++ ":" ++ minute ++ ":" ++ second) ]
```

The new stuff is all coming from the link:{api_time}[`elm/time`] package. Let's go through these parts!



==== Time.Posix and Time.Zone

To work with time successfully in programming, we need three different concepts:

- **Human Time** — This is what you see on clocks (8am) or on calendars (May 3rd). Great! But if my phone call is at 8am in Boston, what time is it for my friend in Vancouver? If it is at 8am in Tokyo, is that even the same day in New York? (No!) So between link:{timezone}[time zones] based on ever-changing political boundaries and inconsistent use of link:{dst}[daylight saving time], human time should basically never be stored in your `Model` or database! It is only for display!

- **POSIX Time** — With POSIX time, it does not matter where you live or what time of year it is. It is just the number of seconds elapsed since some arbitrary moment (in 1970). Everywhere you go on Earth, POSIX time is the same.

- **Time Zones** — A “time zone” is a bunch of data that allows you to turn POSIX time into human time. This is _not_ just `UTC-7` or `UTC+3` though! Time zones are way more complicated than a simple offset! Every time link:{florida}[Florida switches to DST forever] or link:{samoa}[Samoa switches from UTC-11 to UTC+13], some poor soul adds a note to the link:{iana}[IANA time zone database]. That database is loaded onto every computer, and between POSIX time and all the corner cases in the database, we can figure out human times!

So to show a human being a time, you must always know `Time.Posix` and `Time.Zone`. That is it! So all that “human time” stuff is for the `view` function, not the `Model`. In fact, you can see that in our `view`:

```elm
view : Model -> Html Msg
view model =
  let
    hour   = String.fromInt (Time.toHour   model.zone model.time)
    minute = String.fromInt (Time.toMinute model.zone model.time)
    second = String.fromInt (Time.toSecond model.zone model.time)
  in
  h1 [] [ text (hour ++ ":" ++ minute ++ ":" ++ second) ]
```

The link:{api_Time-toHour}[`Time.toHour`] function takes `Time.Zone` and `Time.Posix` gives us back an `Int` from `0` to `23` indicating what hour it is in _your_ time zone.

There is a lot more info about handling times in the README of link:{api_time}[`elm/time`]. Definitely read it before doing more with time! Especially if you are working with scheduling, calendars, etc.



==== subscriptions

Okay, well how should we get our `Time.Posix` though? With a **subscription**!

```elm
subscriptions : Model -> Sub Msg
subscriptions model =
  Time.every 1000 Tick
```

We are using the link:{api_Time-every}[`Time.every`] function:


```elm
every : Float -> (Time.Posix -> msg) -> Sub msg
```

It takes two arguments:

1. A time interval in milliseconds. We said `1000` which means every second. But we could also say `60 * 1000` for every minute, or `5 * 60 * 1000` for every five minutes.
2. A function that turns the current time into a `Msg`. So every second, the current time is going to turn into a `Tick <time>` for our `update` function.

That is the basic pattern of any subscription. You give some configuration, and you describe how to produce `Msg` values. Not too bad!


==== Task.perform

Getting `Time.Zone` is a bit trickier. Our program created a **command** with:

```elm
Task.perform AdjustTimeZone Time.here
```

Reading through the link:{api_task}[`Task`] docs is the best way to understand that line. The docs are written to actually explain the new concepts, and I think it would be too much of a digression to include a worse version of that info here. The point is just that we command the runtime to give us the `Time.Zone` wherever the code is running.



****
**Exercises:**

- Add a button to pause the clock, turning the `Time.every` subscription off.
- Make the digital clock look nicer. Maybe add some link:{api_style}[`style`] attributes.
- Use link:{api_svg}[`elm/svg`] to make an analog clock with a red second hand!
****

[[c07]]

== 7 Installation

We have come a long way without installing anything! We learned **The Elm Architecture**. We learned about **types**. We learned how to interact with the outside world through **commands** and **subscriptions**. Things are going well, but we need to get Elm working on your computer for the next couple sections!

The next two pages will show how to get Elm working in your **editor** and then in your **terminal**.


**Why?** Upcoming topics like "JavaScript Interop" work a lot better when you can save files locally on your computer. This will also set us up to create more complex personal projects!

**Troubleshooting:** Things can sometimes go wrong with installation, so if you run into any trouble, please ask about it in a link:https://elm-lang.org/community[https://elm-lang.org/community]! Talking through an install problem can usually save you a lot of time, and people are happy to help out. Please ask for help!

[[s7.1]]

=== 7.1 Install a Code Editor

The first step is to get a code editor set up to handle Elm files.

image:https://guide.elm-lang.org/install/images/editor.png[editor]

There are a bunch of editor plugins maintained by community members for a broad range of editors. You can check out a list of them link:https://github.com/elm/editor-plugins[https://github.com/elm/editor-plugins].

It can be tricky to get an editor set up, so for the purpose of this guide, I am going to show how to get set up with Sublime Text in particular. Hopefully this will be helpful for people new to programming or as a backup for people who already have a preferred code editor.


==== Sublime Text

**Step 1:** Download Sublime Text from link:https://www.sublimetext.com/[https://www.sublimetext.com/].

**Step 2:** Install the "Elm Syntax Highlighting" plugin.

- link:https://github.com/evancz/elm-syntax-highlighting/blob/master/install/mac.md[Mac]
- link:https://github.com/evancz/elm-syntax-highlighting/blob/master/install/linux.md[Linux]
- link:https://github.com/evancz/elm-syntax-highlighting/blob/master/install/windows.md[Windows]

After going through those steps, it should be possible to open Elm files with syntax highlighting. Keywords like `import` and `type` should be colorful so the code is easier to read.


NOTE: There are alternatives! Community members have created editor plugins for Atom, Emacs, IntelliJ, Vim, VS Code, and many more. We try to keep link:https://github.com/elm/editor-plugins[https://github.com/elm/editor-plugins] up to date with all the options!


[[s7.2]]

=== 7.2 Install Elm

The previous page described how to install a code editor for Elm, so the next step is to obtain an executable file named `elm`. Here are the **install** links:

- **Mac** - link:https://github.com/elm/compiler/releases/download/0.19.1/installer-for-mac.pkg[installer]
- **Linux** - link:https://github.com/elm/compiler/blob/master/installers/linux/README.md[instructions]
- **Windows** - link:https://github.com/elm/compiler/releases/download/0.19.1/installer-for-windows.exe[installer]

After installation is complete, open up the terminal on your computer. It may be called `cmd.exe` or `Command Prompt` on Windows.

image:https://guide.elm-lang.org/install/images/terminal.png[terminal]

Start by navigating to your desktop in the terminal:

```bash
# Mac and Linux
cd ~/Desktop

# Windows (but with <username> filled in with your user name)
cd C:\Users\<username>\Desktop
```

The next step is to get familiar with `elm` command. I personally had a really hard time learning terminal commands, so I worked hard to make the `elm` command nice to use. Let's go through a couple common scenarios.



==== elm init

You can start an Elm project by running:

```bash
elm init
```

Try running this command to create an `elm.json` file and a `src/` directory:

- link:https://github.com/elm/compiler/blob/master/docs/elm.json/application.md[elm.json] describes your project.
- `src/` holds all of your Elm files.

Now try creating a file called `src/Main.elm` in your editor, and copying in the code from link:https://elm-lang.org/examples/buttons[the buttons example].



==== elm reactor

`elm reactor` helps you build Elm projects without messing with the terminal too much. You just run it at the root of your project, like this:

```bash
elm reactor
```

This starts a server at link:http://localhost:8000[http://localhost:8000]. You can navigate to any Elm file and see what it looks like. Run `elm reactor`, follow the localhost link, and try to check out your `src/Main.elm` file!



==== elm make

You can compile Elm code to HTML or JavaScript with commands like this:

```bash
# Create an index.html file that you can open in your browser.
elm make src/Main.elm

# Create an optimized JS file to embed in a custom HTML document.
elm make src/Main.elm --optimize --output=elm.js
```

Try running these commands on your `src/Main.elm` file.

This is the most general way to compile Elm code. It is extremely useful once your project becomes too advanced for `elm reactor`.

This command produces the same messages you have been seeing in the online editor and with `elm reactor`. Years of work has gone into them so far, but please report any unhelpful messages link:https://github.com/elm/error-message-catalog/issues[here]. I am sure there are ways to improve!



==== elm install

Elm packages all live at link:https://package.elm-lang.org/[package.elm-lang.org].

Say you look around and decide you need link:{api_http}[`elm/http`] and link:{api_json}[`elm/json`] to make some HTTP requests. You can get them set up in your project with the following commands:

```bash
elm install elm/http
elm install elm/json
```

This adds these dependencies into your `elm.json` file, making these packages available in your project. That will let you say `import Http` and use functions like `Http.get` in your programs.




==== Tips and Tricks

**First**, do not worry about remembering all this stuff!

You can always run `elm --help` to get a full outline of what `elm` is capable of.

You can also run commands like `elm make --help` and `elm repl --help` to get hints about a specific command. This is great if you want to check which flags are available and what they do.

**Second**, do not worry if it takes some time to get comfortable with the terminal in general.

I have been using it for over a decade now, and I still cannot remember how to compress files, find all Elm files in a directory, etc. I still look a lot of things up!

''''''

Now that we have our editor set up and `elm` available in the terminal, let's get back to learning Elm!


[[c08]]

== 8 JavaScript Interop

By now we have seen **The Elm Architecture**, **types**, **commands**, **subscriptions**, and we even have Elm installed locally.

But what happens when you need to integrate with JavaScript? Maybe there is a browser API that does not have an equivalent Elm package yet. Maybe you want to embed a JavaScript widget within your Elm app? Etc. This chapter will outline Elm's three interop mechanisms:

- <<flags, Flags>>
- <<ports, Ports>>
- <<custom_elements, Custom Elements>>

Before we get into the three mechanisms, we need to know how to compile Elm programs to JavaScript!

NOTE: If you are evaluating Elm for use at work, I encourage you to make sure these three mechanisms will be able to cover all of your needs. You can get a quick overview of this chapter by looking at these link:https://github.com/elm-community/js-integration-examples/[examples]. Please ask link:https://discourse.elm-lang.org/[discourse] if you are not sure about something, and I encourage you to circle back to Elm later if you are not fully confident.


=== Compiling to JavaScript

Running `elm make` produces HTML files by default. So if you say:

```bash
elm make src/Main.elm
```

It produces an `index.html` file that you can just open and start playing with. If you are getting into JavaScript interop, you want to produce JavaScript files instead:

```bash
elm make src/Main.elm --output=main.js
```

This produces a JavaScript file that exposes an `Elm.Main.init()` function. So once you have `main.js` you can write your own HTML file that does whatever you want.


==== Embedding in HTML

Here is the minimal HTML needed to make your `main.js` appear in a browser:

```html
<html>
<head>
  <meta charset="UTF-8">
  <title>Main</title>
  <script src="main.js"></script>
</head>

<body>
  <div id="myapp"></div>
  <script>
  var app = Elm.Main.init({
    node: document.getElementById('myapp')
  });
  </script>
</body>
</html>
```

I want to call attention to the important lines here:

- `<head>` - We have a line to load our compiled `main.js` file. This is required! If you compile an Elm module called `Main`, you will get an `Elm.Main.init()` function available in JavaScript. If you compile an Elm module named `Home`, you will get an `Elm.Home.init()` function in JavaScript. Etc.

- `<body>` - We need to do two things here. First, we create a `<div>` that we want our Elm program to take over. Maybe it is within a larger application, surrounded by tons of other stuff? That is fine! Second, we have a `<script>` to initialize our Elm program. Here we call the `Elm.Main.init()` function to start our program, passing in the `node` we want to take over.

Now that we know how to embed Elm programs in an HTML document, it is time to start exploring the three interop options: flags, ports, and custom elements!

NOTE: This is a normal HTML file, so you can put whatever you want in it! Many people load additional JS and CSS files in the `<head>`. That means it is totally fine to write your CSS by hand or to generate it somehow. Add something like `<link rel="stylesheet" href="whatever-you-want.css">` in your `<head>` and you have access to it. (There are some great options for specifying your CSS all _within_ Elm as well, but that is a whole other topic!)



[[s8.1]][[flags]]

=== 8.1 Flags

Flags are a way to pass values into Elm on initialization.

Common uses are passing in API keys, environment variables, and user data. This can be handy if you generate the HTML dynamically. They can also help us load cached information in link:https://github.com/elm-community/js-integration-examples/tree/master/localStorage[localStorage example].


==== Flags in HTML

The HTML is basically the same as before, but with an additional `flags` argument to the `Elm.Main.init()` function

```html
<html>
<head>
  <meta charset="UTF-8">
  <title>Main</title>
  <script src="main.js"></script>
</head>

<body>
  <div id="myapp"></div>
  <script>
  var app = Elm.Main.init({
    node: document.getElementById('myapp'),
    flags: Date.now()
  });
  </script>
</body>
</html>
```

In this example we are passing in the current time in milliseconds, but any JS value that can be JSON decoded can be given as a flag.

NOTE: This additional data is called “flags” because it is kind of like command line flags. You can call `elm make src/Main.elm`, but you can add some flags like `--optimize` and `--output=main.js` to customize its behavior. Same sort of thing.



==== Flags in Elm

To handle flags on the Elm side, you need to modify your `init` function a bit:

```elm
module Main exposing (..)

import Browser
import Html exposing (Html, text)


-- MAIN

main : Program Int Model Msg
main =
  Browser.element
    { init = init
    , view = view
    , update = update
    , subscriptions = subscriptions
    }


-- MODEL

type alias Model = { currentTime : Int }

init : Int -> ( Model, Cmd Msg )
init currentTime =
  ( { currentTime = currentTime }
  , Cmd.none
  )


-- UPDATE

type Msg = NoOp

update : Msg -> Model -> ( Model, Cmd Msg )
update _ model =
  ( model, Cmd.none )


-- VIEW

view : Model -> Html Msg
view model =
  text (String.fromInt model.currentTime)


-- SUBSCRIPTIONS

subscriptions : Model -> Sub Msg
subscriptions _ =
  Sub.none
```

The only important here is the `init` function says it takes an `Int` argument. This is how Elm code gets immediate access to the flags you pass in from JavaScript. From there, you can put things in your model or run some commands. Whatever you need to do.

I recommend checking out link:https://github.com/elm-community/js-integration-examples/tree/master/localStorage[this `localStorage` example] for a more interesting use of flags!


==== Verifying Flags

But what happens if `init` says it takes an `Int` flag, but someone tries to initialize with `Elm.Main.init({ flags: "haha, what now?" })`?

Elm checks for that sort of thing, making sure the flags are exactly what you expect. Without this check, you could pass in anything, leading to runtime errors in Elm!

There are a bunch of types that can be given as flags:

- `Bool`
- `Int`
- `Float`
- `String`
- `Maybe`
- `List`
- `Array`
- tuples
- records
- link:{api_Json-Decode-Value}[Json-Decode Value]

Many folks always use a `Json.Decode.Value` because it gives them really precise control. They can write a decoder to handle any weird scenarios in Elm code, recovering from unexpected data in a nice way.

The other supported types actually come from before we had figured out a way to do JSON decoders. If you choose to use them, there are some subtleties to be aware of. The following examples show the desired flag type, and then the sub-points show what would happen with a couple different JS values:

- `init : Int -> ...`
  - `0` => `0`
  - `7` => `7`
  - `3.14` => error
  - `6.12` => error

- `init : Maybe Int -> ...`
  - `null` => `Nothing`
  - `42` => `Just 42`
  - `"hi"` => error

- `init : { x : Float, y : Float } -> ...`
  - `{ x: 3, y: 4, z: 50 }` => `{ x = 3, y = 4 }`
  - `{ x: 3, name: "Tom" }` => error
  - `{ x: 360, y: "why?" }` => error

- `init : (String, Int) -> ...`
  - `["Tom", 42]` => `("Tom", 42)`
  - `["Sue", 33]` => `("Sue", 33)`
  - `["Bob", "4"]` => error
  - `["Joe", 9, 9]` => error

Note that when one of the conversions goes wrong, **you get an error on the JS side!** We are taking the “fail fast” policy. Rather than the error making its way through Elm code, it is reported as soon as possible. This is another reason why people like to use `Json.Decode.Value` for flags. Instead of getting an error in JS, the weird value goes through a decoder, guaranteeing that you implement some sort of fallback behavior.



[[s8.2]][[ports]]

=== 8.2 Ports

Ports allow communication between Elm and JavaScript.

Ports are probably most commonly used for link:https://github.com/elm-community/js-integration-examples/tree/master/websockets[`websockets`] and link:https://github.com/elm-community/js-integration-examples/tree/master/localStorage[`localStorage`]. Let's focus on the `WebSockets` example.



==== Ports in JavaScript

Here we have pretty much the same HTML we have been using on the previous pages, but with a bit of extra JavaScript code in there. We create a connection to `wss://echo.websocket.org` that just repeats back whatever you send it. You can see in the link:https://ellie-app.com/8yYgw7y7sM2a1[https://ellie-app.com/8yYgw7y7sM2a1] that this lets us make the skeleton of a chat room:

```html
<!DOCTYPE HTML>
<html>

<head>
  <meta charset="UTF-8">
  <title>Elm + Websockets</title>
  <script type="text/javascript" src="elm.js"></script>
</head>

<body>
	<div id="myapp"></div>
</body>

<script type="text/javascript">

// Start the Elm application.
var app = Elm.Main.init({
	node: document.getElementById('myapp')
});

// Create your WebSocket.
var socket = new WebSocket('wss://echo.websocket.org');

// When a command goes to the `sendMessage` port, we pass the message
// along to the WebSocket.
app.ports.sendMessage.subscribe(function(message) {
    socket.send(message);
});

// When a message comes into our WebSocket, we pass the message along
// to the `messageReceiver` port.
socket.addEventListener("message", function(event) {
	app.ports.messageReceiver.send(event.data);
});

// If you want to use a JavaScript library to manage your WebSocket
// connection, replace the code in JS with the alternate implementation.
</script>

</html>
```

We call `Elm.Main.init()` like in all of our interop examples, but this time we are actually using the resulting `app` object. We are subscribing to the `sendMessage` port and we are sending to the `messageReceiver` port.

Those correspond to code written on the Elm side.



==== Ports in Elm

Check out the lines that use the `port` keyword in the corresponding Elm file. This is how we define the ports that we just saw on the JavaScript side.

```elm
port module Main exposing (..)

import Browser
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Json.Decode as D



-- MAIN


main : Program () Model Msg
main =
  Browser.element
    { init = init
    , view = view
    , update = update
    , subscriptions = subscriptions
    }




-- PORTS


port sendMessage : String -> Cmd msg
port messageReceiver : (String -> msg) -> Sub msg



-- MODEL


type alias Model =
  { draft : String
  , messages : List String
  }


init : () -> ( Model, Cmd Msg )
init flags =
  ( { draft = "", messages = [] }
  , Cmd.none
  )



-- UPDATE


type Msg
  = DraftChanged String
  | Send
  | Recv String


-- Use the `sendMessage` port when someone presses ENTER or clicks
-- the "Send" button. Check out index.html to see the corresponding
-- JS where this is piped into a WebSocket.
--
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
  case msg of
    DraftChanged draft ->
      ( { model | draft = draft }
      , Cmd.none
      )

    Send ->
      ( { model | draft = "" }
      , sendMessage model.draft
      )

    Recv message ->
      ( { model | messages = model.messages ++ [message] }
      , Cmd.none
      )



-- SUBSCRIPTIONS


-- Subscribe to the `messageReceiver` port to hear about messages coming in
-- from JS. Check out the index.html file to see how this is hooked up to a
-- WebSocket.
--
subscriptions : Model -> Sub Msg
subscriptions _ =
  messageReceiver Recv



-- VIEW


view : Model -> Html Msg
view model =
  div []
    [ h1 [] [ text "Echo Chat" ]
    , ul []
        (List.map (\msg -> li [] [ text msg ]) model.messages)
    , input
        [ type_ "text"
        , placeholder "Draft"
        , onInput DraftChanged
        , on "keydown" (ifIsEnter Send)
        , value model.draft
        ]
        []
    , button [ onClick Send ] [ text "Send" ]
    ]



-- DETECT ENTER


ifIsEnter : msg -> D.Decoder msg
ifIsEnter msg =
  D.field "key" D.string
    |> D.andThen (\key -> if key == "Enter" then D.succeed msg else D.fail "some other key")
```

Notice that the first line says `port module` rather than just `module`. This makes it possible to define ports in a given module. The compiler gives a hint about this if it is needed, so hopefully no one gets too stuck on that!

Okay, but what is going on with the `port` declarations for `sendMessage` and `messageReceiver`?


==== Outgoing Messages (Cmd)

The `sendMessage` declaration lets us send messages out of Elm.

[source]
port sendMessage : String -> Cmd msg

Here we are declaring that we want to send out `String` values, but we could send out any of the types that work with flags. We talked about those types on the previous page, and you can check out link:https://ellie-app.com/8yYddD6HRYJa1[this `localStorage` example] to see a link:{api_Json-Encode-Value}[Json-Encode Value] getting sent out to JavaScript.

From there we can use `sendMessage` like any other function. If your `update` function produces a `sendMessage "hello"` command, you will hear about it on the JavaScript side:

```javascript
app.ports.sendMessage.subscribe(function(message) {
    socket.send(message);
});
```

This JavaScript code is subscribed to all of the outgoing messages. You can `subscribe` multiple functions and `unsubscribe` functions by reference, but we generally recommend keeping things static.

We also recommend sending out richer messages, rather than making lots of individual ports. Maybe that means having a custom type in Elm that represents everything you might need to tell JS, and then using link:{api_Json-Encode}[Json-Encode] to send it out to a single JS subscription. Many people find that this creates a cleaner separation of concerns. The Elm code clearly owns some state, and the JS clearly owns other state.


==== Incoming Messages (Sub)

The `messageReceiver` declaration lets us listen for messages coming in to Elm.

```elm
port messageReceiver : (String -> msg) -> Sub msg
```

We are saying we are going to receive `String` values, but again, we can listen for any type that can come in through flags or outgoing ports. Just swap out the `String` type with one of the types that can cross the border.

Again we can use `messageReceiver` like any other function. In our case we call `messageReceiver Recv` when defining our `subscriptions` because we want to hear about any incoming messages from JavaScript. This will let us get messages like `Recv "how are you?"` in our `update` function.

On the JavaScript side, we are able to send things to this port whenever we want:

```javascript
socket.addEventListener("message", function(event) {
	app.ports.messageReceiver.send(event.data);
});
```

We happen to be sending whenever the websocket gets a message, but you could send at other times as well. Maybe we are getting messages from another data source as well. That is fine, and Elm does not need to know anything about it! Just send the strings through the relevant port.


==== Notes

**Ports are about creating strong boundaries!** Definitely do not try to make a port for every JS function you need. You may really like Elm and want to do everything in Elm no matter the cost, but ports are not designed for that. Instead, focus on questions like “who owns the state?” and use one or two ports to send messages back and forth. If you are in a complex scenario, you can even simulate `Msg` values by sending JS like `{ tag: "active-users-changed", list: ... }` where you have a tag for all the variants of information you might send across.

Here are some simple guidelines and common pitfalls:

- **Sending `Json.Encode.Value` through ports is recommended.** Like with flags, certain core types can pass through ports as well. This is from the time before JSON decoders, and you can read about it more <<verifying-flags, here>>.

- **All `port` declarations must appear in a `port module`.** It is probably best to organize all your ports into one `port module` so it is easier to see the interface all in one place.

- **Ports are for applications.** A `port module` is available in applications, but not in packages. This ensures that application authors have the flexibility they need, but the package ecosystem is entirely written in Elm. We think this will create a stronger ecosystem and community in the long run, and we get into the tradeoffs in depth in the upcoming section on the <<limits, limits>> of Elm/JS interop.

- **Ports can be dead code eliminated.** Elm has quite aggressive link:https://en.wikipedia.org/wiki/Dead_code_elimination[Dead code elimination], and it will remove ports that are not used within Elm code. The compiler does not know what goes on in JavaScript, so try to hook things up in Elm before JavaScript.

I hope this information will help you find ways to embed Elm in your existing JavaScript! It is not as glamorous as doing a full-rewrite in Elm, but history has shown that it is a much more effective strategy.



[[s8.3]][[custom_types]]

=== 8.3 Custom Elements

On the last few pages, we have seen (1) how to start Elm programs from JavaScript, (2) how to pass data in as flags on initialization, and (3) how to send messages between Elm and JS with ports. But guess what people? There is another way to do interop!

Browsers seem to be supporting link:https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements[custom elements] more and more, and that turns out to be quite helpful for embedding JS into Elm programs.

Here is a link:https://github.com/elm-community/js-integration-examples/tree/master/internationalization[minimal example] of how to use custom elements to do some localization and internationalization.


==== Creating Custom Elements

Say we want to localize dates, but that is not accessible in Elm core packages yet. Maybe you want to write a function that localizes dates:

```javascript
//
//   localizeDate('sr-RS', 12, 5) === "петак, 1. јун 2012."
//   localizeDate('en-GB', 12, 5) === "Friday, 1 June 2012"
//   localizeDate('en-US', 12, 5) === "Friday, June 1, 2012"
//
function localizeDate(lang, year, month)
{
	const dateTimeFormat = new Intl.DateTimeFormat(lang, {
		weekday: 'long',
		year: 'numeric',
		month: 'long',
		day: 'numeric'
	});

	return dateTimeFormat.format(new Date(year, month));
}
```

But how do we use that in Elm?! Newer browsers allow you to create new types of DOM nodes like this:

```javascript
//
//   <intl-date lang="sr-RS" year="2012" month="5">
//   <intl-date lang="en-GB" year="2012" month="5">
//   <intl-date lang="en-US" year="2012" month="5">
//
customElements.define('intl-date',
	class extends HTMLElement {
		// things required by Custom Elements
		constructor() { super(); }
		connectedCallback() { this.setTextContent(); }
		attributeChangedCallback() { this.setTextContent(); }
		static get observedAttributes() { return ['lang','year','month']; }

		// Our function to set the textContent based on attributes.
		setTextContent()
		{
			const lang = this.getAttribute('lang');
			const year = this.getAttribute('year');
			const month = this.getAttribute('month');
			this.textContent = localizeDate(lang, year, month);
		}
	}
);
```

The most important parts here are `attributeChangedCallback` and `observedAttributes`. You need some logic like that to detect changes to the attributes you care about.

Load that before you initialize your Elm code, and you will be able to write code like this in Elm:

```elm
import Html exposing (Html, node)
import Html.Attributes (attribute)

viewDate : String -> Int -> Int -> Html msg
viewDate lang year month =
  node "intl-date"
    [ attribute "lang" lang
    , attribute "year" (String.fromInt year)
    , attribute "month" (String.fromInt month)
    ]
    []
```

Now you can call `viewDate` when you want access to that kind of localized information in your `view`.

You can check out the full version of this example link:https://github.com/elm-community/js-integration-examples/tree/master/internationalization[https://github.com/elm-community/js-integration-examples/tree/master/internationalization].


==== More Info

Luke has a lot more experience with custom elements, and I think his Elm Europe talk is an excellent introduction!

video::tyFe9Pw6TVE[youtube]

    {% youtube %} https://www.youtube.com/watch?v=tyFe9Pw6TVE {% endyoutube %}

Docs on custom elements can be kind of confusing, but I hope this is enough for people to get started embedding simple logic for `Intl` or even large React widgets if that seems like the right choice for your project.

[[s8.4]]

=== 8.4 The Limits of Elm/JS Interop

Many languages have a Foreign Function Interface (FFI) that allows direct bindings functions in the host language. For example, Scala can call Java functions directly. Same with Clojure/Java, Python/C, Haskell/C, and many others.

**Elm does not have a traditional Foreign Function Interface with JavaScript.** It is not possible to call arbitrary JavaScript functions at any time. This has tradeoffs that some people really love, but it is not for everyone! If you are evaluating Elm for commercial use, I highly encourage you to look through link:https://github.com/elm-community/js-integration-examples[these interop examples] to get a feeling for whether flags, ports, and custom elements can cover everything you need.

Why does Elm make a different choice than other languages on this?


==== Tradeoffs

Ports are somewhat of an outlier in the history of languages. There are two common interop strategies, and Elm did neither of them:

1. **Full backwards compatibility.** For example, C++ is a superset of C, and TypeScript is a superset of JavaScript. This is the most permissive approach, and it has proven extremely effective. By definition, everyone is using your language already.
2. **Foreign function interface (FFI)** This allows direct bindings to functions in the host language. For example, Scala can call Java functions directly. Same with Clojure/Java, Python/C, Haskell/C, and many others. Again, this has proven quite effective.

These paths are attractive for faster adoption and greater flexibility, but they are not ideal for Elm for two main reasons:

1. **Losing Guarantees.** One of the best things about Elm is that there are entire categories of problems you just do not have to worry about. There are no surprise exceptions to catch, and functions cannot mutate data in surprising ways. I think this is the core value of Elm over alternative languages, but if we can call JS directly, all that goes away. Does this package produce runtime exceptions? When? Will it mutate the values I give to it? Do I need to detect that? Does the package have side-effects? Will it send messages to some 3rd party servers? Log passwords? A decent chunk of Elm users are drawn to the language specifically because they do not have to think like that anymore.
2. **Package Flooding.** There is quite high demand to directly copy JavaScript APIs into Elm. In the two years before `elm/html` existed, I am sure someone would have contributed jQuery bindings if it was possible. This has already happened in the typed functional languages that compile to JS, but have more traditional interop designs. As far as I know, package flooding is somewhat unique to compile-to-JS languages. The pressure is not nearly as high in Python for example, so I think that downside is a product of the unique culture and history of the JavaScript ecosystem.

Given these pitfalls, ports and custom elements are attractive because they let you get things done in JavaScript while preserving the best parts of Elm. Great! On the flip side, it means Elm cannot piggyback on the JS ecosystem to gain more libraries more quickly. If you take a longer-view, I think this is actually a key strength. As a result:

1. **Packages are designed for Elm.** As members of the Elm community get more experience and confidence, we are starting to see fresh approaches to layout and data visualization that work seamlessly with The Elm Architecture and the overall ecosystem. I expect this to keep happening with other sorts of problems!
2. **Code is portable.** If the compiler someday produces x86 or WebAssembly, the whole ecosystem just keeps working, but faster! Ports guarantee that all packages are written entirely in Elm, and Elm itself was designed such that other non-JS compiler targets are viable.
3. **Packages are more secure.** Languages like JavaScript have serious security concerns with packages. Reports of link:https://www.bleepingcomputer.com/news/security/compromised-javascript-package-caught-stealing-npm-credentials/[stealing credentials] and link:https://winbuzzer.com/2020/01/14/microsoft-discovers-an-npm-package-thats-been-stealing-unix-user-data-xcxwbn/[stealing API keys] are not uncommon, imposing a permanent auditing cost on all packages. Do they add a keylogger to `window`? Elm packages can guarantee that entire categories of exploits just cannot happen, reducing auditing cost and security risks overall.
4. **Optimization is easier.** The style of generated code has changed significantly from release to release in the past. For example, the link:https://elm-lang.org/news/small-assets-without-the-headache[0.19 release] was able to dramatically reduce asset size by (1) generating code in a way that works better with JavaScript minifiers and (2) using different runtime representations of custom types depending on your optimization level. I expect it will change again for code slicing or if we find a faster calling convention for currying. Furthermore, the compiler can safely assume that all code is pure, which may allow it to move code around more aggressively than other compilers. Locking into a specific calling convention now is likely to make some of these optimizations impossible.

This is definitely a longer and harder path, but languages live for 30+ years. They have to support teams and companies for decades, and when I think about what Elm will look like in 20 or 30 years, I think the trade-offs that come with ports look really promising! My talk link:https://youtu.be/uGlzRt-FYto[What is Success?] starts a little slow, but it gets into this a bit more!

And again, this path is not for everyone! There are many alternative languages that have a traditional FFI instead, and I encourage you to look into those languages if you think that path might be better. Is the package ecosystem as cohesive? Do you get runtime exceptions more often? Maybe, but maybe the extra flexibility is worth it for you. So I encourage you to take a look at link:https://github.com/elm-community/js-integration-examples[these interop examples] to decide if flags, ports, and custom elements will cover everything you need. This is especially important if you are considering Elm for commercial use!

[[c09]]

== 9 Web Apps

So far we have been creating Elm programs with `Browser.element`, allowing us to take over a single node in a larger application. This is great for _introducing_ Elm at work (as described link:https://elm-lang.org/blog/how-to-use-elm-at-work[here]) but what happens after that? How can we use Elm more extensively?

In this chapter, we will learn how to create a “web app” with a bunch of different pages that all integrate nicely with each other, but we must start by controlling a single page.


=== Control the Document

The first step is to switch to starting programs with link:{api_Browser-document}[Browser document]:

```elm
document :
  { init : flags -> ( model, Cmd msg )
  , view : model -> Document msg
  , update : msg -> model -> ( model, Cmd msg )
  , subscriptions : model -> Sub msg
  }
  -> Program flags model msg
```

The arguments are almost exactly the same as `Browser.element`, except for the `view` function. Rather than returning an `Html` value, you return a link:{api_Browser-Document}[Browser Document] like this:

```elm
type alias Document msg =
  { title : String
  , body : List (Html msg)
  }
```

This gives you control over the `<title>` and the `<body>` of the document. Perhaps your program downloads some data and that helps you determine a more specific title. Now you can just change it in your `view` function!


==== Serve the Page

The compiler produces HTML by default, so you can compile your code like this:

```bash
elm make src/Main.elm
```

The output will be a file named `index.html` that you can serve like any other HTML file. That works fine, but you can get a bit more flexibility by (1) compiling Elm to JavaScript and (2) making your own custom HTML file. To take that path, you compile like this:

```bash
elm make src/Main.elm --output=main.js
```

This will produce `main.js` which you can load from a custom HTML file like this:

```html
<!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8">
  <title>Main</title>
  <link rel="stylesheet" href="whatever-you-want.css">
  <script src="main.js"></script>
</head>
<body>
  <script>var app = Elm.Main.init();</script>
</body>
</html>
```

This HTML is pretty simple. You load whatever you need in the `<head>` and you initialize your Elm program in the `<body>`. The Elm program will take it from there and render everything.

Either way, now you have some HTML that you can send to browsers. You can get that HTML to people with free services like link:https://pages.github.com/[GitHub Pages] or link:https://www.netlify.com/[Netlify], or maybe you make your own server and run a VPS with a service like link:https://m.do.co/c/c47faa1916d2[Digital Ocean]. Whatever works for you! You just need a way to get HTML into a browser.

****
NOTE: Note 1: Creating custom HTML is helpful if you are doing something custom with CSS. Many people use projects like link:{api_elm-css}[css] to handle all of their styles from within Elm, but maybe you are working in a team where there is lots of predefined CSS. Maybe the team is even using one of those CSS preprocessors. That is all fine. Just load the final CSS file in the `<head>` of your HTML file.

NOTE: Note 2: The Digital Ocean link above is a referral link, so if you sign up through that and end up using the service, we get a $25 credit towards our hosting costs for `elm-lang.org` and `package.elm-lang.org`.
****


[[s9.1]]

=== 9.1 Navigation

We just saw how to serve one page, but say we are making a website like `package.elm-lang.org`. It has a bunch of pages (e.g. link:https://package.elm-lang.org/[search], link:{api_core}[README], link:{api_Maybe}[docs]) that all work differently. How does it do that?


==== Multiple Pages

The simple way would be to serve a bunch of different HTML files. Going to the home page? Load new HTML. Going to `elm/core` docs? Load new HTML. Going to `elm/json` docs? Load new HTML.

Until Elm 0.19, that is exactly what the package website did! It works. It is simple. But it has some weaknesses:

1. **Blank Screens.** The screen goes white every time you load new HTML. Can we do a nice transition instead?
2. **Redundant Requests.** Each package has a single `docs.json` file, but it gets loaded each time you visit a module like link:{api_String}[String] or link:{api_Maybe}[Maybe]. Can we share the data between pages somehow?
3. **Redundant Code.** The home page and the docs share a lot of functions, like `Html.text` and `Html.div`. Can this code be shared between pages?

We can improve all three cases! The basic idea is to only load HTML once, and then be a bit tricky to handle URL changes.


==== Single Page

Instead of creating our program with `Browser.element` or `Browser.document`, we can create a link:{api_Browser-application}[Browser application] to avoid loading new HTML when the URL changes:

[source]
application :
  { init : flags -> Url -> Key -> ( model, Cmd msg )
  , view : model -> Document msg
  , update : msg -> model -> ( model, Cmd msg )
  , subscriptions : model -> Sub msg
  , onUrlRequest : UrlRequest -> msg
  , onUrlChange : Url -> msg
  }
  -> Program flags model msg


It extends the functionality of `Browser.document` in three important scenarios.

**When the application starts**, `init` gets the current link:{api_url}[`Url`] from the browsers navigation bar. This allows you to show different things depending on the `Url`.

**When someone clicks a link**, like `<a href="/home">Home</a>`, it is intercepted as a link:{api_urlreq}[`UrlRequest`]. So instead of loading new HTML with all the downsides, `onUrlRequest` creates a message for your `update` where you can decide exactly what to do next. You can save scroll position, persist data, change the URL yourself, etc.

**When the URL changes**, the new `Url` is sent to `onUrlChange`.
The resulting message goes to `update` where you can decide how to show the new page.

So rather than loading new HTML, these three additions give you full control over URL changes. Let’s see it in action!



==== Example

We will start with the baseline `Browser.application` program. It just keeps track of the current URL. Skim through the code now! Pretty much all of the new and interesting stuff happens in the `update` function, and we will get into those details after the code:


```elm
import Browser
import Browser.Navigation as Nav
import Html exposing (..)
import Html.Attributes exposing (..)
import Url



-- MAIN


main : Program () Model Msg
main =
  Browser.application
    { init = init
    , view = view
    , update = update
    , subscriptions = subscriptions
    , onUrlChange = UrlChanged
    , onUrlRequest = LinkClicked
    }



-- MODEL


type alias Model =
  { key : Nav.Key
  , url : Url.Url
  }


init : () -> Url.Url -> Nav.Key -> ( Model, Cmd Msg )
init flags url key =
  ( Model key url, Cmd.none )



-- UPDATE


type Msg
  = LinkClicked Browser.UrlRequest
  | UrlChanged Url.Url


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
  case msg of
    LinkClicked urlRequest ->
      case urlRequest of
        Browser.Internal url ->
          ( model, Nav.pushUrl model.key (Url.toString url) )

        Browser.External href ->
          ( model, Nav.load href )

    UrlChanged url ->
      ( { model | url = url }
      , Cmd.none
      )



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions _ =
  Sub.none



-- VIEW


view : Model -> Browser.Document Msg
view model =
  { title = "URL Interceptor"
  , body =
      [ text "The current URL is: "
      , b [] [ text (Url.toString model.url) ]
      , ul []
          [ viewLink "/home"
          , viewLink "/profile"
          , viewLink "/reviews/the-century-of-the-self"
          , viewLink "/reviews/public-opinion"
          , viewLink "/reviews/shah-of-shahs"
          ]
      ]
  }


viewLink : String -> Html msg
viewLink path =
  li [] [ a [ href path ] [ text path ] ]
```

The `update` function can handle either `LinkClicked` or `UrlChanged` messages. There is a lot of new stuff in the `LinkClicked` branch, so we will focus on that first!


==== UrlRequest

Whenever someone clicks a link like `<a href="/home">/home</a>`, it produces a `UrlRequest` value:

```elm
type UrlRequest
  = Internal Url.Url
  | External String
```

The `Internal` variant is for any link that stays on the same domain. So if you are browsing `https://example.com`, internal links include things like `settings#privacy`, `/home`, `https://example.com/home`, and `//example.com/home`.

The `External` variant is for any link that goes to a different domain. Links like `https://elm-lang.org/examples`, `https://static.example.com`, and `http://example.com/home` all go to a different domain. Notice that changing the protocol from `https` to `http` is considered a different domain!

Whichever link someone presses, our example program is going to create a `LinkClicked` message and send it to the `update` function. That is where we see most of the interesting new code!


==== LinkClicked

Most of our `update` logic is deciding what to do with these `UrlRequest` values:

```elm
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
  case msg of
    LinkClicked urlRequest ->
      case urlRequest of
        Browser.Internal url ->
          ( model, Nav.pushUrl model.key (Url.toString url) )

        Browser.External href ->
          ( model, Nav.load href )

    UrlChanged url ->
      ( { model | url = url }
      , Cmd.none
      )
```

The particularly interesting functions are `Nav.load` and `Nav.pushUrl`. These are both from the link:{api_Browser-Navigation}[Browser-Navigation] module which is all about changing the URL in different ways. We are using the two most common functions from that module:

- link:{api_Browser-Navigation-load}[Browser-Navigation load] loads all new HTML. It is equivalent to typing the URL into the URL bar and pressing enter. So whatever is happening in your `Model` will be thrown out, and a whole new page is loaded.
- link:{api_Browser-Navigation-pushUrl}[Browser-Navigation pushUrl] changes the URL, but does not load new HTML. Instead it triggers a `UrlChanged` message that we handle ourselves! It also adds an entry to the “browser history” so things work normal when people press the `BACK` or `FORWARD` buttons.

So looking back at the `update` function, we can understand how it all fits together a bit better now. When the user clicks a `https://elm-lang.org` link, we get an `External` message and use `load` to load new HTML from those servers. But when the user clicks a `/home` link, we get an `Internal` message and use `pushUrl` to change the URL _without_ loading new HTML!

****
NOTE: Note 1: Both `Internal` and `External` links are producing commands immediately in our example, but that is not required! When someone clicks an `External` link, maybe you want to save textbox content to your database before navigating away. Or when someone clicks an `Internal` link, maybe you want to use link:{api_Browser-Dom-getViewport}[Browser-Dom getViewport] to save the scroll position in case they navigate `BACK` later. That is all possible! It is a normal `update` function, and you can delay the navigation and do whatever you want.

NOTE: Note 2: If you want to restore “what they were looking at” when they come `BACK`, scroll position is not perfect. If they resize their browser or reorient their device, it could be off by quite a lot! So it is probably better to save “what they were looking at” instead. Maybe that means using link:{api_Browser-Dom-getViewportOf}[Browser-Dom getViewportOf] to figure out exactly what is on screen at the moment. The particulars depend on how your application works exactly, so I cannot give exact advice!
****

==== UrlChanged

There are a couple ways to get `UrlChanged` messages. We just saw that `pushUrl` produces them, but pressing the browser `BACK` and `FORWARD` buttons produce them as well. And like I was saying in the notes a second ago, when you get a `LinkClicked` message, the `pushUrl` command may not be given immediately.

So the nice thing about having a separate `UrlChanged` message is that it does not matter how or when the URL changed. All you need to know is that it did!

We are just storing the new URL in our example here, but in a real web app, you need to parse the URL to figure out what content to show. That is what the next page is all about!


****
NOTE: I skipped talking about link:{api_Browser-Navigation-Key}[Browser-Navigation Key] to try to focus on more important concepts. But I will explain here for those who are interested!

A navigation `Key` is needed to create navigation commands (like `pushUrl`) that change the URL. You only get access to a `Key` when you create your program with `Browser.application`, guaranteeing that your program is equipped to detect these URL changes. If `Key` values were available in other kinds of programs, unsuspecting programmers would be sure to run into some link:{api_bugs}[annoying bugs] and learn a bunch of techniques the hard way!

As a result of all that, we have a line in our `Model` for our `Key`. A relatively low price to pay to help everyone avoid an extremely subtle category of problems!
****

[[s9.2]]

=== 9.2 Parsing URLs

In a realistic web app, we want to show different content for different URLs:

- `/search`
- `/search?q=seiza`
- `/settings`

How do we do that? We use the link:{api_url}[url] to parse the raw strings into nice Elm data structures. This package makes the most sense when you just look at examples, so that is what we will do!


==== Example 1

Say we have an art website where the following addresses should be valid:

- `/topic/architecture`
- `/topic/painting`
- `/topic/sculpture`
- `/blog/42`
- `/blog/123`
- `/blog/451`
- `/user/tom`
- `/user/sue`
- `/user/sue/comment/11`
- `/user/sue/comment/51`

So we have topic pages, blog posts, user information, and a way to look up individual user comments. We would use the link:{api_Url-Parser}[Url-Parser] module to write a URL parser like this:

```elm
import Url.Parser exposing (Parser, (</>), int, map, oneOf, s, string)

type Route
  = Topic String
  | Blog Int
  | User String
  | Comment String Int

routeParser : Parser (Route -> a) a
routeParser =
  oneOf
    [ map Topic   (s "topic" </> string)
    , map Blog    (s "blog" </> int)
    , map User    (s "user" </> string)
    , map Comment (s "user" </> string </> s "comment" </> int)
    ]

-- /topic/pottery        ==>  Just (Topic "pottery")
-- /topic/collage        ==>  Just (Topic "collage")
-- /topic/               ==>  Nothing

-- /blog/42              ==>  Just (Blog 42)
-- /blog/123             ==>  Just (Blog 123)
-- /blog/mosaic          ==>  Nothing

-- /user/tom/            ==>  Just (User "tom")
-- /user/sue/            ==>  Just (User "sue")
-- /user/bob/comment/42  ==>  Just (Comment "bob" 42)
-- /user/sam/comment/35  ==>  Just (Comment "sam" 35)
-- /user/sam/comment/    ==>  Nothing
-- /user/                ==>  Nothing
```

The `Url.Parser` module makes it quite concise to fully turn valid URLs into nice Elm data!


==== Example 2

Now say we have a personal blog where addresses like this are valid:

- `/blog/12/the-history-of-chairs`
- `/blog/13/the-endless-september`
- `/blog/14/whale-facts`
- `/blog/`
- `/blog?q=whales`
- `/blog?q=seiza`

In this case we have individual blog posts and a blog overview with an optional query parameter. We need to add the link:{api_Url-Parser-Query}[Url-Parser-Query] module to write our URL parser this time:

```elm
import Url.Parser exposing (Parser, (</>), (<?>), int, map, oneOf, s, string)
import Url.Parser.Query as Query

type Route
  = BlogPost Int String
  | BlogQuery (Maybe String)

routeParser : Parser (Route -> a) a
routeParser =
  oneOf
    [ map BlogPost  (s "blog" </> int </> string)
    , map BlogQuery (s "blog" <?> Query.string "q")
    ]

-- /blog/14/whale-facts  ==>  Just (BlogPost 14 "whale-facts")
-- /blog/14              ==>  Nothing
-- /blog/whale-facts     ==>  Nothing
-- /blog/                ==>  Just (BlogQuery Nothing)
-- /blog                 ==>  Just (BlogQuery Nothing)
-- /blog?q=chabudai      ==>  Just (BlogQuery (Just "chabudai"))
-- /blog/?q=whales       ==>  Just (BlogQuery (Just "whales"))
-- /blog/?query=whales   ==>  Just (BlogQuery Nothing)
```

The `</>` and `<?>` operators let us write parsers that look quite like the actual URLs we want to parse. And adding `Url.Parser.Query` allowed us to handle query parameters like `?q=seiza`.


==== Example 3

Okay, now we have a documentation website with addresses like this:

- `/Basics`
- `/Maybe`
- `/List`
- `/List#map`
- `/List#filter`
- `/List#foldl`

We can use the link:{api_Url-Parser-fragment}[Url-Parser fragment] parser from `Url.Parser` to handle these addresses like this:

```elm
type alias Docs =
  (String, Maybe String)

docsParser : Parser (Docs -> a) a
docsParser =
  map Tuple.pair (string </> fragment identity)

-- /Basics     ==>  Just ("Basics", Nothing)
-- /Maybe      ==>  Just ("Maybe", Nothing)
-- /List       ==>  Just ("List", Nothing)
-- /List#map   ==>  Just ("List", Just "map")
-- /List#      ==>  Just ("List", Just "")
-- /List/map   ==>  Nothing
-- /           ==>  Nothing
```

So now we can handle URL fragments as well!


==== Synthesis

Now that we have seen a few parsers, we should look at how this fits into a `Browser.application` program. Rather than just saving the current URL like last time, can we parse it into useful data and show that instead?

```elm
TODO
```

The major new things are:

1. Our `update` parses the URL when it gets a `UrlChanged` message.
2. Our `view` function shows different content for different addresses!

It is really not too fancy. Nice!

But what happens when you have 10 or 20 or 100 different pages? Does it all go in this one `view` function? Surely it cannot be all in one file. How many files should it be in? What should be the directory structure? That is what we will discuss next!


[[s9.3]]

=== 9.3 Modules

Elm has **modules** to help you grow your codebase in a nice way. On the most basic level, modules let you break your code into multiple files.


==== Defining Modules

Elm modules work best when you define them around a central type. Like how the `List` module is all about the `List` type. So say we want to build a module around a `Post` type for a blogging website. We can create something like this:

```elm
module Post exposing (Post, estimatedReadTime, encode, decoder)

import Json.Decode as D
import Json.Encode as E


-- POST

type alias Post =
  { title : String
  , author : String
  , content : String
  }


-- READ TIME

estimatedReadTime : Post -> Float
estimatedReadTime post =
  toFloat (wordCount post) / 220

wordCount : Post -> Int
wordCount post =
  List.length (String.words post.content)


-- JSON

encode : Post -> E.Value
encode post =
  E.object
    [ ("title", E.string post.title)
    , ("author", E.string post.author)
    , ("content", E.string post.content)
    ]

decoder : D.Decoder Post
decoder =
  D.map3 Post
    (D.field "title" D.string)
    (D.field "author" D.string)
    (D.field "content" D.string)
```

The only new syntax here is that `module Post exposing (..)` line at the very top. That means the module is known as `Post` and only certain values are available to outsiders. As written, the `wordCount` function is only available _within_ the `Post` module. Hiding functions like this is one of the most important techniques in Elm!

****
NOTE: If you forget to add a module declaration, Elm will use this one instead:

```elm
module Main exposing (..)
```

This makes things easier for beginners working in just one file. They should not be confronted with the module system on their first day!
****


==== Growing Modules

As your application gets more complex, you will end up adding things to your modules. It is normal for Elm modules to be in the 400 to 1000 line range, as I explain in link:https://youtu.be/XpDsk374LDE[The Life of a File]. But when you have multiple modules, how do you decide _where_ to add new code?

I try to use the following heuristics when code is:

- **Unique** — If logic only appears in one place, I break out top-level helper functions as close to the usage as possible. Maybe use a comment header like `-- POST PREVIEW` to indicate that the following definitions are related to previewing posts.
- **Similar** — Say we want to show `Post` previews on the home page and on the author pages. On the home page, we want to emphasize the interesting content, so we want longer snippets. But on the author page, we want to emphasize the breadth of content, so we want to focus on titles. These cases are _similar_, not the same, so we go back to the **unique** heuristic. Just write the logic separately.
- **The Same** — At some point we will have a bunch of **unique** code. That is fine! But perhaps we find that some definitions contain logic that is _exactly_ the same. Break out a helper function for that logic! If all the uses are in one module, no need to do anything more. Maybe put a comment header like `-- READ TIME` if you really want.

These heuristics are all about making helper functions within a single file. You only want to create a new module when a bunch of these helper functions all center around a specific custom type. For example, you start by creating a `Page.Author` module, and do not create a `Post` module until the helper functions start piling up. At that point, creating a new module should make your code feel easier to navigate and understand. If it does not, go back to the version that was clearer. More modules is not more better! Take the path that keeps the code simple and clear.

To summarize, assume **similar** code is **unique** by default. (It usually is in user interfaces in the end!) If you see logic that is **the same** in different definitions, make some helper functions with appropriate comment headers. When you have a bunch of helper functions about a specific type, _consider_ making a new module. If a new module makes your code clearer, great! If not, go back. More files is not inherently simpler or clearer.

****
NOTE: One of the most common ways to get tripped up with modules is when something that was once **the same** becomes **similar** later on. Very common, especially in user interfaces! Folks will often try to create a Frankenstein function that handles all the different cases. Adding more arguments. Adding more _complex_ arguments. The better path is to accept that you now have two **unique** situations and copy the code into both places. Customize it exactly how you need. Then see if any of the resulting logic is **the same**. If so, move it out into helpers. **Your long functions should split into multiple smaller functions, not grow longer and more complex!**
****

==== Using Modules

It is customary in Elm for all of your code to live in the `src/` directory. That is the default for link:https://github.com/elm/compiler/blob/0.19.0/docs/elm.json/application.md[elm.json] even. So our `Post` module would need to live in a file named `src/Post.elm`. From there, we can `import` a module and use its exposed values. There are four ways to do that:

```elm
import Post
-- Post.Post, Post.estimatedReadTime, Post.encode, Post.decoder

import Post as P
-- P.Post, P.estimatedReadTime, P.encode, P.decoder

import Post exposing (Post, estimatedReadTime)
-- Post, estimatedReadTime
-- Post.Post, Post.estimatedReadTime, Post.encode, Post.decoder

import Post as P exposing (Post, estimatedReadTime)
-- Post, estimatedReadTime
-- P.Post, P.estimatedReadTime, P.encode, P.decoder
```

I recommend using `exposing` pretty rarely. Ideally on zero or one of your imports. Otherwise, it can start getting hard to figure out where things came from when reading though. “Wait, where is `filterPostBy` from again? What arguments does it take?” It gets harder and harder to read through code as you add more `exposing`. I tend to use it for `import Html exposing (..)` but not on anything else. For everything else, I recommend using the standard `import` and maybe using `as` if you have a particularly long module name!

[[s9.4]]

=== 9.4 Structuring Web Apps

Like I was saying on the previous page, **all modules should be built around a central type.** So if I was making a web app for blog posts, I would start with modules like this:

- `Main`
- `Page.Home`
- `Page.Search`
- `Page.Author`

I would have a module for each page, centered around the `Model` type. Those modules follow The Elm Architecture with the typical `Model`, `init`, `update`, `view`, and whatever helper functions you need. From there, I would just keep growing those modules longer and longer. Keep adding the types and functions you need. If I ever notice that I created a custom type with a couple helper functions, I _might_ move that out into its own module.

Before we see some examples, I want to emphasize an important strategy.


==== Do Not Plan Ahead

Notice that my `Page` modules do not make any guesses about the future. I do not try to define modules that can be used in multiple places. I do not try to share any functions. This is on purpose!

Early in my projects, I always have these grand schemes of how everything will fit together. “The pages for editing and viewing posts both care about posts, so I will have a `Post` module!” But as I write my application, I find that only the viewing page should have a publication date. And I actually need to track editing differently to cache data when tabs are closed. And they actually need to be stored a bit differently on servers as a result. Etc. I end up turning `Post` into a big mess to handle all these competing concerns, and it ends up being worse for both pages.

By just starting with pages, it becomes much easier to see when things are **similar**, but not **the same**. The norm in user interfaces! So with editing and viewing posts, it seems plausible that we could end up with an `EditablePost` type and a `ViewablePost` type, each with different structure, helper functions, and JSON decoders. Maybe those types are complex enough to warrant their own module. Maybe not! I would just write the code and see what happens.

This works because the compiler makes it really easy to do huge refactors. If I realize I got something majorly wrong across 20 files, I just fix it.


==== Examples

You can see examples of this structure in the following open-source projects:

- link:https://github.com/rtfeldman/elm-spa-example[https://github.com/rtfeldman/elm-spa-example]
- link:https://github.com/elm/package.elm-lang.org[https://github.com/elm/package.elm-lang.org]


****
## *_Culture Shock_*

Folks coming from JavaScript tend to bring habits, expectations, and anxieties that are specific to JavaScript. They are legitimately important in that context, but they can cause some pretty severe troubles when transferred to Elm.


### *_Defensive Instincts_*

In link:https://youtu.be/XpDsk374LDE[The Life of a File] I point out some JavaScript Folk Knowledge that leads you astray in Elm:

- [.line-through]**“Prefer shorter files.”** In JavaScript, the longer your file is, the more likely you have some sneaky mutation that will cause a really difficult bug. But in Elm, that is not possible! Your file can be 2000 lines long and that still cannot happen.
- [.line-through]**“Get architecture right from the beginning.”** In JavaScript, refactoring is extremely risky. In many cases, it is cheaper just to rewrite it from scratch. But in Elm, refactoring is cheap and reliable! You can make changes in 20 different files with confidence.

These defensive instincts are protecting you from problems that do not exist in Elm. Knowing this in your mind is different than knowing it in your gut though, and I have observed that JS folks often feel deeply uncomfortable when they see files pass the 400 or 600 or 800 line mark. **So I encourage you to push your limit on number of lines!** See how far you can go. Try using comment headers, try making helper functions, but keep it all in one file. Having this experience yourself is extremely valuable!


### *_MVC_*

Some folks see The Elm Architecture and have the intuition to divide their code into separate modules for `Model`, `Update`, and `View`. Do not do this!

It leads to unclear and debatable boundaries. What happens when `Post.estimatedReadTime` is used in both the `update` and `view` functions? Totally reasonable, but it does not clearly _belong_ to one or the other. Maybe you need a `Utils` module? Maybe it actually is a controller kind of thing? The resulting code tends to be hard to navigate because placing each function is now an link:https://en.wikipedia.org/wiki/Ontology[Ontology] question, and all of your colleagues have different theories. What is an `estimatedReadTime` really? What is its essence? Estimation? What would Richard think is its essence? Time?

**If you build each module around a type, you rarely run into these kinds of questions.** You have a `Page.Home` module that contains your `Model`, `update`, and `view`. You write helper functions. You add a `Post` type eventually. You add an `estimatedReadTime` function. Maybe someday there are a bunch of helpers about that `Post` type, and maybe it is worth splitting into its own module. With this convention, you end up spending a lot less time considering and reconsidering module boundaries. I find that the code also comes out much clearer.


### *_Components_*

Folks coming from React expect everything to be components. **Actively trying to make components is a recipe for disaster in Elm.** The root issue is that components are objects:

- components = local state + methods
- local state + methods = objects

It would be odd to start using Elm and wonder "how do I structure my application with objects?" There are no objects in Elm! Folks in the community would recommend using custom types and functions instead.

Thinking in terms of components encourages you to create modules based on the visual design of your application. “There is a sidebar, so I need a `Sidebar` module.” It would be way easier to just make a `viewSidebar` function and pass it whatever arguments it needs. It probably does not even have any state. Maybe one or two fields? Just put it in the `Model` you already have. If it really is worth splitting out into its own module, you will know because you will have a custom type with a bunch of relevant helper functions!

Point is, writing a `viewSidebar` function **does not** mean you need to create a corresponding `update` and `Model` to go with it. Resist this instinct. **Just write the helper functions you need.**
****

****
NOTE: 本体论（Ontology） 是哲学的一个核心分支，主要研究“存在”（being）或“实存”（existence）的本质、范畴及其相互关系。它探讨的问题包括：

• 什么是真实存在的？（例如：物质、心灵、抽象概念是否独立存在？）
• 存在的基本范畴是什么？（例如：实体、属性、关系、事件等）
• 事物如何分类？（例如：自然对象与社会对象的区别）
• 存在是否具有依赖性？（例如：心灵是否依赖于物质？）

核心问题与概念

• 实体（Substance）：被看作独立存在的“基础”，如亚里士多德的“第一实体”（个体事物）。
• 属性（Properties）：依附于实体存在的特性（如颜色、形状）。
• 关系（Relations）：实体之间的关联（如因果关系、空间关系）。

• 一元论（如唯物主义：万物皆物质；唯心主义：万物皆精神）。
• 二元论（如笛卡尔的心物二元论）。
• 多元论（承认多种不可化约的存在范畴）。

• 探讨“可能存在什么”与“必然存在什么”（如莱布尼茨的“可能世界”理论）。

• 数学对象（如数字）、概念（如“正义”）、虚构实体（如“独角兽”）是否具有本体论地位？

哲学史上的关键理论

• 柏拉图：理念论（抽象“形式”是真实存在，具体事物是幻影）。
• 亚里士多德：实体论（个体事物是第一存在，属性依附于实体）。
• 康德：物自体（本体）不可知，人类只能认识现象。
• 海德格尔：存在论（追问“存在本身的意义”而非具体存在者）。
****

[[c10]]

== 10 Optimization

There are two major types of optimization in Elm. Optimizing performance and optimizing asset size:

- **Performance** — The slowest thing in browsers is the DOM. By a huge margin. I have done a lot of profiling to speed up Elm applications, and most things have no noticeable impact. Using better data structures? Negligible. Caching the results of computations in my model? Negligible _and_ my code is worse now. The only thing that makes a big difference is using `Html.Lazy` and `Html.Keyed` to do fewer DOM operations.

- **Asset Size** — Running in browsers means we have to care about download times. The smaller we can get our assets, the faster they load on mobile devices and slow internet connections. This is probably more important than any of the performance optimizations you will do! Fortunately, the Elm compiler does a really good job of making your code as small as possible, so you do not need to do a bunch of work making your code confusing to get decent outcomes here.

Both are important though, so this chapter will go through how this all works!


[[s10.1]]

=== 10.1 Html.Lazy

The link:{api_html}[elm/html] package is used to show things on screen. To understand how to optimize it, we need to learn how it works in the first place!


==== What is the DOM?

If you are creating an HTML file, you would write HTML directly like this:

```html
<div>
  <p>Chair alternatives include:</p>
  <ul>
    <li>seiza</li>
    <li>chabudai</li>
  </ul>
</div>
```

You can think of this as producing some DOM data structure behind the scenes:

[svgbob]
----

                DOM

              .-----.         .-----.
              |  li |         |  li |
              `-----'         `-----'
                 ^               ^
                 |               |
                 `-------+-------'
                         |
      .-----.         .--+--.
      |  p  |         |  ul |
      `-----'         `-----'
         ^               ^
         |               |
         `-------+-------'
                 |
              .--+--.
              | div |
              `-----'
----

// image:https://guide.elm-lang.org/optimization/diagrams/dom.svg[]

The black boxes represent heavy-weight DOM objects with hundreds of attributes. And when any of them change, it can trigger expensive renders and reflows of page content.


==== What is Virtual DOM?

If you are creating an Elm file, you would use `elm/html` to write something like this:

```elm
viewChairAlts : List String -> Html msg
viewChairAlts chairAlts =
  div []
    [ p [] [ text "Chair alternatives include:" ]
    , ul [] (List.map viewAlt chairAlts)
    ]

viewAlt : String -> Html msg
viewAlt chairAlt =
  li [] [ text chairAlt ]
```

You can think of `viewChairAlts ["seiza","chabudai"]` as producing some “Virtual DOM” data structure behind the scenes:


[svgbob]
----

            Virtual DOM         

                .--------.      .--------.
                |  li {b}|      |  li {b}|
                `--------'      `--------'
                    ^               ^
                    |               |
                    `-------+-------'
                            |
        .--------.     .--------.
        |  p {b} |     | ul {b} |
        `--------'     `--------'
            ^               ^
            |               |
            `-------+-------'
                    |
               .--------.
               | div {b}|
               `--------'
# Legend:
b = {stroke:lightgray;}
----

// image:https://guide.elm-lang.org/optimization/diagrams/vdom.svg[]

The white boxes represent light-weight JavaScript objects. They only have the attributes you specify. Their creation can never cause renders or reflows. Point is, compared to DOM nodes, these are much cheaper to allocate!


==== Render

If we are always working with these virtual nodes in Elm, how does it get converted to the DOM we see on screen? When an Elm program starts, it goes like this:

- Call `init` to get the initial `Model`.
- Call `view` to get the initial virtual nodes.

Now that we have virtual nodes, we make an exact replica in the real DOM:

.VirtualDOM render to DOM (https://guide.elm-lang.org/optimization/diagrams/render.svg[SVG 🕸])
[svgbob]
----

            Virtual DOM                                     DOM

        .--------.      .--------.                        .-----.         .-----.
        |  li {b}|      |  li {b}|                        |  li |         |  li |
        `--------'      `--------'                        `-----'         `-----'
            ^               ^                                ^               ^
            |               |                                |               |
            `-------+-------'                                `-------+-------'
                    |                                                |
.--------.     .--------.        .--------.       .-----.         .--+--.
|  p {b} |     | ul {b} |   -->  | render |  -->  |  p  |         |  ul |
`--------'     `--------'        `--------'       `-----'         `-----'
    ^               ^                                ^               ^
    |               |                                |               |
    `-------+-------'                                `-------+-------'
            |                                                |
       .--------.                                         .--+--.
       | div {b}|                                         | div |
       `--------'                                         `-----'

# Legend:
b = {stroke:lightgray;}
g = {stroke:green;}
----


Great! But what about when things change? Redoing the whole DOM on every frame does not work, so what do we do instead?


==== Diffing

Once we have the initial DOM, we switch to working primarily with virtual nodes instead. Whenever the `Model` changes, we run `view` again. From there, we “diff” the resulting virtual nodes to figure out how to touch the DOM as little as possible.

So imagine our `Model` gets a new chair alternative, and we want to add a new `li` node for it. Behind the scenes, Elm diffs the **current** virtual nodes and the **next** virtual nodes to detect any changes:

image:https://guide.elm-lang.org/optimization/diagrams/diff.svg[]

It noticed that a third `li` was added. I marked it in green. Elm now knows exactly how to modify the real DOM to make it match. Just insert that new `li`:

image:https://guide.elm-lang.org/optimization/diagrams/patch.svg[]

This diffing process makes it possible to touch the DOM as little as possible. And if no differences are found, we do not need to touch the DOM at all! So this process helps minimize the renders and reflows that need to happen.

But can we do even less work?


==== Html.Lazy

The link:{api_Html-Lazy}[Html-Lazy] module makes it possible to not even build the virtual nodes! The core idea is the `lazy` function:

[source]
lazy : (a -> Html msg) -> a -> Html msg

Going back to our chair example, we called `viewChairAlts ["seiza","chabudai"]`, but we could just as easily have called `lazy viewChairAlts ["seiza","chabudai"]` instead. The lazy version allocates a single “lazy” node like this:

image:https://guide.elm-lang.org/optimization/diagrams/lazy.svg[]

The node just keeps a reference to the function and arguments. Elm can put the function and arguments together to generate the whole structure if needed, but it is not always needed!

One of the cool things about Elm is the “same input, same output” guarantee for functions. So whenever we run into two “lazy” nodes while diffing virtual nodes, we ask is the function the same? Are the arguments the same? If they are all the same, we know the resulting virtual nodes are the same as well! **So we can skip building the virtual nodes entirely!** If any of them have changed, we can build the virtual nodes and do a normal diff.

****
NOTE: When are two values “the same” though? To optimize for performance, we use JavaScript’s `===` operator behind the scenes:

- Structural equality is used for `Int`, `Float`, `String`, `Char`, and `Bool`.
- Reference equality is used for records, lists, custom types, dictionaries, etc.

Structural equality means that `4` is the same as `4` no matter how you produced those values. Reference equality means the actual pointer in memory has to be the same. Using reference equality is always cheap `O(1)`, even when the data structure has thousands or millions of entries. So this is mostly about making sure that using `lazy` will never slow your code down a bunch by accident. All the checks are super cheap!
****


==== Usage

The ideal place to put a lazy node is at the root of your application. Many applications are set up to have distinct visual regions like headers, sidebars, search results, etc. And when people are messing with one, they are very rarely messing with the others. This creates really natural lines for `lazy` calls!

For example, in my link:https://github.com/evancz/elm-todomvc/[TodoMVC implementation], the `view` is defined like this:

```elm
view : Model -> Html Msg
view model =
  div
    [ class "todomvc-wrapper"
    , style "visibility" "hidden"
    ]
    [ section
        [ class "todoapp" ]
        [ lazy viewInput model.field
        , lazy2 viewEntries model.visibility model.entries
        , lazy2 viewControls model.visibility model.entries
        ]
    , infoFooter
    ]
```

Notice that the text input, entries, and controls are all in separate lazy nodes. So I can type however many characters I want in the input without ever building virtual nodes for the entries or controls. They are not changing! So the first tip is **try to use lazy nodes at the root of your application.**

It can also be useful to use lazy in long lists of items. In the TodoMVC app, it is all about adding entries to your todo list. You could conceivably have hundreds of entries, but they change very infrequently. This is a great candidate for laziness! By switching `viewEntry entry` to `lazy viewEntry entry` we can skip a bunch of allocation that is very rarely useful. So the second tip is **try to use lazy nodes on repeated structures where each individual item changes infrequently.**


==== Summary

Touching the DOM is way more expensive than anything that happens in a normal user interface. Based on my benchmarking, you can do whatever you want with fancy data structures, but in the end it only matters how much you successfully use `lazy`.

On the next page, we will learn a technique to use `lazy` even more!


[[s10.2]]

=== 10.2 Html.Keyed

On the previous page, we learned how Virtual DOM works and how we can use `Html.Lazy` to avoid a bunch of work. Now we are going to introduce  link:{api_Html-Keyed}[Html-Keyed] to skip even more work.

This optimization is particularly helpful for lists of data in your interface that must support **insertion**, **removal**, and **reordering**.


==== The Problem

Say we have a list of all the Presidents of the United States. And maybe it lets us sort by name, link:https://en.wikipedia.org/wiki/List_of_Presidents_of_the_United_States_by_education[by education], link:https://en.wikipedia.org/wiki/List_of_Presidents_of_the_United_States_by_net_worth[by net worth], and link:https://en.wikipedia.org/wiki/List_of_Presidents_of_the_United_States_by_home_state[by birthplace].

When the diffing algorithm (described on the previous page) gets to a long list of items, it just goes through pairwise:

- Diff the current 1st element with the next 1st element.
- Diff the current 2nd element with the next 2nd element.
- ...

But when you change the sort order, all of these are going to be different! So you end up doing a lot of work on the DOM when you could have just shuffled some nodes around.

This issue exists with insertion and removal as well. Say you remove the 1st of 100 items. Everything is going to be off-by-one and look different. So you get 99 diffs and one removal at the end. No good!


==== The Solution

The fix for all of this is link:{api_Html-Keyed-node}[Html-Keyed node], which makes it possible to pair each entry with a “key” that easily distinguishes it from all the others.

So in our presidents example, we could write our code like this:

```elm
import Html exposing (..)
import Html.Keyed as Keyed
import Html.Lazy exposing (lazy)

viewPresidents : List President -> Html msg
viewPresidents presidents =
  Keyed.node "ul" [] (List.map viewKeyedPresident presidents)

viewKeyedPresident : President -> (String, Html msg)
viewKeyedPresident president =
  ( president.name, lazy viewPresident president )

viewPresident : President -> Html msg
viewPresident president =
  li [] [ ... ]
```

Each child node is associated with a key. So instead of doing a pairwise diff, we can diff based on matching keys!

Now the Virtual DOM implementation can recognize when the list is resorted. It first matches all the presidents up by key. Then it diffs those. We used `lazy` for each entry, so we can skip all that work. Nice! It then figures out how to shuffle the DOM nodes to show things in the order you want. So the keyed version does a lot less work in the end.

Resorting helps show how it works, but it is not the most common case that really needs this optimization. **Keyed nodes are extremely important for insertion and removal.** When you remove the 1st of 100 elements, using keyed nodes allows the Virtual DOM implementation to recognize that immediately. So you get a single removal instead of 99 diffs.


==== Summary

Touching the DOM is extraordinarily slow compared to the sort of computations that happen in a normal application. **Always reach for `Html.Lazy` and `Html.Keyed` first.** I recommend verifying this with profiling as much as possible. Some browsers provide a timeline view of your program, link:https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference[like this]. It gives you a summary of how much time is spent in loading, scripting, rendering, painting, etc. If you see that 10% of the time is spent scripting, you could make your Elm code twice as fast and not make any noticeable difference. Whereas simple additions of lazy and keyed nodes could start taking big chunks out of that other 90% by touching the DOM less!


[[s10.3]]

=== 10.3 Minification

==== Asset Size

The only thing that is slower than touching the DOM is talking to servers. Especially for folks on mobile phones with slow internet. So you can optimize your code all day with `Html.Lazy` and `Html.Keyed`, but your application will still feel slow if it loads slowly!

A great way to improve is to send fewer bits. For example, if a 122kb asset can become a 9kb asset, it will load faster! We get results like that by using the following techniques:

- **Compilation.** The Elm compiler can perform optimizations like dead code elimination and record field renaming. So it can cut unused code and shorten record field names like `userStatus` in the generated code.
- **Minification.** In the JavaScript world, there are tools called “minifiers” that do a bunch of transformations. They shorten variables. They inline. They convert `if` statements to ternary operators. They turn `'\u0041'` to `'A'`. Anything to save a few bits!
- **Compression.** Once you have gotten the code as small as possible, you can use a compression algorithm like gzip to shrink it even further. It does particularly well with keywords like `function` and `return` that you just cannot get rid of in the code itself.

Elm makes it pretty easy to get all this set up for your project. No need for some complex build system. It is just two terminal commands!


==== Instructions

Step one is to compile with the `--optimize` flag. This does things like shortening record field names.

Step two is to minify the resulting JavaScript code. I use a minifier called `uglifyjs`, but you can use a different one if you want. The neat thing about `uglifyjs` is all its special flags. These flags unlock optimizations that are unreliable in normal JS code, but thanks to the design of Elm, they are totally safe for us!

Putting those together, we can optimize `src/Main.elm` with two terminal commands:

```bash
elm make src/Main.elm --optimize --output=elm.js
uglifyjs elm.js --compress 'pure_funcs=[F2,F3,F4,F5,F6,F7,F8,F9,A2,A3,A4,A5,A6,A7,A8,A9],pure_getters,keep_fargs=false,unsafe_comps,unsafe' | uglifyjs --mangle --output elm.min.js
```

After this you will have an `elm.js` and a smaller `elm.min.js` file!

****
NOTE: Note 1: `uglifyjs` is called twice there. First to `--compress` and second to `--mangle`. This is necessary! Otherwise `uglifyjs` will ignore our `pure_funcs` flag.

NOTE: Note 2: If the `uglifyjs` command is not available in your terminal, you can run the command `npm install uglify-js --global` to download it. If you do not have `npm` either, you can get it with link:https://nodejs.org/[nodejs].
****


==== Scripts

It is hard to remember all those flags for `uglifyjs`, so it is probably better to write a script that does this.

Say we want a bash script that produces `elm.js` and `elm.min.js` files. On Mac or Linux, we can define `optimize.sh` like this:

```bash
#!/bin/sh

set -e

js="elm.js"
min="elm.min.js"

elm make --optimize --output=$js "$@"

uglifyjs $js --compress 'pure_funcs=[F2,F3,F4,F5,F6,F7,F8,F9,A2,A3,A4,A5,A6,A7,A8,A9],pure_getters,keep_fargs=false,unsafe_comps,unsafe' | uglifyjs --mangle --output $min

echo "Compiled size:$(wc $js -c) bytes  ($js)"
echo "Minified size:$(wc $min -c) bytes  ($min)"
echo "Gzipped size: $(gzip $min -c | wc -c) bytes"
```

Now if I run `./optimize.sh src/Main.elm` on my link:https://github.com/evancz/elm-todomvc[https://github.com/evancz/elm-todomvc] code, I see something like this in the terminal:

```
Compiled size:  122297 bytes  (elm.js)
Minified size:   24123 bytes  (elm.min.js)
Gzipped size:     9148 bytes
```

Pretty neat! We only need to send about 9kb to get this program to people!

The important commands here are `elm` and `uglifyjs` which work on any platform, so it should not be too tough to do something similar on Windows.


==== Advice

I recommend writing a `Browser.application` and compiling to a single JavaScript file as we have seen here. It will get downloaded (and cached) when people first visit. Elm creates quite small files compared to the popular competitors, as you can see link:https://elm-lang.org/blog/small-assets-without-the-headache[here], so this strategy can take you quite far.

****
NOTE: In theory, it is possible to get even smaller assets with Elm. It is not possible right now, but if you are working on 50k lines of Elm or more, we would like to learn about your situation as part of a user study. More details link:https://gist.github.com/evancz/fc6ff4995395a1643155593a182e2de7[here]!
****

[[c11]]

== 11 Next Steps

We have a bunch of foundational knowledge now. The next steps are all about gaining experience and building relationships.


=== Build Something

Experience is a great teacher, so I recommend building an **application** that interests you. If you do not have something in mind, maybe something like this:

- **Expand Examples** — Take some of the examples from this book and add to them. The code is link:https://github.com/evancz/elm-architecture-tutorial/[here]! Mess with link:https://github.com/rtfeldman/elm-spa-example[elm-spa-example].
- **Something from Work** — Maybe there is something you do at work, and you want to see how it might work in Elm. Try it out on your own and see how it goes! This will set you up well for the advice in link:https://elm-lang.org/blog/how-to-use-elm-at-work[How to Use Elm at Work].
- **Data Visualization** — Use a package like link:https://terezka.github.io/line-charts/[terezka/line-charts] to display data that interests you. I would start with some fake data, but maybe work up to trying to showing data from somewhere else. There is a ton of link:https://data.bls.gov/timeseries/LNS11300000[economic] and link:https://wonder.cdc.gov/[health] data available that would benefit from better presentation!
- **Games** — I got into programming by making games like pong, breakout, and space invaders. Maybe you will like that sort of thing too! Start by drawing stuff with link:{api_svg}[svg]. From there, try responding to events like link:{api_Browser-Events-onKeyDown}[Browser-Events onKeyDown], link:{api_Browser-Events-onMouseMove}[Browser-Events onMouseMove], and link:{api_Browser-Events-onAnimationFrame}[Browser-Events onAnimationFrame]. At some point, you can even get into 3D graphics with link:{api_webgl}[webgl]!

****
NOTE: CDC WONDER（Wide-ranging Online Data for Epidemiologic Research）是美国疾病控制与预防中心（Centers for Disease Control and Prevention, CDC）提供的免费在线公共卫生数据库系统，旨在为研究人员、医疗从业者、政策制定者及公众提供便捷的流行病学数据和统计分析工具。

WONDER online databases utilize a rich ad-hoc query system for the analysis of public health data. Reports and other query systems are also available.

通过 CDC WONDER，用户可以高效获取关键公共卫生信息，助力科学研究与公共健康行动。如需深入分析，建议结合其他工具（如R、Python）进行重点数据集数据价值挖掘。

• 死亡率数据（Multiple Cause of Death Database, Fetal Deaths, Infant Deaths）
• 慢性病患病率（如糖尿病、心血管疾病）
• 传染病报告（如流感、HIV/AIDS, Sexually Transmitted Disease Morbidity Data）
• 环境暴露与健康影响（如空气污染、有毒物质）
• 行为风险监测（BRFSS：吸烟、饮酒、肥胖等）
****

=== Ask Questions

There are loads of friendly and knowledgeable folks on link:https://elmlang.herokuapp.com/[https://elmlang.herokuapp.com/] and link:https://discourse.elm-lang.org/[https://discourse.elm-lang.org/]. Whether you just started programming or have 20 years experience in industry, the #beginners channel on Slack is great for people new to programming in Elm! Maybe you have an error message you are stuck on? Maybe you are struggling to understand JSON decoders? Maybe the `Task` type is tripping you up? Maybe you are curious to get some feedback on a custom type you defined? **Whatever the problem, you can always ask for help!**


=== Meet People

There are meetups link:https://www.meetup.com/topics/elm-programming/all/[all over the world]. We encourage organizers to run link:https://blog.noredink.com/post/142283641812/designing-meetups-to-build-better-communities[code nights] where folks can build projects and relationships. The obvious benefit is that you can get help with whatever you are working on, but you also meet everyone else who is using Elm in town. Maybe someone is working on something cool that inspires you. Maybe you learn a technique you did not know you did not know. Maybe someone has a job opening. Maybe knowing a bunch of local Elm programmers will help your case at work. Maybe it is just a fun time. Programmers tend to undervalue the benefits of these personal relationships, but it is one of the most important parts of a healthy programming language community!


[[c12]]

== 12 Appendix


[[s12.1]][[types_as_sets]]

=== 12.1 Types as Sets

We have seen primitive types like `Bool` and `String`. We have made our own custom types like this:

```elm
type Color = Red | Yellow | Green
```

One of the most important techniques in Elm programming is to make **the possible values in code** exactly match **the valid values in real life**. This leaves no room for invalid data, and this is why I always encourage folks to focus on custom types and data structures.

In pursuit of this goal, I have found it helpful to understand the relationship between types and sets. It sounds like a stretch, but it really helps develop your mindset!


==== Sets

You can think of types as a set of values.

- `Bool` is the set `{ True, False }`
- `Color` is the set `{ Red, Yellow, Green }`
- `Int` is the set `{ ... -2, -1, 0, 1, 2 ... }`
- `Float` is the set `{ ... 0.9, 0.99, 0.999 ... 1.0 ... }`
- `String` is the set `{ "", "a", "aa", "aaa" ... "hello" ... }`

So when you say `x : Bool` it is like saying `x` is in the `{ True, False }` set.


==== Cardinality

Some interesting things happen when you start figuring out how many values are in these sets. For example the `Bool` set `{ True, False }` contains two values. So math people would say that `Bool` has a link:https://en.wikipedia.org/wiki/Cardinality[Cardinality] of two. So conceptually:

- cardinality(`Bool`) = 2
- cardinality(`Color`) = 3
- cardinality(`Int`) = ∞
- cardinality(`Float`) = ∞
- cardinality(`String`) = ∞

This gets more interesting when we start thinking about types like `(Bool, Bool)` that combine sets together.

NOTE: The cardinality for `Int` and `Float` are actually smaller than infinity. Computers need to fit the numbers into a fixed amount of bits (as described <<types_as_bits, here>>) so it is more like cardinality(`Int32`) = 2^32 and cardinality(`Float32`) = 2^32. The point is just that it is a lot.


==== Multiplication (Tuples and Records)

When you combine types with tuples, the cardinalities get multiplied:

- cardinality(`(Bool, Bool)`) = cardinality(`Bool`) × cardinality(`Bool`) = 2 × 2 = 4
- cardinality(`(Bool, Color)`) = cardinality(`Bool`) × cardinality(`Color`) = 2 × 3 = 6

To make sure you believe this, try listing all the possible values of `(Bool, Bool)` and `(Bool, Color)`. Do they match the numbers we predicted? How about for `(Color, Color)`?

But what happens when we use infinite sets like `Int` and `String`?

- cardinality(`(Bool, String)`) = 2 × ∞
- cardinality(`(Int, Int)`) = ∞ × ∞

I personally really like the idea of having two infinities. One wasn’t enough? And then seeing infinite infinities. Aren’t we going to run out at some point?

NOTE: So far we have used tuples, but records work exactly the same way:
>
> - cardinality(`(Bool, Bool)`) = cardinality(`{ x : Bool, y : Bool }`)
> - cardinality(`(Bool, Color)`) = cardinality(`{ active : Bool, color : Color }`)
>
> And if you define `type Point = Point Float Float` then cardinality(`Point`) is equivalent to cardinality(`(Float, Float)`). It is all multiplication!


==== Addition (Custom Types)

When figuring out the cardinality of a custom type, you add together the cardinality of each variant. Let’s start by looking at some `Maybe` and `Result` types:

- cardinality(`Result Bool Color`) = cardinality(`Bool`) + cardinality(`Color`) = 2 + 3 = 5
- cardinality(`Maybe Bool`) = 1 + cardinality(`Bool`) = 1 + 2 = 3
- cardinality(`Maybe Int`) = 1 + cardinality(`Int`) = 1 + ∞

To persuade yourself that this is true, try listing out all the possible values in the `Maybe Bool` and `Result Bool Color` sets. Does it match the numbers we got?

Here are some other examples:

```elm
type Height
  = Inches Int
  | Meters Float

-- cardinality(Height)
-- = cardinality(Int) + cardinality(Float)
-- = ∞ + ∞


type Location
  = Nowhere
  | Somewhere Float Float

-- cardinality(Location)
-- = 1 + cardinality((Float, Float))
-- = 1 + cardinality(Float) × cardinality(Float)
-- = 1 + ∞ × ∞
```

Looking at custom types this way helps us see when two types are equivalent. For example, `Location` is equivalent to `Maybe (Float, Float)`. Once you know that, which one should you use? I prefer `Location` for two reasons:

1. The code becomes more self-documenting. No need to wonder if `Just (1.6, 1.8)` is a location or a pair of heights.
2. The `Maybe` module may expose functions that do not make sense for my particular data. For example, combining two locations probably should not work like `Maybe.map2`. Should one `Nowhere` mean that everything is `Nowhere`? Seems weird!

In other words, I write a couple lines of code that are _similar_ to other code, but it gives me a level of clarity and control that is extremely valuable for large code bases and teams.


==== Who Cares?

Thinking of “types as sets” helps explain an important class of bugs: **invalid data**. For example, say we want to represent the color of a traffic light. The set of valid values are { red, yellow, green } but how do we represent that in code? Here are three different approaches:

- `type alias Color = String` — We could decide that `"red"`, `"yellow"`, `"green"` are the three strings we will use, and that all the other ones are _invalid data_. But what happens if invalid data is produced? Maybe someone makes a typo like `"rad"`. Maybe someone types `"RED"` instead. Should all functions have checks for incoming color arguments? Should all functions have tests to make sure color results are valid? The root issue is that cardinality(`Color`) = ∞, meaning there are (∞ - 3) invalid values. We will need to do a lot of checking to make sure none of them ever show up!

- `type alias Color = { red : Bool, yellow : Bool, green : Bool }` — The idea here is that the idea of “red” is represented by `Color True False False`. But what about `Color True True True`? What does it mean for it to be all the colors at once? This is _invalid data_. Just like with the `String` representation, we end up writing checks in our code and tests to make sure there are no mistakes. In this case, cardinality(`Color`) = 2 × 2 × 2 = 8, so there are only 5 invalid values. There are definitely fewer ways to mess up, but we should still have some checks and tests.

- `type Color = Red | Yellow | Green` — In this case, invalid data is impossible. cardinality(`Color`) = 1 + 1 + 1 = 3, exactly corresponding to the set of three values in real life. So there is no point checking for invalid color data in our code or tests. It cannot exist!

So the whole point here is that **ruling out invalid data makes your code shorter, simpler, and more reliable.** By making sure the set of _possible_ values in code exactly matches the set of _valid_ values in real life, many problems just go away. This is a sharp knife!

As your program changes, the set of possible values in code may start to diverge from the set of valid values in real life. **I highly recommend revisiting your types periodically to make them match again.** This is like noticing your knife has become dull and sharpening it with a whetstone. This kind of maintenance is a core part of programming in Elm.

**When you start thinking this way, you end up needing fewer tests, yet having more reliable code.** You start using fewer dependencies, yet accomplishing things more quickly. Similarly, someone skilled with a knife probably will not buy a link:https://www.slapchop.com/[https://www.slapchop.com/]. There is definitely a place for blenders and food processors, but it is smaller than you might think. No one runs ads about how you can be independent and self-sufficient without any serious downsides. No money in that!


> ## Aside on Language Design
>
> Thinking of types as sets like this can also be helpful in explaining why a language would feel “easy” or “restrictive” or “error-prone” to some people. For example:
>
> - **Java** — There are primitive values like `Bool` and `String`. From there, you can create classes with a fixed set of fields of different types. This is much like records in Elm, allowing you to multiply cardinalities. But it is quite difficult to do addition. You can do it with subtyping, but it is quite an elaborate process. So where `Result Bool Color` is easy in Elm, it is pretty tough in Java. I think some people find Java “restrictive” because designing a type with cardinality 5 is quite difficult, often seeming like it is not worth the trouble.
>
> - **JavaScript** — Again, there are primitive values like `Bool` and `String`. From there you can create objects with a dynamic set of fields, allowing you to multiply cardinalities. This is much more lightweight than creating classes. But like Java, doing addition is not particularly easy. For example, you can simulate `Maybe Int` with objects like `{ tag: "just", value: 42 }` and `{ tag: "nothing" }`, but this is really still multiplication of cardinality. This makes it quite difficult to exactly match the set of valid values in real life. So I think people find JavaScript “easy” because designing a type with cardinality (∞ × ∞ × ∞) is super easy and that can cover pretty much anything, but other people find it “error-prone” because designing a type with cardinality 5 is not really possible, leaving lots of space for invalid data.
>
> Interestingly, some imperative languages have custom types! Rust is a great example. They call them link:https://doc.rust-lang.org/book/second-edition/ch06-01-defining-an-enum.html[https://doc.rust-lang.org/book/second-edition/ch06-01-defining-an-enum.html] to build on the intuition folks may have from C and Java. So in Rust, addition of cardinalities is just as easy as in Elm, and it brings all the same benefits!
>
> I think the point here is that “addition” of types is extraordinarily underrated in general, and thinking of “types as sets” helps clarify why certain language designs would produce certain frustrations.



[[s12.2]][[types_as_bits]]

=== 12.2 Types as Bits

There are all sorts of types in Elm:

- `Bool`
- `Int`
- `String`
- `(Int, Int)`
- `Maybe Int`
- ...

We have a conceptual understanding of them by now, but how are they understood by a computer? How is `Maybe Int` stored on a hard disk?


==== Bits

A **bit** is little box that has two states. Zero or a one. On or off. Computer memory is one super long sequence of bits.

Okay, so all we have is a bunch of bits. Now we need to represent _everything_ with that!


==== Bool

A `Bool` value can be either `True` or `False`. This corresponds exactly to a bit!


==== Int

An `Int` value is some whole number like `0`, `1`, `2`, etc. You cannot fit that in a single bit, so the only other option is to use multiple bits. So normally, an `Int` would be a sequence of bits, like these:

```
00000000
00000001
00000010
00000011
...
```

We can arbitrarily assign meaning to each of these sequences. So maybe `00000000` is zero and `00000001` is one. Great! We can just start assigning numbers to bit sequences in ascending order. But eventually we will run out of bits...

By some quick math, eight bits only allow (2^8 = 256) numbers. What about perfectly reasonable numbers like 9000 and 8004?

The answer is to just add more bits. For a long time, people used 32 bits. That allowed for (2^32 = 4,294,967,296) numbers which covers the kinds of numbers humans typically think about. Computers these days support 64-bit integers, allowing for (2^64 = 18,446,744,073,709,551,616) numbers. That is a lot!

NOTE: If you are curious how addition works, learn about link:https://en.wikipedia.org/wiki/Two%27s_complement[Two's complement]. It reveals that numbers are not assigned to bit sequences arbitrarily. For the sake of making addition as fast as possible, this particular way of assigning numbers works really well.


==== String

The string `"abc"` is the sequence of characters `a` `b` `c`, so we will start by trying to represent characters as bits.

One of the early ways of encoding characters is called link:https://en.wikipedia.org/wiki/ASCII[ASCII]. Just like with integers, they decided to list out a bunch of bit sequences and start assigning values arbitrarily:

```
00000000
00000001
00000010
00000011
...
```

So every character needed to fit in eight bits, meaning only 256 characters could be represented! But if you only care about English, this actually works out pretty well. You need to cover 26 lower-case letters, 26 upper-case letters, and 10 numbers. That is 62. There is a bunch of room left for symbols and other weird stuff. You can see what they ended up with link:https://ascii.cl/[https://ascii.cl/].

We have an idea for characters now, but how will the computer know where the `String` ends and the next piece of data begins? It is all just bits. Characters look just like `Int` values really! So we need some way to mark the end.

These days, languages tend to do this by storing the **length** of the string. So a string like `"hello"` might look something like `5` `h` `e` `l` `l` `o` in memory. So you know a `String` always starts with 32-bits representing the length. And whether the length is 0 or 9000, you know exactly where the characters end.

NOTE: At some point, folks wanted to cover languages besides English. This effort eventually resulted in the link:https://en.wikipedia.org/wiki/UTF-8[UTF-8] encoding. It is quite brilliant really, and I encourage you to learn about it. It turns out that “get the 5th character” is harder than it sounds!


==== (Int, Int)

What about tuples? Well, `(Int, Int)` is two `Int` values, and each one is a sequence of bits. Let’s just put those two sequences next to each other in memory and call it a day!


==== Custom Types

A custom type is all about combining different types. Those different types may have all sorts of different shapes. We will start with the `Color` type:

```elm
type Color = Red | Yellow | Green
```

We can assign each case a number: `Red = 0`, `Yellow = 1`, and `Green = 2`. Now we can use the `Int` representation. Here we only need two bits to cover all the possible cases, so `00` is red, `01` is yellow, `10` is green, and `11` is unused.

But what about custom types that hold additional data? Like `Maybe Int`? The typical approach is to set aside some bits to “tag” the data, so we can decide that `Nothing = 0` and `Just = 1`. Here are some examples:

- `Nothing` = `0`
- `Just 12` = `1` `00001100`
- `Just 16` = `1` `00010000`

A `case` expression always looks at that “tag” before deciding what to do next. If it sees a `0` it knows there is no more data. If it sees a `1` it knows it is followed by a sequence of bits representing the data.

This “tag” idea is similar to putting the length at the beginning of `String` values. The values may be different sizes, but the code can always figure out where they start and end.


==== Summary

Eventually, all values need to be represented in bits. This page gives a rough overview of how that actually works.

Normally there is no real reason to think about this, but I found it to be helpful in deepening my understanding of custom types and `case` expressions. I hope it is helpful to you as well!

NOTE: If you think this is interesting, it may be fun to learn more about garbage collection. I have found link:http://gchandbook.org/[http://gchandbook.org/] to be an excellent resource on the topic!

[[s12.3]]

=== 12.3 Function Types

As you look through packages like link:{api_core}[`elm/core`] and link:{api_html}[`elm/html`], you will definitely see functions with multiple arrows. For example:

```elm
String.repeat : Int -> String -> String
String.join : String -> List String -> String
```

Why so many arrows? What is going on here?!



==== Hidden Parentheses

It starts to become clearer when you see all the parentheses. For example, it is also valid to write the type of `String.repeat` like this:

```elm
String.repeat : Int -> (String -> String)
```

It is a function that takes an `Int` and then produces _another_ function. Let's see this in action:

[source]
----
{% replWithTypes %}
[
	{
		"input": "String.repeat",
		"value": "\u001b[36m<function>\u001b[0m",
		"type_": "Int -> String -> String"
	},
	{
		"input": "String.repeat 4",
		"value": "\u001b[36m<function>\u001b[0m",
		"type_": "String -> String"
	},
	{
		"input": "String.repeat 4 \"ha\"",
		"value": "\u001b[93m\"hahahaha\"\u001b[0m",
		"type_": "String"
	},
	{
		"input": "String.join",
		"value": "\u001b[36m<function>\u001b[0m",
		"type_": "String -> List String -> String"
	},
	{
		"input": "String.join \"|\"",
		"value": "\u001b[36m<function>\u001b[0m",
		"type_": "List String -> String"
	},
	{
		"input": "String.join \"|\" [\"red\",\"yellow\",\"green\"]",
		"value": "\u001b[93m\"red|yellow|green\"\u001b[0m",
		"type_": "String"
	}
]
{% endreplWithTypes %}
----

So conceptually, **every function accepts one argument.** It may return another function that accepts one argument. Etc. At some point it will stop returning functions.

We _could_ always put the parentheses to indicate that this is what is really happening, but it starts to get pretty unwieldy when you have multiple arguments. It is the same logic behind writing `4 * 2 + 5 * 3` instead of `(4 * 2) + (5 * 3)`. It means there is a bit extra to learn, but it is so common that it is worth it.

Fine, but what is the point of this feature in the first place? Why not do `(Int, String) -> String` and give all the arguments at once?


==== Partial Application

It is quite common to use the `List.map` function in Elm programs:

```elm
List.map : (a -> b) -> List a -> List b
```

It takes two arguments: a function and a list. From there it transforms every element in the list with that function. Here are some examples:

- `List.map String.reverse ["part","are"] == ["trap","era"]`
- `List.map String.length ["part","are"] == [4,3]`

Now remember how `String.repeat 4` had type `String -> String` on its own? Well, that means we can say:

- `List.map (String.repeat 2) ["ha","choo"] == ["haha","choochoo"]`

The expression `(String.repeat 2)` is a `String -> String` function, so we can use it directly. No need to say `(\str -> String.repeat 2 str)`.

Elm also uses the convention that **the data structure is always the last argument** across the ecosystem. This means that functions are usually designed with this possible usage in mind, making this a pretty common technique.

Now it is important to remember that **this can be overused!** It is convenient and clear sometimes, but I find it is best used in moderation. So I always recommend breaking out top-level helper functions when things get even a _little_ complicated. That way it has a clear name, the arguments are named, and it is easy to test this new helper function. In our example, that means creating:

```elm
-- List.map reduplicate ["ha","choo"]

reduplicate : String -> String
reduplicate string =
  String.repeat 2 string
```

This case is really simple, but (1) it is now clearer that I am interested in the linguistic phenomenon known as link:https://en.wikipedia.org/wiki/Reduplication[Reduplication] and (2) it will be quite easy to add new logic to `reduplicate` as my program evolves. Maybe I want link:https://en.wikipedia.org/wiki/Shm-reduplication[Shm-reduplication] support at some point?

In other words, **if your partial application is getting long, make it a helper function.** And if it is multi-line, it should _definitely_ be turned into a top-level helper! This advice applies to using anonymous functions too.

****
NOTE: If you are ending up with “too many” functions when you use this advice, I recommend using comments like `-- REDUPLICATION` to give an overview of the next five or ten functions. Old school! I have shown this with `-- UPDATE` and `-- VIEW` comments in previous examples, but it is a generic technique that I use in all my code. And if you are worried about files getting too long with this advice, I recommend watching link:https://youtu.be/XpDsk374LDE[The Life of a File]!
****


==== Pipelines

****
NOTE: 管道（|）真的是一个优秀的运算符号，自从 Unix 发源依赖，一直用于各种编程工具，包括Elm 和 Ｂash、JQ Lang 等等。Elm 作为一个现代的编程语言，它不仅有正向管道 `|>`，还给管道引入反向传播 `<|`。分别用于函数的 Forward 和 Backward 应用。Elm 中，调用函数（call）和应用函数（apply）是等价概念。

[source,elm]
----
f1 =
    divide 30 10
        |> multiply 10
        |> add 5
        |> String.fromFloat
        |> Html.text

f2 =
    Html.text <| String.fromFloat <| add 5 <| multiply 10 <| divide 30 10
----
****

Elm also has a link:{api_pipe}[pipe operator] that relies on partial application. For example, say we have a `sanitize` function for turning user input into integers:

```elm
-- BEFORE
sanitize : String -> Maybe Int
sanitize input =
  String.toInt (String.trim input)
```

We can rewrite it like this:

```elm
-- AFTER
sanitize : String -> Maybe Int
sanitize input =
  input
    |> String.trim
    |> String.toInt
```

So in this “pipeline” we pass the input to `String.trim` and then that gets passed along to `String.toInt`.

This is neat because it allows a “left-to-right” reading that many people like, but **pipelines can be overused!** When you have three or four steps, the code often gets clearer if you break out a top-level helper function. Now the transformation has a name. The arguments are named. It has a type annotation. It is much more self-documenting that way, and your teammates and your future self will appreciate it! Testing the logic gets easier too.

NOTE: I personally prefer the `BEFORE`, but perhaps that is just because I learned functional programming in languages without pipes!


==  ELM Community JavaScript Ports Examples

https://vscode.dev/github/elm-community/js-integration-examples

=== Using JS within Elm

Elm can interact with JavaScript in three ways:

- https://guide.elm-lang.org/interop/flags.html[flags]
- https://guide.elm-lang.org/interop/ports.html[ports]
- https://guide.elm-lang.org/interop/custom_elements.html[custom elements]

Not all browser APIs are covered by an official package yet, so if you are evaluating using Elm in your company, definitely browse through the examples here to get familiar with flags, ports, and custom elements to make sure these interop mechanisms will fully meet your needs. It may be safest to circle back to Elm later if not!


=== Ports

- localStorage — https://ellie-app.com/8yYddD6HRYJa1[demo]
- WebSockets — https://ellie-app.com/8yYgw7y7sM2a1[demo]


=== Custom Elements

- Internationalization — https://ellie-app.com/8yYbRQ3Hzrta1[demo]
- https://ellie-app.com/8B2B8fWbvZwa1[Pie Chart Widget]
- https://ellie-app.com/8B8D2Q3WLh7a1[Calendar Widget]
- https://github.com/wolfadex/fluent-web/[Project Fluent]


=== Do you want to know more?

The top-level examples presented here are intentionally boiled down to a minimal setup for you to understand the basic ideas and get started quickly. As the web platform is a place with a lot of history and odd API corners there are more involved examples and tutorials to be explored in the [more](/more) section.

* [Everything you need to know to use WebComponents in your Elm app](/more/webcomponents)


=== LocalStorage

Local Storage - https://ellie-app.com/8yYddD6HRYJa1[Live Demo]

This is a minimal example of how to use `localStorage` through ports.

It remembers user data across sessions. This data may be lost if the user clears their cookies, so it is safest to think of this as a **cache** rather than normal storage.

Anyway, the important code lives in `src/Main.elm` and in `index.html` with comments!


==== Building Locally

Run the following commands:

```bash
git clone https://github.com/elm-community/js-integration-examples.git
cd js-integration-examples/localStorage

elm make src/Main.elm --output=elm.js
open index.html
```

Some terminals may not have an `open` command, in which case you should open the index.html file in your browser another way.

.elm.json
[source,json]
----
{
    "type": "application",
    "source-directories": [
        "src"
    ],
    "elm-version": "0.19.1",
    "dependencies": {
        "direct": {
            "elm/browser": "1.0.2",
            "elm/core": "1.0.5",
            "elm/html": "1.0.0",
            "elm/json": "1.1.3"
        },
        "indirect": {
            "elm/time": "1.0.0",
            "elm/url": "1.0.0",
            "elm/virtual-dom": "1.0.2"
        }
    },
    "test-dependencies": {
        "direct": {},
        "indirect": {}
    }
}
----

.index.html
[source,html]
----
<!DOCTYPE HTML>
<html>

<head>
  <meta charset="UTF-8">
  <title>Elm + localStorage</title>
  <script type="text/javascript" src="elm.js"></script>
</head>

<body>
  <div id="myapp"></div>
</body>

<script type="text/javascript">
// Extract the stored data from previous sessions.
var storedData = localStorage.getItem('myapp-model');
var flags = storedData ? JSON.parse(storedData) : null;

// Load the Elm app, passing in the stored data.
var app = Elm.Main.init({
	node: document.getElementById('myapp'),
	flags: flags
});

// Listen for commands from the `setStorage` port.
// Turn the data to a string and put it in localStorage.
app.ports.setStorage.subscribe(function(state) {
    localStorage.setItem('myapp-model', JSON.stringify(state));
});
</script>

</html>
----

.src/Main.elm
[source,elm]
----
port module Main exposing (..)

import Browser
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Json.Decode as D
import Json.Encode as E



-- MAIN


main : Program E.Value Model Msg
main =
  Browser.element
    { init = init
    , view = view
    , update = updateWithStorage
    , subscriptions = \_ -> Sub.none
    }



-- MODEL


type alias Model =
  { name : String
  , email : String
  }


-- Here we use "flags" to load information in from localStorage. The
-- data comes in as a JS value, so we define a `decoder` at the bottom
-- of this file to turn it into an Elm value.
--
-- Check out index.html to see the corresponding code on the JS side.
--
init : E.Value -> ( Model, Cmd Msg )
init flags =
  (
    case D.decodeValue decoder flags of
      Ok model -> model
      Err _ -> { name = "", email = "" }
  ,
    Cmd.none
  )



-- UPDATE


type Msg
  = NameChanged String
  | EmailChanged String


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
  case msg of
    NameChanged name ->
      ( { model | name = name }
      , Cmd.none
      )

    EmailChanged email ->
      ( { model | email = email }
      , Cmd.none
      )



-- VIEW


view : Model -> Html Msg
view model =
  div []
    [ input
        [ type_ "text"
        , placeholder "Name"
        , onInput NameChanged
        , value model.name
        ]
        []
    , input
        [ type_ "text"
        , placeholder "Email"
        , onInput EmailChanged
        , value model.email
        ]
        []
    ]



-- PORTS


port setStorage : E.Value -> Cmd msg


-- We want to `setStorage` on every update, so this function adds
-- the setStorage command on each step of the update function.
--
-- Check out index.html to see how this is handled on the JS side.
--
updateWithStorage : Msg -> Model -> ( Model, Cmd Msg )
updateWithStorage msg oldModel =
  let
    ( newModel, cmds ) = update msg oldModel
  in
  ( newModel
  , Cmd.batch [ setStorage (encode newModel), cmds ]
  )



-- JSON ENCODE/DECODE


encode : Model -> E.Value
encode model =
  E.object
    [ ("name", E.string model.name)
    , ("email", E.string model.email)
    ]


decoder : D.Decoder Model
decoder =
  D.map2 Model
    (D.field "name" D.string)
    (D.field "email" D.string)
----


=== Internationalization

https://ellie-app.com/8yYbRQ3Hzrta1[Live Demo]

This is a minimal example of how to use the `Intl` library with a custom element.

![Demo](demo.gif)

The important code lives in `src/Main.elm` and in `index.html` with comments!

Check out https://github.com/wolfadex/fluent-web/[`wolfadex/fluent-web`] for a more complete approach, making https://projectfluent.org/[Project Fluent] available through custom elements.


==== Building Locally

Run the following commands:

```bash
git clone https://github.com/elm-community/js-integration-examples.git
cd js-integration-examples/internationalization

elm make src/Main.elm --output=elm.js
open index.html
```

Some terminals may not have an `open` command, in which case you should open the index.html file in your browser another way.

.elm.json
[source,json]
----
{
    "type": "application",
    "source-directories": [
        "src"
    ],
    "elm-version": "0.19.1",
    "dependencies": {
        "direct": {
            "elm/browser": "1.0.2",
            "elm/core": "1.0.5",
            "elm/html": "1.0.0",
            "elm/json": "1.1.3"
        },
        "indirect": {
            "elm/time": "1.0.0",
            "elm/url": "1.0.0",
            "elm/virtual-dom": "1.0.2"
        }
    },
    "test-dependencies": {
        "direct": {},
        "indirect": {}
    }
}
----

.index.html
[source,html]
----
<!DOCTYPE HTML>
<html>

<head>
  <meta charset="UTF-8">
  <title>Elm + Intl</title>
  <script type="text/javascript" src="elm.js"></script>
</head>

<body>
  <div id="myapp"></div>
</body>

<script type="text/javascript">

// Create a function that that formats text as you need. Here we have
// a function to localize dates:
//
//   localizeDate('sr-RS', 12, 5) == "петак, 1. јун 2012."
//   localizeDate('en-GB', 12, 5) == "Friday, 1 June 2012"
//   localizeDate('en-US', 12, 5) == "Friday, June 1, 2012"
//
function localizeDate(lang, year, month)
{
	const dateTimeFormat = new Intl.DateTimeFormat(lang, {
		weekday: 'long',
		year: 'numeric',
		month: 'long',
		day: 'numeric'
	});

	return dateTimeFormat.format(new Date(year, month));
}

// Define a Custom Element that uses this function. Here we make it
// possible to define nodes like this:
//
//     <intl-date lang="sr-RS" year="2012" month="5">
//     <intl-date lang="en-GB" year="2012" month="5">
//     <intl-date lang="en-US" year="2012" month="5">
//
// Check out src/Main.elm to see how you use this on the Elm side.
//
customElements.define('intl-date',
	class extends HTMLElement {
		// things required by Custom Elements
		constructor() { super(); }
		connectedCallback() { this.setTextContent(); }
		attributeChangedCallback() { this.setTextContent(); }
		static get observedAttributes() { return ['lang','year','month']; }

		// Our function to set the textContent based on attributes.
		setTextContent()
		{
			const lang = this.getAttribute('lang');
			const year = this.getAttribute('year');
			const month = this.getAttribute('month');
			this.textContent = localizeDate(lang, year, month);
		}
	}
);

// Start the Elm application that uses the <intl-date> node.
//
var app = Elm.Main.init({
	node: document.getElementById('myapp')
});

</script>

</html>
----

.src/Main.elm
[source,elm]
----
module Main exposing (..)

import Browser
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Json.Decode as D



-- MAIN


main : Program () Model Msg
main =
  Browser.element
    { init = init
    , view = view
    , update = update
    , subscriptions = \_ -> Sub.none
    }



-- MODEL


type alias Model =
  { language : String
  }


init : () -> ( Model, Cmd Msg )
init _ =
  ( { language = "sr-RS" }
  , Cmd.none
  )



-- UPDATE


type Msg
  = LanguageChanged String


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
  case msg of
    LanguageChanged language ->
      ( { model | language = language }
      , Cmd.none
      )



-- VIEW


view : Model -> Html Msg
view model =
  div []
    [ p [] [ viewDate model.language 2012 5 ]
    , select
        [ on "change" (D.map LanguageChanged valueDecoder)
        ]
        [ option [ value "sr-RS" ] [ text "sr-RS" ]
        , option [ value "en-GB" ] [ text "en-GB" ]
        , option [ value "en-US" ] [ text "en-US" ]
        ]
    ]


-- Use the Custom Element defined in index.html
--
viewDate : String -> Int -> Int -> Html msg
viewDate lang year month =
  node "intl-date"
    [ attribute "lang" lang
    , attribute "year" (String.fromInt year)
    , attribute "month" (String.fromInt month)
    ]
    []


valueDecoder : D.Decoder String
valueDecoder =
  D.field "currentTarget" (D.field "value" D.string)
----


== A Guide to Using Elm With Webcomponents

:doc-exec-command: https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand 
:elmpkg-elm-json: https://package.elm-lang.org/packages/elm/json/latest
:jq-event-delegation: https://learn.jquery.com/events/event-delegation/ 
:guide: https://guide.elm-lang.org
:guide-interop: https://guide.elm-lang.org/interop/
:guide-ports: https://guide.elm-lang.org/interop/ports.html 
:guide-custom-elements: https://guide.elm-lang.org/interop/custom_elements.html 
:html5-apis: https://developer.mozilla.org/en-US/docs/Web/API 
:mdn-clipboard: https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API 
:mdn-customevent: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent
:mdn-customevent-polyfill: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill
:mdn-customized-builtins: https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Customized_built-in_elements
:mdn-event-bubbling: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture 
:mdn-shadow-dom: https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM
:mdn-slot: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot 
:mdn-wc: https://developer.mozilla.org/en-US/docs/Web/Web_Components 
:w3c: https://www.w3.org/ 
:wc-custom-elements: https://www.webcomponents.org/specs#the-custom-elements-specification 
:wc-home: https://www.webcomponents.org/
:wc-polyfills: https://www.webcomponents.org/polyfills 
:wc-polyfill-custom-elements: https://github.com/webcomponents/polyfills/tree/master/packages/custom-elements
:wc-polyfill-custom-elements-es5: https://github.com/webcomponents/polyfills/tree/master/packages/custom-elements#es5-vs-es2015 
:wc-specs: https://www.webcomponents.org/specs
:ng-differential-loading: https://blog.angular.io/version-8-of-angular-smaller-bundles-cli-apis-and-alignment-with-the-ecosystem-af0261112a27 
:so-custom-elements: https://stackoverflow.com/questions/50295703/create-custom-elements-v1-in-es5-not-es6 

This document is meant to be a practical guide to the somewhat confusing link:{wc-specs}[web components specs].

Most documentation on web components show the spec and basic usage examples, assuming that you already know the intricate details of why specific parts of the spec exist in the first place and what use case they try to solve. This situation can be daunting even for experienced web developers and even more so for newcomers.

We try to be as concise as possible, while also providing enough information to get you up and running.

=== TL;DR

If you are looking for a quick start with Elm, Webcomponents and the setup of choice have a look at
* <<web-components-setup, web components setup>>
* <<Browser-Support, the browser support section>>
* don't forget to check <<Gotchas, the gotchas section>> to learn how to build Webcomponents that play nice with Elm.

=== Prerequisites

First-off: if you haven't read link:{guide}[the official Elm guide] you should do so before reading on, of particular note is link:{guide-interop}[the interop section] as this is where the usage of link:{guide-ports}[ports] and link:{guide-custom-elements}[custom elements] is motivated.

Now that you're up to date and positive that using web components is the way to solve the problem at hand we'll start off with a quick summary of what web components are, followed by a rundown of the parts of link:{wc-specs}[the spec] you'll most likely interact with when using Elm.

The remainder of the guide is dedicated to getting your app ready for web components in all the browsers you want/need to support.

=== What are web components and what can I do with them?

You might have heard or read "just use web components" as an answer to the question how to integrate a particular JavaScript API or external library with Elm. 

To quote the first paragraph on the link:{wc-specs}[web components specs page]

____
These four specifications can __be used on their own__ but combined allow developers to define their own tags (custom element), whose styles are encapsulated and isolated (shadow dom), that can be restamped many times (template), and have a consistent way of being integrated into applications (es module).
____

I've emphasized the most important information: in order to "use web components" you can and should actually pick and choose what part of the spec you need in order to solve your problem.

* You don't need to use Shadow DOM, if you don't need style encapsulation.
* You don't need to use HTML templates, if you already have a templating solution.
* You don't need ES Modules, if you have a compile-to-js language like, say, *drumroll* Elm.

You may find yourself using all of these specs but they aren't usually necessary in conjuction with Elm. If you want to dive deeper into Webcomponents in plain JavaScript the link:{mdn-wc}[MDN page about Webcomponents] is a good place to start.


=== Web Components Setup

At the time of writing this article you're probably using some form of build system for your JavaScript assets, by choice, custom or force. A detailed assessment of bundling modern web apps is outside the scope of this guide but you can check out <<minimal-es5-setup-html, our minimal ES5 compatible setup>> that provides the polyfills necessary to use web components with older browsers like Internet Explorer 11.

There is more information available in the <<browser-support, browser support section>>.


=== Custom Elements And Elm

Note that if at this point you skipped the earlier requests to have a look at the link:{guide-interop}[interop section of the Elm guide] it's a good idea to do so now. 

So we've looked at link:{wc-specs}[the specs] and the most relevant one to Elm is arguably link:{wc-custom-elements}[Custom Elements]. Looking at the examples on that page, defining a custom element is easy enough.

```javascript
class MyElement extends HTMLElement {}
customElements.define("my-element", MyElement);
```

This defines a new HTML element `<my-element>`. Note that
* the name *has* to include a hyphen and
* the class *needs* to extend `HTMLElement`.

This is what custom elements are about: they let you build your own HTML elements with behavior tailored to your application that are indistinguishable from built-in elements like `<input>` or `<section>`. Which in turn means we can create these kind of elements within Elm without problems.

```elm
import Html

element =
    Html.node "my-element" [] [ Html.text "Awesome!" ]
```

Let's have a look at the anatomy of a custom element. Note that this only covers the part of the API that is most relevant to Elm, we provide links to associated concepts where appropriate.

==== Construction

https://ellie-app.com/8Vw6BbYYpc4a1[demo]

A custom element, just like any other built-in element, can be created declaratively using HTML or imperatively using JavaScript.

```javascript
customElements.define("my-element", class extends HTMLElement {});

const element = document.createElement("my-element");
```

```html
<!-- Note that custom elements can not be self-closing -->
<my-element></my-element>
```
```elm
import Html

myElement =
    Html.node "my-element" [] []
```

==== Lifecycles

https://ellie-app.com/8Vw7J3nFNNma1[demo]

There are lifecycles you can attach clunkily-named callbacks to.

```javascript
customElements.define("i-support-lifecycles", class extends HTMLElement {
    constructor() {
        super();
        // This <i-support-lifecycles> is being initialized, it's not been
        // added to any document yet but you can initialize your fields but
        // don't temper with the DOM just yet, do that in `connectedCallback`
    }
    adoptedCallback() {
        // This <i-support-lifecycles> has been moved to a different document
    }
    connectedCallback() {
        // This <i-support-lifecycles> has been added to the DOM
    }
    disconnectedCallback() {
        // This <i-support-lifecycles> has been removed from the DOM
    }
});
```

==== Attributes

https://ellie-app.com/8Vwfz6c5v2wa1[demo]

Custom elements may declare supported attributes via `observedAttributes` - only attribute names returned from this trigger the `attributeChangedCallback` when changed. Note that attributes can only carry `string` values.

There's also a <<attributes-vs-properties, discussion on whether to use an attribute or a property>>, if you're not sure which to use.

```javascript
customElements.define("twbs-alert", class extends HTMLElement {
    static get observedAttributes() {
        // We need to declare which attributes should be observed,
        // only these trigger the `attributeChangedCallback`
        return ['type'];
    }
    connectedCallback() {
        this.classList.add('alert');
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case 'type':
                this.classList.remove(`alert-${oldValue}`);
                this.classList.add(`alert-${newValue}`);
                break;
        }
    }
});

const element = document.createElement("twbs-alert");
element.setAttribute("type", "info");
```

```html
<twbs-alert type="info"></twbs-alert>
```
```elm
import Html
import Html.Attributes

alert =
    Html.node "twbs-alert"
        [ Html.Attributes.attribute "type" "info"
        -- or alternatively Html.Attributes.type_ "info"
        ]
        [ Html.text "This is a Twitter Bootstrap info box"
        ]
```

If you need to transfer object data you can use a <<Properties, property>>.

==== Properties

https://ellie-app.com/8VwjNrnhyKKa1[demo]

Custom elements can declare properties via `get` and `set`, most kinds of JavaScript objects are supported.

There's also a <<attributes-vs-properties, discussion on whether to use an attribute or a property>>, if you're not sure which to use.

```javascript
customElements.define("atla-trivia", class extends HTMLElement {
    constructor() {
        super();
        this._meta = null;
    }
    set meta(value) {
        this._meta = value;
    }
    get meta() {
        return this._meta;
    }
});

const element = document.createElement("atla-trivia");
element.meta = {
    teamAvatar: ["Aang", "Katara", "Soka"],
    seasons: 3,
};
```

```html
<!-- You can't set properties directly in raw HTML, sorry -->
```

With Elm you need to use a JSON encoder provided by the link:{elmpkg-elm-json}[`elm/json`] package.

```elm
import Html
import Html.Attributes
import Json.Encode -- elm install elm/json

trivia =
    Html.node "atla-trivia"
        [ Html.Attributes.property "meta"
            (Json.Encode.object
                [ ( "teamAvatar"
                  , Json.Encode.list Json.Encode.string
                    [ "Aang"
                    , "Katara"
                    , "Soka"
                    ]
                  )
                , ( "seasons", Json.Encode.int 3 )
                ]
            )
        ]
        []
```

==== Attributes vs Properties
For Elm projects a good rule of thumb is

> Use properties unless you want your custom elements to be used from hand-written or server-rendered HTML.

The reasoning being
* You're interacting with your custom element via JavaScript anyways, so the fact that properties can not be set from raw HTML is usually not an issue
* You can transfer structured data via properties, not just strings
* It's easier to use a consistent interaction method with custom elements from Elm - just use `Html.Attributes.property` everywhere

On the other hand writing custom elements using only attributes might be more suitable for your use case as they can easily be included in static HTML, hand-written or produced by server-side-rendering.


==== Children

https://ellie-app.com/8VwmHKFMYCqa1[demo]

As we've noted a number of times: custom elements are just like regular HTML elements, this includes the ability to be a root node for a sub-tree, your custom element can have child nodes.

```javascript
customElements.define("tree-root", class extends HTMLElement {});

const root = document.createElement("tree-root");
const span = document.createElement("span");
span.innerText = "A span";
const div = document.createElement("div");
div.innerText = "A div";
const plainText = document.createTextNode("Plain text");

root.appendChild(span);
root.appendChild(div);
root.appendChild(plainText);
```

```html
<tree-root>
    <span>A span</span>
    <div>A div</div>
    Plain text
</tree-root>
```

This is equivalent to the following Elm code. Be sure to read up on <<Gotchas, the gotchas>> due to Elm's virtual DOM, though.

```elm
import Html

subTree =
    Html.node "tree-root" []
        [ Html.span [] [ Html.text "A span" ]
        , Html.div [] [ Html.text "A div" ]
        , Html.text "Plain Text"
        ]
```

==== Listening to Events

https://ellie-app.com/8Vwpg8T5GDQa1[demo]

Custom elements support listening to events; this is usually not that useful in conjunction with Elm since you can't imperatively trigger events with it. However, it allows you to employ some nifty tricks like link:{jq-event-delegation}[event delegation] where you use the link:{mdn-event-bubbling}[DOM's event bubbling phase] to listen for events that "bubble up" from your custom element's children.

```javascript
customElements.define("event-delegator", class extends HTMLElement {
    _handleInnerClick(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        alert(`You clicked inside of me`);
    }
    connectedCallback() {
        this.addEventListener("click", this._handleInnerClick)
    }
    disconnectedCallback() {
        this.removeEventListener("click", this._handleInnerClick)
    }
});

const element = document.createElement("event-delegator");
const button = document.createElement("button");
button.innerHTML = "Click Me!";

element.appendChild(button);
document.body.appendChild(element);
```

```html
<event-delegator>
    <button>Click Me!</button>
</event-delegator>
```

As we've seen in <<Children, the Children section>> building DOM trees with Elm is a breeze. In this example we see both the power and the potential problems with using custom elements in Elm, they allow you to execute arbitrary JavaScript inside your declarative views. So be aware of the fact that a rogue custom element can compromise Elm's runtime guarantees, have a look at <<Gotchas, the Gotchas section>> to learn more.

```elm
import Html

root =
    Html.node "event-delegator" []
        [ Html.button [ {- no `onClick` here -} ]
            [ Html.text "Click Me!"
            ]
        ]
```


==== Triggering Events

https://ellie-app.com/8VvL6ggT5qJa1[demo]

Custom elements <<Listening-to-Events, can listen to events>> but they become really useful as soon as they're triggering events themselves. You mainly want to use this as an adapter to give Elm access to link:{html5-apis}[Web APIs] it does not yet support in form of a core package or to embed functionality from external JavaScript libraries.

To demonstrate this we build a slightly more involved custom element `<copy-to-clipboard>` that lets the user copy text from an Elm app via button click using the link:{doc-exec-command}[Document.execCommand API]. This is a fairly old non-standard API that's widely supported, nonetheless. The link:{mdn-clipboard}[Clipboard API] is the modern successor, in case you don't need support for older browsers.

The gist is that our element listens for `click` events from its children, copies the value of its `text` attribute to the clipboard and triggers a link:{mdn-customevent}[`CustomEvent`] notifying Elm that the operation has been successful, Elm can also decode event data being passed.

```javascript
customElements.define("copy-to-clipboard", class extends HTMLElement {
    static get observedAttributes() {
        return ["text"];
    }
    _handleClick(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        const text = this.getAttribute("text");
        this._copy(text);
        this.dispatchEvent(new CustomEvent("clipboard", {
            bubbles: true,
            cancelable: true,
            detail: {
                copiedText: text,
            },
        }));
    }
    _copy(value) {
        const preSelected =            
            document.getSelection().rangeCount > 0
                ? document.getSelection().getRangeAt(0)
                : false;

        const textarea = document.createElement('textarea');
        textarea.setAttribute('readonly', '');
        textarea.style.position = 'absolute';
        textarea.style.left = '-9999px';
        textarea.value = value;
        document.body.appendChild(textarea);
      
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        if (preSelected) {
            document.getSelection().removeAllRanges();
            document.getSelection().addRange(preSelected);
        }
    }
    connectedCallback() {
        this.addEventListener("click", this._handleClick);
    }
    disconnectedCallback() {
        this.removeEventListener("click", this._handleClick);
    }
});
```


```elm
module Main exposing (main)

import Browser
import Html exposing (Html)
import Html.Attributes
import Html.Events
import Json.Decode exposing (Decoder)


type Msg
    = CopiedToClipboard String


type alias Model =
    { copied : Maybe String
    }


clipboardEventDecoder : (String -> msg) -> Decoder msg
clipboardEventDecoder toMsg =
    Json.Decode.map (\copiedTextFromDetail -> toMsg copiedTextFromDetail)
        (Json.Decode.at [ "detail", "copiedText" ] Json.Decode.string)


view : Model -> Html Msg
view { copied } =
    let
        textToCopy =
            "Text from Elm"
    in
    Html.div []
        [ Html.node "copy-to-clipboard"
            [ Html.Attributes.attribute "text" textToCopy
            , Html.Events.on "clipboard" (clipboardEventDecoder CopiedToClipboard)
            ]
            [ Html.button []
                [ Html.text "Copy "
                , Html.text ("\"" ++ textToCopy ++ "\"")
                , Html.text " to clipboard"
                ]
            ]
        , case copied of
            Just _ ->
                Html.div []
                    [ Html.div [] [ Html.text "Copied!" ]
                    , Html.textarea
                        [ Html.Attributes.placeholder "Try pasting it in here"
                        ]
                        []
                    ]

            Nothing ->
                Html.text ""
        ]


update : Msg -> Model -> Model
update (CopiedToClipboard text) model =
    { model | copied = Just text }


main : Program () Model Msg
main =
    Browser.sandbox
        { init = { copied = Nothing }
        , update = update
        , view = view
        }

```

_Note that Internet Explorer needs link:{mdn-customevent-polyfill}[a polyfill for CustomEvent]._

Many Elm apps use this technique to embed libraries like https://github.com/ellie-app/ellie/blob/a45637b81e2495ffada12f9a75dd6bb547a69226/assets/src/Ellie/Ui/CodeEditor.js[CodeMirror] or https://package.elm-lang.org/packages/PaackEng/elm-google-maps/latest/[Google Maps].

Until now all seems hunky-dory in the world of custom elements being embedded with Elm but there are some <<Gotchas, gotchas>> you need to be aware of. We'll take a look at these in the next section.


=== Gotchas

There are some things to keep in mind when employing custom elements in your Elm app.

==== Web Components And Virtual DOM

Elm takes full control of the part of the DOM it manages. Like other virtual-dom based libraries it keeps track of the current state of the DOM in the form of an in-memory representation of the tree and assumes that what is currently rendered in the real DOM is a pure derivative from this in-memory representation.

Some libraries are more forgiving than others with unexpected mutations but if you mess with those nodes too much you risk breaking their invariants, which in turn will cause runtime exceptions, even in Elm. What that means in practice is that you should adhere to the following rules for your custom elements to play nice with virtual-dom libraries in general.

* 1) Make sure your custom element cleans up after itself via `disconnectedCallback` as Elm may decide to re-create any part of the DOM without notice.
* 2) This also means that you should not rely on Elm creating your custom element node exactly x amount of times.
* 3) If your custom element is supposed to receive child nodes from the outside like <<Listening-to-Events, in our little event delegation example>> make sure not to add or remove any children as this may confuse Elm's virtual-dom.
* 4) If your custom element doesn't expect children from the outside you are free to manage the element's child nodes.
* 5) If you need both external and self-managed children you can "hide" them inside a link:{mdn-shadow-dom}[Shadow Root], Elm won't inspect sub-trees of shadow roots. Note that there are polyfills for the Shadow DOM spec out there that work in older browsers but this API is farely involved so these might slow down the browser significantly and/or have unexpected behavior.

==== Customized Built-ins

The link:{wc-specs}[spec] mentions that you can link:{mdn-customized-builtins}[extend built-in elements], e.g. to make your own `<button>`. https://github.com/elm/virtual-dom/issues/156[Elm's virtual dom does not support creating these kind of elements]. <<modern-environments-vs-the-spec, This guide has a small example>> but note that this feature is not widely supported by browsers and it's probably best to avoid it altogether.


And while we're talking about gotchas...


=== Browser Support

Looking at our basic example snippets you may have a very valid question. (https://ellie-app.com/8Vw6BbYYpc4a1[demo])

```javascript
class MyElement extends HTMLElement {}
customElements.define("my-element", MyElement);
```

```elm
import Html

myElement =
    Html.node "my-element" [] [ Html.text "Awesome!" ]
```

> If that's all there is to it why do I even read this guide?

Glad you asked! As is usually the case, there's more than meets the eye.


==== Older Environments

Our custom element seems to work... until we try to use our `<my-element>` component in Internet Explorer, some ancient mobile browser, a webview - `SyntaxError` or maybe `"customElements" is not defined`. Off to the "browser support" page; link:{wc-home}[looks very green and ready for showbiz] but we remember link:{wc-polyfills}[the word "polyfill"] so that is what catches our eye.

The gist is that not every browser supports web components out-of-the-box and some implementations are buggy so you need to include a sort-of base library. After we've included link:{wc-polyfill-custom-elements}[the custom elements polyfill] our code agrees to run inside mobile browsers (and webviews?) but Internet Explorer is relentless, as always - `SyntaxError` is the bane of our existence.

It turns out that Internet Explorer doesn't support the `class` syntax introduced in ES6. Because we know that `class` syntax is actually just syntactic sugar for constructor functions and prototype chaining we begrudgingly rewrite our example component.

```javascript
function MyElement() {}
MyElement.prototype = Object.create(HTMLElement.prototype);
customElements.define("my-element", MyElement);
```

Internet Explorer still complains `the custom element constructor did not produce the element being upgraded`, odd. After more research we link:{so-custom-elements}[come across the magic incantation] that makes our component appear in all browsers. Note that the polyfill detects modern browsers automatically now so we at least don't need to link:{wc-polyfill-custom-elements-es5}[patch the native implementation manually to work with ES5 style classes].

This means that per spec native custom element implementations only work with ES6 classes, keep that in mind!

```html
<!-- We also need a polyfill for `Reflect` -->
<script src="https://unpkg.com/es6-shim@0.35.5/es6-shim.min.js"></script>
<script src="https://unpkg.com/@webcomponents/custom-elements"></script>
```

```javascript
function MyElement() {
    return Reflect.construct(HTMLElement, [], this.constructor);
}
MyElement.prototype = Object.create(HTMLElement.prototype);
MyElement.prototype.constructor = MyElement;
MyElement.prototype.connectedCallback = function () {
    this.appendChild(document.createTextNode("Water!"));
};
Object.setPrototypeOf(MyElement, HTMLElement);

customElements.define("my-element", MyElement);
```

Have a look at the <<minimal-es5-setup-html, minimal example setup that works in ECMAScript 5 compliant browsers>>.

For cross-browser support you'll need a polyfill for old browsers *and* modern browsers! 

And that's not even the whole story. There are other approaches like serving different bundles to different browsers like link:{ng-differential-loading}[Angular 8+ differential loading] does. Which also has problems, having two different code base versions of your app run in older and newer browsers respectively can lead to bugs that are very hard track down.



==== Modern Environments vs the Spec

You may think that targeting only modern browsers frees you from all the hassle. Let's take a look at link:{wc-custom-elements}[the other example] on the web components page.

```javascript
class CustomizedButton extends HTMLButtonElement {
    connectedCallback() {
        this.style.backgroundColor = "orange";
    }
}
customElements.define("customized-button", CustomizedButton, { extends: "button" });
```

```html
<button is="customized-button">Customized!</button>
```

:customized-polyfill: https://github.com/ungap/custom-elements-builtin 
:webkit-nope: https://bugs.webkit.org/show_bug.cgi?id=182671 
:w3c-nope: https://github.com/w3c/webcomponents/issues/509 

If we open this in Chrome our button is indeed a button with an orange background. Safari does not concur, neither does pre-Chromium Microsoft Edge nor link:{webkit-nope}[any Webkit based browser possibly forever] which includes the iOS browser. `Customized built-in` s as they're called are part of the spec but a non-significant amount of browsers doesn't and probably won't support them anytime soon.

Although there is link:{customized-polyfill}[a polyfill] it's probably best to ignore that part of the spec, it's not safe to use as link:{w3c-nope}[is documented in this w3c issue] and layering polyfills upon polyfills onto each other might have consequences.

Also note that Elm's virtual-dom does not support creating these customized built-ins, see the <<gotchas, gotchas section>> for more information.



=== Conclusion

In this guide we've discussed the impetus of why webcomponents exist in the first place and what parts of the spec are particularly relevant when working with Elm.

We've investigated a number usecases with demos where custom elements come in handy to enhance Elm's vocabulary in terms of not yet natively supported web APIs and interop scenarios with external JavaScript libraries.

I hope you now have a fair grasp on these topics so you can confidently incorporate custom elements in your Elm workflow when needed.


=== Further Reading

* link:{mdn-wc}[Mozilla Developer Network Article on Webcomponents]
* link:{wc-home}[https://webcomponents.org]
* https://korban.net/posts/elm/2018-09-17-introduction-custom-elements-shadow-dom/[Alex Korban's A Straight Forwared Introduction to Custom Elements]
* https://webcomponents.dev/blog/all-the-ways-to-make-a-web-component/[All the Ways To Make a Web Component]



[source,html]
----
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Web components example</title>
</head>

<body>
    <script src="https://unpkg.com/es6-shim@0.35.5/es6-shim.min.js"></script>
    <script src="https://unpkg.com/@webcomponents/custom-elements"></script>
    <script>

        // Works in IE11+
        function LegacyElement() {
            return Reflect.construct(HTMLElement, [], this.constructor);
        }
        LegacyElement.prototype = Object.create(HTMLElement.prototype);
        LegacyElement.prototype.constructor = LegacyElement;
        LegacyElement.prototype.connectedCallback = function () {
            this.appendChild(document.createTextNode("A little rusty!"));
        };
        Object.setPrototypeOf(LegacyElement, HTMLElement);

        customElements.define("legacy-element", LegacyElement);

    </script>
    <script type="module">

        // Only for modern browsers
        customElements.define("modern-element", class extends HTMLElement {
            connectedCallback() {
                this.appendChild(document.createTextNode("Shiny!"));
            }
        });

    </script>
    <!-- Note that custom elements can not be self-closing -->
    <legacy-element></legacy-element>
    <modern-element></modern-element>
</body>

</html>
----



== Elm Home Page


All of link:http://elm-lang.org[elm-lang.org] is written in Elm!

以下三个官方项目源代码，以及社区开源项目是研究／学习 Elm 编程的最佳案例：

• link:https://elm-lang.org/[Elm Home Page]
  link:https://github.com/elm/elm-lang.org/[• Source code]
• link:https://guide.elm-lang.org/[the Official Guide]
  link:https://github.com/evancz/guide.elm-lang.org[• Source code]
• link:https://package.elm-lang.org/[the Package Docs]
  link:https://github.com/elm/package.elm-lang.org/[• Source code]

• link:https://ellie-app.com/new[Ellie App]
  link:https://github.com/ellie-app/ellie[• Source code]
• link:https://vscode.dev/github/rtfeldman/elm-spa-example[RealWorld Example App]
• link:https://sporto.github.io/elm-workshop/[]
  link:https://github.com/sporto/elm-workshop[• Source code]
• link:https://elmprogramming.com/[Beginning Elm]
  link:https://github.com/pawanpoudel/beginning-elm-code[• Source code]


官方教程源文档包含 REPL 功能，文档中使用 JSON 数据组织 Elm 代码，并且可以让用户直接通过 Web 页面交互，将代码发送到 https://worker.elm-lang.org/repl 服务器上进行编译，然后将编译结果渲染到页面上。因为是跨域的脚本请求，所以会有一个 HTTP OPTIONS 动作进行预检查（preflight），只有目标服务器支持跨域请求时才正式发送（POST）代码进行在线交互编译。文档的代码块中 	"value" 部分包含终端控制码，譬如 "\u001b[95m2\u001b[0m"，这是带有字体颜色的终端控制码，输出一个紫色的“2”。关于终端软件概念，可以参考 Linux 系统编程手册，也可以参考 xref:vim_flavor.md[《让世界多一份 Vim 教程：Topdown 式入门姿势》]，其中 Keyboar Mapping 部分有解释。

Elm Home Page 源代码也包含了一个编辑器，Ui/Editor 会将 Elm 代码发送到 social.elm.studio 服务器进行在线编译，可以像以下 bash 脚本这样将代码 POST 到服务器上进行在线编译，并返回包含 JavaScript 代码的 HTML 页面文件。

[source,bash]
----
curl 'https://social.elm.studio/api/compile' \
  -H 'Content-Type: multipart/form-data; boundary=----Boundary' \
  --data-raw $'------Boundary\r\nContent-Disposition: form-data; name="code"\r\n\r\nimport Html exposing (..)\r\nmain = div [] [text "Hello Elm!"]\r\n\r\n------Boundary--\r\n' > live.html
----

.https://github.com/elm/elm-lang.org/blob/master/editor/src/Ui/Editor.elm#L203[Ui/Editor.elm]
[source,elm]
----

-- VIEW


viewEditor : Solution.Solution -> Bool -> Model -> Html Msg
viewEditor solution isLight model =
  Html.form
    [ id "editor"
    , action (Constant.server ++ "/api/compile")
    , method "post"
    , enctype "multipart/form-data"
    , target "output"
    ]
    [ textarea [ id "code", name "code", style "display" "none" ] []
    , case solution.hash of
        Just hash -> viewSolutionInput solution hash
        Nothing -> text ""
    , lazy4 viewEditor_ model.source model.selection isLight model.importEnd
    ]
----


=== Build Instructions

Running `bash build.sh` should generate the static website in `_site`.

After that, you can run `(cd _site ; elm reactor)` to see it at `http://localhost:8000` in your browser. Not all the links work with this setup, but you should be able to get to all the pages nonetheless!

[source,json]
----
{
    "type": "application",
    "source-directories": [
        "src"
    ],
    "elm-version": "0.19.1",
    "dependencies": {
        "direct": {
            "NoRedInk/elm-plot-rouge": "1.0.0",
            "elm/browser": "1.0.1",
            "elm/core": "1.0.2",
            "elm/file": "1.0.5",
            "elm/html": "1.0.0",
            "elm/http": "2.0.0",
            "elm/json": "1.1.3",
            "elm/random": "1.0.0",
            "elm/svg": "1.0.1",
            "elm/time": "1.0.0",
            "elm-explorations/linear-algebra": "1.0.3",
            "elm-explorations/markdown": "1.0.0",
            "elm-explorations/webgl": "1.0.1",
            "evancz/elm-playground": "1.0.2",
            "mdgriffith/elm-ui": "1.1.5"
        },
        "indirect": {
            "debois/elm-dom": "1.3.0",
            "elm/bytes": "1.0.8",
            "elm/regex": "1.0.0",
            "elm/url": "1.0.0",
            "elm/virtual-dom": "1.0.2",
            "myrho/elm-round": "1.0.4"
        }
    },
    "test-dependencies": {
        "direct": {},
        "indirect": {}
    }
}
----


== Blogs

=== How to Use Elm at Work

https://elm-lang.org/news/how-to-use-elm-at-work[How to Use Elm at Work] by Evan Czaplicki / 11 July 2016

Embedding Elm in some big JavaScript project is not very hard. It's like three lines of JS, but it feels like no one knows about them! So I created _react-elm-components_ to make it much more obvious. It looks like this:

.Source link:https://vscode.dev/github/evancz/react-elm-components[🕸]
[source,elm]
----
import Elm from 'react-elm-components';
import {Chat} from '../dist/elm/chatroom.js';

function render() {
    return <Elm src={Chat} />;
}
----

Why embed Elm like this? Well, tons of folks are trying out Elm these days, and as they share their experiences, I noticed that everyone who successfully introduces Elm at work tells the same story. They introduce Elm gradually into an existing JS project. The rest of this blog post outlines the typical success story in detail. What strategies work? What are some common mistakes? I hope this will be helpful for folks interested in using Elm at work or on their own!

NOTE: The _react-elm-components_ module is under 20 lines of JS, mostly React-related. So using the same strategy with Angular, Ember, etc. should be pretty simple. More about that here.

==== Gradual Introduction

Every company that uses Elm in production follows a similar path:

• *_Learn_* — Someone on the team starts looking into Elm. They build something on their own. They get familiar with Elm. They become the advocate. They “own” the remaining steps.

• *_Experiment_* — That person writes one little thing in Elm at work to see how it goes. They do not have a massive migration plan or anything. They just do it.

• *_Evaluate_* — If that experiment goes well, they do more. And if it does not go well, they revert it and go back to the other stuff.

• *_Repeat_* — The person who introduced the original code helps everyone on the team learn Elm as it is used in more stuff.

Again, this is the success story. I hear it again and again from folks using Elm in production. I do not hear other stories.

**This process works because it minimizes risk**. Having an advocate means you have someone on the team who knows Elm really well. They can answer questions quickly in-house. Furthermore, you are trying something small in Elm. Maybe it is whipped up in a single day even. Point is, you are not pouring time and money into a project that may not work out. This means trying out Elm is really not a big commitment at all. Big upside, very little downside.

When you go through this loop the second time, I recommend expanding the section already written in Elm or trying something bigger on another page. These routes build on Elm strengths. For example, link:https://elm-lang.org/news/compilers-as-assistants[friendly error messages] get more and more useful as your Elm codebase grows. If you want more advice, check out Richard’s talk link:https://www.youtube.com/watch?v=R2FtMbb-nLs[6 months of Elm in Production] about what they did at NoRedInk. They have been very successful, and Richard is great at choosing projects strategically.

==== Fix a Problem

This broad outline is great, but it is important to be strategic in choosing your first project. Do not just write Elm code because you like it. Fix a problem.

There are two stories you can tell after rewriting code:

• “You know that crazy code that everyone fears touching? It is simpler now and I resolved some bugs.”

• “You know that code that was totally fine? It is different now.”

You want to tell the first story. In the ideal telling, the new version is better because of a particular detail about Elm. Maybe that is immutability or The Elm Architecture or friendly error messages. Not only is it better, but it is better in a way that can only be achieved with Elm!

I tried to illustrate this in the link:https://github.com/evancz/react-elm-components/tree/master/example-elm0.18[Emoji Chat Room example] that comes with link:https://www.npmjs.com/package/react-elm-components[react-elm-components]. The Emoji picker is some off-the-shelf React component, and the chat room is a custom Elm program. We chose this split because (1) we cannot get the chat part off-the-shelf with the style we want and (2) websockets are a pleasure to work with in Elm. In other words, we chose to use Elm in a situation where it really shines!

==== The Checklist

The previous sections give you a flavor of what to do, but I wanted to make a checklist to make it more concrete. **If you want to use Elm at work, make sure you are doing the following things:**

• *Have an advocate* — There should be one person on your team who has experience with Elm on a hobby project. They drive the initiative and help team members with anything they run into.

• *Start Small* — It is best to introduce Elm gradually. Choose a small part of an existing project. Your first work project in Elm should not be a green-field project or high-stakes rewrite.

• *Fix a Problem* — Use Elm where it will really shine. Elm may be nicer for all sorts of stuff, but the best story comes when you resolve issues that hurt your team every day.

• *Write Elm Code* — You can talk a decision like this to death. What about this? What about that? Talking abstractly is a waste of everyone’s time. Write an actual chunk of Elm code. Evaluate it against an actual chunk of JavaScript code. Talk concretely.

Hopefully that helps you out! I would love to hear how it goes, so definitely share your story as a blog post or through one of link:http://elm-lang.org/community[the community forums]. The community is really friendly and will definitely benefit from your experience, whether it works out or not. And who knows, maybe we can help out in some way!

==== Thanks

Huge thank you to link:https://twitter.com/rtfeldman[Richard] who got the react-elm-components example set up and looking good!


== Write React components in Elm

This package makes it easy to turn Elm code into React components.

Companies that use link:http://elm-lang.org/[Elm] in production usually start with a single component. So if you want to use Elm at work, start with a small experiment. Do people think it is nice? Do more! Do people think it sucks? Do less!

Read more about how to use Elm at work link:http://elm-lang.org/blog/how-to-use-elm-at-work[here].

=== Example

- Emoji Chat Room — link:http://evancz.github.io/react-elm-components[Demo] / link:example[Code]



=== Usage

After you have compiled an Elm program to JavaScript, you can embed it in React like this:

```javascript
import Elm from 'react-elm-components'
import { Todo } from '../dist/elm/todomvc.js'

function render() {
	return <Elm src={Todo} />
}
```


==== Flags

Sometimes you want to give your Elm program some **flags** on start up. For example, maybe your `Todo` module needs to get an array of todos. You would write something like this:

```javascript
import Elm from 'react-elm-components'
import { Todo } from '../dist/elm/todomvc.js'

function render() {
	var flags = { todos: ["Get Milk", "Do Laundry"] };
	return <Elm src={Todo} flags={flags} />
}
```

These flags will be given to the Elm program, allowing you to do some setup work in JS first.


==== JavaScript/Elm Interop

As your Elm program gets fancier, you will probably need to interact with JavaScript. We do this with link:http://guide.elm-lang.org/interop/javascript.html[**ports**]. Think of these as holes in the side of an Elm program that let you pass messages back-and-forth.

So maybe we extend our `Todo` app to allow outsiders to register new tasks through the `todos` port. And maybe we also expose `numActiveTodos` so that the outsider can know how much work you have left. You would set it up like this:

```javascript
import Elm from 'react-elm-components'
import { Todo } from '../dist/elm/todomvc.js'

function render() {
	return <Elm src={Todo} ports={setupPorts} />
}

function setupPorts(ports) {
	ports.numActiveTodos.subscribe(function(n) {
		console.log(n);
	});

	ports.todos.send("Invent the Universe");
	ports.todos.send("Bake an Apple Pie");
}
```

In the `setupPorts` function, we first subscribe to the `numActiveTodos` port. Whenever the number of active todos changes, we will run that function and log the number on the console. After that, we send two values through the `todos` port. This will add both of these into the model *and* trigger the `numActiveTodos` callback twice.


=== Advanced Usage

Once the Elm component is initialized, changing the `flags` and `ports` properties will do nothing. So here are some tricks that may help you out:

  1. If you want to reinitialize your Elm component, add a different `key` to the old and new components. This way old one is destroyed and replaced by the new one.
  2. If you want to mess with ports, you can save the `ports` object into your `state` and access it later.
  3. This package is super simple. Fewer than 20 lines. Check out the implementation and do it different if you want!


=== Angular, Ember, etc.

If you want to embed Elm in Angular or Ember or whatever else, you are in luck!

link:index.js[The implementation] is under 20 lines, mostly React-related. The important lines are basically running the following program at the correct time:

```javascript
var Elm = require('../dist/elm/todomvc.js');
var app = Elm.Todo.embed(node, flags);
setupPorts(app.ports)
```

So if you are interested in embedding Elm in something else, do the same trick! You can get more complete docs on embedding Elm in HTML link:http://guide.elm-lang.org/interop/html.html[here] and JavaScript interop link:http://guide.elm-lang.org/interop/javascript.html[here]. Let the community know if you make something!


''''

react-elm-components is maintained by the Front End Capability Team at Culture Amp.


=== example-elm0.18 - Emoji Chat Room

link:http://evancz.github.io/react-elm-components[Try It!]

This example is a simple chat room that makes it easy to input emoji.

The emoji picker is an off-the-shelf React component. The chat room is written in Elm. The interesting code lives in the following two files:

- `index.jsx` — This React code combines the emoji component and the Elm component.

- `Chat.elm` — This Elm code defines a simple chat room.

The rest of the files are to get Elm and JSX and everything working together. You may want to reuse some details of this configuration in your own projects.


==== Build Instructions

Run the following commands:

```bash
git clone https://github.com/evancz/react-elm-components.git
cd react-elm-components/example-elm0.18/
npm install
npm run serve
```

After downloading a bunch of stuff, this should compile `index.jsx` and `Chat.elm` into `build/bundle.js`. Assuming that all succeeds, it should open `index.html` in your browser automatically.


==== Alternate Build Instructions

Run the following commands:

```bash
git clone https://github.com/evancz/react-elm-components.git
cd react-elm-components/example-elm0.18/
npm install
npm run make
elm-reactor
```

And then open [http://localhost:8000/index.html] in your browser.


==== Troubleshooting

If any intructions do not work, please ask about it on link:http://elm-lang.org/community[the Elm slack]! Folks there are friendly and happy to help. They can troubleshoot the problem and help find any issues with these directions.


==== src/package.json

[source,json]
----
{
  "private": true,
  "scripts": {
    "make": "./node_modules/.bin/webpack -d",
    "serve": "npm run make && ./node_modules/http-server/bin/http-server -o -c-1"
  },
  "dependencies": {
    "emojione-picker": "^0.3.6",
    "react": "~0.14.0",
    "react-dom": "~0.14.0",
    "react-elm-components": ".."
  },
  "devDependencies": {
    "babel-cli": "^6.10.1",
    "babel-core": "^6.10.4",
    "babel-loader": "^6.2.4",
    "babel-plugin-transform-react-jsx": "^6.8.0",
    "babel-plugin-uglify": "^1.0.2",
    "babel-preset-es2015": "^6.9.0",
    "babel-preset-react": "^6.11.1",
    "elm-webpack-loader": "^3.0.3",
    "http-server": "^0.9.0",
    "uglify-js": "^2.6.4",
    "webpack": "^1.13.1",
    "webpack-dev-server": "^1.14.1"
  }
}
----

==== src/elm-package.json

[source,json]
----
{
    "version": "1.0.0",
    "summary": "A chat room with an emoji picker",
    "repository": "https://github.com/user/project.git",
    "license": "BSD3",
    "source-directories": [
        "elm"
    ],
    "exposed-modules": [],
    "dependencies": {
        "elm-lang/core": "5.0.0 <= v < 6.0.0",
        "elm-lang/html": "2.0.0 <= v < 3.0.0",
        "elm-lang/websocket": "1.0.2 <= v < 2.0.0"
    },
    "elm-version": "0.18.0 <= v < 0.19.0"
}
----

==== src/index.html

[source,html]
----
<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>React + Elm</title>
		<link href="node_modules/emojione-picker/css/picker.css" rel="stylesheet" />
		<link href="styles.css" rel="stylesheet" />
	</head>
	<body>
		<div id="chat"></div>
		<script src="build/bundle.js"></script>
	</body>
</html>
----

==== src/webpack.config.js

[source,js]
----
var webpack = require('webpack');
var path = require('path');

var BUILD_DIR = path.resolve(__dirname, 'build');
var APP_DIR = path.resolve(__dirname);

var config = {
  entry: APP_DIR + '/index.jsx',

  resolve: {
    modulesDirectories: ['node_modules'],
    extensions: ['', '.js', '.elm']
  },

  module : {
    loaders : [
      {
        test : /\.jsx?/,
        include : APP_DIR,
        exclude: [/elm-stuff/, /node_modules/],
        loader : 'babel'
      },
      {
        test: /\.html$/,
        loader: "html"
      },
      {
        test: /\.elm$/,
        exclude: [/elm-stuff/, /node_modules/],
        loader: 'elm-webpack'
      }
    ],

    noParse: /\.elm$/
  },
  output: {
    path: BUILD_DIR,
    filename: 'bundle.js'
  }
};

module.exports = config;
----

==== src/index.jsx

[source,jsx]
----
import React from 'react'
import ReactDOM from 'react-dom'
import EmojiPicker from 'emojione-picker'
import Elm from 'react-elm-components'
import { Chat } from './Chat'

const EmojiChatRoom = React.createClass({

  render: function() {
    const flags = 'wss://echo.websocket.org';

    let sendEmojiToChat = function() {};

    function setupPorts(ports) {
      sendEmojiToChat = ports.emoji.send;
    };

    function handleChange(emoji) {
      const str = String.fromCodePoint(parseInt("0x" + emoji.unicode));

      sendEmojiToChat(str);
    }

    return (
      <div className="emoji-chat">
        <EmojiPicker onChange={handleChange} />
        <Elm src={Chat} flags={flags} ports={setupPorts} />
      </div>
    );
  }
});

ReactDOM.render(
  <EmojiChatRoom />,
  document.getElementById('chat')
);
----

==== src/Chat.elm

[source,elm]
----
port module Chat exposing (main)

{-| If you are new to Elm, I highly recommend checking out
this guide:

    http://guide.elm-lang.org

It gives a pretty complete overview of how Elm works. For an
abbreviated read, focus on "The Elm Architecture" chapter.

    http://guide.elm-lang.org/architecture

It introduces key concepts gradually until you get to a chat
room very similar to the one here.
-}

import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import WebSocket as WS


main : Program String Model Msg
main =
    Html.programWithFlags
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }



-- MODEL


type alias Model =
    { server : String
    , input : String
    , messages : List String
    }


init : String -> ( Model, Cmd Msg )
init server =
    ( Model server "" [], Cmd.none )



-- UPDATE


type Msg
    = Input String
    | Send
    | NewEmoji String
    | NewMessage String


{-| Our update function reacts to a few different messages.

    1. Typing into the text field
    2. Clicking the "Send" button
    3. Emoji sent in from JavaScript
    4. Messages received from the chat server

The return value of this function is a pair. First is the
updated model. In many cases, we are just modifying the input
field. Second is some commands we want to run. We only use
this with `Send` when we want to send a message to the chat
server.

Again, check out <http://guide.elm-lang.org/architecture> to
learn more about how this works!
-}
update : Msg -> Model -> ( Model, Cmd Msg )
update msg ({ server, input, messages } as model) =
    case msg of
        Input newInput ->
            ( { model | input = newInput }
            , Cmd.none
            )

        Send ->
            ( { model | input = "" }
            , WS.send server input
            )

        NewEmoji emoji ->
            ( { model | input = input ++ emoji }
            , Cmd.none
            )

        NewMessage newMessage ->
            ( { model | messages = newMessage :: messages }
            , Cmd.none
            )



-- SUBSCRIPTIONS


{-| This port lets outsiders send in emoji characters as a string.
We can subscribe to these messages from within Elm.
-}
port emoji : (String -> msg) -> Sub msg


{-| We subscribe to two kinds of messages.

  1. We want messages from the websocket chat server.
  2. We want messages sent through emoji port from JavaScript.

-}
subscriptions : Model -> Sub Msg
subscriptions { server } =
    Sub.batch
        [ WS.listen server NewMessage
        , emoji NewEmoji
        ]



-- VIEW


view : Model -> Html Msg
view model =
    div [ class "chat-container" ]
        [ input [ class "chat-message-input", onInput Input, value model.input ] []
        , button [ onClick Send ] [ text "Send" ]
        , div [ class "chat-messages" ] (List.map viewMessage (List.reverse model.messages))
        ]


viewMessage : String -> Html msg
viewMessage msg =
    div [] [ text msg ]
----

=== example-elm0.19 - Time Example

==== src/package.json

[source,json]
----
{
  "private": true,
  "scripts": {
    "make": "./node_modules/.bin/webpack -d",
    "serve": "npm run make && ./node_modules/http-server/bin/http-server -o -c-1"
  },
  "dependencies": {
    "emojione-picker": "^0.3.6",
    "react": "~0.14.0",
    "react-dom": "~0.14.0",
    "react-elm-components": ".."
  },
  "devDependencies": {
    "babel-cli": "^6.10.1",
    "babel-core": "^6.10.4",
    "babel-loader": "^6.2.4",
    "babel-plugin-transform-react-jsx": "^6.8.0",
    "babel-plugin-uglify": "^1.0.2",
    "babel-preset-es2015": "^6.9.0",
    "babel-preset-react": "^6.11.1",
    "elm-webpack-loader": "^5.0.0",
    "http-server": "^0.9.0",
    "uglify-js": "^2.6.4",
    "webpack": "^1.13.1",
    "webpack-dev-server": "^1.14.1"
  }
}
----

==== src/webpack.config.js

[source,js]
----
var webpack = require('webpack');
var path = require('path');

var BUILD_DIR = path.resolve(__dirname, 'build');
var APP_DIR = path.resolve(__dirname);

var config = {
  entry: APP_DIR + '/index.jsx',

  resolve: {
    modulesDirectories: ['node_modules'],
    extensions: ['', '.js', '.elm']
  },

  module : {
    loaders : [
      {
        test : /\.jsx?/,
        include : APP_DIR,
        exclude: [/elm-stuff/, /node_modules/],
        loader : 'babel'
      },
      {
        test: /\.html$/,
        loader: "html"
      },
      {
        test: /\.elm$/,
        exclude: [/elm-stuff/, /node_modules/],
        loader: 'elm-webpack'
      }
    ],

    noParse: /\.elm$/
  },
  output: {
    path: BUILD_DIR,
    filename: 'bundle.js'
  }
};

module.exports = config;
----

==== src/elm.json

[source,json]
----
{
    "type": "application",
    "source-directories": [],
    "elm-version": "0.19.0",
    "dependencies": {
        "direct": {
            "elm/browser": "1.0.1",
            "elm/core": "1.0.0",
            "elm/html": "1.0.0",
            "elm/time": "1.0.0"
        },
        "indirect": {
            "elm/json": "1.0.0",
            "elm/url": "1.0.0",
            "elm/virtual-dom": "1.0.2"
        }
    },
    "test-dependencies": {
        "direct": {},
        "indirect": {}
    }
}
----

==== src/index.html

[source,html]
----
<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<title>React + Elm</title>
	<link href="styles.css" rel="stylesheet" />
</head>

<body>
	<div id="time"></div>
	<script src="build/bundle.js"></script>
</body>

</html>
----

==== src/index.jsx

[source,jsx]
----
import React from "react";
import ReactDOM from "react-dom";
import EmojiPicker from "emojione-picker";
import Elm from "react-elm-components";
import Time from "./Time";

class ReactTimeExample extends React.Component {
  render() {
    return (
      <div className="time-container">
        <h2>The current time is:</h2>
        <Elm src={Time.Elm.Main} />
      </div>
    );
  }
}

ReactDOM.render(<ReactTimeExample />, document.getElementById("time"));
----

==== src/Time.elm

[source,elm]
----
module Main exposing (Model, Msg(..), init, main, subscriptions, timeToString, update, view)

import Browser
import Html exposing (..)
import Task
import Time



-- MAIN


main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }



-- MODEL


type alias Model =
    { zone : Time.Zone
    , time : Time.Posix
    }


init : () -> ( Model, Cmd Msg )
init _ =
    ( Model Time.utc (Time.millisToPosix 0)
    , Task.perform AdjustTimeZone Time.here
    )



-- UPDATE


type Msg
    = Tick Time.Posix
    | AdjustTimeZone Time.Zone


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        Tick newTime ->
            ( { model | time = newTime }
            , Cmd.none
            )

        AdjustTimeZone newZone ->
            ( { model | zone = newZone }
            , Cmd.none
            )



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    Time.every 1000 Tick



-- VIEW


view : Model -> Html Msg
view model =
    let
        hour =
            timeToString (Time.toHour model.zone model.time)

        minute =
            timeToString (Time.toMinute model.zone model.time)

        second =
            timeToString (Time.toSecond model.zone model.time)
    in
    case Time.posixToMillis model.time of
        0 ->
            h1 [] []

        time ->
            h1 [] [ text (hour ++ ":" ++ minute ++ ":" ++ second) ]


timeToString : Int -> String
timeToString int =
    String.padLeft 2 '0' (String.fromInt int)
----